{"release.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport getpass\nimport glob\nimport io\nimport json\nimport os\nimport subprocess\nimport time\nimport zipfile\n\nimport click\n\nimport requests\n\n\ndef run(*args, **kwargs):\n    print(\"[running] {}\".format(list(args)))\n    subprocess.check_call(list(args), **kwargs)\n\n\ndef wait_for_build_complete_github_actions(session, token, run_url):\n    while True:\n        response = session.get(\n            run_url,\n            headers={\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"token {}\".format(token),\n            },\n        )\n        response.raise_for_status()\n        if response.json()[\"conclusion\"] is not None:\n            break\n        time.sleep(3)\n\n\ndef download_artifacts_github_actions(session, token, run_url):\n    response = session.get(\n        run_url,\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n\n    response = session.get(\n        response.json()[\"artifacts_url\"],\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n    paths = []\n    for artifact in response.json()[\"artifacts\"]:\n        response = session.get(\n            artifact[\"archive_download_url\"],\n            headers={\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"token {}\".format(token),\n            },\n        )\n        with zipfile.ZipFile(io.BytesIO(response.content)) as z:\n            for name in z.namelist():\n                if not name.endswith(\".whl\"):\n                    continue\n                p = z.open(name)\n                out_path = os.path.join(\n                    os.path.dirname(__file__),\n                    \"dist\",\n                    os.path.basename(name),\n                )\n                with open(out_path, \"wb\") as f:\n                    f.write(p.read())\n                paths.append(out_path)\n    return paths\n\n\ndef build_github_actions_wheels(token, version):\n    session = requests.Session()\n\n    response = session.post(\n        \"https://api.github.com/repos/pyca/pynacl/actions/workflows/\"\n        \"wheel-builder.yml/dispatches\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/vnd.github.v3+json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n        data=json.dumps({\"ref\": \"master\", \"inputs\": {\"version\": version}}),\n    )\n    response.raise_for_status()\n\n    # Give it a few seconds for the run to kick off.\n    time.sleep(5)\n    response = session.get(\n        (\n            \"https://api.github.com/repos/pyca/pynacl/actions/workflows/\"\n            \"wheel-builder.yml/runs?event=repository_dispatch\"\n        ),\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n    run_url = response.json()[\"workflow_runs\"][0][\"url\"]\n    wait_for_build_complete_github_actions(session, token, run_url)\n    return download_artifacts_github_actions(session, token, run_url)\n\n\n@click.command()\n@click.argument(\"version\")\ndef release(version):\n    \"\"\"\n    ``version`` should be a string like '0.4' or '1.0'.\n    \"\"\"\n    github_token = getpass.getpass(\"Github person access token: \")\n\n    run(\"git\", \"tag\", \"-s\", version, \"-m\", \"{} release\".format(version))\n    run(\"git\", \"push\", \"--tags\")\n\n    run(\"python\", \"setup.py\", \"sdist\")\n\n    sdist = glob.glob(\"dist/PyNaCl-{}*\".format(version))\n\n    github_actions_wheel_paths = build_github_actions_wheels(\n        github_token, version\n    )\n\n    run(\"twine\", \"upload\", *github_actions_wheel_paths)\n    run(\"twine\", \"upload\", \"-s\", *sdist)\n\n\nif __name__ == \"__main__\":\n    release()\n", "setup.py": "#!/usr/bin/env python\n# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport errno\nimport functools\nimport glob\nimport os\nimport os.path\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom sysconfig import get_config_vars\n\nfrom setuptools import Distribution, setup\nfrom setuptools.command.build_clib import build_clib as _build_clib\nfrom setuptools.command.build_ext import build_ext as _build_ext\n\n\nrequirements = []\nsetup_requirements = [\"setuptools\"]\ntest_requirements = [\n    \"pytest>=3.2.1,!=3.3.0\",\n    \"hypothesis>=3.27.0\",\n]\ndocs_requirements = [\"sphinx<7\", \"sphinx_rtd_theme\"]\n\n\nif platform.python_implementation() == \"PyPy\":\n    if sys.pypy_version_info < (2, 6):\n        raise RuntimeError(\n            \"PyNaCl is not compatible with PyPy < 2.6. Please \"\n            \"upgrade PyPy to use this library.\"\n        )\nelse:\n    requirements.append(\"cffi>=1.4.1\")\n    setup_requirements.append(\"cffi>=1.4.1\")\n\n\ndef here(*paths):\n    return os.path.relpath(os.path.join(*paths))\n\n\ndef abshere(*paths):\n    return os.path.abspath(here(*paths))\n\n\nsodium = functools.partial(here, \"src/libsodium/src/libsodium\")\n\n\nsys.path.insert(0, abshere(\"src\"))\n\n\nimport nacl  # noqa\n\n\ndef use_system():\n    install_type = os.environ.get(\"SODIUM_INSTALL\")\n\n    if install_type == \"system\":\n        # If we are forcing system installs, don't compile the bundled one\n        return True\n    else:\n        # By default we just use the bundled copy\n        return False\n\n\nclass Distribution(Distribution):\n    def has_c_libraries(self):\n        return not use_system()\n\n\nclass build_clib(_build_clib):\n    def get_source_files(self):\n        files = glob.glob(here(\"src/libsodium/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*/*/*\"))\n\n        return files\n\n    def build_libraries(self, libraries):\n        raise Exception(\"build_libraries\")\n\n    def check_library_list(self, libraries):\n        raise Exception(\"check_library_list\")\n\n    def get_library_names(self):\n        return [\"sodium\"]\n\n    def run(self):\n        if use_system():\n            return\n\n        # use Python's build environment variables\n        build_env = {\n            key: val\n            for key, val in get_config_vars().items()\n            if key in (\"LDFLAGS\", \"CFLAGS\", \"CC\", \"CCSHARED\", \"LDSHARED\")\n            and key not in os.environ\n        }\n        os.environ.update(build_env)\n\n        # Ensure our temporary build directory exists\n        build_temp = os.path.abspath(self.build_temp)\n        try:\n            os.makedirs(build_temp)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        # Ensure all of our executable files have their permission set\n        for filename in [\n            \"src/libsodium/autogen.sh\",\n            \"src/libsodium/configure\",\n        ]:\n            os.chmod(here(filename), 0o755)\n\n        if not shutil.which(\"make\"):\n            raise Exception(\"ERROR: The 'make' utility is missing from PATH\")\n\n        # Locate our configure script\n        configure = abshere(\"src/libsodium/configure\")\n\n        # Run ./configure\n        configure_flags = [\n            \"--disable-shared\",\n            \"--enable-static\",\n            \"--disable-debug\",\n            \"--disable-dependency-tracking\",\n            \"--with-pic\",\n        ]\n        if platform.system() == \"SunOS\":\n            # On Solaris, libssp doesn't link statically and causes linker\n            # errors during import\n            configure_flags.append(\"--disable-ssp\")\n        if os.environ.get(\"SODIUM_INSTALL_MINIMAL\"):\n            configure_flags.append(\"--enable-minimal\")\n        subprocess.check_call(\n            [configure]\n            + configure_flags\n            + [\"--prefix\", os.path.abspath(self.build_clib)],\n            cwd=build_temp,\n        )\n\n        make_args = os.environ.get(\"LIBSODIUM_MAKE_ARGS\", \"\").split()\n        # Build the library\n        subprocess.check_call([\"make\"] + make_args, cwd=build_temp)\n\n        # Check the build library\n        subprocess.check_call([\"make\", \"check\"] + make_args, cwd=build_temp)\n\n        # Install the built library\n        subprocess.check_call([\"make\", \"install\"] + make_args, cwd=build_temp)\n\n\nclass build_ext(_build_ext):\n    def run(self):\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command(\"build_clib\")\n            self.include_dirs.append(\n                os.path.join(build_clib.build_clib, \"include\"),\n            )\n            self.library_dirs.insert(\n                0,\n                os.path.join(build_clib.build_clib, \"lib64\"),\n            )\n            self.library_dirs.insert(\n                0,\n                os.path.join(build_clib.build_clib, \"lib\"),\n            )\n\n        return _build_ext.run(self)\n\n\nREADME = open(\"README.rst\").read()\nINSTALL = open(\"INSTALL.rst\").read()\nCHANGELOG = open(\"CHANGELOG.rst\").read()\n\n\nsetup(\n    name=nacl.__title__,\n    version=nacl.__version__,\n    description=nacl.__summary__,\n    long_description=\"\\n\".join((README, INSTALL, CHANGELOG)),\n    url=nacl.__uri__,\n    license=nacl.__license__,\n    author=nacl.__author__,\n    author_email=nacl.__email__,\n    python_requires=\">=3.6\",\n    setup_requires=setup_requirements,\n    install_requires=requirements,\n    extras_require={\"tests\": test_requirements, \"docs\": docs_requirements},\n    tests_require=test_requirements,\n    package_dir={\"\": \"src\"},\n    packages=[\"nacl\", \"nacl.pwhash\", \"nacl.bindings\"],\n    package_data={\"nacl\": [\"py.typed\"]},\n    ext_package=\"nacl\",\n    cffi_modules=[\"src/bindings/build.py:ffi\"],\n    cmdclass={\"build_clib\": build_clib, \"build_ext\": build_ext},\n    distclass=Distribution,\n    zip_safe=False,\n    classifiers=[\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n    ],\n)\n", "docs/conf.py": "#\n# This file is execfile()d with the current directory set to its containing dir\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\ntry:\n    import sphinx_rtd_theme\nexcept ImportError:\n    sphinx_rtd_theme = None\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\n\nimport nacl  # flake8: noqa\n\n# -- General configuration ----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = \"1.0\"\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions  coming with Sphinx (named \"sphinx.ext.*\") or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.viewcode\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = \"utf-8-sig\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"PyNaCl\"\ncopyright = \"2013, Donald Stufft and Individual Contributors\"\n\n# The version info for the project you\"re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \"\".join(nacl.__version__.split(\".\")[:2])\n# The full version, including alpha/beta/rc tags.\nrelease = nacl.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = \"\"\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = \"%B %d, %Y\"\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all documents\n# default_role = None\n\n# If true, \"()\" will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output --------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nif sphinx_rtd_theme:\n    html_theme = \"sphinx_rtd_theme\"\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\nelse:\n    html_theme = \"default\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# If not \"\", a \"Last updated on:\" timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = \"%b %d, %Y\"\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = \"\"\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"PyNaCldoc\"\n\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\n\n# Retry requests in the linkcheck builder so that we're resilient against\n# transient network errors.\nlinkcheck_retries = 10\n", "docs/vectors/python/argondriver.py": "#!/usr/bin/python\n#\n\nimport argparse\nimport json\nimport random\nimport string\nimport subprocess\nimport sys\n\n\nclass argonRunner:\n    GOODCHARS = string.ascii_letters + string.digits\n\n    def __init__(self, args):\n        self.exe = args.exe\n        self.mnsaltlen = args.mnsaltlen\n        self.mnpwlen = args.mnpwlen\n        self.mndgstlen = args.mndgstlen\n        self.mnmem = args.mnmem\n        self.mniters = args.mniters\n        self.mxsaltlen = args.mxsaltlen\n        self.mxpwlen = args.mxpwlen\n        self.mxdgstlen = args.mxdgstlen\n        self.mxmem = args.mxmem\n        self.mxiters = args.mxiters\n        self.encoded = args.encoded\n        self.rng = random.SystemRandom()\n        self.version = args.version\n        self.construct = args.construct\n        self.maxcount = args.n\n        self.count = 0\n\n    def _runOnce(self, passwd, salt, dgst_len, maxmem, iters):\n        argv = [\n            self.exe,\n            salt.encode(\"ascii\"),\n            \"-t\",\n            \"{:2d}\".format(iters),\n            \"-m\",\n            \"{:2d}\".format(maxmem),\n            \"-l\",\n            \"{:3d}\".format(dgst_len),\n            \"-v\",\n            self.version,\n        ]\n\n        if self.encoded:\n            argv.append(\"-e\")\n            mode = \"crypt\"\n        else:\n            argv.append(\"-r\")\n            mode = \"raw\"\n        if self.construct == \"argon2i\":\n            argv.append(\"-i\")\n        elif self.construct == \"argon2d\":\n            argv.append(\"-d\")\n        elif self.construct == \"argon2id\":\n            argv.append(\"-id\")\n        p = subprocess.Popen(\n            argv, stdin=subprocess.PIPE, stdout=subprocess.PIPE\n        )\n        out, err = p.communicate(passwd.encode(\"ascii\"))\n        return dict(\n            passwd=passwd,\n            salt=salt,\n            dgst_len=dgst_len,\n            maxmem=2**maxmem,\n            iters=iters,\n            mode=mode,\n            pwhash=out.decode(\"ascii\").rstrip(),\n            construct=self.construct,\n        )\n\n    def _genSalt(self):\n        sltln = self.rng.randint(self.mnsaltlen, self.mxsaltlen)\n        chrs = [self.rng.choice(self.GOODCHARS) for x in range(sltln)]\n        return \"\".join(chrs)\n\n    def _genPw(self):\n        pwln = self.rng.randint(self.mnpwlen, self.mxpwlen)\n        chrs = [self.rng.choice(self.GOODCHARS) for x in range(pwln)]\n        return \"\".join(chrs)\n\n    def __next__(self):\n        if self.count >= self.maxcount:\n            raise StopIteration\n        psw = self._genPw()\n        slt = self._genSalt()\n        mem = self.rng.randint(self.mnmem, self.mxmem)\n        iters = self.rng.randint(self.mniters, self.mxiters)\n        dgstln = self.rng.randint(self.mndgstlen, self.mxdgstlen)\n        rs = self._runOnce(psw, slt, dgstln, mem, iters)\n        self.count += 1\n        return rs\n\n    def __iter__(self):\n        return self\n\n    next = __next__\n\n\nif __name__ == \"__main__\":\n    p = argparse.ArgumentParser()\n    p.add_argument(\"-x\", \"--executable\", dest=\"exe\", required=True)\n    p.add_argument(\n        \"-c\", \"--construction\", dest=\"construct\", type=str, default=\"argon2i\"\n    )\n    p.add_argument(\"-v\", \"--version\", dest=\"version\", type=str, default=\"13\")\n    p.add_argument(\n        \"-e\",\n        \"--encoded\",\n        dest=\"encoded\",\n        default=False,\n        action=\"store_true\",\n    )\n    p.add_argument(\n        \"-s\", \"--min-salt-len\", dest=\"mnsaltlen\", type=int, default=8\n    )\n    p.add_argument(\n        \"-S\", \"--max-salt-len\", dest=\"mxsaltlen\", type=int, default=8\n    )\n    p.add_argument(\n        \"-p\", \"--min-password-len\", dest=\"mnpwlen\", type=int, default=16\n    )\n    p.add_argument(\n        \"-P\", \"--max-password-len\", dest=\"mxpwlen\", type=int, default=16\n    )\n    p.add_argument(\n        \"-l\", \"--min-digest-len\", dest=\"mndgstlen\", type=int, default=64\n    )\n    p.add_argument(\n        \"-L\", \"--max-digest-len\", dest=\"mxdgstlen\", type=int, default=64\n    )\n    p.add_argument(\n        \"-m\", \"--min-memory-exponent\", dest=\"mnmem\", type=int, default=16\n    )\n    p.add_argument(\n        \"-M\", \"--max-memory-exponent\", dest=\"mxmem\", type=int, default=16\n    )\n    p.add_argument(\n        \"-t\", \"--min-time-opscount\", dest=\"mniters\", type=int, default=3\n    )\n    p.add_argument(\n        \"-T\", \"--max-time-opscount\", dest=\"mxiters\", type=int, default=3\n    )\n    p.add_argument(\"-n\", \"--count\", dest=\"n\", type=int, default=10)\n    p.add_argument(\n        \"-w\",\n        \"--output\",\n        dest=\"outfile\",\n        default=sys.stdout,\n        type=argparse.FileType(\"w\"),\n    )\n\n    args = p.parse_args()\n\n    res = [x for x in argonRunner(args)]\n\n    json.dump(res, args.outfile, indent=2, separators=(\",\", \": \"))\n", "tests/test_bindings.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport hashlib\nfrom binascii import hexlify, unhexlify\nfrom typing import List, Tuple\n\nfrom hypothesis import given, settings\nfrom hypothesis.strategies import binary, integers\n\nimport pytest\n\nfrom nacl import bindings as c\nfrom nacl.exceptions import BadSignatureError, CryptoError, UnavailableError\nfrom nacl.utils import random\n\nfrom .test_signing import ed25519_known_answers\nfrom .utils import flip_byte, read_crypto_test_vectors\n\n\ndef tohex(b: bytes) -> str:\n    return hexlify(b).decode(\"ascii\")\n\n\ndef test_hash():\n    msg = b\"message\"\n    h1 = c.crypto_hash(msg)\n    assert len(h1) == c.crypto_hash_BYTES\n    assert tohex(h1) == (\n        \"f8daf57a3347cc4d6b9d575b31fe6077\"\n        \"e2cb487f60a96233c08cb479dbf31538\"\n        \"cc915ec6d48bdbaa96ddc1a16db4f4f9\"\n        \"6f37276cfcb3510b8246241770d5952c\"\n    )\n    assert tohex(h1) == hashlib.sha512(msg).hexdigest()\n\n    h2 = c.crypto_hash_sha512(msg)\n    assert len(h2) == c.crypto_hash_sha512_BYTES\n    assert tohex(h2) == tohex(h1)\n\n    h3 = c.crypto_hash_sha256(msg)\n    assert len(h3) == c.crypto_hash_sha256_BYTES\n    assert tohex(h3) == (\n        \"ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d\"\n    )\n    assert tohex(h3) == hashlib.sha256(msg).hexdigest()\n\n\ndef test_secretbox():\n    key = b\"\\x00\" * c.crypto_secretbox_KEYBYTES\n    msg = b\"message\"\n    nonce = b\"\\x01\" * c.crypto_secretbox_NONCEBYTES\n    ct = c.crypto_secretbox(msg, nonce, key)\n    assert len(ct) == len(msg) + c.crypto_secretbox_BOXZEROBYTES\n    assert tohex(ct) == \"3ae84dfb89728737bd6e2c8cacbaf8af3d34cc1666533a\"\n    msg2 = c.crypto_secretbox_open(ct, nonce, key)\n    assert msg2 == msg\n\n    with pytest.raises(CryptoError):\n        c.crypto_secretbox_open(\n            msg + b\"!\",\n            nonce,\n            key,\n        )\n\n\ndef test_secretbox_wrong_length():\n    with pytest.raises(ValueError):\n        c.crypto_secretbox(b\"\", b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_secretbox(b\"\", b\"\", b\"\\x00\" * c.crypto_secretbox_KEYBYTES)\n    with pytest.raises(ValueError):\n        c.crypto_secretbox_open(b\"\", b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_secretbox_open(\n            b\"\", b\"\", b\"\\x00\" * c.crypto_secretbox_KEYBYTES\n        )\n\n\ndef test_box():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    assert len(A_secretkey) == c.crypto_box_SECRETKEYBYTES\n    assert len(A_pubkey) == c.crypto_box_PUBLICKEYBYTES\n    B_pubkey, B_secretkey = c.crypto_box_keypair()\n\n    k1 = c.crypto_box_beforenm(B_pubkey, A_secretkey)\n    assert len(k1) == c.crypto_box_BEFORENMBYTES\n    k2 = c.crypto_box_beforenm(A_pubkey, B_secretkey)\n    assert tohex(k1) == tohex(k2)\n\n    message = b\"message\"\n    nonce = b\"\\x01\" * c.crypto_box_NONCEBYTES\n    ct1 = c.crypto_box_afternm(message, nonce, k1)\n    assert len(ct1) == len(message) + c.crypto_box_BOXZEROBYTES\n\n    ct2 = c.crypto_box(message, nonce, B_pubkey, A_secretkey)\n    assert tohex(ct2) == tohex(ct1)\n\n    m1 = c.crypto_box_open(ct1, nonce, A_pubkey, B_secretkey)\n    assert m1 == message\n\n    m2 = c.crypto_box_open_afternm(ct1, nonce, k1)\n    assert m2 == message\n\n    with pytest.raises(CryptoError):\n        c.crypto_box_open(message + b\"!\", nonce, A_pubkey, A_secretkey)\n\n\ndef test_box_wrong_lengths():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    with pytest.raises(ValueError):\n        c.crypto_box(b\"abc\", b\"\\x00\", A_pubkey, A_secretkey)\n    with pytest.raises(ValueError):\n        c.crypto_box(\n            b\"abc\", b\"\\x00\" * c.crypto_box_NONCEBYTES, b\"\", A_secretkey\n        )\n    with pytest.raises(ValueError):\n        c.crypto_box(b\"abc\", b\"\\x00\" * c.crypto_box_NONCEBYTES, A_pubkey, b\"\")\n\n    with pytest.raises(ValueError):\n        c.crypto_box_open(b\"\", b\"\", b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_box_open(b\"\", b\"\\x00\" * c.crypto_box_NONCEBYTES, b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_box_open(\n            b\"\", b\"\\x00\" * c.crypto_box_NONCEBYTES, A_pubkey, b\"\"\n        )\n\n    with pytest.raises(ValueError):\n        c.crypto_box_beforenm(b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_box_beforenm(A_pubkey, b\"\")\n\n    with pytest.raises(ValueError):\n        c.crypto_box_afternm(b\"\", b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_box_afternm(b\"\", b\"\\x00\" * c.crypto_box_NONCEBYTES, b\"\")\n\n    with pytest.raises(ValueError):\n        c.crypto_box_open_afternm(b\"\", b\"\", b\"\")\n    with pytest.raises(ValueError):\n        c.crypto_box_open_afternm(b\"\", b\"\\x00\" * c.crypto_box_NONCEBYTES, b\"\")\n\n\ndef test_sign():\n    seed = b\"\\x00\" * c.crypto_sign_SEEDBYTES\n    pubkey, secretkey = c.crypto_sign_seed_keypair(seed)\n    assert len(pubkey) == c.crypto_sign_PUBLICKEYBYTES\n    assert len(secretkey) == c.crypto_sign_SECRETKEYBYTES\n\n    pubkey, secretkey = c.crypto_sign_keypair()\n    assert len(pubkey) == c.crypto_sign_PUBLICKEYBYTES\n    assert len(secretkey) == c.crypto_sign_SECRETKEYBYTES\n\n    msg = b\"message\"\n    sigmsg = c.crypto_sign(msg, secretkey)\n    assert len(sigmsg) == len(msg) + c.crypto_sign_BYTES\n\n    msg2 = c.crypto_sign_open(sigmsg, pubkey)\n    assert msg2 == msg\n\n\ndef test_sign_wrong_lengths():\n    with pytest.raises(ValueError):\n        c.crypto_sign_seed_keypair(b\"\")\n\n\ndef secret_scalar() -> Tuple[bytes, bytes]:\n    pubkey, secretkey = c.crypto_box_keypair()\n    assert len(secretkey) == c.crypto_box_SECRETKEYBYTES\n    assert c.crypto_box_SECRETKEYBYTES == c.crypto_scalarmult_BYTES\n    return secretkey, pubkey\n\n\ndef test_scalarmult():\n    x, xpub = secret_scalar()\n    assert len(x) == 32\n    y, ypub = secret_scalar()\n    # the Curve25519 base point (generator)\n    base = unhexlify(b\"09\" + b\"00\" * 31)\n\n    bx1 = c.crypto_scalarmult_base(x)\n    bx2 = c.crypto_scalarmult(x, base)\n    assert tohex(bx1) == tohex(bx2)\n    assert tohex(bx1) == tohex(xpub)\n\n    xby = c.crypto_scalarmult(x, c.crypto_scalarmult_base(y))\n    ybx = c.crypto_scalarmult(y, c.crypto_scalarmult_base(x))\n    assert tohex(xby) == tohex(ybx)\n\n    z = unhexlify(b\"10\" * 32)\n    bz1 = c.crypto_scalarmult_base(z)\n    assert tohex(bz1) == (\n        \"781faab908430150daccdd6f9d6c5086e34f73a93ebbaa271765e5036edfc519\"\n    )\n    bz2 = c.crypto_scalarmult(z, base)\n    assert tohex(bz1) == tohex(bz2)\n\n\ndef test_sign_test_key_conversion():\n    \"\"\"\n    Taken from test vectors in libsodium\n    \"\"\"\n    keypair_seed = unhexlify(\n        b\"421151a459faeade3d247115f94aedae42318124095afabe4d1451a559faedee\"\n    )\n    ed25519_pk, ed25519_sk = c.crypto_sign_seed_keypair(keypair_seed)\n\n    assert c.crypto_sign_ed25519_sk_to_pk(ed25519_sk) == ed25519_pk\n    with pytest.raises(ValueError):\n        c.crypto_sign_ed25519_sk_to_pk(unhexlify(b\"12\"))\n\n    assert c.crypto_sign_ed25519_sk_to_seed(ed25519_sk) == keypair_seed\n    with pytest.raises(ValueError):\n        c.crypto_sign_ed25519_sk_to_seed(unhexlify(b\"12\"))\n\n    curve25519_pk = c.crypto_sign_ed25519_pk_to_curve25519(ed25519_pk)\n\n    with pytest.raises(ValueError):\n        c.crypto_sign_ed25519_pk_to_curve25519(unhexlify(b\"12\"))\n    with pytest.raises(ValueError):\n        c.crypto_sign_ed25519_sk_to_curve25519(unhexlify(b\"12\"))\n\n    curve25519_sk = c.crypto_sign_ed25519_sk_to_curve25519(ed25519_sk)\n\n    assert tohex(curve25519_pk) == (\n        \"f1814f0e8ff1043d8a44d25babff3cedcae6c22c3edaa48f857ae70de2baae50\"\n    )\n    assert tohex(curve25519_sk) == (\n        \"8052030376d47112be7f73ed7a019293dd12ad910b654455798b4667d73de166\"\n    )\n\n\ndef test_box_seal_empty():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    empty = b\"\"\n    msg = c.crypto_box_seal(empty, A_pubkey)\n    decoded = c.crypto_box_seal_open(msg, A_pubkey, A_secretkey)\n    assert decoded == empty\n\n\ndef test_box_seal_empty_is_verified():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    empty = b\"\"\n    amsg = bytearray(c.crypto_box_seal(empty, A_pubkey))\n    amsg[-1] ^= 1\n    msg = bytes(amsg)\n    with pytest.raises(CryptoError):\n        c.crypto_box_seal_open(msg, A_pubkey, A_secretkey)\n\n\ndef test_box_seal_wrong_lengths():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    with pytest.raises(ValueError):\n        c.crypto_box_seal(b\"abc\", A_pubkey[:-1])\n    with pytest.raises(ValueError):\n        c.crypto_box_seal_open(b\"abc\", b\"\", A_secretkey)\n    with pytest.raises(ValueError):\n        c.crypto_box_seal_open(b\"abc\", A_pubkey, A_secretkey[:-1])\n    msg = c.crypto_box_seal(b\"\", A_pubkey)\n    with pytest.raises(CryptoError):\n        c.crypto_box_seal_open(msg[:-1], A_pubkey, A_secretkey)\n\n\ndef test_box_seal_wrong_types():\n    A_pubkey, A_secretkey = c.crypto_box_keypair()\n    # type safety: mypy can spot these errors, but we want to spot them at runtime too.\n    with pytest.raises(TypeError):\n        c.crypto_box_seal(b\"abc\", dict())  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        c.crypto_box_seal_open(b\"abc\", None, A_secretkey)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        c.crypto_box_seal_open(b\"abc\", A_pubkey, None)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        c.crypto_box_seal_open(None, A_pubkey, A_secretkey)  # type: ignore[arg-type]\n\n\ndef _box_from_seed_vectors() -> List[Tuple[bytes, bytes, bytes]]:\n    # Fmt: <seed> <tab> <public_key> || <secret_key>\n    DATA = \"box_from_seed.txt\"\n    lines = read_crypto_test_vectors(DATA, maxels=2, delimiter=b\"\\t\")\n    return [\n        (\n            x[0],  # seed\n            x[1][:64],  # derived public key\n            x[1][64:],  # derived secret key\n        )\n        for x in lines\n    ]\n\n\n@pytest.mark.parametrize(\n    (\"seed\", \"public_key\", \"secret_key\"), _box_from_seed_vectors()\n)\ndef test_box_seed_keypair_reference(\n    seed: bytes, public_key: bytes, secret_key: bytes\n):\n    seed = unhexlify(seed)\n    pk, sk = c.crypto_box_seed_keypair(seed)\n    assert pk == unhexlify(public_key)\n    assert sk == unhexlify(secret_key)\n\n\ndef test_box_seed_keypair_random():\n    seed = c.randombytes(c.crypto_box_SEEDBYTES)\n    pk, sk = c.crypto_box_seed_keypair(seed)\n    ppk = c.crypto_scalarmult_base(sk)\n    assert pk == ppk\n\n\ndef test_box_seed_keypair_short_seed():\n    seed = c.randombytes(c.crypto_box_SEEDBYTES - 1)\n    with pytest.raises(ValueError):\n        c.crypto_box_seed_keypair(seed)\n    with pytest.raises(CryptoError):\n        c.crypto_box_seed_keypair(seed)\n\n\n@given(integers(min_value=-2, max_value=0))\ndef test_pad_wrong_blocksize(bl_sz):\n    with pytest.raises(ValueError):\n        c.sodium_pad(b\"x\", bl_sz)\n\n\ndef test_unpad_not_padded():\n    with pytest.raises(CryptoError):\n        c.sodium_unpad(b\"x\", 8)\n\n\n@given(\n    binary(min_size=0, max_size=2049), integers(min_value=16, max_value=256)\n)\n@settings(max_examples=20)\ndef test_pad_sizes(msg: bytes, bl_sz: int):\n    padded = c.sodium_pad(msg, bl_sz)\n    assert len(padded) > len(msg)\n    assert len(padded) >= bl_sz\n    assert len(padded) % bl_sz == 0\n\n\n@given(\n    binary(min_size=0, max_size=2049), integers(min_value=16, max_value=256)\n)\n@settings(max_examples=20)\ndef test_pad_roundtrip(msg: bytes, bl_sz: int):\n    padded = c.sodium_pad(msg, bl_sz)\n    assert len(padded) > len(msg)\n    assert len(padded) >= bl_sz\n    assert len(padded) % bl_sz == 0\n    unpadded = c.sodium_unpad(padded, bl_sz)\n    assert len(unpadded) == len(msg)\n    assert unpadded == msg\n\n\ndef test_sodium_increment():\n    maxint = 32 * b\"\\xff\"\n    zero = 32 * b\"\\x00\"\n    one = b\"\\x01\" + 31 * b\"\\x00\"\n    two = b\"\\x02\" + 31 * b\"\\x00\"\n\n    res = c.sodium_increment(maxint)\n    assert res == zero\n\n    res = c.sodium_increment(res)\n    assert res == one\n\n    res = c.sodium_increment(res)\n    assert res == two\n\n\ndef test_sodium_add():\n    maxint = 32 * b\"\\xff\"\n    zero = 32 * b\"\\x00\"\n    one = b\"\\x01\" + 31 * b\"\\x00\"\n    short_one = b\"\\x01\" + 15 * b\"\\x00\"\n    two = b\"\\x02\" + 31 * b\"\\x00\"\n    three = b\"\\x03\" + 31 * b\"\\x00\"\n    four = b\"\\x04\" + 31 * b\"\\x00\"\n\n    res = c.sodium_add(one, two)\n    assert res == three\n\n    res = c.sodium_add(maxint, four)\n    assert res == three\n\n    res = c.sodium_add(one, maxint)\n    assert res == zero\n\n    with pytest.raises(TypeError):\n        res = c.sodium_add(short_one, two)\n\n\ndef test_sign_ed25519ph_rfc8032():\n    # sk, pk, msg, exp_sig\n    # taken from RFC 8032 section 7.3.  Test Vectors for Ed25519ph\n    sk = unhexlify(\n        b\"833fe62409237b9d62ec77587520911e9a759cec1d19755b7da901b96dca3d42\"\n    )\n    pk = unhexlify(\n        b\"ec172b93ad5e563bf4932c70e1245034c35467ef2efd4d64ebf819683467e2bf\"\n    )\n    msg = b\"abc\"\n    exp_sig = unhexlify(\n        b\"98a70222f0b8121aa9d30f813d683f80\"\n        b\"9e462b469c7ff87639499bb94e6dae41\"\n        b\"31f85042463c2a355a2003d062adf5aa\"\n        b\"a10b8c61e636062aaad11c2a26083406\"\n    )\n    c_sk = sk + pk\n\n    edph = c.crypto_sign_ed25519ph_state()\n    c.crypto_sign_ed25519ph_update(edph, msg)\n    sig = c.crypto_sign_ed25519ph_final_create(edph, c_sk)\n\n    assert sig == exp_sig\n\n    edph_v = c.crypto_sign_ed25519ph_state()\n    c.crypto_sign_ed25519ph_update(edph_v, msg)\n\n    assert c.crypto_sign_ed25519ph_final_verify(edph_v, exp_sig, pk) is True\n\n    c.crypto_sign_ed25519ph_update(edph_v, msg)\n\n    with pytest.raises(BadSignatureError):\n        c.crypto_sign_ed25519ph_final_verify(edph_v, exp_sig, pk)\n\n\ndef test_sign_ed25519ph_libsodium():\n    #\n    _hsk, _hpk, hmsg, _hsig, _hsigmsg = ed25519_known_answers()[-1]\n\n    msg = unhexlify(hmsg)\n\n    seed = unhexlify(\n        b\"421151a459faeade3d247115f94aedae42318124095afabe4d1451a559faedee\"\n    )\n\n    pk, sk = c.crypto_sign_seed_keypair(seed)\n\n    exp_sig = unhexlify(\n        b\"10c5411e40bd10170fb890d4dfdb6d33\"\n        b\"8c8cb11d2764a216ee54df10977dcdef\"\n        b\"d8ff755b1eeb3f16fce80e40e7aafc99\"\n        b\"083dbff43d5031baf04157b48423960d\"\n    )\n\n    edph = c.crypto_sign_ed25519ph_state()\n    c.crypto_sign_ed25519ph_update(edph, msg)\n    sig = c.crypto_sign_ed25519ph_final_create(edph, sk)\n\n    assert sig == exp_sig\n\n    edph_incr = c.crypto_sign_ed25519ph_state()\n    c.crypto_sign_ed25519ph_update(edph_incr, b\"\")\n    c.crypto_sign_ed25519ph_update(edph_incr, msg[0 : len(msg) // 2])\n    c.crypto_sign_ed25519ph_update(edph_incr, msg[len(msg) // 2 :])\n\n    assert c.crypto_sign_ed25519ph_final_verify(edph_incr, exp_sig, pk) is True\n\n    with pytest.raises(BadSignatureError):\n        wrng_sig = flip_byte(exp_sig, 0)\n        c.crypto_sign_ed25519ph_final_verify(edph_incr, wrng_sig, pk)\n\n    with pytest.raises(BadSignatureError):\n        wrng_mesg = flip_byte(msg, 1022)\n        edph_wrng = c.crypto_sign_ed25519ph_state()\n        c.crypto_sign_ed25519ph_update(edph_wrng, wrng_mesg)\n        c.crypto_sign_ed25519ph_final_verify(edph_wrng, exp_sig, pk)\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_is_valid_point():\n    \"\"\"\n    Verify crypto_core_ed25519_is_valid_point correctly rejects\n    the all-zeros \"point\"\n    \"\"\"\n    zero = c.crypto_core_ed25519_BYTES * b\"\\x00\"\n    res = c.crypto_core_ed25519_is_valid_point(zero)\n    assert res is False\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_from_uniform():\n    \"\"\"\n    Verify crypto_core_ed25519_from_uniform maps 32 byte inputs\n    to valid points\"\n    \"\"\"\n    res = True\n    for i in range(500):\n        r = random()\n        p = c.crypto_core_ed25519_from_uniform(r)\n        res = res and c.crypto_core_ed25519_is_valid_point(p)\n    assert res is True\n\n    # Test data sourced from this libsodium discussion:\n    # https://github.com/jedisct1/libsodium/discussions/1086\n    random_data_input = unhexlify(\n        b\"7f3e7fb9428103ad7f52db32f9df32505d7b427d894c5093f7a0f0374a30641d\"\n    )\n    expected_output = unhexlify(\n        b\"44b2fa2a6bb0b2adeace690a5a83b7fbe5bb487c34e64dc109b90bc4e00f670b\"\n    )\n\n    random_data_to_curve = c.crypto_core_ed25519_from_uniform(\n        random_data_input\n    )\n\n    assert c.crypto_core_ed25519_is_valid_point(random_data_input) is False\n    assert c.crypto_core_ed25519_is_valid_point(random_data_to_curve) is True\n    assert random_data_to_curve == expected_output\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_add_and_sub():\n    # the public component of a ed25519 keypair\n    # is a point on the ed25519 curve\n    p1, _s1 = c.crypto_sign_keypair()\n    p2, _s2 = c.crypto_sign_keypair()\n\n    p3 = c.crypto_core_ed25519_add(p1, p2)\n\n    assert c.crypto_core_ed25519_is_valid_point(p3) is True\n    assert c.crypto_core_ed25519_sub(p3, p1) == p2\n    assert c.crypto_core_ed25519_sub(p3, p2) == p1\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519 or not c.has_crypto_scalarmult_ed25519,\n    reason=\"Requires full build of libsodium\",\n)\ndef test_scalarmult_ed25519():\n    SCALARBYTES = c.crypto_scalarmult_ed25519_SCALARBYTES\n\n    # the minimum ed25519 scalar is represented by a 8 value in the\n    # first octet, a 64 value in the last octet, and all zeros\n    # in between:\n    MINSC = bytes(bytearray([8] + (SCALARBYTES - 2) * [0] + [64]))\n\n    # the scalar multiplication formula for ed25519\n    # \"clamps\" the scalar by setting the most significant bit\n    # of the last octet to zero, therefore scalar multiplication\n    # by CLMPD is equivalent to scalar multiplication by MINSC\n    CLMPD = bytes(bytearray([8] + (SCALARBYTES - 2) * [0] + [192]))\n\n    MIN_P1 = bytes(bytearray([9] + (SCALARBYTES - 2) * [0] + [64]))\n    MIN_P7 = bytes(bytearray([15] + (SCALARBYTES - 2) * [0] + [64]))\n    MIN_P8 = bytes(bytearray([16] + (SCALARBYTES - 2) * [0] + [64]))\n\n    p, _s = c.crypto_sign_keypair()\n    _p = p\n\n    for i in range(254):\n        # double _p\n        _p = c.crypto_core_ed25519_add(_p, _p)\n\n    for i in range(8):\n        _p = c.crypto_core_ed25519_add(_p, p)\n\n    # at this point _p is (2^254+8) times p\n\n    assert c.crypto_scalarmult_ed25519(MINSC, p) == _p\n    assert c.crypto_scalarmult_ed25519(CLMPD, p) == _p\n\n    # ed25519 scalar multiplication sets the least three significant\n    # bits of the first octet to zero; therefore:\n    assert c.crypto_scalarmult_ed25519(MIN_P1, p) == _p\n    assert c.crypto_scalarmult_ed25519(MIN_P7, p) == _p\n\n    _p8 = _p\n    for i in range(8):\n        _p8 = c.crypto_core_ed25519_add(_p8, p)\n\n    # at this point _p is (2^254 + 16) times p\n\n    assert c.crypto_scalarmult_ed25519(MIN_P8, p) == _p8\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_scalarmult_ed25519,\n    reason=\"Requires full build of libsodium\",\n)\ndef test_scalarmult_ed25519_base():\n    \"\"\"\n    Verify scalarmult_ed25519_base is congruent to\n    scalarmult_ed25519 on the ed25519 base point\n    \"\"\"\n\n    BASEPOINT = bytes(\n        bytearray(\n            [\n                0x58,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n            ]\n        )\n    )\n\n    sclr = c.randombytes(c.crypto_scalarmult_ed25519_SCALARBYTES)\n\n    p = c.crypto_scalarmult_ed25519_base(sclr)\n    p2 = c.crypto_scalarmult_ed25519(sclr, BASEPOINT)\n\n    assert p2 == p\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_scalarmult_ed25519,\n    reason=\"Requires full build of libsodium\",\n)\ndef test_scalarmult_ed25519_noclamp():\n    # An arbitrary scalar which is known to differ once clamped\n    scalar = 32 * b\"\\x01\"\n    BASEPOINT = bytes(\n        bytearray(\n            [\n                0x58,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n                0x66,\n            ]\n        )\n    )\n\n    p = c.crypto_scalarmult_ed25519_noclamp(scalar, BASEPOINT)\n    pb = c.crypto_scalarmult_ed25519_base_noclamp(scalar)\n    pc = c.crypto_scalarmult_ed25519_base(scalar)\n    assert p == pb\n    assert pb != pc\n\n    # clamp manually\n    ba = bytearray(scalar)\n    ba0 = bytes(bytearray([ba[0] & 248]))\n    ba31 = bytes(bytearray([(ba[31] & 127) | 64]))\n    scalar_clamped = ba0 + bytes(ba[1:31]) + ba31\n\n    p1 = c.crypto_scalarmult_ed25519_noclamp(scalar_clamped, BASEPOINT)\n    p2 = c.crypto_scalarmult_ed25519(scalar, BASEPOINT)\n    assert p1 == p2\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_scalar_add_and_sub():\n    zero = 32 * b\"\\x00\"\n    one = b\"\\x01\" + 31 * b\"\\x00\"\n    two = b\"\\x02\" + 31 * b\"\\x00\"\n    # the max integer over l, the order of the main subgroup\n    # 2^252+27742317777372353535851937790883648493 - 1\n    max = bytes(\n        bytearray(\n            [\n                0xEC,\n                0xD3,\n                0xF5,\n                0x5C,\n                0x1A,\n                0x63,\n                0x12,\n                0x58,\n                0xD6,\n                0x9C,\n                0xF7,\n                0xA2,\n                0xDE,\n                0xF9,\n                0xDE,\n                0x14,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x10,\n            ]\n        )\n    )\n\n    p1 = c.crypto_core_ed25519_scalar_add(two, max)\n    assert p1 == one\n\n    p2 = c.crypto_core_ed25519_scalar_sub(p1, p1)\n    assert p2 == zero\n\n    p3 = c.crypto_core_ed25519_scalar_sub(p2, one)\n    assert p3 == max\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_scalar_mul():\n    zero = 32 * b\"\\x00\"\n    three = b\"\\x03\" + 31 * b\"\\x00\"\n\n    # random scalar modulo l\n    sclr = c.randombytes(c.crypto_core_ed25519_SCALARBYTES)\n    p = c.crypto_core_ed25519_scalar_add(sclr, zero)\n\n    p3 = c.crypto_core_ed25519_scalar_mul(p, three)\n    p2 = c.crypto_core_ed25519_scalar_add(p, p)\n    p1 = c.crypto_core_ed25519_scalar_sub(p3, p2)\n\n    assert p1 == p\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_scalar_invert_negate_complement():\n    zero = 32 * b\"\\x00\"\n    one = b\"\\x01\" + 31 * b\"\\x00\"\n\n    # random scalar modulo l\n    sclr = c.randombytes(c.crypto_core_ed25519_SCALARBYTES)\n    sclr = c.crypto_core_ed25519_scalar_add(sclr, zero)\n\n    i = c.crypto_core_ed25519_scalar_invert(sclr)\n    assert c.crypto_core_ed25519_scalar_mul(sclr, i) == one\n\n    n = c.crypto_core_ed25519_scalar_negate(sclr)\n    assert c.crypto_core_ed25519_scalar_add(sclr, n) == zero\n\n    cp = c.crypto_core_ed25519_scalar_complement(sclr)\n    assert c.crypto_core_ed25519_scalar_add(sclr, cp) == one\n\n\n@pytest.mark.skipif(\n    not c.has_crypto_core_ed25519, reason=\"Requires full build of libsodium\"\n)\ndef test_ed25519_scalar_reduce():\n    zero = 32 * b\"\\x00\"\n    # 65536 times the order of the main subgroup (which is bigger\n    # than 32 bytes), padded to 64 bytes\n    # 2^252+27742317777372353535851937790883648493\n    l65536 = (\n        bytes(2 * b\"\\x00\")\n        + bytes(\n            bytearray(\n                [\n                    0xED,\n                    0xD3,\n                    0xF5,\n                    0x5C,\n                    0x1A,\n                    0x63,\n                    0x12,\n                    0x58,\n                    0xD6,\n                    0x9C,\n                    0xF7,\n                    0xA2,\n                    0xDE,\n                    0xF9,\n                    0xDE,\n                    0x14,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x10,\n                ]\n            )\n        )\n        + bytes(30 * b\"\\x00\")\n    )\n\n    # random scalar modulo l\n    sclr = c.randombytes(c.crypto_core_ed25519_SCALARBYTES)\n    p = c.crypto_core_ed25519_scalar_add(sclr, zero)\n\n    # l65536 + p is bigger than 32 bytes\n    big = c.sodium_add(l65536, p + bytes(32 * b\"\\x00\"))\n\n    r = c.crypto_core_ed25519_scalar_reduce(big)\n    assert r == p\n\n\n@pytest.mark.skipif(\n    c.has_crypto_core_ed25519, reason=\"Requires minimal build of libsodium\"\n)\ndef test_ed25519_unavailable():\n    zero = 32 * b\"\\x00\"\n\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_is_valid_point(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_add(zero, zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_sub(zero, zero)\n\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_invert(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_negate(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_complement(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_add(zero, zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_sub(zero, zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_mul(zero, zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_core_ed25519_scalar_reduce(zero)\n\n\n@pytest.mark.skipif(\n    c.has_crypto_scalarmult_ed25519,\n    reason=\"Requires minimal build of libsodium\",\n)\ndef test_scalarmult_ed25519_unavailable():\n    zero = 32 * b\"\\x00\"\n\n    with pytest.raises(UnavailableError):\n        c.crypto_scalarmult_ed25519_base(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_scalarmult_ed25519_base_noclamp(zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_scalarmult_ed25519(zero, zero)\n    with pytest.raises(UnavailableError):\n        c.crypto_scalarmult_ed25519_noclamp(zero, zero)\n", "tests/test_shorthash.py": "# Copyright 2016 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom binascii import hexlify\nfrom typing import List, Tuple\n\nimport pytest\n\nfrom nacl.exceptions import UnavailableError\nfrom nacl.hash import SIPHASHX_AVAILABLE, siphash24, siphashx24\n\nHASHES = [\n    b\"\\x31\\x0e\\x0e\\xdd\\x47\\xdb\\x6f\\x72\",\n    b\"\\xfd\\x67\\xdc\\x93\\xc5\\x39\\xf8\\x74\",\n    b\"\\x5a\\x4f\\xa9\\xd9\\x09\\x80\\x6c\\x0d\",\n    b\"\\x2d\\x7e\\xfb\\xd7\\x96\\x66\\x67\\x85\",\n    b\"\\xb7\\x87\\x71\\x27\\xe0\\x94\\x27\\xcf\",\n    b\"\\x8d\\xa6\\x99\\xcd\\x64\\x55\\x76\\x18\",\n    b\"\\xce\\xe3\\xfe\\x58\\x6e\\x46\\xc9\\xcb\",\n    b\"\\x37\\xd1\\x01\\x8b\\xf5\\x00\\x02\\xab\",\n    b\"\\x62\\x24\\x93\\x9a\\x79\\xf5\\xf5\\x93\",\n    b\"\\xb0\\xe4\\xa9\\x0b\\xdf\\x82\\x00\\x9e\",\n    b\"\\xf3\\xb9\\xdd\\x94\\xc5\\xbb\\x5d\\x7a\",\n    b\"\\xa7\\xad\\x6b\\x22\\x46\\x2f\\xb3\\xf4\",\n    b\"\\xfb\\xe5\\x0e\\x86\\xbc\\x8f\\x1e\\x75\",\n    b\"\\x90\\x3d\\x84\\xc0\\x27\\x56\\xea\\x14\",\n    b\"\\xee\\xf2\\x7a\\x8e\\x90\\xca\\x23\\xf7\",\n    b\"\\xe5\\x45\\xbe\\x49\\x61\\xca\\x29\\xa1\",\n    b\"\\xdb\\x9b\\xc2\\x57\\x7f\\xcc\\x2a\\x3f\",\n    b\"\\x94\\x47\\xbe\\x2c\\xf5\\xe9\\x9a\\x69\",\n    b\"\\x9c\\xd3\\x8d\\x96\\xf0\\xb3\\xc1\\x4b\",\n    b\"\\xbd\\x61\\x79\\xa7\\x1d\\xc9\\x6d\\xbb\",\n    b\"\\x98\\xee\\xa2\\x1a\\xf2\\x5c\\xd6\\xbe\",\n    b\"\\xc7\\x67\\x3b\\x2e\\xb0\\xcb\\xf2\\xd0\",\n    b\"\\x88\\x3e\\xa3\\xe3\\x95\\x67\\x53\\x93\",\n    b\"\\xc8\\xce\\x5c\\xcd\\x8c\\x03\\x0c\\xa8\",\n    b\"\\x94\\xaf\\x49\\xf6\\xc6\\x50\\xad\\xb8\",\n    b\"\\xea\\xb8\\x85\\x8a\\xde\\x92\\xe1\\xbc\",\n    b\"\\xf3\\x15\\xbb\\x5b\\xb8\\x35\\xd8\\x17\",\n    b\"\\xad\\xcf\\x6b\\x07\\x63\\x61\\x2e\\x2f\",\n    b\"\\xa5\\xc9\\x1d\\xa7\\xac\\xaa\\x4d\\xde\",\n    b\"\\x71\\x65\\x95\\x87\\x66\\x50\\xa2\\xa6\",\n    b\"\\x28\\xef\\x49\\x5c\\x53\\xa3\\x87\\xad\",\n    b\"\\x42\\xc3\\x41\\xd8\\xfa\\x92\\xd8\\x32\",\n    b\"\\xce\\x7c\\xf2\\x72\\x2f\\x51\\x27\\x71\",\n    b\"\\xe3\\x78\\x59\\xf9\\x46\\x23\\xf3\\xa7\",\n    b\"\\x38\\x12\\x05\\xbb\\x1a\\xb0\\xe0\\x12\",\n    b\"\\xae\\x97\\xa1\\x0f\\xd4\\x34\\xe0\\x15\",\n    b\"\\xb4\\xa3\\x15\\x08\\xbe\\xff\\x4d\\x31\",\n    b\"\\x81\\x39\\x62\\x29\\xf0\\x90\\x79\\x02\",\n    b\"\\x4d\\x0c\\xf4\\x9e\\xe5\\xd4\\xdc\\xca\",\n    b\"\\x5c\\x73\\x33\\x6a\\x76\\xd8\\xbf\\x9a\",\n    b\"\\xd0\\xa7\\x04\\x53\\x6b\\xa9\\x3e\\x0e\",\n    b\"\\x92\\x59\\x58\\xfc\\xd6\\x42\\x0c\\xad\",\n    b\"\\xa9\\x15\\xc2\\x9b\\xc8\\x06\\x73\\x18\",\n    b\"\\x95\\x2b\\x79\\xf3\\xbc\\x0a\\xa6\\xd4\",\n    b\"\\xf2\\x1d\\xf2\\xe4\\x1d\\x45\\x35\\xf9\",\n    b\"\\x87\\x57\\x75\\x19\\x04\\x8f\\x53\\xa9\",\n    b\"\\x10\\xa5\\x6c\\xf5\\xdf\\xcd\\x9a\\xdb\",\n    b\"\\xeb\\x75\\x09\\x5c\\xcd\\x98\\x6c\\xd0\",\n    b\"\\x51\\xa9\\xcb\\x9e\\xcb\\xa3\\x12\\xe6\",\n    b\"\\x96\\xaf\\xad\\xfc\\x2c\\xe6\\x66\\xc7\",\n    b\"\\x72\\xfe\\x52\\x97\\x5a\\x43\\x64\\xee\",\n    b\"\\x5a\\x16\\x45\\xb2\\x76\\xd5\\x92\\xa1\",\n    b\"\\xb2\\x74\\xcb\\x8e\\xbf\\x87\\x87\\x0a\",\n    b\"\\x6f\\x9b\\xb4\\x20\\x3d\\xe7\\xb3\\x81\",\n    b\"\\xea\\xec\\xb2\\xa3\\x0b\\x22\\xa8\\x7f\",\n    b\"\\x99\\x24\\xa4\\x3c\\xc1\\x31\\x57\\x24\",\n    b\"\\xbd\\x83\\x8d\\x3a\\xaf\\xbf\\x8d\\xb7\",\n    b\"\\x0b\\x1a\\x2a\\x32\\x65\\xd5\\x1a\\xea\",\n    b\"\\x13\\x50\\x79\\xa3\\x23\\x1c\\xe6\\x60\",\n    b\"\\x93\\x2b\\x28\\x46\\xe4\\xd7\\x06\\x66\",\n    b\"\\xe1\\x91\\x5f\\x5c\\xb1\\xec\\xa4\\x6c\",\n    b\"\\xf3\\x25\\x96\\x5c\\xa1\\x6d\\x62\\x9f\",\n    b\"\\x57\\x5f\\xf2\\x8e\\x60\\x38\\x1b\\xe5\",\n    b\"\\x72\\x45\\x06\\xeb\\x4c\\x32\\x8a\\x95\",\n]\n\nMESG = (\n    b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n    b\"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n    b\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n    b\"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"\n    b\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\"\n    b\"\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\"\n    b\"\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\"\n    b\"\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\"\n)\n\nKEY = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n\nXHASHES = [\n    b\"a3817f04ba25a8e66df67214c7550293\",\n    b\"da87c1d86b99af44347659119b22fc45\",\n    b\"8177228da4a45dc7fca38bdef60affe4\",\n    b\"9c70b60c5267a94e5f33b6b02985ed51\",\n    b\"f88164c12d9c8faf7d0f6e7c7bcd5579\",\n    b\"1368875980776f8854527a07690e9627\",\n    b\"14eeca338b208613485ea0308fd7a15e\",\n    b\"a1f1ebbed8dbc153c0b84aa61ff08239\",\n    b\"3b62a9ba6258f5610f83e264f31497b4\",\n    b\"264499060ad9baabc47f8b02bb6d71ed\",\n    b\"00110dc378146956c95447d3f3d0fbba\",\n    b\"0151c568386b6677a2b4dc6f81e5dc18\",\n    b\"d626b266905ef35882634df68532c125\",\n    b\"9869e247e9c08b10d029934fc4b952f7\",\n    b\"31fcefac66d7de9c7ec7485fe4494902\",\n    b\"5493e99933b0a8117e08ec0f97cfc3d9\",\n    b\"6ee2a4ca67b054bbfd3315bf85230577\",\n    b\"473d06e8738db89854c066c47ae47740\",\n    b\"a426e5e423bf4885294da481feaef723\",\n    b\"78017731cf65fab074d5208952512eb1\",\n    b\"9e25fc833f2290733e9344a5e83839eb\",\n    b\"568e495abe525a218a2214cd3e071d12\",\n    b\"4a29b54552d16b9a469c10528eff0aae\",\n    b\"c9d184ddd5a9f5e0cf8ce29a9abf691c\",\n    b\"2db479ae78bd50d8882a8a178a6132ad\",\n    b\"8ece5f042d5e447b5051b9eacb8d8f6f\",\n    b\"9c0b53b4b3c307e87eaee08678141f66\",\n    b\"abf248af69a6eae4bfd3eb2f129eeb94\",\n    b\"0664da1668574b88b935f3027358aef4\",\n    b\"aa4b9dc4bf337de90cd4fd3c467c6ab7\",\n    b\"ea5c7f471faf6bde2b1ad7d4686d2287\",\n    b\"2939b0183223fafc1723de4f52c43d35\",\n    b\"7c3956ca5eeafc3e363e9d556546eb68\",\n    b\"77c6077146f01c32b6b69d5f4ea9ffcf\",\n    b\"37a6986cb8847edf0925f0f1309b54de\",\n    b\"a705f0e69da9a8f907241a2e923c8cc8\",\n    b\"3dc47d1f29c448461e9e76ed904f6711\",\n    b\"0d62bf01e6fc0e1a0d3c4751c5d3692b\",\n    b\"8c03468bca7c669ee4fd5e084bbee7b5\",\n    b\"528a5bb93baf2c9c4473cce5d0d22bd9\",\n    b\"df6a301e95c95dad97ae0cc8c6913bd8\",\n    b\"801189902c857f39e73591285e70b6db\",\n    b\"e617346ac9c231bb3650ae34ccca0c5b\",\n    b\"27d93437efb721aa401821dcec5adf89\",\n    b\"89237d9ded9c5e78d8b1c9b166cc7342\",\n    b\"4a6d8091bf5e7d651189fa94a250b14c\",\n    b\"0e33f96055e7ae893ffc0e3dcf492902\",\n    b\"e61c432b720b19d18ec8d84bdc63151b\",\n    b\"f7e5aef549f782cf379055a608269b16\",\n    b\"438d030fd0b7a54fa837f2ad201a6403\",\n    b\"a590d3ee4fbf04e3247e0d27f286423f\",\n    b\"5fe2c1a172fe93c4b15cd37caef9f538\",\n    b\"2c97325cbd06b36eb2133dd08b3a017c\",\n    b\"92c814227a6bca949ff0659f002ad39e\",\n    b\"dce850110bd8328cfbd50841d6911d87\",\n    b\"67f14984c7da791248e32bb5922583da\",\n    b\"1938f2cf72d54ee97e94166fa91d2a36\",\n    b\"74481e9646ed49fe0f6224301604698e\",\n    b\"57fca5de98a9d6d8006438d0583d8a1d\",\n    b\"9fecde1cefdc1cbed4763674d9575359\",\n    b\"e3040c00eb28f15366ca73cbd872e740\",\n    b\"7697009a6a831dfecca91c5993670f7a\",\n    b\"5853542321f567a005d547a4f04759bd\",\n    b\"5150d1772f50834a503e069a973fbd7c\",\n]\n\n\ndef sip24_vectors() -> List[Tuple[bytes, bytes, bytes]]:\n    \"\"\"Generate test vectors using data from the reference implementation's\n    test defined in  https://github.com/veorq/SipHash/blob/master/main.c\n\n    The key, the messages sequence and the expected hashes are all coming\n    from that file's definitions.\n    \"\"\"\n    vectors = []\n    for i, expected in enumerate(HASHES):\n        mesg = MESG[0:i]\n        vectors.append((mesg, KEY, expected))\n    return vectors\n\n\ndef sipx24_vectors() -> List[Tuple[bytes, bytes, bytes]]:\n    \"\"\"Generate test vectors using data from libsodium's tests\"\"\"\n    vectors = []\n    for i, expected in enumerate(XHASHES):\n        mesg = MESG[0:i]\n        vectors.append((mesg, KEY, expected))\n    return vectors\n\n\n@pytest.mark.parametrize((\"inp\", \"key\", \"expected\"), sip24_vectors())\ndef test_siphash24(inp: bytes, key: bytes, expected: bytes):\n    rs = siphash24(inp, key)\n    assert rs == hexlify(expected)\n\n\n@pytest.mark.skipif(\n    not SIPHASHX_AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize((\"inp\", \"key\", \"expected\"), sipx24_vectors())\ndef test_siphashx24(inp: bytes, key: bytes, expected: bytes):\n    rs = siphashx24(inp, key)\n    assert rs == expected\n\n\n@pytest.mark.parametrize(\n    (\"inp\", \"key\", \"expected\"),\n    [(b\"\\00\", b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", b\"\")],\n)\ndef test_siphash24_shortened_key(inp: bytes, key: bytes, expected: bytes):\n    with pytest.raises(ValueError):\n        siphash24(inp, key)\n\n\n@pytest.mark.skipif(\n    not SIPHASHX_AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"inp\", \"key\", \"expected\"),\n    [(b\"\\00\", b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", b\"\")],\n)\ndef test_siphashx24_shortened_key(inp: bytes, key: bytes, expected: bytes):\n    with pytest.raises(ValueError):\n        siphashx24(inp, key)\n\n\n@pytest.mark.skipif(\n    SIPHASHX_AVAILABLE, reason=\"Requires minimal build of libsodium\"\n)\ndef test_siphashx24_unavailable():\n    with pytest.raises(UnavailableError):\n        siphashx24(b\"\", b\"\")\n", "tests/test_secret.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport binascii\nimport re\nfrom typing import Dict, Type, TypeVar\n\nfrom hypothesis import given, strategies as st\n\nimport pytest\n\nfrom nacl.encoding import HexEncoder\nfrom nacl.exceptions import CryptoError\nfrom nacl.secret import Aead, SecretBox\n\nfrom .test_aead import xchacha20poly1305_ietf_vectors\nfrom .utils import flip_byte\n\n\nVECTORS = [\n    # Key, Nonce, Plaintext, Ciphertext\n    (\n        b\"1b27556473e985d462cd51197a9a46c76009549eac6474f206c4ee0844f68389\",\n        b\"69696ee955b62b73cd62bda875fc73d68219e0036b7a0b37\",\n        (\n            b\"be075fc53c81f2d5cf141316ebeb0c7b5228c52a4c62cbd44b66849b64244ffce5e\"\n            b\"cbaaf33bd751a1ac728d45e6c61296cdc3c01233561f41db66cce314adb310e3be8\"\n            b\"250c46f06dceea3a7fa1348057e2f6556ad6b1318a024a838f21af1fde048977eb4\"\n            b\"8f59ffd4924ca1c60902e52f0a089bc76897040e082f937763848645e0705\"\n        ),\n        (\n            b\"f3ffc7703f9400e52a7dfb4b3d3305d98e993b9f48681273c29650ba32fc76ce483\"\n            b\"32ea7164d96a4476fb8c531a1186ac0dfc17c98dce87b4da7f011ec48c97271d2c2\"\n            b\"0f9b928fe2270d6fb863d51738b48eeee314a7cc8ab932164548e526ae902243685\"\n            b\"17acfeabd6bb3732bc0e9da99832b61ca01b6de56244a9e88d5f9b37973f622a43d\"\n            b\"14a6599b1f654cb45a74e355a5\"\n        ),\n    ),\n]\n_BoxType = TypeVar(\"_BoxType\", Aead, SecretBox)\n\n\ndef hex_keys(m: Type[_BoxType]) -> st.SearchStrategy[bytes]:\n    return st.binary(min_size=m.KEY_SIZE, max_size=m.KEY_SIZE).map(\n        binascii.hexlify\n    )\n\n\ndef boxes(m: Type[_BoxType]) -> st.SearchStrategy[_BoxType]:\n    return st.binary(min_size=m.KEY_SIZE, max_size=m.KEY_SIZE).map(m)\n\n\n@given(k=hex_keys(Aead))\ndef test_aead_creation(k: bytes):\n    Aead(k, encoder=HexEncoder)\n\n\n@given(k=hex_keys(Aead))\ndef test_aead_bytes(k: bytes):\n    s = Aead(k, encoder=HexEncoder)\n    assert bytes(s) == s._key == binascii.unhexlify(k)\n\n\n@given(box=boxes(Aead), plaintext=st.binary(), aad=st.binary())\ndef test_aead_roundtrip(box: Aead, plaintext: bytes, aad: bytes):\n    assert plaintext == box.decrypt(box.encrypt(plaintext, aad), aad)\n\n\n@given(k=hex_keys(SecretBox))\ndef test_secret_box_creation(k: bytes):\n    SecretBox(k, encoder=HexEncoder)\n\n\n@given(k=hex_keys(SecretBox))\ndef test_secret_box_bytes(k: bytes):\n    s = SecretBox(k, encoder=HexEncoder)\n    assert bytes(s) == s._key == binascii.unhexlify(k)\n\n\nAEAD_VECTORS = [\n    {k: binascii.unhexlify(v) for (k, v) in d.items() if k != \"AEAD\"}\n    for d in xchacha20poly1305_ietf_vectors()\n]\n\n\n@pytest.mark.parametrize(\"kv\", AEAD_VECTORS, ids=range(len(AEAD_VECTORS)))\ndef test_aead_vectors(kv: Dict[str, bytes]):\n    box = Aead(kv[\"KEY\"])\n    combined = kv[\"CT\"] + kv[\"TAG\"]\n    aad, nonce, plaintext = kv[\"AD\"], kv[\"NONCE\"], kv[\"IN\"]\n\n    assert box.encrypt(plaintext, aad, nonce) == nonce + combined\n    assert box.decrypt(combined, aad, nonce) == plaintext\n    assert box.decrypt(nonce + combined, aad) == plaintext\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"nonce\", \"plaintext\", \"ciphertext\"),\n    VECTORS,\n    ids=range(len(VECTORS)),\n)\ndef test_secret_box_encryption(\n    key: bytes, nonce: bytes, plaintext: bytes, ciphertext: bytes\n):\n    box = SecretBox(key, encoder=HexEncoder)\n    encrypted = box.encrypt(\n        binascii.unhexlify(plaintext),\n        binascii.unhexlify(nonce),\n        encoder=HexEncoder,\n    )\n\n    expected = binascii.hexlify(\n        binascii.unhexlify(nonce) + binascii.unhexlify(ciphertext),\n    )\n\n    assert encrypted == expected\n    assert encrypted.nonce == nonce\n    assert encrypted.ciphertext == ciphertext\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"nonce\", \"plaintext\", \"ciphertext\"),\n    VECTORS,\n    ids=range(len(VECTORS)),\n)\ndef test_secret_box_decryption(\n    key: bytes, nonce: bytes, plaintext: bytes, ciphertext: bytes\n):\n    box = SecretBox(key, encoder=HexEncoder)\n\n    nonce = binascii.unhexlify(nonce)\n    decrypted = binascii.hexlify(\n        box.decrypt(ciphertext, nonce, encoder=HexEncoder),\n    )\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"nonce\", \"plaintext\", \"ciphertext\"),\n    VECTORS,\n    ids=range(len(VECTORS)),\n)\ndef test_secret_box_decryption_combined(\n    key: bytes, nonce: bytes, plaintext: bytes, ciphertext: bytes\n):\n    box = SecretBox(key, encoder=HexEncoder)\n\n    combined = binascii.hexlify(\n        binascii.unhexlify(nonce) + binascii.unhexlify(ciphertext),\n    )\n    decrypted = binascii.hexlify(box.decrypt(combined, encoder=HexEncoder))\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"nonce\", \"plaintext\", \"ciphertext\"),\n    VECTORS,\n    ids=range(len(VECTORS)),\n)\ndef test_secret_box_optional_nonce(\n    key: bytes, nonce: bytes, plaintext: bytes, ciphertext: bytes\n):\n    box = SecretBox(key, encoder=HexEncoder)\n\n    encrypted = box.encrypt(binascii.unhexlify(plaintext), encoder=HexEncoder)\n\n    decrypted = binascii.hexlify(box.decrypt(encrypted, encoder=HexEncoder))\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"nonce\", \"plaintext\", \"ciphertext\"),\n    VECTORS,\n    ids=range(len(VECTORS)),\n)\ndef test_secret_box_encryption_generates_different_nonces(\n    key: bytes, nonce: bytes, plaintext: bytes, ciphertext: bytes\n):\n    box = SecretBox(key, encoder=HexEncoder)\n\n    nonce_0 = box.encrypt(\n        binascii.unhexlify(plaintext), encoder=HexEncoder\n    ).nonce\n\n    nonce_1 = box.encrypt(\n        binascii.unhexlify(plaintext), encoder=HexEncoder\n    ).nonce\n\n    assert nonce_0 != nonce_1\n\n\ndef wrong_length(length: int) -> st.SearchStrategy[bytes]:\n    return st.binary().filter(lambda s: len(s) != length)\n\n\n@given(key=wrong_length(Aead.KEY_SIZE))\ndef test_aead_wrong_key_length(key: bytes):\n    with pytest.raises(\n        ValueError, match=r\"key must be exactly \\d+ bytes long\"\n    ):\n        Aead(key)\n\n\n@given(box=boxes(Aead), nonce=wrong_length(Aead.NONCE_SIZE))\ndef test_aead_wrong_nonce_length(box: Aead, nonce: bytes):\n    with pytest.raises(\n        ValueError, match=r\"nonce must be exactly \\d+ bytes long\"\n    ):\n        box.encrypt(b\"\", aad=b\"\", nonce=nonce)\n    with pytest.raises(\n        ValueError, match=r\"nonce must be exactly \\d+ bytes long\"\n    ):\n        box.decrypt(b\"\", aad=b\"\", nonce=nonce)\n\n\n@given(key=wrong_length(SecretBox.KEY_SIZE))\ndef test_secret_box_wrong_key_length(key: bytes):\n    with pytest.raises(\n        ValueError, match=r\"key must be exactly \\d+ bytes long\"\n    ):\n        SecretBox(key)\n\n\n@given(box=boxes(SecretBox), nonce=wrong_length(SecretBox.NONCE_SIZE))\ndef test_secret_box_wrong_nonce_length(box: SecretBox, nonce: bytes):\n    with pytest.raises(\n        ValueError, match=r\"nonce must be exactly \\d+ bytes long\"\n    ):\n        box.encrypt(b\"\", nonce)\n    with pytest.raises(\n        ValueError, match=r\"nonce must be exactly \\d+ bytes long\"\n    ):\n        box.decrypt(b\"\", nonce)\n\n\n@pytest.mark.parametrize(\"cls\", (SecretBox, Aead))\ndef test_wrong_types(cls: Type[_BoxType]):\n    expected = re.compile(\n        cls.__name__ + \" must be created from 32 bytes\", re.IGNORECASE\n    )\n    # Type safety: we're checking these type errors are detected at runtime.\n    with pytest.raises(TypeError, match=expected):\n        cls(12)  # type: ignore[arg-type]\n\n    box = SecretBox(b\"11\" * 32, encoder=HexEncoder)\n    with pytest.raises(TypeError, match=expected):\n        cls(box)  # type: ignore[arg-type]\n\n\ndef test_aead_bad_decryption():\n    box = Aead(b\"\\x11\" * Aead.KEY_SIZE)\n    aad = b\"some data\"\n    ciphertext = box.encrypt(b\"hello\")\n\n    with pytest.raises(CryptoError):\n        # changes the nonce\n        box.decrypt(flip_byte(ciphertext, 0), aad)\n    with pytest.raises(CryptoError):\n        # changes ciphertext\n        box.decrypt(flip_byte(ciphertext, 24), aad)\n    with pytest.raises(CryptoError):\n        # changes MAC tag\n        box.decrypt(flip_byte(ciphertext, len(ciphertext) - 1), aad)\n\n    with pytest.raises(CryptoError):\n        # completely changes ciphertext and tag\n        box.decrypt(ciphertext + b\"\\x00\", aad)\n    with pytest.raises(CryptoError):\n        # completely changes everything\n        box.decrypt(b\"\\x00\" + ciphertext, aad)\n\n    with pytest.raises(CryptoError):\n        # changes the AAD\n        box.decrypt(ciphertext, flip_byte(aad, 0))\n\n\ndef test_secret_box_bad_decryption():\n    box = SecretBox(b\"\\x11\" * 32)\n    ciphertext = box.encrypt(b\"hello\")\n\n    with pytest.raises(CryptoError):\n        # changes the nonce\n        box.decrypt(flip_byte(ciphertext, 0))\n    with pytest.raises(CryptoError):\n        # changes ciphertext\n        box.decrypt(flip_byte(ciphertext, 24))\n    with pytest.raises(CryptoError):\n        # changes MAC tag\n        box.decrypt(flip_byte(ciphertext, len(ciphertext) - 1))\n\n    with pytest.raises(CryptoError):\n        # completely changes ciphertext and tag\n        box.decrypt(ciphertext + b\"\\x00\")\n    with pytest.raises(CryptoError):\n        # completely changes everything\n        box.decrypt(b\"\\x00\" + ciphertext)\n", "tests/test_encoding.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport pytest\n\nimport nacl.encoding\nimport nacl.secret\n\n\nKEY = b\"1\" * nacl.secret.SecretBox.KEY_SIZE\nNONCE = b\"1\" * nacl.secret.SecretBox.NONCE_SIZE\nTEXT = b\"The quick brown fox jumps over the lazy dog\"\nVECTORS = [\n    # Encoder, Ciphertext\n    (\n        nacl.encoding.RawEncoder,\n        (\n            b\"111111111111111111111111\\xfcU\\xe2\\x9f\\xe6E\\x92\\xd7\\x0eFM=x\\x83\\x8fj\"\n            b\"} v\\xd4\\xf0\\x1a1\\xc0\\x88Uk\\x12\\x02\\x1cd\\xfaOH\\x13\\xdc\\x0e\\x0e\\xd7A\"\n            b\"\\x07\\x0b.\\x9f\\x01\\xbf\\xe4\\xd0s\\xf1P\\xd3\\x0e\\xaa\\x9d\\xb3\\xf7\\\\\\x0f\"\n        ),\n    ),\n    (\n        nacl.encoding.HexEncoder,\n        (\n            b\"313131313131313131313131313131313131313131313131fc55e29fe64592d70e4\"\n            b\"64d3d78838f6a7d2076d4f01a31c088556b12021c64fa4f4813dc0e0ed741070b2e\"\n            b\"9f01bfe4d073f150d30eaa9db3f75c0f\"\n        ),\n    ),\n    (\n        nacl.encoding.Base16Encoder,\n        (\n            b\"313131313131313131313131313131313131313131313131FC55E29FE64592D70E4\"\n            b\"64D3D78838F6A7D2076D4F01A31C088556B12021C64FA4F4813DC0E0ED741070B2E\"\n            b\"9F01BFE4D073F150D30EAA9DB3F75C0F\"\n        ),\n    ),\n    (\n        nacl.encoding.Base32Encoder,\n        (\n            b\"GEYTCMJRGEYTCMJRGEYTCMJRGEYTCMJRGEYTCMP4KXRJ7ZSFSLLQ4RSNHV4IHD3KPUQ\"\n            b\"HNVHQDIY4BCCVNMJAEHDE7JHUQE64BYHNOQIHBMXJ6AN74TIHH4KQ2MHKVHNT65OA6\"\n            b\"===\"\n        ),\n    ),\n    (\n        nacl.encoding.Base64Encoder,\n        (\n            b\"MTExMTExMTExMTExMTExMTExMTExMTEx/FXin+ZFktcORk09eIOPan0gdtTwGjHAiFV\"\n            b\"rEgIcZPpPSBPcDg7XQQcLLp8Bv+TQc/FQ0w6qnbP3XA8=\"\n        ),\n    ),\n    (\n        nacl.encoding.URLSafeBase64Encoder,\n        (\n            b\"MTExMTExMTExMTExMTExMTExMTExMTEx_FXin-ZFktcORk09eIOPan0gdtTwGjHAiFV\"\n            b\"rEgIcZPpPSBPcDg7XQQcLLp8Bv-TQc_FQ0w6qnbP3XA8=\"\n        ),\n    ),\n]\n\n\n@pytest.mark.parametrize((\"encoder\", \"ciphertext\"), VECTORS)\ndef test_encoders(encoder: nacl.encoding.Encoder, ciphertext: bytes):\n    box = nacl.secret.SecretBox(KEY)\n\n    test_ciphertext = box.encrypt(TEXT, NONCE, encoder=encoder)\n    assert test_ciphertext == ciphertext\n\n    test_plaintext = box.decrypt(test_ciphertext, encoder=encoder)\n    assert test_plaintext == TEXT\n", "tests/test_public.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport binascii\nfrom typing import Tuple, Union\n\nimport pytest\n\nfrom nacl.bindings import crypto_box_PUBLICKEYBYTES, crypto_box_SECRETKEYBYTES\nfrom nacl.public import Box, PrivateKey, PublicKey\nfrom nacl.utils import random\n\nfrom .utils import assert_equal, assert_not_equal\n\n\nclass TestPublicKey:\n    def test_equal_keys_have_equal_hashes(self):\n        k1 = PublicKey(b\"\\x00\" * crypto_box_PUBLICKEYBYTES)\n        k2 = PublicKey(b\"\\x00\" * crypto_box_PUBLICKEYBYTES)\n        assert hash(k1) == hash(k2)\n        assert id(k1) != id(k2)\n\n    def test_equal_keys_are_equal(self):\n        k1 = PublicKey(b\"\\x00\" * crypto_box_PUBLICKEYBYTES)\n        k2 = PublicKey(b\"\\x00\" * crypto_box_PUBLICKEYBYTES)\n        assert_equal(k1, k1)\n        assert_equal(k1, k2)\n\n    @pytest.mark.parametrize(\n        \"k2\",\n        [\n            b\"\\x00\" * crypto_box_PUBLICKEYBYTES,\n            PublicKey(b\"\\x01\" * crypto_box_PUBLICKEYBYTES),\n            PublicKey(b\"\\x00\" * (crypto_box_PUBLICKEYBYTES - 1) + b\"\\x01\"),\n        ],\n    )\n    def test_different_keys_are_not_equal(self, k2: Union[bytes, PublicKey]):\n        k1 = PublicKey(b\"\\x00\" * crypto_box_PUBLICKEYBYTES)\n        assert_not_equal(k1, k2)\n\n\nclass TestPrivateKey:\n    def test_equal_keys_have_equal_hashes(self):\n        k1 = PrivateKey(b\"\\x00\" * crypto_box_SECRETKEYBYTES)\n        k2 = PrivateKey(b\"\\x00\" * crypto_box_SECRETKEYBYTES)\n        assert hash(k1) == hash(k2)\n        assert id(k1) != id(k2)\n\n    def test_equal_keys_are_equal(self):\n        k1 = PrivateKey(b\"\\x00\" * crypto_box_SECRETKEYBYTES)\n        k2 = PrivateKey(b\"\\x00\" * crypto_box_SECRETKEYBYTES)\n        assert_equal(k1, k1)\n        assert_equal(k1, k2)\n\n    def _gen_equivalent_raw_keys_couple(self) -> Tuple[PrivateKey, PrivateKey]:\n        rwk1 = bytearray(random(crypto_box_SECRETKEYBYTES))\n        rwk2 = bytearray(rwk1)\n        # mask rwk1 bits\n        rwk1[0] &= 248\n        rwk1[31] &= 127\n        rwk1[31] |= 64\n        # set rwk2 bits\n        rwk2[0] |= 7\n        rwk2[31] |= 128\n        rwk2[31] &= 191\n        sk1 = PrivateKey(bytes(rwk1))\n        sk2 = PrivateKey(bytes(rwk2))\n        return sk1, sk2\n\n    def test_equivalent_keys_have_equal_hashes(self):\n        k1, k2 = self._gen_equivalent_raw_keys_couple()\n        assert bytes(k1) != bytes(k2)\n        assert hash(k1) == hash(k2)\n\n    def test_equivalent_keys_compare_as_equal(self):\n        k1, k2 = self._gen_equivalent_raw_keys_couple()\n        assert bytes(k1) != bytes(k2)\n        assert k1 == k2\n\n    def test_sk_and_pk_hashes_are_different(self):\n        sk = PrivateKey(random(crypto_box_SECRETKEYBYTES))\n        assert hash(sk) != hash(sk.public_key)\n\n    @pytest.mark.parametrize(\n        \"k2\",\n        [\n            b\"\\x00\" * crypto_box_SECRETKEYBYTES,\n            PrivateKey(b\"\\x01\" * crypto_box_SECRETKEYBYTES),\n            PrivateKey(b\"\\x00\" * (crypto_box_SECRETKEYBYTES - 1) + b\"\\x01\"),\n        ],\n    )\n    def test_different_keys_are_not_equal(self, k2: Union[bytes, PrivateKey]):\n        k1 = PrivateKey(b\"\\x00\" * crypto_box_SECRETKEYBYTES)\n        assert_not_equal(k1, k2)\n\n    def test_shared_key_getter(self):\n        \"\"\"\n        RFC 7748 \"Elliptic Curves for Security\" gives a set of test\n        parameters for the Diffie-Hellman key exchange on Curve25519:\n\n        6.1.  [Diffie-Hellman on] Curve25519\n            [ . . . ]\n        Alice's private key, a:\n          77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n        Alice's public key, X25519(a, 9):\n          8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n        Bob's private key, b:\n          5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n        Bob's public key, X25519(b, 9):\n          de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n\n        Since libNaCl/libsodium shared key generation adds an HSalsa20\n        key derivation pass on the raw shared Diffie-Hellman key, which\n        is not exposed by itself, we just check the shared key for equality.\n        \"\"\"\n        prv_A = (\n            b\"77076d0a7318a57d3c16c17251b26645\"\n            b\"df4c2f87ebc0992ab177fba51db92c2a\"\n        )\n        pub_A = (\n            b\"8520f0098930a754748b7ddcb43ef75a\"\n            b\"0dbf3a0d26381af4eba4a98eaa9b4e6a\"\n        )\n        prv_B = (\n            b\"5dab087e624a8a4b79e17f8b83800ee6\"\n            b\"6f3bb1292618b6fd1c2f8b27ff88e0eb\"\n        )\n        pub_B = (\n            b\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n            b\"3f8343c85b78674dadfc7e146f882b4f\"\n        )\n\n        alices = PrivateKey(binascii.unhexlify(prv_A))\n        bobs = PrivateKey(binascii.unhexlify(prv_B))\n        alicesP = alices.public_key\n        bobsP = bobs.public_key\n\n        assert binascii.unhexlify(pub_A) == bytes(alicesP)\n        assert binascii.unhexlify(pub_B) == bytes(bobsP)\n\n        box_AB = Box(alices, bobsP)\n        box_BA = Box(bobs, alicesP)\n\n        assert box_AB.shared_key() == box_BA.shared_key()\n\n    def test_equivalent_keys_shared_key_getter(self):\n        alices = PrivateKey.generate()\n        alicesP = alices.public_key\n        bobs, bobsprime = self._gen_equivalent_raw_keys_couple()\n        bobsP, bobsprimeP = bobs.public_key, bobsprime.public_key\n\n        assert bobsP == bobsprimeP\n\n        box_AB = Box(alices, bobsP)\n\n        box_BA = Box(bobs, alicesP)\n        box_BprimeA = Box(bobsprime, alicesP)\n\n        assert box_AB.shared_key() == box_BA.shared_key()\n        assert box_BprimeA.shared_key() == box_BA.shared_key()\n", "tests/test_signing.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport binascii\nfrom typing import List, Tuple, Union\n\nimport pytest\n\nfrom nacl.bindings import crypto_sign_PUBLICKEYBYTES, crypto_sign_SEEDBYTES\nfrom nacl.encoding import Base64Encoder, HexEncoder\nfrom nacl.exceptions import BadSignatureError\nfrom nacl.signing import SignedMessage, SigningKey, VerifyKey\n\nfrom .utils import (\n    assert_equal,\n    assert_not_equal,\n    check_type_error,\n    read_crypto_test_vectors,\n)\n\n\ndef tohex(b: bytes) -> str:\n    return binascii.hexlify(b).decode(\"ascii\")\n\n\ndef ed25519_known_answers() -> List[Tuple[bytes, bytes, bytes, bytes, bytes]]:\n    # Known answers taken from: http://ed25519.cr.yp.to/python/sign.input\n    # hex-encoded fields on each input line: sk||pk, pk, msg, signature||msg\n    # known answer fields: sk, pk, msg, signature, signed\n    DATA = \"ed25519\"\n    lines = read_crypto_test_vectors(DATA, delimiter=b\":\")\n    return [\n        (\n            x[0][:64],  # secret key\n            x[1],  # public key\n            x[2],  # message\n            x[3][:128],  # signature\n            x[3],  # signed message\n        )\n        for x in lines\n    ]\n\n\nclass TestSigningKey:\n    def test_initialize_with_generate(self):\n        SigningKey.generate()\n\n    def test_wrong_length(self):\n        with pytest.raises(ValueError):\n            SigningKey(b\"\")\n\n    def test_bytes(self):\n        k = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        assert bytes(k) == b\"\\x00\" * crypto_sign_SEEDBYTES\n\n    def test_equal_keys_are_equal(self):\n        k1 = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        k2 = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        assert_equal(k1, k1)\n        assert_equal(k1, k2)\n\n    def test_equal_keys_have_equal_hashes(self):\n        k1 = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        k2 = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        assert hash(k1) == hash(k2)\n        assert id(k1) != id(k2)\n\n    @pytest.mark.parametrize(\n        \"k2\",\n        [\n            b\"\\x00\" * crypto_sign_SEEDBYTES,\n            SigningKey(b\"\\x01\" * crypto_sign_SEEDBYTES),\n            SigningKey(b\"\\x00\" * (crypto_sign_SEEDBYTES - 1) + b\"\\x01\"),\n        ],\n    )\n    def test_different_keys_are_not_equal(self, k2: Union[bytes, SigningKey]):\n        k1 = SigningKey(b\"\\x00\" * crypto_sign_SEEDBYTES)\n        assert_not_equal(k1, k2)\n\n    @pytest.mark.parametrize(\n        \"seed\",\n        [b\"77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\"],\n    )\n    def test_initialization_with_seed(self, seed: bytes):\n        SigningKey(seed, encoder=HexEncoder)\n\n    @pytest.mark.parametrize(\n        (\"seed\", \"_public_key\", \"message\", \"signature\", \"expected\"),\n        ed25519_known_answers(),\n    )\n    def test_message_signing(\n        self,\n        seed: bytes,\n        _public_key: bytes,\n        message: bytes,\n        signature: bytes,\n        expected: bytes,\n    ):\n        signing_key = SigningKey(\n            seed,\n            encoder=HexEncoder,\n        )\n        signed = signing_key.sign(\n            binascii.unhexlify(message),\n            encoder=HexEncoder,\n        )\n\n        assert signed == expected\n        assert signed.message == message\n        assert signed.signature == signature\n\n\nclass TestVerifyKey:\n    def test_wrong_length(self):\n        with pytest.raises(ValueError):\n            VerifyKey(b\"\")\n\n    def test_bytes(self):\n        k = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        assert bytes(k) == b\"\\x00\" * crypto_sign_PUBLICKEYBYTES\n\n    def test_equal_keys_are_equal(self):\n        k1 = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        k2 = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        assert_equal(k1, k1)\n        assert_equal(k1, k2)\n\n    def test_equal_keys_have_equal_hashes(self):\n        k1 = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        k2 = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        assert hash(k1) == hash(k2)\n        assert id(k1) != id(k2)\n\n    @pytest.mark.parametrize(\n        \"k2\",\n        [\n            b\"\\x00\" * crypto_sign_PUBLICKEYBYTES,\n            VerifyKey(b\"\\x01\" * crypto_sign_PUBLICKEYBYTES),\n            VerifyKey(b\"\\x00\" * (crypto_sign_PUBLICKEYBYTES - 1) + b\"\\x01\"),\n        ],\n    )\n    def test_different_keys_are_not_equal(self, k2: Union[bytes, VerifyKey]):\n        k1 = VerifyKey(b\"\\x00\" * crypto_sign_PUBLICKEYBYTES)\n        assert_not_equal(k1, k2)\n\n    @pytest.mark.parametrize(\n        (\"_seed\", \"public_key\", \"message\", \"signature\", \"signed\"),\n        ed25519_known_answers(),\n    )\n    def test_valid_signed_message(\n        self,\n        _seed: bytes,\n        public_key: bytes,\n        message: bytes,\n        signature: bytes,\n        signed: bytes,\n    ):\n        key = VerifyKey(\n            public_key,\n            encoder=HexEncoder,\n        )\n\n        assert (\n            binascii.hexlify(\n                key.verify(signed, encoder=HexEncoder),\n            )\n            == message\n        )\n        assert (\n            binascii.hexlify(\n                key.verify(\n                    message, HexEncoder.decode(signature), encoder=HexEncoder\n                ),\n            )\n            == message\n        )\n\n    def test_invalid_signed_message(self):\n        skey = SigningKey.generate()\n        smessage = skey.sign(b\"A Test Message!\")\n        signature, message = smessage.signature, b\"A Forged Test Message!\"\n\n        # Small sanity check\n        assert skey.verify_key.verify(smessage)\n\n        with pytest.raises(BadSignatureError):\n            skey.verify_key.verify(message, signature)\n\n        with pytest.raises(BadSignatureError):\n            forged = SignedMessage(signature + message)\n            skey.verify_key.verify(forged)\n\n    def test_invalid_signature_length(self):\n        skey = SigningKey.generate()\n        message = b\"hello\"\n        signature = skey.sign(message).signature\n\n        # Sanity checks\n        assert skey.verify_key.verify(message, signature)\n        assert skey.verify_key.verify(signature + message)\n\n        with pytest.raises(ValueError):\n            skey.verify_key.verify(message, b\"\")\n\n        with pytest.raises(ValueError):\n            skey.verify_key.verify(message, signature * 2)\n\n        with pytest.raises(ValueError):\n            skey.verify_key.verify(signature + message, b\"\")\n\n    def test_base64_smessage_with_detached_sig_matches_with_attached_sig(self):\n        sk = SigningKey.generate()\n        vk = sk.verify_key\n\n        smsg = sk.sign(b\"Hello World in base64\", encoder=Base64Encoder)\n\n        msg = smsg.message\n        b64sig = smsg.signature\n\n        sig = Base64Encoder.decode(b64sig)\n\n        assert vk.verify(msg, sig, encoder=Base64Encoder) == vk.verify(\n            smsg, encoder=Base64Encoder\n        )\n\n        assert Base64Encoder.decode(msg) == b\"Hello World in base64\"\n\n    def test_hex_smessage_with_detached_sig_matches_with_attached_sig(self):\n        sk = SigningKey.generate()\n        vk = sk.verify_key\n\n        smsg = sk.sign(b\"Hello World in hex\", encoder=HexEncoder)\n\n        msg = smsg.message\n        hexsig = smsg.signature\n\n        sig = HexEncoder.decode(hexsig)\n\n        assert vk.verify(msg, sig, encoder=HexEncoder) == vk.verify(\n            smsg, encoder=HexEncoder\n        )\n\n        assert HexEncoder.decode(msg) == b\"Hello World in hex\"\n\n    def test_key_conversion(self):\n        keypair_seed = (\n            b\"421151a459faeade3d247115f94aedae\"\n            b\"42318124095afabe4d1451a559faedee\"\n        )\n        signing_key = SigningKey(binascii.unhexlify(keypair_seed))\n        verify_key = signing_key.verify_key\n\n        private_key = bytes(signing_key.to_curve25519_private_key())\n        public_key = bytes(verify_key.to_curve25519_public_key())\n\n        assert tohex(private_key) == (\n            \"8052030376d47112be7f73ed7a019293\"\n            \"dd12ad910b654455798b4667d73de166\"\n        )\n\n        assert tohex(public_key) == (\n            \"f1814f0e8ff1043d8a44d25babff3ced\"\n            \"cae6c22c3edaa48f857ae70de2baae50\"\n        )\n\n\ndef test_wrong_types():\n    sk = SigningKey.generate()\n\n    check_type_error(\n        \"SigningKey must be created from a 32 byte seed\", SigningKey, 12\n    )\n    check_type_error(\n        \"SigningKey must be created from a 32 byte seed\", SigningKey, sk\n    )\n    check_type_error(\n        \"SigningKey must be created from a 32 byte seed\",\n        SigningKey,\n        sk.verify_key,\n    )\n\n    check_type_error(\"VerifyKey must be created from 32 bytes\", VerifyKey, 13)\n    check_type_error(\"VerifyKey must be created from 32 bytes\", VerifyKey, sk)\n    check_type_error(\n        \"VerifyKey must be created from 32 bytes\", VerifyKey, sk.verify_key\n    )\n\n    def verify_detached_signature(x: bytes) -> None:\n        sk.verify_key.verify(b\"\", x)\n\n    check_type_error(\n        \"Verification signature must be created from 64 bytes\",\n        verify_detached_signature,\n        13,\n    )\n    check_type_error(\n        \"Verification signature must be created from 64 bytes\",\n        verify_detached_signature,\n        sk,\n    )\n    check_type_error(\n        \"Verification signature must be created from 64 bytes\",\n        verify_detached_signature,\n        sk.verify_key,\n    )\n", "tests/utils.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport os\nfrom typing import Callable, Dict, List, Optional, Tuple\n\nimport pytest\n\n\ndef assert_equal(x: object, y: object) -> None:\n    assert x == y\n    assert not (x != y)\n\n\ndef assert_not_equal(x: object, y: object) -> None:\n    assert x != y\n    assert not (x == y)\n\n\ndef read_crypto_test_vectors(\n    fname: str, maxels: int = 0, delimiter: Optional[bytes] = None\n) -> List[Tuple[bytes, ...]]:\n    assert delimiter is not None and isinstance(delimiter, bytes)\n    vectors = []\n    path = os.path.join(os.path.dirname(__file__), \"data\", fname)\n    with open(path, \"rb\") as fp:\n        for line in fp:\n            line = line.rstrip()\n            if line and line[0] != b\"#\"[0]:\n                splt = [x for x in line.split(delimiter)]\n                if maxels:\n                    splt = splt[:maxels]\n                vectors.append(tuple(splt))\n    return vectors\n\n\ndef read_kv_test_vectors(\n    fname: str,\n    delimiter: Optional[bytes] = None,\n    newrecord: Optional[bytes] = None,\n) -> List[Dict[str, bytes]]:\n    assert delimiter is not None and isinstance(delimiter, bytes)\n    assert newrecord is not None and isinstance(newrecord, bytes)\n    vectors = []\n    path = os.path.join(os.path.dirname(__file__), \"data\", fname)\n    vector: Dict[str, bytes] = {}\n    with open(path, \"rb\") as fp:\n        for line in fp:\n            line = line.rstrip()\n            if line and line[0] != b\"#\"[0]:\n                [k, v] = line.split(delimiter, 1)\n                k, v = k.strip(), v.strip()\n                if k == newrecord and k.decode(\"utf-8\") in vector:\n                    vectors.append(vector)\n                    vector = {}\n                vector[k.decode(\"utf-8\")] = v\n        vectors.append(vector)\n    return vectors\n\n\ndef flip_byte(original: bytes, byte_offset: int) -> bytes:\n    return (\n        original[:byte_offset]\n        + bytes([0x01 ^ original[byte_offset]])\n        + original[byte_offset + 1 :]\n    )\n\n\n# Type safety: it's fine to use `...` here, but mypy config doesn't like it because it's\n# an explicit `Any`.\ndef check_type_error(  # type: ignore[misc]\n    expected: str, f: Callable[..., object], *args: object\n) -> None:\n    with pytest.raises(TypeError) as e:\n        f(*args)\n    assert expected in str(e.value)\n", "tests/test_hash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport pytest\n\nimport nacl.encoding\nimport nacl.hash\n\n\n@pytest.mark.parametrize(\n    (\"inp\", \"expected\"),\n    [\n        (\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\",\n        ),\n        (\n            b\"\",\n            b\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n        ),\n    ],\n)\ndef test_sha256_hex(inp: bytes, expected: bytes):\n    assert nacl.hash.sha256(inp) == expected\n\n\n@pytest.mark.parametrize(\n    (\"inp\", \"expected\"),\n    [\n        (\n            b\"The quick brown fox jumps over the lazy dog.\",\n            (\n                b\"\\xEFS\\x7F%\\xC8\\x95\\xBF\\xA7\\x82Re)\\xA9\\xB6=\\x97\\xAAc\\x15d\\xD5\\xD7\"\n                b\"\\x89\\xC2\\xB7eD\\x8C\\x865\\xFBl\"\n            ),\n        ),\n        (\n            b\"\",\n            (\n                b\"\\xe3\\xb0\\xc4B\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99o\\xb9$'\\xaeA\\xe4d\"\n                b\"\\x9b\\x93L\\xa4\\x95\\x99\\x1bxR\\xb8U\"\n            ),\n        ),\n    ],\n)\ndef test_sha256_binary(inp: bytes, expected: bytes):\n    assert nacl.hash.sha256(inp, encoder=nacl.encoding.RawEncoder) == expected\n\n\n@pytest.mark.parametrize(\n    (\"inp\", \"expected\"),\n    [\n        (\n            b\"The quick brown fox jumps over the lazy dog.\",\n            (\n                b\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bbc6c\"\n                b\"7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n            ),\n        ),\n        (\n            b\"\",\n            (\n                b\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d\"\n                b\"0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n            ),\n        ),\n    ],\n)\ndef test_sha512_hex(inp: bytes, expected: bytes):\n    assert nacl.hash.sha512(inp) == expected\n\n\n@pytest.mark.parametrize(\n    (\"inp\", \"expected\"),\n    [\n        (\n            b\"The quick brown fox jumps over the lazy dog.\",\n            (\n                b\"\\x91\\xEA\\x12E\\xF2\\rF\\xAE\\x9A\\x03z\\x98\\x9FT\\xF1\\xF7\\x90\\xF0\\xA4v\\a\"\n                b\"\\xEE\\xB8\\xA1M\\x12\\x89\\f\\xEAw\\xA1\\xBB\\xC6\\xC7\\xED\\x9C\\xF2\\x05\\xE6{\"\n                b\"\\x7F+\\x8F\\xD4\\xC7\\xDF\\xD3\\xA7\\xA8a~E\\xF3\\xC4c\\xD4\\x81\\xC7\\xE5\\x86\"\n                b\"\\xC3\\x9A\\xC1\\xED\"\n            ),\n        ),\n        (\n            b\"\",\n            (\n                b\"\\xCF\\x83\\xE15~\\xEF\\xB8\\xBD\\xF1T(P\\xD6m\\x80\\a\\xD6 \\xE4\\x05\\vW\\x15\"\n                b\"\\xDC\\x83\\xF4\\xA9!\\xD3l\\xE9\\xCEG\\xD0\\xD1<]\\x85\\xF2\\xB0\\xFF\\x83\\x18\"\n                b\"\\xD2\\x87~\\xEC/c\\xB91\\xBDGAz\\x81\\xA582z\\xF9'\\xDA>\"\n            ),\n        ),\n    ],\n)\ndef test_sha512_binary(inp: bytes, expected: bytes):\n    assert nacl.hash.sha512(inp, encoder=nacl.encoding.RawEncoder) == expected\n", "tests/test_aead.py": "# Copyright 2016 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport binascii\nfrom typing import Callable, Dict, List, NamedTuple, Optional\n\nfrom hypothesis import given, settings\nfrom hypothesis.strategies import binary, sampled_from\n\nimport pytest\n\nimport nacl.bindings as b\nimport nacl.exceptions as exc\n\nfrom .utils import read_kv_test_vectors\n\n\ndef chacha20poly1305_agl_vectors() -> List[Dict[str, bytes]]:\n    # NIST vectors derived format\n    DATA = \"chacha20-poly1305-agl_ref.txt\"\n    return read_kv_test_vectors(DATA, delimiter=b\":\", newrecord=b\"AEAD\")\n\n\ndef chacha20poly1305_ietf_vectors() -> List[Dict[str, bytes]]:\n    # NIST vectors derived format\n    DATA = \"chacha20-poly1305-ietf_ref.txt\"\n    return read_kv_test_vectors(DATA, delimiter=b\":\", newrecord=b\"AEAD\")\n\n\ndef xchacha20poly1305_ietf_vectors() -> List[Dict[str, bytes]]:\n    # NIST vectors derived format\n    DATA = \"xchacha20-poly1305-ietf_ref.txt\"\n    return read_kv_test_vectors(DATA, delimiter=b\":\", newrecord=b\"AEAD\")\n\n\nclass Construction(NamedTuple):\n    encrypt: Callable[[bytes, Optional[bytes], bytes, bytes], bytes]\n    decrypt: Callable[[bytes, Optional[bytes], bytes, bytes], bytes]\n    NPUB: int\n    KEYBYTES: int\n\n\ndef _getconstruction(construction: bytes) -> Construction:\n    if construction == b\"chacha20-poly1305-old\":\n        encrypt = b.crypto_aead_chacha20poly1305_encrypt\n        decrypt = b.crypto_aead_chacha20poly1305_decrypt\n        NPUB = b.crypto_aead_chacha20poly1305_NPUBBYTES\n        KEYBYTES = b.crypto_aead_chacha20poly1305_KEYBYTES\n    elif construction == b\"chacha20-poly1305\":\n        encrypt = b.crypto_aead_chacha20poly1305_ietf_encrypt\n        decrypt = b.crypto_aead_chacha20poly1305_ietf_decrypt\n        NPUB = b.crypto_aead_chacha20poly1305_ietf_NPUBBYTES\n        KEYBYTES = b.crypto_aead_chacha20poly1305_ietf_KEYBYTES\n    else:\n        encrypt = b.crypto_aead_xchacha20poly1305_ietf_encrypt\n        decrypt = b.crypto_aead_xchacha20poly1305_ietf_decrypt\n        NPUB = b.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n        KEYBYTES = b.crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n\n    return Construction(encrypt, decrypt, NPUB, KEYBYTES)\n\n\n@pytest.mark.parametrize(\n    \"kv\",\n    chacha20poly1305_agl_vectors()\n    + chacha20poly1305_ietf_vectors()\n    + xchacha20poly1305_ietf_vectors(),\n)\ndef test_chacha20poly1305_variants_kat(kv: Dict[str, bytes]):\n    msg = binascii.unhexlify(kv[\"IN\"])\n    ad = binascii.unhexlify(kv[\"AD\"])\n    nonce = binascii.unhexlify(kv[\"NONCE\"])\n    k = binascii.unhexlify(kv[\"KEY\"])\n    c = _getconstruction(kv[\"AEAD\"])\n    _tag = kv.get(\"TAG\", b\"\")\n    exp = binascii.unhexlify(kv[\"CT\"]) + binascii.unhexlify(_tag)\n    out = c.encrypt(msg, ad, nonce, k)\n    assert out == exp\n\n\n@given(\n    sampled_from(\n        (b\"chacha20-poly1305-old\", b\"chacha20-poly1305\", b\"xchacha20-poly1305\")\n    ),\n    binary(min_size=0, max_size=100),\n    binary(min_size=0, max_size=50),\n    binary(\n        min_size=b.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n        max_size=b.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n    ),\n    binary(\n        min_size=b.crypto_aead_chacha20poly1305_KEYBYTES,\n        max_size=b.crypto_aead_chacha20poly1305_KEYBYTES,\n    ),\n)\n@settings(deadline=None, max_examples=20)\ndef test_chacha20poly1305_variants_roundtrip(\n    construction: bytes, message: bytes, aad: bytes, nonce: bytes, key: bytes\n):\n    c = _getconstruction(construction)\n    unonce = nonce[: c.NPUB]\n\n    ct = c.encrypt(message, aad, unonce, key)\n    pt = c.decrypt(ct, aad, unonce, key)\n\n    assert pt == message\n    with pytest.raises(exc.CryptoError):\n        ct1 = bytearray(ct)\n        ct1[0] = ct1[0] ^ 0xFF\n        c.decrypt(ct1, aad, unonce, key)\n\n\n@pytest.mark.parametrize(\n    \"construction\",\n    [b\"chacha20-poly1305-old\", b\"chacha20-poly1305\", b\"xchacha20-poly1305\"],\n)\ndef test_chacha20poly1305_variants_wrong_params(construction: bytes):\n    c = _getconstruction(construction)\n    nonce = b\"\\x00\" * c.NPUB\n    key = b\"\\x00\" * c.KEYBYTES\n    aad = None\n    c.encrypt(b\"\", aad, nonce, key)\n    # The first two checks call encrypt with a nonce/key that's too short. Otherwise,\n    # the types are fine. (TODO: Should this raise ValueError rather than TypeError?\n    # Doing so would be a breaking change.)\n    with pytest.raises(exc.TypeError):\n        c.encrypt(b\"\", aad, nonce[:-1], key)\n    with pytest.raises(exc.TypeError):\n        c.encrypt(b\"\", aad, nonce, key[:-1])\n    # Type safety: mypy spots these next two errors, but we want to check that they're\n    # spotted at runtime too.\n    with pytest.raises(exc.TypeError):\n        c.encrypt(b\"\", aad, nonce.decode(\"utf-8\"), key)  # type: ignore[arg-type]\n    with pytest.raises(exc.TypeError):\n        c.encrypt(b\"\", aad, nonce, key.decode(\"utf-8\"))  # type: ignore[arg-type]\n\n\n@pytest.mark.parametrize(\n    \"construction\",\n    [b\"chacha20-poly1305-old\", b\"chacha20-poly1305\", b\"xchacha20-poly1305\"],\n)\ndef test_chacha20poly1305_variants_str_msg(construction: bytes):\n    c = _getconstruction(construction)\n    nonce = b\"\\x00\" * c.NPUB\n    key = b\"\\x00\" * c.KEYBYTES\n    aad = None\n    with pytest.raises(exc.TypeError):\n        c.encrypt(\"\", aad, nonce, key)  # type: ignore[arg-type]\n", "tests/test_hashlib_scrypt.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom binascii import unhexlify\n\nimport pytest\n\nimport nacl.bindings\nimport nacl.encoding\nimport nacl.hashlib\nfrom nacl.exceptions import UnavailableError\n\n\n# Test vectors from rfc 7914, Page 13\n#   scrypt (P=\"\", S=\"\",\n#           N=16, r=1, p=1, dklen=64) =\n#   77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97\n#   f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42\n#   fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17\n#   e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06\n#\n#   scrypt (P=\"password\", S=\"NaCl\",\n#           N=1024, r=8, p=16, dkLen=64) =\n#   fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe\n#   7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62\n#   2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da\n#   c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40\n#\n#   scrypt (P=\"pleaseletmein\", S=\"SodiumChloride\",\n#           N=16384, r=8, p=1, dkLen=64) =\n#   70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb\n#   fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2\n#   d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9\n#   e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87\n#\n#   scrypt (P=\"pleaseletmein\", S=\"SodiumChloride\",\n#           N=1048576, r=8, p=1, dkLen=64) =\n#   21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81\n#   ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47\n#   8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3\n#   37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4\n\nRFC_7914_VECTORS = [\n    (\n        b\"\",\n        b\"\",\n        16,\n        1,\n        1,\n        64,\n        (\n            b\"77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97\"\n            b\"f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42\"\n            b\"fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17\"\n            b\"e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06\"\n        ),\n    ),\n    (\n        b\"password\",\n        b\"NaCl\",\n        1024,\n        8,\n        16,\n        64,\n        (\n            b\"fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe\"\n            b\"7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62\"\n            b\"2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da\"\n            b\"c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40\"\n        ),\n    ),\n    (\n        b\"pleaseletmein\",\n        b\"SodiumChloride\",\n        16384,\n        8,\n        1,\n        64,\n        (\n            b\"70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb\"\n            b\"fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2\"\n            b\"d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9\"\n            b\"e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87\"\n        ),\n    ),\n    (\n        b\"pleaseletmein\",\n        b\"SodiumChloride\",\n        1048576,\n        8,\n        1,\n        64,\n        (\n            b\"21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81\"\n            b\"ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47\"\n            b\"8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3\"\n            b\"37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4\"\n        ),\n    ),\n]\n\n\n@pytest.mark.skipif(\n    not nacl.hashlib.SCRYPT_AVAILABLE,\n    reason=\"Requires full build of libsodium\",\n)\n@pytest.mark.parametrize(\n    (\"password\", \"salt\", \"n\", \"r\", \"p\", \"dklen\", \"expected\"), RFC_7914_VECTORS\n)\ndef test_hashlib_scrypt_api(\n    password: bytes,\n    salt: bytes,\n    n: int,\n    r: int,\n    p: int,\n    dklen: int,\n    expected: bytes,\n):\n    _exp = unhexlify(expected.replace(b\" \", b\"\"))\n    dgst = nacl.hashlib.scrypt(\n        password, salt=salt, n=n, r=r, p=p, dklen=dklen, maxmem=2 * (1024**3)\n    )\n    assert _exp == dgst\n\n\n@pytest.mark.skipif(\n    nacl.hashlib.SCRYPT_AVAILABLE, reason=\"Requires minimal build of libsodium\"\n)\ndef test_hashlib_scrypt_unavailable():\n    with pytest.raises(UnavailableError):\n        nacl.hashlib.scrypt(b\"\")\n", "tests/test_secretstream.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport binascii\nimport json\nimport os\nimport random\nfrom typing import ByteString, List, Optional, Tuple\n\nfrom _pytest._code import ExceptionInfo\nfrom _pytest.monkeypatch import MonkeyPatch\n\nimport pytest\n\nfrom nacl._sodium import ffi\nfrom nacl.bindings.crypto_secretstream import (\n    crypto_secretstream_xchacha20poly1305_ABYTES,\n    crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    crypto_secretstream_xchacha20poly1305_TAG_FINAL,\n    crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n    crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n    crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n    crypto_secretstream_xchacha20poly1305_init_pull,\n    crypto_secretstream_xchacha20poly1305_init_push,\n    crypto_secretstream_xchacha20poly1305_keygen,\n    crypto_secretstream_xchacha20poly1305_pull,\n    crypto_secretstream_xchacha20poly1305_push,\n    crypto_secretstream_xchacha20poly1305_rekey,\n    crypto_secretstream_xchacha20poly1305_state,\n)\nfrom nacl.utils import random as randombytes\n\nChunk = Tuple[int, Optional[bytes], bytes, bytes]\n\n\ndef read_secretstream_vectors() -> List[Tuple[bytes, bytes, List[Chunk]]]:\n    DATA = \"secretstream-test-vectors.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    with open(path) as fp:\n        jvectors = json.load(fp)\n    unhex = binascii.unhexlify\n    vectors = [\n        (\n            unhex(v[\"key\"]),\n            unhex(v[\"header\"]),\n            [\n                (\n                    c[\"tag\"],\n                    unhex(c[\"ad\"]) if c[\"ad\"] is not None else None,\n                    unhex(c[\"message\"]),\n                    unhex(c[\"ciphertext\"]),\n                )\n                for c in v[\"chunks\"]\n            ],\n        )\n        for v in jvectors\n    ]\n    return vectors\n\n\n@pytest.mark.parametrize(\n    (\"key\", \"header\", \"chunks\"),\n    read_secretstream_vectors(),\n)\ndef test_vectors(key: bytes, header: bytes, chunks: List[Chunk]):\n    state = crypto_secretstream_xchacha20poly1305_state()\n    crypto_secretstream_xchacha20poly1305_init_pull(state, header, key)\n    for tag, ad, message, ciphertext in chunks:\n        m, t = crypto_secretstream_xchacha20poly1305_pull(\n            state, ciphertext, ad\n        )\n        assert m == message\n        assert t == tag\n\n\ndef test_it_like_libsodium():\n    ad_len = random.randint(1, 100)\n    m1_len = random.randint(1, 1000)\n    m2_len = random.randint(1, 1000)\n    m3_len = random.randint(1, 1000)\n\n    ad = randombytes(ad_len)\n    m1 = randombytes(m1_len)\n    m2 = randombytes(m2_len)\n    m3 = randombytes(m3_len)\n    m1_ = m1[:]\n    m2_ = m2[:]\n    m3_ = m3[:]\n\n    state = crypto_secretstream_xchacha20poly1305_state()\n\n    k = crypto_secretstream_xchacha20poly1305_keygen()\n    assert len(k) == crypto_secretstream_xchacha20poly1305_KEYBYTES\n\n    # push\n\n    assert (\n        len(state.statebuf) == crypto_secretstream_xchacha20poly1305_STATEBYTES\n    )\n    header = crypto_secretstream_xchacha20poly1305_init_push(state, k)\n    assert len(header) == crypto_secretstream_xchacha20poly1305_HEADERBYTES\n\n    c1 = crypto_secretstream_xchacha20poly1305_push(state, m1)\n    assert len(c1) == m1_len + crypto_secretstream_xchacha20poly1305_ABYTES\n\n    c2 = crypto_secretstream_xchacha20poly1305_push(state, m2, ad)\n    assert len(c2) == m2_len + crypto_secretstream_xchacha20poly1305_ABYTES\n\n    c3 = crypto_secretstream_xchacha20poly1305_push(\n        state, m3, ad=ad, tag=crypto_secretstream_xchacha20poly1305_TAG_FINAL\n    )\n    assert len(c3) == m3_len + crypto_secretstream_xchacha20poly1305_ABYTES\n\n    # pull\n\n    crypto_secretstream_xchacha20poly1305_init_pull(state, header, k)\n\n    m1, tag = crypto_secretstream_xchacha20poly1305_pull(state, c1)\n    assert tag == crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\n    assert m1 == m1_\n\n    m2, tag = crypto_secretstream_xchacha20poly1305_pull(state, c2, ad)\n    assert tag == crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\n    assert m2 == m2_\n\n    # Mark this as taking a generic Exception, or else mypy will later complain\n    # that we can't write an ExceptionInfo[ValueError] value to an expression of type\n    # ExceptionInfo[RuntimeError].\n    excinfo: ExceptionInfo[Exception]\n\n    with pytest.raises(RuntimeError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_pull(state, c3)\n    assert str(excinfo.value) == \"Unexpected failure\"\n    m3, tag = crypto_secretstream_xchacha20poly1305_pull(state, c3, ad)\n    assert tag == crypto_secretstream_xchacha20poly1305_TAG_FINAL\n    assert m3 == m3_\n\n    # previous with FINAL tag\n\n    with pytest.raises(RuntimeError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_pull(state, c3, ad)\n    assert str(excinfo.value) == \"Unexpected failure\"\n\n    # previous without a tag\n\n    with pytest.raises(RuntimeError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_pull(state, c2, None)\n    assert str(excinfo.value) == \"Unexpected failure\"\n\n    # short ciphertext\n\n    with pytest.raises(ValueError) as excinfo:\n        c2len = random.randint(\n            1, crypto_secretstream_xchacha20poly1305_ABYTES - 1\n        )\n        crypto_secretstream_xchacha20poly1305_pull(state, c2[:c2len])\n    assert str(excinfo.value) == \"Ciphertext is too short\"\n    with pytest.raises(ValueError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_pull(state, b\"\")\n    assert str(excinfo.value) == \"Ciphertext is too short\"\n\n    # empty ciphertext\n\n    with pytest.raises(ValueError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_pull(\n            state,\n            c2[: crypto_secretstream_xchacha20poly1305_ABYTES - 1],\n            None,\n        )\n    assert str(excinfo.value) == \"Ciphertext is too short\"\n\n    # without explicit rekeying\n\n    header = crypto_secretstream_xchacha20poly1305_init_push(state, k)\n    c1 = crypto_secretstream_xchacha20poly1305_push(state, m1)\n    c2 = crypto_secretstream_xchacha20poly1305_push(state, m2)\n\n    crypto_secretstream_xchacha20poly1305_init_pull(state, header, k)\n    m1, tag = crypto_secretstream_xchacha20poly1305_pull(state, c1)\n    assert m1 == m1_\n    m2, tag = crypto_secretstream_xchacha20poly1305_pull(state, c2)\n    assert m2 == m2_\n\n    # with explicit rekeying\n\n    header = crypto_secretstream_xchacha20poly1305_init_push(state, k)\n    c1 = crypto_secretstream_xchacha20poly1305_push(state, m1)\n\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n\n    c2 = crypto_secretstream_xchacha20poly1305_push(state, m2)\n\n    crypto_secretstream_xchacha20poly1305_init_pull(state, header, k)\n    m1, tag = crypto_secretstream_xchacha20poly1305_pull(state, c1)\n    assert m1 == m1_\n\n    with pytest.raises(RuntimeError):\n        crypto_secretstream_xchacha20poly1305_pull(state, c2)\n\n    crypto_secretstream_xchacha20poly1305_rekey(state)\n\n    m2, tag = crypto_secretstream_xchacha20poly1305_pull(state, c2)\n    assert m2 == m2_\n\n    # with explicit rekeying using TAG_REKEY\n\n    header = crypto_secretstream_xchacha20poly1305_init_push(state, k)\n\n    state_save: ByteString = ffi.buffer(state.statebuf)[:]\n\n    c1 = crypto_secretstream_xchacha20poly1305_push(\n        state, m1, tag=crypto_secretstream_xchacha20poly1305_TAG_REKEY\n    )\n\n    c2 = crypto_secretstream_xchacha20poly1305_push(state, m2)\n\n    csave = c2[:]\n\n    crypto_secretstream_xchacha20poly1305_init_pull(state, header, k)\n    m1, tag = crypto_secretstream_xchacha20poly1305_pull(state, c1)\n    assert m1 == m1_\n    assert tag == crypto_secretstream_xchacha20poly1305_TAG_REKEY\n\n    m2, tag = crypto_secretstream_xchacha20poly1305_pull(state, c2)\n    assert m2 == m2_\n    assert tag == crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\n\n    # avoid using from_buffer until at least cffi >= 1.10 in setup.py\n    # state = ffi.from_buffer(state_save)\n    for i in range(crypto_secretstream_xchacha20poly1305_STATEBYTES):\n        # Type safety: we can't write to a `ByteString` (\u2248 `Sequence[int]`). It's really\n        # a CFFI `cdata` object which owns an `unsigned char[]` (which we can write to).\n        # This is the only place we mutate `state_buf` in place across the project,\n        # and we don't expect end-users to do this.\n        state.statebuf[i] = state_save[i]  # type: ignore[index]\n\n    c1 = crypto_secretstream_xchacha20poly1305_push(state, m1)\n\n    c2 = crypto_secretstream_xchacha20poly1305_push(state, m2)\n    assert csave != c2\n\n    # New stream\n\n    header = crypto_secretstream_xchacha20poly1305_init_push(state, k)\n\n    c1 = crypto_secretstream_xchacha20poly1305_push(\n        state, m1, tag=crypto_secretstream_xchacha20poly1305_TAG_PUSH\n    )\n    assert len(c1) == m1_len + crypto_secretstream_xchacha20poly1305_ABYTES\n\n    # snip tests that require introspection into the state buffer\n    # to test the nonce as we're using an opaque pointer\n\n\ndef test_max_message_size(monkeypatch: MonkeyPatch):\n    import nacl.bindings.crypto_secretstream as css\n\n    # we want to create an oversized message but don't want to blow out\n    # memory so knock it down a bit for this test\n    monkeypatch.setattr(\n        css,\n        \"crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX\",\n        2**10 - 1,\n    )\n    m = b\"0\" * (css.crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX + 1)\n    k = crypto_secretstream_xchacha20poly1305_keygen()\n    state = crypto_secretstream_xchacha20poly1305_state()\n    crypto_secretstream_xchacha20poly1305_init_push(state, k)\n    with pytest.raises(ValueError) as excinfo:\n        crypto_secretstream_xchacha20poly1305_push(state, m, None, 0)\n    assert str(excinfo.value) == \"Message is too long\"\n", "tests/test_exc.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport pytest\n\nfrom nacl import exceptions as exc\n\n\nclass CustomError(exc.CryptoError):\n    pass\n\n\n# Type safety: mypy can spot comparisons that will always evaluate to False, and the\n# bad argument type. Suppress these: we want to test these are detected at runtime.\n\n\ndef test_exceptions_ensure_with_true_condition():\n    exc.ensure(1 == 1, \"one equals one\")\n\n\ndef test_exceptions_ensure_with_false_condition():\n    with pytest.raises(exc.AssertionError):\n        exc.ensure(\n            1 == 0,  # type: ignore[comparison-overlap]\n            \"one is not zero\",\n            raising=exc.AssertionError,\n        )\n\n\ndef test_exceptions_ensure_with_unwanted_kwarg():\n    with pytest.raises(exc.TypeError):\n        exc.ensure(\n            1 == 1,\n            unexpected=\"unexpected\",  # type: ignore[arg-type]\n        )\n\n\ndef test_exceptions_ensure_custom_exception():\n    with pytest.raises(CustomError):\n        exc.ensure(\n            1 == 0,  # type: ignore[comparison-overlap]\n            \"Raising a CustomError\",\n            raising=CustomError,\n        )\n", "tests/test_sealed_box.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport binascii\nfrom typing import List, Tuple\n\nimport pytest\n\nfrom nacl.encoding import HexEncoder\nfrom nacl.exceptions import CryptoError\nfrom nacl.public import PrivateKey, PublicKey, SealedBox\n\nfrom .utils import check_type_error, read_crypto_test_vectors\n\n\ndef sealbox_vectors() -> List[Tuple[bytes, bytes, bytes, bytes]]:\n    # Fmt: <recipient sk><tab><recipient pk><tab><pt_len>:<plaintext>\n    # <tab><cr_len>:<ciphertext>[<tab> ...]\n\n    def splitlen(x: bytes) -> bytes:\n        ln, dta = x.split(b\":\")\n        assert len(dta) == 2 * int(ln)\n        return dta\n\n    DATA = \"sealed_box_ref.txt\"\n    return [\n        (x[0], x[1], splitlen(x[2]), splitlen(x[3]))\n        for x in read_crypto_test_vectors(DATA, maxels=4, delimiter=b\"\\t\")\n    ]\n\n\ndef test_generate_private_key():\n    PrivateKey.generate()\n\n\ndef test_sealed_box_creation():\n    pub = PublicKey(\n        b\"ec2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    priv = PrivateKey(\n        b\"5c2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    SealedBox(priv)\n    SealedBox(pub)\n\n\n@pytest.mark.parametrize(\n    (\"privalice\", \"pubalice\", \"plaintext\", \"_encrypted\"), sealbox_vectors()\n)\ndef test_sealed_box_encryption(\n    privalice: bytes, pubalice: bytes, plaintext: bytes, _encrypted: bytes\n):\n    pubalice_decoded = PublicKey(pubalice, encoder=HexEncoder)\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = SealedBox(pubalice_decoded)\n    encrypted = box.encrypt(\n        binascii.unhexlify(plaintext),\n        encoder=HexEncoder,\n    )\n\n    assert encrypted != _encrypted\n    # since SealedBox.encrypt uses an ephemeral sender's keypair\n\n    box2 = SealedBox(privalice_decoded)\n    decrypted = box2.decrypt(\n        encrypted,\n        encoder=HexEncoder,\n    )\n    assert binascii.hexlify(decrypted) == plaintext\n    assert bytes(box) == bytes(box2)\n\n\n@pytest.mark.parametrize(\n    (\"privalice\", \"_pubalice\", \"plaintext\", \"encrypted\"), sealbox_vectors()\n)\ndef test_sealed_box_decryption(\n    privalice: bytes, _pubalice: bytes, plaintext: bytes, encrypted: bytes\n):\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = SealedBox(privalice_decoded)\n    decrypted = box.decrypt(\n        encrypted,\n        encoder=HexEncoder,\n    )\n    assert binascii.hexlify(decrypted) == plaintext\n\n\ndef test_wrong_types():\n    priv = PrivateKey.generate()\n\n    check_type_error(\n        (\"SealedBox must be created from a PublicKey or a PrivateKey\"),\n        SealedBox,\n        priv.encode(),\n    )\n    check_type_error(\n        (\"SealedBox must be created from a PublicKey or a PrivateKey\"),\n        SealedBox,\n        priv.public_key.encode(),\n    )\n    with pytest.raises(TypeError):\n        # Type safety: we want to check this error is detected at runtime.\n        SealedBox(priv, priv.public_key)  # type: ignore[call-arg]\n\n\n@pytest.mark.parametrize(\n    (\"_privalice\", \"pubalice\", \"_plaintext\", \"encrypted\"), sealbox_vectors()\n)\ndef test_sealed_box_public_key_cannot_decrypt(\n    _privalice: bytes, pubalice: bytes, _plaintext: bytes, encrypted: bytes\n):\n    pubalice_decoded = PublicKey(pubalice, encoder=HexEncoder)\n\n    box = SealedBox(pubalice_decoded)\n    with pytest.raises(TypeError):\n        # Type safety: mypy spots that you can't decrypt with a public key, but we\n        # want to detect this at runtime too.\n        box.decrypt(  # type: ignore[misc]\n            encrypted,\n            encoder=HexEncoder,\n        )\n\n\ndef test_sealed_box_zero_length_plaintext():\n    empty_plaintext = b\"\"\n    k = PrivateKey.generate()\n    enc_box = SealedBox(k.public_key)\n    dec_box = SealedBox(k)\n\n    msg = enc_box.encrypt(empty_plaintext)\n    decoded = dec_box.decrypt(msg)\n\n    assert decoded == empty_plaintext\n\n\ndef test_sealed_box_too_short_msg():\n    empty_plaintext = b\"\"\n    k = PrivateKey.generate()\n    enc_box = SealedBox(k.public_key)\n    dec_box = SealedBox(k)\n\n    msg = enc_box.encrypt(empty_plaintext)\n    with pytest.raises(CryptoError):\n        dec_box.decrypt(msg[:-1])\n", "tests/test_kx.py": "# Copyright 2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom hypothesis import HealthCheck, given, settings\nfrom hypothesis.strategies import binary\n\nimport pytest\n\nimport nacl.bindings as b\nimport nacl.exceptions as exc\n\n\ndef test_crypto_kx_keypair():\n    public_key, secret_key = b.crypto_kx_keypair()\n    public_key_2, secret_key_2 = b.crypto_kx_keypair()\n    assert public_key != public_key_2\n    assert secret_key != secret_key_2\n\n\n@given(\n    binary(min_size=32, max_size=32),\n    binary(min_size=32, max_size=32),\n)\n@settings(max_examples=100)\ndef test_crypto_kx_seed_keypair(seed1: bytes, seed2: bytes):\n    seeded = b.crypto_kx_seed_keypair(seed1)\n    seeded_other = b.crypto_kx_seed_keypair(seed2)\n    if seed1 != seed2:\n        assert seeded != seeded_other\n    else:\n        assert seeded == seeded_other\n\n\n@given(\n    binary(min_size=33, max_size=128),\n)\n@settings(max_examples=20, suppress_health_check=[HealthCheck.too_slow])\ndef test_crypto_kx_seed_keypair_seed_too_large(seed: bytes):\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_seed_keypair(seed)\n\n\n@given(\n    binary(min_size=0, max_size=31),\n)\n@settings(max_examples=20)\ndef test_crypto_kx_seed_keypair_seed_too_small(seed: bytes):\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_seed_keypair(seed)\n\n\n@given(\n    binary(min_size=32, max_size=32),\n    binary(min_size=32, max_size=32),\n)\n@settings(max_examples=100)\ndef test_crypto_kx_session_keys(seed1: bytes, seed2: bytes):\n    s_keys = b.crypto_kx_seed_keypair(seed1)\n    c_keys = b.crypto_kx_seed_keypair(seed2)\n\n    server_rx_key, server_tx_key = b.crypto_kx_server_session_keys(\n        s_keys[0], s_keys[1], c_keys[0]\n    )\n    client_rx_key, client_tx_key = b.crypto_kx_client_session_keys(\n        c_keys[0], c_keys[1], s_keys[0]\n    )\n\n    assert client_rx_key == server_tx_key\n    assert server_rx_key == client_tx_key\n\n\ndef test_crypto_kx_session_wrong_key_lengths():\n    s_keys = b.crypto_kx_keypair()\n    c_keys = b.crypto_kx_keypair()\n\n    # TODO: should invalid argument lengths (but correct types) raise ValueError?\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_server_session_keys(s_keys[0][:-1], s_keys[1], c_keys[0])\n\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_client_session_keys(c_keys[0][:-1], c_keys[1], s_keys[0])\n\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_server_session_keys(s_keys[0], s_keys[1][:-1], c_keys[0])\n\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_client_session_keys(c_keys[0], c_keys[1][:-1], s_keys[0])\n\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_server_session_keys(s_keys[0], s_keys[1], c_keys[0][:-1])\n\n    with pytest.raises(exc.TypeError):\n        b.crypto_kx_client_session_keys(c_keys[0], c_keys[1], s_keys[0][:-1])\n", "tests/test_generichash.py": "# Copyright 2016 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport binascii\nimport copy\nimport json\nimport os\nfrom typing import AnyStr, Dict, List, Tuple, Union\n\nimport pytest\n\nimport nacl.encoding\nimport nacl.exceptions as exc\nimport nacl.hash\nimport nacl.hashlib\n\nfrom .utils import read_crypto_test_vectors\n\n\nOVERLONG_PARAMS_VECTORS = [\n    (b\"key\", 65 * b\"\\xaa\", 16 * b\"\\xaa\", 16 * b\"\\x55\", 64, b\"will raise\"),\n    (b\"salt\", b\"key\", 17 * b\"\\xaa\", 16 * b\"\\x55\", 64, b\"will raise\"),\n    (b\"personal\", b\"key\", 16 * b\"\\xaa\", 17 * b\"\\x55\", 64, b\"will raise\"),\n    (b\"digest_size\", b\"key\", 16 * b\"\\xaa\", 16 * b\"\\x55\", 65, b\"will raise\"),\n]\n\n\ndef generichash_vectors() -> List[Tuple[bytes, bytes, bytes, bytes]]:\n    # Format: <message> <tab> <key> <tab> <output length> <tab> <output>\n    DATA = \"crypto-test-vectors-blake2-nosalt-nopersonalization.txt\"\n    # Type safety: read_crypto_test_vectors returns an arbitrary length tuple, but we\n    # know this file's test entries contain exactly four fields.\n    return read_crypto_test_vectors(DATA, delimiter=b\"\\t\")  # type: ignore[return-value]\n\n\ndef blake2_salt_pers_vectors() -> (\n    List[Tuple[bytes, bytes, bytes, bytes, bytes, bytes]]\n):\n    # Format: <message> <tab> <key> <tab> <salt> <tab>\n    # <personalization> <tab> <output length> <tab> <output>\n    DATA = \"crypto-test-vectors-blake2-salt-personalization.txt\"\n    # Type safety: read_crypto_test_vectors returns an arbitrary length tuple, but we\n    # know this file's test entries contain exactly six fields.\n    return read_crypto_test_vectors(DATA, delimiter=b\"\\t\")  # type: ignore[return-value]\n\n\ndef blake2_reference_vectors() -> List[Tuple[str, str, int, str]]:\n    DATA = \"blake2-kat.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    jvectors: List[Dict[str, str]] = json.load(open(path))\n    vectors = [\n        (x[\"in\"], x[\"key\"], len(x[\"out\"]) // 2, x[\"out\"])\n        for x in jvectors\n        if x[\"hash\"] == \"blake2b\"\n    ]\n    return vectors\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"outlen\", \"output\"], generichash_vectors()\n)\ndef test_generichash(\n    message: AnyStr, key: AnyStr, outlen: Union[AnyStr, int], output: AnyStr\n):\n    msg = binascii.unhexlify(message)\n    output_bytes = binascii.hexlify(binascii.unhexlify(output))\n    k = binascii.unhexlify(key)\n    outlen_parsed = int(outlen)\n    out = nacl.hash.generichash(msg, digest_size=outlen_parsed, key=k)\n    assert out == output_bytes\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"salt\", \"person\", \"outlen\", \"output\"],\n    OVERLONG_PARAMS_VECTORS,\n)\ndef test_overlong_blake2b_oneshot_params(\n    message: bytes,\n    key: bytes,\n    salt: bytes,\n    person: bytes,\n    outlen: int,\n    output: bytes,\n):\n    with pytest.raises(exc.ValueError):\n        nacl.hash.blake2b(\n            message, digest_size=outlen, key=key, salt=salt, person=person\n        )\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"outlen\", \"output\"], blake2_reference_vectors()\n)\ndef test_generichash_blake2_ref(\n    message: str, key: str, outlen: int, output: str\n):\n    test_generichash(message, key, outlen, output)\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"salt\", \"person\", \"outlen\", \"output\"],\n    blake2_salt_pers_vectors(),\n)\ndef test_hash_blake2b(\n    message: bytes,\n    key: bytes,\n    salt: bytes,\n    person: bytes,\n    outlen: bytes,\n    output: bytes,\n):\n    msg = binascii.unhexlify(message)\n    output = binascii.hexlify(binascii.unhexlify(output))\n    k = binascii.unhexlify(key)\n    slt = binascii.unhexlify(salt)\n    pers = binascii.unhexlify(person)\n    outlen_parsed = int(outlen)\n    out = nacl.hash.blake2b(\n        msg, digest_size=outlen_parsed, key=k, salt=slt, person=pers\n    )\n    assert out == output\n\n\ndef test_expected_hashlib_level_pickle_and_copy_failures():\n    h = nacl.hashlib.blake2b()\n    with pytest.raises(TypeError):\n        copy.deepcopy(h)\n    with pytest.raises(TypeError):\n        copy.copy(h)\n\n\ndef test_expected_bindings_level_pickle_and_copy_failures():\n    from nacl.bindings.crypto_generichash import (\n        Blake2State,\n        crypto_generichash_BYTES,\n    )\n\n    st = Blake2State(crypto_generichash_BYTES)\n    with pytest.raises(TypeError):\n        copy.deepcopy(st)\n    with pytest.raises(TypeError):\n        copy.copy(st)\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"outlen\", \"output\"], blake2_reference_vectors()\n)\ndef test_hashlib_blake2_ref_vectors(\n    message: str, key: str, outlen: int, output: str\n):\n    msg = binascii.unhexlify(message)\n    k = binascii.unhexlify(key)\n    outlen = int(outlen)\n    out = binascii.unhexlify(output)\n    h = nacl.hashlib.blake2b(msg, digest_size=outlen, key=k)\n    dgst = h.digest()\n    assert out == dgst\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"outlen\", \"output\"], blake2_reference_vectors()\n)\ndef test_hashlib_blake2_iuf_ref_vectors(\n    message: str, key: str, outlen: int, output: str\n):\n    msg = binascii.unhexlify(message)\n    k = binascii.unhexlify(key)\n    outlen = int(outlen)\n    out = binascii.unhexlify(output)\n    h = nacl.hashlib.blake2b(digest_size=outlen, key=k)\n    for _pos in range(len(msg)):\n        _end = _pos + 1\n        h.update(bytes(msg[_pos:_end]))\n    dgst = h.digest()\n    hdgst = h.hexdigest()\n    assert hdgst == output\n    assert out == dgst\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"outlen\", \"output\"], blake2_reference_vectors()\n)\ndef test_hashlib_blake2_iuf_cp_ref_vectors(\n    message: str, key: str, outlen: int, output: str\n):\n    msg = binascii.unhexlify(message)\n    msglen = len(msg)\n    if msglen < 2:\n        pytest.skip(\"Message too short for splitting\")\n    k = binascii.unhexlify(key)\n    outlen = int(outlen)\n    out = binascii.unhexlify(output)\n    h = nacl.hashlib.blake2b(digest_size=outlen, key=k)\n    for _pos in range(len(msg)):\n        _end = _pos + 1\n        h.update(bytes(msg[_pos:_end]))\n        if _end == msglen // 2:\n            h2 = h.copy()\n    dgst = h.digest()\n    d2 = h2.digest()\n    assert out == dgst\n    assert d2 != dgst\n\n\n@pytest.mark.parametrize(\n    [\"message\", \"key\", \"salt\", \"person\", \"outlen\", \"output\"],\n    OVERLONG_PARAMS_VECTORS,\n)\ndef test_overlong_blake2b_iuf_params(\n    message: bytes,\n    key: bytes,\n    salt: bytes,\n    person: bytes,\n    outlen: int,\n    output: bytes,\n):\n    with pytest.raises(exc.ValueError):\n        nacl.hashlib.blake2b(\n            message, digest_size=outlen, key=key, salt=salt, person=person\n        )\n\n\ndef test_blake2_descriptors_presence():\n    h = nacl.hashlib.blake2b()\n    assert h.name == \"blake2b\"\n    assert h.block_size == 128\n    assert h.digest_size == 32  # this is the default digest_size\n\n\ndef test_blake2_digest_size_descriptor_coherence():\n    h = nacl.hashlib.blake2b(digest_size=64)\n    assert h.name == \"blake2b\"\n    assert h.block_size == 128\n    assert h.digest_size == 64\n", "tests/__init__.py": "", "tests/test_pwhash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport binascii\nimport json\nimport os\nimport sys\nimport unicodedata as ud\nfrom typing import List, Tuple\n\nfrom hypothesis import given, settings\nfrom hypothesis.strategies import integers, text\n\nimport pytest\n\nimport nacl.bindings\nimport nacl.encoding\nimport nacl.exceptions as exc\nimport nacl.pwhash\n\n_all_unicode = \"\".join(chr(i) for i in range(sys.maxunicode))\nPASSWD_CHARS = \"\".join(\n    c\n    for c in _all_unicode\n    if (\n        ud.category(c).startswith(\"L\")\n        or ud.category(c).startswith(\"N\")\n        or ud.category(c) == \"Zs\"\n    )\n)\n# Select Letters, number representations and spacing characters\n\n\ndef argon2i_modular_crypt_ref() -> List[Tuple[str, str]]:\n    DATA = \"modular_crypt_argon2i_hashes.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    jvectors = json.load(open(path))\n    vectors = [\n        (x[\"pwhash\"], x[\"passwd\"]) for x in jvectors if x[\"mode\"] == \"crypt\"\n    ]\n    return vectors\n\n\ndef argon2i_raw_ref() -> List[Tuple[int, str, str, int, int, str]]:\n    DATA = \"raw_argon2i_hashes.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    jvectors = json.load(open(path))\n    vectors = [\n        (\n            x[\"dgst_len\"],\n            x[\"passwd\"],\n            x[\"salt\"],\n            x[\"iters\"],\n            x[\"maxmem\"],\n            x[\"pwhash\"],\n        )\n        for x in jvectors\n        if x[\"mode\"] == \"raw\"\n    ]\n    return vectors\n\n\ndef argon2id_modular_crypt_ref() -> List[Tuple[str, str]]:\n    DATA = \"modular_crypt_argon2id_hashes.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    jvectors = json.load(open(path))\n    vectors = [\n        (x[\"pwhash\"], x[\"passwd\"])\n        for x in jvectors\n        if (x[\"mode\"] == \"crypt\" and x[\"construct\"] == \"argon2id\")\n    ]\n    return vectors\n\n\ndef argon2id_raw_ref() -> List[Tuple[int, str, str, int, int, str]]:\n    DATA = \"raw_argon2id_hashes.json\"\n    path = os.path.join(os.path.dirname(__file__), \"data\", DATA)\n    jvectors = json.load(open(path))\n    vectors = [\n        (\n            x[\"dgst_len\"],\n            x[\"passwd\"],\n            x[\"salt\"],\n            x[\"iters\"],\n            x[\"maxmem\"],\n            x[\"pwhash\"],\n        )\n        for x in jvectors\n        if (x[\"mode\"] == \"raw\" and x[\"construct\"] == \"argon2id\")\n    ]\n    return vectors\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\", \"expected\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9b63d97\",\n            20000,\n            (2**20) * 100,\n            (\n                b\"\\x10e>\\xc8A8\\x11\\xde\\x07\\xf1\\x0f\\x98\"\n                b\"EG\\xe6}V]\\xd4yN\\xae\\xd3P\\x87yP\\x1b\\xc7+n*\"\n            ),\n        ),\n    ],\n)\ndef test_kdf_scryptsalsa208sha256(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int,\n    memlimit: int,\n    expected: bytes,\n):\n    res = nacl.pwhash.kdf_scryptsalsa208sha256(\n        size, password, salt, opslimit, memlimit\n    )\n    assert res == expected\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scryptsalsa208sha256_random(password: bytes):\n    h1 = nacl.pwhash.scryptsalsa208sha256_str(password)\n    h2 = nacl.pwhash.scryptsalsa208sha256_str(password)\n    assert h1 != h2\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scryptsalsa208sha256_verify(password: bytes):\n    assert nacl.pwhash.verify_scryptsalsa208sha256(\n        nacl.pwhash.scryptsalsa208sha256_str(password), password\n    )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scryptsalsa208sha256_verify_incorrect(password: bytes):\n    with pytest.raises(exc.InvalidkeyError):\n        nacl.pwhash.verify_scryptsalsa208sha256(\n            nacl.pwhash.scryptsalsa208sha256_str(password),\n            password.replace(b\"dog\", b\"cat\"),\n        )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9\",\n            20000,\n            (2**20) * 100,\n        ),\n    ],\n)\ndef test_wrong_salt_length(\n    size: int, password: bytes, salt: bytes, opslimit: int, memlimit: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.kdf_scryptsalsa208sha256(\n            size, password, salt, opslimit, memlimit\n        )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"passwd_hash\", \"password\"),\n    [\n        (\n            b\"Too short (and wrong) hash\",\n            b\"a password\",\n        )\n    ],\n)\ndef test_wrong_hash_length(passwd_hash: bytes, password: bytes):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.verify_scryptsalsa208sha256(passwd_hash, password)\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9b6\",\n            20000,\n            (2**20) * 100,\n        ),\n    ],\n)\ndef test_kdf_wrong_salt_length(\n    size: int, password: bytes, salt: bytes, opslimit: int, memlimit: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.kdf_scryptsalsa208sha256(\n            size, password, salt, opslimit, memlimit\n        )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"passwd_hash\", \"password\"),\n    [\n        (\n            b\"Too short (and wrong) hash\",\n            b\"another password\",\n        )\n    ],\n)\ndef test_str_verify_wrong_hash_length(passwd_hash: bytes, password: bytes):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.verify_scryptsalsa208sha256(passwd_hash, password)\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\", \"expected\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9b63d97\",\n            20000,\n            (2**20) * 100,\n            (\n                b\"\\x10e>\\xc8A8\\x11\\xde\\x07\\xf1\\x0f\\x98\"\n                b\"EG\\xe6}V]\\xd4yN\\xae\\xd3P\\x87yP\\x1b\\xc7+n*\"\n            ),\n        ),\n    ],\n)\ndef test_scrypt_kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int,\n    memlimit: int,\n    expected: bytes,\n):\n    res = nacl.pwhash.scrypt.kdf(size, password, salt, opslimit, memlimit)\n    assert res == expected\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scrypt_random(password: bytes):\n    h1 = nacl.pwhash.scrypt.str(password)\n    h2 = nacl.pwhash.scrypt.str(password)\n    assert h1 != h2\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scrypt_verify(password: bytes):\n    assert nacl.pwhash.scrypt.verify(\n        nacl.pwhash.scrypt.str(password), password\n    )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"password\",), [(b\"The quick brown fox jumps over the lazy dog.\",)]\n)\ndef test_scrypt_verify_incorrect(password: bytes):\n    with pytest.raises(exc.InvalidkeyError):\n        nacl.pwhash.scrypt.verify(\n            nacl.pwhash.scrypt.str(password), password.replace(b\"dog\", b\"cat\")\n        )\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9\",\n            20000,\n            (2**20) * 100,\n        ),\n    ],\n)\ndef test_wrong_scrypt_salt_length(\n    size: int, password: bytes, salt: bytes, opslimit: int, memlimit: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.scrypt.kdf(size, password, salt, opslimit, memlimit)\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"passwd_hash\", \"password\"),\n    [\n        (\n            b\"Too short (and wrong) hash\",\n            b\"a password\",\n        )\n    ],\n)\ndef test_wrong_scrypt_hash_length(passwd_hash: bytes, password: bytes):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.scrypt.verify(passwd_hash, password)\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"size\", \"password\", \"salt\", \"opslimit\", \"memlimit\"),\n    [\n        (\n            32,\n            b\"The quick brown fox jumps over the lazy dog.\",\n            b\"ef537f25c895bfa782526529a9b6\",\n            20000,\n            (2**20) * 100,\n        ),\n    ],\n)\ndef test_scrypt_kdf_wrong_salt_length(\n    size: int, password: bytes, salt: bytes, opslimit: int, memlimit: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.scrypt.kdf(size, password, salt, opslimit, memlimit)\n\n\n@pytest.mark.parametrize(\n    (\"opslimit\", \"memlimit\", \"n\", \"r\", \"p\"),\n    [\n        (32768, 2 * (2**20), 10, 8, 1),\n        (32768, 8 * (2**10), 3, 8, 128),\n        (65536, (2**20) * 2, 11, 8, 1),\n        (262144, (2**20) * 2, 11, 8, 4),\n        (2 * (2**20), 2 * (2**20), 11, 8, 32),\n    ],\n)\ndef test_variable_limits(opslimit: int, memlimit: int, n: int, r: int, p: int):\n    rn, rr, rp = nacl.bindings.nacl_bindings_pick_scrypt_params(\n        opslimit, memlimit\n    )\n    assert rn == n\n    assert rr == r\n    assert rp == p\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@pytest.mark.parametrize(\n    (\"passwd_hash\", \"password\"),\n    [\n        (\n            b\"Too short (and wrong) hash\",\n            b\"another password\",\n        )\n    ],\n)\ndef test_scrypt_str_verify_wrong_hash_length(\n    passwd_hash: bytes, password: bytes\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.scrypt.verify(passwd_hash, password)\n\n\n@pytest.mark.parametrize(\n    (\"password_hash\", \"password\"),\n    argon2i_modular_crypt_ref() + argon2id_modular_crypt_ref(),\n)\ndef test_str_verify_argon2_ref(password_hash: str, password: str):\n    pw_hash = password_hash.encode(\"ascii\")\n    pw = password.encode(\"ascii\")\n    res = nacl.pwhash.argon2id.verify(pw_hash, pw)\n    assert res is True\n\n\n@pytest.mark.parametrize(\n    (\"password_hash\", \"password\"),\n    argon2i_modular_crypt_ref() + argon2id_modular_crypt_ref(),\n)\ndef test_str_verify_argon2_ref_fail(password_hash: str, password: str):\n    pw_hash = password_hash.encode(\"ascii\")\n    pw = (\"a\" + password).encode(\"ascii\")\n    with pytest.raises(exc.InvalidkeyError):\n        nacl.pwhash.argon2id.verify(pw_hash, pw)\n\n\n@given(\n    text(alphabet=PASSWD_CHARS, min_size=5, max_size=20),\n    integers(min_value=4, max_value=6),\n    integers(min_value=1024 * 1024, max_value=16 * 1024 * 1024),\n)\n@settings(deadline=None, max_examples=20)\ndef test_argon2i_str_and_verify(password: str, ops: int, mem: int):\n    _psw = password.encode(\"utf-8\")\n    pw_hash = nacl.pwhash.argon2i.str(_psw, opslimit=ops, memlimit=mem)\n    res = nacl.pwhash.argon2i.verify(pw_hash, _psw)\n    assert res is True\n\n\n@given(\n    text(alphabet=PASSWD_CHARS, min_size=5, max_size=20),\n    integers(min_value=1, max_value=4),\n    integers(min_value=1024 * 1024, max_value=16 * 1024 * 1024),\n)\n@settings(deadline=None, max_examples=20)\ndef test_argon2id_str_and_verify(password: str, ops: int, mem: int):\n    _psw = password.encode(\"utf-8\")\n    pw_hash = nacl.pwhash.argon2id.str(_psw, opslimit=ops, memlimit=mem)\n    res = nacl.pwhash.argon2id.verify(pw_hash, _psw)\n    assert res is True\n\n\n@given(\n    text(alphabet=PASSWD_CHARS, min_size=5, max_size=20),\n    integers(min_value=4, max_value=6),\n    integers(min_value=1024 * 1024, max_value=16 * 1024 * 1024),\n)\n@settings(deadline=None, max_examples=20)\ndef test_argon2i_str_and_verify_fail(password: str, ops: int, mem: int):\n    _psw = password.encode(\"utf-8\")\n    pw_hash = nacl.pwhash.argon2i.str(_psw, opslimit=ops, memlimit=mem)\n    with pytest.raises(exc.InvalidkeyError):\n        nacl.pwhash.argon2i.verify(pw_hash, b\"A\" + _psw)\n\n\n@given(text(alphabet=PASSWD_CHARS, min_size=5, max_size=20))\n@settings(deadline=None, max_examples=5)\ndef test_pwhash_str_and_verify(password: str):\n    _psw = password.encode(\"utf-8\")\n\n    a2i_hash = nacl.pwhash.argon2i.str(\n        _psw,\n        opslimit=nacl.pwhash.argon2i.OPSLIMIT_INTERACTIVE,\n        memlimit=nacl.pwhash.argon2i.MEMLIMIT_INTERACTIVE,\n    )\n    a2i_res = nacl.pwhash.verify(a2i_hash, _psw)\n    assert a2i_res is True\n\n    a2id_hash = nacl.pwhash.argon2id.str(\n        _psw,\n        opslimit=nacl.pwhash.argon2id.OPSLIMIT_INTERACTIVE,\n        memlimit=nacl.pwhash.argon2id.MEMLIMIT_INTERACTIVE,\n    )\n    a2id_res = nacl.pwhash.verify(a2id_hash, _psw)\n    assert a2id_res is True\n\n\n@pytest.mark.skipif(\n    not nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires full build of libsodium\"\n)\n@given(text(alphabet=PASSWD_CHARS, min_size=5, max_size=20))\n@settings(deadline=None, max_examples=5)\ndef test_pwhash_scrypt_str_and_verify(password: str):\n    _psw = password.encode(\"utf-8\")\n\n    scrypt_hash = nacl.pwhash.scrypt.str(\n        _psw,\n        opslimit=nacl.pwhash.scrypt.OPSLIMIT_INTERACTIVE,\n        memlimit=nacl.pwhash.scrypt.MEMLIMIT_INTERACTIVE,\n    )\n    scrypt_res = nacl.pwhash.verify(scrypt_hash, _psw)\n    assert scrypt_res is True\n\n\ndef test_invalid_modular_scrypt_prefix():\n    psw = b\"always invalid password\"\n    invalid_modular_hash = b\"$invalid_prefix$\"\n    with pytest.raises(exc.InvalidkeyError):\n        nacl.pwhash.verify(invalid_modular_hash, psw)\n\n\ndef test_crypt_prefix_error():\n    psw = b\"always invalid password\"\n    invalid_modular_hash = b\"$invalid_prefix$\"\n    with pytest.raises(exc.CryptPrefixError):\n        nacl.pwhash.verify(invalid_modular_hash, psw)\n\n\n@pytest.mark.parametrize(\n    (\"dk_size\", \"password\", \"salt\", \"iters\", \"mem_kb\", \"pwhash\"),\n    argon2i_raw_ref(),\n)\ndef test_argon2i_kdf(\n    dk_size: int,\n    password: str,\n    salt: str,\n    iters: int,\n    mem_kb: int,\n    pwhash: str,\n):\n    dk = nacl.pwhash.argon2i.kdf(\n        dk_size,\n        password.encode(\"utf-8\"),\n        salt.encode(\"utf-8\"),\n        iters,\n        1024 * mem_kb,\n    )\n    ref = binascii.unhexlify(pwhash)\n    assert dk == ref\n\n\n@pytest.mark.parametrize(\n    (\"dk_size\", \"password\", \"salt\", \"iters\", \"mem_kb\", \"pwhash\"),\n    argon2id_raw_ref(),\n)\ndef test_argon2_kdf_alg_argon2id(\n    dk_size: int,\n    password: str,\n    salt: str,\n    iters: int,\n    mem_kb: int,\n    pwhash: str,\n):\n    dk = nacl.pwhash.argon2id.kdf(\n        dk_size,\n        password.encode(\"utf-8\"),\n        salt.encode(\"utf-8\"),\n        iters,\n        1024 * mem_kb,\n    )\n    ref = binascii.unhexlify(pwhash)\n    assert dk == ref\n\n\nraising_argon2_parameters = [\n    #  wrong salt length:\n    (20, \"aPassword\", 3 * \"salt\", 3, 256),\n    #  too short output:\n    (15, \"aPassword\", 4 * \"salt\", 4, 256),\n    #  too long output:\n    (0xFFFFFFFF + 1, \"aPassword\", 4 * \"salt\", 4, 256),\n    #  too high iteration count:\n    (20, \"aPassword\", 4 * \"salt\", 0xFFFFFFFF + 1, 256),\n    #  too low memory usage:\n    (20, \"aPassword\", 4 * \"salt\", 4, 2),\n    #  too high memory usage:\n    (20, \"aPassword\", 4 * \"salt\", 4, 0xFFFFFFFF + 1),\n]\n\n\n@pytest.mark.parametrize(\n    (\"dk_size\", \"password\", \"salt\", \"iters\", \"mem_kb\"),\n    raising_argon2_parameters\n    + [\n        #  too low iteration count:\n        (20, \"aPassword\", 4 * \"salt\", 1, 256),\n    ],\n)\ndef test_argon2i_kdf_invalid_parms(\n    dk_size: int, password: str, salt: str, iters: int, mem_kb: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.argon2i.kdf(\n            dk_size,\n            password.encode(\"utf-8\"),\n            salt.encode(\"utf-8\"),\n            iters,\n            1024 * mem_kb,\n        )\n\n\n@pytest.mark.parametrize(\n    (\"dk_size\", \"password\", \"salt\", \"iters\", \"mem_kb\"),\n    raising_argon2_parameters\n    + [\n        #  too low iteration count:\n        (20, \"aPassword\", 4 * \"salt\", 0, 256),\n    ],\n)\ndef test_argon2id_kdf_invalid_parms(\n    dk_size: int, password: str, salt: str, iters: int, mem_kb: int\n):\n    with pytest.raises(exc.ValueError):\n        nacl.pwhash.argon2id.kdf(\n            dk_size,\n            password.encode(\"utf-8\"),\n            salt.encode(\"utf-8\"),\n            iters,\n            1024 * mem_kb,\n        )\n\n\ndef test_check_limits_for_unknown_algorithm():\n    from nacl.bindings.crypto_pwhash import _check_argon2_limits_alg\n\n    with pytest.raises(exc.TypeError):\n        _check_argon2_limits_alg(4, 1024, -1)\n\n\n@pytest.mark.skipif(\n    nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires minimal build of libsodium\"\n)\ndef test_scryptsalsa208sha256_unavailable():\n    empty = b\"\"\n\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.kdf_scryptsalsa208sha256(0, empty, empty)\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.scryptsalsa208sha256_str(empty)\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.verify_scryptsalsa208sha256(empty, empty)\n\n\n@pytest.mark.skipif(\n    nacl.pwhash.scrypt.AVAILABLE, reason=\"Requires minimal build of libsodium\"\n)\ndef test_scrypt_unavailable():\n    empty = b\"\"\n\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.scrypt.kdf(0, empty, empty)\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.scrypt.str(empty)\n    with pytest.raises(exc.UnavailableError):\n        nacl.pwhash.scrypt.verify(empty, empty)\n", "tests/test_box.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport binascii\n\nimport pytest\n\nfrom nacl.encoding import HexEncoder\nfrom nacl.exceptions import CryptoError\nfrom nacl.public import Box, PrivateKey, PublicKey\nfrom nacl.utils import random\n\nfrom .test_bindings import _box_from_seed_vectors\nfrom .utils import check_type_error\n\nVECTORS = [\n    # privalice, pubalice, privbob, pubbob, nonce, plaintext, ciphertext\n    (\n        b\"77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\",\n        b\"8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\",\n        b\"5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\",\n        b\"de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\",\n        b\"69696ee955b62b73cd62bda875fc73d68219e0036b7a0b37\",\n        (\n            b\"be075fc53c81f2d5cf141316ebeb0c7b5228c52a4c62cbd44b66849b64244ffce5e\"\n            b\"cbaaf33bd751a1ac728d45e6c61296cdc3c01233561f41db66cce314adb310e3be8\"\n            b\"250c46f06dceea3a7fa1348057e2f6556ad6b1318a024a838f21af1fde048977eb4\"\n            b\"8f59ffd4924ca1c60902e52f0a089bc76897040e082f937763848645e0705\"\n        ),\n        (\n            b\"f3ffc7703f9400e52a7dfb4b3d3305d98e993b9f48681273c29650ba32fc76ce483\"\n            b\"32ea7164d96a4476fb8c531a1186ac0dfc17c98dce87b4da7f011ec48c97271d2c2\"\n            b\"0f9b928fe2270d6fb863d51738b48eeee314a7cc8ab932164548e526ae902243685\"\n            b\"17acfeabd6bb3732bc0e9da99832b61ca01b6de56244a9e88d5f9b37973f622a43d\"\n            b\"14a6599b1f654cb45a74e355a5\"\n        ),\n    ),\n]\n\n\ndef test_generate_private_key():\n    PrivateKey.generate()\n\n\ndef test_generate_private_key_from_random_seed():\n    PrivateKey.from_seed(random(PrivateKey.SEED_SIZE))\n\n\n@pytest.mark.parametrize(\n    (\"seed\", \"public_key\", \"secret_key\"), _box_from_seed_vectors()\n)\ndef test_generate_private_key_from_seed(\n    seed: bytes, public_key: bytes, secret_key: bytes\n):\n    prvt = PrivateKey.from_seed(seed, encoder=HexEncoder)\n    sk = binascii.unhexlify(secret_key)\n    pk = binascii.unhexlify(public_key)\n    assert bytes(prvt) == sk\n    assert bytes(prvt.public_key) == pk\n\n\ndef test_box_creation():\n    pub = PublicKey(\n        b\"ec2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    priv = PrivateKey(\n        b\"5c2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    Box(priv, pub)\n\n\ndef test_box_decode():\n    pub = PublicKey(\n        b\"ec2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    priv = PrivateKey(\n        b\"5c2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    b1 = Box(priv, pub)\n    b2 = Box.decode(b1._shared_key)\n    assert b1._shared_key == b2._shared_key\n\n\ndef test_box_bytes():\n    pub = PublicKey(\n        b\"ec2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    priv = PrivateKey(\n        b\"5c2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    b = Box(priv, pub)\n    assert bytes(b) == b._shared_key\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_encryption(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubalice_decoded = PublicKey(pubalice, encoder=HexEncoder)\n    privbob_decoded = PrivateKey(privbob, encoder=HexEncoder)\n\n    box = Box(privbob_decoded, pubalice_decoded)\n    encrypted = box.encrypt(\n        binascii.unhexlify(plaintext),\n        binascii.unhexlify(nonce),\n        encoder=HexEncoder,\n    )\n\n    expected = binascii.hexlify(\n        binascii.unhexlify(nonce) + binascii.unhexlify(ciphertext),\n    )\n\n    assert encrypted == expected\n    assert encrypted.nonce == nonce\n    assert encrypted.ciphertext == ciphertext\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_decryption(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubbob_decoded = PublicKey(pubbob, encoder=HexEncoder)\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = Box(privalice_decoded, pubbob_decoded)\n\n    nonce = binascii.unhexlify(nonce)\n    decrypted = binascii.hexlify(\n        box.decrypt(ciphertext, nonce, encoder=HexEncoder),\n    )\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_decryption_combined(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubbob_decoded = PublicKey(pubbob, encoder=HexEncoder)\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = Box(privalice_decoded, pubbob_decoded)\n\n    combined = binascii.hexlify(\n        binascii.unhexlify(nonce) + binascii.unhexlify(ciphertext),\n    )\n    decrypted = binascii.hexlify(box.decrypt(combined, encoder=HexEncoder))\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_optional_nonce(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubbob_decoded = PublicKey(pubbob, encoder=HexEncoder)\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = Box(privalice_decoded, pubbob_decoded)\n\n    encrypted = box.encrypt(binascii.unhexlify(plaintext), encoder=HexEncoder)\n\n    decrypted = binascii.hexlify(box.decrypt(encrypted, encoder=HexEncoder))\n\n    assert decrypted == plaintext\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_encryption_generates_different_nonces(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubbob_decoded = PublicKey(pubbob, encoder=HexEncoder)\n    privalice_decoded = PrivateKey(privalice, encoder=HexEncoder)\n\n    box = Box(privalice_decoded, pubbob_decoded)\n\n    nonce_0 = box.encrypt(\n        binascii.unhexlify(plaintext), encoder=HexEncoder\n    ).nonce\n\n    nonce_1 = box.encrypt(\n        binascii.unhexlify(plaintext), encoder=HexEncoder\n    ).nonce\n\n    assert nonce_0 != nonce_1\n\n\n@pytest.mark.parametrize(\n    (\n        \"privalice\",\n        \"pubalice\",\n        \"privbob\",\n        \"pubbob\",\n        \"nonce\",\n        \"plaintext\",\n        \"ciphertext\",\n    ),\n    VECTORS,\n)\ndef test_box_failed_decryption(\n    privalice: bytes,\n    pubalice: bytes,\n    privbob: bytes,\n    pubbob: bytes,\n    nonce: bytes,\n    plaintext: bytes,\n    ciphertext: bytes,\n):\n    pubbob_decoded = PublicKey(pubbob, encoder=HexEncoder)\n    privbob_decoded = PrivateKey(privbob, encoder=HexEncoder)\n\n    # this cannot decrypt the ciphertext! the ciphertext must be decrypted by\n    # (privalice, pubbob) or (privbob, pubalice)\n    box = Box(privbob_decoded, pubbob_decoded)\n\n    with pytest.raises(CryptoError):\n        box.decrypt(ciphertext, binascii.unhexlify(nonce), encoder=HexEncoder)\n\n\ndef test_box_wrong_length():\n    with pytest.raises(ValueError):\n        PublicKey(b\"\")\n    # TODO: should the below raise a ValueError?\n    with pytest.raises(TypeError):\n        PrivateKey(b\"\")\n\n    pub = PublicKey(\n        b\"ec2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    priv = PrivateKey(\n        b\"5c2bee2d5be613ca82e377c96a0bf2220d823ce980cdff6279473edc52862798\",\n        encoder=HexEncoder,\n    )\n    b = Box(priv, pub)\n    with pytest.raises(ValueError):\n        b.encrypt(b\"\", b\"\")\n    with pytest.raises(ValueError):\n        b.decrypt(b\"\", b\"\")\n\n\ndef test_wrong_types():\n    priv = PrivateKey.generate()\n\n    check_type_error(\n        (\"PrivateKey must be created from a 32 bytes long raw secret key\"),\n        PrivateKey,\n        12,\n    )\n    check_type_error(\n        (\"PrivateKey must be created from a 32 bytes long raw secret key\"),\n        PrivateKey,\n        priv,\n    )\n    check_type_error(\n        (\"PrivateKey must be created from a 32 bytes long raw secret key\"),\n        PrivateKey,\n        priv.public_key,\n    )\n\n    check_type_error(\"PublicKey must be created from 32 bytes\", PublicKey, 13)\n    check_type_error(\n        \"PublicKey must be created from 32 bytes\", PublicKey, priv\n    )\n    check_type_error(\n        \"PublicKey must be created from 32 bytes\", PublicKey, priv.public_key\n    )\n\n    check_type_error(\n        \"Box must be created from a PrivateKey and a PublicKey\",\n        Box,\n        priv,\n        \"not a public key\",\n    )\n    check_type_error(\n        \"Box must be created from a PrivateKey and a PublicKey\",\n        Box,\n        priv.encode(),\n        priv.public_key.encode(),\n    )\n    check_type_error(\n        \"Box must be created from a PrivateKey and a PublicKey\",\n        Box,\n        priv,\n        priv.public_key.encode(),\n    )\n    check_type_error(\n        \"Box must be created from a PrivateKey and a PublicKey\",\n        Box,\n        priv.encode(),\n        priv.public_key,\n    )\n\n    check_type_error(\n        \"seed must be a 32 bytes long\", PrivateKey.from_seed, b\"1\"\n    )\n", "tests/test_utils.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport pytest\n\nimport nacl.secret\nimport nacl.utils\n\n\ndef test_random_bytes_produces():\n    assert len(nacl.utils.random(16)) == 16\n\n\ndef test_random_bytes_produces_different_bytes():\n    assert nacl.utils.random(16) != nacl.utils.random(16)\n\n\ndef test_string_fixer():\n    assert str(nacl.secret.SecretBox(b\"\\x00\" * 32)) == str(b\"\\x00\" * 32)\n\n\ndef test_deterministic_random_bytes():\n    expected = (\n        b\"0d8e6cc68715648926732e7ea73250cfaf2d58422083904c841a8ba\"\n        b\"33b986111f346ba50723a68ae283524a6bded09f83be6b80595856f\"\n        b\"72e25b86918e8b114bafb94bc8abedd73daab454576b7c5833eb0bf\"\n        b\"982a1bb4587a5c970ff0810ca3b791d7e12\"\n    )\n    seed = (\n        b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\"\n        b\"\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\"\n        b\"\\x1c\\x1d\\x1e\\x1f\"\n    )\n    assert (\n        nacl.utils.randombytes_deterministic(\n            100, seed, encoder=nacl.encoding.HexEncoder\n        )\n        == expected\n    )\n\n\ndef test_deterministic_random_bytes_invalid_seed_length():\n    expected = \"Deterministic random bytes must be generated from 32 bytes\"\n    seed = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\"\n    with pytest.raises(TypeError) as e:\n        nacl.utils.randombytes_deterministic(100, seed)\n    assert expected in str(e.value)\n", "src/libsodium/regen-msvc/regen-msvc.py": "#! /usr/bin/env python3\n\nimport glob\nimport os\nimport uuid\n\ndirs = set()\n\ntlv1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlv1 = tlv1 + '    <ClCompile Include=\"..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\ntlv2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlv2 = tlv2 + '    <ClInclude Include=\"..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\ntlf1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlf1 = tlf1 + '    <ClCompile Include=\"..\\\\..\\\\{}\">\\r\\n'.format(file)\n    tlf1 = tlf1 + \"      <Filter>Source Files</Filter>\\r\\n\"\n    tlf1 = tlf1 + \"    </ClCompile>\\r\\n\"\n\ntlf2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlf2 = tlf2 + '    <ClInclude Include=\"..\\\\..\\\\{}\">\\r\\n'.format(file)\n    tlf2 = tlf2 + \"      <Filter>Header Files</Filter>\\r\\n\"\n    tlf2 = tlf2 + \"    </ClInclude>\\r\\n\"\n\nv1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    v1 = v1 + '    <ClCompile Include=\"..\\\\..\\\\..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\nv2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    v2 = v2 + '    <ClInclude Include=\"..\\\\..\\\\..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\nf1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    basedir = os.path.dirname(file).replace(\"src/libsodium/\", \"\")\n    t = basedir\n    while t != \"\":\n        dirs.add(t)\n        t = os.path.dirname(t)\n    basedir = basedir.replace(\"/\", \"\\\\\")\n    file = file.replace(\"/\", \"\\\\\")\n    f1 = f1 + '    <ClCompile Include=\"..\\\\..\\\\..\\\\..\\\\{}\">\\r\\n'.format(file)\n    f1 = f1 + \"      <Filter>{}</Filter>\\r\\n\".format(basedir)\n    f1 = f1 + \"    </ClCompile>\\r\\n\"\n\nf2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    basedir = os.path.dirname(file).replace(\"src/libsodium/\", \"\")\n    t = basedir\n    while t != \"\":\n        dirs.add(t)\n        t = os.path.dirname(t)\n    basedir = basedir.replace(\"/\", \"\\\\\")\n    file = file.replace(\"/\", \"\\\\\")\n    f2 = f2 + '    <ClInclude Include=\"..\\\\..\\\\..\\\\..\\\\{}\">\\r\\n'.format(file)\n    f2 = f2 + \"      <Filter>{}</Filter>\\r\\n\".format(basedir)\n    f2 = f2 + \"    </ClInclude>\\r\\n\"\n\nfd = \"\"\ndirs = list(dirs)\ndirs.sort()\nfor dir in dirs:\n    dir = dir.replace(\"/\", \"\\\\\")\n    uid = uuid.uuid3(uuid.UUID(bytes=b\"LibSodiumMSVCUID\"), dir)\n    fd = fd + '    <Filter Include=\"{}\">\\r\\n'.format(dir)\n    fd = fd + \"      <UniqueIdentifier>{{{}}}</UniqueIdentifier>\\r\\n\".format(\n        uid\n    )\n    fd = fd + \"    </Filter>\\r\\n\"\n\n\ndef get_project_configurations(vs_version):\n    projconfig = \"\"\n    configs = [\n        \"DebugDLL\",\n        \"ReleaseDLL\",\n        \"DebugLIB\",\n        \"ReleaseLIB\",\n        \"DebugLTCG\",\n        \"ReleaseLTCG\",\n    ]\n    platforms = [\"Win32\", \"x64\"]\n    # add arm64 platform only for v142+ toolchain\n    if vs_version >= 142:\n        platforms.append(\"ARM64\")\n    for config in configs:\n        for platform in platforms:\n            projconfig = (\n                projconfig\n                + '    <ProjectConfiguration Include=\"{}|{}\">\\r\\n'.format(\n                    config, platform\n                )\n            )\n            projconfig = (\n                projconfig\n                + \"      <Configuration>{}</Configuration>\\r\\n\".format(config)\n            )\n            projconfig = (\n                projconfig\n                + \"      <Platform>{}</Platform>\\r\\n\".format(platform)\n            )\n            projconfig = projconfig + \"    </ProjectConfiguration>\\r\\n\"\n    return projconfig\n\n\ndef apply_template(tplfile, outfile, sbox):\n    tpl = \"\"\n    with open(tplfile, \"rb\") as fd:\n        tpl = fd.read()\n    for s in sbox.keys():\n        tpl = tpl.replace(\n            str.encode(\"{{\" + s + \"}}\", \"utf8\"),\n            str.encode(str.strip(sbox[s]), \"utf8\"),\n        )\n\n    with open(outfile, \"wb\") as fd:\n        fd.write(tpl)\n\n\nsbox = {\n    \"tlv1\": tlv1,\n    \"tlv2\": tlv2,\n    \"tlf1\": tlf1,\n    \"tlf2\": tlf2,\n    \"v1\": v1,\n    \"v2\": v2,\n    \"f1\": f1,\n    \"f2\": f2,\n    \"fd\": fd,\n}\n\nsd = os.path.dirname(os.path.realpath(__file__))\n\napply_template(\n    sd + \"/tl_libsodium.vcxproj.filters.tpl\",\n    \"ci/appveyor/libsodium.vcxproj.filters\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v140\"})\nsbox.update({\"configurations\": get_project_configurations(140)})\napply_template(\n    sd + \"/tl_libsodium.vcxproj.tpl\", \"ci/appveyor/libsodium.vcxproj\", sbox\n)\n\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2022/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2019/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2017/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2015/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2013/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2012/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2010/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v143\"})\nsbox.update({\"configurations\": get_project_configurations(143)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2022/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v142\"})\nsbox.update({\"configurations\": get_project_configurations(142)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2019/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v141\"})\nsbox.update({\"configurations\": get_project_configurations(141)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2017/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v140\"})\nsbox.update({\"configurations\": get_project_configurations(140)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2015/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v120\"})\nsbox.update({\"configurations\": get_project_configurations(120)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2013/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v110\"})\nsbox.update({\"configurations\": get_project_configurations(110)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2012/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v100\"})\nsbox.update({\"configurations\": get_project_configurations(100)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2010/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n", "src/nacl/public.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ClassVar, Generic, Optional, Type, TypeVar\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.encoding import Encoder\nfrom nacl.utils import EncryptedMessage, StringFixer, random\n\n\nclass PublicKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    The public key counterpart to an Curve25519 :class:`nacl.public.PrivateKey`\n    for encrypting messages.\n\n    :param public_key: [:class:`bytes`] Encoded Curve25519 public key\n    :param encoder: A class that is able to decode the `public_key`\n\n    :cvar SIZE: The size that the public key is required to be\n    \"\"\"\n\n    SIZE: ClassVar[int] = nacl.bindings.crypto_box_PUBLICKEYBYTES\n\n    def __init__(\n        self,\n        public_key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        self._public_key = encoder.decode(public_key)\n        if not isinstance(self._public_key, bytes):\n            raise exc.TypeError(\"PublicKey must be created from 32 bytes\")\n\n        if len(self._public_key) != self.SIZE:\n            raise exc.ValueError(\n                \"The public key must be exactly {} bytes long\".format(\n                    self.SIZE\n                )\n            )\n\n    def __bytes__(self) -> bytes:\n        return self._public_key\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n\nclass PrivateKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    Private key for decrypting messages using the Curve25519 algorithm.\n\n    .. warning:: This **must** be protected and remain secret. Anyone who\n        knows the value of your :class:`~nacl.public.PrivateKey` can decrypt\n        any message encrypted by the corresponding\n        :class:`~nacl.public.PublicKey`\n\n    :param private_key: The private key used to decrypt messages\n    :param encoder: The encoder class used to decode the given keys\n\n    :cvar SIZE: The size that the private key is required to be\n    :cvar SEED_SIZE: The size that the seed used to generate the\n                     private key is required to be\n    \"\"\"\n\n    SIZE: ClassVar[int] = nacl.bindings.crypto_box_SECRETKEYBYTES\n    SEED_SIZE: ClassVar[int] = nacl.bindings.crypto_box_SEEDBYTES\n\n    def __init__(\n        self,\n        private_key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        # Decode the secret_key\n        private_key = encoder.decode(private_key)\n        # verify the given secret key type and size are correct\n        if not (\n            isinstance(private_key, bytes) and len(private_key) == self.SIZE\n        ):\n            raise exc.TypeError(\n                (\n                    \"PrivateKey must be created from a {} \"\n                    \"bytes long raw secret key\"\n                ).format(self.SIZE)\n            )\n\n        raw_public_key = nacl.bindings.crypto_scalarmult_base(private_key)\n\n        self._private_key = private_key\n        self.public_key = PublicKey(raw_public_key)\n\n    @classmethod\n    def from_seed(\n        cls,\n        seed: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> \"PrivateKey\":\n        \"\"\"\n        Generate a PrivateKey using a deterministic construction\n        starting from a caller-provided seed\n\n        .. warning:: The seed **must** be high-entropy; therefore,\n            its generator **must** be a cryptographic quality\n            random function like, for example, :func:`~nacl.utils.random`.\n\n        .. warning:: The seed **must** be protected and remain secret.\n            Anyone who knows the seed is really in possession of\n            the corresponding PrivateKey.\n\n        :param seed: The seed used to generate the private key\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        # decode the seed\n        seed = encoder.decode(seed)\n        # Verify the given seed type and size are correct\n        if not (isinstance(seed, bytes) and len(seed) == cls.SEED_SIZE):\n            raise exc.TypeError(\n                (\n                    \"PrivateKey seed must be a {} bytes long \"\n                    \"binary sequence\"\n                ).format(cls.SEED_SIZE)\n            )\n        # generate a raw key pair from the given seed\n        raw_pk, raw_sk = nacl.bindings.crypto_box_seed_keypair(seed)\n        # construct a instance from the raw secret key\n        return cls(raw_sk)\n\n    def __bytes__(self) -> bytes:\n        return self._private_key\n\n    def __hash__(self) -> int:\n        return hash((type(self), bytes(self.public_key)))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return self.public_key == other.public_key\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    @classmethod\n    def generate(cls) -> \"PrivateKey\":\n        \"\"\"\n        Generates a random :class:`~nacl.public.PrivateKey` object\n\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        return cls(random(PrivateKey.SIZE), encoder=encoding.RawEncoder)\n\n\n_Box = TypeVar(\"_Box\", bound=\"Box\")\n\n\nclass Box(encoding.Encodable, StringFixer):\n    \"\"\"\n    The Box class boxes and unboxes messages between a pair of keys\n\n    The ciphertexts generated by :class:`~nacl.public.Box` include a 16\n    byte authenticator which is checked as part of the decryption. An invalid\n    authenticator will cause the decrypt function to raise an exception. The\n    authenticator is not a signature. Once you've decrypted the message you've\n    demonstrated the ability to create arbitrary valid message, so messages you\n    send are repudiable. For non-repudiable messages, sign them after\n    encryption.\n\n    :param private_key: :class:`~nacl.public.PrivateKey` used to encrypt and\n        decrypt messages\n    :param public_key: :class:`~nacl.public.PublicKey` used to encrypt and\n        decrypt messages\n\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    \"\"\"\n\n    NONCE_SIZE: ClassVar[int] = nacl.bindings.crypto_box_NONCEBYTES\n    _shared_key: bytes\n\n    def __init__(self, private_key: PrivateKey, public_key: PublicKey):\n        if not isinstance(private_key, PrivateKey) or not isinstance(\n            public_key, PublicKey\n        ):\n            raise exc.TypeError(\n                \"Box must be created from a PrivateKey and a PublicKey\"\n            )\n        self._shared_key = nacl.bindings.crypto_box_beforenm(\n            public_key.encode(encoder=encoding.RawEncoder),\n            private_key.encode(encoder=encoding.RawEncoder),\n        )\n\n    def __bytes__(self) -> bytes:\n        return self._shared_key\n\n    @classmethod\n    def decode(\n        cls: Type[_Box], encoded: bytes, encoder: Encoder = encoding.RawEncoder\n    ) -> _Box:\n        \"\"\"\n        Alternative constructor. Creates a Box from an existing Box's shared key.\n        \"\"\"\n        # Create an empty box\n        box: _Box = cls.__new__(cls)\n\n        # Assign our decoded value to the shared key of the box\n        box._shared_key = encoder.decode(encoded)\n\n        return box\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is **VITALLY** important that the nonce is a nonce,\n            i.e. it is a number used only once for any given key. If you fail\n            to do this, you compromise the privacy of the messages encrypted.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE\n            )\n\n        ciphertext = nacl.bindings.crypto_box_afternm(\n            plaintext,\n            nonce,\n            self._shared_key,\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE\n            )\n\n        plaintext = nacl.bindings.crypto_box_open_afternm(\n            ciphertext,\n            nonce,\n            self._shared_key,\n        )\n\n        return plaintext\n\n    def shared_key(self) -> bytes:\n        \"\"\"\n        Returns the Curve25519 shared secret, that can then be used as a key in\n        other symmetric ciphers.\n\n        .. warning:: It is **VITALLY** important that you use a nonce with your\n            symmetric cipher. If you fail to do this, you compromise the\n            privacy of the messages encrypted. Ensure that the key length of\n            your cipher is 32 bytes.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n\n        return self._shared_key\n\n\n_Key = TypeVar(\"_Key\", PublicKey, PrivateKey)\n\n\nclass SealedBox(Generic[_Key], encoding.Encodable, StringFixer):\n    \"\"\"\n    The SealedBox class boxes and unboxes messages addressed to\n    a specified key-pair by using ephemeral sender's key pairs,\n    whose private part will be discarded just after encrypting\n    a single plaintext message.\n\n    The ciphertexts generated by :class:`~nacl.public.SecretBox` include\n    the public part of the ephemeral key before the :class:`~nacl.public.Box`\n    ciphertext.\n\n    :param recipient_key: a :class:`~nacl.public.PublicKey` used to encrypt\n        messages and derive nonces, or a :class:`~nacl.public.PrivateKey` used\n        to decrypt messages.\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    _public_key: bytes\n    _private_key: Optional[bytes]\n\n    def __init__(self, recipient_key: _Key):\n        if isinstance(recipient_key, PublicKey):\n            self._public_key = recipient_key.encode(\n                encoder=encoding.RawEncoder\n            )\n            self._private_key = None\n        elif isinstance(recipient_key, PrivateKey):\n            self._private_key = recipient_key.encode(\n                encoder=encoding.RawEncoder\n            )\n            self._public_key = recipient_key.public_key.encode(\n                encoder=encoding.RawEncoder\n            )\n        else:\n            raise exc.TypeError(\n                \"SealedBox must be created from a PublicKey or a PrivateKey\"\n            )\n\n    def __bytes__(self) -> bytes:\n        return self._public_key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Encrypts the plaintext message using a random-generated ephemeral\n        key pair and returns a \"composed ciphertext\", containing both\n        the public part of the key pair and the ciphertext proper,\n        encoded with the encoder.\n\n        The private part of the ephemeral key-pair will be scrubbed before\n        returning the ciphertext, therefore, the sender will not be able to\n        decrypt the generated ciphertext.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param encoder: The encoder to use to encode the ciphertext\n        :return bytes: encoded ciphertext\n        \"\"\"\n\n        ciphertext = nacl.bindings.crypto_box_seal(plaintext, self._public_key)\n\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return encoded_ciphertext\n\n    def decrypt(\n        self: \"SealedBox[PrivateKey]\",\n        ciphertext: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the ephemeral public key enclosed\n        in the ciphertext and the SealedBox private key, returning\n        the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param encoder: The encoder used to decode the ciphertext.\n        :return bytes: The original plaintext\n        :raises TypeError: if this SealedBox was created with a\n            :class:`~nacl.public.PublicKey` rather than a\n            :class:`~nacl.public.PrivateKey`.\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if self._private_key is None:\n            raise TypeError(\n                \"SealedBoxes created with a public key cannot decrypt\"\n            )\n        plaintext = nacl.bindings.crypto_box_seal_open(\n            ciphertext,\n            self._public_key,\n            self._private_key,\n        )\n\n        return plaintext\n", "src/nacl/exceptions.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n# We create a clone of various builtin Exception types which additionally\n# inherit from CryptoError. Below, we refer to the parent types via the\n# `builtins` namespace, so mypy can distinguish between (e.g.)\n# `nacl.exceptions.RuntimeError` and `builtins.RuntimeError`.\nimport builtins\nfrom typing import Type\n\n\nclass CryptoError(Exception):\n    \"\"\"\n    Base exception for all nacl related errors\n    \"\"\"\n\n\nclass BadSignatureError(CryptoError):\n    \"\"\"\n    Raised when the signature was forged or otherwise corrupt.\n    \"\"\"\n\n\nclass RuntimeError(builtins.RuntimeError, CryptoError):\n    pass\n\n\nclass AssertionError(builtins.AssertionError, CryptoError):\n    pass\n\n\nclass TypeError(builtins.TypeError, CryptoError):\n    pass\n\n\nclass ValueError(builtins.ValueError, CryptoError):\n    pass\n\n\nclass InvalidkeyError(CryptoError):\n    pass\n\n\nclass CryptPrefixError(InvalidkeyError):\n    pass\n\n\nclass UnavailableError(RuntimeError):\n    \"\"\"\n    is a subclass of :class:`~nacl.exceptions.RuntimeError`, raised when\n    trying to call functions not available in a minimal build of\n    libsodium.\n    \"\"\"\n\n    pass\n\n\ndef ensure(cond: bool, *args: object, **kwds: Type[Exception]) -> None:\n    \"\"\"\n    Return if a condition is true, otherwise raise a caller-configurable\n    :py:class:`Exception`\n    :param bool cond: the condition to be checked\n    :param sequence args: the arguments to be passed to the exception's\n                          constructor\n    The only accepted named parameter is `raising` used to configure the\n    exception to be raised if `cond` is not `True`\n    \"\"\"\n    _CHK_UNEXP = \"check_condition() got an unexpected keyword argument {0}\"\n\n    raising = kwds.pop(\"raising\", AssertionError)\n    if kwds:\n        raise TypeError(_CHK_UNEXP.format(repr(kwds.popitem()[0])))\n\n    if cond is True:\n        return\n    raise raising(*args)\n", "src/nacl/utils.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport os\nfrom typing import SupportsBytes, Type, TypeVar\n\nimport nacl.bindings\nfrom nacl import encoding\n\n_EncryptedMessage = TypeVar(\"_EncryptedMessage\", bound=\"EncryptedMessage\")\n\n\nclass EncryptedMessage(bytes):\n    \"\"\"\n    A bytes subclass that holds a messaged that has been encrypted by a\n    :class:`SecretBox`.\n    \"\"\"\n\n    _nonce: bytes\n    _ciphertext: bytes\n\n    @classmethod\n    def _from_parts(\n        cls: Type[_EncryptedMessage],\n        nonce: bytes,\n        ciphertext: bytes,\n        combined: bytes,\n    ) -> _EncryptedMessage:\n        obj = cls(combined)\n        obj._nonce = nonce\n        obj._ciphertext = ciphertext\n        return obj\n\n    @property\n    def nonce(self) -> bytes:\n        \"\"\"\n        The nonce used during the encryption of the :class:`EncryptedMessage`.\n        \"\"\"\n        return self._nonce\n\n    @property\n    def ciphertext(self) -> bytes:\n        \"\"\"\n        The ciphertext contained within the :class:`EncryptedMessage`.\n        \"\"\"\n        return self._ciphertext\n\n\nclass StringFixer:\n    def __str__(self: SupportsBytes) -> str:\n        return str(self.__bytes__())\n\n\ndef bytes_as_string(bytes_in: bytes) -> str:\n    return bytes_in.decode(\"ascii\")\n\n\ndef random(size: int = 32) -> bytes:\n    return os.urandom(size)\n\n\ndef randombytes_deterministic(\n    size: int, seed: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n) -> bytes:\n    \"\"\"\n    Returns ``size`` number of deterministically generated pseudorandom bytes\n    from a seed\n\n    :param size: int\n    :param seed: bytes\n    :param encoder: The encoder class used to encode the produced bytes\n    :rtype: bytes\n    \"\"\"\n    raw_data = nacl.bindings.randombytes_buf_deterministic(size, seed)\n\n    return encoder.encode(raw_data)\n", "src/nacl/hash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nThe :mod:`nacl.hash` module exposes one-shot interfaces\nfor libsodium selected hash primitives and the constants needed\nfor their usage.\n\"\"\"\n\n\nimport nacl.bindings\nimport nacl.encoding\n\n\nBLAKE2B_BYTES = nacl.bindings.crypto_generichash_BYTES\n\"\"\"Default digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_BYTES_MIN = nacl.bindings.crypto_generichash_BYTES_MIN\n\"\"\"Minimum allowed digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_BYTES_MAX = nacl.bindings.crypto_generichash_BYTES_MAX\n\"\"\"Maximum allowed digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES = nacl.bindings.crypto_generichash_KEYBYTES\n\"\"\"Default size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES_MIN = nacl.bindings.crypto_generichash_KEYBYTES_MIN\n\"\"\"Minimum allowed size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES_MAX = nacl.bindings.crypto_generichash_KEYBYTES_MAX\n\"\"\"Maximum allowed size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_SALTBYTES = nacl.bindings.crypto_generichash_SALTBYTES\n\"\"\"Maximum allowed length of the ``salt`` byte array for\n:func:`blake2b` hash\"\"\"\nBLAKE2B_PERSONALBYTES = nacl.bindings.crypto_generichash_PERSONALBYTES\n\"\"\"Maximum allowed length of the ``personalization``\nbyte array for :func:`blake2b` hash\"\"\"\n\nSIPHASH_BYTES = nacl.bindings.crypto_shorthash_siphash24_BYTES\n\"\"\"Size of the :func:`siphash24` digest\"\"\"\nSIPHASH_KEYBYTES = nacl.bindings.crypto_shorthash_siphash24_KEYBYTES\n\"\"\"Size of the secret ``key`` used by the :func:`siphash24` MAC\"\"\"\n\nSIPHASHX_AVAILABLE = nacl.bindings.has_crypto_shorthash_siphashx24\n\"\"\"``True`` if :func:`siphashx24` is available to be called\"\"\"\n\nSIPHASHX_BYTES = nacl.bindings.crypto_shorthash_siphashx24_BYTES\n\"\"\"Size of the :func:`siphashx24` digest\"\"\"\nSIPHASHX_KEYBYTES = nacl.bindings.crypto_shorthash_siphashx24_KEYBYTES\n\"\"\"Size of the secret ``key`` used by the :func:`siphashx24` MAC\"\"\"\n\n_b2b_hash = nacl.bindings.crypto_generichash_blake2b_salt_personal\n_sip_hash = nacl.bindings.crypto_shorthash_siphash24\n_sip_hashx = nacl.bindings.crypto_shorthash_siphashx24\n\n\ndef sha256(\n    message: bytes, encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder\n) -> bytes:\n    \"\"\"\n    Hashes ``message`` with SHA256.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n    return encoder.encode(nacl.bindings.crypto_hash_sha256(message))\n\n\ndef sha512(\n    message: bytes, encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder\n) -> bytes:\n    \"\"\"\n    Hashes ``message`` with SHA512.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n    return encoder.encode(nacl.bindings.crypto_hash_sha512(message))\n\n\ndef blake2b(\n    data: bytes,\n    digest_size: int = BLAKE2B_BYTES,\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Hashes ``data`` with blake2b.\n\n    :param data: the digest input byte sequence\n    :type data: bytes\n    :param digest_size: the requested digest size; must be at most\n                        :const:`BLAKE2B_BYTES_MAX`;\n                        the default digest size is\n                        :const:`BLAKE2B_BYTES`\n    :type digest_size: int\n    :param key: the key to be set for keyed MAC/PRF usage; if set, the key\n                must be at most :data:`~nacl.hash.BLAKE2B_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: an initialization salt at most\n                 :const:`BLAKE2B_SALTBYTES` long;\n                 it will be zero-padded if needed\n    :type salt: bytes\n    :param person: a personalization string at most\n                   :const:`BLAKE2B_PERSONALBYTES` long;\n                   it will be zero-padded if needed\n    :type person: bytes\n    :param encoder: the encoder to use on returned digest\n    :type encoder: class\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n\n    digest = _b2b_hash(\n        data, digest_size=digest_size, key=key, salt=salt, person=person\n    )\n    return encoder.encode(digest)\n\n\ngenerichash = blake2b\n\n\ndef siphash24(\n    message: bytes,\n    key: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Computes a keyed MAC of ``message`` using the short-input-optimized\n    siphash-2-4 construction.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param key: the message authentication key for the siphash MAC construct\n    :type key: bytes(:const:`SIPHASH_KEYBYTES`)\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes(:const:`SIPHASH_BYTES`)\n    \"\"\"\n    digest = _sip_hash(message, key)\n    return encoder.encode(digest)\n\n\nshorthash = siphash24\n\n\ndef siphashx24(\n    message: bytes,\n    key: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Computes a keyed MAC of ``message`` using the 128 bit variant of the\n    siphash-2-4 construction.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param key: the message authentication key for the siphash MAC construct\n    :type key: bytes(:const:`SIPHASHX_KEYBYTES`)\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes(:const:`SIPHASHX_BYTES`)\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    digest = _sip_hashx(message, key)\n    return encoder.encode(digest)\n", "src/nacl/secret.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ClassVar, Optional\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.utils import EncryptedMessage, StringFixer, random\n\n\nclass SecretBox(encoding.Encodable, StringFixer):\n    \"\"\"\n    The SecretBox class encrypts and decrypts messages using the given secret\n    key.\n\n    The ciphertexts generated by :class:`~nacl.secret.Secretbox` include a 16\n    byte authenticator which is checked as part of the decryption. An invalid\n    authenticator will cause the decrypt function to raise an exception. The\n    authenticator is not a signature. Once you've decrypted the message you've\n    demonstrated the ability to create arbitrary valid message, so messages you\n    send are repudiable. For non-repudiable messages, sign them after\n    encryption.\n\n    Encryption is done using `XSalsa20-Poly1305`_, and there are no practical\n    limits on the number or size of messages (up to 2\u2076\u2074 messages, each up to 2\u2076\u2074\n    bytes).\n\n    .. _XSalsa20-Poly1305: https://doc.libsodium.org/secret-key_cryptography/secretbox#algorithm-details\n\n    :param key: The secret key used to encrypt and decrypt messages\n    :param encoder: The encoder class used to decode the given key\n\n    :cvar KEY_SIZE: The size that the key is required to be.\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    :cvar MACBYTES: The size of the authentication MAC tag in bytes.\n    :cvar MESSAGEBYTES_MAX: The maximum size of a message which can be\n                            safely encrypted with a single key/nonce\n                            pair.\n    \"\"\"\n\n    KEY_SIZE: ClassVar[int] = nacl.bindings.crypto_secretbox_KEYBYTES\n    NONCE_SIZE: ClassVar[int] = nacl.bindings.crypto_secretbox_NONCEBYTES\n    MACBYTES: ClassVar[int] = nacl.bindings.crypto_secretbox_MACBYTES\n    MESSAGEBYTES_MAX: ClassVar[int] = (\n        nacl.bindings.crypto_secretbox_MESSAGEBYTES_MAX\n    )\n\n    def __init__(\n        self, key: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n    ):\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"SecretBox must be created from 32 bytes\")\n\n        if len(key) != self.KEY_SIZE:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\" % self.KEY_SIZE,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is **VITALLY** important that the nonce is a nonce,\n            i.e. it is a number used only once for any given key. If you fail\n            to do this, you compromise the privacy of the messages encrypted.\n            Give your nonces a different prefix, or have one side use an odd\n            counter and one an even counter. Just make sure they are different.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        ciphertext = nacl.bindings.crypto_secretbox(\n            plaintext, nonce, self._key\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        plaintext = nacl.bindings.crypto_secretbox_open(\n            ciphertext, nonce, self._key\n        )\n\n        return plaintext\n\n\nclass Aead(encoding.Encodable, StringFixer):\n    \"\"\"\n    The AEAD class encrypts and decrypts messages using the given secret key.\n\n    Unlike :class:`~nacl.secret.SecretBox`, AEAD supports authenticating\n    non-confidential data received alongside the message, such as a length\n    or type tag.\n\n    Like :class:`~nacl.secret.Secretbox`, this class provides authenticated\n    encryption. An inauthentic message will cause the decrypt function to raise\n    an exception.\n\n    Likewise, the authenticator should not be mistaken for a (public-key)\n    signature: recipients (with the ability to decrypt messages) are capable of\n    creating arbitrary valid message; in particular, this means AEAD messages\n    are repudiable. For non-repudiable messages, sign them after encryption.\n\n    The cryptosystem used is `XChacha20-Poly1305`_ as specified for\n    `standardization`_. There are `no practical limits`_ to how much can safely\n    be encrypted under a given key (up to 2\u2076\u2074 messages each containing up\n    to 2\u2076\u2074 bytes).\n\n    .. _standardization: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n    .. _XChacha20-Poly1305: https://doc.libsodium.org/secret-key_cryptography/aead#xchacha-20-poly1305\n    .. _no practical limits: https://doc.libsodium.org/secret-key_cryptography/aead#limitations\n\n    :param key: The secret key used to encrypt and decrypt messages\n    :param encoder: The encoder class used to decode the given key\n\n    :cvar KEY_SIZE: The size that the key is required to be.\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    :cvar MACBYTES: The size of the authentication MAC tag in bytes.\n    :cvar MESSAGEBYTES_MAX: The maximum size of a message which can be\n                            safely encrypted with a single key/nonce\n                            pair.\n    \"\"\"\n\n    KEY_SIZE = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n    NONCE_SIZE = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n    MACBYTES = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_ABYTES\n    MESSAGEBYTES_MAX = (\n        nacl.bindings.crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n    )\n\n    def __init__(\n        self,\n        key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"AEAD must be created from 32 bytes\")\n\n        if len(key) != self.KEY_SIZE:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\" % self.KEY_SIZE,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        aad: bytes = b\"\",\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is vitally important for :param nonce: to be unique.\n            By default, it is generated randomly; [:class:`Aead`] uses XChacha20\n            for extended (192b) nonce size, so the risk of reusing random nonces\n            is negligible.  It is *strongly recommended* to keep this behaviour,\n            as nonce reuse will compromise the privacy of encrypted messages.\n            Should implicit nonces be inadequate for your application, the\n            second best option is using split counters; e.g. if sending messages\n            encrypted under a shared key between 2 users, each user can use the\n            number of messages it sent so far, prefixed or suffixed with a 1bit\n            user id.  Note that the counter must **never** be rolled back (due\n            to overflow, on-disk state being rolled back to an earlier backup,\n            ...)\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        ciphertext = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            plaintext, aad, nonce, self._key\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        aad: bytes = b\"\",\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        plaintext = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            ciphertext, aad, nonce, self._key\n        )\n\n        return plaintext\n", "src/nacl/__init__.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n__all__ = [\n    \"__title__\",\n    \"__summary__\",\n    \"__uri__\",\n    \"__version__\",\n    \"__author__\",\n    \"__email__\",\n    \"__license__\",\n    \"__copyright__\",\n]\n\n__title__ = \"PyNaCl\"\n__summary__ = (\n    \"Python binding to the Networking and Cryptography (NaCl) library\"\n)\n__uri__ = \"https://github.com/pyca/pynacl/\"\n\n__version__ = \"1.6.0.dev1\"\n\n__author__ = \"The PyNaCl developers\"\n__email__ = \"cryptography-dev@python.org\"\n\n__license__ = \"Apache License 2.0\"\n__copyright__ = \"Copyright 2013-2018 {}\".format(__author__)\n", "src/nacl/signing.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Optional\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.public import (\n    PrivateKey as _Curve25519_PrivateKey,\n    PublicKey as _Curve25519_PublicKey,\n)\nfrom nacl.utils import StringFixer, random\n\n\nclass SignedMessage(bytes):\n    \"\"\"\n    A bytes subclass that holds a messaged that has been signed by a\n    :class:`SigningKey`.\n    \"\"\"\n\n    _signature: bytes\n    _message: bytes\n\n    @classmethod\n    def _from_parts(\n        cls, signature: bytes, message: bytes, combined: bytes\n    ) -> \"SignedMessage\":\n        obj = cls(combined)\n        obj._signature = signature\n        obj._message = message\n        return obj\n\n    @property\n    def signature(self) -> bytes:\n        \"\"\"\n        The signature contained within the :class:`SignedMessage`.\n        \"\"\"\n        return self._signature\n\n    @property\n    def message(self) -> bytes:\n        \"\"\"\n        The message contained within the :class:`SignedMessage`.\n        \"\"\"\n        return self._message\n\n\nclass VerifyKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    The public key counterpart to an Ed25519 SigningKey for producing digital\n    signatures.\n\n    :param key: [:class:`bytes`] Serialized Ed25519 public key\n    :param encoder: A class that is able to decode the `key`\n    \"\"\"\n\n    def __init__(\n        self, key: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n    ):\n        # Decode the key\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"VerifyKey must be created from 32 bytes\")\n\n        if len(key) != nacl.bindings.crypto_sign_PUBLICKEYBYTES:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\"\n                % nacl.bindings.crypto_sign_PUBLICKEYBYTES,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    def verify(\n        self,\n        smessage: bytes,\n        signature: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Verifies the signature of a signed message, returning the message\n        if it has not been tampered with else raising\n        :class:`~nacl.signing.BadSignatureError`.\n\n        :param smessage: [:class:`bytes`] Either the original messaged or a\n            signature and message concated together.\n        :param signature: [:class:`bytes`] If an unsigned message is given for\n            smessage then the detached signature must be provided.\n        :param encoder: A class that is able to decode the secret message and\n            signature.\n        :rtype: :class:`bytes`\n        \"\"\"\n        if signature is not None:\n            # If we were given the message and signature separately, validate\n            #   signature size and combine them.\n            if not isinstance(signature, bytes):\n                raise exc.TypeError(\n                    \"Verification signature must be created from %d bytes\"\n                    % nacl.bindings.crypto_sign_BYTES,\n                )\n\n            if len(signature) != nacl.bindings.crypto_sign_BYTES:\n                raise exc.ValueError(\n                    \"The signature must be exactly %d bytes long\"\n                    % nacl.bindings.crypto_sign_BYTES,\n                )\n\n            smessage = signature + encoder.decode(smessage)\n        else:\n            # Decode the signed message\n            smessage = encoder.decode(smessage)\n\n        return nacl.bindings.crypto_sign_open(smessage, self._key)\n\n    def to_curve25519_public_key(self) -> _Curve25519_PublicKey:\n        \"\"\"\n        Converts a :class:`~nacl.signing.VerifyKey` to a\n        :class:`~nacl.public.PublicKey`\n\n        :rtype: :class:`~nacl.public.PublicKey`\n        \"\"\"\n        raw_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(self._key)\n        return _Curve25519_PublicKey(raw_pk)\n\n\nclass SigningKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    Private key for producing digital signatures using the Ed25519 algorithm.\n\n    Signing keys are produced from a 32-byte (256-bit) random seed value. This\n    value can be passed into the :class:`~nacl.signing.SigningKey` as a\n    :func:`bytes` whose length is 32.\n\n    .. warning:: This **must** be protected and remain secret. Anyone who knows\n        the value of your :class:`~nacl.signing.SigningKey` or it's seed can\n        masquerade as you.\n\n    :param seed: [:class:`bytes`] Random 32-byte value (i.e. private key)\n    :param encoder: A class that is able to decode the seed\n\n    :ivar: verify_key: [:class:`~nacl.signing.VerifyKey`] The verify\n        (i.e. public) key that corresponds with this signing key.\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        # Decode the seed\n        seed = encoder.decode(seed)\n        if not isinstance(seed, bytes):\n            raise exc.TypeError(\n                \"SigningKey must be created from a 32 byte seed\"\n            )\n\n        # Verify that our seed is the proper size\n        if len(seed) != nacl.bindings.crypto_sign_SEEDBYTES:\n            raise exc.ValueError(\n                \"The seed must be exactly %d bytes long\"\n                % nacl.bindings.crypto_sign_SEEDBYTES\n            )\n\n        public_key, secret_key = nacl.bindings.crypto_sign_seed_keypair(seed)\n\n        self._seed = seed\n        self._signing_key = secret_key\n        self.verify_key = VerifyKey(public_key)\n\n    def __bytes__(self) -> bytes:\n        return self._seed\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    @classmethod\n    def generate(cls) -> \"SigningKey\":\n        \"\"\"\n        Generates a random :class:`~nacl.signing.SigningKey` object.\n\n        :rtype: :class:`~nacl.signing.SigningKey`\n        \"\"\"\n        return cls(\n            random(nacl.bindings.crypto_sign_SEEDBYTES),\n            encoder=encoding.RawEncoder,\n        )\n\n    def sign(\n        self,\n        message: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> SignedMessage:\n        \"\"\"\n        Sign a message using this key.\n\n        :param message: [:class:`bytes`] The data to be signed.\n        :param encoder: A class that is used to encode the signed message.\n        :rtype: :class:`~nacl.signing.SignedMessage`\n        \"\"\"\n        raw_signed = nacl.bindings.crypto_sign(message, self._signing_key)\n\n        crypto_sign_BYTES = nacl.bindings.crypto_sign_BYTES\n        signature = encoder.encode(raw_signed[:crypto_sign_BYTES])\n        message = encoder.encode(raw_signed[crypto_sign_BYTES:])\n        signed = encoder.encode(raw_signed)\n\n        return SignedMessage._from_parts(signature, message, signed)\n\n    def to_curve25519_private_key(self) -> _Curve25519_PrivateKey:\n        \"\"\"\n        Converts a :class:`~nacl.signing.SigningKey` to a\n        :class:`~nacl.public.PrivateKey`\n\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        sk = self._signing_key\n        raw_private = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(sk)\n        return _Curve25519_PrivateKey(raw_private)\n", "src/nacl/encoding.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport base64\nimport binascii\nfrom abc import ABCMeta, abstractmethod\nfrom typing import SupportsBytes, Type\n\n\n# TODO: when the minimum supported version of Python is 3.8, we can import\n# Protocol from typing, and replace Encoder with a Protocol instead.\nclass _Encoder(metaclass=ABCMeta):\n    @staticmethod\n    @abstractmethod\n    def encode(data: bytes) -> bytes:\n        \"\"\"Transform raw data to encoded data.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def decode(data: bytes) -> bytes:\n        \"\"\"Transform encoded data back to raw data.\n\n        Decoding after encoding should be a no-op, i.e. `decode(encode(x)) == x`.\n        \"\"\"\n\n\n# Functions that use encoders are passed a subclass of _Encoder, not an instance\n# (because the methods are all static). Let's gloss over that detail by defining\n# an alias for Type[_Encoder].\nEncoder = Type[_Encoder]\n\n\nclass RawEncoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return data\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return data\n\n\nclass HexEncoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return binascii.hexlify(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return binascii.unhexlify(data)\n\n\nclass Base16Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b16encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b16decode(data)\n\n\nclass Base32Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b32encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b32decode(data)\n\n\nclass Base64Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b64encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b64decode(data)\n\n\nclass URLSafeBase64Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.urlsafe_b64encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.urlsafe_b64decode(data)\n\n\nclass Encodable:\n    def encode(self: SupportsBytes, encoder: Encoder = RawEncoder) -> bytes:\n        return encoder.encode(bytes(self))\n", "src/nacl/hashlib.py": "# Copyright 2016-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport binascii\nfrom typing import NoReturn\n\nimport nacl.bindings\nfrom nacl.utils import bytes_as_string\n\nBYTES = nacl.bindings.crypto_generichash_BYTES\nBYTES_MIN = nacl.bindings.crypto_generichash_BYTES_MIN\nBYTES_MAX = nacl.bindings.crypto_generichash_BYTES_MAX\nKEYBYTES = nacl.bindings.crypto_generichash_KEYBYTES\nKEYBYTES_MIN = nacl.bindings.crypto_generichash_KEYBYTES_MIN\nKEYBYTES_MAX = nacl.bindings.crypto_generichash_KEYBYTES_MAX\nSALTBYTES = nacl.bindings.crypto_generichash_SALTBYTES\nPERSONALBYTES = nacl.bindings.crypto_generichash_PERSONALBYTES\n\nSCRYPT_AVAILABLE = nacl.bindings.has_crypto_pwhash_scryptsalsa208sha256\n\n_b2b_init = nacl.bindings.crypto_generichash_blake2b_init\n_b2b_final = nacl.bindings.crypto_generichash_blake2b_final\n_b2b_update = nacl.bindings.crypto_generichash_blake2b_update\n\n\nclass blake2b:\n    \"\"\"\n    :py:mod:`hashlib` API compatible blake2b algorithm implementation\n    \"\"\"\n\n    MAX_DIGEST_SIZE = BYTES\n    MAX_KEY_SIZE = KEYBYTES_MAX\n    PERSON_SIZE = PERSONALBYTES\n    SALT_SIZE = SALTBYTES\n\n    def __init__(\n        self,\n        data: bytes = b\"\",\n        digest_size: int = BYTES,\n        key: bytes = b\"\",\n        salt: bytes = b\"\",\n        person: bytes = b\"\",\n    ):\n        \"\"\"\n        :py:class:`.blake2b` algorithm initializer\n\n        :param data:\n        :type data: bytes\n        :param int digest_size: the requested digest size; must be\n                                at most :py:attr:`.MAX_DIGEST_SIZE`;\n                                the default digest size is :py:data:`.BYTES`\n        :param key: the key to be set for keyed MAC/PRF usage; if set,\n                    the key must be at most :py:data:`.KEYBYTES_MAX` long\n        :type key: bytes\n        :param salt: a initialization salt at most\n                     :py:attr:`.SALT_SIZE` long; it will be zero-padded\n                     if needed\n        :type salt: bytes\n        :param person: a personalization string at most\n                       :py:attr:`.PERSONAL_SIZE` long; it will be zero-padded\n                       if needed\n        :type person: bytes\n        \"\"\"\n\n        self._state = _b2b_init(\n            key=key, salt=salt, person=person, digest_size=digest_size\n        )\n        self._digest_size = digest_size\n\n        if data:\n            self.update(data)\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n    @property\n    def block_size(self) -> int:\n        return 128\n\n    @property\n    def name(self) -> str:\n        return \"blake2b\"\n\n    def update(self, data: bytes) -> None:\n        _b2b_update(self._state, data)\n\n    def digest(self) -> bytes:\n        _st = self._state.copy()\n        return _b2b_final(_st)\n\n    def hexdigest(self) -> str:\n        return bytes_as_string(binascii.hexlify(self.digest()))\n\n    def copy(self) -> \"blake2b\":\n        _cp = type(self)(digest_size=self.digest_size)\n        _st = self._state.copy()\n        _cp._state = _st\n        return _cp\n\n    def __reduce__(self) -> NoReturn:\n        \"\"\"\n        Raise the same exception as hashlib's blake implementation\n        on copy.copy()\n        \"\"\"\n        raise TypeError(\n            \"can't pickle {} objects\".format(self.__class__.__name__)\n        )\n\n\ndef scrypt(\n    password: bytes,\n    salt: bytes = b\"\",\n    n: int = 2**20,\n    r: int = 8,\n    p: int = 1,\n    maxmem: int = 2**25,\n    dklen: int = 64,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the scrypt KDF.\n\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    Implements the same signature as the ``hashlib.scrypt`` implemented\n    in cpython version 3.6\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_ll(\n        password, salt, n, r, p, maxmem=maxmem, dklen=dklen\n    )\n", "src/nacl/bindings/crypto_hash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\n# crypto_hash_BYTES = lib.crypto_hash_bytes()\ncrypto_hash_BYTES: int = lib.crypto_hash_sha512_bytes()\ncrypto_hash_sha256_BYTES: int = lib.crypto_hash_sha256_bytes()\ncrypto_hash_sha512_BYTES: int = lib.crypto_hash_sha512_bytes()\n\n\ndef crypto_hash(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_BYTES)\n    rc = lib.crypto_hash(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_BYTES)[:]\n\n\ndef crypto_hash_sha256(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_sha256_BYTES)\n    rc = lib.crypto_hash_sha256(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_sha256_BYTES)[:]\n\n\ndef crypto_hash_sha512(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_sha512_BYTES)\n    rc = lib.crypto_hash_sha512(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_sha512_BYTES)[:]\n", "src/nacl/bindings/crypto_aead.py": "# Copyright 2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Optional\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\"\"\"\nImplementations of authenticated encription with associated data (*AEAD*)\nconstructions building on the chacha20 stream cipher and the poly1305\nauthenticator\n\"\"\"\n\ncrypto_aead_chacha20poly1305_ietf_KEYBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_keybytes()\n)\ncrypto_aead_chacha20poly1305_ietf_NSECBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_nsecbytes()\n)\ncrypto_aead_chacha20poly1305_ietf_NPUBBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_npubbytes()\n)\ncrypto_aead_chacha20poly1305_ietf_ABYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_abytes()\n)\ncrypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_messagebytes_max()\n)\n_aead_chacha20poly1305_ietf_CRYPTBYTES_MAX = (\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\n    + crypto_aead_chacha20poly1305_ietf_ABYTES\n)\n\ncrypto_aead_chacha20poly1305_KEYBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_keybytes()\n)\ncrypto_aead_chacha20poly1305_NSECBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_nsecbytes()\n)\ncrypto_aead_chacha20poly1305_NPUBBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_npubbytes()\n)\ncrypto_aead_chacha20poly1305_ABYTES: int = (\n    lib.crypto_aead_chacha20poly1305_abytes()\n)\ncrypto_aead_chacha20poly1305_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_chacha20poly1305_messagebytes_max()\n)\n_aead_chacha20poly1305_CRYPTBYTES_MAX = (\n    crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\n    + crypto_aead_chacha20poly1305_ABYTES\n)\n\ncrypto_aead_xchacha20poly1305_ietf_KEYBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_keybytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_NSECBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_nsecbytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_NPUBBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_npubbytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_ABYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_abytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_messagebytes_max()\n)\n_aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX = (\n    crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n    + crypto_aead_xchacha20poly1305_ietf_ABYTES\n)\n\n\ndef crypto_aead_chacha20poly1305_ietf_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the IETF ratified chacha20poly1305\n    construction described in RFC7539.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mxout = mlen + crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_chacha20poly1305_ietf_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_ietf_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the IETF ratified chacha20poly1305\n    construction described in RFC7539.\n\n    :param ciphertext:\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_chacha20poly1305_ietf_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_chacha20poly1305_ietf_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_chacha20poly1305_ietf_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the \"legacy\" construction\n    described in draft-agl-tls-chacha20poly1305.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mlen = len(message)\n    mxout = mlen + crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_chacha20poly1305_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the \"legacy\" construction\n    described in draft-agl-tls-chacha20poly1305.\n\n    :param ciphertext: authenticated ciphertext\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_chacha20poly1305_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_chacha20poly1305_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_chacha20poly1305_ABYTES\n\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_chacha20poly1305_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n\n\ndef crypto_aead_xchacha20poly1305_ietf_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the long-nonces xchacha20poly1305\n    construction.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mlen = len(message)\n    mxout = mlen + crypto_aead_xchacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_xchacha20poly1305_ietf_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_xchacha20poly1305_ietf_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the long-nonces xchacha20poly1305\n    construction.\n\n    :param ciphertext: authenticated ciphertext\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_xchacha20poly1305_ietf_ABYTES\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_xchacha20poly1305_ietf_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n", "src/nacl/bindings/crypto_secretbox.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_secretbox_KEYBYTES: int = lib.crypto_secretbox_keybytes()\ncrypto_secretbox_NONCEBYTES: int = lib.crypto_secretbox_noncebytes()\ncrypto_secretbox_ZEROBYTES: int = lib.crypto_secretbox_zerobytes()\ncrypto_secretbox_BOXZEROBYTES: int = lib.crypto_secretbox_boxzerobytes()\ncrypto_secretbox_MACBYTES: int = lib.crypto_secretbox_macbytes()\ncrypto_secretbox_MESSAGEBYTES_MAX: int = (\n    lib.crypto_secretbox_messagebytes_max()\n)\n\n\ndef crypto_secretbox(message: bytes, nonce: bytes, key: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns the message ``message`` with the secret ``key`` and\n    the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param key: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(key) != crypto_secretbox_KEYBYTES:\n        raise exc.ValueError(\"Invalid key\")\n\n    if len(nonce) != crypto_secretbox_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    padded = b\"\\x00\" * crypto_secretbox_ZEROBYTES + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_secretbox(ciphertext, padded, len(padded), nonce, key)\n    ensure(res == 0, \"Encryption failed\", raising=exc.CryptoError)\n\n    ciphertext = ffi.buffer(ciphertext, len(padded))\n    return ciphertext[crypto_secretbox_BOXZEROBYTES:]\n\n\ndef crypto_secretbox_open(\n    ciphertext: bytes, nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt and returns the encrypted message ``ciphertext`` with the secret\n    ``key`` and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param key: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(key) != crypto_secretbox_KEYBYTES:\n        raise exc.ValueError(\"Invalid key\")\n\n    if len(nonce) != crypto_secretbox_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    padded = b\"\\x00\" * crypto_secretbox_BOXZEROBYTES + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_secretbox_open(plaintext, padded, len(padded), nonce, key)\n    ensure(\n        res == 0,\n        \"Decryption failed. Ciphertext failed verification\",\n        raising=exc.CryptoError,\n    )\n\n    plaintext = ffi.buffer(plaintext, len(padded))\n    return plaintext[crypto_secretbox_ZEROBYTES:]\n", "src/nacl/bindings/utils.py": "# Copyright 2013-2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ndef sodium_memcmp(inp1: bytes, inp2: bytes) -> bool:\n    \"\"\"\n    Compare contents of two memory regions in constant time\n    \"\"\"\n    ensure(isinstance(inp1, bytes), raising=exc.TypeError)\n    ensure(isinstance(inp2, bytes), raising=exc.TypeError)\n\n    ln = max(len(inp1), len(inp2))\n\n    buf1 = ffi.new(\"char []\", ln)\n    buf2 = ffi.new(\"char []\", ln)\n\n    ffi.memmove(buf1, inp1, len(inp1))\n    ffi.memmove(buf2, inp2, len(inp2))\n\n    eqL = len(inp1) == len(inp2)\n    eqC = lib.sodium_memcmp(buf1, buf2, ln) == 0\n\n    return eqL and eqC\n\n\ndef sodium_pad(s: bytes, blocksize: int) -> bytes:\n    \"\"\"\n    Pad the input bytearray ``s`` to a multiple of ``blocksize``\n    using the ISO/IEC 7816-4 algorithm\n\n    :param s: input bytes string\n    :type s: bytes\n    :param blocksize:\n    :type blocksize: int\n    :return: padded string\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(s, bytes), raising=exc.TypeError)\n    ensure(isinstance(blocksize, int), raising=exc.TypeError)\n    if blocksize <= 0:\n        raise exc.ValueError\n    s_len = len(s)\n    m_len = s_len + blocksize\n    buf = ffi.new(\"unsigned char []\", m_len)\n    p_len = ffi.new(\"size_t []\", 1)\n    ffi.memmove(buf, s, s_len)\n    rc = lib.sodium_pad(p_len, buf, s_len, blocksize, m_len)\n    ensure(rc == 0, \"Padding failure\", raising=exc.CryptoError)\n    return ffi.buffer(buf, p_len[0])[:]\n\n\ndef sodium_unpad(s: bytes, blocksize: int) -> bytes:\n    \"\"\"\n    Remove ISO/IEC 7816-4 padding from the input byte array ``s``\n\n    :param s: input bytes string\n    :type s: bytes\n    :param blocksize:\n    :type blocksize: int\n    :return: unpadded string\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(s, bytes), raising=exc.TypeError)\n    ensure(isinstance(blocksize, int), raising=exc.TypeError)\n    s_len = len(s)\n    u_len = ffi.new(\"size_t []\", 1)\n    rc = lib.sodium_unpad(u_len, s, s_len, blocksize)\n    if rc != 0:\n        raise exc.CryptoError(\"Unpadding failure\")\n    return s[: u_len[0]]\n\n\ndef sodium_increment(inp: bytes) -> bytes:\n    \"\"\"\n    Increment the value of a byte-sequence interpreted\n    as the little-endian representation of a unsigned big integer.\n\n    :param inp: input bytes buffer\n    :type inp: bytes\n    :return: a byte-sequence representing, as a little-endian\n             unsigned big integer, the value ``to_int(inp)``\n             incremented by one.\n    :rtype: bytes\n\n    \"\"\"\n    ensure(isinstance(inp, bytes), raising=exc.TypeError)\n\n    ln = len(inp)\n    buf = ffi.new(\"unsigned char []\", ln)\n\n    ffi.memmove(buf, inp, ln)\n\n    lib.sodium_increment(buf, ln)\n\n    return ffi.buffer(buf, ln)[:]\n\n\ndef sodium_add(a: bytes, b: bytes) -> bytes:\n    \"\"\"\n    Given a couple of *same-sized* byte sequences, interpreted as the\n    little-endian representation of two unsigned integers, compute\n    the modular addition of the represented values, in constant time for\n    a given common length of the byte sequences.\n\n    :param a: input bytes buffer\n    :type a: bytes\n    :param b: input bytes buffer\n    :type b: bytes\n    :return: a byte-sequence representing, as a little-endian big integer,\n             the integer value of ``(to_int(a) + to_int(b)) mod 2^(8*len(a))``\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(a, bytes), raising=exc.TypeError)\n    ensure(isinstance(b, bytes), raising=exc.TypeError)\n    ln = len(a)\n    ensure(len(b) == ln, raising=exc.TypeError)\n\n    buf_a = ffi.new(\"unsigned char []\", ln)\n    buf_b = ffi.new(\"unsigned char []\", ln)\n\n    ffi.memmove(buf_a, a, ln)\n    ffi.memmove(buf_b, b, ln)\n\n    lib.sodium_add(buf_a, buf_b, ln)\n\n    return ffi.buffer(buf_a, ln)[:]\n", "src/nacl/bindings/crypto_sign.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_sign_BYTES: int = lib.crypto_sign_bytes()\n# crypto_sign_SEEDBYTES = lib.crypto_sign_seedbytes()\ncrypto_sign_SEEDBYTES: int = lib.crypto_sign_secretkeybytes() // 2\ncrypto_sign_PUBLICKEYBYTES: int = lib.crypto_sign_publickeybytes()\ncrypto_sign_SECRETKEYBYTES: int = lib.crypto_sign_secretkeybytes()\n\ncrypto_sign_curve25519_BYTES: int = lib.crypto_box_secretkeybytes()\n\ncrypto_sign_ed25519ph_STATEBYTES: int = lib.crypto_sign_ed25519ph_statebytes()\n\n\ndef crypto_sign_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a randomly generated public key and secret key.\n\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    pk = ffi.new(\"unsigned char[]\", crypto_sign_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_sign_SECRETKEYBYTES)\n\n    rc = lib.crypto_sign_keypair(pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_sign_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_sign_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_sign_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Computes and returns the public key and secret key using the seed ``seed``.\n\n    :param seed: bytes\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    if len(seed) != crypto_sign_SEEDBYTES:\n        raise exc.ValueError(\"Invalid seed\")\n\n    pk = ffi.new(\"unsigned char[]\", crypto_sign_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_sign_SECRETKEYBYTES)\n\n    rc = lib.crypto_sign_seed_keypair(pk, sk, seed)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_sign_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_sign_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_sign(message: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Signs the message ``message`` using the secret key ``sk`` and returns the\n    signed message.\n\n    :param message: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    signed = ffi.new(\"unsigned char[]\", len(message) + crypto_sign_BYTES)\n    signed_len = ffi.new(\"unsigned long long *\")\n\n    rc = lib.crypto_sign(signed, signed_len, message, len(message), sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(signed, signed_len[0])[:]\n\n\ndef crypto_sign_open(signed: bytes, pk: bytes) -> bytes:\n    \"\"\"\n    Verifies the signature of the signed message ``signed`` using the public\n    key ``pk`` and returns the unsigned message.\n\n    :param signed: bytes\n    :param pk: bytes\n    :rtype: bytes\n    \"\"\"\n    message = ffi.new(\"unsigned char[]\", len(signed))\n    message_len = ffi.new(\"unsigned long long *\")\n\n    if (\n        lib.crypto_sign_open(message, message_len, signed, len(signed), pk)\n        != 0\n    ):\n        raise exc.BadSignatureError(\"Signature was forged or corrupt\")\n\n    return ffi.buffer(message, message_len[0])[:]\n\n\ndef crypto_sign_ed25519_pk_to_curve25519(public_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Converts a public Ed25519 key (encoded as bytes ``public_key_bytes``) to\n    a public Curve25519 key as bytes.\n\n    Raises a ValueError if ``public_key_bytes`` is not of length\n    ``crypto_sign_PUBLICKEYBYTES``\n\n    :param public_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(public_key_bytes) != crypto_sign_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid curve public key\")\n\n    curve_public_key_len = crypto_sign_curve25519_BYTES\n    curve_public_key = ffi.new(\"unsigned char[]\", curve_public_key_len)\n\n    rc = lib.crypto_sign_ed25519_pk_to_curve25519(\n        curve_public_key, public_key_bytes\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(curve_public_key, curve_public_key_len)[:]\n\n\ndef crypto_sign_ed25519_sk_to_curve25519(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Converts a secret Ed25519 key (encoded as bytes ``secret_key_bytes``) to\n    a secret Curve25519 key as bytes.\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid curve secret key\")\n\n    curve_secret_key_len = crypto_sign_curve25519_BYTES\n    curve_secret_key = ffi.new(\"unsigned char[]\", curve_secret_key_len)\n\n    rc = lib.crypto_sign_ed25519_sk_to_curve25519(\n        curve_secret_key, secret_key_bytes\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(curve_secret_key, curve_secret_key_len)[:]\n\n\ndef crypto_sign_ed25519_sk_to_pk(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Extract the public Ed25519 key from a secret Ed25519 key (encoded\n    as bytes ``secret_key_bytes``).\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    return secret_key_bytes[crypto_sign_SEEDBYTES:]\n\n\ndef crypto_sign_ed25519_sk_to_seed(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Extract the seed from a secret Ed25519 key (encoded\n    as bytes ``secret_key_bytes``).\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    return secret_key_bytes[:crypto_sign_SEEDBYTES]\n\n\nclass crypto_sign_ed25519ph_state:\n    \"\"\"\n    State object wrapping the sha-512 state used in ed25519ph computation\n    \"\"\"\n\n    __slots__ = [\"state\"]\n\n    def __init__(self) -> None:\n        self.state: bytes = ffi.new(\n            \"unsigned char[]\", crypto_sign_ed25519ph_STATEBYTES\n        )\n\n        rc = lib.crypto_sign_ed25519ph_init(self.state)\n\n        ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n\ndef crypto_sign_ed25519ph_update(\n    edph: crypto_sign_ed25519ph_state, pmsg: bytes\n) -> None:\n    \"\"\"\n    Update the hash state wrapped in edph\n\n    :param edph: the ed25519ph state being updated\n    :type edph: crypto_sign_ed25519ph_state\n    :param pmsg: the partial message\n    :type pmsg: bytes\n    :rtype: None\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(pmsg, bytes),\n        \"pmsg parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    rc = lib.crypto_sign_ed25519ph_update(edph.state, pmsg, len(pmsg))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n\ndef crypto_sign_ed25519ph_final_create(\n    edph: crypto_sign_ed25519ph_state, sk: bytes\n) -> bytes:\n    \"\"\"\n    Create a signature for the data hashed in edph\n    using the secret key sk\n\n    :param edph: the ed25519ph state for the data\n                 being signed\n    :type edph: crypto_sign_ed25519ph_state\n    :param sk: the ed25519 secret key (secret and public part)\n    :type sk: bytes\n    :return: ed25519ph signature\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(sk, bytes),\n        \"secret key parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(sk) == crypto_sign_SECRETKEYBYTES,\n        (\"secret key must be {} bytes long\").format(\n            crypto_sign_SECRETKEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n    signature = ffi.new(\"unsigned char[]\", crypto_sign_BYTES)\n    rc = lib.crypto_sign_ed25519ph_final_create(\n        edph.state, signature, ffi.NULL, sk\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(signature, crypto_sign_BYTES)[:]\n\n\ndef crypto_sign_ed25519ph_final_verify(\n    edph: crypto_sign_ed25519ph_state, signature: bytes, pk: bytes\n) -> bool:\n    \"\"\"\n    Verify a prehashed signature using the public key pk\n\n    :param edph: the ed25519ph state for the data\n                 being verified\n    :type edph: crypto_sign_ed25519ph_state\n    :param signature: the signature being verified\n    :type signature: bytes\n    :param pk: the ed25519 public part of the signing key\n    :type pk: bytes\n    :return: True if the signature is valid\n    :rtype: boolean\n    :raises exc.BadSignatureError: if the signature is not valid\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(signature, bytes),\n        \"signature parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(signature) == crypto_sign_BYTES,\n        (\"signature must be {} bytes long\").format(crypto_sign_BYTES),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(pk, bytes),\n        \"public key parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(pk) == crypto_sign_PUBLICKEYBYTES,\n        (\"public key must be {} bytes long\").format(\n            crypto_sign_PUBLICKEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n    rc = lib.crypto_sign_ed25519ph_final_verify(edph.state, signature, pk)\n    if rc != 0:\n        raise exc.BadSignatureError(\"Signature was forged or corrupt\")\n\n    return True\n", "src/nacl/bindings/crypto_secretstream.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ByteString, Optional, Tuple, cast\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_secretstream_xchacha20poly1305_ABYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_abytes()\n)\ncrypto_secretstream_xchacha20poly1305_HEADERBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_headerbytes()\n)\ncrypto_secretstream_xchacha20poly1305_KEYBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_keybytes()\n)\ncrypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX: int = (\n    lib.crypto_secretstream_xchacha20poly1305_messagebytes_max()\n)\ncrypto_secretstream_xchacha20poly1305_STATEBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_statebytes()\n)\n\n\ncrypto_secretstream_xchacha20poly1305_TAG_MESSAGE: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_message()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_PUSH: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_push()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_REKEY: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_rekey()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_FINAL: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_final()\n)\n\n\ndef crypto_secretstream_xchacha20poly1305_keygen() -> bytes:\n    \"\"\"\n    Generate a key for use with\n    :func:`.crypto_secretstream_xchacha20poly1305_init_push`.\n\n    \"\"\"\n    keybuf = ffi.new(\n        \"unsigned char[]\",\n        crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    )\n    lib.crypto_secretstream_xchacha20poly1305_keygen(keybuf)\n    return ffi.buffer(keybuf)[:]\n\n\nclass crypto_secretstream_xchacha20poly1305_state:\n    \"\"\"\n    An object wrapping the crypto_secretstream_xchacha20poly1305 state.\n\n    \"\"\"\n\n    __slots__ = [\"statebuf\", \"rawbuf\", \"tagbuf\"]\n\n    def __init__(self) -> None:\n        \"\"\"Initialize a clean state object.\"\"\"\n        self.statebuf: ByteString = ffi.new(\n            \"unsigned char[]\",\n            crypto_secretstream_xchacha20poly1305_STATEBYTES,\n        )\n\n        self.rawbuf: Optional[ByteString] = None\n        self.tagbuf: Optional[ByteString] = None\n\n\ndef crypto_secretstream_xchacha20poly1305_init_push(\n    state: crypto_secretstream_xchacha20poly1305_state, key: bytes\n) -> bytes:\n    \"\"\"\n    Initialize a crypto_secretstream_xchacha20poly1305 encryption buffer.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param key: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_KEYBYTES` long\n    :type key: bytes\n    :return: header\n    :rtype: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(key) == crypto_secretstream_xchacha20poly1305_KEYBYTES,\n        \"Invalid key length\",\n        raising=exc.ValueError,\n    )\n\n    headerbuf = ffi.new(\n        \"unsigned char []\",\n        crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    )\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_init_push(\n        state.statebuf, headerbuf, key\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(headerbuf)[:]\n\n\ndef crypto_secretstream_xchacha20poly1305_push(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    m: bytes,\n    ad: Optional[bytes] = None,\n    tag: int = crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n) -> bytes:\n    \"\"\"\n    Add an encrypted message to the secret stream.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param m: the message to encrypt, the maximum length of an individual\n              message is\n              :data:`.crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX`.\n    :type m: bytes\n    :param ad: additional data to include in the authentication tag\n    :type ad: bytes or None\n    :param tag: the message tag, usually\n                :data:`.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE` or\n                :data:`.crypto_secretstream_xchacha20poly1305_TAG_FINAL`.\n    :type tag: int\n    :return: ciphertext\n    :rtype: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(isinstance(m, bytes), \"Message is not bytes\", raising=exc.TypeError)\n    ensure(\n        len(m) <= crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX,\n        \"Message is too long\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        ad is None or isinstance(ad, bytes),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(m) + crypto_secretstream_xchacha20poly1305_ABYTES\n    if state.rawbuf is None or len(state.rawbuf) < clen:\n        state.rawbuf = ffi.new(\"unsigned char[]\", clen)\n\n    if ad is None:\n        ad = ffi.NULL\n        adlen = 0\n    else:\n        adlen = len(ad)\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_push(\n        state.statebuf,\n        state.rawbuf,\n        ffi.NULL,\n        m,\n        len(m),\n        ad,\n        adlen,\n        tag,\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(state.rawbuf, clen)[:]\n\n\ndef crypto_secretstream_xchacha20poly1305_init_pull(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    header: bytes,\n    key: bytes,\n) -> None:\n    \"\"\"\n    Initialize a crypto_secretstream_xchacha20poly1305 decryption buffer.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param header: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_HEADERBYTES` long\n    :type header: bytes\n    :param key: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_KEYBYTES` long\n    :type key: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(header, bytes),\n        \"Header must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(header) == crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n        \"Invalid header length\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(key) == crypto_secretstream_xchacha20poly1305_KEYBYTES,\n        \"Invalid key length\",\n        raising=exc.ValueError,\n    )\n\n    if state.tagbuf is None:\n        state.tagbuf = ffi.new(\"unsigned char *\")\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_init_pull(\n        state.statebuf, header, key\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n\ndef crypto_secretstream_xchacha20poly1305_pull(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    c: bytes,\n    ad: Optional[bytes] = None,\n) -> Tuple[bytes, int]:\n    \"\"\"\n    Read a decrypted message from the secret stream.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param c: the ciphertext to decrypt, the maximum length of an individual\n              ciphertext is\n              :data:`.crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX` +\n              :data:`.crypto_secretstream_xchacha20poly1305_ABYTES`.\n    :type c: bytes\n    :param ad: additional data to include in the authentication tag\n    :type ad: bytes or None\n    :return: (message, tag)\n    :rtype: (bytes, int)\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        state.tagbuf is not None,\n        (\n            \"State must be initialized using \"\n            \"crypto_secretstream_xchacha20poly1305_init_pull\"\n        ),\n        raising=exc.ValueError,\n    )\n    ensure(\n        isinstance(c, bytes),\n        \"Ciphertext is not bytes\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(c) >= crypto_secretstream_xchacha20poly1305_ABYTES,\n        \"Ciphertext is too short\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        len(c)\n        <= (\n            crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX\n            + crypto_secretstream_xchacha20poly1305_ABYTES\n        ),\n        \"Ciphertext is too long\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        ad is None or isinstance(ad, bytes),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(c) - crypto_secretstream_xchacha20poly1305_ABYTES\n    if state.rawbuf is None or len(state.rawbuf) < mlen:\n        state.rawbuf = ffi.new(\"unsigned char[]\", mlen)\n\n    if ad is None:\n        ad = ffi.NULL\n        adlen = 0\n    else:\n        adlen = len(ad)\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_pull(\n        state.statebuf,\n        state.rawbuf,\n        ffi.NULL,\n        state.tagbuf,\n        c,\n        len(c),\n        ad,\n        adlen,\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    # Cast safety: we `ensure` above that `state.tagbuf is not None`.\n    return (\n        ffi.buffer(state.rawbuf, mlen)[:],\n        int(cast(bytes, state.tagbuf)[0]),\n    )\n\n\ndef crypto_secretstream_xchacha20poly1305_rekey(\n    state: crypto_secretstream_xchacha20poly1305_state,\n) -> None:\n    \"\"\"\n    Explicitly change the encryption key in the stream.\n\n    Normally the stream is re-keyed as needed or an explicit ``tag`` of\n    :data:`.crypto_secretstream_xchacha20poly1305_TAG_REKEY` is added to a\n    message to ensure forward secrecy, but this method can be used instead\n    if the re-keying is controlled without adding the tag.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    lib.crypto_secretstream_xchacha20poly1305_rekey(state.statebuf)\n", "src/nacl/bindings/randombytes.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\n\nrandombytes_SEEDBYTES: int = lib.randombytes_seedbytes()\n\n\ndef randombytes(size: int) -> bytes:\n    \"\"\"\n    Returns ``size`` number of random bytes from a cryptographically secure\n    random source.\n\n    :param size: int\n    :rtype: bytes\n    \"\"\"\n    buf = ffi.new(\"unsigned char[]\", size)\n    lib.randombytes(buf, size)\n    return ffi.buffer(buf, size)[:]\n\n\ndef randombytes_buf_deterministic(size: int, seed: bytes) -> bytes:\n    \"\"\"\n    Returns ``size`` number of deterministically generated pseudorandom bytes\n    from a seed\n\n    :param size: int\n    :param seed: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(seed) != randombytes_SEEDBYTES:\n        raise exc.TypeError(\n            \"Deterministic random bytes must be generated from 32 bytes\"\n        )\n\n    buf = ffi.new(\"unsigned char[]\", size)\n    lib.randombytes_buf_deterministic(buf, size, seed)\n    return ffi.buffer(buf, size)[:]\n", "src/nacl/bindings/crypto_kx.py": "# Copyright 2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n__all__ = [\n    \"crypto_kx_keypair\",\n    \"crypto_kx_client_session_keys\",\n    \"crypto_kx_server_session_keys\",\n    \"crypto_kx_PUBLIC_KEY_BYTES\",\n    \"crypto_kx_SECRET_KEY_BYTES\",\n    \"crypto_kx_SEED_BYTES\",\n    \"crypto_kx_SESSION_KEY_BYTES\",\n]\n\n\"\"\"\nImplementations of client, server key exchange\n\"\"\"\ncrypto_kx_PUBLIC_KEY_BYTES: int = lib.crypto_kx_publickeybytes()\ncrypto_kx_SECRET_KEY_BYTES: int = lib.crypto_kx_secretkeybytes()\ncrypto_kx_SEED_BYTES: int = lib.crypto_kx_seedbytes()\ncrypto_kx_SESSION_KEY_BYTES: int = lib.crypto_kx_sessionkeybytes()\n\n\ndef crypto_kx_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate a key pair.\n    This is a duplicate crypto_box_keypair, but\n    is included for api consistency.\n    :return: (public_key, secret_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    public_key = ffi.new(\"unsigned char[]\", crypto_kx_PUBLIC_KEY_BYTES)\n    secret_key = ffi.new(\"unsigned char[]\", crypto_kx_SECRET_KEY_BYTES)\n    res = lib.crypto_kx_keypair(public_key, secret_key)\n    ensure(res == 0, \"Key generation failed.\", raising=exc.CryptoError)\n\n    return (\n        ffi.buffer(public_key, crypto_kx_PUBLIC_KEY_BYTES)[:],\n        ffi.buffer(secret_key, crypto_kx_SECRET_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate a key pair with a given seed.\n    This is functionally the same as crypto_box_seed_keypair, however\n    it uses the blake2b hash primitive instead of sha512.\n    It is included mainly for api consistency when using crypto_kx.\n    :param seed: random seed\n    :type seed: bytes\n    :return: (public_key, secret_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    public_key = ffi.new(\"unsigned char[]\", crypto_kx_PUBLIC_KEY_BYTES)\n    secret_key = ffi.new(\"unsigned char[]\", crypto_kx_SECRET_KEY_BYTES)\n    ensure(\n        isinstance(seed, bytes) and len(seed) == crypto_kx_SEED_BYTES,\n        \"Seed must be a {} byte long bytes sequence\".format(\n            crypto_kx_SEED_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    res = lib.crypto_kx_seed_keypair(public_key, secret_key, seed)\n    ensure(res == 0, \"Key generation failed.\", raising=exc.CryptoError)\n\n    return (\n        ffi.buffer(public_key, crypto_kx_PUBLIC_KEY_BYTES)[:],\n        ffi.buffer(secret_key, crypto_kx_SECRET_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_client_session_keys(\n    client_public_key: bytes,\n    client_secret_key: bytes,\n    server_public_key: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate session keys for the client.\n    :param client_public_key:\n    :type client_public_key: bytes\n    :param client_secret_key:\n    :type client_secret_key: bytes\n    :param server_public_key:\n    :type server_public_key: bytes\n    :return: (rx_key, tx_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    ensure(\n        isinstance(client_public_key, bytes)\n        and len(client_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Client public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(client_secret_key, bytes)\n        and len(client_secret_key) == crypto_kx_SECRET_KEY_BYTES,\n        \"Client secret key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(server_public_key, bytes)\n        and len(server_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Server public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    rx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    tx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    res = lib.crypto_kx_client_session_keys(\n        rx_key, tx_key, client_public_key, client_secret_key, server_public_key\n    )\n    ensure(\n        res == 0,\n        \"Client session key generation failed.\",\n        raising=exc.CryptoError,\n    )\n\n    return (\n        ffi.buffer(rx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n        ffi.buffer(tx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_server_session_keys(\n    server_public_key: bytes,\n    server_secret_key: bytes,\n    client_public_key: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate session keys for the server.\n    :param server_public_key:\n    :type server_public_key: bytes\n    :param server_secret_key:\n    :type server_secret_key: bytes\n    :param client_public_key:\n    :type client_public_key: bytes\n    :return: (rx_key, tx_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    ensure(\n        isinstance(server_public_key, bytes)\n        and len(server_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Server public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(server_secret_key, bytes)\n        and len(server_secret_key) == crypto_kx_SECRET_KEY_BYTES,\n        \"Server secret key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(client_public_key, bytes)\n        and len(client_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Client public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    rx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    tx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    res = lib.crypto_kx_server_session_keys(\n        rx_key, tx_key, server_public_key, server_secret_key, client_public_key\n    )\n    ensure(\n        res == 0,\n        \"Server session key generation failed.\",\n        raising=exc.CryptoError,\n    )\n\n    return (\n        ffi.buffer(rx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n        ffi.buffer(tx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n    )\n", "src/nacl/bindings/sodium_core.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ndef _sodium_init() -> None:\n    ensure(\n        lib.sodium_init() != -1,\n        \"Could not initialize sodium\",\n        raising=exc.RuntimeError,\n    )\n\n\ndef sodium_init() -> None:\n    \"\"\"\n    Initializes sodium, picking the best implementations available for this\n    machine.\n    \"\"\"\n    ffi.init_once(_sodium_init, \"libsodium\")\n", "src/nacl/bindings/crypto_pwhash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\nfrom typing import Tuple\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_pwhash_scryptsalsa208sha256 = bool(\n    lib.PYNACL_HAS_CRYPTO_PWHASH_SCRYPTSALSA208SHA256\n)\n\ncrypto_pwhash_scryptsalsa208sha256_STRPREFIX = b\"\"\ncrypto_pwhash_scryptsalsa208sha256_SALTBYTES = 0\ncrypto_pwhash_scryptsalsa208sha256_STRBYTES = 0\ncrypto_pwhash_scryptsalsa208sha256_PASSWD_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_PASSWD_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_BYTES_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_BYTES_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE = 0\n\nif has_crypto_pwhash_scryptsalsa208sha256:\n    crypto_pwhash_scryptsalsa208sha256_STRPREFIX = ffi.string(\n        ffi.cast(\"char *\", lib.crypto_pwhash_scryptsalsa208sha256_strprefix())\n    )[:]\n    crypto_pwhash_scryptsalsa208sha256_SALTBYTES = (\n        lib.crypto_pwhash_scryptsalsa208sha256_saltbytes()\n    )\n    crypto_pwhash_scryptsalsa208sha256_STRBYTES = (\n        lib.crypto_pwhash_scryptsalsa208sha256_strbytes()\n    )\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_passwd_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_passwd_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_bytes_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_bytes_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_interactive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_interactive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive()\n    )\n\ncrypto_pwhash_ALG_ARGON2I13: int = lib.crypto_pwhash_alg_argon2i13()\ncrypto_pwhash_ALG_ARGON2ID13: int = lib.crypto_pwhash_alg_argon2id13()\ncrypto_pwhash_ALG_DEFAULT: int = lib.crypto_pwhash_alg_default()\n\ncrypto_pwhash_SALTBYTES: int = lib.crypto_pwhash_saltbytes()\ncrypto_pwhash_STRBYTES: int = lib.crypto_pwhash_strbytes()\n\ncrypto_pwhash_PASSWD_MIN: int = lib.crypto_pwhash_passwd_min()\ncrypto_pwhash_PASSWD_MAX: int = lib.crypto_pwhash_passwd_max()\ncrypto_pwhash_BYTES_MIN: int = lib.crypto_pwhash_bytes_min()\ncrypto_pwhash_BYTES_MAX: int = lib.crypto_pwhash_bytes_max()\n\ncrypto_pwhash_argon2i_STRPREFIX: bytes = ffi.string(\n    ffi.cast(\"char *\", lib.crypto_pwhash_argon2i_strprefix())\n)[:]\ncrypto_pwhash_argon2i_MEMLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2i_memlimit_min()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2i_memlimit_max()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2i_opslimit_min()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2i_opslimit_max()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_interactive()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_interactive()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_moderate()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_moderate()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_sensitive()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_sensitive()\n)\n\ncrypto_pwhash_argon2id_STRPREFIX: bytes = ffi.string(\n    ffi.cast(\"char *\", lib.crypto_pwhash_argon2id_strprefix())\n)[:]\ncrypto_pwhash_argon2id_MEMLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2id_memlimit_min()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2id_memlimit_max()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2id_opslimit_min()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2id_opslimit_max()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_interactive()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_interactive()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_moderate()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_moderate()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_sensitive()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_sensitive()\n)\n\nSCRYPT_OPSLIMIT_INTERACTIVE = (\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\n)\nSCRYPT_MEMLIMIT_INTERACTIVE = (\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\n)\nSCRYPT_OPSLIMIT_SENSITIVE = (\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\n)\nSCRYPT_MEMLIMIT_SENSITIVE = (\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\n)\nSCRYPT_SALTBYTES = crypto_pwhash_scryptsalsa208sha256_SALTBYTES\nSCRYPT_STRBYTES = crypto_pwhash_scryptsalsa208sha256_STRBYTES\n\nSCRYPT_PR_MAX = (1 << 30) - 1\nLOG2_UINT64_MAX = 63\nUINT64_MAX = (1 << 64) - 1\nSCRYPT_MAX_MEM = 32 * (1024 * 1024)\n\n\ndef _check_memory_occupation(\n    n: int, r: int, p: int, maxmem: int = SCRYPT_MAX_MEM\n) -> None:\n    ensure(r != 0, \"Invalid block size\", raising=exc.ValueError)\n\n    ensure(p != 0, \"Invalid parallelization factor\", raising=exc.ValueError)\n\n    ensure(\n        (n & (n - 1)) == 0,\n        \"Cost factor must be a power of 2\",\n        raising=exc.ValueError,\n    )\n\n    ensure(n > 1, \"Cost factor must be at least 2\", raising=exc.ValueError)\n\n    ensure(\n        p <= SCRYPT_PR_MAX / r,\n        \"p*r is greater than {}\".format(SCRYPT_PR_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(n < (1 << (16 * r)), raising=exc.ValueError)\n\n    Blen = p * 128 * r\n\n    i = UINT64_MAX / 128\n\n    ensure(n + 2 <= i / r, raising=exc.ValueError)\n\n    Vlen = 32 * r * (n + 2) * 4\n\n    ensure(Blen <= UINT64_MAX - Vlen, raising=exc.ValueError)\n\n    ensure(Blen <= sys.maxsize - Vlen, raising=exc.ValueError)\n\n    ensure(\n        Blen + Vlen <= maxmem,\n        \"Memory limit would be exceeded with the chosen n, r, p\",\n        raising=exc.ValueError,\n    )\n\n\ndef nacl_bindings_pick_scrypt_params(\n    opslimit: int, memlimit: int\n) -> Tuple[int, int, int]:\n    \"\"\"Python implementation of libsodium's pickparams\"\"\"\n\n    if opslimit < 32768:\n        opslimit = 32768\n\n    r = 8\n\n    if opslimit < (memlimit // 32):\n        p = 1\n        maxn = opslimit // (4 * r)\n        for n_log2 in range(1, 63):  # pragma: no branch\n            if (2**n_log2) > (maxn // 2):\n                break\n    else:\n        maxn = memlimit // (r * 128)\n        for n_log2 in range(1, 63):  # pragma: no branch\n            if (2**n_log2) > maxn // 2:\n                break\n\n        maxrp = (opslimit // 4) // (2**n_log2)\n\n        if maxrp > 0x3FFFFFFF:  # pragma: no cover\n            maxrp = 0x3FFFFFFF\n\n        p = maxrp // r\n\n    return n_log2, r, p\n\n\ndef crypto_pwhash_scryptsalsa208sha256_ll(\n    passwd: bytes,\n    salt: bytes,\n    n: int,\n    r: int,\n    p: int,\n    dklen: int = 64,\n    maxmem: int = SCRYPT_MAX_MEM,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` and ``salt``\n    given as input.\n\n    The work factor can be tuned by by picking different\n    values for the parameters\n\n    :param bytes passwd:\n    :param bytes salt:\n    :param bytes salt: *must* be *exactly* :py:const:`.SALTBYTES` long\n    :param int dklen:\n    :param int opslimit:\n    :param int n:\n    :param int r: block size,\n    :param int p: the parallelism factor\n    :param int maxmem: the maximum available memory available for scrypt's\n                       operations\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(isinstance(n, int), raising=TypeError)\n    ensure(isinstance(r, int), raising=TypeError)\n    ensure(isinstance(p, int), raising=TypeError)\n\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n    ensure(isinstance(salt, bytes), raising=TypeError)\n\n    _check_memory_occupation(n, r, p, maxmem)\n\n    buf = ffi.new(\"uint8_t[]\", dklen)\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_ll(\n        passwd, len(passwd), salt, len(salt), n, r, p, buf, dklen\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.buffer(ffi.cast(\"char *\", buf), dklen)[:]\n\n\ndef crypto_pwhash_scryptsalsa208sha256_str(\n    passwd: bytes,\n    opslimit: int = SCRYPT_OPSLIMIT_INTERACTIVE,\n    memlimit: int = SCRYPT_MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` and ``salt``\n    given as input, returning a string representation which includes\n    the salt and the tuning parameters.\n\n    The returned string can be directly stored as a password hash.\n\n    See :py:func:`.crypto_pwhash_scryptsalsa208sha256` for a short\n    discussion about ``opslimit`` and ``memlimit`` values.\n\n    :param bytes passwd:\n    :param int opslimit:\n    :param int memlimit:\n    :return: serialized key hash, including salt and tuning parameters\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    buf = ffi.new(\"char[]\", SCRYPT_STRBYTES)\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_str(\n        buf, passwd, len(passwd), opslimit, memlimit\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in password hashing\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.string(buf)\n\n\ndef crypto_pwhash_scryptsalsa208sha256_str_verify(\n    passwd_hash: bytes, passwd: bytes\n) -> bool:\n    \"\"\"\n    Verifies the ``passwd`` against the ``passwd_hash`` that was generated.\n    Returns True or False depending on the success\n\n    :param passwd_hash: bytes\n    :param passwd: bytes\n    :rtype: boolean\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(passwd_hash) == SCRYPT_STRBYTES - 1,\n        \"Invalid password hash\",\n        raising=exc.ValueError,\n    )\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_str_verify(\n        passwd_hash, passwd, len(passwd)\n    )\n    ensure(ret == 0, \"Wrong password\", raising=exc.InvalidkeyError)\n    # all went well, therefore:\n    return True\n\n\ndef _check_argon2_limits_alg(opslimit: int, memlimit: int, alg: int) -> None:\n    if alg == crypto_pwhash_ALG_ARGON2I13:\n        if memlimit < crypto_pwhash_argon2i_MEMLIMIT_MIN:\n            raise exc.ValueError(\n                \"memlimit must be at least {} bytes\".format(\n                    crypto_pwhash_argon2i_MEMLIMIT_MIN\n                )\n            )\n        elif memlimit > crypto_pwhash_argon2i_MEMLIMIT_MAX:\n            raise exc.ValueError(\n                \"memlimit must be at most {} bytes\".format(\n                    crypto_pwhash_argon2i_MEMLIMIT_MAX\n                )\n            )\n        if opslimit < crypto_pwhash_argon2i_OPSLIMIT_MIN:\n            raise exc.ValueError(\n                \"opslimit must be at least {}\".format(\n                    crypto_pwhash_argon2i_OPSLIMIT_MIN\n                )\n            )\n        elif opslimit > crypto_pwhash_argon2i_OPSLIMIT_MAX:\n            raise exc.ValueError(\n                \"opslimit must be at most {}\".format(\n                    crypto_pwhash_argon2i_OPSLIMIT_MAX\n                )\n            )\n\n    elif alg == crypto_pwhash_ALG_ARGON2ID13:\n        if memlimit < crypto_pwhash_argon2id_MEMLIMIT_MIN:\n            raise exc.ValueError(\n                \"memlimit must be at least {} bytes\".format(\n                    crypto_pwhash_argon2id_MEMLIMIT_MIN\n                )\n            )\n        elif memlimit > crypto_pwhash_argon2id_MEMLIMIT_MAX:\n            raise exc.ValueError(\n                \"memlimit must be at most {} bytes\".format(\n                    crypto_pwhash_argon2id_MEMLIMIT_MAX\n                )\n            )\n        if opslimit < crypto_pwhash_argon2id_OPSLIMIT_MIN:\n            raise exc.ValueError(\n                \"opslimit must be at least {}\".format(\n                    crypto_pwhash_argon2id_OPSLIMIT_MIN\n                )\n            )\n        elif opslimit > crypto_pwhash_argon2id_OPSLIMIT_MAX:\n            raise exc.ValueError(\n                \"opslimit must be at most {}\".format(\n                    crypto_pwhash_argon2id_OPSLIMIT_MAX\n                )\n            )\n    else:\n        raise exc.TypeError(\"Unsupported algorithm\")\n\n\ndef crypto_pwhash_alg(\n    outlen: int,\n    passwd: bytes,\n    salt: bytes,\n    opslimit: int,\n    memlimit: int,\n    alg: int,\n) -> bytes:\n    \"\"\"\n    Derive a raw cryptographic key using the ``passwd`` and the ``salt``\n    given as input to the ``alg`` algorithm.\n\n    :param outlen: the length of the derived key\n    :type outlen: int\n    :param passwd: The input password\n    :type passwd: bytes\n    :param salt:\n    :type salt: bytes\n    :param opslimit: computational cost\n    :type opslimit: int\n    :param memlimit: memory cost\n    :type memlimit: int\n    :param alg: algorithm identifier\n    :type alg: int\n    :return: derived key\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(outlen, int), raising=exc.TypeError)\n    ensure(isinstance(opslimit, int), raising=exc.TypeError)\n    ensure(isinstance(memlimit, int), raising=exc.TypeError)\n    ensure(isinstance(alg, int), raising=exc.TypeError)\n    ensure(isinstance(passwd, bytes), raising=exc.TypeError)\n\n    if len(salt) != crypto_pwhash_SALTBYTES:\n        raise exc.ValueError(\n            \"salt must be exactly {} bytes long\".format(\n                crypto_pwhash_SALTBYTES\n            )\n        )\n\n    if outlen < crypto_pwhash_BYTES_MIN:\n        raise exc.ValueError(\n            \"derived key must be at least {} bytes long\".format(\n                crypto_pwhash_BYTES_MIN\n            )\n        )\n\n    elif outlen > crypto_pwhash_BYTES_MAX:\n        raise exc.ValueError(\n            \"derived key must be at most {} bytes long\".format(\n                crypto_pwhash_BYTES_MAX\n            )\n        )\n\n    _check_argon2_limits_alg(opslimit, memlimit, alg)\n\n    outbuf = ffi.new(\"unsigned char[]\", outlen)\n\n    ret = lib.crypto_pwhash(\n        outbuf, outlen, passwd, len(passwd), salt, opslimit, memlimit, alg\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.buffer(outbuf, outlen)[:]\n\n\ndef crypto_pwhash_str_alg(\n    passwd: bytes,\n    opslimit: int,\n    memlimit: int,\n    alg: int,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` given as input\n    and a random salt, returning a string representation which\n    includes the salt, the tuning parameters and the used algorithm.\n\n    :param passwd: The input password\n    :type passwd: bytes\n    :param opslimit: computational cost\n    :type opslimit: int\n    :param memlimit: memory cost\n    :type memlimit: int\n    :param alg: The algorithm to use\n    :type alg: int\n    :return: serialized derived key and parameters\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(opslimit, int), raising=TypeError)\n    ensure(isinstance(memlimit, int), raising=TypeError)\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n\n    _check_argon2_limits_alg(opslimit, memlimit, alg)\n\n    outbuf = ffi.new(\"char[]\", 128)\n\n    ret = lib.crypto_pwhash_str_alg(\n        outbuf, passwd, len(passwd), opslimit, memlimit, alg\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.string(outbuf)\n\n\ndef crypto_pwhash_str_verify(passwd_hash: bytes, passwd: bytes) -> bool:\n    \"\"\"\n    Verifies the ``passwd`` against a given password hash.\n\n    Returns True on success, raises InvalidkeyError on failure\n    :param passwd_hash: saved password hash\n    :type passwd_hash: bytes\n    :param passwd: password to be checked\n    :type passwd: bytes\n    :return: success\n    :rtype: boolean\n    \"\"\"\n    ensure(isinstance(passwd_hash, bytes), raising=TypeError)\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n    ensure(\n        len(passwd_hash) <= 127,\n        \"Hash must be at most 127 bytes long\",\n        raising=exc.ValueError,\n    )\n\n    ret = lib.crypto_pwhash_str_verify(passwd_hash, passwd, len(passwd))\n\n    ensure(ret == 0, \"Wrong password\", raising=exc.InvalidkeyError)\n    # all went well, therefore:\n    return True\n\n\ncrypto_pwhash_argon2i_str_verify = crypto_pwhash_str_verify\n", "src/nacl/bindings/crypto_core.py": "# Copyright 2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_core_ed25519 = bool(lib.PYNACL_HAS_CRYPTO_CORE_ED25519)\n\ncrypto_core_ed25519_BYTES = 0\ncrypto_core_ed25519_SCALARBYTES = 0\ncrypto_core_ed25519_NONREDUCEDSCALARBYTES = 0\n\nif has_crypto_core_ed25519:\n    crypto_core_ed25519_BYTES = lib.crypto_core_ed25519_bytes()\n    crypto_core_ed25519_SCALARBYTES = lib.crypto_core_ed25519_scalarbytes()\n    crypto_core_ed25519_NONREDUCEDSCALARBYTES = (\n        lib.crypto_core_ed25519_nonreducedscalarbytes()\n    )\n\n\ndef crypto_core_ed25519_is_valid_point(p: bytes) -> bool:\n    \"\"\"\n    Check if ``p`` represents a point on the edwards25519 curve, in canonical\n    form, on the main subgroup, and that the point doesn't have a small order.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: point validity\n    :rtype: bool\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_core_ed25519_BYTES,\n        \"Point must be a crypto_core_ed25519_BYTES long bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    rc = lib.crypto_core_ed25519_is_valid_point(p)\n    return rc == 1\n\n\ndef crypto_core_ed25519_from_uniform(r: bytes) -> bytes:\n    \"\"\"\n    Maps a 32 bytes vector ``r`` to a point. The point is guaranteed to be on the main subgroup.\n    This function directly exposes the Elligator 2 map, uses the high bit to set\n    the sign of the X coordinate, and the resulting point is multiplied by the cofactor.\n\n    :param r: a :py:data:`.crypto_core_ed25519_BYTES` long bytes\n              sequence representing arbitrary data\n    :type r: bytes\n    :return: a point on the edwards25519 curve main order subgroup, represented as a\n             :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(r, bytes) and len(r) == crypto_core_ed25519_BYTES,\n        \"Integer r must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    p = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_from_uniform(p, r)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(p, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_add(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Add two points on the edwards25519 curve.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type q: bytes\n    :return: a point on the edwards25519 curve represented as\n             a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_BYTES\n        and len(q) == crypto_core_ed25519_BYTES,\n        \"Each point must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_add(r, p, q)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_sub(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Subtract a point from another on the edwards25519 curve.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type q: bytes\n    :return: a point on the edwards25519 curve represented as\n             a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_BYTES\n        and len(q) == crypto_core_ed25519_BYTES,\n        \"Each point must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_sub(r, p, q)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_invert(s: bytes) -> bytes:\n    \"\"\"\n    Return the multiplicative inverse of integer ``s`` modulo ``L``,\n    i.e an integer ``i`` such that ``s * i = 1 (mod L)``, where ``L``\n    is the order of the main subgroup.\n\n    Raises a ``exc.RuntimeError`` if ``s`` is the integer zero.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    rc = lib.crypto_core_ed25519_scalar_invert(r, s)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_negate(s: bytes) -> bytes:\n    \"\"\"\n    Return the integer ``n`` such that ``s + n = 0 (mod L)``, where ``L``\n    is the order of the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_negate(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_complement(s: bytes) -> bytes:\n    \"\"\"\n    Return the complement of integer ``s`` modulo ``L``, i.e. an integer\n    ``c`` such that ``s + c = 1 (mod L)``, where ``L`` is the order of\n    the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_complement(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_add(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Add integers ``p`` and ``q`` modulo ``L``, where ``L`` is the order of\n    the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_add(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_sub(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Subtract integers ``p`` and ``q`` modulo ``L``, where ``L`` is the\n    order of the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_sub(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_mul(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Multiply integers ``p`` and ``q`` modulo ``L``, where ``L`` is the\n    order of the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_mul(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_reduce(s: bytes) -> bytes:\n    \"\"\"\n    Reduce integer ``s`` to ``s`` modulo ``L``, where ``L`` is the order\n    of the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_NONREDUCEDSCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes)\n        and len(s) == crypto_core_ed25519_NONREDUCEDSCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_NONREDUCEDSCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_reduce(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n", "src/nacl/bindings/crypto_scalarmult.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_scalarmult_ed25519 = bool(lib.PYNACL_HAS_CRYPTO_SCALARMULT_ED25519)\n\ncrypto_scalarmult_BYTES: int = lib.crypto_scalarmult_bytes()\ncrypto_scalarmult_SCALARBYTES: int = lib.crypto_scalarmult_scalarbytes()\n\ncrypto_scalarmult_ed25519_BYTES = 0\ncrypto_scalarmult_ed25519_SCALARBYTES = 0\n\nif has_crypto_scalarmult_ed25519:\n    crypto_scalarmult_ed25519_BYTES = lib.crypto_scalarmult_ed25519_bytes()\n    crypto_scalarmult_ed25519_SCALARBYTES = (\n        lib.crypto_scalarmult_ed25519_scalarbytes()\n    )\n\n\ndef crypto_scalarmult_base(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n``.\n\n    :param n: bytes\n    :rtype: bytes\n    \"\"\"\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_BYTES)\n\n    rc = lib.crypto_scalarmult_base(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_SCALARBYTES)[:]\n\n\ndef crypto_scalarmult(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of the given group element and an\n    integer ``n``.\n\n    :param p: bytes\n    :param n: bytes\n    :rtype: bytes\n    \"\"\"\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_BYTES)\n\n    rc = lib.crypto_scalarmult(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_SCALARBYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_base(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n`` on the edwards25519 curve.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_base(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_base_noclamp(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n`` on the edwards25519 curve. The integer ``n`` is not clamped.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_base_noclamp(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a *clamped* integer ``n``\n    and the given group element on the edwards25519 curve.\n    The scalar is clamped, as done in the public key generation case,\n    by setting to zero the bits in position [0, 1, 2, 255] and setting\n    to one the bit in position 254.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :param p: a :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_scalarmult_ed25519_BYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_noclamp(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of an integer ``n``\n    and the given group element on the edwards25519 curve. The integer\n    ``n`` is not clamped.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :param p: a :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_scalarmult_ed25519_BYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_noclamp(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n", "src/nacl/bindings/__init__.py": "# Copyright 2013-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl.bindings.crypto_aead import (\n    crypto_aead_chacha20poly1305_ABYTES,\n    crypto_aead_chacha20poly1305_KEYBYTES,\n    crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX,\n    crypto_aead_chacha20poly1305_NPUBBYTES,\n    crypto_aead_chacha20poly1305_NSECBYTES,\n    crypto_aead_chacha20poly1305_decrypt,\n    crypto_aead_chacha20poly1305_encrypt,\n    crypto_aead_chacha20poly1305_ietf_ABYTES,\n    crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX,\n    crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n    crypto_aead_chacha20poly1305_ietf_NSECBYTES,\n    crypto_aead_chacha20poly1305_ietf_decrypt,\n    crypto_aead_chacha20poly1305_ietf_encrypt,\n    crypto_aead_xchacha20poly1305_ietf_ABYTES,\n    crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n    crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX,\n    crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n    crypto_aead_xchacha20poly1305_ietf_NSECBYTES,\n    crypto_aead_xchacha20poly1305_ietf_decrypt,\n    crypto_aead_xchacha20poly1305_ietf_encrypt,\n)\nfrom nacl.bindings.crypto_box import (\n    crypto_box,\n    crypto_box_BEFORENMBYTES,\n    crypto_box_BOXZEROBYTES,\n    crypto_box_NONCEBYTES,\n    crypto_box_PUBLICKEYBYTES,\n    crypto_box_SEALBYTES,\n    crypto_box_SECRETKEYBYTES,\n    crypto_box_SEEDBYTES,\n    crypto_box_ZEROBYTES,\n    crypto_box_afternm,\n    crypto_box_beforenm,\n    crypto_box_keypair,\n    crypto_box_open,\n    crypto_box_open_afternm,\n    crypto_box_seal,\n    crypto_box_seal_open,\n    crypto_box_seed_keypair,\n)\nfrom nacl.bindings.crypto_core import (\n    crypto_core_ed25519_BYTES,\n    crypto_core_ed25519_NONREDUCEDSCALARBYTES,\n    crypto_core_ed25519_SCALARBYTES,\n    crypto_core_ed25519_add,\n    crypto_core_ed25519_from_uniform,\n    crypto_core_ed25519_is_valid_point,\n    crypto_core_ed25519_scalar_add,\n    crypto_core_ed25519_scalar_complement,\n    crypto_core_ed25519_scalar_invert,\n    crypto_core_ed25519_scalar_mul,\n    crypto_core_ed25519_scalar_negate,\n    crypto_core_ed25519_scalar_reduce,\n    crypto_core_ed25519_scalar_sub,\n    crypto_core_ed25519_sub,\n    has_crypto_core_ed25519,\n)\nfrom nacl.bindings.crypto_generichash import (\n    crypto_generichash_BYTES,\n    crypto_generichash_BYTES_MAX,\n    crypto_generichash_BYTES_MIN,\n    crypto_generichash_KEYBYTES,\n    crypto_generichash_KEYBYTES_MAX,\n    crypto_generichash_KEYBYTES_MIN,\n    crypto_generichash_PERSONALBYTES,\n    crypto_generichash_SALTBYTES,\n    crypto_generichash_STATEBYTES,\n    generichash_blake2b_final as crypto_generichash_blake2b_final,\n    generichash_blake2b_init as crypto_generichash_blake2b_init,\n    generichash_blake2b_salt_personal as crypto_generichash_blake2b_salt_personal,\n    generichash_blake2b_update as crypto_generichash_blake2b_update,\n)\nfrom nacl.bindings.crypto_hash import (\n    crypto_hash,\n    crypto_hash_BYTES,\n    crypto_hash_sha256,\n    crypto_hash_sha256_BYTES,\n    crypto_hash_sha512,\n    crypto_hash_sha512_BYTES,\n)\nfrom nacl.bindings.crypto_kx import (\n    crypto_kx_PUBLIC_KEY_BYTES,\n    crypto_kx_SECRET_KEY_BYTES,\n    crypto_kx_SEED_BYTES,\n    crypto_kx_SESSION_KEY_BYTES,\n    crypto_kx_client_session_keys,\n    crypto_kx_keypair,\n    crypto_kx_seed_keypair,\n    crypto_kx_server_session_keys,\n)\nfrom nacl.bindings.crypto_pwhash import (\n    crypto_pwhash_ALG_ARGON2I13,\n    crypto_pwhash_ALG_ARGON2ID13,\n    crypto_pwhash_ALG_DEFAULT,\n    crypto_pwhash_BYTES_MAX,\n    crypto_pwhash_BYTES_MIN,\n    crypto_pwhash_PASSWD_MAX,\n    crypto_pwhash_PASSWD_MIN,\n    crypto_pwhash_SALTBYTES,\n    crypto_pwhash_STRBYTES,\n    crypto_pwhash_alg,\n    crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2i_MEMLIMIT_MAX,\n    crypto_pwhash_argon2i_MEMLIMIT_MIN,\n    crypto_pwhash_argon2i_MEMLIMIT_MODERATE,\n    crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2i_OPSLIMIT_MAX,\n    crypto_pwhash_argon2i_OPSLIMIT_MIN,\n    crypto_pwhash_argon2i_OPSLIMIT_MODERATE,\n    crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_argon2i_STRPREFIX,\n    crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2id_MEMLIMIT_MAX,\n    crypto_pwhash_argon2id_MEMLIMIT_MIN,\n    crypto_pwhash_argon2id_MEMLIMIT_MODERATE,\n    crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2id_OPSLIMIT_MAX,\n    crypto_pwhash_argon2id_OPSLIMIT_MIN,\n    crypto_pwhash_argon2id_OPSLIMIT_MODERATE,\n    crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_argon2id_STRPREFIX,\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MAX,\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MIN,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX,\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN,\n    crypto_pwhash_scryptsalsa208sha256_SALTBYTES,\n    crypto_pwhash_scryptsalsa208sha256_STRBYTES,\n    crypto_pwhash_scryptsalsa208sha256_STRPREFIX,\n    crypto_pwhash_scryptsalsa208sha256_ll,\n    crypto_pwhash_scryptsalsa208sha256_str,\n    crypto_pwhash_scryptsalsa208sha256_str_verify,\n    crypto_pwhash_str_alg,\n    crypto_pwhash_str_verify,\n    has_crypto_pwhash_scryptsalsa208sha256,\n    nacl_bindings_pick_scrypt_params,\n)\nfrom nacl.bindings.crypto_scalarmult import (\n    crypto_scalarmult,\n    crypto_scalarmult_BYTES,\n    crypto_scalarmult_SCALARBYTES,\n    crypto_scalarmult_base,\n    crypto_scalarmult_ed25519,\n    crypto_scalarmult_ed25519_BYTES,\n    crypto_scalarmult_ed25519_SCALARBYTES,\n    crypto_scalarmult_ed25519_base,\n    crypto_scalarmult_ed25519_base_noclamp,\n    crypto_scalarmult_ed25519_noclamp,\n    has_crypto_scalarmult_ed25519,\n)\nfrom nacl.bindings.crypto_secretbox import (\n    crypto_secretbox,\n    crypto_secretbox_BOXZEROBYTES,\n    crypto_secretbox_KEYBYTES,\n    crypto_secretbox_MACBYTES,\n    crypto_secretbox_MESSAGEBYTES_MAX,\n    crypto_secretbox_NONCEBYTES,\n    crypto_secretbox_ZEROBYTES,\n    crypto_secretbox_open,\n)\nfrom nacl.bindings.crypto_secretstream import (\n    crypto_secretstream_xchacha20poly1305_ABYTES,\n    crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    crypto_secretstream_xchacha20poly1305_TAG_FINAL,\n    crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n    crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n    crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n    crypto_secretstream_xchacha20poly1305_init_pull,\n    crypto_secretstream_xchacha20poly1305_init_push,\n    crypto_secretstream_xchacha20poly1305_keygen,\n    crypto_secretstream_xchacha20poly1305_pull,\n    crypto_secretstream_xchacha20poly1305_push,\n    crypto_secretstream_xchacha20poly1305_rekey,\n    crypto_secretstream_xchacha20poly1305_state,\n)\nfrom nacl.bindings.crypto_shorthash import (\n    BYTES as crypto_shorthash_siphash24_BYTES,\n    KEYBYTES as crypto_shorthash_siphash24_KEYBYTES,\n    XBYTES as crypto_shorthash_siphashx24_BYTES,\n    XKEYBYTES as crypto_shorthash_siphashx24_KEYBYTES,\n    crypto_shorthash_siphash24,\n    crypto_shorthash_siphashx24,\n    has_crypto_shorthash_siphashx24,\n)\nfrom nacl.bindings.crypto_sign import (\n    crypto_sign,\n    crypto_sign_BYTES,\n    crypto_sign_PUBLICKEYBYTES,\n    crypto_sign_SECRETKEYBYTES,\n    crypto_sign_SEEDBYTES,\n    crypto_sign_ed25519_pk_to_curve25519,\n    crypto_sign_ed25519_sk_to_curve25519,\n    crypto_sign_ed25519_sk_to_pk,\n    crypto_sign_ed25519_sk_to_seed,\n    crypto_sign_ed25519ph_STATEBYTES,\n    crypto_sign_ed25519ph_final_create,\n    crypto_sign_ed25519ph_final_verify,\n    crypto_sign_ed25519ph_state,\n    crypto_sign_ed25519ph_update,\n    crypto_sign_keypair,\n    crypto_sign_open,\n    crypto_sign_seed_keypair,\n)\nfrom nacl.bindings.randombytes import (\n    randombytes,\n    randombytes_buf_deterministic,\n)\nfrom nacl.bindings.sodium_core import sodium_init\nfrom nacl.bindings.utils import (\n    sodium_add,\n    sodium_increment,\n    sodium_memcmp,\n    sodium_pad,\n    sodium_unpad,\n)\n\n\n__all__ = [\n    \"crypto_aead_chacha20poly1305_ABYTES\",\n    \"crypto_aead_chacha20poly1305_KEYBYTES\",\n    \"crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\",\n    \"crypto_aead_chacha20poly1305_NPUBBYTES\",\n    \"crypto_aead_chacha20poly1305_NSECBYTES\",\n    \"crypto_aead_chacha20poly1305_decrypt\",\n    \"crypto_aead_chacha20poly1305_encrypt\",\n    \"crypto_aead_chacha20poly1305_ietf_ABYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_KEYBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\",\n    \"crypto_aead_chacha20poly1305_ietf_NPUBBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_NSECBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_decrypt\",\n    \"crypto_aead_chacha20poly1305_ietf_encrypt\",\n    \"crypto_aead_xchacha20poly1305_ietf_ABYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_KEYBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\",\n    \"crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_NSECBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_decrypt\",\n    \"crypto_aead_xchacha20poly1305_ietf_encrypt\",\n    \"crypto_box_SECRETKEYBYTES\",\n    \"crypto_box_PUBLICKEYBYTES\",\n    \"crypto_box_SEEDBYTES\",\n    \"crypto_box_NONCEBYTES\",\n    \"crypto_box_ZEROBYTES\",\n    \"crypto_box_BOXZEROBYTES\",\n    \"crypto_box_BEFORENMBYTES\",\n    \"crypto_box_SEALBYTES\",\n    \"crypto_box_keypair\",\n    \"crypto_box\",\n    \"crypto_box_open\",\n    \"crypto_box_beforenm\",\n    \"crypto_box_afternm\",\n    \"crypto_box_open_afternm\",\n    \"crypto_box_seal\",\n    \"crypto_box_seal_open\",\n    \"crypto_box_seed_keypair\",\n    \"has_crypto_core_ed25519\",\n    \"crypto_core_ed25519_BYTES\",\n    \"crypto_core_ed25519_UNIFORMBYTES\",\n    \"crypto_core_ed25519_SCALARBYTES\",\n    \"crypto_core_ed25519_NONREDUCEDSCALARBYTES\",\n    \"crypto_core_ed25519_add\",\n    \"crypto_core_ed25519_from_uniform\",\n    \"crypto_core_ed25519_is_valid_point\",\n    \"crypto_core_ed25519_sub\",\n    \"crypto_core_ed25519_scalar_invert\",\n    \"crypto_core_ed25519_scalar_negate\",\n    \"crypto_core_ed25519_scalar_complement\",\n    \"crypto_core_ed25519_scalar_add\",\n    \"crypto_core_ed25519_scalar_sub\",\n    \"crypto_core_ed25519_scalar_mul\",\n    \"crypto_core_ed25519_scalar_reduce\",\n    \"crypto_hash_BYTES\",\n    \"crypto_hash_sha256_BYTES\",\n    \"crypto_hash_sha512_BYTES\",\n    \"crypto_hash\",\n    \"crypto_hash_sha256\",\n    \"crypto_hash_sha512\",\n    \"crypto_generichash_BYTES\",\n    \"crypto_generichash_BYTES_MIN\",\n    \"crypto_generichash_BYTES_MAX\",\n    \"crypto_generichash_KEYBYTES\",\n    \"crypto_generichash_KEYBYTES_MIN\",\n    \"crypto_generichash_KEYBYTES_MAX\",\n    \"crypto_generichash_SALTBYTES\",\n    \"crypto_generichash_PERSONALBYTES\",\n    \"crypto_generichash_STATEBYTES\",\n    \"crypto_generichash_blake2b_salt_personal\",\n    \"crypto_generichash_blake2b_init\",\n    \"crypto_generichash_blake2b_update\",\n    \"crypto_generichash_blake2b_final\",\n    \"crypto_kx_keypair\",\n    \"crypto_kx_seed_keypair\",\n    \"crypto_kx_client_session_keys\",\n    \"crypto_kx_server_session_keys\",\n    \"crypto_kx_PUBLIC_KEY_BYTES\",\n    \"crypto_kx_SECRET_KEY_BYTES\",\n    \"crypto_kx_SEED_BYTES\",\n    \"crypto_kx_SESSION_KEY_BYTES\",\n    \"has_crypto_scalarmult_ed25519\",\n    \"crypto_scalarmult_BYTES\",\n    \"crypto_scalarmult_SCALARBYTES\",\n    \"crypto_scalarmult\",\n    \"crypto_scalarmult_base\",\n    \"crypto_scalarmult_ed25519_BYTES\",\n    \"crypto_scalarmult_ed25519_SCALARBYTES\",\n    \"crypto_scalarmult_ed25519\",\n    \"crypto_scalarmult_ed25519_base\",\n    \"crypto_scalarmult_ed25519_noclamp\",\n    \"crypto_scalarmult_ed25519_base_noclamp\",\n    \"crypto_secretbox_KEYBYTES\",\n    \"crypto_secretbox_NONCEBYTES\",\n    \"crypto_secretbox_ZEROBYTES\",\n    \"crypto_secretbox_BOXZEROBYTES\",\n    \"crypto_secretbox_MACBYTES\",\n    \"crypto_secretbox_MESSAGEBYTES_MAX\",\n    \"crypto_secretbox\",\n    \"crypto_secretbox_open\",\n    \"crypto_secretstream_xchacha20poly1305_ABYTES\",\n    \"crypto_secretstream_xchacha20poly1305_HEADERBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_KEYBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_STATEBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_FINAL\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_PUSH\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_REKEY\",\n    \"crypto_secretstream_xchacha20poly1305_init_pull\",\n    \"crypto_secretstream_xchacha20poly1305_init_push\",\n    \"crypto_secretstream_xchacha20poly1305_keygen\",\n    \"crypto_secretstream_xchacha20poly1305_pull\",\n    \"crypto_secretstream_xchacha20poly1305_push\",\n    \"crypto_secretstream_xchacha20poly1305_rekey\",\n    \"crypto_secretstream_xchacha20poly1305_state\",\n    \"has_crypto_shorthash_siphashx24\",\n    \"crypto_shorthash_siphash24_BYTES\",\n    \"crypto_shorthash_siphash24_KEYBYTES\",\n    \"crypto_shorthash_siphash24\",\n    \"crypto_shorthash_siphashx24_BYTES\",\n    \"crypto_shorthash_siphashx24_KEYBYTES\",\n    \"crypto_shorthash_siphashx24\",\n    \"crypto_sign_BYTES\",\n    \"crypto_sign_SEEDBYTES\",\n    \"crypto_sign_PUBLICKEYBYTES\",\n    \"crypto_sign_SECRETKEYBYTES\",\n    \"crypto_sign_keypair\",\n    \"crypto_sign_seed_keypair\",\n    \"crypto_sign\",\n    \"crypto_sign_open\",\n    \"crypto_sign_ed25519_pk_to_curve25519\",\n    \"crypto_sign_ed25519_sk_to_curve25519\",\n    \"crypto_sign_ed25519_sk_to_pk\",\n    \"crypto_sign_ed25519_sk_to_seed\",\n    \"crypto_sign_ed25519ph_STATEBYTES\",\n    \"crypto_sign_ed25519ph_final_create\",\n    \"crypto_sign_ed25519ph_final_verify\",\n    \"crypto_sign_ed25519ph_state\",\n    \"crypto_sign_ed25519ph_update\",\n    \"crypto_pwhash_ALG_ARGON2I13\",\n    \"crypto_pwhash_ALG_ARGON2ID13\",\n    \"crypto_pwhash_ALG_DEFAULT\",\n    \"crypto_pwhash_BYTES_MAX\",\n    \"crypto_pwhash_BYTES_MIN\",\n    \"crypto_pwhash_PASSWD_MAX\",\n    \"crypto_pwhash_PASSWD_MIN\",\n    \"crypto_pwhash_SALTBYTES\",\n    \"crypto_pwhash_STRBYTES\",\n    \"crypto_pwhash_alg\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MIN\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MAX\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MIN\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MAX\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2i_STRPREFIX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MIN\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MAX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MIN\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MAX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2id_STRPREFIX\",\n    \"crypto_pwhash_str_alg\",\n    \"crypto_pwhash_str_verify\",\n    \"has_crypto_pwhash_scryptsalsa208sha256\",\n    \"crypto_pwhash_scryptsalsa208sha256_BYTES_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_BYTES_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_SALTBYTES\",\n    \"crypto_pwhash_scryptsalsa208sha256_STRBYTES\",\n    \"crypto_pwhash_scryptsalsa208sha256_STRPREFIX\",\n    \"crypto_pwhash_scryptsalsa208sha256_ll\",\n    \"crypto_pwhash_scryptsalsa208sha256_str\",\n    \"crypto_pwhash_scryptsalsa208sha256_str_verify\",\n    \"nacl_bindings_pick_scrypt_params\",\n    \"randombytes\",\n    \"randombytes_buf_deterministic\",\n    \"sodium_init\",\n    \"sodium_add\",\n    \"sodium_increment\",\n    \"sodium_memcmp\",\n    \"sodium_pad\",\n    \"sodium_unpad\",\n]\n\n\n# Initialize Sodium\nsodium_init()\n", "src/nacl/bindings/crypto_box.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\n__all__ = [\"crypto_box_keypair\", \"crypto_box\"]\n\n\ncrypto_box_SECRETKEYBYTES: int = lib.crypto_box_secretkeybytes()\ncrypto_box_PUBLICKEYBYTES: int = lib.crypto_box_publickeybytes()\ncrypto_box_SEEDBYTES: int = lib.crypto_box_seedbytes()\ncrypto_box_NONCEBYTES: int = lib.crypto_box_noncebytes()\ncrypto_box_ZEROBYTES: int = lib.crypto_box_zerobytes()\ncrypto_box_BOXZEROBYTES: int = lib.crypto_box_boxzerobytes()\ncrypto_box_BEFORENMBYTES: int = lib.crypto_box_beforenmbytes()\ncrypto_box_SEALBYTES: int = lib.crypto_box_sealbytes()\n\n\ndef crypto_box_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a randomly generated public and secret key.\n\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    pk = ffi.new(\"unsigned char[]\", crypto_box_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_box_SECRETKEYBYTES)\n\n    rc = lib.crypto_box_keypair(pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_box_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_box_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_box_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a (public, secret) key pair deterministically generated\n    from an input ``seed``.\n\n    .. warning:: The seed **must** be high-entropy; therefore,\n        its generator **must** be a cryptographic quality\n        random function like, for example, :func:`~nacl.utils.random`.\n\n    .. warning:: The seed **must** be protected and remain secret.\n        Anyone who knows the seed is really in possession of\n        the corresponding PrivateKey.\n\n\n    :param seed: bytes\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    ensure(isinstance(seed, bytes), \"seed must be bytes\", raising=TypeError)\n\n    if len(seed) != crypto_box_SEEDBYTES:\n        raise exc.ValueError(\"Invalid seed\")\n\n    pk = ffi.new(\"unsigned char[]\", crypto_box_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_box_SECRETKEYBYTES)\n\n    rc = lib.crypto_box_seed_keypair(pk, sk, seed)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_box_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_box_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_box(message: bytes, nonce: bytes, pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns a message ``message`` using the secret key ``sk``,\n    public key ``pk``, and the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce size\")\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    padded = (b\"\\x00\" * crypto_box_ZEROBYTES) + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    rc = lib.crypto_box(ciphertext, padded, len(padded), nonce, pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, len(padded))[crypto_box_BOXZEROBYTES:]\n\n\ndef crypto_box_open(\n    ciphertext: bytes, nonce: bytes, pk: bytes, sk: bytes\n) -> bytes:\n    \"\"\"\n    Decrypts and returns an encrypted message ``ciphertext``, using the secret\n    key ``sk``, public key ``pk``, and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce size\")\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    padded = (b\"\\x00\" * crypto_box_BOXZEROBYTES) + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_box_open(plaintext, padded, len(padded), nonce, pk, sk)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, len(padded))[crypto_box_ZEROBYTES:]\n\n\ndef crypto_box_beforenm(pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the shared key for the public key ``pk`` and the\n    secret key ``sk``. This can be used to speed up operations where the same\n    set of keys is going to be used multiple times.\n\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    k = ffi.new(\"unsigned char[]\", crypto_box_BEFORENMBYTES)\n\n    rc = lib.crypto_box_beforenm(k, pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(k, crypto_box_BEFORENMBYTES)[:]\n\n\ndef crypto_box_afternm(message: bytes, nonce: bytes, k: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns the message ``message`` using the shared key ``k`` and\n    the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param k: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    if len(k) != crypto_box_BEFORENMBYTES:\n        raise exc.ValueError(\"Invalid shared key\")\n\n    padded = b\"\\x00\" * crypto_box_ZEROBYTES + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    rc = lib.crypto_box_afternm(ciphertext, padded, len(padded), nonce, k)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, len(padded))[crypto_box_BOXZEROBYTES:]\n\n\ndef crypto_box_open_afternm(\n    ciphertext: bytes, nonce: bytes, k: bytes\n) -> bytes:\n    \"\"\"\n    Decrypts and returns the encrypted message ``ciphertext``, using the shared\n    key ``k`` and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param k: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    if len(k) != crypto_box_BEFORENMBYTES:\n        raise exc.ValueError(\"Invalid shared key\")\n\n    padded = (b\"\\x00\" * crypto_box_BOXZEROBYTES) + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_box_open_afternm(plaintext, padded, len(padded), nonce, k)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, len(padded))[crypto_box_ZEROBYTES:]\n\n\ndef crypto_box_seal(message: bytes, pk: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns a message ``message`` using an ephemeral secret key\n    and the public key ``pk``.\n    The ephemeral public key, which is embedded in the sealed box, is also\n    used, in combination with ``pk``, to derive the nonce needed for the\n    underlying box construct.\n\n    :param message: bytes\n    :param pk: bytes\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"input message must be bytes\",\n        raising=TypeError,\n    )\n\n    ensure(\n        isinstance(pk, bytes), \"public key must be bytes\", raising=TypeError\n    )\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    _mlen = len(message)\n    _clen = crypto_box_SEALBYTES + _mlen\n\n    ciphertext = ffi.new(\"unsigned char[]\", _clen)\n\n    rc = lib.crypto_box_seal(ciphertext, message, _mlen, pk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, _clen)[:]\n\n\ndef crypto_box_seal_open(ciphertext: bytes, pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Decrypts and returns an encrypted message ``ciphertext``, using the\n    recipent's secret key ``sk`` and the sender's ephemeral public key\n    embedded in the sealed box. The box construct nonce is derived from\n    the recipient's public key ``pk`` and the sender's public key.\n\n    :param ciphertext: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"input ciphertext must be bytes\",\n        raising=TypeError,\n    )\n\n    ensure(\n        isinstance(pk, bytes), \"public key must be bytes\", raising=TypeError\n    )\n\n    ensure(\n        isinstance(sk, bytes), \"secret key must be bytes\", raising=TypeError\n    )\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    _clen = len(ciphertext)\n\n    ensure(\n        _clen >= crypto_box_SEALBYTES,\n        (\"Input ciphertext must be at least {} long\").format(\n            crypto_box_SEALBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    _mlen = _clen - crypto_box_SEALBYTES\n\n    # zero-length malloc results are implementation.dependent\n    plaintext = ffi.new(\"unsigned char[]\", max(1, _mlen))\n\n    res = lib.crypto_box_seal_open(plaintext, ciphertext, _clen, pk, sk)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, _mlen)[:]\n", "src/nacl/bindings/crypto_generichash.py": "# Copyright 2013-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import NoReturn, TypeVar\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_generichash_BYTES: int = lib.crypto_generichash_blake2b_bytes()\ncrypto_generichash_BYTES_MIN: int = lib.crypto_generichash_blake2b_bytes_min()\ncrypto_generichash_BYTES_MAX: int = lib.crypto_generichash_blake2b_bytes_max()\ncrypto_generichash_KEYBYTES: int = lib.crypto_generichash_blake2b_keybytes()\ncrypto_generichash_KEYBYTES_MIN: int = (\n    lib.crypto_generichash_blake2b_keybytes_min()\n)\ncrypto_generichash_KEYBYTES_MAX: int = (\n    lib.crypto_generichash_blake2b_keybytes_max()\n)\ncrypto_generichash_SALTBYTES: int = lib.crypto_generichash_blake2b_saltbytes()\ncrypto_generichash_PERSONALBYTES: int = (\n    lib.crypto_generichash_blake2b_personalbytes()\n)\ncrypto_generichash_STATEBYTES: int = lib.crypto_generichash_statebytes()\n\n_OVERLONG = \"{0} length greater than {1} bytes\"\n_TOOBIG = \"{0} greater than {1}\"\n\n\ndef _checkparams(\n    digest_size: int, key: bytes, salt: bytes, person: bytes\n) -> None:\n    \"\"\"Check hash parameters\"\"\"\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(salt, bytes),\n        \"Salt must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(person, bytes),\n        \"Person must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(digest_size, int),\n        \"Digest size must be an integer number\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        digest_size <= crypto_generichash_BYTES_MAX,\n        _TOOBIG.format(\"Digest_size\", crypto_generichash_BYTES_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(key) <= crypto_generichash_KEYBYTES_MAX,\n        _OVERLONG.format(\"Key\", crypto_generichash_KEYBYTES_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(salt) <= crypto_generichash_SALTBYTES,\n        _OVERLONG.format(\"Salt\", crypto_generichash_SALTBYTES),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(person) <= crypto_generichash_PERSONALBYTES,\n        _OVERLONG.format(\"Person\", crypto_generichash_PERSONALBYTES),\n        raising=exc.ValueError,\n    )\n\n\ndef generichash_blake2b_salt_personal(\n    data: bytes,\n    digest_size: int = crypto_generichash_BYTES,\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n) -> bytes:\n    \"\"\"One shot hash interface\n\n    :param data: the input data to the hash function\n    :type data: bytes\n    :param digest_size: must be at most\n                        :py:data:`.crypto_generichash_BYTES_MAX`;\n                        the default digest size is\n                        :py:data:`.crypto_generichash_BYTES`\n    :type digest_size: int\n    :param key: must be at most\n                :py:data:`.crypto_generichash_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: must be at most\n                 :py:data:`.crypto_generichash_SALTBYTES` long;\n                 will be zero-padded if needed\n    :type salt: bytes\n    :param person: must be at most\n                   :py:data:`.crypto_generichash_PERSONALBYTES` long:\n                   will be zero-padded if needed\n    :type person: bytes\n    :return: digest_size long digest\n    :rtype: bytes\n    \"\"\"\n\n    _checkparams(digest_size, key, salt, person)\n\n    ensure(\n        isinstance(data, bytes),\n        \"Input data must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    digest = ffi.new(\"unsigned char[]\", digest_size)\n\n    # both _salt and _personal must be zero-padded to the correct length\n    _salt = ffi.new(\"unsigned char []\", crypto_generichash_SALTBYTES)\n    _person = ffi.new(\"unsigned char []\", crypto_generichash_PERSONALBYTES)\n\n    ffi.memmove(_salt, salt, len(salt))\n    ffi.memmove(_person, person, len(person))\n\n    rc = lib.crypto_generichash_blake2b_salt_personal(\n        digest, digest_size, data, len(data), key, len(key), _salt, _person\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(digest, digest_size)[:]\n\n\n_Blake2State = TypeVar(\"_Blake2State\", bound=\"Blake2State\")\n\n\nclass Blake2State:\n    \"\"\"\n    Python-level wrapper for the crypto_generichash_blake2b state buffer\n    \"\"\"\n\n    __slots__ = [\"_statebuf\", \"digest_size\"]\n\n    def __init__(self, digest_size: int):\n        self._statebuf = ffi.new(\n            \"unsigned char[]\", crypto_generichash_STATEBYTES\n        )\n        self.digest_size = digest_size\n\n    def __reduce__(self) -> NoReturn:\n        \"\"\"\n        Raise the same exception as hashlib's blake implementation\n        on copy.copy()\n        \"\"\"\n        raise TypeError(\n            \"can't pickle {} objects\".format(self.__class__.__name__)\n        )\n\n    def copy(self: _Blake2State) -> _Blake2State:\n        _st = self.__class__(self.digest_size)\n        ffi.memmove(\n            _st._statebuf, self._statebuf, crypto_generichash_STATEBYTES\n        )\n        return _st\n\n\ndef generichash_blake2b_init(\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n    digest_size: int = crypto_generichash_BYTES,\n) -> Blake2State:\n    \"\"\"\n    Create a new initialized blake2b hash state\n\n    :param key: must be at most\n                :py:data:`.crypto_generichash_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: must be at most\n                 :py:data:`.crypto_generichash_SALTBYTES` long;\n                 will be zero-padded if needed\n    :type salt: bytes\n    :param person: must be at most\n                   :py:data:`.crypto_generichash_PERSONALBYTES` long:\n                   will be zero-padded if needed\n    :type person: bytes\n    :param digest_size: must be at most\n                        :py:data:`.crypto_generichash_BYTES_MAX`;\n                        the default digest size is\n                        :py:data:`.crypto_generichash_BYTES`\n    :type digest_size: int\n    :return: a initialized :py:class:`.Blake2State`\n    :rtype: object\n    \"\"\"\n\n    _checkparams(digest_size, key, salt, person)\n\n    state = Blake2State(digest_size)\n\n    # both _salt and _personal must be zero-padded to the correct length\n    _salt = ffi.new(\"unsigned char []\", crypto_generichash_SALTBYTES)\n    _person = ffi.new(\"unsigned char []\", crypto_generichash_PERSONALBYTES)\n\n    ffi.memmove(_salt, salt, len(salt))\n    ffi.memmove(_person, person, len(person))\n\n    rc = lib.crypto_generichash_blake2b_init_salt_personal(\n        state._statebuf, key, len(key), digest_size, _salt, _person\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return state\n\n\ndef generichash_blake2b_update(state: Blake2State, data: bytes) -> None:\n    \"\"\"Update the blake2b hash state\n\n    :param state: a initialized Blake2bState object as returned from\n                     :py:func:`.crypto_generichash_blake2b_init`\n    :type state: :py:class:`.Blake2State`\n    :param data:\n    :type data: bytes\n    \"\"\"\n\n    ensure(\n        isinstance(state, Blake2State),\n        \"State must be a Blake2State object\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(data, bytes),\n        \"Input data must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    rc = lib.crypto_generichash_blake2b_update(\n        state._statebuf, data, len(data)\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n\ndef generichash_blake2b_final(state: Blake2State) -> bytes:\n    \"\"\"Finalize the blake2b hash state and return the digest.\n\n    :param state: a initialized Blake2bState object as returned from\n                     :py:func:`.crypto_generichash_blake2b_init`\n    :type state: :py:class:`.Blake2State`\n    :return: the blake2 digest of the passed-in data stream\n    :rtype: bytes\n    \"\"\"\n\n    ensure(\n        isinstance(state, Blake2State),\n        \"State must be a Blake2State object\",\n        raising=exc.TypeError,\n    )\n\n    _digest = ffi.new(\"unsigned char[]\", crypto_generichash_BYTES_MAX)\n    rc = lib.crypto_generichash_blake2b_final(\n        state._statebuf, _digest, state.digest_size\n    )\n\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n    return ffi.buffer(_digest, state.digest_size)[:]\n", "src/nacl/bindings/crypto_shorthash.py": "# Copyright 2016 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_shorthash_siphashx24 = bool(\n    lib.PYNACL_HAS_CRYPTO_SHORTHASH_SIPHASHX24\n)\n\nBYTES: int = lib.crypto_shorthash_siphash24_bytes()\nKEYBYTES: int = lib.crypto_shorthash_siphash24_keybytes()\n\nXBYTES = 0\nXKEYBYTES = 0\n\nif has_crypto_shorthash_siphashx24:\n    XBYTES = lib.crypto_shorthash_siphashx24_bytes()\n    XKEYBYTES = lib.crypto_shorthash_siphashx24_keybytes()\n\n\ndef crypto_shorthash_siphash24(data: bytes, key: bytes) -> bytes:\n    \"\"\"Compute a fast, cryptographic quality, keyed hash of the input data\n\n    :param data:\n    :type data: bytes\n    :param key: len(key) must be equal to\n                :py:data:`.KEYBYTES` (16)\n    :type key: bytes\n    \"\"\"\n    if len(key) != KEYBYTES:\n        raise exc.ValueError(\n            \"Key length must be exactly {} bytes\".format(KEYBYTES)\n        )\n    digest = ffi.new(\"unsigned char[]\", BYTES)\n    rc = lib.crypto_shorthash_siphash24(digest, data, len(data), key)\n\n    ensure(rc == 0, raising=exc.RuntimeError)\n    return ffi.buffer(digest, BYTES)[:]\n\n\ndef crypto_shorthash_siphashx24(data: bytes, key: bytes) -> bytes:\n    \"\"\"Compute a fast, cryptographic quality, keyed hash of the input data\n\n    :param data:\n    :type data: bytes\n    :param key: len(key) must be equal to\n                :py:data:`.XKEYBYTES` (16)\n    :type key: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_shorthash_siphashx24,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    if len(key) != XKEYBYTES:\n        raise exc.ValueError(\n            \"Key length must be exactly {} bytes\".format(XKEYBYTES)\n        )\n    digest = ffi.new(\"unsigned char[]\", XBYTES)\n    rc = lib.crypto_shorthash_siphashx24(digest, data, len(data), key)\n\n    ensure(rc == 0, raising=exc.RuntimeError)\n    return ffi.buffer(digest, XBYTES)[:]\n", "src/nacl/pwhash/argon2i.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\nimport nacl.encoding\n\nfrom . import _argon2\n\nALG = _argon2.ALG_ARGON2I13\nSTRPREFIX = nacl.bindings.crypto_pwhash_argon2i_STRPREFIX\n\nSALTBYTES = _argon2.SALTBYTES\n\nPASSWD_MIN = _argon2.PASSWD_MIN\nPASSWD_MAX = _argon2.PASSWD_MAX\n\nPWHASH_SIZE = _argon2.PWHASH_SIZE\n\nBYTES_MIN = _argon2.BYTES_MIN\nBYTES_MAX = _argon2.BYTES_MAX\n\nverify = _argon2.verify\n\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MAX\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MIN\n\nOPSLIMIT_INTERACTIVE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE\nMEMLIMIT_INTERACTIVE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE\nOPSLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE\n\nOPSLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MODERATE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the argon2i\n    memory-hard construct.\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n\n    as a guidance for correct settings.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_alg(\n            size, password, salt, opslimit, memlimit, ALG\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    argon2i construct and returning an ascii string that has all\n    the needed info to check against a future password\n\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_alg(\n        password, opslimit, memlimit, ALG\n    )\n", "src/nacl/pwhash/argon2id.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\nimport nacl.encoding\n\nfrom . import _argon2\n\nALG = _argon2.ALG_ARGON2ID13\nSTRPREFIX = nacl.bindings.crypto_pwhash_argon2id_STRPREFIX\n\nSALTBYTES = _argon2.SALTBYTES\n\nPASSWD_MIN = _argon2.PASSWD_MIN\nPASSWD_MAX = _argon2.PASSWD_MAX\n\nPWHASH_SIZE = _argon2.PWHASH_SIZE\n\nBYTES_MIN = _argon2.BYTES_MIN\nBYTES_MAX = _argon2.BYTES_MAX\n\nverify = _argon2.verify\n\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MIN\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MAX\n\nOPSLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE\n)\nMEMLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE\n)\nOPSLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE\n\nOPSLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MODERATE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the argon2id\n    memory-hard construct.\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n\n    as a guidance for correct settings.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_alg(\n            size, password, salt, opslimit, memlimit, ALG\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    argon2id construct and returning an ascii string that has all\n    the needed info to check against a future password\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_alg(\n        password, opslimit, memlimit, ALG\n    )\n", "src/nacl/pwhash/scrypt.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import cast\n\nimport nacl.bindings\nimport nacl.encoding\nfrom nacl import exceptions as exc\nfrom nacl.exceptions import ensure\n\n_strbytes_plus_one = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRBYTES\n\nAVAILABLE = nacl.bindings.has_crypto_pwhash_scryptsalsa208sha256\n\nSTRPREFIX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRPREFIX\n\nSALTBYTES = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_SALTBYTES\n\nPASSWD_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN\nPASSWD_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX\n\nPWHASH_SIZE = _strbytes_plus_one - 1\n\nBYTES_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN\nBYTES_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX\n\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX\n\nOPSLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\n)\nMEMLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\n)\nOPSLIMIT_SENSITIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\n)\nMEMLIMIT_SENSITIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\n)\n\nOPSLIMIT_MODERATE = 8 * OPSLIMIT_INTERACTIVE\nMEMLIMIT_MODERATE = 8 * MEMLIMIT_INTERACTIVE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the scryptsalsa208sha256\n    memory-hard construct.\n\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n\n    as a guidance for correct settings respectively for the\n    interactive login and the long term key protecting sensitive data\n    use cases.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(salt) == SALTBYTES,\n        \"The salt must be exactly %s, not %s bytes long\"\n        % (SALTBYTES, len(salt)),\n        raising=exc.ValueError,\n    )\n\n    n_log2, r, p = nacl.bindings.nacl_bindings_pick_scrypt_params(\n        opslimit, memlimit\n    )\n    maxmem = memlimit + (2**16)\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_scryptsalsa208sha256_ll(\n            password,\n            salt,\n            # Cast safety: n_log2 is a positive integer, and so 2 ** n_log2 is also\n            # a positive integer. Mypy+typeshed can't deduce this, because there's no\n            # way to for them to know that n_log2: int is positive.\n            cast(int, 2**n_log2),\n            r,\n            p,\n            maxmem=maxmem,\n            dklen=size,\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    scryptsalsa208sha256 construct and returning an ascii string\n    that has all the needed info to check against a future password\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_str(\n        password, opslimit, memlimit\n    )\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes the output of scryptsalsa208sha256 and compares it against\n    a user provided password to see if they are the same\n\n    :param password_hash: bytes\n    :param password: bytes\n    :rtype: boolean\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(password_hash) == PWHASH_SIZE,\n        \"The password hash must be exactly %s bytes long\"\n        % nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRBYTES,\n        raising=exc.ValueError,\n    )\n\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_str_verify(\n        password_hash, password\n    )\n", "src/nacl/pwhash/_argon2.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\n\n_argon2_strbytes_plus_one = nacl.bindings.crypto_pwhash_STRBYTES\n\nPWHASH_SIZE = _argon2_strbytes_plus_one - 1\nSALTBYTES = nacl.bindings.crypto_pwhash_SALTBYTES\n\nPASSWD_MIN = nacl.bindings.crypto_pwhash_PASSWD_MIN\nPASSWD_MAX = nacl.bindings.crypto_pwhash_PASSWD_MAX\n\nPWHASH_SIZE = _argon2_strbytes_plus_one - 1\n\nBYTES_MAX = nacl.bindings.crypto_pwhash_BYTES_MAX\nBYTES_MIN = nacl.bindings.crypto_pwhash_BYTES_MIN\n\nALG_ARGON2I13 = nacl.bindings.crypto_pwhash_ALG_ARGON2I13\nALG_ARGON2ID13 = nacl.bindings.crypto_pwhash_ALG_ARGON2ID13\nALG_ARGON2_DEFAULT = nacl.bindings.crypto_pwhash_ALG_DEFAULT\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes a modular crypt encoded argon2i or argon2id stored password hash\n    and checks if the user provided password will hash to the same string\n    when using the stored parameters\n\n    :param password_hash: password hash serialized in modular crypt() format\n    :type password_hash: bytes\n    :param password: user provided password\n    :type password: bytes\n    :rtype: boolean\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_verify(password_hash, password)\n", "src/nacl/pwhash/__init__.py": "# Copyright 2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl.exceptions import CryptPrefixError\n\nfrom . import _argon2, argon2i, argon2id, scrypt\n\nSTRPREFIX = argon2id.STRPREFIX\n\nPWHASH_SIZE = argon2id.PWHASH_SIZE\n\nassert _argon2.ALG_ARGON2_DEFAULT == _argon2.ALG_ARGON2ID13\n# since version 1.0.15 of libsodium\n\nPASSWD_MIN = argon2id.PASSWD_MIN\nPASSWD_MAX = argon2id.PASSWD_MAX\nMEMLIMIT_MAX = argon2id.MEMLIMIT_MAX\nMEMLIMIT_MIN = argon2id.MEMLIMIT_MIN\nOPSLIMIT_MAX = argon2id.OPSLIMIT_MAX\nOPSLIMIT_MIN = argon2id.OPSLIMIT_MIN\nOPSLIMIT_INTERACTIVE = argon2id.OPSLIMIT_INTERACTIVE\nMEMLIMIT_INTERACTIVE = argon2id.MEMLIMIT_INTERACTIVE\nOPSLIMIT_MODERATE = argon2id.OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = argon2id.MEMLIMIT_MODERATE\nOPSLIMIT_SENSITIVE = argon2id.OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = argon2id.MEMLIMIT_SENSITIVE\n\nstr = argon2id.str\n\nassert argon2i.ALG != argon2id.ALG\n\nSCRYPT_SALTBYTES = scrypt.SALTBYTES\nSCRYPT_PWHASH_SIZE = scrypt.PWHASH_SIZE\nSCRYPT_OPSLIMIT_INTERACTIVE = scrypt.OPSLIMIT_INTERACTIVE\nSCRYPT_MEMLIMIT_INTERACTIVE = scrypt.MEMLIMIT_INTERACTIVE\nSCRYPT_OPSLIMIT_SENSITIVE = scrypt.OPSLIMIT_SENSITIVE\nSCRYPT_MEMLIMIT_SENSITIVE = scrypt.MEMLIMIT_SENSITIVE\n\n\nkdf_scryptsalsa208sha256 = scrypt.kdf\nscryptsalsa208sha256_str = scrypt.str\nverify_scryptsalsa208sha256 = scrypt.verify\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes a modular crypt encoded stored password hash derived using one\n    of the algorithms supported by `libsodium` and checks if the user provided\n    password will hash to the same string when using the parameters saved\n    in the stored hash\n    \"\"\"\n    if password_hash.startswith(argon2id.STRPREFIX):\n        return argon2id.verify(password_hash, password)\n    elif password_hash.startswith(argon2i.STRPREFIX):\n        return argon2id.verify(password_hash, password)\n    elif scrypt.AVAILABLE and password_hash.startswith(scrypt.STRPREFIX):\n        return scrypt.verify(password_hash, password)\n    else:\n        raise (\n            CryptPrefixError(\n                \"given password_hash is not in a supported format\"\n            )\n        )\n", "src/bindings/build.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport glob\nimport os.path\nimport sys\n\nfrom cffi import FFI\n\n\n__all__ = [\"ffi\"]\n\n\nHEADERS = glob.glob(\n    os.path.join(os.path.abspath(os.path.dirname(__file__)), \"*.h\")\n)\n\nMINIMAL_HEADERS = glob.glob(\n    os.path.join(os.path.abspath(os.path.dirname(__file__)), \"minimal\", \"*.h\")\n)\n\n\n# Build our FFI instance\nffi = FFI()\n\nfor header in HEADERS:\n    with open(header) as hfile:\n        ffi.cdef(hfile.read())\n\nsource = []\n\n# SODIUM_STATIC controls the visibility of symbols in the headers. (see\n# export.h in the libsodium source tree). If you do not set SODIUM_STATIC\n# when linking against the static library in Windows then the compile will\n# fail with no symbols found.\nif os.getenv(\"PYNACL_SODIUM_STATIC\") is not None:\n    source.append(\"#define SODIUM_STATIC\")\n\nsource.append(\"#include <sodium.h>\")\n\nfor header in MINIMAL_HEADERS:\n    with open(header) as hfile:\n        source.append(hfile.read())\n\nif sys.platform == \"win32\":\n    libraries = [\"libsodium\"]\nelse:\n    libraries = [\"sodium\"]\n\n# Set our source so that we can actually build our bindings to sodium.\nffi.set_source(\"_sodium\", \"\\n\".join(source), libraries=libraries)\n"}