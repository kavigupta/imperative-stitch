{"release.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport getpass\nimport glob\nimport io\nimport json\nimport os\nimport subprocess\nimport time\nimport zipfile\n\nimport click\n\nimport requests\n\n\ndef run(*args, **kwargs):\n    print(\"[running] {}\".format(list(args)))\n    subprocess.check_call(list(args), **kwargs)\n\n\ndef wait_for_build_complete_github_actions(session, token, run_url):\n    while True:\n        response = session.get(\n            run_url,\n            headers={\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"token {}\".format(token),\n            },\n        )\n        response.raise_for_status()\n        if response.json()[\"conclusion\"] is not None:\n            break\n        time.sleep(3)\n\n\ndef download_artifacts_github_actions(session, token, run_url):\n    response = session.get(\n        run_url,\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n\n    response = session.get(\n        response.json()[\"artifacts_url\"],\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n    paths = []\n    for artifact in response.json()[\"artifacts\"]:\n        response = session.get(\n            artifact[\"archive_download_url\"],\n            headers={\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"token {}\".format(token),\n            },\n        )\n        with zipfile.ZipFile(io.BytesIO(response.content)) as z:\n            for name in z.namelist():\n                if not name.endswith(\".whl\"):\n                    continue\n                p = z.open(name)\n                out_path = os.path.join(\n                    os.path.dirname(__file__),\n                    \"dist\",\n                    os.path.basename(name),\n                )\n                with open(out_path, \"wb\") as f:\n                    f.write(p.read())\n                paths.append(out_path)\n    return paths\n\n\ndef build_github_actions_wheels(token, version):\n    session = requests.Session()\n\n    response = session.post(\n        \"https://api.github.com/repos/pyca/pynacl/actions/workflows/\"\n        \"wheel-builder.yml/dispatches\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/vnd.github.v3+json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n        data=json.dumps({\"ref\": \"master\", \"inputs\": {\"version\": version}}),\n    )\n    response.raise_for_status()\n\n    # Give it a few seconds for the run to kick off.\n    time.sleep(5)\n    response = session.get(\n        (\n            \"https://api.github.com/repos/pyca/pynacl/actions/workflows/\"\n            \"wheel-builder.yml/runs?event=repository_dispatch\"\n        ),\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"token {}\".format(token),\n        },\n    )\n    response.raise_for_status()\n    run_url = response.json()[\"workflow_runs\"][0][\"url\"]\n    wait_for_build_complete_github_actions(session, token, run_url)\n    return download_artifacts_github_actions(session, token, run_url)\n\n\n@click.command()\n@click.argument(\"version\")\ndef release(version):\n    \"\"\"\n    ``version`` should be a string like '0.4' or '1.0'.\n    \"\"\"\n    github_token = getpass.getpass(\"Github person access token: \")\n\n    run(\"git\", \"tag\", \"-s\", version, \"-m\", \"{} release\".format(version))\n    run(\"git\", \"push\", \"--tags\")\n\n    run(\"python\", \"setup.py\", \"sdist\")\n\n    sdist = glob.glob(\"dist/PyNaCl-{}*\".format(version))\n\n    github_actions_wheel_paths = build_github_actions_wheels(\n        github_token, version\n    )\n\n    run(\"twine\", \"upload\", *github_actions_wheel_paths)\n    run(\"twine\", \"upload\", \"-s\", *sdist)\n\n\nif __name__ == \"__main__\":\n    release()\n", "setup.py": "#!/usr/bin/env python\n# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport errno\nimport functools\nimport glob\nimport os\nimport os.path\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom sysconfig import get_config_vars\n\nfrom setuptools import Distribution, setup\nfrom setuptools.command.build_clib import build_clib as _build_clib\nfrom setuptools.command.build_ext import build_ext as _build_ext\n\n\nrequirements = []\nsetup_requirements = [\"setuptools\"]\ntest_requirements = [\n    \"pytest>=3.2.1,!=3.3.0\",\n    \"hypothesis>=3.27.0\",\n]\ndocs_requirements = [\"sphinx<7\", \"sphinx_rtd_theme\"]\n\n\nif platform.python_implementation() == \"PyPy\":\n    if sys.pypy_version_info < (2, 6):\n        raise RuntimeError(\n            \"PyNaCl is not compatible with PyPy < 2.6. Please \"\n            \"upgrade PyPy to use this library.\"\n        )\nelse:\n    requirements.append(\"cffi>=1.4.1\")\n    setup_requirements.append(\"cffi>=1.4.1\")\n\n\ndef here(*paths):\n    return os.path.relpath(os.path.join(*paths))\n\n\ndef abshere(*paths):\n    return os.path.abspath(here(*paths))\n\n\nsodium = functools.partial(here, \"src/libsodium/src/libsodium\")\n\n\nsys.path.insert(0, abshere(\"src\"))\n\n\nimport nacl  # noqa\n\n\ndef use_system():\n    install_type = os.environ.get(\"SODIUM_INSTALL\")\n\n    if install_type == \"system\":\n        # If we are forcing system installs, don't compile the bundled one\n        return True\n    else:\n        # By default we just use the bundled copy\n        return False\n\n\nclass Distribution(Distribution):\n    def has_c_libraries(self):\n        return not use_system()\n\n\nclass build_clib(_build_clib):\n    def get_source_files(self):\n        files = glob.glob(here(\"src/libsodium/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*/*\"))\n        files += glob.glob(here(\"src/libsodium/*/*/*/*/*/*\"))\n\n        return files\n\n    def build_libraries(self, libraries):\n        raise Exception(\"build_libraries\")\n\n    def check_library_list(self, libraries):\n        raise Exception(\"check_library_list\")\n\n    def get_library_names(self):\n        return [\"sodium\"]\n\n    def run(self):\n        if use_system():\n            return\n\n        # use Python's build environment variables\n        build_env = {\n            key: val\n            for key, val in get_config_vars().items()\n            if key in (\"LDFLAGS\", \"CFLAGS\", \"CC\", \"CCSHARED\", \"LDSHARED\")\n            and key not in os.environ\n        }\n        os.environ.update(build_env)\n\n        # Ensure our temporary build directory exists\n        build_temp = os.path.abspath(self.build_temp)\n        try:\n            os.makedirs(build_temp)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        # Ensure all of our executable files have their permission set\n        for filename in [\n            \"src/libsodium/autogen.sh\",\n            \"src/libsodium/configure\",\n        ]:\n            os.chmod(here(filename), 0o755)\n\n        if not shutil.which(\"make\"):\n            raise Exception(\"ERROR: The 'make' utility is missing from PATH\")\n\n        # Locate our configure script\n        configure = abshere(\"src/libsodium/configure\")\n\n        # Run ./configure\n        configure_flags = [\n            \"--disable-shared\",\n            \"--enable-static\",\n            \"--disable-debug\",\n            \"--disable-dependency-tracking\",\n            \"--with-pic\",\n        ]\n        if platform.system() == \"SunOS\":\n            # On Solaris, libssp doesn't link statically and causes linker\n            # errors during import\n            configure_flags.append(\"--disable-ssp\")\n        if os.environ.get(\"SODIUM_INSTALL_MINIMAL\"):\n            configure_flags.append(\"--enable-minimal\")\n        subprocess.check_call(\n            [configure]\n            + configure_flags\n            + [\"--prefix\", os.path.abspath(self.build_clib)],\n            cwd=build_temp,\n        )\n\n        make_args = os.environ.get(\"LIBSODIUM_MAKE_ARGS\", \"\").split()\n        # Build the library\n        subprocess.check_call([\"make\"] + make_args, cwd=build_temp)\n\n        # Check the build library\n        subprocess.check_call([\"make\", \"check\"] + make_args, cwd=build_temp)\n\n        # Install the built library\n        subprocess.check_call([\"make\", \"install\"] + make_args, cwd=build_temp)\n\n\nclass build_ext(_build_ext):\n    def run(self):\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command(\"build_clib\")\n            self.include_dirs.append(\n                os.path.join(build_clib.build_clib, \"include\"),\n            )\n            self.library_dirs.insert(\n                0,\n                os.path.join(build_clib.build_clib, \"lib64\"),\n            )\n            self.library_dirs.insert(\n                0,\n                os.path.join(build_clib.build_clib, \"lib\"),\n            )\n\n        return _build_ext.run(self)\n\n\nREADME = open(\"README.rst\").read()\nINSTALL = open(\"INSTALL.rst\").read()\nCHANGELOG = open(\"CHANGELOG.rst\").read()\n\n\nsetup(\n    name=nacl.__title__,\n    version=nacl.__version__,\n    description=nacl.__summary__,\n    long_description=\"\\n\".join((README, INSTALL, CHANGELOG)),\n    url=nacl.__uri__,\n    license=nacl.__license__,\n    author=nacl.__author__,\n    author_email=nacl.__email__,\n    python_requires=\">=3.6\",\n    setup_requires=setup_requirements,\n    install_requires=requirements,\n    extras_require={\"tests\": test_requirements, \"docs\": docs_requirements},\n    tests_require=test_requirements,\n    package_dir={\"\": \"src\"},\n    packages=[\"nacl\", \"nacl.pwhash\", \"nacl.bindings\"],\n    package_data={\"nacl\": [\"py.typed\"]},\n    ext_package=\"nacl\",\n    cffi_modules=[\"src/bindings/build.py:ffi\"],\n    cmdclass={\"build_clib\": build_clib, \"build_ext\": build_ext},\n    distclass=Distribution,\n    zip_safe=False,\n    classifiers=[\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n    ],\n)\n", "src/libsodium/regen-msvc/regen-msvc.py": "#! /usr/bin/env python3\n\nimport glob\nimport os\nimport uuid\n\ndirs = set()\n\ntlv1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlv1 = tlv1 + '    <ClCompile Include=\"..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\ntlv2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlv2 = tlv2 + '    <ClInclude Include=\"..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\ntlf1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlf1 = tlf1 + '    <ClCompile Include=\"..\\\\..\\\\{}\">\\r\\n'.format(file)\n    tlf1 = tlf1 + \"      <Filter>Source Files</Filter>\\r\\n\"\n    tlf1 = tlf1 + \"    </ClCompile>\\r\\n\"\n\ntlf2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    tlf2 = tlf2 + '    <ClInclude Include=\"..\\\\..\\\\{}\">\\r\\n'.format(file)\n    tlf2 = tlf2 + \"      <Filter>Header Files</Filter>\\r\\n\"\n    tlf2 = tlf2 + \"    </ClInclude>\\r\\n\"\n\nv1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    v1 = v1 + '    <ClCompile Include=\"..\\\\..\\\\..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\nv2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    file = file.replace(\"/\", \"\\\\\")\n    v2 = v2 + '    <ClInclude Include=\"..\\\\..\\\\..\\\\..\\\\{}\" />\\r\\n'.format(file)\n\nf1 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.c\", recursive=True):\n    basedir = os.path.dirname(file).replace(\"src/libsodium/\", \"\")\n    t = basedir\n    while t != \"\":\n        dirs.add(t)\n        t = os.path.dirname(t)\n    basedir = basedir.replace(\"/\", \"\\\\\")\n    file = file.replace(\"/\", \"\\\\\")\n    f1 = f1 + '    <ClCompile Include=\"..\\\\..\\\\..\\\\..\\\\{}\">\\r\\n'.format(file)\n    f1 = f1 + \"      <Filter>{}</Filter>\\r\\n\".format(basedir)\n    f1 = f1 + \"    </ClCompile>\\r\\n\"\n\nf2 = \"\"\nfor file in glob.iglob(\"src/libsodium/**/*.h\", recursive=True):\n    basedir = os.path.dirname(file).replace(\"src/libsodium/\", \"\")\n    t = basedir\n    while t != \"\":\n        dirs.add(t)\n        t = os.path.dirname(t)\n    basedir = basedir.replace(\"/\", \"\\\\\")\n    file = file.replace(\"/\", \"\\\\\")\n    f2 = f2 + '    <ClInclude Include=\"..\\\\..\\\\..\\\\..\\\\{}\">\\r\\n'.format(file)\n    f2 = f2 + \"      <Filter>{}</Filter>\\r\\n\".format(basedir)\n    f2 = f2 + \"    </ClInclude>\\r\\n\"\n\nfd = \"\"\ndirs = list(dirs)\ndirs.sort()\nfor dir in dirs:\n    dir = dir.replace(\"/\", \"\\\\\")\n    uid = uuid.uuid3(uuid.UUID(bytes=b\"LibSodiumMSVCUID\"), dir)\n    fd = fd + '    <Filter Include=\"{}\">\\r\\n'.format(dir)\n    fd = fd + \"      <UniqueIdentifier>{{{}}}</UniqueIdentifier>\\r\\n\".format(\n        uid\n    )\n    fd = fd + \"    </Filter>\\r\\n\"\n\n\ndef get_project_configurations(vs_version):\n    projconfig = \"\"\n    configs = [\n        \"DebugDLL\",\n        \"ReleaseDLL\",\n        \"DebugLIB\",\n        \"ReleaseLIB\",\n        \"DebugLTCG\",\n        \"ReleaseLTCG\",\n    ]\n    platforms = [\"Win32\", \"x64\"]\n    # add arm64 platform only for v142+ toolchain\n    if vs_version >= 142:\n        platforms.append(\"ARM64\")\n    for config in configs:\n        for platform in platforms:\n            projconfig = (\n                projconfig\n                + '    <ProjectConfiguration Include=\"{}|{}\">\\r\\n'.format(\n                    config, platform\n                )\n            )\n            projconfig = (\n                projconfig\n                + \"      <Configuration>{}</Configuration>\\r\\n\".format(config)\n            )\n            projconfig = (\n                projconfig\n                + \"      <Platform>{}</Platform>\\r\\n\".format(platform)\n            )\n            projconfig = projconfig + \"    </ProjectConfiguration>\\r\\n\"\n    return projconfig\n\n\ndef apply_template(tplfile, outfile, sbox):\n    tpl = \"\"\n    with open(tplfile, \"rb\") as fd:\n        tpl = fd.read()\n    for s in sbox.keys():\n        tpl = tpl.replace(\n            str.encode(\"{{\" + s + \"}}\", \"utf8\"),\n            str.encode(str.strip(sbox[s]), \"utf8\"),\n        )\n\n    with open(outfile, \"wb\") as fd:\n        fd.write(tpl)\n\n\nsbox = {\n    \"tlv1\": tlv1,\n    \"tlv2\": tlv2,\n    \"tlf1\": tlf1,\n    \"tlf2\": tlf2,\n    \"v1\": v1,\n    \"v2\": v2,\n    \"f1\": f1,\n    \"f2\": f2,\n    \"fd\": fd,\n}\n\nsd = os.path.dirname(os.path.realpath(__file__))\n\napply_template(\n    sd + \"/tl_libsodium.vcxproj.filters.tpl\",\n    \"ci/appveyor/libsodium.vcxproj.filters\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v140\"})\nsbox.update({\"configurations\": get_project_configurations(140)})\napply_template(\n    sd + \"/tl_libsodium.vcxproj.tpl\", \"ci/appveyor/libsodium.vcxproj\", sbox\n)\n\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2022/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2019/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2017/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2015/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2013/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2012/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\napply_template(\n    sd + \"/libsodium.vcxproj.filters.tpl\",\n    \"builds/msvc/vs2010/libsodium/libsodium.vcxproj.filters\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v143\"})\nsbox.update({\"configurations\": get_project_configurations(143)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2022/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v142\"})\nsbox.update({\"configurations\": get_project_configurations(142)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2019/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v141\"})\nsbox.update({\"configurations\": get_project_configurations(141)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2017/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v140\"})\nsbox.update({\"configurations\": get_project_configurations(140)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2015/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v120\"})\nsbox.update({\"configurations\": get_project_configurations(120)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2013/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v110\"})\nsbox.update({\"configurations\": get_project_configurations(110)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2012/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n\nsbox.update({\"platform\": \"v100\"})\nsbox.update({\"configurations\": get_project_configurations(100)})\napply_template(\n    sd + \"/libsodium.vcxproj.tpl\",\n    \"builds/msvc/vs2010/libsodium/libsodium.vcxproj\",\n    sbox,\n)\n", "src/nacl/public.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ClassVar, Generic, Optional, Type, TypeVar\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.encoding import Encoder\nfrom nacl.utils import EncryptedMessage, StringFixer, random\n\n\nclass PublicKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    The public key counterpart to an Curve25519 :class:`nacl.public.PrivateKey`\n    for encrypting messages.\n\n    :param public_key: [:class:`bytes`] Encoded Curve25519 public key\n    :param encoder: A class that is able to decode the `public_key`\n\n    :cvar SIZE: The size that the public key is required to be\n    \"\"\"\n\n    SIZE: ClassVar[int] = nacl.bindings.crypto_box_PUBLICKEYBYTES\n\n    def __init__(\n        self,\n        public_key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        self._public_key = encoder.decode(public_key)\n        if not isinstance(self._public_key, bytes):\n            raise exc.TypeError(\"PublicKey must be created from 32 bytes\")\n\n        if len(self._public_key) != self.SIZE:\n            raise exc.ValueError(\n                \"The public key must be exactly {} bytes long\".format(\n                    self.SIZE\n                )\n            )\n\n    def __bytes__(self) -> bytes:\n        return self._public_key\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n\nclass PrivateKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    Private key for decrypting messages using the Curve25519 algorithm.\n\n    .. warning:: This **must** be protected and remain secret. Anyone who\n        knows the value of your :class:`~nacl.public.PrivateKey` can decrypt\n        any message encrypted by the corresponding\n        :class:`~nacl.public.PublicKey`\n\n    :param private_key: The private key used to decrypt messages\n    :param encoder: The encoder class used to decode the given keys\n\n    :cvar SIZE: The size that the private key is required to be\n    :cvar SEED_SIZE: The size that the seed used to generate the\n                     private key is required to be\n    \"\"\"\n\n    SIZE: ClassVar[int] = nacl.bindings.crypto_box_SECRETKEYBYTES\n    SEED_SIZE: ClassVar[int] = nacl.bindings.crypto_box_SEEDBYTES\n\n    def __init__(\n        self,\n        private_key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        # Decode the secret_key\n        private_key = encoder.decode(private_key)\n        # verify the given secret key type and size are correct\n        if not (\n            isinstance(private_key, bytes) and len(private_key) == self.SIZE\n        ):\n            raise exc.TypeError(\n                (\n                    \"PrivateKey must be created from a {} \"\n                    \"bytes long raw secret key\"\n                ).format(self.SIZE)\n            )\n\n        raw_public_key = nacl.bindings.crypto_scalarmult_base(private_key)\n\n        self._private_key = private_key\n        self.public_key = PublicKey(raw_public_key)\n\n    @classmethod\n    def from_seed(\n        cls,\n        seed: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> \"PrivateKey\":\n        \"\"\"\n        Generate a PrivateKey using a deterministic construction\n        starting from a caller-provided seed\n\n        .. warning:: The seed **must** be high-entropy; therefore,\n            its generator **must** be a cryptographic quality\n            random function like, for example, :func:`~nacl.utils.random`.\n\n        .. warning:: The seed **must** be protected and remain secret.\n            Anyone who knows the seed is really in possession of\n            the corresponding PrivateKey.\n\n        :param seed: The seed used to generate the private key\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        # decode the seed\n        seed = encoder.decode(seed)\n        # Verify the given seed type and size are correct\n        if not (isinstance(seed, bytes) and len(seed) == cls.SEED_SIZE):\n            raise exc.TypeError(\n                (\n                    \"PrivateKey seed must be a {} bytes long \"\n                    \"binary sequence\"\n                ).format(cls.SEED_SIZE)\n            )\n        # generate a raw key pair from the given seed\n        raw_pk, raw_sk = nacl.bindings.crypto_box_seed_keypair(seed)\n        # construct a instance from the raw secret key\n        return cls(raw_sk)\n\n    def __bytes__(self) -> bytes:\n        return self._private_key\n\n    def __hash__(self) -> int:\n        return hash((type(self), bytes(self.public_key)))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return self.public_key == other.public_key\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    @classmethod\n    def generate(cls) -> \"PrivateKey\":\n        \"\"\"\n        Generates a random :class:`~nacl.public.PrivateKey` object\n\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        return cls(random(PrivateKey.SIZE), encoder=encoding.RawEncoder)\n\n\n_Box = TypeVar(\"_Box\", bound=\"Box\")\n\n\nclass Box(encoding.Encodable, StringFixer):\n    \"\"\"\n    The Box class boxes and unboxes messages between a pair of keys\n\n    The ciphertexts generated by :class:`~nacl.public.Box` include a 16\n    byte authenticator which is checked as part of the decryption. An invalid\n    authenticator will cause the decrypt function to raise an exception. The\n    authenticator is not a signature. Once you've decrypted the message you've\n    demonstrated the ability to create arbitrary valid message, so messages you\n    send are repudiable. For non-repudiable messages, sign them after\n    encryption.\n\n    :param private_key: :class:`~nacl.public.PrivateKey` used to encrypt and\n        decrypt messages\n    :param public_key: :class:`~nacl.public.PublicKey` used to encrypt and\n        decrypt messages\n\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    \"\"\"\n\n    NONCE_SIZE: ClassVar[int] = nacl.bindings.crypto_box_NONCEBYTES\n    _shared_key: bytes\n\n    def __init__(self, private_key: PrivateKey, public_key: PublicKey):\n        if not isinstance(private_key, PrivateKey) or not isinstance(\n            public_key, PublicKey\n        ):\n            raise exc.TypeError(\n                \"Box must be created from a PrivateKey and a PublicKey\"\n            )\n        self._shared_key = nacl.bindings.crypto_box_beforenm(\n            public_key.encode(encoder=encoding.RawEncoder),\n            private_key.encode(encoder=encoding.RawEncoder),\n        )\n\n    def __bytes__(self) -> bytes:\n        return self._shared_key\n\n    @classmethod\n    def decode(\n        cls: Type[_Box], encoded: bytes, encoder: Encoder = encoding.RawEncoder\n    ) -> _Box:\n        \"\"\"\n        Alternative constructor. Creates a Box from an existing Box's shared key.\n        \"\"\"\n        # Create an empty box\n        box: _Box = cls.__new__(cls)\n\n        # Assign our decoded value to the shared key of the box\n        box._shared_key = encoder.decode(encoded)\n\n        return box\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is **VITALLY** important that the nonce is a nonce,\n            i.e. it is a number used only once for any given key. If you fail\n            to do this, you compromise the privacy of the messages encrypted.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE\n            )\n\n        ciphertext = nacl.bindings.crypto_box_afternm(\n            plaintext,\n            nonce,\n            self._shared_key,\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE\n            )\n\n        plaintext = nacl.bindings.crypto_box_open_afternm(\n            ciphertext,\n            nonce,\n            self._shared_key,\n        )\n\n        return plaintext\n\n    def shared_key(self) -> bytes:\n        \"\"\"\n        Returns the Curve25519 shared secret, that can then be used as a key in\n        other symmetric ciphers.\n\n        .. warning:: It is **VITALLY** important that you use a nonce with your\n            symmetric cipher. If you fail to do this, you compromise the\n            privacy of the messages encrypted. Ensure that the key length of\n            your cipher is 32 bytes.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n\n        return self._shared_key\n\n\n_Key = TypeVar(\"_Key\", PublicKey, PrivateKey)\n\n\nclass SealedBox(Generic[_Key], encoding.Encodable, StringFixer):\n    \"\"\"\n    The SealedBox class boxes and unboxes messages addressed to\n    a specified key-pair by using ephemeral sender's key pairs,\n    whose private part will be discarded just after encrypting\n    a single plaintext message.\n\n    The ciphertexts generated by :class:`~nacl.public.SecretBox` include\n    the public part of the ephemeral key before the :class:`~nacl.public.Box`\n    ciphertext.\n\n    :param recipient_key: a :class:`~nacl.public.PublicKey` used to encrypt\n        messages and derive nonces, or a :class:`~nacl.public.PrivateKey` used\n        to decrypt messages.\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    _public_key: bytes\n    _private_key: Optional[bytes]\n\n    def __init__(self, recipient_key: _Key):\n        if isinstance(recipient_key, PublicKey):\n            self._public_key = recipient_key.encode(\n                encoder=encoding.RawEncoder\n            )\n            self._private_key = None\n        elif isinstance(recipient_key, PrivateKey):\n            self._private_key = recipient_key.encode(\n                encoder=encoding.RawEncoder\n            )\n            self._public_key = recipient_key.public_key.encode(\n                encoder=encoding.RawEncoder\n            )\n        else:\n            raise exc.TypeError(\n                \"SealedBox must be created from a PublicKey or a PrivateKey\"\n            )\n\n    def __bytes__(self) -> bytes:\n        return self._public_key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Encrypts the plaintext message using a random-generated ephemeral\n        key pair and returns a \"composed ciphertext\", containing both\n        the public part of the key pair and the ciphertext proper,\n        encoded with the encoder.\n\n        The private part of the ephemeral key-pair will be scrubbed before\n        returning the ciphertext, therefore, the sender will not be able to\n        decrypt the generated ciphertext.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param encoder: The encoder to use to encode the ciphertext\n        :return bytes: encoded ciphertext\n        \"\"\"\n\n        ciphertext = nacl.bindings.crypto_box_seal(plaintext, self._public_key)\n\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return encoded_ciphertext\n\n    def decrypt(\n        self: \"SealedBox[PrivateKey]\",\n        ciphertext: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the ephemeral public key enclosed\n        in the ciphertext and the SealedBox private key, returning\n        the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param encoder: The encoder used to decode the ciphertext.\n        :return bytes: The original plaintext\n        :raises TypeError: if this SealedBox was created with a\n            :class:`~nacl.public.PublicKey` rather than a\n            :class:`~nacl.public.PrivateKey`.\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if self._private_key is None:\n            raise TypeError(\n                \"SealedBoxes created with a public key cannot decrypt\"\n            )\n        plaintext = nacl.bindings.crypto_box_seal_open(\n            ciphertext,\n            self._public_key,\n            self._private_key,\n        )\n\n        return plaintext\n", "src/nacl/exceptions.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n# We create a clone of various builtin Exception types which additionally\n# inherit from CryptoError. Below, we refer to the parent types via the\n# `builtins` namespace, so mypy can distinguish between (e.g.)\n# `nacl.exceptions.RuntimeError` and `builtins.RuntimeError`.\nimport builtins\nfrom typing import Type\n\n\nclass CryptoError(Exception):\n    \"\"\"\n    Base exception for all nacl related errors\n    \"\"\"\n\n\nclass BadSignatureError(CryptoError):\n    \"\"\"\n    Raised when the signature was forged or otherwise corrupt.\n    \"\"\"\n\n\nclass RuntimeError(builtins.RuntimeError, CryptoError):\n    pass\n\n\nclass AssertionError(builtins.AssertionError, CryptoError):\n    pass\n\n\nclass TypeError(builtins.TypeError, CryptoError):\n    pass\n\n\nclass ValueError(builtins.ValueError, CryptoError):\n    pass\n\n\nclass InvalidkeyError(CryptoError):\n    pass\n\n\nclass CryptPrefixError(InvalidkeyError):\n    pass\n\n\nclass UnavailableError(RuntimeError):\n    \"\"\"\n    is a subclass of :class:`~nacl.exceptions.RuntimeError`, raised when\n    trying to call functions not available in a minimal build of\n    libsodium.\n    \"\"\"\n\n    pass\n\n\ndef ensure(cond: bool, *args: object, **kwds: Type[Exception]) -> None:\n    \"\"\"\n    Return if a condition is true, otherwise raise a caller-configurable\n    :py:class:`Exception`\n    :param bool cond: the condition to be checked\n    :param sequence args: the arguments to be passed to the exception's\n                          constructor\n    The only accepted named parameter is `raising` used to configure the\n    exception to be raised if `cond` is not `True`\n    \"\"\"\n    _CHK_UNEXP = \"check_condition() got an unexpected keyword argument {0}\"\n\n    raising = kwds.pop(\"raising\", AssertionError)\n    if kwds:\n        raise TypeError(_CHK_UNEXP.format(repr(kwds.popitem()[0])))\n\n    if cond is True:\n        return\n    raise raising(*args)\n", "src/nacl/utils.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport os\nfrom typing import SupportsBytes, Type, TypeVar\n\nimport nacl.bindings\nfrom nacl import encoding\n\n_EncryptedMessage = TypeVar(\"_EncryptedMessage\", bound=\"EncryptedMessage\")\n\n\nclass EncryptedMessage(bytes):\n    \"\"\"\n    A bytes subclass that holds a messaged that has been encrypted by a\n    :class:`SecretBox`.\n    \"\"\"\n\n    _nonce: bytes\n    _ciphertext: bytes\n\n    @classmethod\n    def _from_parts(\n        cls: Type[_EncryptedMessage],\n        nonce: bytes,\n        ciphertext: bytes,\n        combined: bytes,\n    ) -> _EncryptedMessage:\n        obj = cls(combined)\n        obj._nonce = nonce\n        obj._ciphertext = ciphertext\n        return obj\n\n    @property\n    def nonce(self) -> bytes:\n        \"\"\"\n        The nonce used during the encryption of the :class:`EncryptedMessage`.\n        \"\"\"\n        return self._nonce\n\n    @property\n    def ciphertext(self) -> bytes:\n        \"\"\"\n        The ciphertext contained within the :class:`EncryptedMessage`.\n        \"\"\"\n        return self._ciphertext\n\n\nclass StringFixer:\n    def __str__(self: SupportsBytes) -> str:\n        return str(self.__bytes__())\n\n\ndef bytes_as_string(bytes_in: bytes) -> str:\n    return bytes_in.decode(\"ascii\")\n\n\ndef random(size: int = 32) -> bytes:\n    return os.urandom(size)\n\n\ndef randombytes_deterministic(\n    size: int, seed: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n) -> bytes:\n    \"\"\"\n    Returns ``size`` number of deterministically generated pseudorandom bytes\n    from a seed\n\n    :param size: int\n    :param seed: bytes\n    :param encoder: The encoder class used to encode the produced bytes\n    :rtype: bytes\n    \"\"\"\n    raw_data = nacl.bindings.randombytes_buf_deterministic(size, seed)\n\n    return encoder.encode(raw_data)\n", "src/nacl/hash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nThe :mod:`nacl.hash` module exposes one-shot interfaces\nfor libsodium selected hash primitives and the constants needed\nfor their usage.\n\"\"\"\n\n\nimport nacl.bindings\nimport nacl.encoding\n\n\nBLAKE2B_BYTES = nacl.bindings.crypto_generichash_BYTES\n\"\"\"Default digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_BYTES_MIN = nacl.bindings.crypto_generichash_BYTES_MIN\n\"\"\"Minimum allowed digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_BYTES_MAX = nacl.bindings.crypto_generichash_BYTES_MAX\n\"\"\"Maximum allowed digest size for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES = nacl.bindings.crypto_generichash_KEYBYTES\n\"\"\"Default size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES_MIN = nacl.bindings.crypto_generichash_KEYBYTES_MIN\n\"\"\"Minimum allowed size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_KEYBYTES_MAX = nacl.bindings.crypto_generichash_KEYBYTES_MAX\n\"\"\"Maximum allowed size of the ``key`` byte array for :func:`blake2b` hash\"\"\"\nBLAKE2B_SALTBYTES = nacl.bindings.crypto_generichash_SALTBYTES\n\"\"\"Maximum allowed length of the ``salt`` byte array for\n:func:`blake2b` hash\"\"\"\nBLAKE2B_PERSONALBYTES = nacl.bindings.crypto_generichash_PERSONALBYTES\n\"\"\"Maximum allowed length of the ``personalization``\nbyte array for :func:`blake2b` hash\"\"\"\n\nSIPHASH_BYTES = nacl.bindings.crypto_shorthash_siphash24_BYTES\n\"\"\"Size of the :func:`siphash24` digest\"\"\"\nSIPHASH_KEYBYTES = nacl.bindings.crypto_shorthash_siphash24_KEYBYTES\n\"\"\"Size of the secret ``key`` used by the :func:`siphash24` MAC\"\"\"\n\nSIPHASHX_AVAILABLE = nacl.bindings.has_crypto_shorthash_siphashx24\n\"\"\"``True`` if :func:`siphashx24` is available to be called\"\"\"\n\nSIPHASHX_BYTES = nacl.bindings.crypto_shorthash_siphashx24_BYTES\n\"\"\"Size of the :func:`siphashx24` digest\"\"\"\nSIPHASHX_KEYBYTES = nacl.bindings.crypto_shorthash_siphashx24_KEYBYTES\n\"\"\"Size of the secret ``key`` used by the :func:`siphashx24` MAC\"\"\"\n\n_b2b_hash = nacl.bindings.crypto_generichash_blake2b_salt_personal\n_sip_hash = nacl.bindings.crypto_shorthash_siphash24\n_sip_hashx = nacl.bindings.crypto_shorthash_siphashx24\n\n\ndef sha256(\n    message: bytes, encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder\n) -> bytes:\n    \"\"\"\n    Hashes ``message`` with SHA256.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n    return encoder.encode(nacl.bindings.crypto_hash_sha256(message))\n\n\ndef sha512(\n    message: bytes, encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder\n) -> bytes:\n    \"\"\"\n    Hashes ``message`` with SHA512.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n    return encoder.encode(nacl.bindings.crypto_hash_sha512(message))\n\n\ndef blake2b(\n    data: bytes,\n    digest_size: int = BLAKE2B_BYTES,\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Hashes ``data`` with blake2b.\n\n    :param data: the digest input byte sequence\n    :type data: bytes\n    :param digest_size: the requested digest size; must be at most\n                        :const:`BLAKE2B_BYTES_MAX`;\n                        the default digest size is\n                        :const:`BLAKE2B_BYTES`\n    :type digest_size: int\n    :param key: the key to be set for keyed MAC/PRF usage; if set, the key\n                must be at most :data:`~nacl.hash.BLAKE2B_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: an initialization salt at most\n                 :const:`BLAKE2B_SALTBYTES` long;\n                 it will be zero-padded if needed\n    :type salt: bytes\n    :param person: a personalization string at most\n                   :const:`BLAKE2B_PERSONALBYTES` long;\n                   it will be zero-padded if needed\n    :type person: bytes\n    :param encoder: the encoder to use on returned digest\n    :type encoder: class\n    :returns: The hashed message.\n    :rtype: bytes\n    \"\"\"\n\n    digest = _b2b_hash(\n        data, digest_size=digest_size, key=key, salt=salt, person=person\n    )\n    return encoder.encode(digest)\n\n\ngenerichash = blake2b\n\n\ndef siphash24(\n    message: bytes,\n    key: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Computes a keyed MAC of ``message`` using the short-input-optimized\n    siphash-2-4 construction.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param key: the message authentication key for the siphash MAC construct\n    :type key: bytes(:const:`SIPHASH_KEYBYTES`)\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes(:const:`SIPHASH_BYTES`)\n    \"\"\"\n    digest = _sip_hash(message, key)\n    return encoder.encode(digest)\n\n\nshorthash = siphash24\n\n\ndef siphashx24(\n    message: bytes,\n    key: bytes = b\"\",\n    encoder: nacl.encoding.Encoder = nacl.encoding.HexEncoder,\n) -> bytes:\n    \"\"\"\n    Computes a keyed MAC of ``message`` using the 128 bit variant of the\n    siphash-2-4 construction.\n\n    :param message: The message to hash.\n    :type message: bytes\n    :param key: the message authentication key for the siphash MAC construct\n    :type key: bytes(:const:`SIPHASHX_KEYBYTES`)\n    :param encoder: A class that is able to encode the hashed message.\n    :returns: The hashed message.\n    :rtype: bytes(:const:`SIPHASHX_BYTES`)\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    digest = _sip_hashx(message, key)\n    return encoder.encode(digest)\n", "src/nacl/secret.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ClassVar, Optional\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.utils import EncryptedMessage, StringFixer, random\n\n\nclass SecretBox(encoding.Encodable, StringFixer):\n    \"\"\"\n    The SecretBox class encrypts and decrypts messages using the given secret\n    key.\n\n    The ciphertexts generated by :class:`~nacl.secret.Secretbox` include a 16\n    byte authenticator which is checked as part of the decryption. An invalid\n    authenticator will cause the decrypt function to raise an exception. The\n    authenticator is not a signature. Once you've decrypted the message you've\n    demonstrated the ability to create arbitrary valid message, so messages you\n    send are repudiable. For non-repudiable messages, sign them after\n    encryption.\n\n    Encryption is done using `XSalsa20-Poly1305`_, and there are no practical\n    limits on the number or size of messages (up to 2\u2076\u2074 messages, each up to 2\u2076\u2074\n    bytes).\n\n    .. _XSalsa20-Poly1305: https://doc.libsodium.org/secret-key_cryptography/secretbox#algorithm-details\n\n    :param key: The secret key used to encrypt and decrypt messages\n    :param encoder: The encoder class used to decode the given key\n\n    :cvar KEY_SIZE: The size that the key is required to be.\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    :cvar MACBYTES: The size of the authentication MAC tag in bytes.\n    :cvar MESSAGEBYTES_MAX: The maximum size of a message which can be\n                            safely encrypted with a single key/nonce\n                            pair.\n    \"\"\"\n\n    KEY_SIZE: ClassVar[int] = nacl.bindings.crypto_secretbox_KEYBYTES\n    NONCE_SIZE: ClassVar[int] = nacl.bindings.crypto_secretbox_NONCEBYTES\n    MACBYTES: ClassVar[int] = nacl.bindings.crypto_secretbox_MACBYTES\n    MESSAGEBYTES_MAX: ClassVar[int] = (\n        nacl.bindings.crypto_secretbox_MESSAGEBYTES_MAX\n    )\n\n    def __init__(\n        self, key: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n    ):\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"SecretBox must be created from 32 bytes\")\n\n        if len(key) != self.KEY_SIZE:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\" % self.KEY_SIZE,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is **VITALLY** important that the nonce is a nonce,\n            i.e. it is a number used only once for any given key. If you fail\n            to do this, you compromise the privacy of the messages encrypted.\n            Give your nonces a different prefix, or have one side use an odd\n            counter and one an even counter. Just make sure they are different.\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        ciphertext = nacl.bindings.crypto_secretbox(\n            plaintext, nonce, self._key\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        plaintext = nacl.bindings.crypto_secretbox_open(\n            ciphertext, nonce, self._key\n        )\n\n        return plaintext\n\n\nclass Aead(encoding.Encodable, StringFixer):\n    \"\"\"\n    The AEAD class encrypts and decrypts messages using the given secret key.\n\n    Unlike :class:`~nacl.secret.SecretBox`, AEAD supports authenticating\n    non-confidential data received alongside the message, such as a length\n    or type tag.\n\n    Like :class:`~nacl.secret.Secretbox`, this class provides authenticated\n    encryption. An inauthentic message will cause the decrypt function to raise\n    an exception.\n\n    Likewise, the authenticator should not be mistaken for a (public-key)\n    signature: recipients (with the ability to decrypt messages) are capable of\n    creating arbitrary valid message; in particular, this means AEAD messages\n    are repudiable. For non-repudiable messages, sign them after encryption.\n\n    The cryptosystem used is `XChacha20-Poly1305`_ as specified for\n    `standardization`_. There are `no practical limits`_ to how much can safely\n    be encrypted under a given key (up to 2\u2076\u2074 messages each containing up\n    to 2\u2076\u2074 bytes).\n\n    .. _standardization: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n    .. _XChacha20-Poly1305: https://doc.libsodium.org/secret-key_cryptography/aead#xchacha-20-poly1305\n    .. _no practical limits: https://doc.libsodium.org/secret-key_cryptography/aead#limitations\n\n    :param key: The secret key used to encrypt and decrypt messages\n    :param encoder: The encoder class used to decode the given key\n\n    :cvar KEY_SIZE: The size that the key is required to be.\n    :cvar NONCE_SIZE: The size that the nonce is required to be.\n    :cvar MACBYTES: The size of the authentication MAC tag in bytes.\n    :cvar MESSAGEBYTES_MAX: The maximum size of a message which can be\n                            safely encrypted with a single key/nonce\n                            pair.\n    \"\"\"\n\n    KEY_SIZE = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n    NONCE_SIZE = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n    MACBYTES = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_ABYTES\n    MESSAGEBYTES_MAX = (\n        nacl.bindings.crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n    )\n\n    def __init__(\n        self,\n        key: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"AEAD must be created from 32 bytes\")\n\n        if len(key) != self.KEY_SIZE:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\" % self.KEY_SIZE,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def encrypt(\n        self,\n        plaintext: bytes,\n        aad: bytes = b\"\",\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> EncryptedMessage:\n        \"\"\"\n        Encrypts the plaintext message using the given `nonce` (or generates\n        one randomly if omitted) and returns the ciphertext encoded with the\n        encoder.\n\n        .. warning:: It is vitally important for :param nonce: to be unique.\n            By default, it is generated randomly; [:class:`Aead`] uses XChacha20\n            for extended (192b) nonce size, so the risk of reusing random nonces\n            is negligible.  It is *strongly recommended* to keep this behaviour,\n            as nonce reuse will compromise the privacy of encrypted messages.\n            Should implicit nonces be inadequate for your application, the\n            second best option is using split counters; e.g. if sending messages\n            encrypted under a shared key between 2 users, each user can use the\n            number of messages it sent so far, prefixed or suffixed with a 1bit\n            user id.  Note that the counter must **never** be rolled back (due\n            to overflow, on-disk state being rolled back to an earlier backup,\n            ...)\n\n        :param plaintext: [:class:`bytes`] The plaintext message to encrypt\n        :param nonce: [:class:`bytes`] The nonce to use in the encryption\n        :param encoder: The encoder to use to encode the ciphertext\n        :rtype: [:class:`nacl.utils.EncryptedMessage`]\n        \"\"\"\n        if nonce is None:\n            nonce = random(self.NONCE_SIZE)\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        ciphertext = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_encrypt(\n            plaintext, aad, nonce, self._key\n        )\n\n        encoded_nonce = encoder.encode(nonce)\n        encoded_ciphertext = encoder.encode(ciphertext)\n\n        return EncryptedMessage._from_parts(\n            encoded_nonce,\n            encoded_ciphertext,\n            encoder.encode(nonce + ciphertext),\n        )\n\n    def decrypt(\n        self,\n        ciphertext: bytes,\n        aad: bytes = b\"\",\n        nonce: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Decrypts the ciphertext using the `nonce` (explicitly, when passed as a\n        parameter or implicitly, when omitted, as part of the ciphertext) and\n        returns the plaintext message.\n\n        :param ciphertext: [:class:`bytes`] The encrypted message to decrypt\n        :param nonce: [:class:`bytes`] The nonce used when encrypting the\n            ciphertext\n        :param encoder: The encoder used to decode the ciphertext.\n        :rtype: [:class:`bytes`]\n        \"\"\"\n        # Decode our ciphertext\n        ciphertext = encoder.decode(ciphertext)\n\n        if nonce is None:\n            # If we were given the nonce and ciphertext combined, split them.\n            nonce = ciphertext[: self.NONCE_SIZE]\n            ciphertext = ciphertext[self.NONCE_SIZE :]\n\n        if len(nonce) != self.NONCE_SIZE:\n            raise exc.ValueError(\n                \"The nonce must be exactly %s bytes long\" % self.NONCE_SIZE,\n            )\n\n        plaintext = nacl.bindings.crypto_aead_xchacha20poly1305_ietf_decrypt(\n            ciphertext, aad, nonce, self._key\n        )\n\n        return plaintext\n", "src/nacl/__init__.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n__all__ = [\n    \"__title__\",\n    \"__summary__\",\n    \"__uri__\",\n    \"__version__\",\n    \"__author__\",\n    \"__email__\",\n    \"__license__\",\n    \"__copyright__\",\n]\n\n__title__ = \"PyNaCl\"\n__summary__ = (\n    \"Python binding to the Networking and Cryptography (NaCl) library\"\n)\n__uri__ = \"https://github.com/pyca/pynacl/\"\n\n__version__ = \"1.6.0.dev1\"\n\n__author__ = \"The PyNaCl developers\"\n__email__ = \"cryptography-dev@python.org\"\n\n__license__ = \"Apache License 2.0\"\n__copyright__ = \"Copyright 2013-2018 {}\".format(__author__)\n", "src/nacl/signing.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Optional\n\nimport nacl.bindings\nfrom nacl import encoding\nfrom nacl import exceptions as exc\nfrom nacl.public import (\n    PrivateKey as _Curve25519_PrivateKey,\n    PublicKey as _Curve25519_PublicKey,\n)\nfrom nacl.utils import StringFixer, random\n\n\nclass SignedMessage(bytes):\n    \"\"\"\n    A bytes subclass that holds a messaged that has been signed by a\n    :class:`SigningKey`.\n    \"\"\"\n\n    _signature: bytes\n    _message: bytes\n\n    @classmethod\n    def _from_parts(\n        cls, signature: bytes, message: bytes, combined: bytes\n    ) -> \"SignedMessage\":\n        obj = cls(combined)\n        obj._signature = signature\n        obj._message = message\n        return obj\n\n    @property\n    def signature(self) -> bytes:\n        \"\"\"\n        The signature contained within the :class:`SignedMessage`.\n        \"\"\"\n        return self._signature\n\n    @property\n    def message(self) -> bytes:\n        \"\"\"\n        The message contained within the :class:`SignedMessage`.\n        \"\"\"\n        return self._message\n\n\nclass VerifyKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    The public key counterpart to an Ed25519 SigningKey for producing digital\n    signatures.\n\n    :param key: [:class:`bytes`] Serialized Ed25519 public key\n    :param encoder: A class that is able to decode the `key`\n    \"\"\"\n\n    def __init__(\n        self, key: bytes, encoder: encoding.Encoder = encoding.RawEncoder\n    ):\n        # Decode the key\n        key = encoder.decode(key)\n        if not isinstance(key, bytes):\n            raise exc.TypeError(\"VerifyKey must be created from 32 bytes\")\n\n        if len(key) != nacl.bindings.crypto_sign_PUBLICKEYBYTES:\n            raise exc.ValueError(\n                \"The key must be exactly %s bytes long\"\n                % nacl.bindings.crypto_sign_PUBLICKEYBYTES,\n            )\n\n        self._key = key\n\n    def __bytes__(self) -> bytes:\n        return self._key\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    def verify(\n        self,\n        smessage: bytes,\n        signature: Optional[bytes] = None,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> bytes:\n        \"\"\"\n        Verifies the signature of a signed message, returning the message\n        if it has not been tampered with else raising\n        :class:`~nacl.signing.BadSignatureError`.\n\n        :param smessage: [:class:`bytes`] Either the original messaged or a\n            signature and message concated together.\n        :param signature: [:class:`bytes`] If an unsigned message is given for\n            smessage then the detached signature must be provided.\n        :param encoder: A class that is able to decode the secret message and\n            signature.\n        :rtype: :class:`bytes`\n        \"\"\"\n        if signature is not None:\n            # If we were given the message and signature separately, validate\n            #   signature size and combine them.\n            if not isinstance(signature, bytes):\n                raise exc.TypeError(\n                    \"Verification signature must be created from %d bytes\"\n                    % nacl.bindings.crypto_sign_BYTES,\n                )\n\n            if len(signature) != nacl.bindings.crypto_sign_BYTES:\n                raise exc.ValueError(\n                    \"The signature must be exactly %d bytes long\"\n                    % nacl.bindings.crypto_sign_BYTES,\n                )\n\n            smessage = signature + encoder.decode(smessage)\n        else:\n            # Decode the signed message\n            smessage = encoder.decode(smessage)\n\n        return nacl.bindings.crypto_sign_open(smessage, self._key)\n\n    def to_curve25519_public_key(self) -> _Curve25519_PublicKey:\n        \"\"\"\n        Converts a :class:`~nacl.signing.VerifyKey` to a\n        :class:`~nacl.public.PublicKey`\n\n        :rtype: :class:`~nacl.public.PublicKey`\n        \"\"\"\n        raw_pk = nacl.bindings.crypto_sign_ed25519_pk_to_curve25519(self._key)\n        return _Curve25519_PublicKey(raw_pk)\n\n\nclass SigningKey(encoding.Encodable, StringFixer):\n    \"\"\"\n    Private key for producing digital signatures using the Ed25519 algorithm.\n\n    Signing keys are produced from a 32-byte (256-bit) random seed value. This\n    value can be passed into the :class:`~nacl.signing.SigningKey` as a\n    :func:`bytes` whose length is 32.\n\n    .. warning:: This **must** be protected and remain secret. Anyone who knows\n        the value of your :class:`~nacl.signing.SigningKey` or it's seed can\n        masquerade as you.\n\n    :param seed: [:class:`bytes`] Random 32-byte value (i.e. private key)\n    :param encoder: A class that is able to decode the seed\n\n    :ivar: verify_key: [:class:`~nacl.signing.VerifyKey`] The verify\n        (i.e. public) key that corresponds with this signing key.\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ):\n        # Decode the seed\n        seed = encoder.decode(seed)\n        if not isinstance(seed, bytes):\n            raise exc.TypeError(\n                \"SigningKey must be created from a 32 byte seed\"\n            )\n\n        # Verify that our seed is the proper size\n        if len(seed) != nacl.bindings.crypto_sign_SEEDBYTES:\n            raise exc.ValueError(\n                \"The seed must be exactly %d bytes long\"\n                % nacl.bindings.crypto_sign_SEEDBYTES\n            )\n\n        public_key, secret_key = nacl.bindings.crypto_sign_seed_keypair(seed)\n\n        self._seed = seed\n        self._signing_key = secret_key\n        self.verify_key = VerifyKey(public_key)\n\n    def __bytes__(self) -> bytes:\n        return self._seed\n\n    def __hash__(self) -> int:\n        return hash(bytes(self))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return nacl.bindings.sodium_memcmp(bytes(self), bytes(other))\n\n    def __ne__(self, other: object) -> bool:\n        return not (self == other)\n\n    @classmethod\n    def generate(cls) -> \"SigningKey\":\n        \"\"\"\n        Generates a random :class:`~nacl.signing.SigningKey` object.\n\n        :rtype: :class:`~nacl.signing.SigningKey`\n        \"\"\"\n        return cls(\n            random(nacl.bindings.crypto_sign_SEEDBYTES),\n            encoder=encoding.RawEncoder,\n        )\n\n    def sign(\n        self,\n        message: bytes,\n        encoder: encoding.Encoder = encoding.RawEncoder,\n    ) -> SignedMessage:\n        \"\"\"\n        Sign a message using this key.\n\n        :param message: [:class:`bytes`] The data to be signed.\n        :param encoder: A class that is used to encode the signed message.\n        :rtype: :class:`~nacl.signing.SignedMessage`\n        \"\"\"\n        raw_signed = nacl.bindings.crypto_sign(message, self._signing_key)\n\n        crypto_sign_BYTES = nacl.bindings.crypto_sign_BYTES\n        signature = encoder.encode(raw_signed[:crypto_sign_BYTES])\n        message = encoder.encode(raw_signed[crypto_sign_BYTES:])\n        signed = encoder.encode(raw_signed)\n\n        return SignedMessage._from_parts(signature, message, signed)\n\n    def to_curve25519_private_key(self) -> _Curve25519_PrivateKey:\n        \"\"\"\n        Converts a :class:`~nacl.signing.SigningKey` to a\n        :class:`~nacl.public.PrivateKey`\n\n        :rtype: :class:`~nacl.public.PrivateKey`\n        \"\"\"\n        sk = self._signing_key\n        raw_private = nacl.bindings.crypto_sign_ed25519_sk_to_curve25519(sk)\n        return _Curve25519_PrivateKey(raw_private)\n", "src/nacl/encoding.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport base64\nimport binascii\nfrom abc import ABCMeta, abstractmethod\nfrom typing import SupportsBytes, Type\n\n\n# TODO: when the minimum supported version of Python is 3.8, we can import\n# Protocol from typing, and replace Encoder with a Protocol instead.\nclass _Encoder(metaclass=ABCMeta):\n    @staticmethod\n    @abstractmethod\n    def encode(data: bytes) -> bytes:\n        \"\"\"Transform raw data to encoded data.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def decode(data: bytes) -> bytes:\n        \"\"\"Transform encoded data back to raw data.\n\n        Decoding after encoding should be a no-op, i.e. `decode(encode(x)) == x`.\n        \"\"\"\n\n\n# Functions that use encoders are passed a subclass of _Encoder, not an instance\n# (because the methods are all static). Let's gloss over that detail by defining\n# an alias for Type[_Encoder].\nEncoder = Type[_Encoder]\n\n\nclass RawEncoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return data\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return data\n\n\nclass HexEncoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return binascii.hexlify(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return binascii.unhexlify(data)\n\n\nclass Base16Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b16encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b16decode(data)\n\n\nclass Base32Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b32encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b32decode(data)\n\n\nclass Base64Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.b64encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.b64decode(data)\n\n\nclass URLSafeBase64Encoder(_Encoder):\n    @staticmethod\n    def encode(data: bytes) -> bytes:\n        return base64.urlsafe_b64encode(data)\n\n    @staticmethod\n    def decode(data: bytes) -> bytes:\n        return base64.urlsafe_b64decode(data)\n\n\nclass Encodable:\n    def encode(self: SupportsBytes, encoder: Encoder = RawEncoder) -> bytes:\n        return encoder.encode(bytes(self))\n", "src/nacl/hashlib.py": "# Copyright 2016-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport binascii\nfrom typing import NoReturn\n\nimport nacl.bindings\nfrom nacl.utils import bytes_as_string\n\nBYTES = nacl.bindings.crypto_generichash_BYTES\nBYTES_MIN = nacl.bindings.crypto_generichash_BYTES_MIN\nBYTES_MAX = nacl.bindings.crypto_generichash_BYTES_MAX\nKEYBYTES = nacl.bindings.crypto_generichash_KEYBYTES\nKEYBYTES_MIN = nacl.bindings.crypto_generichash_KEYBYTES_MIN\nKEYBYTES_MAX = nacl.bindings.crypto_generichash_KEYBYTES_MAX\nSALTBYTES = nacl.bindings.crypto_generichash_SALTBYTES\nPERSONALBYTES = nacl.bindings.crypto_generichash_PERSONALBYTES\n\nSCRYPT_AVAILABLE = nacl.bindings.has_crypto_pwhash_scryptsalsa208sha256\n\n_b2b_init = nacl.bindings.crypto_generichash_blake2b_init\n_b2b_final = nacl.bindings.crypto_generichash_blake2b_final\n_b2b_update = nacl.bindings.crypto_generichash_blake2b_update\n\n\nclass blake2b:\n    \"\"\"\n    :py:mod:`hashlib` API compatible blake2b algorithm implementation\n    \"\"\"\n\n    MAX_DIGEST_SIZE = BYTES\n    MAX_KEY_SIZE = KEYBYTES_MAX\n    PERSON_SIZE = PERSONALBYTES\n    SALT_SIZE = SALTBYTES\n\n    def __init__(\n        self,\n        data: bytes = b\"\",\n        digest_size: int = BYTES,\n        key: bytes = b\"\",\n        salt: bytes = b\"\",\n        person: bytes = b\"\",\n    ):\n        \"\"\"\n        :py:class:`.blake2b` algorithm initializer\n\n        :param data:\n        :type data: bytes\n        :param int digest_size: the requested digest size; must be\n                                at most :py:attr:`.MAX_DIGEST_SIZE`;\n                                the default digest size is :py:data:`.BYTES`\n        :param key: the key to be set for keyed MAC/PRF usage; if set,\n                    the key must be at most :py:data:`.KEYBYTES_MAX` long\n        :type key: bytes\n        :param salt: a initialization salt at most\n                     :py:attr:`.SALT_SIZE` long; it will be zero-padded\n                     if needed\n        :type salt: bytes\n        :param person: a personalization string at most\n                       :py:attr:`.PERSONAL_SIZE` long; it will be zero-padded\n                       if needed\n        :type person: bytes\n        \"\"\"\n\n        self._state = _b2b_init(\n            key=key, salt=salt, person=person, digest_size=digest_size\n        )\n        self._digest_size = digest_size\n\n        if data:\n            self.update(data)\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n    @property\n    def block_size(self) -> int:\n        return 128\n\n    @property\n    def name(self) -> str:\n        return \"blake2b\"\n\n    def update(self, data: bytes) -> None:\n        _b2b_update(self._state, data)\n\n    def digest(self) -> bytes:\n        _st = self._state.copy()\n        return _b2b_final(_st)\n\n    def hexdigest(self) -> str:\n        return bytes_as_string(binascii.hexlify(self.digest()))\n\n    def copy(self) -> \"blake2b\":\n        _cp = type(self)(digest_size=self.digest_size)\n        _st = self._state.copy()\n        _cp._state = _st\n        return _cp\n\n    def __reduce__(self) -> NoReturn:\n        \"\"\"\n        Raise the same exception as hashlib's blake implementation\n        on copy.copy()\n        \"\"\"\n        raise TypeError(\n            \"can't pickle {} objects\".format(self.__class__.__name__)\n        )\n\n\ndef scrypt(\n    password: bytes,\n    salt: bytes = b\"\",\n    n: int = 2**20,\n    r: int = 8,\n    p: int = 1,\n    maxmem: int = 2**25,\n    dklen: int = 64,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the scrypt KDF.\n\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    Implements the same signature as the ``hashlib.scrypt`` implemented\n    in cpython version 3.6\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_ll(\n        password, salt, n, r, p, maxmem=maxmem, dklen=dklen\n    )\n", "src/nacl/bindings/crypto_hash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\n# crypto_hash_BYTES = lib.crypto_hash_bytes()\ncrypto_hash_BYTES: int = lib.crypto_hash_sha512_bytes()\ncrypto_hash_sha256_BYTES: int = lib.crypto_hash_sha256_bytes()\ncrypto_hash_sha512_BYTES: int = lib.crypto_hash_sha512_bytes()\n\n\ndef crypto_hash(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_BYTES)\n    rc = lib.crypto_hash(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_BYTES)[:]\n\n\ndef crypto_hash_sha256(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_sha256_BYTES)\n    rc = lib.crypto_hash_sha256(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_sha256_BYTES)[:]\n\n\ndef crypto_hash_sha512(message: bytes) -> bytes:\n    \"\"\"\n    Hashes and returns the message ``message``.\n\n    :param message: bytes\n    :rtype: bytes\n    \"\"\"\n    digest = ffi.new(\"unsigned char[]\", crypto_hash_sha512_BYTES)\n    rc = lib.crypto_hash_sha512(digest, message, len(message))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n    return ffi.buffer(digest, crypto_hash_sha512_BYTES)[:]\n", "src/nacl/bindings/crypto_aead.py": "# Copyright 2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Optional\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\"\"\"\nImplementations of authenticated encription with associated data (*AEAD*)\nconstructions building on the chacha20 stream cipher and the poly1305\nauthenticator\n\"\"\"\n\ncrypto_aead_chacha20poly1305_ietf_KEYBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_keybytes()\n)\ncrypto_aead_chacha20poly1305_ietf_NSECBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_nsecbytes()\n)\ncrypto_aead_chacha20poly1305_ietf_NPUBBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_npubbytes()\n)\ncrypto_aead_chacha20poly1305_ietf_ABYTES: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_abytes()\n)\ncrypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_chacha20poly1305_ietf_messagebytes_max()\n)\n_aead_chacha20poly1305_ietf_CRYPTBYTES_MAX = (\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\n    + crypto_aead_chacha20poly1305_ietf_ABYTES\n)\n\ncrypto_aead_chacha20poly1305_KEYBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_keybytes()\n)\ncrypto_aead_chacha20poly1305_NSECBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_nsecbytes()\n)\ncrypto_aead_chacha20poly1305_NPUBBYTES: int = (\n    lib.crypto_aead_chacha20poly1305_npubbytes()\n)\ncrypto_aead_chacha20poly1305_ABYTES: int = (\n    lib.crypto_aead_chacha20poly1305_abytes()\n)\ncrypto_aead_chacha20poly1305_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_chacha20poly1305_messagebytes_max()\n)\n_aead_chacha20poly1305_CRYPTBYTES_MAX = (\n    crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\n    + crypto_aead_chacha20poly1305_ABYTES\n)\n\ncrypto_aead_xchacha20poly1305_ietf_KEYBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_keybytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_NSECBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_nsecbytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_NPUBBYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_npubbytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_ABYTES: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_abytes()\n)\ncrypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX: int = (\n    lib.crypto_aead_xchacha20poly1305_ietf_messagebytes_max()\n)\n_aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX = (\n    crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n    + crypto_aead_xchacha20poly1305_ietf_ABYTES\n)\n\n\ndef crypto_aead_chacha20poly1305_ietf_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the IETF ratified chacha20poly1305\n    construction described in RFC7539.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mxout = mlen + crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_chacha20poly1305_ietf_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_ietf_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the IETF ratified chacha20poly1305\n    construction described in RFC7539.\n\n    :param ciphertext:\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_chacha20poly1305_ietf_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_chacha20poly1305_ietf_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_chacha20poly1305_ietf_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the \"legacy\" construction\n    described in draft-agl-tls-chacha20poly1305.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mlen = len(message)\n    mxout = mlen + crypto_aead_chacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_chacha20poly1305_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_chacha20poly1305_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the \"legacy\" construction\n    described in draft-agl-tls-chacha20poly1305.\n\n    :param ciphertext: authenticated ciphertext\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_chacha20poly1305_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_chacha20poly1305_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_chacha20poly1305_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_chacha20poly1305_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_chacha20poly1305_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_chacha20poly1305_ABYTES\n\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_chacha20poly1305_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n\n\ndef crypto_aead_xchacha20poly1305_ietf_encrypt(\n    message: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Encrypt the given ``message`` using the long-nonces xchacha20poly1305\n    construction.\n\n    :param message:\n    :type message: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: authenticated ciphertext\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"Input message type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(message)\n\n    ensure(\n        mlen <= crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX,\n        \"Message must be at most {} bytes long\".format(\n            crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    mlen = len(message)\n    mxout = mlen + crypto_aead_xchacha20poly1305_ietf_ABYTES\n\n    clen = ffi.new(\"unsigned long long *\")\n\n    ciphertext = ffi.new(\"unsigned char[]\", mxout)\n\n    res = lib.crypto_aead_xchacha20poly1305_ietf_encrypt(\n        ciphertext, clen, message, mlen, _aad, aalen, ffi.NULL, nonce, key\n    )\n\n    ensure(res == 0, \"Encryption failed.\", raising=exc.CryptoError)\n    return ffi.buffer(ciphertext, clen[0])[:]\n\n\ndef crypto_aead_xchacha20poly1305_ietf_decrypt(\n    ciphertext: bytes, aad: Optional[bytes], nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt the given ``ciphertext`` using the long-nonces xchacha20poly1305\n    construction.\n\n    :param ciphertext: authenticated ciphertext\n    :type ciphertext: bytes\n    :param aad:\n    :type aad: Optional[bytes]\n    :param nonce:\n    :type nonce: bytes\n    :param key:\n    :type key: bytes\n    :return: message\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"Input ciphertext type must be bytes\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(ciphertext)\n\n    ensure(\n        clen <= _aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX,\n        \"Ciphertext must be at most {} bytes long\".format(\n            _aead_xchacha20poly1305_ietf_CRYPTBYTES_MAX\n        ),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        isinstance(aad, bytes) or (aad is None),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(nonce, bytes)\n        and len(nonce) == crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n        \"Nonce must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(key, bytes)\n        and len(key) == crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n        \"Key must be a {} bytes long bytes sequence\".format(\n            crypto_aead_xchacha20poly1305_ietf_KEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    mxout = clen - crypto_aead_xchacha20poly1305_ietf_ABYTES\n    mlen = ffi.new(\"unsigned long long *\")\n    message = ffi.new(\"unsigned char[]\", mxout)\n\n    if aad:\n        _aad = aad\n        aalen = len(aad)\n    else:\n        _aad = ffi.NULL\n        aalen = 0\n\n    res = lib.crypto_aead_xchacha20poly1305_ietf_decrypt(\n        message, mlen, ffi.NULL, ciphertext, clen, _aad, aalen, nonce, key\n    )\n\n    ensure(res == 0, \"Decryption failed.\", raising=exc.CryptoError)\n\n    return ffi.buffer(message, mlen[0])[:]\n", "src/nacl/bindings/crypto_secretbox.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_secretbox_KEYBYTES: int = lib.crypto_secretbox_keybytes()\ncrypto_secretbox_NONCEBYTES: int = lib.crypto_secretbox_noncebytes()\ncrypto_secretbox_ZEROBYTES: int = lib.crypto_secretbox_zerobytes()\ncrypto_secretbox_BOXZEROBYTES: int = lib.crypto_secretbox_boxzerobytes()\ncrypto_secretbox_MACBYTES: int = lib.crypto_secretbox_macbytes()\ncrypto_secretbox_MESSAGEBYTES_MAX: int = (\n    lib.crypto_secretbox_messagebytes_max()\n)\n\n\ndef crypto_secretbox(message: bytes, nonce: bytes, key: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns the message ``message`` with the secret ``key`` and\n    the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param key: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(key) != crypto_secretbox_KEYBYTES:\n        raise exc.ValueError(\"Invalid key\")\n\n    if len(nonce) != crypto_secretbox_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    padded = b\"\\x00\" * crypto_secretbox_ZEROBYTES + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_secretbox(ciphertext, padded, len(padded), nonce, key)\n    ensure(res == 0, \"Encryption failed\", raising=exc.CryptoError)\n\n    ciphertext = ffi.buffer(ciphertext, len(padded))\n    return ciphertext[crypto_secretbox_BOXZEROBYTES:]\n\n\ndef crypto_secretbox_open(\n    ciphertext: bytes, nonce: bytes, key: bytes\n) -> bytes:\n    \"\"\"\n    Decrypt and returns the encrypted message ``ciphertext`` with the secret\n    ``key`` and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param key: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(key) != crypto_secretbox_KEYBYTES:\n        raise exc.ValueError(\"Invalid key\")\n\n    if len(nonce) != crypto_secretbox_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    padded = b\"\\x00\" * crypto_secretbox_BOXZEROBYTES + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_secretbox_open(plaintext, padded, len(padded), nonce, key)\n    ensure(\n        res == 0,\n        \"Decryption failed. Ciphertext failed verification\",\n        raising=exc.CryptoError,\n    )\n\n    plaintext = ffi.buffer(plaintext, len(padded))\n    return plaintext[crypto_secretbox_ZEROBYTES:]\n", "src/nacl/bindings/utils.py": "# Copyright 2013-2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ndef sodium_memcmp(inp1: bytes, inp2: bytes) -> bool:\n    \"\"\"\n    Compare contents of two memory regions in constant time\n    \"\"\"\n    ensure(isinstance(inp1, bytes), raising=exc.TypeError)\n    ensure(isinstance(inp2, bytes), raising=exc.TypeError)\n\n    ln = max(len(inp1), len(inp2))\n\n    buf1 = ffi.new(\"char []\", ln)\n    buf2 = ffi.new(\"char []\", ln)\n\n    ffi.memmove(buf1, inp1, len(inp1))\n    ffi.memmove(buf2, inp2, len(inp2))\n\n    eqL = len(inp1) == len(inp2)\n    eqC = lib.sodium_memcmp(buf1, buf2, ln) == 0\n\n    return eqL and eqC\n\n\ndef sodium_pad(s: bytes, blocksize: int) -> bytes:\n    \"\"\"\n    Pad the input bytearray ``s`` to a multiple of ``blocksize``\n    using the ISO/IEC 7816-4 algorithm\n\n    :param s: input bytes string\n    :type s: bytes\n    :param blocksize:\n    :type blocksize: int\n    :return: padded string\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(s, bytes), raising=exc.TypeError)\n    ensure(isinstance(blocksize, int), raising=exc.TypeError)\n    if blocksize <= 0:\n        raise exc.ValueError\n    s_len = len(s)\n    m_len = s_len + blocksize\n    buf = ffi.new(\"unsigned char []\", m_len)\n    p_len = ffi.new(\"size_t []\", 1)\n    ffi.memmove(buf, s, s_len)\n    rc = lib.sodium_pad(p_len, buf, s_len, blocksize, m_len)\n    ensure(rc == 0, \"Padding failure\", raising=exc.CryptoError)\n    return ffi.buffer(buf, p_len[0])[:]\n\n\ndef sodium_unpad(s: bytes, blocksize: int) -> bytes:\n    \"\"\"\n    Remove ISO/IEC 7816-4 padding from the input byte array ``s``\n\n    :param s: input bytes string\n    :type s: bytes\n    :param blocksize:\n    :type blocksize: int\n    :return: unpadded string\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(s, bytes), raising=exc.TypeError)\n    ensure(isinstance(blocksize, int), raising=exc.TypeError)\n    s_len = len(s)\n    u_len = ffi.new(\"size_t []\", 1)\n    rc = lib.sodium_unpad(u_len, s, s_len, blocksize)\n    if rc != 0:\n        raise exc.CryptoError(\"Unpadding failure\")\n    return s[: u_len[0]]\n\n\ndef sodium_increment(inp: bytes) -> bytes:\n    \"\"\"\n    Increment the value of a byte-sequence interpreted\n    as the little-endian representation of a unsigned big integer.\n\n    :param inp: input bytes buffer\n    :type inp: bytes\n    :return: a byte-sequence representing, as a little-endian\n             unsigned big integer, the value ``to_int(inp)``\n             incremented by one.\n    :rtype: bytes\n\n    \"\"\"\n    ensure(isinstance(inp, bytes), raising=exc.TypeError)\n\n    ln = len(inp)\n    buf = ffi.new(\"unsigned char []\", ln)\n\n    ffi.memmove(buf, inp, ln)\n\n    lib.sodium_increment(buf, ln)\n\n    return ffi.buffer(buf, ln)[:]\n\n\ndef sodium_add(a: bytes, b: bytes) -> bytes:\n    \"\"\"\n    Given a couple of *same-sized* byte sequences, interpreted as the\n    little-endian representation of two unsigned integers, compute\n    the modular addition of the represented values, in constant time for\n    a given common length of the byte sequences.\n\n    :param a: input bytes buffer\n    :type a: bytes\n    :param b: input bytes buffer\n    :type b: bytes\n    :return: a byte-sequence representing, as a little-endian big integer,\n             the integer value of ``(to_int(a) + to_int(b)) mod 2^(8*len(a))``\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(a, bytes), raising=exc.TypeError)\n    ensure(isinstance(b, bytes), raising=exc.TypeError)\n    ln = len(a)\n    ensure(len(b) == ln, raising=exc.TypeError)\n\n    buf_a = ffi.new(\"unsigned char []\", ln)\n    buf_b = ffi.new(\"unsigned char []\", ln)\n\n    ffi.memmove(buf_a, a, ln)\n    ffi.memmove(buf_b, b, ln)\n\n    lib.sodium_add(buf_a, buf_b, ln)\n\n    return ffi.buffer(buf_a, ln)[:]\n", "src/nacl/bindings/crypto_sign.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_sign_BYTES: int = lib.crypto_sign_bytes()\n# crypto_sign_SEEDBYTES = lib.crypto_sign_seedbytes()\ncrypto_sign_SEEDBYTES: int = lib.crypto_sign_secretkeybytes() // 2\ncrypto_sign_PUBLICKEYBYTES: int = lib.crypto_sign_publickeybytes()\ncrypto_sign_SECRETKEYBYTES: int = lib.crypto_sign_secretkeybytes()\n\ncrypto_sign_curve25519_BYTES: int = lib.crypto_box_secretkeybytes()\n\ncrypto_sign_ed25519ph_STATEBYTES: int = lib.crypto_sign_ed25519ph_statebytes()\n\n\ndef crypto_sign_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a randomly generated public key and secret key.\n\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    pk = ffi.new(\"unsigned char[]\", crypto_sign_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_sign_SECRETKEYBYTES)\n\n    rc = lib.crypto_sign_keypair(pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_sign_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_sign_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_sign_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Computes and returns the public key and secret key using the seed ``seed``.\n\n    :param seed: bytes\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    if len(seed) != crypto_sign_SEEDBYTES:\n        raise exc.ValueError(\"Invalid seed\")\n\n    pk = ffi.new(\"unsigned char[]\", crypto_sign_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_sign_SECRETKEYBYTES)\n\n    rc = lib.crypto_sign_seed_keypair(pk, sk, seed)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_sign_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_sign_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_sign(message: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Signs the message ``message`` using the secret key ``sk`` and returns the\n    signed message.\n\n    :param message: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    signed = ffi.new(\"unsigned char[]\", len(message) + crypto_sign_BYTES)\n    signed_len = ffi.new(\"unsigned long long *\")\n\n    rc = lib.crypto_sign(signed, signed_len, message, len(message), sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(signed, signed_len[0])[:]\n\n\ndef crypto_sign_open(signed: bytes, pk: bytes) -> bytes:\n    \"\"\"\n    Verifies the signature of the signed message ``signed`` using the public\n    key ``pk`` and returns the unsigned message.\n\n    :param signed: bytes\n    :param pk: bytes\n    :rtype: bytes\n    \"\"\"\n    message = ffi.new(\"unsigned char[]\", len(signed))\n    message_len = ffi.new(\"unsigned long long *\")\n\n    if (\n        lib.crypto_sign_open(message, message_len, signed, len(signed), pk)\n        != 0\n    ):\n        raise exc.BadSignatureError(\"Signature was forged or corrupt\")\n\n    return ffi.buffer(message, message_len[0])[:]\n\n\ndef crypto_sign_ed25519_pk_to_curve25519(public_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Converts a public Ed25519 key (encoded as bytes ``public_key_bytes``) to\n    a public Curve25519 key as bytes.\n\n    Raises a ValueError if ``public_key_bytes`` is not of length\n    ``crypto_sign_PUBLICKEYBYTES``\n\n    :param public_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(public_key_bytes) != crypto_sign_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid curve public key\")\n\n    curve_public_key_len = crypto_sign_curve25519_BYTES\n    curve_public_key = ffi.new(\"unsigned char[]\", curve_public_key_len)\n\n    rc = lib.crypto_sign_ed25519_pk_to_curve25519(\n        curve_public_key, public_key_bytes\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(curve_public_key, curve_public_key_len)[:]\n\n\ndef crypto_sign_ed25519_sk_to_curve25519(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Converts a secret Ed25519 key (encoded as bytes ``secret_key_bytes``) to\n    a secret Curve25519 key as bytes.\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid curve secret key\")\n\n    curve_secret_key_len = crypto_sign_curve25519_BYTES\n    curve_secret_key = ffi.new(\"unsigned char[]\", curve_secret_key_len)\n\n    rc = lib.crypto_sign_ed25519_sk_to_curve25519(\n        curve_secret_key, secret_key_bytes\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(curve_secret_key, curve_secret_key_len)[:]\n\n\ndef crypto_sign_ed25519_sk_to_pk(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Extract the public Ed25519 key from a secret Ed25519 key (encoded\n    as bytes ``secret_key_bytes``).\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    return secret_key_bytes[crypto_sign_SEEDBYTES:]\n\n\ndef crypto_sign_ed25519_sk_to_seed(secret_key_bytes: bytes) -> bytes:\n    \"\"\"\n    Extract the seed from a secret Ed25519 key (encoded\n    as bytes ``secret_key_bytes``).\n\n    Raises a ValueError if ``secret_key_bytes``is not of length\n    ``crypto_sign_SECRETKEYBYTES``\n\n    :param secret_key_bytes: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(secret_key_bytes) != crypto_sign_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    return secret_key_bytes[:crypto_sign_SEEDBYTES]\n\n\nclass crypto_sign_ed25519ph_state:\n    \"\"\"\n    State object wrapping the sha-512 state used in ed25519ph computation\n    \"\"\"\n\n    __slots__ = [\"state\"]\n\n    def __init__(self) -> None:\n        self.state: bytes = ffi.new(\n            \"unsigned char[]\", crypto_sign_ed25519ph_STATEBYTES\n        )\n\n        rc = lib.crypto_sign_ed25519ph_init(self.state)\n\n        ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n\ndef crypto_sign_ed25519ph_update(\n    edph: crypto_sign_ed25519ph_state, pmsg: bytes\n) -> None:\n    \"\"\"\n    Update the hash state wrapped in edph\n\n    :param edph: the ed25519ph state being updated\n    :type edph: crypto_sign_ed25519ph_state\n    :param pmsg: the partial message\n    :type pmsg: bytes\n    :rtype: None\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(pmsg, bytes),\n        \"pmsg parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    rc = lib.crypto_sign_ed25519ph_update(edph.state, pmsg, len(pmsg))\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n\ndef crypto_sign_ed25519ph_final_create(\n    edph: crypto_sign_ed25519ph_state, sk: bytes\n) -> bytes:\n    \"\"\"\n    Create a signature for the data hashed in edph\n    using the secret key sk\n\n    :param edph: the ed25519ph state for the data\n                 being signed\n    :type edph: crypto_sign_ed25519ph_state\n    :param sk: the ed25519 secret key (secret and public part)\n    :type sk: bytes\n    :return: ed25519ph signature\n    :rtype: bytes\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(sk, bytes),\n        \"secret key parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(sk) == crypto_sign_SECRETKEYBYTES,\n        (\"secret key must be {} bytes long\").format(\n            crypto_sign_SECRETKEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n    signature = ffi.new(\"unsigned char[]\", crypto_sign_BYTES)\n    rc = lib.crypto_sign_ed25519ph_final_create(\n        edph.state, signature, ffi.NULL, sk\n    )\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(signature, crypto_sign_BYTES)[:]\n\n\ndef crypto_sign_ed25519ph_final_verify(\n    edph: crypto_sign_ed25519ph_state, signature: bytes, pk: bytes\n) -> bool:\n    \"\"\"\n    Verify a prehashed signature using the public key pk\n\n    :param edph: the ed25519ph state for the data\n                 being verified\n    :type edph: crypto_sign_ed25519ph_state\n    :param signature: the signature being verified\n    :type signature: bytes\n    :param pk: the ed25519 public part of the signing key\n    :type pk: bytes\n    :return: True if the signature is valid\n    :rtype: boolean\n    :raises exc.BadSignatureError: if the signature is not valid\n    \"\"\"\n    ensure(\n        isinstance(edph, crypto_sign_ed25519ph_state),\n        \"edph parameter must be a ed25519ph_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(signature, bytes),\n        \"signature parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(signature) == crypto_sign_BYTES,\n        (\"signature must be {} bytes long\").format(crypto_sign_BYTES),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(pk, bytes),\n        \"public key parameter must be a bytes object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(pk) == crypto_sign_PUBLICKEYBYTES,\n        (\"public key must be {} bytes long\").format(\n            crypto_sign_PUBLICKEYBYTES\n        ),\n        raising=exc.TypeError,\n    )\n    rc = lib.crypto_sign_ed25519ph_final_verify(edph.state, signature, pk)\n    if rc != 0:\n        raise exc.BadSignatureError(\"Signature was forged or corrupt\")\n\n    return True\n", "src/nacl/bindings/crypto_secretstream.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import ByteString, Optional, Tuple, cast\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_secretstream_xchacha20poly1305_ABYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_abytes()\n)\ncrypto_secretstream_xchacha20poly1305_HEADERBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_headerbytes()\n)\ncrypto_secretstream_xchacha20poly1305_KEYBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_keybytes()\n)\ncrypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX: int = (\n    lib.crypto_secretstream_xchacha20poly1305_messagebytes_max()\n)\ncrypto_secretstream_xchacha20poly1305_STATEBYTES: int = (\n    lib.crypto_secretstream_xchacha20poly1305_statebytes()\n)\n\n\ncrypto_secretstream_xchacha20poly1305_TAG_MESSAGE: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_message()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_PUSH: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_push()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_REKEY: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_rekey()\n)\ncrypto_secretstream_xchacha20poly1305_TAG_FINAL: int = (\n    lib.crypto_secretstream_xchacha20poly1305_tag_final()\n)\n\n\ndef crypto_secretstream_xchacha20poly1305_keygen() -> bytes:\n    \"\"\"\n    Generate a key for use with\n    :func:`.crypto_secretstream_xchacha20poly1305_init_push`.\n\n    \"\"\"\n    keybuf = ffi.new(\n        \"unsigned char[]\",\n        crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    )\n    lib.crypto_secretstream_xchacha20poly1305_keygen(keybuf)\n    return ffi.buffer(keybuf)[:]\n\n\nclass crypto_secretstream_xchacha20poly1305_state:\n    \"\"\"\n    An object wrapping the crypto_secretstream_xchacha20poly1305 state.\n\n    \"\"\"\n\n    __slots__ = [\"statebuf\", \"rawbuf\", \"tagbuf\"]\n\n    def __init__(self) -> None:\n        \"\"\"Initialize a clean state object.\"\"\"\n        self.statebuf: ByteString = ffi.new(\n            \"unsigned char[]\",\n            crypto_secretstream_xchacha20poly1305_STATEBYTES,\n        )\n\n        self.rawbuf: Optional[ByteString] = None\n        self.tagbuf: Optional[ByteString] = None\n\n\ndef crypto_secretstream_xchacha20poly1305_init_push(\n    state: crypto_secretstream_xchacha20poly1305_state, key: bytes\n) -> bytes:\n    \"\"\"\n    Initialize a crypto_secretstream_xchacha20poly1305 encryption buffer.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param key: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_KEYBYTES` long\n    :type key: bytes\n    :return: header\n    :rtype: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(key) == crypto_secretstream_xchacha20poly1305_KEYBYTES,\n        \"Invalid key length\",\n        raising=exc.ValueError,\n    )\n\n    headerbuf = ffi.new(\n        \"unsigned char []\",\n        crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    )\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_init_push(\n        state.statebuf, headerbuf, key\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(headerbuf)[:]\n\n\ndef crypto_secretstream_xchacha20poly1305_push(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    m: bytes,\n    ad: Optional[bytes] = None,\n    tag: int = crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n) -> bytes:\n    \"\"\"\n    Add an encrypted message to the secret stream.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param m: the message to encrypt, the maximum length of an individual\n              message is\n              :data:`.crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX`.\n    :type m: bytes\n    :param ad: additional data to include in the authentication tag\n    :type ad: bytes or None\n    :param tag: the message tag, usually\n                :data:`.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE` or\n                :data:`.crypto_secretstream_xchacha20poly1305_TAG_FINAL`.\n    :type tag: int\n    :return: ciphertext\n    :rtype: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(isinstance(m, bytes), \"Message is not bytes\", raising=exc.TypeError)\n    ensure(\n        len(m) <= crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX,\n        \"Message is too long\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        ad is None or isinstance(ad, bytes),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    clen = len(m) + crypto_secretstream_xchacha20poly1305_ABYTES\n    if state.rawbuf is None or len(state.rawbuf) < clen:\n        state.rawbuf = ffi.new(\"unsigned char[]\", clen)\n\n    if ad is None:\n        ad = ffi.NULL\n        adlen = 0\n    else:\n        adlen = len(ad)\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_push(\n        state.statebuf,\n        state.rawbuf,\n        ffi.NULL,\n        m,\n        len(m),\n        ad,\n        adlen,\n        tag,\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(state.rawbuf, clen)[:]\n\n\ndef crypto_secretstream_xchacha20poly1305_init_pull(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    header: bytes,\n    key: bytes,\n) -> None:\n    \"\"\"\n    Initialize a crypto_secretstream_xchacha20poly1305 decryption buffer.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param header: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_HEADERBYTES` long\n    :type header: bytes\n    :param key: must be\n                :data:`.crypto_secretstream_xchacha20poly1305_KEYBYTES` long\n    :type key: bytes\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(header, bytes),\n        \"Header must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(header) == crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n        \"Invalid header length\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(key) == crypto_secretstream_xchacha20poly1305_KEYBYTES,\n        \"Invalid key length\",\n        raising=exc.ValueError,\n    )\n\n    if state.tagbuf is None:\n        state.tagbuf = ffi.new(\"unsigned char *\")\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_init_pull(\n        state.statebuf, header, key\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n\ndef crypto_secretstream_xchacha20poly1305_pull(\n    state: crypto_secretstream_xchacha20poly1305_state,\n    c: bytes,\n    ad: Optional[bytes] = None,\n) -> Tuple[bytes, int]:\n    \"\"\"\n    Read a decrypted message from the secret stream.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n    :param c: the ciphertext to decrypt, the maximum length of an individual\n              ciphertext is\n              :data:`.crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX` +\n              :data:`.crypto_secretstream_xchacha20poly1305_ABYTES`.\n    :type c: bytes\n    :param ad: additional data to include in the authentication tag\n    :type ad: bytes or None\n    :return: (message, tag)\n    :rtype: (bytes, int)\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        state.tagbuf is not None,\n        (\n            \"State must be initialized using \"\n            \"crypto_secretstream_xchacha20poly1305_init_pull\"\n        ),\n        raising=exc.ValueError,\n    )\n    ensure(\n        isinstance(c, bytes),\n        \"Ciphertext is not bytes\",\n        raising=exc.TypeError,\n    )\n    ensure(\n        len(c) >= crypto_secretstream_xchacha20poly1305_ABYTES,\n        \"Ciphertext is too short\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        len(c)\n        <= (\n            crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX\n            + crypto_secretstream_xchacha20poly1305_ABYTES\n        ),\n        \"Ciphertext is too long\",\n        raising=exc.ValueError,\n    )\n    ensure(\n        ad is None or isinstance(ad, bytes),\n        \"Additional data must be bytes or None\",\n        raising=exc.TypeError,\n    )\n\n    mlen = len(c) - crypto_secretstream_xchacha20poly1305_ABYTES\n    if state.rawbuf is None or len(state.rawbuf) < mlen:\n        state.rawbuf = ffi.new(\"unsigned char[]\", mlen)\n\n    if ad is None:\n        ad = ffi.NULL\n        adlen = 0\n    else:\n        adlen = len(ad)\n\n    rc = lib.crypto_secretstream_xchacha20poly1305_pull(\n        state.statebuf,\n        state.rawbuf,\n        ffi.NULL,\n        state.tagbuf,\n        c,\n        len(c),\n        ad,\n        adlen,\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    # Cast safety: we `ensure` above that `state.tagbuf is not None`.\n    return (\n        ffi.buffer(state.rawbuf, mlen)[:],\n        int(cast(bytes, state.tagbuf)[0]),\n    )\n\n\ndef crypto_secretstream_xchacha20poly1305_rekey(\n    state: crypto_secretstream_xchacha20poly1305_state,\n) -> None:\n    \"\"\"\n    Explicitly change the encryption key in the stream.\n\n    Normally the stream is re-keyed as needed or an explicit ``tag`` of\n    :data:`.crypto_secretstream_xchacha20poly1305_TAG_REKEY` is added to a\n    message to ensure forward secrecy, but this method can be used instead\n    if the re-keying is controlled without adding the tag.\n\n    :param state: a secretstream state object\n    :type state: crypto_secretstream_xchacha20poly1305_state\n\n    \"\"\"\n    ensure(\n        isinstance(state, crypto_secretstream_xchacha20poly1305_state),\n        \"State must be a crypto_secretstream_xchacha20poly1305_state object\",\n        raising=exc.TypeError,\n    )\n    lib.crypto_secretstream_xchacha20poly1305_rekey(state.statebuf)\n", "src/nacl/bindings/randombytes.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\n\nrandombytes_SEEDBYTES: int = lib.randombytes_seedbytes()\n\n\ndef randombytes(size: int) -> bytes:\n    \"\"\"\n    Returns ``size`` number of random bytes from a cryptographically secure\n    random source.\n\n    :param size: int\n    :rtype: bytes\n    \"\"\"\n    buf = ffi.new(\"unsigned char[]\", size)\n    lib.randombytes(buf, size)\n    return ffi.buffer(buf, size)[:]\n\n\ndef randombytes_buf_deterministic(size: int, seed: bytes) -> bytes:\n    \"\"\"\n    Returns ``size`` number of deterministically generated pseudorandom bytes\n    from a seed\n\n    :param size: int\n    :param seed: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(seed) != randombytes_SEEDBYTES:\n        raise exc.TypeError(\n            \"Deterministic random bytes must be generated from 32 bytes\"\n        )\n\n    buf = ffi.new(\"unsigned char[]\", size)\n    lib.randombytes_buf_deterministic(buf, size, seed)\n    return ffi.buffer(buf, size)[:]\n", "src/nacl/bindings/crypto_kx.py": "# Copyright 2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n__all__ = [\n    \"crypto_kx_keypair\",\n    \"crypto_kx_client_session_keys\",\n    \"crypto_kx_server_session_keys\",\n    \"crypto_kx_PUBLIC_KEY_BYTES\",\n    \"crypto_kx_SECRET_KEY_BYTES\",\n    \"crypto_kx_SEED_BYTES\",\n    \"crypto_kx_SESSION_KEY_BYTES\",\n]\n\n\"\"\"\nImplementations of client, server key exchange\n\"\"\"\ncrypto_kx_PUBLIC_KEY_BYTES: int = lib.crypto_kx_publickeybytes()\ncrypto_kx_SECRET_KEY_BYTES: int = lib.crypto_kx_secretkeybytes()\ncrypto_kx_SEED_BYTES: int = lib.crypto_kx_seedbytes()\ncrypto_kx_SESSION_KEY_BYTES: int = lib.crypto_kx_sessionkeybytes()\n\n\ndef crypto_kx_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate a key pair.\n    This is a duplicate crypto_box_keypair, but\n    is included for api consistency.\n    :return: (public_key, secret_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    public_key = ffi.new(\"unsigned char[]\", crypto_kx_PUBLIC_KEY_BYTES)\n    secret_key = ffi.new(\"unsigned char[]\", crypto_kx_SECRET_KEY_BYTES)\n    res = lib.crypto_kx_keypair(public_key, secret_key)\n    ensure(res == 0, \"Key generation failed.\", raising=exc.CryptoError)\n\n    return (\n        ffi.buffer(public_key, crypto_kx_PUBLIC_KEY_BYTES)[:],\n        ffi.buffer(secret_key, crypto_kx_SECRET_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate a key pair with a given seed.\n    This is functionally the same as crypto_box_seed_keypair, however\n    it uses the blake2b hash primitive instead of sha512.\n    It is included mainly for api consistency when using crypto_kx.\n    :param seed: random seed\n    :type seed: bytes\n    :return: (public_key, secret_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    public_key = ffi.new(\"unsigned char[]\", crypto_kx_PUBLIC_KEY_BYTES)\n    secret_key = ffi.new(\"unsigned char[]\", crypto_kx_SECRET_KEY_BYTES)\n    ensure(\n        isinstance(seed, bytes) and len(seed) == crypto_kx_SEED_BYTES,\n        \"Seed must be a {} byte long bytes sequence\".format(\n            crypto_kx_SEED_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    res = lib.crypto_kx_seed_keypair(public_key, secret_key, seed)\n    ensure(res == 0, \"Key generation failed.\", raising=exc.CryptoError)\n\n    return (\n        ffi.buffer(public_key, crypto_kx_PUBLIC_KEY_BYTES)[:],\n        ffi.buffer(secret_key, crypto_kx_SECRET_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_client_session_keys(\n    client_public_key: bytes,\n    client_secret_key: bytes,\n    server_public_key: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate session keys for the client.\n    :param client_public_key:\n    :type client_public_key: bytes\n    :param client_secret_key:\n    :type client_secret_key: bytes\n    :param server_public_key:\n    :type server_public_key: bytes\n    :return: (rx_key, tx_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    ensure(\n        isinstance(client_public_key, bytes)\n        and len(client_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Client public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(client_secret_key, bytes)\n        and len(client_secret_key) == crypto_kx_SECRET_KEY_BYTES,\n        \"Client secret key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(server_public_key, bytes)\n        and len(server_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Server public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    rx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    tx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    res = lib.crypto_kx_client_session_keys(\n        rx_key, tx_key, client_public_key, client_secret_key, server_public_key\n    )\n    ensure(\n        res == 0,\n        \"Client session key generation failed.\",\n        raising=exc.CryptoError,\n    )\n\n    return (\n        ffi.buffer(rx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n        ffi.buffer(tx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n    )\n\n\ndef crypto_kx_server_session_keys(\n    server_public_key: bytes,\n    server_secret_key: bytes,\n    client_public_key: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Generate session keys for the server.\n    :param server_public_key:\n    :type server_public_key: bytes\n    :param server_secret_key:\n    :type server_secret_key: bytes\n    :param client_public_key:\n    :type client_public_key: bytes\n    :return: (rx_key, tx_key)\n    :rtype: (bytes, bytes)\n    \"\"\"\n    ensure(\n        isinstance(server_public_key, bytes)\n        and len(server_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Server public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(server_secret_key, bytes)\n        and len(server_secret_key) == crypto_kx_SECRET_KEY_BYTES,\n        \"Server secret key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n    ensure(\n        isinstance(client_public_key, bytes)\n        and len(client_public_key) == crypto_kx_PUBLIC_KEY_BYTES,\n        \"Client public key must be a {} bytes long bytes sequence\".format(\n            crypto_kx_PUBLIC_KEY_BYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    rx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    tx_key = ffi.new(\"unsigned char[]\", crypto_kx_SESSION_KEY_BYTES)\n    res = lib.crypto_kx_server_session_keys(\n        rx_key, tx_key, server_public_key, server_secret_key, client_public_key\n    )\n    ensure(\n        res == 0,\n        \"Server session key generation failed.\",\n        raising=exc.CryptoError,\n    )\n\n    return (\n        ffi.buffer(rx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n        ffi.buffer(tx_key, crypto_kx_SESSION_KEY_BYTES)[:],\n    )\n", "src/nacl/bindings/sodium_core.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ndef _sodium_init() -> None:\n    ensure(\n        lib.sodium_init() != -1,\n        \"Could not initialize sodium\",\n        raising=exc.RuntimeError,\n    )\n\n\ndef sodium_init() -> None:\n    \"\"\"\n    Initializes sodium, picking the best implementations available for this\n    machine.\n    \"\"\"\n    ffi.init_once(_sodium_init, \"libsodium\")\n", "src/nacl/bindings/crypto_pwhash.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\nfrom typing import Tuple\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_pwhash_scryptsalsa208sha256 = bool(\n    lib.PYNACL_HAS_CRYPTO_PWHASH_SCRYPTSALSA208SHA256\n)\n\ncrypto_pwhash_scryptsalsa208sha256_STRPREFIX = b\"\"\ncrypto_pwhash_scryptsalsa208sha256_SALTBYTES = 0\ncrypto_pwhash_scryptsalsa208sha256_STRBYTES = 0\ncrypto_pwhash_scryptsalsa208sha256_PASSWD_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_PASSWD_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_BYTES_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_BYTES_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE = 0\ncrypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE = 0\n\nif has_crypto_pwhash_scryptsalsa208sha256:\n    crypto_pwhash_scryptsalsa208sha256_STRPREFIX = ffi.string(\n        ffi.cast(\"char *\", lib.crypto_pwhash_scryptsalsa208sha256_strprefix())\n    )[:]\n    crypto_pwhash_scryptsalsa208sha256_SALTBYTES = (\n        lib.crypto_pwhash_scryptsalsa208sha256_saltbytes()\n    )\n    crypto_pwhash_scryptsalsa208sha256_STRBYTES = (\n        lib.crypto_pwhash_scryptsalsa208sha256_strbytes()\n    )\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_passwd_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_passwd_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_bytes_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_bytes_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_min()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_max()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_interactive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_interactive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive()\n    )\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE = (\n        lib.crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive()\n    )\n\ncrypto_pwhash_ALG_ARGON2I13: int = lib.crypto_pwhash_alg_argon2i13()\ncrypto_pwhash_ALG_ARGON2ID13: int = lib.crypto_pwhash_alg_argon2id13()\ncrypto_pwhash_ALG_DEFAULT: int = lib.crypto_pwhash_alg_default()\n\ncrypto_pwhash_SALTBYTES: int = lib.crypto_pwhash_saltbytes()\ncrypto_pwhash_STRBYTES: int = lib.crypto_pwhash_strbytes()\n\ncrypto_pwhash_PASSWD_MIN: int = lib.crypto_pwhash_passwd_min()\ncrypto_pwhash_PASSWD_MAX: int = lib.crypto_pwhash_passwd_max()\ncrypto_pwhash_BYTES_MIN: int = lib.crypto_pwhash_bytes_min()\ncrypto_pwhash_BYTES_MAX: int = lib.crypto_pwhash_bytes_max()\n\ncrypto_pwhash_argon2i_STRPREFIX: bytes = ffi.string(\n    ffi.cast(\"char *\", lib.crypto_pwhash_argon2i_strprefix())\n)[:]\ncrypto_pwhash_argon2i_MEMLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2i_memlimit_min()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2i_memlimit_max()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2i_opslimit_min()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2i_opslimit_max()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_interactive()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_interactive()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_moderate()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_moderate()\n)\ncrypto_pwhash_argon2i_OPSLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2i_opslimit_sensitive()\n)\ncrypto_pwhash_argon2i_MEMLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2i_memlimit_sensitive()\n)\n\ncrypto_pwhash_argon2id_STRPREFIX: bytes = ffi.string(\n    ffi.cast(\"char *\", lib.crypto_pwhash_argon2id_strprefix())\n)[:]\ncrypto_pwhash_argon2id_MEMLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2id_memlimit_min()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2id_memlimit_max()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MIN: int = (\n    lib.crypto_pwhash_argon2id_opslimit_min()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MAX: int = (\n    lib.crypto_pwhash_argon2id_opslimit_max()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_interactive()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_interactive()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_moderate()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_MODERATE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_moderate()\n)\ncrypto_pwhash_argon2id_OPSLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2id_opslimit_sensitive()\n)\ncrypto_pwhash_argon2id_MEMLIMIT_SENSITIVE: int = (\n    lib.crypto_pwhash_argon2id_memlimit_sensitive()\n)\n\nSCRYPT_OPSLIMIT_INTERACTIVE = (\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\n)\nSCRYPT_MEMLIMIT_INTERACTIVE = (\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\n)\nSCRYPT_OPSLIMIT_SENSITIVE = (\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\n)\nSCRYPT_MEMLIMIT_SENSITIVE = (\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\n)\nSCRYPT_SALTBYTES = crypto_pwhash_scryptsalsa208sha256_SALTBYTES\nSCRYPT_STRBYTES = crypto_pwhash_scryptsalsa208sha256_STRBYTES\n\nSCRYPT_PR_MAX = (1 << 30) - 1\nLOG2_UINT64_MAX = 63\nUINT64_MAX = (1 << 64) - 1\nSCRYPT_MAX_MEM = 32 * (1024 * 1024)\n\n\ndef _check_memory_occupation(\n    n: int, r: int, p: int, maxmem: int = SCRYPT_MAX_MEM\n) -> None:\n    ensure(r != 0, \"Invalid block size\", raising=exc.ValueError)\n\n    ensure(p != 0, \"Invalid parallelization factor\", raising=exc.ValueError)\n\n    ensure(\n        (n & (n - 1)) == 0,\n        \"Cost factor must be a power of 2\",\n        raising=exc.ValueError,\n    )\n\n    ensure(n > 1, \"Cost factor must be at least 2\", raising=exc.ValueError)\n\n    ensure(\n        p <= SCRYPT_PR_MAX / r,\n        \"p*r is greater than {}\".format(SCRYPT_PR_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(n < (1 << (16 * r)), raising=exc.ValueError)\n\n    Blen = p * 128 * r\n\n    i = UINT64_MAX / 128\n\n    ensure(n + 2 <= i / r, raising=exc.ValueError)\n\n    Vlen = 32 * r * (n + 2) * 4\n\n    ensure(Blen <= UINT64_MAX - Vlen, raising=exc.ValueError)\n\n    ensure(Blen <= sys.maxsize - Vlen, raising=exc.ValueError)\n\n    ensure(\n        Blen + Vlen <= maxmem,\n        \"Memory limit would be exceeded with the chosen n, r, p\",\n        raising=exc.ValueError,\n    )\n\n\ndef nacl_bindings_pick_scrypt_params(\n    opslimit: int, memlimit: int\n) -> Tuple[int, int, int]:\n    \"\"\"Python implementation of libsodium's pickparams\"\"\"\n\n    if opslimit < 32768:\n        opslimit = 32768\n\n    r = 8\n\n    if opslimit < (memlimit // 32):\n        p = 1\n        maxn = opslimit // (4 * r)\n        for n_log2 in range(1, 63):  # pragma: no branch\n            if (2**n_log2) > (maxn // 2):\n                break\n    else:\n        maxn = memlimit // (r * 128)\n        for n_log2 in range(1, 63):  # pragma: no branch\n            if (2**n_log2) > maxn // 2:\n                break\n\n        maxrp = (opslimit // 4) // (2**n_log2)\n\n        if maxrp > 0x3FFFFFFF:  # pragma: no cover\n            maxrp = 0x3FFFFFFF\n\n        p = maxrp // r\n\n    return n_log2, r, p\n\n\ndef crypto_pwhash_scryptsalsa208sha256_ll(\n    passwd: bytes,\n    salt: bytes,\n    n: int,\n    r: int,\n    p: int,\n    dklen: int = 64,\n    maxmem: int = SCRYPT_MAX_MEM,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` and ``salt``\n    given as input.\n\n    The work factor can be tuned by by picking different\n    values for the parameters\n\n    :param bytes passwd:\n    :param bytes salt:\n    :param bytes salt: *must* be *exactly* :py:const:`.SALTBYTES` long\n    :param int dklen:\n    :param int opslimit:\n    :param int n:\n    :param int r: block size,\n    :param int p: the parallelism factor\n    :param int maxmem: the maximum available memory available for scrypt's\n                       operations\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(isinstance(n, int), raising=TypeError)\n    ensure(isinstance(r, int), raising=TypeError)\n    ensure(isinstance(p, int), raising=TypeError)\n\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n    ensure(isinstance(salt, bytes), raising=TypeError)\n\n    _check_memory_occupation(n, r, p, maxmem)\n\n    buf = ffi.new(\"uint8_t[]\", dklen)\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_ll(\n        passwd, len(passwd), salt, len(salt), n, r, p, buf, dklen\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.buffer(ffi.cast(\"char *\", buf), dklen)[:]\n\n\ndef crypto_pwhash_scryptsalsa208sha256_str(\n    passwd: bytes,\n    opslimit: int = SCRYPT_OPSLIMIT_INTERACTIVE,\n    memlimit: int = SCRYPT_MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` and ``salt``\n    given as input, returning a string representation which includes\n    the salt and the tuning parameters.\n\n    The returned string can be directly stored as a password hash.\n\n    See :py:func:`.crypto_pwhash_scryptsalsa208sha256` for a short\n    discussion about ``opslimit`` and ``memlimit`` values.\n\n    :param bytes passwd:\n    :param int opslimit:\n    :param int memlimit:\n    :return: serialized key hash, including salt and tuning parameters\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    buf = ffi.new(\"char[]\", SCRYPT_STRBYTES)\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_str(\n        buf, passwd, len(passwd), opslimit, memlimit\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in password hashing\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.string(buf)\n\n\ndef crypto_pwhash_scryptsalsa208sha256_str_verify(\n    passwd_hash: bytes, passwd: bytes\n) -> bool:\n    \"\"\"\n    Verifies the ``passwd`` against the ``passwd_hash`` that was generated.\n    Returns True or False depending on the success\n\n    :param passwd_hash: bytes\n    :param passwd: bytes\n    :rtype: boolean\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_pwhash_scryptsalsa208sha256,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(passwd_hash) == SCRYPT_STRBYTES - 1,\n        \"Invalid password hash\",\n        raising=exc.ValueError,\n    )\n\n    ret = lib.crypto_pwhash_scryptsalsa208sha256_str_verify(\n        passwd_hash, passwd, len(passwd)\n    )\n    ensure(ret == 0, \"Wrong password\", raising=exc.InvalidkeyError)\n    # all went well, therefore:\n    return True\n\n\ndef _check_argon2_limits_alg(opslimit: int, memlimit: int, alg: int) -> None:\n    if alg == crypto_pwhash_ALG_ARGON2I13:\n        if memlimit < crypto_pwhash_argon2i_MEMLIMIT_MIN:\n            raise exc.ValueError(\n                \"memlimit must be at least {} bytes\".format(\n                    crypto_pwhash_argon2i_MEMLIMIT_MIN\n                )\n            )\n        elif memlimit > crypto_pwhash_argon2i_MEMLIMIT_MAX:\n            raise exc.ValueError(\n                \"memlimit must be at most {} bytes\".format(\n                    crypto_pwhash_argon2i_MEMLIMIT_MAX\n                )\n            )\n        if opslimit < crypto_pwhash_argon2i_OPSLIMIT_MIN:\n            raise exc.ValueError(\n                \"opslimit must be at least {}\".format(\n                    crypto_pwhash_argon2i_OPSLIMIT_MIN\n                )\n            )\n        elif opslimit > crypto_pwhash_argon2i_OPSLIMIT_MAX:\n            raise exc.ValueError(\n                \"opslimit must be at most {}\".format(\n                    crypto_pwhash_argon2i_OPSLIMIT_MAX\n                )\n            )\n\n    elif alg == crypto_pwhash_ALG_ARGON2ID13:\n        if memlimit < crypto_pwhash_argon2id_MEMLIMIT_MIN:\n            raise exc.ValueError(\n                \"memlimit must be at least {} bytes\".format(\n                    crypto_pwhash_argon2id_MEMLIMIT_MIN\n                )\n            )\n        elif memlimit > crypto_pwhash_argon2id_MEMLIMIT_MAX:\n            raise exc.ValueError(\n                \"memlimit must be at most {} bytes\".format(\n                    crypto_pwhash_argon2id_MEMLIMIT_MAX\n                )\n            )\n        if opslimit < crypto_pwhash_argon2id_OPSLIMIT_MIN:\n            raise exc.ValueError(\n                \"opslimit must be at least {}\".format(\n                    crypto_pwhash_argon2id_OPSLIMIT_MIN\n                )\n            )\n        elif opslimit > crypto_pwhash_argon2id_OPSLIMIT_MAX:\n            raise exc.ValueError(\n                \"opslimit must be at most {}\".format(\n                    crypto_pwhash_argon2id_OPSLIMIT_MAX\n                )\n            )\n    else:\n        raise exc.TypeError(\"Unsupported algorithm\")\n\n\ndef crypto_pwhash_alg(\n    outlen: int,\n    passwd: bytes,\n    salt: bytes,\n    opslimit: int,\n    memlimit: int,\n    alg: int,\n) -> bytes:\n    \"\"\"\n    Derive a raw cryptographic key using the ``passwd`` and the ``salt``\n    given as input to the ``alg`` algorithm.\n\n    :param outlen: the length of the derived key\n    :type outlen: int\n    :param passwd: The input password\n    :type passwd: bytes\n    :param salt:\n    :type salt: bytes\n    :param opslimit: computational cost\n    :type opslimit: int\n    :param memlimit: memory cost\n    :type memlimit: int\n    :param alg: algorithm identifier\n    :type alg: int\n    :return: derived key\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(outlen, int), raising=exc.TypeError)\n    ensure(isinstance(opslimit, int), raising=exc.TypeError)\n    ensure(isinstance(memlimit, int), raising=exc.TypeError)\n    ensure(isinstance(alg, int), raising=exc.TypeError)\n    ensure(isinstance(passwd, bytes), raising=exc.TypeError)\n\n    if len(salt) != crypto_pwhash_SALTBYTES:\n        raise exc.ValueError(\n            \"salt must be exactly {} bytes long\".format(\n                crypto_pwhash_SALTBYTES\n            )\n        )\n\n    if outlen < crypto_pwhash_BYTES_MIN:\n        raise exc.ValueError(\n            \"derived key must be at least {} bytes long\".format(\n                crypto_pwhash_BYTES_MIN\n            )\n        )\n\n    elif outlen > crypto_pwhash_BYTES_MAX:\n        raise exc.ValueError(\n            \"derived key must be at most {} bytes long\".format(\n                crypto_pwhash_BYTES_MAX\n            )\n        )\n\n    _check_argon2_limits_alg(opslimit, memlimit, alg)\n\n    outbuf = ffi.new(\"unsigned char[]\", outlen)\n\n    ret = lib.crypto_pwhash(\n        outbuf, outlen, passwd, len(passwd), salt, opslimit, memlimit, alg\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.buffer(outbuf, outlen)[:]\n\n\ndef crypto_pwhash_str_alg(\n    passwd: bytes,\n    opslimit: int,\n    memlimit: int,\n    alg: int,\n) -> bytes:\n    \"\"\"\n    Derive a cryptographic key using the ``passwd`` given as input\n    and a random salt, returning a string representation which\n    includes the salt, the tuning parameters and the used algorithm.\n\n    :param passwd: The input password\n    :type passwd: bytes\n    :param opslimit: computational cost\n    :type opslimit: int\n    :param memlimit: memory cost\n    :type memlimit: int\n    :param alg: The algorithm to use\n    :type alg: int\n    :return: serialized derived key and parameters\n    :rtype: bytes\n    \"\"\"\n    ensure(isinstance(opslimit, int), raising=TypeError)\n    ensure(isinstance(memlimit, int), raising=TypeError)\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n\n    _check_argon2_limits_alg(opslimit, memlimit, alg)\n\n    outbuf = ffi.new(\"char[]\", 128)\n\n    ret = lib.crypto_pwhash_str_alg(\n        outbuf, passwd, len(passwd), opslimit, memlimit, alg\n    )\n\n    ensure(\n        ret == 0,\n        \"Unexpected failure in key derivation\",\n        raising=exc.RuntimeError,\n    )\n\n    return ffi.string(outbuf)\n\n\ndef crypto_pwhash_str_verify(passwd_hash: bytes, passwd: bytes) -> bool:\n    \"\"\"\n    Verifies the ``passwd`` against a given password hash.\n\n    Returns True on success, raises InvalidkeyError on failure\n    :param passwd_hash: saved password hash\n    :type passwd_hash: bytes\n    :param passwd: password to be checked\n    :type passwd: bytes\n    :return: success\n    :rtype: boolean\n    \"\"\"\n    ensure(isinstance(passwd_hash, bytes), raising=TypeError)\n    ensure(isinstance(passwd, bytes), raising=TypeError)\n    ensure(\n        len(passwd_hash) <= 127,\n        \"Hash must be at most 127 bytes long\",\n        raising=exc.ValueError,\n    )\n\n    ret = lib.crypto_pwhash_str_verify(passwd_hash, passwd, len(passwd))\n\n    ensure(ret == 0, \"Wrong password\", raising=exc.InvalidkeyError)\n    # all went well, therefore:\n    return True\n\n\ncrypto_pwhash_argon2i_str_verify = crypto_pwhash_str_verify\n", "src/nacl/bindings/crypto_core.py": "# Copyright 2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_core_ed25519 = bool(lib.PYNACL_HAS_CRYPTO_CORE_ED25519)\n\ncrypto_core_ed25519_BYTES = 0\ncrypto_core_ed25519_SCALARBYTES = 0\ncrypto_core_ed25519_NONREDUCEDSCALARBYTES = 0\n\nif has_crypto_core_ed25519:\n    crypto_core_ed25519_BYTES = lib.crypto_core_ed25519_bytes()\n    crypto_core_ed25519_SCALARBYTES = lib.crypto_core_ed25519_scalarbytes()\n    crypto_core_ed25519_NONREDUCEDSCALARBYTES = (\n        lib.crypto_core_ed25519_nonreducedscalarbytes()\n    )\n\n\ndef crypto_core_ed25519_is_valid_point(p: bytes) -> bool:\n    \"\"\"\n    Check if ``p`` represents a point on the edwards25519 curve, in canonical\n    form, on the main subgroup, and that the point doesn't have a small order.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: point validity\n    :rtype: bool\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_core_ed25519_BYTES,\n        \"Point must be a crypto_core_ed25519_BYTES long bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    rc = lib.crypto_core_ed25519_is_valid_point(p)\n    return rc == 1\n\n\ndef crypto_core_ed25519_from_uniform(r: bytes) -> bytes:\n    \"\"\"\n    Maps a 32 bytes vector ``r`` to a point. The point is guaranteed to be on the main subgroup.\n    This function directly exposes the Elligator 2 map, uses the high bit to set\n    the sign of the X coordinate, and the resulting point is multiplied by the cofactor.\n\n    :param r: a :py:data:`.crypto_core_ed25519_BYTES` long bytes\n              sequence representing arbitrary data\n    :type r: bytes\n    :return: a point on the edwards25519 curve main order subgroup, represented as a\n             :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(r, bytes) and len(r) == crypto_core_ed25519_BYTES,\n        \"Integer r must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    p = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_from_uniform(p, r)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(p, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_add(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Add two points on the edwards25519 curve.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type q: bytes\n    :return: a point on the edwards25519 curve represented as\n             a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_BYTES\n        and len(q) == crypto_core_ed25519_BYTES,\n        \"Each point must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_add(r, p, q)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_sub(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Subtract a point from another on the edwards25519 curve.\n\n    :param p: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type q: bytes\n    :return: a point on the edwards25519 curve represented as\n             a :py:data:`.crypto_core_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_BYTES\n        and len(q) == crypto_core_ed25519_BYTES,\n        \"Each point must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_BYTES)\n\n    rc = lib.crypto_core_ed25519_sub(r, p, q)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_BYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_invert(s: bytes) -> bytes:\n    \"\"\"\n    Return the multiplicative inverse of integer ``s`` modulo ``L``,\n    i.e an integer ``i`` such that ``s * i = 1 (mod L)``, where ``L``\n    is the order of the main subgroup.\n\n    Raises a ``exc.RuntimeError`` if ``s`` is the integer zero.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    rc = lib.crypto_core_ed25519_scalar_invert(r, s)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_negate(s: bytes) -> bytes:\n    \"\"\"\n    Return the integer ``n`` such that ``s + n = 0 (mod L)``, where ``L``\n    is the order of the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_negate(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_complement(s: bytes) -> bytes:\n    \"\"\"\n    Return the complement of integer ``s`` modulo ``L``, i.e. an integer\n    ``c`` such that ``s + c = 1 (mod L)``, where ``L`` is the order of\n    the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes) and len(s) == crypto_core_ed25519_SCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_complement(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_add(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Add integers ``p`` and ``q`` modulo ``L``, where ``L`` is the order of\n    the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_add(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_sub(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Subtract integers ``p`` and ``q`` modulo ``L``, where ``L`` is the\n    order of the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_sub(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_mul(p: bytes, q: bytes) -> bytes:\n    \"\"\"\n    Multiply integers ``p`` and ``q`` modulo ``L``, where ``L`` is the\n    order of the main subgroup.\n\n    :param p: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type p: bytes\n    :param q: a :py:data:`.crypto_core_ed25519_SCALARBYTES`\n              long bytes sequence representing an integer\n    :type q: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(p, bytes)\n        and isinstance(q, bytes)\n        and len(p) == crypto_core_ed25519_SCALARBYTES\n        and len(q) == crypto_core_ed25519_SCALARBYTES,\n        \"Each integer must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_mul(r, p, q)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n\n\ndef crypto_core_ed25519_scalar_reduce(s: bytes) -> bytes:\n    \"\"\"\n    Reduce integer ``s`` to ``s`` modulo ``L``, where ``L`` is the order\n    of the main subgroup.\n\n    :param s: a :py:data:`.crypto_core_ed25519_NONREDUCEDSCALARBYTES`\n              long bytes sequence representing an integer\n    :type s: bytes\n    :return: an integer represented as a\n              :py:data:`.crypto_core_ed25519_SCALARBYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_core_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(s, bytes)\n        and len(s) == crypto_core_ed25519_NONREDUCEDSCALARBYTES,\n        \"Integer s must be a {} long bytes sequence\".format(\n            \"crypto_core_ed25519_NONREDUCEDSCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    r = ffi.new(\"unsigned char[]\", crypto_core_ed25519_SCALARBYTES)\n\n    lib.crypto_core_ed25519_scalar_reduce(r, s)\n\n    return ffi.buffer(r, crypto_core_ed25519_SCALARBYTES)[:]\n", "src/nacl/bindings/crypto_scalarmult.py": "# Copyright 2013-2018 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_scalarmult_ed25519 = bool(lib.PYNACL_HAS_CRYPTO_SCALARMULT_ED25519)\n\ncrypto_scalarmult_BYTES: int = lib.crypto_scalarmult_bytes()\ncrypto_scalarmult_SCALARBYTES: int = lib.crypto_scalarmult_scalarbytes()\n\ncrypto_scalarmult_ed25519_BYTES = 0\ncrypto_scalarmult_ed25519_SCALARBYTES = 0\n\nif has_crypto_scalarmult_ed25519:\n    crypto_scalarmult_ed25519_BYTES = lib.crypto_scalarmult_ed25519_bytes()\n    crypto_scalarmult_ed25519_SCALARBYTES = (\n        lib.crypto_scalarmult_ed25519_scalarbytes()\n    )\n\n\ndef crypto_scalarmult_base(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n``.\n\n    :param n: bytes\n    :rtype: bytes\n    \"\"\"\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_BYTES)\n\n    rc = lib.crypto_scalarmult_base(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_SCALARBYTES)[:]\n\n\ndef crypto_scalarmult(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of the given group element and an\n    integer ``n``.\n\n    :param p: bytes\n    :param n: bytes\n    :rtype: bytes\n    \"\"\"\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_BYTES)\n\n    rc = lib.crypto_scalarmult(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_SCALARBYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_base(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n`` on the edwards25519 curve.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_base(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_base_noclamp(n: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a standard group element and an\n    integer ``n`` on the edwards25519 curve. The integer ``n`` is not clamped.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_base_noclamp(q, n)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of a *clamped* integer ``n``\n    and the given group element on the edwards25519 curve.\n    The scalar is clamped, as done in the public key generation case,\n    by setting to zero the bits in position [0, 1, 2, 255] and setting\n    to one the bit in position 254.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :param p: a :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_scalarmult_ed25519_BYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n\n\ndef crypto_scalarmult_ed25519_noclamp(n: bytes, p: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the scalar product of an integer ``n``\n    and the given group element on the edwards25519 curve. The integer\n    ``n`` is not clamped.\n\n    :param n: a :py:data:`.crypto_scalarmult_ed25519_SCALARBYTES` long bytes\n              sequence representing a scalar\n    :type n: bytes\n    :param p: a :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n              representing a point on the edwards25519 curve\n    :type p: bytes\n    :return: a point on the edwards25519 curve, represented as a\n             :py:data:`.crypto_scalarmult_ed25519_BYTES` long bytes sequence\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_scalarmult_ed25519,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        isinstance(n, bytes)\n        and len(n) == crypto_scalarmult_ed25519_SCALARBYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_SCALARBYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(p, bytes) and len(p) == crypto_scalarmult_ed25519_BYTES,\n        \"Input must be a {} long bytes sequence\".format(\n            \"crypto_scalarmult_ed25519_BYTES\"\n        ),\n        raising=exc.TypeError,\n    )\n\n    q = ffi.new(\"unsigned char[]\", crypto_scalarmult_ed25519_BYTES)\n\n    rc = lib.crypto_scalarmult_ed25519_noclamp(q, n, p)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(q, crypto_scalarmult_ed25519_BYTES)[:]\n", "src/nacl/bindings/__init__.py": "# Copyright 2013-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl.bindings.crypto_aead import (\n    crypto_aead_chacha20poly1305_ABYTES,\n    crypto_aead_chacha20poly1305_KEYBYTES,\n    crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX,\n    crypto_aead_chacha20poly1305_NPUBBYTES,\n    crypto_aead_chacha20poly1305_NSECBYTES,\n    crypto_aead_chacha20poly1305_decrypt,\n    crypto_aead_chacha20poly1305_encrypt,\n    crypto_aead_chacha20poly1305_ietf_ABYTES,\n    crypto_aead_chacha20poly1305_ietf_KEYBYTES,\n    crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX,\n    crypto_aead_chacha20poly1305_ietf_NPUBBYTES,\n    crypto_aead_chacha20poly1305_ietf_NSECBYTES,\n    crypto_aead_chacha20poly1305_ietf_decrypt,\n    crypto_aead_chacha20poly1305_ietf_encrypt,\n    crypto_aead_xchacha20poly1305_ietf_ABYTES,\n    crypto_aead_xchacha20poly1305_ietf_KEYBYTES,\n    crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX,\n    crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,\n    crypto_aead_xchacha20poly1305_ietf_NSECBYTES,\n    crypto_aead_xchacha20poly1305_ietf_decrypt,\n    crypto_aead_xchacha20poly1305_ietf_encrypt,\n)\nfrom nacl.bindings.crypto_box import (\n    crypto_box,\n    crypto_box_BEFORENMBYTES,\n    crypto_box_BOXZEROBYTES,\n    crypto_box_NONCEBYTES,\n    crypto_box_PUBLICKEYBYTES,\n    crypto_box_SEALBYTES,\n    crypto_box_SECRETKEYBYTES,\n    crypto_box_SEEDBYTES,\n    crypto_box_ZEROBYTES,\n    crypto_box_afternm,\n    crypto_box_beforenm,\n    crypto_box_keypair,\n    crypto_box_open,\n    crypto_box_open_afternm,\n    crypto_box_seal,\n    crypto_box_seal_open,\n    crypto_box_seed_keypair,\n)\nfrom nacl.bindings.crypto_core import (\n    crypto_core_ed25519_BYTES,\n    crypto_core_ed25519_NONREDUCEDSCALARBYTES,\n    crypto_core_ed25519_SCALARBYTES,\n    crypto_core_ed25519_add,\n    crypto_core_ed25519_from_uniform,\n    crypto_core_ed25519_is_valid_point,\n    crypto_core_ed25519_scalar_add,\n    crypto_core_ed25519_scalar_complement,\n    crypto_core_ed25519_scalar_invert,\n    crypto_core_ed25519_scalar_mul,\n    crypto_core_ed25519_scalar_negate,\n    crypto_core_ed25519_scalar_reduce,\n    crypto_core_ed25519_scalar_sub,\n    crypto_core_ed25519_sub,\n    has_crypto_core_ed25519,\n)\nfrom nacl.bindings.crypto_generichash import (\n    crypto_generichash_BYTES,\n    crypto_generichash_BYTES_MAX,\n    crypto_generichash_BYTES_MIN,\n    crypto_generichash_KEYBYTES,\n    crypto_generichash_KEYBYTES_MAX,\n    crypto_generichash_KEYBYTES_MIN,\n    crypto_generichash_PERSONALBYTES,\n    crypto_generichash_SALTBYTES,\n    crypto_generichash_STATEBYTES,\n    generichash_blake2b_final as crypto_generichash_blake2b_final,\n    generichash_blake2b_init as crypto_generichash_blake2b_init,\n    generichash_blake2b_salt_personal as crypto_generichash_blake2b_salt_personal,\n    generichash_blake2b_update as crypto_generichash_blake2b_update,\n)\nfrom nacl.bindings.crypto_hash import (\n    crypto_hash,\n    crypto_hash_BYTES,\n    crypto_hash_sha256,\n    crypto_hash_sha256_BYTES,\n    crypto_hash_sha512,\n    crypto_hash_sha512_BYTES,\n)\nfrom nacl.bindings.crypto_kx import (\n    crypto_kx_PUBLIC_KEY_BYTES,\n    crypto_kx_SECRET_KEY_BYTES,\n    crypto_kx_SEED_BYTES,\n    crypto_kx_SESSION_KEY_BYTES,\n    crypto_kx_client_session_keys,\n    crypto_kx_keypair,\n    crypto_kx_seed_keypair,\n    crypto_kx_server_session_keys,\n)\nfrom nacl.bindings.crypto_pwhash import (\n    crypto_pwhash_ALG_ARGON2I13,\n    crypto_pwhash_ALG_ARGON2ID13,\n    crypto_pwhash_ALG_DEFAULT,\n    crypto_pwhash_BYTES_MAX,\n    crypto_pwhash_BYTES_MIN,\n    crypto_pwhash_PASSWD_MAX,\n    crypto_pwhash_PASSWD_MIN,\n    crypto_pwhash_SALTBYTES,\n    crypto_pwhash_STRBYTES,\n    crypto_pwhash_alg,\n    crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2i_MEMLIMIT_MAX,\n    crypto_pwhash_argon2i_MEMLIMIT_MIN,\n    crypto_pwhash_argon2i_MEMLIMIT_MODERATE,\n    crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2i_OPSLIMIT_MAX,\n    crypto_pwhash_argon2i_OPSLIMIT_MIN,\n    crypto_pwhash_argon2i_OPSLIMIT_MODERATE,\n    crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_argon2i_STRPREFIX,\n    crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2id_MEMLIMIT_MAX,\n    crypto_pwhash_argon2id_MEMLIMIT_MIN,\n    crypto_pwhash_argon2id_MEMLIMIT_MODERATE,\n    crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_argon2id_OPSLIMIT_MAX,\n    crypto_pwhash_argon2id_OPSLIMIT_MIN,\n    crypto_pwhash_argon2id_OPSLIMIT_MODERATE,\n    crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_argon2id_STRPREFIX,\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MAX,\n    crypto_pwhash_scryptsalsa208sha256_BYTES_MIN,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN,\n    crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN,\n    crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE,\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX,\n    crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN,\n    crypto_pwhash_scryptsalsa208sha256_SALTBYTES,\n    crypto_pwhash_scryptsalsa208sha256_STRBYTES,\n    crypto_pwhash_scryptsalsa208sha256_STRPREFIX,\n    crypto_pwhash_scryptsalsa208sha256_ll,\n    crypto_pwhash_scryptsalsa208sha256_str,\n    crypto_pwhash_scryptsalsa208sha256_str_verify,\n    crypto_pwhash_str_alg,\n    crypto_pwhash_str_verify,\n    has_crypto_pwhash_scryptsalsa208sha256,\n    nacl_bindings_pick_scrypt_params,\n)\nfrom nacl.bindings.crypto_scalarmult import (\n    crypto_scalarmult,\n    crypto_scalarmult_BYTES,\n    crypto_scalarmult_SCALARBYTES,\n    crypto_scalarmult_base,\n    crypto_scalarmult_ed25519,\n    crypto_scalarmult_ed25519_BYTES,\n    crypto_scalarmult_ed25519_SCALARBYTES,\n    crypto_scalarmult_ed25519_base,\n    crypto_scalarmult_ed25519_base_noclamp,\n    crypto_scalarmult_ed25519_noclamp,\n    has_crypto_scalarmult_ed25519,\n)\nfrom nacl.bindings.crypto_secretbox import (\n    crypto_secretbox,\n    crypto_secretbox_BOXZEROBYTES,\n    crypto_secretbox_KEYBYTES,\n    crypto_secretbox_MACBYTES,\n    crypto_secretbox_MESSAGEBYTES_MAX,\n    crypto_secretbox_NONCEBYTES,\n    crypto_secretbox_ZEROBYTES,\n    crypto_secretbox_open,\n)\nfrom nacl.bindings.crypto_secretstream import (\n    crypto_secretstream_xchacha20poly1305_ABYTES,\n    crypto_secretstream_xchacha20poly1305_HEADERBYTES,\n    crypto_secretstream_xchacha20poly1305_KEYBYTES,\n    crypto_secretstream_xchacha20poly1305_STATEBYTES,\n    crypto_secretstream_xchacha20poly1305_TAG_FINAL,\n    crypto_secretstream_xchacha20poly1305_TAG_MESSAGE,\n    crypto_secretstream_xchacha20poly1305_TAG_PUSH,\n    crypto_secretstream_xchacha20poly1305_TAG_REKEY,\n    crypto_secretstream_xchacha20poly1305_init_pull,\n    crypto_secretstream_xchacha20poly1305_init_push,\n    crypto_secretstream_xchacha20poly1305_keygen,\n    crypto_secretstream_xchacha20poly1305_pull,\n    crypto_secretstream_xchacha20poly1305_push,\n    crypto_secretstream_xchacha20poly1305_rekey,\n    crypto_secretstream_xchacha20poly1305_state,\n)\nfrom nacl.bindings.crypto_shorthash import (\n    BYTES as crypto_shorthash_siphash24_BYTES,\n    KEYBYTES as crypto_shorthash_siphash24_KEYBYTES,\n    XBYTES as crypto_shorthash_siphashx24_BYTES,\n    XKEYBYTES as crypto_shorthash_siphashx24_KEYBYTES,\n    crypto_shorthash_siphash24,\n    crypto_shorthash_siphashx24,\n    has_crypto_shorthash_siphashx24,\n)\nfrom nacl.bindings.crypto_sign import (\n    crypto_sign,\n    crypto_sign_BYTES,\n    crypto_sign_PUBLICKEYBYTES,\n    crypto_sign_SECRETKEYBYTES,\n    crypto_sign_SEEDBYTES,\n    crypto_sign_ed25519_pk_to_curve25519,\n    crypto_sign_ed25519_sk_to_curve25519,\n    crypto_sign_ed25519_sk_to_pk,\n    crypto_sign_ed25519_sk_to_seed,\n    crypto_sign_ed25519ph_STATEBYTES,\n    crypto_sign_ed25519ph_final_create,\n    crypto_sign_ed25519ph_final_verify,\n    crypto_sign_ed25519ph_state,\n    crypto_sign_ed25519ph_update,\n    crypto_sign_keypair,\n    crypto_sign_open,\n    crypto_sign_seed_keypair,\n)\nfrom nacl.bindings.randombytes import (\n    randombytes,\n    randombytes_buf_deterministic,\n)\nfrom nacl.bindings.sodium_core import sodium_init\nfrom nacl.bindings.utils import (\n    sodium_add,\n    sodium_increment,\n    sodium_memcmp,\n    sodium_pad,\n    sodium_unpad,\n)\n\n\n__all__ = [\n    \"crypto_aead_chacha20poly1305_ABYTES\",\n    \"crypto_aead_chacha20poly1305_KEYBYTES\",\n    \"crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX\",\n    \"crypto_aead_chacha20poly1305_NPUBBYTES\",\n    \"crypto_aead_chacha20poly1305_NSECBYTES\",\n    \"crypto_aead_chacha20poly1305_decrypt\",\n    \"crypto_aead_chacha20poly1305_encrypt\",\n    \"crypto_aead_chacha20poly1305_ietf_ABYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_KEYBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX\",\n    \"crypto_aead_chacha20poly1305_ietf_NPUBBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_NSECBYTES\",\n    \"crypto_aead_chacha20poly1305_ietf_decrypt\",\n    \"crypto_aead_chacha20poly1305_ietf_encrypt\",\n    \"crypto_aead_xchacha20poly1305_ietf_ABYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_KEYBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX\",\n    \"crypto_aead_xchacha20poly1305_ietf_NPUBBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_NSECBYTES\",\n    \"crypto_aead_xchacha20poly1305_ietf_decrypt\",\n    \"crypto_aead_xchacha20poly1305_ietf_encrypt\",\n    \"crypto_box_SECRETKEYBYTES\",\n    \"crypto_box_PUBLICKEYBYTES\",\n    \"crypto_box_SEEDBYTES\",\n    \"crypto_box_NONCEBYTES\",\n    \"crypto_box_ZEROBYTES\",\n    \"crypto_box_BOXZEROBYTES\",\n    \"crypto_box_BEFORENMBYTES\",\n    \"crypto_box_SEALBYTES\",\n    \"crypto_box_keypair\",\n    \"crypto_box\",\n    \"crypto_box_open\",\n    \"crypto_box_beforenm\",\n    \"crypto_box_afternm\",\n    \"crypto_box_open_afternm\",\n    \"crypto_box_seal\",\n    \"crypto_box_seal_open\",\n    \"crypto_box_seed_keypair\",\n    \"has_crypto_core_ed25519\",\n    \"crypto_core_ed25519_BYTES\",\n    \"crypto_core_ed25519_UNIFORMBYTES\",\n    \"crypto_core_ed25519_SCALARBYTES\",\n    \"crypto_core_ed25519_NONREDUCEDSCALARBYTES\",\n    \"crypto_core_ed25519_add\",\n    \"crypto_core_ed25519_from_uniform\",\n    \"crypto_core_ed25519_is_valid_point\",\n    \"crypto_core_ed25519_sub\",\n    \"crypto_core_ed25519_scalar_invert\",\n    \"crypto_core_ed25519_scalar_negate\",\n    \"crypto_core_ed25519_scalar_complement\",\n    \"crypto_core_ed25519_scalar_add\",\n    \"crypto_core_ed25519_scalar_sub\",\n    \"crypto_core_ed25519_scalar_mul\",\n    \"crypto_core_ed25519_scalar_reduce\",\n    \"crypto_hash_BYTES\",\n    \"crypto_hash_sha256_BYTES\",\n    \"crypto_hash_sha512_BYTES\",\n    \"crypto_hash\",\n    \"crypto_hash_sha256\",\n    \"crypto_hash_sha512\",\n    \"crypto_generichash_BYTES\",\n    \"crypto_generichash_BYTES_MIN\",\n    \"crypto_generichash_BYTES_MAX\",\n    \"crypto_generichash_KEYBYTES\",\n    \"crypto_generichash_KEYBYTES_MIN\",\n    \"crypto_generichash_KEYBYTES_MAX\",\n    \"crypto_generichash_SALTBYTES\",\n    \"crypto_generichash_PERSONALBYTES\",\n    \"crypto_generichash_STATEBYTES\",\n    \"crypto_generichash_blake2b_salt_personal\",\n    \"crypto_generichash_blake2b_init\",\n    \"crypto_generichash_blake2b_update\",\n    \"crypto_generichash_blake2b_final\",\n    \"crypto_kx_keypair\",\n    \"crypto_kx_seed_keypair\",\n    \"crypto_kx_client_session_keys\",\n    \"crypto_kx_server_session_keys\",\n    \"crypto_kx_PUBLIC_KEY_BYTES\",\n    \"crypto_kx_SECRET_KEY_BYTES\",\n    \"crypto_kx_SEED_BYTES\",\n    \"crypto_kx_SESSION_KEY_BYTES\",\n    \"has_crypto_scalarmult_ed25519\",\n    \"crypto_scalarmult_BYTES\",\n    \"crypto_scalarmult_SCALARBYTES\",\n    \"crypto_scalarmult\",\n    \"crypto_scalarmult_base\",\n    \"crypto_scalarmult_ed25519_BYTES\",\n    \"crypto_scalarmult_ed25519_SCALARBYTES\",\n    \"crypto_scalarmult_ed25519\",\n    \"crypto_scalarmult_ed25519_base\",\n    \"crypto_scalarmult_ed25519_noclamp\",\n    \"crypto_scalarmult_ed25519_base_noclamp\",\n    \"crypto_secretbox_KEYBYTES\",\n    \"crypto_secretbox_NONCEBYTES\",\n    \"crypto_secretbox_ZEROBYTES\",\n    \"crypto_secretbox_BOXZEROBYTES\",\n    \"crypto_secretbox_MACBYTES\",\n    \"crypto_secretbox_MESSAGEBYTES_MAX\",\n    \"crypto_secretbox\",\n    \"crypto_secretbox_open\",\n    \"crypto_secretstream_xchacha20poly1305_ABYTES\",\n    \"crypto_secretstream_xchacha20poly1305_HEADERBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_KEYBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_STATEBYTES\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_FINAL\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_PUSH\",\n    \"crypto_secretstream_xchacha20poly1305_TAG_REKEY\",\n    \"crypto_secretstream_xchacha20poly1305_init_pull\",\n    \"crypto_secretstream_xchacha20poly1305_init_push\",\n    \"crypto_secretstream_xchacha20poly1305_keygen\",\n    \"crypto_secretstream_xchacha20poly1305_pull\",\n    \"crypto_secretstream_xchacha20poly1305_push\",\n    \"crypto_secretstream_xchacha20poly1305_rekey\",\n    \"crypto_secretstream_xchacha20poly1305_state\",\n    \"has_crypto_shorthash_siphashx24\",\n    \"crypto_shorthash_siphash24_BYTES\",\n    \"crypto_shorthash_siphash24_KEYBYTES\",\n    \"crypto_shorthash_siphash24\",\n    \"crypto_shorthash_siphashx24_BYTES\",\n    \"crypto_shorthash_siphashx24_KEYBYTES\",\n    \"crypto_shorthash_siphashx24\",\n    \"crypto_sign_BYTES\",\n    \"crypto_sign_SEEDBYTES\",\n    \"crypto_sign_PUBLICKEYBYTES\",\n    \"crypto_sign_SECRETKEYBYTES\",\n    \"crypto_sign_keypair\",\n    \"crypto_sign_seed_keypair\",\n    \"crypto_sign\",\n    \"crypto_sign_open\",\n    \"crypto_sign_ed25519_pk_to_curve25519\",\n    \"crypto_sign_ed25519_sk_to_curve25519\",\n    \"crypto_sign_ed25519_sk_to_pk\",\n    \"crypto_sign_ed25519_sk_to_seed\",\n    \"crypto_sign_ed25519ph_STATEBYTES\",\n    \"crypto_sign_ed25519ph_final_create\",\n    \"crypto_sign_ed25519ph_final_verify\",\n    \"crypto_sign_ed25519ph_state\",\n    \"crypto_sign_ed25519ph_update\",\n    \"crypto_pwhash_ALG_ARGON2I13\",\n    \"crypto_pwhash_ALG_ARGON2ID13\",\n    \"crypto_pwhash_ALG_DEFAULT\",\n    \"crypto_pwhash_BYTES_MAX\",\n    \"crypto_pwhash_BYTES_MIN\",\n    \"crypto_pwhash_PASSWD_MAX\",\n    \"crypto_pwhash_PASSWD_MIN\",\n    \"crypto_pwhash_SALTBYTES\",\n    \"crypto_pwhash_STRBYTES\",\n    \"crypto_pwhash_alg\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MIN\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MAX\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MIN\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MAX\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2i_STRPREFIX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MIN\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MAX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MIN\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MAX\",\n    \"crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_MODERATE\",\n    \"crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_argon2id_STRPREFIX\",\n    \"crypto_pwhash_str_alg\",\n    \"crypto_pwhash_str_verify\",\n    \"has_crypto_pwhash_scryptsalsa208sha256\",\n    \"crypto_pwhash_scryptsalsa208sha256_BYTES_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_BYTES_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\",\n    \"crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX\",\n    \"crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN\",\n    \"crypto_pwhash_scryptsalsa208sha256_SALTBYTES\",\n    \"crypto_pwhash_scryptsalsa208sha256_STRBYTES\",\n    \"crypto_pwhash_scryptsalsa208sha256_STRPREFIX\",\n    \"crypto_pwhash_scryptsalsa208sha256_ll\",\n    \"crypto_pwhash_scryptsalsa208sha256_str\",\n    \"crypto_pwhash_scryptsalsa208sha256_str_verify\",\n    \"nacl_bindings_pick_scrypt_params\",\n    \"randombytes\",\n    \"randombytes_buf_deterministic\",\n    \"sodium_init\",\n    \"sodium_add\",\n    \"sodium_increment\",\n    \"sodium_memcmp\",\n    \"sodium_pad\",\n    \"sodium_unpad\",\n]\n\n\n# Initialize Sodium\nsodium_init()\n", "src/nacl/bindings/crypto_box.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Tuple\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\n__all__ = [\"crypto_box_keypair\", \"crypto_box\"]\n\n\ncrypto_box_SECRETKEYBYTES: int = lib.crypto_box_secretkeybytes()\ncrypto_box_PUBLICKEYBYTES: int = lib.crypto_box_publickeybytes()\ncrypto_box_SEEDBYTES: int = lib.crypto_box_seedbytes()\ncrypto_box_NONCEBYTES: int = lib.crypto_box_noncebytes()\ncrypto_box_ZEROBYTES: int = lib.crypto_box_zerobytes()\ncrypto_box_BOXZEROBYTES: int = lib.crypto_box_boxzerobytes()\ncrypto_box_BEFORENMBYTES: int = lib.crypto_box_beforenmbytes()\ncrypto_box_SEALBYTES: int = lib.crypto_box_sealbytes()\n\n\ndef crypto_box_keypair() -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a randomly generated public and secret key.\n\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    pk = ffi.new(\"unsigned char[]\", crypto_box_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_box_SECRETKEYBYTES)\n\n    rc = lib.crypto_box_keypair(pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_box_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_box_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_box_seed_keypair(seed: bytes) -> Tuple[bytes, bytes]:\n    \"\"\"\n    Returns a (public, secret) key pair deterministically generated\n    from an input ``seed``.\n\n    .. warning:: The seed **must** be high-entropy; therefore,\n        its generator **must** be a cryptographic quality\n        random function like, for example, :func:`~nacl.utils.random`.\n\n    .. warning:: The seed **must** be protected and remain secret.\n        Anyone who knows the seed is really in possession of\n        the corresponding PrivateKey.\n\n\n    :param seed: bytes\n    :rtype: (bytes(public_key), bytes(secret_key))\n    \"\"\"\n    ensure(isinstance(seed, bytes), \"seed must be bytes\", raising=TypeError)\n\n    if len(seed) != crypto_box_SEEDBYTES:\n        raise exc.ValueError(\"Invalid seed\")\n\n    pk = ffi.new(\"unsigned char[]\", crypto_box_PUBLICKEYBYTES)\n    sk = ffi.new(\"unsigned char[]\", crypto_box_SECRETKEYBYTES)\n\n    rc = lib.crypto_box_seed_keypair(pk, sk, seed)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return (\n        ffi.buffer(pk, crypto_box_PUBLICKEYBYTES)[:],\n        ffi.buffer(sk, crypto_box_SECRETKEYBYTES)[:],\n    )\n\n\ndef crypto_box(message: bytes, nonce: bytes, pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns a message ``message`` using the secret key ``sk``,\n    public key ``pk``, and the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce size\")\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    padded = (b\"\\x00\" * crypto_box_ZEROBYTES) + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    rc = lib.crypto_box(ciphertext, padded, len(padded), nonce, pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, len(padded))[crypto_box_BOXZEROBYTES:]\n\n\ndef crypto_box_open(\n    ciphertext: bytes, nonce: bytes, pk: bytes, sk: bytes\n) -> bytes:\n    \"\"\"\n    Decrypts and returns an encrypted message ``ciphertext``, using the secret\n    key ``sk``, public key ``pk``, and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce size\")\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    padded = (b\"\\x00\" * crypto_box_BOXZEROBYTES) + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_box_open(plaintext, padded, len(padded), nonce, pk, sk)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, len(padded))[crypto_box_ZEROBYTES:]\n\n\ndef crypto_box_beforenm(pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Computes and returns the shared key for the public key ``pk`` and the\n    secret key ``sk``. This can be used to speed up operations where the same\n    set of keys is going to be used multiple times.\n\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    k = ffi.new(\"unsigned char[]\", crypto_box_BEFORENMBYTES)\n\n    rc = lib.crypto_box_beforenm(k, pk, sk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(k, crypto_box_BEFORENMBYTES)[:]\n\n\ndef crypto_box_afternm(message: bytes, nonce: bytes, k: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns the message ``message`` using the shared key ``k`` and\n    the nonce ``nonce``.\n\n    :param message: bytes\n    :param nonce: bytes\n    :param k: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    if len(k) != crypto_box_BEFORENMBYTES:\n        raise exc.ValueError(\"Invalid shared key\")\n\n    padded = b\"\\x00\" * crypto_box_ZEROBYTES + message\n    ciphertext = ffi.new(\"unsigned char[]\", len(padded))\n\n    rc = lib.crypto_box_afternm(ciphertext, padded, len(padded), nonce, k)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, len(padded))[crypto_box_BOXZEROBYTES:]\n\n\ndef crypto_box_open_afternm(\n    ciphertext: bytes, nonce: bytes, k: bytes\n) -> bytes:\n    \"\"\"\n    Decrypts and returns the encrypted message ``ciphertext``, using the shared\n    key ``k`` and the nonce ``nonce``.\n\n    :param ciphertext: bytes\n    :param nonce: bytes\n    :param k: bytes\n    :rtype: bytes\n    \"\"\"\n    if len(nonce) != crypto_box_NONCEBYTES:\n        raise exc.ValueError(\"Invalid nonce\")\n\n    if len(k) != crypto_box_BEFORENMBYTES:\n        raise exc.ValueError(\"Invalid shared key\")\n\n    padded = (b\"\\x00\" * crypto_box_BOXZEROBYTES) + ciphertext\n    plaintext = ffi.new(\"unsigned char[]\", len(padded))\n\n    res = lib.crypto_box_open_afternm(plaintext, padded, len(padded), nonce, k)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, len(padded))[crypto_box_ZEROBYTES:]\n\n\ndef crypto_box_seal(message: bytes, pk: bytes) -> bytes:\n    \"\"\"\n    Encrypts and returns a message ``message`` using an ephemeral secret key\n    and the public key ``pk``.\n    The ephemeral public key, which is embedded in the sealed box, is also\n    used, in combination with ``pk``, to derive the nonce needed for the\n    underlying box construct.\n\n    :param message: bytes\n    :param pk: bytes\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        isinstance(message, bytes),\n        \"input message must be bytes\",\n        raising=TypeError,\n    )\n\n    ensure(\n        isinstance(pk, bytes), \"public key must be bytes\", raising=TypeError\n    )\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    _mlen = len(message)\n    _clen = crypto_box_SEALBYTES + _mlen\n\n    ciphertext = ffi.new(\"unsigned char[]\", _clen)\n\n    rc = lib.crypto_box_seal(ciphertext, message, _mlen, pk)\n    ensure(rc == 0, \"Unexpected library error\", raising=exc.RuntimeError)\n\n    return ffi.buffer(ciphertext, _clen)[:]\n\n\ndef crypto_box_seal_open(ciphertext: bytes, pk: bytes, sk: bytes) -> bytes:\n    \"\"\"\n    Decrypts and returns an encrypted message ``ciphertext``, using the\n    recipent's secret key ``sk`` and the sender's ephemeral public key\n    embedded in the sealed box. The box construct nonce is derived from\n    the recipient's public key ``pk`` and the sender's public key.\n\n    :param ciphertext: bytes\n    :param pk: bytes\n    :param sk: bytes\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        isinstance(ciphertext, bytes),\n        \"input ciphertext must be bytes\",\n        raising=TypeError,\n    )\n\n    ensure(\n        isinstance(pk, bytes), \"public key must be bytes\", raising=TypeError\n    )\n\n    ensure(\n        isinstance(sk, bytes), \"secret key must be bytes\", raising=TypeError\n    )\n\n    if len(pk) != crypto_box_PUBLICKEYBYTES:\n        raise exc.ValueError(\"Invalid public key\")\n\n    if len(sk) != crypto_box_SECRETKEYBYTES:\n        raise exc.ValueError(\"Invalid secret key\")\n\n    _clen = len(ciphertext)\n\n    ensure(\n        _clen >= crypto_box_SEALBYTES,\n        (\"Input ciphertext must be at least {} long\").format(\n            crypto_box_SEALBYTES\n        ),\n        raising=exc.TypeError,\n    )\n\n    _mlen = _clen - crypto_box_SEALBYTES\n\n    # zero-length malloc results are implementation.dependent\n    plaintext = ffi.new(\"unsigned char[]\", max(1, _mlen))\n\n    res = lib.crypto_box_seal_open(plaintext, ciphertext, _clen, pk, sk)\n    ensure(\n        res == 0,\n        \"An error occurred trying to decrypt the message\",\n        raising=exc.CryptoError,\n    )\n\n    return ffi.buffer(plaintext, _mlen)[:]\n", "src/nacl/bindings/crypto_generichash.py": "# Copyright 2013-2019 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import NoReturn, TypeVar\n\nfrom nacl import exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\ncrypto_generichash_BYTES: int = lib.crypto_generichash_blake2b_bytes()\ncrypto_generichash_BYTES_MIN: int = lib.crypto_generichash_blake2b_bytes_min()\ncrypto_generichash_BYTES_MAX: int = lib.crypto_generichash_blake2b_bytes_max()\ncrypto_generichash_KEYBYTES: int = lib.crypto_generichash_blake2b_keybytes()\ncrypto_generichash_KEYBYTES_MIN: int = (\n    lib.crypto_generichash_blake2b_keybytes_min()\n)\ncrypto_generichash_KEYBYTES_MAX: int = (\n    lib.crypto_generichash_blake2b_keybytes_max()\n)\ncrypto_generichash_SALTBYTES: int = lib.crypto_generichash_blake2b_saltbytes()\ncrypto_generichash_PERSONALBYTES: int = (\n    lib.crypto_generichash_blake2b_personalbytes()\n)\ncrypto_generichash_STATEBYTES: int = lib.crypto_generichash_statebytes()\n\n_OVERLONG = \"{0} length greater than {1} bytes\"\n_TOOBIG = \"{0} greater than {1}\"\n\n\ndef _checkparams(\n    digest_size: int, key: bytes, salt: bytes, person: bytes\n) -> None:\n    \"\"\"Check hash parameters\"\"\"\n    ensure(\n        isinstance(key, bytes),\n        \"Key must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(salt, bytes),\n        \"Salt must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(person, bytes),\n        \"Person must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(digest_size, int),\n        \"Digest size must be an integer number\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        digest_size <= crypto_generichash_BYTES_MAX,\n        _TOOBIG.format(\"Digest_size\", crypto_generichash_BYTES_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(key) <= crypto_generichash_KEYBYTES_MAX,\n        _OVERLONG.format(\"Key\", crypto_generichash_KEYBYTES_MAX),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(salt) <= crypto_generichash_SALTBYTES,\n        _OVERLONG.format(\"Salt\", crypto_generichash_SALTBYTES),\n        raising=exc.ValueError,\n    )\n\n    ensure(\n        len(person) <= crypto_generichash_PERSONALBYTES,\n        _OVERLONG.format(\"Person\", crypto_generichash_PERSONALBYTES),\n        raising=exc.ValueError,\n    )\n\n\ndef generichash_blake2b_salt_personal(\n    data: bytes,\n    digest_size: int = crypto_generichash_BYTES,\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n) -> bytes:\n    \"\"\"One shot hash interface\n\n    :param data: the input data to the hash function\n    :type data: bytes\n    :param digest_size: must be at most\n                        :py:data:`.crypto_generichash_BYTES_MAX`;\n                        the default digest size is\n                        :py:data:`.crypto_generichash_BYTES`\n    :type digest_size: int\n    :param key: must be at most\n                :py:data:`.crypto_generichash_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: must be at most\n                 :py:data:`.crypto_generichash_SALTBYTES` long;\n                 will be zero-padded if needed\n    :type salt: bytes\n    :param person: must be at most\n                   :py:data:`.crypto_generichash_PERSONALBYTES` long:\n                   will be zero-padded if needed\n    :type person: bytes\n    :return: digest_size long digest\n    :rtype: bytes\n    \"\"\"\n\n    _checkparams(digest_size, key, salt, person)\n\n    ensure(\n        isinstance(data, bytes),\n        \"Input data must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    digest = ffi.new(\"unsigned char[]\", digest_size)\n\n    # both _salt and _personal must be zero-padded to the correct length\n    _salt = ffi.new(\"unsigned char []\", crypto_generichash_SALTBYTES)\n    _person = ffi.new(\"unsigned char []\", crypto_generichash_PERSONALBYTES)\n\n    ffi.memmove(_salt, salt, len(salt))\n    ffi.memmove(_person, person, len(person))\n\n    rc = lib.crypto_generichash_blake2b_salt_personal(\n        digest, digest_size, data, len(data), key, len(key), _salt, _person\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return ffi.buffer(digest, digest_size)[:]\n\n\n_Blake2State = TypeVar(\"_Blake2State\", bound=\"Blake2State\")\n\n\nclass Blake2State:\n    \"\"\"\n    Python-level wrapper for the crypto_generichash_blake2b state buffer\n    \"\"\"\n\n    __slots__ = [\"_statebuf\", \"digest_size\"]\n\n    def __init__(self, digest_size: int):\n        self._statebuf = ffi.new(\n            \"unsigned char[]\", crypto_generichash_STATEBYTES\n        )\n        self.digest_size = digest_size\n\n    def __reduce__(self) -> NoReturn:\n        \"\"\"\n        Raise the same exception as hashlib's blake implementation\n        on copy.copy()\n        \"\"\"\n        raise TypeError(\n            \"can't pickle {} objects\".format(self.__class__.__name__)\n        )\n\n    def copy(self: _Blake2State) -> _Blake2State:\n        _st = self.__class__(self.digest_size)\n        ffi.memmove(\n            _st._statebuf, self._statebuf, crypto_generichash_STATEBYTES\n        )\n        return _st\n\n\ndef generichash_blake2b_init(\n    key: bytes = b\"\",\n    salt: bytes = b\"\",\n    person: bytes = b\"\",\n    digest_size: int = crypto_generichash_BYTES,\n) -> Blake2State:\n    \"\"\"\n    Create a new initialized blake2b hash state\n\n    :param key: must be at most\n                :py:data:`.crypto_generichash_KEYBYTES_MAX` long\n    :type key: bytes\n    :param salt: must be at most\n                 :py:data:`.crypto_generichash_SALTBYTES` long;\n                 will be zero-padded if needed\n    :type salt: bytes\n    :param person: must be at most\n                   :py:data:`.crypto_generichash_PERSONALBYTES` long:\n                   will be zero-padded if needed\n    :type person: bytes\n    :param digest_size: must be at most\n                        :py:data:`.crypto_generichash_BYTES_MAX`;\n                        the default digest size is\n                        :py:data:`.crypto_generichash_BYTES`\n    :type digest_size: int\n    :return: a initialized :py:class:`.Blake2State`\n    :rtype: object\n    \"\"\"\n\n    _checkparams(digest_size, key, salt, person)\n\n    state = Blake2State(digest_size)\n\n    # both _salt and _personal must be zero-padded to the correct length\n    _salt = ffi.new(\"unsigned char []\", crypto_generichash_SALTBYTES)\n    _person = ffi.new(\"unsigned char []\", crypto_generichash_PERSONALBYTES)\n\n    ffi.memmove(_salt, salt, len(salt))\n    ffi.memmove(_person, person, len(person))\n\n    rc = lib.crypto_generichash_blake2b_init_salt_personal(\n        state._statebuf, key, len(key), digest_size, _salt, _person\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n    return state\n\n\ndef generichash_blake2b_update(state: Blake2State, data: bytes) -> None:\n    \"\"\"Update the blake2b hash state\n\n    :param state: a initialized Blake2bState object as returned from\n                     :py:func:`.crypto_generichash_blake2b_init`\n    :type state: :py:class:`.Blake2State`\n    :param data:\n    :type data: bytes\n    \"\"\"\n\n    ensure(\n        isinstance(state, Blake2State),\n        \"State must be a Blake2State object\",\n        raising=exc.TypeError,\n    )\n\n    ensure(\n        isinstance(data, bytes),\n        \"Input data must be a bytes sequence\",\n        raising=exc.TypeError,\n    )\n\n    rc = lib.crypto_generichash_blake2b_update(\n        state._statebuf, data, len(data)\n    )\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n\n\ndef generichash_blake2b_final(state: Blake2State) -> bytes:\n    \"\"\"Finalize the blake2b hash state and return the digest.\n\n    :param state: a initialized Blake2bState object as returned from\n                     :py:func:`.crypto_generichash_blake2b_init`\n    :type state: :py:class:`.Blake2State`\n    :return: the blake2 digest of the passed-in data stream\n    :rtype: bytes\n    \"\"\"\n\n    ensure(\n        isinstance(state, Blake2State),\n        \"State must be a Blake2State object\",\n        raising=exc.TypeError,\n    )\n\n    _digest = ffi.new(\"unsigned char[]\", crypto_generichash_BYTES_MAX)\n    rc = lib.crypto_generichash_blake2b_final(\n        state._statebuf, _digest, state.digest_size\n    )\n\n    ensure(rc == 0, \"Unexpected failure\", raising=exc.RuntimeError)\n    return ffi.buffer(_digest, state.digest_size)[:]\n", "src/nacl/bindings/crypto_shorthash.py": "# Copyright 2016 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport nacl.exceptions as exc\nfrom nacl._sodium import ffi, lib\nfrom nacl.exceptions import ensure\n\n\nhas_crypto_shorthash_siphashx24 = bool(\n    lib.PYNACL_HAS_CRYPTO_SHORTHASH_SIPHASHX24\n)\n\nBYTES: int = lib.crypto_shorthash_siphash24_bytes()\nKEYBYTES: int = lib.crypto_shorthash_siphash24_keybytes()\n\nXBYTES = 0\nXKEYBYTES = 0\n\nif has_crypto_shorthash_siphashx24:\n    XBYTES = lib.crypto_shorthash_siphashx24_bytes()\n    XKEYBYTES = lib.crypto_shorthash_siphashx24_keybytes()\n\n\ndef crypto_shorthash_siphash24(data: bytes, key: bytes) -> bytes:\n    \"\"\"Compute a fast, cryptographic quality, keyed hash of the input data\n\n    :param data:\n    :type data: bytes\n    :param key: len(key) must be equal to\n                :py:data:`.KEYBYTES` (16)\n    :type key: bytes\n    \"\"\"\n    if len(key) != KEYBYTES:\n        raise exc.ValueError(\n            \"Key length must be exactly {} bytes\".format(KEYBYTES)\n        )\n    digest = ffi.new(\"unsigned char[]\", BYTES)\n    rc = lib.crypto_shorthash_siphash24(digest, data, len(data), key)\n\n    ensure(rc == 0, raising=exc.RuntimeError)\n    return ffi.buffer(digest, BYTES)[:]\n\n\ndef crypto_shorthash_siphashx24(data: bytes, key: bytes) -> bytes:\n    \"\"\"Compute a fast, cryptographic quality, keyed hash of the input data\n\n    :param data:\n    :type data: bytes\n    :param key: len(key) must be equal to\n                :py:data:`.XKEYBYTES` (16)\n    :type key: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n    \"\"\"\n    ensure(\n        has_crypto_shorthash_siphashx24,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    if len(key) != XKEYBYTES:\n        raise exc.ValueError(\n            \"Key length must be exactly {} bytes\".format(XKEYBYTES)\n        )\n    digest = ffi.new(\"unsigned char[]\", XBYTES)\n    rc = lib.crypto_shorthash_siphashx24(digest, data, len(data), key)\n\n    ensure(rc == 0, raising=exc.RuntimeError)\n    return ffi.buffer(digest, XBYTES)[:]\n", "src/nacl/pwhash/argon2i.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\nimport nacl.encoding\n\nfrom . import _argon2\n\nALG = _argon2.ALG_ARGON2I13\nSTRPREFIX = nacl.bindings.crypto_pwhash_argon2i_STRPREFIX\n\nSALTBYTES = _argon2.SALTBYTES\n\nPASSWD_MIN = _argon2.PASSWD_MIN\nPASSWD_MAX = _argon2.PASSWD_MAX\n\nPWHASH_SIZE = _argon2.PWHASH_SIZE\n\nBYTES_MIN = _argon2.BYTES_MIN\nBYTES_MAX = _argon2.BYTES_MAX\n\nverify = _argon2.verify\n\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MAX\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MIN\n\nOPSLIMIT_INTERACTIVE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE\nMEMLIMIT_INTERACTIVE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE\nOPSLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE\n\nOPSLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2i_OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2i_MEMLIMIT_MODERATE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the argon2i\n    memory-hard construct.\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n\n    as a guidance for correct settings.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_alg(\n            size, password, salt, opslimit, memlimit, ALG\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    argon2i construct and returning an ascii string that has all\n    the needed info to check against a future password\n\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_alg(\n        password, opslimit, memlimit, ALG\n    )\n", "src/nacl/pwhash/argon2id.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\nimport nacl.encoding\n\nfrom . import _argon2\n\nALG = _argon2.ALG_ARGON2ID13\nSTRPREFIX = nacl.bindings.crypto_pwhash_argon2id_STRPREFIX\n\nSALTBYTES = _argon2.SALTBYTES\n\nPASSWD_MIN = _argon2.PASSWD_MIN\nPASSWD_MAX = _argon2.PASSWD_MAX\n\nPWHASH_SIZE = _argon2.PWHASH_SIZE\n\nBYTES_MIN = _argon2.BYTES_MIN\nBYTES_MAX = _argon2.BYTES_MAX\n\nverify = _argon2.verify\n\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MIN\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MAX\n\nOPSLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE\n)\nMEMLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE\n)\nOPSLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE\n\nOPSLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2id_OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = nacl.bindings.crypto_pwhash_argon2id_MEMLIMIT_MODERATE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the argon2id\n    memory-hard construct.\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n\n    as a guidance for correct settings.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_alg(\n            size, password, salt, opslimit, memlimit, ALG\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    argon2id construct and returning an ascii string that has all\n    the needed info to check against a future password\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_alg(\n        password, opslimit, memlimit, ALG\n    )\n", "src/nacl/pwhash/scrypt.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import cast\n\nimport nacl.bindings\nimport nacl.encoding\nfrom nacl import exceptions as exc\nfrom nacl.exceptions import ensure\n\n_strbytes_plus_one = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRBYTES\n\nAVAILABLE = nacl.bindings.has_crypto_pwhash_scryptsalsa208sha256\n\nSTRPREFIX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRPREFIX\n\nSALTBYTES = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_SALTBYTES\n\nPASSWD_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN\nPASSWD_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_PASSWD_MAX\n\nPWHASH_SIZE = _strbytes_plus_one - 1\n\nBYTES_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN\nBYTES_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX\n\nMEMLIMIT_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN\nMEMLIMIT_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX\nOPSLIMIT_MIN = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN\nOPSLIMIT_MAX = nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX\n\nOPSLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE\n)\nMEMLIMIT_INTERACTIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE\n)\nOPSLIMIT_SENSITIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE\n)\nMEMLIMIT_SENSITIVE = (\n    nacl.bindings.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE\n)\n\nOPSLIMIT_MODERATE = 8 * OPSLIMIT_INTERACTIVE\nMEMLIMIT_MODERATE = 8 * MEMLIMIT_INTERACTIVE\n\n\ndef kdf(\n    size: int,\n    password: bytes,\n    salt: bytes,\n    opslimit: int = OPSLIMIT_SENSITIVE,\n    memlimit: int = MEMLIMIT_SENSITIVE,\n    encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder,\n) -> bytes:\n    \"\"\"\n    Derive a ``size`` bytes long key from a caller-supplied\n    ``password`` and ``salt`` pair using the scryptsalsa208sha256\n    memory-hard construct.\n\n\n    the enclosing module provides the constants\n\n        - :py:const:`.OPSLIMIT_INTERACTIVE`\n        - :py:const:`.MEMLIMIT_INTERACTIVE`\n        - :py:const:`.OPSLIMIT_SENSITIVE`\n        - :py:const:`.MEMLIMIT_SENSITIVE`\n        - :py:const:`.OPSLIMIT_MODERATE`\n        - :py:const:`.MEMLIMIT_MODERATE`\n\n    as a guidance for correct settings respectively for the\n    interactive login and the long term key protecting sensitive data\n    use cases.\n\n    :param size: derived key size, must be between\n                 :py:const:`.BYTES_MIN` and\n                 :py:const:`.BYTES_MAX`\n    :type size: int\n    :param password: password used to seed the key derivation procedure;\n                     it length must be between\n                     :py:const:`.PASSWD_MIN` and\n                     :py:const:`.PASSWD_MAX`\n    :type password: bytes\n    :param salt: **RANDOM** salt used in the key derivation procedure;\n                 its length must be exactly :py:const:`.SALTBYTES`\n    :type salt: bytes\n    :param opslimit: the time component (operation count)\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.OPSLIMIT_MIN` and\n                     :py:const:`.OPSLIMIT_MAX`\n    :type opslimit: int\n    :param memlimit: the memory occupation component\n                     of the key derivation procedure's computational cost;\n                     it must be between\n                     :py:const:`.MEMLIMIT_MIN` and\n                     :py:const:`.MEMLIMIT_MAX`\n    :type memlimit: int\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(salt) == SALTBYTES,\n        \"The salt must be exactly %s, not %s bytes long\"\n        % (SALTBYTES, len(salt)),\n        raising=exc.ValueError,\n    )\n\n    n_log2, r, p = nacl.bindings.nacl_bindings_pick_scrypt_params(\n        opslimit, memlimit\n    )\n    maxmem = memlimit + (2**16)\n\n    return encoder.encode(\n        nacl.bindings.crypto_pwhash_scryptsalsa208sha256_ll(\n            password,\n            salt,\n            # Cast safety: n_log2 is a positive integer, and so 2 ** n_log2 is also\n            # a positive integer. Mypy+typeshed can't deduce this, because there's no\n            # way to for them to know that n_log2: int is positive.\n            cast(int, 2**n_log2),\n            r,\n            p,\n            maxmem=maxmem,\n            dklen=size,\n        )\n    )\n\n\ndef str(\n    password: bytes,\n    opslimit: int = OPSLIMIT_INTERACTIVE,\n    memlimit: int = MEMLIMIT_INTERACTIVE,\n) -> bytes:\n    \"\"\"\n    Hashes a password with a random salt, using the memory-hard\n    scryptsalsa208sha256 construct and returning an ascii string\n    that has all the needed info to check against a future password\n\n    The default settings for opslimit and memlimit are those deemed\n    correct for the interactive user login case.\n\n    :param bytes password:\n    :param int opslimit:\n    :param int memlimit:\n    :rtype: bytes\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_str(\n        password, opslimit, memlimit\n    )\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes the output of scryptsalsa208sha256 and compares it against\n    a user provided password to see if they are the same\n\n    :param password_hash: bytes\n    :param password: bytes\n    :rtype: boolean\n    :raises nacl.exceptions.UnavailableError: If called when using a\n        minimal build of libsodium.\n\n    .. versionadded:: 1.2\n    \"\"\"\n    ensure(\n        AVAILABLE,\n        \"Not available in minimal build\",\n        raising=exc.UnavailableError,\n    )\n\n    ensure(\n        len(password_hash) == PWHASH_SIZE,\n        \"The password hash must be exactly %s bytes long\"\n        % nacl.bindings.crypto_pwhash_scryptsalsa208sha256_STRBYTES,\n        raising=exc.ValueError,\n    )\n\n    return nacl.bindings.crypto_pwhash_scryptsalsa208sha256_str_verify(\n        password_hash, password\n    )\n", "src/nacl/pwhash/_argon2.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport nacl.bindings\n\n_argon2_strbytes_plus_one = nacl.bindings.crypto_pwhash_STRBYTES\n\nPWHASH_SIZE = _argon2_strbytes_plus_one - 1\nSALTBYTES = nacl.bindings.crypto_pwhash_SALTBYTES\n\nPASSWD_MIN = nacl.bindings.crypto_pwhash_PASSWD_MIN\nPASSWD_MAX = nacl.bindings.crypto_pwhash_PASSWD_MAX\n\nPWHASH_SIZE = _argon2_strbytes_plus_one - 1\n\nBYTES_MAX = nacl.bindings.crypto_pwhash_BYTES_MAX\nBYTES_MIN = nacl.bindings.crypto_pwhash_BYTES_MIN\n\nALG_ARGON2I13 = nacl.bindings.crypto_pwhash_ALG_ARGON2I13\nALG_ARGON2ID13 = nacl.bindings.crypto_pwhash_ALG_ARGON2ID13\nALG_ARGON2_DEFAULT = nacl.bindings.crypto_pwhash_ALG_DEFAULT\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes a modular crypt encoded argon2i or argon2id stored password hash\n    and checks if the user provided password will hash to the same string\n    when using the stored parameters\n\n    :param password_hash: password hash serialized in modular crypt() format\n    :type password_hash: bytes\n    :param password: user provided password\n    :type password: bytes\n    :rtype: boolean\n\n    .. versionadded:: 1.2\n    \"\"\"\n    return nacl.bindings.crypto_pwhash_str_verify(password_hash, password)\n", "src/nacl/pwhash/__init__.py": "# Copyright 2017 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom nacl.exceptions import CryptPrefixError\n\nfrom . import _argon2, argon2i, argon2id, scrypt\n\nSTRPREFIX = argon2id.STRPREFIX\n\nPWHASH_SIZE = argon2id.PWHASH_SIZE\n\nassert _argon2.ALG_ARGON2_DEFAULT == _argon2.ALG_ARGON2ID13\n# since version 1.0.15 of libsodium\n\nPASSWD_MIN = argon2id.PASSWD_MIN\nPASSWD_MAX = argon2id.PASSWD_MAX\nMEMLIMIT_MAX = argon2id.MEMLIMIT_MAX\nMEMLIMIT_MIN = argon2id.MEMLIMIT_MIN\nOPSLIMIT_MAX = argon2id.OPSLIMIT_MAX\nOPSLIMIT_MIN = argon2id.OPSLIMIT_MIN\nOPSLIMIT_INTERACTIVE = argon2id.OPSLIMIT_INTERACTIVE\nMEMLIMIT_INTERACTIVE = argon2id.MEMLIMIT_INTERACTIVE\nOPSLIMIT_MODERATE = argon2id.OPSLIMIT_MODERATE\nMEMLIMIT_MODERATE = argon2id.MEMLIMIT_MODERATE\nOPSLIMIT_SENSITIVE = argon2id.OPSLIMIT_SENSITIVE\nMEMLIMIT_SENSITIVE = argon2id.MEMLIMIT_SENSITIVE\n\nstr = argon2id.str\n\nassert argon2i.ALG != argon2id.ALG\n\nSCRYPT_SALTBYTES = scrypt.SALTBYTES\nSCRYPT_PWHASH_SIZE = scrypt.PWHASH_SIZE\nSCRYPT_OPSLIMIT_INTERACTIVE = scrypt.OPSLIMIT_INTERACTIVE\nSCRYPT_MEMLIMIT_INTERACTIVE = scrypt.MEMLIMIT_INTERACTIVE\nSCRYPT_OPSLIMIT_SENSITIVE = scrypt.OPSLIMIT_SENSITIVE\nSCRYPT_MEMLIMIT_SENSITIVE = scrypt.MEMLIMIT_SENSITIVE\n\n\nkdf_scryptsalsa208sha256 = scrypt.kdf\nscryptsalsa208sha256_str = scrypt.str\nverify_scryptsalsa208sha256 = scrypt.verify\n\n\ndef verify(password_hash: bytes, password: bytes) -> bool:\n    \"\"\"\n    Takes a modular crypt encoded stored password hash derived using one\n    of the algorithms supported by `libsodium` and checks if the user provided\n    password will hash to the same string when using the parameters saved\n    in the stored hash\n    \"\"\"\n    if password_hash.startswith(argon2id.STRPREFIX):\n        return argon2id.verify(password_hash, password)\n    elif password_hash.startswith(argon2i.STRPREFIX):\n        return argon2id.verify(password_hash, password)\n    elif scrypt.AVAILABLE and password_hash.startswith(scrypt.STRPREFIX):\n        return scrypt.verify(password_hash, password)\n    else:\n        raise (\n            CryptPrefixError(\n                \"given password_hash is not in a supported format\"\n            )\n        )\n", "src/bindings/build.py": "# Copyright 2013 Donald Stufft and individual contributors\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport glob\nimport os.path\nimport sys\n\nfrom cffi import FFI\n\n\n__all__ = [\"ffi\"]\n\n\nHEADERS = glob.glob(\n    os.path.join(os.path.abspath(os.path.dirname(__file__)), \"*.h\")\n)\n\nMINIMAL_HEADERS = glob.glob(\n    os.path.join(os.path.abspath(os.path.dirname(__file__)), \"minimal\", \"*.h\")\n)\n\n\n# Build our FFI instance\nffi = FFI()\n\nfor header in HEADERS:\n    with open(header) as hfile:\n        ffi.cdef(hfile.read())\n\nsource = []\n\n# SODIUM_STATIC controls the visibility of symbols in the headers. (see\n# export.h in the libsodium source tree). If you do not set SODIUM_STATIC\n# when linking against the static library in Windows then the compile will\n# fail with no symbols found.\nif os.getenv(\"PYNACL_SODIUM_STATIC\") is not None:\n    source.append(\"#define SODIUM_STATIC\")\n\nsource.append(\"#include <sodium.h>\")\n\nfor header in MINIMAL_HEADERS:\n    with open(header) as hfile:\n        source.append(hfile.read())\n\nif sys.platform == \"win32\":\n    libraries = [\"libsodium\"]\nelse:\n    libraries = [\"sodium\"]\n\n# Set our source so that we can actually build our bindings to sodium.\nffi.set_source(\"_sodium\", \"\\n\".join(source), libraries=libraries)\n"}