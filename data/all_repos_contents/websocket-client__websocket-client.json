{"setup.py": "from setuptools import find_packages, setup\n\n\"\"\"\nsetup.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nVERSION = \"1.8.0\"\n\ninstall_requires = []\ntests_require = []\n\nsetup(\n    name=\"websocket-client\",\n    version=VERSION,\n    description=\"WebSocket client for Python with low level API options\",\n    long_description=open(\"README.md\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"liris\",\n    author_email=\"liris.pp@gmail.com\",\n    maintainer=\"engn33r\",\n    maintainer_email=\"websocket.client@proton.me\",\n    license=\"Apache-2.0\",\n    url=\"https://github.com/websocket-client/websocket-client.git\",\n    download_url=\"https://github.com/websocket-client/websocket-client/releases\",\n    python_requires=\">=3.8\",\n    extras_require={\n        \"test\": [\"websockets\"],\n        \"optional\": [\"python-socks\", \"wsaccel\"],\n        \"docs\": [\"Sphinx >= 6.0\", \"sphinx_rtd_theme >= 1.1.0\", \"myst-parser >= 2.0.0\"],\n    },\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Topic :: Internet\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Intended Audience :: Developers\",\n    ],\n    project_urls={\n        \"Documentation\": \"https://websocket-client.readthedocs.io/\",\n        \"Source\": \"https://github.com/websocket-client/websocket-client/\",\n    },\n    keywords=\"websockets client\",\n    entry_points={\n        \"console_scripts\": [\n            \"wsdump=websocket._wsdump:main\",\n        ],\n    },\n    install_requires=install_requires,\n    packages=find_packages(),\n    package_data={\"websocket.tests\": [\"data/*.txt\"]},\n    tests_require=tests_require,\n    test_suite=\"websocket.tests\",\n)\n", "websocket/_http.py": "\"\"\"\n_http.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nimport errno\nimport os\nimport socket\nfrom base64 import encodebytes as base64encode\n\nfrom ._exceptions import (\n    WebSocketAddressException,\n    WebSocketException,\n    WebSocketProxyException,\n)\nfrom ._logging import debug, dump, trace\nfrom ._socket import DEFAULT_SOCKET_OPTION, recv_line, send\nfrom ._ssl_compat import HAVE_SSL, ssl\nfrom ._url import get_proxy_info, parse_url\n\n__all__ = [\"proxy_info\", \"connect\", \"read_headers\"]\n\ntry:\n    from python_socks._errors import *\n    from python_socks._types import ProxyType\n    from python_socks.sync import Proxy\n\n    HAVE_PYTHON_SOCKS = True\nexcept:\n    HAVE_PYTHON_SOCKS = False\n\n    class ProxyError(Exception):\n        pass\n\n    class ProxyTimeoutError(Exception):\n        pass\n\n    class ProxyConnectionError(Exception):\n        pass\n\n\nclass proxy_info:\n    def __init__(self, **options):\n        self.proxy_host = options.get(\"http_proxy_host\", None)\n        if self.proxy_host:\n            self.proxy_port = options.get(\"http_proxy_port\", 0)\n            self.auth = options.get(\"http_proxy_auth\", None)\n            self.no_proxy = options.get(\"http_no_proxy\", None)\n            self.proxy_protocol = options.get(\"proxy_type\", \"http\")\n            # Note: If timeout not specified, default python-socks timeout is 60 seconds\n            self.proxy_timeout = options.get(\"http_proxy_timeout\", None)\n            if self.proxy_protocol not in [\n                \"http\",\n                \"socks4\",\n                \"socks4a\",\n                \"socks5\",\n                \"socks5h\",\n            ]:\n                raise ProxyError(\n                    \"Only http, socks4, socks5 proxy protocols are supported\"\n                )\n        else:\n            self.proxy_port = 0\n            self.auth = None\n            self.no_proxy = None\n            self.proxy_protocol = \"http\"\n\n\ndef _start_proxied_socket(url: str, options, proxy) -> tuple:\n    if not HAVE_PYTHON_SOCKS:\n        raise WebSocketException(\n            \"Python Socks is needed for SOCKS proxying but is not available\"\n        )\n\n    hostname, port, resource, is_secure = parse_url(url)\n\n    if proxy.proxy_protocol == \"socks4\":\n        rdns = False\n        proxy_type = ProxyType.SOCKS4\n    # socks4a sends DNS through proxy\n    elif proxy.proxy_protocol == \"socks4a\":\n        rdns = True\n        proxy_type = ProxyType.SOCKS4\n    elif proxy.proxy_protocol == \"socks5\":\n        rdns = False\n        proxy_type = ProxyType.SOCKS5\n    # socks5h sends DNS through proxy\n    elif proxy.proxy_protocol == \"socks5h\":\n        rdns = True\n        proxy_type = ProxyType.SOCKS5\n\n    ws_proxy = Proxy.create(\n        proxy_type=proxy_type,\n        host=proxy.proxy_host,\n        port=int(proxy.proxy_port),\n        username=proxy.auth[0] if proxy.auth else None,\n        password=proxy.auth[1] if proxy.auth else None,\n        rdns=rdns,\n    )\n\n    sock = ws_proxy.connect(hostname, port, timeout=proxy.proxy_timeout)\n\n    if is_secure:\n        if HAVE_SSL:\n            sock = _ssl_socket(sock, options.sslopt, hostname)\n        else:\n            raise WebSocketException(\"SSL not available.\")\n\n    return sock, (hostname, port, resource)\n\n\ndef connect(url: str, options, proxy, socket):\n    # Use _start_proxied_socket() only for socks4 or socks5 proxy\n    # Use _tunnel() for http proxy\n    # TODO: Use python-socks for http protocol also, to standardize flow\n    if proxy.proxy_host and not socket and proxy.proxy_protocol != \"http\":\n        return _start_proxied_socket(url, options, proxy)\n\n    hostname, port_from_url, resource, is_secure = parse_url(url)\n\n    if socket:\n        return socket, (hostname, port_from_url, resource)\n\n    addrinfo_list, need_tunnel, auth = _get_addrinfo_list(\n        hostname, port_from_url, is_secure, proxy\n    )\n    if not addrinfo_list:\n        raise WebSocketException(f\"Host not found.: {hostname}:{port_from_url}\")\n\n    sock = None\n    try:\n        sock = _open_socket(addrinfo_list, options.sockopt, options.timeout)\n        if need_tunnel:\n            sock = _tunnel(sock, hostname, port_from_url, auth)\n\n        if is_secure:\n            if HAVE_SSL:\n                sock = _ssl_socket(sock, options.sslopt, hostname)\n            else:\n                raise WebSocketException(\"SSL not available.\")\n\n        return sock, (hostname, port_from_url, resource)\n    except:\n        if sock:\n            sock.close()\n        raise\n\n\ndef _get_addrinfo_list(hostname, port: int, is_secure: bool, proxy) -> tuple:\n    phost, pport, pauth = get_proxy_info(\n        hostname,\n        is_secure,\n        proxy.proxy_host,\n        proxy.proxy_port,\n        proxy.auth,\n        proxy.no_proxy,\n    )\n    try:\n        # when running on windows 10, getaddrinfo without socktype returns a socktype 0.\n        # This generates an error exception: `_on_error: exception Socket type must be stream or datagram, not 0`\n        # or `OSError: [Errno 22] Invalid argument` when creating socket. Force the socket type to SOCK_STREAM.\n        if not phost:\n            addrinfo_list = socket.getaddrinfo(\n                hostname, port, 0, socket.SOCK_STREAM, socket.SOL_TCP\n            )\n            return addrinfo_list, False, None\n        else:\n            pport = pport and pport or 80\n            # when running on windows 10, the getaddrinfo used above\n            # returns a socktype 0. This generates an error exception:\n            # _on_error: exception Socket type must be stream or datagram, not 0\n            # Force the socket type to SOCK_STREAM\n            addrinfo_list = socket.getaddrinfo(\n                phost, pport, 0, socket.SOCK_STREAM, socket.SOL_TCP\n            )\n            return addrinfo_list, True, pauth\n    except socket.gaierror as e:\n        raise WebSocketAddressException(e)\n\n\ndef _open_socket(addrinfo_list, sockopt, timeout):\n    err = None\n    for addrinfo in addrinfo_list:\n        family, socktype, proto = addrinfo[:3]\n        sock = socket.socket(family, socktype, proto)\n        sock.settimeout(timeout)\n        for opts in DEFAULT_SOCKET_OPTION:\n            sock.setsockopt(*opts)\n        for opts in sockopt:\n            sock.setsockopt(*opts)\n\n        address = addrinfo[4]\n        err = None\n        while not err:\n            try:\n                sock.connect(address)\n            except socket.error as error:\n                sock.close()\n                error.remote_ip = str(address[0])\n                try:\n                    eConnRefused = (\n                        errno.ECONNREFUSED,\n                        errno.WSAECONNREFUSED,\n                        errno.ENETUNREACH,\n                    )\n                except AttributeError:\n                    eConnRefused = (errno.ECONNREFUSED, errno.ENETUNREACH)\n                if error.errno not in eConnRefused:\n                    raise error\n                err = error\n                continue\n            else:\n                break\n        else:\n            continue\n        break\n    else:\n        if err:\n            raise err\n\n    return sock\n\n\ndef _wrap_sni_socket(sock: socket.socket, sslopt: dict, hostname, check_hostname):\n    context = sslopt.get(\"context\", None)\n    if not context:\n        context = ssl.SSLContext(sslopt.get(\"ssl_version\", ssl.PROTOCOL_TLS_CLIENT))\n        # Non default context need to manually enable SSLKEYLOGFILE support by setting the keylog_filename attribute.\n        # For more details see also:\n        # * https://docs.python.org/3.8/library/ssl.html?highlight=sslkeylogfile#context-creation\n        # * https://docs.python.org/3.8/library/ssl.html?highlight=sslkeylogfile#ssl.SSLContext.keylog_filename\n        context.keylog_filename = os.environ.get(\"SSLKEYLOGFILE\", None)\n\n        if sslopt.get(\"cert_reqs\", ssl.CERT_NONE) != ssl.CERT_NONE:\n            cafile = sslopt.get(\"ca_certs\", None)\n            capath = sslopt.get(\"ca_cert_path\", None)\n            if cafile or capath:\n                context.load_verify_locations(cafile=cafile, capath=capath)\n            elif hasattr(context, \"load_default_certs\"):\n                context.load_default_certs(ssl.Purpose.SERVER_AUTH)\n        if sslopt.get(\"certfile\", None):\n            context.load_cert_chain(\n                sslopt[\"certfile\"],\n                sslopt.get(\"keyfile\", None),\n                sslopt.get(\"password\", None),\n            )\n\n        # Python 3.10 switch to PROTOCOL_TLS_CLIENT defaults to \"cert_reqs = ssl.CERT_REQUIRED\" and \"check_hostname = True\"\n        # If both disabled, set check_hostname before verify_mode\n        # see https://github.com/liris/websocket-client/commit/b96a2e8fa765753e82eea531adb19716b52ca3ca#commitcomment-10803153\n        if sslopt.get(\"cert_reqs\", ssl.CERT_NONE) == ssl.CERT_NONE and not sslopt.get(\n            \"check_hostname\", False\n        ):\n            context.check_hostname = False\n            context.verify_mode = ssl.CERT_NONE\n        else:\n            context.check_hostname = sslopt.get(\"check_hostname\", True)\n            context.verify_mode = sslopt.get(\"cert_reqs\", ssl.CERT_REQUIRED)\n\n        if \"ciphers\" in sslopt:\n            context.set_ciphers(sslopt[\"ciphers\"])\n        if \"cert_chain\" in sslopt:\n            certfile, keyfile, password = sslopt[\"cert_chain\"]\n            context.load_cert_chain(certfile, keyfile, password)\n        if \"ecdh_curve\" in sslopt:\n            context.set_ecdh_curve(sslopt[\"ecdh_curve\"])\n\n    return context.wrap_socket(\n        sock,\n        do_handshake_on_connect=sslopt.get(\"do_handshake_on_connect\", True),\n        suppress_ragged_eofs=sslopt.get(\"suppress_ragged_eofs\", True),\n        server_hostname=hostname,\n    )\n\n\ndef _ssl_socket(sock: socket.socket, user_sslopt: dict, hostname):\n    sslopt: dict = {\"cert_reqs\": ssl.CERT_REQUIRED}\n    sslopt.update(user_sslopt)\n\n    cert_path = os.environ.get(\"WEBSOCKET_CLIENT_CA_BUNDLE\")\n    if (\n        cert_path\n        and os.path.isfile(cert_path)\n        and user_sslopt.get(\"ca_certs\", None) is None\n    ):\n        sslopt[\"ca_certs\"] = cert_path\n    elif (\n        cert_path\n        and os.path.isdir(cert_path)\n        and user_sslopt.get(\"ca_cert_path\", None) is None\n    ):\n        sslopt[\"ca_cert_path\"] = cert_path\n\n    if sslopt.get(\"server_hostname\", None):\n        hostname = sslopt[\"server_hostname\"]\n\n    check_hostname = sslopt.get(\"check_hostname\", True)\n    sock = _wrap_sni_socket(sock, sslopt, hostname, check_hostname)\n\n    return sock\n\n\ndef _tunnel(sock: socket.socket, host, port: int, auth) -> socket.socket:\n    debug(\"Connecting proxy...\")\n    connect_header = f\"CONNECT {host}:{port} HTTP/1.1\\r\\n\"\n    connect_header += f\"Host: {host}:{port}\\r\\n\"\n\n    # TODO: support digest auth.\n    if auth and auth[0]:\n        auth_str = auth[0]\n        if auth[1]:\n            auth_str += f\":{auth[1]}\"\n        encoded_str = base64encode(auth_str.encode()).strip().decode().replace(\"\\n\", \"\")\n        connect_header += f\"Proxy-Authorization: Basic {encoded_str}\\r\\n\"\n    connect_header += \"\\r\\n\"\n    dump(\"request header\", connect_header)\n\n    send(sock, connect_header)\n\n    try:\n        status, _, _ = read_headers(sock)\n    except Exception as e:\n        raise WebSocketProxyException(str(e))\n\n    if status != 200:\n        raise WebSocketProxyException(f\"failed CONNECT via proxy status: {status}\")\n\n    return sock\n\n\ndef read_headers(sock: socket.socket) -> tuple:\n    status = None\n    status_message = None\n    headers: dict = {}\n    trace(\"--- response header ---\")\n\n    while True:\n        line = recv_line(sock)\n        line = line.decode(\"utf-8\").strip()\n        if not line:\n            break\n        trace(line)\n        if not status:\n            status_info = line.split(\" \", 2)\n            status = int(status_info[1])\n            if len(status_info) > 2:\n                status_message = status_info[2]\n        else:\n            kv = line.split(\":\", 1)\n            if len(kv) != 2:\n                raise WebSocketException(\"Invalid header\")\n            key, value = kv\n            if key.lower() == \"set-cookie\" and headers.get(\"set-cookie\"):\n                headers[\"set-cookie\"] = headers.get(\"set-cookie\") + \"; \" + value.strip()\n            else:\n                headers[key.lower()] = value.strip()\n\n    trace(\"-----------------------\")\n\n    return status, headers, status_message\n", "websocket/_wsdump.py": "#!/usr/bin/env python3\n\n\"\"\"\nwsdump.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nimport argparse\nimport code\nimport gzip\nimport ssl\nimport sys\nimport threading\nimport time\nimport zlib\nfrom urllib.parse import urlparse\n\nimport websocket\n\ntry:\n    import readline\nexcept ImportError:\n    pass\n\n\ndef get_encoding() -> str:\n    encoding = getattr(sys.stdin, \"encoding\", \"\")\n    if not encoding:\n        return \"utf-8\"\n    else:\n        return encoding.lower()\n\n\nOPCODE_DATA = (websocket.ABNF.OPCODE_TEXT, websocket.ABNF.OPCODE_BINARY)\nENCODING = get_encoding()\n\n\nclass VAction(argparse.Action):\n    def __call__(\n        self,\n        parser: argparse.Namespace,\n        args: tuple,\n        values: str,\n        option_string: str = None,\n    ) -> None:\n        if values is None:\n            values = \"1\"\n        try:\n            values = int(values)\n        except ValueError:\n            values = values.count(\"v\") + 1\n        setattr(args, self.dest, values)\n\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"WebSocket Simple Dump Tool\")\n    parser.add_argument(\n        \"url\", metavar=\"ws_url\", help=\"websocket url. ex. ws://echo.websocket.events/\"\n    )\n    parser.add_argument(\"-p\", \"--proxy\", help=\"proxy url. ex. http://127.0.0.1:8080\")\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        default=0,\n        nargs=\"?\",\n        action=VAction,\n        dest=\"verbose\",\n        help=\"set verbose mode. If set to 1, show opcode. \"\n        \"If set to 2, enable to trace  websocket module\",\n    )\n    parser.add_argument(\n        \"-n\", \"--nocert\", action=\"store_true\", help=\"Ignore invalid SSL cert\"\n    )\n    parser.add_argument(\"-r\", \"--raw\", action=\"store_true\", help=\"raw output\")\n    parser.add_argument(\"-s\", \"--subprotocols\", nargs=\"*\", help=\"Set subprotocols\")\n    parser.add_argument(\"-o\", \"--origin\", help=\"Set origin\")\n    parser.add_argument(\n        \"--eof-wait\",\n        default=0,\n        type=int,\n        help=\"wait time(second) after 'EOF' received.\",\n    )\n    parser.add_argument(\"-t\", \"--text\", help=\"Send initial text\")\n    parser.add_argument(\n        \"--timings\", action=\"store_true\", help=\"Print timings in seconds\"\n    )\n    parser.add_argument(\"--headers\", help=\"Set custom headers. Use ',' as separator\")\n\n    return parser.parse_args()\n\n\nclass RawInput:\n    def raw_input(self, prompt: str = \"\") -> str:\n        line = input(prompt)\n\n        if ENCODING and ENCODING != \"utf-8\" and not isinstance(line, str):\n            line = line.decode(ENCODING).encode(\"utf-8\")\n        elif isinstance(line, str):\n            line = line.encode(\"utf-8\")\n\n        return line\n\n\nclass InteractiveConsole(RawInput, code.InteractiveConsole):\n    def write(self, data: str) -> None:\n        sys.stdout.write(\"\\033[2K\\033[E\")\n        # sys.stdout.write(\"\\n\")\n        sys.stdout.write(\"\\033[34m< \" + data + \"\\033[39m\")\n        sys.stdout.write(\"\\n> \")\n        sys.stdout.flush()\n\n    def read(self) -> str:\n        return self.raw_input(\"> \")\n\n\nclass NonInteractive(RawInput):\n    def write(self, data: str) -> None:\n        sys.stdout.write(data)\n        sys.stdout.write(\"\\n\")\n        sys.stdout.flush()\n\n    def read(self) -> str:\n        return self.raw_input(\"\")\n\n\ndef main() -> None:\n    start_time = time.time()\n    args = parse_args()\n    if args.verbose > 1:\n        websocket.enableTrace(True)\n    options = {}\n    if args.proxy:\n        p = urlparse(args.proxy)\n        options[\"http_proxy_host\"] = p.hostname\n        options[\"http_proxy_port\"] = p.port\n    if args.origin:\n        options[\"origin\"] = args.origin\n    if args.subprotocols:\n        options[\"subprotocols\"] = args.subprotocols\n    opts = {}\n    if args.nocert:\n        opts = {\"cert_reqs\": ssl.CERT_NONE, \"check_hostname\": False}\n    if args.headers:\n        options[\"header\"] = list(map(str.strip, args.headers.split(\",\")))\n    ws = websocket.create_connection(args.url, sslopt=opts, **options)\n    if args.raw:\n        console = NonInteractive()\n    else:\n        console = InteractiveConsole()\n        print(\"Press Ctrl+C to quit\")\n\n    def recv() -> tuple:\n        try:\n            frame = ws.recv_frame()\n        except websocket.WebSocketException:\n            return websocket.ABNF.OPCODE_CLOSE, \"\"\n        if not frame:\n            raise websocket.WebSocketException(f\"Not a valid frame {frame}\")\n        elif frame.opcode in OPCODE_DATA:\n            return frame.opcode, frame.data\n        elif frame.opcode == websocket.ABNF.OPCODE_CLOSE:\n            ws.send_close()\n            return frame.opcode, \"\"\n        elif frame.opcode == websocket.ABNF.OPCODE_PING:\n            ws.pong(frame.data)\n            return frame.opcode, frame.data\n\n        return frame.opcode, frame.data\n\n    def recv_ws() -> None:\n        while True:\n            opcode, data = recv()\n            msg = None\n            if opcode == websocket.ABNF.OPCODE_TEXT and isinstance(data, bytes):\n                data = str(data, \"utf-8\")\n            if (\n                isinstance(data, bytes) and len(data) > 2 and data[:2] == b\"\\037\\213\"\n            ):  # gzip magick\n                try:\n                    data = \"[gzip] \" + str(gzip.decompress(data), \"utf-8\")\n                except:\n                    pass\n            elif isinstance(data, bytes):\n                try:\n                    data = \"[zlib] \" + str(\n                        zlib.decompress(data, -zlib.MAX_WBITS), \"utf-8\"\n                    )\n                except:\n                    pass\n\n            if isinstance(data, bytes):\n                data = repr(data)\n\n            if args.verbose:\n                msg = f\"{websocket.ABNF.OPCODE_MAP.get(opcode)}: {data}\"\n            else:\n                msg = data\n\n            if msg is not None:\n                if args.timings:\n                    console.write(f\"{time.time() - start_time}: {msg}\")\n                else:\n                    console.write(msg)\n\n            if opcode == websocket.ABNF.OPCODE_CLOSE:\n                break\n\n    thread = threading.Thread(target=recv_ws)\n    thread.daemon = True\n    thread.start()\n\n    if args.text:\n        ws.send(args.text)\n\n    while True:\n        try:\n            message = console.read()\n            ws.send(message)\n        except KeyboardInterrupt:\n            return\n        except EOFError:\n            time.sleep(args.eof_wait)\n            return\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(e)\n", "websocket/_exceptions.py": "\"\"\"\n_exceptions.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n\nclass WebSocketException(Exception):\n    \"\"\"\n    WebSocket exception class.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketProtocolException(WebSocketException):\n    \"\"\"\n    If the WebSocket protocol is invalid, this exception will be raised.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketPayloadException(WebSocketException):\n    \"\"\"\n    If the WebSocket payload is invalid, this exception will be raised.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketConnectionClosedException(WebSocketException):\n    \"\"\"\n    If remote host closed the connection or some network error happened,\n    this exception will be raised.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketTimeoutException(WebSocketException):\n    \"\"\"\n    WebSocketTimeoutException will be raised at socket timeout during read/write data.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketProxyException(WebSocketException):\n    \"\"\"\n    WebSocketProxyException will be raised when proxy error occurred.\n    \"\"\"\n\n    pass\n\n\nclass WebSocketBadStatusException(WebSocketException):\n    \"\"\"\n    WebSocketBadStatusException will be raised when we get bad handshake status code.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        status_code: int,\n        status_message=None,\n        resp_headers=None,\n        resp_body=None,\n    ):\n        super().__init__(message)\n        self.status_code = status_code\n        self.resp_headers = resp_headers\n        self.resp_body = resp_body\n\n\nclass WebSocketAddressException(WebSocketException):\n    \"\"\"\n    If the websocket address info cannot be found, this exception will be raised.\n    \"\"\"\n\n    pass\n", "websocket/_ssl_compat.py": "\"\"\"\n_ssl_compat.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n__all__ = [\n    \"HAVE_SSL\",\n    \"ssl\",\n    \"SSLError\",\n    \"SSLEOFError\",\n    \"SSLWantReadError\",\n    \"SSLWantWriteError\",\n]\n\ntry:\n    import ssl\n    from ssl import SSLError, SSLEOFError, SSLWantReadError, SSLWantWriteError\n\n    HAVE_SSL = True\nexcept ImportError:\n    # dummy class of SSLError for environment without ssl support\n    class SSLError(Exception):\n        pass\n\n    class SSLEOFError(Exception):\n        pass\n\n    class SSLWantReadError(Exception):\n        pass\n\n    class SSLWantWriteError(Exception):\n        pass\n\n    ssl = None\n    HAVE_SSL = False\n", "websocket/_url.py": "import os\nimport socket\nimport struct\nfrom typing import Optional\nfrom urllib.parse import unquote, urlparse\nfrom ._exceptions import WebSocketProxyException\n\n\"\"\"\n_url.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n__all__ = [\"parse_url\", \"get_proxy_info\"]\n\n\ndef parse_url(url: str) -> tuple:\n    \"\"\"\n    parse url and the result is tuple of\n    (hostname, port, resource path and the flag of secure mode)\n\n    Parameters\n    ----------\n    url: str\n        url string.\n    \"\"\"\n    if \":\" not in url:\n        raise ValueError(\"url is invalid\")\n\n    scheme, url = url.split(\":\", 1)\n\n    parsed = urlparse(url, scheme=\"http\")\n    if parsed.hostname:\n        hostname = parsed.hostname\n    else:\n        raise ValueError(\"hostname is invalid\")\n    port = 0\n    if parsed.port:\n        port = parsed.port\n\n    is_secure = False\n    if scheme == \"ws\":\n        if not port:\n            port = 80\n    elif scheme == \"wss\":\n        is_secure = True\n        if not port:\n            port = 443\n    else:\n        raise ValueError(\"scheme %s is invalid\" % scheme)\n\n    if parsed.path:\n        resource = parsed.path\n    else:\n        resource = \"/\"\n\n    if parsed.query:\n        resource += f\"?{parsed.query}\"\n\n    return hostname, port, resource, is_secure\n\n\nDEFAULT_NO_PROXY_HOST = [\"localhost\", \"127.0.0.1\"]\n\n\ndef _is_ip_address(addr: str) -> bool:\n    try:\n        socket.inet_aton(addr)\n    except socket.error:\n        return False\n    else:\n        return True\n\n\ndef _is_subnet_address(hostname: str) -> bool:\n    try:\n        addr, netmask = hostname.split(\"/\")\n        return _is_ip_address(addr) and 0 <= int(netmask) < 32\n    except ValueError:\n        return False\n\n\ndef _is_address_in_network(ip: str, net: str) -> bool:\n    ipaddr: int = struct.unpack(\"!I\", socket.inet_aton(ip))[0]\n    netaddr, netmask = net.split(\"/\")\n    netaddr: int = struct.unpack(\"!I\", socket.inet_aton(netaddr))[0]\n\n    netmask = (0xFFFFFFFF << (32 - int(netmask))) & 0xFFFFFFFF\n    return ipaddr & netmask == netaddr\n\n\ndef _is_no_proxy_host(hostname: str, no_proxy: Optional[list]) -> bool:\n    if not no_proxy:\n        if v := os.environ.get(\"no_proxy\", os.environ.get(\"NO_PROXY\", \"\")).replace(\n            \" \", \"\"\n        ):\n            no_proxy = v.split(\",\")\n    if not no_proxy:\n        no_proxy = DEFAULT_NO_PROXY_HOST\n\n    if \"*\" in no_proxy:\n        return True\n    if hostname in no_proxy:\n        return True\n    if _is_ip_address(hostname):\n        return any(\n            [\n                _is_address_in_network(hostname, subnet)\n                for subnet in no_proxy\n                if _is_subnet_address(subnet)\n            ]\n        )\n    for domain in [domain for domain in no_proxy if domain.startswith(\".\")]:\n        if hostname.endswith(domain):\n            return True\n    return False\n\n\ndef get_proxy_info(\n    hostname: str,\n    is_secure: bool,\n    proxy_host: Optional[str] = None,\n    proxy_port: int = 0,\n    proxy_auth: Optional[tuple] = None,\n    no_proxy: Optional[list] = None,\n    proxy_type: str = \"http\",\n) -> tuple:\n    \"\"\"\n    Try to retrieve proxy host and port from environment\n    if not provided in options.\n    Result is (proxy_host, proxy_port, proxy_auth).\n    proxy_auth is tuple of username and password\n    of proxy authentication information.\n\n    Parameters\n    ----------\n    hostname: str\n        Websocket server name.\n    is_secure: bool\n        Is the connection secure? (wss) looks for \"https_proxy\" in env\n        instead of \"http_proxy\"\n    proxy_host: str\n        http proxy host name.\n    proxy_port: str or int\n        http proxy port.\n    no_proxy: list\n        Whitelisted host names that don't use the proxy.\n    proxy_auth: tuple\n        HTTP proxy auth information. Tuple of username and password. Default is None.\n    proxy_type: str\n        Specify the proxy protocol (http, socks4, socks4a, socks5, socks5h). Default is \"http\".\n        Use socks4a or socks5h if you want to send DNS requests through the proxy.\n    \"\"\"\n    if _is_no_proxy_host(hostname, no_proxy):\n        return None, 0, None\n\n    if proxy_host:\n        if not proxy_port:\n            raise WebSocketProxyException(\"Cannot use port 0 when proxy_host specified\")\n        port = proxy_port\n        auth = proxy_auth\n        return proxy_host, port, auth\n\n    env_key = \"https_proxy\" if is_secure else \"http_proxy\"\n    value = os.environ.get(env_key, os.environ.get(env_key.upper(), \"\")).replace(\n        \" \", \"\"\n    )\n    if value:\n        proxy = urlparse(value)\n        auth = (\n            (unquote(proxy.username), unquote(proxy.password))\n            if proxy.username\n            else None\n        )\n        return proxy.hostname, proxy.port, auth\n\n    return None, 0, None\n", "websocket/_abnf.py": "import array\nimport os\nimport struct\nimport sys\nfrom threading import Lock\nfrom typing import Callable, Optional, Union\n\nfrom ._exceptions import WebSocketPayloadException, WebSocketProtocolException\nfrom ._utils import validate_utf8\n\n\"\"\"\n_abnf.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\ntry:\n    # If wsaccel is available, use compiled routines to mask data.\n    # wsaccel only provides around a 10% speed boost compared\n    # to the websocket-client _mask() implementation.\n    # Note that wsaccel is unmaintained.\n    from wsaccel.xormask import XorMaskerSimple\n\n    def _mask(mask_value: array.array, data_value: array.array) -> bytes:\n        mask_result: bytes = XorMaskerSimple(mask_value).process(data_value)\n        return mask_result\n\nexcept ImportError:\n    # wsaccel is not available, use websocket-client _mask()\n    native_byteorder = sys.byteorder\n\n    def _mask(mask_value: array.array, data_value: array.array) -> bytes:\n        datalen = len(data_value)\n        int_data_value = int.from_bytes(data_value, native_byteorder)\n        int_mask_value = int.from_bytes(\n            mask_value * (datalen // 4) + mask_value[: datalen % 4], native_byteorder\n        )\n        return (int_data_value ^ int_mask_value).to_bytes(datalen, native_byteorder)\n\n\n__all__ = [\n    \"ABNF\",\n    \"continuous_frame\",\n    \"frame_buffer\",\n    \"STATUS_NORMAL\",\n    \"STATUS_GOING_AWAY\",\n    \"STATUS_PROTOCOL_ERROR\",\n    \"STATUS_UNSUPPORTED_DATA_TYPE\",\n    \"STATUS_STATUS_NOT_AVAILABLE\",\n    \"STATUS_ABNORMAL_CLOSED\",\n    \"STATUS_INVALID_PAYLOAD\",\n    \"STATUS_POLICY_VIOLATION\",\n    \"STATUS_MESSAGE_TOO_BIG\",\n    \"STATUS_INVALID_EXTENSION\",\n    \"STATUS_UNEXPECTED_CONDITION\",\n    \"STATUS_BAD_GATEWAY\",\n    \"STATUS_TLS_HANDSHAKE_ERROR\",\n]\n\n# closing frame status codes.\nSTATUS_NORMAL = 1000\nSTATUS_GOING_AWAY = 1001\nSTATUS_PROTOCOL_ERROR = 1002\nSTATUS_UNSUPPORTED_DATA_TYPE = 1003\nSTATUS_STATUS_NOT_AVAILABLE = 1005\nSTATUS_ABNORMAL_CLOSED = 1006\nSTATUS_INVALID_PAYLOAD = 1007\nSTATUS_POLICY_VIOLATION = 1008\nSTATUS_MESSAGE_TOO_BIG = 1009\nSTATUS_INVALID_EXTENSION = 1010\nSTATUS_UNEXPECTED_CONDITION = 1011\nSTATUS_SERVICE_RESTART = 1012\nSTATUS_TRY_AGAIN_LATER = 1013\nSTATUS_BAD_GATEWAY = 1014\nSTATUS_TLS_HANDSHAKE_ERROR = 1015\n\nVALID_CLOSE_STATUS = (\n    STATUS_NORMAL,\n    STATUS_GOING_AWAY,\n    STATUS_PROTOCOL_ERROR,\n    STATUS_UNSUPPORTED_DATA_TYPE,\n    STATUS_INVALID_PAYLOAD,\n    STATUS_POLICY_VIOLATION,\n    STATUS_MESSAGE_TOO_BIG,\n    STATUS_INVALID_EXTENSION,\n    STATUS_UNEXPECTED_CONDITION,\n    STATUS_SERVICE_RESTART,\n    STATUS_TRY_AGAIN_LATER,\n    STATUS_BAD_GATEWAY,\n)\n\n\nclass ABNF:\n    \"\"\"\n    ABNF frame class.\n    See http://tools.ietf.org/html/rfc5234\n    and http://tools.ietf.org/html/rfc6455#section-5.2\n    \"\"\"\n\n    # operation code values.\n    OPCODE_CONT = 0x0\n    OPCODE_TEXT = 0x1\n    OPCODE_BINARY = 0x2\n    OPCODE_CLOSE = 0x8\n    OPCODE_PING = 0x9\n    OPCODE_PONG = 0xA\n\n    # available operation code value tuple\n    OPCODES = (\n        OPCODE_CONT,\n        OPCODE_TEXT,\n        OPCODE_BINARY,\n        OPCODE_CLOSE,\n        OPCODE_PING,\n        OPCODE_PONG,\n    )\n\n    # opcode human readable string\n    OPCODE_MAP = {\n        OPCODE_CONT: \"cont\",\n        OPCODE_TEXT: \"text\",\n        OPCODE_BINARY: \"binary\",\n        OPCODE_CLOSE: \"close\",\n        OPCODE_PING: \"ping\",\n        OPCODE_PONG: \"pong\",\n    }\n\n    # data length threshold.\n    LENGTH_7 = 0x7E\n    LENGTH_16 = 1 << 16\n    LENGTH_63 = 1 << 63\n\n    def __init__(\n        self,\n        fin: int = 0,\n        rsv1: int = 0,\n        rsv2: int = 0,\n        rsv3: int = 0,\n        opcode: int = OPCODE_TEXT,\n        mask_value: int = 1,\n        data: Union[str, bytes, None] = \"\",\n    ) -> None:\n        \"\"\"\n        Constructor for ABNF. Please check RFC for arguments.\n        \"\"\"\n        self.fin = fin\n        self.rsv1 = rsv1\n        self.rsv2 = rsv2\n        self.rsv3 = rsv3\n        self.opcode = opcode\n        self.mask_value = mask_value\n        if data is None:\n            data = \"\"\n        self.data = data\n        self.get_mask_key = os.urandom\n\n    def validate(self, skip_utf8_validation: bool = False) -> None:\n        \"\"\"\n        Validate the ABNF frame.\n\n        Parameters\n        ----------\n        skip_utf8_validation: skip utf8 validation.\n        \"\"\"\n        if self.rsv1 or self.rsv2 or self.rsv3:\n            raise WebSocketProtocolException(\"rsv is not implemented, yet\")\n\n        if self.opcode not in ABNF.OPCODES:\n            raise WebSocketProtocolException(\"Invalid opcode %r\", self.opcode)\n\n        if self.opcode == ABNF.OPCODE_PING and not self.fin:\n            raise WebSocketProtocolException(\"Invalid ping frame.\")\n\n        if self.opcode == ABNF.OPCODE_CLOSE:\n            l = len(self.data)\n            if not l:\n                return\n            if l == 1 or l >= 126:\n                raise WebSocketProtocolException(\"Invalid close frame.\")\n            if l > 2 and not skip_utf8_validation and not validate_utf8(self.data[2:]):\n                raise WebSocketProtocolException(\"Invalid close frame.\")\n\n            code = 256 * int(self.data[0]) + int(self.data[1])\n            if not self._is_valid_close_status(code):\n                raise WebSocketProtocolException(\"Invalid close opcode %r\", code)\n\n    @staticmethod\n    def _is_valid_close_status(code: int) -> bool:\n        return code in VALID_CLOSE_STATUS or (3000 <= code < 5000)\n\n    def __str__(self) -> str:\n        return f\"fin={self.fin} opcode={self.opcode} data={self.data}\"\n\n    @staticmethod\n    def create_frame(data: Union[bytes, str], opcode: int, fin: int = 1) -> \"ABNF\":\n        \"\"\"\n        Create frame to send text, binary and other data.\n\n        Parameters\n        ----------\n        data: str\n            data to send. This is string value(byte array).\n            If opcode is OPCODE_TEXT and this value is unicode,\n            data value is converted into unicode string, automatically.\n        opcode: int\n            operation code. please see OPCODE_MAP.\n        fin: int\n            fin flag. if set to 0, create continue fragmentation.\n        \"\"\"\n        if opcode == ABNF.OPCODE_TEXT and isinstance(data, str):\n            data = data.encode(\"utf-8\")\n        # mask must be set if send data from client\n        return ABNF(fin, 0, 0, 0, opcode, 1, data)\n\n    def format(self) -> bytes:\n        \"\"\"\n        Format this object to string(byte array) to send data to server.\n        \"\"\"\n        if any(x not in (0, 1) for x in [self.fin, self.rsv1, self.rsv2, self.rsv3]):\n            raise ValueError(\"not 0 or 1\")\n        if self.opcode not in ABNF.OPCODES:\n            raise ValueError(\"Invalid OPCODE\")\n        length = len(self.data)\n        if length >= ABNF.LENGTH_63:\n            raise ValueError(\"data is too long\")\n\n        frame_header = chr(\n            self.fin << 7\n            | self.rsv1 << 6\n            | self.rsv2 << 5\n            | self.rsv3 << 4\n            | self.opcode\n        ).encode(\"latin-1\")\n        if length < ABNF.LENGTH_7:\n            frame_header += chr(self.mask_value << 7 | length).encode(\"latin-1\")\n        elif length < ABNF.LENGTH_16:\n            frame_header += chr(self.mask_value << 7 | 0x7E).encode(\"latin-1\")\n            frame_header += struct.pack(\"!H\", length)\n        else:\n            frame_header += chr(self.mask_value << 7 | 0x7F).encode(\"latin-1\")\n            frame_header += struct.pack(\"!Q\", length)\n\n        if not self.mask_value:\n            if isinstance(self.data, str):\n                self.data = self.data.encode(\"utf-8\")\n            return frame_header + self.data\n        mask_key = self.get_mask_key(4)\n        return frame_header + self._get_masked(mask_key)\n\n    def _get_masked(self, mask_key: Union[str, bytes]) -> bytes:\n        s = ABNF.mask(mask_key, self.data)\n\n        if isinstance(mask_key, str):\n            mask_key = mask_key.encode(\"utf-8\")\n\n        return mask_key + s\n\n    @staticmethod\n    def mask(mask_key: Union[str, bytes], data: Union[str, bytes]) -> bytes:\n        \"\"\"\n        Mask or unmask data. Just do xor for each byte\n\n        Parameters\n        ----------\n        mask_key: bytes or str\n            4 byte mask.\n        data: bytes or str\n            data to mask/unmask.\n        \"\"\"\n        if data is None:\n            data = \"\"\n\n        if isinstance(mask_key, str):\n            mask_key = mask_key.encode(\"latin-1\")\n\n        if isinstance(data, str):\n            data = data.encode(\"latin-1\")\n\n        return _mask(array.array(\"B\", mask_key), array.array(\"B\", data))\n\n\nclass frame_buffer:\n    _HEADER_MASK_INDEX = 5\n    _HEADER_LENGTH_INDEX = 6\n\n    def __init__(\n        self, recv_fn: Callable[[int], int], skip_utf8_validation: bool\n    ) -> None:\n        self.recv = recv_fn\n        self.skip_utf8_validation = skip_utf8_validation\n        # Buffers over the packets from the layer beneath until desired amount\n        # bytes of bytes are received.\n        self.recv_buffer: list = []\n        self.clear()\n        self.lock = Lock()\n\n    def clear(self) -> None:\n        self.header: Optional[tuple] = None\n        self.length: Optional[int] = None\n        self.mask_value: Union[bytes, str, None] = None\n\n    def has_received_header(self) -> bool:\n        return self.header is None\n\n    def recv_header(self) -> None:\n        header = self.recv_strict(2)\n        b1 = header[0]\n        fin = b1 >> 7 & 1\n        rsv1 = b1 >> 6 & 1\n        rsv2 = b1 >> 5 & 1\n        rsv3 = b1 >> 4 & 1\n        opcode = b1 & 0xF\n        b2 = header[1]\n        has_mask = b2 >> 7 & 1\n        length_bits = b2 & 0x7F\n\n        self.header = (fin, rsv1, rsv2, rsv3, opcode, has_mask, length_bits)\n\n    def has_mask(self) -> Union[bool, int]:\n        if not self.header:\n            return False\n        header_val: int = self.header[frame_buffer._HEADER_MASK_INDEX]\n        return header_val\n\n    def has_received_length(self) -> bool:\n        return self.length is None\n\n    def recv_length(self) -> None:\n        bits = self.header[frame_buffer._HEADER_LENGTH_INDEX]\n        length_bits = bits & 0x7F\n        if length_bits == 0x7E:\n            v = self.recv_strict(2)\n            self.length = struct.unpack(\"!H\", v)[0]\n        elif length_bits == 0x7F:\n            v = self.recv_strict(8)\n            self.length = struct.unpack(\"!Q\", v)[0]\n        else:\n            self.length = length_bits\n\n    def has_received_mask(self) -> bool:\n        return self.mask_value is None\n\n    def recv_mask(self) -> None:\n        self.mask_value = self.recv_strict(4) if self.has_mask() else \"\"\n\n    def recv_frame(self) -> ABNF:\n        with self.lock:\n            # Header\n            if self.has_received_header():\n                self.recv_header()\n            (fin, rsv1, rsv2, rsv3, opcode, has_mask, _) = self.header\n\n            # Frame length\n            if self.has_received_length():\n                self.recv_length()\n            length = self.length\n\n            # Mask\n            if self.has_received_mask():\n                self.recv_mask()\n            mask_value = self.mask_value\n\n            # Payload\n            payload = self.recv_strict(length)\n            if has_mask:\n                payload = ABNF.mask(mask_value, payload)\n\n            # Reset for next frame\n            self.clear()\n\n            frame = ABNF(fin, rsv1, rsv2, rsv3, opcode, has_mask, payload)\n            frame.validate(self.skip_utf8_validation)\n\n        return frame\n\n    def recv_strict(self, bufsize: int) -> bytes:\n        shortage = bufsize - sum(map(len, self.recv_buffer))\n        while shortage > 0:\n            # Limit buffer size that we pass to socket.recv() to avoid\n            # fragmenting the heap -- the number of bytes recv() actually\n            # reads is limited by socket buffer and is relatively small,\n            # yet passing large numbers repeatedly causes lots of large\n            # buffers allocated and then shrunk, which results in\n            # fragmentation.\n            bytes_ = self.recv(min(16384, shortage))\n            self.recv_buffer.append(bytes_)\n            shortage -= len(bytes_)\n\n        unified = b\"\".join(self.recv_buffer)\n\n        if shortage == 0:\n            self.recv_buffer = []\n            return unified\n        else:\n            self.recv_buffer = [unified[bufsize:]]\n            return unified[:bufsize]\n\n\nclass continuous_frame:\n    def __init__(self, fire_cont_frame: bool, skip_utf8_validation: bool) -> None:\n        self.fire_cont_frame = fire_cont_frame\n        self.skip_utf8_validation = skip_utf8_validation\n        self.cont_data: Optional[list] = None\n        self.recving_frames: Optional[int] = None\n\n    def validate(self, frame: ABNF) -> None:\n        if not self.recving_frames and frame.opcode == ABNF.OPCODE_CONT:\n            raise WebSocketProtocolException(\"Illegal frame\")\n        if self.recving_frames and frame.opcode in (\n            ABNF.OPCODE_TEXT,\n            ABNF.OPCODE_BINARY,\n        ):\n            raise WebSocketProtocolException(\"Illegal frame\")\n\n    def add(self, frame: ABNF) -> None:\n        if self.cont_data:\n            self.cont_data[1] += frame.data\n        else:\n            if frame.opcode in (ABNF.OPCODE_TEXT, ABNF.OPCODE_BINARY):\n                self.recving_frames = frame.opcode\n            self.cont_data = [frame.opcode, frame.data]\n\n        if frame.fin:\n            self.recving_frames = None\n\n    def is_fire(self, frame: ABNF) -> Union[bool, int]:\n        return frame.fin or self.fire_cont_frame\n\n    def extract(self, frame: ABNF) -> tuple:\n        data = self.cont_data\n        self.cont_data = None\n        frame.data = data[1]\n        if (\n            not self.fire_cont_frame\n            and data[0] == ABNF.OPCODE_TEXT\n            and not self.skip_utf8_validation\n            and not validate_utf8(frame.data)\n        ):\n            raise WebSocketPayloadException(f\"cannot decode: {repr(frame.data)}\")\n        return data[0], frame\n", "websocket/_logging.py": "import logging\n\n\"\"\"\n_logging.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n_logger = logging.getLogger(\"websocket\")\ntry:\n    from logging import NullHandler\nexcept ImportError:\n\n    class NullHandler(logging.Handler):\n        def emit(self, record) -> None:\n            pass\n\n\n_logger.addHandler(NullHandler())\n\n_traceEnabled = False\n\n__all__ = [\n    \"enableTrace\",\n    \"dump\",\n    \"error\",\n    \"warning\",\n    \"debug\",\n    \"trace\",\n    \"isEnabledForError\",\n    \"isEnabledForDebug\",\n    \"isEnabledForTrace\",\n]\n\n\ndef enableTrace(\n    traceable: bool,\n    handler: logging.StreamHandler = logging.StreamHandler(),\n    level: str = \"DEBUG\",\n) -> None:\n    \"\"\"\n    Turn on/off the traceability.\n\n    Parameters\n    ----------\n    traceable: bool\n        If set to True, traceability is enabled.\n    \"\"\"\n    global _traceEnabled\n    _traceEnabled = traceable\n    if traceable:\n        _logger.addHandler(handler)\n        _logger.setLevel(getattr(logging, level))\n\n\ndef dump(title: str, message: str) -> None:\n    if _traceEnabled:\n        _logger.debug(f\"--- {title} ---\")\n        _logger.debug(message)\n        _logger.debug(\"-----------------------\")\n\n\ndef error(msg: str) -> None:\n    _logger.error(msg)\n\n\ndef warning(msg: str) -> None:\n    _logger.warning(msg)\n\n\ndef debug(msg: str) -> None:\n    _logger.debug(msg)\n\n\ndef info(msg: str) -> None:\n    _logger.info(msg)\n\n\ndef trace(msg: str) -> None:\n    if _traceEnabled:\n        _logger.debug(msg)\n\n\ndef isEnabledForError() -> bool:\n    return _logger.isEnabledFor(logging.ERROR)\n\n\ndef isEnabledForDebug() -> bool:\n    return _logger.isEnabledFor(logging.DEBUG)\n\n\ndef isEnabledForTrace() -> bool:\n    return _traceEnabled\n", "websocket/_utils.py": "from typing import Union\n\n\"\"\"\n_url.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n__all__ = [\"NoLock\", \"validate_utf8\", \"extract_err_message\", \"extract_error_code\"]\n\n\nclass NoLock:\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(self, exc_type, exc_value, traceback) -> None:\n        pass\n\n\ntry:\n    # If wsaccel is available we use compiled routines to validate UTF-8\n    # strings.\n    from wsaccel.utf8validator import Utf8Validator\n\n    def _validate_utf8(utfbytes: Union[str, bytes]) -> bool:\n        result: bool = Utf8Validator().validate(utfbytes)[0]\n        return result\n\nexcept ImportError:\n    # UTF-8 validator\n    # python implementation of http://bjoern.hoehrmann.de/utf-8/decoder/dfa/\n\n    _UTF8_ACCEPT = 0\n    _UTF8_REJECT = 12\n\n    _UTF8D = [\n        # The first part of the table maps bytes to character classes that\n        # to reduce the size of the transition table and create bitmasks.\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        9,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        7,\n        8,\n        8,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        10,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        3,\n        4,\n        3,\n        3,\n        11,\n        6,\n        6,\n        6,\n        5,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        8,\n        # The second part is a transition table that maps a combination\n        # of a state of the automaton and a character class to a state.\n        0,\n        12,\n        24,\n        36,\n        60,\n        96,\n        84,\n        12,\n        12,\n        12,\n        48,\n        72,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        0,\n        12,\n        12,\n        12,\n        12,\n        12,\n        0,\n        12,\n        0,\n        12,\n        12,\n        12,\n        24,\n        12,\n        12,\n        12,\n        12,\n        12,\n        24,\n        12,\n        24,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        24,\n        12,\n        12,\n        12,\n        12,\n        12,\n        24,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        24,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        36,\n        12,\n        36,\n        12,\n        12,\n        12,\n        36,\n        12,\n        12,\n        12,\n        12,\n        12,\n        36,\n        12,\n        36,\n        12,\n        12,\n        12,\n        36,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n        12,\n    ]\n\n    def _decode(state: int, codep: int, ch: int) -> tuple:\n        tp = _UTF8D[ch]\n\n        codep = (\n            (ch & 0x3F) | (codep << 6) if (state != _UTF8_ACCEPT) else (0xFF >> tp) & ch\n        )\n        state = _UTF8D[256 + state + tp]\n\n        return state, codep\n\n    def _validate_utf8(utfbytes: Union[str, bytes]) -> bool:\n        state = _UTF8_ACCEPT\n        codep = 0\n        for i in utfbytes:\n            state, codep = _decode(state, codep, int(i))\n            if state == _UTF8_REJECT:\n                return False\n\n        return True\n\n\ndef validate_utf8(utfbytes: Union[str, bytes]) -> bool:\n    \"\"\"\n    validate utf8 byte string.\n    utfbytes: utf byte string to check.\n    return value: if valid utf8 string, return true. Otherwise, return false.\n    \"\"\"\n    return _validate_utf8(utfbytes)\n\n\ndef extract_err_message(exception: Exception) -> Union[str, None]:\n    if exception.args:\n        exception_message: str = exception.args[0]\n        return exception_message\n    else:\n        return None\n\n\ndef extract_error_code(exception: Exception) -> Union[int, None]:\n    if exception.args and len(exception.args) > 1:\n        return exception.args[0] if isinstance(exception.args[0], int) else None\n", "websocket/_cookiejar.py": "import http.cookies\nfrom typing import Optional\n\n\"\"\"\n_cookiejar.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n\nclass SimpleCookieJar:\n    def __init__(self) -> None:\n        self.jar: dict = {}\n\n    def add(self, set_cookie: Optional[str]) -> None:\n        if set_cookie:\n            simple_cookie = http.cookies.SimpleCookie(set_cookie)\n\n            for v in simple_cookie.values():\n                if domain := v.get(\"domain\"):\n                    if not domain.startswith(\".\"):\n                        domain = f\".{domain}\"\n                    cookie = (\n                        self.jar.get(domain)\n                        if self.jar.get(domain)\n                        else http.cookies.SimpleCookie()\n                    )\n                    cookie.update(simple_cookie)\n                    self.jar[domain.lower()] = cookie\n\n    def set(self, set_cookie: str) -> None:\n        if set_cookie:\n            simple_cookie = http.cookies.SimpleCookie(set_cookie)\n\n            for v in simple_cookie.values():\n                if domain := v.get(\"domain\"):\n                    if not domain.startswith(\".\"):\n                        domain = f\".{domain}\"\n                    self.jar[domain.lower()] = simple_cookie\n\n    def get(self, host: str) -> str:\n        if not host:\n            return \"\"\n\n        cookies = []\n        for domain, _ in self.jar.items():\n            host = host.lower()\n            if host.endswith(domain) or host == domain[1:]:\n                cookies.append(self.jar.get(domain))\n\n        return \"; \".join(\n            filter(\n                None,\n                sorted(\n                    [\n                        f\"{k}={v.value}\"\n                        for cookie in filter(None, cookies)\n                        for k, v in cookie.items()\n                    ]\n                ),\n            )\n        )\n", "websocket/_app.py": "import inspect\nimport selectors\nimport socket\nimport threading\nimport time\nfrom typing import Any, Callable, Optional, Union\n\nfrom . import _logging\nfrom ._abnf import ABNF\nfrom ._core import WebSocket, getdefaulttimeout\nfrom ._exceptions import (\n    WebSocketConnectionClosedException,\n    WebSocketException,\n    WebSocketTimeoutException,\n)\nfrom ._ssl_compat import SSLEOFError\nfrom ._url import parse_url\n\n\"\"\"\n_app.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n__all__ = [\"WebSocketApp\"]\n\nRECONNECT = 0\n\n\ndef setReconnect(reconnectInterval: int) -> None:\n    global RECONNECT\n    RECONNECT = reconnectInterval\n\n\nclass DispatcherBase:\n    \"\"\"\n    DispatcherBase\n    \"\"\"\n\n    def __init__(self, app: Any, ping_timeout: Union[float, int, None]) -> None:\n        self.app = app\n        self.ping_timeout = ping_timeout\n\n    def timeout(self, seconds: Union[float, int, None], callback: Callable) -> None:\n        time.sleep(seconds)\n        callback()\n\n    def reconnect(self, seconds: int, reconnector: Callable) -> None:\n        try:\n            _logging.info(\n                f\"reconnect() - retrying in {seconds} seconds [{len(inspect.stack())} frames in stack]\"\n            )\n            time.sleep(seconds)\n            reconnector(reconnecting=True)\n        except KeyboardInterrupt as e:\n            _logging.info(f\"User exited {e}\")\n            raise e\n\n\nclass Dispatcher(DispatcherBase):\n    \"\"\"\n    Dispatcher\n    \"\"\"\n\n    def read(\n        self,\n        sock: socket.socket,\n        read_callback: Callable,\n        check_callback: Callable,\n    ) -> None:\n        sel = selectors.DefaultSelector()\n        sel.register(self.app.sock.sock, selectors.EVENT_READ)\n        try:\n            while self.app.keep_running:\n                if sel.select(self.ping_timeout):\n                    if not read_callback():\n                        break\n                check_callback()\n        finally:\n            sel.close()\n\n\nclass SSLDispatcher(DispatcherBase):\n    \"\"\"\n    SSLDispatcher\n    \"\"\"\n\n    def read(\n        self,\n        sock: socket.socket,\n        read_callback: Callable,\n        check_callback: Callable,\n    ) -> None:\n        sock = self.app.sock.sock\n        sel = selectors.DefaultSelector()\n        sel.register(sock, selectors.EVENT_READ)\n        try:\n            while self.app.keep_running:\n                if self.select(sock, sel):\n                    if not read_callback():\n                        break\n                check_callback()\n        finally:\n            sel.close()\n\n    def select(self, sock, sel: selectors.DefaultSelector):\n        sock = self.app.sock.sock\n        if sock.pending():\n            return [\n                sock,\n            ]\n\n        r = sel.select(self.ping_timeout)\n\n        if len(r) > 0:\n            return r[0][0]\n\n\nclass WrappedDispatcher:\n    \"\"\"\n    WrappedDispatcher\n    \"\"\"\n\n    def __init__(self, app, ping_timeout: Union[float, int, None], dispatcher) -> None:\n        self.app = app\n        self.ping_timeout = ping_timeout\n        self.dispatcher = dispatcher\n        dispatcher.signal(2, dispatcher.abort)  # keyboard interrupt\n\n    def read(\n        self,\n        sock: socket.socket,\n        read_callback: Callable,\n        check_callback: Callable,\n    ) -> None:\n        self.dispatcher.read(sock, read_callback)\n        self.ping_timeout and self.timeout(self.ping_timeout, check_callback)\n\n    def timeout(self, seconds: float, callback: Callable) -> None:\n        self.dispatcher.timeout(seconds, callback)\n\n    def reconnect(self, seconds: int, reconnector: Callable) -> None:\n        self.timeout(seconds, reconnector)\n\n\nclass WebSocketApp:\n    \"\"\"\n    Higher level of APIs are provided. The interface is like JavaScript WebSocket object.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        header: Union[list, dict, Callable, None] = None,\n        on_open: Optional[Callable[[WebSocket], None]] = None,\n        on_reconnect: Optional[Callable[[WebSocket], None]] = None,\n        on_message: Optional[Callable[[WebSocket, Any], None]] = None,\n        on_error: Optional[Callable[[WebSocket, Any], None]] = None,\n        on_close: Optional[Callable[[WebSocket, Any, Any], None]] = None,\n        on_ping: Optional[Callable] = None,\n        on_pong: Optional[Callable] = None,\n        on_cont_message: Optional[Callable] = None,\n        keep_running: bool = True,\n        get_mask_key: Optional[Callable] = None,\n        cookie: Optional[str] = None,\n        subprotocols: Optional[list] = None,\n        on_data: Optional[Callable] = None,\n        socket: Optional[socket.socket] = None,\n    ) -> None:\n        \"\"\"\n        WebSocketApp initialization\n\n        Parameters\n        ----------\n        url: str\n            Websocket url.\n        header: list or dict or Callable\n            Custom header for websocket handshake.\n            If the parameter is a callable object, it is called just before the connection attempt.\n            The returned dict or list is used as custom header value.\n            This could be useful in order to properly setup timestamp dependent headers.\n        on_open: function\n            Callback object which is called at opening websocket.\n            on_open has one argument.\n            The 1st argument is this class object.\n        on_reconnect: function\n            Callback object which is called at reconnecting websocket.\n            on_reconnect has one argument.\n            The 1st argument is this class object.\n        on_message: function\n            Callback object which is called when received data.\n            on_message has 2 arguments.\n            The 1st argument is this class object.\n            The 2nd argument is utf-8 data received from the server.\n        on_error: function\n            Callback object which is called when we get error.\n            on_error has 2 arguments.\n            The 1st argument is this class object.\n            The 2nd argument is exception object.\n        on_close: function\n            Callback object which is called when connection is closed.\n            on_close has 3 arguments.\n            The 1st argument is this class object.\n            The 2nd argument is close_status_code.\n            The 3rd argument is close_msg.\n        on_cont_message: function\n            Callback object which is called when a continuation\n            frame is received.\n            on_cont_message has 3 arguments.\n            The 1st argument is this class object.\n            The 2nd argument is utf-8 string which we get from the server.\n            The 3rd argument is continue flag. if 0, the data continue\n            to next frame data\n        on_data: function\n            Callback object which is called when a message received.\n            This is called before on_message or on_cont_message,\n            and then on_message or on_cont_message is called.\n            on_data has 4 argument.\n            The 1st argument is this class object.\n            The 2nd argument is utf-8 string which we get from the server.\n            The 3rd argument is data type. ABNF.OPCODE_TEXT or ABNF.OPCODE_BINARY will be came.\n            The 4th argument is continue flag. If 0, the data continue\n        keep_running: bool\n            This parameter is obsolete and ignored.\n        get_mask_key: function\n            A callable function to get new mask keys, see the\n            WebSocket.set_mask_key's docstring for more information.\n        cookie: str\n            Cookie value.\n        subprotocols: list\n            List of available sub protocols. Default is None.\n        socket: socket\n            Pre-initialized stream socket.\n        \"\"\"\n        self.url = url\n        self.header = header if header is not None else []\n        self.cookie = cookie\n\n        self.on_open = on_open\n        self.on_reconnect = on_reconnect\n        self.on_message = on_message\n        self.on_data = on_data\n        self.on_error = on_error\n        self.on_close = on_close\n        self.on_ping = on_ping\n        self.on_pong = on_pong\n        self.on_cont_message = on_cont_message\n        self.keep_running = False\n        self.get_mask_key = get_mask_key\n        self.sock: Optional[WebSocket] = None\n        self.last_ping_tm = float(0)\n        self.last_pong_tm = float(0)\n        self.ping_thread: Optional[threading.Thread] = None\n        self.stop_ping: Optional[threading.Event] = None\n        self.ping_interval = float(0)\n        self.ping_timeout: Union[float, int, None] = None\n        self.ping_payload = \"\"\n        self.subprotocols = subprotocols\n        self.prepared_socket = socket\n        self.has_errored = False\n        self.has_done_teardown = False\n        self.has_done_teardown_lock = threading.Lock()\n\n    def send(self, data: Union[bytes, str], opcode: int = ABNF.OPCODE_TEXT) -> None:\n        \"\"\"\n        send message\n\n        Parameters\n        ----------\n        data: str\n            Message to send. If you set opcode to OPCODE_TEXT,\n            data must be utf-8 string or unicode.\n        opcode: int\n            Operation code of data. Default is OPCODE_TEXT.\n        \"\"\"\n\n        if not self.sock or self.sock.send(data, opcode) == 0:\n            raise WebSocketConnectionClosedException(\"Connection is already closed.\")\n\n    def send_text(self, text_data: str) -> None:\n        \"\"\"\n        Sends UTF-8 encoded text.\n        \"\"\"\n        if not self.sock or self.sock.send(text_data, ABNF.OPCODE_TEXT) == 0:\n            raise WebSocketConnectionClosedException(\"Connection is already closed.\")\n\n    def send_bytes(self, data: Union[bytes, bytearray]) -> None:\n        \"\"\"\n        Sends a sequence of bytes.\n        \"\"\"\n        if not self.sock or self.sock.send(data, ABNF.OPCODE_BINARY) == 0:\n            raise WebSocketConnectionClosedException(\"Connection is already closed.\")\n\n    def close(self, **kwargs) -> None:\n        \"\"\"\n        Close websocket connection.\n        \"\"\"\n        self.keep_running = False\n        if self.sock:\n            self.sock.close(**kwargs)\n            self.sock = None\n\n    def _start_ping_thread(self) -> None:\n        self.last_ping_tm = self.last_pong_tm = float(0)\n        self.stop_ping = threading.Event()\n        self.ping_thread = threading.Thread(target=self._send_ping)\n        self.ping_thread.daemon = True\n        self.ping_thread.start()\n\n    def _stop_ping_thread(self) -> None:\n        if self.stop_ping:\n            self.stop_ping.set()\n        if self.ping_thread and self.ping_thread.is_alive():\n            self.ping_thread.join(3)\n        self.last_ping_tm = self.last_pong_tm = float(0)\n\n    def _send_ping(self) -> None:\n        if self.stop_ping.wait(self.ping_interval) or self.keep_running is False:\n            return\n        while not self.stop_ping.wait(self.ping_interval) and self.keep_running is True:\n            if self.sock:\n                self.last_ping_tm = time.time()\n                try:\n                    _logging.debug(\"Sending ping\")\n                    self.sock.ping(self.ping_payload)\n                except Exception as e:\n                    _logging.debug(f\"Failed to send ping: {e}\")\n\n    def run_forever(\n        self,\n        sockopt: tuple = None,\n        sslopt: dict = None,\n        ping_interval: Union[float, int] = 0,\n        ping_timeout: Union[float, int, None] = None,\n        ping_payload: str = \"\",\n        http_proxy_host: str = None,\n        http_proxy_port: Union[int, str] = None,\n        http_no_proxy: list = None,\n        http_proxy_auth: tuple = None,\n        http_proxy_timeout: Optional[float] = None,\n        skip_utf8_validation: bool = False,\n        host: str = None,\n        origin: str = None,\n        dispatcher=None,\n        suppress_origin: bool = False,\n        proxy_type: str = None,\n        reconnect: int = None,\n    ) -> bool:\n        \"\"\"\n        Run event loop for WebSocket framework.\n\n        This loop is an infinite loop and is alive while websocket is available.\n\n        Parameters\n        ----------\n        sockopt: tuple\n            Values for socket.setsockopt.\n            sockopt must be tuple\n            and each element is argument of sock.setsockopt.\n        sslopt: dict\n            Optional dict object for ssl socket option.\n        ping_interval: int or float\n            Automatically send \"ping\" command\n            every specified period (in seconds).\n            If set to 0, no ping is sent periodically.\n        ping_timeout: int or float\n            Timeout (in seconds) if the pong message is not received.\n        ping_payload: str\n            Payload message to send with each ping.\n        http_proxy_host: str\n            HTTP proxy host name.\n        http_proxy_port: int or str\n            HTTP proxy port. If not set, set to 80.\n        http_no_proxy: list\n            Whitelisted host names that don't use the proxy.\n        http_proxy_timeout: int or float\n            HTTP proxy timeout, default is 60 sec as per python-socks.\n        http_proxy_auth: tuple\n            HTTP proxy auth information. tuple of username and password. Default is None.\n        skip_utf8_validation: bool\n            skip utf8 validation.\n        host: str\n            update host header.\n        origin: str\n            update origin header.\n        dispatcher: Dispatcher object\n            customize reading data from socket.\n        suppress_origin: bool\n            suppress outputting origin header.\n        proxy_type: str\n            type of proxy from: http, socks4, socks4a, socks5, socks5h\n        reconnect: int\n            delay interval when reconnecting\n\n        Returns\n        -------\n        teardown: bool\n            False if the `WebSocketApp` is closed or caught KeyboardInterrupt,\n            True if any other exception was raised during a loop.\n        \"\"\"\n\n        if reconnect is None:\n            reconnect = RECONNECT\n\n        if ping_timeout is not None and ping_timeout <= 0:\n            raise WebSocketException(\"Ensure ping_timeout > 0\")\n        if ping_interval is not None and ping_interval < 0:\n            raise WebSocketException(\"Ensure ping_interval >= 0\")\n        if ping_timeout and ping_interval and ping_interval <= ping_timeout:\n            raise WebSocketException(\"Ensure ping_interval > ping_timeout\")\n        if not sockopt:\n            sockopt = ()\n        if not sslopt:\n            sslopt = {}\n        if self.sock:\n            raise WebSocketException(\"socket is already opened\")\n\n        self.ping_interval = ping_interval\n        self.ping_timeout = ping_timeout\n        self.ping_payload = ping_payload\n        self.has_done_teardown = False\n        self.keep_running = True\n\n        def teardown(close_frame: ABNF = None):\n            \"\"\"\n            Tears down the connection.\n\n            Parameters\n            ----------\n            close_frame: ABNF frame\n                If close_frame is set, the on_close handler is invoked\n                with the statusCode and reason from the provided frame.\n            \"\"\"\n\n            # teardown() is called in many code paths to ensure resources are cleaned up and on_close is fired.\n            # To ensure the work is only done once, we use this bool and lock.\n            with self.has_done_teardown_lock:\n                if self.has_done_teardown:\n                    return\n                self.has_done_teardown = True\n\n            self._stop_ping_thread()\n            self.keep_running = False\n            if self.sock:\n                self.sock.close()\n            close_status_code, close_reason = self._get_close_args(\n                close_frame if close_frame else None\n            )\n            self.sock = None\n\n            # Finally call the callback AFTER all teardown is complete\n            self._callback(self.on_close, close_status_code, close_reason)\n\n        def setSock(reconnecting: bool = False) -> None:\n            if reconnecting and self.sock:\n                self.sock.shutdown()\n\n            self.sock = WebSocket(\n                self.get_mask_key,\n                sockopt=sockopt,\n                sslopt=sslopt,\n                fire_cont_frame=self.on_cont_message is not None,\n                skip_utf8_validation=skip_utf8_validation,\n                enable_multithread=True,\n            )\n\n            self.sock.settimeout(getdefaulttimeout())\n            try:\n                header = self.header() if callable(self.header) else self.header\n\n                self.sock.connect(\n                    self.url,\n                    header=header,\n                    cookie=self.cookie,\n                    http_proxy_host=http_proxy_host,\n                    http_proxy_port=http_proxy_port,\n                    http_no_proxy=http_no_proxy,\n                    http_proxy_auth=http_proxy_auth,\n                    http_proxy_timeout=http_proxy_timeout,\n                    subprotocols=self.subprotocols,\n                    host=host,\n                    origin=origin,\n                    suppress_origin=suppress_origin,\n                    proxy_type=proxy_type,\n                    socket=self.prepared_socket,\n                )\n\n                _logging.info(\"Websocket connected\")\n\n                if self.ping_interval:\n                    self._start_ping_thread()\n\n                if reconnecting and self.on_reconnect:\n                    self._callback(self.on_reconnect)\n                else:\n                    self._callback(self.on_open)\n\n                dispatcher.read(self.sock.sock, read, check)\n            except (\n                WebSocketConnectionClosedException,\n                ConnectionRefusedError,\n                KeyboardInterrupt,\n                SystemExit,\n                Exception,\n            ) as e:\n                handleDisconnect(e, reconnecting)\n\n        def read() -> bool:\n            if not self.keep_running:\n                return teardown()\n\n            try:\n                op_code, frame = self.sock.recv_data_frame(True)\n            except (\n                WebSocketConnectionClosedException,\n                KeyboardInterrupt,\n                SSLEOFError,\n            ) as e:\n                if custom_dispatcher:\n                    return handleDisconnect(e, bool(reconnect))\n                else:\n                    raise e\n\n            if op_code == ABNF.OPCODE_CLOSE:\n                return teardown(frame)\n            elif op_code == ABNF.OPCODE_PING:\n                self._callback(self.on_ping, frame.data)\n            elif op_code == ABNF.OPCODE_PONG:\n                self.last_pong_tm = time.time()\n                self._callback(self.on_pong, frame.data)\n            elif op_code == ABNF.OPCODE_CONT and self.on_cont_message:\n                self._callback(self.on_data, frame.data, frame.opcode, frame.fin)\n                self._callback(self.on_cont_message, frame.data, frame.fin)\n            else:\n                data = frame.data\n                if op_code == ABNF.OPCODE_TEXT and not skip_utf8_validation:\n                    data = data.decode(\"utf-8\")\n                self._callback(self.on_data, data, frame.opcode, True)\n                self._callback(self.on_message, data)\n\n            return True\n\n        def check() -> bool:\n            if self.ping_timeout:\n                has_timeout_expired = (\n                    time.time() - self.last_ping_tm > self.ping_timeout\n                )\n                has_pong_not_arrived_after_last_ping = (\n                    self.last_pong_tm - self.last_ping_tm < 0\n                )\n                has_pong_arrived_too_late = (\n                    self.last_pong_tm - self.last_ping_tm > self.ping_timeout\n                )\n\n                if (\n                    self.last_ping_tm\n                    and has_timeout_expired\n                    and (\n                        has_pong_not_arrived_after_last_ping\n                        or has_pong_arrived_too_late\n                    )\n                ):\n                    raise WebSocketTimeoutException(\"ping/pong timed out\")\n            return True\n\n        def handleDisconnect(\n            e: Union[\n                WebSocketConnectionClosedException,\n                ConnectionRefusedError,\n                KeyboardInterrupt,\n                SystemExit,\n                Exception,\n            ],\n            reconnecting: bool = False,\n        ) -> bool:\n            self.has_errored = True\n            self._stop_ping_thread()\n            if not reconnecting:\n                self._callback(self.on_error, e)\n\n            if isinstance(e, (KeyboardInterrupt, SystemExit)):\n                teardown()\n                # Propagate further\n                raise\n\n            if reconnect:\n                _logging.info(f\"{e} - reconnect\")\n                if custom_dispatcher:\n                    _logging.debug(\n                        f\"Calling custom dispatcher reconnect [{len(inspect.stack())} frames in stack]\"\n                    )\n                    dispatcher.reconnect(reconnect, setSock)\n            else:\n                _logging.error(f\"{e} - goodbye\")\n                teardown()\n\n        custom_dispatcher = bool(dispatcher)\n        dispatcher = self.create_dispatcher(\n            ping_timeout, dispatcher, parse_url(self.url)[3]\n        )\n\n        try:\n            setSock()\n            if not custom_dispatcher and reconnect:\n                while self.keep_running:\n                    _logging.debug(\n                        f\"Calling dispatcher reconnect [{len(inspect.stack())} frames in stack]\"\n                    )\n                    dispatcher.reconnect(reconnect, setSock)\n        except (KeyboardInterrupt, Exception) as e:\n            _logging.info(f\"tearing down on exception {e}\")\n            teardown()\n        finally:\n            if not custom_dispatcher:\n                # Ensure teardown was called before returning from run_forever\n                teardown()\n\n        return self.has_errored\n\n    def create_dispatcher(\n        self,\n        ping_timeout: Union[float, int, None],\n        dispatcher: Optional[DispatcherBase] = None,\n        is_ssl: bool = False,\n    ) -> Union[Dispatcher, SSLDispatcher, WrappedDispatcher]:\n        if dispatcher:  # If custom dispatcher is set, use WrappedDispatcher\n            return WrappedDispatcher(self, ping_timeout, dispatcher)\n        timeout = ping_timeout or 10\n        if is_ssl:\n            return SSLDispatcher(self, timeout)\n        return Dispatcher(self, timeout)\n\n    def _get_close_args(self, close_frame: ABNF) -> list:\n        \"\"\"\n        _get_close_args extracts the close code and reason from the close body\n        if it exists (RFC6455 says WebSocket Connection Close Code is optional)\n        \"\"\"\n        # Need to catch the case where close_frame is None\n        # Otherwise the following if statement causes an error\n        if not self.on_close or not close_frame:\n            return [None, None]\n\n        # Extract close frame status code\n        if close_frame.data and len(close_frame.data) >= 2:\n            close_status_code = 256 * int(close_frame.data[0]) + int(\n                close_frame.data[1]\n            )\n            reason = close_frame.data[2:]\n            if isinstance(reason, bytes):\n                reason = reason.decode(\"utf-8\")\n            return [close_status_code, reason]\n        else:\n            # Most likely reached this because len(close_frame_data.data) < 2\n            return [None, None]\n\n    def _callback(self, callback, *args) -> None:\n        if callback:\n            try:\n                callback(self, *args)\n\n            except Exception as e:\n                _logging.error(f\"error from callback {callback}: {e}\")\n                if self.on_error:\n                    self.on_error(self, e)\n", "websocket/_handshake.py": "\"\"\"\n_handshake.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nimport hashlib\nimport hmac\nimport os\nfrom base64 import encodebytes as base64encode\nfrom http import HTTPStatus\n\nfrom ._cookiejar import SimpleCookieJar\nfrom ._exceptions import WebSocketException, WebSocketBadStatusException\nfrom ._http import read_headers\nfrom ._logging import dump, error\nfrom ._socket import send\n\n__all__ = [\"handshake_response\", \"handshake\", \"SUPPORTED_REDIRECT_STATUSES\"]\n\n# websocket supported version.\nVERSION = 13\n\nSUPPORTED_REDIRECT_STATUSES = (\n    HTTPStatus.MOVED_PERMANENTLY,\n    HTTPStatus.FOUND,\n    HTTPStatus.SEE_OTHER,\n    HTTPStatus.TEMPORARY_REDIRECT,\n    HTTPStatus.PERMANENT_REDIRECT,\n)\nSUCCESS_STATUSES = SUPPORTED_REDIRECT_STATUSES + (HTTPStatus.SWITCHING_PROTOCOLS,)\n\nCookieJar = SimpleCookieJar()\n\n\nclass handshake_response:\n    def __init__(self, status: int, headers: dict, subprotocol):\n        self.status = status\n        self.headers = headers\n        self.subprotocol = subprotocol\n        CookieJar.add(headers.get(\"set-cookie\"))\n\n\ndef handshake(\n    sock, url: str, hostname: str, port: int, resource: str, **options\n) -> handshake_response:\n    headers, key = _get_handshake_headers(resource, url, hostname, port, options)\n\n    header_str = \"\\r\\n\".join(headers)\n    send(sock, header_str)\n    dump(\"request header\", header_str)\n\n    status, resp = _get_resp_headers(sock)\n    if status in SUPPORTED_REDIRECT_STATUSES:\n        return handshake_response(status, resp, None)\n    success, subproto = _validate(resp, key, options.get(\"subprotocols\"))\n    if not success:\n        raise WebSocketException(\"Invalid WebSocket Header\")\n\n    return handshake_response(status, resp, subproto)\n\n\ndef _pack_hostname(hostname: str) -> str:\n    # IPv6 address\n    if \":\" in hostname:\n        return f\"[{hostname}]\"\n    return hostname\n\n\ndef _get_handshake_headers(\n    resource: str, url: str, host: str, port: int, options: dict\n) -> tuple:\n    headers = [f\"GET {resource} HTTP/1.1\", \"Upgrade: websocket\"]\n    if port in [80, 443]:\n        hostport = _pack_hostname(host)\n    else:\n        hostport = f\"{_pack_hostname(host)}:{port}\"\n    if options.get(\"host\"):\n        headers.append(f'Host: {options[\"host\"]}')\n    else:\n        headers.append(f\"Host: {hostport}\")\n\n    # scheme indicates whether http or https is used in Origin\n    # The same approach is used in parse_url of _url.py to set default port\n    scheme, url = url.split(\":\", 1)\n    if not options.get(\"suppress_origin\"):\n        if \"origin\" in options and options[\"origin\"] is not None:\n            headers.append(f'Origin: {options[\"origin\"]}')\n        elif scheme == \"wss\":\n            headers.append(f\"Origin: https://{hostport}\")\n        else:\n            headers.append(f\"Origin: http://{hostport}\")\n\n    key = _create_sec_websocket_key()\n\n    # Append Sec-WebSocket-Key & Sec-WebSocket-Version if not manually specified\n    if not options.get(\"header\") or \"Sec-WebSocket-Key\" not in options[\"header\"]:\n        headers.append(f\"Sec-WebSocket-Key: {key}\")\n    else:\n        key = options[\"header\"][\"Sec-WebSocket-Key\"]\n\n    if not options.get(\"header\") or \"Sec-WebSocket-Version\" not in options[\"header\"]:\n        headers.append(f\"Sec-WebSocket-Version: {VERSION}\")\n\n    if not options.get(\"connection\"):\n        headers.append(\"Connection: Upgrade\")\n    else:\n        headers.append(options[\"connection\"])\n\n    if subprotocols := options.get(\"subprotocols\"):\n        headers.append(f'Sec-WebSocket-Protocol: {\",\".join(subprotocols)}')\n\n    if header := options.get(\"header\"):\n        if isinstance(header, dict):\n            header = [\": \".join([k, v]) for k, v in header.items() if v is not None]\n        headers.extend(header)\n\n    server_cookie = CookieJar.get(host)\n    client_cookie = options.get(\"cookie\", None)\n\n    if cookie := \"; \".join(filter(None, [server_cookie, client_cookie])):\n        headers.append(f\"Cookie: {cookie}\")\n\n    headers.extend((\"\", \"\"))\n    return headers, key\n\n\ndef _get_resp_headers(sock, success_statuses: tuple = SUCCESS_STATUSES) -> tuple:\n    status, resp_headers, status_message = read_headers(sock)\n    if status not in success_statuses:\n        content_len = resp_headers.get(\"content-length\")\n        if content_len:\n            response_body = sock.recv(\n                int(content_len)\n            )  # read the body of the HTTP error message response and include it in the exception\n        else:\n            response_body = None\n        raise WebSocketBadStatusException(\n            f\"Handshake status {status} {status_message} -+-+- {resp_headers} -+-+- {response_body}\",\n            status,\n            status_message,\n            resp_headers,\n            response_body,\n        )\n    return status, resp_headers\n\n\n_HEADERS_TO_CHECK = {\n    \"upgrade\": \"websocket\",\n    \"connection\": \"upgrade\",\n}\n\n\ndef _validate(headers, key: str, subprotocols) -> tuple:\n    subproto = None\n    for k, v in _HEADERS_TO_CHECK.items():\n        r = headers.get(k, None)\n        if not r:\n            return False, None\n        r = [x.strip().lower() for x in r.split(\",\")]\n        if v not in r:\n            return False, None\n\n    if subprotocols:\n        subproto = headers.get(\"sec-websocket-protocol\", None)\n        if not subproto or subproto.lower() not in [s.lower() for s in subprotocols]:\n            error(f\"Invalid subprotocol: {subprotocols}\")\n            return False, None\n        subproto = subproto.lower()\n\n    result = headers.get(\"sec-websocket-accept\", None)\n    if not result:\n        return False, None\n    result = result.lower()\n\n    if isinstance(result, str):\n        result = result.encode(\"utf-8\")\n\n    value = f\"{key}258EAFA5-E914-47DA-95CA-C5AB0DC85B11\".encode(\"utf-8\")\n    hashed = base64encode(hashlib.sha1(value).digest()).strip().lower()\n\n    if hmac.compare_digest(hashed, result):\n        return True, subproto\n    else:\n        return False, None\n\n\ndef _create_sec_websocket_key() -> str:\n    randomness = os.urandom(16)\n    return base64encode(randomness).decode(\"utf-8\").strip()\n", "websocket/__init__.py": "\"\"\"\n__init__.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nfrom ._abnf import *\nfrom ._app import WebSocketApp as WebSocketApp, setReconnect as setReconnect\nfrom ._core import *\nfrom ._exceptions import *\nfrom ._logging import *\nfrom ._socket import *\n\n__version__ = \"1.8.0\"\n", "websocket/_socket.py": "import errno\nimport selectors\nimport socket\nfrom typing import Union\n\nfrom ._exceptions import (\n    WebSocketConnectionClosedException,\n    WebSocketTimeoutException,\n)\nfrom ._ssl_compat import SSLError, SSLWantReadError, SSLWantWriteError\nfrom ._utils import extract_error_code, extract_err_message\n\n\"\"\"\n_socket.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\nDEFAULT_SOCKET_OPTION = [(socket.SOL_TCP, socket.TCP_NODELAY, 1)]\nif hasattr(socket, \"SO_KEEPALIVE\"):\n    DEFAULT_SOCKET_OPTION.append((socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1))\nif hasattr(socket, \"TCP_KEEPIDLE\"):\n    DEFAULT_SOCKET_OPTION.append((socket.SOL_TCP, socket.TCP_KEEPIDLE, 30))\nif hasattr(socket, \"TCP_KEEPINTVL\"):\n    DEFAULT_SOCKET_OPTION.append((socket.SOL_TCP, socket.TCP_KEEPINTVL, 10))\nif hasattr(socket, \"TCP_KEEPCNT\"):\n    DEFAULT_SOCKET_OPTION.append((socket.SOL_TCP, socket.TCP_KEEPCNT, 3))\n\n_default_timeout = None\n\n__all__ = [\n    \"DEFAULT_SOCKET_OPTION\",\n    \"sock_opt\",\n    \"setdefaulttimeout\",\n    \"getdefaulttimeout\",\n    \"recv\",\n    \"recv_line\",\n    \"send\",\n]\n\n\nclass sock_opt:\n    def __init__(self, sockopt: list, sslopt: dict) -> None:\n        if sockopt is None:\n            sockopt = []\n        if sslopt is None:\n            sslopt = {}\n        self.sockopt = sockopt\n        self.sslopt = sslopt\n        self.timeout = None\n\n\ndef setdefaulttimeout(timeout: Union[int, float, None]) -> None:\n    \"\"\"\n    Set the global timeout setting to connect.\n\n    Parameters\n    ----------\n    timeout: int or float\n        default socket timeout time (in seconds)\n    \"\"\"\n    global _default_timeout\n    _default_timeout = timeout\n\n\ndef getdefaulttimeout() -> Union[int, float, None]:\n    \"\"\"\n    Get default timeout\n\n    Returns\n    ----------\n    _default_timeout: int or float\n        Return the global timeout setting (in seconds) to connect.\n    \"\"\"\n    return _default_timeout\n\n\ndef recv(sock: socket.socket, bufsize: int) -> bytes:\n    if not sock:\n        raise WebSocketConnectionClosedException(\"socket is already closed.\")\n\n    def _recv():\n        try:\n            return sock.recv(bufsize)\n        except SSLWantReadError:\n            pass\n        except socket.error as exc:\n            error_code = extract_error_code(exc)\n            if error_code not in [errno.EAGAIN, errno.EWOULDBLOCK]:\n                raise\n\n        sel = selectors.DefaultSelector()\n        sel.register(sock, selectors.EVENT_READ)\n\n        r = sel.select(sock.gettimeout())\n        sel.close()\n\n        if r:\n            return sock.recv(bufsize)\n\n    try:\n        if sock.gettimeout() == 0:\n            bytes_ = sock.recv(bufsize)\n        else:\n            bytes_ = _recv()\n    except TimeoutError:\n        raise WebSocketTimeoutException(\"Connection timed out\")\n    except socket.timeout as e:\n        message = extract_err_message(e)\n        raise WebSocketTimeoutException(message)\n    except SSLError as e:\n        message = extract_err_message(e)\n        if isinstance(message, str) and \"timed out\" in message:\n            raise WebSocketTimeoutException(message)\n        else:\n            raise\n\n    if not bytes_:\n        raise WebSocketConnectionClosedException(\"Connection to remote host was lost.\")\n\n    return bytes_\n\n\ndef recv_line(sock: socket.socket) -> bytes:\n    line = []\n    while True:\n        c = recv(sock, 1)\n        line.append(c)\n        if c == b\"\\n\":\n            break\n    return b\"\".join(line)\n\n\ndef send(sock: socket.socket, data: Union[bytes, str]) -> int:\n    if isinstance(data, str):\n        data = data.encode(\"utf-8\")\n\n    if not sock:\n        raise WebSocketConnectionClosedException(\"socket is already closed.\")\n\n    def _send():\n        try:\n            return sock.send(data)\n        except SSLWantWriteError:\n            pass\n        except socket.error as exc:\n            error_code = extract_error_code(exc)\n            if error_code is None:\n                raise\n            if error_code not in [errno.EAGAIN, errno.EWOULDBLOCK]:\n                raise\n\n        sel = selectors.DefaultSelector()\n        sel.register(sock, selectors.EVENT_WRITE)\n\n        w = sel.select(sock.gettimeout())\n        sel.close()\n\n        if w:\n            return sock.send(data)\n\n    try:\n        if sock.gettimeout() == 0:\n            return sock.send(data)\n        else:\n            return _send()\n    except socket.timeout as e:\n        message = extract_err_message(e)\n        raise WebSocketTimeoutException(message)\n    except Exception as e:\n        message = extract_err_message(e)\n        if isinstance(message, str) and \"timed out\" in message:\n            raise WebSocketTimeoutException(message)\n        else:\n            raise\n", "websocket/_core.py": "import socket\nimport struct\nimport threading\nimport time\nfrom typing import Optional, Union\n\n# websocket modules\nfrom ._abnf import ABNF, STATUS_NORMAL, continuous_frame, frame_buffer\nfrom ._exceptions import WebSocketProtocolException, WebSocketConnectionClosedException\nfrom ._handshake import SUPPORTED_REDIRECT_STATUSES, handshake\nfrom ._http import connect, proxy_info\nfrom ._logging import debug, error, trace, isEnabledForError, isEnabledForTrace\nfrom ._socket import getdefaulttimeout, recv, send, sock_opt\nfrom ._ssl_compat import ssl\nfrom ._utils import NoLock\n\n\"\"\"\n_core.py\nwebsocket - WebSocket client library for Python\n\nCopyright 2024 engn33r\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\n\n__all__ = [\"WebSocket\", \"create_connection\"]\n\n\nclass WebSocket:\n    \"\"\"\n    Low level WebSocket interface.\n\n    This class is based on the WebSocket protocol `draft-hixie-thewebsocketprotocol-76 <http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76>`_\n\n    We can connect to the websocket server and send/receive data.\n    The following example is an echo client.\n\n    >>> import websocket\n    >>> ws = websocket.WebSocket()\n    >>> ws.connect(\"ws://echo.websocket.events\")\n    >>> ws.recv()\n    'echo.websocket.events sponsored by Lob.com'\n    >>> ws.send(\"Hello, Server\")\n    19\n    >>> ws.recv()\n    'Hello, Server'\n    >>> ws.close()\n\n    Parameters\n    ----------\n    get_mask_key: func\n        A callable function to get new mask keys, see the\n        WebSocket.set_mask_key's docstring for more information.\n    sockopt: tuple\n        Values for socket.setsockopt.\n        sockopt must be tuple and each element is argument of sock.setsockopt.\n    sslopt: dict\n        Optional dict object for ssl socket options. See FAQ for details.\n    fire_cont_frame: bool\n        Fire recv event for each cont frame. Default is False.\n    enable_multithread: bool\n        If set to True, lock send method.\n    skip_utf8_validation: bool\n        Skip utf8 validation.\n    \"\"\"\n\n    def __init__(\n        self,\n        get_mask_key=None,\n        sockopt=None,\n        sslopt=None,\n        fire_cont_frame: bool = False,\n        enable_multithread: bool = True,\n        skip_utf8_validation: bool = False,\n        **_,\n    ):\n        \"\"\"\n        Initialize WebSocket object.\n\n        Parameters\n        ----------\n        sslopt: dict\n            Optional dict object for ssl socket options. See FAQ for details.\n        \"\"\"\n        self.sock_opt = sock_opt(sockopt, sslopt)\n        self.handshake_response = None\n        self.sock: Optional[socket.socket] = None\n\n        self.connected = False\n        self.get_mask_key = get_mask_key\n        # These buffer over the build-up of a single frame.\n        self.frame_buffer = frame_buffer(self._recv, skip_utf8_validation)\n        self.cont_frame = continuous_frame(fire_cont_frame, skip_utf8_validation)\n\n        if enable_multithread:\n            self.lock = threading.Lock()\n            self.readlock = threading.Lock()\n        else:\n            self.lock = NoLock()\n            self.readlock = NoLock()\n\n    def __iter__(self):\n        \"\"\"\n        Allow iteration over websocket, implying sequential `recv` executions.\n        \"\"\"\n        while True:\n            yield self.recv()\n\n    def __next__(self):\n        return self.recv()\n\n    def next(self):\n        return self.__next__()\n\n    def fileno(self):\n        return self.sock.fileno()\n\n    def set_mask_key(self, func):\n        \"\"\"\n        Set function to create mask key. You can customize mask key generator.\n        Mainly, this is for testing purpose.\n\n        Parameters\n        ----------\n        func: func\n            callable object. the func takes 1 argument as integer.\n            The argument means length of mask key.\n            This func must return string(byte array),\n            which length is argument specified.\n        \"\"\"\n        self.get_mask_key = func\n\n    def gettimeout(self) -> Union[float, int, None]:\n        \"\"\"\n        Get the websocket timeout (in seconds) as an int or float\n\n        Returns\n        ----------\n        timeout: int or float\n             returns timeout value (in seconds). This value could be either float/integer.\n        \"\"\"\n        return self.sock_opt.timeout\n\n    def settimeout(self, timeout: Union[float, int, None]):\n        \"\"\"\n        Set the timeout to the websocket.\n\n        Parameters\n        ----------\n        timeout: int or float\n            timeout time (in seconds). This value could be either float/integer.\n        \"\"\"\n        self.sock_opt.timeout = timeout\n        if self.sock:\n            self.sock.settimeout(timeout)\n\n    timeout = property(gettimeout, settimeout)\n\n    def getsubprotocol(self):\n        \"\"\"\n        Get subprotocol\n        \"\"\"\n        if self.handshake_response:\n            return self.handshake_response.subprotocol\n        else:\n            return None\n\n    subprotocol = property(getsubprotocol)\n\n    def getstatus(self):\n        \"\"\"\n        Get handshake status\n        \"\"\"\n        if self.handshake_response:\n            return self.handshake_response.status\n        else:\n            return None\n\n    status = property(getstatus)\n\n    def getheaders(self):\n        \"\"\"\n        Get handshake response header\n        \"\"\"\n        if self.handshake_response:\n            return self.handshake_response.headers\n        else:\n            return None\n\n    def is_ssl(self):\n        try:\n            return isinstance(self.sock, ssl.SSLSocket)\n        except:\n            return False\n\n    headers = property(getheaders)\n\n    def connect(self, url, **options):\n        \"\"\"\n        Connect to url. url is websocket url scheme.\n        ie. ws://host:port/resource\n        You can customize using 'options'.\n        If you set \"header\" list object, you can set your own custom header.\n\n        >>> ws = WebSocket()\n        >>> ws.connect(\"ws://echo.websocket.events\",\n                ...     header=[\"User-Agent: MyProgram\",\n                ...             \"x-custom: header\"])\n\n        Parameters\n        ----------\n        header: list or dict\n            Custom http header list or dict.\n        cookie: str\n            Cookie value.\n        origin: str\n            Custom origin url.\n        connection: str\n            Custom connection header value.\n            Default value \"Upgrade\" set in _handshake.py\n        suppress_origin: bool\n            Suppress outputting origin header.\n        host: str\n            Custom host header string.\n        timeout: int or float\n            Socket timeout time. This value is an integer or float.\n            If you set None for this value, it means \"use default_timeout value\"\n        http_proxy_host: str\n            HTTP proxy host name.\n        http_proxy_port: str or int\n            HTTP proxy port. Default is 80.\n        http_no_proxy: list\n            Whitelisted host names that don't use the proxy.\n        http_proxy_auth: tuple\n            HTTP proxy auth information. Tuple of username and password. Default is None.\n        http_proxy_timeout: int or float\n            HTTP proxy timeout, default is 60 sec as per python-socks.\n        redirect_limit: int\n            Number of redirects to follow.\n        subprotocols: list\n            List of available subprotocols. Default is None.\n        socket: socket\n            Pre-initialized stream socket.\n        \"\"\"\n        self.sock_opt.timeout = options.get(\"timeout\", self.sock_opt.timeout)\n        self.sock, addrs = connect(\n            url, self.sock_opt, proxy_info(**options), options.pop(\"socket\", None)\n        )\n\n        try:\n            self.handshake_response = handshake(self.sock, url, *addrs, **options)\n            for _ in range(options.pop(\"redirect_limit\", 3)):\n                if self.handshake_response.status in SUPPORTED_REDIRECT_STATUSES:\n                    url = self.handshake_response.headers[\"location\"]\n                    self.sock.close()\n                    self.sock, addrs = connect(\n                        url,\n                        self.sock_opt,\n                        proxy_info(**options),\n                        options.pop(\"socket\", None),\n                    )\n                    self.handshake_response = handshake(\n                        self.sock, url, *addrs, **options\n                    )\n            self.connected = True\n        except:\n            if self.sock:\n                self.sock.close()\n                self.sock = None\n            raise\n\n    def send(self, payload: Union[bytes, str], opcode: int = ABNF.OPCODE_TEXT) -> int:\n        \"\"\"\n        Send the data as string.\n\n        Parameters\n        ----------\n        payload: str\n            Payload must be utf-8 string or unicode,\n            If the opcode is OPCODE_TEXT.\n            Otherwise, it must be string(byte array).\n        opcode: int\n            Operation code (opcode) to send.\n        \"\"\"\n\n        frame = ABNF.create_frame(payload, opcode)\n        return self.send_frame(frame)\n\n    def send_text(self, text_data: str) -> int:\n        \"\"\"\n        Sends UTF-8 encoded text.\n        \"\"\"\n        return self.send(text_data, ABNF.OPCODE_TEXT)\n\n    def send_bytes(self, data: Union[bytes, bytearray]) -> int:\n        \"\"\"\n        Sends a sequence of bytes.\n        \"\"\"\n        return self.send(data, ABNF.OPCODE_BINARY)\n\n    def send_frame(self, frame) -> int:\n        \"\"\"\n        Send the data frame.\n\n        >>> ws = create_connection(\"ws://echo.websocket.events\")\n        >>> frame = ABNF.create_frame(\"Hello\", ABNF.OPCODE_TEXT)\n        >>> ws.send_frame(frame)\n        >>> cont_frame = ABNF.create_frame(\"My name is \", ABNF.OPCODE_CONT, 0)\n        >>> ws.send_frame(frame)\n        >>> cont_frame = ABNF.create_frame(\"Foo Bar\", ABNF.OPCODE_CONT, 1)\n        >>> ws.send_frame(frame)\n\n        Parameters\n        ----------\n        frame: ABNF frame\n            frame data created by ABNF.create_frame\n        \"\"\"\n        if self.get_mask_key:\n            frame.get_mask_key = self.get_mask_key\n        data = frame.format()\n        length = len(data)\n        if isEnabledForTrace():\n            trace(f\"++Sent raw: {repr(data)}\")\n            trace(f\"++Sent decoded: {frame.__str__()}\")\n        with self.lock:\n            while data:\n                l = self._send(data)\n                data = data[l:]\n\n        return length\n\n    def send_binary(self, payload: bytes) -> int:\n        \"\"\"\n        Send a binary message (OPCODE_BINARY).\n\n        Parameters\n        ----------\n        payload: bytes\n            payload of message to send.\n        \"\"\"\n        return self.send(payload, ABNF.OPCODE_BINARY)\n\n    def ping(self, payload: Union[str, bytes] = \"\"):\n        \"\"\"\n        Send ping data.\n\n        Parameters\n        ----------\n        payload: str\n            data payload to send server.\n        \"\"\"\n        if isinstance(payload, str):\n            payload = payload.encode(\"utf-8\")\n        self.send(payload, ABNF.OPCODE_PING)\n\n    def pong(self, payload: Union[str, bytes] = \"\"):\n        \"\"\"\n        Send pong data.\n\n        Parameters\n        ----------\n        payload: str\n            data payload to send server.\n        \"\"\"\n        if isinstance(payload, str):\n            payload = payload.encode(\"utf-8\")\n        self.send(payload, ABNF.OPCODE_PONG)\n\n    def recv(self) -> Union[str, bytes]:\n        \"\"\"\n        Receive string data(byte array) from the server.\n\n        Returns\n        ----------\n        data: string (byte array) value.\n        \"\"\"\n        with self.readlock:\n            opcode, data = self.recv_data()\n        if opcode == ABNF.OPCODE_TEXT:\n            data_received: Union[bytes, str] = data\n            if isinstance(data_received, bytes):\n                return data_received.decode(\"utf-8\")\n            elif isinstance(data_received, str):\n                return data_received\n        elif opcode == ABNF.OPCODE_BINARY:\n            data_binary: bytes = data\n            return data_binary\n        else:\n            return \"\"\n\n    def recv_data(self, control_frame: bool = False) -> tuple:\n        \"\"\"\n        Receive data with operation code.\n\n        Parameters\n        ----------\n        control_frame: bool\n            a boolean flag indicating whether to return control frame\n            data, defaults to False\n\n        Returns\n        -------\n        opcode, frame.data: tuple\n            tuple of operation code and string(byte array) value.\n        \"\"\"\n        opcode, frame = self.recv_data_frame(control_frame)\n        return opcode, frame.data\n\n    def recv_data_frame(self, control_frame: bool = False) -> tuple:\n        \"\"\"\n        Receive data with operation code.\n\n        If a valid ping message is received, a pong response is sent.\n\n        Parameters\n        ----------\n        control_frame: bool\n            a boolean flag indicating whether to return control frame\n            data, defaults to False\n\n        Returns\n        -------\n        frame.opcode, frame: tuple\n            tuple of operation code and string(byte array) value.\n        \"\"\"\n        while True:\n            frame = self.recv_frame()\n            if isEnabledForTrace():\n                trace(f\"++Rcv raw: {repr(frame.format())}\")\n                trace(f\"++Rcv decoded: {frame.__str__()}\")\n            if not frame:\n                # handle error:\n                # 'NoneType' object has no attribute 'opcode'\n                raise WebSocketProtocolException(f\"Not a valid frame {frame}\")\n            elif frame.opcode in (\n                ABNF.OPCODE_TEXT,\n                ABNF.OPCODE_BINARY,\n                ABNF.OPCODE_CONT,\n            ):\n                self.cont_frame.validate(frame)\n                self.cont_frame.add(frame)\n\n                if self.cont_frame.is_fire(frame):\n                    return self.cont_frame.extract(frame)\n\n            elif frame.opcode == ABNF.OPCODE_CLOSE:\n                self.send_close()\n                return frame.opcode, frame\n            elif frame.opcode == ABNF.OPCODE_PING:\n                if len(frame.data) < 126:\n                    self.pong(frame.data)\n                else:\n                    raise WebSocketProtocolException(\"Ping message is too long\")\n                if control_frame:\n                    return frame.opcode, frame\n            elif frame.opcode == ABNF.OPCODE_PONG:\n                if control_frame:\n                    return frame.opcode, frame\n\n    def recv_frame(self):\n        \"\"\"\n        Receive data as frame from server.\n\n        Returns\n        -------\n        self.frame_buffer.recv_frame(): ABNF frame object\n        \"\"\"\n        return self.frame_buffer.recv_frame()\n\n    def send_close(self, status: int = STATUS_NORMAL, reason: bytes = b\"\"):\n        \"\"\"\n        Send close data to the server.\n\n        Parameters\n        ----------\n        status: int\n            Status code to send. See STATUS_XXX.\n        reason: str or bytes\n            The reason to close. This must be string or UTF-8 bytes.\n        \"\"\"\n        if status < 0 or status >= ABNF.LENGTH_16:\n            raise ValueError(\"code is invalid range\")\n        self.connected = False\n        self.send(struct.pack(\"!H\", status) + reason, ABNF.OPCODE_CLOSE)\n\n    def close(self, status: int = STATUS_NORMAL, reason: bytes = b\"\", timeout: int = 3):\n        \"\"\"\n        Close Websocket object\n\n        Parameters\n        ----------\n        status: int\n            Status code to send. See VALID_CLOSE_STATUS in ABNF.\n        reason: bytes\n            The reason to close in UTF-8.\n        timeout: int or float\n            Timeout until receive a close frame.\n            If None, it will wait forever until receive a close frame.\n        \"\"\"\n        if not self.connected:\n            return\n        if status < 0 or status >= ABNF.LENGTH_16:\n            raise ValueError(\"code is invalid range\")\n\n        try:\n            self.connected = False\n            self.send(struct.pack(\"!H\", status) + reason, ABNF.OPCODE_CLOSE)\n            sock_timeout = self.sock.gettimeout()\n            self.sock.settimeout(timeout)\n            start_time = time.time()\n            while timeout is None or time.time() - start_time < timeout:\n                try:\n                    frame = self.recv_frame()\n                    if frame.opcode != ABNF.OPCODE_CLOSE:\n                        continue\n                    if isEnabledForError():\n                        recv_status = struct.unpack(\"!H\", frame.data[0:2])[0]\n                        if recv_status >= 3000 and recv_status <= 4999:\n                            debug(f\"close status: {repr(recv_status)}\")\n                        elif recv_status != STATUS_NORMAL:\n                            error(f\"close status: {repr(recv_status)}\")\n                    break\n                except:\n                    break\n            self.sock.settimeout(sock_timeout)\n            self.sock.shutdown(socket.SHUT_RDWR)\n        except:\n            pass\n\n        self.shutdown()\n\n    def abort(self):\n        \"\"\"\n        Low-level asynchronous abort, wakes up other threads that are waiting in recv_*\n        \"\"\"\n        if self.connected:\n            self.sock.shutdown(socket.SHUT_RDWR)\n\n    def shutdown(self):\n        \"\"\"\n        close socket, immediately.\n        \"\"\"\n        if self.sock:\n            self.sock.close()\n            self.sock = None\n            self.connected = False\n\n    def _send(self, data: Union[str, bytes]):\n        return send(self.sock, data)\n\n    def _recv(self, bufsize):\n        try:\n            return recv(self.sock, bufsize)\n        except WebSocketConnectionClosedException:\n            if self.sock:\n                self.sock.close()\n            self.sock = None\n            self.connected = False\n            raise\n\n\ndef create_connection(url: str, timeout=None, class_=WebSocket, **options):\n    \"\"\"\n    Connect to url and return websocket object.\n\n    Connect to url and return the WebSocket object.\n    Passing optional timeout parameter will set the timeout on the socket.\n    If no timeout is supplied,\n    the global default timeout setting returned by getdefaulttimeout() is used.\n    You can customize using 'options'.\n    If you set \"header\" list object, you can set your own custom header.\n\n    >>> conn = create_connection(\"ws://echo.websocket.events\",\n         ...     header=[\"User-Agent: MyProgram\",\n         ...             \"x-custom: header\"])\n\n    Parameters\n    ----------\n    class_: class\n        class to instantiate when creating the connection. It has to implement\n        settimeout and connect. It's __init__ should be compatible with\n        WebSocket.__init__, i.e. accept all of it's kwargs.\n    header: list or dict\n        custom http header list or dict.\n    cookie: str\n        Cookie value.\n    origin: str\n        custom origin url.\n    suppress_origin: bool\n        suppress outputting origin header.\n    host: str\n        custom host header string.\n    timeout: int or float\n        socket timeout time. This value could be either float/integer.\n        If set to None, it uses the default_timeout value.\n    http_proxy_host: str\n        HTTP proxy host name.\n    http_proxy_port: str or int\n        HTTP proxy port. If not set, set to 80.\n    http_no_proxy: list\n        Whitelisted host names that don't use the proxy.\n    http_proxy_auth: tuple\n        HTTP proxy auth information. tuple of username and password. Default is None.\n    http_proxy_timeout: int or float\n        HTTP proxy timeout, default is 60 sec as per python-socks.\n    enable_multithread: bool\n        Enable lock for multithread.\n    redirect_limit: int\n        Number of redirects to follow.\n    sockopt: tuple\n        Values for socket.setsockopt.\n        sockopt must be a tuple and each element is an argument of sock.setsockopt.\n    sslopt: dict\n        Optional dict object for ssl socket options. See FAQ for details.\n    subprotocols: list\n        List of available subprotocols. Default is None.\n    skip_utf8_validation: bool\n        Skip utf8 validation.\n    socket: socket\n        Pre-initialized stream socket.\n    \"\"\"\n    sockopt = options.pop(\"sockopt\", [])\n    sslopt = options.pop(\"sslopt\", {})\n    fire_cont_frame = options.pop(\"fire_cont_frame\", False)\n    enable_multithread = options.pop(\"enable_multithread\", True)\n    skip_utf8_validation = options.pop(\"skip_utf8_validation\", False)\n    websock = class_(\n        sockopt=sockopt,\n        sslopt=sslopt,\n        fire_cont_frame=fire_cont_frame,\n        enable_multithread=enable_multithread,\n        skip_utf8_validation=skip_utf8_validation,\n        **options,\n    )\n    websock.settimeout(timeout if timeout is not None else getdefaulttimeout())\n    websock.connect(url, **options)\n    return websock\n", "examples/echoapp_client.py": "import sys\nimport time\nfrom threading import Thread\n\nimport websocket\n\n\ndef on_message(ws, message):\n    print(message)\n\n\ndef on_error(ws, error):\n    print(error)\n\n\ndef on_close(ws, close_status_code, close_msg):\n    print(\"### closed ###\")\n\n\ndef on_open(ws):\n    def run(*args):\n        for i in range(3):\n            # send the message, then wait\n            # so thread doesn't exit and socket\n            # isn't closed\n            ws.send(\"Hello %d\" % i)\n            time.sleep(1)\n\n        time.sleep(1)\n        ws.close()\n        print(\"Thread terminating...\")\n\n    Thread(target=run).start()\n\n\nif __name__ == \"__main__\":\n    websocket.enableTrace(True)\n    if len(sys.argv) < 2:\n        host = \"ws://echo.websocket.events/\"\n    else:\n        host = sys.argv[1]\n    ws = websocket.WebSocketApp(\n        host, on_message=on_message, on_error=on_error, on_close=on_close\n    )\n    ws.on_open = on_open\n    ws.run_forever()\n", "examples/echo_client.py": "import websocket\n\nif __name__ == \"__main__\":\n    websocket.enableTrace(True)\n    ws = websocket.create_connection(\"ws://echo.websocket.events/\")\n    ws.recv()\n    print(\"Sending 'Hello, World'...\")\n    ws.send(\"Hello, World\")\n    print(\"Sent\")\n    print(\"Receiving...\")\n    result = ws.recv()\n    print(f\"Received '{result}'\")\n    ws.close()\n", "examples/rel_client.py": "import rel\n\nimport websocket\n\naddr = \"wss://api.gemini.com/v1/marketdata/%s\"\n\nif __name__ == \"__main__\":\n    for symbol in [\"BTCUSD\", \"ETHUSD\", \"ETHBTC\"]:\n        ws = websocket.WebSocketApp(addr % (symbol,), on_message=lambda w, m: print(m))\n        ws.run_forever(dispatcher=rel)\n    rel.signal(2, rel.abort)  # Keyboard Interrupt\n    rel.dispatch()\n"}