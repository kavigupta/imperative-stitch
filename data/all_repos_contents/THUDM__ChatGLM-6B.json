{"cli_demo.py": "import os\nimport platform\nimport signal\nfrom transformers import AutoTokenizer, AutoModel\nimport readline\n\ntokenizer = AutoTokenizer.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True)\nmodel = AutoModel.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True).half().cuda()\nmodel = model.eval()\n\nos_name = platform.system()\nclear_command = 'cls' if os_name == 'Windows' else 'clear'\nstop_stream = False\n\n\ndef build_prompt(history):\n    prompt = \"\u6b22\u8fce\u4f7f\u7528 ChatGLM-6B \u6a21\u578b\uff0c\u8f93\u5165\u5185\u5bb9\u5373\u53ef\u8fdb\u884c\u5bf9\u8bdd\uff0cclear \u6e05\u7a7a\u5bf9\u8bdd\u5386\u53f2\uff0cstop \u7ec8\u6b62\u7a0b\u5e8f\"\n    for query, response in history:\n        prompt += f\"\\n\\n\u7528\u6237\uff1a{query}\"\n        prompt += f\"\\n\\nChatGLM-6B\uff1a{response}\"\n    return prompt\n\n\ndef signal_handler(signal, frame):\n    global stop_stream\n    stop_stream = True\n\n\ndef main():\n    history = []\n    global stop_stream\n    print(\"\u6b22\u8fce\u4f7f\u7528 ChatGLM-6B \u6a21\u578b\uff0c\u8f93\u5165\u5185\u5bb9\u5373\u53ef\u8fdb\u884c\u5bf9\u8bdd\uff0cclear \u6e05\u7a7a\u5bf9\u8bdd\u5386\u53f2\uff0cstop \u7ec8\u6b62\u7a0b\u5e8f\")\n    while True:\n        query = input(\"\\n\u7528\u6237\uff1a\")\n        if query.strip() == \"stop\":\n            break\n        if query.strip() == \"clear\":\n            history = []\n            os.system(clear_command)\n            print(\"\u6b22\u8fce\u4f7f\u7528 ChatGLM-6B \u6a21\u578b\uff0c\u8f93\u5165\u5185\u5bb9\u5373\u53ef\u8fdb\u884c\u5bf9\u8bdd\uff0cclear \u6e05\u7a7a\u5bf9\u8bdd\u5386\u53f2\uff0cstop \u7ec8\u6b62\u7a0b\u5e8f\")\n            continue\n        count = 0\n        for response, history in model.stream_chat(tokenizer, query, history=history):\n            if stop_stream:\n                stop_stream = False\n                break\n            else:\n                count += 1\n                if count % 8 == 0:\n                    os.system(clear_command)\n                    print(build_prompt(history), flush=True)\n                    signal.signal(signal.SIGINT, signal_handler)\n        os.system(clear_command)\n        print(build_prompt(history), flush=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "web_demo_vision.py": "from transformers import AutoModel, AutoTokenizer\nimport gradio as gr\nimport mdtex2html\n\ntokenizer = AutoTokenizer.from_pretrained(\"THUDM/visualglm-6b\", trust_remote_code=True)\nmodel = AutoModel.from_pretrained(\"THUDM/visualglm-6b\", trust_remote_code=True).half().cuda()\nmodel = model.eval()\n\n\"\"\"Override Chatbot.postprocess\"\"\"\n\n\ndef postprocess(self, y):\n    if y is None:\n        return []\n    for i, (message, response) in enumerate(y):\n        y[i] = (\n            None if message is None else mdtex2html.convert((message)),\n            None if response is None else mdtex2html.convert(response),\n        )\n    return y\n\n\ngr.Chatbot.postprocess = postprocess\n\n\ndef parse_text(text):\n    \"\"\"copy from https://github.com/GaiZhenbiao/ChuanhuChatGPT/\"\"\"\n    lines = text.split(\"\\n\")\n    lines = [line for line in lines if line != \"\"]\n    count = 0\n    for i, line in enumerate(lines):\n        if \"```\" in line:\n            count += 1\n            items = line.split('`')\n            if count % 2 == 1:\n                lines[i] = f'<pre><code class=\"language-{items[-1]}\">'\n            else:\n                lines[i] = f'<br></code></pre>'\n        else:\n            if i > 0:\n                if count % 2 == 1:\n                    line = line.replace(\"`\", \"\\`\")\n                    line = line.replace(\"<\", \"&lt;\")\n                    line = line.replace(\">\", \"&gt;\")\n                    line = line.replace(\" \", \"&nbsp;\")\n                    line = line.replace(\"*\", \"&ast;\")\n                    line = line.replace(\"_\", \"&lowbar;\")\n                    line = line.replace(\"-\", \"&#45;\")\n                    line = line.replace(\".\", \"&#46;\")\n                    line = line.replace(\"!\", \"&#33;\")\n                    line = line.replace(\"(\", \"&#40;\")\n                    line = line.replace(\")\", \"&#41;\")\n                    line = line.replace(\"$\", \"&#36;\")\n                lines[i] = \"<br>\"+line\n    text = \"\".join(lines)\n    return text\n\n\ndef predict(input, image_path, chatbot, max_length, top_p, temperature, history):\n    if image_path is None:\n        return [(input, \"\u56fe\u7247\u4e3a\u7a7a\uff01\u8bf7\u91cd\u65b0\u4e0a\u4f20\u56fe\u7247\u5e76\u91cd\u8bd5\u3002\")]\n    chatbot.append((parse_text(input), \"\"))\n    for response, history in model.stream_chat(tokenizer, image_path, input, history, max_length=max_length, top_p=top_p,\n                                               temperature=temperature):\n        chatbot[-1] = (parse_text(input), parse_text(response))\n\n        yield chatbot, history\n\n\ndef predict_new_image(image_path, chatbot, max_length, top_p, temperature):\n    input, history = \"\u63cf\u8ff0\u8fd9\u5f20\u56fe\u7247\u3002\", []\n    chatbot.append((parse_text(input), \"\"))\n    for response, history in model.stream_chat(tokenizer, image_path, input, history, max_length=max_length,\n                                               top_p=top_p,\n                                               temperature=temperature):\n        chatbot[-1] = (parse_text(input), parse_text(response))\n\n        yield chatbot, history\n\n\ndef reset_user_input():\n    return gr.update(value='')\n\n\ndef reset_state():\n    return None, [], []\n\n\nwith gr.Blocks() as demo:\n    gr.HTML(\"\"\"<h1 align=\"center\">VisualGLM</h1>\"\"\")\n\n    image_path = gr.Image(type=\"filepath\", label=\"Image Prompt\", value=None)\n    chatbot = gr.Chatbot()\n    with gr.Row():\n        with gr.Column(scale=4):\n            with gr.Column(scale=12):\n                user_input = gr.Textbox(show_label=False, placeholder=\"Input...\", lines=10).style(\n                    container=False)\n            with gr.Column(min_width=32, scale=1):\n                submitBtn = gr.Button(\"Submit\", variant=\"primary\")\n        with gr.Column(scale=1):\n            emptyBtn = gr.Button(\"Clear History\")\n            max_length = gr.Slider(0, 4096, value=2048, step=1.0, label=\"Maximum length\", interactive=True)\n            top_p = gr.Slider(0, 1, value=0.4, step=0.01, label=\"Top P\", interactive=True)\n            temperature = gr.Slider(0, 1, value=0.8, step=0.01, label=\"Temperature\", interactive=True)\n\n    history = gr.State([])\n\n    submitBtn.click(predict, [user_input, image_path, chatbot, max_length, top_p, temperature, history], [chatbot, history],\n                    show_progress=True)\n\n    image_path.upload(predict_new_image, [image_path, chatbot, max_length, top_p, temperature], [chatbot, history],\n                      show_progress=True)\n    image_path.clear(reset_state, outputs=[image_path, chatbot, history], show_progress=True)\n\n    submitBtn.click(reset_user_input, [], [user_input])\n\n    emptyBtn.click(reset_state, outputs=[image_path, chatbot, history], show_progress=True)\n\ndemo.queue().launch(share=False, inbrowser=True)\n", "api.py": "from fastapi import FastAPI, Request\nfrom transformers import AutoTokenizer, AutoModel\nimport uvicorn, json, datetime\nimport torch\n\nDEVICE = \"cuda\"\nDEVICE_ID = \"0\"\nCUDA_DEVICE = f\"{DEVICE}:{DEVICE_ID}\" if DEVICE_ID else DEVICE\n\n\ndef torch_gc():\n    if torch.cuda.is_available():\n        with torch.cuda.device(CUDA_DEVICE):\n            torch.cuda.empty_cache()\n            torch.cuda.ipc_collect()\n\n\napp = FastAPI()\n\n\n@app.post(\"/\")\nasync def create_item(request: Request):\n    global model, tokenizer\n    json_post_raw = await request.json()\n    json_post = json.dumps(json_post_raw)\n    json_post_list = json.loads(json_post)\n    prompt = json_post_list.get('prompt')\n    history = json_post_list.get('history')\n    max_length = json_post_list.get('max_length')\n    top_p = json_post_list.get('top_p')\n    temperature = json_post_list.get('temperature')\n    response, history = model.chat(tokenizer,\n                                   prompt,\n                                   history=history,\n                                   max_length=max_length if max_length else 2048,\n                                   top_p=top_p if top_p else 0.7,\n                                   temperature=temperature if temperature else 0.95)\n    now = datetime.datetime.now()\n    time = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n    answer = {\n        \"response\": response,\n        \"history\": history,\n        \"status\": 200,\n        \"time\": time\n    }\n    log = \"[\" + time + \"] \" + '\", prompt:\"' + prompt + '\", response:\"' + repr(response) + '\"'\n    print(log)\n    torch_gc()\n    return answer\n\n\nif __name__ == '__main__':\n    tokenizer = AutoTokenizer.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True)\n    model = AutoModel.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True).half().cuda()\n    model.eval()\n    uvicorn.run(app, host='0.0.0.0', port=8000, workers=1)\n", "web_demo.py": "from transformers import AutoModel, AutoTokenizer\nimport gradio as gr\nimport mdtex2html\n\ntokenizer = AutoTokenizer.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True)\nmodel = AutoModel.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True).half().cuda()\nmodel = model.eval()\n\n\"\"\"Override Chatbot.postprocess\"\"\"\n\n\ndef postprocess(self, y):\n    if y is None:\n        return []\n    for i, (message, response) in enumerate(y):\n        y[i] = (\n            None if message is None else mdtex2html.convert((message)),\n            None if response is None else mdtex2html.convert(response),\n        )\n    return y\n\n\ngr.Chatbot.postprocess = postprocess\n\n\ndef parse_text(text):\n    \"\"\"copy from https://github.com/GaiZhenbiao/ChuanhuChatGPT/\"\"\"\n    lines = text.split(\"\\n\")\n    lines = [line for line in lines if line != \"\"]\n    count = 0\n    for i, line in enumerate(lines):\n        if \"```\" in line:\n            count += 1\n            items = line.split('`')\n            if count % 2 == 1:\n                lines[i] = f'<pre><code class=\"language-{items[-1]}\">'\n            else:\n                lines[i] = f'<br></code></pre>'\n        else:\n            if i > 0:\n                if count % 2 == 1:\n                    line = line.replace(\"`\", \"\\`\")\n                    line = line.replace(\"<\", \"&lt;\")\n                    line = line.replace(\">\", \"&gt;\")\n                    line = line.replace(\" \", \"&nbsp;\")\n                    line = line.replace(\"*\", \"&ast;\")\n                    line = line.replace(\"_\", \"&lowbar;\")\n                    line = line.replace(\"-\", \"&#45;\")\n                    line = line.replace(\".\", \"&#46;\")\n                    line = line.replace(\"!\", \"&#33;\")\n                    line = line.replace(\"(\", \"&#40;\")\n                    line = line.replace(\")\", \"&#41;\")\n                    line = line.replace(\"$\", \"&#36;\")\n                lines[i] = \"<br>\"+line\n    text = \"\".join(lines)\n    return text\n\n\ndef predict(input, chatbot, max_length, top_p, temperature, history):\n    chatbot.append((parse_text(input), \"\"))\n    for response, history in model.stream_chat(tokenizer, input, history, max_length=max_length, top_p=top_p,\n                                               temperature=temperature):\n        chatbot[-1] = (parse_text(input), parse_text(response))       \n\n        yield chatbot, history\n\n\ndef reset_user_input():\n    return gr.update(value='')\n\n\ndef reset_state():\n    return [], []\n\n\nwith gr.Blocks() as demo:\n    gr.HTML(\"\"\"<h1 align=\"center\">ChatGLM</h1>\"\"\")\n\n    chatbot = gr.Chatbot()\n    with gr.Row():\n        with gr.Column(scale=4):\n            with gr.Column(scale=12):\n                user_input = gr.Textbox(show_label=False, placeholder=\"Input...\", lines=10).style(\n                    container=False)\n            with gr.Column(min_width=32, scale=1):\n                submitBtn = gr.Button(\"Submit\", variant=\"primary\")\n        with gr.Column(scale=1):\n            emptyBtn = gr.Button(\"Clear History\")\n            max_length = gr.Slider(0, 4096, value=2048, step=1.0, label=\"Maximum length\", interactive=True)\n            top_p = gr.Slider(0, 1, value=0.7, step=0.01, label=\"Top P\", interactive=True)\n            temperature = gr.Slider(0, 1, value=0.95, step=0.01, label=\"Temperature\", interactive=True)\n\n    history = gr.State([])\n\n    submitBtn.click(predict, [user_input, chatbot, max_length, top_p, temperature, history], [chatbot, history],\n                    show_progress=True)\n    submitBtn.click(reset_user_input, [], [user_input])\n\n    emptyBtn.click(reset_state, outputs=[chatbot, history], show_progress=True)\n\ndemo.queue().launch(share=False, inbrowser=True)\n", "utils.py": "import os\nfrom typing import Dict, Tuple, Union, Optional\n\nfrom torch.nn import Module\nfrom transformers import AutoModel\n\n\ndef auto_configure_device_map(num_gpus: int) -> Dict[str, int]:\n    # transformer.word_embeddings \u5360\u75281\u5c42\n    # transformer.final_layernorm \u548c lm_head \u5360\u75281\u5c42\n    # transformer.layers \u5360\u7528 28 \u5c42\n    # \u603b\u517130\u5c42\u5206\u914d\u5230num_gpus\u5f20\u5361\u4e0a\n    num_trans_layers = 28\n    per_gpu_layers = 30 / num_gpus\n\n    # bugfix: \u5728linux\u4e2d\u8c03\u7528torch.embedding\u4f20\u5165\u7684weight,input\u4e0d\u5728\u540c\u4e00device\u4e0a,\u5bfc\u81f4RuntimeError\n    # windows\u4e0b model.device \u4f1a\u88ab\u8bbe\u7f6e\u6210 transformer.word_embeddings.device\n    # linux\u4e0b model.device \u4f1a\u88ab\u8bbe\u7f6e\u6210 lm_head.device\n    # \u5728\u8c03\u7528chat\u6216\u8005stream_chat\u65f6,input_ids\u4f1a\u88ab\u653e\u5230model.device\u4e0a\n    # \u5982\u679ctransformer.word_embeddings.device\u548cmodel.device\u4e0d\u540c,\u5219\u4f1a\u5bfc\u81f4RuntimeError\n    # \u56e0\u6b64\u8fd9\u91cc\u5c06transformer.word_embeddings,transformer.final_layernorm,lm_head\u90fd\u653e\u5230\u7b2c\u4e00\u5f20\u5361\u4e0a\n    device_map = {'transformer.word_embeddings': 0,\n                  'transformer.final_layernorm': 0, 'lm_head': 0}\n\n    used = 2\n    gpu_target = 0\n    for i in range(num_trans_layers):\n        if used >= per_gpu_layers:\n            gpu_target += 1\n            used = 0\n        assert gpu_target < num_gpus\n        device_map[f'transformer.layers.{i}'] = gpu_target\n        used += 1\n\n    return device_map\n\n\ndef load_model_on_gpus(checkpoint_path: Union[str, os.PathLike], num_gpus: int = 2,\n                       device_map: Optional[Dict[str, int]] = None, **kwargs) -> Module:\n    if num_gpus < 2 and device_map is None:\n        model = AutoModel.from_pretrained(checkpoint_path, trust_remote_code=True, **kwargs).half().cuda()\n    else:\n        from accelerate import dispatch_model\n\n        model = AutoModel.from_pretrained(checkpoint_path, trust_remote_code=True, **kwargs).half()\n\n        if device_map is None:\n            device_map = auto_configure_device_map(num_gpus)\n\n        model = dispatch_model(model, device_map=device_map)\n\n    return model\n\n\n", "cli_demo_vision.py": "import os\nimport platform\nimport signal\nimport sys\n\nfrom transformers import AutoTokenizer, AutoModel\nimport readline\n\ntokenizer = AutoTokenizer.from_pretrained(\"THUDM/visualglm-6b\", trust_remote_code=True)\nmodel = AutoModel.from_pretrained(\"THUDM/visualglm-6b\", trust_remote_code=True).half().cuda()\nmodel = model.eval()\n\nos_name = platform.system()\nclear_command = 'cls' if os_name == 'Windows' else 'clear'\nstop_stream = False\n\n\ndef build_prompt(history, prefix):\n    prompt = prefix\n    for query, response in history:\n        prompt += f\"\\n\\n\u7528\u6237\uff1a{query}\"\n        prompt += f\"\\n\\nChatGLM-6B\uff1a{response}\"\n    return prompt\n\n\ndef signal_handler(signal, frame):\n    global stop_stream\n    stop_stream = True\n\n\ndef main():\n    global stop_stream\n    while True:\n        history = []\n        prefix = \"\u6b22\u8fce\u4f7f\u7528 VisualGLM-6B \u6a21\u578b\uff0c\u8f93\u5165\u56fe\u7247\u8def\u5f84\u548c\u5185\u5bb9\u5373\u53ef\u8fdb\u884c\u5bf9\u8bdd\uff0cclear \u6e05\u7a7a\u5bf9\u8bdd\u5386\u53f2\uff0cstop \u7ec8\u6b62\u7a0b\u5e8f\"\n        print(prefix)\n        image_path = input(\"\\n\u8bf7\u8f93\u5165\u56fe\u7247\u8def\u5f84\uff1a\")\n        if image_path == \"stop\":\n            break\n        prefix = prefix + \"\\n\" + image_path\n        query = \"\u63cf\u8ff0\u8fd9\u5f20\u56fe\u7247\u3002\"\n        while True:\n            count = 0\n            for response, history in model.stream_chat(tokenizer, image_path, query, history=history):\n                if stop_stream:\n                    stop_stream = False\n                    break\n                else:\n                    count += 1\n                    if count % 8 == 0:\n                        os.system(clear_command)\n                        print(build_prompt(history, prefix), flush=True)\n                        signal.signal(signal.SIGINT, signal_handler)\n            os.system(clear_command)\n            print(build_prompt(history, prefix), flush=True)\n            query = input(\"\\n\u7528\u6237\uff1a\")\n            if query.strip() == \"clear\":\n                break\n            if query.strip() == \"stop\":\n                sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n", "web_demo2.py": "from transformers import AutoModel, AutoTokenizer\nimport streamlit as st\nfrom streamlit_chat import message\n\n\nst.set_page_config(\n    page_title=\"ChatGLM-6b \u6f14\u793a\",\n    page_icon=\":robot:\"\n)\n\n\n@st.cache_resource\ndef get_model():\n    tokenizer = AutoTokenizer.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True)\n    model = AutoModel.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True).half().cuda()\n    model = model.eval()\n    return tokenizer, model\n\n\nMAX_TURNS = 20\nMAX_BOXES = MAX_TURNS * 2\n\n\ndef predict(input, max_length, top_p, temperature, history=None):\n    tokenizer, model = get_model()\n    if history is None:\n        history = []\n\n    with container:\n        if len(history) > 0:\n            if len(history)>MAX_BOXES:\n                history = history[-MAX_TURNS:]\n            for i, (query, response) in enumerate(history):\n                message(query, avatar_style=\"big-smile\", key=str(i) + \"_user\")\n                message(response, avatar_style=\"bottts\", key=str(i))\n\n        message(input, avatar_style=\"big-smile\", key=str(len(history)) + \"_user\")\n        st.write(\"AI\u6b63\u5728\u56de\u590d:\")\n        with st.empty():\n            for response, history in model.stream_chat(tokenizer, input, history, max_length=max_length, top_p=top_p,\n                                               temperature=temperature):\n                query, response = history[-1]\n                st.write(response)\n\n    return history\n\n\ncontainer = st.container()\n\n# create a prompt text for the text generation\nprompt_text = st.text_area(label=\"\u7528\u6237\u547d\u4ee4\u8f93\u5165\",\n            height = 100,\n            placeholder=\"\u8bf7\u5728\u8fd9\u513f\u8f93\u5165\u60a8\u7684\u547d\u4ee4\")\n\nmax_length = st.sidebar.slider(\n    'max_length', 0, 4096, 2048, step=1\n)\ntop_p = st.sidebar.slider(\n    'top_p', 0.0, 1.0, 0.6, step=0.01\n)\ntemperature = st.sidebar.slider(\n    'temperature', 0.0, 1.0, 0.95, step=0.01\n)\n\nif 'state' not in st.session_state:\n    st.session_state['state'] = []\n\nif st.button(\"\u53d1\u9001\", key=\"predict\"):\n    with st.spinner(\"AI\u6b63\u5728\u601d\u8003\uff0c\u8bf7\u7a0d\u7b49........\"):\n        # text generation\n        st.session_state[\"state\"] = predict(prompt_text, max_length, top_p, temperature, st.session_state[\"state\"])\n", "web_demo_old.py": "from transformers import AutoModel, AutoTokenizer\nimport gradio as gr\n\ntokenizer = AutoTokenizer.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True)\nmodel = AutoModel.from_pretrained(\"THUDM/chatglm-6b\", trust_remote_code=True).half().cuda()\nmodel = model.eval()\n\nMAX_TURNS = 20\nMAX_BOXES = MAX_TURNS * 2\n\n\ndef predict(input, max_length, top_p, temperature, history=None):\n    if history is None:\n        history = []\n    for response, history in model.stream_chat(tokenizer, input, history, max_length=max_length, top_p=top_p,\n                                               temperature=temperature):\n        updates = []\n        for query, response in history:\n            updates.append(gr.update(visible=True, value=\"\u7528\u6237\uff1a\" + query))\n            updates.append(gr.update(visible=True, value=\"ChatGLM-6B\uff1a\" + response))\n        if len(updates) < MAX_BOXES:\n            updates = updates + [gr.Textbox.update(visible=False)] * (MAX_BOXES - len(updates))\n        yield [history] + updates\n\n\nwith gr.Blocks() as demo:\n    state = gr.State([])\n    text_boxes = []\n    for i in range(MAX_BOXES):\n        if i % 2 == 0:\n            text_boxes.append(gr.Markdown(visible=False, label=\"\u63d0\u95ee\uff1a\"))\n        else:\n            text_boxes.append(gr.Markdown(visible=False, label=\"\u56de\u590d\uff1a\"))\n\n    with gr.Row():\n        with gr.Column(scale=4):\n            txt = gr.Textbox(show_label=False, placeholder=\"Enter text and press enter\", lines=11).style(\n                container=False)\n        with gr.Column(scale=1):\n            max_length = gr.Slider(0, 4096, value=2048, step=1.0, label=\"Maximum length\", interactive=True)\n            top_p = gr.Slider(0, 1, value=0.7, step=0.01, label=\"Top P\", interactive=True)\n            temperature = gr.Slider(0, 1, value=0.95, step=0.01, label=\"Temperature\", interactive=True)\n            button = gr.Button(\"Generate\")\n    button.click(predict, [txt, max_length, top_p, temperature, state], [state] + text_boxes)\ndemo.queue().launch(share=False, inbrowser=True)\n", "ptuning/trainer.py": "# coding=utf-8\n# Copyright 2020-present the HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nThe Trainer class, to easily train a \ud83e\udd17 Transformers from scratch or finetune it on a new task.\n\"\"\"\n\nimport contextlib\nimport functools\nimport glob\nimport inspect\nimport math\nimport os\nimport random\nimport re\nimport shutil\nimport sys\nimport time\nimport warnings\nfrom collections.abc import Mapping\nfrom distutils.util import strtobool\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom tqdm.auto import tqdm\n\n\n# Integrations must be imported before ML frameworks:\n# isort: off\nfrom transformers.integrations import (\n    default_hp_search_backend,\n    get_reporting_integration_callbacks,\n    hp_params,\n    is_fairscale_available,\n    is_optuna_available,\n    is_ray_tune_available,\n    is_sigopt_available,\n    is_wandb_available,\n    run_hp_search_optuna,\n    run_hp_search_ray,\n    run_hp_search_sigopt,\n    run_hp_search_wandb,\n)\n\n# isort: on\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\nfrom huggingface_hub import Repository, create_repo\nfrom packaging import version\nfrom torch import nn\nfrom torch.utils.data import DataLoader, Dataset, RandomSampler, SequentialSampler\nfrom torch.utils.data.distributed import DistributedSampler\n\nfrom transformers import __version__\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.data.data_collator import DataCollator, DataCollatorWithPadding, default_data_collator\nfrom transformers.debug_utils import DebugOption, DebugUnderflowOverflow\nfrom transformers.deepspeed import deepspeed_init, is_deepspeed_zero3_enabled\nfrom transformers.dependency_versions_check import dep_version_check\nfrom transformers.modelcard import TrainingSummary\nfrom transformers.modeling_utils import PreTrainedModel, load_sharded_checkpoint, unwrap_model\nfrom transformers.models.auto.modeling_auto import MODEL_FOR_CAUSAL_LM_MAPPING_NAMES, MODEL_MAPPING_NAMES\nfrom transformers.optimization import Adafactor, get_scheduler\nfrom transformers.pytorch_utils import ALL_LAYERNORM_LAYERS, is_torch_greater_or_equal_than_1_10, is_torch_less_than_1_11\nfrom transformers.tokenization_utils_base import PreTrainedTokenizerBase\nfrom transformers.trainer_callback import (\n    CallbackHandler,\n    DefaultFlowCallback,\n    PrinterCallback,\n    ProgressCallback,\n    TrainerCallback,\n    TrainerControl,\n    TrainerState,\n)\nfrom transformers.trainer_pt_utils import (\n    DistributedLengthGroupedSampler,\n    DistributedSamplerWithLoop,\n    DistributedTensorGatherer,\n    IterableDatasetShard,\n    LabelSmoother,\n    LengthGroupedSampler,\n    SequentialDistributedSampler,\n    ShardSampler,\n    distributed_broadcast_scalars,\n    distributed_concat,\n    find_batch_size,\n    get_module_class_from_name,\n    get_parameter_names,\n    nested_concat,\n    nested_detach,\n    nested_numpify,\n    nested_truncate,\n    nested_xla_mesh_reduce,\n    reissue_pt_warnings,\n)\nfrom transformers.trainer_utils import (\n    PREFIX_CHECKPOINT_DIR,\n    BestRun,\n    EvalLoopOutput,\n    EvalPrediction,\n    FSDPOption,\n    HPSearchBackend,\n    HubStrategy,\n    IntervalStrategy,\n    PredictionOutput,\n    RemoveColumnsCollator,\n    ShardedDDPOption,\n    TrainerMemoryTracker,\n    TrainOutput,\n    default_compute_objective,\n    default_hp_space,\n    denumpify_detensorize,\n    enable_full_determinism,\n    find_executable_batch_size,\n    get_last_checkpoint,\n    has_length,\n    number_of_arguments,\n    seed_worker,\n    set_seed,\n    speed_metrics,\n)\nfrom transformers.training_args import OptimizerNames, ParallelMode, TrainingArguments\nfrom transformers.utils import (\n    CONFIG_NAME,\n    WEIGHTS_INDEX_NAME,\n    WEIGHTS_NAME,\n    can_return_loss,\n    find_labels,\n    get_full_repo_name,\n    is_accelerate_available,\n    is_apex_available,\n    is_datasets_available,\n    is_in_notebook,\n    is_ipex_available,\n    is_sagemaker_dp_enabled,\n    is_sagemaker_mp_enabled,\n    is_torch_compile_available,\n    is_torch_neuroncore_available,\n    is_torch_tpu_available,\n    logging,\n)\nfrom transformers.utils.generic import ContextManagers\n\n\n_is_native_cpu_amp_available = is_torch_greater_or_equal_than_1_10\n\nDEFAULT_CALLBACKS = [DefaultFlowCallback]\nDEFAULT_PROGRESS_CALLBACK = ProgressCallback\n\nif is_in_notebook():\n    from transformers.utils.notebook import NotebookProgressCallback\n\n    DEFAULT_PROGRESS_CALLBACK = NotebookProgressCallback\n\nif is_apex_available():\n    from apex import amp\n\nif is_datasets_available():\n    import datasets\n\nif is_torch_tpu_available(check_device=False):\n    import torch_xla.core.xla_model as xm\n    import torch_xla.debug.metrics as met\n    import torch_xla.distributed.parallel_loader as pl\n\nif is_fairscale_available():\n    dep_version_check(\"fairscale\")\n    import fairscale\n    from fairscale.nn.data_parallel import FullyShardedDataParallel as FullyShardedDDP\n    from fairscale.nn.data_parallel import ShardedDataParallel as ShardedDDP\n    from fairscale.nn.wrap import auto_wrap\n    from fairscale.optim import OSS\n    from fairscale.optim.grad_scaler import ShardedGradScaler\n\n\nif is_sagemaker_mp_enabled():\n    import smdistributed.modelparallel.torch as smp\n    from smdistributed.modelparallel import __version__ as SMP_VERSION\n\n    IS_SAGEMAKER_MP_POST_1_10 = version.parse(SMP_VERSION) >= version.parse(\"1.10\")\n\n    from transformers.trainer_pt_utils import smp_forward_backward, smp_forward_only, smp_gather, smp_nested_concat\nelse:\n    IS_SAGEMAKER_MP_POST_1_10 = False\n\n\nskip_first_batches = None\nif is_accelerate_available():\n    from accelerate import __version__ as accelerate_version\n\n    if version.parse(accelerate_version) >= version.parse(\"0.16\"):\n        from accelerate import skip_first_batches\n\n\nif TYPE_CHECKING:\n    import optuna\n\nlogger = logging.get_logger(__name__)\n\n\n# Name of the files used for checkpointing\nTRAINING_ARGS_NAME = \"training_args.bin\"\nTRAINER_STATE_NAME = \"trainer_state.json\"\nOPTIMIZER_NAME = \"optimizer.pt\"\nSCHEDULER_NAME = \"scheduler.pt\"\nSCALER_NAME = \"scaler.pt\"\n\n\nclass Trainer:\n    \"\"\"\n    Trainer is a simple but feature-complete training and eval loop for PyTorch, optimized for \ud83e\udd17 Transformers.\n\n    Args:\n        model ([`PreTrainedModel`] or `torch.nn.Module`, *optional*):\n            The model to train, evaluate or use for predictions. If not provided, a `model_init` must be passed.\n\n            <Tip>\n\n            [`Trainer`] is optimized to work with the [`PreTrainedModel`] provided by the library. You can still use\n            your own models defined as `torch.nn.Module` as long as they work the same way as the \ud83e\udd17 Transformers\n            models.\n\n            </Tip>\n\n        args ([`TrainingArguments`], *optional*):\n            The arguments to tweak for training. Will default to a basic instance of [`TrainingArguments`] with the\n            `output_dir` set to a directory named *tmp_trainer* in the current directory if not provided.\n        data_collator (`DataCollator`, *optional*):\n            The function to use to form a batch from a list of elements of `train_dataset` or `eval_dataset`. Will\n            default to [`default_data_collator`] if no `tokenizer` is provided, an instance of\n            [`DataCollatorWithPadding`] otherwise.\n        train_dataset (`torch.utils.data.Dataset` or `torch.utils.data.IterableDataset`, *optional*):\n            The dataset to use for training. If it is a [`~datasets.Dataset`], columns not accepted by the\n            `model.forward()` method are automatically removed.\n\n            Note that if it's a `torch.utils.data.IterableDataset` with some randomization and you are training in a\n            distributed fashion, your iterable dataset should either use a internal attribute `generator` that is a\n            `torch.Generator` for the randomization that must be identical on all processes (and the Trainer will\n            manually set the seed of this `generator` at each epoch) or have a `set_epoch()` method that internally\n            sets the seed of the RNGs used.\n        eval_dataset (Union[`torch.utils.data.Dataset`, Dict[str, `torch.utils.data.Dataset`]), *optional*):\n             The dataset to use for evaluation. If it is a [`~datasets.Dataset`], columns not accepted by the\n             `model.forward()` method are automatically removed. If it is a dictionary, it will evaluate on each\n             dataset prepending the dictionary key to the metric name.\n        tokenizer ([`PreTrainedTokenizerBase`], *optional*):\n            The tokenizer used to preprocess the data. If provided, will be used to automatically pad the inputs to the\n            maximum length when batching inputs, and it will be saved along the model to make it easier to rerun an\n            interrupted training or reuse the fine-tuned model.\n        model_init (`Callable[[], PreTrainedModel]`, *optional*):\n            A function that instantiates the model to be used. If provided, each call to [`~Trainer.train`] will start\n            from a new instance of the model as given by this function.\n\n            The function may have zero argument, or a single one containing the optuna/Ray Tune/SigOpt trial object, to\n            be able to choose different architectures according to hyper parameters (such as layer count, sizes of\n            inner layers, dropout probabilities etc).\n        compute_metrics (`Callable[[EvalPrediction], Dict]`, *optional*):\n            The function that will be used to compute metrics at evaluation. Must take a [`EvalPrediction`] and return\n            a dictionary string to metric values.\n        callbacks (List of [`TrainerCallback`], *optional*):\n            A list of callbacks to customize the training loop. Will add those to the list of default callbacks\n            detailed in [here](callback).\n\n            If you want to remove one of the default callbacks used, use the [`Trainer.remove_callback`] method.\n        optimizers (`Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR]`, *optional*): A tuple\n            containing the optimizer and the scheduler to use. Will default to an instance of [`AdamW`] on your model\n            and a scheduler given by [`get_linear_schedule_with_warmup`] controlled by `args`.\n        preprocess_logits_for_metrics (`Callable[[torch.Tensor, torch.Tensor], torch.Tensor]`, *optional*):\n            A function that preprocess the logits right before caching them at each evaluation step. Must take two\n            tensors, the logits and the labels, and return the logits once processed as desired. The modifications made\n            by this function will be reflected in the predictions received by `compute_metrics`.\n\n            Note that the labels (second parameter) will be `None` if the dataset does not have them.\n\n    Important attributes:\n\n        - **model** -- Always points to the core model. If using a transformers model, it will be a [`PreTrainedModel`]\n          subclass.\n        - **model_wrapped** -- Always points to the most external model in case one or more other modules wrap the\n          original model. This is the model that should be used for the forward pass. For example, under `DeepSpeed`,\n          the inner model is wrapped in `DeepSpeed` and then again in `torch.nn.DistributedDataParallel`. If the inner\n          model hasn't been wrapped, then `self.model_wrapped` is the same as `self.model`.\n        - **is_model_parallel** -- Whether or not a model has been switched to a model parallel mode (different from\n          data parallelism, this means some of the model layers are split on different GPUs).\n        - **place_model_on_device** -- Whether or not to automatically place the model on the device - it will be set\n          to `False` if model parallel or deepspeed is used, or if the default\n          `TrainingArguments.place_model_on_device` is overridden to return `False` .\n        - **is_in_train** -- Whether or not a model is currently running `train` (e.g. when `evaluate` is called while\n          in `train`)\n\n    \"\"\"\n\n    from transformers.trainer_pt_utils import _get_learning_rate, log_metrics, metrics_format, save_metrics, save_state\n\n    def __init__(\n        self,\n        model: Union[PreTrainedModel, nn.Module] = None,\n        args: TrainingArguments = None,\n        data_collator: Optional[DataCollator] = None,\n        train_dataset: Optional[Dataset] = None,\n        eval_dataset: Optional[Union[Dataset, Dict[str, Dataset]]] = None,\n        tokenizer: Optional[PreTrainedTokenizerBase] = None,\n        model_init: Optional[Callable[[], PreTrainedModel]] = None,\n        compute_metrics: Optional[Callable[[EvalPrediction], Dict]] = None,\n        callbacks: Optional[List[TrainerCallback]] = None,\n        optimizers: Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR] = (None, None),\n        preprocess_logits_for_metrics: Optional[Callable[[torch.Tensor, torch.Tensor], torch.Tensor]] = None,\n        save_prefixencoder: bool = False,\n    ):\n        self.save_prefixencoder = save_prefixencoder\n        if args is None:\n            output_dir = \"tmp_trainer\"\n            logger.info(f\"No `TrainingArguments` passed, using `output_dir={output_dir}`.\")\n            args = TrainingArguments(output_dir=output_dir)\n        self.args = args\n        # Seed must be set before instantiating the model when using model\n        enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n        self.hp_name = None\n        self.deepspeed = None\n        self.is_in_train = False\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker = TrainerMemoryTracker(self.args.skip_memory_metrics)\n        self._memory_tracker.start()\n\n        # set the correct log level depending on the node\n        log_level = args.get_process_log_level()\n        logging.set_verbosity(log_level)\n\n        # force device and distributed setup init explicitly\n        args._setup_devices\n\n        if model is None:\n            if model_init is not None:\n                self.model_init = model_init\n                model = self.call_model_init()\n            else:\n                raise RuntimeError(\"`Trainer` requires either a `model` or `model_init` argument\")\n        else:\n            if model_init is not None:\n                warnings.warn(\n                    \"`Trainer` requires either a `model` or `model_init` argument, but not both. `model_init` will\"\n                    \" overwrite your model when calling the `train` method. This will become a fatal error in the next\"\n                    \" release.\",\n                    FutureWarning,\n                )\n            self.model_init = model_init\n\n        if model.__class__.__name__ in MODEL_MAPPING_NAMES:\n            raise ValueError(\n                f\"The model you have picked ({model.__class__.__name__}) cannot be used as is for training: it only \"\n                \"computes hidden states and does not accept any labels. You should choose a model with a head \"\n                \"suitable for your task like any of the `AutoModelForXxx` listed at \"\n                \"https://huggingface.co/docs/transformers/model_doc/auto.\"\n            )\n\n        if hasattr(model, \"is_parallelizable\") and model.is_parallelizable and model.model_parallel:\n            self.is_model_parallel = True\n        else:\n            self.is_model_parallel = False\n\n        # At this stage the model is already loaded\n        if getattr(model, \"is_loaded_in_8bit\", False):\n            if getattr(model, \"_is_int8_training_enabled\", False):\n                logger.info(\n                    \"The model is loaded in 8-bit precision. To train this model you need to add additional modules\"\n                    \" inside the model such as adapters using `peft` library and freeze the model weights. Please\"\n                    \" check \"\n                    \" the examples in https://github.com/huggingface/peft for more details.\"\n                )\n            else:\n                raise ValueError(\n                    \"The model you want to train is loaded in 8-bit precision.  if you want to fine-tune an 8-bit\"\n                    \" model, please make sure that you have installed `bitsandbytes>=0.37.0`. \"\n                )\n\n        # Setup Sharded DDP training\n        self.sharded_ddp = None\n        if len(args.sharded_ddp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if len(args.fsdp) > 0:\n                raise ValueError(\n                    \"Using --sharded_ddp xxx together with --fsdp is not possible, deactivate one of those flags.\"\n                )\n\n            if args.local_rank == -1:\n                raise ValueError(\"Using sharded DDP only works in distributed training.\")\n            elif not is_fairscale_available():\n                raise ImportError(\"Sharded DDP training requires fairscale: `pip install fairscale`.\")\n            elif ShardedDDPOption.SIMPLE not in args.sharded_ddp and FullyShardedDDP is None:\n                raise ImportError(\n                    \"Sharded DDP in a mode other than simple training requires fairscale version >= 0.3, found \"\n                    f\"{fairscale.__version__}. Upgrade your fairscale library: `pip install --upgrade fairscale`.\"\n                )\n            elif ShardedDDPOption.SIMPLE in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.SIMPLE\n            elif ShardedDDPOption.ZERO_DP_2 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_2\n            elif ShardedDDPOption.ZERO_DP_3 in args.sharded_ddp:\n                self.sharded_ddp = ShardedDDPOption.ZERO_DP_3\n\n        self.fsdp = None\n        if len(args.fsdp) > 0:\n            if args.deepspeed:\n                raise ValueError(\n                    \"Using --fsdp xxx together with --deepspeed is not possible, deactivate one of those flags.\"\n                )\n            if not args.fsdp_config[\"xla\"] and args.local_rank == -1:\n                raise ValueError(\"Using fsdp only works in distributed training.\")\n\n            # dep_version_check(\"torch>=1.12.0\")\n            # Would have to update setup.py with torch>=1.12.0\n            # which isn't ideally given that it will force people not using FSDP to also use torch>=1.12.0\n            # below is the current alternative.\n            if version.parse(version.parse(torch.__version__).base_version) < version.parse(\"1.12.0\"):\n                raise ValueError(\"FSDP requires PyTorch >= 1.12.0\")\n\n            from torch.distributed.fsdp.fully_sharded_data_parallel import BackwardPrefetch, ShardingStrategy\n\n            if FSDPOption.FULL_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.FULL_SHARD\n            elif FSDPOption.SHARD_GRAD_OP in args.fsdp:\n                self.fsdp = ShardingStrategy.SHARD_GRAD_OP\n            elif FSDPOption.NO_SHARD in args.fsdp:\n                self.fsdp = ShardingStrategy.NO_SHARD\n\n            self.backward_prefetch = BackwardPrefetch.BACKWARD_PRE\n            if \"backward_prefetch\" in self.args.fsdp_config and \"backward_pos\" not in self.backward_prefetch:\n                self.backward_prefetch = BackwardPrefetch.BACKWARD_POST\n\n            self.forword_prefetch = False\n            if self.args.fsdp_config.get(\"forword_prefect\", False):\n                self.forword_prefetch = True\n\n            self.limit_all_gathers = False\n            if self.args.fsdp_config.get(\"limit_all_gathers\", False):\n                self.limit_all_gathers = True\n\n        # one place to sort out whether to place the model on device or not\n        # postpone switching model to cuda when:\n        # 1. MP - since we are trying to fit a much bigger than 1 gpu model\n        # 2. fp16-enabled DeepSpeed loads the model in half the size and it doesn't need .to() anyway,\n        #    and we only use deepspeed for training at the moment\n        # 3. full bf16 or fp16 eval - since the model needs to be cast to the right dtype first\n        # 4. Sharded DDP - same as MP\n        # 5. FSDP - same as MP\n        self.place_model_on_device = args.place_model_on_device\n        if (\n            self.is_model_parallel\n            or args.deepspeed\n            or ((args.fp16_full_eval or args.bf16_full_eval) and not args.do_train)\n            or (self.sharded_ddp in [ShardedDDPOption.ZERO_DP_2, ShardedDDPOption.ZERO_DP_3])\n            or (self.fsdp is not None)\n        ):\n            self.place_model_on_device = False\n\n        default_collator = default_data_collator if tokenizer is None else DataCollatorWithPadding(tokenizer)\n        self.data_collator = data_collator if data_collator is not None else default_collator\n        self.train_dataset = train_dataset\n        self.eval_dataset = eval_dataset\n        self.tokenizer = tokenizer\n\n        if self.place_model_on_device and not getattr(model, \"is_loaded_in_8bit\", False):\n            self._move_model_to_device(model, args.device)\n\n        # Force n_gpu to 1 to avoid DataParallel as MP will manage the GPUs\n        if self.is_model_parallel:\n            self.args._n_gpu = 1\n\n        # later use `self.model is self.model_wrapped` to check if it's wrapped or not\n        self.model_wrapped = model\n        self.model = model\n\n        self.compute_metrics = compute_metrics\n        self.preprocess_logits_for_metrics = preprocess_logits_for_metrics\n        self.optimizer, self.lr_scheduler = optimizers\n        if model_init is not None and (self.optimizer is not None or self.lr_scheduler is not None):\n            raise RuntimeError(\n                \"Passing a `model_init` is incompatible with providing the `optimizers` argument. \"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        if is_torch_tpu_available() and self.optimizer is not None:\n            for param in self.model.parameters():\n                model_device = param.device\n                break\n            for param_group in self.optimizer.param_groups:\n                if len(param_group[\"params\"]) > 0:\n                    optimizer_device = param_group[\"params\"][0].device\n                    break\n            if model_device != optimizer_device:\n                raise ValueError(\n                    \"The model and the optimizer parameters are not on the same device, which probably means you\"\n                    \" created an optimizer around your model **before** putting on the device and passing it to the\"\n                    \" `Trainer`. Make sure the lines `import torch_xla.core.xla_model as xm` and\"\n                    \" `model.to(xm.xla_device())` is performed before the optimizer creation in your script.\"\n                )\n        if ((self.sharded_ddp is not None) or args.deepspeed or (self.fsdp is not None)) and (\n            self.optimizer is not None or self.lr_scheduler is not None\n        ):\n            raise RuntimeError(\n                \"Passing `optimizers` is not allowed if Fairscale, Deepspeed or PyTorch FSDP is enabled.\"\n                \"You should subclass `Trainer` and override the `create_optimizer_and_scheduler` method.\"\n            )\n        default_callbacks = DEFAULT_CALLBACKS + get_reporting_integration_callbacks(self.args.report_to)\n        callbacks = default_callbacks if callbacks is None else default_callbacks + callbacks\n        self.callback_handler = CallbackHandler(\n            callbacks, self.model, self.tokenizer, self.optimizer, self.lr_scheduler\n        )\n        self.add_callback(PrinterCallback if self.args.disable_tqdm else DEFAULT_PROGRESS_CALLBACK)\n\n        # Will be set to True by `self._setup_loggers()` on first call to `self.log()`.\n        self._loggers_initialized = False\n\n        # Create clone of distant repo and output directory if needed\n        if self.args.push_to_hub:\n            self.init_git_repo(at_init=True)\n            # In case of pull, we need to make sure every process has the latest.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"init git repo\")\n            elif args.local_rank != -1:\n                dist.barrier()\n\n        if self.args.should_save:\n            os.makedirs(self.args.output_dir, exist_ok=True)\n\n        if not callable(self.data_collator) and callable(getattr(self.data_collator, \"collate_batch\", None)):\n            raise ValueError(\"The `data_collator` should be a simple callable (function, class with `__call__`).\")\n\n        if args.max_steps > 0:\n            logger.info(\"max_steps is given, it will override any value given in num_train_epochs\")\n\n        if train_dataset is not None and not has_length(train_dataset) and args.max_steps <= 0:\n            raise ValueError(\"train_dataset does not implement __len__, max_steps has to be specified\")\n\n        if (\n            train_dataset is not None\n            and isinstance(train_dataset, torch.utils.data.IterableDataset)\n            and args.group_by_length\n        ):\n            raise ValueError(\"the `--group_by_length` option is only available for `Dataset`, not `IterableDataset\")\n\n        self._signature_columns = None\n\n        # Mixed precision setup\n        self.use_apex = False\n        self.use_cuda_amp = False\n        self.use_cpu_amp = False\n\n        # Mixed precision setup for SageMaker Model Parallel\n        if is_sagemaker_mp_enabled():\n            # BF16 + model parallelism in SageMaker: currently not supported, raise an error\n            if args.bf16:\n                raise ValueError(\"SageMaker Model Parallelism does not support BF16 yet. Please use FP16 instead \")\n\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # When there's mismatch between SMP config and trainer argument, use SMP config as truth\n                if args.fp16 != smp.state.cfg.fp16:\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16},\"\n                        f\"but FP16 provided in trainer argument is {args.fp16},\"\n                        f\"setting to {smp.state.cfg.fp16}\"\n                    )\n                    args.fp16 = smp.state.cfg.fp16\n            else:\n                # smp < 1.10 does not support fp16 in trainer.\n                if hasattr(smp.state.cfg, \"fp16\"):\n                    logger.warning(\n                        f\"FP16 provided in SM_HP_MP_PARAMETERS is {smp.state.cfg.fp16}, \"\n                        \"but SageMaker Model Parallelism < 1.10 does not support FP16 in trainer.\"\n                    )\n\n        if args.fp16 or args.bf16:\n            if args.half_precision_backend == \"auto\":\n                if args.device == torch.device(\"cpu\"):\n                    if args.fp16:\n                        raise ValueError(\"Tried to use `fp16` but it is not supported on cpu\")\n                    elif _is_native_cpu_amp_available:\n                        args.half_precision_backend = \"cpu_amp\"\n                    else:\n                        raise ValueError(\"Tried to use cpu amp but native cpu amp is not available\")\n                else:\n                    args.half_precision_backend = \"cuda_amp\"\n\n            logger.info(f\"Using {args.half_precision_backend} half precision backend\")\n\n        self.do_grad_scaling = False\n        if (args.fp16 or args.bf16) and not (args.deepspeed or is_sagemaker_mp_enabled() or is_torch_tpu_available()):\n            # deepspeed and SageMaker Model Parallel manage their own half precision\n            if args.half_precision_backend == \"cuda_amp\":\n                self.use_cuda_amp = True\n                self.amp_dtype = torch.float16 if args.fp16 else torch.bfloat16\n                #  bf16 does not need grad scaling\n                self.do_grad_scaling = self.amp_dtype == torch.float16\n                if self.do_grad_scaling:\n                    if self.sharded_ddp is not None:\n                        self.scaler = ShardedGradScaler()\n                    elif self.fsdp is not None:\n                        from torch.distributed.fsdp.sharded_grad_scaler import (\n                            ShardedGradScaler as FSDPShardedGradScaler,\n                        )\n\n                        self.scaler = FSDPShardedGradScaler()\n                    elif is_torch_tpu_available():\n                        from torch_xla.amp import GradScaler\n\n                        self.scaler = GradScaler()\n                    else:\n                        self.scaler = torch.cuda.amp.GradScaler()\n            elif args.half_precision_backend == \"cpu_amp\":\n                self.use_cpu_amp = True\n                self.amp_dtype = torch.bfloat16\n            else:\n                if not is_apex_available():\n                    raise ImportError(\n                        \"Using FP16 with APEX but APEX is not installed, please refer to\"\n                        \" https://www.github.com/nvidia/apex.\"\n                    )\n                self.use_apex = True\n\n        # FP16 + model parallelism in SageMaker: gradient clipping does not work for now so we raise a helpful error.\n        if (\n            is_sagemaker_mp_enabled()\n            and self.use_cuda_amp\n            and args.max_grad_norm is not None\n            and args.max_grad_norm > 0\n        ):\n            raise ValueError(\n                \"SageMaker Model Parallelism in mixed precision mode does not support gradient clipping yet. Pass \"\n                \"along 'max_grad_norm': 0 in your hyperparameters.\"\n            )\n\n        # Label smoothing\n        if self.args.label_smoothing_factor != 0:\n            self.label_smoother = LabelSmoother(epsilon=self.args.label_smoothing_factor)\n        else:\n            self.label_smoother = None\n\n        self.state = TrainerState(\n            is_local_process_zero=self.is_local_process_zero(),\n            is_world_process_zero=self.is_world_process_zero(),\n        )\n\n        self.control = TrainerControl()\n        # Internal variable to count flos in each process, will be accumulated in `self.state.total_flos` then\n        # returned to 0 every time flos need to be logged\n        self.current_flos = 0\n        self.hp_search_backend = None\n        self.use_tune_checkpoints = False\n        default_label_names = find_labels(self.model.__class__)\n        self.label_names = default_label_names if self.args.label_names is None else self.args.label_names\n        self.can_return_loss = can_return_loss(self.model.__class__)\n        self.control = self.callback_handler.on_init_end(self.args, self.state, self.control)\n\n        # Internal variables to keep track of the original batch size\n        self._train_batch_size = args.train_batch_size\n\n        # very last\n        self._memory_tracker.stop_and_update_metrics()\n\n        # torch.compile\n        if args.torch_compile and not is_torch_compile_available():\n            raise RuntimeError(\"Using torch.compile requires PyTorch 2.0 or higher.\")\n\n    def add_callback(self, callback):\n        \"\"\"\n        Add a callback to the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will instantiate a member of that class.\n        \"\"\"\n        self.callback_handler.add_callback(callback)\n\n    def pop_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`] and returns it.\n\n        If the callback is not found, returns `None` (and no error is raised).\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will pop the first member of that class found in the list of callbacks.\n\n        Returns:\n            [`~transformer.TrainerCallback`]: The callback removed, if found.\n        \"\"\"\n        return self.callback_handler.pop_callback(callback)\n\n    def remove_callback(self, callback):\n        \"\"\"\n        Remove a callback from the current list of [`~transformer.TrainerCallback`].\n\n        Args:\n           callback (`type` or [`~transformer.TrainerCallback`]):\n               A [`~transformer.TrainerCallback`] class or an instance of a [`~transformer.TrainerCallback`]. In the\n               first case, will remove the first member of that class found in the list of callbacks.\n        \"\"\"\n        self.callback_handler.remove_callback(callback)\n\n    def _move_model_to_device(self, model, device):\n        model = model.to(device)\n        # Moving a model to an XLA device disconnects the tied weights, so we have to retie them.\n        if self.args.parallel_mode == ParallelMode.TPU and hasattr(model, \"tie_weights\"):\n            model.tie_weights()\n\n    def _set_signature_columns_if_needed(self):\n        if self._signature_columns is None:\n            # Inspect model forward signature to keep only the arguments it accepts.\n            signature = inspect.signature(self.model.forward)\n            self._signature_columns = list(signature.parameters.keys())\n            # Labels may be named label or label_ids, the default data collator handles that.\n            self._signature_columns += list(set([\"label\", \"label_ids\"] + self.label_names))\n\n    def _remove_unused_columns(self, dataset: \"datasets.Dataset\", description: Optional[str] = None):\n        if not self.args.remove_unused_columns:\n            return dataset\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        ignored_columns = list(set(dataset.column_names) - set(signature_columns))\n        if len(ignored_columns) > 0:\n            dset_description = \"\" if description is None else f\"in the {description} set\"\n            logger.info(\n                f\"The following columns {dset_description} don't have a corresponding argument in \"\n                f\"`{self.model.__class__.__name__}.forward` and have been ignored: {', '.join(ignored_columns)}.\"\n                f\" If {', '.join(ignored_columns)} are not expected by `{self.model.__class__.__name__}.forward`, \"\n                \" you can safely ignore this message.\"\n            )\n\n        columns = [k for k in signature_columns if k in dataset.column_names]\n\n        if version.parse(datasets.__version__) < version.parse(\"1.4.0\"):\n            dataset.set_format(\n                type=dataset.format[\"type\"], columns=columns, format_kwargs=dataset.format[\"format_kwargs\"]\n            )\n            return dataset\n        else:\n            return dataset.remove_columns(ignored_columns)\n\n    def _get_collator_with_removed_columns(\n        self, data_collator: Callable, description: Optional[str] = None\n    ) -> Callable:\n        \"\"\"Wrap the data collator in a callable removing unused columns.\"\"\"\n        if not self.args.remove_unused_columns:\n            return data_collator\n        self._set_signature_columns_if_needed()\n        signature_columns = self._signature_columns\n\n        remove_columns_collator = RemoveColumnsCollator(\n            data_collator=data_collator,\n            signature_columns=signature_columns,\n            logger=logger,\n            description=description,\n            model_name=self.model.__class__.__name__,\n        )\n        return remove_columns_collator\n\n    def _get_train_sampler(self) -> Optional[torch.utils.data.Sampler]:\n        if self.train_dataset is None or not has_length(self.train_dataset):\n            return None\n\n        generator = None\n        if self.args.world_size <= 1:\n            generator = torch.Generator()\n            # for backwards compatibility, we generate a seed here (which is sampled from a generator seeded with\n            # `args.seed`) if data_seed isn't provided.\n            # Further on in this method, we default to `args.seed` instead.\n            if self.args.data_seed is None:\n                seed = int(torch.empty((), dtype=torch.int64).random_().item())\n            else:\n                seed = self.args.data_seed\n            generator.manual_seed(seed)\n\n        seed = self.args.data_seed if self.args.data_seed is not None else self.args.seed\n\n        # Build the sampler.\n        if self.args.group_by_length:\n            if is_datasets_available() and isinstance(self.train_dataset, datasets.Dataset):\n                lengths = (\n                    self.train_dataset[self.args.length_column_name]\n                    if self.args.length_column_name in self.train_dataset.column_names\n                    else None\n                )\n            else:\n                lengths = None\n            model_input_name = self.tokenizer.model_input_names[0] if self.tokenizer is not None else None\n            if self.args.world_size <= 1:\n                return LengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    generator=generator,\n                )\n            else:\n                return DistributedLengthGroupedSampler(\n                    self.args.train_batch_size * self.args.gradient_accumulation_steps,\n                    dataset=self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    lengths=lengths,\n                    model_input_name=model_input_name,\n                    seed=seed,\n                )\n\n        else:\n            if self.args.world_size <= 1:\n                return RandomSampler(self.train_dataset, generator=generator)\n            elif (\n                self.args.parallel_mode in [ParallelMode.TPU, ParallelMode.SAGEMAKER_MODEL_PARALLEL]\n                and not self.args.dataloader_drop_last\n            ):\n                # Use a loop for TPUs when drop_last is False to have all batches have the same size.\n                return DistributedSamplerWithLoop(\n                    self.train_dataset,\n                    batch_size=self.args.per_device_train_batch_size,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n            else:\n                return DistributedSampler(\n                    self.train_dataset,\n                    num_replicas=self.args.world_size,\n                    rank=self.args.process_index,\n                    seed=seed,\n                )\n\n    def get_train_dataloader(self) -> DataLoader:\n        \"\"\"\n        Returns the training [`~torch.utils.data.DataLoader`].\n\n        Will use no sampler if `train_dataset` does not implement `__len__`, a random sampler (adapted to distributed\n        training if necessary) otherwise.\n\n        Subclass and override this method if you want to inject some custom behavior.\n        \"\"\"\n        if self.train_dataset is None:\n            raise ValueError(\"Trainer: training requires a train_dataset.\")\n\n        train_dataset = self.train_dataset\n        data_collator = self.data_collator\n        if is_datasets_available() and isinstance(train_dataset, datasets.Dataset):\n            train_dataset = self._remove_unused_columns(train_dataset, description=\"training\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"training\")\n\n        if isinstance(train_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                train_dataset = IterableDatasetShard(\n                    train_dataset,\n                    batch_size=self._train_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n\n            return DataLoader(\n                train_dataset,\n                batch_size=self._train_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        train_sampler = self._get_train_sampler()\n\n        return DataLoader(\n            train_dataset,\n            batch_size=self._train_batch_size,\n            sampler=train_sampler,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n            worker_init_fn=seed_worker,\n        )\n\n    def _get_eval_sampler(self, eval_dataset: Dataset) -> Optional[torch.utils.data.Sampler]:\n        # Deprecated code\n        if self.args.use_legacy_prediction_loop:\n            if is_torch_tpu_available():\n                return SequentialDistributedSampler(\n                    eval_dataset, num_replicas=xm.xrt_world_size(), rank=xm.get_ordinal()\n                )\n            elif is_sagemaker_mp_enabled():\n                return SequentialDistributedSampler(\n                    eval_dataset,\n                    num_replicas=smp.dp_size(),\n                    rank=smp.dp_rank(),\n                    batch_size=self.args.per_device_eval_batch_size,\n                )\n            elif self.args.local_rank != -1:\n                return SequentialDistributedSampler(eval_dataset)\n            else:\n                return SequentialSampler(eval_dataset)\n\n        if self.args.world_size <= 1:\n            return SequentialSampler(eval_dataset)\n        else:\n            return ShardSampler(\n                eval_dataset,\n                batch_size=self.args.per_device_eval_batch_size,\n                num_processes=self.args.world_size,\n                process_index=self.args.process_index,\n            )\n\n    def get_eval_dataloader(self, eval_dataset: Optional[Dataset] = None) -> DataLoader:\n        \"\"\"\n        Returns the evaluation [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            eval_dataset (`torch.utils.data.Dataset`, *optional*):\n                If provided, will override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns not accepted\n                by the `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        if eval_dataset is None and self.eval_dataset is None:\n            raise ValueError(\"Trainer: evaluation requires an eval_dataset.\")\n        eval_dataset = eval_dataset if eval_dataset is not None else self.eval_dataset\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(eval_dataset, datasets.Dataset):\n            eval_dataset = self._remove_unused_columns(eval_dataset, description=\"evaluation\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"evaluation\")\n\n        if isinstance(eval_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                eval_dataset = IterableDatasetShard(\n                    eval_dataset,\n                    batch_size=self.args.per_device_eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                eval_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        eval_sampler = self._get_eval_sampler(eval_dataset)\n\n        return DataLoader(\n            eval_dataset,\n            sampler=eval_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def get_test_dataloader(self, test_dataset: Dataset) -> DataLoader:\n        \"\"\"\n        Returns the test [`~torch.utils.data.DataLoader`].\n\n        Subclass and override this method if you want to inject some custom behavior.\n\n        Args:\n            test_dataset (`torch.utils.data.Dataset`, *optional*):\n                The test dataset to use. If it is a [`~datasets.Dataset`], columns not accepted by the\n                `model.forward()` method are automatically removed. It must implement `__len__`.\n        \"\"\"\n        data_collator = self.data_collator\n\n        if is_datasets_available() and isinstance(test_dataset, datasets.Dataset):\n            test_dataset = self._remove_unused_columns(test_dataset, description=\"test\")\n        else:\n            data_collator = self._get_collator_with_removed_columns(data_collator, description=\"test\")\n\n        if isinstance(test_dataset, torch.utils.data.IterableDataset):\n            if self.args.world_size > 1:\n                test_dataset = IterableDatasetShard(\n                    test_dataset,\n                    batch_size=self.args.eval_batch_size,\n                    drop_last=self.args.dataloader_drop_last,\n                    num_processes=self.args.world_size,\n                    process_index=self.args.process_index,\n                )\n            return DataLoader(\n                test_dataset,\n                batch_size=self.args.eval_batch_size,\n                collate_fn=data_collator,\n                num_workers=self.args.dataloader_num_workers,\n                pin_memory=self.args.dataloader_pin_memory,\n            )\n\n        test_sampler = self._get_eval_sampler(test_dataset)\n\n        # We use the same batch_size as for eval.\n        return DataLoader(\n            test_dataset,\n            sampler=test_sampler,\n            batch_size=self.args.eval_batch_size,\n            collate_fn=data_collator,\n            drop_last=self.args.dataloader_drop_last,\n            num_workers=self.args.dataloader_num_workers,\n            pin_memory=self.args.dataloader_pin_memory,\n        )\n\n    def create_optimizer_and_scheduler(self, num_training_steps: int):\n        \"\"\"\n        Setup the optimizer and the learning rate scheduler.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method (or `create_optimizer` and/or\n        `create_scheduler`) in a subclass.\n        \"\"\"\n        self.create_optimizer()\n        if IS_SAGEMAKER_MP_POST_1_10 and smp.state.cfg.fp16:\n            # If smp >= 1.10 and fp16 is enabled, we unwrap the optimizer\n            optimizer = self.optimizer.optimizer\n        else:\n            optimizer = self.optimizer\n        self.create_scheduler(num_training_steps=num_training_steps, optimizer=optimizer)\n\n    def create_optimizer(self):\n        \"\"\"\n        Setup the optimizer.\n\n        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the\n        Trainer's init through `optimizers`, or subclass and override this method in a subclass.\n        \"\"\"\n        opt_model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n\n        if self.optimizer is None:\n            decay_parameters = get_parameter_names(opt_model, ALL_LAYERNORM_LAYERS)\n            decay_parameters = [name for name in decay_parameters if \"bias\" not in name]\n            optimizer_grouped_parameters = [\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": self.args.weight_decay,\n                },\n                {\n                    \"params\": [\n                        p for n, p in opt_model.named_parameters() if (n not in decay_parameters and p.requires_grad)\n                    ],\n                    \"weight_decay\": 0.0,\n                },\n            ]\n\n            optimizer_cls, optimizer_kwargs = Trainer.get_optimizer_cls_and_kwargs(self.args)\n\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                self.optimizer = OSS(\n                    params=optimizer_grouped_parameters,\n                    optim=optimizer_cls,\n                    **optimizer_kwargs,\n                )\n            else:\n                self.optimizer = optimizer_cls(optimizer_grouped_parameters, **optimizer_kwargs)\n                if optimizer_cls.__name__ == \"Adam8bit\":\n                    import bitsandbytes\n\n                    manager = bitsandbytes.optim.GlobalOptimManager.get_instance()\n\n                    skipped = 0\n                    for module in opt_model.modules():\n                        if isinstance(module, nn.Embedding):\n                            skipped += sum({p.data_ptr(): p.numel() for p in module.parameters()}.values())\n                            print(f\"skipped {module}: {skipped/2**20}M params\")\n                            manager.register_module_override(module, \"weight\", {\"optim_bits\": 32})\n                            logger.debug(f\"bitsandbytes: will optimize {module} in fp32\")\n                    print(f\"skipped: {skipped/2**20}M params\")\n\n        if is_sagemaker_mp_enabled():\n            self.optimizer = smp.DistributedOptimizer(self.optimizer)\n\n        return self.optimizer\n\n    @staticmethod\n    def get_optimizer_cls_and_kwargs(args: TrainingArguments) -> Tuple[Any, Any]:\n        \"\"\"\n        Returns the optimizer class and optimizer parameters based on the training arguments.\n\n        Args:\n            args (`transformers.training_args.TrainingArguments`):\n                The training arguments for the training session.\n\n        \"\"\"\n\n        # parse args.optim_args\n        optim_args = {}\n        if args.optim_args:\n            for mapping in args.optim_args.replace(\" \", \"\").split(\",\"):\n                key, value = mapping.split(\"=\")\n                optim_args[key] = value\n\n        optimizer_kwargs = {\"lr\": args.learning_rate}\n\n        adam_kwargs = {\n            \"betas\": (args.adam_beta1, args.adam_beta2),\n            \"eps\": args.adam_epsilon,\n        }\n        if args.optim == OptimizerNames.ADAFACTOR:\n            optimizer_cls = Adafactor\n            optimizer_kwargs.update({\"scale_parameter\": False, \"relative_step\": False})\n        elif args.optim == OptimizerNames.ADAMW_HF:\n            from transformers.optimization import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n        elif args.optim in [OptimizerNames.ADAMW_TORCH, OptimizerNames.ADAMW_TORCH_FUSED]:\n            from torch.optim import AdamW\n\n            optimizer_cls = AdamW\n            optimizer_kwargs.update(adam_kwargs)\n            if args.optim == OptimizerNames.ADAMW_TORCH_FUSED:\n                optimizer_kwargs.update({\"fused\": True})\n        elif args.optim == OptimizerNames.ADAMW_TORCH_XLA:\n            try:\n                from torch_xla.amp.syncfree import AdamW\n\n                optimizer_cls = AdamW\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer failed to import syncfree AdamW from torch_xla.\")\n        elif args.optim == OptimizerNames.ADAMW_APEX_FUSED:\n            try:\n                from apex.optimizers import FusedAdam\n\n                optimizer_cls = FusedAdam\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate apex FusedAdam but apex is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_BNB:\n            try:\n                from bitsandbytes.optim import Adam8bit\n\n                optimizer_cls = Adam8bit\n                optimizer_kwargs.update(adam_kwargs)\n            except ImportError:\n                raise ValueError(\"Trainer tried to instantiate bnb Adam8bit but bnb is not installed!\")\n        elif args.optim == OptimizerNames.ADAMW_ANYPRECISION:\n            try:\n                from torchdistx.optimizers import AnyPrecisionAdamW\n\n                optimizer_cls = AnyPrecisionAdamW\n                optimizer_kwargs.update(adam_kwargs)\n\n                # TODO Change dtypes back to M=FP32, Var = BF16, Kahan = False once they can be cast together in torchdistx.\n                optimizer_kwargs.update(\n                    {\n                        \"use_kahan_summation\": strtobool(optim_args.get(\"use_kahan_summation\", \"False\")),\n                        \"momentum_dtype\": getattr(torch, optim_args.get(\"momentum_dtype\", \"float32\")),\n                        \"variance_dtype\": getattr(torch, optim_args.get(\"variance_dtype\", \"float32\")),\n                        \"compensation_buffer_dtype\": getattr(\n                            torch, optim_args.get(\"compensation_buffer_dtype\", \"bfloat16\")\n                        ),\n                    }\n                )\n            except ImportError:\n                raise ValueError(\"Please install https://github.com/pytorch/torchdistx\")\n        elif args.optim == OptimizerNames.SGD:\n            optimizer_cls = torch.optim.SGD\n        elif args.optim == OptimizerNames.ADAGRAD:\n            optimizer_cls = torch.optim.Adagrad\n        else:\n            raise ValueError(f\"Trainer cannot instantiate unsupported optimizer: {args.optim}\")\n        return optimizer_cls, optimizer_kwargs\n\n    def create_scheduler(self, num_training_steps: int, optimizer: torch.optim.Optimizer = None):\n        \"\"\"\n        Setup the scheduler. The optimizer of the trainer must have been set up either before this method is called or\n        passed as an argument.\n\n        Args:\n            num_training_steps (int): The number of training steps to do.\n        \"\"\"\n        if self.lr_scheduler is None:\n            self.lr_scheduler = get_scheduler(\n                self.args.lr_scheduler_type,\n                optimizer=self.optimizer if optimizer is None else optimizer,\n                num_warmup_steps=self.args.get_warmup_steps(num_training_steps),\n                num_training_steps=num_training_steps,\n            )\n        return self.lr_scheduler\n\n    def num_examples(self, dataloader: DataLoader) -> int:\n        \"\"\"\n        Helper to get number of samples in a [`~torch.utils.data.DataLoader`] by accessing its dataset. When\n        dataloader.dataset does not exist or has no length, estimates as best it can\n        \"\"\"\n        try:\n            dataset = dataloader.dataset\n            # Special case for IterableDatasetShard, we need to dig deeper\n            if isinstance(dataset, IterableDatasetShard):\n                return len(dataloader.dataset.dataset)\n            return len(dataloader.dataset)\n        except (NameError, AttributeError, TypeError):  # no dataset or length, estimate by length of dataloader\n            return len(dataloader) * self.args.per_device_train_batch_size\n\n    def _hp_search_setup(self, trial: Union[\"optuna.Trial\", Dict[str, Any]]):\n        \"\"\"HP search setup code\"\"\"\n        self._trial = trial\n\n        if self.hp_search_backend is None or trial is None:\n            return\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            params = self.hp_space(trial)\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            params = trial\n            params.pop(\"wandb\", None)\n        elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n            params = {k: int(v) if isinstance(v, str) else v for k, v in trial.assignments.items()}\n        elif self.hp_search_backend == HPSearchBackend.WANDB:\n            params = trial\n\n        for key, value in params.items():\n            if not hasattr(self.args, key):\n                logger.warning(\n                    f\"Trying to set {key} in the hyperparameter search but there is no corresponding field in\"\n                    \" `TrainingArguments`.\"\n                )\n                continue\n            old_attr = getattr(self.args, key, None)\n            # Casting value to the proper type\n            if old_attr is not None:\n                value = type(old_attr)(value)\n            setattr(self.args, key, value)\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            logger.info(f\"Trial: {trial.params}\")\n        if self.hp_search_backend == HPSearchBackend.SIGOPT:\n            logger.info(f\"SigOpt Assignments: {trial.assignments}\")\n        if self.hp_search_backend == HPSearchBackend.WANDB:\n            logger.info(f\"W&B Sweep parameters: {trial}\")\n        if self.args.deepspeed:\n            # Rebuild the deepspeed config to reflect the updated training parameters\n            from transformers.deepspeed import HfTrainerDeepSpeedConfig\n\n            self.args.hf_deepspeed_config = HfTrainerDeepSpeedConfig(self.args.deepspeed)\n            self.args.hf_deepspeed_config.trainer_config_process(self.args)\n\n    def _report_to_hp_search(self, trial: Union[\"optuna.Trial\", Dict[str, Any]], step: int, metrics: Dict[str, float]):\n        if self.hp_search_backend is None or trial is None:\n            return\n        self.objective = self.compute_objective(metrics.copy())\n        if self.hp_search_backend == HPSearchBackend.OPTUNA:\n            import optuna\n\n            trial.report(self.objective, step)\n            if trial.should_prune():\n                self.callback_handler.on_train_end(self.args, self.state, self.control)\n                raise optuna.TrialPruned()\n        elif self.hp_search_backend == HPSearchBackend.RAY:\n            from ray import tune\n\n            if self.control.should_save:\n                self._tune_save_checkpoint()\n            tune.report(objective=self.objective, **metrics)\n\n    def _tune_save_checkpoint(self):\n        from ray import tune\n\n        if not self.use_tune_checkpoints:\n            return\n        with tune.checkpoint_dir(step=self.state.global_step) as checkpoint_dir:\n            output_dir = os.path.join(checkpoint_dir, f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\")\n            self.save_model(output_dir, _internal_call=True)\n            if self.args.should_save:\n                self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n                torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n\n    def call_model_init(self, trial=None):\n        model_init_argcount = number_of_arguments(self.model_init)\n        if model_init_argcount == 0:\n            model = self.model_init()\n        elif model_init_argcount == 1:\n            model = self.model_init(trial)\n        else:\n            raise RuntimeError(\"model_init should have 0 or 1 argument.\")\n\n        if model is None:\n            raise RuntimeError(\"model_init should not return None.\")\n\n        return model\n\n    def torch_jit_model_eval(self, model, dataloader, training=False):\n        if not training:\n            if dataloader is None:\n                logger.warning(\"failed to use PyTorch jit mode due to current dataloader is none.\")\n                return model\n            example_batch = next(iter(dataloader))\n            example_batch = self._prepare_inputs(example_batch)\n            try:\n                jit_model = model.eval()\n                with ContextManagers([self.autocast_smart_context_manager(cache_enabled=False), torch.no_grad()]):\n                    if version.parse(version.parse(torch.__version__).base_version) >= version.parse(\"1.14.0\"):\n                        if isinstance(example_batch, dict):\n                            jit_model = torch.jit.trace(jit_model, example_kwarg_inputs=example_batch, strict=False)\n                        else:\n                            jit_model = torch.jit.trace(\n                                jit_model,\n                                example_kwarg_inputs={key: example_batch[key] for key in example_batch},\n                                strict=False,\n                            )\n                    else:\n                        jit_inputs = []\n                        for key in example_batch:\n                            example_tensor = torch.ones_like(example_batch[key])\n                            jit_inputs.append(example_tensor)\n                        jit_inputs = tuple(jit_inputs)\n                        jit_model = torch.jit.trace(jit_model, jit_inputs, strict=False)\n                jit_model = torch.jit.freeze(jit_model)\n                with torch.no_grad():\n                    jit_model(**example_batch)\n                    jit_model(**example_batch)\n                model = jit_model\n                self.use_cpu_amp = False\n                self.use_cuda_amp = False\n            except (RuntimeError, TypeError, ValueError, NameError, IndexError) as e:\n                logger.warning(f\"failed to use PyTorch jit mode due to: {e}.\")\n\n        return model\n\n    def ipex_optimize_model(self, model, training=False, dtype=torch.float32):\n        if not is_ipex_available():\n            raise ImportError(\n                \"Using IPEX but IPEX is not installed or IPEX's version does not match current PyTorch, please refer\"\n                \" to https://github.com/intel/intel-extension-for-pytorch.\"\n            )\n\n        import intel_extension_for_pytorch as ipex\n\n        if not training:\n            model.eval()\n            dtype = torch.bfloat16 if not self.is_in_train and self.args.bf16_full_eval else dtype\n            # conv_bn_folding is disabled as it fails in symbolic tracing, resulting in ipex warnings\n            model = ipex.optimize(model, dtype=dtype, level=\"O1\", conv_bn_folding=False, inplace=not self.is_in_train)\n        else:\n            if not model.training:\n                model.train()\n            model, self.optimizer = ipex.optimize(\n                model, dtype=dtype, optimizer=self.optimizer, inplace=True, level=\"O1\"\n            )\n\n        return model\n\n    def _wrap_model(self, model, training=True, dataloader=None):\n        if self.args.torch_compile:\n            model = torch.compile(model, backend=self.args.torch_compile_backend, mode=self.args.torch_compile_mode)\n\n        if self.args.use_ipex:\n            dtype = torch.bfloat16 if self.use_cpu_amp else torch.float32\n            model = self.ipex_optimize_model(model, training, dtype=dtype)\n\n        if is_sagemaker_mp_enabled():\n            # Wrapping the base model twice in a DistributedModel will raise an error.\n            if isinstance(self.model_wrapped, smp.model.DistributedModel):\n                return self.model_wrapped\n            return smp.DistributedModel(model, backward_passes_per_step=self.args.gradient_accumulation_steps)\n\n        # already initialized its own DDP and AMP\n        if self.deepspeed:\n            return self.deepspeed\n\n        # train/eval could be run multiple-times - if already wrapped, don't re-wrap it again\n        if unwrap_model(model) is not model:\n            return model\n\n        # Mixed precision training with apex (torch < 1.6)\n        if self.use_apex and training:\n            model, self.optimizer = amp.initialize(model, self.optimizer, opt_level=self.args.fp16_opt_level)\n\n        # Multi-gpu training (should be after apex fp16 initialization)\n        if self.args.n_gpu > 1:\n            model = nn.DataParallel(model)\n\n        if self.args.jit_mode_eval:\n            start_time = time.time()\n            model = self.torch_jit_model_eval(model, dataloader, training)\n            self.jit_compilation_time = round(time.time() - start_time, 4)\n\n        # Note: in torch.distributed mode, there's no point in wrapping the model\n        # inside a DistributedDataParallel as we'll be under `no_grad` anyways.\n        if not training:\n            return model\n\n        # Distributed training (should be after apex fp16 initialization)\n        if self.sharded_ddp is not None:\n            # Sharded DDP!\n            if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n                model = ShardedDDP(model, self.optimizer)\n            else:\n                mixed_precision = self.args.fp16 or self.args.bf16\n                cpu_offload = ShardedDDPOption.OFFLOAD in self.args.sharded_ddp\n                zero_3 = self.sharded_ddp == ShardedDDPOption.ZERO_DP_3\n                # XXX: Breaking the self.model convention but I see no way around it for now.\n                if ShardedDDPOption.AUTO_WRAP in self.args.sharded_ddp:\n                    model = auto_wrap(model)\n                self.model = model = FullyShardedDDP(\n                    model,\n                    mixed_precision=mixed_precision,\n                    reshard_after_forward=zero_3,\n                    cpu_offload=cpu_offload,\n                ).to(self.args.device)\n        # Distributed training using PyTorch FSDP\n        elif self.fsdp is not None:\n            if not self.args.fsdp_config[\"xla\"]:\n                # PyTorch FSDP!\n                from torch.distributed.fsdp.fully_sharded_data_parallel import CPUOffload, MixedPrecision\n                from torch.distributed.fsdp.fully_sharded_data_parallel import FullyShardedDataParallel as FSDP\n                from torch.distributed.fsdp.wrap import size_based_auto_wrap_policy, transformer_auto_wrap_policy\n\n                if FSDPOption.OFFLOAD in self.args.fsdp:\n                    cpu_offload = CPUOffload(offload_params=True)\n                else:\n                    cpu_offload = CPUOffload(offload_params=False)\n\n                auto_wrap_policy = None\n\n                if FSDPOption.AUTO_WRAP in self.args.fsdp:\n                    if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                        auto_wrap_policy = functools.partial(\n                            size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                        )\n                    elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                        transformer_cls_to_wrap = set()\n                        for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                            transformer_cls = get_module_class_from_name(model, layer_class)\n                            if transformer_cls is None:\n                                raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                            else:\n                                transformer_cls_to_wrap.add(transformer_cls)\n                        auto_wrap_policy = functools.partial(\n                            transformer_auto_wrap_policy,\n                            # Transformer layer class to wrap\n                            transformer_layer_cls=transformer_cls_to_wrap,\n                        )\n                mixed_precision_policy = None\n                dtype = None\n                if self.args.fp16:\n                    dtype = torch.float16\n                elif self.args.bf16:\n                    dtype = torch.bfloat16\n                if dtype is not None:\n                    mixed_precision_policy = MixedPrecision(param_dtype=dtype, reduce_dtype=dtype, buffer_dtype=dtype)\n                if type(model) != FSDP:\n                    # XXX: Breaking the self.model convention but I see no way around it for now.\n                    self.model = model = FSDP(\n                        model,\n                        sharding_strategy=self.fsdp,\n                        cpu_offload=cpu_offload,\n                        auto_wrap_policy=auto_wrap_policy,\n                        mixed_precision=mixed_precision_policy,\n                        device_id=self.args.device,\n                        backward_prefetch=self.backward_prefetch,\n                        forward_prefetch=self.forword_prefetch,\n                        limit_all_gathers=self.limit_all_gathers,\n                    )\n            else:\n                try:\n                    from torch_xla.distributed.fsdp import XlaFullyShardedDataParallel as FSDP\n                    from torch_xla.distributed.fsdp import checkpoint_module\n                    from torch_xla.distributed.fsdp.wrap import (\n                        size_based_auto_wrap_policy,\n                        transformer_auto_wrap_policy,\n                    )\n                except ImportError:\n                    raise ImportError(\"Missing XLA FSDP related module; please make sure to use torch-xla >= 2.0.\")\n                auto_wrap_policy = None\n                auto_wrapper_callable = None\n                if self.args.fsdp_config[\"fsdp_min_num_params\"] > 0:\n                    auto_wrap_policy = functools.partial(\n                        size_based_auto_wrap_policy, min_num_params=self.args.fsdp_config[\"fsdp_min_num_params\"]\n                    )\n                elif self.args.fsdp_config.get(\"fsdp_transformer_layer_cls_to_wrap\", None) is not None:\n                    transformer_cls_to_wrap = set()\n                    for layer_class in self.args.fsdp_config[\"fsdp_transformer_layer_cls_to_wrap\"]:\n                        transformer_cls = get_module_class_from_name(model, layer_class)\n                        if transformer_cls is None:\n                            raise Exception(\"Could not find the transformer layer class to wrap in the model.\")\n                        else:\n                            transformer_cls_to_wrap.add(transformer_cls)\n                    auto_wrap_policy = functools.partial(\n                        transformer_auto_wrap_policy,\n                        # Transformer layer class to wrap\n                        transformer_layer_cls=transformer_cls_to_wrap,\n                    )\n                fsdp_kwargs = self.args.xla_fsdp_config\n                if self.args.fsdp_config[\"xla_fsdp_grad_ckpt\"]:\n                    # Apply gradient checkpointing to auto-wrapped sub-modules if specified\n                    def auto_wrapper_callable(m, *args, **kwargs):\n                        return FSDP(checkpoint_module(m), *args, **kwargs)\n\n                # Wrap the base model with an outer FSDP wrapper\n                self.model = model = FSDP(\n                    model,\n                    auto_wrap_policy=auto_wrap_policy,\n                    auto_wrapper_callable=auto_wrapper_callable,\n                    **fsdp_kwargs,\n                )\n\n                # Patch `xm.optimizer_step` should not reduce gradients in this case,\n                # as FSDP does not need gradient reduction over sharded parameters.\n                def patched_optimizer_step(optimizer, barrier=False, optimizer_args={}):\n                    loss = optimizer.step(**optimizer_args)\n                    if barrier:\n                        xm.mark_step()\n                    return loss\n\n                xm.optimizer_step = patched_optimizer_step\n        elif is_sagemaker_dp_enabled():\n            model = nn.parallel.DistributedDataParallel(\n                model, device_ids=[int(os.getenv(\"SMDATAPARALLEL_LOCAL_RANK\"))]\n            )\n        elif self.args.local_rank != -1:\n            kwargs = {}\n            if self.args.ddp_find_unused_parameters is not None:\n                kwargs[\"find_unused_parameters\"] = self.args.ddp_find_unused_parameters\n            elif isinstance(model, PreTrainedModel):\n                # find_unused_parameters breaks checkpointing as per\n                # https://github.com/huggingface/transformers/pull/4659#issuecomment-643356021\n                kwargs[\"find_unused_parameters\"] = not model.is_gradient_checkpointing\n            else:\n                kwargs[\"find_unused_parameters\"] = True\n\n            if self.args.ddp_bucket_cap_mb is not None:\n                kwargs[\"bucket_cap_mb\"] = self.args.ddp_bucket_cap_mb\n            if is_torch_neuroncore_available():\n                return model\n            model = nn.parallel.DistributedDataParallel(\n                model,\n                device_ids=[self.args.local_rank] if self.args._n_gpu != 0 else None,\n                output_device=self.args.local_rank if self.args._n_gpu != 0 else None,\n                **kwargs,\n            )\n\n        return model\n\n    def train(\n        self,\n        resume_from_checkpoint: Optional[Union[str, bool]] = None,\n        trial: Union[\"optuna.Trial\", Dict[str, Any]] = None,\n        ignore_keys_for_eval: Optional[List[str]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Main training entry point.\n\n        Args:\n            resume_from_checkpoint (`str` or `bool`, *optional*):\n                If a `str`, local path to a saved checkpoint as saved by a previous instance of [`Trainer`]. If a\n                `bool` and equals `True`, load the last checkpoint in *args.output_dir* as saved by a previous instance\n                of [`Trainer`]. If present, training will resume from the model/optimizer/scheduler states loaded here.\n            trial (`optuna.Trial` or `Dict[str, Any]`, *optional*):\n                The trial run or the hyperparameter dictionary for hyperparameter search.\n            ignore_keys_for_eval (`List[str]`, *optional*)\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions for evaluation during the training.\n            kwargs:\n                Additional keyword arguments used to hide deprecated arguments\n        \"\"\"\n        if resume_from_checkpoint is False:\n            resume_from_checkpoint = None\n\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        args = self.args\n\n        self.is_in_train = True\n\n        # do_train is not a reliable argument, as it might not be set and .train() still called, so\n        # the following is a workaround:\n        if (args.fp16_full_eval or args.bf16_full_eval) and not args.do_train:\n            self._move_model_to_device(self.model, args.device)\n\n        if \"model_path\" in kwargs:\n            resume_from_checkpoint = kwargs.pop(\"model_path\")\n            warnings.warn(\n                \"`model_path` is deprecated and will be removed in a future version. Use `resume_from_checkpoint` \"\n                \"instead.\",\n                FutureWarning,\n            )\n        if len(kwargs) > 0:\n            raise TypeError(f\"train() received got unexpected keyword arguments: {', '.join(list(kwargs.keys()))}.\")\n        # This might change the seed so needs to run first.\n        self._hp_search_setup(trial)\n        self._train_batch_size = self.args.train_batch_size\n\n        # Model re-init\n        model_reloaded = False\n        if self.model_init is not None:\n            # Seed must be set before instantiating the model when using model_init.\n            enable_full_determinism(self.args.seed) if self.args.full_determinism else set_seed(self.args.seed)\n            self.model = self.call_model_init(trial)\n            model_reloaded = True\n            # Reinitializes optimizer and scheduler\n            self.optimizer, self.lr_scheduler = None, None\n\n        # Load potential model checkpoint\n        if isinstance(resume_from_checkpoint, bool) and resume_from_checkpoint:\n            resume_from_checkpoint = get_last_checkpoint(args.output_dir)\n            if resume_from_checkpoint is None:\n                raise ValueError(f\"No valid checkpoint found in output directory ({args.output_dir})\")\n\n        if resume_from_checkpoint is not None and not is_sagemaker_mp_enabled() and args.deepspeed is None:\n            self._load_from_checkpoint(resume_from_checkpoint)\n\n        # If model was re-initialized, put it on the right device and update self.model_wrapped\n        if model_reloaded:\n            if self.place_model_on_device:\n                self._move_model_to_device(self.model, args.device)\n            self.model_wrapped = self.model\n\n        inner_training_loop = find_executable_batch_size(\n            self._inner_training_loop, self._train_batch_size, args.auto_find_batch_size\n        )\n        return inner_training_loop(\n            args=args,\n            resume_from_checkpoint=resume_from_checkpoint,\n            trial=trial,\n            ignore_keys_for_eval=ignore_keys_for_eval,\n        )\n\n    def _inner_training_loop(\n        self, batch_size=None, args=None, resume_from_checkpoint=None, trial=None, ignore_keys_for_eval=None\n    ):\n        self._train_batch_size = batch_size\n        # Data loader and number of training steps\n        train_dataloader = self.get_train_dataloader()\n\n        # Setting up training control variables:\n        # number of training epochs: num_train_epochs\n        # number of training steps per epoch: num_update_steps_per_epoch\n        # total number of training steps to execute: max_steps\n        total_train_batch_size = args.train_batch_size * args.gradient_accumulation_steps * args.world_size\n\n        len_dataloader = None\n        if has_length(train_dataloader):\n            len_dataloader = len(train_dataloader)\n            num_update_steps_per_epoch = len_dataloader // args.gradient_accumulation_steps\n            num_update_steps_per_epoch = max(num_update_steps_per_epoch, 1)\n            num_examples = self.num_examples(train_dataloader)\n            if args.max_steps > 0:\n                max_steps = args.max_steps\n                num_train_epochs = args.max_steps // num_update_steps_per_epoch + int(\n                    args.max_steps % num_update_steps_per_epoch > 0\n                )\n                # May be slightly incorrect if the last batch in the training dataloader has a smaller size but it's\n                # the best we can do.\n                num_train_samples = args.max_steps * total_train_batch_size\n            else:\n                max_steps = math.ceil(args.num_train_epochs * num_update_steps_per_epoch)\n                num_train_epochs = math.ceil(args.num_train_epochs)\n                num_train_samples = self.num_examples(train_dataloader) * args.num_train_epochs\n        elif args.max_steps > 0:  # Rely on max_steps when dataloader does not have a working size\n            max_steps = args.max_steps\n            # Setting a very large number of epochs so we go as many times as necessary over the iterator.\n            num_train_epochs = sys.maxsize\n            num_update_steps_per_epoch = max_steps\n            num_examples = total_train_batch_size * args.max_steps\n            num_train_samples = args.max_steps * total_train_batch_size\n        else:\n            raise ValueError(\n                \"args.max_steps must be set to a positive value if dataloader does not have a length, was\"\n                f\" {args.max_steps}\"\n            )\n\n        if DebugOption.UNDERFLOW_OVERFLOW in self.args.debug:\n            if self.args.n_gpu > 1:\n                # nn.DataParallel(model) replicates the model, creating new variables and module\n                # references registered here no longer work on other gpus, breaking the module\n                raise ValueError(\n                    \"Currently --debug underflow_overflow is not supported under DP. Please use DDP\"\n                    \" (torch.distributed.launch).\"\n                )\n            else:\n                debug_overflow = DebugUnderflowOverflow(self.model)  # noqa\n\n        delay_optimizer_creation = (\n            self.sharded_ddp is not None\n            and self.sharded_ddp != ShardedDDPOption.SIMPLE\n            or is_sagemaker_mp_enabled()\n            or self.fsdp is not None\n        )\n        if args.deepspeed:\n            deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                self, num_training_steps=max_steps, resume_from_checkpoint=resume_from_checkpoint\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            self.optimizer = optimizer\n            self.lr_scheduler = lr_scheduler\n        elif not delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        self.state = TrainerState()\n        self.state.is_hyper_param_search = trial is not None\n\n        # Activate gradient checkpointing if needed\n        if args.gradient_checkpointing:\n            self.model.gradient_checkpointing_enable()\n\n        model = self._wrap_model(self.model_wrapped)\n\n        if is_sagemaker_mp_enabled() and resume_from_checkpoint is not None:\n            self._load_from_checkpoint(resume_from_checkpoint, model)\n\n        # for the rest of this function `model` is the outside model, whether it was wrapped or not\n        if model is not self.model:\n            self.model_wrapped = model\n\n        if delay_optimizer_creation:\n            self.create_optimizer_and_scheduler(num_training_steps=max_steps)\n\n        # Check if saved optimizer or scheduler states exist\n        self._load_optimizer_and_scheduler(resume_from_checkpoint)\n\n        # important: at this point:\n        # self.model         is the Transformers Model\n        # self.model_wrapped is DDP(Transformers Model), Deepspeed(Transformers Model), etc.\n\n        # Train!\n        logger.info(\"***** Running training *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Num Epochs = {num_train_epochs}\")\n        logger.info(f\"  Instantaneous batch size per device = {args.per_device_train_batch_size}\")\n        logger.info(f\"  Total train batch size (w. parallel, distributed & accumulation) = {total_train_batch_size}\")\n        logger.info(f\"  Gradient Accumulation steps = {args.gradient_accumulation_steps}\")\n        logger.info(f\"  Total optimization steps = {max_steps}\")\n        logger.info(\n            f\"  Number of trainable parameters = {sum(p.numel() for p in model.parameters() if p.requires_grad)}\"\n        )\n\n        self.state.epoch = 0\n        start_time = time.time()\n        epochs_trained = 0\n        steps_trained_in_current_epoch = 0\n        steps_trained_progress_bar = None\n\n        # Check if continuing training from a checkpoint\n        if resume_from_checkpoint is not None and os.path.isfile(\n            os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME)\n        ):\n            self.state = TrainerState.load_from_json(os.path.join(resume_from_checkpoint, TRAINER_STATE_NAME))\n            epochs_trained = self.state.global_step // num_update_steps_per_epoch\n            if not args.ignore_data_skip:\n                steps_trained_in_current_epoch = self.state.global_step % (num_update_steps_per_epoch)\n                steps_trained_in_current_epoch *= args.gradient_accumulation_steps\n            else:\n                steps_trained_in_current_epoch = 0\n\n            logger.info(\"  Continuing training from checkpoint, will skip to saved global_step\")\n            logger.info(f\"  Continuing training from epoch {epochs_trained}\")\n            logger.info(f\"  Continuing training from global step {self.state.global_step}\")\n            if not args.ignore_data_skip:\n                if skip_first_batches is None:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch. If this takes a lot of time,\"\n                        \" you can install the latest version of Accelerate with `pip install -U accelerate`.You can\"\n                        \" also add the `--ignore_data_skip` flag to your launch command, but you will resume the\"\n                        \" training on data already seen by your model.\"\n                    )\n                else:\n                    logger.info(\n                        f\"  Will skip the first {epochs_trained} epochs then the first\"\n                        f\" {steps_trained_in_current_epoch} batches in the first epoch.\"\n                    )\n                if self.is_local_process_zero() and not args.disable_tqdm and skip_first_batches is None:\n                    steps_trained_progress_bar = tqdm(total=steps_trained_in_current_epoch)\n                    steps_trained_progress_bar.set_description(\"Skipping the first batches\")\n\n        # Update the references\n        self.callback_handler.model = self.model\n        self.callback_handler.optimizer = self.optimizer\n        self.callback_handler.lr_scheduler = self.lr_scheduler\n        self.callback_handler.train_dataloader = train_dataloader\n        if self.hp_name is not None and self._trial is not None:\n            # use self._trial because the SigOpt/Optuna hpo only call `_hp_search_setup(trial)` instead of passing trial\n            # parameter to Train when using DDP.\n            self.state.trial_name = self.hp_name(self._trial)\n        if trial is not None:\n            assignments = trial.assignments if self.hp_search_backend == HPSearchBackend.SIGOPT else trial\n            self.state.trial_params = hp_params(assignments)\n        else:\n            self.state.trial_params = None\n        # This should be the same if the state has been saved but in case the training arguments changed, it's safer\n        # to set this after the load.\n        self.state.max_steps = max_steps\n        self.state.num_train_epochs = num_train_epochs\n        self.state.is_local_process_zero = self.is_local_process_zero()\n        self.state.is_world_process_zero = self.is_world_process_zero()\n\n        # tr_loss is a tensor to avoid synchronization of TPUs through .item()\n        tr_loss = torch.tensor(0.0).to(args.device)\n        # _total_loss_scalar is updated everytime .item() has to be called on tr_loss and stores the sum of all losses\n        self._total_loss_scalar = 0.0\n        self._globalstep_last_logged = self.state.global_step\n        model.zero_grad()\n\n        self.control = self.callback_handler.on_train_begin(args, self.state, self.control)\n\n        # Skip the first epochs_trained epochs to get the random state of the dataloader at the right point.\n        if not args.ignore_data_skip:\n            for epoch in range(epochs_trained):\n                is_random_sampler = hasattr(train_dataloader, \"sampler\") and isinstance(\n                    train_dataloader.sampler, RandomSampler\n                )\n                if is_torch_less_than_1_11 or not is_random_sampler:\n                    # We just need to begin an iteration to create the randomization of the sampler.\n                    # That was before PyTorch 1.11 however...\n                    for _ in train_dataloader:\n                        break\n                else:\n                    # Otherwise we need to call the whooooole sampler cause there is some random operation added\n                    # AT THE VERY END!\n                    _ = list(train_dataloader.sampler)\n\n        total_batched_samples = 0\n        for epoch in range(epochs_trained, num_train_epochs):\n            if isinstance(train_dataloader, DataLoader) and isinstance(train_dataloader.sampler, DistributedSampler):\n                train_dataloader.sampler.set_epoch(epoch)\n            elif hasattr(train_dataloader, \"dataset\") and isinstance(train_dataloader.dataset, IterableDatasetShard):\n                train_dataloader.dataset.set_epoch(epoch)\n\n            if is_torch_tpu_available():\n                parallel_loader = pl.ParallelLoader(train_dataloader, [args.device]).per_device_loader(args.device)\n                epoch_iterator = parallel_loader\n            else:\n                epoch_iterator = train_dataloader\n\n            # Reset the past mems state at the beginning of each epoch if necessary.\n            if args.past_index >= 0:\n                self._past = None\n\n            steps_in_epoch = (\n                len(epoch_iterator)\n                if len_dataloader is not None\n                else args.max_steps * args.gradient_accumulation_steps\n            )\n            self.control = self.callback_handler.on_epoch_begin(args, self.state, self.control)\n\n            if epoch == epochs_trained and resume_from_checkpoint is not None and steps_trained_in_current_epoch == 0:\n                self._load_rng_state(resume_from_checkpoint)\n\n            rng_to_sync = False\n            steps_skipped = 0\n            if skip_first_batches is not None and steps_trained_in_current_epoch > 0:\n                epoch_iterator = skip_first_batches(epoch_iterator, steps_trained_in_current_epoch)\n                steps_skipped = steps_trained_in_current_epoch\n                steps_trained_in_current_epoch = 0\n                rng_to_sync = True\n\n            step = -1\n            for step, inputs in enumerate(epoch_iterator):\n                total_batched_samples += 1\n                if rng_to_sync:\n                    self._load_rng_state(resume_from_checkpoint)\n                    rng_to_sync = False\n\n                # Skip past any already trained steps if resuming training\n                if steps_trained_in_current_epoch > 0:\n                    steps_trained_in_current_epoch -= 1\n                    if steps_trained_progress_bar is not None:\n                        steps_trained_progress_bar.update(1)\n                    if steps_trained_in_current_epoch == 0:\n                        self._load_rng_state(resume_from_checkpoint)\n                    continue\n                elif steps_trained_progress_bar is not None:\n                    steps_trained_progress_bar.close()\n                    steps_trained_progress_bar = None\n\n                if step % args.gradient_accumulation_steps == 0:\n                    self.control = self.callback_handler.on_step_begin(args, self.state, self.control)\n\n                if (\n                    (total_batched_samples % args.gradient_accumulation_steps != 0)\n                    and args.local_rank != -1\n                    and args._no_sync_in_gradient_accumulation\n                ):\n                    # Avoid unnecessary DDP synchronization since there will be no backward pass on this example.\n                    with model.no_sync():\n                        tr_loss_step = self.training_step(model, inputs)\n                else:\n                    tr_loss_step = self.training_step(model, inputs)\n\n                if (\n                    args.logging_nan_inf_filter\n                    and not is_torch_tpu_available()\n                    and (torch.isnan(tr_loss_step) or torch.isinf(tr_loss_step))\n                ):\n                    # if loss is nan or inf simply add the average of previous logged losses\n                    tr_loss += tr_loss / (1 + self.state.global_step - self._globalstep_last_logged)\n                else:\n                    tr_loss += tr_loss_step\n\n                self.current_flos += float(self.floating_point_ops(inputs))\n\n                # Optimizer step for deepspeed must be called on every step regardless of the value of gradient_accumulation_steps\n                if self.deepspeed:\n                    self.deepspeed.step()\n\n                if total_batched_samples % args.gradient_accumulation_steps == 0 or (\n                    # last step in epoch but step is always smaller than gradient_accumulation_steps\n                    steps_in_epoch <= args.gradient_accumulation_steps\n                    and (step + 1) == steps_in_epoch\n                ):\n                    # Gradient clipping\n                    if args.max_grad_norm is not None and args.max_grad_norm > 0 and not self.deepspeed:\n                        # deepspeed does its own clipping\n\n                        if self.do_grad_scaling:\n                            # Reduce gradients first for XLA\n                            if is_torch_tpu_available():\n                                gradients = xm._fetch_gradients(self.optimizer)\n                                xm.all_reduce(\"sum\", gradients, scale=1.0 / xm.xrt_world_size())\n                            # AMP: gradients need unscaling\n                            self.scaler.unscale_(self.optimizer)\n\n                        if is_sagemaker_mp_enabled() and args.fp16:\n                            self.optimizer.clip_master_grads(args.max_grad_norm)\n                        elif hasattr(self.optimizer, \"clip_grad_norm\"):\n                            # Some optimizers (like the sharded optimizer) have a specific way to do gradient clipping\n                            self.optimizer.clip_grad_norm(args.max_grad_norm)\n                        elif hasattr(model, \"clip_grad_norm_\"):\n                            # Some models (like FullyShardedDDP) have a specific way to do gradient clipping\n                            model.clip_grad_norm_(args.max_grad_norm)\n                        else:\n                            # Revert to normal clipping otherwise, handling Apex or full precision\n                            nn.utils.clip_grad_norm_(\n                                amp.master_params(self.optimizer) if self.use_apex else model.parameters(),\n                                args.max_grad_norm,\n                            )\n\n                    # Optimizer step\n                    optimizer_was_run = True\n                    if self.deepspeed:\n                        pass  # called outside the loop\n                    elif is_torch_tpu_available():\n                        if self.do_grad_scaling:\n                            self.scaler.step(self.optimizer)\n                            self.scaler.update()\n                        else:\n                            xm.optimizer_step(self.optimizer)\n                    elif self.do_grad_scaling:\n                        scale_before = self.scaler.get_scale()\n                        self.scaler.step(self.optimizer)\n                        self.scaler.update()\n                        scale_after = self.scaler.get_scale()\n                        optimizer_was_run = scale_before <= scale_after\n                    else:\n                        self.optimizer.step()\n\n                    if optimizer_was_run and not self.deepspeed:\n                        self.lr_scheduler.step()\n\n                    model.zero_grad()\n                    self.state.global_step += 1\n                    self.state.epoch = epoch + (step + 1 + steps_skipped) / steps_in_epoch\n                    self.control = self.callback_handler.on_step_end(args, self.state, self.control)\n\n                    self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n                else:\n                    self.control = self.callback_handler.on_substep_end(args, self.state, self.control)\n\n                if self.control.should_epoch_stop or self.control.should_training_stop:\n                    break\n            if step < 0:\n                logger.warning(\n                    \"There seems to be not a single sample in your epoch_iterator, stopping training at step\"\n                    f\" {self.state.global_step}! This is expected if you're using an IterableDataset and set\"\n                    f\" num_steps ({max_steps}) higher than the number of available samples.\"\n                )\n                self.control.should_training_stop = True\n\n            self.control = self.callback_handler.on_epoch_end(args, self.state, self.control)\n            self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)\n\n            if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n                if is_torch_tpu_available():\n                    # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n                    xm.master_print(met.metrics_report())\n                else:\n                    logger.warning(\n                        \"You enabled PyTorch/XLA debug metrics but you don't have a TPU \"\n                        \"configured. Check your training configuration if this is unexpected.\"\n                    )\n            if self.control.should_training_stop:\n                break\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of training\n            delattr(self, \"_past\")\n\n        logger.info(\"\\n\\nTraining completed. Do not forget to share your model on huggingface.co/models =)\\n\\n\")\n        if args.load_best_model_at_end and self.state.best_model_checkpoint is not None:\n            # Wait for everyone to get here so we are sur the model has been saved by process 0.\n            if is_torch_tpu_available():\n                xm.rendezvous(\"load_best_model_at_end\")\n            elif args.local_rank != -1:\n                dist.barrier()\n            elif is_sagemaker_mp_enabled():\n                smp.barrier()\n\n            self._load_best_model()\n\n        # add remaining tr_loss\n        self._total_loss_scalar += tr_loss.item()\n        train_loss = self._total_loss_scalar / self.state.global_step\n\n        metrics = speed_metrics(\"train\", start_time, num_samples=num_train_samples, num_steps=self.state.max_steps)\n        self.store_flos()\n        metrics[\"total_flos\"] = self.state.total_flos\n        metrics[\"train_loss\"] = train_loss\n\n        self.is_in_train = False\n\n        self._memory_tracker.stop_and_update_metrics(metrics)\n\n        self.log(metrics)\n\n        run_dir = self._get_output_dir(trial)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=False, output_dir=run_dir)\n\n        # Delete the last checkpoint when save_total_limit=1 if it's different from the best checkpoint and process allowed to save.\n        if self.args.should_save and self.state.best_model_checkpoint is not None and self.args.save_total_limit == 1:\n            for checkpoint in checkpoints_sorted:\n                if checkpoint != self.state.best_model_checkpoint:\n                    logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n                    shutil.rmtree(checkpoint)\n\n        self.control = self.callback_handler.on_train_end(args, self.state, self.control)\n\n        return TrainOutput(self.state.global_step, train_loss, metrics)\n\n    def _get_output_dir(self, trial):\n        if self.hp_search_backend is not None and trial is not None:\n            if self.hp_search_backend == HPSearchBackend.OPTUNA:\n                run_id = trial.number\n            elif self.hp_search_backend == HPSearchBackend.RAY:\n                from ray import tune\n\n                run_id = tune.get_trial_id()\n            elif self.hp_search_backend == HPSearchBackend.SIGOPT:\n                run_id = trial.id\n            elif self.hp_search_backend == HPSearchBackend.WANDB:\n                import wandb\n\n                run_id = wandb.run.id\n            run_name = self.hp_name(trial) if self.hp_name is not None else f\"run-{run_id}\"\n            run_dir = os.path.join(self.args.output_dir, run_name)\n        else:\n            run_dir = self.args.output_dir\n        return run_dir\n\n    def _load_from_checkpoint(self, resume_from_checkpoint, model=None):\n        if model is None:\n            model = self.model\n\n        if not os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)) and not os.path.isfile(\n            os.path.join(resume_from_checkpoint, WEIGHTS_INDEX_NAME)\n        ):\n            raise ValueError(f\"Can't find a valid checkpoint at {resume_from_checkpoint}\")\n\n        logger.info(f\"Loading model from {resume_from_checkpoint}.\")\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, CONFIG_NAME)):\n            config = PretrainedConfig.from_json_file(os.path.join(resume_from_checkpoint, CONFIG_NAME))\n            checkpoint_version = config.transformers_version\n            if checkpoint_version is not None and checkpoint_version != __version__:\n                logger.warning(\n                    f\"You are resuming training from a checkpoint trained with {checkpoint_version} of \"\n                    f\"Transformers but your current version is {__version__}. This is not recommended and could \"\n                    \"yield to errors or unwanted behaviors.\"\n                )\n\n        if os.path.isfile(os.path.join(resume_from_checkpoint, WEIGHTS_NAME)):\n            # If the model is on the GPU, it still works!\n            if is_sagemaker_mp_enabled():\n                if os.path.isfile(os.path.join(resume_from_checkpoint, \"user_content.pt\")):\n                    # If the 'user_content.pt' file exists, load with the new smp api.\n                    # Checkpoint must have been saved with the new smp api.\n                    smp.resume_from_checkpoint(\n                        path=resume_from_checkpoint, tag=WEIGHTS_NAME, partial=False, load_optimizer=False\n                    )\n                else:\n                    # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                    # Checkpoint must have been saved with the old smp api.\n                    if hasattr(self.args, \"fp16\") and self.args.fp16 is True:\n                        logger.warning(\n                            \"Enabling FP16 and loading from smp < 1.10 checkpoint together is not suppported.\"\n                        )\n                    state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                    # Required for smp to not auto-translate state_dict from hf to smp (is already smp).\n                    state_dict[\"_smp_is_partial\"] = False\n                    load_result = model.load_state_dict(state_dict, strict=True)\n                    # release memory\n                    del state_dict\n            else:\n                # We load the model state dict on the CPU to avoid an OOM error.\n                state_dict = torch.load(os.path.join(resume_from_checkpoint, WEIGHTS_NAME), map_location=\"cpu\")\n                # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                # which takes *args instead of **kwargs\n                load_result = model.load_state_dict(state_dict, False)\n                # release memory\n                del state_dict\n                self._issue_warnings_after_load(load_result)\n        else:\n            # We load the sharded checkpoint\n            load_result = load_sharded_checkpoint(model, resume_from_checkpoint, strict=is_sagemaker_mp_enabled())\n            if not is_sagemaker_mp_enabled():\n                self._issue_warnings_after_load(load_result)\n\n    def _load_best_model(self):\n        logger.info(f\"Loading best model from {self.state.best_model_checkpoint} (score: {self.state.best_metric}).\")\n        best_model_path = os.path.join(self.state.best_model_checkpoint, WEIGHTS_NAME)\n        model = self.model_wrapped if is_sagemaker_mp_enabled() else self.model\n        if os.path.exists(best_model_path):\n            if self.deepspeed:\n                if self.model_wrapped is not None:\n                    # this removes the pre-hooks from the previous engine\n                    self.model_wrapped.destroy()\n                    self.model_wrapped = None\n\n                # temp hack until Deepspeed fixes the problem with resume from an existing engine that did some stepping\n                deepspeed_engine, optimizer, lr_scheduler = deepspeed_init(\n                    self,\n                    num_training_steps=self.args.max_steps,\n                    resume_from_checkpoint=self.state.best_model_checkpoint,\n                )\n                self.model = deepspeed_engine.module\n                self.model_wrapped = deepspeed_engine\n                self.deepspeed = deepspeed_engine\n                self.optimizer = optimizer\n                self.lr_scheduler = lr_scheduler\n            else:\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(self.state.best_model_checkpoint, \"user_content.pt\")):\n                        # If the 'user_content.pt' file exists, load with the new smp api.\n                        # Checkpoint must have been saved with the new smp api.\n                        smp.resume_from_checkpoint(\n                            path=self.state.best_model_checkpoint,\n                            tag=WEIGHTS_NAME,\n                            partial=False,\n                            load_optimizer=False,\n                        )\n                    else:\n                        # If the 'user_content.pt' file does NOT exist, load with the old smp api.\n                        # Checkpoint must have been saved with the old smp api.\n                        state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                        state_dict[\"_smp_is_partial\"] = False\n                        load_result = model.load_state_dict(state_dict, strict=True)\n                else:\n                    # We load the model state dict on the CPU to avoid an OOM error.\n                    state_dict = torch.load(best_model_path, map_location=\"cpu\")\n                    # If the model is on the GPU, it still works!\n                    # workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963\n                    # which takes *args instead of **kwargs\n                    load_result = model.load_state_dict(state_dict, False)\n                if not is_sagemaker_mp_enabled():\n                    self._issue_warnings_after_load(load_result)\n        elif os.path.exists(os.path.join(self.state.best_model_checkpoint, WEIGHTS_INDEX_NAME)):\n            load_result = load_sharded_checkpoint(\n                model, self.state.best_model_checkpoint, strict=is_sagemaker_mp_enabled()\n            )\n            if not is_sagemaker_mp_enabled():\n                self._issue_warnings_after_load(load_result)\n        else:\n            logger.warning(\n                f\"Could not locate the best model at {best_model_path}, if you are running a distributed training \"\n                \"on multiple nodes, you should activate `--save_on_each_node`.\"\n            )\n\n    def _issue_warnings_after_load(self, load_result):\n        if len(load_result.missing_keys) != 0:\n            if self.model._keys_to_ignore_on_save is not None and set(load_result.missing_keys) == set(\n                self.model._keys_to_ignore_on_save\n            ):\n                self.model.tie_weights()\n            else:\n                logger.warning(f\"There were missing keys in the checkpoint model loaded: {load_result.missing_keys}.\")\n        if len(load_result.unexpected_keys) != 0:\n            logger.warning(\n                f\"There were unexpected keys in the checkpoint model loaded: {load_result.unexpected_keys}.\"\n            )\n\n    def _maybe_log_save_evaluate(self, tr_loss, model, trial, epoch, ignore_keys_for_eval):\n        if self.control.should_log:\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            logs: Dict[str, float] = {}\n\n            # all_gather + mean() to get average loss over all processes\n            tr_loss_scalar = self._nested_gather(tr_loss).mean().item()\n\n            # reset tr_loss to zero\n            tr_loss -= tr_loss\n\n            logs[\"loss\"] = round(tr_loss_scalar / (self.state.global_step - self._globalstep_last_logged), 4)\n            logs[\"learning_rate\"] = self._get_learning_rate()\n\n            self._total_loss_scalar += tr_loss_scalar\n            self._globalstep_last_logged = self.state.global_step\n            self.store_flos()\n\n            self.log(logs)\n\n        metrics = None\n        if self.control.should_evaluate:\n            if isinstance(self.eval_dataset, dict):\n                for eval_dataset_name, eval_dataset in self.eval_dataset.items():\n                    metrics = self.evaluate(\n                        eval_dataset=eval_dataset,\n                        ignore_keys=ignore_keys_for_eval,\n                        metric_key_prefix=f\"eval_{eval_dataset_name}\",\n                    )\n            else:\n                metrics = self.evaluate(ignore_keys=ignore_keys_for_eval)\n            self._report_to_hp_search(trial, self.state.global_step, metrics)\n\n        if self.control.should_save:\n            self._save_checkpoint(model, trial, metrics=metrics)\n            self.control = self.callback_handler.on_save(self.args, self.state, self.control)\n\n    def _load_rng_state(self, checkpoint):\n        # Load RNG states from `checkpoint`\n        if checkpoint is None:\n            return\n\n        if self.args.world_size > 1:\n            process_index = self.args.process_index\n            rng_file = os.path.join(checkpoint, f\"rng_state_{process_index}.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    f\"Didn't find an RNG file for process {process_index}, if you are resuming a training that \"\n                    \"wasn't launched in a distributed fashion, reproducibility is not guaranteed.\"\n                )\n                return\n        else:\n            rng_file = os.path.join(checkpoint, \"rng_state.pth\")\n            if not os.path.isfile(rng_file):\n                logger.info(\n                    \"Didn't find an RNG file, if you are resuming a training that was launched in a distributed \"\n                    \"fashion, reproducibility is not guaranteed.\"\n                )\n                return\n\n        checkpoint_rng_state = torch.load(rng_file)\n        random.setstate(checkpoint_rng_state[\"python\"])\n        np.random.set_state(checkpoint_rng_state[\"numpy\"])\n        torch.random.set_rng_state(checkpoint_rng_state[\"cpu\"])\n        if torch.cuda.is_available():\n            if self.args.local_rank != -1:\n                torch.cuda.random.set_rng_state(checkpoint_rng_state[\"cuda\"])\n            else:\n                try:\n                    torch.cuda.random.set_rng_state_all(checkpoint_rng_state[\"cuda\"])\n                except Exception as e:\n                    logger.info(\n                        f\"Didn't manage to set back the RNG states of the GPU because of the following error:\\n {e}\"\n                        \"\\nThis won't yield the same results as if the training had not been interrupted.\"\n                    )\n        if is_torch_tpu_available():\n            xm.set_rng_state(checkpoint_rng_state[\"xla\"])\n\n    def _save_checkpoint(self, model, trial, metrics=None):\n        # In all cases, including ddp/dp/deepspeed, self.model is always a reference to the model we\n        # want to save except FullyShardedDDP.\n        # assert unwrap_model(model) is self.model, \"internal model should be a reference to self.model\"\n\n        # Save model checkpoint\n        checkpoint_folder = f\"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}\"\n\n        if self.hp_search_backend is None and trial is None:\n            self.store_flos()\n\n        run_dir = self._get_output_dir(trial=trial)\n        output_dir = os.path.join(run_dir, checkpoint_folder)\n        self.save_model(output_dir, _internal_call=True)\n        if self.deepspeed:\n            # under zero3 model file itself doesn't get saved since it's bogus! Unless deepspeed\n            # config `stage3_gather_16bit_weights_on_model_save` is True\n            self.deepspeed.save_checkpoint(output_dir)\n\n        # Save optimizer and scheduler\n        if self.sharded_ddp == ShardedDDPOption.SIMPLE:\n            self.optimizer.consolidate_state_dict()\n\n        if is_torch_tpu_available():\n            xm.rendezvous(\"saving_optimizer_states\")\n            xm.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                xm.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n        elif is_sagemaker_mp_enabled():\n            opt_state_dict = self.optimizer.local_state_dict(gather_if_shard=False)\n            smp.barrier()\n            if smp.rdp_rank() == 0 or smp.state.cfg.shard_optimizer_state:\n                smp.save(\n                    opt_state_dict,\n                    os.path.join(output_dir, OPTIMIZER_NAME),\n                    partial=True,\n                    v3=smp.state.cfg.shard_optimizer_state,\n                )\n            if self.args.should_save:\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling:\n                    torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n        elif self.args.should_save and not self.deepspeed:\n            # deepspeed.save_checkpoint above saves model/optim/sched\n            torch.save(self.optimizer.state_dict(), os.path.join(output_dir, OPTIMIZER_NAME))\n            with warnings.catch_warnings(record=True) as caught_warnings:\n                torch.save(self.lr_scheduler.state_dict(), os.path.join(output_dir, SCHEDULER_NAME))\n            reissue_pt_warnings(caught_warnings)\n            if self.do_grad_scaling:\n                torch.save(self.scaler.state_dict(), os.path.join(output_dir, SCALER_NAME))\n\n        # Determine the new best metric / best model checkpoint\n        if metrics is not None and self.args.metric_for_best_model is not None:\n            metric_to_check = self.args.metric_for_best_model\n            if not metric_to_check.startswith(\"eval_\"):\n                metric_to_check = f\"eval_{metric_to_check}\"\n            metric_value = metrics[metric_to_check]\n\n            operator = np.greater if self.args.greater_is_better else np.less\n            if (\n                self.state.best_metric is None\n                or self.state.best_model_checkpoint is None\n                or operator(metric_value, self.state.best_metric)\n            ):\n                self.state.best_metric = metric_value\n                self.state.best_model_checkpoint = output_dir\n\n        # Save the Trainer state\n        if self.args.should_save:\n            self.state.save_to_json(os.path.join(output_dir, TRAINER_STATE_NAME))\n\n        # Save RNG state in non-distributed training\n        rng_states = {\n            \"python\": random.getstate(),\n            \"numpy\": np.random.get_state(),\n            \"cpu\": torch.random.get_rng_state(),\n        }\n        if torch.cuda.is_available():\n            if self.args.local_rank == -1:\n                # In non distributed, we save the global CUDA RNG state (will take care of DataParallel)\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state_all()\n            else:\n                rng_states[\"cuda\"] = torch.cuda.random.get_rng_state()\n\n        if is_torch_tpu_available():\n            rng_states[\"xla\"] = xm.get_rng_state()\n\n        # A process can arrive here before the process 0 has a chance to save the model, in which case output_dir may\n        # not yet exist.\n        os.makedirs(output_dir, exist_ok=True)\n\n        if self.args.world_size <= 1:\n            torch.save(rng_states, os.path.join(output_dir, \"rng_state.pth\"))\n        else:\n            torch.save(rng_states, os.path.join(output_dir, f\"rng_state_{self.args.process_index}.pth\"))\n\n        if self.args.push_to_hub:\n            self._push_from_checkpoint(output_dir)\n\n        # Maybe delete some older checkpoints.\n        if self.args.should_save:\n            self._rotate_checkpoints(use_mtime=True, output_dir=run_dir)\n\n    def _load_optimizer_and_scheduler(self, checkpoint):\n        \"\"\"If optimizer and scheduler states exist, load them.\"\"\"\n        if checkpoint is None:\n            return\n\n        if self.deepspeed:\n            # deepspeed loads optimizer/lr_scheduler together with the model in deepspeed_init\n            return\n\n        checkpoint_file_exists = (\n            glob.glob(os.path.join(checkpoint, OPTIMIZER_NAME) + \"_*\")\n            if is_sagemaker_mp_enabled()\n            else os.path.isfile(os.path.join(checkpoint, OPTIMIZER_NAME))\n        )\n        if checkpoint_file_exists and os.path.isfile(os.path.join(checkpoint, SCHEDULER_NAME)):\n            # Load in optimizer and scheduler states\n            if is_torch_tpu_available():\n                # On TPU we have to take some extra precautions to properly load the states on the right device.\n                optimizer_state = torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=\"cpu\")\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    lr_scheduler_state = torch.load(os.path.join(checkpoint, SCHEDULER_NAME), map_location=\"cpu\")\n                reissue_pt_warnings(caught_warnings)\n\n                xm.send_cpu_data_to_device(optimizer_state, self.args.device)\n                xm.send_cpu_data_to_device(lr_scheduler_state, self.args.device)\n\n                self.optimizer.load_state_dict(optimizer_state)\n                self.lr_scheduler.load_state_dict(lr_scheduler_state)\n            else:\n                map_location = \"cpu\" if is_sagemaker_mp_enabled() else self.args.device\n                if is_sagemaker_mp_enabled():\n                    if os.path.isfile(os.path.join(checkpoint, \"user_content.pt\")):\n                        # Optimizer checkpoint was saved with smp >= 1.10\n                        def opt_load_hook(mod, opt):\n                            opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    else:\n                        # Optimizer checkpoint was saved with smp < 1.10\n                        def opt_load_hook(mod, opt):\n                            if IS_SAGEMAKER_MP_POST_1_10:\n                                opt.load_state_dict(\n                                    smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True, back_compat=True)\n                                )\n                            else:\n                                opt.load_state_dict(smp.load(os.path.join(checkpoint, OPTIMIZER_NAME), partial=True))\n\n                    self.model_wrapped.register_post_step_hook(opt_load_hook)\n                else:\n                    self.optimizer.load_state_dict(\n                        torch.load(os.path.join(checkpoint, OPTIMIZER_NAME), map_location=map_location)\n                    )\n                with warnings.catch_warnings(record=True) as caught_warnings:\n                    self.lr_scheduler.load_state_dict(torch.load(os.path.join(checkpoint, SCHEDULER_NAME)))\n                reissue_pt_warnings(caught_warnings)\n                if self.do_grad_scaling and os.path.isfile(os.path.join(checkpoint, SCALER_NAME)):\n                    self.scaler.load_state_dict(torch.load(os.path.join(checkpoint, SCALER_NAME)))\n\n    def hyperparameter_search(\n        self,\n        hp_space: Optional[Callable[[\"optuna.Trial\"], Dict[str, float]]] = None,\n        compute_objective: Optional[Callable[[Dict[str, float]], float]] = None,\n        n_trials: int = 20,\n        direction: str = \"minimize\",\n        backend: Optional[Union[\"str\", HPSearchBackend]] = None,\n        hp_name: Optional[Callable[[\"optuna.Trial\"], str]] = None,\n        **kwargs,\n    ) -> BestRun:\n        \"\"\"\n        Launch an hyperparameter search using `optuna` or `Ray Tune` or `SigOpt`. The optimized quantity is determined\n        by `compute_objective`, which defaults to a function returning the evaluation loss when no metric is provided,\n        the sum of all metrics otherwise.\n\n        <Tip warning={true}>\n\n        To use this method, you need to have provided a `model_init` when initializing your [`Trainer`]: we need to\n        reinitialize the model at each new run. This is incompatible with the `optimizers` argument, so you need to\n        subclass [`Trainer`] and override the method [`~Trainer.create_optimizer_and_scheduler`] for custom\n        optimizer/scheduler.\n\n        </Tip>\n\n        Args:\n            hp_space (`Callable[[\"optuna.Trial\"], Dict[str, float]]`, *optional*):\n                A function that defines the hyperparameter search space. Will default to\n                [`~trainer_utils.default_hp_space_optuna`] or [`~trainer_utils.default_hp_space_ray`] or\n                [`~trainer_utils.default_hp_space_sigopt`] depending on your backend.\n            compute_objective (`Callable[[Dict[str, float]], float]`, *optional*):\n                A function computing the objective to minimize or maximize from the metrics returned by the `evaluate`\n                method. Will default to [`~trainer_utils.default_compute_objective`].\n            n_trials (`int`, *optional*, defaults to 100):\n                The number of trial runs to test.\n            direction (`str`, *optional*, defaults to `\"minimize\"`):\n                Whether to optimize greater or lower objects. Can be `\"minimize\"` or `\"maximize\"`, you should pick\n                `\"minimize\"` when optimizing the validation loss, `\"maximize\"` when optimizing one or several metrics.\n            backend (`str` or [`~training_utils.HPSearchBackend`], *optional*):\n                The backend to use for hyperparameter search. Will default to optuna or Ray Tune or SigOpt, depending\n                on which one is installed. If all are installed, will default to optuna.\n            hp_name (`Callable[[\"optuna.Trial\"], str]]`, *optional*):\n                A function that defines the trial/run name. Will default to None.\n            kwargs (`Dict[str, Any]`, *optional*):\n                Additional keyword arguments passed along to `optuna.create_study` or `ray.tune.run`. For more\n                information see:\n\n                - the documentation of\n                  [optuna.create_study](https://optuna.readthedocs.io/en/stable/reference/generated/optuna.study.create_study.html)\n                - the documentation of [tune.run](https://docs.ray.io/en/latest/tune/api_docs/execution.html#tune-run)\n                - the documentation of [sigopt](https://app.sigopt.com/docs/endpoints/experiments/create)\n\n        Returns:\n            [`trainer_utils.BestRun`]: All the information about the best run. Experiment summary can be found in\n            `run_summary` attribute for Ray backend.\n        \"\"\"\n        if backend is None:\n            backend = default_hp_search_backend()\n            if backend is None:\n                raise RuntimeError(\n                    \"At least one of optuna or ray should be installed. \"\n                    \"To install optuna run `pip install optuna`. \"\n                    \"To install ray run `pip install ray[tune]`. \"\n                    \"To install sigopt run `pip install sigopt`.\"\n                )\n        backend = HPSearchBackend(backend)\n        if backend == HPSearchBackend.OPTUNA and not is_optuna_available():\n            raise RuntimeError(\"You picked the optuna backend, but it is not installed. Use `pip install optuna`.\")\n        if backend == HPSearchBackend.RAY and not is_ray_tune_available():\n            raise RuntimeError(\n                \"You picked the Ray Tune backend, but it is not installed. Use `pip install 'ray[tune]'`.\"\n            )\n        if backend == HPSearchBackend.SIGOPT and not is_sigopt_available():\n            raise RuntimeError(\"You picked the sigopt backend, but it is not installed. Use `pip install sigopt`.\")\n        if backend == HPSearchBackend.WANDB and not is_wandb_available():\n            raise RuntimeError(\"You picked the wandb backend, but it is not installed. Use `pip install wandb`.\")\n        self.hp_search_backend = backend\n        if self.model_init is None:\n            raise RuntimeError(\n                \"To use hyperparameter search, you need to pass your model through a model_init function.\"\n            )\n\n        self.hp_space = default_hp_space[backend] if hp_space is None else hp_space\n        self.hp_name = hp_name\n        self.compute_objective = default_compute_objective if compute_objective is None else compute_objective\n\n        backend_dict = {\n            HPSearchBackend.OPTUNA: run_hp_search_optuna,\n            HPSearchBackend.RAY: run_hp_search_ray,\n            HPSearchBackend.SIGOPT: run_hp_search_sigopt,\n            HPSearchBackend.WANDB: run_hp_search_wandb,\n        }\n        best_run = backend_dict[backend](self, n_trials, direction, **kwargs)\n\n        self.hp_search_backend = None\n        return best_run\n\n    def log(self, logs: Dict[str, float]) -> None:\n        \"\"\"\n        Log `logs` on the various objects watching training.\n\n        Subclass and override this method to inject custom behavior.\n\n        Args:\n            logs (`Dict[str, float]`):\n                The values to log.\n        \"\"\"\n        if self.state.epoch is not None:\n            logs[\"epoch\"] = round(self.state.epoch, 2)\n\n        output = {**logs, **{\"step\": self.state.global_step}}\n        self.state.log_history.append(output)\n        self.control = self.callback_handler.on_log(self.args, self.state, self.control, logs)\n\n    def _prepare_input(self, data: Union[torch.Tensor, Any]) -> Union[torch.Tensor, Any]:\n        \"\"\"\n        Prepares one `data` before feeding it to the model, be it a tensor or a nested list/dictionary of tensors.\n        \"\"\"\n        if isinstance(data, Mapping):\n            return type(data)({k: self._prepare_input(v) for k, v in data.items()})\n        elif isinstance(data, (tuple, list)):\n            return type(data)(self._prepare_input(v) for v in data)\n        elif isinstance(data, torch.Tensor):\n            kwargs = {\"device\": self.args.device}\n            if self.deepspeed and (torch.is_floating_point(data) or torch.is_complex(data)):\n                # NLP models inputs are int/uint and those get adjusted to the right dtype of the\n                # embedding. Other models such as wav2vec2's inputs are already float and thus\n                # may need special handling to match the dtypes of the model\n                kwargs.update({\"dtype\": self.args.hf_deepspeed_config.dtype()})\n            return data.to(**kwargs)\n        return data\n\n    def _prepare_inputs(self, inputs: Dict[str, Union[torch.Tensor, Any]]) -> Dict[str, Union[torch.Tensor, Any]]:\n        \"\"\"\n        Prepare `inputs` before feeding them to the model, converting them to tensors if they are not already and\n        handling potential state.\n        \"\"\"\n        inputs = self._prepare_input(inputs)\n        if len(inputs) == 0:\n            raise ValueError(\n                \"The batch received was empty, your model won't be able to train on it. Double-check that your \"\n                f\"training dataset contains keys expected by the model: {','.join(self._signature_columns)}.\"\n            )\n        if self.args.past_index >= 0 and self._past is not None:\n            inputs[\"mems\"] = self._past\n\n        return inputs\n\n    def compute_loss_context_manager(self):\n        \"\"\"\n        A helper wrapper to group together context managers.\n        \"\"\"\n        return self.autocast_smart_context_manager()\n\n    def autocast_smart_context_manager(self, cache_enabled: Optional[bool] = True):\n        \"\"\"\n        A helper wrapper that creates an appropriate context manager for `autocast` while feeding it the desired\n        arguments, depending on the situation.\n        \"\"\"\n        if self.use_cuda_amp or self.use_cpu_amp:\n            if is_torch_greater_or_equal_than_1_10:\n                ctx_manager = (\n                    torch.cpu.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                    if self.use_cpu_amp\n                    else torch.cuda.amp.autocast(cache_enabled=cache_enabled, dtype=self.amp_dtype)\n                )\n            else:\n                ctx_manager = torch.cuda.amp.autocast()\n        else:\n            ctx_manager = contextlib.nullcontext() if sys.version_info >= (3, 7) else contextlib.suppress()\n\n        return ctx_manager\n\n    def training_step(self, model: nn.Module, inputs: Dict[str, Union[torch.Tensor, Any]]) -> torch.Tensor:\n        \"\"\"\n        Perform a training step on a batch of inputs.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to train.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n\n        Return:\n            `torch.Tensor`: The tensor with training loss on this batch.\n        \"\"\"\n        model.train()\n        inputs = self._prepare_inputs(inputs)\n\n        if is_sagemaker_mp_enabled():\n            loss_mb = smp_forward_backward(model, inputs, self.args.gradient_accumulation_steps)\n            return loss_mb.reduce_mean().detach().to(self.args.device)\n\n        with self.compute_loss_context_manager():\n            loss = self.compute_loss(model, inputs)\n\n        if self.args.n_gpu > 1:\n            loss = loss.mean()  # mean() to average on multi-gpu parallel training\n\n        if self.args.gradient_accumulation_steps > 1 and not self.deepspeed:\n            # deepspeed handles loss scaling by gradient_accumulation_steps in its `backward`\n            loss = loss / self.args.gradient_accumulation_steps\n\n        if self.do_grad_scaling:\n            self.scaler.scale(loss).backward()\n        elif self.use_apex:\n            with amp.scale_loss(loss, self.optimizer) as scaled_loss:\n                scaled_loss.backward()\n        elif self.deepspeed:\n            # loss gets scaled under gradient_accumulation_steps in deepspeed\n            loss = self.deepspeed.backward(loss)\n        else:\n            loss.backward()\n\n        return loss.detach()\n\n    def compute_loss(self, model, inputs, return_outputs=False):\n        \"\"\"\n        How the loss is computed by Trainer. By default, all models return the loss in the first element.\n\n        Subclass and override for custom behavior.\n        \"\"\"\n        if self.label_smoother is not None and \"labels\" in inputs:\n            labels = inputs.pop(\"labels\")\n        else:\n            labels = None\n        outputs = model(**inputs)\n        # Save past state if it exists\n        # TODO: this needs to be fixed and made cleaner later.\n        if self.args.past_index >= 0:\n            self._past = outputs[self.args.past_index]\n\n        if labels is not None:\n            if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():\n                loss = self.label_smoother(outputs, labels, shift_labels=True)\n            else:\n                loss = self.label_smoother(outputs, labels)\n        else:\n            if isinstance(outputs, dict) and \"loss\" not in outputs:\n                raise ValueError(\n                    \"The model did not return a loss from the inputs, only the following keys: \"\n                    f\"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}.\"\n                )\n            # We don't use .loss here since the model may return tuples instead of ModelOutput.\n            loss = outputs[\"loss\"] if isinstance(outputs, dict) else outputs[0]\n\n        return (loss, outputs) if return_outputs else loss\n\n    def is_local_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the local (e.g., on one machine if training in a distributed fashion on several\n        machines) main process.\n        \"\"\"\n        return self.args.local_process_index == 0\n\n    def is_world_process_zero(self) -> bool:\n        \"\"\"\n        Whether or not this process is the global main process (when training in a distributed fashion on several\n        machines, this is only going to be `True` for one process).\n        \"\"\"\n        # Special case for SageMaker ModelParallel since there process_index is dp_process_index, not the global\n        # process index.\n        if is_sagemaker_mp_enabled():\n            return smp.rank() == 0\n        else:\n            return self.args.process_index == 0\n\n    def save_model(self, output_dir: Optional[str] = None, _internal_call: bool = False):\n        \"\"\"\n        Will save the model, so you can reload it using `from_pretrained()`.\n\n        Will only save from the main process.\n        \"\"\"\n\n        if output_dir is None:\n            output_dir = self.args.output_dir\n\n        if is_torch_tpu_available():\n            self._save_tpu(output_dir)\n        elif is_sagemaker_mp_enabled():\n            # Calling the state_dict needs to be done on the wrapped model and on all processes.\n            os.makedirs(output_dir, exist_ok=True)\n            state_dict = self.model_wrapped.state_dict()\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n            if IS_SAGEMAKER_MP_POST_1_10:\n                # 'user_content.pt' indicates model state_dict saved with smp >= 1.10\n                Path(os.path.join(output_dir, \"user_content.pt\")).touch()\n        elif (\n            ShardedDDPOption.ZERO_DP_2 in self.args.sharded_ddp\n            or ShardedDDPOption.ZERO_DP_3 in self.args.sharded_ddp\n            or self.fsdp is not None\n        ):\n            state_dict = self.model.state_dict()\n\n            if self.args.should_save:\n                self._save(output_dir, state_dict=state_dict)\n        elif self.deepspeed:\n            # this takes care of everything as long as we aren't under zero3\n            if self.args.should_save:\n                self._save(output_dir)\n\n            if is_deepspeed_zero3_enabled():\n                # It's too complicated to try to override different places where the weights dump gets\n                # saved, so since under zero3 the file is bogus, simply delete it. The user should\n                # either user deepspeed checkpoint to resume or to recover full weights use\n                # zero_to_fp32.py stored in the checkpoint.\n                if self.args.should_save:\n                    file = os.path.join(output_dir, WEIGHTS_NAME)\n                    if os.path.isfile(file):\n                        # logger.info(f\"deepspeed zero3: removing {file}, see zero_to_fp32.py to recover weights\")\n                        os.remove(file)\n\n                # now save the real model if stage3_gather_16bit_weights_on_model_save=True\n                # if false it will not be saved.\n                # This must be called on all ranks\n                if not self.deepspeed.save_16bit_model(output_dir, WEIGHTS_NAME):\n                    logger.warning(\n                        \"deepspeed.save_16bit_model didn't save the model, since\"\n                        \" stage3_gather_16bit_weights_on_model_save=false. Saving the full checkpoint instead, use\"\n                        \" zero_to_fp32.py to recover weights\"\n                    )\n                    self.deepspeed.save_checkpoint(output_dir)\n\n        elif self.args.should_save:\n            self._save(output_dir)\n\n        # Push to the Hub when `save_model` is called by the user.\n        if self.args.push_to_hub and not _internal_call:\n            self.push_to_hub(commit_message=\"Model save\")\n\n    def _save_tpu(self, output_dir: Optional[str] = None):\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n\n        if xm.is_master_ordinal():\n            os.makedirs(output_dir, exist_ok=True)\n            torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n        xm.rendezvous(\"saving_checkpoint\")\n        if not isinstance(self.model, PreTrainedModel):\n            if isinstance(unwrap_model(self.model), PreTrainedModel):\n                unwrap_model(self.model).save_pretrained(\n                    output_dir,\n                    is_main_process=self.args.should_save,\n                    state_dict=self.model.state_dict(),\n                    save_function=xm.save,\n                )\n            else:\n                logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n                state_dict = self.model.state_dict()\n                xm.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        else:\n            self.model.save_pretrained(output_dir, is_main_process=self.args.should_save, save_function=xm.save)\n        if self.tokenizer is not None and self.args.should_save:\n            self.tokenizer.save_pretrained(output_dir)\n\n    def _save(self, output_dir: Optional[str] = None, state_dict=None):\n        # If we are executing this function, we are the process zero, so we don't check for that.\n        output_dir = output_dir if output_dir is not None else self.args.output_dir\n        os.makedirs(output_dir, exist_ok=True)\n        logger.info(f\"Saving model checkpoint to {output_dir}\")\n        # Save a trained model and configuration using `save_pretrained()`.\n        # They can then be reloaded using `from_pretrained()`\n        if not isinstance(self.model, PreTrainedModel):\n            if isinstance(unwrap_model(self.model), PreTrainedModel):\n                if state_dict is None:\n                    state_dict = self.model.state_dict()\n                unwrap_model(self.model).save_pretrained(output_dir, state_dict=filtered_state_dict)\n            else:\n                logger.info(\"Trainer.model is not a `PreTrainedModel`, only saving its state dict.\")\n                if state_dict is None:\n                    state_dict = self.model.state_dict()\n                torch.save(state_dict, os.path.join(output_dir, WEIGHTS_NAME))\n        else:\n            if self.save_prefixencoder:\n                print(\"Saving PrefixEncoder\")\n                state_dict = self.model.state_dict()\n                filtered_state_dict = {}\n                for k, v in self.model.named_parameters():\n                    if v.requires_grad:\n                        filtered_state_dict[k] = state_dict[k]\n                self.model.save_pretrained(output_dir, state_dict=filtered_state_dict)\n            else:\n                print(\"Saving the whole model\")\n                self.model.save_pretrained(output_dir, state_dict=state_dict)\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n\n        # Good practice: save your training arguments together with the trained model\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n    def store_flos(self):\n        # Storing the number of floating-point operations that went into the model\n        if self.args.local_rank != -1:\n            self.state.total_flos += (\n                distributed_broadcast_scalars([self.current_flos], device=self.args.device).sum().item()\n            )\n            self.current_flos = 0\n        else:\n            self.state.total_flos += self.current_flos\n            self.current_flos = 0\n\n    def _sorted_checkpoints(\n        self, output_dir=None, checkpoint_prefix=PREFIX_CHECKPOINT_DIR, use_mtime=False\n    ) -> List[str]:\n        ordering_and_checkpoint_path = []\n\n        glob_checkpoints = [str(x) for x in Path(output_dir).glob(f\"{checkpoint_prefix}-*\") if os.path.isdir(x)]\n\n        for path in glob_checkpoints:\n            if use_mtime:\n                ordering_and_checkpoint_path.append((os.path.getmtime(path), path))\n            else:\n                regex_match = re.match(f\".*{checkpoint_prefix}-([0-9]+)\", path)\n                if regex_match is not None and regex_match.groups() is not None:\n                    ordering_and_checkpoint_path.append((int(regex_match.groups()[0]), path))\n\n        checkpoints_sorted = sorted(ordering_and_checkpoint_path)\n        checkpoints_sorted = [checkpoint[1] for checkpoint in checkpoints_sorted]\n        # Make sure we don't delete the best model.\n        if self.state.best_model_checkpoint is not None:\n            best_model_index = checkpoints_sorted.index(str(Path(self.state.best_model_checkpoint)))\n            for i in range(best_model_index, len(checkpoints_sorted) - 2):\n                checkpoints_sorted[i], checkpoints_sorted[i + 1] = checkpoints_sorted[i + 1], checkpoints_sorted[i]\n        return checkpoints_sorted\n\n    def _rotate_checkpoints(self, use_mtime=False, output_dir=None) -> None:\n        if self.args.save_total_limit is None or self.args.save_total_limit <= 0:\n            return\n\n        # Check if we should delete older checkpoint(s)\n        checkpoints_sorted = self._sorted_checkpoints(use_mtime=use_mtime, output_dir=output_dir)\n        if len(checkpoints_sorted) <= self.args.save_total_limit:\n            return\n\n        # If save_total_limit=1 with load_best_model_at_end=True, we could end up deleting the last checkpoint, which\n        # we don't do to allow resuming.\n        save_total_limit = self.args.save_total_limit\n        if (\n            self.state.best_model_checkpoint is not None\n            and self.args.save_total_limit == 1\n            and checkpoints_sorted[-1] != self.state.best_model_checkpoint\n        ):\n            save_total_limit = 2\n\n        number_of_checkpoints_to_delete = max(0, len(checkpoints_sorted) - save_total_limit)\n        checkpoints_to_be_deleted = checkpoints_sorted[:number_of_checkpoints_to_delete]\n        for checkpoint in checkpoints_to_be_deleted:\n            logger.info(f\"Deleting older checkpoint [{checkpoint}] due to args.save_total_limit\")\n            shutil.rmtree(checkpoint, ignore_errors=True)\n\n    def evaluate(\n        self,\n        eval_dataset: Optional[Dataset] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> Dict[str, float]:\n        \"\"\"\n        Run evaluation and returns metrics.\n\n        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent\n        (pass it to the init `compute_metrics` argument).\n\n        You can also subclass and override this method to inject custom behavior.\n\n        Args:\n            eval_dataset (`Dataset`, *optional*):\n                Pass a dataset if you wish to override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns\n                not accepted by the `model.forward()` method are automatically removed. It must implement the `__len__`\n                method.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is \"eval\" (default)\n\n        Returns:\n            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The\n            dictionary also contains the epoch number which comes from the training state.\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        eval_dataloader = self.get_eval_dataloader(eval_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            eval_dataloader,\n            description=\"Evaluation\",\n            # No point gathering the predictions if there are no metrics, otherwise we defer to\n            # self.args.prediction_loss_only\n            prediction_loss_only=True if self.compute_metrics is None else None,\n            ignore_keys=ignore_keys,\n            metric_key_prefix=metric_key_prefix,\n        )\n\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.log(output.metrics)\n\n        if DebugOption.TPU_METRICS_DEBUG in self.args.debug:\n            # tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)\n            xm.master_print(met.metrics_report())\n\n        self.control = self.callback_handler.on_evaluate(self.args, self.state, self.control, output.metrics)\n\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return output.metrics\n\n    def predict(\n        self, test_dataset: Dataset, ignore_keys: Optional[List[str]] = None, metric_key_prefix: str = \"test\"\n    ) -> PredictionOutput:\n        \"\"\"\n        Run prediction and returns predictions and potential metrics.\n\n        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method\n        will also return metrics, like in `evaluate()`.\n\n        Args:\n            test_dataset (`Dataset`):\n                Dataset to run the predictions on. If it is an `datasets.Dataset`, columns not accepted by the\n                `model.forward()` method are automatically removed. Has to implement the method `__len__`\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"test\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"test_bleu\" if the prefix is \"test\" (default)\n\n        <Tip>\n\n        If your predictions or labels have different sequence length (for instance because you're doing dynamic padding\n        in a token classification task) the predictions will be padded (on the right) to allow for concatenation into\n        one array. The padding index is -100.\n\n        </Tip>\n\n        Returns: *NamedTuple* A namedtuple with the following keys:\n\n            - predictions (`np.ndarray`): The predictions on `test_dataset`.\n            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).\n            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained\n              labels).\n        \"\"\"\n        # memory metrics - must set up as early as possible\n        self._memory_tracker.start()\n\n        test_dataloader = self.get_test_dataloader(test_dataset)\n        start_time = time.time()\n\n        eval_loop = self.prediction_loop if self.args.use_legacy_prediction_loop else self.evaluation_loop\n        output = eval_loop(\n            test_dataloader, description=\"Prediction\", ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix\n        )\n        total_batch_size = self.args.eval_batch_size * self.args.world_size\n        if f\"{metric_key_prefix}_jit_compilation_time\" in output.metrics:\n            start_time += output.metrics[f\"{metric_key_prefix}_jit_compilation_time\"]\n        output.metrics.update(\n            speed_metrics(\n                metric_key_prefix,\n                start_time,\n                num_samples=output.num_samples,\n                num_steps=math.ceil(output.num_samples / total_batch_size),\n            )\n        )\n\n        self.control = self.callback_handler.on_predict(self.args, self.state, self.control, output.metrics)\n        self._memory_tracker.stop_and_update_metrics(output.metrics)\n\n        return PredictionOutput(predictions=output.predictions, label_ids=output.label_ids, metrics=output.metrics)\n\n    def evaluation_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(\n                self, num_training_steps=0, resume_from_checkpoint=None, inference=True\n            )\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = self.args.eval_batch_size\n\n        logger.info(f\"***** Running {description} *****\")\n        if has_length(dataloader):\n            logger.info(f\"  Num examples = {self.num_examples(dataloader)}\")\n        else:\n            logger.info(\"  Num examples: Unknown\")\n        logger.info(f\"  Batch size = {batch_size}\")\n\n        model.eval()\n\n        self.callback_handler.eval_dataloader = dataloader\n        # Do this before wrapping.\n        eval_dataset = getattr(dataloader, \"dataset\", None)\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        # Initialize containers\n        # losses/preds/labels on GPU/TPU (accumulated for eval_accumulation_steps)\n        losses_host = None\n        preds_host = None\n        labels_host = None\n        inputs_host = None\n\n        # losses/preds/labels on CPU (final containers)\n        all_losses = None\n        all_preds = None\n        all_labels = None\n        all_inputs = None\n        # Will be useful when we have an iterable dataset so don't know its length.\n\n        observed_num_examples = 0\n        # Main evaluation loop\n        for step, inputs in enumerate(dataloader):\n            # Update the observed num examples\n            observed_batch_size = find_batch_size(inputs)\n            if observed_batch_size is not None:\n                observed_num_examples += observed_batch_size\n                # For batch samplers, batch_size is not known by the dataloader in advance.\n                if batch_size is None:\n                    batch_size = observed_batch_size\n\n            # Prediction step\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if is_torch_tpu_available():\n                xm.mark_step()\n\n            # Update containers on host\n            if loss is not None:\n                losses = self._nested_gather(loss.repeat(batch_size))\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if labels is not None:\n                labels = self._pad_across_processes(labels)\n                labels = self._nested_gather(labels)\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_decode = self._pad_across_processes(inputs_decode)\n                inputs_decode = self._nested_gather(inputs_decode)\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            if logits is not None:\n                logits = self._pad_across_processes(logits)\n                logits = self._nested_gather(logits)\n                if self.preprocess_logits_for_metrics is not None:\n                    logits = self.preprocess_logits_for_metrics(logits, labels)\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                if losses_host is not None:\n                    losses = nested_numpify(losses_host)\n                    all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n                if preds_host is not None:\n                    logits = nested_numpify(preds_host)\n                    all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n                if inputs_host is not None:\n                    inputs_decode = nested_numpify(inputs_host)\n                    all_inputs = (\n                        inputs_decode\n                        if all_inputs is None\n                        else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n                    )\n                if labels_host is not None:\n                    labels = nested_numpify(labels_host)\n                    all_labels = (\n                        labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n                    )\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, inputs_host, labels_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        if losses_host is not None:\n            losses = nested_numpify(losses_host)\n            all_losses = losses if all_losses is None else np.concatenate((all_losses, losses), axis=0)\n        if preds_host is not None:\n            logits = nested_numpify(preds_host)\n            all_preds = logits if all_preds is None else nested_concat(all_preds, logits, padding_index=-100)\n        if inputs_host is not None:\n            inputs_decode = nested_numpify(inputs_host)\n            all_inputs = (\n                inputs_decode if all_inputs is None else nested_concat(all_inputs, inputs_decode, padding_index=-100)\n            )\n        if labels_host is not None:\n            labels = nested_numpify(labels_host)\n            all_labels = labels if all_labels is None else nested_concat(all_labels, labels, padding_index=-100)\n\n        # Number of samples\n        if has_length(eval_dataset):\n            num_samples = len(eval_dataset)\n        # The instance check is weird and does not actually check for the type, but whether the dataset has the right\n        # methods. Therefore we need to make sure it also has the attribute.\n        elif isinstance(eval_dataset, IterableDatasetShard) and getattr(eval_dataset, \"num_examples\", 0) > 0:\n            num_samples = eval_dataset.num_examples\n        else:\n            if has_length(dataloader):\n                num_samples = self.num_examples(dataloader)\n            else:  # both len(dataloader.dataset) and len(dataloader) fail\n                num_samples = observed_num_examples\n        if num_samples == 0 and observed_num_examples > 0:\n            num_samples = observed_num_examples\n\n        # Number of losses has been rounded to a multiple of batch_size and in a distributed training, the number of\n        # samplers has been rounded to a multiple of batch_size, so we truncate.\n        if all_losses is not None:\n            all_losses = all_losses[:num_samples]\n        if all_preds is not None:\n            all_preds = nested_truncate(all_preds, num_samples)\n        if all_labels is not None:\n            all_labels = nested_truncate(all_labels, num_samples)\n        if all_inputs is not None:\n            all_inputs = nested_truncate(all_inputs, num_samples)\n\n        # Metrics!\n        if self.compute_metrics is not None and all_preds is not None and all_labels is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=all_preds, label_ids=all_labels, inputs=all_inputs)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=all_preds, label_ids=all_labels))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if all_losses is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = all_losses.mean().item()\n        if hasattr(self, \"jit_compilation_time\"):\n            metrics[f\"{metric_key_prefix}_jit_compilation_time\"] = self.jit_compilation_time\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=all_preds, label_ids=all_labels, metrics=metrics, num_samples=num_samples)\n\n    def _nested_gather(self, tensors, name=None):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            if name is None:\n                name = \"nested_gather\"\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n        return tensors\n\n    # Copied from Accelerate.\n    def _pad_across_processes(self, tensor, pad_index=-100):\n        \"\"\"\n        Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so\n        they can safely be gathered.\n        \"\"\"\n        if isinstance(tensor, (list, tuple)):\n            return type(tensor)(self._pad_across_processes(t, pad_index=pad_index) for t in tensor)\n        elif isinstance(tensor, dict):\n            return type(tensor)({k: self._pad_across_processes(v, pad_index=pad_index) for k, v in tensor.items()})\n        elif not isinstance(tensor, torch.Tensor):\n            raise TypeError(\n                f\"Can't pad the values of type {type(tensor)}, only of nested list/tuple/dicts of tensors.\"\n            )\n\n        if len(tensor.shape) < 2:\n            return tensor\n        # Gather all sizes\n        size = torch.tensor(tensor.shape, device=tensor.device)[None]\n        sizes = self._nested_gather(size).cpu()\n\n        max_size = max(s[1] for s in sizes)\n        # When extracting XLA graphs for compilation, max_size is 0,\n        # so use inequality to avoid errors.\n        if tensor.shape[1] >= max_size:\n            return tensor\n\n        # Then pad to the maximum size\n        old_size = tensor.shape\n        new_size = list(old_size)\n        new_size[1] = max_size\n        new_tensor = tensor.new_zeros(tuple(new_size)) + pad_index\n        new_tensor[:, : old_size[1]] = tensor\n        return new_tensor\n\n    def prediction_step(\n        self,\n        model: nn.Module,\n        inputs: Dict[str, Union[torch.Tensor, Any]],\n        prediction_loss_only: bool,\n        ignore_keys: Optional[List[str]] = None,\n    ) -> Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]:\n        \"\"\"\n        Perform an evaluation step on `model` using `inputs`.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to evaluate.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n            prediction_loss_only (`bool`):\n                Whether or not to return the loss only.\n            ignore_keys (`Lst[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n\n        Return:\n            Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss,\n            logits and labels (each being optional).\n        \"\"\"\n        has_labels = False if len(self.label_names) == 0 else all(inputs.get(k) is not None for k in self.label_names)\n        # For CLIP-like models capable of returning loss values.\n        # If `return_loss` is not specified or being `None` in `inputs`, we check if the default value of `return_loss`\n        # is `True` in `model.forward`.\n        return_loss = inputs.get(\"return_loss\", None)\n        if return_loss is None:\n            return_loss = self.can_return_loss\n        loss_without_labels = True if len(self.label_names) == 0 and return_loss else False\n\n        inputs = self._prepare_inputs(inputs)\n        if ignore_keys is None:\n            if hasattr(self.model, \"config\"):\n                ignore_keys = getattr(self.model.config, \"keys_to_ignore_at_inference\", [])\n            else:\n                ignore_keys = []\n\n        # labels may be popped when computing the loss (label smoothing for instance) so we grab them first.\n        if has_labels or loss_without_labels:\n            labels = nested_detach(tuple(inputs.get(name) for name in self.label_names))\n            if len(labels) == 1:\n                labels = labels[0]\n        else:\n            labels = None\n\n        with torch.no_grad():\n            if is_sagemaker_mp_enabled():\n                raw_outputs = smp_forward_only(model, inputs)\n                if has_labels or loss_without_labels:\n                    if isinstance(raw_outputs, dict):\n                        loss_mb = raw_outputs[\"loss\"]\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        loss_mb = raw_outputs[0]\n                        logits_mb = raw_outputs[1:]\n\n                    loss = loss_mb.reduce_mean().detach().cpu()\n                    logits = smp_nested_concat(logits_mb)\n                else:\n                    loss = None\n                    if isinstance(raw_outputs, dict):\n                        logits_mb = tuple(v for k, v in raw_outputs.items() if k not in ignore_keys)\n                    else:\n                        logits_mb = raw_outputs\n                    logits = smp_nested_concat(logits_mb)\n            else:\n                if has_labels or loss_without_labels:\n                    with self.compute_loss_context_manager():\n                        loss, outputs = self.compute_loss(model, inputs, return_outputs=True)\n                    loss = loss.mean().detach()\n\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys + [\"loss\"])\n                    else:\n                        logits = outputs[1:]\n                else:\n                    loss = None\n                    with self.compute_loss_context_manager():\n                        outputs = model(**inputs)\n                    if isinstance(outputs, dict):\n                        logits = tuple(v for k, v in outputs.items() if k not in ignore_keys)\n                    else:\n                        logits = outputs\n                    # TODO: this needs to be fixed and made cleaner later.\n                    if self.args.past_index >= 0:\n                        self._past = outputs[self.args.past_index - 1]\n\n        if prediction_loss_only:\n            return (loss, None, None)\n\n        logits = nested_detach(logits)\n        if len(logits) == 1:\n            logits = logits[0]\n\n        return (loss, logits, labels)\n\n    def floating_point_ops(self, inputs: Dict[str, Union[torch.Tensor, Any]]):\n        \"\"\"\n        For models that inherit from [`PreTrainedModel`], uses that method to compute the number of floating point\n        operations for every backward + forward pass. If using another model, either implement such a method in the\n        model or subclass and override this method.\n\n        Args:\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n        Returns:\n            `int`: The number of floating-point operations.\n        \"\"\"\n        if hasattr(self.model, \"floating_point_ops\"):\n            return self.model.floating_point_ops(inputs)\n        else:\n            return 0\n\n    def init_git_repo(self, at_init: bool = False):\n        \"\"\"\n        Initializes a git repo in `self.args.hub_model_id`.\n\n        Args:\n            at_init (`bool`, *optional*, defaults to `False`):\n                Whether this function is called before any training or not. If `self.args.overwrite_output_dir` is\n                `True` and `at_init` is `True`, the path to the repo (which is `self.args.output_dir`) might be wiped\n                out.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n        if self.args.hub_model_id is None:\n            repo_name = Path(self.args.output_dir).absolute().name\n        else:\n            repo_name = self.args.hub_model_id\n        if \"/\" not in repo_name:\n            repo_name = get_full_repo_name(repo_name, token=self.args.hub_token)\n\n        # Make sure the repo exists.\n        create_repo(repo_name, token=self.args.hub_token, private=self.args.hub_private_repo, exist_ok=True)\n        try:\n            self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n        except EnvironmentError:\n            if self.args.overwrite_output_dir and at_init:\n                # Try again after wiping output_dir\n                shutil.rmtree(self.args.output_dir)\n                self.repo = Repository(self.args.output_dir, clone_from=repo_name, token=self.args.hub_token)\n            else:\n                raise\n\n        self.repo.git_pull()\n\n        # By default, ignore the checkpoint folders\n        if (\n            not os.path.exists(os.path.join(self.args.output_dir, \".gitignore\"))\n            and self.args.hub_strategy != HubStrategy.ALL_CHECKPOINTS\n        ):\n            with open(os.path.join(self.args.output_dir, \".gitignore\"), \"w\", encoding=\"utf-8\") as writer:\n                writer.writelines([\"checkpoint-*/\"])\n\n        # Add \"*.sagemaker\" to .gitignore if using SageMaker\n        if os.environ.get(\"SM_TRAINING_ENV\"):\n            self._add_sm_patterns_to_gitignore()\n\n        self.push_in_progress = None\n\n    def create_model_card(\n        self,\n        language: Optional[str] = None,\n        license: Optional[str] = None,\n        tags: Union[str, List[str], None] = None,\n        model_name: Optional[str] = None,\n        finetuned_from: Optional[str] = None,\n        tasks: Union[str, List[str], None] = None,\n        dataset_tags: Union[str, List[str], None] = None,\n        dataset: Union[str, List[str], None] = None,\n        dataset_args: Union[str, List[str], None] = None,\n    ):\n        \"\"\"\n        Creates a draft of a model card using the information available to the `Trainer`.\n\n        Args:\n            language (`str`, *optional*):\n                The language of the model (if applicable)\n            license (`str`, *optional*):\n                The license of the model. Will default to the license of the pretrained model used, if the original\n                model given to the `Trainer` comes from a repo on the Hub.\n            tags (`str` or `List[str]`, *optional*):\n                Some tags to be included in the metadata of the model card.\n            model_name (`str`, *optional*):\n                The name of the model.\n            finetuned_from (`str`, *optional*):\n                The name of the model used to fine-tune this one (if applicable). Will default to the name of the repo\n                of the original model given to the `Trainer` (if it comes from the Hub).\n            tasks (`str` or `List[str]`, *optional*):\n                One or several task identifiers, to be included in the metadata of the model card.\n            dataset_tags (`str` or `List[str]`, *optional*):\n                One or several dataset tags, to be included in the metadata of the model card.\n            dataset (`str` or `List[str]`, *optional*):\n                One or several dataset identifiers, to be included in the metadata of the model card.\n            dataset_args (`str` or `List[str]`, *optional*):\n               One or several dataset arguments, to be included in the metadata of the model card.\n        \"\"\"\n        if not self.is_world_process_zero():\n            return\n\n        training_summary = TrainingSummary.from_trainer(\n            self,\n            language=language,\n            license=license,\n            tags=tags,\n            model_name=model_name,\n            finetuned_from=finetuned_from,\n            tasks=tasks,\n            dataset_tags=dataset_tags,\n            dataset=dataset,\n            dataset_args=dataset_args,\n        )\n        model_card = training_summary.to_model_card()\n        with open(os.path.join(self.args.output_dir, \"README.md\"), \"w\") as f:\n            f.write(model_card)\n\n    def _push_from_checkpoint(self, checkpoint_folder):\n        # Only push from one node.\n        if not self.is_world_process_zero() or self.args.hub_strategy == HubStrategy.END:\n            return\n        # If we haven't finished the last push, we don't do this one.\n        if self.push_in_progress is not None and not self.push_in_progress.is_done:\n            return\n\n        output_dir = self.args.output_dir\n        # To avoid a new synchronization of all model weights, we just copy the file from the checkpoint folder\n        modeling_files = [CONFIG_NAME, WEIGHTS_NAME]\n        for modeling_file in modeling_files:\n            if os.path.isfile(os.path.join(checkpoint_folder, modeling_file)):\n                shutil.copy(os.path.join(checkpoint_folder, modeling_file), os.path.join(output_dir, modeling_file))\n        # Saving the tokenizer is fast and we don't know how many files it may have spawned, so we resave it to be sure.\n        if self.tokenizer is not None:\n            self.tokenizer.save_pretrained(output_dir)\n        # Same for the training arguments\n        torch.save(self.args, os.path.join(output_dir, TRAINING_ARGS_NAME))\n\n        try:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Temporarily move the checkpoint just saved for the push\n                tmp_checkpoint = os.path.join(output_dir, \"last-checkpoint\")\n                # We have to remove the \"last-checkpoint\" dir if it exists, otherwise the checkpoint is moved as a\n                # subfolder.\n                if os.path.isdir(tmp_checkpoint):\n                    shutil.rmtree(tmp_checkpoint)\n                shutil.move(checkpoint_folder, tmp_checkpoint)\n\n            if self.args.save_strategy == IntervalStrategy.STEPS:\n                commit_message = f\"Training in progress, step {self.state.global_step}\"\n            else:\n                commit_message = f\"Training in progress, epoch {int(self.state.epoch)}\"\n            _, self.push_in_progress = self.repo.push_to_hub(\n                commit_message=commit_message, blocking=False, auto_lfs_prune=True\n            )\n        finally:\n            if self.args.hub_strategy == HubStrategy.CHECKPOINT:\n                # Move back the checkpoint to its place\n                shutil.move(tmp_checkpoint, checkpoint_folder)\n\n    def push_to_hub(self, commit_message: Optional[str] = \"End of training\", blocking: bool = True, **kwargs) -> str:\n        \"\"\"\n        Upload *self.model* and *self.tokenizer* to the \ud83e\udd17 model hub on the repo *self.args.hub_model_id*.\n\n        Parameters:\n            commit_message (`str`, *optional*, defaults to `\"End of training\"`):\n                Message to commit while pushing.\n            blocking (`bool`, *optional*, defaults to `True`):\n                Whether the function should return only when the `git push` has finished.\n            kwargs:\n                Additional keyword arguments passed along to [`~Trainer.create_model_card`].\n\n        Returns:\n            The url of the commit of your model in the given repository if `blocking=False`, a tuple with the url of\n            the commit and an object to track the progress of the commit if `blocking=True`\n        \"\"\"\n        # If a user calls manually `push_to_hub` with `self.args.push_to_hub = False`, we try to create the repo but\n        # it might fail.\n        if not hasattr(self, \"repo\"):\n            self.init_git_repo()\n\n        model_name = kwargs.pop(\"model_name\", None)\n        if model_name is None and self.args.should_save:\n            if self.args.hub_model_id is None:\n                model_name = Path(self.args.output_dir).name\n            else:\n                model_name = self.args.hub_model_id.split(\"/\")[-1]\n\n        # Needs to be executed on all processes for TPU training, but will only save on the processed determined by\n        # self.args.should_save.\n        self.save_model(_internal_call=True)\n\n        # Only push from one node.\n        if not self.is_world_process_zero():\n            return\n\n        # Cancel any async push in progress if blocking=True. The commits will all be pushed together.\n        if blocking and self.push_in_progress is not None and not self.push_in_progress.is_done:\n            self.push_in_progress._process.kill()\n            self.push_in_progress = None\n\n        git_head_commit_url = self.repo.push_to_hub(\n            commit_message=commit_message, blocking=blocking, auto_lfs_prune=True\n        )\n        # push separately the model card to be independant from the rest of the model\n        if self.args.should_save:\n            self.create_model_card(model_name=model_name, **kwargs)\n            try:\n                self.repo.push_to_hub(\n                    commit_message=\"update model card README.md\", blocking=blocking, auto_lfs_prune=True\n                )\n            except EnvironmentError as exc:\n                logger.error(f\"Error pushing update to the model card. Please read logs and retry.\\n${exc}\")\n\n        return git_head_commit_url\n\n    #\n    # Deprecated code\n    #\n\n    def prediction_loop(\n        self,\n        dataloader: DataLoader,\n        description: str,\n        prediction_loss_only: Optional[bool] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n    ) -> EvalLoopOutput:\n        \"\"\"\n        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.\n\n        Works both with or without labels.\n        \"\"\"\n        args = self.args\n\n        if not has_length(dataloader):\n            raise ValueError(\"dataloader must implement a working __len__\")\n\n        prediction_loss_only = prediction_loss_only if prediction_loss_only is not None else args.prediction_loss_only\n\n        # if eval is called w/o train init deepspeed here\n        if args.deepspeed and not self.deepspeed:\n            # XXX: eval doesn't have `resume_from_checkpoint` arg but we should be able to do eval\n            # from the checkpoint eventually\n            deepspeed_engine, _, _ = deepspeed_init(self, num_training_steps=0, resume_from_checkpoint=None)\n            self.model = deepspeed_engine.module\n            self.model_wrapped = deepspeed_engine\n            self.deepspeed = deepspeed_engine\n            # XXX: we don't need optim/sched for inference, but this needs to be sorted out, since\n            # for example the Z3-optimizer is a must for zero3 to work even for inference - what we\n            # don't need is the deepspeed basic optimizer which is self.optimizer.optimizer\n            deepspeed_engine.optimizer.optimizer = None\n            deepspeed_engine.lr_scheduler = None\n\n        model = self._wrap_model(self.model, training=False, dataloader=dataloader)\n\n        # if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called\n        # while ``train`` is running, cast it to the right dtype first and then put on device\n        if not self.is_in_train:\n            if args.fp16_full_eval:\n                model = model.to(dtype=torch.float16, device=args.device)\n            elif args.bf16_full_eval:\n                model = model.to(dtype=torch.bfloat16, device=args.device)\n\n        batch_size = dataloader.batch_size\n        num_examples = self.num_examples(dataloader)\n        logger.info(f\"***** Running {description} *****\")\n        logger.info(f\"  Num examples = {num_examples}\")\n        logger.info(f\"  Batch size = {batch_size}\")\n        losses_host: torch.Tensor = None\n        preds_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        labels_host: Union[torch.Tensor, List[torch.Tensor]] = None\n        inputs_host: Union[torch.Tensor, List[torch.Tensor]] = None\n\n        world_size = max(1, args.world_size)\n\n        eval_losses_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=batch_size)\n        if not prediction_loss_only:\n            # The actual number of eval_sample can be greater than num_examples in distributed settings (when we pass\n            # a batch size to the sampler)\n            make_multiple_of = None\n            if hasattr(dataloader, \"sampler\") and isinstance(dataloader.sampler, SequentialDistributedSampler):\n                make_multiple_of = dataloader.sampler.batch_size\n            preds_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            labels_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n            inputs_gatherer = DistributedTensorGatherer(world_size, num_examples, make_multiple_of=make_multiple_of)\n\n        model.eval()\n\n        if is_torch_tpu_available():\n            dataloader = pl.ParallelLoader(dataloader, [args.device]).per_device_loader(args.device)\n\n        if args.past_index >= 0:\n            self._past = None\n\n        self.callback_handler.eval_dataloader = dataloader\n\n        for step, inputs in enumerate(dataloader):\n            loss, logits, labels = self.prediction_step(model, inputs, prediction_loss_only, ignore_keys=ignore_keys)\n            inputs_decode = self._prepare_input(inputs[\"input_ids\"]) if args.include_inputs_for_metrics else None\n\n            if loss is not None:\n                losses = loss.repeat(batch_size)\n                losses_host = losses if losses_host is None else torch.cat((losses_host, losses), dim=0)\n            if logits is not None:\n                preds_host = logits if preds_host is None else nested_concat(preds_host, logits, padding_index=-100)\n            if labels is not None:\n                labels_host = labels if labels_host is None else nested_concat(labels_host, labels, padding_index=-100)\n            if inputs_decode is not None:\n                inputs_host = (\n                    inputs_decode\n                    if inputs_host is None\n                    else nested_concat(inputs_host, inputs_decode, padding_index=-100)\n                )\n            self.control = self.callback_handler.on_prediction_step(args, self.state, self.control)\n\n            # Gather all tensors and put them back on the CPU if we have done enough accumulation steps.\n            if args.eval_accumulation_steps is not None and (step + 1) % args.eval_accumulation_steps == 0:\n                eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n                if not prediction_loss_only:\n                    preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n                    labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n                    inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n                # Set back to None to begin a new accumulation\n                losses_host, preds_host, labels_host, inputs_host = None, None, None, None\n\n        if args.past_index and hasattr(self, \"_past\"):\n            # Clean the state at the end of the evaluation loop\n            delattr(self, \"_past\")\n\n        # Gather all remaining tensors and put them back on the CPU\n        eval_losses_gatherer.add_arrays(self._gather_and_numpify(losses_host, \"eval_losses\"))\n        if not prediction_loss_only:\n            preds_gatherer.add_arrays(self._gather_and_numpify(preds_host, \"eval_preds\"))\n            labels_gatherer.add_arrays(self._gather_and_numpify(labels_host, \"eval_label_ids\"))\n            inputs_gatherer.add_arrays(self._gather_and_numpify(inputs_host, \"eval_inputs_ids\"))\n\n        eval_loss = eval_losses_gatherer.finalize()\n        preds = preds_gatherer.finalize() if not prediction_loss_only else None\n        label_ids = labels_gatherer.finalize() if not prediction_loss_only else None\n        inputs_ids = inputs_gatherer.finalize() if not prediction_loss_only else None\n\n        if self.compute_metrics is not None and preds is not None and label_ids is not None:\n            if args.include_inputs_for_metrics:\n                metrics = self.compute_metrics(\n                    EvalPrediction(predictions=preds, label_ids=label_ids, inputs=inputs_ids)\n                )\n            else:\n                metrics = self.compute_metrics(EvalPrediction(predictions=preds, label_ids=label_ids))\n        else:\n            metrics = {}\n\n        # To be JSON-serializable, we need to remove numpy types or zero-d tensors\n        metrics = denumpify_detensorize(metrics)\n\n        if eval_loss is not None:\n            metrics[f\"{metric_key_prefix}_loss\"] = eval_loss.mean().item()\n\n        # Prefix all keys with metric_key_prefix + '_'\n        for key in list(metrics.keys()):\n            if not key.startswith(f\"{metric_key_prefix}_\"):\n                metrics[f\"{metric_key_prefix}_{key}\"] = metrics.pop(key)\n\n        return EvalLoopOutput(predictions=preds, label_ids=label_ids, metrics=metrics, num_samples=num_examples)\n\n    def _gather_and_numpify(self, tensors, name):\n        \"\"\"\n        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before\n        concatenating them to `gathered`\n        \"\"\"\n        if tensors is None:\n            return\n        if is_torch_tpu_available():\n            tensors = nested_xla_mesh_reduce(tensors, name)\n        elif is_sagemaker_mp_enabled():\n            tensors = smp_gather(tensors)\n        elif self.args.local_rank != -1:\n            tensors = distributed_concat(tensors)\n\n        return nested_numpify(tensors)\n\n    def _add_sm_patterns_to_gitignore(self) -> None:\n        \"\"\"Add SageMaker Checkpointing patterns to .gitignore file.\"\"\"\n        # Make sure we only do this on the main process\n        if not self.is_world_process_zero():\n            return\n\n        patterns = [\"*.sagemaker-uploading\", \"*.sagemaker-uploaded\"]\n\n        # Get current .gitignore content\n        if os.path.exists(os.path.join(self.repo.local_dir, \".gitignore\")):\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"r\") as f:\n                current_content = f.read()\n        else:\n            current_content = \"\"\n\n        # Add the patterns to .gitignore\n        content = current_content\n        for pattern in patterns:\n            if pattern not in content:\n                if content.endswith(\"\\n\"):\n                    content += pattern\n                else:\n                    content += f\"\\n{pattern}\"\n\n        # Write the .gitignore file if it has changed\n        if content != current_content:\n            with open(os.path.join(self.repo.local_dir, \".gitignore\"), \"w\") as f:\n                logger.debug(f\"Writing .gitignore file. Content: {content}\")\n                f.write(content)\n\n        self.repo.git_add(\".gitignore\")\n\n        # avoid race condition with git status\n        time.sleep(0.5)\n\n        if not self.repo.is_repo_clean():\n            self.repo.git_commit(\"Add *.sagemaker patterns to .gitignore.\")\n            self.repo.git_push()\n", "ptuning/web_demo.py": "import os, sys\n\nimport gradio as gr\nimport mdtex2html\n\nimport torch\nimport transformers\nfrom transformers import (\n    AutoConfig,\n    AutoModel,\n    AutoTokenizer,\n    AutoTokenizer,\n    DataCollatorForSeq2Seq,\n    HfArgumentParser,\n    Seq2SeqTrainingArguments,\n    set_seed,\n)\n\nfrom arguments import ModelArguments, DataTrainingArguments\n\n\nmodel = None\ntokenizer = None\n\n\"\"\"Override Chatbot.postprocess\"\"\"\n\n\ndef postprocess(self, y):\n    if y is None:\n        return []\n    for i, (message, response) in enumerate(y):\n        y[i] = (\n            None if message is None else mdtex2html.convert((message)),\n            None if response is None else mdtex2html.convert(response),\n        )\n    return y\n\n\ngr.Chatbot.postprocess = postprocess\n\n\ndef parse_text(text):\n    \"\"\"copy from https://github.com/GaiZhenbiao/ChuanhuChatGPT/\"\"\"\n    lines = text.split(\"\\n\")\n    lines = [line for line in lines if line != \"\"]\n    count = 0\n    for i, line in enumerate(lines):\n        if \"```\" in line:\n            count += 1\n            items = line.split('`')\n            if count % 2 == 1:\n                lines[i] = f'<pre><code class=\"language-{items[-1]}\">'\n            else:\n                lines[i] = f'<br></code></pre>'\n        else:\n            if i > 0:\n                if count % 2 == 1:\n                    line = line.replace(\"`\", \"\\`\")\n                    line = line.replace(\"<\", \"&lt;\")\n                    line = line.replace(\">\", \"&gt;\")\n                    line = line.replace(\" \", \"&nbsp;\")\n                    line = line.replace(\"*\", \"&ast;\")\n                    line = line.replace(\"_\", \"&lowbar;\")\n                    line = line.replace(\"-\", \"&#45;\")\n                    line = line.replace(\".\", \"&#46;\")\n                    line = line.replace(\"!\", \"&#33;\")\n                    line = line.replace(\"(\", \"&#40;\")\n                    line = line.replace(\")\", \"&#41;\")\n                    line = line.replace(\"$\", \"&#36;\")\n                lines[i] = \"<br>\"+line\n    text = \"\".join(lines)\n    return text\n\n\ndef predict(input, chatbot, max_length, top_p, temperature, history):\n    chatbot.append((parse_text(input), \"\"))\n    for response, history in model.stream_chat(tokenizer, input, history, max_length=max_length, top_p=top_p,\n                                               temperature=temperature):\n        chatbot[-1] = (parse_text(input), parse_text(response))       \n\n        yield chatbot, history\n\n\ndef reset_user_input():\n    return gr.update(value='')\n\n\ndef reset_state():\n    return [], []\n\n\nwith gr.Blocks() as demo:\n    gr.HTML(\"\"\"<h1 align=\"center\">ChatGLM</h1>\"\"\")\n\n    chatbot = gr.Chatbot()\n    with gr.Row():\n        with gr.Column(scale=4):\n            with gr.Column(scale=12):\n                user_input = gr.Textbox(show_label=False, placeholder=\"Input...\", lines=10).style(\n                    container=False)\n            with gr.Column(min_width=32, scale=1):\n                submitBtn = gr.Button(\"Submit\", variant=\"primary\")\n        with gr.Column(scale=1):\n            emptyBtn = gr.Button(\"Clear History\")\n            max_length = gr.Slider(0, 4096, value=2048, step=1.0, label=\"Maximum length\", interactive=True)\n            top_p = gr.Slider(0, 1, value=0.7, step=0.01, label=\"Top P\", interactive=True)\n            temperature = gr.Slider(0, 1, value=0.95, step=0.01, label=\"Temperature\", interactive=True)\n\n    history = gr.State([])\n\n    submitBtn.click(predict, [user_input, chatbot, max_length, top_p, temperature, history], [chatbot, history],\n                    show_progress=True)\n    submitBtn.click(reset_user_input, [], [user_input])\n\n    emptyBtn.click(reset_state, outputs=[chatbot, history], show_progress=True)\n\n\n\ndef main():\n    global model, tokenizer\n\n    parser = HfArgumentParser((\n        ModelArguments))\n    if len(sys.argv) == 2 and sys.argv[1].endswith(\".json\"):\n        # If we pass only one argument to the script and it's the path to a json file,\n        # let's parse it to get our arguments.\n        model_args = parser.parse_json_file(json_file=os.path.abspath(sys.argv[1]))[0]\n    else:\n        model_args = parser.parse_args_into_dataclasses()[0]\n\n    tokenizer = AutoTokenizer.from_pretrained(\n        model_args.model_name_or_path, trust_remote_code=True)\n    config = AutoConfig.from_pretrained(\n        model_args.model_name_or_path, trust_remote_code=True)\n\n    config.pre_seq_len = model_args.pre_seq_len\n    config.prefix_projection = model_args.prefix_projection\n\n    if model_args.ptuning_checkpoint is not None:\n        print(f\"Loading prefix_encoder weight from {model_args.ptuning_checkpoint}\")\n        model = AutoModel.from_pretrained(model_args.model_name_or_path, config=config, trust_remote_code=True)\n        prefix_state_dict = torch.load(os.path.join(model_args.ptuning_checkpoint, \"pytorch_model.bin\"))\n        new_prefix_state_dict = {}\n        for k, v in prefix_state_dict.items():\n            if k.startswith(\"transformer.prefix_encoder.\"):\n                new_prefix_state_dict[k[len(\"transformer.prefix_encoder.\"):]] = v\n        model.transformer.prefix_encoder.load_state_dict(new_prefix_state_dict)\n    else:\n        model = AutoModel.from_pretrained(model_args.model_name_or_path, config=config, trust_remote_code=True)\n\n    if model_args.quantization_bit is not None:\n        print(f\"Quantized to {model_args.quantization_bit} bit\")\n        model = model.quantize(model_args.quantization_bit)\n\n    if model_args.pre_seq_len is not None:\n        # P-tuning v2\n        model = model.half().cuda()\n        model.transformer.prefix_encoder.float().cuda()\n    \n    model = model.eval()\n    demo.queue().launch(share=False, inbrowser=True)\n\n\n\nif __name__ == \"__main__\":\n    main()", "ptuning/main.py": "#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nFine-tuning the library models for sequence to sequence.\n\"\"\"\n# You can also adapt this script on your own sequence to sequence task. Pointers for this are left as comments.\n\nimport logging\nimport os\nimport sys\nimport json\n\nimport numpy as np\nfrom datasets import load_dataset\nimport jieba \nfrom rouge_chinese import Rouge\nfrom nltk.translate.bleu_score import sentence_bleu, SmoothingFunction\nimport torch\n\nimport transformers\nfrom transformers import (\n    AutoConfig,\n    AutoModel,\n    AutoTokenizer,\n    DataCollatorForSeq2Seq,\n    HfArgumentParser,\n    Seq2SeqTrainingArguments,\n    set_seed,\n)\nfrom trainer_seq2seq import Seq2SeqTrainer\n\nfrom arguments import ModelArguments, DataTrainingArguments\n\nlogger = logging.getLogger(__name__)\n\ndef main():\n\n    parser = HfArgumentParser((ModelArguments, DataTrainingArguments, Seq2SeqTrainingArguments))\n    if len(sys.argv) == 2 and sys.argv[1].endswith(\".json\"):\n        # If we pass only one argument to the script and it's the path to a json file,\n        # let's parse it to get our arguments.\n        model_args, data_args, training_args = parser.parse_json_file(json_file=os.path.abspath(sys.argv[1]))\n    else:\n        model_args, data_args, training_args = parser.parse_args_into_dataclasses()\n\n    # Setup logging\n    logging.basicConfig(\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        datefmt=\"%m/%d/%Y %H:%M:%S\",\n        handlers=[logging.StreamHandler(sys.stdout)],\n    )\n\n    if training_args.should_log:\n        # The default of training_args.log_level is passive, so we set log level at info here to have that default.\n        transformers.utils.logging.set_verbosity_info()\n\n    log_level = training_args.get_process_log_level()\n    logger.setLevel(log_level)\n    # datasets.utils.logging.set_verbosity(log_level)\n    transformers.utils.logging.set_verbosity(log_level)\n    transformers.utils.logging.enable_default_handler()\n    transformers.utils.logging.enable_explicit_format()\n\n    # Log on each process the small summary:\n    logger.warning(\n        f\"Process rank: {training_args.local_rank}, device: {training_args.device}, n_gpu: {training_args.n_gpu}\"\n        + f\"distributed training: {bool(training_args.local_rank != -1)}, 16-bits training: {training_args.fp16}\"\n    )\n    logger.info(f\"Training/evaluation parameters {training_args}\")\n\n    # Set seed before initializing model.\n    set_seed(training_args.seed)\n\n    # Load dataset\n    data_files = {}\n    if data_args.train_file is not None:\n        data_files[\"train\"] = data_args.train_file\n        extension = data_args.train_file.split(\".\")[-1]\n    if data_args.validation_file is not None:\n        data_files[\"validation\"] = data_args.validation_file\n        extension = data_args.validation_file.split(\".\")[-1]\n    if data_args.test_file is not None:\n        data_files[\"test\"] = data_args.test_file\n        extension = data_args.test_file.split(\".\")[-1]\n\n    raw_datasets = load_dataset(\n        extension,\n        data_files=data_files,\n        cache_dir=model_args.cache_dir,\n        use_auth_token=True if model_args.use_auth_token else None,\n    )\n\n    # Load pretrained model and tokenizer\n    config = AutoConfig.from_pretrained(model_args.model_name_or_path, trust_remote_code=True)\n    config.pre_seq_len = model_args.pre_seq_len\n    config.prefix_projection = model_args.prefix_projection\n\n    tokenizer = AutoTokenizer.from_pretrained(model_args.model_name_or_path, trust_remote_code=True)\n\n    if model_args.ptuning_checkpoint is not None:\n        # Evaluation\n        # Loading extra state dict of prefix encoder\n        model = AutoModel.from_pretrained(model_args.model_name_or_path, config=config, trust_remote_code=True)\n        prefix_state_dict = torch.load(os.path.join(model_args.ptuning_checkpoint, \"pytorch_model.bin\"))\n        new_prefix_state_dict = {}\n        for k, v in prefix_state_dict.items():\n            if k.startswith(\"transformer.prefix_encoder.\"):\n                new_prefix_state_dict[k[len(\"transformer.prefix_encoder.\"):]] = v\n        model.transformer.prefix_encoder.load_state_dict(new_prefix_state_dict)\n    else:\n        model = AutoModel.from_pretrained(model_args.model_name_or_path, config=config, trust_remote_code=True)\n\n    if model_args.quantization_bit is not None:\n        print(f\"Quantized to {model_args.quantization_bit} bit\")\n        model = model.quantize(model_args.quantization_bit)\n    if model_args.pre_seq_len is not None:\n        # P-tuning v2\n        model = model.half()\n        model.transformer.prefix_encoder.float()\n    else:\n        # Finetune\n        model = model.float()\n\n    prefix = data_args.source_prefix if data_args.source_prefix is not None else \"\"\n\n    # Preprocessing the datasets.\n    # We need to tokenize inputs and targets.\n    if training_args.do_train:\n        column_names = raw_datasets[\"train\"].column_names\n    elif training_args.do_eval:\n        column_names = raw_datasets[\"validation\"].column_names\n    elif training_args.do_predict:\n        column_names = raw_datasets[\"test\"].column_names\n    else:\n        logger.info(\"There is nothing to do. Please pass `do_train`, `do_eval` and/or `do_predict`.\")\n        return\n\n    # Get the column names for input/target.\n    prompt_column = data_args.prompt_column\n    response_column = data_args.response_column\n    history_column = data_args.history_column\n    \n    # Temporarily set max_target_length for training.\n    max_target_length = data_args.max_target_length\n\n    def preprocess_function_eval(examples):\n        inputs, targets = [], []\n        for i in range(len(examples[prompt_column])):\n            if examples[prompt_column][i] and examples[response_column][i]:\n                query = examples[prompt_column][i]\n                if history_column is None or len(examples[history_column][i]) == 0:\n                    prompt = query\n                else:\n                    prompt = \"\"\n                    history = examples[history_column][i]\n                    for turn_idx, (old_query, response) in enumerate(history):\n                        prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(turn_idx, old_query, response)\n                    prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n                inputs.append(prompt)\n                targets.append(examples[response_column][i])\n\n        inputs = [prefix + inp for inp in inputs]\n        model_inputs = tokenizer(inputs, max_length=data_args.max_source_length, truncation=True, padding=True)\n        labels = tokenizer(text_target=targets, max_length=max_target_length, truncation=True)\n\n        if data_args.ignore_pad_token_for_loss:\n            labels[\"input_ids\"] = [\n                [(l if l != tokenizer.pad_token_id else -100) for l in label] for label in labels[\"input_ids\"]\n            ]\n        model_inputs[\"labels\"] = labels[\"input_ids\"]\n\n        return model_inputs\n\n    def preprocess_function_train(examples):\n        max_seq_length = data_args.max_source_length + data_args.max_target_length\n\n        model_inputs = {\n            \"input_ids\": [],\n            \"labels\": [],\n        }\n        for i in range(len(examples[prompt_column])):\n            if examples[prompt_column][i] and examples[response_column][i]:\n                query, answer = examples[prompt_column][i], examples[response_column][i]\n\n                if history_column is None:\n                    prompt = query\n                else:\n                    prompt = \"\"\n                    history = examples[history_column][i]\n                    for turn_idx, (old_query, response) in enumerate(history):\n                        prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a{}\\n\".format(turn_idx, old_query, response)\n                    prompt += \"[Round {}]\\n\u95ee\uff1a{}\\n\u7b54\uff1a\".format(len(history), query)\n\n                prompt = prefix + prompt\n                a_ids = tokenizer.encode(text=prompt, add_special_tokens=False)\n                b_ids = tokenizer.encode(text=answer, add_special_tokens=False)\n\n                if len(a_ids) > data_args.max_source_length - 1:\n                    a_ids = a_ids[: data_args.max_source_length - 1]\n\n                if len(b_ids) > data_args.max_target_length - 2:\n                    b_ids = b_ids[: data_args.max_target_length - 2]\n\n                input_ids = tokenizer.build_inputs_with_special_tokens(a_ids, b_ids)\n\n                context_length = input_ids.index(tokenizer.bos_token_id)\n                mask_position = context_length - 1\n                labels = [-100] * context_length + input_ids[mask_position+1:]\n                \n                pad_len = max_seq_length - len(input_ids)\n                input_ids = input_ids + [tokenizer.pad_token_id] * pad_len\n                labels = labels + [tokenizer.pad_token_id] * pad_len\n                if data_args.ignore_pad_token_for_loss:\n                    labels = [(l if l != tokenizer.pad_token_id else -100) for l in labels]\n\n                model_inputs[\"input_ids\"].append(input_ids)\n                model_inputs[\"labels\"].append(labels)\n\n        return model_inputs\n    \n    def print_dataset_example(example):\n        print(\"input_ids\",example[\"input_ids\"])\n        print(\"inputs\", tokenizer.decode(example[\"input_ids\"]))\n        print(\"label_ids\", example[\"labels\"])\n        print(\"labels\", tokenizer.decode(example[\"labels\"]))\n\n    if training_args.do_train:\n        if \"train\" not in raw_datasets:\n            raise ValueError(\"--do_train requires a train dataset\")\n        train_dataset = raw_datasets[\"train\"]\n        if data_args.max_train_samples is not None:\n            max_train_samples = min(len(train_dataset), data_args.max_train_samples)\n            train_dataset = train_dataset.select(range(max_train_samples))\n        with training_args.main_process_first(desc=\"train dataset map pre-processing\"):\n            train_dataset = train_dataset.map(\n                preprocess_function_train,\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=not data_args.overwrite_cache,\n                desc=\"Running tokenizer on train dataset\",\n            )\n        print_dataset_example(train_dataset[0])\n\n    if training_args.do_eval:\n        max_target_length = data_args.val_max_target_length\n        if \"validation\" not in raw_datasets:\n            raise ValueError(\"--do_eval requires a validation dataset\")\n        eval_dataset = raw_datasets[\"validation\"]\n        if data_args.max_eval_samples is not None:\n            max_eval_samples = min(len(eval_dataset), data_args.max_eval_samples)\n            eval_dataset = eval_dataset.select(range(max_eval_samples))\n        with training_args.main_process_first(desc=\"validation dataset map pre-processing\"):\n            eval_dataset = eval_dataset.map(\n                preprocess_function_eval,\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=not data_args.overwrite_cache,\n                desc=\"Running tokenizer on validation dataset\",\n            )\n        print_dataset_example(eval_dataset[0])\n\n    if training_args.do_predict:\n        max_target_length = data_args.val_max_target_length\n        if \"test\" not in raw_datasets:\n            raise ValueError(\"--do_predict requires a test dataset\")\n        predict_dataset = raw_datasets[\"test\"]\n        if data_args.max_predict_samples is not None:\n            max_predict_samples = min(len(predict_dataset), data_args.max_predict_samples)\n            predict_dataset = predict_dataset.select(range(max_predict_samples))\n        with training_args.main_process_first(desc=\"prediction dataset map pre-processing\"):\n            predict_dataset = predict_dataset.map(\n                preprocess_function_eval,\n                batched=True,\n                num_proc=data_args.preprocessing_num_workers,\n                remove_columns=column_names,\n                load_from_cache_file=not data_args.overwrite_cache,\n                desc=\"Running tokenizer on prediction dataset\",\n            )\n        print_dataset_example(predict_dataset[0])\n\n    # Data collator\n    label_pad_token_id = -100 if data_args.ignore_pad_token_for_loss else tokenizer.pad_token_id\n    data_collator = DataCollatorForSeq2Seq(\n        tokenizer,\n        model=model,\n        label_pad_token_id=label_pad_token_id,\n        pad_to_multiple_of=None,\n        padding=False\n    )\n\n    # Metric\n    def compute_metrics(eval_preds):\n        preds, labels = eval_preds\n        if isinstance(preds, tuple):\n            preds = preds[0]\n        decoded_preds = tokenizer.batch_decode(preds, skip_special_tokens=True)\n        if data_args.ignore_pad_token_for_loss:\n            # Replace -100 in the labels as we can't decode them.\n            labels = np.where(labels != -100, labels, tokenizer.pad_token_id)\n        decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)\n\n        score_dict = {\n            \"rouge-1\": [],\n            \"rouge-2\": [],\n            \"rouge-l\": [],\n            \"bleu-4\": []\n        }\n        for pred, label in zip(decoded_preds, decoded_labels):\n            hypothesis = list(jieba.cut(pred))\n            reference = list(jieba.cut(label))\n            rouge = Rouge()\n            scores = rouge.get_scores(' '.join(hypothesis) , ' '.join(reference))\n            result = scores[0]\n            \n            for k, v in result.items():\n                score_dict[k].append(round(v[\"f\"] * 100, 4))\n            bleu_score = sentence_bleu([list(label)], list(pred), smoothing_function=SmoothingFunction().method3)\n            score_dict[\"bleu-4\"].append(round(bleu_score * 100, 4))\n\n        for k, v in score_dict.items():\n            score_dict[k] = float(np.mean(v))\n        return score_dict\n\n    # Override the decoding parameters of Seq2SeqTrainer\n    training_args.generation_max_length = (\n        training_args.generation_max_length\n        if training_args.generation_max_length is not None\n        else data_args.val_max_target_length\n    )\n    training_args.generation_num_beams = (\n        data_args.num_beams if data_args.num_beams is not None else training_args.generation_num_beams\n    )\n    # Initialize our Trainer\n    trainer = Seq2SeqTrainer(\n        model=model,\n        args=training_args,\n        train_dataset=train_dataset if training_args.do_train else None,\n        eval_dataset=eval_dataset if training_args.do_eval else None,\n        tokenizer=tokenizer,\n        data_collator=data_collator,\n        compute_metrics=compute_metrics if training_args.predict_with_generate else None,\n        save_prefixencoder=model_args.pre_seq_len is not None\n    )\n\n    # Training\n    if training_args.do_train:\n        checkpoint = None\n        if training_args.resume_from_checkpoint is not None:\n            checkpoint = training_args.resume_from_checkpoint\n        # elif last_checkpoint is not None:\n        #     checkpoint = last_checkpoint\n        model.gradient_checkpointing_enable()\n        model.enable_input_require_grads()\n        train_result = trainer.train(resume_from_checkpoint=checkpoint)\n        # trainer.save_model()  # Saves the tokenizer too for easy upload\n\n        metrics = train_result.metrics\n        max_train_samples = (\n            data_args.max_train_samples if data_args.max_train_samples is not None else len(train_dataset)\n        )\n        metrics[\"train_samples\"] = min(max_train_samples, len(train_dataset))\n\n        trainer.log_metrics(\"train\", metrics)\n        trainer.save_metrics(\"train\", metrics)\n        trainer.save_state()\n\n    # Evaluation\n    results = {}\n    max_seq_length = data_args.max_source_length + data_args.max_target_length + 1\n    if training_args.do_eval:\n        logger.info(\"*** Evaluate ***\")\n        metrics = trainer.evaluate(metric_key_prefix=\"eval\", do_sample=True, top_p=0.7, max_length=max_seq_length, temperature=0.95)\n        max_eval_samples = data_args.max_eval_samples if data_args.max_eval_samples is not None else len(eval_dataset)\n        metrics[\"eval_samples\"] = min(max_eval_samples, len(eval_dataset))\n\n        trainer.log_metrics(\"eval\", metrics)\n        trainer.save_metrics(\"eval\", metrics)\n\n    if training_args.do_predict:\n        logger.info(\"*** Predict ***\")\n        predict_results = trainer.predict(predict_dataset, metric_key_prefix=\"predict\", max_length=max_seq_length, do_sample=True, top_p=0.7, temperature=0.95)\n        metrics = predict_results.metrics\n        max_predict_samples = (\n            data_args.max_predict_samples if data_args.max_predict_samples is not None else len(predict_dataset)\n        )\n        metrics[\"predict_samples\"] = min(max_predict_samples, len(predict_dataset))\n\n        trainer.log_metrics(\"predict\", metrics)\n        trainer.save_metrics(\"predict\", metrics)\n\n        if trainer.is_world_process_zero():\n            if training_args.predict_with_generate:\n                predictions = tokenizer.batch_decode(\n                    predict_results.predictions, skip_special_tokens=True, clean_up_tokenization_spaces=True\n                )\n                predictions = [pred.strip() for pred in predictions]\n                labels = tokenizer.batch_decode(\n                    predict_results.label_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True\n                )\n                labels = [label.strip() for label in labels]\n                output_prediction_file = os.path.join(training_args.output_dir, \"generated_predictions.txt\")\n                with open(output_prediction_file, \"w\", encoding=\"utf-8\") as writer:\n                    for p, l in zip(predictions, labels):\n                        res = json.dumps({\"labels\": l, \"predict\": p}, ensure_ascii=False)\n                        writer.write(f\"{res}\\n\")\n    return results\n\n\ndef _mp_fn(index):\n    # For xla_spawn (TPUs)\n    main()\n\n\nif __name__ == \"__main__\":\n    main()\n", "ptuning/arguments.py": "from dataclasses import dataclass, field\nfrom typing import Optional\n\n\n@dataclass\nclass ModelArguments:\n    \"\"\"\n    Arguments pertaining to which model/config/tokenizer we are going to fine-tune from.\n    \"\"\"\n\n    model_name_or_path: str = field(\n        metadata={\"help\": \"Path to pretrained model or model identifier from huggingface.co/models\"}\n    )\n    ptuning_checkpoint: str = field(\n        default=None, metadata={\"help\": \"Path to p-tuning v2 checkpoints\"}\n    )\n    config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained config name or path if not the same as model_name\"}\n    )\n    tokenizer_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"Pretrained tokenizer name or path if not the same as model_name\"}\n    )\n    cache_dir: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"Where to store the pretrained models downloaded from huggingface.co\"},\n    )\n    use_fast_tokenizer: bool = field(\n        default=True,\n        metadata={\"help\": \"Whether to use one of the fast tokenizer (backed by the tokenizers library) or not.\"},\n    )\n    model_revision: str = field(\n        default=\"main\",\n        metadata={\"help\": \"The specific model version to use (can be a branch name, tag name or commit id).\"},\n    )\n    use_auth_token: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Will use the token generated when running `huggingface-cli login` (necessary to use this script \"\n                \"with private models).\"\n            )\n        },\n    )\n    resize_position_embeddings: Optional[bool] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"Whether to automatically resize the position embeddings if `max_source_length` exceeds \"\n                \"the model's position embeddings.\"\n            )\n        },\n    )\n    quantization_bit: Optional[int] = field(\n        default=None\n    )\n    pre_seq_len: Optional[int] = field(\n        default=None\n    )\n    prefix_projection: bool = field(\n        default=False\n    )\n\n\n@dataclass\nclass DataTrainingArguments:\n    \"\"\"\n    Arguments pertaining to what data we are going to input our model for training and eval.\n    \"\"\"\n\n    lang: Optional[str] = field(default=None, metadata={\"help\": \"Language id for summarization.\"})\n\n    dataset_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The name of the dataset to use (via the datasets library).\"}\n    )\n    dataset_config_name: Optional[str] = field(\n        default=None, metadata={\"help\": \"The configuration name of the dataset to use (via the datasets library).\"}\n    )\n    prompt_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the full texts (for summarization).\"},\n    )\n    response_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the summaries (for summarization).\"},\n    )\n    history_column: Optional[str] = field(\n        default=None,\n        metadata={\"help\": \"The name of the column in the datasets containing the history of chat.\"},\n    )\n    train_file: Optional[str] = field(\n        default=None, metadata={\"help\": \"The input training data file (a jsonlines or csv file).\"}\n    )\n    validation_file: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"An optional input evaluation data file to evaluate the metrics (rouge) on (a jsonlines or csv file).\"\n            )\n        },\n    )\n    test_file: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": \"An optional input test data file to evaluate the metrics (rouge) on (a jsonlines or csv file).\"\n        },\n    )\n    overwrite_cache: bool = field(\n        default=False, metadata={\"help\": \"Overwrite the cached training and evaluation sets\"}\n    )\n    preprocessing_num_workers: Optional[int] = field(\n        default=None,\n        metadata={\"help\": \"The number of processes to use for the preprocessing.\"},\n    )\n    max_source_length: Optional[int] = field(\n        default=1024,\n        metadata={\n            \"help\": (\n                \"The maximum total input sequence length after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded.\"\n            )\n        },\n    )\n    max_target_length: Optional[int] = field(\n        default=128,\n        metadata={\n            \"help\": (\n                \"The maximum total sequence length for target text after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded.\"\n            )\n        },\n    )\n    val_max_target_length: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The maximum total sequence length for validation target text after tokenization. Sequences longer \"\n                \"than this will be truncated, sequences shorter will be padded. Will default to `max_target_length`.\"\n                \"This argument is also used to override the ``max_length`` param of ``model.generate``, which is used \"\n                \"during ``evaluate`` and ``predict``.\"\n            )\n        },\n    )\n    pad_to_max_length: bool = field(\n        default=False,\n        metadata={\n            \"help\": (\n                \"Whether to pad all samples to model maximum sentence length. \"\n                \"If False, will pad the samples dynamically when batching to the maximum length in the batch. More \"\n                \"efficient on GPU but very bad for TPU.\"\n            )\n        },\n    )\n    max_train_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of training examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    max_eval_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of evaluation examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    max_predict_samples: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"For debugging purposes or quicker training, truncate the number of prediction examples to this \"\n                \"value if set.\"\n            )\n        },\n    )\n    num_beams: Optional[int] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"Number of beams to use for evaluation. This argument will be passed to ``model.generate``, \"\n                \"which is used during ``evaluate`` and ``predict``.\"\n            )\n        },\n    )\n    ignore_pad_token_for_loss: bool = field(\n        default=True,\n        metadata={\n            \"help\": \"Whether to ignore the tokens corresponding to padded labels in the loss computation or not.\"\n        },\n    )\n    source_prefix: Optional[str] = field(\n        default=\"\", metadata={\"help\": \"A prefix to add before every source text (useful for T5 models).\"}\n    )\n\n    forced_bos_token: Optional[str] = field(\n        default=None,\n        metadata={\n            \"help\": (\n                \"The token to force as the first generated token after the decoder_start_token_id.\"\n                \"Useful for multilingual models like mBART where the first generated token\"\n                \"needs to be the target language token (Usually it is the target language token)\"\n            )\n        },\n    )\n\n    \n\n    def __post_init__(self):\n        if self.dataset_name is None and self.train_file is None and self.validation_file is None and self.test_file is None:\n            raise ValueError(\"Need either a dataset name or a training/validation/test file.\")\n        else:\n            if self.train_file is not None:\n                extension = self.train_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\"], \"`train_file` should be a csv or a json file.\"\n            if self.validation_file is not None:\n                extension = self.validation_file.split(\".\")[-1]\n                assert extension in [\"csv\", \"json\"], \"`validation_file` should be a csv or a json file.\"\n        if self.val_max_target_length is None:\n            self.val_max_target_length = self.max_target_length\n\n", "ptuning/trainer_seq2seq.py": "# Copyright 2020 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\nimport torch\nfrom torch import nn\nfrom torch.utils.data import Dataset\n\nfrom transformers.deepspeed import is_deepspeed_zero3_enabled\nfrom trainer import Trainer\nfrom transformers.trainer_utils import PredictionOutput\nfrom transformers.utils import logging\n\n\nlogger = logging.get_logger(__name__)\n\n\nclass Seq2SeqTrainer(Trainer):\n    def evaluate(\n        self,\n        eval_dataset: Optional[Dataset] = None,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"eval\",\n        **gen_kwargs\n    ) -> Dict[str, float]:\n        \"\"\"\n        Run evaluation and returns metrics.\n\n        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent\n        (pass it to the init `compute_metrics` argument).\n\n        You can also subclass and override this method to inject custom behavior.\n\n        Args:\n            eval_dataset (`Dataset`, *optional*):\n                Pass a dataset if you wish to override `self.eval_dataset`. If it is an [`~datasets.Dataset`], columns\n                not accepted by the `model.forward()` method are automatically removed. It must implement the `__len__`\n                method.\n            ignore_keys (`List[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is `\"eval\"` (default)\n            max_length (`int`, *optional*):\n                The maximum target length to use when predicting with the generate method.\n            num_beams (`int`, *optional*):\n                Number of beams for beam search that will be used when predicting with the generate method. 1 means no\n                beam search.\n            gen_kwargs:\n                Additional `generate` specific kwargs.\n\n        Returns:\n            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The\n            dictionary also contains the epoch number which comes from the training state.\n        \"\"\"\n\n        gen_kwargs = gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.args.generation_max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.args.generation_num_beams\n        )\n        self._gen_kwargs = gen_kwargs\n\n        return super().evaluate(eval_dataset, ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix)\n\n    def predict(\n        self,\n        test_dataset: Dataset,\n        ignore_keys: Optional[List[str]] = None,\n        metric_key_prefix: str = \"test\",\n        **gen_kwargs\n    ) -> PredictionOutput:\n        \"\"\"\n        Run prediction and returns predictions and potential metrics.\n\n        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method\n        will also return metrics, like in `evaluate()`.\n\n        Args:\n            test_dataset (`Dataset`):\n                Dataset to run the predictions on. If it is a [`~datasets.Dataset`], columns not accepted by the\n                `model.forward()` method are automatically removed. Has to implement the method `__len__`\n            ignore_keys (`List[str]`, *optional*):\n                A list of keys in the output of your model (if it is a dictionary) that should be ignored when\n                gathering predictions.\n            metric_key_prefix (`str`, *optional*, defaults to `\"eval\"`):\n                An optional prefix to be used as the metrics key prefix. For example the metrics \"bleu\" will be named\n                \"eval_bleu\" if the prefix is `\"eval\"` (default)\n            max_length (`int`, *optional*):\n                The maximum target length to use when predicting with the generate method.\n            num_beams (`int`, *optional*):\n                Number of beams for beam search that will be used when predicting with the generate method. 1 means no\n                beam search.\n            gen_kwargs:\n                Additional `generate` specific kwargs.\n\n        <Tip>\n\n        If your predictions or labels have different sequence lengths (for instance because you're doing dynamic\n        padding in a token classification task) the predictions will be padded (on the right) to allow for\n        concatenation into one array. The padding index is -100.\n\n        </Tip>\n\n        Returns: *NamedTuple* A namedtuple with the following keys:\n\n            - predictions (`np.ndarray`): The predictions on `test_dataset`.\n            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).\n            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained\n              labels).\n        \"\"\"\n\n        gen_kwargs = gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.args.generation_max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.args.generation_num_beams\n        )\n        self._gen_kwargs = gen_kwargs\n\n\n        return super().predict(test_dataset, ignore_keys=ignore_keys, metric_key_prefix=metric_key_prefix)\n\n    def prediction_step(\n        self,\n        model: nn.Module,\n        inputs: Dict[str, Union[torch.Tensor, Any]],\n        prediction_loss_only: bool,\n        ignore_keys: Optional[List[str]] = None,\n    ) -> Tuple[Optional[float], Optional[torch.Tensor], Optional[torch.Tensor]]:\n        \"\"\"\n        Perform an evaluation step on `model` using `inputs`.\n\n        Subclass and override to inject custom behavior.\n\n        Args:\n            model (`nn.Module`):\n                The model to evaluate.\n            inputs (`Dict[str, Union[torch.Tensor, Any]]`):\n                The inputs and targets of the model.\n\n                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the\n                argument `labels`. Check your model's documentation for all accepted arguments.\n            prediction_loss_only (`bool`):\n                Whether or not to return the loss only.\n\n        Return:\n            Tuple[Optional[float], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss, logits and\n            labels (each being optional).\n        \"\"\"\n\n        if not self.args.predict_with_generate or prediction_loss_only:\n            return super().prediction_step(\n                model, inputs, prediction_loss_only=prediction_loss_only, ignore_keys=ignore_keys\n            )\n\n        has_labels = \"labels\" in inputs\n        inputs = self._prepare_inputs(inputs)\n\n        # XXX: adapt synced_gpus for fairscale as well\n        gen_kwargs = self._gen_kwargs.copy()\n        if gen_kwargs.get(\"max_length\") is None and gen_kwargs.get(\"max_new_tokens\") is None:\n            gen_kwargs[\"max_length\"] = self.model.config.max_length\n        gen_kwargs[\"num_beams\"] = (\n            gen_kwargs[\"num_beams\"] if gen_kwargs.get(\"num_beams\") is not None else self.model.config.num_beams\n        )\n        default_synced_gpus = True if is_deepspeed_zero3_enabled() else False\n        gen_kwargs[\"synced_gpus\"] = (\n            gen_kwargs[\"synced_gpus\"] if gen_kwargs.get(\"synced_gpus\") is not None else default_synced_gpus\n        )\n\n        if \"attention_mask\" in inputs:\n            gen_kwargs[\"attention_mask\"] = inputs.get(\"attention_mask\", None)\n        if \"position_ids\" in inputs:\n            gen_kwargs[\"position_ids\"] = inputs.get(\"position_ids\", None)\n        if \"global_attention_mask\" in inputs:\n            gen_kwargs[\"global_attention_mask\"] = inputs.get(\"global_attention_mask\", None)\n\n        # prepare generation inputs\n        # some encoder-decoder models can have varying encoder's and thus\n        # varying model input names\n        if hasattr(self.model, \"encoder\") and self.model.encoder.main_input_name != self.model.main_input_name:\n            generation_inputs = inputs[self.model.encoder.main_input_name]\n        else:\n            generation_inputs = inputs[self.model.main_input_name]\n\n        gen_kwargs[\"input_ids\"] = generation_inputs\n        generated_tokens = self.model.generate(**gen_kwargs)\n        generated_tokens = generated_tokens[:, generation_inputs.size()[-1]:]\n\n        # in case the batch is shorter than max length, the output should be padded\n        if gen_kwargs.get(\"max_length\") is not None and generated_tokens.shape[-1] < gen_kwargs[\"max_length\"]:\n            generated_tokens = self._pad_tensors_to_max_len(generated_tokens, gen_kwargs[\"max_length\"])\n        elif gen_kwargs.get(\"max_new_tokens\") is not None and generated_tokens.shape[-1] < (\n            gen_kwargs[\"max_new_tokens\"] + 1\n        ):\n            generated_tokens = self._pad_tensors_to_max_len(generated_tokens, gen_kwargs[\"max_new_tokens\"] + 1)\n\n        loss = None\n\n        if self.args.prediction_loss_only:\n            return (loss, None, None)\n\n        if has_labels:\n            labels = inputs[\"labels\"]\n            if gen_kwargs.get(\"max_length\") is not None and labels.shape[-1] < gen_kwargs[\"max_length\"]:\n                labels = self._pad_tensors_to_max_len(labels, gen_kwargs[\"max_length\"])\n            elif gen_kwargs.get(\"max_new_tokens\") is not None and labels.shape[-1] < (\n                gen_kwargs[\"max_new_tokens\"] + 1\n            ):\n                labels = self._pad_tensors_to_max_len(labels, (gen_kwargs[\"max_new_tokens\"] + 1))\n        else:\n            labels = None\n\n        return (loss, generated_tokens, labels)\n\n    def _pad_tensors_to_max_len(self, tensor, max_length):\n        if self.tokenizer is not None and hasattr(self.tokenizer, \"pad_token_id\"):\n            # If PAD token is not defined at least EOS token has to be defined\n            pad_token_id = (\n                self.tokenizer.pad_token_id if self.tokenizer.pad_token_id is not None else self.tokenizer.eos_token_id\n            )\n        else:\n            if self.model.config.pad_token_id is not None:\n                pad_token_id = self.model.config.pad_token_id\n            else:\n                raise ValueError(\"Pad_token_id must be set in the configuration of the model, in order to pad tensors\")\n\n        padded_tensor = pad_token_id * torch.ones(\n            (tensor.shape[0], max_length), dtype=tensor.dtype, device=tensor.device\n        )\n        padded_tensor[:, : tensor.shape[-1]] = tensor\n        return padded_tensor\n"}