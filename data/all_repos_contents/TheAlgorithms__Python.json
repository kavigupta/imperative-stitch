{"neural_network/back_propagation_neural_network.py": "#!/usr/bin/python\n\n\"\"\"\n\nA Framework of Back Propagation Neural Network (BP) model\n\nEasy to use:\n    * add many layers as you want ! ! !\n    * clearly see how the loss decreasing\nEasy to expand:\n    * more activation functions\n    * more loss functions\n    * more optimization method\n\nAuthor: Stephen Lee\nGithub : https://github.com/RiptideBo\nDate: 2017.11.23\n\n\"\"\"\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n\ndef sigmoid(x: np.ndarray) -> np.ndarray:\n    return 1 / (1 + np.exp(-x))\n\n\nclass DenseLayer:\n    \"\"\"\n    Layers of BP neural network\n    \"\"\"\n\n    def __init__(\n        self, units, activation=None, learning_rate=None, is_input_layer=False\n    ):\n        \"\"\"\n        common connected layer of bp network\n        :param units: numbers of neural units\n        :param activation: activation function\n        :param learning_rate: learning rate for paras\n        :param is_input_layer: whether it is input layer or not\n        \"\"\"\n        self.units = units\n        self.weight = None\n        self.bias = None\n        self.activation = activation\n        if learning_rate is None:\n            learning_rate = 0.3\n        self.learn_rate = learning_rate\n        self.is_input_layer = is_input_layer\n\n    def initializer(self, back_units):\n        rng = np.random.default_rng()\n        self.weight = np.asmatrix(rng.normal(0, 0.5, (self.units, back_units)))\n        self.bias = np.asmatrix(rng.normal(0, 0.5, self.units)).T\n        if self.activation is None:\n            self.activation = sigmoid\n\n    def cal_gradient(self):\n        # activation function may be sigmoid or linear\n        if self.activation == sigmoid:\n            gradient_mat = np.dot(self.output, (1 - self.output).T)\n            gradient_activation = np.diag(np.diag(gradient_mat))\n        else:\n            gradient_activation = 1\n        return gradient_activation\n\n    def forward_propagation(self, xdata):\n        self.xdata = xdata\n        if self.is_input_layer:\n            # input layer\n            self.wx_plus_b = xdata\n            self.output = xdata\n            return xdata\n        else:\n            self.wx_plus_b = np.dot(self.weight, self.xdata) - self.bias\n            self.output = self.activation(self.wx_plus_b)\n            return self.output\n\n    def back_propagation(self, gradient):\n        gradient_activation = self.cal_gradient()  # i * i \u7ef4\n        gradient = np.asmatrix(np.dot(gradient.T, gradient_activation))\n\n        self._gradient_weight = np.asmatrix(self.xdata)\n        self._gradient_bias = -1\n        self._gradient_x = self.weight\n\n        self.gradient_weight = np.dot(gradient.T, self._gradient_weight.T)\n        self.gradient_bias = gradient * self._gradient_bias\n        self.gradient = np.dot(gradient, self._gradient_x).T\n        # upgrade: the Negative gradient direction\n        self.weight = self.weight - self.learn_rate * self.gradient_weight\n        self.bias = self.bias - self.learn_rate * self.gradient_bias.T\n        # updates the weights and bias according to learning rate (0.3 if undefined)\n        return self.gradient\n\n\nclass BPNN:\n    \"\"\"\n    Back Propagation Neural Network model\n    \"\"\"\n\n    def __init__(self):\n        self.layers = []\n        self.train_mse = []\n        self.fig_loss = plt.figure()\n        self.ax_loss = self.fig_loss.add_subplot(1, 1, 1)\n\n    def add_layer(self, layer):\n        self.layers.append(layer)\n\n    def build(self):\n        for i, layer in enumerate(self.layers[:]):\n            if i < 1:\n                layer.is_input_layer = True\n            else:\n                layer.initializer(self.layers[i - 1].units)\n\n    def summary(self):\n        for i, layer in enumerate(self.layers[:]):\n            print(f\"------- layer {i} -------\")\n            print(\"weight.shape \", np.shape(layer.weight))\n            print(\"bias.shape \", np.shape(layer.bias))\n\n    def train(self, xdata, ydata, train_round, accuracy):\n        self.train_round = train_round\n        self.accuracy = accuracy\n\n        self.ax_loss.hlines(self.accuracy, 0, self.train_round * 1.1)\n\n        x_shape = np.shape(xdata)\n        for _ in range(train_round):\n            all_loss = 0\n            for row in range(x_shape[0]):\n                _xdata = np.asmatrix(xdata[row, :]).T\n                _ydata = np.asmatrix(ydata[row, :]).T\n\n                # forward propagation\n                for layer in self.layers:\n                    _xdata = layer.forward_propagation(_xdata)\n\n                loss, gradient = self.cal_loss(_ydata, _xdata)\n                all_loss = all_loss + loss\n\n                # back propagation: the input_layer does not upgrade\n                for layer in self.layers[:0:-1]:\n                    gradient = layer.back_propagation(gradient)\n\n            mse = all_loss / x_shape[0]\n            self.train_mse.append(mse)\n\n            self.plot_loss()\n\n            if mse < self.accuracy:\n                print(\"----\u8fbe\u5230\u7cbe\u5ea6----\")\n                return mse\n        return None\n\n    def cal_loss(self, ydata, ydata_):\n        self.loss = np.sum(np.power((ydata - ydata_), 2))\n        self.loss_gradient = 2 * (ydata_ - ydata)\n        # vector (shape is the same as _ydata.shape)\n        return self.loss, self.loss_gradient\n\n    def plot_loss(self):\n        if self.ax_loss.lines:\n            self.ax_loss.lines.remove(self.ax_loss.lines[0])\n        self.ax_loss.plot(self.train_mse, \"r-\")\n        plt.ion()\n        plt.xlabel(\"step\")\n        plt.ylabel(\"loss\")\n        plt.show()\n        plt.pause(0.1)\n\n\ndef example():\n    rng = np.random.default_rng()\n    x = rng.normal(size=(10, 10))\n    y = np.asarray(\n        [\n            [0.8, 0.4],\n            [0.4, 0.3],\n            [0.34, 0.45],\n            [0.67, 0.32],\n            [0.88, 0.67],\n            [0.78, 0.77],\n            [0.55, 0.66],\n            [0.55, 0.43],\n            [0.54, 0.1],\n            [0.1, 0.5],\n        ]\n    )\n    model = BPNN()\n    for i in (10, 20, 30, 2):\n        model.add_layer(DenseLayer(i))\n    model.build()\n    model.summary()\n    model.train(xdata=x, ydata=y, train_round=100, accuracy=0.01)\n\n\nif __name__ == \"__main__\":\n    example()\n", "neural_network/simple_neural_network.py": "\"\"\"\nForward propagation explanation:\nhttps://towardsdatascience.com/forward-propagation-in-neural-networks-simplified-math-and-code-version-bbcfef6f9250\n\"\"\"\n\nimport math\nimport random\n\n\n# Sigmoid\ndef sigmoid_function(value: float, deriv: bool = False) -> float:\n    \"\"\"Return the sigmoid function of a float.\n\n    >>> sigmoid_function(3.5)\n    0.9706877692486436\n    >>> sigmoid_function(3.5, True)\n    -8.75\n    \"\"\"\n    if deriv:\n        return value * (1 - value)\n    return 1 / (1 + math.exp(-value))\n\n\n# Initial Value\nINITIAL_VALUE = 0.02\n\n\ndef forward_propagation(expected: int, number_propagations: int) -> float:\n    \"\"\"Return the value found after the forward propagation training.\n\n    >>> res = forward_propagation(32, 450_000)  # Was 10_000_000\n    >>> res > 31 and res < 33\n    True\n\n    >>> res = forward_propagation(32, 1000)\n    >>> res > 31 and res < 33\n    False\n    \"\"\"\n\n    # Random weight\n    weight = float(2 * (random.randint(1, 100)) - 1)\n\n    for _ in range(number_propagations):\n        # Forward propagation\n        layer_1 = sigmoid_function(INITIAL_VALUE * weight)\n        # How much did we miss?\n        layer_1_error = (expected / 100) - layer_1\n        # Error delta\n        layer_1_delta = layer_1_error * sigmoid_function(layer_1, True)\n        # Update weight\n        weight += INITIAL_VALUE * layer_1_delta\n\n    return layer_1 * 100\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    expected = int(input(\"Expected value: \"))\n    number_propagations = int(input(\"Number of propagations: \"))\n    print(forward_propagation(expected, number_propagations))\n", "neural_network/convolution_neural_network.py": "\"\"\"\n - - - - - -- - - - - - - - - - - - - - - - - - - - - - -\nName - - CNN - Convolution Neural Network For Photo Recognizing\nGoal - - Recognize Handwriting Word Photo\nDetail: Total 5 layers neural network\n        * Convolution layer\n        * Pooling layer\n        * Input layer layer of BP\n        * Hidden layer of BP\n        * Output layer of BP\nAuthor: Stephen Lee\nGithub: 245885195@qq.com\nDate: 2017.9.20\n- - - - - -- - - - - - - - - - - - - - - - - - - - - - -\n\"\"\"\n\nimport pickle\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n\nclass CNN:\n    def __init__(\n        self, conv1_get, size_p1, bp_num1, bp_num2, bp_num3, rate_w=0.2, rate_t=0.2\n    ):\n        \"\"\"\n        :param conv1_get: [a,c,d], size, number, step of convolution kernel\n        :param size_p1: pooling size\n        :param bp_num1: units number of flatten layer\n        :param bp_num2: units number of hidden layer\n        :param bp_num3: units number of output layer\n        :param rate_w: rate of weight learning\n        :param rate_t: rate of threshold learning\n        \"\"\"\n        self.num_bp1 = bp_num1\n        self.num_bp2 = bp_num2\n        self.num_bp3 = bp_num3\n        self.conv1 = conv1_get[:2]\n        self.step_conv1 = conv1_get[2]\n        self.size_pooling1 = size_p1\n        self.rate_weight = rate_w\n        self.rate_thre = rate_t\n        rng = np.random.default_rng()\n        self.w_conv1 = [\n            np.asmatrix(-1 * rng.random((self.conv1[0], self.conv1[0])) + 0.5)\n            for i in range(self.conv1[1])\n        ]\n        self.wkj = np.asmatrix(-1 * rng.random((self.num_bp3, self.num_bp2)) + 0.5)\n        self.vji = np.asmatrix(-1 * rng.random((self.num_bp2, self.num_bp1)) + 0.5)\n        self.thre_conv1 = -2 * rng.random(self.conv1[1]) + 1\n        self.thre_bp2 = -2 * rng.random(self.num_bp2) + 1\n        self.thre_bp3 = -2 * rng.random(self.num_bp3) + 1\n\n    def save_model(self, save_path):\n        # save model dict with pickle\n        model_dic = {\n            \"num_bp1\": self.num_bp1,\n            \"num_bp2\": self.num_bp2,\n            \"num_bp3\": self.num_bp3,\n            \"conv1\": self.conv1,\n            \"step_conv1\": self.step_conv1,\n            \"size_pooling1\": self.size_pooling1,\n            \"rate_weight\": self.rate_weight,\n            \"rate_thre\": self.rate_thre,\n            \"w_conv1\": self.w_conv1,\n            \"wkj\": self.wkj,\n            \"vji\": self.vji,\n            \"thre_conv1\": self.thre_conv1,\n            \"thre_bp2\": self.thre_bp2,\n            \"thre_bp3\": self.thre_bp3,\n        }\n        with open(save_path, \"wb\") as f:\n            pickle.dump(model_dic, f)\n\n        print(f\"Model saved: {save_path}\")\n\n    @classmethod\n    def read_model(cls, model_path):\n        # read saved model\n        with open(model_path, \"rb\") as f:\n            model_dic = pickle.load(f)  # noqa: S301\n\n        conv_get = model_dic.get(\"conv1\")\n        conv_get.append(model_dic.get(\"step_conv1\"))\n        size_p1 = model_dic.get(\"size_pooling1\")\n        bp1 = model_dic.get(\"num_bp1\")\n        bp2 = model_dic.get(\"num_bp2\")\n        bp3 = model_dic.get(\"num_bp3\")\n        r_w = model_dic.get(\"rate_weight\")\n        r_t = model_dic.get(\"rate_thre\")\n        # create model instance\n        conv_ins = CNN(conv_get, size_p1, bp1, bp2, bp3, r_w, r_t)\n        # modify model parameter\n        conv_ins.w_conv1 = model_dic.get(\"w_conv1\")\n        conv_ins.wkj = model_dic.get(\"wkj\")\n        conv_ins.vji = model_dic.get(\"vji\")\n        conv_ins.thre_conv1 = model_dic.get(\"thre_conv1\")\n        conv_ins.thre_bp2 = model_dic.get(\"thre_bp2\")\n        conv_ins.thre_bp3 = model_dic.get(\"thre_bp3\")\n        return conv_ins\n\n    def sig(self, x):\n        return 1 / (1 + np.exp(-1 * x))\n\n    def do_round(self, x):\n        return round(x, 3)\n\n    def convolute(self, data, convs, w_convs, thre_convs, conv_step):\n        # convolution process\n        size_conv = convs[0]\n        num_conv = convs[1]\n        size_data = np.shape(data)[0]\n        # get the data slice of original image data, data_focus\n        data_focus = []\n        for i_focus in range(0, size_data - size_conv + 1, conv_step):\n            for j_focus in range(0, size_data - size_conv + 1, conv_step):\n                focus = data[\n                    i_focus : i_focus + size_conv, j_focus : j_focus + size_conv\n                ]\n                data_focus.append(focus)\n        # calculate the feature map of every single kernel, and saved as list of matrix\n        data_featuremap = []\n        size_feature_map = int((size_data - size_conv) / conv_step + 1)\n        for i_map in range(num_conv):\n            featuremap = []\n            for i_focus in range(len(data_focus)):\n                net_focus = (\n                    np.sum(np.multiply(data_focus[i_focus], w_convs[i_map]))\n                    - thre_convs[i_map]\n                )\n                featuremap.append(self.sig(net_focus))\n            featuremap = np.asmatrix(featuremap).reshape(\n                size_feature_map, size_feature_map\n            )\n            data_featuremap.append(featuremap)\n\n        # expanding the data slice to one dimension\n        focus1_list = []\n        for each_focus in data_focus:\n            focus1_list.extend(self.Expand_Mat(each_focus))\n        focus_list = np.asarray(focus1_list)\n        return focus_list, data_featuremap\n\n    def pooling(self, featuremaps, size_pooling, pooling_type=\"average_pool\"):\n        # pooling process\n        size_map = len(featuremaps[0])\n        size_pooled = int(size_map / size_pooling)\n        featuremap_pooled = []\n        for i_map in range(len(featuremaps)):\n            feature_map = featuremaps[i_map]\n            map_pooled = []\n            for i_focus in range(0, size_map, size_pooling):\n                for j_focus in range(0, size_map, size_pooling):\n                    focus = feature_map[\n                        i_focus : i_focus + size_pooling,\n                        j_focus : j_focus + size_pooling,\n                    ]\n                    if pooling_type == \"average_pool\":\n                        # average pooling\n                        map_pooled.append(np.average(focus))\n                    elif pooling_type == \"max_pooling\":\n                        # max pooling\n                        map_pooled.append(np.max(focus))\n            map_pooled = np.asmatrix(map_pooled).reshape(size_pooled, size_pooled)\n            featuremap_pooled.append(map_pooled)\n        return featuremap_pooled\n\n    def _expand(self, data):\n        # expanding three dimension data to one dimension list\n        data_expanded = []\n        for i in range(len(data)):\n            shapes = np.shape(data[i])\n            data_listed = data[i].reshape(1, shapes[0] * shapes[1])\n            data_listed = data_listed.getA().tolist()[0]\n            data_expanded.extend(data_listed)\n        data_expanded = np.asarray(data_expanded)\n        return data_expanded\n\n    def _expand_mat(self, data_mat):\n        # expanding matrix to one dimension list\n        data_mat = np.asarray(data_mat)\n        shapes = np.shape(data_mat)\n        data_expanded = data_mat.reshape(1, shapes[0] * shapes[1])\n        return data_expanded\n\n    def _calculate_gradient_from_pool(\n        self, out_map, pd_pool, num_map, size_map, size_pooling\n    ):\n        \"\"\"\n        calculate the gradient from the data slice of pool layer\n        pd_pool: list of matrix\n        out_map: the shape of data slice(size_map*size_map)\n        return: pd_all: list of matrix, [num, size_map, size_map]\n        \"\"\"\n        pd_all = []\n        i_pool = 0\n        for i_map in range(num_map):\n            pd_conv1 = np.ones((size_map, size_map))\n            for i in range(0, size_map, size_pooling):\n                for j in range(0, size_map, size_pooling):\n                    pd_conv1[i : i + size_pooling, j : j + size_pooling] = pd_pool[\n                        i_pool\n                    ]\n                    i_pool = i_pool + 1\n            pd_conv2 = np.multiply(\n                pd_conv1, np.multiply(out_map[i_map], (1 - out_map[i_map]))\n            )\n            pd_all.append(pd_conv2)\n        return pd_all\n\n    def train(\n        self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e=bool\n    ):\n        # model training\n        print(\"----------------------Start Training-------------------------\")\n        print((\" - - Shape: Train_Data  \", np.shape(datas_train)))\n        print((\" - - Shape: Teach_Data  \", np.shape(datas_teach)))\n        rp = 0\n        all_mse = []\n        mse = 10000\n        while rp < n_repeat and mse >= error_accuracy:\n            error_count = 0\n            print(f\"-------------Learning Time {rp}--------------\")\n            for p in range(len(datas_train)):\n                # print('------------Learning Image: %d--------------'%p)\n                data_train = np.asmatrix(datas_train[p])\n                data_teach = np.asarray(datas_teach[p])\n                data_focus1, data_conved1 = self.convolute(\n                    data_train,\n                    self.conv1,\n                    self.w_conv1,\n                    self.thre_conv1,\n                    conv_step=self.step_conv1,\n                )\n                data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\n                shape_featuremap1 = np.shape(data_conved1)\n                \"\"\"\n                print('  -----original shape   ', np.shape(data_train))\n                print('  ---- after convolution  ',np.shape(data_conv1))\n                print('  -----after pooling  ',np.shape(data_pooled1))\n               \"\"\"\n                data_bp_input = self._expand(data_pooled1)\n                bp_out1 = data_bp_input\n\n                bp_net_j = np.dot(bp_out1, self.vji.T) - self.thre_bp2\n                bp_out2 = self.sig(bp_net_j)\n                bp_net_k = np.dot(bp_out2, self.wkj.T) - self.thre_bp3\n                bp_out3 = self.sig(bp_net_k)\n\n                # --------------Model Leaning ------------------------\n                # calculate error and gradient---------------\n                pd_k_all = np.multiply(\n                    (data_teach - bp_out3), np.multiply(bp_out3, (1 - bp_out3))\n                )\n                pd_j_all = np.multiply(\n                    np.dot(pd_k_all, self.wkj), np.multiply(bp_out2, (1 - bp_out2))\n                )\n                pd_i_all = np.dot(pd_j_all, self.vji)\n\n                pd_conv1_pooled = pd_i_all / (self.size_pooling1 * self.size_pooling1)\n                pd_conv1_pooled = pd_conv1_pooled.T.getA().tolist()\n                pd_conv1_all = self._calculate_gradient_from_pool(\n                    data_conved1,\n                    pd_conv1_pooled,\n                    shape_featuremap1[0],\n                    shape_featuremap1[1],\n                    self.size_pooling1,\n                )\n                # weight and threshold learning process---------\n                # convolution layer\n                for k_conv in range(self.conv1[1]):\n                    pd_conv_list = self._expand_mat(pd_conv1_all[k_conv])\n                    delta_w = self.rate_weight * np.dot(pd_conv_list, data_focus1)\n\n                    self.w_conv1[k_conv] = self.w_conv1[k_conv] + delta_w.reshape(\n                        (self.conv1[0], self.conv1[0])\n                    )\n\n                    self.thre_conv1[k_conv] = (\n                        self.thre_conv1[k_conv]\n                        - np.sum(pd_conv1_all[k_conv]) * self.rate_thre\n                    )\n                # all connected layer\n                self.wkj = self.wkj + pd_k_all.T * bp_out2 * self.rate_weight\n                self.vji = self.vji + pd_j_all.T * bp_out1 * self.rate_weight\n                self.thre_bp3 = self.thre_bp3 - pd_k_all * self.rate_thre\n                self.thre_bp2 = self.thre_bp2 - pd_j_all * self.rate_thre\n                # calculate the sum error of all single image\n                errors = np.sum(abs(data_teach - bp_out3))\n                error_count += errors\n                # print('   ----Teach      ',data_teach)\n                # print('   ----BP_output  ',bp_out3)\n            rp = rp + 1\n            mse = error_count / patterns\n            all_mse.append(mse)\n\n        def draw_error():\n            yplot = [error_accuracy for i in range(int(n_repeat * 1.2))]\n            plt.plot(all_mse, \"+-\")\n            plt.plot(yplot, \"r--\")\n            plt.xlabel(\"Learning Times\")\n            plt.ylabel(\"All_mse\")\n            plt.grid(True, alpha=0.5)\n            plt.show()\n\n        print(\"------------------Training Complete---------------------\")\n        print((\" - - Training epoch: \", rp, f\"     - - Mse: {mse:.6f}\"))\n        if draw_e:\n            draw_error()\n        return mse\n\n    def predict(self, datas_test):\n        # model predict\n        produce_out = []\n        print(\"-------------------Start Testing-------------------------\")\n        print((\" - - Shape: Test_Data  \", np.shape(datas_test)))\n        for p in range(len(datas_test)):\n            data_test = np.asmatrix(datas_test[p])\n            data_focus1, data_conved1 = self.convolute(\n                data_test,\n                self.conv1,\n                self.w_conv1,\n                self.thre_conv1,\n                conv_step=self.step_conv1,\n            )\n            data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\n            data_bp_input = self._expand(data_pooled1)\n\n            bp_out1 = data_bp_input\n            bp_net_j = bp_out1 * self.vji.T - self.thre_bp2\n            bp_out2 = self.sig(bp_net_j)\n            bp_net_k = bp_out2 * self.wkj.T - self.thre_bp3\n            bp_out3 = self.sig(bp_net_k)\n            produce_out.extend(bp_out3.getA().tolist())\n        res = [list(map(self.do_round, each)) for each in produce_out]\n        return np.asarray(res)\n\n    def convolution(self, data):\n        # return the data of image after convoluting process so we can check it out\n        data_test = np.asmatrix(data)\n        data_focus1, data_conved1 = self.convolute(\n            data_test,\n            self.conv1,\n            self.w_conv1,\n            self.thre_conv1,\n            conv_step=self.step_conv1,\n        )\n        data_pooled1 = self.pooling(data_conved1, self.size_pooling1)\n\n        return data_conved1, data_pooled1\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    I will put the example in another file\n    \"\"\"\n", "neural_network/two_hidden_layers_neural_network.py": "\"\"\"\nReferences:\n    - http://neuralnetworksanddeeplearning.com/chap2.html (Backpropagation)\n    - https://en.wikipedia.org/wiki/Sigmoid_function (Sigmoid activation function)\n    - https://en.wikipedia.org/wiki/Feedforward_neural_network (Feedforward)\n\"\"\"\n\nimport numpy as np\n\n\nclass TwoHiddenLayerNeuralNetwork:\n    def __init__(self, input_array: np.ndarray, output_array: np.ndarray) -> None:\n        \"\"\"\n        This function initializes the TwoHiddenLayerNeuralNetwork class with random\n        weights for every layer and initializes predicted output with zeroes.\n\n        input_array : input values for training the neural network (i.e training data) .\n        output_array : expected output values of the given inputs.\n        \"\"\"\n\n        # Input values provided for training the model.\n        self.input_array = input_array\n\n        # Random initial weights are assigned where first argument is the\n        # number of nodes in previous layer and second argument is the\n        # number of nodes in the next layer.\n\n        # Random initial weights are assigned.\n        # self.input_array.shape[1] is used to represent number of nodes in input layer.\n        # First hidden layer consists of 4 nodes.\n        rng = np.random.default_rng()\n        self.input_layer_and_first_hidden_layer_weights = rng.random(\n            (self.input_array.shape[1], 4)\n        )\n\n        # Random initial values for the first hidden layer.\n        # First hidden layer has 4 nodes.\n        # Second hidden layer has 3 nodes.\n        self.first_hidden_layer_and_second_hidden_layer_weights = rng.random((4, 3))\n\n        # Random initial values for the second hidden layer.\n        # Second hidden layer has 3 nodes.\n        # Output layer has 1 node.\n        self.second_hidden_layer_and_output_layer_weights = rng.random((3, 1))\n\n        # Real output values provided.\n        self.output_array = output_array\n\n        # Predicted output values by the neural network.\n        # Predicted_output array initially consists of zeroes.\n        self.predicted_output = np.zeros(output_array.shape)\n\n    def feedforward(self) -> np.ndarray:\n        \"\"\"\n        The information moves in only one direction i.e. forward from the input nodes,\n        through the two hidden nodes and to the output nodes.\n        There are no cycles or loops in the network.\n\n        Return layer_between_second_hidden_layer_and_output\n            (i.e the last layer of the neural network).\n\n        >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\n        >>> output_val = np.array(([0], [0], [0]), dtype=float)\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        >>> res = nn.feedforward()\n        >>> array_sum = np.sum(res)\n        >>> np.isnan(array_sum)\n        False\n        \"\"\"\n        # Layer_between_input_and_first_hidden_layer is the layer connecting the\n        # input nodes with the first hidden layer nodes.\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\n            np.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)\n        )\n\n        # layer_between_first_hidden_layer_and_second_hidden_layer is the layer\n        # connecting the first hidden set of nodes with the second hidden set of nodes.\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\n            np.dot(\n                self.layer_between_input_and_first_hidden_layer,\n                self.first_hidden_layer_and_second_hidden_layer_weights,\n            )\n        )\n\n        # layer_between_second_hidden_layer_and_output is the layer connecting\n        # second hidden layer with the output node.\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\n            np.dot(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\n                self.second_hidden_layer_and_output_layer_weights,\n            )\n        )\n\n        return self.layer_between_second_hidden_layer_and_output\n\n    def back_propagation(self) -> None:\n        \"\"\"\n        Function for fine-tuning the weights of the neural net based on the\n        error rate obtained in the previous epoch (i.e., iteration).\n        Updation is done using derivative of sogmoid activation function.\n\n        >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\n        >>> output_val = np.array(([0], [0], [0]), dtype=float)\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        >>> res = nn.feedforward()\n        >>> nn.back_propagation()\n        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights\n        >>> (res == updated_weights).all()\n        False\n        \"\"\"\n\n        updated_second_hidden_layer_and_output_layer_weights = np.dot(\n            self.layer_between_first_hidden_layer_and_second_hidden_layer.T,\n            2\n            * (self.output_array - self.predicted_output)\n            * sigmoid_derivative(self.predicted_output),\n        )\n        updated_first_hidden_layer_and_second_hidden_layer_weights = np.dot(\n            self.layer_between_input_and_first_hidden_layer.T,\n            np.dot(\n                2\n                * (self.output_array - self.predicted_output)\n                * sigmoid_derivative(self.predicted_output),\n                self.second_hidden_layer_and_output_layer_weights.T,\n            )\n            * sigmoid_derivative(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer\n            ),\n        )\n        updated_input_layer_and_first_hidden_layer_weights = np.dot(\n            self.input_array.T,\n            np.dot(\n                np.dot(\n                    2\n                    * (self.output_array - self.predicted_output)\n                    * sigmoid_derivative(self.predicted_output),\n                    self.second_hidden_layer_and_output_layer_weights.T,\n                )\n                * sigmoid_derivative(\n                    self.layer_between_first_hidden_layer_and_second_hidden_layer\n                ),\n                self.first_hidden_layer_and_second_hidden_layer_weights.T,\n            )\n            * sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),\n        )\n\n        self.input_layer_and_first_hidden_layer_weights += (\n            updated_input_layer_and_first_hidden_layer_weights\n        )\n        self.first_hidden_layer_and_second_hidden_layer_weights += (\n            updated_first_hidden_layer_and_second_hidden_layer_weights\n        )\n        self.second_hidden_layer_and_output_layer_weights += (\n            updated_second_hidden_layer_and_output_layer_weights\n        )\n\n    def train(self, output: np.ndarray, iterations: int, give_loss: bool) -> None:\n        \"\"\"\n        Performs the feedforwarding and back propagation process for the\n        given number of iterations.\n        Every iteration will update the weights of neural network.\n\n        output : real output values,required for calculating loss.\n        iterations : number of times the weights are to be updated.\n        give_loss : boolean value, If True then prints loss for each iteration,\n                    If False then nothing is printed\n\n        >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\n        >>> output_val = np.array(([0], [1], [1]), dtype=float)\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        >>> first_iteration_weights = nn.feedforward()\n        >>> nn.back_propagation()\n        >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights\n        >>> (first_iteration_weights == updated_weights).all()\n        False\n        \"\"\"\n        for iteration in range(1, iterations + 1):\n            self.output = self.feedforward()\n            self.back_propagation()\n            if give_loss:\n                loss = np.mean(np.square(output - self.feedforward()))\n                print(f\"Iteration {iteration} Loss: {loss}\")\n\n    def predict(self, input_arr: np.ndarray) -> int:\n        \"\"\"\n        Predict's the output for the given input values using\n        the trained neural network.\n\n        The output value given by the model ranges in-between 0 and 1.\n        The predict function returns 1 if the model value is greater\n        than the threshold value else returns 0,\n        as the real output values are in binary.\n\n        >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\n        >>> output_val = np.array(([0], [1], [1]), dtype=float)\n        >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        >>> nn.train(output_val, 1000, False)\n        >>> nn.predict([0, 1, 0]) in (0, 1)\n        True\n        \"\"\"\n\n        # Input values for which the predictions are to be made.\n        self.array = input_arr\n\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\n            np.dot(self.array, self.input_layer_and_first_hidden_layer_weights)\n        )\n\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\n            np.dot(\n                self.layer_between_input_and_first_hidden_layer,\n                self.first_hidden_layer_and_second_hidden_layer_weights,\n            )\n        )\n\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\n            np.dot(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\n                self.second_hidden_layer_and_output_layer_weights,\n            )\n        )\n\n        return int((self.layer_between_second_hidden_layer_and_output > 0.6)[0])\n\n\ndef sigmoid(value: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies sigmoid activation function.\n\n    return normalized values\n\n    >>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\n    array([[0.73105858, 0.5       , 0.88079708],\n           [0.73105858, 0.5       , 0.5       ]])\n    \"\"\"\n    return 1 / (1 + np.exp(-value))\n\n\ndef sigmoid_derivative(value: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Provides the derivative value of the sigmoid function.\n\n    returns derivative of the sigmoid value\n\n    >>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))\n    array([[ 0.,  0., -2.],\n           [ 0.,  0.,  0.]])\n    \"\"\"\n    return (value) * (1 - (value))\n\n\ndef example() -> int:\n    \"\"\"\n    Example for \"how to use the neural network class and use the\n    respected methods for the desired output\".\n    Calls the TwoHiddenLayerNeuralNetwork class and\n    provides the fixed input output values to the model.\n    Model is trained for a fixed amount of iterations then the predict method is called.\n    In this example the output is divided into 2 classes i.e. binary classification,\n    the two classes are represented by '0' and '1'.\n\n    >>> example() in (0, 1)\n    True\n    \"\"\"\n    # Input values.\n    test_input = np.array(\n        (\n            [0, 0, 0],\n            [0, 0, 1],\n            [0, 1, 0],\n            [0, 1, 1],\n            [1, 0, 0],\n            [1, 0, 1],\n            [1, 1, 0],\n            [1, 1, 1],\n        ),\n        dtype=np.float64,\n    )\n\n    # True output values for the given input values.\n    output = np.array(([0], [1], [1], [0], [1], [0], [0], [1]), dtype=np.float64)\n\n    # Calling neural network class.\n    neural_network = TwoHiddenLayerNeuralNetwork(\n        input_array=test_input, output_array=output\n    )\n\n    # Calling training function.\n    # Set give_loss to True if you want to see loss in every iteration.\n    neural_network.train(output=output, iterations=10, give_loss=False)\n\n    return neural_network.predict(np.array(([1, 1, 1]), dtype=np.float64))\n\n\nif __name__ == \"__main__\":\n    example()\n", "neural_network/__init__.py": "", "neural_network/activation_functions/rectified_linear_unit.py": "\"\"\"\nThis script demonstrates the implementation of the ReLU function.\n\nIt's a kind of activation function defined as the positive part of its argument in the\ncontext of neural network.\nThe function takes a vector of K real numbers as input and then argmax(x, 0).\nAfter through ReLU, the element of the vector always 0 or real number.\n\nScript inspired from its corresponding Wikipedia article\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\n\ndef relu(vector: list[float]):\n    \"\"\"\n    Implements the relu function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        relu_vec (np.array): The input numpy array, after applying\n        relu.\n\n    >>> vec = np.array([-1, 0, 5])\n    >>> relu(vec)\n    array([0, 0, 5])\n    \"\"\"\n\n    # compare two arrays and then return element-wise maxima.\n    return np.maximum(0, vector)\n\n\nif __name__ == \"__main__\":\n    print(np.array(relu([-1, 0, 5])))  # --> [0, 0, 5]\n", "neural_network/activation_functions/mish.py": "\"\"\"\nMish Activation Function\n\nUse Case: Improved version of the ReLU activation function used in Computer Vision.\nFor more detailed information, you can refer to the following link:\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Mish\n\"\"\"\n\nimport numpy as np\n\nfrom .softplus import softplus\n\n\ndef mish(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n        Implements the Mish activation function.\n\n        Parameters:\n            vector (np.ndarray): The input array for Mish activation.\n\n        Returns:\n            np.ndarray: The input array after applying the Mish activation.\n\n        Formula:\n            f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))\n\n    Examples:\n    >>> mish(vector=np.array([2.3,0.6,-2,-3.8]))\n    array([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])\n\n    >>> mish(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([-0.00092952, -0.15113318,  0.33152014, -0.04745745])\n\n    \"\"\"\n    return vector * np.tanh(softplus(vector))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/scaled_exponential_linear_unit.py": "\"\"\"\nImplements the Scaled Exponential Linear Unit or SELU function.\nThe function takes a vector of K real numbers and two real numbers\nalpha(default = 1.6732) & lambda (default = 1.0507) as input and\nthen applies the SELU function to each element of the vector.\nSELU is a self-normalizing activation function. It is a variant\nof the ELU. The main advantage of SELU is that we can be sure\nthat the output will always be standardized due to its\nself-normalizing behavior. That means there is no need to\ninclude Batch-Normalization layers.\nReferences :\nhttps://iq.opengenus.org/scaled-exponential-linear-unit/\n\"\"\"\n\nimport numpy as np\n\n\ndef scaled_exponential_linear_unit(\n    vector: np.ndarray, alpha: float = 1.6732, lambda_: float = 1.0507\n) -> np.ndarray:\n    \"\"\"\n    Applies the Scaled Exponential Linear Unit function to each element of the vector.\n    Parameters :\n        vector : np.ndarray\n        alpha : float (default = 1.6732)\n        lambda_ : float (default = 1.0507)\n\n    Returns : np.ndarray\n    Formula : f(x) = lambda_ * x if x > 0\n                     lambda_ * alpha * (e**x - 1) if x <= 0\n    Examples :\n    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4]))\n    array([1.36591, 3.88759, 2.52168])\n\n    >>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2]))\n    array([1.36591, 4.93829, 8.61574])\n    \"\"\"\n    return lambda_ * np.where(vector > 0, vector, alpha * (np.exp(vector) - 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/gaussian_error_linear_unit.py": "\"\"\"\nThis script demonstrates an implementation of the Gaussian Error Linear Unit function.\n* https://en.wikipedia.org/wiki/Activation_function#Comparison_of_activation_functions\n\nThe function takes a vector of K real numbers as input and returns x * sigmoid(1.702*x).\nGaussian Error Linear Unit (GELU) is a high-performing neural network activation\nfunction.\n\nThis script is inspired by a corresponding research paper.\n* https://arxiv.org/abs/1606.08415\n\"\"\"\n\nimport numpy as np\n\n\ndef sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mathematical function sigmoid takes a vector x of K real numbers as input and\n    returns 1/ (1 + e^-x).\n    https://en.wikipedia.org/wiki/Sigmoid_function\n\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))\n\n\ndef gaussian_error_linear_unit(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Gaussian Error Linear Unit (GELU) function\n\n    Parameters:\n        vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values\n\n    Returns:\n        gelu_vec (np.ndarray): The input numpy array, after applying gelu\n\n    Examples:\n    >>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))\n    array([-0.15420423,  0.84579577,  1.93565862])\n\n    >>> gaussian_error_linear_unit(np.array([-3]))\n    array([-0.01807131])\n    \"\"\"\n    return vector * sigmoid(1.702 * vector)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/leaky_rectified_linear_unit.py": "\"\"\"\nLeaky Rectified Linear Unit (Leaky ReLU)\n\nUse Case: Leaky ReLU addresses the problem of the vanishing gradient.\nFor more detailed information, you can refer to the following link:\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Leaky_ReLU\n\"\"\"\n\nimport numpy as np\n\n\ndef leaky_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n        Implements the LeakyReLU activation function.\n\n        Parameters:\n            vector (np.ndarray): The input array for LeakyReLU activation.\n            alpha (float): The slope for negative values.\n\n        Returns:\n            np.ndarray: The input array after applying the LeakyReLU activation.\n\n        Formula: f(x) = x if x > 0 else f(x) = alpha * x\n\n    Examples:\n    >>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3 ,  0.6 , -0.6 , -1.14])\n\n    >>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)\n    array([-0.6164 , -0.0201 ,  0.45   , -0.30552])\n\n    \"\"\"\n    return np.where(vector > 0, vector, alpha * vector)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/soboleva_modified_hyperbolic_tangent.py": "\"\"\"\nThis script implements the Soboleva Modified Hyperbolic Tangent function.\n\nThe function applies the Soboleva Modified Hyperbolic Tangent function\nto each element of the vector.\n\nMore details about the activation function can be found on:\nhttps://en.wikipedia.org/wiki/Soboleva_modified_hyperbolic_tangent\n\"\"\"\n\nimport numpy as np\n\n\ndef soboleva_modified_hyperbolic_tangent(\n    vector: np.ndarray, a_value: float, b_value: float, c_value: float, d_value: float\n) -> np.ndarray:\n    \"\"\"\n    Implements the Soboleva Modified Hyperbolic Tangent function\n\n    Parameters:\n        vector (ndarray): A vector that consists of numeric values\n        a_value (float): parameter a of the equation\n        b_value (float): parameter b of the equation\n        c_value (float): parameter c of the equation\n        d_value (float): parameter d of the equation\n\n    Returns:\n        vector (ndarray): Input array after applying SMHT function\n\n    >>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56])\n    >>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8)\n    array([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,\n            0.1566043 ])\n    \"\"\"\n\n    # Separate the numerator and denominator for simplicity\n    # Calculate the numerator and denominator element-wise\n    numerator = np.exp(a_value * vector) - np.exp(-b_value * vector)\n    denominator = np.exp(c_value * vector) + np.exp(-d_value * vector)\n\n    # Calculate and return the final result element-wise\n    return numerator / denominator\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/exponential_linear_unit.py": "\"\"\"\nImplements the Exponential Linear Unit or ELU function.\n\nThe function takes a vector of K real numbers and a real number alpha as\ninput and then applies the ELU function to each element of the vector.\n\nScript inspired from its corresponding Wikipedia article\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)\n\"\"\"\n\nimport numpy as np\n\n\ndef exponential_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n         Implements the ELU activation function.\n         Parameters:\n             vector: the array containing input of elu activation\n             alpha: hyper-parameter\n         return:\n         elu (np.array): The input numpy array after applying elu.\n\n         Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0\n\n    Examples:\n    >>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)\n    array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])\n\n    >>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)\n    array([-0.06699323, -0.01736518,  0.45      , -0.06629904])\n\n\n    \"\"\"\n    return np.where(vector > 0, vector, (alpha * (np.exp(vector) - 1)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/softplus.py": "\"\"\"\nSoftplus Activation Function\n\nUse Case: The Softplus function is a smooth approximation of the ReLU function.\nFor more detailed information, you can refer to the following link:\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Softplus\n\"\"\"\n\nimport numpy as np\n\n\ndef softplus(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Softplus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the Softplus activation.\n\n    Returns:\n        np.ndarray: The input array after applying the Softplus activation.\n\n    Formula: f(x) = ln(1 + e^x)\n\n    Examples:\n    >>> softplus(np.array([2.3, 0.6, -2, -3.8]))\n    array([2.39554546, 1.03748795, 0.12692801, 0.02212422])\n\n    >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))\n    array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])\n    \"\"\"\n    return np.log(1 + np.exp(vector))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/__init__.py": "", "neural_network/activation_functions/binary_step.py": "\"\"\"\nThis script demonstrates the implementation of the Binary Step function.\n\nIt's an activation function in which the neuron is activated if the input is positive\nor 0, else it is deactivated\n\nIt's a simple activation function which is mentioned in this wikipedia article:\nhttps://en.wikipedia.org/wiki/Activation_function\n\"\"\"\n\nimport numpy as np\n\n\ndef binary_step(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the binary step function\n\n    Parameters:\n        vector (ndarray): A vector that consists of numeric values\n\n    Returns:\n        vector (ndarray): Input vector after applying binary step function\n\n    >>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])\n    >>> binary_step(vector)\n    array([0, 1, 1, 1, 0, 1])\n    \"\"\"\n\n    return np.where(vector >= 0, 1, 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/squareplus.py": "\"\"\"\nSquareplus Activation Function\n\nUse Case: Squareplus designed to enhance positive values and suppress negative values.\nFor more detailed information, you can refer to the following link:\nhttps://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Squareplus\n\"\"\"\n\nimport numpy as np\n\n\ndef squareplus(vector: np.ndarray, beta: float) -> np.ndarray:\n    \"\"\"\n    Implements the SquarePlus activation function.\n\n    Parameters:\n        vector (np.ndarray): The input array for the SquarePlus activation.\n        beta (float): size of the curved region\n\n    Returns:\n        np.ndarray: The input array after applying the SquarePlus activation.\n\n    Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2\n\n    Examples:\n    >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)\n    array([2.5       , 1.06811457, 0.22474487, 0.12731349])\n\n    >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)\n    array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])\n    \"\"\"\n    return (vector + np.sqrt(vector**2 + beta)) / 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "neural_network/activation_functions/swish.py": "\"\"\"\nThis script demonstrates the implementation of the Sigmoid Linear Unit (SiLU)\nor swish function.\n* https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\n* https://en.wikipedia.org/wiki/Swish_function\n\nThe function takes a vector x of K real numbers as input and returns x * sigmoid(x).\nSwish is a smooth, non-monotonic function defined as f(x) = x * sigmoid(x).\nExtensive experiments shows that Swish consistently matches or outperforms ReLU\non deep networks applied to a variety of challenging domains such as\nimage classification and machine translation.\n\nThis script is inspired by a corresponding research paper.\n* https://arxiv.org/abs/1710.05941\n* https://blog.paperspace.com/swish-activation-function/\n\"\"\"\n\nimport numpy as np\n\n\ndef sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mathematical function sigmoid takes a vector x of K real numbers as input and\n    returns 1/ (1 + e^-x).\n    https://en.wikipedia.org/wiki/Sigmoid_function\n\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))\n\n\ndef sigmoid_linear_unit(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the Sigmoid Linear Unit (SiLU) or swish function\n\n    Parameters:\n        vector (np.ndarray): A  numpy array consisting of real values\n\n    Returns:\n        swish_vec (np.ndarray): The input numpy array, after applying swish\n\n    Examples:\n    >>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0]))\n    array([-0.26894142,  0.73105858,  1.76159416])\n\n    >>> sigmoid_linear_unit(np.array([-2]))\n    array([-0.23840584])\n    \"\"\"\n    return vector * sigmoid(vector)\n\n\ndef swish(vector: np.ndarray, trainable_parameter: int) -> np.ndarray:\n    \"\"\"\n    Parameters:\n        vector (np.ndarray): A  numpy array consisting of real values\n        trainable_parameter: Use to implement various Swish Activation Functions\n\n    Returns:\n        swish_vec (np.ndarray): The input numpy array, after applying swish\n\n    Examples:\n    >>> swish(np.array([-1.0, 1.0, 2.0]), 2)\n    array([-0.11920292,  0.88079708,  1.96402758])\n\n    >>> swish(np.array([-2]), 1)\n    array([-0.23840584])\n    \"\"\"\n    return vector * sigmoid(trainable_parameter * vector)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "genetic_algorithm/basic_string.py": "\"\"\"\nSimple multithreaded algorithm to show how the 4 phases of a genetic algorithm works\n(Evaluation, Selection, Crossover and Mutation)\nhttps://en.wikipedia.org/wiki/Genetic_algorithm\nAuthor: D4rkia\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\n\n# Maximum size of the population.  Bigger could be faster but is more memory expensive.\nN_POPULATION = 200\n# Number of elements selected in every generation of evolution. The selection takes\n# place from best to worst of that generation and must be smaller than N_POPULATION.\nN_SELECTED = 50\n# Probability that an element of a generation can mutate, changing one of its genes.\n# This will guarantee that all genes will be used during evolution.\nMUTATION_PROBABILITY = 0.4\n# Just a seed to improve randomness required by the algorithm.\nrandom.seed(random.randint(0, 1000))\n\n\ndef evaluate(item: str, main_target: str) -> tuple[str, float]:\n    \"\"\"\n    Evaluate how similar the item is with the target by just\n    counting each char in the right position\n    >>> evaluate(\"Helxo Worlx\", \"Hello World\")\n    ('Helxo Worlx', 9.0)\n    \"\"\"\n    score = len([g for position, g in enumerate(item) if g == main_target[position]])\n    return (item, float(score))\n\n\ndef crossover(parent_1: str, parent_2: str) -> tuple[str, str]:\n    \"\"\"\n    Slice and combine two strings at a random point.\n    >>> random.seed(42)\n    >>> crossover(\"123456\", \"abcdef\")\n    ('12345f', 'abcde6')\n    \"\"\"\n    random_slice = random.randint(0, len(parent_1) - 1)\n    child_1 = parent_1[:random_slice] + parent_2[random_slice:]\n    child_2 = parent_2[:random_slice] + parent_1[random_slice:]\n    return (child_1, child_2)\n\n\ndef mutate(child: str, genes: list[str]) -> str:\n    \"\"\"\n    Mutate a random gene of a child with another one from the list.\n    >>> random.seed(123)\n    >>> mutate(\"123456\", list(\"ABCDEF\"))\n    '12345A'\n    \"\"\"\n    child_list = list(child)\n    if random.uniform(0, 1) < MUTATION_PROBABILITY:\n        child_list[random.randint(0, len(child)) - 1] = random.choice(genes)\n    return \"\".join(child_list)\n\n\n# Select, crossover and mutate a new population.\ndef select(\n    parent_1: tuple[str, float],\n    population_score: list[tuple[str, float]],\n    genes: list[str],\n) -> list[str]:\n    \"\"\"\n    Select the second parent and generate new population\n\n    >>> random.seed(42)\n    >>> parent_1 = (\"123456\", 8.0)\n    >>> population_score = [(\"abcdef\", 4.0), (\"ghijkl\", 5.0), (\"mnopqr\", 7.0)]\n    >>> genes = list(\"ABCDEF\")\n    >>> child_n = int(min(parent_1[1] + 1, 10))\n    >>> population = []\n    >>> for _ in range(child_n):\n    ...     parent_2 = population_score[random.randrange(len(population_score))][0]\n    ...     child_1, child_2 = crossover(parent_1[0], parent_2)\n    ...     population.extend((mutate(child_1, genes), mutate(child_2, genes)))\n    >>> len(population) == (int(parent_1[1]) + 1) * 2\n    True\n    \"\"\"\n    pop = []\n    # Generate more children proportionally to the fitness score.\n    child_n = int(parent_1[1] * 100) + 1\n    child_n = 10 if child_n >= 10 else child_n\n    for _ in range(child_n):\n        parent_2 = population_score[random.randint(0, N_SELECTED)][0]\n\n        child_1, child_2 = crossover(parent_1[0], parent_2)\n        # Append new string to the population list.\n        pop.append(mutate(child_1, genes))\n        pop.append(mutate(child_2, genes))\n    return pop\n\n\ndef basic(target: str, genes: list[str], debug: bool = True) -> tuple[int, int, str]:\n    \"\"\"\n    Verify that the target contains no genes besides the ones inside genes variable.\n\n    >>> from string import ascii_lowercase\n    >>> basic(\"doctest\", ascii_lowercase, debug=False)[2]\n    'doctest'\n    >>> genes = list(ascii_lowercase)\n    >>> genes.remove(\"e\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e'] is not in genes list, evolution cannot converge\n    >>> genes.remove(\"s\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e', 's'] is not in genes list, evolution cannot converge\n    >>> genes.remove(\"t\")\n    >>> basic(\"test\", genes)\n    Traceback (most recent call last):\n        ...\n    ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge\n    \"\"\"\n\n    # Verify if N_POPULATION is bigger than N_SELECTED\n    if N_POPULATION < N_SELECTED:\n        msg = f\"{N_POPULATION} must be bigger than {N_SELECTED}\"\n        raise ValueError(msg)\n    # Verify that the target contains no genes besides the ones inside genes variable.\n    not_in_genes_list = sorted({c for c in target if c not in genes})\n    if not_in_genes_list:\n        msg = f\"{not_in_genes_list} is not in genes list, evolution cannot converge\"\n        raise ValueError(msg)\n\n    # Generate random starting population.\n    population = []\n    for _ in range(N_POPULATION):\n        population.append(\"\".join([random.choice(genes) for i in range(len(target))]))\n\n    # Just some logs to know what the algorithms is doing.\n    generation, total_population = 0, 0\n\n    # This loop will end when we find a perfect match for our target.\n    while True:\n        generation += 1\n        total_population += len(population)\n\n        # Random population created. Now it's time to evaluate.\n\n        # Adding a bit of concurrency can make everything faster,\n        #\n        # import concurrent.futures\n        # population_score: list[tuple[str, float]] = []\n        # with concurrent.futures.ThreadPoolExecutor(\n        #                                   max_workers=NUM_WORKERS) as executor:\n        #     futures = {executor.submit(evaluate, item) for item in population}\n        #     concurrent.futures.wait(futures)\n        #     population_score = [item.result() for item in futures]\n        #\n        # but with a simple algorithm like this, it will probably be slower.\n        # We just need to call evaluate for every item inside the population.\n        population_score = [evaluate(item, target) for item in population]\n\n        # Check if there is a matching evolution.\n        population_score = sorted(population_score, key=lambda x: x[1], reverse=True)\n        if population_score[0][0] == target:\n            return (generation, total_population, population_score[0][0])\n\n        # Print the best result every 10 generation.\n        # Just to know that the algorithm is working.\n        if debug and generation % 10 == 0:\n            print(\n                f\"\\nGeneration: {generation}\"\n                f\"\\nTotal Population:{total_population}\"\n                f\"\\nBest score: {population_score[0][1]}\"\n                f\"\\nBest string: {population_score[0][0]}\"\n            )\n\n        # Flush the old population, keeping some of the best evolutions.\n        # Keeping this avoid regression of evolution.\n        population_best = population[: int(N_POPULATION / 3)]\n        population.clear()\n        population.extend(population_best)\n        # Normalize population score to be between 0 and 1.\n        population_score = [\n            (item, score / len(target)) for item, score in population_score\n        ]\n\n        # This is selection\n        for i in range(N_SELECTED):\n            population.extend(select(population_score[int(i)], population_score, genes))\n            # Check if the population has already reached the maximum value and if so,\n            # break the cycle.  If this check is disabled, the algorithm will take\n            # forever to compute large strings, but will also calculate small strings in\n            # a far fewer generations.\n            if len(population) > N_POPULATION:\n                break\n\n\nif __name__ == \"__main__\":\n    target_str = (\n        \"This is a genetic algorithm to evaluate, combine, evolve, and mutate a string!\"\n    )\n    genes_list = list(\n        \" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm\"\n        \"nopqrstuvwxyz.,;!?+-*#@^'\u00e8\u00e9\u00f2\u00e0\u20ac\u00f9=)(&%$\u00a3/\\\\\"\n    )\n    generation, population, target = basic(target_str, genes_list)\n    print(\n        f\"\\nGeneration: {generation}\\nTotal Population: {population}\\nTarget: {target}\"\n    )\n", "genetic_algorithm/__init__.py": "", "project_euler/__init__.py": "", "project_euler/problem_074/sol2.py": "\"\"\"\nProject Euler Problem 074: https://projecteuler.net/problem=74\n\nThe number 145 is well known for the property that the sum of the factorial of its\ndigits is equal to 145:\n\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\nPerhaps less well known is 169, in that it produces the longest chain of numbers that\nlink back to 169; it turns out that there are only three such loops that exist:\n\n169 \u2192 363601 \u2192 1454 \u2192 169\n871 \u2192 45361 \u2192 871\n872 \u2192 45362 \u2192 872\n\nIt is not difficult to prove that EVERY starting number will eventually get stuck in a\nloop. For example,\n\n69 \u2192 363600 \u2192 1454 \u2192 169 \u2192 363601 (\u2192 1454)\n78 \u2192 45360 \u2192 871 \u2192 45361 (\u2192 871)\n540 \u2192 145 (\u2192 145)\n\nStarting with 69 produces a chain of five non-repeating terms, but the longest\nnon-repeating chain with a starting number below one million is sixty terms.\n\nHow many chains, with a starting number below one million, contain exactly sixty\nnon-repeating terms?\n\nSolution approach:\nThis solution simply consists in a loop that generates the chains of non repeating\nitems using the cached sizes of the previous chains.\nThe generation of the chain stops before a repeating item or if the size of the chain\nis greater then the desired one.\nAfter generating each chain, the length is checked and the counter increases.\n\"\"\"\n\nfrom math import factorial\n\nDIGIT_FACTORIAL: dict[str, int] = {str(digit): factorial(digit) for digit in range(10)}\n\n\ndef digit_factorial_sum(number: int) -> int:\n    \"\"\"\n    Function to perform the sum of the factorial of all the digits in number\n\n    >>> digit_factorial_sum(69.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter number must be int\n\n    >>> digit_factorial_sum(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter number must be greater than or equal to 0\n\n    >>> digit_factorial_sum(0)\n    1\n\n    >>> digit_factorial_sum(69)\n    363600\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Parameter number must be int\")\n\n    if number < 0:\n        raise ValueError(\"Parameter number must be greater than or equal to 0\")\n\n    # Converts number in string to iterate on its digits and adds its factorial.\n    return sum(DIGIT_FACTORIAL[digit] for digit in str(number))\n\n\ndef solution(chain_length: int = 60, number_limit: int = 1000000) -> int:\n    \"\"\"\n    Returns the number of numbers below number_limit that produce chains with exactly\n    chain_length non repeating elements.\n\n    >>> solution(10.0, 1000)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(10, 1000.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameters chain_length and number_limit must be int\n\n    >>> solution(0, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameters chain_length and number_limit must be greater than 0\n\n    >>> solution(10, 1000)\n    26\n    \"\"\"\n\n    if not isinstance(chain_length, int) or not isinstance(number_limit, int):\n        raise TypeError(\"Parameters chain_length and number_limit must be int\")\n\n    if chain_length <= 0 or number_limit <= 0:\n        raise ValueError(\n            \"Parameters chain_length and number_limit must be greater than 0\"\n        )\n\n    # the counter for the chains with the exact desired length\n    chains_counter = 0\n    # the cached sizes of the previous chains\n    chain_sets_lengths: dict[int, int] = {}\n\n    for start_chain_element in range(1, number_limit):\n        # The temporary set will contain the elements of the chain\n        chain_set = set()\n        chain_set_length = 0\n\n        # Stop computing the chain when you find a cached size, a repeating item or the\n        # length is greater then the desired one.\n        chain_element = start_chain_element\n        while (\n            chain_element not in chain_sets_lengths\n            and chain_element not in chain_set\n            and chain_set_length <= chain_length\n        ):\n            chain_set.add(chain_element)\n            chain_set_length += 1\n            chain_element = digit_factorial_sum(chain_element)\n\n        if chain_element in chain_sets_lengths:\n            chain_set_length += chain_sets_lengths[chain_element]\n\n        chain_sets_lengths[start_chain_element] = chain_set_length\n\n        # If chain contains the exact amount of elements increase the counter\n        if chain_set_length == chain_length:\n            chains_counter += 1\n\n    return chains_counter\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{solution()}\")\n", "project_euler/problem_074/sol1.py": "\"\"\"\nProject Euler Problem 74: https://projecteuler.net/problem=74\n\nThe number 145 is well known for the property that the sum of the factorial of its\ndigits is equal to 145:\n\n1! + 4! + 5! = 1 + 24 + 120 = 145\n\nPerhaps less well known is 169, in that it produces the longest chain of numbers that\nlink back to 169; it turns out that there are only three such loops that exist:\n\n169 \u2192 363601 \u2192 1454 \u2192 169\n871 \u2192 45361 \u2192 871\n872 \u2192 45362 \u2192 872\n\nIt is not difficult to prove that EVERY starting number will eventually get stuck in\na loop. For example,\n\n69 \u2192 363600 \u2192 1454 \u2192 169 \u2192 363601 (\u2192 1454)\n78 \u2192 45360 \u2192 871 \u2192 45361 (\u2192 871)\n540 \u2192 145 (\u2192 145)\n\nStarting with 69 produces a chain of five non-repeating terms, but the longest\nnon-repeating chain with a starting number below one million is sixty terms.\n\nHow many chains, with a starting number below one million, contain exactly sixty\nnon-repeating terms?\n\"\"\"\n\nDIGIT_FACTORIALS = {\n    \"0\": 1,\n    \"1\": 1,\n    \"2\": 2,\n    \"3\": 6,\n    \"4\": 24,\n    \"5\": 120,\n    \"6\": 720,\n    \"7\": 5040,\n    \"8\": 40320,\n    \"9\": 362880,\n}\n\nCACHE_SUM_DIGIT_FACTORIALS = {145: 145}\n\nCHAIN_LENGTH_CACHE = {\n    145: 0,\n    169: 3,\n    36301: 3,\n    1454: 3,\n    871: 2,\n    45361: 2,\n    872: 2,\n}\n\n\ndef sum_digit_factorials(n: int) -> int:\n    \"\"\"\n    Return the sum of the factorial of the digits of n.\n    >>> sum_digit_factorials(145)\n    145\n    >>> sum_digit_factorials(45361)\n    871\n    >>> sum_digit_factorials(540)\n    145\n    \"\"\"\n    if n in CACHE_SUM_DIGIT_FACTORIALS:\n        return CACHE_SUM_DIGIT_FACTORIALS[n]\n    ret = sum(DIGIT_FACTORIALS[let] for let in str(n))\n    CACHE_SUM_DIGIT_FACTORIALS[n] = ret\n    return ret\n\n\ndef chain_length(n: int, previous: set | None = None) -> int:\n    \"\"\"\n    Calculate the length of the chain of non-repeating terms starting with n.\n    Previous is a set containing the previous member of the chain.\n    >>> chain_length(10101)\n    11\n    >>> chain_length(555)\n    20\n    >>> chain_length(178924)\n    39\n    \"\"\"\n    previous = previous or set()\n    if n in CHAIN_LENGTH_CACHE:\n        return CHAIN_LENGTH_CACHE[n]\n    next_number = sum_digit_factorials(n)\n    if next_number in previous:\n        CHAIN_LENGTH_CACHE[n] = 0\n        return 0\n    else:\n        previous.add(n)\n        ret = 1 + chain_length(next_number, previous)\n        CHAIN_LENGTH_CACHE[n] = ret\n        return ret\n\n\ndef solution(num_terms: int = 60, max_start: int = 1000000) -> int:\n    \"\"\"\n    Return the number of chains with a starting number below one million which\n    contain exactly n non-repeating terms.\n    >>> solution(10,1000)\n    28\n    \"\"\"\n    return sum(1 for i in range(1, max_start) if chain_length(i) == num_terms)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_074/__init__.py": "", "project_euler/problem_800/sol1.py": "\"\"\"\nProject Euler Problem 800: https://projecteuler.net/problem=800\n\nAn integer of the form p^q q^p with prime numbers p != q is called a hybrid-integer.\nFor example, 800 = 2^5 5^2 is a hybrid-integer.\n\nWe define C(n) to be the number of hybrid-integers less than or equal to n.\nYou are given C(800) = 2 and C(800^800) = 10790\n\nFind C(800800^800800)\n\"\"\"\n\nfrom math import isqrt, log2\n\n\ndef calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number\n\n    >>> calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n    \"\"\"\n\n    is_prime = [True] * max_number\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]\n\n\ndef solution(base: int = 800800, degree: int = 800800) -> int:\n    \"\"\"\n    Returns the number of hybrid-integers less than or equal to base^degree\n\n    >>> solution(800, 1)\n    2\n\n    >>> solution(800, 800)\n    10790\n    \"\"\"\n\n    upper_bound = degree * log2(base)\n    max_prime = int(upper_bound)\n    prime_numbers = calculate_prime_numbers(max_prime)\n\n    hybrid_integers_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left < right:\n        while (\n            prime_numbers[right] * log2(prime_numbers[left])\n            + prime_numbers[left] * log2(prime_numbers[right])\n            > upper_bound\n        ):\n            right -= 1\n        hybrid_integers_count += right - left\n        left += 1\n\n    return hybrid_integers_count\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_800/__init__.py": "", "project_euler/problem_005/sol2.py": "from maths.greatest_common_divisor import greatest_common_divisor\n\n\"\"\"\nProject Euler Problem 5: https://projecteuler.net/problem=5\n\nSmallest multiple\n\n2520 is the smallest number that can be divided by each of the numbers\nfrom 1 to 10 without any remainder.\n\nWhat is the smallest positive number that is _evenly divisible_ by all\nof the numbers from 1 to 20?\n\nReferences:\n    - https://en.wiktionary.org/wiki/evenly_divisible\n    - https://en.wikipedia.org/wiki/Euclidean_algorithm\n    - https://en.wikipedia.org/wiki/Least_common_multiple\n\"\"\"\n\n\ndef lcm(x: int, y: int) -> int:\n    \"\"\"\n    Least Common Multiple.\n\n    Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b\n\n    >>> lcm(3, 15)\n    15\n    >>> lcm(1, 27)\n    27\n    >>> lcm(13, 27)\n    351\n    >>> lcm(64, 48)\n    192\n    \"\"\"\n\n    return (x * y) // greatest_common_divisor(x, y)\n\n\ndef solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    \"\"\"\n\n    g = 1\n    for i in range(1, n + 1):\n        g = lcm(g, i)\n    return g\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_005/sol1.py": "\"\"\"\nProject Euler Problem 5: https://projecteuler.net/problem=5\n\nSmallest multiple\n\n2520 is the smallest number that can be divided by each of the numbers\nfrom 1 to 10 without any remainder.\n\nWhat is the smallest positive number that is _evenly divisible_ by all\nof the numbers from 1 to 20?\n\nReferences:\n    - https://en.wiktionary.org/wiki/evenly_divisible\n\"\"\"\n\n\ndef solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the smallest positive number that is evenly divisible (divisible\n    with no remainder) by all of the numbers from 1 to n.\n\n    >>> solution(10)\n    2520\n    >>> solution(15)\n    360360\n    >>> solution(22)\n    232792560\n    >>> solution(3.4)\n    6\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 0\n    while 1:\n        i += n * (n - 1)\n        nfound = 0\n        for j in range(2, n):\n            if i % j != 0:\n                nfound = 1\n                break\n        if nfound == 0:\n            if i == 0:\n                i = 1\n            return i\n    return None\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_005/__init__.py": "", "project_euler/problem_033/sol1.py": "\"\"\"\nProblem 33: https://projecteuler.net/problem=33\n\nThe fraction 49/98 is a curious fraction, as an inexperienced\nmathematician in attempting to simplify it may incorrectly believe\nthat 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.\n\nWe shall consider fractions like, 30/50 = 3/5, to be trivial examples.\n\nThere are exactly four non-trivial examples of this type of fraction,\nless than one in value, and containing two digits in the numerator\nand denominator.\n\nIf the product of these four fractions is given in its lowest common\nterms, find the value of the denominator.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom fractions import Fraction\n\n\ndef is_digit_cancelling(num: int, den: int) -> bool:\n    return (\n        num != den and num % 10 == den // 10 and (num // 10) / (den % 10) == num / den\n    )\n\n\ndef fraction_list(digit_len: int) -> list[str]:\n    \"\"\"\n    >>> fraction_list(2)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(3)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(4)\n    ['16/64', '19/95', '26/65', '49/98']\n    >>> fraction_list(0)\n    []\n    >>> fraction_list(5)\n    ['16/64', '19/95', '26/65', '49/98']\n    \"\"\"\n    solutions = []\n    den = 11\n    last_digit = int(\"1\" + \"0\" * digit_len)\n    for num in range(den, last_digit):\n        while den <= 99:\n            if (\n                (num != den)\n                and (num % 10 == den // 10)\n                and (den % 10 != 0)\n                and is_digit_cancelling(num, den)\n            ):\n                solutions.append(f\"{num}/{den}\")\n            den += 1\n        num += 1\n        den = 10\n    return solutions\n\n\ndef solution(n: int = 2) -> int:\n    \"\"\"\n    Return the solution to the problem\n    \"\"\"\n    result = 1.0\n    for fraction in fraction_list(n):\n        frac = Fraction(fraction)\n        result *= frac.denominator / frac.numerator\n    return int(result)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_033/__init__.py": "", "project_euler/problem_011/sol2.py": "\"\"\"\nWhat is the greatest product of four adjacent numbers (horizontally,\nvertically, or diagonally) in this 20x20 array?\n\n08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"Returns the greatest product of four adjacent numbers (horizontally,\n    vertically, or diagonally).\n\n    >>> solution()\n    70600674\n    \"\"\"\n    with open(os.path.dirname(__file__) + \"/grid.txt\") as f:\n        grid = []\n        for _ in range(20):\n            grid.append([int(x) for x in f.readline().split()])\n\n        maximum = 0\n\n        # right\n        for i in range(20):\n            for j in range(17):\n                temp = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]\n                if temp > maximum:\n                    maximum = temp\n\n        # down\n        for i in range(17):\n            for j in range(20):\n                temp = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]\n                if temp > maximum:\n                    maximum = temp\n\n        # diagonal 1\n        for i in range(17):\n            for j in range(17):\n                temp = (\n                    grid[i][j]\n                    * grid[i + 1][j + 1]\n                    * grid[i + 2][j + 2]\n                    * grid[i + 3][j + 3]\n                )\n                if temp > maximum:\n                    maximum = temp\n\n        # diagonal 2\n        for i in range(17):\n            for j in range(3, 20):\n                temp = (\n                    grid[i][j]\n                    * grid[i + 1][j - 1]\n                    * grid[i + 2][j - 2]\n                    * grid[i + 3][j - 3]\n                )\n                if temp > maximum:\n                    maximum = temp\n        return maximum\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_011/sol1.py": "\"\"\"\nWhat is the greatest product of four adjacent numbers (horizontally,\nvertically, or diagonally) in this 20x20 array?\n\n08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\n\"\"\"\n\nimport os\n\n\ndef largest_product(grid):\n    n_columns = len(grid[0])\n    n_rows = len(grid)\n\n    largest = 0\n    lr_diag_product = 0\n    rl_diag_product = 0\n\n    # Check vertically, horizontally, diagonally at the same time (only works\n    # for nxn grid)\n    for i in range(n_columns):\n        for j in range(n_rows - 3):\n            vert_product = grid[j][i] * grid[j + 1][i] * grid[j + 2][i] * grid[j + 3][i]\n            horz_product = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]\n\n            # Left-to-right diagonal (\\) product\n            if i < n_columns - 3:\n                lr_diag_product = (\n                    grid[i][j]\n                    * grid[i + 1][j + 1]\n                    * grid[i + 2][j + 2]\n                    * grid[i + 3][j + 3]\n                )\n\n            # Right-to-left diagonal(/) product\n            if i > 2:\n                rl_diag_product = (\n                    grid[i][j]\n                    * grid[i - 1][j + 1]\n                    * grid[i - 2][j + 2]\n                    * grid[i - 3][j + 3]\n                )\n\n            max_product = max(\n                vert_product, horz_product, lr_diag_product, rl_diag_product\n            )\n            if max_product > largest:\n                largest = max_product\n\n    return largest\n\n\ndef solution():\n    \"\"\"Returns the greatest product of four adjacent numbers (horizontally,\n    vertically, or diagonally).\n\n    >>> solution()\n    70600674\n    \"\"\"\n    grid = []\n    with open(os.path.dirname(__file__) + \"/grid.txt\") as file:\n        for line in file:\n            grid.append(line.strip(\"\\n\").split(\" \"))\n\n    grid = [[int(i) for i in grid[j]] for j in range(len(grid))]\n\n    return largest_product(grid)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_011/__init__.py": "", "project_euler/problem_012/sol2.py": "\"\"\"\nHighly divisible triangular numbers\nProblem 12\nThe sequence of triangle numbers is generated by adding the natural numbers. So\nthe 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten\nterms would be:\n\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n\nLet us list the factors of the first seven triangle numbers:\n\n 1: 1\n 3: 1,3\n 6: 1,2,3,6\n10: 1,2,5,10\n15: 1,3,5,15\n21: 1,3,7,21\n28: 1,2,4,7,14,28\nWe can see that 28 is the first triangle number to have over five divisors.\n\nWhat is the value of the first triangle number to have over five hundred\ndivisors?\n\"\"\"\n\n\ndef triangle_number_generator():\n    for n in range(1, 1000000):\n        yield n * (n + 1) // 2\n\n\ndef count_divisors(n):\n    divisors_count = 1\n    i = 2\n    while i * i <= n:\n        multiplicity = 0\n        while n % i == 0:\n            n //= i\n            multiplicity += 1\n        divisors_count *= multiplicity + 1\n        i += 1\n    if n > 1:\n        divisors_count *= 2\n    return divisors_count\n\n\ndef solution():\n    \"\"\"Returns the value of the first triangle number to have over five hundred\n    divisors.\n\n    >>> solution()\n    76576500\n    \"\"\"\n    return next(i for i in triangle_number_generator() if count_divisors(i) > 500)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_012/sol1.py": "\"\"\"\nHighly divisible triangular numbers\nProblem 12\nThe sequence of triangle numbers is generated by adding the natural numbers. So\nthe 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten\nterms would be:\n\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n\nLet us list the factors of the first seven triangle numbers:\n\n 1: 1\n 3: 1,3\n 6: 1,2,3,6\n10: 1,2,5,10\n15: 1,3,5,15\n21: 1,3,7,21\n28: 1,2,4,7,14,28\nWe can see that 28 is the first triangle number to have over five divisors.\n\nWhat is the value of the first triangle number to have over five hundred\ndivisors?\n\"\"\"\n\n\ndef count_divisors(n):\n    n_divisors = 1\n    i = 2\n    while i * i <= n:\n        multiplicity = 0\n        while n % i == 0:\n            n //= i\n            multiplicity += 1\n        n_divisors *= multiplicity + 1\n        i += 1\n    if n > 1:\n        n_divisors *= 2\n    return n_divisors\n\n\ndef solution():\n    \"\"\"Returns the value of the first triangle number to have over five hundred\n    divisors.\n\n    >>> solution()\n    76576500\n    \"\"\"\n    t_num = 1\n    i = 1\n\n    while True:\n        i += 1\n        t_num += i\n\n        if count_divisors(t_num) > 500:\n            break\n\n    return t_num\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_012/__init__.py": "", "project_euler/problem_082/sol1.py": "\"\"\"\nProject Euler Problem 82: https://projecteuler.net/problem=82\n\nThe minimal path sum in the 5 by 5 matrix below, by starting in any cell\nin the left column and finishing in any cell in the right column,\nand only moving up, down, and right, is indicated in red and bold;\nthe sum is equal to 994.\n\n     131    673   [234]  [103]  [18]\n    [201]  [96]   [342]   965    150\n     630    803    746    422    111\n     537    699    497    121    956\n     805    732    524    37     331\n\nFind the minimal path sum from the left column to the right column in matrix.txt\n(https://projecteuler.net/project/resources/p082_matrix.txt)\n(right click and \"Save Link/Target As...\"),\na 31K text file containing an 80 by 80 matrix.\n\"\"\"\n\nimport os\n\n\ndef solution(filename: str = \"input.txt\") -> int:\n    \"\"\"\n    Returns the minimal path sum in the matrix from the file, by starting in any cell\n    in the left column and finishing in any cell in the right column,\n    and only moving up, down, and right\n\n    >>> solution(\"test_matrix.txt\")\n    994\n    \"\"\"\n\n    with open(os.path.join(os.path.dirname(__file__), filename)) as input_file:\n        matrix = [\n            [int(element) for element in line.split(\",\")]\n            for line in input_file.readlines()\n        ]\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    minimal_path_sums = [[-1 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        minimal_path_sums[i][0] = matrix[i][0]\n\n    for j in range(1, cols):\n        for i in range(rows):\n            minimal_path_sums[i][j] = minimal_path_sums[i][j - 1] + matrix[i][j]\n\n        for i in range(1, rows):\n            minimal_path_sums[i][j] = min(\n                minimal_path_sums[i][j], minimal_path_sums[i - 1][j] + matrix[i][j]\n            )\n\n        for i in range(rows - 2, -1, -1):\n            minimal_path_sums[i][j] = min(\n                minimal_path_sums[i][j], minimal_path_sums[i + 1][j] + matrix[i][j]\n            )\n\n    return min(minimal_path_sums_row[-1] for minimal_path_sums_row in minimal_path_sums)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_082/__init__.py": "", "project_euler/problem_493/sol1.py": "\"\"\"\nProject Euler Problem 493: https://projecteuler.net/problem=493\n\n70 coloured balls are placed in an urn, 10 for each of the seven rainbow colours.\nWhat is the expected number of distinct colours in 20 randomly picked balls?\nGive your answer with nine digits after the decimal point (a.bcdefghij).\n\n-----\n\nThis combinatorial problem can be solved by decomposing the problem into the\nfollowing steps:\n1. Calculate the total number of possible picking combinations\n[combinations := binom_coeff(70, 20)]\n2. Calculate the number of combinations with one colour missing\n[missing := binom_coeff(60, 20)]\n3. Calculate the probability of one colour missing\n[missing_prob := missing / combinations]\n4. Calculate the probability of no colour missing\n[no_missing_prob := 1 - missing_prob]\n5. Calculate the expected number of distinct colours\n[expected = 7 * no_missing_prob]\n\nReferences:\n- https://en.wikipedia.org/wiki/Binomial_coefficient\n\"\"\"\n\nimport math\n\nBALLS_PER_COLOUR = 10\nNUM_COLOURS = 7\nNUM_BALLS = BALLS_PER_COLOUR * NUM_COLOURS\n\n\ndef solution(num_picks: int = 20) -> str:\n    \"\"\"\n    Calculates the expected number of distinct colours\n\n    >>> solution(10)\n    '5.669644129'\n\n    >>> solution(30)\n    '6.985042712'\n    \"\"\"\n    total = math.comb(NUM_BALLS, num_picks)\n    missing_colour = math.comb(NUM_BALLS - BALLS_PER_COLOUR, num_picks)\n\n    result = NUM_COLOURS * (1 - missing_colour / total)\n\n    return f\"{result:.9f}\"\n\n\nif __name__ == \"__main__\":\n    print(solution(20))\n", "project_euler/problem_493/__init__.py": "", "project_euler/problem_041/sol1.py": "\"\"\"\nPandigital prime\nProblem 41: https://projecteuler.net/problem=41\n\nWe shall say that an n-digit number is pandigital if it makes use of all the digits\n1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.\nWhat is the largest n-digit pandigital prime that exists?\n\nAll pandigital numbers except for 1, 4 ,7 pandigital numbers are divisible by 3.\nSo we will check only 7 digit pandigital numbers to obtain the largest possible\npandigital prime.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom itertools import permutations\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(n: int = 7) -> int:\n    \"\"\"\n    Returns the maximum pandigital prime number of length n.\n    If there are none, then it will return 0.\n    >>> solution(2)\n    0\n    >>> solution(4)\n    4231\n    >>> solution(7)\n    7652413\n    \"\"\"\n    pandigital_str = \"\".join(str(i) for i in range(1, n + 1))\n    perm_list = [int(\"\".join(i)) for i in permutations(pandigital_str, n)]\n    pandigitals = [num for num in perm_list if is_prime(num)]\n    return max(pandigitals) if pandigitals else 0\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_041/__init__.py": "#\n", "project_euler/problem_109/sol1.py": "\"\"\"\nIn the game of darts a player throws three darts at a target board which is\nsplit into twenty equal sized sections numbered one to twenty.\n\ufffc\nThe score of a dart is determined by the number of the region that the dart\nlands in. A dart landing outside the red/green outer ring scores zero. The black\nand cream regions inside this ring represent single scores. However, the red/green\nouter ring and middle ring score double and treble scores respectively.\n\nAt the centre of the board are two concentric circles called the bull region, or\nbulls-eye. The outer bull is worth 25 points and the inner bull is a double,\nworth 50 points.\n\nThere are many variations of rules but in the most popular game the players will\nbegin with a score 301 or 501 and the first player to reduce their running total\nto zero is a winner. However, it is normal to play a \"doubles out\" system, which\nmeans that the player must land a double (including the double bulls-eye at the\ncentre of the board) on their final dart to win; any other dart that would reduce\ntheir running total to one or lower means the score for that set of three darts\nis \"bust\".\n\nWhen a player is able to finish on their current score it is called a \"checkout\"\nand the highest checkout is 170: T20 T20 D25 (two treble 20s and double bull).\n\nThere are exactly eleven distinct ways to checkout on a score of 6:\n\nD3\nD1  D2\nS2  D2\nD2  D1\nS4  D1\nS1  S1  D2\nS1  T1  D1\nS1  S3  D1\nD1  D1  D1\nD1  S2  D1\nS2  S2  D1\n\nNote that D1 D2 is considered different to D2 D1 as they finish on different\ndoubles. However, the combination S1 T1 D1 is considered the same as T1 S1 D1.\n\nIn addition we shall not include misses in considering combinations; for example,\nD3 is the same as 0 D3 and 0 0 D3.\n\nIncredibly there are 42336 distinct ways of checking out in total.\n\nHow many distinct ways can a player checkout with a score less than 100?\n\nSolution:\n    We first construct a list of the possible dart values, separated by type.\n    We then iterate through the doubles, followed by the possible 2 following throws.\n    If the total of these three darts is less than the given limit, we increment\n    the counter.\n\"\"\"\n\nfrom itertools import combinations_with_replacement\n\n\ndef solution(limit: int = 100) -> int:\n    \"\"\"\n    Count the number of distinct ways a player can checkout with a score\n    less than limit.\n    >>> solution(171)\n    42336\n    >>> solution(50)\n    12577\n    \"\"\"\n    singles: list[int] = [*list(range(1, 21)), 25]\n    doubles: list[int] = [2 * x for x in range(1, 21)] + [50]\n    triples: list[int] = [3 * x for x in range(1, 21)]\n    all_values: list[int] = singles + doubles + triples + [0]\n\n    num_checkouts: int = 0\n    double: int\n    throw1: int\n    throw2: int\n    checkout_total: int\n\n    for double in doubles:\n        for throw1, throw2 in combinations_with_replacement(all_values, 2):\n            checkout_total = double + throw1 + throw2\n            if checkout_total < limit:\n                num_checkouts += 1\n\n    return num_checkouts\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_109/__init__.py": "", "project_euler/problem_085/sol1.py": "\"\"\"\nProject Euler Problem 85: https://projecteuler.net/problem=85\n\nBy counting carefully it can be seen that a rectangular grid measuring 3 by 2\ncontains eighteen rectangles.\n\ufffc\nAlthough there exists no rectangular grid that contains exactly two million\nrectangles, find the area of the grid with the nearest solution.\n\nSolution:\n\n    For a grid with side-lengths a and b, the number of rectangles contained in the grid\n    is [a*(a+1)/2] * [b*(b+1)/2)], which happens to be the product of the a-th and b-th\n    triangle numbers. So to find the solution grid (a,b), we need to find the two\n    triangle numbers whose product is closest to two million.\n\n    Denote these two triangle numbers Ta and Tb. We want their product Ta*Tb to be\n    as close as possible to 2m. Assuming that the best solution is fairly close to 2m,\n    We can assume that both Ta and Tb are roughly bounded by 2m. Since Ta = a(a+1)/2,\n    we can assume that a (and similarly b) are roughly bounded by sqrt(2 * 2m) = 2000.\n    Since this is a rough bound, to be on the safe side we add 10%. Therefore we start\n    by generating all the triangle numbers Ta for 1 <= a <= 2200. This can be done\n    iteratively since the ith triangle number is the sum of 1,2, ... ,i, and so\n    T(i) = T(i-1) + i.\n\n    We then search this list of triangle numbers for the two that give a product\n    closest to our target of two million. Rather than testing every combination of 2\n    elements of the list, which would find the result in quadratic time, we can find\n    the best pair in linear time.\n\n    We iterate through the list of triangle numbers using enumerate() so we have a\n    and Ta. Since we want Ta * Tb to be as close as possible to 2m, we know that Tb\n    needs to be roughly 2m / Ta. Using the formula Tb = b*(b+1)/2 as well as the\n    quadratic formula, we can solve for b:\n    b is roughly (-1 + sqrt(1 + 8 * 2m / Ta)) / 2.\n\n    Since the closest integers to this estimate will give product closest to 2m,\n    we only need to consider the integers above and below. It's then a simple matter\n    to get the triangle numbers corresponding to those integers, calculate the product\n    Ta * Tb, compare that product to our target 2m, and keep track of the (a,b) pair\n    that comes the closest.\n\n\nReference: https://en.wikipedia.org/wiki/Triangular_number\n           https://en.wikipedia.org/wiki/Quadratic_formula\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom math import ceil, floor, sqrt\n\n\ndef solution(target: int = 2000000) -> int:\n    \"\"\"\n    Find the area of the grid which contains as close to two million rectangles\n    as possible.\n    >>> solution(20)\n    6\n    >>> solution(2000)\n    72\n    >>> solution(2000000000)\n    86595\n    \"\"\"\n    triangle_numbers: list[int] = [0]\n    idx: int\n\n    for idx in range(1, ceil(sqrt(target * 2) * 1.1)):\n        triangle_numbers.append(triangle_numbers[-1] + idx)\n\n    # we want this to be as close as possible to target\n    best_product: int = 0\n    # the area corresponding to the grid that gives the product closest to target\n    area: int = 0\n    # an estimate of b, using the quadratic formula\n    b_estimate: float\n    # the largest integer less than b_estimate\n    b_floor: int\n    # the largest integer less than b_estimate\n    b_ceil: int\n    # the triangle number corresponding to b_floor\n    triangle_b_first_guess: int\n    # the triangle number corresponding to b_ceil\n    triangle_b_second_guess: int\n\n    for idx_a, triangle_a in enumerate(triangle_numbers[1:], 1):\n        b_estimate = (-1 + sqrt(1 + 8 * target / triangle_a)) / 2\n        b_floor = floor(b_estimate)\n        b_ceil = ceil(b_estimate)\n        triangle_b_first_guess = triangle_numbers[b_floor]\n        triangle_b_second_guess = triangle_numbers[b_ceil]\n\n        if abs(target - triangle_b_first_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_first_guess * triangle_a\n            area = idx_a * b_floor\n\n        if abs(target - triangle_b_second_guess * triangle_a) < abs(\n            target - best_product\n        ):\n            best_product = triangle_b_second_guess * triangle_a\n            area = idx_a * b_ceil\n\n    return area\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_085/__init__.py": "", "project_euler/problem_079/sol1.py": "\"\"\"\nProject Euler Problem 79: https://projecteuler.net/problem=79\n\nPasscode derivation\n\nA common security method used for online banking is to ask the user for three\nrandom characters from a passcode. For example, if the passcode was 531278,\nthey may ask for the 2nd, 3rd, and 5th characters; the expected reply would\nbe: 317.\n\nThe text file, keylog.txt, contains fifty successful login attempts.\n\nGiven that the three characters are always asked for in order, analyse the file\nso as to determine the shortest possible secret passcode of unknown length.\n\"\"\"\n\nimport itertools\nfrom pathlib import Path\n\n\ndef find_secret_passcode(logins: list[str]) -> int:\n    \"\"\"\n    Returns the shortest possible secret passcode of unknown length.\n\n    >>> find_secret_passcode([\"135\", \"259\", \"235\", \"189\", \"690\", \"168\", \"120\",\n    ...     \"136\", \"289\", \"589\", \"160\", \"165\", \"580\", \"369\", \"250\", \"280\"])\n    12365890\n\n    >>> find_secret_passcode([\"426\", \"281\", \"061\", \"819\" \"268\", \"406\", \"420\",\n    ...     \"428\", \"209\", \"689\", \"019\", \"421\", \"469\", \"261\", \"681\", \"201\"])\n    4206819\n    \"\"\"\n\n    # Split each login by character e.g. '319' -> ('3', '1', '9')\n    split_logins = [tuple(login) for login in logins]\n\n    unique_chars = {char for login in split_logins for char in login}\n\n    for permutation in itertools.permutations(unique_chars):\n        satisfied = True\n        for login in logins:\n            if not (\n                permutation.index(login[0])\n                < permutation.index(login[1])\n                < permutation.index(login[2])\n            ):\n                satisfied = False\n                break\n\n        if satisfied:\n            return int(\"\".join(permutation))\n\n    raise Exception(\"Unable to find the secret passcode\")\n\n\ndef solution(input_file: str = \"keylog.txt\") -> int:\n    \"\"\"\n    Returns the shortest possible secret passcode of unknown length\n    for successful login attempts given by `input_file` text file.\n\n    >>> solution(\"keylog_test.txt\")\n    6312980\n    \"\"\"\n    logins = Path(__file__).parent.joinpath(input_file).read_text().splitlines()\n\n    return find_secret_passcode(logins)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_079/__init__.py": "", "project_euler/problem_101/sol1.py": "\"\"\"\nIf we are presented with the first k terms of a sequence it is impossible to say with\ncertainty the value of the next term, as there are infinitely many polynomial functions\nthat can model the sequence.\n\nAs an example, let us consider the sequence of cube\nnumbers. This is defined by the generating function,\nu(n) = n3: 1, 8, 27, 64, 125, 216, ...\n\nSuppose we were only given the first two terms of this sequence. Working on the\nprinciple that \"simple is best\" we should assume a linear relationship and predict the\nnext term to be 15 (common difference 7). Even if we were presented with the first three\nterms, by the same principle of simplicity, a quadratic relationship should be\nassumed.\n\nWe shall define OP(k, n) to be the nth term of the optimum polynomial\ngenerating function for the first k terms of a sequence. It should be clear that\nOP(k, n) will accurately generate the terms of the sequence for n \u2264 k, and potentially\nthe first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a\nbad OP (BOP).\n\nAs a basis, if we were only given the first term of sequence, it would be most\nsensible to assume constancy; that is, for n \u2265 2, OP(1, n) = u(1).\n\nHence we obtain the\nfollowing OPs for the cubic sequence:\n\nOP(1, n) = 1            1, 1, 1, 1, ...\nOP(2, n) = 7n-6         1, 8, 15, ...\nOP(3, n) = 6n^2-11n+6   1, 8, 27, 58, ...\nOP(4, n) = n^3          1, 8, 27, 64, 125, ...\n\nClearly no BOPs exist for k \u2265 4.\n\nBy considering the sum of FITs generated by the BOPs (indicated in red above), we\nobtain 1 + 15 + 58 = 74.\n\nConsider the following tenth degree polynomial generating function:\n\n1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10\n\nFind the sum of FITs for the BOPs.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\n\nMatrix = list[list[float | int]]\n\n\ndef solve(matrix: Matrix, vector: Matrix) -> Matrix:\n    \"\"\"\n    Solve the linear system of equations Ax = b (A = \"matrix\", b = \"vector\")\n    for x using Gaussian elimination and back substitution. We assume that A\n    is an invertible square matrix and that b is a column vector of the\n    same height.\n    >>> solve([[1, 0], [0, 1]], [[1],[2]])\n    [[1.0], [2.0]]\n    >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]])\n    [[2.0], [3.0], [-1.0]]\n    \"\"\"\n    size: int = len(matrix)\n    augmented: Matrix = [[0 for _ in range(size + 1)] for _ in range(size)]\n    row: int\n    row2: int\n    col: int\n    col2: int\n    pivot_row: int\n    ratio: float\n\n    for row in range(size):\n        for col in range(size):\n            augmented[row][col] = matrix[row][col]\n\n        augmented[row][size] = vector[row][0]\n\n    row = 0\n    col = 0\n    while row < size and col < size:\n        # pivoting\n        pivot_row = max((abs(augmented[row2][col]), row2) for row2 in range(col, size))[\n            1\n        ]\n        if augmented[pivot_row][col] == 0:\n            col += 1\n            continue\n        else:\n            augmented[row], augmented[pivot_row] = augmented[pivot_row], augmented[row]\n\n        for row2 in range(row + 1, size):\n            ratio = augmented[row2][col] / augmented[row][col]\n            augmented[row2][col] = 0\n            for col2 in range(col + 1, size + 1):\n                augmented[row2][col2] -= augmented[row][col2] * ratio\n\n        row += 1\n        col += 1\n\n    # back substitution\n    for col in range(1, size):\n        for row in range(col):\n            ratio = augmented[row][col] / augmented[col][col]\n            for col2 in range(col, size + 1):\n                augmented[row][col2] -= augmented[col][col2] * ratio\n\n    # round to get rid of numbers like 2.000000000000004\n    return [\n        [round(augmented[row][size] / augmented[row][row], 10)] for row in range(size)\n    ]\n\n\ndef interpolate(y_list: list[int]) -> Callable[[int], int]:\n    \"\"\"\n    Given a list of data points (1,y0),(2,y1), ..., return a function that\n    interpolates the data points. We find the coefficients of the interpolating\n    polynomial by solving a system of linear equations corresponding to\n    x = 1, 2, 3...\n\n    >>> interpolate([1])(3)\n    1\n    >>> interpolate([1, 8])(3)\n    15\n    >>> interpolate([1, 8, 27])(4)\n    58\n    >>> interpolate([1, 8, 27, 64])(6)\n    216\n    \"\"\"\n\n    size: int = len(y_list)\n    matrix: Matrix = [[0 for _ in range(size)] for _ in range(size)]\n    vector: Matrix = [[0] for _ in range(size)]\n    coeffs: Matrix\n    x_val: int\n    y_val: int\n    col: int\n\n    for x_val, y_val in enumerate(y_list):\n        for col in range(size):\n            matrix[x_val][col] = (x_val + 1) ** (size - col - 1)\n        vector[x_val][0] = y_val\n\n    coeffs = solve(matrix, vector)\n\n    def interpolated_func(var: int) -> int:\n        \"\"\"\n        >>> interpolate([1])(3)\n        1\n        >>> interpolate([1, 8])(3)\n        15\n        >>> interpolate([1, 8, 27])(4)\n        58\n        >>> interpolate([1, 8, 27, 64])(6)\n        216\n        \"\"\"\n        return sum(\n            round(coeffs[x_val][0]) * (var ** (size - x_val - 1))\n            for x_val in range(size)\n        )\n\n    return interpolated_func\n\n\ndef question_function(variable: int) -> int:\n    \"\"\"\n    The generating function u as specified in the question.\n    >>> question_function(0)\n    1\n    >>> question_function(1)\n    1\n    >>> question_function(5)\n    8138021\n    >>> question_function(10)\n    9090909091\n    \"\"\"\n    return (\n        1\n        - variable\n        + variable**2\n        - variable**3\n        + variable**4\n        - variable**5\n        + variable**6\n        - variable**7\n        + variable**8\n        - variable**9\n        + variable**10\n    )\n\n\ndef solution(func: Callable[[int], int] = question_function, order: int = 10) -> int:\n    \"\"\"\n    Find the sum of the FITs of the BOPS. For each interpolating polynomial of order\n    1, 2, ... , 10, find the first x such that the value of the polynomial at x does\n    not equal u(x).\n    >>> solution(lambda n: n ** 3, 3)\n    74\n    \"\"\"\n    data_points: list[int] = [func(x_val) for x_val in range(1, order + 1)]\n\n    polynomials: list[Callable[[int], int]] = [\n        interpolate(data_points[:max_coeff]) for max_coeff in range(1, order + 1)\n    ]\n\n    ret: int = 0\n    poly: Callable[[int], int]\n    x_val: int\n\n    for poly in polynomials:\n        x_val = 1\n        while func(x_val) == poly(x_val):\n            x_val += 1\n\n        ret += poly(x_val)\n\n    return ret\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_101/__init__.py": "", "project_euler/problem_301/sol1.py": "\"\"\"\nProject Euler Problem 301: https://projecteuler.net/problem=301\n\nProblem Statement:\nNim is a game played with heaps of stones, where two players take\nit in turn to remove any number of stones from any heap until no stones remain.\n\nWe'll consider the three-heap normal-play version of\nNim, which works as follows:\n- At the start of the game there are three heaps of stones.\n- On each player's turn, the player may remove any positive\n  number of stones from any single heap.\n- The first player unable to move (because no stones remain) loses.\n\nIf (n1, n2, n3) indicates a Nim position consisting of heaps of size\nn1, n2, and n3, then there is a simple function, which you may look up\nor attempt to deduce for yourself, X(n1, n2, n3) that returns:\n- zero if, with perfect strategy, the player about to\n  move will eventually lose; or\n- non-zero if, with perfect strategy, the player about\n  to move will eventually win.\n\nFor example X(1,2,3) = 0 because, no matter what the current player does,\nthe opponent can respond with a move that leaves two heaps of equal size,\nat which point every move by the current player can be mirrored by the\nopponent until no stones remain; so the current player loses. To illustrate:\n- current player moves to (1,2,1)\n- opponent moves to (1,0,1)\n- current player moves to (0,0,1)\n- opponent moves to (0,0,0), and so wins.\n\nFor how many positive integers n <= 2^30 does X(n,2n,3n) = 0?\n\"\"\"\n\n\ndef solution(exponent: int = 30) -> int:\n    \"\"\"\n    For any given exponent x >= 0, 1 <= n <= 2^x.\n    This function returns how many Nim games are lost given that\n    each Nim game has three heaps of the form (n, 2*n, 3*n).\n    >>> solution(0)\n    1\n    >>> solution(2)\n    3\n    >>> solution(10)\n    144\n    \"\"\"\n    # To find how many total games were lost for a given exponent x,\n    # we need to find the Fibonacci number F(x+2).\n    fibonacci_index = exponent + 2\n    phi = (1 + 5**0.5) / 2\n    fibonacci = (phi**fibonacci_index - (phi - 1) ** fibonacci_index) / 5**0.5\n\n    return int(fibonacci)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_301/__init__.py": "", "project_euler/problem_049/sol1.py": "\"\"\"\nPrime permutations\n\nProblem 49\n\nThe arithmetic sequence, 1487, 4817, 8147, in which each of\nthe terms increases by 3330, is unusual in two ways:\n(i) each of the three terms are prime,\n(ii) each of the 4-digit numbers are permutations of one another.\n\nThere are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes,\nexhibiting this property, but there is one other 4-digit increasing sequence.\n\nWhat 12-digit number do you form by concatenating the three terms in this sequence?\n\nSolution:\n\nFirst, we need to generate all 4 digits prime numbers. Then greedy\nall of them and use permutation to form new numbers. Use binary search\nto check if the permutated numbers is in our prime list and include\nthem in a candidate list.\n\nAfter that, bruteforce all passed candidates sequences using\n3 nested loops since we know the answer will be 12 digits.\nThe bruteforce of this solution will be about 1 sec.\n\"\"\"\n\nimport math\nfrom itertools import permutations\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef search(target: int, prime_list: list) -> bool:\n    \"\"\"\n    function to search a number in a list using Binary Search.\n    >>> search(3, [1, 2, 3])\n    True\n    >>> search(4, [1, 2, 3])\n    False\n    >>> search(101, list(range(-100, 100)))\n    False\n    \"\"\"\n\n    left, right = 0, len(prime_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if prime_list[middle] == target:\n            return True\n        elif prime_list[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return False\n\n\ndef solution():\n    \"\"\"\n    Return the solution of the problem.\n    >>> solution()\n    296962999629\n    \"\"\"\n    prime_list = [n for n in range(1001, 10000, 2) if is_prime(n)]\n    candidates = []\n\n    for number in prime_list:\n        tmp_numbers = []\n\n        for prime_member in permutations(list(str(number))):\n            prime = int(\"\".join(prime_member))\n\n            if prime % 2 == 0:\n                continue\n\n            if search(prime, prime_list):\n                tmp_numbers.append(prime)\n\n        tmp_numbers.sort()\n        if len(tmp_numbers) >= 3:\n            candidates.append(tmp_numbers)\n\n    passed = []\n    for candidate in candidates:\n        length = len(candidate)\n        found = False\n\n        for i in range(length):\n            for j in range(i + 1, length):\n                for k in range(j + 1, length):\n                    if (\n                        abs(candidate[i] - candidate[j])\n                        == abs(candidate[j] - candidate[k])\n                        and len({candidate[i], candidate[j], candidate[k]}) == 3\n                    ):\n                        passed.append(\n                            sorted([candidate[i], candidate[j], candidate[k]])\n                        )\n                        found = True\n\n                    if found:\n                        break\n                if found:\n                    break\n            if found:\n                break\n\n    answer = set()\n    for seq in passed:\n        answer.add(\"\".join([str(i) for i in seq]))\n\n    return max(int(x) for x in answer)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_049/__init__.py": "", "project_euler/problem_112/sol1.py": "\"\"\"\nProblem 112: https://projecteuler.net/problem=112\n\nWorking from left-to-right if no digit is exceeded by the digit to its left it is\ncalled an increasing number; for example, 134468.\nSimilarly if no digit is exceeded by the digit to its right it is called a decreasing\nnumber; for example, 66420.\nWe shall call a positive integer that is neither increasing nor decreasing a \"bouncy\"\nnumber, for example, 155349.\nClearly there cannot be any bouncy numbers below one-hundred, but just over half of\nthe numbers below one-thousand (525) are bouncy. In fact, the least number for which\nthe proportion of bouncy numbers first reaches 50% is 538.\nSurprisingly, bouncy numbers become more and more common and by the time we reach\n21780 the proportion of bouncy numbers is equal to 90%.\n\nFind the least number for which the proportion of bouncy numbers is exactly 99%.\n\"\"\"\n\n\ndef check_bouncy(n: int) -> bool:\n    \"\"\"\n    Returns True if number is bouncy, False otherwise\n    >>> check_bouncy(6789)\n    False\n    >>> check_bouncy(-12345)\n    False\n    >>> check_bouncy(0)\n    False\n    >>> check_bouncy(6.74)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(132475)\n    True\n    >>> check_bouncy(34)\n    False\n    >>> check_bouncy(341)\n    True\n    >>> check_bouncy(47)\n    False\n    >>> check_bouncy(-12.54)\n    Traceback (most recent call last):\n        ...\n    ValueError: check_bouncy() accepts only integer arguments\n    >>> check_bouncy(-6548)\n    True\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"check_bouncy() accepts only integer arguments\")\n    str_n = str(n)\n    sorted_str_n = \"\".join(sorted(str_n))\n    return str_n not in {sorted_str_n, sorted_str_n[::-1]}\n\n\ndef solution(percent: float = 99) -> int:\n    \"\"\"\n    Returns the least number for which the proportion of bouncy numbers is\n    exactly 'percent'\n    >>> solution(50)\n    538\n    >>> solution(90)\n    21780\n    >>> solution(80)\n    4770\n    >>> solution(105)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    >>> solution(100.011)\n    Traceback (most recent call last):\n        ...\n    ValueError: solution() only accepts values from 0 to 100\n    \"\"\"\n    if not 0 < percent < 100:\n        raise ValueError(\"solution() only accepts values from 0 to 100\")\n    bouncy_num = 0\n    num = 1\n\n    while True:\n        if check_bouncy(num):\n            bouncy_num += 1\n        if (bouncy_num / num) * 100 >= percent:\n            return num\n        num += 1\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(f\"{solution(99)}\")\n", "project_euler/problem_112/__init__.py": "", "project_euler/problem_234/sol1.py": "\"\"\"\nhttps://projecteuler.net/problem=234\n\nFor an integer n \u2265 4, we define the lower prime square root of n, denoted by\nlps(n), as the largest prime \u2264 \u221an and the upper prime square root of n, ups(n),\nas the smallest prime \u2265 \u221an.\n\nSo, for example, lps(4) = 2 = ups(4), lps(1000) = 31, ups(1000) = 37. Let us\ncall an integer n \u2265 4 semidivisible, if one of lps(n) and ups(n) divides n,\nbut not both.\n\nThe sum of the semidivisible numbers not exceeding 15 is 30, the numbers are 8,\n10 and 12. 15 is not semidivisible because it is a multiple of both lps(15) = 3\nand ups(15) = 5. As a further example, the sum of the 92 semidivisible numbers\nup to 1000 is 34825.\n\nWhat is the sum of all semidivisible numbers not exceeding 999966663333 ?\n\"\"\"\n\nimport math\n\n\ndef prime_sieve(n: int) -> list:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    >>> prime_sieve(3)\n    [2]\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n**0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes\n\n\ndef solution(limit: int = 999_966_663_333) -> int:\n    \"\"\"\n    Computes the solution to the problem up to the specified limit\n    >>> solution(1000)\n    34825\n\n    >>> solution(10_000)\n    1134942\n\n    >>> solution(100_000)\n    36393008\n    \"\"\"\n    primes_upper_bound = math.floor(math.sqrt(limit)) + 100\n    primes = prime_sieve(primes_upper_bound)\n\n    matches_sum = 0\n    prime_index = 0\n    last_prime = primes[prime_index]\n\n    while (last_prime**2) <= limit:\n        next_prime = primes[prime_index + 1]\n\n        lower_bound = last_prime**2\n        upper_bound = next_prime**2\n\n        # Get numbers divisible by lps(current)\n        current = lower_bound + last_prime\n        while upper_bound > current <= limit:\n            matches_sum += current\n            current += last_prime\n\n        # Reset the upper_bound\n        while (upper_bound - next_prime) > limit:\n            upper_bound -= next_prime\n\n        # Add the numbers divisible by ups(current)\n        current = upper_bound - next_prime\n        while current > lower_bound:\n            matches_sum += current\n            current -= next_prime\n\n        # Remove the numbers divisible by both ups and lps\n        current = 0\n        while upper_bound > current <= limit:\n            if current <= lower_bound:\n                # Increment the current number\n                current += last_prime * next_prime\n                continue\n\n            if current > limit:\n                break\n\n            # Remove twice since it was added by both ups and lps\n            matches_sum -= current * 2\n\n            # Increment the current number\n            current += last_prime * next_prime\n\n        # Setup for next pair\n        last_prime = next_prime\n        prime_index += 1\n\n    return matches_sum\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_234/__init__.py": "", "project_euler/problem_008/sol2.py": "\"\"\"\nProject Euler Problem 8: https://projecteuler.net/problem=8\n\nLargest product in a series\n\nThe four adjacent digits in the 1000-digit number that have the greatest\nproduct are 9 x 9 x 8 x 9 = 5832.\n\n    73167176531330624919225119674426574742355349194934\n    96983520312774506326239578318016984801869478851843\n    85861560789112949495459501737958331952853208805511\n    12540698747158523863050715693290963295227443043557\n    66896648950445244523161731856403098711121722383113\n    62229893423380308135336276614282806444486645238749\n    30358907296290491560440772390713810515859307960866\n    70172427121883998797908792274921901699720888093776\n    65727333001053367881220235421809751254540594752243\n    52584907711670556013604839586446706324415722155397\n    53697817977846174064955149290862569321978468622482\n    83972241375657056057490261407972968652414535100474\n    82166370484403199890008895243450658541227588666881\n    16427171479924442928230863465674813919123162824586\n    17866458359124566529476545682848912883142607690042\n    24219022671055626321111109370544217506941658960408\n    07198403850962455444362981230987879927244284909188\n    84580156166097919133875499200524063689912560717606\n    05886116467109405077541002256983155200055935729725\n    71636269561882670428252483600823257530420752963450\n\nFind the thirteen adjacent digits in the 1000-digit number that have the\ngreatest product. What is the value of this product?\n\"\"\"\n\nfrom functools import reduce\n\nN = (\n    \"73167176531330624919225119674426574742355349194934\"\n    \"96983520312774506326239578318016984801869478851843\"\n    \"85861560789112949495459501737958331952853208805511\"\n    \"12540698747158523863050715693290963295227443043557\"\n    \"66896648950445244523161731856403098711121722383113\"\n    \"62229893423380308135336276614282806444486645238749\"\n    \"30358907296290491560440772390713810515859307960866\"\n    \"70172427121883998797908792274921901699720888093776\"\n    \"65727333001053367881220235421809751254540594752243\"\n    \"52584907711670556013604839586446706324415722155397\"\n    \"53697817977846174064955149290862569321978468622482\"\n    \"83972241375657056057490261407972968652414535100474\"\n    \"82166370484403199890008895243450658541227588666881\"\n    \"16427171479924442928230863465674813919123162824586\"\n    \"17866458359124566529476545682848912883142607690042\"\n    \"24219022671055626321111109370544217506941658960408\"\n    \"07198403850962455444362981230987879927244284909188\"\n    \"84580156166097919133875499200524063689912560717606\"\n    \"05886116467109405077541002256983155200055935729725\"\n    \"71636269561882670428252483600823257530420752963450\"\n)\n\n\ndef solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n\n    >>> solution(\"13978431290823798458352374\")\n    609638400\n    >>> solution(\"13978431295823798458352374\")\n    2612736000\n    >>> solution(\"1397843129582379841238352374\")\n    209018880\n    \"\"\"\n\n    return max(\n        # mypy cannot properly interpret reduce\n        int(reduce(lambda x, y: str(int(x) * int(y)), n[i : i + 13]))\n        for i in range(len(n) - 12)\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_008/sol3.py": "\"\"\"\nProject Euler Problem 8: https://projecteuler.net/problem=8\n\nLargest product in a series\n\nThe four adjacent digits in the 1000-digit number that have the greatest\nproduct are 9 x 9 x 8 x 9 = 5832.\n\n    73167176531330624919225119674426574742355349194934\n    96983520312774506326239578318016984801869478851843\n    85861560789112949495459501737958331952853208805511\n    12540698747158523863050715693290963295227443043557\n    66896648950445244523161731856403098711121722383113\n    62229893423380308135336276614282806444486645238749\n    30358907296290491560440772390713810515859307960866\n    70172427121883998797908792274921901699720888093776\n    65727333001053367881220235421809751254540594752243\n    52584907711670556013604839586446706324415722155397\n    53697817977846174064955149290862569321978468622482\n    83972241375657056057490261407972968652414535100474\n    82166370484403199890008895243450658541227588666881\n    16427171479924442928230863465674813919123162824586\n    17866458359124566529476545682848912883142607690042\n    24219022671055626321111109370544217506941658960408\n    07198403850962455444362981230987879927244284909188\n    84580156166097919133875499200524063689912560717606\n    05886116467109405077541002256983155200055935729725\n    71636269561882670428252483600823257530420752963450\n\nFind the thirteen adjacent digits in the 1000-digit number that have the\ngreatest product. What is the value of this product?\n\"\"\"\n\nimport sys\n\nN = (\n    \"73167176531330624919225119674426574742355349194934\"\n    \"96983520312774506326239578318016984801869478851843\"\n    \"85861560789112949495459501737958331952853208805511\"\n    \"12540698747158523863050715693290963295227443043557\"\n    \"66896648950445244523161731856403098711121722383113\"\n    \"62229893423380308135336276614282806444486645238749\"\n    \"30358907296290491560440772390713810515859307960866\"\n    \"70172427121883998797908792274921901699720888093776\"\n    \"65727333001053367881220235421809751254540594752243\"\n    \"52584907711670556013604839586446706324415722155397\"\n    \"53697817977846174064955149290862569321978468622482\"\n    \"83972241375657056057490261407972968652414535100474\"\n    \"82166370484403199890008895243450658541227588666881\"\n    \"16427171479924442928230863465674813919123162824586\"\n    \"17866458359124566529476545682848912883142607690042\"\n    \"24219022671055626321111109370544217506941658960408\"\n    \"07198403850962455444362981230987879927244284909188\"\n    \"84580156166097919133875499200524063689912560717606\"\n    \"05886116467109405077541002256983155200055935729725\"\n    \"71636269561882670428252483600823257530420752963450\"\n)\n\n\ndef str_eval(s: str) -> int:\n    \"\"\"\n    Returns product of digits in given string n\n\n    >>> str_eval(\"987654321\")\n    362880\n    >>> str_eval(\"22222222\")\n    256\n    \"\"\"\n\n    product = 1\n    for digit in s:\n        product *= int(digit)\n    return product\n\n\ndef solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n    \"\"\"\n\n    largest_product = -sys.maxsize - 1\n    substr = n[:13]\n    cur_index = 13\n    while cur_index < len(n) - 13:\n        if int(n[cur_index]) >= int(substr[0]):\n            substr = substr[1:] + n[cur_index]\n            cur_index += 1\n        else:\n            largest_product = max(largest_product, str_eval(substr))\n            substr = n[cur_index : cur_index + 13]\n            cur_index += 13\n    return largest_product\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_008/sol1.py": "\"\"\"\nProject Euler Problem 8: https://projecteuler.net/problem=8\n\nLargest product in a series\n\nThe four adjacent digits in the 1000-digit number that have the greatest\nproduct are 9 x 9 x 8 x 9 = 5832.\n\n    73167176531330624919225119674426574742355349194934\n    96983520312774506326239578318016984801869478851843\n    85861560789112949495459501737958331952853208805511\n    12540698747158523863050715693290963295227443043557\n    66896648950445244523161731856403098711121722383113\n    62229893423380308135336276614282806444486645238749\n    30358907296290491560440772390713810515859307960866\n    70172427121883998797908792274921901699720888093776\n    65727333001053367881220235421809751254540594752243\n    52584907711670556013604839586446706324415722155397\n    53697817977846174064955149290862569321978468622482\n    83972241375657056057490261407972968652414535100474\n    82166370484403199890008895243450658541227588666881\n    16427171479924442928230863465674813919123162824586\n    17866458359124566529476545682848912883142607690042\n    24219022671055626321111109370544217506941658960408\n    07198403850962455444362981230987879927244284909188\n    84580156166097919133875499200524063689912560717606\n    05886116467109405077541002256983155200055935729725\n    71636269561882670428252483600823257530420752963450\n\nFind the thirteen adjacent digits in the 1000-digit number that have the\ngreatest product. What is the value of this product?\n\"\"\"\n\nimport sys\n\nN = (\n    \"73167176531330624919225119674426574742355349194934\"\n    \"96983520312774506326239578318016984801869478851843\"\n    \"85861560789112949495459501737958331952853208805511\"\n    \"12540698747158523863050715693290963295227443043557\"\n    \"66896648950445244523161731856403098711121722383113\"\n    \"62229893423380308135336276614282806444486645238749\"\n    \"30358907296290491560440772390713810515859307960866\"\n    \"70172427121883998797908792274921901699720888093776\"\n    \"65727333001053367881220235421809751254540594752243\"\n    \"52584907711670556013604839586446706324415722155397\"\n    \"53697817977846174064955149290862569321978468622482\"\n    \"83972241375657056057490261407972968652414535100474\"\n    \"82166370484403199890008895243450658541227588666881\"\n    \"16427171479924442928230863465674813919123162824586\"\n    \"17866458359124566529476545682848912883142607690042\"\n    \"24219022671055626321111109370544217506941658960408\"\n    \"07198403850962455444362981230987879927244284909188\"\n    \"84580156166097919133875499200524063689912560717606\"\n    \"05886116467109405077541002256983155200055935729725\"\n    \"71636269561882670428252483600823257530420752963450\"\n)\n\n\ndef solution(n: str = N) -> int:\n    \"\"\"\n    Find the thirteen adjacent digits in the 1000-digit number n that have\n    the greatest product and returns it.\n\n    >>> solution(\"13978431290823798458352374\")\n    609638400\n    >>> solution(\"13978431295823798458352374\")\n    2612736000\n    >>> solution(\"1397843129582379841238352374\")\n    209018880\n    \"\"\"\n\n    largest_product = -sys.maxsize - 1\n    for i in range(len(n) - 12):\n        product = 1\n        for j in range(13):\n            product *= int(n[i + j])\n        if product > largest_product:\n            largest_product = product\n    return largest_product\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_008/__init__.py": "", "project_euler/problem_099/sol1.py": "\"\"\"\nProblem:\n\nComparing two numbers written in index form like 2'11 and 3'7 is not difficult, as any\ncalculator would confirm that 2^11 = 2048 < 3^7 = 2187.\n\nHowever, confirming that 632382^518061 > 519432^525806 would be much more difficult, as\nboth numbers contain over three million digits.\n\nUsing base_exp.txt, a 22K text file containing one thousand lines with a base/exponent\npair on each line, determine which line number has the greatest numerical value.\n\nNOTE: The first two lines in the file represent the numbers in the example given above.\n\"\"\"\n\nimport os\nfrom math import log10\n\n\ndef solution(data_file: str = \"base_exp.txt\") -> int:\n    \"\"\"\n    >>> solution()\n    709\n    \"\"\"\n    largest: float = 0\n    result = 0\n    for i, line in enumerate(open(os.path.join(os.path.dirname(__file__), data_file))):\n        a, x = list(map(int, line.split(\",\")))\n        if x * log10(a) > largest:\n            largest = x * log10(a)\n            result = i + 1\n    return result\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_099/__init__.py": "", "project_euler/problem_102/sol1.py": "\"\"\"\nThree distinct points are plotted at random on a Cartesian plane,\nfor which -1000 \u2264 x, y \u2264 1000, such that a triangle is formed.\n\nConsider the following two triangles:\n\nA(-340,495), B(-153,-910), C(835,-947)\n\nX(-175,41), Y(-421,-714), Z(574,-645)\n\nIt can be verified that triangle ABC contains the origin, whereas\ntriangle XYZ does not.\n\nUsing triangles.txt (right click and 'Save Link/Target As...'), a 27K text\nfile containing the coordinates of one thousand \"random\" triangles, find\nthe number of triangles for which the interior contains the origin.\n\nNOTE: The first two examples in the file represent the triangles in the\nexample given above.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\n\ndef vector_product(point1: tuple[int, int], point2: tuple[int, int]) -> int:\n    \"\"\"\n    Return the 2-d vector product of two vectors.\n    >>> vector_product((1, 2), (-5, 0))\n    10\n    >>> vector_product((3, 1), (6, 10))\n    24\n    \"\"\"\n    return point1[0] * point2[1] - point1[1] * point2[0]\n\n\ndef contains_origin(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> bool:\n    \"\"\"\n    Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3)\n    contains the origin.\n    >>> contains_origin(-340, 495, -153, -910, 835, -947)\n    True\n    >>> contains_origin(-175, 41, -421, -714, 574, -645)\n    False\n    \"\"\"\n    point_a: tuple[int, int] = (x1, y1)\n    point_a_to_b: tuple[int, int] = (x2 - x1, y2 - y1)\n    point_a_to_c: tuple[int, int] = (x3 - x1, y3 - y1)\n    a: float = -vector_product(point_a, point_a_to_b) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n    b: float = +vector_product(point_a, point_a_to_c) / vector_product(\n        point_a_to_c, point_a_to_b\n    )\n\n    return a > 0 and b > 0 and a + b < 1\n\n\ndef solution(filename: str = \"p102_triangles.txt\") -> int:\n    \"\"\"\n    Find the number of triangles whose interior contains the origin.\n    >>> solution(\"test_triangles.txt\")\n    1\n    \"\"\"\n    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=\"utf-8\")\n\n    triangles: list[list[int]] = []\n    for line in data.strip().split(\"\\n\"):\n        triangles.append([int(number) for number in line.split(\",\")])\n\n    ret: int = 0\n    triangle: list[int]\n\n    for triangle in triangles:\n        ret += contains_origin(*triangle)\n\n    return ret\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_102/__init__.py": "", "project_euler/problem_205/sol1.py": "\"\"\"\nProject Euler Problem 205: https://projecteuler.net/problem=205\n\nPeter has nine four-sided (pyramidal) dice, each with faces numbered 1, 2, 3, 4.\nColin has six six-sided (cubic) dice, each with faces numbered 1, 2, 3, 4, 5, 6.\n\nPeter and Colin roll their dice and compare totals: the highest total wins.\nThe result is a draw if the totals are equal.\n\nWhat is the probability that Pyramidal Peter beats Cubic Colin?\nGive your answer rounded to seven decimal places in the form 0.abcdefg\n\"\"\"\n\nfrom itertools import product\n\n\ndef total_frequency_distribution(sides_number: int, dice_number: int) -> list[int]:\n    \"\"\"\n    Returns frequency distribution of total\n\n    >>> total_frequency_distribution(sides_number=6, dice_number=1)\n    [0, 1, 1, 1, 1, 1, 1]\n\n    >>> total_frequency_distribution(sides_number=4, dice_number=2)\n    [0, 0, 1, 2, 3, 4, 3, 2, 1]\n    \"\"\"\n\n    max_face_number = sides_number\n    max_total = max_face_number * dice_number\n    totals_frequencies = [0] * (max_total + 1)\n\n    min_face_number = 1\n    faces_numbers = range(min_face_number, max_face_number + 1)\n    for dice_numbers in product(faces_numbers, repeat=dice_number):\n        total = sum(dice_numbers)\n        totals_frequencies[total] += 1\n\n    return totals_frequencies\n\n\ndef solution() -> float:\n    \"\"\"\n    Returns probability that Pyramidal Peter beats Cubic Colin\n    rounded to seven decimal places in the form 0.abcdefg\n\n    >>> solution()\n    0.5731441\n    \"\"\"\n\n    peter_totals_frequencies = total_frequency_distribution(\n        sides_number=4, dice_number=9\n    )\n    colin_totals_frequencies = total_frequency_distribution(\n        sides_number=6, dice_number=6\n    )\n\n    peter_wins_count = 0\n    min_peter_total = 9\n    max_peter_total = 4 * 9\n    min_colin_total = 6\n    for peter_total in range(min_peter_total, max_peter_total + 1):\n        peter_wins_count += peter_totals_frequencies[peter_total] * sum(\n            colin_totals_frequencies[min_colin_total:peter_total]\n        )\n\n    total_games_number = (4**9) * (6**6)\n    peter_win_probability = peter_wins_count / total_games_number\n\n    rounded_peter_win_probability = round(peter_win_probability, ndigits=7)\n\n    return rounded_peter_win_probability\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_205/__init__.py": "", "project_euler/problem_117/sol1.py": "\"\"\"\nProject Euler Problem 117: https://projecteuler.net/problem=117\n\nUsing a combination of grey square tiles and oblong tiles chosen from:\nred tiles (measuring two units), green tiles (measuring three units),\nand blue tiles (measuring four units),\nit is possible to tile a row measuring five units in length\nin exactly fifteen different ways.\n\n    |grey|grey|grey|grey|grey|       |red,red|grey|grey|grey|\n\n    |grey|red,red|grey|grey|         |grey|grey|red,red|grey|\n\n    |grey|grey|grey|red,red|         |red,red|red,red|grey|\n\n    |red,red|grey|red,red|           |grey|red,red|red,red|\n\n    |green,green,green|grey|grey|    |grey|green,green,green|grey|\n\n    |grey|grey|green,green,green|    |red,red|green,green,green|\n\n    |green,green,green|red,red|      |blue,blue,blue,blue|grey|\n\n    |grey|blue,blue,blue,blue|\n\nHow many ways can a row measuring fifty units in length be tiled?\n\nNOTE: This is related to Problem 116 (https://projecteuler.net/problem=116).\n\"\"\"\n\n\ndef solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of ways can a row of the given length be tiled\n\n    >>> solution(5)\n    15\n    \"\"\"\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                ways_number[row_length] += ways_number[\n                    row_length - tile_start - tile_length\n                ]\n\n    return ways_number[length]\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_117/__init__.py": "", "project_euler/problem_025/sol2.py": "\"\"\"\nThe Fibonacci sequence is defined by the recurrence relation:\n\n    Fn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.\n\nHence the first 12 terms will be:\n\n    F1 = 1\n    F2 = 1\n    F3 = 2\n    F4 = 3\n    F5 = 5\n    F6 = 8\n    F7 = 13\n    F8 = 21\n    F9 = 34\n    F10 = 55\n    F11 = 89\n    F12 = 144\n\nThe 12th term, F12, is the first term to contain three digits.\n\nWhat is the index of the first term in the Fibonacci sequence to contain 1000\ndigits?\n\"\"\"\n\nfrom collections.abc import Generator\n\n\ndef fibonacci_generator() -> Generator[int, None, None]:\n    \"\"\"\n    A generator that produces numbers in the Fibonacci sequence\n\n    >>> generator = fibonacci_generator()\n    >>> next(generator)\n    1\n    >>> next(generator)\n    2\n    >>> next(generator)\n    3\n    >>> next(generator)\n    5\n    >>> next(generator)\n    8\n    \"\"\"\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        yield b\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    answer = 1\n    gen = fibonacci_generator()\n    while len(str(next(gen))) < n:\n        answer += 1\n    return answer + 1\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input()).strip())))\n", "project_euler/problem_025/sol3.py": "\"\"\"\nThe Fibonacci sequence is defined by the recurrence relation:\n\n    Fn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.\n\nHence the first 12 terms will be:\n\n    F1 = 1\n    F2 = 1\n    F3 = 2\n    F4 = 3\n    F5 = 5\n    F6 = 8\n    F7 = 13\n    F8 = 21\n    F9 = 34\n    F10 = 55\n    F11 = 89\n    F12 = 144\n\nThe 12th term, F12, is the first term to contain three digits.\n\nWhat is the index of the first term in the Fibonacci sequence to contain 1000\ndigits?\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    f1, f2 = 1, 1\n    index = 2\n    while True:\n        i = 0\n        f = f1 + f2\n        f1, f2 = f2, f\n        index += 1\n        for _ in str(f):\n            i += 1\n        if i == n:\n            break\n    return index\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input()).strip())))\n", "project_euler/problem_025/sol1.py": "\"\"\"\nThe Fibonacci sequence is defined by the recurrence relation:\n\n    Fn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.\n\nHence the first 12 terms will be:\n\n    F1 = 1\n    F2 = 1\n    F3 = 2\n    F4 = 3\n    F5 = 5\n    F6 = 8\n    F7 = 13\n    F8 = 21\n    F9 = 34\n    F10 = 55\n    F11 = 89\n    F12 = 144\n\nThe 12th term, F12, is the first term to contain three digits.\n\nWhat is the index of the first term in the Fibonacci sequence to contain 1000\ndigits?\n\"\"\"\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Computes the Fibonacci number for input n by iterating through n numbers\n    and creating an array of ints using the Fibonacci formula.\n    Returns the nth element of the array.\n\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(3)\n    2\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(10)\n    55\n    >>> fibonacci(12)\n    144\n\n    \"\"\"\n    if n == 1 or not isinstance(n, int):\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        sequence = [0, 1]\n        for i in range(2, n + 1):\n            sequence.append(sequence[i - 1] + sequence[i - 2])\n\n        return sequence[n]\n\n\ndef fibonacci_digits_index(n: int) -> int:\n    \"\"\"\n    Computes incrementing Fibonacci numbers starting from 3 until the length\n    of the resulting Fibonacci result is the input value n. Returns the term\n    of the Fibonacci sequence where this occurs.\n\n    >>> fibonacci_digits_index(1000)\n    4782\n    >>> fibonacci_digits_index(100)\n    476\n    >>> fibonacci_digits_index(50)\n    237\n    >>> fibonacci_digits_index(3)\n    12\n    \"\"\"\n    digits = 0\n    index = 2\n\n    while digits < n:\n        index += 1\n        digits = len(str(fibonacci(index)))\n\n    return index\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the index of the first term in the Fibonacci sequence to contain\n    n digits.\n\n    >>> solution(1000)\n    4782\n    >>> solution(100)\n    476\n    >>> solution(50)\n    237\n    >>> solution(3)\n    12\n    \"\"\"\n    return fibonacci_digits_index(n)\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input()).strip())))\n", "project_euler/problem_025/__init__.py": "", "project_euler/problem_187/sol1.py": "\"\"\"\nProject Euler Problem 187: https://projecteuler.net/problem=187\n\nA composite is a number containing at least two prime factors.\nFor example, 15 = 3 x 5; 9 = 3 x 3; 12 = 2 x 2 x 3.\n\nThere are ten composites below thirty containing precisely two,\nnot necessarily distinct, prime factors: 4, 6, 9, 10, 14, 15, 21, 22, 25, 26.\n\nHow many composite integers, n < 10^8, have precisely two,\nnot necessarily distinct, prime factors?\n\"\"\"\n\nfrom math import isqrt\n\n\ndef slow_calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number.\n    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> slow_calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n\n    >>> slow_calculate_prime_numbers(2)\n    []\n    \"\"\"\n\n    # List containing a bool value for every number below max_number/2\n    is_prime = [True] * max_number\n\n    for i in range(2, isqrt(max_number - 1) + 1):\n        if is_prime[i]:\n            # Mark all multiple of i as not prime\n            for j in range(i**2, max_number, i):\n                is_prime[j] = False\n\n    return [i for i in range(2, max_number) if is_prime[i]]\n\n\ndef calculate_prime_numbers(max_number: int) -> list[int]:\n    \"\"\"\n    Returns prime numbers below max_number.\n    See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> calculate_prime_numbers(10)\n    [2, 3, 5, 7]\n\n    >>> calculate_prime_numbers(2)\n    []\n    \"\"\"\n\n    if max_number <= 2:\n        return []\n\n    # List containing a bool value for every odd number below max_number/2\n    is_prime = [True] * (max_number // 2)\n\n    for i in range(3, isqrt(max_number - 1) + 1, 2):\n        if is_prime[i // 2]:\n            # Mark all multiple of i as not prime using list slicing\n            is_prime[i**2 // 2 :: i] = [False] * (\n                # Same as: (max_number - (i**2)) // (2 * i) + 1\n                # but faster than len(is_prime[i**2 // 2 :: i])\n                len(range(i**2 // 2, max_number // 2, i))\n            )\n\n    return [2] + [2 * i + 1 for i in range(1, max_number // 2) if is_prime[i]]\n\n\ndef slow_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> slow_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = slow_calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count\n\n\ndef while_solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> while_solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    left = 0\n    right = len(prime_numbers) - 1\n    while left <= right:\n        while prime_numbers[left] * prime_numbers[right] >= max_number:\n            right -= 1\n        semiprimes_count += right - left + 1\n        left += 1\n\n    return semiprimes_count\n\n\ndef solution(max_number: int = 10**8) -> int:\n    \"\"\"\n    Returns the number of composite integers below max_number have precisely two,\n    not necessarily distinct, prime factors.\n\n    >>> solution(30)\n    10\n    \"\"\"\n\n    prime_numbers = calculate_prime_numbers(max_number // 2)\n\n    semiprimes_count = 0\n    right = len(prime_numbers) - 1\n    for left in range(len(prime_numbers)):\n        if left > right:\n            break\n        for r in range(right, left - 2, -1):\n            if prime_numbers[left] * prime_numbers[r] < max_number:\n                break\n        right = r\n        semiprimes_count += right - left + 1\n\n    return semiprimes_count\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmarks\n    \"\"\"\n    # Running performance benchmarks...\n    # slow_solution : 108.50874730000032\n    # while_sol     : 28.09581200000048\n    # solution      : 25.063097400000515\n\n    from timeit import timeit\n\n    print(\"Running performance benchmarks...\")\n\n    print(f\"slow_solution : {timeit('slow_solution()', globals=globals(), number=10)}\")\n    print(f\"while_sol     : {timeit('while_solution()', globals=globals(), number=10)}\")\n    print(f\"solution      : {timeit('solution()', globals=globals(), number=10)}\")\n\n\nif __name__ == \"__main__\":\n    print(f\"Solution: {solution()}\")\n    benchmark()\n", "project_euler/problem_187/__init__.py": "", "project_euler/problem_062/sol1.py": "\"\"\"\nProject Euler 62\nhttps://projecteuler.net/problem=62\n\nThe cube, 41063625 (345^3), can be permuted to produce two other cubes:\n56623104 (384^3) and 66430125 (405^3). In fact, 41063625 is the smallest cube\nwhich has exactly three permutations of its digits which are also cube.\n\nFind the smallest cube for which exactly five permutations of its digits are\ncube.\n\"\"\"\n\nfrom collections import defaultdict\n\n\ndef solution(max_base: int = 5) -> int:\n    \"\"\"\n    Iterate through every possible cube and sort the cube's digits in\n    ascending order. Sorting maintains an ordering of the digits that allows\n    you to compare permutations. Store each sorted sequence of digits in a\n    dictionary, whose key is the sequence of digits and value is a list of\n    numbers that are the base of the cube.\n\n    Once you find 5 numbers that produce the same sequence of digits, return\n    the smallest one, which is at index 0 since we insert each base number in\n    ascending order.\n\n    >>> solution(2)\n    125\n    >>> solution(3)\n    41063625\n    \"\"\"\n    freqs = defaultdict(list)\n    num = 0\n\n    while True:\n        digits = get_digits(num)\n        freqs[digits].append(num)\n\n        if len(freqs[digits]) == max_base:\n            base = freqs[digits][0] ** 3\n            return base\n\n        num += 1\n\n\ndef get_digits(num: int) -> str:\n    \"\"\"\n    Computes the sorted sequence of digits of the cube of num.\n\n    >>> get_digits(3)\n    '27'\n    >>> get_digits(99)\n    '027999'\n    >>> get_digits(123)\n    '0166788'\n    \"\"\"\n    return \"\".join(sorted(str(num**3)))\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_062/__init__.py": "", "project_euler/problem_073/sol1.py": "\"\"\"\nProject Euler Problem 73: https://projecteuler.net/problem=73\n\nConsider the fraction, n/d, where n and d are positive integers.\nIf n<d and HCF(n,d)=1, it is called a reduced proper fraction.\n\nIf we list the set of reduced proper fractions for d \u2264 8 in ascending order of size,\nwe get:\n\n1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3,\n5/7, 3/4, 4/5, 5/6, 6/7, 7/8\n\nIt can be seen that there are 3 fractions between 1/3 and 1/2.\n\nHow many fractions lie between 1/3 and 1/2 in the sorted set\nof reduced proper fractions for d \u2264 12,000?\n\"\"\"\n\nfrom math import gcd\n\n\ndef solution(max_d: int = 12_000) -> int:\n    \"\"\"\n    Returns number of fractions lie between 1/3 and 1/2 in the sorted set\n    of reduced proper fractions for d \u2264 max_d\n\n    >>> solution(4)\n    0\n\n    >>> solution(5)\n    1\n\n    >>> solution(8)\n    3\n    \"\"\"\n\n    fractions_number = 0\n    for d in range(max_d + 1):\n        for n in range(d // 3 + 1, (d + 1) // 2):\n            if gcd(n, d) == 1:\n                fractions_number += 1\n    return fractions_number\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_073/__init__.py": "", "project_euler/problem_072/sol2.py": "\"\"\"\nProject Euler Problem 72: https://projecteuler.net/problem=72\n\nConsider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1,\nit is called a reduced proper fraction.\n\nIf we list the set of reduced proper fractions for d \u2264 8 in ascending order of size,\nwe get:\n\n1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2,\n4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8\n\nIt can be seen that there are 21 elements in this set.\n\nHow many elements would be contained in the set of reduced proper fractions\nfor d \u2264 1,000,000?\n\"\"\"\n\n\ndef solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of reduced proper fractions with denominator less than limit.\n    >>> solution(8)\n    21\n    >>> solution(1000)\n    304191\n    \"\"\"\n    primes = set(range(3, limit, 2))\n    primes.add(2)\n    for p in range(3, limit, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, limit, p)))\n\n    phi = [float(n) for n in range(limit + 1)]\n\n    for p in primes:\n        for n in range(p, limit + 1, p):\n            phi[n] *= 1 - 1 / p\n\n    return int(sum(phi[2:]))\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_072/sol1.py": "\"\"\"\nProblem 72 Counting fractions: https://projecteuler.net/problem=72\n\nDescription:\n\nConsider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1,\nit is called a reduced proper fraction.\nIf we list the set of reduced proper fractions for d \u2264 8 in ascending order of size, we\nget: 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7,\n3/4, 4/5, 5/6, 6/7, 7/8\nIt can be seen that there are 21 elements in this set.\nHow many elements would be contained in the set of reduced proper fractions for\nd \u2264 1,000,000?\n\nSolution:\n\nNumber of numbers between 1 and n that are coprime to n is given by the Euler's Totient\nfunction, phi(n). So, the answer is simply the sum of phi(n) for 2 <= n <= 1,000,000\nSum of phi(d), for all d|n = n. This result can be used to find phi(n) using a sieve.\n\nTime: 1 sec\n\"\"\"\n\nimport numpy as np\n\n\ndef solution(limit: int = 1_000_000) -> int:\n    \"\"\"\n    Returns an integer, the solution to the problem\n    >>> solution(10)\n    31\n    >>> solution(100)\n    3043\n    >>> solution(1_000)\n    304191\n    \"\"\"\n\n    # generating an array from -1 to limit\n    phi = np.arange(-1, limit)\n\n    for i in range(2, limit + 1):\n        if phi[i] == i - 1:\n            ind = np.arange(2 * i, limit + 1, i)  # indexes for selection\n            phi[ind] -= phi[ind] // i\n\n    return np.sum(phi[2 : limit + 1])\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_072/__init__.py": "", "project_euler/problem_125/sol1.py": "\"\"\"\nProblem 125: https://projecteuler.net/problem=125\n\nThe palindromic number 595 is interesting because it can be written as the sum\nof consecutive squares: 6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 + 12^2.\n\nThere are exactly eleven palindromes below one-thousand that can be written as\nconsecutive square sums, and the sum of these palindromes is 4164. Note that\n1 = 0^2 + 1^2 has not been included as this problem is concerned with the\nsquares of positive integers.\n\nFind the sum of all the numbers less than 10^8 that are both palindromic and can\nbe written as the sum of consecutive squares.\n\"\"\"\n\nLIMIT = 10**8\n\n\ndef is_palindrome(n: int) -> bool:\n    \"\"\"\n    Check if an integer is palindromic.\n    >>> is_palindrome(12521)\n    True\n    >>> is_palindrome(12522)\n    False\n    >>> is_palindrome(12210)\n    False\n    \"\"\"\n    if n % 10 == 0:\n        return False\n    s = str(n)\n    return s == s[::-1]\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the sum of all numbers less than 1e8 that are both palindromic and\n    can be written as the sum of consecutive squares.\n    \"\"\"\n    answer = set()\n    first_square = 1\n    sum_squares = 5\n    while sum_squares < LIMIT:\n        last_square = first_square + 1\n        while sum_squares < LIMIT:\n            if is_palindrome(sum_squares):\n                answer.add(sum_squares)\n            last_square += 1\n            sum_squares += last_square**2\n        first_square += 1\n        sum_squares = first_square**2 + (first_square + 1) ** 2\n\n    return sum(answer)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_125/__init__.py": "", "project_euler/problem_065/sol1.py": "\"\"\"\nProject Euler Problem 65: https://projecteuler.net/problem=65\n\nThe square root of 2 can be written as an infinite continued fraction.\n\nsqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 + 1 / (2 + ...))))\n\nThe infinite continued fraction can be written, sqrt(2) = [1;(2)], (2)\nindicates that 2 repeats ad infinitum. In a similar way, sqrt(23) =\n[4;(1,3,1,8)].\n\nIt turns out that the sequence of partial values of continued\nfractions for square roots provide the best rational approximations.\nLet us consider the convergents for sqrt(2).\n\n1 + 1 / 2 = 3/2\n1 + 1 / (2 + 1 / 2) = 7/5\n1 + 1 / (2 + 1 / (2 + 1 / 2)) = 17/12\n1 + 1 / (2 + 1 / (2 + 1 / (2 + 1 / 2))) = 41/29\n\nHence the sequence of the first ten convergents for sqrt(2) are:\n1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...\n\nWhat is most surprising is that the important mathematical constant,\ne = [2;1,2,1,1,4,1,1,6,1,...,1,2k,1,...].\n\nThe first ten terms in the sequence of convergents for e are:\n2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...\n\nThe sum of digits in the numerator of the 10th convergent is\n1 + 4 + 5 + 7 = 17.\n\nFind the sum of the digits in the numerator of the 100th convergent\nof the continued fraction for e.\n\n-----\n\nThe solution mostly comes down to finding an equation that will generate\nthe numerator of the continued fraction. For the i-th numerator, the\npattern is:\n\nn_i = m_i * n_(i-1) + n_(i-2)\n\nfor m_i = the i-th index of the continued fraction representation of e,\nn_0 = 1, and n_1 = 2 as the first 2 numbers of the representation.\n\nFor example:\nn_9 = 6 * 193 + 106 = 1264\n1 + 2 + 6 + 4 = 13\n\nn_10 = 1 * 193 + 1264 = 1457\n1 + 4 + 5 + 7 = 17\n\"\"\"\n\n\ndef sum_digits(num: int) -> int:\n    \"\"\"\n    Returns the sum of every digit in num.\n\n    >>> sum_digits(1)\n    1\n    >>> sum_digits(12345)\n    15\n    >>> sum_digits(999001)\n    28\n    \"\"\"\n    digit_sum = 0\n    while num > 0:\n        digit_sum += num % 10\n        num //= 10\n    return digit_sum\n\n\ndef solution(max_n: int = 100) -> int:\n    \"\"\"\n    Returns the sum of the digits in the numerator of the max-th convergent of\n    the continued fraction for e.\n\n    >>> solution(9)\n    13\n    >>> solution(10)\n    17\n    >>> solution(50)\n    91\n    \"\"\"\n    pre_numerator = 1\n    cur_numerator = 2\n\n    for i in range(2, max_n + 1):\n        temp = pre_numerator\n        e_cont = 2 * i // 3 if i % 3 == 0 else 1\n        pre_numerator = cur_numerator\n        cur_numerator = e_cont * pre_numerator + temp\n\n    return sum_digits(cur_numerator)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_065/__init__.py": "", "project_euler/problem_075/sol1.py": "\"\"\"\nProject Euler Problem 75: https://projecteuler.net/problem=75\n\nIt turns out that 12 cm is the smallest length of wire that can be bent to form an\ninteger sided right angle triangle in exactly one way, but there are many more examples.\n\n12 cm: (3,4,5)\n24 cm: (6,8,10)\n30 cm: (5,12,13)\n36 cm: (9,12,15)\n40 cm: (8,15,17)\n48 cm: (12,16,20)\n\nIn contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided\nright angle triangle, and other lengths allow more than one solution to be found; for\nexample, using 120 cm it is possible to form exactly three different integer sided\nright angle triangles.\n\n120 cm: (30,40,50), (20,48,52), (24,45,51)\n\nGiven that L is the length of the wire, for how many values of L \u2264 1,500,000 can\nexactly one integer sided right angle triangle be formed?\n\nSolution: we generate all pythagorean triples using Euclid's formula and\nkeep track of the frequencies of the perimeters.\n\nReference: https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple\n\"\"\"\n\nfrom collections import defaultdict\nfrom math import gcd\n\n\ndef solution(limit: int = 1500000) -> int:\n    \"\"\"\n    Return the number of values of L <= limit such that a wire of length L can be\n    formmed into an integer sided right angle triangle in exactly one way.\n    >>> solution(50)\n    6\n    >>> solution(1000)\n    112\n    >>> solution(50000)\n    5502\n    \"\"\"\n    frequencies: defaultdict = defaultdict(int)\n    euclid_m = 2\n    while 2 * euclid_m * (euclid_m + 1) <= limit:\n        for euclid_n in range((euclid_m % 2) + 1, euclid_m, 2):\n            if gcd(euclid_m, euclid_n) > 1:\n                continue\n            primitive_perimeter = 2 * euclid_m * (euclid_m + euclid_n)\n            for perimeter in range(primitive_perimeter, limit + 1, primitive_perimeter):\n                frequencies[perimeter] += 1\n        euclid_m += 1\n    return sum(1 for frequency in frequencies.values() if frequency == 1)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_075/__init__.py": "", "project_euler/problem_089/sol1.py": "\"\"\"\nProject Euler Problem 89: https://projecteuler.net/problem=89\n\nFor a number written in Roman numerals to be considered valid there are basic rules\nwhich must be followed. Even though the rules allow some numbers to be expressed in\nmore than one way there is always a \"best\" way of writing a particular number.\n\nFor example, it would appear that there are at least six ways of writing the number\nsixteen:\n\nIIIIIIIIIIIIIIII\nVIIIIIIIIIII\nVVIIIIII\nXIIIIII\nVVVI\nXVI\n\nHowever, according to the rules only XIIIIII and XVI are valid, and the last example\nis considered to be the most efficient, as it uses the least number of numerals.\n\nThe 11K text file, roman.txt (right click and 'Save Link/Target As...'), contains one\nthousand numbers written in valid, but not necessarily minimal, Roman numerals; see\nAbout... Roman Numerals for the definitive rules for this problem.\n\nFind the number of characters saved by writing each of these in their minimal form.\n\nNote: You can assume that all the Roman numerals in the file contain no more than four\nconsecutive identical units.\n\"\"\"\n\nimport os\n\nSYMBOLS = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n\n\ndef parse_roman_numerals(numerals: str) -> int:\n    \"\"\"\n    Converts a string of roman numerals to an integer.\n    e.g.\n    >>> parse_roman_numerals(\"LXXXIX\")\n    89\n    >>> parse_roman_numerals(\"IIII\")\n    4\n    \"\"\"\n\n    total_value = 0\n\n    index = 0\n    while index < len(numerals) - 1:\n        current_value = SYMBOLS[numerals[index]]\n        next_value = SYMBOLS[numerals[index + 1]]\n        if current_value < next_value:\n            total_value -= current_value\n        else:\n            total_value += current_value\n        index += 1\n    total_value += SYMBOLS[numerals[index]]\n\n    return total_value\n\n\ndef generate_roman_numerals(num: int) -> str:\n    \"\"\"\n    Generates a string of roman numerals for a given integer.\n    e.g.\n    >>> generate_roman_numerals(89)\n    'LXXXIX'\n    >>> generate_roman_numerals(4)\n    'IV'\n    \"\"\"\n\n    numerals = \"\"\n\n    m_count = num // 1000\n    numerals += m_count * \"M\"\n    num %= 1000\n\n    c_count = num // 100\n    if c_count == 9:\n        numerals += \"CM\"\n        c_count -= 9\n    elif c_count == 4:\n        numerals += \"CD\"\n        c_count -= 4\n    if c_count >= 5:\n        numerals += \"D\"\n        c_count -= 5\n    numerals += c_count * \"C\"\n    num %= 100\n\n    x_count = num // 10\n    if x_count == 9:\n        numerals += \"XC\"\n        x_count -= 9\n    elif x_count == 4:\n        numerals += \"XL\"\n        x_count -= 4\n    if x_count >= 5:\n        numerals += \"L\"\n        x_count -= 5\n    numerals += x_count * \"X\"\n    num %= 10\n\n    if num == 9:\n        numerals += \"IX\"\n        num -= 9\n    elif num == 4:\n        numerals += \"IV\"\n        num -= 4\n    if num >= 5:\n        numerals += \"V\"\n        num -= 5\n    numerals += num * \"I\"\n\n    return numerals\n\n\ndef solution(roman_numerals_filename: str = \"/p089_roman.txt\") -> int:\n    \"\"\"\n    Calculates and returns the answer to project euler problem 89.\n\n    >>> solution(\"/numeralcleanup_test.txt\")\n    16\n    \"\"\"\n\n    savings = 0\n\n    with open(os.path.dirname(__file__) + roman_numerals_filename) as file1:\n        lines = file1.readlines()\n\n    for line in lines:\n        original = line.strip()\n        num = parse_roman_numerals(original)\n        shortened = generate_roman_numerals(num)\n        savings += len(original) - len(shortened)\n\n    return savings\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_089/__init__.py": "#\n", "project_euler/problem_017/sol1.py": "\"\"\"\nNumber letter counts\nProblem 17: https://projecteuler.net/problem=17\n\nIf the numbers 1 to 5 are written out in words: one, two, three, four, five,\nthen there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.\n\nIf all the numbers from 1 to 1000 (one thousand) inclusive were written out in\nwords, how many letters would be used?\n\n\nNOTE: Do not count spaces or hyphens. For example, 342 (three hundred and\nforty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20\nletters. The use of \"and\" when writing out numbers is in compliance withBritish\nusage.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"Returns the number of letters used to write all numbers from 1 to n.\n    where n is lower or equals to 1000.\n    >>> solution(1000)\n    21124\n    >>> solution(5)\n    19\n    \"\"\"\n    # number of letters in zero, one, two, ..., nineteen (0 for zero since it's\n    # never said aloud)\n    ones_counts = [0, 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6, 6, 8, 8, 7, 7, 9, 8, 8]\n    # number of letters in twenty, thirty, ..., ninety (0 for numbers less than\n    # 20 due to inconsistency in teens)\n    tens_counts = [0, 0, 6, 6, 5, 5, 5, 7, 6, 6]\n\n    count = 0\n\n    for i in range(1, n + 1):\n        if i < 1000:\n            if i >= 100:\n                # add number of letters for \"n hundred\"\n                count += ones_counts[i // 100] + 7\n\n                if i % 100 != 0:\n                    # add number of letters for \"and\" if number is not multiple\n                    # of 100\n                    count += 3\n\n            if 0 < i % 100 < 20:\n                # add number of letters for one, two, three, ..., nineteen\n                # (could be combined with below if not for inconsistency in\n                # teens)\n                count += ones_counts[i % 100]\n            else:\n                # add number of letters for twenty, twenty one, ..., ninety\n                # nine\n                count += ones_counts[i % 10]\n                count += tens_counts[(i % 100 - i % 10) // 10]\n        else:\n            count += ones_counts[i // 1000] + 8\n    return count\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input().strip())))\n", "project_euler/problem_017/__init__.py": "", "project_euler/problem_007/sol2.py": "\"\"\"\nProject Euler Problem 7: https://projecteuler.net/problem=7\n\n10001st prime\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we\ncan see that the 6th prime is 13.\n\nWhat is the 10001st prime number?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n\"\"\"\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    >>> solution(3.4)\n    5\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter nth must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter nth must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter nth must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter nth must be int or castable to int.\n    \"\"\"\n\n    try:\n        nth = int(nth)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter nth must be int or castable to int.\") from None\n    if nth <= 0:\n        raise ValueError(\"Parameter nth must be greater than or equal to one.\")\n    primes: list[int] = []\n    num = 2\n    while len(primes) < nth:\n        if is_prime(num):\n            primes.append(num)\n            num += 1\n        else:\n            num += 1\n    return primes[len(primes) - 1]\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_007/sol3.py": "\"\"\"\nProject Euler Problem 7: https://projecteuler.net/problem=7\n\n10001st prime\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we\ncan see that the 6th prime is 13.\n\nWhat is the 10001st prime number?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n\"\"\"\n\nimport itertools\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef prime_generator():\n    \"\"\"\n    Generate a sequence of prime numbers\n    \"\"\"\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1\n\n\ndef solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    \"\"\"\n    return next(itertools.islice(prime_generator(), nth - 1, nth))\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_007/sol1.py": "\"\"\"\nProject Euler Problem 7: https://projecteuler.net/problem=7\n\n10001st prime\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we\ncan see that the 6th prime is 13.\n\nWhat is the 10001st prime number?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n\"\"\"\n\nfrom math import sqrt\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(nth: int = 10001) -> int:\n    \"\"\"\n    Returns the n-th prime number.\n\n    >>> solution(6)\n    13\n    >>> solution(1)\n    2\n    >>> solution(3)\n    5\n    >>> solution(20)\n    71\n    >>> solution(50)\n    229\n    >>> solution(100)\n    541\n    \"\"\"\n\n    count = 0\n    number = 1\n    while count != nth and number < 3:\n        number += 1\n        if is_prime(number):\n            count += 1\n    while count != nth:\n        number += 2\n        if is_prime(number):\n            count += 1\n    return number\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_007/__init__.py": "", "project_euler/problem_069/sol1.py": "\"\"\"\nTotient maximum\nProblem 69: https://projecteuler.net/problem=69\n\nEuler's Totient function, \u03c6(n) [sometimes called the phi function],\nis used to determine the number of numbers less than n which are relatively prime to n.\nFor example, as 1, 2, 4, 5, 7, and 8,\nare all less than nine and relatively prime to nine, \u03c6(9)=6.\n\nn\tRelatively Prime\t\u03c6(n)\tn/\u03c6(n)\n2\t1\t                1\t    2\n3\t1,2\t                2\t    1.5\n4\t1,3\t                2\t    2\n5\t1,2,3,4\t            4\t    1.25\n6\t1,5\t\t            2\t    3\n7\t1,2,3,4,5,6\t        6\t    1.1666...\n8\t1,3,5,7\t\t        4\t    2\n9\t1,2,4,5,7,8\t        6\t    1.5\n10\t1,3,7,9\t            4\t    2.5\n\nIt can be seen that n=6 produces a maximum n/\u03c6(n) for n \u2264 10.\n\nFind the value of n \u2264 1,000,000 for which n/\u03c6(n) is a maximum.\n\"\"\"\n\n\ndef solution(n: int = 10**6) -> int:\n    \"\"\"\n    Returns solution to problem.\n    Algorithm:\n    1. Precompute \u03c6(k) for all natural k, k <= n using product formula (wikilink below)\n    https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler's_product_formula\n\n    2. Find k/\u03c6(k) for all k \u2264 n and return the k that attains maximum\n\n    >>> solution(10)\n    6\n\n    >>> solution(100)\n    30\n\n    >>> solution(9973)\n    2310\n\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Please enter an integer greater than 0\")\n\n    phi = list(range(n + 1))\n    for number in range(2, n + 1):\n        if phi[number] == number:\n            phi[number] -= 1\n            for multiple in range(number * 2, n + 1, number):\n                phi[multiple] = (phi[multiple] // number) * (number - 1)\n\n    answer = 1\n    for number in range(1, n + 1):\n        if (answer / phi[answer]) < (number / phi[number]):\n            answer = number\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_069/__init__.py": "", "project_euler/problem_004/sol2.py": "\"\"\"\nProject Euler Problem 4: https://projecteuler.net/problem=4\n\nLargest palindrome product\n\nA palindromic number reads the same both ways. The largest palindrome made\nfrom the product of two 2-digit numbers is 9009 = 91 x 99.\n\nFind the largest palindrome made from the product of two 3-digit numbers.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Palindromic_number\n\"\"\"\n\n\ndef solution(n: int = 998001) -> int:\n    \"\"\"\n    Returns the largest palindrome made from the product of two 3-digit\n    numbers which is less than n.\n\n    >>> solution(20000)\n    19591\n    >>> solution(30000)\n    29992\n    >>> solution(40000)\n    39893\n    \"\"\"\n\n    answer = 0\n    for i in range(999, 99, -1):  # 3 digit numbers range from 999 down to 100\n        for j in range(999, 99, -1):\n            product_string = str(i * j)\n            if product_string == product_string[::-1] and i * j < n:\n                answer = max(answer, i * j)\n    return answer\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_004/sol1.py": "\"\"\"\nProject Euler Problem 4: https://projecteuler.net/problem=4\n\nLargest palindrome product\n\nA palindromic number reads the same both ways. The largest palindrome made\nfrom the product of two 2-digit numbers is 9009 = 91 x 99.\n\nFind the largest palindrome made from the product of two 3-digit numbers.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Palindromic_number\n\"\"\"\n\n\ndef solution(n: int = 998001) -> int:\n    \"\"\"\n    Returns the largest palindrome made from the product of two 3-digit\n    numbers which is less than n.\n\n    >>> solution(20000)\n    19591\n    >>> solution(30000)\n    29992\n    >>> solution(40000)\n    39893\n    >>> solution(10000)\n    Traceback (most recent call last):\n        ...\n    ValueError: That number is larger than our acceptable range.\n    \"\"\"\n\n    # fetches the next number\n    for number in range(n - 1, 9999, -1):\n        str_number = str(number)\n\n        # checks whether 'str_number' is a palindrome.\n        if str_number == str_number[::-1]:\n            divisor = 999\n\n            # if 'number' is a product of two 3-digit numbers\n            # then number is the answer otherwise fetch next number.\n            while divisor != 99:\n                if (number % divisor == 0) and (len(str(number // divisor)) == 3.0):\n                    return number\n                divisor -= 1\n    raise ValueError(\"That number is larger than our acceptable range.\")\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_004/__init__.py": "", "project_euler/problem_053/sol1.py": "\"\"\"\nCombinatoric selections\nProblem 53\n\nThere are exactly ten ways of selecting three from five, 12345:\n\n    123, 124, 125, 134, 135, 145, 234, 235, 245, and 345\n\nIn combinatorics, we use the notation, 5C3 = 10.\n\nIn general,\n\nnCr = n!/(r!(n-r)!),where r \u2264 n, n! = nx(n-1)x...x3x2x1, and 0! = 1.\nIt is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.\n\nHow many, not necessarily distinct, values of nCr, for 1 \u2264 n \u2264 100, are greater\nthan one-million?\n\"\"\"\n\nfrom math import factorial\n\n\ndef combinations(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\n\ndef solution():\n    \"\"\"Returns the number of values of nCr, for 1 \u2264 n \u2264 100, are greater than\n    one-million\n\n    >>> solution()\n    4075\n    \"\"\"\n    total = 0\n\n    for i in range(1, 101):\n        for j in range(1, i + 1):\n            if combinations(i, j) > 1e6:\n                total += 1\n    return total\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_053/__init__.py": "", "project_euler/problem_207/sol1.py": "\"\"\"\n\nProject Euler Problem 207: https://projecteuler.net/problem=207\n\nProblem Statement:\nFor some positive integers k, there exists an integer partition of the form\n4**t = 2**t + k, where 4**t, 2**t, and k are all positive integers and t is a real\nnumber. The first two such partitions are 4**1 = 2**1 + 2 and\n4**1.5849625... = 2**1.5849625... + 6.\nPartitions where t is also an integer are called perfect.\nFor any m \u2265 1 let P(m) be the proportion of such partitions that are perfect with\nk \u2264 m.\nThus P(6) = 1/2.\nIn the following table are listed some values of P(m)\n\n   P(5) = 1/1\n   P(10) = 1/2\n   P(15) = 2/3\n   P(20) = 1/2\n   P(25) = 1/2\n   P(30) = 2/5\n   ...\n   P(180) = 1/4\n   P(185) = 3/13\n\nFind the smallest m for which P(m) < 1/12345\n\nSolution:\nEquation 4**t = 2**t + k solved for t gives:\n    t = log2(sqrt(4*k+1)/2 + 1/2)\nFor t to be real valued, sqrt(4*k+1) must be an integer which is implemented in\nfunction check_t_real(k). For a perfect partition t must be an integer.\nTo speed up significantly the search for partitions, instead of incrementing k by one\nper iteration, the next valid k is found by k = (i**2 - 1) / 4 with an integer i and\nk has to be a positive integer. If this is the case a partition is found. The partition\nis perfect if t os an integer. The integer i is increased with increment 1 until the\nproportion perfect partitions / total partitions drops under the given value.\n\n\"\"\"\n\nimport math\n\n\ndef check_partition_perfect(positive_integer: int) -> bool:\n    \"\"\"\n\n    Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a\n    real number.\n\n    >>> check_partition_perfect(2)\n    True\n\n    >>> check_partition_perfect(6)\n    False\n\n    \"\"\"\n\n    exponent = math.log2(math.sqrt(4 * positive_integer + 1) / 2 + 1 / 2)\n\n    return exponent == int(exponent)\n\n\ndef solution(max_proportion: float = 1 / 12345) -> int:\n    \"\"\"\n    Find m for which the proportion of perfect partitions to total partitions is lower\n    than max_proportion\n\n    >>> solution(1) > 5\n    True\n\n    >>> solution(1/2) > 10\n    True\n\n    >>> solution(3 / 13) > 185\n    True\n\n    \"\"\"\n\n    total_partitions = 0\n    perfect_partitions = 0\n\n    integer = 3\n    while True:\n        partition_candidate = (integer**2 - 1) / 4\n        # if candidate is an integer, then there is a partition for k\n        if partition_candidate == int(partition_candidate):\n            partition_candidate = int(partition_candidate)\n            total_partitions += 1\n            if check_partition_perfect(partition_candidate):\n                perfect_partitions += 1\n        if (\n            perfect_partitions > 0\n            and perfect_partitions / total_partitions < max_proportion\n        ):\n            return int(partition_candidate)\n        integer += 1\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_207/__init__.py": "", "project_euler/problem_135/sol1.py": "\"\"\"\nProject Euler Problem 135: https://projecteuler.net/problem=135\n\nGiven the positive integers, x, y, and z, are consecutive terms of an arithmetic\nprogression, the least value of the positive integer, n, for which the equation,\nx2 - y2 - z2 = n, has exactly two solutions is n = 27:\n\n342 - 272 - 202 = 122 - 92 - 62 = 27\n\nIt turns out that n = 1155 is the least value which has exactly ten solutions.\n\nHow many values of n less than one million have exactly ten distinct solutions?\n\n\nTaking x, y, z of the form a + d, a, a - d respectively, the given equation reduces to\na * (4d - a) = n.\nCalculating no of solutions for every n till 1 million by fixing a, and n must be a\nmultiple of a. Total no of steps = n * (1/1 + 1/2 + 1/3 + 1/4 + ... + 1/n), so roughly\nO(nlogn) time complexity.\n\"\"\"\n\n\ndef solution(limit: int = 1000000) -> int:\n    \"\"\"\n    returns the values of n less than or equal to the limit\n    have exactly ten distinct solutions.\n    >>> solution(100)\n    0\n    >>> solution(10000)\n    45\n    >>> solution(50050)\n    292\n    \"\"\"\n    limit = limit + 1\n    frequency = [0] * limit\n    for first_term in range(1, limit):\n        for n in range(first_term, limit, first_term):\n            common_difference = first_term + n / first_term\n            if common_difference % 4:  # d must be divisible by 4\n                continue\n            else:\n                common_difference /= 4\n                if (\n                    first_term > common_difference\n                    and first_term < 4 * common_difference\n                ):  # since x, y, z are positive integers\n                    frequency[n] += 1  # so z > 0, a > d and 4d < a\n\n    count = sum(1 for x in frequency[1:limit] if x == 10)\n\n    return count\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_135/__init__.py": "", "project_euler/problem_174/sol1.py": "\"\"\"\nProject Euler Problem 174: https://projecteuler.net/problem=174\n\nWe shall define a square lamina to be a square outline with a square \"hole\" so that\nthe shape possesses vertical and horizontal symmetry.\n\nGiven eight tiles it is possible to form a lamina in only one way: 3x3 square with a\n1x1 hole in the middle. However, using thirty-two tiles it is possible to form two\ndistinct laminae.\n\nIf t represents the number of tiles used, we shall say that t = 8 is type L(1) and\nt = 32 is type L(2).\n\nLet N(n) be the number of t \u2264 1000000 such that t is type L(n); for example,\nN(15) = 832.\n\nWhat is sum N(n) for 1 \u2264 n \u2264 10?\n\"\"\"\n\nfrom collections import defaultdict\nfrom math import ceil, sqrt\n\n\ndef solution(t_limit: int = 1000000, n_limit: int = 10) -> int:\n    \"\"\"\n    Return the sum of N(n) for 1 <= n <= n_limit.\n\n    >>> solution(1000,5)\n    222\n    >>> solution(1000,10)\n    249\n    >>> solution(10000,10)\n    2383\n    \"\"\"\n    count: defaultdict = defaultdict(int)\n\n    for outer_width in range(3, (t_limit // 4) + 2):\n        if outer_width * outer_width > t_limit:\n            hole_width_lower_bound = max(\n                ceil(sqrt(outer_width * outer_width - t_limit)), 1\n            )\n        else:\n            hole_width_lower_bound = 1\n\n        hole_width_lower_bound += (outer_width - hole_width_lower_bound) % 2\n\n        for hole_width in range(hole_width_lower_bound, outer_width - 1, 2):\n            count[outer_width * outer_width - hole_width * hole_width] += 1\n\n    return sum(1 for n in count.values() if 1 <= n <= n_limit)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_174/__init__.py": "", "project_euler/problem_006/sol2.py": "\"\"\"\nProject Euler Problem 6: https://projecteuler.net/problem=6\n\nSum square difference\n\nThe sum of the squares of the first ten natural numbers is,\n    1^2 + 2^2 + ... + 10^2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n    (1 + 2 + ... + 10)^2 = 55^2 = 3025\n\nHence the difference between the sum of the squares of the first ten\nnatural numbers and the square of the sum is 3025 - 385 = 2640.\n\nFind the difference between the sum of the squares of the first one\nhundred natural numbers and the square of the sum.\n\"\"\"\n\n\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    return sum_cubes - sum_squares\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_006/sol4.py": "\"\"\"\nProject Euler Problem 6: https://projecteuler.net/problem=6\n\nSum square difference\n\nThe sum of the squares of the first ten natural numbers is,\n    1^2 + 2^2 + ... + 10^2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n    (1 + 2 + ... + 10)^2 = 55^2 = 3025\n\nHence the difference between the sum of the squares of the first ten\nnatural numbers and the square of the sum is 3025 - 385 = 2640.\n\nFind the difference between the sum of the squares of the first one\nhundred natural numbers and the square of the sum.\n\"\"\"\n\n\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = n * (n + 1) * (2 * n + 1) / 6\n    square_of_sum = (n * (n + 1) / 2) ** 2\n    return int(square_of_sum - sum_of_squares)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_006/sol3.py": "\"\"\"\nProject Euler Problem 6: https://projecteuler.net/problem=6\n\nSum square difference\n\nThe sum of the squares of the first ten natural numbers is,\n    1^2 + 2^2 + ... + 10^2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n    (1 + 2 + ... + 10)^2 = 55^2 = 3025\n\nHence the difference between the sum of the squares of the first ten\nnatural numbers and the square of the sum is 3025 - 385 = 2640.\n\nFind the difference between the sum of the squares of the first one\nhundred natural numbers and the square of the sum.\n\"\"\"\n\nimport math\n\n\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = sum(i * i for i in range(1, n + 1))\n    square_of_sum = int(math.pow(sum(range(1, n + 1)), 2))\n    return square_of_sum - sum_of_squares\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_006/sol1.py": "\"\"\"\nProject Euler Problem 6: https://projecteuler.net/problem=6\n\nSum square difference\n\nThe sum of the squares of the first ten natural numbers is,\n    1^2 + 2^2 + ... + 10^2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n    (1 + 2 + ... + 10)^2 = 55^2 = 3025\n\nHence the difference between the sum of the squares of the first ten\nnatural numbers and the square of the sum is 3025 - 385 = 2640.\n\nFind the difference between the sum of the squares of the first one\nhundred natural numbers and the square of the sum.\n\"\"\"\n\n\ndef solution(n: int = 100) -> int:\n    \"\"\"\n    Returns the difference between the sum of the squares of the first n\n    natural numbers and the square of the sum.\n\n    >>> solution(10)\n    2640\n    >>> solution(15)\n    13160\n    >>> solution(20)\n    41230\n    >>> solution(50)\n    1582700\n    \"\"\"\n\n    sum_of_squares = 0\n    sum_of_ints = 0\n    for i in range(1, n + 1):\n        sum_of_squares += i**2\n        sum_of_ints += i\n    return sum_of_ints**2 - sum_of_squares\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_006/__init__.py": "", "project_euler/problem_071/sol1.py": "\"\"\"\nOrdered fractions\nProblem 71\nhttps://projecteuler.net/problem=71\n\nConsider the fraction n/d, where n and d are positive\nintegers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.\n\nIf we list the set of reduced proper fractions for d \u2264 8\nin ascending order of size, we get:\n    1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7,\n    1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8\n\nIt can be seen that 2/5 is the fraction immediately to the left of 3/7.\n\nBy listing the set of reduced proper fractions for d \u2264 1,000,000\nin ascending order of size, find the numerator of the fraction\nimmediately to the left of 3/7.\n\"\"\"\n\n\ndef solution(numerator: int = 3, denominator: int = 7, limit: int = 1000000) -> int:\n    \"\"\"\n    Returns the closest numerator of the fraction immediately to the\n    left of given fraction (numerator/denominator) from a list of reduced\n    proper fractions.\n    >>> solution()\n    428570\n    >>> solution(3, 7, 8)\n    2\n    >>> solution(6, 7, 60)\n    47\n    \"\"\"\n    max_numerator = 0\n    max_denominator = 1\n\n    for current_denominator in range(1, limit + 1):\n        current_numerator = current_denominator * numerator // denominator\n        if current_denominator % denominator == 0:\n            current_numerator -= 1\n        if current_numerator * max_denominator > current_denominator * max_numerator:\n            max_numerator = current_numerator\n            max_denominator = current_denominator\n    return max_numerator\n\n\nif __name__ == \"__main__\":\n    print(solution(numerator=3, denominator=7, limit=1000000))\n", "project_euler/problem_071/__init__.py": "", "project_euler/problem_058/sol1.py": "\"\"\"\nProject Euler Problem 58:https://projecteuler.net/problem=58\n\n\nStarting with 1 and spiralling anticlockwise in the following way,\na square spiral with side length 7 is formed.\n\n37 36 35 34 33 32 31\n38 17 16 15 14 13 30\n39 18  5  4  3 12 29\n40 19  6  1  2 11 28\n41 20  7  8  9 10 27\n42 21 22 23 24 25 26\n43 44 45 46 47 48 49\n\nIt is interesting to note that the odd squares lie along the bottom right\ndiagonal ,but what is more interesting is that 8 out of the 13 numbers\nlying along both diagonals are prime; that is, a ratio of 8/13 \u2248 62%.\n\nIf one complete new layer is wrapped around the spiral above,\na square spiral with side length 9 will be formed.\nIf this process is continued,\nwhat is the side length of the square spiral for which\nthe ratio of primes along both diagonals first falls below 10%?\n\nSolution: We have to find an odd length side for which square falls below\n10%. With every layer we add 4 elements are being added to the diagonals\n,lets say we have a square spiral of odd length with side length j,\nthen if we move from j to j+2, we are adding j*j+j+1,j*j+2*(j+1),j*j+3*(j+1)\nj*j+4*(j+1). Out of these 4 only the first three can become prime\nbecause last one reduces to (j+2)*(j+2).\nSo we check individually each one of these before incrementing our\ncount of current primes.\n\n\"\"\"\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(ratio: float = 0.1) -> int:\n    \"\"\"\n    Returns the side length of the square spiral of odd length greater\n    than 1 for which the ratio of primes along both diagonals\n    first falls below the given ratio.\n    >>> solution(.5)\n    11\n    >>> solution(.2)\n    309\n    >>> solution(.111)\n    11317\n    \"\"\"\n\n    j = 3\n    primes = 3\n\n    while primes / (2 * j - 1) >= ratio:\n        for i in range(j * j + j + 1, (j + 2) * (j + 2), j + 1):\n            primes += is_prime(i)\n        j += 2\n    return j\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "project_euler/problem_058/__init__.py": "#\n", "project_euler/problem_045/sol1.py": "\"\"\"\nProblem 45: https://projecteuler.net/problem=45\n\nTriangle, pentagonal, and hexagonal numbers are generated by the following formulae:\nTriangle\t \tT(n) = (n * (n + 1)) / 2\t \t1, 3, 6, 10, 15, ...\nPentagonal\t \tP(n) = (n * (3 * n - 1)) / 2\t \t1, 5, 12, 22, 35, ...\nHexagonal\t \tH(n) = n * (2 * n - 1)\t \t1, 6, 15, 28, 45, ...\nIt can be verified that T(285) = P(165) = H(143) = 40755.\n\nFind the next triangle number that is also pentagonal and hexagonal.\nAll triangle numbers are hexagonal numbers.\nT(2n-1) = n * (2 * n - 1) = H(n)\nSo we shall check only for hexagonal numbers which are also pentagonal.\n\"\"\"\n\n\ndef hexagonal_num(n: int) -> int:\n    \"\"\"\n    Returns nth hexagonal number\n    >>> hexagonal_num(143)\n    40755\n    >>> hexagonal_num(21)\n    861\n    >>> hexagonal_num(10)\n    190\n    \"\"\"\n    return n * (2 * n - 1)\n\n\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0\n\n\ndef solution(start: int = 144) -> int:\n    \"\"\"\n    Returns the next number which is triangular, pentagonal and hexagonal.\n    >>> solution(144)\n    1533776805\n    \"\"\"\n    n = start\n    num = hexagonal_num(n)\n    while not is_pentagonal(num):\n        n += 1\n        num = hexagonal_num(n)\n    return num\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution()} = \")\n", "project_euler/problem_045/__init__.py": "#\n", "project_euler/problem_180/sol1.py": "\"\"\"\nProject Euler Problem 234: https://projecteuler.net/problem=234\n\nFor any integer n, consider the three functions\n\nf1,n(x,y,z) = x^(n+1) + y^(n+1) - z^(n+1)\nf2,n(x,y,z) = (xy + yz + zx)*(x^(n-1) + y^(n-1) - z^(n-1))\nf3,n(x,y,z) = xyz*(xn-2 + yn-2 - zn-2)\n\nand their combination\n\nfn(x,y,z) = f1,n(x,y,z) + f2,n(x,y,z) - f3,n(x,y,z)\n\nWe call (x,y,z) a golden triple of order k if x, y, and z are all rational numbers\nof the form a / b with 0 < a < b \u2264 k and there is (at least) one integer n,\nso that fn(x,y,z) = 0.\n\nLet s(x,y,z) = x + y + z.\nLet t = u / v be the sum of all distinct s(x,y,z) for all golden triples\n(x,y,z) of order 35.\nAll the s(x,y,z) and t must be in reduced form.\n\nFind u + v.\n\n\nSolution:\n\nBy expanding the brackets it is easy to show that\nfn(x, y, z) = (x + y + z) * (x^n + y^n - z^n).\n\nSince x,y,z are positive, the requirement fn(x, y, z) = 0 is fulfilled if and\nonly if x^n + y^n = z^n.\n\nBy Fermat's Last Theorem, this means that the absolute value of n can not\nexceed 2, i.e. n is in {-2, -1, 0, 1, 2}. We can eliminate n = 0 since then the\nequation would reduce to 1 + 1 = 1, for which there are no solutions.\n\nSo all we have to do is iterate through the possible numerators and denominators\nof x and y, calculate the corresponding z, and check if the corresponding numerator and\ndenominator are integer and satisfy 0 < z_num < z_den <= 0. We use a set \"uniquq_s\"\nto make sure there are no duplicates, and the fractions.Fraction class to make sure\nwe get the right numerator and denominator.\n\nReference:\nhttps://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom fractions import Fraction\nfrom math import gcd, sqrt\n\n\ndef is_sq(number: int) -> bool:\n    \"\"\"\n    Check if number is a perfect square.\n\n    >>> is_sq(1)\n    True\n    >>> is_sq(1000001)\n    False\n    >>> is_sq(1000000)\n    True\n    \"\"\"\n    sq: int = int(number**0.5)\n    return number == sq * sq\n\n\ndef add_three(\n    x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int\n) -> tuple[int, int]:\n    \"\"\"\n    Given the numerators and denominators of three fractions, return the\n    numerator and denominator of their sum in lowest form.\n    >>> add_three(1, 3, 1, 3, 1, 3)\n    (1, 1)\n    >>> add_three(2, 5, 4, 11, 12, 3)\n    (262, 55)\n    \"\"\"\n    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den\n    bottom: int = x_den * y_den * z_den\n    hcf: int = gcd(top, bottom)\n    top //= hcf\n    bottom //= hcf\n    return top, bottom\n\n\ndef solution(order: int = 35) -> int:\n    \"\"\"\n    Find the sum of the numerator and denominator of the sum of all s(x,y,z) for\n    golden triples (x,y,z) of the given order.\n\n    >>> solution(5)\n    296\n    >>> solution(10)\n    12519\n    >>> solution(20)\n    19408891927\n    \"\"\"\n    unique_s: set = set()\n    hcf: int\n    total: Fraction = Fraction(0)\n    fraction_sum: tuple[int, int]\n\n    for x_num in range(1, order + 1):\n        for x_den in range(x_num + 1, order + 1):\n            for y_num in range(1, order + 1):\n                for y_den in range(y_num + 1, order + 1):\n                    # n=1\n                    z_num = x_num * y_den + x_den * y_num\n                    z_den = x_den * y_den\n                    hcf = gcd(z_num, z_den)\n                    z_num //= hcf\n                    z_den //= hcf\n                    if 0 < z_num < z_den <= order:\n                        fraction_sum = add_three(\n                            x_num, x_den, y_num, y_den, z_num, z_den\n                        )\n                        unique_s.add(fraction_sum)\n\n                    # n=2\n                    z_num = (\n                        x_num * x_num * y_den * y_den + x_den * x_den * y_num * y_num\n                    )\n                    z_den = x_den * x_den * y_den * y_den\n                    if is_sq(z_num) and is_sq(z_den):\n                        z_num = int(sqrt(z_num))\n                        z_den = int(sqrt(z_den))\n                        hcf = gcd(z_num, z_den)\n                        z_num //= hcf\n                        z_den //= hcf\n                        if 0 < z_num < z_den <= order:\n                            fraction_sum = add_three(\n                                x_num, x_den, y_num, y_den, z_num, z_den\n                            )\n                            unique_s.add(fraction_sum)\n\n                    # n=-1\n                    z_num = x_num * y_num\n                    z_den = x_den * y_num + x_num * y_den\n                    hcf = gcd(z_num, z_den)\n                    z_num //= hcf\n                    z_den //= hcf\n                    if 0 < z_num < z_den <= order:\n                        fraction_sum = add_three(\n                            x_num, x_den, y_num, y_den, z_num, z_den\n                        )\n                        unique_s.add(fraction_sum)\n\n                    # n=2\n                    z_num = x_num * x_num * y_num * y_num\n                    z_den = (\n                        x_den * x_den * y_num * y_num + x_num * x_num * y_den * y_den\n                    )\n                    if is_sq(z_num) and is_sq(z_den):\n                        z_num = int(sqrt(z_num))\n                        z_den = int(sqrt(z_den))\n                        hcf = gcd(z_num, z_den)\n                        z_num //= hcf\n                        z_den //= hcf\n                        if 0 < z_num < z_den <= order:\n                            fraction_sum = add_three(\n                                x_num, x_den, y_num, y_den, z_num, z_den\n                            )\n                            unique_s.add(fraction_sum)\n\n    for num, den in unique_s:\n        total += Fraction(num, den)\n\n    return total.denominator + total.numerator\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_180/__init__.py": "", "project_euler/problem_097/sol1.py": "\"\"\"\nThe first known prime found to exceed one million digits was discovered in 1999,\nand is a Mersenne prime of the form 2**6972593 - 1; it contains exactly 2,098,960\ndigits. Subsequently other Mersenne primes, of the form 2**p - 1, have been found\nwhich contain more digits.\nHowever, in 2004 there was found a massive non-Mersenne prime which contains\n2,357,207 digits: (28433 * (2 ** 7830457 + 1)).\n\nFind the last ten digits of this prime number.\n\"\"\"\n\n\ndef solution(n: int = 10) -> str:\n    \"\"\"\n    Returns the last n digits of NUMBER.\n    >>> solution()\n    '8739992577'\n    >>> solution(8)\n    '39992577'\n    >>> solution(1)\n    '7'\n    >>> solution(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    >>> solution(8.3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    >>> solution(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Invalid input\")\n    modulus = 10**n\n    number = 28433 * (pow(2, 7830457, modulus)) + 1\n    return str(number % modulus)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(f\"{solution(10) = }\")\n", "project_euler/problem_097/__init__.py": "#\n", "project_euler/problem_077/sol1.py": "\"\"\"\nProject Euler Problem 77: https://projecteuler.net/problem=77\n\nIt is possible to write ten as the sum of primes in exactly five different ways:\n\n7 + 3\n5 + 5\n5 + 3 + 2\n3 + 3 + 2 + 2\n2 + 2 + 2 + 2 + 2\n\nWhat is the first value which can be written as the sum of primes in over\nfive thousand different ways?\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import lru_cache\nfrom math import ceil\n\nNUM_PRIMES = 100\n\nprimes = set(range(3, NUM_PRIMES, 2))\nprimes.add(2)\nprime: int\n\nfor prime in range(3, ceil(NUM_PRIMES**0.5), 2):\n    if prime not in primes:\n        continue\n    primes.difference_update(set(range(prime * prime, NUM_PRIMES, prime)))\n\n\n@lru_cache(maxsize=100)\ndef partition(number_to_partition: int) -> set[int]:\n    \"\"\"\n    Return a set of integers corresponding to unique prime partitions of n.\n    The unique prime partitions can be represented as unique prime decompositions,\n    e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36\n    >>> partition(10)\n    {32, 36, 21, 25, 30}\n    >>> partition(15)\n    {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126}\n    >>> len(partition(20))\n    26\n    \"\"\"\n    if number_to_partition < 0:\n        return set()\n    elif number_to_partition == 0:\n        return {1}\n\n    ret: set[int] = set()\n    prime: int\n    sub: int\n\n    for prime in primes:\n        if prime > number_to_partition:\n            continue\n        for sub in partition(number_to_partition - prime):\n            ret.add(sub * prime)\n\n    return ret\n\n\ndef solution(number_unique_partitions: int = 5000) -> int | None:\n    \"\"\"\n    Return the smallest integer that can be written as the sum of primes in over\n    m unique ways.\n    >>> solution(4)\n    10\n    >>> solution(500)\n    45\n    >>> solution(1000)\n    53\n    \"\"\"\n    for number_to_partition in range(1, NUM_PRIMES):\n        if len(partition(number_to_partition)) > number_unique_partitions:\n            return number_to_partition\n    return None\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_077/__init__.py": "", "project_euler/problem_086/sol1.py": "\"\"\"\nProject Euler Problem 86: https://projecteuler.net/problem=86\n\nA spider, S, sits in one corner of a cuboid room, measuring 6 by 5 by 3, and a fly, F,\nsits in the opposite corner. By travelling on the surfaces of the room the shortest\n\"straight line\" distance from S to F is 10 and the path is shown on the diagram.\n\ufffc\nHowever, there are up to three \"shortest\" path candidates for any given cuboid and the\nshortest route doesn't always have integer length.\n\nIt can be shown that there are exactly 2060 distinct cuboids, ignoring rotations, with\ninteger dimensions, up to a maximum size of M by M by M, for which the shortest route\nhas integer length when M = 100. This is the least value of M for which the number of\nsolutions first exceeds two thousand; the number of solutions when M = 99 is 1975.\n\nFind the least value of M such that the number of solutions first exceeds one million.\n\nSolution:\n    Label the 3 side-lengths of the cuboid a,b,c such that 1 <= a <= b <= c <= M.\n    By conceptually \"opening up\" the cuboid and laying out its faces on a plane,\n    it can be seen that the shortest distance between 2 opposite corners is\n    sqrt((a+b)^2 + c^2). This distance is an integer if and only if (a+b),c make up\n    the first 2 sides of a pythagorean triplet.\n\n    The second useful insight is rather than calculate the number of cuboids\n    with integral shortest distance for each maximum cuboid side-length M,\n    we can calculate this number iteratively each time we increase M, as follows.\n    The set of cuboids satisfying this property with maximum side-length M-1 is a\n    subset of the cuboids satisfying the property with maximum side-length M\n    (since any cuboids with side lengths <= M-1 are also <= M). To calculate the\n    number of cuboids in the larger set (corresponding to M) we need only consider\n    the cuboids which have at least one side of length M. Since we have ordered the\n    side lengths a <= b <= c, we can assume that c = M. Then we just need to count\n    the number of pairs a,b satisfying the conditions:\n        sqrt((a+b)^2 + M^2) is integer\n        1 <= a <= b <= M\n\n    To count the number of pairs (a,b) satisfying these conditions, write d = a+b.\n    Now we have:\n        1 <= a <= b <= M  =>  2 <= d <= 2*M\n                                   we can actually make the second equality strict,\n                                   since d = 2*M => d^2 + M^2 = 5M^2\n                                              => shortest distance = M * sqrt(5)\n                                              => not integral.\n        a + b = d => b = d - a\n                 and a <= b\n                  => a <= d/2\n                also a <= M\n                  => a <= min(M, d//2)\n\n        a + b = d => a = d - b\n                 and b <= M\n                  => a >= d - M\n                also a >= 1\n                  => a >= max(1, d - M)\n\n        So a is in range(max(1, d - M), min(M, d // 2) + 1)\n\n    For a given d, the number of cuboids satisfying the required property with c = M\n    and a + b = d is the length of this range, which is\n        min(M, d // 2) + 1 - max(1, d - M).\n\n    In the code below, d is sum_shortest_sides\n                   and M is max_cuboid_size.\n\n\n\"\"\"\n\nfrom math import sqrt\n\n\ndef solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the least value of M such that there are more than one million cuboids\n    of side lengths 1 <= a,b,c <= M such that the shortest distance between two\n    opposite vertices of the cuboid is integral.\n    >>> solution(100)\n    24\n    >>> solution(1000)\n    72\n    >>> solution(2000)\n    100\n    >>> solution(20000)\n    288\n    \"\"\"\n    num_cuboids: int = 0\n    max_cuboid_size: int = 0\n    sum_shortest_sides: int\n\n    while num_cuboids <= limit:\n        max_cuboid_size += 1\n        for sum_shortest_sides in range(2, 2 * max_cuboid_size + 1):\n            if sqrt(sum_shortest_sides**2 + max_cuboid_size**2).is_integer():\n                num_cuboids += (\n                    min(max_cuboid_size, sum_shortest_sides // 2)\n                    - max(1, sum_shortest_sides - max_cuboid_size)\n                    + 1\n                )\n\n    return max_cuboid_size\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_086/__init__.py": "", "project_euler/problem_002/sol2.py": "\"\"\"\nProject Euler Problem 2: https://projecteuler.net/problem=2\n\nEven Fibonacci Numbers\n\nEach new term in the Fibonacci sequence is generated by adding the previous\ntwo terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed\nfour million, find the sum of the even-valued terms.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Fibonacci_number\n\"\"\"\n\n\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    even_fibs = []\n    a, b = 0, 1\n    while b <= n:\n        if b % 2 == 0:\n            even_fibs.append(b)\n        a, b = b, a + b\n    return sum(even_fibs)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_002/sol4.py": "\"\"\"\nProject Euler Problem 2: https://projecteuler.net/problem=2\n\nEven Fibonacci Numbers\n\nEach new term in the Fibonacci sequence is generated by adding the previous\ntwo terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed\nfour million, find the sum of the even-valued terms.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Fibonacci_number\n\"\"\"\n\nimport math\nfrom decimal import Decimal, getcontext\n\n\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    >>> solution(3.4)\n    2\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    getcontext().prec = 100\n    phi = (Decimal(5) ** Decimal(0.5) + 1) / Decimal(2)\n\n    index = (math.floor(math.log(n * (phi + 2), phi) - 1) // 3) * 3 + 2\n    num = Decimal(round(phi ** Decimal(index + 1))) / (phi + 2)\n    total = num // 2\n    return int(total)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_002/sol3.py": "\"\"\"\nProject Euler Problem 2: https://projecteuler.net/problem=2\n\nEven Fibonacci Numbers\n\nEach new term in the Fibonacci sequence is generated by adding the previous\ntwo terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed\nfour million, find the sum of the even-valued terms.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Fibonacci_number\n\"\"\"\n\n\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    a = 0\n    b = 2\n    count = 0\n    while 4 * b + a <= n:\n        a, b = b, 4 * b + a\n        count += a\n    return count + b\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_002/sol1.py": "\"\"\"\nProject Euler Problem 2: https://projecteuler.net/problem=2\n\nEven Fibonacci Numbers\n\nEach new term in the Fibonacci sequence is generated by adding the previous\ntwo terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed\nfour million, find the sum of the even-valued terms.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Fibonacci_number\n\"\"\"\n\n\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    i = 1\n    j = 2\n    total = 0\n    while j <= n:\n        if j % 2 == 0:\n            total += j\n        i, j = j, i + j\n\n    return total\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_002/__init__.py": "", "project_euler/problem_002/sol5.py": "\"\"\"\nProject Euler Problem 2: https://projecteuler.net/problem=2\n\nEven Fibonacci Numbers\n\nEach new term in the Fibonacci sequence is generated by adding the previous\ntwo terms. By starting with 1 and 2, the first 10 terms will be:\n\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\nBy considering the terms in the Fibonacci sequence whose values do not exceed\nfour million, find the sum of the even-valued terms.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Fibonacci_number\n\"\"\"\n\n\ndef solution(n: int = 4000000) -> int:\n    \"\"\"\n    Returns the sum of all even fibonacci sequence elements that are lower\n    or equal to n.\n\n    >>> solution(10)\n    10\n    >>> solution(15)\n    10\n    >>> solution(2)\n    2\n    >>> solution(1)\n    0\n    >>> solution(34)\n    44\n    \"\"\"\n\n    fib = [0, 1]\n    i = 0\n    while fib[i] <= n:\n        fib.append(fib[i] + fib[i + 1])\n        if fib[i + 2] > n:\n            break\n        i += 1\n    total = 0\n    for j in range(len(fib) - 1):\n        if fib[j] % 2 == 0:\n            total += fib[j]\n\n    return total\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_107/sol1.py": "\"\"\"\nThe following undirected network consists of seven vertices and twelve edges\nwith a total weight of 243.\n\ufffc\nThe same network can be represented by the matrix below.\n\n    A   B   C   D   E   F   G\nA   -   16  12  21  -   -   -\nB   16  -   -   17  20  -   -\nC   12  -   -   28  -   31  -\nD   21  17  28  -   18  19  23\nE   -   20  -   18  -   -   11\nF   -   -   31  19  -   -   27\nG   -   -   -   23  11  27  -\n\nHowever, it is possible to optimise the network by removing some edges and still\nensure that all points on the network remain connected. The network which achieves\nthe maximum saving is shown below. It has a weight of 93, representing a saving of\n243 - 93 = 150 from the original network.\n\nUsing network.txt (right click and 'Save Link/Target As...'), a 6K text file\ncontaining a network with forty vertices, and given in matrix form, find the maximum\nsaving which can be achieved by removing redundant edges whilst ensuring that the\nnetwork remains connected.\n\nSolution:\n    We use Prim's algorithm to find a Minimum Spanning Tree.\n    Reference: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections.abc import Mapping\n\nEdgeT = tuple[int, int]\n\n\nclass Graph:\n    \"\"\"\n    A class representing an undirected weighted graph.\n    \"\"\"\n\n    def __init__(self, vertices: set[int], edges: Mapping[EdgeT, int]) -> None:\n        self.vertices: set[int] = vertices\n        self.edges: dict[EdgeT, int] = {\n            (min(edge), max(edge)): weight for edge, weight in edges.items()\n        }\n\n    def add_edge(self, edge: EdgeT, weight: int) -> None:\n        \"\"\"\n        Add a new edge to the graph.\n        >>> graph = Graph({1, 2}, {(2, 1): 4})\n        >>> graph.add_edge((3, 1), 5)\n        >>> sorted(graph.vertices)\n        [1, 2, 3]\n        >>> sorted([(v,k) for k,v in graph.edges.items()])\n        [(4, (1, 2)), (5, (1, 3))]\n        \"\"\"\n        self.vertices.add(edge[0])\n        self.vertices.add(edge[1])\n        self.edges[(min(edge), max(edge))] = weight\n\n    def prims_algorithm(self) -> Graph:\n        \"\"\"\n        Run Prim's algorithm to find the minimum spanning tree.\n        Reference: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n        >>> graph = Graph({1,2,3,4},{(1,2):5, (1,3):10, (1,4):20, (2,4):30, (3,4):1})\n        >>> mst = graph.prims_algorithm()\n        >>> sorted(mst.vertices)\n        [1, 2, 3, 4]\n        >>> sorted(mst.edges)\n        [(1, 2), (1, 3), (3, 4)]\n        \"\"\"\n        subgraph: Graph = Graph({min(self.vertices)}, {})\n        min_edge: EdgeT\n        min_weight: int\n        edge: EdgeT\n        weight: int\n\n        while len(subgraph.vertices) < len(self.vertices):\n            min_weight = max(self.edges.values()) + 1\n            for edge, weight in self.edges.items():\n                if (edge[0] in subgraph.vertices) ^ (\n                    edge[1] in subgraph.vertices\n                ) and weight < min_weight:\n                    min_edge = edge\n                    min_weight = weight\n\n            subgraph.add_edge(min_edge, min_weight)\n\n        return subgraph\n\n\ndef solution(filename: str = \"p107_network.txt\") -> int:\n    \"\"\"\n    Find the maximum saving which can be achieved by removing redundant edges\n    whilst ensuring that the network remains connected.\n    >>> solution(\"test_network.txt\")\n    150\n    \"\"\"\n    script_dir: str = os.path.abspath(os.path.dirname(__file__))\n    network_file: str = os.path.join(script_dir, filename)\n    edges: dict[EdgeT, int] = {}\n    data: list[str]\n    edge1: int\n    edge2: int\n\n    with open(network_file) as f:\n        data = f.read().strip().split(\"\\n\")\n\n    adjaceny_matrix = [line.split(\",\") for line in data]\n\n    for edge1 in range(1, len(adjaceny_matrix)):\n        for edge2 in range(edge1):\n            if adjaceny_matrix[edge1][edge2] != \"-\":\n                edges[(edge2, edge1)] = int(adjaceny_matrix[edge1][edge2])\n\n    graph: Graph = Graph(set(range(len(adjaceny_matrix))), edges)\n\n    subgraph: Graph = graph.prims_algorithm()\n\n    initial_total: int = sum(graph.edges.values())\n    optimal_total: int = sum(subgraph.edges.values())\n\n    return initial_total - optimal_total\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_107/__init__.py": "", "project_euler/problem_036/sol1.py": "\"\"\"\nProject Euler Problem 36\nhttps://projecteuler.net/problem=36\n\nProblem Statement:\n\nDouble-base palindromes\nProblem 36\nThe decimal number, 585 = 10010010012 (binary), is palindromic in both bases.\n\nFind the sum of all numbers, less than one million, which are palindromic in\nbase 10 and base 2.\n\n(Please note that the palindromic number, in either base, may not include\nleading zeros.)\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef is_palindrome(n: int | str) -> bool:\n    \"\"\"\n    Return true if the input n is a palindrome.\n    Otherwise return false. n can be an integer or a string.\n\n    >>> is_palindrome(909)\n    True\n    >>> is_palindrome(908)\n    False\n    >>> is_palindrome('10101')\n    True\n    >>> is_palindrome('10111')\n    False\n    \"\"\"\n    n = str(n)\n    return n == n[::-1]\n\n\ndef solution(n: int = 1000000):\n    \"\"\"Return the sum of all numbers, less than n , which are palindromic in\n    base 10 and base 2.\n\n    >>> solution(1000000)\n    872187\n    >>> solution(500000)\n    286602\n    >>> solution(100000)\n    286602\n    >>> solution(1000)\n    1772\n    >>> solution(100)\n    157\n    >>> solution(10)\n    25\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    total = 0\n\n    for i in range(1, n):\n        if is_palindrome(i) and is_palindrome(bin(i).split(\"b\")[1]):\n            total += i\n    return total\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input().strip()))))\n", "project_euler/problem_036/__init__.py": "", "project_euler/problem_016/sol2.py": "\"\"\"\nProblem 16: https://projecteuler.net/problem=16\n\n2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\n\nWhat is the sum of the digits of the number 2^1000?\n\"\"\"\n\n\ndef solution(power: int = 1000) -> int:\n    \"\"\"Returns the sum of the digits of the number 2^power.\n\n    >>> solution(1000)\n    1366\n    >>> solution(50)\n    76\n    >>> solution(20)\n    31\n    >>> solution(15)\n    26\n    \"\"\"\n    n = 2**power\n    r = 0\n    while n:\n        r, n = r + n % 10, n // 10\n    return r\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input()).strip())))\n", "project_euler/problem_016/sol1.py": "\"\"\"\nProblem 16: https://projecteuler.net/problem=16\n\n2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\n\nWhat is the sum of the digits of the number 2^1000?\n\"\"\"\n\n\ndef solution(power: int = 1000) -> int:\n    \"\"\"Returns the sum of the digits of the number 2^power.\n    >>> solution(1000)\n    1366\n    >>> solution(50)\n    76\n    >>> solution(20)\n    31\n    >>> solution(15)\n    26\n    \"\"\"\n    num = 2**power\n    string_num = str(num)\n    list_num = list(string_num)\n    sum_of_num = 0\n\n    for i in list_num:\n        sum_of_num += int(i)\n\n    return sum_of_num\n\n\nif __name__ == \"__main__\":\n    power = int(input(\"Enter the power of 2: \").strip())\n    print(\"2 ^ \", power, \" = \", 2**power)\n    result = solution(power)\n    print(\"Sum of the digits is: \", result)\n", "project_euler/problem_016/__init__.py": "", "project_euler/problem_121/sol1.py": "\"\"\"\nA bag contains one red disc and one blue disc. In a game of chance a player takes a\ndisc at random and its colour is noted. After each turn the disc is returned to the\nbag, an extra red disc is added, and another disc is taken at random.\n\nThe player pays \u00a31 to play and wins if they have taken more blue discs than red\ndiscs at the end of the game.\n\nIf the game is played for four turns, the probability of a player winning is exactly\n11/120, and so the maximum prize fund the banker should allocate for winning in this\ngame would be \u00a310 before they would expect to incur a loss. Note that any payout will\nbe a whole number of pounds and also includes the original \u00a31 paid to play the game,\nso in the example given the player actually wins \u00a39.\n\nFind the maximum prize fund that should be allocated to a single game in which\nfifteen turns are played.\n\n\nSolution:\n    For each 15-disc sequence of red and blue for which there are more red than blue,\n    we calculate the probability of that sequence and add it to the total probability\n    of the player winning. The inverse of this probability gives an upper bound for\n    the prize if the banker wants to avoid an expected loss.\n\"\"\"\n\nfrom itertools import product\n\n\ndef solution(num_turns: int = 15) -> int:\n    \"\"\"\n    Find the maximum prize fund that should be allocated to a single game in which\n    fifteen turns are played.\n    >>> solution(4)\n    10\n    >>> solution(10)\n    225\n    \"\"\"\n    total_prob: float = 0.0\n    prob: float\n    num_blue: int\n    num_red: int\n    ind: int\n    col: int\n    series: tuple[int, ...]\n\n    for series in product(range(2), repeat=num_turns):\n        num_blue = series.count(1)\n        num_red = num_turns - num_blue\n        if num_red >= num_blue:\n            continue\n        prob = 1.0\n        for ind, col in enumerate(series, 2):\n            if col == 0:\n                prob *= (ind - 1) / ind\n            else:\n                prob *= 1 / ind\n\n        total_prob += prob\n\n    return int(1 / total_prob)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_121/__init__.py": "", "project_euler/problem_014/sol2.py": "\"\"\"\nProblem 14: https://projecteuler.net/problem=14\n\nCollatz conjecture: start with any positive integer n. Next term obtained from\nthe previous term as follows:\n\nIf the previous term is even, the next term is one half the previous term.\nIf the previous term is odd, the next term is 3 times the previous term plus 1.\nThe conjecture states the sequence will always reach 1 regardless of starting\nn.\n\nProblem Statement:\nThe following iterative sequence is defined for the set of positive integers:\n\n    n \u2192 n/2 (n is even)\n    n \u2192 3n + 1 (n is odd)\n\nUsing the rule above and starting with 13, we generate the following sequence:\n\n    13 \u2192 40 \u2192 20 \u2192 10 \u2192 5 \u2192 16 \u2192 8 \u2192 4 \u2192 2 \u2192 1\n\nIt can be seen that this sequence (starting at 13 and finishing at 1) contains\n10 terms. Although it has not been proved yet (Collatz Problem), it is thought\nthat all starting numbers finish at 1.\n\nWhich starting number, under one million, produces the longest chain?\n\"\"\"\n\nfrom __future__ import annotations\n\nCOLLATZ_SEQUENCE_LENGTHS = {1: 1}\n\n\ndef collatz_sequence_length(n: int) -> int:\n    \"\"\"Returns the Collatz sequence length for n.\"\"\"\n    if n in COLLATZ_SEQUENCE_LENGTHS:\n        return COLLATZ_SEQUENCE_LENGTHS[n]\n    next_n = n // 2 if n % 2 == 0 else 3 * n + 1\n    sequence_length = collatz_sequence_length(next_n) + 1\n    COLLATZ_SEQUENCE_LENGTHS[n] = sequence_length\n    return sequence_length\n\n\ndef solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest Collatz sequence.\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n\n    result = max((collatz_sequence_length(i), i) for i in range(1, n))\n    return result[1]\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input().strip())))\n", "project_euler/problem_014/sol1.py": "\"\"\"\nProblem 14: https://projecteuler.net/problem=14\n\nProblem Statement:\nThe following iterative sequence is defined for the set of positive integers:\n\n    n \u2192 n/2 (n is even)\n    n \u2192 3n + 1 (n is odd)\n\nUsing the rule above and starting with 13, we generate the following sequence:\n\n    13 \u2192 40 \u2192 20 \u2192 10 \u2192 5 \u2192 16 \u2192 8 \u2192 4 \u2192 2 \u2192 1\n\nIt can be seen that this sequence (starting at 13 and finishing at 1) contains\n10 terms. Although it has not been proved yet (Collatz Problem), it is thought\nthat all starting numbers finish at 1.\n\nWhich starting number, under one million, produces the longest chain?\n\"\"\"\n\n\ndef solution(n: int = 1000000) -> int:\n    \"\"\"Returns the number under n that generates the longest sequence using the\n    formula:\n    n \u2192 n/2 (n is even)\n    n \u2192 3n + 1 (n is odd)\n\n    >>> solution(1000000)\n    837799\n    >>> solution(200)\n    171\n    >>> solution(5000)\n    3711\n    >>> solution(15000)\n    13255\n    \"\"\"\n    largest_number = 1\n    pre_counter = 1\n    counters = {1: 1}\n\n    for input1 in range(2, n):\n        counter = 0\n        number = input1\n\n        while True:\n            if number in counters:\n                counter += counters[number]\n                break\n            if number % 2 == 0:\n                number //= 2\n                counter += 1\n            else:\n                number = (3 * number) + 1\n                counter += 1\n\n        if input1 not in counters:\n            counters[input1] = counter\n\n        if counter > pre_counter:\n            largest_number = input1\n            pre_counter = counter\n    return largest_number\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input().strip())))\n", "project_euler/problem_014/__init__.py": "", "project_euler/problem_003/sol2.py": "\"\"\"\nProject Euler Problem 3: https://projecteuler.net/problem=3\n\nLargest prime factor\n\nThe prime factors of 13195 are 5, 7, 13 and 29.\n\nWhat is the largest prime factor of the number 600851475143?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number#Unique_factorization\n\"\"\"\n\n\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    prime = 1\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        prime = n\n    return int(prime)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_003/sol3.py": "\"\"\"\nProject Euler Problem 3: https://projecteuler.net/problem=3\n\nLargest prime factor\n\nThe prime factors of 13195 are 5, 7, 13 and 29.\n\nWhat is the largest prime factor of the number 600851475143?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number#Unique_factorization\n\"\"\"\n\n\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    i = 2\n    ans = 0\n    if n == 2:\n        return 2\n    while n > 2:\n        while n % i != 0:\n            i += 1\n        ans = i\n        while n % i == 0:\n            n = n // i\n        i += 1\n    return int(ans)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_003/sol1.py": "\"\"\"\nProject Euler Problem 3: https://projecteuler.net/problem=3\n\nLargest prime factor\n\nThe prime factors of 13195 are 5, 7, 13 and 29.\n\nWhat is the largest prime factor of the number 600851475143?\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number#Unique_factorization\n\"\"\"\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(n: int = 600851475143) -> int:\n    \"\"\"\n    Returns the largest prime factor of a given number n.\n\n    >>> solution(13195)\n    29\n    >>> solution(10)\n    5\n    >>> solution(17)\n    17\n    >>> solution(3.4)\n    3\n    >>> solution(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution(-17)\n    Traceback (most recent call last):\n        ...\n    ValueError: Parameter n must be greater than or equal to one.\n    >>> solution([])\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    >>> solution(\"asd\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Parameter n must be int or castable to int.\n    \"\"\"\n\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or castable to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater than or equal to one.\")\n    max_number = 0\n    if is_prime(n):\n        return n\n    while n % 2 == 0:\n        n //= 2\n    if is_prime(n):\n        return n\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            if is_prime(n // i):\n                max_number = n // i\n                break\n            elif is_prime(i):\n                max_number = i\n    return max_number\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_003/__init__.py": "", "project_euler/problem_044/sol1.py": "\"\"\"\nProblem 44: https://projecteuler.net/problem=44\n\nPentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten\npentagonal numbers are:\n1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...\nIt can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference,\n70 - 22 = 48, is not pentagonal.\n\nFind the pair of pentagonal numbers, Pj and Pk, for which their sum and difference\nare pentagonal and D = |Pk - Pj| is minimised; what is the value of D?\n\"\"\"\n\n\ndef is_pentagonal(n: int) -> bool:\n    \"\"\"\n    Returns True if n is pentagonal, False otherwise.\n    >>> is_pentagonal(330)\n    True\n    >>> is_pentagonal(7683)\n    False\n    >>> is_pentagonal(2380)\n    True\n    \"\"\"\n    root = (1 + 24 * n) ** 0.5\n    return ((1 + root) / 6) % 1 == 0\n\n\ndef solution(limit: int = 5000) -> int:\n    \"\"\"\n    Returns the minimum difference of two pentagonal numbers P1 and P2 such that\n    P1 + P2 is pentagonal and P2 - P1 is pentagonal.\n    >>> solution(5000)\n    5482660\n    \"\"\"\n    pentagonal_nums = [(i * (3 * i - 1)) // 2 for i in range(1, limit)]\n    for i, pentagonal_i in enumerate(pentagonal_nums):\n        for j in range(i, len(pentagonal_nums)):\n            pentagonal_j = pentagonal_nums[j]\n            a = pentagonal_i + pentagonal_j\n            b = pentagonal_j - pentagonal_i\n            if is_pentagonal(a) and is_pentagonal(b):\n                return b\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_044/__init__.py": "#\n", "project_euler/problem_064/sol1.py": "\"\"\"\nProject Euler Problem 64: https://projecteuler.net/problem=64\n\nAll square roots are periodic when written as continued fractions.\nFor example, let us consider sqrt(23).\nIt can be seen that the sequence is repeating.\nFor conciseness, we use the notation sqrt(23)=[4;(1,3,1,8)],\nto indicate that the block (1,3,1,8) repeats indefinitely.\nExactly four continued fractions, for N<=13, have an odd period.\nHow many continued fractions for N<=10000 have an odd period?\n\nReferences:\n- https://en.wikipedia.org/wiki/Continued_fraction\n\"\"\"\n\nfrom math import floor, sqrt\n\n\ndef continuous_fraction_period(n: int) -> int:\n    \"\"\"\n    Returns the continued fraction period of a number n.\n\n    >>> continuous_fraction_period(2)\n    1\n    >>> continuous_fraction_period(5)\n    1\n    >>> continuous_fraction_period(7)\n    4\n    >>> continuous_fraction_period(11)\n    2\n    >>> continuous_fraction_period(13)\n    5\n    \"\"\"\n    numerator = 0.0\n    denominator = 1.0\n    root = int(sqrt(n))\n    integer_part = root\n    period = 0\n    while integer_part != 2 * root:\n        numerator = denominator * integer_part - numerator\n        denominator = (n - numerator**2) / denominator\n        integer_part = int((root + numerator) / denominator)\n        period += 1\n    return period\n\n\ndef solution(n: int = 10000) -> int:\n    \"\"\"\n    Returns the count of numbers <= 10000 with odd periods.\n    This function calls continuous_fraction_period for numbers which are\n    not perfect squares.\n    This is checked in if sr - floor(sr) != 0 statement.\n    If an odd period is returned by continuous_fraction_period,\n    count_odd_periods is increased by 1.\n\n    >>> solution(2)\n    1\n    >>> solution(5)\n    2\n    >>> solution(7)\n    2\n    >>> solution(11)\n    3\n    >>> solution(13)\n    4\n    \"\"\"\n    count_odd_periods = 0\n    for i in range(2, n + 1):\n        sr = sqrt(i)\n        if sr - floor(sr) != 0 and continuous_fraction_period(i) % 2 == 1:\n            count_odd_periods += 1\n    return count_odd_periods\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution(int(input().strip()))}\")\n", "project_euler/problem_064/__init__.py": "", "project_euler/problem_131/sol1.py": "\"\"\"\nProject Euler Problem 131: https://projecteuler.net/problem=131\n\nThere are some prime values, p, for which there exists a positive integer, n,\nsuch that the expression n^3 + n^2p is a perfect cube.\n\nFor example, when p = 19, 8^3 + 8^2 x 19 = 12^3.\n\nWhat is perhaps most surprising is that for each prime with this property\nthe value of n is unique, and there are only four such primes below one-hundred.\n\nHow many primes below one million have this remarkable property?\n\"\"\"\n\nfrom math import isqrt\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"\n    Determines whether number is prime\n\n    >>> is_prime(3)\n    True\n\n    >>> is_prime(4)\n    False\n    \"\"\"\n\n    return all(number % divisor != 0 for divisor in range(2, isqrt(number) + 1))\n\n\ndef solution(max_prime: int = 10**6) -> int:\n    \"\"\"\n    Returns number of primes below max_prime with the property\n\n    >>> solution(100)\n    4\n    \"\"\"\n\n    primes_count = 0\n    cube_index = 1\n    prime_candidate = 7\n    while prime_candidate < max_prime:\n        primes_count += is_prime(prime_candidate)\n\n        cube_index += 1\n        prime_candidate += 6 * cube_index\n\n    return primes_count\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_131/__init__.py": "", "project_euler/problem_067/sol2.py": "\"\"\"\nProblem Statement:\nBy starting at the top of the triangle below and moving to adjacent numbers on\nthe row below, the maximum total from top to bottom is 23.\n3\n7 4\n2 4 6\n8 5 9 3\nThat is, 3 + 7 + 4 + 9 = 23.\nFind the maximum total from top to bottom in triangle.txt (right click and\n'Save Link/Target As...'), a 15K text file containing a triangle with\none-hundred rows.\n\"\"\"\n\nimport os\n\n\ndef solution() -> int:\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n    >>> solution()\n    7273\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle_path = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle_path) as in_file:\n        triangle = [[int(i) for i in line.split()] for line in in_file]\n\n    while len(triangle) != 1:\n        last_row = triangle.pop()\n        curr_row = triangle[-1]\n        for j in range(len(last_row) - 1):\n            curr_row[j] += max(last_row[j], last_row[j + 1])\n    return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_067/sol1.py": "\"\"\"\nProblem Statement:\nBy starting at the top of the triangle below and moving to adjacent numbers on\nthe row below, the maximum total from top to bottom is 23.\n3\n7 4\n2 4 6\n8 5 9 3\nThat is, 3 + 7 + 4 + 9 = 23.\nFind the maximum total from top to bottom in triangle.txt (right click and\n'Save Link/Target As...'), a 15K text file containing a triangle with\none-hundred rows.\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n\n    >>> solution()\n    7273\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = []\n    for line in triangle:\n        numbers_from_line = []\n        for number in line.strip().split(\" \"):\n            numbers_from_line.append(int(number))\n        a.append(numbers_from_line)\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_067/__init__.py": "", "project_euler/problem_114/sol1.py": "\"\"\"\nProject Euler Problem 114: https://projecteuler.net/problem=114\n\nA row measuring seven units in length has red blocks with a minimum length\nof three units placed on it, such that any two red blocks\n(which are allowed to be different lengths) are separated by at least one grey square.\nThere are exactly seventeen ways of doing this.\n\n    |g|g|g|g|g|g|g|    |r,r,r|g|g|g|g|\n\n    |g|r,r,r|g|g|g|    |g|g|r,r,r|g|g|\n\n    |g|g|g|r,r,r|g|    |g|g|g|g|r,r,r|\n\n    |r,r,r|g|r,r,r|    |r,r,r,r|g|g|g|\n\n    |g|r,r,r,r|g|g|    |g|g|r,r,r,r|g|\n\n    |g|g|g|r,r,r,r|    |r,r,r,r,r|g|g|\n\n    |g|r,r,r,r,r|g|    |g|g|r,r,r,r,r|\n\n    |r,r,r,r,r,r|g|    |g|r,r,r,r,r,r|\n\n    |r,r,r,r,r,r,r|\n\nHow many ways can a row measuring fifty units in length be filled?\n\nNOTE: Although the example above does not lend itself to the possibility,\nin general it is permitted to mix block sizes. For example,\non a row measuring eight units in length you could use red (3), grey (1), and red (4).\n\"\"\"\n\n\ndef solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of ways a row of the given length can be filled\n\n    >>> solution(7)\n    17\n    \"\"\"\n\n    ways_number = [1] * (length + 1)\n\n    for row_length in range(3, length + 1):\n        for block_length in range(3, row_length + 1):\n            for block_start in range(row_length - block_length):\n                ways_number[row_length] += ways_number[\n                    row_length - block_start - block_length - 1\n                ]\n\n            ways_number[row_length] += 1\n\n    return ways_number[length]\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_114/__init__.py": "", "project_euler/problem_188/sol1.py": "\"\"\"\nProject Euler Problem 188: https://projecteuler.net/problem=188\n\nThe hyperexponentiation of a number\n\nThe hyperexponentiation or tetration of a number a by a positive integer b,\ndenoted by a\u2191\u2191b or b^a, is recursively defined by:\n\na\u2191\u21911 = a,\na\u2191\u2191(k+1) = a(a\u2191\u2191k).\n\nThus we have e.g. 3\u2191\u21912 = 3^3 = 27, hence 3\u2191\u21913 = 3^27 = 7625597484987 and\n3\u2191\u21914 is roughly 103.6383346400240996*10^12.\n\nFind the last 8 digits of 1777\u2191\u21911855.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Tetration\n\"\"\"\n\n\n# small helper function for modular exponentiation (fast exponentiation algorithm)\ndef _modexpt(base: int, exponent: int, modulo_value: int) -> int:\n    \"\"\"\n    Returns the modular exponentiation, that is the value\n    of `base ** exponent % modulo_value`, without calculating\n    the actual number.\n    >>> _modexpt(2, 4, 10)\n    6\n    >>> _modexpt(2, 1024, 100)\n    16\n    >>> _modexpt(13, 65535, 7)\n    6\n    \"\"\"\n\n    if exponent == 1:\n        return base\n    if exponent % 2 == 0:\n        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value\n        return (x * x) % modulo_value\n    else:\n        return (base * _modexpt(base, exponent - 1, modulo_value)) % modulo_value\n\n\ndef solution(base: int = 1777, height: int = 1855, digits: int = 8) -> int:\n    \"\"\"\n    Returns the last 8 digits of the hyperexponentiation of base by\n    height, i.e. the number base\u2191\u2191height:\n\n    >>> solution(base=3, height=2)\n    27\n    >>> solution(base=3, height=3)\n    97484987\n    >>> solution(base=123, height=456, digits=4)\n    2547\n    \"\"\"\n\n    # calculate base\u2191\u2191height by right-assiciative repeated modular\n    # exponentiation\n    result = base\n    for _ in range(1, height):\n        result = _modexpt(base, result, 10**digits)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_188/__init__.py": "", "project_euler/problem_038/sol1.py": "\"\"\"\nProject Euler Problem 38: https://projecteuler.net/problem=38\n\nTake the number 192 and multiply it by each of 1, 2, and 3:\n\n192 x 1 = 192\n192 x 2 = 384\n192 x 3 = 576\n\nBy concatenating each product we get the 1 to 9 pandigital, 192384576. We will call\n192384576 the concatenated product of 192 and (1,2,3)\n\nThe same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5,\ngiving the pandigital, 918273645, which is the concatenated product of 9 and\n(1,2,3,4,5).\n\nWhat is the largest 1 to 9 pandigital 9-digit number that can be formed as the\nconcatenated product of an integer with (1,2, ... , n) where n > 1?\n\nSolution:\nSince n>1, the largest candidate for the solution will be a concactenation of\na 4-digit number and its double, a 5-digit number.\nLet a be the 4-digit number.\na  has 4 digits  =>  1000 <=  a  < 10000\n2a has 5 digits  => 10000 <= 2a  < 100000\n=>  5000 <= a < 10000\n\nThe concatenation of a with 2a = a * 10^5 + 2a\nso our candidate for a given a is 100002 * a.\nWe iterate through the search space 5000 <= a < 10000 in reverse order,\ncalculating the candidates for each a and checking if they are 1-9 pandigital.\n\nIn case there are no 4-digit numbers that satisfy this property, we check\nthe 3-digit numbers with a similar formula (the example a=192 gives a lower\nbound on the length of a):\na has 3 digits, etc...\n=>  100 <= a < 334, candidate = a * 10^6 + 2a * 10^3 + 3a\n                              = 1002003 * a\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef is_9_pandigital(n: int) -> bool:\n    \"\"\"\n    Checks whether n is a 9-digit 1 to 9 pandigital number.\n    >>> is_9_pandigital(12345)\n    False\n    >>> is_9_pandigital(156284973)\n    True\n    >>> is_9_pandigital(1562849733)\n    False\n    \"\"\"\n    s = str(n)\n    return len(s) == 9 and set(s) == set(\"123456789\")\n\n\ndef solution() -> int | None:\n    \"\"\"\n    Return the largest 1 to 9 pandigital 9-digital number that can be formed as the\n    concatenated product of an integer with (1,2,...,n) where n > 1.\n    \"\"\"\n    for base_num in range(9999, 4999, -1):\n        candidate = 100002 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    for base_num in range(333, 99, -1):\n        candidate = 1002003 * base_num\n        if is_9_pandigital(candidate):\n            return candidate\n\n    return None\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_038/__init__.py": "", "project_euler/problem_052/sol1.py": "\"\"\"\nPermuted multiples\nProblem 52\n\nIt can be seen that the number, 125874, and its double, 251748, contain exactly\nthe same digits, but in a different order.\n\nFind the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x,\ncontain the same digits.\n\"\"\"\n\n\ndef solution():\n    \"\"\"Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and\n    6x, contain the same digits.\n\n    >>> solution()\n    142857\n    \"\"\"\n    i = 1\n\n    while True:\n        if (\n            sorted(str(i))\n            == sorted(str(2 * i))\n            == sorted(str(3 * i))\n            == sorted(str(4 * i))\n            == sorted(str(5 * i))\n            == sorted(str(6 * i))\n        ):\n            return i\n\n        i += 1\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_052/__init__.py": "", "project_euler/problem_587/sol1.py": "\"\"\"\nProject Euler Problem 587: https://projecteuler.net/problem=587\n\nA square is drawn around a circle as shown in the diagram below on the left.\nWe shall call the blue shaded region the L-section.\nA line is drawn from the bottom left of the square to the top right\nas shown in the diagram on the right.\nWe shall call the orange shaded region a concave triangle.\n\nIt should be clear that the concave triangle occupies exactly half of the L-section.\n\nTwo circles are placed next to each other horizontally,\na rectangle is drawn around both circles, and\na line is drawn from the bottom left to the top right as shown in the diagram below.\n\nThis time the concave triangle occupies approximately 36.46% of the L-section.\n\nIf n circles are placed next to each other horizontally,\na rectangle is drawn around the n circles, and\na line is drawn from the bottom left to the top right,\nthen it can be shown that the least value of n\nfor which the concave triangle occupies less than 10% of the L-section is n = 15.\n\nWhat is the least value of n\nfor which the concave triangle occupies less than 0.1% of the L-section?\n\"\"\"\n\nfrom itertools import count\nfrom math import asin, pi, sqrt\n\n\ndef circle_bottom_arc_integral(point: float) -> float:\n    \"\"\"\n    Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)\n\n    >>> circle_bottom_arc_integral(0)\n    0.39269908169872414\n\n    >>> circle_bottom_arc_integral(1 / 2)\n    0.44634954084936207\n\n    >>> circle_bottom_arc_integral(1)\n    0.5\n    \"\"\"\n\n    return (\n        (1 - 2 * point) * sqrt(point - point**2) + 2 * point + asin(sqrt(1 - point))\n    ) / 4\n\n\ndef concave_triangle_area(circles_number: int) -> float:\n    \"\"\"\n    Returns area of concave triangle\n\n    >>> concave_triangle_area(1)\n    0.026825229575318944\n\n    >>> concave_triangle_area(2)\n    0.01956236140083944\n    \"\"\"\n\n    intersection_y = (circles_number + 1 - sqrt(2 * circles_number)) / (\n        2 * (circles_number**2 + 1)\n    )\n    intersection_x = circles_number * intersection_y\n\n    triangle_area = intersection_x * intersection_y / 2\n    concave_region_area = circle_bottom_arc_integral(\n        1 / 2\n    ) - circle_bottom_arc_integral(intersection_x)\n\n    return triangle_area + concave_region_area\n\n\ndef solution(fraction: float = 1 / 1000) -> int:\n    \"\"\"\n    Returns least value of n\n    for which the concave triangle occupies less than fraction of the L-section\n\n    >>> solution(1 / 10)\n    15\n    \"\"\"\n\n    l_section_area = (1 - pi / 4) / 4\n\n    for n in count(1):\n        if concave_triangle_area(n) / l_section_area < fraction:\n            return n\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_587/__init__.py": "", "project_euler/problem_173/sol1.py": "\"\"\"\nProject Euler Problem 173: https://projecteuler.net/problem=173\n\nWe shall define a square lamina to be a square outline with a square \"hole\" so that\nthe shape possesses vertical and horizontal symmetry. For example, using exactly\nthirty-two square tiles we can form two different square laminae:\n\nWith one-hundred tiles, and not necessarily using all of the tiles at one time, it is\npossible to form forty-one different square laminae.\n\nUsing up to one million tiles how many different square laminae can be formed?\n\"\"\"\n\nfrom math import ceil, sqrt\n\n\ndef solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the number of different square laminae that can be formed using up to\n    one million tiles.\n    >>> solution(100)\n    41\n    \"\"\"\n    answer = 0\n\n    for outer_width in range(3, (limit // 4) + 2):\n        if outer_width**2 > limit:\n            hole_width_lower_bound = max(ceil(sqrt(outer_width**2 - limit)), 1)\n        else:\n            hole_width_lower_bound = 1\n        if (outer_width - hole_width_lower_bound) % 2:\n            hole_width_lower_bound += 1\n\n        answer += (outer_width - hole_width_lower_bound - 2) // 2 + 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_173/__init__.py": "", "project_euler/problem_059/sol1.py": "\"\"\"\nEach character on a computer is assigned a unique code and the preferred standard is\nASCII (American Standard Code for Information Interchange).\nFor example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.\n\nA modern encryption method is to take a text file, convert the bytes to ASCII, then\nXOR each byte with a given value, taken from a secret key. The advantage with the\nXOR function is that using the same encryption key on the cipher text, restores\nthe plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.\n\nFor unbreakable encryption, the key is the same length as the plain text message, and\nthe key is made up of random bytes. The user would keep the encrypted message and the\nencryption key in different locations, and without both \"halves\", it is impossible to\ndecrypt the message.\n\nUnfortunately, this method is impractical for most users, so the modified method is\nto use a password as a key. If the password is shorter than the message, which is\nlikely, the key is repeated cyclically throughout the message. The balance for this\nmethod is using a sufficiently long password key for security, but short enough to\nbe memorable.\n\nYour task has been made easy, as the encryption key consists of three lower case\ncharacters. Using p059_cipher.txt (right click and 'Save Link/Target As...'), a\nfile containing the encrypted ASCII codes, and the knowledge that the plain text\nmust contain common English words, decrypt the message and find the sum of the ASCII\nvalues in the original text.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport string\nfrom itertools import cycle, product\nfrom pathlib import Path\n\nVALID_CHARS: str = (\n    string.ascii_letters + string.digits + string.punctuation + string.whitespace\n)\nLOWERCASE_INTS: list[int] = [ord(letter) for letter in string.ascii_lowercase]\nVALID_INTS: set[int] = {ord(char) for char in VALID_CHARS}\n\nCOMMON_WORDS: list[str] = [\"the\", \"be\", \"to\", \"of\", \"and\", \"in\", \"that\", \"have\"]\n\n\ndef try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:\n    \"\"\"\n    Given an encrypted message and a possible 3-character key, decrypt the message.\n    If the decrypted message contains a invalid character, i.e. not an ASCII letter,\n    a digit, punctuation or whitespace, then we know the key is incorrect, so return\n    None.\n    >>> try_key([0, 17, 20, 4, 27], (104, 116, 120))\n    'hello'\n    >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None\n    True\n    \"\"\"\n    decoded: str = \"\"\n    keychar: int\n    cipherchar: int\n    decodedchar: int\n\n    for keychar, cipherchar in zip(cycle(key), ciphertext):\n        decodedchar = cipherchar ^ keychar\n        if decodedchar not in VALID_INTS:\n            return None\n        decoded += chr(decodedchar)\n\n    return decoded\n\n\ndef filter_valid_chars(ciphertext: list[int]) -> list[str]:\n    \"\"\"\n    Given an encrypted message, test all 3-character strings to try and find the\n    key. Return a list of the possible decrypted messages.\n    >>> from itertools import cycle\n    >>> text = \"The enemy's gate is down\"\n    >>> key = \"end\"\n    >>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]\n    >>> text in filter_valid_chars(encoded)\n    True\n    \"\"\"\n    possibles: list[str] = []\n    for key in product(LOWERCASE_INTS, repeat=3):\n        encoded = try_key(ciphertext, key)\n        if encoded is not None:\n            possibles.append(encoded)\n    return possibles\n\n\ndef filter_common_word(possibles: list[str], common_word: str) -> list[str]:\n    \"\"\"\n    Given a list of possible decoded messages, narrow down the possibilities\n    for checking for the presence of a specified common word. Only decoded messages\n    containing common_word will be returned.\n    >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am')\n    ['I am here']\n    >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am')\n    ['athla amf', 'I am here']\n    \"\"\"\n    return [possible for possible in possibles if common_word in possible.lower()]\n\n\ndef solution(filename: str = \"p059_cipher.txt\") -> int:\n    \"\"\"\n    Test the ciphertext against all possible 3-character keys, then narrow down the\n    possibilities by filtering using common words until there's only one possible\n    decoded message.\n    >>> solution(\"test_cipher.txt\")\n    3000\n    \"\"\"\n    ciphertext: list[int]\n    possibles: list[str]\n    common_word: str\n    decoded_text: str\n    data: str = Path(__file__).parent.joinpath(filename).read_text(encoding=\"utf-8\")\n\n    ciphertext = [int(number) for number in data.strip().split(\",\")]\n\n    possibles = filter_valid_chars(ciphertext)\n    for common_word in COMMON_WORDS:\n        possibles = filter_common_word(possibles, common_word)\n        if len(possibles) == 1:\n            break\n\n    decoded_text = possibles[0]\n    return sum(ord(char) for char in decoded_text)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_059/__init__.py": "", "project_euler/problem_029/sol1.py": "\"\"\"\nConsider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:\n\n2^2=4,  2^3=8,   2^4=16,  2^5=32\n3^2=9,  3^3=27,  3^4=81,  3^5=243\n4^2=16, 4^3=64,  4^4=256, 4^5=1024\n5^2=25, 5^3=125, 5^4=625, 5^5=3125\n\nIf they are then placed in numerical order, with any repeats removed, we get\nthe following sequence of 15 distinct terms:\n\n4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125\n\nHow many distinct terms are in the sequence generated by ab\nfor 2 <= a <= 100 and 2 <= b <= 100?\n\"\"\"\n\n\ndef solution(n: int = 100) -> int:\n    \"\"\"Returns the number of distinct terms in the sequence generated by a^b\n    for 2 <= a <= 100 and 2 <= b <= 100.\n\n    >>> solution(100)\n    9183\n    >>> solution(50)\n    2184\n    >>> solution(20)\n    324\n    >>> solution(5)\n    15\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    collect_powers = set()\n\n    current_pow = 0\n\n    n = n + 1  # maximum limit\n\n    for a in range(2, n):\n        for b in range(2, n):\n            current_pow = a**b  # calculates the current power\n            collect_powers.add(current_pow)  # adds the result to the set\n    return len(collect_powers)\n\n\nif __name__ == \"__main__\":\n    print(\"Number of terms \", solution(int(str(input()).strip())))\n", "project_euler/problem_029/__init__.py": "", "project_euler/problem_081/sol1.py": "\"\"\"\nProblem 81: https://projecteuler.net/problem=81\nIn the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right,\nby only moving to the right and down, is indicated in bold red and is equal to 2427.\n\n    [131]   673   234    103    18\n    [201]  [96]  [342]   965   150\n     630   803   [746]  [422]  111\n     537   699   497    [121]  956\n     805   732   524    [37]  [331]\n\nFind the minimal path sum from the top left to the bottom right by only moving right\nand down in matrix.txt (https://projecteuler.net/project/resources/p081_matrix.txt),\na 31K text file containing an 80 by 80 matrix.\n\"\"\"\n\nimport os\n\n\ndef solution(filename: str = \"matrix.txt\") -> int:\n    \"\"\"\n    Returns the minimal path sum from the top left to the bottom right of the matrix.\n    >>> solution()\n    427337\n    \"\"\"\n    with open(os.path.join(os.path.dirname(__file__), filename)) as in_file:\n        data = in_file.read()\n\n    grid = [[int(cell) for cell in row.split(\",\")] for row in data.strip().splitlines()]\n    dp = [[0 for cell in row] for row in grid]\n    n = len(grid[0])\n\n    dp = [[0 for i in range(n)] for j in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[0][i] = grid[0][i] + dp[0][i - 1]\n    for i in range(1, n):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_081/__init__.py": "", "project_euler/problem_030/sol1.py": "\"\"\"Problem Statement (Digit Fifth Powers): https://projecteuler.net/problem=30\n\nSurprisingly there are only three numbers that can be written as the sum of fourth\npowers of their digits:\n\n1634 = 1^4 + 6^4 + 3^4 + 4^4\n8208 = 8^4 + 2^4 + 0^4 + 8^4\n9474 = 9^4 + 4^4 + 7^4 + 4^4\nAs 1 = 1^4 is not a sum it is not included.\n\nThe sum of these numbers is 1634 + 8208 + 9474 = 19316.\n\nFind the sum of all the numbers that can be written as the sum of fifth powers of their\ndigits.\n\n9^5 = 59049\n59049 * 7 = 413343 (which is only 6 digit number)\nSo, numbers greater than 999999 are rejected\nand also 59049 * 3 = 177147 (which exceeds the criteria of number being 3 digit)\nSo, number > 999\nand hence a number between 1000 and 1000000\n\"\"\"\n\nDIGITS_FIFTH_POWER = {str(digit): digit**5 for digit in range(10)}\n\n\ndef digits_fifth_powers_sum(number: int) -> int:\n    \"\"\"\n    >>> digits_fifth_powers_sum(1234)\n    1300\n    \"\"\"\n    return sum(DIGITS_FIFTH_POWER[digit] for digit in str(number))\n\n\ndef solution() -> int:\n    return sum(\n        number\n        for number in range(1000, 1000000)\n        if number == digits_fifth_powers_sum(number)\n    )\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_030/__init__.py": "", "project_euler/problem_037/sol1.py": "\"\"\"\nTruncatable primes\nProblem 37: https://projecteuler.net/problem=37\n\nThe number 3797 has an interesting property. Being prime itself, it is possible\nto continuously remove digits from left to right, and remain prime at each stage:\n3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.\n\nFind the sum of the only eleven primes that are both truncatable from left to right\nand right to left.\n\nNOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef list_truncated_nums(n: int) -> list[int]:\n    \"\"\"\n    Returns a list of all left and right truncated numbers of n\n    >>> list_truncated_nums(927628)\n    [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9]\n    >>> list_truncated_nums(467)\n    [467, 67, 46, 7, 4]\n    >>> list_truncated_nums(58)\n    [58, 8, 5]\n    \"\"\"\n    str_num = str(n)\n    list_nums = [n]\n    for i in range(1, len(str_num)):\n        list_nums.append(int(str_num[i:]))\n        list_nums.append(int(str_num[:-i]))\n    return list_nums\n\n\ndef validate(n: int) -> bool:\n    \"\"\"\n    To optimize the approach, we will rule out the numbers above 1000,\n    whose first or last three digits are not prime\n    >>> validate(74679)\n    False\n    >>> validate(235693)\n    False\n    >>> validate(3797)\n    True\n    \"\"\"\n    if len(str(n)) > 3 and (\n        not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3]))\n    ):\n        return False\n    return True\n\n\ndef compute_truncated_primes(count: int = 11) -> list[int]:\n    \"\"\"\n    Returns the list of truncated primes\n    >>> compute_truncated_primes(11)\n    [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397]\n    \"\"\"\n    list_truncated_primes: list[int] = []\n    num = 13\n    while len(list_truncated_primes) != count:\n        if validate(num):\n            list_nums = list_truncated_nums(num)\n            if all(is_prime(i) for i in list_nums):\n                list_truncated_primes.append(num)\n        num += 2\n    return list_truncated_primes\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the sum of truncated primes\n    \"\"\"\n    return sum(compute_truncated_primes(11))\n\n\nif __name__ == \"__main__\":\n    print(f\"{sum(compute_truncated_primes(11)) = }\")\n", "project_euler/problem_037/__init__.py": "#\n", "project_euler/problem_022/sol2.py": "\"\"\"\nName scores\nProblem 22\n\nUsing names.txt (right click and 'Save Link/Target As...'), a 46K text file\ncontaining over five-thousand first names, begin by sorting it into\nalphabetical order. Then working out the alphabetical value for each name,\nmultiply this value by its alphabetical position in the list to obtain a name\nscore.\n\nFor example, when the list is sorted into alphabetical order, COLIN, which is\nworth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would\nobtain a score of 938 x 53 = 49714.\n\nWhat is the total of all the name scores in the file?\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"Returns the total of all the name scores in the file.\n\n    >>> solution()\n    871198282\n    \"\"\"\n    total_sum = 0\n    temp_sum = 0\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        name = str(file.readlines()[0])\n        name = name.replace('\"', \"\").split(\",\")\n\n    name.sort()\n    for i in range(len(name)):\n        for j in name[i]:\n            temp_sum += ord(j) - ord(\"A\") + 1\n        total_sum += (i + 1) * temp_sum\n        temp_sum = 0\n    return total_sum\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_022/sol1.py": "\"\"\"\nName scores\nProblem 22\n\nUsing names.txt (right click and 'Save Link/Target As...'), a 46K text file\ncontaining over five-thousand first names, begin by sorting it into\nalphabetical order. Then working out the alphabetical value for each name,\nmultiply this value by its alphabetical position in the list to obtain a name\nscore.\n\nFor example, when the list is sorted into alphabetical order, COLIN, which is\nworth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would\nobtain a score of 938 x 53 = 49714.\n\nWhat is the total of all the name scores in the file?\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"Returns the total of all the name scores in the file.\n\n    >>> solution()\n    871198282\n    \"\"\"\n    with open(os.path.dirname(__file__) + \"/p022_names.txt\") as file:\n        names = str(file.readlines()[0])\n        names = names.replace('\"', \"\").split(\",\")\n\n    names.sort()\n\n    name_score = 0\n    total_score = 0\n\n    for i, name in enumerate(names):\n        for letter in name:\n            name_score += ord(letter) - 64\n\n        total_score += (i + 1) * name_score\n        name_score = 0\n    return total_score\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_022/__init__.py": "", "project_euler/problem_047/sol1.py": "\"\"\"\nCombinatoric selections\n\nProblem 47\n\nThe first two consecutive numbers to have two distinct prime factors are:\n\n14 = 2 x 7\n15 = 3 x 5\n\nThe first three consecutive numbers to have three distinct prime factors are:\n\n644 = 2\u00b2 x 7 x 23\n645 = 3 x 5 x 43\n646 = 2 x 17 x 19.\n\nFind the first four consecutive integers to have four distinct prime factors each.\nWhat is the first of these numbers?\n\"\"\"\n\nfrom functools import lru_cache\n\n\ndef unique_prime_factors(n: int) -> set:\n    \"\"\"\n    Find unique prime factors of an integer.\n    Tests include sorting because only the set really matters,\n    not the order in which it is produced.\n    >>> sorted(set(unique_prime_factors(14)))\n    [2, 7]\n    >>> sorted(set(unique_prime_factors(644)))\n    [2, 7, 23]\n    >>> sorted(set(unique_prime_factors(646)))\n    [2, 17, 19]\n    \"\"\"\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\n\n@lru_cache\ndef upf_len(num: int) -> int:\n    \"\"\"\n    Memoize upf() length results for a given value.\n    >>> upf_len(14)\n    2\n    \"\"\"\n    return len(unique_prime_factors(num))\n\n\ndef equality(iterable: list) -> bool:\n    \"\"\"\n    Check equality of ALL elements in an iterable\n    >>> equality([1, 2, 3, 4])\n    False\n    >>> equality([2, 2, 2, 2])\n    True\n    >>> equality([1, 2, 3, 2, 1])\n    False\n    \"\"\"\n    return len(set(iterable)) in (0, 1)\n\n\ndef run(n: int) -> list:\n    \"\"\"\n    Runs core process to find problem solution.\n    >>> run(3)\n    [644, 645, 646]\n    \"\"\"\n\n    # Incrementor variable for our group list comprehension.\n    # This serves as the first number in each list of values\n    # to test.\n    base = 2\n\n    while True:\n        # Increment each value of a generated range\n        group = [base + i for i in range(n)]\n\n        # Run elements through out unique_prime_factors function\n        # Append our target number to the end.\n        checker = [upf_len(x) for x in group]\n        checker.append(n)\n\n        # If all numbers in the list are equal, return the group variable.\n        if equality(checker):\n            return group\n\n        # Increment our base variable by 1\n        base += 1\n\n\ndef solution(n: int = 4) -> int:\n    \"\"\"Return the first value of the first four consecutive integers to have four\n    distinct prime factors each.\n    >>> solution()\n    134043\n    \"\"\"\n    results = run(n)\n    return results[0] if len(results) else None\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_047/__init__.py": "", "project_euler/problem_051/sol1.py": "\"\"\"\nhttps://projecteuler.net/problem=51\nPrime digit replacements\nProblem 51\n\nBy replacing the 1st digit of the 2-digit number *3, it turns out that six of\nthe nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.\n\nBy replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit\nnumber is the first example having seven primes among the ten generated numbers,\nyielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993.\nConsequently 56003, being the first member of this family, is the smallest prime\nwith this property.\n\nFind the smallest prime which, by replacing part of the number (not necessarily\nadjacent digits) with the same digit, is part of an eight prime value family.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import Counter\n\n\ndef prime_sieve(n: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a certain number\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * n\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(n**0.5 + 1), 2):\n        index = i * 2\n        while index < n:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, n, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes\n\n\ndef digit_replacements(number: int) -> list[list[int]]:\n    \"\"\"\n    Returns all the possible families of digit replacements in a number which\n    contains at least one repeating digit\n\n    >>> digit_replacements(544)\n    [[500, 511, 522, 533, 544, 555, 566, 577, 588, 599]]\n\n    >>> digit_replacements(3112)\n    [[3002, 3112, 3222, 3332, 3442, 3552, 3662, 3772, 3882, 3992]]\n    \"\"\"\n    number_str = str(number)\n    replacements = []\n    digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n    for duplicate in Counter(number_str) - Counter(set(number_str)):\n        family = [int(number_str.replace(duplicate, digit)) for digit in digits]\n        replacements.append(family)\n\n    return replacements\n\n\ndef solution(family_length: int = 8) -> int:\n    \"\"\"\n    Returns the solution of the problem\n\n    >>> solution(2)\n    229399\n\n    >>> solution(3)\n    221311\n    \"\"\"\n    numbers_checked = set()\n\n    # Filter primes with less than 3 replaceable digits\n    primes = {\n        x for x in set(prime_sieve(1_000_000)) if len(str(x)) - len(set(str(x))) >= 3\n    }\n\n    for prime in primes:\n        if prime in numbers_checked:\n            continue\n\n        replacements = digit_replacements(prime)\n\n        for family in replacements:\n            numbers_checked.update(family)\n            primes_in_family = primes.intersection(family)\n\n            if len(primes_in_family) != family_length:\n                continue\n\n            return min(primes_in_family)\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_051/__init__.py": "", "project_euler/problem_043/sol1.py": "\"\"\"\nProblem 43: https://projecteuler.net/problem=43\n\nThe number, 1406357289, is a 0 to 9 pandigital number because it is made up of\neach of the digits 0 to 9 in some order, but it also has a rather interesting\nsub-string divisibility property.\n\nLet d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note\nthe following:\n\nd2d3d4=406 is divisible by 2\nd3d4d5=063 is divisible by 3\nd4d5d6=635 is divisible by 5\nd5d6d7=357 is divisible by 7\nd6d7d8=572 is divisible by 11\nd7d8d9=728 is divisible by 13\nd8d9d10=289 is divisible by 17\nFind the sum of all 0 to 9 pandigital numbers with this property.\n\"\"\"\n\nfrom itertools import permutations\n\n\ndef is_substring_divisible(num: tuple) -> bool:\n    \"\"\"\n    Returns True if the pandigital number passes\n    all the divisibility tests.\n    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))\n    False\n    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))\n    False\n    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))\n    True\n    \"\"\"\n    if num[3] % 2 != 0:\n        return False\n\n    if (num[2] + num[3] + num[4]) % 3 != 0:\n        return False\n\n    if num[5] % 5 != 0:\n        return False\n\n    tests = [7, 11, 13, 17]\n    for i, test in enumerate(tests):\n        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:\n            return False\n    return True\n\n\ndef solution(n: int = 10) -> int:\n    \"\"\"\n    Returns the sum of all pandigital numbers which pass the\n    divisibility tests.\n    >>> solution(10)\n    16695334890\n    \"\"\"\n    return sum(\n        int(\"\".join(map(str, num)))\n        for num in permutations(range(n))\n        if is_substring_divisible(num)\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_043/__init__.py": "#\n", "project_euler/problem_116/sol1.py": "\"\"\"\nProject Euler Problem 116: https://projecteuler.net/problem=116\n\nA row of five grey square tiles is to have a number of its tiles\nreplaced with coloured oblong tiles chosen\nfrom red (length two), green (length three), or blue (length four).\n\nIf red tiles are chosen there are exactly seven ways this can be done.\n\n    |red,red|grey|grey|grey|    |grey|red,red|grey|grey|\n\n    |grey|grey|red,red|grey|    |grey|grey|grey|red,red|\n\n    |red,red|red,red|grey|      |red,red|grey|red,red|\n\n    |grey|red,red|red,red|\n\nIf green tiles are chosen there are three ways.\n\n    |green,green,green|grey|grey|    |grey|green,green,green|grey|\n\n    |grey|grey|green,green,green|\n\nAnd if blue tiles are chosen there are two ways.\n\n    |blue,blue,blue,blue|grey|    |grey|blue,blue,blue,blue|\n\nAssuming that colours cannot be mixed there are 7 + 3 + 2 = 12 ways\nof replacing the grey tiles in a row measuring five units in length.\n\nHow many different ways can the grey tiles in a row measuring fifty units in length\nbe replaced if colours cannot be mixed and at least one coloured tile must be used?\n\nNOTE: This is related to Problem 117 (https://projecteuler.net/problem=117).\n\"\"\"\n\n\ndef solution(length: int = 50) -> int:\n    \"\"\"\n    Returns the number of different ways can the grey tiles in a row\n    of the given length be replaced if colours cannot be mixed\n    and at least one coloured tile must be used\n\n    >>> solution(5)\n    12\n    \"\"\"\n\n    different_colour_ways_number = [[0] * 3 for _ in range(length + 1)]\n\n    for row_length in range(length + 1):\n        for tile_length in range(2, 5):\n            for tile_start in range(row_length - tile_length + 1):\n                different_colour_ways_number[row_length][tile_length - 2] += (\n                    different_colour_ways_number[row_length - tile_start - tile_length][\n                        tile_length - 2\n                    ]\n                    + 1\n                )\n\n    return sum(different_colour_ways_number[length])\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_116/__init__.py": "", "project_euler/problem_042/__init__.py": "", "project_euler/problem_042/solution42.py": "\"\"\"\nThe nth term of the sequence of triangle numbers is given by, tn = \u00bdn(n+1); so\nthe first ten triangle numbers are:\n\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n\nBy converting each letter in a word to a number corresponding to its\nalphabetical position and adding these values we form a word value. For example,\nthe word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a\ntriangle number then we shall call the word a triangle word.\n\nUsing words.txt (right click and 'Save Link/Target As...'), a 16K text file\ncontaining nearly two-thousand common English words, how many are triangle\nwords?\n\"\"\"\n\nimport os\n\n# Precomputes a list of the 100 first triangular numbers\nTRIANGULAR_NUMBERS = [int(0.5 * n * (n + 1)) for n in range(1, 101)]\n\n\ndef solution():\n    \"\"\"\n    Finds the amount of triangular words in the words file.\n\n    >>> solution()\n    162\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    words_file_path = os.path.join(script_dir, \"words.txt\")\n\n    words = \"\"\n    with open(words_file_path) as f:\n        words = f.readline()\n\n    words = [word.strip('\"') for word in words.strip(\"\\r\\n\").split(\",\")]\n    words = [\n        word\n        for word in [sum(ord(x) - 64 for x in word) for word in words]\n        if word in TRIANGULAR_NUMBERS\n    ]\n    return len(words)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_018/solution.py": "\"\"\"\nBy starting at the top of the triangle below and moving to adjacent numbers on\nthe row below, the maximum total from top to bottom is 23.\n\n3\n7 4\n2 4 6\n8 5 9 3\n\nThat is, 3 + 7 + 4 + 9 = 23.\n\nFind the maximum total from top to bottom of the triangle below:\n\n75\n95 64\n17 47 82\n18 35 87 10\n20 04 82 47 65\n19 01 23 75 03 34\n88 02 77 73 07 63 67\n99 65 04 28 06 16 70 92\n41 41 26 56 83 40 80 70 33\n41 48 72 33 47 32 37 16 94 29\n53 71 44 65 25 43 91 52 97 51 14\n70 11 33 28 77 73 17 78 39 68 17 57\n91 71 52 38 17 14 91 43 58 50 27 29 48\n63 66 04 68 89 53 67 30 73 16 69 87 40 31\n04 62 98 27 23 09 70 98 73 93 38 53 60 04 23\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"\n    Finds the maximum total in a triangle as described by the problem statement\n    above.\n\n    >>> solution()\n    1074\n    \"\"\"\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n    triangle = os.path.join(script_dir, \"triangle.txt\")\n\n    with open(triangle) as f:\n        triangle = f.readlines()\n\n    a = [[int(y) for y in x.rstrip(\"\\r\\n\").split(\" \")] for x in triangle]\n\n    for i in range(1, len(a)):\n        for j in range(len(a[i])):\n            number1 = a[i - 1][j] if j != len(a[i - 1]) else 0\n            number2 = a[i - 1][j - 1] if j > 0 else 0\n            a[i][j] += max(number1, number2)\n    return max(a[-1])\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_018/__init__.py": "", "project_euler/problem_048/sol1.py": "\"\"\"\nSelf Powers\nProblem 48\n\nThe series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.\n\nFind the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\"\"\"\n\n\ndef solution():\n    \"\"\"\n    Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\n    >>> solution()\n    '9110846700'\n    \"\"\"\n    total = 0\n    for i in range(1, 1001):\n        total += i**i\n    return str(total)[-10:]\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_048/__init__.py": "", "project_euler/problem_129/sol1.py": "\"\"\"\nProject Euler Problem 129: https://projecteuler.net/problem=129\n\nA number consisting entirely of ones is called a repunit. We shall define R(k) to be\na repunit of length k; for example, R(6) = 111111.\n\nGiven that n is a positive integer and GCD(n, 10) = 1, it can be shown that there\nalways exists a value, k, for which R(k) is divisible by n, and let A(n) be the least\nsuch value of k; for example, A(7) = 6 and A(41) = 5.\n\nThe least value of n for which A(n) first exceeds ten is 17.\n\nFind the least value of n for which A(n) first exceeds one-million.\n\"\"\"\n\n\ndef least_divisible_repunit(divisor: int) -> int:\n    \"\"\"\n    Return the least value k such that the Repunit of length k is divisible by divisor.\n    >>> least_divisible_repunit(7)\n    6\n    >>> least_divisible_repunit(41)\n    5\n    >>> least_divisible_repunit(1234567)\n    34020\n    \"\"\"\n    if divisor % 5 == 0 or divisor % 2 == 0:\n        return 0\n    repunit = 1\n    repunit_index = 1\n    while repunit:\n        repunit = (10 * repunit + 1) % divisor\n        repunit_index += 1\n    return repunit_index\n\n\ndef solution(limit: int = 1000000) -> int:\n    \"\"\"\n    Return the least value of n for which least_divisible_repunit(n)\n    first exceeds limit.\n    >>> solution(10)\n    17\n    >>> solution(100)\n    109\n    >>> solution(1000)\n    1017\n    \"\"\"\n    divisor = limit - 1\n    if divisor % 2 == 0:\n        divisor += 1\n    while least_divisible_repunit(divisor) <= limit:\n        divisor += 2\n    return divisor\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_129/__init__.py": "", "project_euler/problem_206/sol1.py": "\"\"\"\nProject Euler Problem 206: https://projecteuler.net/problem=206\n\nFind the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0,\nwhere each \u201c_\u201d is a single digit.\n\n-----\n\nInstead of computing every single permutation of that number and going\nthrough a 10^9 search space, we can narrow it down considerably.\n\nIf the square ends in a 0, then the square root must also end in a 0. Thus,\nthe last missing digit must be 0 and the square root is a multiple of 10.\nWe can narrow the search space down to the first 8 digits and multiply the\nresult of that by 10 at the end.\n\nNow the last digit is a 9, which can only happen if the square root ends\nin a 3 or 7. From this point, we can try one of two different methods to find\nthe answer:\n\n1. Start at the lowest possible base number whose square would be in the\nformat, and count up. The base we would start at is 101010103, whose square is\nthe closest number to 10203040506070809. Alternate counting up by 4 and 6 so\nthe last digit of the base is always a 3 or 7.\n\n2. Start at the highest possible base number whose square would be in the\nformat, and count down. That base would be 138902663, whose square is the\nclosest number to 1929394959697989. Alternate counting down by 6 and 4 so the\nlast digit of the base is always a 3 or 7.\n\nThe solution does option 2 because the answer happens to be much closer to the\nstarting point.\n\"\"\"\n\n\ndef is_square_form(num: int) -> bool:\n    \"\"\"\n    Determines if num is in the form 1_2_3_4_5_6_7_8_9\n\n    >>> is_square_form(1)\n    False\n    >>> is_square_form(112233445566778899)\n    True\n    >>> is_square_form(123456789012345678)\n    False\n    \"\"\"\n    digit = 9\n\n    while num > 0:\n        if num % 10 != digit:\n            return False\n        num //= 100\n        digit -= 1\n\n    return True\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0\n    \"\"\"\n    num = 138902663\n\n    while not is_square_form(num * num):\n        if num % 10 == 3:\n            num -= 6  # (3 - 6) % 10 = 7\n        else:\n            num -= 4  # (7 - 4) % 10 = 3\n\n    return num * 10\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_206/__init__.py": "", "project_euler/problem_076/sol1.py": "\"\"\"\nCounting Summations\nProblem 76: https://projecteuler.net/problem=76\n\nIt is possible to write five as a sum in exactly six different ways:\n\n4 + 1\n3 + 2\n3 + 1 + 1\n2 + 2 + 1\n2 + 1 + 1 + 1\n1 + 1 + 1 + 1 + 1\n\nHow many different ways can one hundred be written as a sum of at least two\npositive integers?\n\"\"\"\n\n\ndef solution(m: int = 100) -> int:\n    \"\"\"\n    Returns the number of different ways the number m can be written as a\n    sum of at least two positive integers.\n\n    >>> solution(100)\n    190569291\n    >>> solution(50)\n    204225\n    >>> solution(30)\n    5603\n    >>> solution(10)\n    41\n    >>> solution(5)\n    6\n    >>> solution(3)\n    2\n    >>> solution(2)\n    1\n    >>> solution(1)\n    0\n    \"\"\"\n    memo = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n > k:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1] - 1\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input(\"Enter a number: \").strip())))\n", "project_euler/problem_076/__init__.py": "", "project_euler/problem_010/sol2.py": "\"\"\"\nProject Euler Problem 10: https://projecteuler.net/problem=10\n\nSummation of primes\n\nThe sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n\nFind the sum of all the primes below two million.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n\"\"\"\n\nimport math\nfrom collections.abc import Iterator\nfrom itertools import takewhile\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef prime_generator() -> Iterator[int]:\n    \"\"\"\n    Generate a list sequence of prime numbers\n    \"\"\"\n\n    num = 2\n    while True:\n        if is_prime(num):\n            yield num\n        num += 1\n\n\ndef solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(takewhile(lambda x: x < n, prime_generator()))\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_010/sol3.py": "\"\"\"\nProject Euler Problem 10: https://projecteuler.net/problem=10\n\nSummation of primes\n\nThe sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n\nFind the sum of all the primes below two million.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n    - https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\"\"\"\n\n\ndef solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n using Sieve of Eratosthenes:\n\n    The sieve of Eratosthenes is one of the most efficient ways to find all primes\n    smaller than n when n is smaller than 10 million.  Only for positive numbers.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    >>> solution(7.1)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> solution(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> solution(\"seven\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: can only concatenate str (not \"int\") to str\n    \"\"\"\n\n    primality_list = [0 for i in range(n + 1)]\n    primality_list[0] = 1\n    primality_list[1] = 1\n\n    for i in range(2, int(n**0.5) + 1):\n        if primality_list[i] == 0:\n            for j in range(i * i, n + 1, i):\n                primality_list[j] = 1\n    sum_of_primes = 0\n    for i in range(n):\n        if primality_list[i] == 0:\n            sum_of_primes += i\n    return sum_of_primes\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_010/sol1.py": "\"\"\"\nProject Euler Problem 10: https://projecteuler.net/problem=10\n\nSummation of primes\n\nThe sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n\nFind the sum of all the primes below two million.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Prime_number\n\"\"\"\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(n: int = 2000000) -> int:\n    \"\"\"\n    Returns the sum of all the primes below n.\n\n    >>> solution(1000)\n    76127\n    >>> solution(5000)\n    1548136\n    >>> solution(10000)\n    5736396\n    >>> solution(7)\n    10\n    \"\"\"\n\n    return sum(num for num in range(3, n, 2) if is_prime(num)) + 2 if n > 2 else 0\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_010/__init__.py": "", "project_euler/problem_020/sol2.py": "\"\"\"\nProblem 20: https://projecteuler.net/problem=20\n\nn! means n x (n - 1) x ... x 3 x 2 x 1\n\nFor example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800,\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\nFind the sum of the digits in the number 100!\n\"\"\"\n\nfrom math import factorial\n\n\ndef solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    return sum(int(x) for x in str(factorial(num)))\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input(\"Enter the Number: \").strip())))\n", "project_euler/problem_020/sol4.py": "\"\"\"\nProblem 20: https://projecteuler.net/problem=20\n\nn! means n x (n - 1) x ... x 3 x 2 x 1\n\nFor example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800,\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\nFind the sum of the digits in the number 100!\n\"\"\"\n\n\ndef solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    fact = 1\n    result = 0\n    for i in range(1, num + 1):\n        fact *= i\n\n    for j in str(fact):\n        result += int(j)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input(\"Enter the Number: \").strip())))\n", "project_euler/problem_020/sol3.py": "\"\"\"\nProblem 20: https://projecteuler.net/problem=20\n\nn! means n x (n - 1) x ... x 3 x 2 x 1\n\nFor example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800,\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\nFind the sum of the digits in the number 100!\n\"\"\"\n\nfrom math import factorial\n\n\ndef solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(1000)\n    10539\n    >>> solution(200)\n    1404\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    >>> solution(0)\n    1\n    \"\"\"\n    return sum(map(int, str(factorial(num))))\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input(\"Enter the Number: \").strip())))\n", "project_euler/problem_020/sol1.py": "\"\"\"\nProblem 20: https://projecteuler.net/problem=20\n\nn! means n x (n - 1) x ... x 3 x 2 x 1\n\nFor example, 10! = 10 x 9 x ... x 3 x 2 x 1 = 3628800,\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\nFind the sum of the digits in the number 100!\n\"\"\"\n\n\ndef factorial(num: int) -> int:\n    \"\"\"Find the factorial of a given number n\"\"\"\n    fact = 1\n    for i in range(1, num + 1):\n        fact *= i\n    return fact\n\n\ndef split_and_add(number: int) -> int:\n    \"\"\"Split number digits and add them.\"\"\"\n    sum_of_digits = 0\n    while number > 0:\n        last_digit = number % 10\n        sum_of_digits += last_digit\n        number = number // 10  # Removing the last_digit from the given number\n    return sum_of_digits\n\n\ndef solution(num: int = 100) -> int:\n    \"\"\"Returns the sum of the digits in the factorial of num\n    >>> solution(100)\n    648\n    >>> solution(50)\n    216\n    >>> solution(10)\n    27\n    >>> solution(5)\n    3\n    >>> solution(3)\n    6\n    >>> solution(2)\n    2\n    >>> solution(1)\n    1\n    \"\"\"\n    nfact = factorial(num)\n    result = split_and_add(nfact)\n    return result\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input(\"Enter the Number: \").strip())))\n", "project_euler/problem_020/__init__.py": "", "project_euler/problem_686/sol1.py": "\"\"\"\nProject Euler Problem 686: https://projecteuler.net/problem=686\n\n2^7 = 128 is the first power of two whose leading digits are \"12\".\nThe next power of two whose leading digits are \"12\" is 2^80.\n\nDefine p(L,n) to be the nth-smallest value of j such that\nthe base 10 representation of 2^j begins with the digits of L.\n\nSo p(12, 1) = 7 and p(12, 2) = 80.\n\nYou are given that p(123, 45) = 12710.\n\nFind p(123, 678910).\n\"\"\"\n\nimport math\n\n\ndef log_difference(number: int) -> float:\n    \"\"\"\n    This function returns the decimal value of a number multiplied with log(2)\n    Since the problem is on powers of two, finding the powers of two with\n    large exponents is time consuming. Hence we use log to reduce compute time.\n\n    We can find out that the first power of 2 with starting digits 123 is 90.\n    Computing 2^90 is time consuming.\n    Hence we find log(2^90) = 90*log(2) = 27.092699609758302\n    But we require only the decimal part to determine whether the power starts with 123.\n    So we just return the decimal part of the log product.\n    Therefore we return 0.092699609758302\n\n    >>> log_difference(90)\n    0.092699609758302\n    >>> log_difference(379)\n    0.090368356648852\n\n    \"\"\"\n\n    log_number = math.log(2, 10) * number\n    difference = round((log_number - int(log_number)), 15)\n\n    return difference\n\n\ndef solution(number: int = 678910) -> int:\n    \"\"\"\n    This function calculates the power of two which is nth (n = number)\n    smallest value of power of 2\n    such that the starting digits of the 2^power is 123.\n\n    For example the powers of 2 for which starting digits is 123 are:\n    90, 379, 575, 864, 1060, 1545, 1741, 2030, 2226, 2515 and so on.\n    90 is the first power of 2 whose starting digits are 123,\n    379 is second power of 2 whose starting digits are 123,\n    and so on.\n\n    So if number = 10, then solution returns 2515 as we observe from above series.\n\n    We will define a lowerbound and upperbound.\n    lowerbound = log(1.23), upperbound = log(1.24)\n    because we need to find the powers that yield 123 as starting digits.\n\n    log(1.23) = 0.08990511143939792, log(1,24) = 0.09342168516223506.\n    We use 1.23 and not 12.3 or 123, because log(1.23) yields only decimal value\n    which is less than 1.\n    log(12.3) will be same decimal value but 1 added to it\n    which is log(12.3) = 1.093421685162235.\n    We observe that decimal value remains same no matter 1.23 or 12.3\n    Since we use the function log_difference(),\n    which returns the value that is only decimal part, using 1.23 is logical.\n\n    If we see, 90*log(2) = 27.092699609758302,\n    decimal part = 0.092699609758302, which is inside the range of lowerbound\n    and upperbound.\n\n    If we compute the difference between all the powers which lead to 123\n    starting digits is as follows:\n\n    379 - 90 = 289\n    575 - 379 = 196\n    864 - 575 = 289\n    1060 - 864 = 196\n\n    We see a pattern here. The difference is either 196 or 289 = 196 + 93.\n\n    Hence to optimize the algorithm we will increment by 196 or 93 depending upon the\n    log_difference() value.\n\n    Let's take for example 90.\n    Since 90 is the first power leading to staring digits as 123,\n    we will increment iterator by 196.\n    Because the difference between any two powers leading to 123\n    as staring digits is greater than or equal to 196.\n    After incrementing by 196 we get 286.\n\n    log_difference(286) = 0.09457875989861 which is greater than upperbound.\n    The next power is 379, and we need to add 93 to get there.\n    The iterator will now become 379,\n    which is the next power leading to 123 as starting digits.\n\n    Let's take 1060. We increment by 196, we get 1256.\n    log_difference(1256) = 0.09367455396034,\n    Which is greater than upperbound hence we increment by 93. Now iterator is 1349.\n    log_difference(1349) = 0.08946415071057 which is less than lowerbound.\n    The next power is 1545 and we need to add 196 to get 1545.\n\n    Conditions are as follows:\n\n    1) If we find a power whose log_difference() is in the range of\n    lower and upperbound, we will increment by 196.\n    which implies that the power is a number which will lead to 123 as starting digits.\n    2) If we find a power, whose log_difference() is greater than or equal upperbound,\n    we will increment by 93.\n    3) if log_difference() < lowerbound, we increment by 196.\n\n    Reference to the above logic:\n    https://math.stackexchange.com/questions/4093970/powers-of-2-starting-with-123-does-a-pattern-exist\n\n    >>> solution(1000)\n    284168\n\n    >>> solution(56000)\n    15924915\n\n    >>> solution(678910)\n    193060223\n\n    \"\"\"\n\n    power_iterator = 90\n    position = 0\n\n    lower_limit = math.log(1.23, 10)\n    upper_limit = math.log(1.24, 10)\n    previous_power = 0\n\n    while position < number:\n        difference = log_difference(power_iterator)\n\n        if difference >= upper_limit:\n            power_iterator += 93\n\n        elif difference < lower_limit:\n            power_iterator += 196\n\n        else:\n            previous_power = power_iterator\n            power_iterator += 196\n            position += 1\n\n    return previous_power\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(f\"{solution() = }\")\n", "project_euler/problem_686/__init__.py": "", "project_euler/problem_055/sol1.py": "\"\"\"\nLychrel numbers\nProblem 55: https://projecteuler.net/problem=55\n\nIf we take 47, reverse and add, 47 + 74 = 121, which is palindromic.\n\nNot all numbers produce palindromes so quickly. For example,\n349 + 943 = 1292,\n1292 + 2921 = 4213\n4213 + 3124 = 7337\nThat is, 349 took three iterations to arrive at a palindrome.\n\nAlthough no one has proved it yet, it is thought that some numbers, like 196,\nnever produce a palindrome. A number that never forms a palindrome through the\nreverse and add process is called a Lychrel number. Due to the theoretical nature\nof these numbers, and for the purpose of this problem, we shall assume that a number\nis Lychrel until proven otherwise. In addition you are given that for every number\nbelow ten-thousand, it will either (i) become a palindrome in less than fifty\niterations, or, (ii) no one, with all the computing power that exists, has managed\nso far to map it to a palindrome. In fact, 10677 is the first number to be shown\nto require over fifty iterations before producing a palindrome:\n4668731596684224866951378664 (53 iterations, 28-digits).\n\nSurprisingly, there are palindromic numbers that are themselves Lychrel numbers;\nthe first example is 4994.\nHow many Lychrel numbers are there below ten-thousand?\n\"\"\"\n\n\ndef is_palindrome(n: int) -> bool:\n    \"\"\"\n    Returns True if a number is palindrome.\n    >>> is_palindrome(12567321)\n    False\n    >>> is_palindrome(1221)\n    True\n    >>> is_palindrome(9876789)\n    True\n    \"\"\"\n    return str(n) == str(n)[::-1]\n\n\ndef sum_reverse(n: int) -> int:\n    \"\"\"\n    Returns the sum of n and reverse of n.\n    >>> sum_reverse(123)\n    444\n    >>> sum_reverse(3478)\n    12221\n    >>> sum_reverse(12)\n    33\n    \"\"\"\n    return int(n) + int(str(n)[::-1])\n\n\ndef solution(limit: int = 10000) -> int:\n    \"\"\"\n    Returns the count of all lychrel numbers below limit.\n    >>> solution(10000)\n    249\n    >>> solution(5000)\n    76\n    >>> solution(1000)\n    13\n    \"\"\"\n    lychrel_nums = []\n    for num in range(1, limit):\n        iterations = 0\n        a = num\n        while iterations < 50:\n            num = sum_reverse(num)\n            iterations += 1\n            if is_palindrome(num):\n                break\n        else:\n            lychrel_nums.append(a)\n    return len(lychrel_nums)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_055/__init__.py": "#\n", "project_euler/problem_078/sol1.py": "\"\"\"\nProblem 78\nUrl: https://projecteuler.net/problem=78\nStatement:\nLet p(n) represent the number of different ways in which n coins\ncan be separated into piles. For example, five coins can be separated\ninto piles in exactly seven different ways, so p(5)=7.\n\n            OOOOO\n            OOOO   O\n            OOO   OO\n            OOO   O   O\n            OO   OO   O\n            OO   O   O   O\n            O   O   O   O   O\nFind the least value of n for which p(n) is divisible by one million.\n\"\"\"\n\nimport itertools\n\n\ndef solution(number: int = 1000000) -> int:\n    \"\"\"\n    >>> solution(1)\n    1\n\n    >>> solution(9)\n    14\n\n    >>> solution()\n    55374\n    \"\"\"\n    partitions = [1]\n\n    for i in itertools.count(len(partitions)):\n        item = 0\n        for j in itertools.count(1):\n            sign = -1 if j % 2 == 0 else +1\n            index = (j * j * 3 - j) // 2\n            if index > i:\n                break\n            item += partitions[i - index] * sign\n            item %= number\n            index += j\n            if index > i:\n                break\n            item += partitions[i - index] * sign\n            item %= number\n\n        if item == 0:\n            return i\n        partitions.append(item)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(f\"{solution() = }\")\n", "project_euler/problem_078/__init__.py": "", "project_euler/problem_019/sol1.py": "\"\"\"\nCounting Sundays\nProblem 19\n\nYou are given the following information, but you may prefer to do some research\nfor yourself.\n\n1 Jan 1900 was a Monday.\nThirty days has September,\nApril, June and November.\nAll the rest have thirty-one,\nSaving February alone,\nWhich has twenty-eight, rain or shine.\nAnd on leap years, twenty-nine.\n\nA leap year occurs on any year evenly divisible by 4, but not on a century\nunless it is divisible by 400.\n\nHow many Sundays fell on the first of the month during the twentieth century\n(1 Jan 1901 to 31 Dec 2000)?\n\"\"\"\n\n\ndef solution():\n    \"\"\"Returns the number of mondays that fall on the first of the month during\n    the twentieth century (1 Jan 1901 to 31 Dec 2000)?\n\n    >>> solution()\n    171\n    \"\"\"\n    days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    day = 6\n    month = 1\n    year = 1901\n\n    sundays = 0\n\n    while year < 2001:\n        day += 7\n\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            if day > days_per_month[month - 1] and month != 2:\n                month += 1\n                day = day - days_per_month[month - 2]\n            elif day > 29 and month == 2:\n                month += 1\n                day = day - 29\n        elif day > days_per_month[month - 1]:\n            month += 1\n            day = day - days_per_month[month - 2]\n\n        if month > 12:\n            year += 1\n            month = 1\n\n        if year < 2001 and day == 1:\n            sundays += 1\n    return sundays\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_019/__init__.py": "", "project_euler/problem_080/sol1.py": "\"\"\"\nProject Euler Problem 80: https://projecteuler.net/problem=80\nAuthor: Sandeep Gupta\nProblem statement: For the first one hundred natural numbers, find the total of\nthe digital sums of the first one hundred decimal digits for all the irrational\nsquare roots.\nTime: 5 October 2020, 18:30\n\"\"\"\n\nimport decimal\n\n\ndef solution() -> int:\n    \"\"\"\n    To evaluate the sum, Used decimal python module to calculate the decimal\n    places up to 100, the most important thing would be take calculate\n    a few extra places for decimal otherwise there will be rounding\n    error.\n\n    >>> solution()\n    40886\n    \"\"\"\n    answer = 0\n    decimal_context = decimal.Context(prec=105)\n    for i in range(2, 100):\n        number = decimal.Decimal(i)\n        sqrt_number = number.sqrt(decimal_context)\n        if len(str(sqrt_number)) > 1:\n            answer += int(str(sqrt_number)[0])\n            sqrt_number_str = str(sqrt_number)[2:101]\n            answer += sum(int(x) for x in sqrt_number_str)\n    return answer\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{solution() = }\")\n", "project_euler/problem_080/__init__.py": "", "project_euler/problem_032/sol32.py": "\"\"\"\nWe shall say that an n-digit number is pandigital if it makes use of all the\ndigits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through\n5 pandigital.\n\nThe product 7254 is unusual, as the identity, 39 x 186 = 7254, containing\nmultiplicand, multiplier, and product is 1 through 9 pandigital.\n\nFind the sum of all products whose multiplicand/multiplier/product identity can\nbe written as a 1 through 9 pandigital.\n\nHINT: Some products can be obtained in more than one way so be sure to only\ninclude it once in your sum.\n\"\"\"\n\nimport itertools\n\n\ndef is_combination_valid(combination):\n    \"\"\"\n    Checks if a combination (a tuple of 9 digits)\n    is a valid product equation.\n\n    >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))\n    True\n\n    >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))\n    False\n\n    \"\"\"\n    return (\n        int(\"\".join(combination[0:2])) * int(\"\".join(combination[2:5]))\n        == int(\"\".join(combination[5:9]))\n    ) or (\n        int(\"\".join(combination[0])) * int(\"\".join(combination[1:5]))\n        == int(\"\".join(combination[5:9]))\n    )\n\n\ndef solution():\n    \"\"\"\n    Finds the sum of all products whose multiplicand/multiplier/product identity\n    can be written as a 1 through 9 pandigital\n\n    >>> solution()\n    45228\n    \"\"\"\n\n    return sum(\n        {\n            int(\"\".join(pandigital[5:9]))\n            for pandigital in itertools.permutations(\"123456789\")\n            if is_combination_valid(pandigital)\n        }\n    )\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_032/__init__.py": "", "project_euler/problem_123/sol1.py": "\"\"\"\nProblem 123: https://projecteuler.net/problem=123\n\nName: Prime square remainders\n\nLet pn be the nth prime: 2, 3, 5, 7, 11, ..., and\nlet r be the remainder when (pn-1)^n + (pn+1)^n is divided by pn^2.\n\nFor example, when n = 3, p3 = 5, and 43 + 63 = 280 \u2261 5 mod 25.\nThe least value of n for which the remainder first exceeds 10^9 is 7037.\n\nFind the least value of n for which the remainder first exceeds 10^10.\n\n\nSolution:\n\nn=1: (p-1) + (p+1) = 2p\nn=2: (p-1)^2 + (p+1)^2\n     = p^2 + 1 - 2p + p^2 + 1 + 2p  (Using (p+b)^2 = (p^2 + b^2 + 2pb),\n                                           (p-b)^2 = (p^2 + b^2 - 2pb) and b = 1)\n     = 2p^2 + 2\nn=3: (p-1)^3 + (p+1)^3  (Similarly using (p+b)^3 & (p-b)^3 formula and so on)\n     = 2p^3 + 6p\nn=4: 2p^4 + 12p^2 + 2\nn=5: 2p^5 + 20p^3 + 10p\n\nAs you could see, when the expression is divided by p^2.\nExcept for the last term, the rest will result in the remainder 0.\n\nn=1: 2p\nn=2: 2\nn=3: 6p\nn=4: 2\nn=5: 10p\n\nSo it could be simplified as,\n    r = 2pn when n is odd\n    r = 2   when n is even.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\n\n\ndef sieve() -> Generator[int, None, None]:\n    \"\"\"\n    Returns a prime number generator using sieve method.\n    >>> type(sieve())\n    <class 'generator'>\n    >>> primes = sieve()\n    >>> next(primes)\n    2\n    >>> next(primes)\n    3\n    >>> next(primes)\n    5\n    >>> next(primes)\n    7\n    >>> next(primes)\n    11\n    >>> next(primes)\n    13\n    \"\"\"\n    factor_map: dict[int, int] = {}\n    prime = 2\n    while True:\n        factor = factor_map.pop(prime, None)\n        if factor:\n            x = factor + prime\n            while x in factor_map:\n                x += factor\n            factor_map[x] = factor\n        else:\n            factor_map[prime * prime] = prime\n            yield prime\n        prime += 1\n\n\ndef solution(limit: float = 1e10) -> int:\n    \"\"\"\n    Returns the least value of n for which the remainder first exceeds 10^10.\n    >>> solution(1e8)\n    2371\n    >>> solution(1e9)\n    7037\n    \"\"\"\n    primes = sieve()\n\n    n = 1\n    while True:\n        prime = next(primes)\n        if (2 * prime * n) > limit:\n            return n\n        # Ignore the next prime as the reminder will be 2.\n        next(primes)\n        n += 2\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_123/__init__.py": "", "project_euler/problem_063/sol1.py": "\"\"\"\nThe 5-digit number, 16807=75, is also a fifth power. Similarly, the 9-digit number,\n134217728=89, is a ninth power.\nHow many n-digit positive integers exist which are also an nth power?\n\"\"\"\n\n\"\"\"\nThe maximum base can be 9 because all n-digit numbers < 10^n.\nNow 9**23 has 22 digits so the maximum power can be 22.\nUsing these conclusions, we will calculate the result.\n\"\"\"\n\n\ndef solution(max_base: int = 10, max_power: int = 22) -> int:\n    \"\"\"\n    Returns the count of all n-digit numbers which are nth power\n    >>> solution(10, 22)\n    49\n    >>> solution(0, 0)\n    0\n    >>> solution(1, 1)\n    0\n    >>> solution(-1, -1)\n    0\n    \"\"\"\n    bases = range(1, max_base)\n    powers = range(1, max_power)\n    return sum(\n        1 for power in powers for base in bases if len(str(base**power)) == power\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution(10, 22) = }\")\n", "project_euler/problem_063/__init__.py": "#\n", "project_euler/problem_087/sol1.py": "\"\"\"\nProject Euler Problem 87: https://projecteuler.net/problem=87\n\nThe smallest number expressible as the sum of a prime square, prime cube, and prime\nfourth power is 28. In fact, there are exactly four numbers below fifty that can be\nexpressed in such a way:\n\n28 = 22 + 23 + 24\n33 = 32 + 23 + 24\n49 = 52 + 23 + 24\n47 = 22 + 33 + 24\n\nHow many numbers below fifty million can be expressed as the sum of a prime square,\nprime cube, and prime fourth power?\n\"\"\"\n\n\ndef solution(limit: int = 50000000) -> int:\n    \"\"\"\n    Return the number of integers less than limit which can be expressed as the sum\n    of a prime square, prime cube, and prime fourth power.\n    >>> solution(50)\n    4\n    \"\"\"\n    ret = set()\n    prime_square_limit = int((limit - 24) ** (1 / 2))\n\n    primes = set(range(3, prime_square_limit + 1, 2))\n    primes.add(2)\n    for p in range(3, prime_square_limit + 1, 2):\n        if p not in primes:\n            continue\n        primes.difference_update(set(range(p * p, prime_square_limit + 1, p)))\n\n    for prime1 in primes:\n        square = prime1 * prime1\n        for prime2 in primes:\n            cube = prime2 * prime2 * prime2\n            if square + cube >= limit - 16:\n                break\n            for prime3 in primes:\n                tetr = prime3 * prime3 * prime3 * prime3\n                total = square + cube + tetr\n                if total >= limit:\n                    break\n                ret.add(total)\n\n    return len(ret)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_087/__init__.py": "", "project_euler/problem_057/sol1.py": "\"\"\"\nProject Euler Problem 57: https://projecteuler.net/problem=57\nIt is possible to show that the square root of two can be expressed as an infinite\ncontinued fraction.\n\nsqrt(2) = 1 + 1 / (2 + 1 / (2 + 1 / (2 + ...)))\n\nBy expanding this for the first four iterations, we get:\n1 + 1 / 2 = 3 / 2 = 1.5\n1 + 1 / (2 + 1 / 2} = 7 / 5 = 1.4\n1 + 1 / (2 + 1 / (2 + 1 / 2)) = 17 / 12 = 1.41666...\n1 + 1 / (2 + 1 / (2 + 1 / (2 + 1 / 2))) = 41/ 29 = 1.41379...\n\nThe next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion,\n1393/985, is the first example where the number of digits in the numerator exceeds\nthe number of digits in the denominator.\n\nIn the first one-thousand expansions, how many fractions contain a numerator with\nmore digits than the denominator?\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    returns number of fractions containing a numerator with more digits than\n    the denominator in the first n expansions.\n    >>> solution(14)\n    2\n    >>> solution(100)\n    15\n    >>> solution(10000)\n    1508\n    \"\"\"\n    prev_numerator, prev_denominator = 1, 1\n    result = []\n    for i in range(1, n + 1):\n        numerator = prev_numerator + 2 * prev_denominator\n        denominator = prev_numerator + prev_denominator\n        if len(str(numerator)) > len(str(denominator)):\n            result.append(i)\n        prev_numerator = numerator\n        prev_denominator = denominator\n\n    return len(result)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_057/__init__.py": "", "project_euler/problem_119/sol1.py": "\"\"\"\nProblem 119: https://projecteuler.net/problem=119\n\nName: Digit power sum\n\nThe number 512 is interesting because it is equal to the sum of its digits\nraised to some power: 5 + 1 + 2 = 8, and 8^3 = 512. Another example of a number\nwith this property is 614656 = 28^4. We shall define an to be the nth term of\nthis sequence and insist that a number must contain at least two digits to have a sum.\nYou are given that a2 = 512 and a10 = 614656. Find a30\n\"\"\"\n\nimport math\n\n\ndef digit_sum(n: int) -> int:\n    \"\"\"\n    Returns the sum of the digits of the number.\n    >>> digit_sum(123)\n    6\n    >>> digit_sum(456)\n    15\n    >>> digit_sum(78910)\n    25\n    \"\"\"\n    return sum(int(digit) for digit in str(n))\n\n\ndef solution(n: int = 30) -> int:\n    \"\"\"\n    Returns the value of 30th digit power sum.\n    >>> solution(2)\n    512\n    >>> solution(5)\n    5832\n    >>> solution(10)\n    614656\n    \"\"\"\n    digit_to_powers = []\n    for digit in range(2, 100):\n        for power in range(2, 100):\n            number = int(math.pow(digit, power))\n            if digit == digit_sum(number):\n                digit_to_powers.append(number)\n\n    digit_to_powers.sort()\n    return digit_to_powers[n - 1]\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_119/__init__.py": "", "project_euler/problem_001/sol2.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    total = 0\n    terms = (n - 1) // 3\n    total += ((terms) * (6 + (terms - 1) * 3)) // 2  # total of an A.P.\n    terms = (n - 1) // 5\n    total += ((terms) * (10 + (terms - 1) * 5)) // 2\n    terms = (n - 1) // 15\n    total -= ((terms) * (30 + (terms - 1) * 15)) // 2\n    return total\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/sol4.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    xmulti = []\n    zmulti = []\n    z = 3\n    x = 5\n    temp = 1\n    while True:\n        result = z * temp\n        if result < n:\n            zmulti.append(result)\n            temp += 1\n        else:\n            temp = 1\n            break\n    while True:\n        result = x * temp\n        if result < n:\n            xmulti.append(result)\n            temp += 1\n        else:\n            break\n    collection = list(set(xmulti + zmulti))\n    return sum(collection)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/sol7.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/sol6.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    a = 3\n    result = 0\n    while a < n:\n        if a % 3 == 0 or a % 5 == 0:\n            result += a\n        elif a % 15 == 0:\n            result -= a\n        a += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/sol3.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    This solution is based on the pattern that the successive numbers in the\n    series follow: 0+3,+2,+1,+3,+1,+2,+3.\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    total = 0\n    num = 0\n    while 1:\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n        num += 1\n        if num >= n:\n            break\n        total += num\n        num += 2\n        if num >= n:\n            break\n        total += num\n        num += 3\n        if num >= n:\n            break\n        total += num\n    return total\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/sol1.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    >>> solution(-7)\n    0\n    \"\"\"\n\n    return sum(e for e in range(3, n) if e % 3 == 0 or e % 5 == 0)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_001/__init__.py": "", "project_euler/problem_001/sol5.py": "\"\"\"\nProject Euler Problem 1: https://projecteuler.net/problem=1\n\nMultiples of 3 and 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\nwe get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns the sum of all the multiples of 3 or 5 below n.\n    A straightforward pythonic solution using list comprehension.\n\n    >>> solution(3)\n    0\n    >>> solution(4)\n    3\n    >>> solution(10)\n    23\n    >>> solution(600)\n    83700\n    \"\"\"\n\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_054/sol1.py": "\"\"\"\nProblem: https://projecteuler.net/problem=54\n\nIn the card game poker, a hand consists of five cards and are ranked,\nfrom lowest to highest, in the following way:\n\nHigh Card: Highest value card.\nOne Pair: Two cards of the same value.\nTwo Pairs: Two different pairs.\nThree of a Kind: Three cards of the same value.\nStraight: All cards are consecutive values.\nFlush: All cards of the same suit.\nFull House: Three of a kind and a pair.\nFour of a Kind: Four cards of the same value.\nStraight Flush: All cards are consecutive values of same suit.\nRoyal Flush: Ten, Jack, Queen, King, Ace, in same suit.\n\nThe cards are valued in the order:\n2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.\n\nIf two players have the same ranked hands then the rank made up of the highest\nvalue wins; for example, a pair of eights beats a pair of fives.\nBut if two ranks tie, for example, both players have a pair of queens, then highest\ncards in each hand are compared; if the highest cards tie then the next highest\ncards are compared, and so on.\n\nThe file, poker.txt, contains one-thousand random hands dealt to two players.\nEach line of the file contains ten cards (separated by a single space): the\nfirst five are Player 1's cards and the last five are Player 2's cards.\nYou can assume that all hands are valid (no invalid characters or repeated cards),\neach player's hand is in no specific order, and in each hand there is a clear winner.\n\nHow many hands does Player 1 win?\n\nResources used:\nhttps://en.wikipedia.org/wiki/Texas_hold_%27em\nhttps://en.wikipedia.org/wiki/List_of_poker_hands\n\nSimilar problem on codewars:\nhttps://www.codewars.com/kata/ranking-poker-hands\nhttps://www.codewars.com/kata/sortable-poker-hands\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\n\n\nclass PokerHand:\n    \"\"\"Create an object representing a Poker Hand based on an input of a\n    string which represents the best 5-card combination from the player's hand\n    and board cards.\n\n    Attributes: (read-only)\n        hand: a string representing the hand consisting of five cards\n\n    Methods:\n        compare_with(opponent): takes in player's hand (self) and\n            opponent's hand (opponent) and compares both hands according to\n            the rules of Texas Hold'em.\n            Returns one of 3 strings (Win, Loss, Tie) based on whether\n            player's hand is better than the opponent's hand.\n\n        hand_name(): Returns a string made up of two parts: hand name\n            and high card.\n\n    Supported operators:\n        Rich comparison operators: <, >, <=, >=, ==, !=\n\n    Supported built-in methods and functions:\n        list.sort(), sorted()\n    \"\"\"\n\n    _HAND_NAME = (\n        \"High card\",\n        \"One pair\",\n        \"Two pairs\",\n        \"Three of a kind\",\n        \"Straight\",\n        \"Flush\",\n        \"Full house\",\n        \"Four of a kind\",\n        \"Straight flush\",\n        \"Royal flush\",\n    )\n\n    _CARD_NAME = (\n        \"\",  # placeholder as tuples are zero-indexed\n        \"One\",\n        \"Two\",\n        \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n        \"Eight\",\n        \"Nine\",\n        \"Ten\",\n        \"Jack\",\n        \"Queen\",\n        \"King\",\n        \"Ace\",\n    )\n\n    def __init__(self, hand: str) -> None:\n        \"\"\"\n        Initialize hand.\n        Hand should of type str and should contain only five cards each\n        separated by a space.\n\n        The cards should be of the following format:\n        [card value][card suit]\n\n        The first character is the value of the card:\n        2, 3, 4, 5, 6, 7, 8, 9, T(en), J(ack), Q(ueen), K(ing), A(ce)\n\n        The second character represents the suit:\n        S(pades), H(earts), D(iamonds), C(lubs)\n\n        For example: \"6S 4C KC AS TH\"\n        \"\"\"\n        if not isinstance(hand, str):\n            msg = f\"Hand should be of type 'str': {hand!r}\"\n            raise TypeError(msg)\n        # split removes duplicate whitespaces so no need of strip\n        if len(hand.split(\" \")) != 5:\n            msg = f\"Hand should contain only 5 cards: {hand!r}\"\n            raise ValueError(msg)\n        self._hand = hand\n        self._first_pair = 0\n        self._second_pair = 0\n        self._card_values, self._card_suit = self._internal_state()\n        self._hand_type = self._get_hand_type()\n        self._high_card = self._card_values[0]\n\n    @property\n    def hand(self):\n        \"\"\"Returns the self hand\"\"\"\n        return self._hand\n\n    def compare_with(self, other: PokerHand) -> str:\n        \"\"\"\n        Determines the outcome of comparing self hand with other hand.\n        Returns the output as 'Win', 'Loss', 'Tie' according to the rules of\n        Texas Hold'em.\n\n        Here are some examples:\n        >>> player = PokerHand(\"2H 3H 4H 5H 6H\")  # Stright flush\n        >>> opponent = PokerHand(\"KS AS TS QS JS\")  # Royal flush\n        >>> player.compare_with(opponent)\n        'Loss'\n\n        >>> player = PokerHand(\"2S AH 2H AS AC\")  # Full house\n        >>> opponent = PokerHand(\"2H 3H 5H 6H 7H\")  # Flush\n        >>> player.compare_with(opponent)\n        'Win'\n\n        >>> player = PokerHand(\"2S AH 4H 5S 6C\")  # High card\n        >>> opponent = PokerHand(\"AD 4C 5H 6H 2C\")  # High card\n        >>> player.compare_with(opponent)\n        'Tie'\n        \"\"\"\n        # Breaking the tie works on the following order of precedence:\n        # 1. First pair (default 0)\n        # 2. Second pair (default 0)\n        # 3. Compare all cards in reverse order because they are sorted.\n\n        # First pair and second pair will only be a non-zero value if the card\n        # type is either from the following:\n        # 21: Four of a kind\n        # 20: Full house\n        # 17: Three of a kind\n        # 16: Two pairs\n        # 15: One pair\n        if self._hand_type > other._hand_type:\n            return \"Win\"\n        elif self._hand_type < other._hand_type:\n            return \"Loss\"\n        elif self._first_pair == other._first_pair:\n            if self._second_pair == other._second_pair:\n                return self._compare_cards(other)\n            else:\n                return \"Win\" if self._second_pair > other._second_pair else \"Loss\"\n        return \"Win\" if self._first_pair > other._first_pair else \"Loss\"\n\n    # This function is not part of the problem, I did it just for fun\n    def hand_name(self) -> str:\n        \"\"\"\n        Return the name of the hand in the following format:\n        'hand name, high card'\n\n        Here are some examples:\n        >>> PokerHand(\"KS AS TS QS JS\").hand_name()\n        'Royal flush'\n\n        >>> PokerHand(\"2D 6D 3D 4D 5D\").hand_name()\n        'Straight flush, Six-high'\n\n        >>> PokerHand(\"JC 6H JS JD JH\").hand_name()\n        'Four of a kind, Jacks'\n\n        >>> PokerHand(\"3D 2H 3H 2C 2D\").hand_name()\n        'Full house, Twos over Threes'\n\n        >>> PokerHand(\"2H 4D 3C AS 5S\").hand_name()  # Low ace\n        'Straight, Five-high'\n\n        Source: https://en.wikipedia.org/wiki/List_of_poker_hands\n        \"\"\"\n        name = PokerHand._HAND_NAME[self._hand_type - 14]\n        high = PokerHand._CARD_NAME[self._high_card]\n        pair1 = PokerHand._CARD_NAME[self._first_pair]\n        pair2 = PokerHand._CARD_NAME[self._second_pair]\n        if self._hand_type in [22, 19, 18]:\n            return name + f\", {high}-high\"\n        elif self._hand_type in [21, 17, 15]:\n            return name + f\", {pair1}s\"\n        elif self._hand_type in [20, 16]:\n            join = \"over\" if self._hand_type == 20 else \"and\"\n            return name + f\", {pair1}s {join} {pair2}s\"\n        elif self._hand_type == 23:\n            return name\n        else:\n            return name + f\", {high}\"\n\n    def _compare_cards(self, other: PokerHand) -> str:\n        # Enumerate gives us the index as well as the element of a list\n        for index, card_value in enumerate(self._card_values):\n            if card_value != other._card_values[index]:\n                return \"Win\" if card_value > other._card_values[index] else \"Loss\"\n        return \"Tie\"\n\n    def _get_hand_type(self) -> int:\n        # Number representing the type of hand internally:\n        # 23: Royal flush\n        # 22: Straight flush\n        # 21: Four of a kind\n        # 20: Full house\n        # 19: Flush\n        # 18: Straight\n        # 17: Three of a kind\n        # 16: Two pairs\n        # 15: One pair\n        # 14: High card\n        if self._is_flush():\n            if self._is_five_high_straight() or self._is_straight():\n                return 23 if sum(self._card_values) == 60 else 22\n            return 19\n        elif self._is_five_high_straight() or self._is_straight():\n            return 18\n        return 14 + self._is_same_kind()\n\n    def _is_flush(self) -> bool:\n        return len(self._card_suit) == 1\n\n    def _is_five_high_straight(self) -> bool:\n        # If a card is a five high straight (low ace) change the location of\n        # ace from the start of the list to the end. Check whether the first\n        # element is ace or not. (Don't want to change again)\n        # Five high straight (low ace): AH 2H 3S 4C 5D\n        # Why use sorted here? One call to this function will mutate the list to\n        # [5, 4, 3, 2, 14] and so for subsequent calls (which will be rare) we\n        # need to compare the sorted version.\n        # Refer test_multiple_calls_five_high_straight in test_poker_hand.py\n        if sorted(self._card_values) == [2, 3, 4, 5, 14]:\n            if self._card_values[0] == 14:\n                # Remember, our list is sorted in reverse order\n                ace_card = self._card_values.pop(0)\n                self._card_values.append(ace_card)\n            return True\n        return False\n\n    def _is_straight(self) -> bool:\n        for i in range(4):\n            if self._card_values[i] - self._card_values[i + 1] != 1:\n                return False\n        return True\n\n    def _is_same_kind(self) -> int:\n        # Kind Values for internal use:\n        # 7: Four of a kind\n        # 6: Full house\n        # 3: Three of a kind\n        # 2: Two pairs\n        # 1: One pair\n        # 0: False\n        kind = val1 = val2 = 0\n        for i in range(4):\n            # Compare two cards at a time, if they are same increase 'kind',\n            # add the value of the card to val1, if it is repeating again we\n            # will add 2 to 'kind' as there are now 3 cards with same value.\n            # If we get card of different value than val1, we will do the same\n            # thing with val2\n            if self._card_values[i] == self._card_values[i + 1]:\n                if not val1:\n                    val1 = self._card_values[i]\n                    kind += 1\n                elif val1 == self._card_values[i]:\n                    kind += 2\n                elif not val2:\n                    val2 = self._card_values[i]\n                    kind += 1\n                elif val2 == self._card_values[i]:\n                    kind += 2\n        # For consistency in hand type (look at note in _get_hand_type function)\n        kind = kind + 2 if kind in [4, 5] else kind\n        # first meaning first pair to compare in 'compare_with'\n        first = max(val1, val2)\n        second = min(val1, val2)\n        # If it's full house (three count pair + two count pair), make sure\n        # first pair is three count and if not then switch them both.\n        if kind == 6 and self._card_values.count(first) != 3:\n            first, second = second, first\n        self._first_pair = first\n        self._second_pair = second\n        return kind\n\n    def _internal_state(self) -> tuple[list[int], set[str]]:\n        # Internal representation of hand as a list of card values and\n        # a set of card suit\n        trans: dict = {\"T\": \"10\", \"J\": \"11\", \"Q\": \"12\", \"K\": \"13\", \"A\": \"14\"}\n        new_hand = self._hand.translate(str.maketrans(trans)).split()\n        card_values = [int(card[:-1]) for card in new_hand]\n        card_suit = {card[-1] for card in new_hand}\n        return sorted(card_values, reverse=True), card_suit\n\n    def __repr__(self):\n        return f'{self.__class__}(\"{self._hand}\")'\n\n    def __str__(self):\n        return self._hand\n\n    # Rich comparison operators (used in list.sort() and sorted() builtin functions)\n    # Note that this is not part of the problem but another extra feature where\n    # if you have a list of PokerHand objects, you can sort them just through\n    # the builtin functions.\n    def __eq__(self, other):\n        if isinstance(other, PokerHand):\n            return self.compare_with(other) == \"Tie\"\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, PokerHand):\n            return self.compare_with(other) == \"Loss\"\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, PokerHand):\n            return self < other or self == other\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, PokerHand):\n            return not self < other and self != other\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, PokerHand):\n            return not self < other\n        return NotImplemented\n\n    def __hash__(self):\n        return object.__hash__(self)\n\n\ndef solution() -> int:\n    # Solution for problem number 54 from Project Euler\n    # Input from poker_hands.txt file\n    answer = 0\n    script_dir = os.path.abspath(os.path.dirname(__file__))\n    poker_hands = os.path.join(script_dir, \"poker_hands.txt\")\n    with open(poker_hands) as file_hand:\n        for line in file_hand:\n            player_hand = line[:14].strip()\n            opponent_hand = line[15:].strip()\n            player, opponent = PokerHand(player_hand), PokerHand(opponent_hand)\n            output = player.compare_with(opponent)\n            if output == \"Win\":\n                answer += 1\n    return answer\n\n\nif __name__ == \"__main__\":\n    solution()\n", "project_euler/problem_054/__init__.py": "", "project_euler/problem_021/sol1.py": "\"\"\"\nAmicable Numbers\nProblem 21\n\nLet d(n) be defined as the sum of proper divisors of n (numbers less than n\nwhich divide evenly into n).\nIf d(a) = b and d(b) = a, where a \u2260 b, then a and b are an amicable pair and\neach of a and b are called amicable numbers.\n\nFor example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55\nand 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and\n142; so d(284) = 220.\n\nEvaluate the sum of all the amicable numbers under 10000.\n\"\"\"\n\nfrom math import sqrt\n\n\ndef sum_of_divisors(n: int) -> int:\n    total = 0\n    for i in range(1, int(sqrt(n) + 1)):\n        if n % i == 0 and i != sqrt(n):\n            total += i + n // i\n        elif i == sqrt(n):\n            total += i\n    return total - n\n\n\ndef solution(n: int = 10000) -> int:\n    \"\"\"Returns the sum of all the amicable numbers under n.\n\n    >>> solution(10000)\n    31626\n    >>> solution(5000)\n    8442\n    >>> solution(1000)\n    504\n    >>> solution(100)\n    0\n    >>> solution(50)\n    0\n    \"\"\"\n    total = sum(\n        i\n        for i in range(1, n)\n        if sum_of_divisors(sum_of_divisors(i)) == i and sum_of_divisors(i) != i\n    )\n    return total\n\n\nif __name__ == \"__main__\":\n    print(solution(int(str(input()).strip())))\n", "project_euler/problem_021/__init__.py": "", "project_euler/problem_551/sol1.py": "\"\"\"\nSum of digits sequence\nProblem 551\n\nLet a(0), a(1),... be an integer sequence defined by:\n     a(0) = 1\n     for n >= 1, a(n) is the sum of the digits of all preceding terms\n\nThe sequence starts with 1, 1, 2, 4, 8, ...\nYou are given a(10^6) = 31054319.\n\nFind a(10^15)\n\"\"\"\n\nks = range(2, 20 + 1)\nbase = [10**k for k in range(ks[-1] + 1)]\nmemo: dict[int, dict[int, list[list[int]]]] = {}\n\n\ndef next_term(a_i, k, i, n):\n    \"\"\"\n    Calculates and updates a_i in-place to either the n-th term or the\n    smallest term for which c > 10^k when the terms are written in the form:\n            a(i) = b * 10^k + c\n\n    For any a(i), if digitsum(b) and c have the same value, the difference\n    between subsequent terms will be the same until c >= 10^k.  This difference\n    is cached to greatly speed up the computation.\n\n    Arguments:\n    a_i -- array of digits starting from the one's place that represent\n           the i-th term in the sequence\n    k --  k when terms are written in the from a(i) = b*10^k + c.\n          Term are calulcated until c > 10^k or the n-th term is reached.\n    i -- position along the sequence\n    n -- term to calculate up to if k is large enough\n\n    Return: a tuple of difference between ending term and starting term, and\n    the number of terms calculated. ex. if starting term is a_0=1, and\n    ending term is a_10=62, then (61, 9) is returned.\n    \"\"\"\n    # ds_b - digitsum(b)\n    ds_b = sum(a_i[j] for j in range(k, len(a_i)))\n    c = sum(a_i[j] * base[j] for j in range(min(len(a_i), k)))\n\n    diff, dn = 0, 0\n    max_dn = n - i\n\n    sub_memo = memo.get(ds_b)\n\n    if sub_memo is not None:\n        jumps = sub_memo.get(c)\n\n        if jumps is not None and len(jumps) > 0:\n            # find and make the largest jump without going over\n            max_jump = -1\n            for _k in range(len(jumps) - 1, -1, -1):\n                if jumps[_k][2] <= k and jumps[_k][1] <= max_dn:\n                    max_jump = _k\n                    break\n\n            if max_jump >= 0:\n                diff, dn, _kk = jumps[max_jump]\n                # since the difference between jumps is cached, add c\n                new_c = diff + c\n                for j in range(min(k, len(a_i))):\n                    new_c, a_i[j] = divmod(new_c, 10)\n                if new_c > 0:\n                    add(a_i, k, new_c)\n\n        else:\n            sub_memo[c] = []\n    else:\n        sub_memo = {c: []}\n        memo[ds_b] = sub_memo\n\n    if dn >= max_dn or c + diff >= base[k]:\n        return diff, dn\n\n    if k > ks[0]:\n        while True:\n            # keep doing smaller jumps\n            _diff, terms_jumped = next_term(a_i, k - 1, i + dn, n)\n            diff += _diff\n            dn += terms_jumped\n\n            if dn >= max_dn or c + diff >= base[k]:\n                break\n    else:\n        # would be too small a jump, just compute sequential terms instead\n        _diff, terms_jumped = compute(a_i, k, i + dn, n)\n        diff += _diff\n        dn += terms_jumped\n\n    jumps = sub_memo[c]\n\n    # keep jumps sorted by # of terms skipped\n    j = 0\n    while j < len(jumps):\n        if jumps[j][1] > dn:\n            break\n        j += 1\n\n    # cache the jump for this value digitsum(b) and c\n    sub_memo[c].insert(j, (diff, dn, k))\n    return (diff, dn)\n\n\ndef compute(a_i, k, i, n):\n    \"\"\"\n    same as next_term(a_i, k, i, n) but computes terms without memoizing results.\n    \"\"\"\n    if i >= n:\n        return 0, i\n    if k > len(a_i):\n        a_i.extend([0 for _ in range(k - len(a_i))])\n\n    # note: a_i -> b * 10^k + c\n    # ds_b -> digitsum(b)\n    # ds_c -> digitsum(c)\n    start_i = i\n    ds_b, ds_c, diff = 0, 0, 0\n    for j in range(len(a_i)):\n        if j >= k:\n            ds_b += a_i[j]\n        else:\n            ds_c += a_i[j]\n\n    while i < n:\n        i += 1\n        addend = ds_c + ds_b\n        diff += addend\n        ds_c = 0\n        for j in range(k):\n            s = a_i[j] + addend\n            addend, a_i[j] = divmod(s, 10)\n\n            ds_c += a_i[j]\n\n        if addend > 0:\n            break\n\n    if addend > 0:\n        add(a_i, k, addend)\n    return diff, i - start_i\n\n\ndef add(digits, k, addend):\n    \"\"\"\n    adds addend to digit array given in digits\n    starting at index k\n    \"\"\"\n    for j in range(k, len(digits)):\n        s = digits[j] + addend\n        if s >= 10:\n            quotient, digits[j] = divmod(s, 10)\n            addend = addend // 10 + quotient\n        else:\n            digits[j] = s\n            addend = addend // 10\n\n        if addend == 0:\n            break\n\n    while addend > 0:\n        addend, digit = divmod(addend, 10)\n        digits.append(digit)\n\n\ndef solution(n: int = 10**15) -> int:\n    \"\"\"\n    returns n-th term of sequence\n\n    >>> solution(10)\n    62\n\n    >>> solution(10**6)\n    31054319\n\n    >>> solution(10**15)\n    73597483551591773\n    \"\"\"\n\n    digits = [1]\n    i = 1\n    dn = 0\n    while True:\n        diff, terms_jumped = next_term(digits, 20, i + dn, n)\n        dn += terms_jumped\n        if dn == n - i:\n            break\n\n    a_n = 0\n    for j in range(len(digits)):\n        a_n += digits[j] * 10**j\n    return a_n\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_551/__init__.py": "", "project_euler/problem_120/sol1.py": "\"\"\"\nProblem 120 Square remainders: https://projecteuler.net/problem=120\n\nDescription:\n\nLet r be the remainder when (a-1)^n + (a+1)^n is divided by a^2.\nFor example, if a = 7 and n = 3, then r = 42: 6^3 + 8^3 = 728 \u2261 42 mod 49.\nAnd as n varies, so too will r, but for a = 7 it turns out that r_max = 42.\nFor 3 \u2264 a \u2264 1000, find \u2211 r_max.\n\nSolution:\n\nOn expanding the terms, we get 2 if n is even and 2an if n is odd.\nFor maximizing the value, 2an < a*a => n <= (a - 1)/2 (integer division)\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns \u2211 r_max for 3 <= a <= n as explained above\n    >>> solution(10)\n    300\n    >>> solution(100)\n    330750\n    >>> solution(1000)\n    333082500\n    \"\"\"\n    return sum(2 * a * ((a - 1) // 2) for a in range(3, n + 1))\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_120/__init__.py": "", "project_euler/problem_013/sol1.py": "\"\"\"\nProblem 13: https://projecteuler.net/problem=13\n\nProblem Statement:\nWork out the first ten digits of the sum of the following one-hundred 50-digit\nnumbers.\n\"\"\"\n\nimport os\n\n\ndef solution():\n    \"\"\"\n    Returns the first ten digits of the sum of the array elements\n    from the file num.txt\n\n    >>> solution()\n    '5537376230'\n    \"\"\"\n    file_path = os.path.join(os.path.dirname(__file__), \"num.txt\")\n    with open(file_path) as file_hand:\n        return str(sum(int(line) for line in file_hand))[:10]\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_013/__init__.py": "", "project_euler/problem_091/sol1.py": "\"\"\"\nProject Euler Problem 91: https://projecteuler.net/problem=91\n\nThe points P (x1, y1) and Q (x2, y2) are plotted at integer coordinates and\nare joined to the origin, O(0,0), to form \u0394OPQ.\n\ufffc\nThere are exactly fourteen triangles containing a right angle that can be formed\nwhen each coordinate lies between 0 and 2 inclusive; that is,\n0 \u2264 x1, y1, x2, y2 \u2264 2.\n\ufffc\nGiven that 0 \u2264 x1, y1, x2, y2 \u2264 50, how many right triangles can be formed?\n\"\"\"\n\nfrom itertools import combinations, product\n\n\ndef is_right(x1: int, y1: int, x2: int, y2: int) -> bool:\n    \"\"\"\n    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.\n    Note: this doesn't check if P and Q are equal, but that's handled by the use of\n    itertools.combinations in the solution function.\n\n    >>> is_right(0, 1, 2, 0)\n    True\n    >>> is_right(1, 0, 2, 2)\n    False\n    \"\"\"\n    if x1 == y1 == 0 or x2 == y2 == 0:\n        return False\n    a_square = x1 * x1 + y1 * y1\n    b_square = x2 * x2 + y2 * y2\n    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    return (\n        a_square + b_square == c_square\n        or a_square + c_square == b_square\n        or b_square + c_square == a_square\n    )\n\n\ndef solution(limit: int = 50) -> int:\n    \"\"\"\n    Return the number of right triangles OPQ that can be formed by two points P, Q\n    which have both x- and y- coordinates between 0 and limit inclusive.\n\n    >>> solution(2)\n    14\n    >>> solution(10)\n    448\n    \"\"\"\n    return sum(\n        1\n        for pt1, pt2 in combinations(product(range(limit + 1), repeat=2), 2)\n        if is_right(*pt1, *pt2)\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_091/__init__.py": "", "project_euler/problem_031/sol2.py": "\"\"\"\nProblem 31: https://projecteuler.net/problem=31\n\nCoin sums\n\nIn England the currency is made up of pound, f, and pence, p, and there are\neight coins in general circulation:\n\n1p, 2p, 5p, 10p, 20p, 50p, f1 (100p) and f2 (200p).\nIt is possible to make f2 in the following way:\n\n1xf1 + 1x50p + 2x20p + 1x5p + 1x2p + 3x1p\nHow many different ways can f2 be made using any number of coins?\n\nHint:\n    > There are 100 pence in a pound (f1 = 100p)\n    > There are coins(in pence) are available: 1, 2, 5, 10, 20, 50, 100 and 200.\n    > how many different ways you can combine these values to create 200 pence.\n\nExample:\n    to make 6p there are 5 ways\n      1,1,1,1,1,1\n      1,1,1,1,2\n      1,1,2,2\n      2,2,2\n      1,5\n    to make 5p there are 4 ways\n      1,1,1,1,1\n      1,1,1,2\n      1,2,2\n      5\n\"\"\"\n\n\ndef solution(pence: int = 200) -> int:\n    \"\"\"Returns the number of different ways to make X pence using any number of coins.\n    The solution is based on dynamic programming paradigm in a bottom-up fashion.\n\n    >>> solution(500)\n    6295434\n    >>> solution(200)\n    73682\n    >>> solution(50)\n    451\n    >>> solution(10)\n    11\n    \"\"\"\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    number_of_ways = [0] * (pence + 1)\n    number_of_ways[0] = 1  # base case: 1 way to make 0 pence\n\n    for coin in coins:\n        for i in range(coin, pence + 1, 1):\n            number_of_ways[i] += number_of_ways[i - coin]\n    return number_of_ways[pence]\n\n\nif __name__ == \"__main__\":\n    assert solution(200) == 73682\n", "project_euler/problem_031/sol1.py": "\"\"\"\nCoin sums\nProblem 31: https://projecteuler.net/problem=31\n\nIn England the currency is made up of pound, f, and pence, p, and there are\neight coins in general circulation:\n\n1p, 2p, 5p, 10p, 20p, 50p, f1 (100p) and f2 (200p).\nIt is possible to make f2 in the following way:\n\n1xf1 + 1x50p + 2x20p + 1x5p + 1x2p + 3x1p\nHow many different ways can f2 be made using any number of coins?\n\"\"\"\n\n\ndef one_pence() -> int:\n    return 1\n\n\ndef two_pence(x: int) -> int:\n    return 0 if x < 0 else two_pence(x - 2) + one_pence()\n\n\ndef five_pence(x: int) -> int:\n    return 0 if x < 0 else five_pence(x - 5) + two_pence(x)\n\n\ndef ten_pence(x: int) -> int:\n    return 0 if x < 0 else ten_pence(x - 10) + five_pence(x)\n\n\ndef twenty_pence(x: int) -> int:\n    return 0 if x < 0 else twenty_pence(x - 20) + ten_pence(x)\n\n\ndef fifty_pence(x: int) -> int:\n    return 0 if x < 0 else fifty_pence(x - 50) + twenty_pence(x)\n\n\ndef one_pound(x: int) -> int:\n    return 0 if x < 0 else one_pound(x - 100) + fifty_pence(x)\n\n\ndef two_pound(x: int) -> int:\n    return 0 if x < 0 else two_pound(x - 200) + one_pound(x)\n\n\ndef solution(n: int = 200) -> int:\n    \"\"\"Returns the number of different ways can n pence be made using any number of\n    coins?\n\n    >>> solution(500)\n    6295434\n    >>> solution(200)\n    73682\n    >>> solution(50)\n    451\n    >>> solution(10)\n    11\n    \"\"\"\n    return two_pound(n)\n\n\nif __name__ == \"__main__\":\n    print(solution(int(input().strip())))\n", "project_euler/problem_031/__init__.py": "", "project_euler/problem_104/sol1.py": "\"\"\"\nProject Euler Problem 104 : https://projecteuler.net/problem=104\n\nThe Fibonacci sequence is defined by the recurrence relation:\n\nFn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.\nIt turns out that F541, which contains 113 digits, is the first Fibonacci number\nfor which the last nine digits are 1-9 pandigital (contain all the digits 1 to 9,\nbut not necessarily in order). And F2749, which contains 575 digits, is the first\nFibonacci number for which the first nine digits are 1-9 pandigital.\n\nGiven that Fk is the first Fibonacci number for which the first nine digits AND\nthe last nine digits are 1-9 pandigital, find k.\n\"\"\"\n\nimport sys\n\nsys.set_int_max_str_digits(0)\n\n\ndef check(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital both from start and end\n\n\n    >>> check(123456789987654321)\n    True\n\n    >>> check(120000987654321)\n    False\n\n    >>> check(1234567895765677987654321)\n    True\n\n    \"\"\"\n\n    check_last = [0] * 11\n    check_front = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    if not f:\n        return f\n\n    # mark first 9 numbers\n    number = int(str(number)[:9])\n\n    for _ in range(9):\n        check_front[int(number % 10)] = 1\n        number = number // 10\n\n    # check first 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_front[x + 1]:\n            f = False\n    return f\n\n\ndef check1(number: int) -> bool:\n    \"\"\"\n    Takes a number and checks if it is pandigital from END\n\n    >>> check1(123456789987654321)\n    True\n\n    >>> check1(120000987654321)\n    True\n\n    >>> check1(12345678957656779870004321)\n    False\n\n    \"\"\"\n\n    check_last = [0] * 11\n\n    # mark last 9 numbers\n    for _ in range(9):\n        check_last[int(number % 10)] = 1\n        number = number // 10\n    # flag\n    f = True\n\n    # check last 9 numbers for pandigitality\n\n    for x in range(9):\n        if not check_last[x + 1]:\n            f = False\n    return f\n\n\ndef solution() -> int:\n    \"\"\"\n    Outputs the answer is the least Fibonacci number pandigital from both sides.\n    >>> solution()\n    329468\n    \"\"\"\n\n    a = 1\n    b = 1\n    c = 2\n    # temporary Fibonacci numbers\n\n    a1 = 1\n    b1 = 1\n    c1 = 2\n    # temporary Fibonacci numbers mod 1e9\n\n    # mod m=1e9, done for fast optimisation\n    tocheck = [0] * 1000000\n    m = 1000000000\n\n    for x in range(1000000):\n        c1 = (a1 + b1) % m\n        a1 = b1 % m\n        b1 = c1 % m\n        if check1(b1):\n            tocheck[x + 3] = 1\n\n    for x in range(1000000):\n        c = a + b\n        a = b\n        b = c\n        # perform check only if in tocheck\n        if tocheck[x + 3] and check(b):\n            return x + 3  # first 2 already done\n    return -1\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_104/__init__.py": "", "project_euler/problem_094/sol1.py": "\"\"\"\nProject Euler Problem 94: https://projecteuler.net/problem=94\n\nIt is easily proved that no equilateral triangle exists with integral length sides and\nintegral area. However, the almost equilateral triangle 5-5-6 has an area of 12 square\nunits.\n\nWe shall define an almost equilateral triangle to be a triangle for which two sides are\nequal and the third differs by no more than one unit.\n\nFind the sum of the perimeters of all almost equilateral triangles with integral side\nlengths and area and whose perimeters do not exceed one billion (1,000,000,000).\n\"\"\"\n\n\ndef solution(max_perimeter: int = 10**9) -> int:\n    \"\"\"\n    Returns the sum of the perimeters of all almost equilateral triangles with integral\n    side lengths and area and whose perimeters do not exceed max_perimeter\n\n    >>> solution(20)\n    16\n    \"\"\"\n\n    prev_value = 1\n    value = 2\n\n    perimeters_sum = 0\n    i = 0\n    perimeter = 0\n    while perimeter <= max_perimeter:\n        perimeters_sum += perimeter\n\n        prev_value += 2 * value\n        value += prev_value\n\n        perimeter = 2 * value + 2 if i % 2 == 0 else 2 * value - 2\n        i += 1\n\n    return perimeters_sum\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_094/__init__.py": "", "project_euler/problem_009/sol2.py": "\"\"\"\nProject Euler Problem 9: https://projecteuler.net/problem=9\n\nSpecial Pythagorean triplet\n\nA Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n\n    a^2 + b^2 = c^2\n\nFor example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.\n\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000.\nFind the product a*b*c.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Pythagorean_triple\n\"\"\"\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Return the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = n\n\n    >>> solution(36)\n    1620\n    >>> solution(126)\n    66780\n    \"\"\"\n\n    product = -1\n    candidate = 0\n    for a in range(1, n // 3):\n        # Solving the two equations a**2+b**2=c**2 and a+b+c=N eliminating c\n        b = (n * n - 2 * a * n) // (2 * n - 2 * a)\n        c = n - a - b\n        if c * c == (a * a + b * b):\n            candidate = a * b * c\n            if candidate >= product:\n                product = candidate\n    return product\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_009/sol3.py": "\"\"\"\nProject Euler Problem 9: https://projecteuler.net/problem=9\n\nSpecial Pythagorean triplet\n\nA Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n\n    a^2 + b^2 = c^2\n\nFor example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.\n\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000.\nFind the product a*b*c.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Pythagorean_triple\n\"\"\"\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a**2 + b**2 = c**2\n      2. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    return next(\n        iter(\n            [\n                a * b * (1000 - a - b)\n                for a in range(1, 999)\n                for b in range(a, 999)\n                if (a * a + b * b == (1000 - a - b) ** 2)\n            ]\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_009/sol1.py": "\"\"\"\nProject Euler Problem 9: https://projecteuler.net/problem=9\n\nSpecial Pythagorean triplet\n\nA Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n\n    a^2 + b^2 = c^2\n\nFor example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.\n\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000.\nFind the product a*b*c.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Pythagorean_triple\n\"\"\"\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(a + 1, 400):\n            for c in range(b + 1, 500):\n                if (a + b + c) == 1000 and (a**2) + (b**2) == (c**2):\n                    return a * b * c\n\n    return -1\n\n\ndef solution_fast() -> int:\n    \"\"\"\n    Returns the product of a,b,c which are Pythagorean Triplet that satisfies\n    the following:\n      1. a < b < c\n      2. a**2 + b**2 = c**2\n      3. a + b + c = 1000\n\n    >>> solution_fast()\n    31875000\n    \"\"\"\n\n    for a in range(300):\n        for b in range(400):\n            c = 1000 - a - b\n            if a < b < c and (a**2) + (b**2) == (c**2):\n                return a * b * c\n\n    return -1\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark code comparing two different version function.\n    \"\"\"\n    import timeit\n\n    print(\n        timeit.timeit(\"solution()\", setup=\"from __main__ import solution\", number=1000)\n    )\n    print(\n        timeit.timeit(\n            \"solution_fast()\", setup=\"from __main__ import solution_fast\", number=1000\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_009/__init__.py": "", "project_euler/problem_115/sol1.py": "\"\"\"\nProject Euler Problem 115: https://projecteuler.net/problem=115\n\nNOTE: This is a more difficult version of Problem 114\n(https://projecteuler.net/problem=114).\n\nA row measuring n units in length has red blocks\nwith a minimum length of m units placed on it, such that any two red blocks\n(which are allowed to be different lengths) are separated by at least one black square.\n\nLet the fill-count function, F(m, n),\nrepresent the number of ways that a row can be filled.\n\nFor example, F(3, 29) = 673135 and F(3, 30) = 1089155.\n\nThat is, for m = 3, it can be seen that n = 30 is the smallest value\nfor which the fill-count function first exceeds one million.\n\nIn the same way, for m = 10, it can be verified that\nF(10, 56) = 880711 and F(10, 57) = 1148904, so n = 57 is the least value\nfor which the fill-count function first exceeds one million.\n\nFor m = 50, find the least value of n\nfor which the fill-count function first exceeds one million.\n\"\"\"\n\nfrom itertools import count\n\n\ndef solution(min_block_length: int = 50) -> int:\n    \"\"\"\n    Returns for given minimum block length the least value of n\n    for which the fill-count function first exceeds one million\n\n    >>> solution(3)\n    30\n\n    >>> solution(10)\n    57\n    \"\"\"\n\n    fill_count_functions = [1] * min_block_length\n\n    for n in count(min_block_length):\n        fill_count_functions.append(1)\n\n        for block_length in range(min_block_length, n + 1):\n            for block_start in range(n - block_length):\n                fill_count_functions[n] += fill_count_functions[\n                    n - block_start - block_length - 1\n                ]\n\n            fill_count_functions[n] += 1\n\n        if fill_count_functions[n] > 1_000_000:\n            break\n\n    return n\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_115/__init__.py": "", "project_euler/problem_191/sol1.py": "\"\"\"\nPrize Strings\nProblem 191\n\nA particular school offers cash rewards to children with good attendance and\npunctuality. If they are absent for three consecutive days or late on more\nthan one occasion then they forfeit their prize.\n\nDuring an n-day period a trinary string is formed for each child consisting\nof L's (late), O's (on time), and A's (absent).\n\nAlthough there are eighty-one trinary strings for a 4-day period that can be\nformed, exactly forty-three strings would lead to a prize:\n\nOOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA\nOAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO\nAOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL\nAALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA\nLAOO LAOA LAAO\n\nHow many \"prize\" strings exist over a 30-day period?\n\nReferences:\n    - The original Project Euler project page:\n      https://projecteuler.net/problem=191\n\"\"\"\n\ncache: dict[tuple[int, int, int], int] = {}\n\n\ndef _calculate(days: int, absent: int, late: int) -> int:\n    \"\"\"\n    A small helper function for the recursion, mainly to have\n    a clean interface for the solution() function below.\n\n    It should get called with the number of days (corresponding\n    to the desired length of the 'prize strings'), and the\n    initial values for the number of consecutive absent days and\n    number of total late days.\n\n    >>> _calculate(days=4, absent=0, late=0)\n    43\n    >>> _calculate(days=30, absent=2, late=0)\n    0\n    >>> _calculate(days=30, absent=1, late=0)\n    98950096\n    \"\"\"\n\n    # if we are absent twice, or late 3 consecutive days,\n    # no further prize strings are possible\n    if late == 3 or absent == 2:\n        return 0\n\n    # if we have no days left, and have not failed any other rules,\n    # we have a prize string\n    if days == 0:\n        return 1\n\n    # No easy solution, so now we need to do the recursive calculation\n\n    # First, check if the combination is already in the cache, and\n    # if yes, return the stored value from there since we already\n    # know the number of possible prize strings from this point on\n    key = (days, absent, late)\n    if key in cache:\n        return cache[key]\n\n    # now we calculate the three possible ways that can unfold from\n    # this point on, depending on our attendance today\n\n    # 1) if we are late (but not absent), the \"absent\" counter stays as\n    # it is, but the \"late\" counter increases by one\n    state_late = _calculate(days - 1, absent, late + 1)\n\n    # 2) if we are absent, the \"absent\" counter increases by 1, and the\n    # \"late\" counter resets to 0\n    state_absent = _calculate(days - 1, absent + 1, 0)\n\n    # 3) if we are on time, this resets the \"late\" counter and keeps the\n    # absent counter\n    state_ontime = _calculate(days - 1, absent, 0)\n\n    prizestrings = state_late + state_absent + state_ontime\n\n    cache[key] = prizestrings\n    return prizestrings\n\n\ndef solution(days: int = 30) -> int:\n    \"\"\"\n    Returns the number of possible prize strings for a particular number\n    of days, using a simple recursive function with caching to speed it up.\n\n    >>> solution()\n    1918080160\n    >>> solution(4)\n    43\n    \"\"\"\n\n    return _calculate(days, absent=0, late=0)\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_191/__init__.py": "", "project_euler/problem_026/sol1.py": "\"\"\"\nEuler Problem 26\nhttps://projecteuler.net/problem=26\n\nProblem Statement:\n\nA unit fraction contains 1 in the numerator. The decimal representation of the\nunit fractions with denominators 2 to 10 are given:\n\n1/2\t= \t0.5\n1/3\t= \t0.(3)\n1/4\t= \t0.25\n1/5\t= \t0.2\n1/6\t= \t0.1(6)\n1/7\t= \t0.(142857)\n1/8\t= \t0.125\n1/9\t= \t0.(1)\n1/10\t= \t0.1\nWhere 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be\nseen that 1/7 has a 6-digit recurring cycle.\n\nFind the value of d < 1000 for which 1/d contains the longest recurring cycle\nin its decimal fraction part.\n\"\"\"\n\n\ndef solution(numerator: int = 1, digit: int = 1000) -> int:\n    \"\"\"\n    Considering any range can be provided,\n    because as per the problem, the digit d < 1000\n    >>> solution(1, 10)\n    7\n    >>> solution(10, 100)\n    97\n    >>> solution(10, 1000)\n    983\n    \"\"\"\n    the_digit = 1\n    longest_list_length = 0\n\n    for divide_by_number in range(numerator, digit + 1):\n        has_been_divided: list[int] = []\n        now_divide = numerator\n        for _ in range(1, digit + 1):\n            if now_divide in has_been_divided:\n                if longest_list_length < len(has_been_divided):\n                    longest_list_length = len(has_been_divided)\n                    the_digit = divide_by_number\n            else:\n                has_been_divided.append(now_divide)\n                now_divide = now_divide * 10 % divide_by_number\n\n    return the_digit\n\n\n# Tests\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "project_euler/problem_026/__init__.py": "", "project_euler/problem_070/sol1.py": "\"\"\"\nProject Euler Problem 70: https://projecteuler.net/problem=70\n\nEuler's Totient function, \u03c6(n) [sometimes called the phi function], is used to\ndetermine the number of positive numbers less than or equal to n which are\nrelatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are all less than\nnine and relatively prime to nine, \u03c6(9)=6.\n\nThe number 1 is considered to be relatively prime to every positive number, so\n\u03c6(1)=1.\n\nInterestingly, \u03c6(87109)=79180, and it can be seen that 87109 is a permutation\nof 79180.\n\nFind the value of n, 1 < n < 10^7, for which \u03c6(n) is a permutation of n and\nthe ratio n/\u03c6(n) produces a minimum.\n\n-----\n\nThis is essentially brute force. Calculate all totients up to 10^7 and\nfind the minimum ratio of n/\u03c6(n) that way. To minimize the ratio, we want\nto minimize n and maximize \u03c6(n) as much as possible, so we can store the\nminimum fraction's numerator and denominator and calculate new fractions\nwith each totient to compare against. To avoid dividing by zero, I opt to\nuse cross multiplication.\n\nReferences:\nFinding totients\nhttps://en.wikipedia.org/wiki/Euler's_totient_function#Euler's_product_formula\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\n\ndef get_totients(max_one: int) -> list[int]:\n    \"\"\"\n    Calculates a list of totients from 0 to max_one exclusive, using the\n    definition of Euler's product formula.\n\n    >>> get_totients(5)\n    [0, 1, 1, 2, 2]\n\n    >>> get_totients(10)\n    [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]\n    \"\"\"\n    totients = np.arange(max_one)\n\n    for i in range(2, max_one):\n        if totients[i] == i:\n            x = np.arange(i, max_one, i)  # array of indexes to select\n            totients[x] -= totients[x] // i\n\n    return totients.tolist()\n\n\ndef has_same_digits(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if num1 and num2 have the same frequency of every digit, False\n    otherwise.\n\n    >>> has_same_digits(123456789, 987654321)\n    True\n\n    >>> has_same_digits(123, 23)\n    False\n\n    >>> has_same_digits(1234566, 123456)\n    False\n    \"\"\"\n    return sorted(str(num1)) == sorted(str(num2))\n\n\ndef solution(max_n: int = 10000000) -> int:\n    \"\"\"\n    Finds the value of n from 1 to max such that n/\u03c6(n) produces a minimum.\n\n    >>> solution(100)\n    21\n\n    >>> solution(10000)\n    4435\n    \"\"\"\n\n    min_numerator = 1  # i\n    min_denominator = 0  # \u03c6(i)\n    totients = get_totients(max_n + 1)\n\n    for i in range(2, max_n + 1):\n        t = totients[i]\n\n        if i * min_denominator < min_numerator * t and has_same_digits(i, t):\n            min_numerator = i\n            min_denominator = t\n\n    return min_numerator\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_070/__init__.py": "", "project_euler/problem_092/sol1.py": "\"\"\"\nProject Euler Problem 092: https://projecteuler.net/problem=92\nSquare digit chains\nA number chain is created by continuously adding the square of the digits in\na number to form a new number until it has been seen before.\nFor example,\n44 \u2192 32 \u2192 13 \u2192 10 \u2192 1 \u2192 1\n85 \u2192 89 \u2192 145 \u2192 42 \u2192 20 \u2192 4 \u2192 16 \u2192 37 \u2192 58 \u2192 89\nTherefore any chain that arrives at 1 or 89 will become stuck in an endless loop.\nWhat is most amazing is that EVERY starting number will eventually arrive at 1 or 89.\nHow many starting numbers below ten million will arrive at 89?\n\"\"\"\n\nDIGITS_SQUARED = [sum(int(c, 10) ** 2 for c in i.__str__()) for i in range(100000)]\n\n\ndef next_number(number: int) -> int:\n    \"\"\"\n    Returns the next number of the chain by adding the square of each digit\n    to form a new number.\n    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.\n    Therefore, 5 is the next number of the chain.\n    >>> next_number(44)\n    32\n    >>> next_number(10)\n    1\n    >>> next_number(32)\n    13\n    \"\"\"\n\n    sum_of_digits_squared = 0\n    while number:\n        # Increased Speed Slightly by checking every 5 digits together.\n        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]\n        number //= 100000\n\n    return sum_of_digits_squared\n\n\n# There are 2 Chains made,\n# One ends with 89 with the chain member 58 being the one which when declared first,\n# there will be the least number of iterations for all the members to be checked.\n\n# The other one ends with 1 and has only one element 1.\n\n# So 58 and 1 are chosen to be declared at the starting.\n\n# Changed dictionary to an array to quicken the solution\nCHAINS: list[bool | None] = [None] * 10000000\nCHAINS[0] = True\nCHAINS[57] = False\n\n\ndef chain(number: int) -> bool:\n    \"\"\"\n    The function generates the chain of numbers until the next number is 1 or 89.\n    For example, if starting number is 44, then the function generates the\n    following chain of numbers:\n    44 \u2192 32 \u2192 13 \u2192 10 \u2192 1 \u2192 1.\n    Once the next number generated is 1 or 89, the function returns whether\n    or not the next number generated by next_number() is 1.\n    >>> chain(10)\n    True\n    >>> chain(58)\n    False\n    >>> chain(1)\n    True\n    \"\"\"\n\n    if CHAINS[number - 1] is not None:\n        return CHAINS[number - 1]  # type: ignore[return-value]\n\n    number_chain = chain(next_number(number))\n    CHAINS[number - 1] = number_chain\n\n    while number < 10000000:\n        CHAINS[number - 1] = number_chain\n        number *= 10\n\n    return number_chain\n\n\ndef solution(number: int = 10000000) -> int:\n    \"\"\"\n    The function returns the number of integers that end up being 89 in each chain.\n    The function accepts a range number and the function checks all the values\n    under value number.\n\n    >>> solution(100)\n    80\n    >>> solution(10000000)\n    8581146\n    \"\"\"\n    for i in range(1, number):\n        if CHAINS[i] is None:\n            chain(i + 1)\n\n    return CHAINS[:number].count(False)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{solution() = }\")\n", "project_euler/problem_092/__init__.py": "", "project_euler/problem_144/sol1.py": "\"\"\"\nIn laser physics, a \"white cell\" is a mirror system that acts as a delay line for the\nlaser beam. The beam enters the cell, bounces around on the mirrors, and eventually\nworks its way back out.\n\nThe specific white cell we will be considering is an ellipse with the equation\n4x^2 + y^2 = 100\n\nThe section corresponding to -0.01 \u2264 x \u2264 +0.01 at the top is missing, allowing the\nlight to enter and exit through the hole.\n\ufffc\ufffc\nThe light beam in this problem starts at the point (0.0,10.1) just outside the white\ncell, and the beam first impacts the mirror at (1.4,-9.6).\n\nEach time the laser beam hits the surface of the ellipse, it follows the usual law of\nreflection \"angle of incidence equals angle of reflection.\" That is, both the incident\nand reflected beams make the same angle with the normal line at the point of incidence.\n\nIn the figure on the left, the red line shows the first two points of contact between\nthe laser beam and the wall of the white cell; the blue line shows the line tangent to\nthe ellipse at the point of incidence of the first bounce.\n\nThe slope m of the tangent line at any point (x,y) of the given ellipse is: m = -4x/y\n\nThe normal line is perpendicular to this tangent line at the point of incidence.\n\nThe animation on the right shows the first 10 reflections of the beam.\n\nHow many times does the beam hit the internal surface of the white cell before exiting?\n\"\"\"\n\nfrom math import isclose, sqrt\n\n\ndef next_point(\n    point_x: float, point_y: float, incoming_gradient: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    Given that a laser beam hits the interior of the white cell at point\n    (point_x, point_y) with gradient incoming_gradient, return a tuple (x,y,m1)\n    where the next point of contact with the interior is (x,y) with gradient m1.\n    >>> next_point(5.0, 0.0, 0.0)\n    (-5.0, 0.0, 0.0)\n    >>> next_point(5.0, 0.0, -2.0)\n    (0.0, -10.0, 2.0)\n    \"\"\"\n    # normal_gradient = gradient of line through which the beam is reflected\n    # outgoing_gradient = gradient of reflected line\n    normal_gradient = point_y / 4 / point_x\n    s2 = 2 * normal_gradient / (1 + normal_gradient * normal_gradient)\n    c2 = (1 - normal_gradient * normal_gradient) / (\n        1 + normal_gradient * normal_gradient\n    )\n    outgoing_gradient = (s2 - c2 * incoming_gradient) / (c2 + s2 * incoming_gradient)\n\n    # to find the next point, solve the simultaeneous equations:\n    # y^2 + 4x^2 = 100\n    # y - b = m * (x - a)\n    # ==> A x^2 + B x + C = 0\n    quadratic_term = outgoing_gradient**2 + 4\n    linear_term = 2 * outgoing_gradient * (point_y - outgoing_gradient * point_x)\n    constant_term = (point_y - outgoing_gradient * point_x) ** 2 - 100\n\n    x_minus = (\n        -linear_term - sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n    x_plus = (\n        -linear_term + sqrt(linear_term**2 - 4 * quadratic_term * constant_term)\n    ) / (2 * quadratic_term)\n\n    # two solutions, one of which is our input point\n    next_x = x_minus if isclose(x_plus, point_x) else x_plus\n    next_y = point_y + outgoing_gradient * (next_x - point_x)\n\n    return next_x, next_y, outgoing_gradient\n\n\ndef solution(first_x_coord: float = 1.4, first_y_coord: float = -9.6) -> int:\n    \"\"\"\n    Return the number of times that the beam hits the interior wall of the\n    cell before exiting.\n    >>> solution(0.00001,-10)\n    1\n    >>> solution(5, 0)\n    287\n    \"\"\"\n    num_reflections: int = 0\n    point_x: float = first_x_coord\n    point_y: float = first_y_coord\n    gradient: float = (10.1 - point_y) / (0.0 - point_x)\n\n    while not (-0.01 <= point_x <= 0.01 and point_y > 0):\n        point_x, point_y, gradient = next_point(point_x, point_y, gradient)\n        num_reflections += 1\n\n    return num_reflections\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_144/__init__.py": "", "project_euler/problem_039/sol1.py": "\"\"\"\nProblem 39: https://projecteuler.net/problem=39\n\nIf p is the perimeter of a right angle triangle with integral length sides,\n{a,b,c}, there are exactly three solutions for p = 120.\n{20,48,52}, {24,45,51}, {30,40,50}\n\nFor which value of p \u2264 1000, is the number of solutions maximised?\n\"\"\"\n\nfrom __future__ import annotations\n\nimport typing\nfrom collections import Counter\n\n\ndef pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:\n    \"\"\"\n    Returns a dictionary with keys as the perimeter of a right angled triangle\n    and value as the number of corresponding triplets.\n    >>> pythagorean_triple(15)\n    Counter({12: 1})\n    >>> pythagorean_triple(40)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})\n    >>> pythagorean_triple(50)\n    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})\n    \"\"\"\n    triplets: typing.Counter[int] = Counter()\n    for base in range(1, max_perimeter + 1):\n        for perpendicular in range(base, max_perimeter + 1):\n            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5\n            if hypotenuse == int(hypotenuse):\n                perimeter = int(base + perpendicular + hypotenuse)\n                if perimeter > max_perimeter:\n                    continue\n                triplets[perimeter] += 1\n    return triplets\n\n\ndef solution(n: int = 1000) -> int:\n    \"\"\"\n    Returns perimeter with maximum solutions.\n    >>> solution(100)\n    90\n    >>> solution(200)\n    180\n    >>> solution(1000)\n    840\n    \"\"\"\n    triplets = pythagorean_triple(n)\n    return triplets.most_common(1)[0][0]\n\n\nif __name__ == \"__main__\":\n    print(f\"Perimeter {solution()} has maximum solutions\")\n", "project_euler/problem_039/__init__.py": "#\n", "project_euler/problem_040/sol1.py": "\"\"\"\nChampernowne's constant\nProblem 40\nAn irrational decimal fraction is created by concatenating the positive\nintegers:\n\n0.123456789101112131415161718192021...\n\nIt can be seen that the 12th digit of the fractional part is 1.\n\nIf dn represents the nth digit of the fractional part, find the value of the\nfollowing expression.\n\nd1 x d10 x d100 x d1000 x d10000 x d100000 x d1000000\n\"\"\"\n\n\ndef solution():\n    \"\"\"Returns\n\n    >>> solution()\n    210\n    \"\"\"\n    constant = []\n    i = 1\n\n    while len(constant) < 1e6:\n        constant.append(str(i))\n        i += 1\n\n    constant = \"\".join(constant)\n\n    return (\n        int(constant[0])\n        * int(constant[9])\n        * int(constant[99])\n        * int(constant[999])\n        * int(constant[9999])\n        * int(constant[99999])\n        * int(constant[999999])\n    )\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_040/__init__.py": "", "project_euler/problem_068/sol1.py": "\"\"\"\nProject Euler Problem 68: https://projecteuler.net/problem=68\n\nMagic 5-gon ring\n\nProblem Statement:\nConsider the following \"magic\" 3-gon ring,\nfilled with the numbers 1 to 6, and each line adding to nine.\n\n   4\n    \\\n     3\n    / \\\n   1 - 2 - 6\n  /\n 5\n\nWorking clockwise, and starting from the group of three\nwith the numerically lowest external node (4,3,2 in this example),\neach solution can be described uniquely.\nFor example, the above solution can be described by the set: 4,3,2; 6,2,1; 5,1,3.\n\nIt is possible to complete the ring with four different totals: 9, 10, 11, and 12.\nThere are eight solutions in total.\nTotal   Solution Set\n9       4,2,3; 5,3,1; 6,1,2\n9       4,3,2; 6,2,1; 5,1,3\n10      2,3,5; 4,5,1; 6,1,3\n10      2,5,3; 6,3,1; 4,1,5\n11      1,4,6; 3,6,2; 5,2,4\n11      1,6,4; 5,4,2; 3,2,6\n12      1,5,6; 2,6,4; 3,4,5\n12      1,6,5; 3,5,4; 2,4,6\n\nBy concatenating each group it is possible to form 9-digit strings;\nthe maximum string for a 3-gon ring is 432621513.\n\nUsing the numbers 1 to 10, and depending on arrangements,\nit is possible to form 16- and 17-digit strings.\nWhat is the maximum 16-digit string for a \"magic\" 5-gon ring?\n\"\"\"\n\nfrom itertools import permutations\n\n\ndef solution(gon_side: int = 5) -> int:\n    \"\"\"\n    Find the maximum number for a \"magic\" gon_side-gon ring\n\n    The gon_side parameter should be in the range [3, 5],\n    other side numbers aren't tested\n\n    >>> solution(3)\n    432621513\n    >>> solution(4)\n    426561813732\n    >>> solution()\n    6531031914842725\n    >>> solution(6)\n    Traceback (most recent call last):\n    ValueError: gon_side must be in the range [3, 5]\n    \"\"\"\n    if gon_side < 3 or gon_side > 5:\n        raise ValueError(\"gon_side must be in the range [3, 5]\")\n\n    # Since it's 16, we know 10 is on the outer ring\n    # Put the big numbers at the end so that they are never the first number\n    small_numbers = list(range(gon_side + 1, 0, -1))\n    big_numbers = list(range(gon_side + 2, gon_side * 2 + 1))\n\n    for perm in permutations(small_numbers + big_numbers):\n        numbers = generate_gon_ring(gon_side, list(perm))\n        if is_magic_gon(numbers):\n            return int(\"\".join(str(n) for n in numbers))\n\n    msg = f\"Magic {gon_side}-gon ring is impossible\"\n    raise ValueError(msg)\n\n\ndef generate_gon_ring(gon_side: int, perm: list[int]) -> list[int]:\n    \"\"\"\n    Generate a gon_side-gon ring from a permutation state\n    The permutation state is the ring, but every duplicate is removed\n\n    >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6])\n    [4, 2, 3, 5, 3, 1, 6, 1, 2]\n    >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10])\n    [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]\n    \"\"\"\n    result = [0] * (gon_side * 3)\n    result[0:3] = perm[0:3]\n    perm.append(perm[1])\n\n    magic_number = 1 if gon_side < 5 else 2\n\n    for i in range(1, len(perm) // 3 + magic_number):\n        result[3 * i] = perm[2 * i + 1]\n        result[3 * i + 1] = result[3 * i - 1]\n        result[3 * i + 2] = perm[2 * i + 2]\n\n    return result\n\n\ndef is_magic_gon(numbers: list[int]) -> bool:\n    \"\"\"\n    Check if the solution set is a magic n-gon ring\n    Check that the first number is the smallest number on the outer ring\n    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total\n\n    >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])\n    True\n    >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])\n    True\n    >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])\n    True\n    >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    False\n    >>> is_magic_gon([1])\n    Traceback (most recent call last):\n    ValueError: a gon ring should have a length that is a multiple of 3\n    \"\"\"\n    if len(numbers) % 3 != 0:\n        raise ValueError(\"a gon ring should have a length that is a multiple of 3\")\n\n    if min(numbers[::3]) != numbers[0]:\n        return False\n\n    total = sum(numbers[:3])\n\n    return all(sum(numbers[i : i + 3]) == total for i in range(3, len(numbers), 3))\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_068/__init__.py": "", "project_euler/problem_145/sol1.py": "\"\"\"\nProject Euler problem 145: https://projecteuler.net/problem=145\nAuthor: Vineet Rao, Maxim Smolskiy\nProblem statement:\n\nSome positive integers n have the property that the sum [ n + reverse(n) ]\nconsists entirely of odd (decimal) digits.\nFor instance, 36 + 63 = 99 and 409 + 904 = 1313.\nWe will call such numbers reversible; so 36, 63, 409, and 904 are reversible.\nLeading zeroes are not allowed in either n or reverse(n).\n\nThere are 120 reversible numbers below one-thousand.\n\nHow many reversible numbers are there below one-billion (10^9)?\n\"\"\"\n\nEVEN_DIGITS = [0, 2, 4, 6, 8]\nODD_DIGITS = [1, 3, 5, 7, 9]\n\n\ndef slow_reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    \"\"\"\n    Count the number of reversible numbers of given length.\n    Iterate over possible digits considering parity of current sum remainder.\n    >>> slow_reversible_numbers(1, 0, [0], 1)\n    0\n    >>> slow_reversible_numbers(2, 0, [0] * 2, 2)\n    20\n    >>> slow_reversible_numbers(3, 0, [0] * 3, 3)\n    100\n    \"\"\"\n    if remaining_length == 0:\n        if digits[0] == 0 or digits[-1] == 0:\n            return 0\n\n        for i in range(length // 2 - 1, -1, -1):\n            remainder += digits[i] + digits[length - i - 1]\n\n            if remainder % 2 == 0:\n                return 0\n\n            remainder //= 10\n\n        return 1\n\n    if remaining_length == 1:\n        if remainder % 2 == 0:\n            return 0\n\n        result = 0\n        for digit in range(10):\n            digits[length // 2] = digit\n            result += slow_reversible_numbers(\n                0, (remainder + 2 * digit) // 10, digits, length\n            )\n        return result\n\n    result = 0\n    for digit1 in range(10):\n        digits[(length + remaining_length) // 2 - 1] = digit1\n\n        if (remainder + digit1) % 2 == 0:\n            other_parity_digits = ODD_DIGITS\n        else:\n            other_parity_digits = EVEN_DIGITS\n\n        for digit2 in other_parity_digits:\n            digits[(length - remaining_length) // 2] = digit2\n            result += slow_reversible_numbers(\n                remaining_length - 2,\n                (remainder + digit1 + digit2) // 10,\n                digits,\n                length,\n            )\n    return result\n\n\ndef slow_solution(max_power: int = 9) -> int:\n    \"\"\"\n    To evaluate the solution, use solution()\n    >>> slow_solution(3)\n    120\n    >>> slow_solution(6)\n    18720\n    >>> slow_solution(7)\n    68720\n    \"\"\"\n    result = 0\n    for length in range(1, max_power + 1):\n        result += slow_reversible_numbers(length, 0, [0] * length, length)\n    return result\n\n\ndef reversible_numbers(\n    remaining_length: int, remainder: int, digits: list[int], length: int\n) -> int:\n    \"\"\"\n    Count the number of reversible numbers of given length.\n    Iterate over possible digits considering parity of current sum remainder.\n    >>> reversible_numbers(1, 0, [0], 1)\n    0\n    >>> reversible_numbers(2, 0, [0] * 2, 2)\n    20\n    >>> reversible_numbers(3, 0, [0] * 3, 3)\n    100\n    \"\"\"\n    # There exist no reversible 1, 5, 9, 13 (ie. 4k+1) digit numbers\n    if (length - 1) % 4 == 0:\n        return 0\n\n    return slow_reversible_numbers(remaining_length, remainder, digits, length)\n\n\ndef solution(max_power: int = 9) -> int:\n    \"\"\"\n    To evaluate the solution, use solution()\n    >>> solution(3)\n    120\n    >>> solution(6)\n    18720\n    >>> solution(7)\n    68720\n    \"\"\"\n    result = 0\n    for length in range(1, max_power + 1):\n        result += reversible_numbers(length, 0, [0] * length, length)\n    return result\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmarks\n    \"\"\"\n    # Running performance benchmarks...\n    # slow_solution : 292.9300301000003\n    # solution      : 54.90970860000016\n\n    from timeit import timeit\n\n    print(\"Running performance benchmarks...\")\n\n    print(f\"slow_solution : {timeit('slow_solution()', globals=globals(), number=10)}\")\n    print(f\"solution      : {timeit('solution()', globals=globals(), number=10)}\")\n\n\nif __name__ == \"__main__\":\n    print(f\"Solution : {solution()}\")\n    benchmark()\n\n    # for i in range(1, 15):\n    #     print(f\"{i}. {reversible_numbers(i, 0, [0]*i, i)}\")\n", "project_euler/problem_145/__init__.py": "", "project_euler/problem_203/sol1.py": "\"\"\"\nProject Euler Problem 203: https://projecteuler.net/problem=203\n\nThe binomial coefficients (n k) can be arranged in triangular form, Pascal's\ntriangle, like this:\n                            1\n                        1       1\n                    1\t\t2       1\n                1\t\t3\t\t3       1\n            1\t\t4\t\t6\t\t4\t\t1\n        1\t\t5\t\t10\t\t10\t\t5\t\t1\n    1\t\t6\t\t15\t\t20\t\t15\t\t6\t\t1\n1\t\t7\t\t21\t\t35\t\t35\t\t21\t\t7\t\t1\n                        .........\n\nIt can be seen that the first eight rows of Pascal's triangle contain twelve\ndistinct numbers: 1, 2, 3, 4, 5, 6, 7, 10, 15, 20, 21 and 35.\n\nA positive integer n is called squarefree if no square of a prime divides n.\nOf the twelve distinct numbers in the first eight rows of Pascal's triangle,\nall except 4 and 20 are squarefree. The sum of the distinct squarefree numbers\nin the first eight rows is 105.\n\nFind the sum of the distinct squarefree numbers in the first 51 rows of\nPascal's triangle.\n\nReferences:\n- https://en.wikipedia.org/wiki/Pascal%27s_triangle\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef get_pascal_triangle_unique_coefficients(depth: int) -> set[int]:\n    \"\"\"\n    Returns the unique coefficients of a Pascal's triangle of depth \"depth\".\n\n    The coefficients of this triangle are symmetric. A further improvement to this\n    method could be to calculate the coefficients once per level. Nonetheless,\n    the current implementation is fast enough for the original problem.\n\n    >>> get_pascal_triangle_unique_coefficients(1)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(2)\n    {1}\n    >>> get_pascal_triangle_unique_coefficients(3)\n    {1, 2}\n    >>> get_pascal_triangle_unique_coefficients(8)\n    {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}\n    \"\"\"\n    coefficients = {1}\n    previous_coefficients = [1]\n    for _ in range(2, depth + 1):\n        coefficients_begins_one = [*previous_coefficients, 0]\n        coefficients_ends_one = [0, *previous_coefficients]\n        previous_coefficients = []\n        for x, y in zip(coefficients_begins_one, coefficients_ends_one):\n            coefficients.add(x + y)\n            previous_coefficients.append(x + y)\n    return coefficients\n\n\ndef get_squarefrees(unique_coefficients: set[int]) -> set[int]:\n    \"\"\"\n    Calculates the squarefree numbers inside unique_coefficients.\n\n    Based on the definition of a non-squarefree number, then any non-squarefree\n    n can be decomposed as n = p*p*r, where p is positive prime number and r\n    is a positive integer.\n\n    Under the previous formula, any coefficient that is lower than p*p is\n    squarefree as r cannot be negative. On the contrary, if any r exists such\n    that n = p*p*r, then the number is non-squarefree.\n\n    >>> get_squarefrees({1})\n    {1}\n    >>> get_squarefrees({1, 2})\n    {1, 2}\n    >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21})\n    {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}\n    \"\"\"\n\n    non_squarefrees = set()\n    for number in unique_coefficients:\n        divisor = 2\n        copy_number = number\n        while divisor**2 <= copy_number:\n            multiplicity = 0\n            while copy_number % divisor == 0:\n                copy_number //= divisor\n                multiplicity += 1\n            if multiplicity >= 2:\n                non_squarefrees.add(number)\n                break\n            divisor += 1\n\n    return unique_coefficients.difference(non_squarefrees)\n\n\ndef solution(n: int = 51) -> int:\n    \"\"\"\n    Returns the sum of squarefrees for a given Pascal's Triangle of depth n.\n\n    >>> solution(1)\n    1\n    >>> solution(8)\n    105\n    >>> solution(9)\n    175\n    \"\"\"\n    unique_coefficients = get_pascal_triangle_unique_coefficients(n)\n    squarefrees = get_squarefrees(unique_coefficients)\n    return sum(squarefrees)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_203/__init__.py": "", "project_euler/problem_050/sol1.py": "\"\"\"\nProject Euler Problem 50: https://projecteuler.net/problem=50\n\nConsecutive prime sum\n\nThe prime 41, can be written as the sum of six consecutive primes:\n41 = 2 + 3 + 5 + 7 + 11 + 13\n\nThis is the longest sum of consecutive primes that adds to a prime below\none-hundred.\n\nThe longest sum of consecutive primes below one-thousand that adds to a prime,\ncontains 21 terms, and is equal to 953.\n\nWhich prime, below one-million, can be written as the sum of the most\nconsecutive primes?\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef prime_sieve(limit: int) -> list[int]:\n    \"\"\"\n    Sieve of Erotosthenes\n    Function to return all the prime numbers up to a number 'limit'\n    https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\n    >>> prime_sieve(3)\n    [2]\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    \"\"\"\n    is_prime = [True] * limit\n    is_prime[0] = False\n    is_prime[1] = False\n    is_prime[2] = True\n\n    for i in range(3, int(limit**0.5 + 1), 2):\n        index = i * 2\n        while index < limit:\n            is_prime[index] = False\n            index = index + i\n\n    primes = [2]\n\n    for i in range(3, limit, 2):\n        if is_prime[i]:\n            primes.append(i)\n\n    return primes\n\n\ndef solution(ceiling: int = 1_000_000) -> int:\n    \"\"\"\n    Returns the biggest prime, below the celing, that can be written as the sum\n    of consecutive the most consecutive primes.\n\n    >>> solution(500)\n    499\n\n    >>> solution(1_000)\n    953\n\n    >>> solution(10_000)\n    9521\n    \"\"\"\n    primes = prime_sieve(ceiling)\n    length = 0\n    largest = 0\n\n    for i in range(len(primes)):\n        for j in range(i + length, len(primes)):\n            sol = sum(primes[i:j])\n            if sol >= ceiling:\n                break\n\n            if sol in primes:\n                length = j - i\n                largest = sol\n\n    return largest\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_050/__init__.py": "", "project_euler/problem_027/sol1.py": "\"\"\"\nProject Euler Problem 27\nhttps://projecteuler.net/problem=27\n\nProblem Statement:\n\nEuler discovered the remarkable quadratic formula:\nn2 + n + 41\nIt turns out that the formula will produce 40 primes for the consecutive values\nn = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible\nby 41, and certainly when n = 41, 412 + 41 + 41 is clearly divisible by 41.\nThe incredible formula  n2 - 79n + 1601 was discovered, which produces 80 primes\nfor the consecutive values n = 0 to 79. The product of the coefficients, -79 and\n1601, is -126479.\nConsidering quadratics of the form:\nn\u00b2 + an + b, where |a| &lt; 1000 and |b| &lt; 1000\nwhere |n| is the modulus/absolute value of ne.g. |11| = 11 and |-4| = 4\nFind the product of the coefficients, a and b, for the quadratic expression that\nproduces the maximum number of primes for consecutive values of n, starting with\nn = 0.\n\"\"\"\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n    A number is prime if it has exactly two factors: 1 and itself.\n    Returns boolean representing primality of given number num (i.e., if the\n    result is true, then the number is indeed prime else it is not).\n\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(2999)\n    True\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(-10)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\ndef solution(a_limit: int = 1000, b_limit: int = 1000) -> int:\n    \"\"\"\n    >>> solution(1000, 1000)\n    -59231\n    >>> solution(200, 1000)\n    -59231\n    >>> solution(200, 200)\n    -4925\n    >>> solution(-1000, 1000)\n    0\n    >>> solution(-1000, -1000)\n    0\n    \"\"\"\n    longest = [0, 0, 0]  # length, a, b\n    for a in range((a_limit * -1) + 1, a_limit):\n        for b in range(2, b_limit):\n            if is_prime(b):\n                count = 0\n                n = 0\n                while is_prime((n**2) + (a * n) + b):\n                    count += 1\n                    n += 1\n                if count > longest[0]:\n                    longest = [count, a, b]\n    ans = longest[1] * longest[2]\n    return ans\n\n\nif __name__ == \"__main__\":\n    print(solution(1000, 1000))\n", "project_euler/problem_027/__init__.py": "", "project_euler/problem_024/sol1.py": "\"\"\"\nA permutation is an ordered arrangement of objects. For example, 3124 is one\npossible permutation of the digits 1, 2, 3 and 4. If all of the permutations\nare listed numerically or alphabetically, we call it lexicographic order. The\nlexicographic permutations of 0, 1 and 2 are:\n\n    012   021   102   120   201   210\n\nWhat is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5,\n6, 7, 8 and 9?\n\"\"\"\n\nfrom itertools import permutations\n\n\ndef solution():\n    \"\"\"Returns the millionth lexicographic permutation of the digits 0, 1, 2,\n    3, 4, 5, 6, 7, 8 and 9.\n\n    >>> solution()\n    '2783915460'\n    \"\"\"\n    result = list(map(\"\".join, permutations(\"0123456789\")))\n    return result[999999]\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_024/__init__.py": "", "project_euler/problem_035/sol1.py": "\"\"\"\nProject Euler Problem 35\nhttps://projecteuler.net/problem=35\n\nProblem Statement:\n\nThe number 197 is called a circular prime because all rotations of the digits:\n197, 971, and 719, are themselves prime.\nThere are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73,\n79, and 97.\nHow many circular primes are there below one million?\n\nTo solve this problem in an efficient manner, we will first mark all the primes\nbelow 1 million using the Sieve of Eratosthenes. Then, out of all these primes,\nwe will rule out the numbers which contain an even digit. After this we will\ngenerate each circular combination of the number and check if all are prime.\n\"\"\"\n\nfrom __future__ import annotations\n\nsieve = [True] * 1000001\ni = 2\nwhile i * i <= 1000000:\n    if sieve[i]:\n        for j in range(i * i, 1000001, i):\n            sieve[j] = False\n    i += 1\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    For 2 <= n <= 1000000, return True if n is prime.\n    >>> is_prime(87)\n    False\n    >>> is_prime(23)\n    True\n    >>> is_prime(25363)\n    False\n    \"\"\"\n    return sieve[n]\n\n\ndef contains_an_even_digit(n: int) -> bool:\n    \"\"\"\n    Return True if n contains an even digit.\n    >>> contains_an_even_digit(0)\n    True\n    >>> contains_an_even_digit(975317933)\n    False\n    >>> contains_an_even_digit(-245679)\n    True\n    \"\"\"\n    return any(digit in \"02468\" for digit in str(n))\n\n\ndef find_circular_primes(limit: int = 1000000) -> list[int]:\n    \"\"\"\n    Return circular primes below limit.\n    >>> len(find_circular_primes(100))\n    13\n    >>> len(find_circular_primes(1000000))\n    55\n    \"\"\"\n    result = [2]  # result already includes the number 2.\n    for num in range(3, limit + 1, 2):\n        if is_prime(num) and not contains_an_even_digit(num):\n            str_num = str(num)\n            list_nums = [int(str_num[j:] + str_num[:j]) for j in range(len(str_num))]\n            if all(is_prime(i) for i in list_nums):\n                result.append(num)\n    return result\n\n\ndef solution() -> int:\n    \"\"\"\n    >>> solution()\n    55\n    \"\"\"\n    return len(find_circular_primes())\n\n\nif __name__ == \"__main__\":\n    print(f\"{len(find_circular_primes()) = }\")\n", "project_euler/problem_035/__init__.py": "#\n", "project_euler/problem_028/sol1.py": "\"\"\"\nProblem 28\nUrl: https://projecteuler.net/problem=28\nStatement:\nStarting with the number 1 and moving to the right in a clockwise direction a 5\nby 5 spiral is formed as follows:\n\n    21 22 23 24 25\n    20  7  8  9 10\n    19  6  1  2 11\n    18  5  4  3 12\n    17 16 15 14 13\n\nIt can be verified that the sum of the numbers on the diagonals is 101.\n\nWhat is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed\nin the same way?\n\"\"\"\n\nfrom math import ceil\n\n\ndef solution(n: int = 1001) -> int:\n    \"\"\"Returns the sum of the numbers on the diagonals in a n by n spiral\n    formed in the same way.\n\n    >>> solution(1001)\n    669171001\n    >>> solution(500)\n    82959497\n    >>> solution(100)\n    651897\n    >>> solution(50)\n    79697\n    >>> solution(10)\n    537\n    \"\"\"\n    total = 1\n\n    for i in range(1, int(ceil(n / 2.0))):\n        odd = 2 * i + 1\n        even = 2 * i\n        total = total + 4 * odd**2 - 6 * even\n\n    return total\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    if len(sys.argv) == 1:\n        print(solution())\n    else:\n        try:\n            n = int(sys.argv[1])\n            print(solution(n))\n        except ValueError:\n            print(\"Invalid entry - please enter a number\")\n", "project_euler/problem_028/__init__.py": "", "project_euler/problem_015/sol1.py": "\"\"\"\nProblem 15: https://projecteuler.net/problem=15\n\nStarting in the top left corner of a 2x2 grid, and only being able to move to\nthe right and down, there are exactly 6 routes to the bottom right corner.\nHow many such routes are there through a 20x20 grid?\n\"\"\"\n\nfrom math import factorial\n\n\ndef solution(n: int = 20) -> int:\n    \"\"\"\n    Returns the number of paths possible in a n x n grid starting at top left\n    corner going to bottom right corner and being able to move right and down\n    only.\n    >>> solution(25)\n    126410606437752\n    >>> solution(23)\n    8233430727600\n    >>> solution(20)\n    137846528820\n    >>> solution(15)\n    155117520\n    >>> solution(1)\n    2\n    \"\"\"\n    n = 2 * n  # middle entry of odd rows starting at row 3 is the solution for n = 1,\n    # 2, 3,...\n    k = n // 2\n\n    return int(factorial(n) / (factorial(k) * factorial(n - k)))\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    if len(sys.argv) == 1:\n        print(solution(20))\n    else:\n        try:\n            n = int(sys.argv[1])\n            print(solution(n))\n        except ValueError:\n            print(\"Invalid entry - please enter a number.\")\n", "project_euler/problem_015/__init__.py": "", "project_euler/problem_100/sol1.py": "\"\"\"\nProject Euler Problem 100: https://projecteuler.net/problem=100\n\nIf a box contains twenty-one coloured discs, composed of fifteen blue discs and\nsix red discs, and two discs were taken at random, it can be seen that\nthe probability of taking two blue discs, P(BB) = (15/21) x (14/20) = 1/2.\n\nThe next such arrangement, for which there is exactly 50% chance of taking two blue\ndiscs at random, is a box containing eighty-five blue discs and thirty-five red discs.\n\nBy finding the first arrangement to contain over 10^12 = 1,000,000,000,000 discs\nin total, determine the number of blue discs that the box would contain.\n\"\"\"\n\n\ndef solution(min_total: int = 10**12) -> int:\n    \"\"\"\n    Returns the number of blue discs for the first arrangement to contain\n    over min_total discs in total\n\n    >>> solution(2)\n    3\n\n    >>> solution(4)\n    15\n\n    >>> solution(21)\n    85\n    \"\"\"\n\n    prev_numerator = 1\n    prev_denominator = 0\n\n    numerator = 1\n    denominator = 1\n\n    while numerator <= 2 * min_total - 1:\n        prev_numerator += 2 * numerator\n        numerator += 2 * prev_numerator\n\n        prev_denominator += 2 * denominator\n        denominator += 2 * prev_denominator\n\n    return (denominator + 1) // 2\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_100/__init__.py": "", "project_euler/problem_046/sol1.py": "\"\"\"\nProblem 46: https://projecteuler.net/problem=46\n\nIt was proposed by Christian Goldbach that every odd composite number can be\nwritten as the sum of a prime and twice a square.\n\n9 = 7 + 2 x 12\n15 = 7 + 2 x 22\n21 = 3 + 2 x 32\n25 = 7 + 2 x 32\n27 = 19 + 2 x 22\n33 = 31 + 2 x 12\n\nIt turns out that the conjecture was false.\n\nWhat is the smallest odd composite that cannot be written as the sum of a\nprime and twice a square?\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    \"\"\"\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\nodd_composites = [num for num in range(3, 100001, 2) if not is_prime(num)]\n\n\ndef compute_nums(n: int) -> list[int]:\n    \"\"\"\n    Returns a list of first n odd composite numbers which do\n    not follow the conjecture.\n    >>> compute_nums(1)\n    [5777]\n    >>> compute_nums(2)\n    [5777, 5993]\n    >>> compute_nums(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be >= 0\n    >>> compute_nums(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n    >>> compute_nums(1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be an integer\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be >= 0\")\n\n    list_nums = []\n    for num in range(len(odd_composites)):\n        i = 0\n        while 2 * i * i <= odd_composites[num]:\n            rem = odd_composites[num] - 2 * i * i\n            if is_prime(rem):\n                break\n            i += 1\n        else:\n            list_nums.append(odd_composites[num])\n            if len(list_nums) == n:\n                return list_nums\n\n    return []\n\n\ndef solution() -> int:\n    \"\"\"Return the solution to the problem\"\"\"\n    return compute_nums(1)[0]\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_046/__init__.py": "#\n", "project_euler/problem_056/sol1.py": "\"\"\"\nProject Euler Problem 56: https://projecteuler.net/problem=56\n\nA googol (10^100) is a massive number: one followed by one-hundred zeros;\n100^100 is almost unimaginably large: one followed by two-hundred zeros.\nDespite their size, the sum of the digits in each number is only 1.\n\nConsidering natural numbers of the form, ab, where a, b < 100,\nwhat is the maximum digital sum?\n\"\"\"\n\n\ndef solution(a: int = 100, b: int = 100) -> int:\n    \"\"\"\n    Considering natural numbers of the form, a**b, where a, b < 100,\n    what is the maximum digital sum?\n    :param a:\n    :param b:\n    :return:\n    >>> solution(10,10)\n    45\n\n    >>> solution(100,100)\n    972\n\n    >>> solution(100,200)\n    1872\n    \"\"\"\n\n    # RETURN the MAXIMUM from the list of SUMs of the list of INT converted from STR of\n    # BASE raised to the POWER\n    return max(\n        sum(int(x) for x in str(base**power)) for base in range(a) for power in range(b)\n    )\n\n\n# Tests\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "project_euler/problem_056/__init__.py": "", "project_euler/problem_034/sol1.py": "\"\"\"\nProblem 34: https://projecteuler.net/problem=34\n\n145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.\nFind the sum of all numbers which are equal to the sum of the factorial of their digits.\nNote: As 1! = 1 and 2! = 2 are not sums they are not included.\n\"\"\"\n\nfrom math import factorial\n\nDIGIT_FACTORIAL = {str(d): factorial(d) for d in range(10)}\n\n\ndef sum_of_digit_factorial(n: int) -> int:\n    \"\"\"\n    Returns the sum of the factorial of digits in n\n    >>> sum_of_digit_factorial(15)\n    121\n    >>> sum_of_digit_factorial(0)\n    1\n    \"\"\"\n    return sum(DIGIT_FACTORIAL[d] for d in str(n))\n\n\ndef solution() -> int:\n    \"\"\"\n    Returns the sum of all numbers whose\n    sum of the factorials of all digits\n    add up to the number itself.\n    >>> solution()\n    40730\n    \"\"\"\n    limit = 7 * factorial(9) + 1\n    return sum(i for i in range(3, limit) if sum_of_digit_factorial(i) == i)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_034/__init__.py": "#\n", "project_euler/problem_113/sol1.py": "\"\"\"\nProject Euler Problem 113: https://projecteuler.net/problem=113\n\nWorking from left-to-right if no digit is exceeded by the digit to its left it is\ncalled an increasing number; for example, 134468.\n\nSimilarly if no digit is exceeded by the digit to its right it is called a decreasing\nnumber; for example, 66420.\n\nWe shall call a positive integer that is neither increasing nor decreasing a\n\"bouncy\" number; for example, 155349.\n\nAs n increases, the proportion of bouncy numbers below n increases such that there\nare only 12951 numbers below one-million that are not bouncy and only 277032\nnon-bouncy numbers below 10^10.\n\nHow many numbers below a googol (10^100) are not bouncy?\n\"\"\"\n\n\ndef choose(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient c(n,r) using the multiplicative formula.\n    >>> choose(4,2)\n    6\n    >>> choose(5,3)\n    10\n    >>> choose(20,6)\n    38760\n    \"\"\"\n    ret = 1.0\n    for i in range(1, r + 1):\n        ret *= (n + 1 - i) / i\n    return round(ret)\n\n\ndef non_bouncy_exact(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_exact(1)\n    9\n    >>> non_bouncy_exact(6)\n    7998\n    >>> non_bouncy_exact(10)\n    136126\n    \"\"\"\n    return choose(8 + n, n) + choose(9 + n, n) - 10\n\n\ndef non_bouncy_upto(n: int) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers with at most n digits.\n    >>> non_bouncy_upto(1)\n    9\n    >>> non_bouncy_upto(6)\n    12951\n    >>> non_bouncy_upto(10)\n    277032\n    \"\"\"\n    return sum(non_bouncy_exact(i) for i in range(1, n + 1))\n\n\ndef solution(num_digits: int = 100) -> int:\n    \"\"\"\n    Calculate the number of non-bouncy numbers less than a googol.\n    >>> solution(6)\n    12951\n    >>> solution(10)\n    277032\n    \"\"\"\n    return non_bouncy_upto(num_digits)\n\n\nif __name__ == \"__main__\":\n    print(f\"{solution() = }\")\n", "project_euler/problem_113/__init__.py": "", "project_euler/problem_023/sol1.py": "\"\"\"\nA perfect number is a number for which the sum of its proper divisors is exactly\nequal to the number. For example, the sum of the proper divisors of 28 would be\n1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.\n\nA number n is called deficient if the sum of its proper divisors is less than n\nand it is called abundant if this sum exceeds n.\n\nAs 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest\nnumber that can be written as the sum of two abundant numbers is 24. By\nmathematical analysis, it can be shown that all integers greater than 28123\ncan be written as the sum of two abundant numbers. However, this upper limit\ncannot be reduced any further by analysis even though it is known that the\ngreatest number that cannot be expressed as the sum of two abundant numbers\nis less than this limit.\n\nFind the sum of all the positive integers which cannot be written as the sum\nof two abundant numbers.\n\"\"\"\n\n\ndef solution(limit=28123):\n    \"\"\"\n    Finds the sum of all the positive integers which cannot be written as\n    the sum of two abundant numbers\n    as described by the statement above.\n\n    >>> solution()\n    4179871\n    \"\"\"\n    sum_divs = [1] * (limit + 1)\n\n    for i in range(2, int(limit**0.5) + 1):\n        sum_divs[i * i] += i\n        for k in range(i + 1, limit // i + 1):\n            sum_divs[k * i] += k + i\n\n    abundants = set()\n    res = 0\n\n    for n in range(1, limit + 1):\n        if sum_divs[n] > n:\n            abundants.add(n)\n\n        if not any((n - a in abundants) for a in abundants):\n            res += n\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solution())\n", "project_euler/problem_023/__init__.py": "", "graphics/bezier_curve.py": "# https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n# https://www.tutorialspoint.com/computer_graphics/computer_graphics_curves.htm\nfrom __future__ import annotations\n\nfrom scipy.special import comb\n\n\nclass BezierCurve:\n    \"\"\"\n    Bezier curve is a weighted sum of a set of control points.\n    Generate Bezier curves from a given set of control points.\n    This implementation works only for 2d coordinates in the xy plane.\n    \"\"\"\n\n    def __init__(self, list_of_points: list[tuple[float, float]]):\n        \"\"\"\n        list_of_points: Control points in the xy plane on which to interpolate. These\n            points control the behavior (shape) of the Bezier curve.\n        \"\"\"\n        self.list_of_points = list_of_points\n        # Degree determines the flexibility of the curve.\n        # Degree = 1 will produce a straight line.\n        self.degree = len(list_of_points) - 1\n\n    def basis_function(self, t: float) -> list[float]:\n        \"\"\"\n        The basis function determines the weight of each control point at time t.\n            t: time value between 0 and 1 inclusive at which to evaluate the basis of\n               the curve.\n        returns the x, y values of basis function at time t\n\n        >>> curve = BezierCurve([(1,1), (1,2)])\n        >>> curve.basis_function(0)\n        [1.0, 0.0]\n        >>> curve.basis_function(1)\n        [0.0, 1.0]\n        \"\"\"\n        assert 0 <= t <= 1, \"Time t must be between 0 and 1.\"\n        output_values: list[float] = []\n        for i in range(len(self.list_of_points)):\n            # basis function for each i\n            output_values.append(\n                comb(self.degree, i) * ((1 - t) ** (self.degree - i)) * (t**i)\n            )\n        # the basis must sum up to 1 for it to produce a valid Bezier curve.\n        assert round(sum(output_values), 5) == 1\n        return output_values\n\n    def bezier_curve_function(self, t: float) -> tuple[float, float]:\n        \"\"\"\n        The function to produce the values of the Bezier curve at time t.\n            t: the value of time t at which to evaluate the Bezier function\n        Returns the x, y coordinates of the Bezier curve at time t.\n            The first point in the curve is when t = 0.\n            The last point in the curve is when t = 1.\n\n        >>> curve = BezierCurve([(1,1), (1,2)])\n        >>> curve.bezier_curve_function(0)\n        (1.0, 1.0)\n        >>> curve.bezier_curve_function(1)\n        (1.0, 2.0)\n        \"\"\"\n\n        assert 0 <= t <= 1, \"Time t must be between 0 and 1.\"\n\n        basis_function = self.basis_function(t)\n        x = 0.0\n        y = 0.0\n        for i in range(len(self.list_of_points)):\n            # For all points, sum up the product of i-th basis function and i-th point.\n            x += basis_function[i] * self.list_of_points[i][0]\n            y += basis_function[i] * self.list_of_points[i][1]\n        return (x, y)\n\n    def plot_curve(self, step_size: float = 0.01):\n        \"\"\"\n        Plots the Bezier curve using matplotlib plotting capabilities.\n            step_size: defines the step(s) at which to evaluate the Bezier curve.\n            The smaller the step size, the finer the curve produced.\n        \"\"\"\n        from matplotlib import pyplot as plt\n\n        to_plot_x: list[float] = []  # x coordinates of points to plot\n        to_plot_y: list[float] = []  # y coordinates of points to plot\n\n        t = 0.0\n        while t <= 1:\n            value = self.bezier_curve_function(t)\n            to_plot_x.append(value[0])\n            to_plot_y.append(value[1])\n            t += step_size\n\n        x = [i[0] for i in self.list_of_points]\n        y = [i[1] for i in self.list_of_points]\n\n        plt.plot(\n            to_plot_x,\n            to_plot_y,\n            color=\"blue\",\n            label=\"Curve of Degree \" + str(self.degree),\n        )\n        plt.scatter(x, y, color=\"red\", label=\"Control Points\")\n        plt.legend()\n        plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    BezierCurve([(1, 2), (3, 5)]).plot_curve()  # degree 1\n    BezierCurve([(0, 0), (5, 5), (5, 0)]).plot_curve()  # degree 2\n    BezierCurve([(0, 0), (5, 5), (5, 0), (2.5, -2.5)]).plot_curve()  # degree 3\n", "graphics/vector3_for_2d_rendering.py": "\"\"\"\nrender 3d points for 2d surfaces.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\n__version__ = \"2020.9.26\"\n__author__ = \"xcodz-dot, cclaus, dhruvmanila\"\n\n\ndef convert_to_2d(\n    x: float, y: float, z: float, scale: float, distance: float\n) -> tuple[float, float]:\n    \"\"\"\n    Converts 3d point to a 2d drawable point\n\n    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(1, 2, 3, 10, 10)\n    (7.6923076923076925, 15.384615384615385)\n\n    >>> convert_to_2d(\"1\", 2, 3, 10, 10)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]\n    \"\"\"\n    if not all(isinstance(val, (float, int)) for val in locals().values()):\n        msg = f\"Input values must either be float or int: {list(locals().values())}\"\n        raise TypeError(msg)\n    projected_x = ((x * distance) / (z + distance)) * scale\n    projected_y = ((y * distance) / (z + distance)) * scale\n    return projected_x, projected_y\n\n\ndef rotate(\n    x: float, y: float, z: float, axis: str, angle: float\n) -> tuple[float, float, float]:\n    \"\"\"\n    rotate a point around a certain axis with a certain angle\n    angle can be any integer between 1, 360 and axis can be any one of\n    'x', 'y', 'z'\n\n    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)\n    (3.130524675073759, 2.0, 0.4470070007889556)\n\n    >>> rotate(1, 2, 3, \"z\", 180)\n    (0.999736015495891, -2.0001319704760485, 3)\n\n    >>> rotate('1', 2, 3, \"z\", 90.0)  # '1' is str\n    Traceback (most recent call last):\n        ...\n    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]\n\n    >>> rotate(1, 2, 3, \"n\", 90)  # 'n' is not a valid axis\n    Traceback (most recent call last):\n        ...\n    ValueError: not a valid axis, choose one of 'x', 'y', 'z'\n\n    >>> rotate(1, 2, 3, \"x\", -90)\n    (1, -2.5049096187183877, -2.5933429780983657)\n\n    >>> rotate(1, 2, 3, \"x\", 450)  # 450 wrap around to 90\n    (1, 3.5776792428178217, -0.44744970165427644)\n    \"\"\"\n    if not isinstance(axis, str):\n        raise TypeError(\"Axis must be a str\")\n    input_variables = locals()\n    del input_variables[\"axis\"]\n    if not all(isinstance(val, (float, int)) for val in input_variables.values()):\n        msg = (\n            \"Input values except axis must either be float or int: \"\n            f\"{list(input_variables.values())}\"\n        )\n        raise TypeError(msg)\n    angle = (angle % 360) / 450 * 180 / math.pi\n    if axis == \"z\":\n        new_x = x * math.cos(angle) - y * math.sin(angle)\n        new_y = y * math.cos(angle) + x * math.sin(angle)\n        new_z = z\n    elif axis == \"x\":\n        new_y = y * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + y * math.sin(angle)\n        new_x = x\n    elif axis == \"y\":\n        new_x = x * math.cos(angle) - z * math.sin(angle)\n        new_z = z * math.cos(angle) + x * math.sin(angle)\n        new_y = y\n    else:\n        raise ValueError(\"not a valid axis, choose one of 'x', 'y', 'z'\")\n\n    return new_x, new_y, new_z\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0) = }\")\n    print(f\"{rotate(1.0, 2.0, 3.0, 'y', 90.0) = }\")\n", "graphics/__init__.py": "", "graphs/minimum_path_sum.py": "def min_path_sum(grid: list) -> int:\n    \"\"\"\n    Find the path from top left to bottom right of array of numbers\n    with the lowest possible sum and return the sum along this path.\n    >>> min_path_sum([\n    ...     [1, 3, 1],\n    ...     [1, 5, 1],\n    ...     [4, 2, 1],\n    ... ])\n    7\n\n    >>> min_path_sum([\n    ...     [1, 0, 5, 6, 7],\n    ...     [8, 9, 0, 4, 2],\n    ...     [4, 4, 4, 5, 1],\n    ...     [9, 6, 3, 1, 0],\n    ...     [8, 4, 3, 2, 7],\n    ... ])\n    20\n\n    >>> min_path_sum(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: The grid does not contain the appropriate information\n\n    >>> min_path_sum([[]])\n    Traceback (most recent call last):\n        ...\n    TypeError: The grid does not contain the appropriate information\n    \"\"\"\n\n    if not grid or not grid[0]:\n        raise TypeError(\"The grid does not contain the appropriate information\")\n\n    for cell_n in range(1, len(grid[0])):\n        grid[0][cell_n] += grid[0][cell_n - 1]\n    row_above = grid[0]\n\n    for row_n in range(1, len(grid)):\n        current_row = grid[row_n]\n        grid[row_n] = fill_row(current_row, row_above)\n        row_above = grid[row_n]\n\n    return grid[-1][-1]\n\n\ndef fill_row(current_row: list, row_above: list) -> list:\n    \"\"\"\n    >>> fill_row([2, 2, 2], [1, 2, 3])\n    [3, 4, 5]\n    \"\"\"\n\n    current_row[0] += row_above[0]\n    for cell_n in range(1, len(current_row)):\n        current_row[cell_n] += min(current_row[cell_n - 1], row_above[cell_n])\n\n    return current_row\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/graph_adjacency_matrix.py": "#!/usr/bin/env python3\n\"\"\"\nAuthor: Vikram Nithyanandam\n\nDescription:\nThe following implementation is a robust unweighted Graph data structure\nimplemented using an adjacency matrix. This vertices and edges of this graph can be\neffectively initialized and modified while storing your chosen generic\nvalue in each vertex.\n\nAdjacency Matrix: https://mathworld.wolfram.com/AdjacencyMatrix.html\n\nPotential Future Ideas:\n- Add a flag to set edge weights on and set edge weights\n- Make edge weights and vertex values customizable to store whatever the client wants\n- Support multigraph functionality if the client wants it\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\nimport unittest\nfrom pprint import pformat\nfrom typing import Generic, TypeVar\n\nimport pytest\n\nT = TypeVar(\"T\")\n\n\nclass GraphAdjacencyMatrix(Generic[T]):\n    def __init__(\n        self, vertices: list[T], edges: list[list[T]], directed: bool = True\n    ) -> None:\n        \"\"\"\n        Parameters:\n        - vertices: (list[T]) The list of vertex names the client wants to\n        pass in. Default is empty.\n        - edges: (list[list[T]]) The list of edges the client wants to\n        pass in. Each edge is a 2-element list. Default is empty.\n        - directed: (bool) Indicates if graph is directed or undirected.\n        Default is True.\n        \"\"\"\n        self.directed = directed\n        self.vertex_to_index: dict[T, int] = {}\n        self.adj_matrix: list[list[int]] = []\n\n        # Falsey checks\n        edges = edges or []\n        vertices = vertices or []\n\n        for vertex in vertices:\n            self.add_vertex(vertex)\n\n        for edge in edges:\n            if len(edge) != 2:\n                msg = f\"Invalid input: {edge} must have length 2.\"\n                raise ValueError(msg)\n            self.add_edge(edge[0], edge[1])\n\n    def add_edge(self, source_vertex: T, destination_vertex: T) -> None:\n        \"\"\"\n        Creates an edge from source vertex to destination vertex. If any\n        given vertex doesn't exist or the edge already exists, a ValueError\n        will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} or \"\n                f\"{destination_vertex} does not exist\"\n            )\n            raise ValueError(msg)\n        if self.contains_edge(source_vertex, destination_vertex):\n            msg = (\n                \"Incorrect input: The edge already exists between \"\n                f\"{source_vertex} and {destination_vertex}\"\n            )\n            raise ValueError(msg)\n\n        # Get the indices of the corresponding vertices and set their edge value to 1.\n        u: int = self.vertex_to_index[source_vertex]\n        v: int = self.vertex_to_index[destination_vertex]\n        self.adj_matrix[u][v] = 1\n        if not self.directed:\n            self.adj_matrix[v][u] = 1\n\n    def remove_edge(self, source_vertex: T, destination_vertex: T) -> None:\n        \"\"\"\n        Removes the edge between the two vertices. If any given vertex\n        doesn't exist or the edge does not exist, a ValueError will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} or \"\n                f\"{destination_vertex} does not exist\"\n            )\n            raise ValueError(msg)\n        if not self.contains_edge(source_vertex, destination_vertex):\n            msg = (\n                \"Incorrect input: The edge does NOT exist between \"\n                f\"{source_vertex} and {destination_vertex}\"\n            )\n            raise ValueError(msg)\n\n        # Get the indices of the corresponding vertices and set their edge value to 0.\n        u: int = self.vertex_to_index[source_vertex]\n        v: int = self.vertex_to_index[destination_vertex]\n        self.adj_matrix[u][v] = 0\n        if not self.directed:\n            self.adj_matrix[v][u] = 0\n\n    def add_vertex(self, vertex: T) -> None:\n        \"\"\"\n        Adds a vertex to the graph. If the given vertex already exists,\n        a ValueError will be thrown.\n        \"\"\"\n        if self.contains_vertex(vertex):\n            msg = f\"Incorrect input: {vertex} already exists in this graph.\"\n            raise ValueError(msg)\n\n        # build column for vertex\n        for row in self.adj_matrix:\n            row.append(0)\n\n        # build row for vertex and update other data structures\n        self.adj_matrix.append([0] * (len(self.adj_matrix) + 1))\n        self.vertex_to_index[vertex] = len(self.adj_matrix) - 1\n\n    def remove_vertex(self, vertex: T) -> None:\n        \"\"\"\n        Removes the given vertex from the graph and deletes all incoming and\n        outgoing edges from the given vertex as well. If the given vertex\n        does not exist, a ValueError will be thrown.\n        \"\"\"\n        if not self.contains_vertex(vertex):\n            msg = f\"Incorrect input: {vertex} does not exist in this graph.\"\n            raise ValueError(msg)\n\n        # first slide up the rows by deleting the row corresponding to\n        # the vertex being deleted.\n        start_index = self.vertex_to_index[vertex]\n        self.adj_matrix.pop(start_index)\n\n        # next, slide the columns to the left by deleting the values in\n        # the column corresponding to the vertex being deleted\n        for lst in self.adj_matrix:\n            lst.pop(start_index)\n\n        # final clean up\n        self.vertex_to_index.pop(vertex)\n\n        # decrement indices for vertices shifted by the deleted vertex in the adj matrix\n        for vertex in self.vertex_to_index:\n            if self.vertex_to_index[vertex] >= start_index:\n                self.vertex_to_index[vertex] = self.vertex_to_index[vertex] - 1\n\n    def contains_vertex(self, vertex: T) -> bool:\n        \"\"\"\n        Returns True if the graph contains the vertex, False otherwise.\n        \"\"\"\n        return vertex in self.vertex_to_index\n\n    def contains_edge(self, source_vertex: T, destination_vertex: T) -> bool:\n        \"\"\"\n        Returns True if the graph contains the edge from the source_vertex to the\n        destination_vertex, False otherwise. If any given vertex doesn't exist, a\n        ValueError will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} \"\n                f\"or {destination_vertex} does not exist.\"\n            )\n            raise ValueError(msg)\n\n        u = self.vertex_to_index[source_vertex]\n        v = self.vertex_to_index[destination_vertex]\n        return self.adj_matrix[u][v] == 1\n\n    def clear_graph(self) -> None:\n        \"\"\"\n        Clears all vertices and edges.\n        \"\"\"\n        self.vertex_to_index = {}\n        self.adj_matrix = []\n\n    def __repr__(self) -> str:\n        first = \"Adj Matrix:\\n\" + pformat(self.adj_matrix)\n        second = \"\\nVertex to index mapping:\\n\" + pformat(self.vertex_to_index)\n        return first + second\n\n\nclass TestGraphMatrix(unittest.TestCase):\n    def __assert_graph_edge_exists_check(\n        self,\n        undirected_graph: GraphAdjacencyMatrix,\n        directed_graph: GraphAdjacencyMatrix,\n        edge: list[int],\n    ) -> None:\n        assert undirected_graph.contains_edge(edge[0], edge[1])\n        assert undirected_graph.contains_edge(edge[1], edge[0])\n        assert directed_graph.contains_edge(edge[0], edge[1])\n\n    def __assert_graph_edge_does_not_exist_check(\n        self,\n        undirected_graph: GraphAdjacencyMatrix,\n        directed_graph: GraphAdjacencyMatrix,\n        edge: list[int],\n    ) -> None:\n        assert not undirected_graph.contains_edge(edge[0], edge[1])\n        assert not undirected_graph.contains_edge(edge[1], edge[0])\n        assert not directed_graph.contains_edge(edge[0], edge[1])\n\n    def __assert_graph_vertex_exists_check(\n        self,\n        undirected_graph: GraphAdjacencyMatrix,\n        directed_graph: GraphAdjacencyMatrix,\n        vertex: int,\n    ) -> None:\n        assert undirected_graph.contains_vertex(vertex)\n        assert directed_graph.contains_vertex(vertex)\n\n    def __assert_graph_vertex_does_not_exist_check(\n        self,\n        undirected_graph: GraphAdjacencyMatrix,\n        directed_graph: GraphAdjacencyMatrix,\n        vertex: int,\n    ) -> None:\n        assert not undirected_graph.contains_vertex(vertex)\n        assert not directed_graph.contains_vertex(vertex)\n\n    def __generate_random_edges(\n        self, vertices: list[int], edge_pick_count: int\n    ) -> list[list[int]]:\n        assert edge_pick_count <= len(vertices)\n\n        random_source_vertices: list[int] = random.sample(\n            vertices[0 : int(len(vertices) / 2)], edge_pick_count\n        )\n        random_destination_vertices: list[int] = random.sample(\n            vertices[int(len(vertices) / 2) :], edge_pick_count\n        )\n        random_edges: list[list[int]] = []\n\n        for source in random_source_vertices:\n            for dest in random_destination_vertices:\n                random_edges.append([source, dest])\n\n        return random_edges\n\n    def __generate_graphs(\n        self, vertex_count: int, min_val: int, max_val: int, edge_pick_count: int\n    ) -> tuple[GraphAdjacencyMatrix, GraphAdjacencyMatrix, list[int], list[list[int]]]:\n        if max_val - min_val + 1 < vertex_count:\n            raise ValueError(\n                \"Will result in duplicate vertices. Either increase \"\n                \"range between min_val and max_val or decrease vertex count\"\n            )\n\n        # generate graph input\n        random_vertices: list[int] = random.sample(\n            range(min_val, max_val + 1), vertex_count\n        )\n        random_edges: list[list[int]] = self.__generate_random_edges(\n            random_vertices, edge_pick_count\n        )\n\n        # build graphs\n        undirected_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=random_edges, directed=False\n        )\n        directed_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=random_edges, directed=True\n        )\n\n        return undirected_graph, directed_graph, random_vertices, random_edges\n\n    def test_init_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # test graph initialization with vertices and edges\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n        for edge in random_edges:\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n\n        assert not undirected_graph.directed\n        assert directed_graph.directed\n\n    def test_contains_vertex(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # Build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # Test contains_vertex\n        for num in range(101):\n            assert (num in random_vertices) == undirected_graph.contains_vertex(num)\n            assert (num in random_vertices) == directed_graph.contains_vertex(num)\n\n    def test_add_vertices(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # build empty graphs\n        undirected_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(\n            vertices=[], edges=[], directed=False\n        )\n        directed_graph: GraphAdjacencyMatrix = GraphAdjacencyMatrix(\n            vertices=[], edges=[], directed=True\n        )\n\n        # run add_vertex\n        for num in random_vertices:\n            undirected_graph.add_vertex(num)\n\n        for num in random_vertices:\n            directed_graph.add_vertex(num)\n\n        # test add_vertex worked\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n    def test_remove_vertices(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # test remove_vertex worked\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n            undirected_graph.remove_vertex(num)\n            directed_graph.remove_vertex(num)\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, num\n            )\n\n    def test_add_and_remove_vertices_repeatedly(self) -> None:\n        random_vertices1: list[int] = random.sample(range(51), 20)\n        random_vertices2: list[int] = random.sample(range(51, 101), 20)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices1, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices1, edges=[], directed=True\n        )\n\n        # test adding and removing vertices\n        for i, _ in enumerate(random_vertices1):\n            undirected_graph.add_vertex(random_vertices2[i])\n            directed_graph.add_vertex(random_vertices2[i])\n\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, random_vertices2[i]\n            )\n\n            undirected_graph.remove_vertex(random_vertices1[i])\n            directed_graph.remove_vertex(random_vertices1[i])\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, random_vertices1[i]\n            )\n\n        # remove all vertices\n        for i, _ in enumerate(random_vertices1):\n            undirected_graph.remove_vertex(random_vertices2[i])\n            directed_graph.remove_vertex(random_vertices2[i])\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, random_vertices2[i]\n            )\n\n    def test_contains_edge(self) -> None:\n        # generate graphs and graph input\n        vertex_count = 20\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(vertex_count, 0, 100, 4)\n\n        # generate all possible edges for testing\n        all_possible_edges: list[list[int]] = []\n        for i in range(vertex_count - 1):\n            for j in range(i + 1, vertex_count):\n                all_possible_edges.append([random_vertices[i], random_vertices[j]])\n                all_possible_edges.append([random_vertices[j], random_vertices[i]])\n\n        # test contains_edge function\n        for edge in all_possible_edges:\n            if edge in random_edges:\n                self.__assert_graph_edge_exists_check(\n                    undirected_graph, directed_graph, edge\n                )\n            elif [edge[1], edge[0]] in random_edges:\n                # since this edge exists for undirected but the reverse may\n                # not exist for directed\n                self.__assert_graph_edge_exists_check(\n                    undirected_graph, directed_graph, [edge[1], edge[0]]\n                )\n            else:\n                self.__assert_graph_edge_does_not_exist_check(\n                    undirected_graph, directed_graph, edge\n                )\n\n    def test_add_edge(self) -> None:\n        # generate graph input\n        random_vertices: list[int] = random.sample(range(101), 15)\n        random_edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyMatrix(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # run and test add_edge\n        for edge in random_edges:\n            undirected_graph.add_edge(edge[0], edge[1])\n            directed_graph.add_edge(edge[0], edge[1])\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n\n    def test_remove_edge(self) -> None:\n        # generate graph input and graphs\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # run and test remove_edge\n        for edge in random_edges:\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n            undirected_graph.remove_edge(edge[0], edge[1])\n            directed_graph.remove_edge(edge[0], edge[1])\n            self.__assert_graph_edge_does_not_exist_check(\n                undirected_graph, directed_graph, edge\n            )\n\n    def test_add_and_remove_edges_repeatedly(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # make some more edge options!\n        more_random_edges: list[list[int]] = []\n\n        while len(more_random_edges) != len(random_edges):\n            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n            for edge in edges:\n                if len(more_random_edges) == len(random_edges):\n                    break\n                elif edge not in more_random_edges and edge not in random_edges:\n                    more_random_edges.append(edge)\n\n        for i, _ in enumerate(random_edges):\n            undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])\n            directed_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])\n\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, more_random_edges[i]\n            )\n\n            undirected_graph.remove_edge(random_edges[i][0], random_edges[i][1])\n            directed_graph.remove_edge(random_edges[i][0], random_edges[i][1])\n\n            self.__assert_graph_edge_does_not_exist_check(\n                undirected_graph, directed_graph, random_edges[i]\n            )\n\n    def test_add_vertex_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for vertex in random_vertices:\n            with pytest.raises(ValueError):\n                undirected_graph.add_vertex(vertex)\n            with pytest.raises(ValueError):\n                directed_graph.add_vertex(vertex)\n\n    def test_remove_vertex_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for i in range(101):\n            if i not in random_vertices:\n                with pytest.raises(ValueError):\n                    undirected_graph.remove_vertex(i)\n                with pytest.raises(ValueError):\n                    directed_graph.remove_vertex(i)\n\n    def test_add_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for edge in random_edges:\n            with pytest.raises(ValueError):\n                undirected_graph.add_edge(edge[0], edge[1])\n            with pytest.raises(ValueError):\n                directed_graph.add_edge(edge[0], edge[1])\n\n    def test_remove_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        more_random_edges: list[list[int]] = []\n\n        while len(more_random_edges) != len(random_edges):\n            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n            for edge in edges:\n                if len(more_random_edges) == len(random_edges):\n                    break\n                elif edge not in more_random_edges and edge not in random_edges:\n                    more_random_edges.append(edge)\n\n        for edge in more_random_edges:\n            with pytest.raises(ValueError):\n                undirected_graph.remove_edge(edge[0], edge[1])\n            with pytest.raises(ValueError):\n                directed_graph.remove_edge(edge[0], edge[1])\n\n    def test_contains_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for vertex in random_vertices:\n            with pytest.raises(ValueError):\n                undirected_graph.contains_edge(vertex, 102)\n            with pytest.raises(ValueError):\n                directed_graph.contains_edge(vertex, 102)\n\n        with pytest.raises(ValueError):\n            undirected_graph.contains_edge(103, 102)\n        with pytest.raises(ValueError):\n            directed_graph.contains_edge(103, 102)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "graphs/breadth_first_search_2.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Breadth-first_search\npseudo-code:\nbreadth_first_search(graph G, start vertex s):\n// all nodes initially unexplored\nmark s as explored\nlet Q = queue data structure, initialized with s\nwhile Q is non-empty:\n    remove the first node of Q, call it v\n    for each edge(v, w):  // for w in graph[v]\n        if w unexplored:\n            mark w as explored\n            add w to Q (at the end)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import deque\nfrom queue import Queue\nfrom timeit import timeit\n\nG = {\n    \"A\": [\"B\", \"C\"],\n    \"B\": [\"A\", \"D\", \"E\"],\n    \"C\": [\"A\", \"F\"],\n    \"D\": [\"B\"],\n    \"E\": [\"B\", \"F\"],\n    \"F\": [\"C\", \"E\"],\n}\n\n\ndef breadth_first_search(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using queue.Queue.\n\n    >>> ''.join(breadth_first_search(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    explored = {start}\n    result = [start]\n    queue: Queue = Queue()\n    queue.put(start)\n    while not queue.empty():\n        v = queue.get()\n        for w in graph[v]:\n            if w not in explored:\n                explored.add(w)\n                result.append(w)\n                queue.put(w)\n    return result\n\n\ndef breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:\n    \"\"\"\n    Implementation of breadth first search using collection.queue.\n\n    >>> ''.join(breadth_first_search_with_deque(G, 'A'))\n    'ABCDEF'\n    \"\"\"\n    visited = {start}\n    result = [start]\n    queue = deque([start])\n    while queue:\n        v = queue.popleft()\n        for child in graph[v]:\n            if child not in visited:\n                visited.add(child)\n                result.append(child)\n                queue.append(child)\n    return result\n\n\ndef benchmark_function(name: str) -> None:\n    setup = f\"from __main__ import G, {name}\"\n    number = 10000\n    res = timeit(f\"{name}(G, 'A')\", setup=setup, number=number)\n    print(f\"{name:<35} finished {number} runs in {res:.5f} seconds\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    benchmark_function(\"breadth_first_search\")\n    benchmark_function(\"breadth_first_search_with_deque\")\n    # breadth_first_search                finished 10000 runs in 0.20999 seconds\n    # breadth_first_search_with_deque     finished 10000 runs in 0.01421 seconds\n", "graphs/depth_first_search_2.py": "#!/usr/bin/python\n\n\"\"\"Author: OMKAR PATHAK\"\"\"\n\n\nclass Graph:\n    def __init__(self):\n        self.vertex = {}\n\n    # for printing the Graph vertices\n    def print_graph(self) -> None:\n        \"\"\"\n        Print the graph vertices.\n\n        Example:\n        >>> g = Graph()\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 2)\n        >>> g.add_edge(1, 2)\n        >>> g.add_edge(2, 0)\n        >>> g.add_edge(2, 3)\n        >>> g.add_edge(3, 3)\n        >>> g.print_graph()\n        {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n        0  ->  1 -> 2\n        1  ->  2\n        2  ->  0 -> 3\n        3  ->  3\n        \"\"\"\n        print(self.vertex)\n        for i in self.vertex:\n            print(i, \" -> \", \" -> \".join([str(j) for j in self.vertex[i]]))\n\n    # for adding the edge between two vertices\n    def add_edge(self, from_vertex: int, to_vertex: int) -> None:\n        \"\"\"\n        Add an edge between two vertices.\n\n        :param from_vertex: The source vertex.\n        :param to_vertex: The destination vertex.\n\n        Example:\n        >>> g = Graph()\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 2)\n        >>> g.print_graph()\n        {0: [1, 2]}\n        0  ->  1 -> 2\n        \"\"\"\n        # check if vertex is already present,\n        if from_vertex in self.vertex:\n            self.vertex[from_vertex].append(to_vertex)\n        else:\n            # else make a new vertex\n            self.vertex[from_vertex] = [to_vertex]\n\n    def dfs(self) -> None:\n        \"\"\"\n        Perform depth-first search (DFS) traversal on the graph\n        and print the visited vertices.\n\n        Example:\n        >>> g = Graph()\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 2)\n        >>> g.add_edge(1, 2)\n        >>> g.add_edge(2, 0)\n        >>> g.add_edge(2, 3)\n        >>> g.add_edge(3, 3)\n        >>> g.dfs()\n        0 1 2 3\n        \"\"\"\n        # visited array for storing already visited nodes\n        visited = [False] * len(self.vertex)\n\n        # call the recursive helper function\n        for i in range(len(self.vertex)):\n            if not visited[i]:\n                self.dfs_recursive(i, visited)\n\n    def dfs_recursive(self, start_vertex: int, visited: list) -> None:\n        \"\"\"\n        Perform a recursive depth-first search (DFS) traversal on the graph.\n\n        :param start_vertex: The starting vertex for the traversal.\n        :param visited: A list to track visited vertices.\n\n        Example:\n        >>> g = Graph()\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 2)\n        >>> g.add_edge(1, 2)\n        >>> g.add_edge(2, 0)\n        >>> g.add_edge(2, 3)\n        >>> g.add_edge(3, 3)\n        >>> visited = [False] * len(g.vertex)\n        >>> g.dfs_recursive(0, visited)\n        0 1 2 3\n        \"\"\"\n        # mark start vertex as visited\n        visited[start_vertex] = True\n\n        print(start_vertex, end=\"\")\n\n        # Recur for all the vertices that are adjacent to this node\n        for i in self.vertex:\n            if not visited[i]:\n                print(\" \", end=\"\")\n                self.dfs_recursive(i, visited)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    g = Graph()\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(1, 2)\n    g.add_edge(2, 0)\n    g.add_edge(2, 3)\n    g.add_edge(3, 3)\n\n    g.print_graph()\n    print(\"DFS:\")\n    g.dfs()\n", "graphs/matching_min_vertex_cover.py": "\"\"\"\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\n* Description: Approximization algorithm for minimum vertex cover problem.\n               Matching Approach. Uses graphs represented with an adjacency list\n\nURL: https://mathworld.wolfram.com/MinimumVertexCover.html\nURL: https://www.princeton.edu/~aaa/Public/Teaching/ORF523/ORF523_Lec6.pdf\n\"\"\"\n\n\ndef matching_min_vertex_cover(graph: dict) -> set:\n    \"\"\"\n    APX Algorithm for min Vertex Cover using Matching Approach\n    @input: graph (graph stored in an adjacency list where each vertex\n            is represented as an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    >>> matching_min_vertex_cover(graph)\n    {0, 1, 2, 4}\n    \"\"\"\n    # chosen_vertices = set of chosen vertices\n    chosen_vertices = set()\n    # edges = list of graph's edges\n    edges = get_edges(graph)\n\n    # While there are still elements in edges list, take an arbitrary edge\n    # (from_node, to_node) and add his extremity to chosen_vertices and then\n    # remove all arcs adjacent to the from_node and to_node\n    while edges:\n        from_node, to_node = edges.pop()\n        chosen_vertices.add(from_node)\n        chosen_vertices.add(to_node)\n        for edge in edges.copy():\n            if from_node in edge or to_node in edge:\n                edges.discard(edge)\n    return chosen_vertices\n\n\ndef get_edges(graph: dict) -> set:\n    \"\"\"\n    Return a set of couples that represents all of the edges.\n    @input: graph (graph stored in an adjacency list where each vertex is\n            represented as an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}\n    >>> get_edges(graph)\n    {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}\n    \"\"\"\n    edges = set()\n    for from_node, to_nodes in graph.items():\n        for to_node in to_nodes:\n            edges.add((from_node, to_node))\n    return edges\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    # print(f\"Matching vertex cover:\\n{matching_min_vertex_cover(graph)}\")\n", "graphs/directed_and_undirected_weighted_graph.py": "from collections import deque\nfrom math import floor\nfrom random import random\nfrom time import time\n\n# the default weight is 1 if not assigned but all the implementation is weighted\n\n\nclass DirectedGraph:\n    def __init__(self):\n        self.graph = {}\n\n    # adding vertices and edges\n    # adding the weight is optional\n    # handles repetition\n    def add_pair(self, u, v, w=1):\n        if self.graph.get(u):\n            if self.graph[u].count([w, v]) == 0:\n                self.graph[u].append([w, v])\n        else:\n            self.graph[u] = [[w, v]]\n        if not self.graph.get(v):\n            self.graph[v] = []\n\n    def all_nodes(self):\n        return list(self.graph)\n\n    # handles if the input does not exist\n    def remove_pair(self, u, v):\n        if self.graph.get(u):\n            for _ in self.graph[u]:\n                if _[1] == v:\n                    self.graph[u].remove(_)\n\n    # if no destination is meant the default value is -1\n    def dfs(self, s=-2, d=-1):\n        if s == d:\n            return []\n        stack = []\n        visited = []\n        if s == -2:\n            s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        ss = s\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if visited.count(node[1]) < 1:\n                        if node[1] == d:\n                            visited.append(d)\n                            return visited\n                        else:\n                            stack.append(node[1])\n                            visited.append(node[1])\n                            ss = node[1]\n                            break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return visited\n\n    # c is the count of nodes you want and if you leave it or pass -1 to the function\n    # the count will be random from 10 to 10000\n    def fill_graph_randomly(self, c=-1):\n        if c == -1:\n            c = floor(random() * 10000) + 10\n        for i in range(c):\n            # every vertex has max 100 edges\n            for _ in range(floor(random() * 102) + 1):\n                n = floor(random() * c) + 1\n                if n != i:\n                    self.add_pair(i, n, 1)\n\n    def bfs(self, s=-2):\n        d = deque()\n        visited = []\n        if s == -2:\n            s = next(iter(self.graph))\n        d.append(s)\n        visited.append(s)\n        while d:\n            s = d.popleft()\n            if len(self.graph[s]) != 0:\n                for node in self.graph[s]:\n                    if visited.count(node[1]) < 1:\n                        d.append(node[1])\n                        visited.append(node[1])\n        return visited\n\n    def in_degree(self, u):\n        count = 0\n        for x in self.graph:\n            for y in self.graph[x]:\n                if y[1] == u:\n                    count += 1\n        return count\n\n    def out_degree(self, u):\n        return len(self.graph[u])\n\n    def topological_sort(self, s=-2):\n        stack = []\n        visited = []\n        if s == -2:\n            s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        ss = s\n        sorted_nodes = []\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if visited.count(node[1]) < 1:\n                        stack.append(node[1])\n                        visited.append(node[1])\n                        ss = node[1]\n                        break\n\n            # check if all the children are visited\n            if s == ss:\n                sorted_nodes.append(stack.pop())\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return sorted_nodes\n\n    def cycle_nodes(self):\n        stack = []\n        visited = []\n        s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        parent = -2\n        indirect_parents = []\n        ss = s\n        on_the_way_back = False\n        anticipating_nodes = set()\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if (\n                        visited.count(node[1]) > 0\n                        and node[1] != parent\n                        and indirect_parents.count(node[1]) > 0\n                        and not on_the_way_back\n                    ):\n                        len_stack = len(stack) - 1\n                        while len_stack >= 0:\n                            if stack[len_stack] == node[1]:\n                                anticipating_nodes.add(node[1])\n                                break\n                            else:\n                                anticipating_nodes.add(stack[len_stack])\n                                len_stack -= 1\n                    if visited.count(node[1]) < 1:\n                        stack.append(node[1])\n                        visited.append(node[1])\n                        ss = node[1]\n                        break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                on_the_way_back = True\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                on_the_way_back = False\n                indirect_parents.append(parent)\n                parent = s\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return list(anticipating_nodes)\n\n    def has_cycle(self):\n        stack = []\n        visited = []\n        s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        parent = -2\n        indirect_parents = []\n        ss = s\n        on_the_way_back = False\n        anticipating_nodes = set()\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if (\n                        visited.count(node[1]) > 0\n                        and node[1] != parent\n                        and indirect_parents.count(node[1]) > 0\n                        and not on_the_way_back\n                    ):\n                        len_stack_minus_one = len(stack) - 1\n                        while len_stack_minus_one >= 0:\n                            if stack[len_stack_minus_one] == node[1]:\n                                anticipating_nodes.add(node[1])\n                                break\n                            else:\n                                return True\n                    if visited.count(node[1]) < 1:\n                        stack.append(node[1])\n                        visited.append(node[1])\n                        ss = node[1]\n                        break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                on_the_way_back = True\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                on_the_way_back = False\n                indirect_parents.append(parent)\n                parent = s\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return False\n\n    def dfs_time(self, s=-2, e=-1):\n        begin = time()\n        self.dfs(s, e)\n        end = time()\n        return end - begin\n\n    def bfs_time(self, s=-2):\n        begin = time()\n        self.bfs(s)\n        end = time()\n        return end - begin\n\n\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    # adding vertices and edges\n    # adding the weight is optional\n    # handles repetition\n    def add_pair(self, u, v, w=1):\n        # check if the u exists\n        if self.graph.get(u):\n            # if there already is a edge\n            if self.graph[u].count([w, v]) == 0:\n                self.graph[u].append([w, v])\n        else:\n            # if u does not exist\n            self.graph[u] = [[w, v]]\n        # add the other way\n        if self.graph.get(v):\n            # if there already is a edge\n            if self.graph[v].count([w, u]) == 0:\n                self.graph[v].append([w, u])\n        else:\n            # if u does not exist\n            self.graph[v] = [[w, u]]\n\n    # handles if the input does not exist\n    def remove_pair(self, u, v):\n        if self.graph.get(u):\n            for _ in self.graph[u]:\n                if _[1] == v:\n                    self.graph[u].remove(_)\n        # the other way round\n        if self.graph.get(v):\n            for _ in self.graph[v]:\n                if _[1] == u:\n                    self.graph[v].remove(_)\n\n    # if no destination is meant the default value is -1\n    def dfs(self, s=-2, d=-1):\n        if s == d:\n            return []\n        stack = []\n        visited = []\n        if s == -2:\n            s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        ss = s\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if visited.count(node[1]) < 1:\n                        if node[1] == d:\n                            visited.append(d)\n                            return visited\n                        else:\n                            stack.append(node[1])\n                            visited.append(node[1])\n                            ss = node[1]\n                            break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return visited\n\n    # c is the count of nodes you want and if you leave it or pass -1 to the function\n    # the count will be random from 10 to 10000\n    def fill_graph_randomly(self, c=-1):\n        if c == -1:\n            c = floor(random() * 10000) + 10\n        for i in range(c):\n            # every vertex has max 100 edges\n            for _ in range(floor(random() * 102) + 1):\n                n = floor(random() * c) + 1\n                if n != i:\n                    self.add_pair(i, n, 1)\n\n    def bfs(self, s=-2):\n        d = deque()\n        visited = []\n        if s == -2:\n            s = next(iter(self.graph))\n        d.append(s)\n        visited.append(s)\n        while d:\n            s = d.popleft()\n            if len(self.graph[s]) != 0:\n                for node in self.graph[s]:\n                    if visited.count(node[1]) < 1:\n                        d.append(node[1])\n                        visited.append(node[1])\n        return visited\n\n    def degree(self, u):\n        return len(self.graph[u])\n\n    def cycle_nodes(self):\n        stack = []\n        visited = []\n        s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        parent = -2\n        indirect_parents = []\n        ss = s\n        on_the_way_back = False\n        anticipating_nodes = set()\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if (\n                        visited.count(node[1]) > 0\n                        and node[1] != parent\n                        and indirect_parents.count(node[1]) > 0\n                        and not on_the_way_back\n                    ):\n                        len_stack = len(stack) - 1\n                        while len_stack >= 0:\n                            if stack[len_stack] == node[1]:\n                                anticipating_nodes.add(node[1])\n                                break\n                            else:\n                                anticipating_nodes.add(stack[len_stack])\n                                len_stack -= 1\n                    if visited.count(node[1]) < 1:\n                        stack.append(node[1])\n                        visited.append(node[1])\n                        ss = node[1]\n                        break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                on_the_way_back = True\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                on_the_way_back = False\n                indirect_parents.append(parent)\n                parent = s\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return list(anticipating_nodes)\n\n    def has_cycle(self):\n        stack = []\n        visited = []\n        s = next(iter(self.graph))\n        stack.append(s)\n        visited.append(s)\n        parent = -2\n        indirect_parents = []\n        ss = s\n        on_the_way_back = False\n        anticipating_nodes = set()\n\n        while True:\n            # check if there is any non isolated nodes\n            if len(self.graph[s]) != 0:\n                ss = s\n                for node in self.graph[s]:\n                    if (\n                        visited.count(node[1]) > 0\n                        and node[1] != parent\n                        and indirect_parents.count(node[1]) > 0\n                        and not on_the_way_back\n                    ):\n                        len_stack_minus_one = len(stack) - 1\n                        while len_stack_minus_one >= 0:\n                            if stack[len_stack_minus_one] == node[1]:\n                                anticipating_nodes.add(node[1])\n                                break\n                            else:\n                                return True\n                    if visited.count(node[1]) < 1:\n                        stack.append(node[1])\n                        visited.append(node[1])\n                        ss = node[1]\n                        break\n\n            # check if all the children are visited\n            if s == ss:\n                stack.pop()\n                on_the_way_back = True\n                if len(stack) != 0:\n                    s = stack[len(stack) - 1]\n            else:\n                on_the_way_back = False\n                indirect_parents.append(parent)\n                parent = s\n                s = ss\n\n            # check if se have reached the starting point\n            if len(stack) == 0:\n                return False\n\n    def all_nodes(self):\n        return list(self.graph)\n\n    def dfs_time(self, s=-2, e=-1):\n        begin = time()\n        self.dfs(s, e)\n        end = time()\n        return end - begin\n\n    def bfs_time(self, s=-2):\n        begin = time()\n        self.bfs(s)\n        end = time()\n        return end - begin\n", "graphs/minimum_spanning_tree_prims2.py": "\"\"\"\nPrim's (also known as Jarn\u00edk's) algorithm is a greedy algorithm that finds a minimum\nspanning tree for a weighted undirected graph. This means it finds a subset of the\nedges that forms a tree that includes every vertex, where the total weight of all the\nedges in the tree is minimized. The algorithm operates by building this tree one vertex\nat a time, from an arbitrary starting vertex, at each step adding the cheapest possible\nconnection from the tree to another vertex.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sys import maxsize\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef get_parent_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the parent of the current node\n\n    >>> get_parent_position(1)\n    0\n    >>> get_parent_position(2)\n    0\n    \"\"\"\n    return (position - 1) // 2\n\n\ndef get_child_left_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the left child of the current node\n\n    >>> get_child_left_position(0)\n    1\n    \"\"\"\n    return (2 * position) + 1\n\n\ndef get_child_right_position(position: int) -> int:\n    \"\"\"\n    heap helper function get the position of the right child of the current node\n\n    >>> get_child_right_position(0)\n    2\n    \"\"\"\n    return (2 * position) + 2\n\n\nclass MinPriorityQueue(Generic[T]):\n    \"\"\"\n    Minimum Priority Queue Class\n\n    Functions:\n    is_empty: function to check if the priority queue is empty\n    push: function to add an element with given priority to the queue\n    extract_min: function to remove and return the element with lowest weight (highest\n                 priority)\n    update_key: function to update the weight of the given key\n    _bubble_up: helper function to place a node at the proper position (upward\n                movement)\n    _bubble_down: helper function to place a node at the proper position (downward\n                movement)\n    _swap_nodes: helper function to swap the nodes at the given positions\n\n    >>> queue = MinPriorityQueue()\n\n    >>> queue.push(1, 1000)\n    >>> queue.push(2, 100)\n    >>> queue.push(3, 4000)\n    >>> queue.push(4, 3000)\n\n    >>> queue.extract_min()\n    2\n\n    >>> queue.update_key(4, 50)\n\n    >>> queue.extract_min()\n    4\n    >>> queue.extract_min()\n    1\n    >>> queue.extract_min()\n    3\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.heap: list[tuple[T, int]] = []\n        self.position_map: dict[T, int] = {}\n        self.elements: int = 0\n\n    def __len__(self) -> int:\n        return self.elements\n\n    def __repr__(self) -> str:\n        return str(self.heap)\n\n    def is_empty(self) -> bool:\n        # Check if the priority queue is empty\n        return self.elements == 0\n\n    def push(self, elem: T, weight: int) -> None:\n        # Add an element with given priority to the queue\n        self.heap.append((elem, weight))\n        self.position_map[elem] = self.elements\n        self.elements += 1\n        self._bubble_up(elem)\n\n    def extract_min(self) -> T:\n        # Remove and return the element with lowest weight (highest priority)\n        if self.elements > 1:\n            self._swap_nodes(0, self.elements - 1)\n        elem, _ = self.heap.pop()\n        del self.position_map[elem]\n        self.elements -= 1\n        if self.elements > 0:\n            bubble_down_elem, _ = self.heap[0]\n            self._bubble_down(bubble_down_elem)\n        return elem\n\n    def update_key(self, elem: T, weight: int) -> None:\n        # Update the weight of the given key\n        position = self.position_map[elem]\n        self.heap[position] = (elem, weight)\n        if position > 0:\n            parent_position = get_parent_position(position)\n            _, parent_weight = self.heap[parent_position]\n            if parent_weight > weight:\n                self._bubble_up(elem)\n            else:\n                self._bubble_down(elem)\n        else:\n            self._bubble_down(elem)\n\n    def _bubble_up(self, elem: T) -> None:\n        # Place a node at the proper position (upward movement) [to be used internally\n        # only]\n        curr_pos = self.position_map[elem]\n        if curr_pos == 0:\n            return None\n        parent_position = get_parent_position(curr_pos)\n        _, weight = self.heap[curr_pos]\n        _, parent_weight = self.heap[parent_position]\n        if parent_weight > weight:\n            self._swap_nodes(parent_position, curr_pos)\n            return self._bubble_up(elem)\n        return None\n\n    def _bubble_down(self, elem: T) -> None:\n        # Place a node at the proper position (downward movement) [to be used\n        # internally only]\n        curr_pos = self.position_map[elem]\n        _, weight = self.heap[curr_pos]\n        child_left_position = get_child_left_position(curr_pos)\n        child_right_position = get_child_right_position(curr_pos)\n        if child_left_position < self.elements and child_right_position < self.elements:\n            _, child_left_weight = self.heap[child_left_position]\n            _, child_right_weight = self.heap[child_right_position]\n            if child_right_weight < child_left_weight and child_right_weight < weight:\n                self._swap_nodes(child_right_position, curr_pos)\n                return self._bubble_down(elem)\n        if child_left_position < self.elements:\n            _, child_left_weight = self.heap[child_left_position]\n            if child_left_weight < weight:\n                self._swap_nodes(child_left_position, curr_pos)\n                return self._bubble_down(elem)\n        else:\n            return None\n        if child_right_position < self.elements:\n            _, child_right_weight = self.heap[child_right_position]\n            if child_right_weight < weight:\n                self._swap_nodes(child_right_position, curr_pos)\n                return self._bubble_down(elem)\n        return None\n\n    def _swap_nodes(self, node1_pos: int, node2_pos: int) -> None:\n        # Swap the nodes at the given positions\n        node1_elem = self.heap[node1_pos][0]\n        node2_elem = self.heap[node2_pos][0]\n        self.heap[node1_pos], self.heap[node2_pos] = (\n            self.heap[node2_pos],\n            self.heap[node1_pos],\n        )\n        self.position_map[node1_elem] = node2_pos\n        self.position_map[node2_elem] = node1_pos\n\n\nclass GraphUndirectedWeighted(Generic[T]):\n    \"\"\"\n    Graph Undirected Weighted Class\n\n    Functions:\n    add_node: function to add a node in the graph\n    add_edge: function to add an edge between 2 nodes in the graph\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.connections: dict[T, dict[T, int]] = {}\n        self.nodes: int = 0\n\n    def __repr__(self) -> str:\n        return str(self.connections)\n\n    def __len__(self) -> int:\n        return self.nodes\n\n    def add_node(self, node: T) -> None:\n        # Add a node in the graph if it is not in the graph\n        if node not in self.connections:\n            self.connections[node] = {}\n            self.nodes += 1\n\n    def add_edge(self, node1: T, node2: T, weight: int) -> None:\n        # Add an edge between 2 nodes in the graph\n        self.add_node(node1)\n        self.add_node(node2)\n        self.connections[node1][node2] = weight\n        self.connections[node2][node1] = weight\n\n\ndef prims_algo(\n    graph: GraphUndirectedWeighted[T],\n) -> tuple[dict[T, int], dict[T, T | None]]:\n    \"\"\"\n    >>> graph = GraphUndirectedWeighted()\n\n    >>> graph.add_edge(\"a\", \"b\", 3)\n    >>> graph.add_edge(\"b\", \"c\", 10)\n    >>> graph.add_edge(\"c\", \"d\", 5)\n    >>> graph.add_edge(\"a\", \"c\", 15)\n    >>> graph.add_edge(\"b\", \"d\", 100)\n\n    >>> dist, parent = prims_algo(graph)\n\n    >>> abs(dist[\"a\"] - dist[\"b\"])\n    3\n    >>> abs(dist[\"d\"] - dist[\"b\"])\n    15\n    >>> abs(dist[\"a\"] - dist[\"c\"])\n    13\n    \"\"\"\n    # prim's algorithm for minimum spanning tree\n    dist: dict[T, int] = {node: maxsize for node in graph.connections}\n    parent: dict[T, T | None] = {node: None for node in graph.connections}\n\n    priority_queue: MinPriorityQueue[T] = MinPriorityQueue()\n    for node, weight in dist.items():\n        priority_queue.push(node, weight)\n\n    if priority_queue.is_empty():\n        return dist, parent\n\n    # initialization\n    node = priority_queue.extract_min()\n    dist[node] = 0\n    for neighbour in graph.connections[node]:\n        if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\n            dist[neighbour] = dist[node] + graph.connections[node][neighbour]\n            priority_queue.update_key(neighbour, dist[neighbour])\n            parent[neighbour] = node\n\n    # running prim's algorithm\n    while not priority_queue.is_empty():\n        node = priority_queue.extract_min()\n        for neighbour in graph.connections[node]:\n            if dist[neighbour] > dist[node] + graph.connections[node][neighbour]:\n                dist[neighbour] = dist[node] + graph.connections[node][neighbour]\n                priority_queue.update_key(neighbour, dist[neighbour])\n                parent[neighbour] = node\n    return dist, parent\n", "graphs/finding_bridges.py": "\"\"\"\nAn edge is a bridge if, after removing it count of connected components in graph will\nbe increased by one. Bridges represent vulnerabilities in a connected network and are\nuseful for designing reliable networks. For example, in a wired computer network, an\narticulation point indicates the critical computers and a bridge indicates the critical\nwires or connections.\n\nFor more details, refer this article:\nhttps://www.geeksforgeeks.org/bridge-in-a-graph/\n\"\"\"\n\n\ndef __get_demo_graph(index):\n    return [\n        {\n            0: [1, 2],\n            1: [0, 2],\n            2: [0, 1, 3, 5],\n            3: [2, 4],\n            4: [3],\n            5: [2, 6, 8],\n            6: [5, 7],\n            7: [6, 8],\n            8: [5, 7],\n        },\n        {\n            0: [6],\n            1: [9],\n            2: [4, 5],\n            3: [4],\n            4: [2, 3],\n            5: [2],\n            6: [0, 7],\n            7: [6],\n            8: [],\n            9: [1],\n        },\n        {\n            0: [4],\n            1: [6],\n            2: [],\n            3: [5, 6, 7],\n            4: [0, 6],\n            5: [3, 8, 9],\n            6: [1, 3, 4, 7],\n            7: [3, 6, 8, 9],\n            8: [5, 7],\n            9: [5, 7],\n        },\n        {\n            0: [1, 3],\n            1: [0, 2, 4],\n            2: [1, 3, 4],\n            3: [0, 2, 4],\n            4: [1, 2, 3],\n        },\n    ][index]\n\n\ndef compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:\n    \"\"\"\n    Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi\n    >>> compute_bridges(__get_demo_graph(0))\n    [(3, 4), (2, 3), (2, 5)]\n    >>> compute_bridges(__get_demo_graph(1))\n    [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]\n    >>> compute_bridges(__get_demo_graph(2))\n    [(1, 6), (4, 6), (0, 4)]\n    >>> compute_bridges(__get_demo_graph(3))\n    []\n    >>> compute_bridges({})\n    []\n    \"\"\"\n\n    id_ = 0\n    n = len(graph)  # No of vertices in graph\n    low = [0] * n\n    visited = [False] * n\n\n    def dfs(at, parent, bridges, id_):\n        visited[at] = True\n        low[at] = id_\n        id_ += 1\n        for to in graph[at]:\n            if to == parent:\n                pass\n            elif not visited[to]:\n                dfs(to, at, bridges, id_)\n                low[at] = min(low[at], low[to])\n                if id_ <= low[to]:\n                    bridges.append((at, to) if at < to else (to, at))\n            else:\n                # This edge is a back edge and cannot be a bridge\n                low[at] = min(low[at], low[to])\n\n    bridges: list[tuple[int, int]] = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1, bridges, id_)\n    return bridges\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/check_cycle.py": "\"\"\"\nProgram to check if a cycle is present in a given graph\n\"\"\"\n\n\ndef check_cycle(graph: dict) -> bool:\n    \"\"\"\n    Returns True if graph is cyclic else False\n    >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})\n    False\n    >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})\n    True\n    \"\"\"\n    # Keep track of visited nodes\n    visited: set[int] = set()\n    # To detect a back edge, keep track of vertices currently in the recursion stack\n    rec_stk: set[int] = set()\n    return any(\n        node not in visited and depth_first_search(graph, node, visited, rec_stk)\n        for node in graph\n    )\n\n\ndef depth_first_search(graph: dict, vertex: int, visited: set, rec_stk: set) -> bool:\n    \"\"\"\n    Recur for all neighbours.\n    If any neighbour is visited and in rec_stk then graph is cyclic.\n    >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}\n    >>> vertex, visited, rec_stk = 0, set(), set()\n    >>> depth_first_search(graph, vertex, visited, rec_stk)\n    False\n    \"\"\"\n    # Mark current node as visited and add to recursion stack\n    visited.add(vertex)\n    rec_stk.add(vertex)\n\n    for node in graph[vertex]:\n        if node not in visited:\n            if depth_first_search(graph, node, visited, rec_stk):\n                return True\n        elif node in rec_stk:\n            return True\n\n    # The node needs to be removed from recursion stack before function ends\n    rec_stk.remove(vertex)\n    return False\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "graphs/prim.py": "\"\"\"Prim's Algorithm.\n\nDetermines the minimum spanning tree(MST) of a graph using the Prim's Algorithm.\n\nDetails: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n\"\"\"\n\nimport heapq as hq\nimport math\nfrom collections.abc import Iterator\n\n\nclass Vertex:\n    \"\"\"Class Vertex.\"\"\"\n\n    def __init__(self, id_):\n        \"\"\"\n        Arguments:\n            id - input an id to identify the vertex\n        Attributes:\n            neighbors - a list of the vertices it is linked to\n            edges     - a dict to store the edges's weight\n        \"\"\"\n        self.id = str(id_)\n        self.key = None\n        self.pi = None\n        self.neighbors = []\n        self.edges = {}  # {vertex:distance}\n\n    def __lt__(self, other):\n        \"\"\"Comparison rule to < operator.\"\"\"\n        return self.key < other.key\n\n    def __repr__(self):\n        \"\"\"Return the vertex id.\"\"\"\n        return self.id\n\n    def add_neighbor(self, vertex):\n        \"\"\"Add a pointer to a vertex at neighbor's list.\"\"\"\n        self.neighbors.append(vertex)\n\n    def add_edge(self, vertex, weight):\n        \"\"\"Destination vertex and weight.\"\"\"\n        self.edges[vertex.id] = weight\n\n\ndef connect(graph, a, b, edge):\n    # add the neighbors:\n    graph[a - 1].add_neighbor(graph[b - 1])\n    graph[b - 1].add_neighbor(graph[a - 1])\n    # add the edges:\n    graph[a - 1].add_edge(graph[b - 1], edge)\n    graph[b - 1].add_edge(graph[a - 1], edge)\n\n\ndef prim(graph: list, root: Vertex) -> list:\n    \"\"\"Prim's Algorithm.\n\n    Runtime:\n        O(mn) with `m` edges and `n` vertices\n\n    Return:\n        List with the edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    a = []\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n    q = graph[:]\n    while q:\n        u = min(q)\n        q.remove(u)\n        for v in u.neighbors:\n            if (v in q) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n    for i in range(1, len(graph)):\n        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))\n    return a\n\n\ndef prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:\n    \"\"\"Prim's Algorithm with min heap.\n\n    Runtime:\n        O((m + n)log n) with `m` edges and `n` vertices\n\n    Yield:\n        Edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    \"\"\"\n    for u in graph:\n        u.key = math.inf\n        u.pi = None\n    root.key = 0\n\n    h = list(graph)\n    hq.heapify(h)\n\n    while h:\n        u = hq.heappop(h)\n        for v in u.neighbors:\n            if (v in h) and (u.edges[v.id] < v.key):\n                v.pi = u\n                v.key = u.edges[v.id]\n                hq.heapify(h)\n\n    for i in range(1, len(graph)):\n        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)\n\n\ndef test_vector() -> None:\n    \"\"\"\n    # Creates a list to store x vertices.\n    >>> x = 5\n    >>> G = [Vertex(n) for n in range(x)]\n\n    >>> connect(G, 1, 2, 15)\n    >>> connect(G, 1, 3, 12)\n    >>> connect(G, 2, 4, 13)\n    >>> connect(G, 2, 5, 5)\n    >>> connect(G, 3, 2, 6)\n    >>> connect(G, 3, 4, 6)\n    >>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\n    >>> G_heap = G[:]\n    >>> MST = prim(G, G[0])\n    >>> MST_heap = prim_heap(G, G[0])\n    >>> for i in MST:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    >>> for i in MST_heap:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/edmonds_karp_multiple_source_and_sink.py": "class FlowNetwork:\n    def __init__(self, graph, sources, sinks):\n        self.source_index = None\n        self.sink_index = None\n        self.graph = graph\n\n        self._normalize_graph(sources, sinks)\n        self.vertices_count = len(graph)\n        self.maximum_flow_algorithm = None\n\n    # make only one source and one sink\n    def _normalize_graph(self, sources, sinks):\n        if sources is int:\n            sources = [sources]\n        if sinks is int:\n            sinks = [sinks]\n\n        if len(sources) == 0 or len(sinks) == 0:\n            return\n\n        self.source_index = sources[0]\n        self.sink_index = sinks[0]\n\n        # make fake vertex if there are more\n        # than one source or sink\n        if len(sources) > 1 or len(sinks) > 1:\n            max_input_flow = 0\n            for i in sources:\n                max_input_flow += sum(self.graph[i])\n\n            size = len(self.graph) + 1\n            for room in self.graph:\n                room.insert(0, 0)\n            self.graph.insert(0, [0] * size)\n            for i in sources:\n                self.graph[0][i + 1] = max_input_flow\n            self.source_index = 0\n\n            size = len(self.graph) + 1\n            for room in self.graph:\n                room.append(0)\n            self.graph.append([0] * size)\n            for i in sinks:\n                self.graph[i + 1][size - 1] = max_input_flow\n            self.sink_index = size - 1\n\n    def find_maximum_flow(self):\n        if self.maximum_flow_algorithm is None:\n            raise Exception(\"You need to set maximum flow algorithm before.\")\n        if self.source_index is None or self.sink_index is None:\n            return 0\n\n        self.maximum_flow_algorithm.execute()\n        return self.maximum_flow_algorithm.getMaximumFlow()\n\n    def set_maximum_flow_algorithm(self, algorithm):\n        self.maximum_flow_algorithm = algorithm(self)\n\n\nclass FlowNetworkAlgorithmExecutor:\n    def __init__(self, flow_network):\n        self.flow_network = flow_network\n        self.verticies_count = flow_network.verticesCount\n        self.source_index = flow_network.sourceIndex\n        self.sink_index = flow_network.sinkIndex\n        # it's just a reference, so you shouldn't change\n        # it in your algorithms, use deep copy before doing that\n        self.graph = flow_network.graph\n        self.executed = False\n\n    def execute(self):\n        if not self.executed:\n            self._algorithm()\n            self.executed = True\n\n    # You should override it\n    def _algorithm(self):\n        pass\n\n\nclass MaximumFlowAlgorithmExecutor(FlowNetworkAlgorithmExecutor):\n    def __init__(self, flow_network):\n        super().__init__(flow_network)\n        # use this to save your result\n        self.maximum_flow = -1\n\n    def get_maximum_flow(self):\n        if not self.executed:\n            raise Exception(\"You should execute algorithm before using its result!\")\n\n        return self.maximum_flow\n\n\nclass PushRelabelExecutor(MaximumFlowAlgorithmExecutor):\n    def __init__(self, flow_network):\n        super().__init__(flow_network)\n\n        self.preflow = [[0] * self.verticies_count for i in range(self.verticies_count)]\n\n        self.heights = [0] * self.verticies_count\n        self.excesses = [0] * self.verticies_count\n\n    def _algorithm(self):\n        self.heights[self.source_index] = self.verticies_count\n\n        # push some substance to graph\n        for nextvertex_index, bandwidth in enumerate(self.graph[self.source_index]):\n            self.preflow[self.source_index][nextvertex_index] += bandwidth\n            self.preflow[nextvertex_index][self.source_index] -= bandwidth\n            self.excesses[nextvertex_index] += bandwidth\n\n        # Relabel-to-front selection rule\n        vertices_list = [\n            i\n            for i in range(self.verticies_count)\n            if i not in {self.source_index, self.sink_index}\n        ]\n\n        # move through list\n        i = 0\n        while i < len(vertices_list):\n            vertex_index = vertices_list[i]\n            previous_height = self.heights[vertex_index]\n            self.process_vertex(vertex_index)\n            if self.heights[vertex_index] > previous_height:\n                # if it was relabeled, swap elements\n                # and start from 0 index\n                vertices_list.insert(0, vertices_list.pop(i))\n                i = 0\n            else:\n                i += 1\n\n        self.maximum_flow = sum(self.preflow[self.source_index])\n\n    def process_vertex(self, vertex_index):\n        while self.excesses[vertex_index] > 0:\n            for neighbour_index in range(self.verticies_count):\n                # if it's neighbour and current vertex is higher\n                if (\n                    self.graph[vertex_index][neighbour_index]\n                    - self.preflow[vertex_index][neighbour_index]\n                    > 0\n                    and self.heights[vertex_index] > self.heights[neighbour_index]\n                ):\n                    self.push(vertex_index, neighbour_index)\n\n            self.relabel(vertex_index)\n\n    def push(self, from_index, to_index):\n        preflow_delta = min(\n            self.excesses[from_index],\n            self.graph[from_index][to_index] - self.preflow[from_index][to_index],\n        )\n        self.preflow[from_index][to_index] += preflow_delta\n        self.preflow[to_index][from_index] -= preflow_delta\n        self.excesses[from_index] -= preflow_delta\n        self.excesses[to_index] += preflow_delta\n\n    def relabel(self, vertex_index):\n        min_height = None\n        for to_index in range(self.verticies_count):\n            if (\n                self.graph[vertex_index][to_index]\n                - self.preflow[vertex_index][to_index]\n                > 0\n            ) and (min_height is None or self.heights[to_index] < min_height):\n                min_height = self.heights[to_index]\n\n        if min_height is not None:\n            self.heights[vertex_index] = min_height + 1\n\n\nif __name__ == \"__main__\":\n    entrances = [0]\n    exits = [3]\n    # graph = [\n    #     [0, 0, 4, 6, 0, 0],\n    #     [0, 0, 5, 2, 0, 0],\n    #     [0, 0, 0, 0, 4, 4],\n    #     [0, 0, 0, 0, 6, 6],\n    #     [0, 0, 0, 0, 0, 0],\n    #     [0, 0, 0, 0, 0, 0],\n    # ]\n    graph = [[0, 7, 0, 0], [0, 0, 6, 0], [0, 0, 0, 8], [9, 0, 0, 0]]\n\n    # prepare our network\n    flow_network = FlowNetwork(graph, entrances, exits)\n    # set algorithm\n    flow_network.set_maximum_flow_algorithm(PushRelabelExecutor)\n    # and calculate\n    maximum_flow = flow_network.find_maximum_flow()\n\n    print(f\"maximum flow is {maximum_flow}\")\n", "graphs/bellman_ford.py": "from __future__ import annotations\n\n\ndef print_distance(distance: list[float], src):\n    print(f\"Vertex\\tShortest Distance from vertex {src}\")\n    for i, d in enumerate(distance):\n        print(f\"{i}\\t\\t{d}\")\n\n\ndef check_negative_cycle(\n    graph: list[dict[str, int]], distance: list[float], edge_count: int\n):\n    for j in range(edge_count):\n        u, v, w = (graph[j][k] for k in [\"src\", \"dst\", \"weight\"])\n        if distance[u] != float(\"inf\") and distance[u] + w < distance[v]:\n            return True\n    return False\n\n\ndef bellman_ford(\n    graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int\n) -> list[float]:\n    \"\"\"\n    Returns shortest paths from a vertex src to all\n    other vertices.\n    >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\n    >>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges]\n    >>> bellman_ford(g, 4, 4, 0)\n    [0.0, -2.0, 8.0, 5.0]\n    >>> g = [{\"src\": s, \"dst\": d, \"weight\": w} for s, d, w in edges + [(1, 3, 5)]]\n    >>> bellman_ford(g, 4, 5, 0)\n    Traceback (most recent call last):\n     ...\n    Exception: Negative cycle found\n    \"\"\"\n    distance = [float(\"inf\")] * vertex_count\n    distance[src] = 0.0\n\n    for _ in range(vertex_count - 1):\n        for j in range(edge_count):\n            u, v, w = (graph[j][k] for k in [\"src\", \"dst\", \"weight\"])\n\n            if distance[u] != float(\"inf\") and distance[u] + w < distance[v]:\n                distance[v] = distance[u] + w\n\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\n    if negative_cycle_exists:\n        raise Exception(\"Negative cycle found\")\n\n    return distance\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    V = int(input(\"Enter number of vertices: \").strip())\n    E = int(input(\"Enter number of edges: \").strip())\n\n    graph: list[dict[str, int]] = [{} for _ in range(E)]\n\n    for i in range(E):\n        print(\"Edge \", i + 1)\n        src, dest, weight = (\n            int(x)\n            for x in input(\"Enter source, destination, weight: \").strip().split(\" \")\n        )\n        graph[i] = {\"src\": src, \"dst\": dest, \"weight\": weight}\n\n    source = int(input(\"\\nEnter shortest path source:\").strip())\n    shortest_distance = bellman_ford(graph, V, E, source)\n    print_distance(shortest_distance, 0)\n", "graphs/scc_kosaraju.py": "from __future__ import annotations\n\n\ndef dfs(u):\n    global graph, reversed_graph, scc, component, visit, stack\n    if visit[u]:\n        return\n    visit[u] = True\n    for v in graph[u]:\n        dfs(v)\n    stack.append(u)\n\n\ndef dfs2(u):\n    global graph, reversed_graph, scc, component, visit, stack\n    if visit[u]:\n        return\n    visit[u] = True\n    component.append(u)\n    for v in reversed_graph[u]:\n        dfs2(v)\n\n\ndef kosaraju():\n    global graph, reversed_graph, scc, component, visit, stack\n    for i in range(n):\n        dfs(i)\n    visit = [False] * n\n    for i in stack[::-1]:\n        if visit[i]:\n            continue\n        component = []\n        dfs2(i)\n        scc.append(component)\n    return scc\n\n\nif __name__ == \"__main__\":\n    # n - no of nodes, m - no of edges\n    n, m = list(map(int, input().strip().split()))\n\n    graph: list[list[int]] = [[] for _ in range(n)]  # graph\n    reversed_graph: list[list[int]] = [[] for i in range(n)]  # reversed graph\n    # input graph data (edges)\n    for _ in range(m):\n        u, v = list(map(int, input().strip().split()))\n        graph[u].append(v)\n        reversed_graph[v].append(u)\n\n    stack: list[int] = []\n    visit: list[bool] = [False] * n\n    scc: list[int] = []\n    component: list[int] = []\n    print(kosaraju())\n", "graphs/bidirectional_a_star.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Bidirectional_search\n\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom math import sqrt\n\n# 1 for manhattan, 0 for euclidean\nHEURISTIC = 0\n\ngrid = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0],\n]\n\ndelta = [[-1, 0], [0, -1], [1, 0], [0, 1]]  # up, left, down, right\n\nTPosition = tuple[int, int]\n\n\nclass Node:\n    \"\"\"\n    >>> k = Node(0, 0, 4, 3, 0, None)\n    >>> k.calculate_heuristic()\n    5.0\n    >>> n = Node(1, 4, 3, 4, 2, None)\n    >>> n.calculate_heuristic()\n    2.0\n    >>> l = [k, n]\n    >>> n == l[0]\n    False\n    >>> l.sort()\n    >>> n == l[0]\n    True\n    \"\"\"\n\n    def __init__(\n        self,\n        pos_x: int,\n        pos_y: int,\n        goal_x: int,\n        goal_y: int,\n        g_cost: int,\n        parent: Node | None,\n    ) -> None:\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n        self.pos = (pos_y, pos_x)\n        self.goal_x = goal_x\n        self.goal_y = goal_y\n        self.g_cost = g_cost\n        self.parent = parent\n        self.h_cost = self.calculate_heuristic()\n        self.f_cost = self.g_cost + self.h_cost\n\n    def calculate_heuristic(self) -> float:\n        \"\"\"\n        Heuristic for the A*\n        \"\"\"\n        dy = self.pos_x - self.goal_x\n        dx = self.pos_y - self.goal_y\n        if HEURISTIC == 1:\n            return abs(dx) + abs(dy)\n        else:\n            return sqrt(dy**2 + dx**2)\n\n    def __lt__(self, other: Node) -> bool:\n        return self.f_cost < other.f_cost\n\n\nclass AStar:\n    \"\"\"\n    >>> astar = AStar((0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    >>> (astar.start.pos_y + delta[3][0], astar.start.pos_x + delta[3][1])\n    (0, 1)\n    >>> [x.pos for x in astar.get_successors(astar.start)]\n    [(1, 0), (0, 1)]\n    >>> (astar.start.pos_y + delta[2][0], astar.start.pos_x + delta[2][1])\n    (1, 0)\n    >>> astar.retrace_path(astar.start)\n    [(0, 0)]\n    >>> astar.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3),\n     (4, 3), (4, 4), (5, 4), (5, 5), (6, 5), (6, 6)]\n    \"\"\"\n\n    def __init__(self, start: TPosition, goal: TPosition):\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\n\n        self.open_nodes = [self.start]\n        self.closed_nodes: list[Node] = []\n\n        self.reached = False\n\n    def search(self) -> list[TPosition]:\n        while self.open_nodes:\n            # Open Nodes are sorted using __lt__\n            self.open_nodes.sort()\n            current_node = self.open_nodes.pop(0)\n\n            if current_node.pos == self.target.pos:\n                return self.retrace_path(current_node)\n\n            self.closed_nodes.append(current_node)\n            successors = self.get_successors(current_node)\n\n            for child_node in successors:\n                if child_node in self.closed_nodes:\n                    continue\n\n                if child_node not in self.open_nodes:\n                    self.open_nodes.append(child_node)\n                else:\n                    # retrieve the best current path\n                    better_node = self.open_nodes.pop(self.open_nodes.index(child_node))\n\n                    if child_node.g_cost < better_node.g_cost:\n                        self.open_nodes.append(child_node)\n                    else:\n                        self.open_nodes.append(better_node)\n\n        return [self.start.pos]\n\n    def get_successors(self, parent: Node) -> list[Node]:\n        \"\"\"\n        Returns a list of successors (both in the grid and free spaces)\n        \"\"\"\n        successors = []\n        for action in delta:\n            pos_x = parent.pos_x + action[1]\n            pos_y = parent.pos_y + action[0]\n            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):\n                continue\n\n            if grid[pos_y][pos_x] != 0:\n                continue\n\n            successors.append(\n                Node(\n                    pos_x,\n                    pos_y,\n                    self.target.pos_y,\n                    self.target.pos_x,\n                    parent.g_cost + 1,\n                    parent,\n                )\n            )\n        return successors\n\n    def retrace_path(self, node: Node | None) -> list[TPosition]:\n        \"\"\"\n        Retrace the path from parents to parents until start node\n        \"\"\"\n        current_node = node\n        path = []\n        while current_node is not None:\n            path.append((current_node.pos_y, current_node.pos_x))\n            current_node = current_node.parent\n        path.reverse()\n        return path\n\n\nclass BidirectionalAStar:\n    \"\"\"\n    >>> bd_astar = BidirectionalAStar((0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    >>> bd_astar.fwd_astar.start.pos == bd_astar.bwd_astar.target.pos\n    True\n    >>> bd_astar.retrace_bidirectional_path(bd_astar.fwd_astar.start,\n    ...                                     bd_astar.bwd_astar.start)\n    [(0, 0)]\n    >>> bd_astar.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4),\n     (2, 5), (3, 5), (4, 5), (5, 5), (5, 6), (6, 6)]\n    \"\"\"\n\n    def __init__(self, start: TPosition, goal: TPosition) -> None:\n        self.fwd_astar = AStar(start, goal)\n        self.bwd_astar = AStar(goal, start)\n        self.reached = False\n\n    def search(self) -> list[TPosition]:\n        while self.fwd_astar.open_nodes or self.bwd_astar.open_nodes:\n            self.fwd_astar.open_nodes.sort()\n            self.bwd_astar.open_nodes.sort()\n            current_fwd_node = self.fwd_astar.open_nodes.pop(0)\n            current_bwd_node = self.bwd_astar.open_nodes.pop(0)\n\n            if current_bwd_node.pos == current_fwd_node.pos:\n                return self.retrace_bidirectional_path(\n                    current_fwd_node, current_bwd_node\n                )\n\n            self.fwd_astar.closed_nodes.append(current_fwd_node)\n            self.bwd_astar.closed_nodes.append(current_bwd_node)\n\n            self.fwd_astar.target = current_bwd_node\n            self.bwd_astar.target = current_fwd_node\n\n            successors = {\n                self.fwd_astar: self.fwd_astar.get_successors(current_fwd_node),\n                self.bwd_astar: self.bwd_astar.get_successors(current_bwd_node),\n            }\n\n            for astar in [self.fwd_astar, self.bwd_astar]:\n                for child_node in successors[astar]:\n                    if child_node in astar.closed_nodes:\n                        continue\n\n                    if child_node not in astar.open_nodes:\n                        astar.open_nodes.append(child_node)\n                    else:\n                        # retrieve the best current path\n                        better_node = astar.open_nodes.pop(\n                            astar.open_nodes.index(child_node)\n                        )\n\n                        if child_node.g_cost < better_node.g_cost:\n                            astar.open_nodes.append(child_node)\n                        else:\n                            astar.open_nodes.append(better_node)\n\n        return [self.fwd_astar.start.pos]\n\n    def retrace_bidirectional_path(\n        self, fwd_node: Node, bwd_node: Node\n    ) -> list[TPosition]:\n        fwd_path = self.fwd_astar.retrace_path(fwd_node)\n        bwd_path = self.bwd_astar.retrace_path(bwd_node)\n        bwd_path.pop()\n        bwd_path.reverse()\n        path = fwd_path + bwd_path\n        return path\n\n\nif __name__ == \"__main__\":\n    # all coordinates are given in format [y,x]\n    init = (0, 0)\n    goal = (len(grid) - 1, len(grid[0]) - 1)\n    for elem in grid:\n        print(elem)\n\n    start_time = time.time()\n    a_star = AStar(init, goal)\n    path = a_star.search()\n    end_time = time.time() - start_time\n    print(f\"AStar execution time = {end_time:f} seconds\")\n\n    bd_start_time = time.time()\n    bidir_astar = BidirectionalAStar(init, goal)\n    bd_end_time = time.time() - bd_start_time\n    print(f\"BidirectionalAStar execution time = {bd_end_time:f} seconds\")\n", "graphs/even_tree.py": "\"\"\"\nYou are given a tree(a simple connected graph with no cycles). The tree has N\nnodes numbered from 1 to N and is rooted at node 1.\n\nFind the maximum number of edges you can remove from the tree to get a forest\nsuch that each connected component of the forest contains an even number of\nnodes.\n\nConstraints\n2 <= 2 <= 100\n\nNote: The tree input will be such that it can always be decomposed into\ncomponents containing an even number of nodes.\n\"\"\"\n\n# pylint: disable=invalid-name\nfrom collections import defaultdict\n\n\ndef dfs(start: int) -> int:\n    \"\"\"DFS traversal\"\"\"\n    # pylint: disable=redefined-outer-name\n    ret = 1\n    visited[start] = True\n    for v in tree[start]:\n        if v not in visited:\n            ret += dfs(v)\n    if ret % 2 == 0:\n        cuts.append(start)\n    return ret\n\n\ndef even_tree():\n    \"\"\"\n    2 1\n    3 1\n    4 3\n    5 2\n    6 1\n    7 2\n    8 6\n    9 8\n    10 8\n    On removing edges (1,3) and (1,6), we can get the desired result 2.\n    \"\"\"\n    dfs(1)\n\n\nif __name__ == \"__main__\":\n    n, m = 10, 9\n    tree = defaultdict(list)\n    visited: dict[int, bool] = {}\n    cuts: list[int] = []\n    count = 0\n    edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    even_tree()\n    print(len(cuts) - 1)\n", "graphs/depth_first_search.py": "\"\"\"Non recursive implementation of a DFS algorithm.\"\"\"\n\nfrom __future__ import annotations\n\n\ndef depth_first_search(graph: dict, start: str) -> set[str]:\n    \"\"\"Depth First Search on Graph\n    :param graph: directed graph in dictionary format\n    :param start: starting vertex as a string\n    :returns: the trace of the search\n    >>> input_G = { \"A\": [\"B\", \"C\", \"D\"], \"B\": [\"A\", \"D\", \"E\"],\n    ... \"C\": [\"A\", \"F\"], \"D\": [\"B\", \"D\"], \"E\": [\"B\", \"F\"],\n    ... \"F\": [\"C\", \"E\", \"G\"], \"G\": [\"F\"] }\n    >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"A\")))\n    True\n    >>> all(x in output_G for x in list(depth_first_search(input_G, \"G\")))\n    True\n    \"\"\"\n    explored, stack = set(start), [start]\n\n    while stack:\n        v = stack.pop()\n        explored.add(v)\n        # Differences from BFS:\n        # 1) pop last element instead of first one\n        # 2) add adjacent elements to stack without exploring them\n        for adj in reversed(graph[v]):\n            if adj not in explored:\n                stack.append(adj)\n    return explored\n\n\nG = {\n    \"A\": [\"B\", \"C\", \"D\"],\n    \"B\": [\"A\", \"D\", \"E\"],\n    \"C\": [\"A\", \"F\"],\n    \"D\": [\"B\", \"D\"],\n    \"E\": [\"B\", \"F\"],\n    \"F\": [\"C\", \"E\", \"G\"],\n    \"G\": [\"F\"],\n}\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(depth_first_search(G, \"A\"))\n", "graphs/graph_adjacency_list.py": "#!/usr/bin/env python3\n\"\"\"\nAuthor: Vikram Nithyanandam\n\nDescription:\nThe following implementation is a robust unweighted Graph data structure\nimplemented using an adjacency list. This vertices and edges of this graph can be\neffectively initialized and modified while storing your chosen generic\nvalue in each vertex.\n\nAdjacency List: https://en.wikipedia.org/wiki/Adjacency_list\n\nPotential Future Ideas:\n- Add a flag to set edge weights on and set edge weights\n- Make edge weights and vertex values customizable to store whatever the client wants\n- Support multigraph functionality if the client wants it\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\nimport unittest\nfrom pprint import pformat\nfrom typing import Generic, TypeVar\n\nimport pytest\n\nT = TypeVar(\"T\")\n\n\nclass GraphAdjacencyList(Generic[T]):\n    def __init__(\n        self, vertices: list[T], edges: list[list[T]], directed: bool = True\n    ) -> None:\n        \"\"\"\n        Parameters:\n         - vertices: (list[T]) The list of vertex names the client wants to\n        pass in. Default is empty.\n        - edges: (list[list[T]]) The list of edges the client wants to\n        pass in. Each edge is a 2-element list. Default is empty.\n        - directed: (bool) Indicates if graph is directed or undirected.\n        Default is True.\n        \"\"\"\n        self.adj_list: dict[T, list[T]] = {}  # dictionary of lists of T\n        self.directed = directed\n\n        # Falsey checks\n        edges = edges or []\n        vertices = vertices or []\n\n        for vertex in vertices:\n            self.add_vertex(vertex)\n\n        for edge in edges:\n            if len(edge) != 2:\n                msg = f\"Invalid input: {edge} is the wrong length.\"\n                raise ValueError(msg)\n            self.add_edge(edge[0], edge[1])\n\n    def add_vertex(self, vertex: T) -> None:\n        \"\"\"\n        Adds a vertex to the graph. If the given vertex already exists,\n        a ValueError will be thrown.\n        \"\"\"\n        if self.contains_vertex(vertex):\n            msg = f\"Incorrect input: {vertex} is already in the graph.\"\n            raise ValueError(msg)\n        self.adj_list[vertex] = []\n\n    def add_edge(self, source_vertex: T, destination_vertex: T) -> None:\n        \"\"\"\n        Creates an edge from source vertex to destination vertex. If any\n        given vertex doesn't exist or the edge already exists, a ValueError\n        will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} or \"\n                f\"{destination_vertex} does not exist\"\n            )\n            raise ValueError(msg)\n        if self.contains_edge(source_vertex, destination_vertex):\n            msg = (\n                \"Incorrect input: The edge already exists between \"\n                f\"{source_vertex} and {destination_vertex}\"\n            )\n            raise ValueError(msg)\n\n        # add the destination vertex to the list associated with the source vertex\n        # and vice versa if not directed\n        self.adj_list[source_vertex].append(destination_vertex)\n        if not self.directed:\n            self.adj_list[destination_vertex].append(source_vertex)\n\n    def remove_vertex(self, vertex: T) -> None:\n        \"\"\"\n        Removes the given vertex from the graph and deletes all incoming and\n        outgoing edges from the given vertex as well. If the given vertex\n        does not exist, a ValueError will be thrown.\n        \"\"\"\n        if not self.contains_vertex(vertex):\n            msg = f\"Incorrect input: {vertex} does not exist in this graph.\"\n            raise ValueError(msg)\n\n        if not self.directed:\n            # If not directed, find all neighboring vertices and delete all references\n            # of edges connecting to the given vertex\n            for neighbor in self.adj_list[vertex]:\n                self.adj_list[neighbor].remove(vertex)\n        else:\n            # If directed, search all neighbors of all vertices and delete all\n            # references of edges connecting to the given vertex\n            for edge_list in self.adj_list.values():\n                if vertex in edge_list:\n                    edge_list.remove(vertex)\n\n        # Finally, delete the given vertex and all of its outgoing edge references\n        self.adj_list.pop(vertex)\n\n    def remove_edge(self, source_vertex: T, destination_vertex: T) -> None:\n        \"\"\"\n        Removes the edge between the two vertices. If any given vertex\n        doesn't exist or the edge does not exist, a ValueError will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} or \"\n                f\"{destination_vertex} does not exist\"\n            )\n            raise ValueError(msg)\n        if not self.contains_edge(source_vertex, destination_vertex):\n            msg = (\n                \"Incorrect input: The edge does NOT exist between \"\n                f\"{source_vertex} and {destination_vertex}\"\n            )\n            raise ValueError(msg)\n\n        # remove the destination vertex from the list associated with the source\n        # vertex and vice versa if not directed\n        self.adj_list[source_vertex].remove(destination_vertex)\n        if not self.directed:\n            self.adj_list[destination_vertex].remove(source_vertex)\n\n    def contains_vertex(self, vertex: T) -> bool:\n        \"\"\"\n        Returns True if the graph contains the vertex, False otherwise.\n        \"\"\"\n        return vertex in self.adj_list\n\n    def contains_edge(self, source_vertex: T, destination_vertex: T) -> bool:\n        \"\"\"\n        Returns True if the graph contains the edge from the source_vertex to the\n        destination_vertex, False otherwise. If any given vertex doesn't exist, a\n        ValueError will be thrown.\n        \"\"\"\n        if not (\n            self.contains_vertex(source_vertex)\n            and self.contains_vertex(destination_vertex)\n        ):\n            msg = (\n                f\"Incorrect input: Either {source_vertex} \"\n                f\"or {destination_vertex} does not exist.\"\n            )\n            raise ValueError(msg)\n\n        return destination_vertex in self.adj_list[source_vertex]\n\n    def clear_graph(self) -> None:\n        \"\"\"\n        Clears all vertices and edges.\n        \"\"\"\n        self.adj_list = {}\n\n    def __repr__(self) -> str:\n        return pformat(self.adj_list)\n\n\nclass TestGraphAdjacencyList(unittest.TestCase):\n    def __assert_graph_edge_exists_check(\n        self,\n        undirected_graph: GraphAdjacencyList,\n        directed_graph: GraphAdjacencyList,\n        edge: list[int],\n    ) -> None:\n        assert undirected_graph.contains_edge(edge[0], edge[1])\n        assert undirected_graph.contains_edge(edge[1], edge[0])\n        assert directed_graph.contains_edge(edge[0], edge[1])\n\n    def __assert_graph_edge_does_not_exist_check(\n        self,\n        undirected_graph: GraphAdjacencyList,\n        directed_graph: GraphAdjacencyList,\n        edge: list[int],\n    ) -> None:\n        assert not undirected_graph.contains_edge(edge[0], edge[1])\n        assert not undirected_graph.contains_edge(edge[1], edge[0])\n        assert not directed_graph.contains_edge(edge[0], edge[1])\n\n    def __assert_graph_vertex_exists_check(\n        self,\n        undirected_graph: GraphAdjacencyList,\n        directed_graph: GraphAdjacencyList,\n        vertex: int,\n    ) -> None:\n        assert undirected_graph.contains_vertex(vertex)\n        assert directed_graph.contains_vertex(vertex)\n\n    def __assert_graph_vertex_does_not_exist_check(\n        self,\n        undirected_graph: GraphAdjacencyList,\n        directed_graph: GraphAdjacencyList,\n        vertex: int,\n    ) -> None:\n        assert not undirected_graph.contains_vertex(vertex)\n        assert not directed_graph.contains_vertex(vertex)\n\n    def __generate_random_edges(\n        self, vertices: list[int], edge_pick_count: int\n    ) -> list[list[int]]:\n        assert edge_pick_count <= len(vertices)\n\n        random_source_vertices: list[int] = random.sample(\n            vertices[0 : int(len(vertices) / 2)], edge_pick_count\n        )\n        random_destination_vertices: list[int] = random.sample(\n            vertices[int(len(vertices) / 2) :], edge_pick_count\n        )\n        random_edges: list[list[int]] = []\n\n        for source in random_source_vertices:\n            for dest in random_destination_vertices:\n                random_edges.append([source, dest])\n\n        return random_edges\n\n    def __generate_graphs(\n        self, vertex_count: int, min_val: int, max_val: int, edge_pick_count: int\n    ) -> tuple[GraphAdjacencyList, GraphAdjacencyList, list[int], list[list[int]]]:\n        if max_val - min_val + 1 < vertex_count:\n            raise ValueError(\n                \"Will result in duplicate vertices. Either increase range \"\n                \"between min_val and max_val or decrease vertex count.\"\n            )\n\n        # generate graph input\n        random_vertices: list[int] = random.sample(\n            range(min_val, max_val + 1), vertex_count\n        )\n        random_edges: list[list[int]] = self.__generate_random_edges(\n            random_vertices, edge_pick_count\n        )\n\n        # build graphs\n        undirected_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=random_edges, directed=False\n        )\n        directed_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=random_edges, directed=True\n        )\n\n        return undirected_graph, directed_graph, random_vertices, random_edges\n\n    def test_init_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # test graph initialization with vertices and edges\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n        for edge in random_edges:\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n        assert not undirected_graph.directed\n        assert directed_graph.directed\n\n    def test_contains_vertex(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # Build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # Test contains_vertex\n        for num in range(101):\n            assert (num in random_vertices) == undirected_graph.contains_vertex(num)\n            assert (num in random_vertices) == directed_graph.contains_vertex(num)\n\n    def test_add_vertices(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # build empty graphs\n        undirected_graph: GraphAdjacencyList = GraphAdjacencyList(\n            vertices=[], edges=[], directed=False\n        )\n        directed_graph: GraphAdjacencyList = GraphAdjacencyList(\n            vertices=[], edges=[], directed=True\n        )\n\n        # run add_vertex\n        for num in random_vertices:\n            undirected_graph.add_vertex(num)\n\n        for num in random_vertices:\n            directed_graph.add_vertex(num)\n\n        # test add_vertex worked\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n    def test_remove_vertices(self) -> None:\n        random_vertices: list[int] = random.sample(range(101), 20)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # test remove_vertex worked\n        for num in random_vertices:\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, num\n            )\n\n            undirected_graph.remove_vertex(num)\n            directed_graph.remove_vertex(num)\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, num\n            )\n\n    def test_add_and_remove_vertices_repeatedly(self) -> None:\n        random_vertices1: list[int] = random.sample(range(51), 20)\n        random_vertices2: list[int] = random.sample(range(51, 101), 20)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyList(\n            vertices=random_vertices1, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyList(\n            vertices=random_vertices1, edges=[], directed=True\n        )\n\n        # test adding and removing vertices\n        for i, _ in enumerate(random_vertices1):\n            undirected_graph.add_vertex(random_vertices2[i])\n            directed_graph.add_vertex(random_vertices2[i])\n\n            self.__assert_graph_vertex_exists_check(\n                undirected_graph, directed_graph, random_vertices2[i]\n            )\n\n            undirected_graph.remove_vertex(random_vertices1[i])\n            directed_graph.remove_vertex(random_vertices1[i])\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, random_vertices1[i]\n            )\n\n        # remove all vertices\n        for i, _ in enumerate(random_vertices1):\n            undirected_graph.remove_vertex(random_vertices2[i])\n            directed_graph.remove_vertex(random_vertices2[i])\n\n            self.__assert_graph_vertex_does_not_exist_check(\n                undirected_graph, directed_graph, random_vertices2[i]\n            )\n\n    def test_contains_edge(self) -> None:\n        # generate graphs and graph input\n        vertex_count = 20\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(vertex_count, 0, 100, 4)\n\n        # generate all possible edges for testing\n        all_possible_edges: list[list[int]] = []\n        for i in range(vertex_count - 1):\n            for j in range(i + 1, vertex_count):\n                all_possible_edges.append([random_vertices[i], random_vertices[j]])\n                all_possible_edges.append([random_vertices[j], random_vertices[i]])\n\n        # test contains_edge function\n        for edge in all_possible_edges:\n            if edge in random_edges:\n                self.__assert_graph_edge_exists_check(\n                    undirected_graph, directed_graph, edge\n                )\n            elif [edge[1], edge[0]] in random_edges:\n                # since this edge exists for undirected but the reverse\n                # may not exist for directed\n                self.__assert_graph_edge_exists_check(\n                    undirected_graph, directed_graph, [edge[1], edge[0]]\n                )\n            else:\n                self.__assert_graph_edge_does_not_exist_check(\n                    undirected_graph, directed_graph, edge\n                )\n\n    def test_add_edge(self) -> None:\n        # generate graph input\n        random_vertices: list[int] = random.sample(range(101), 15)\n        random_edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n\n        # build graphs WITHOUT edges\n        undirected_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=False\n        )\n        directed_graph = GraphAdjacencyList(\n            vertices=random_vertices, edges=[], directed=True\n        )\n\n        # run and test add_edge\n        for edge in random_edges:\n            undirected_graph.add_edge(edge[0], edge[1])\n            directed_graph.add_edge(edge[0], edge[1])\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n\n    def test_remove_edge(self) -> None:\n        # generate graph input and graphs\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # run and test remove_edge\n        for edge in random_edges:\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, edge\n            )\n            undirected_graph.remove_edge(edge[0], edge[1])\n            directed_graph.remove_edge(edge[0], edge[1])\n            self.__assert_graph_edge_does_not_exist_check(\n                undirected_graph, directed_graph, edge\n            )\n\n    def test_add_and_remove_edges_repeatedly(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        # make some more edge options!\n        more_random_edges: list[list[int]] = []\n\n        while len(more_random_edges) != len(random_edges):\n            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n            for edge in edges:\n                if len(more_random_edges) == len(random_edges):\n                    break\n                elif edge not in more_random_edges and edge not in random_edges:\n                    more_random_edges.append(edge)\n\n        for i, _ in enumerate(random_edges):\n            undirected_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])\n            directed_graph.add_edge(more_random_edges[i][0], more_random_edges[i][1])\n\n            self.__assert_graph_edge_exists_check(\n                undirected_graph, directed_graph, more_random_edges[i]\n            )\n\n            undirected_graph.remove_edge(random_edges[i][0], random_edges[i][1])\n            directed_graph.remove_edge(random_edges[i][0], random_edges[i][1])\n\n            self.__assert_graph_edge_does_not_exist_check(\n                undirected_graph, directed_graph, random_edges[i]\n            )\n\n    def test_add_vertex_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for vertex in random_vertices:\n            with pytest.raises(ValueError):\n                undirected_graph.add_vertex(vertex)\n            with pytest.raises(ValueError):\n                directed_graph.add_vertex(vertex)\n\n    def test_remove_vertex_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for i in range(101):\n            if i not in random_vertices:\n                with pytest.raises(ValueError):\n                    undirected_graph.remove_vertex(i)\n                with pytest.raises(ValueError):\n                    directed_graph.remove_vertex(i)\n\n    def test_add_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for edge in random_edges:\n            with pytest.raises(ValueError):\n                undirected_graph.add_edge(edge[0], edge[1])\n            with pytest.raises(ValueError):\n                directed_graph.add_edge(edge[0], edge[1])\n\n    def test_remove_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        more_random_edges: list[list[int]] = []\n\n        while len(more_random_edges) != len(random_edges):\n            edges: list[list[int]] = self.__generate_random_edges(random_vertices, 4)\n            for edge in edges:\n                if len(more_random_edges) == len(random_edges):\n                    break\n                elif edge not in more_random_edges and edge not in random_edges:\n                    more_random_edges.append(edge)\n\n        for edge in more_random_edges:\n            with pytest.raises(ValueError):\n                undirected_graph.remove_edge(edge[0], edge[1])\n            with pytest.raises(ValueError):\n                directed_graph.remove_edge(edge[0], edge[1])\n\n    def test_contains_edge_exception_check(self) -> None:\n        (\n            undirected_graph,\n            directed_graph,\n            random_vertices,\n            random_edges,\n        ) = self.__generate_graphs(20, 0, 100, 4)\n\n        for vertex in random_vertices:\n            with pytest.raises(ValueError):\n                undirected_graph.contains_edge(vertex, 102)\n            with pytest.raises(ValueError):\n                directed_graph.contains_edge(vertex, 102)\n\n        with pytest.raises(ValueError):\n            undirected_graph.contains_edge(103, 102)\n        with pytest.raises(ValueError):\n            directed_graph.contains_edge(103, 102)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "graphs/multi_heuristic_astar.py": "import heapq\nimport sys\n\nimport numpy as np\n\nTPos = tuple[int, int]\n\n\nclass PriorityQueue:\n    def __init__(self):\n        self.elements = []\n        self.set = set()\n\n    def minkey(self):\n        if not self.empty():\n            return self.elements[0][0]\n        else:\n            return float(\"inf\")\n\n    def empty(self):\n        return len(self.elements) == 0\n\n    def put(self, item, priority):\n        if item not in self.set:\n            heapq.heappush(self.elements, (priority, item))\n            self.set.add(item)\n        else:\n            # update\n            # print(\"update\", item)\n            temp = []\n            (pri, x) = heapq.heappop(self.elements)\n            while x != item:\n                temp.append((pri, x))\n                (pri, x) = heapq.heappop(self.elements)\n            temp.append((priority, item))\n            for pro, xxx in temp:\n                heapq.heappush(self.elements, (pro, xxx))\n\n    def remove_element(self, item):\n        if item in self.set:\n            self.set.remove(item)\n            temp = []\n            (pro, x) = heapq.heappop(self.elements)\n            while x != item:\n                temp.append((pro, x))\n                (pro, x) = heapq.heappop(self.elements)\n            for prito, yyy in temp:\n                heapq.heappush(self.elements, (prito, yyy))\n\n    def top_show(self):\n        return self.elements[0][1]\n\n    def get(self):\n        (priority, item) = heapq.heappop(self.elements)\n        self.set.remove(item)\n        return (priority, item)\n\n\ndef consistent_heuristic(p: TPos, goal: TPos):\n    # euclidean distance\n    a = np.array(p)\n    b = np.array(goal)\n    return np.linalg.norm(a - b)\n\n\ndef heuristic_2(p: TPos, goal: TPos):\n    # integer division by time variable\n    return consistent_heuristic(p, goal) // t\n\n\ndef heuristic_1(p: TPos, goal: TPos):\n    # manhattan distance\n    return abs(p[0] - goal[0]) + abs(p[1] - goal[1])\n\n\ndef key(start: TPos, i: int, goal: TPos, g_function: dict[TPos, float]):\n    ans = g_function[start] + W1 * heuristics[i](start, goal)\n    return ans\n\n\ndef do_something(back_pointer, goal, start):\n    grid = np.chararray((n, n))\n    for i in range(n):\n        for j in range(n):\n            grid[i][j] = \"*\"\n\n    for i in range(n):\n        for j in range(n):\n            if (j, (n - 1) - i) in blocks:\n                grid[i][j] = \"#\"\n\n    grid[0][(n - 1)] = \"-\"\n    x = back_pointer[goal]\n    while x != start:\n        (x_c, y_c) = x\n        # print(x)\n        grid[(n - 1) - y_c][x_c] = \"-\"\n        x = back_pointer[x]\n    grid[(n - 1)][0] = \"-\"\n\n    for i in range(n):\n        for j in range(n):\n            if (i, j) == (0, n - 1):\n                print(grid[i][j], end=\" \")\n                print(\"<-- End position\", end=\" \")\n            else:\n                print(grid[i][j], end=\" \")\n        print()\n    print(\"^\")\n    print(\"Start position\")\n    print()\n    print(\"# is an obstacle\")\n    print(\"- is the path taken by algorithm\")\n    print(\"PATH TAKEN BY THE ALGORITHM IS:-\")\n    x = back_pointer[goal]\n    while x != start:\n        print(x, end=\" \")\n        x = back_pointer[x]\n    print(x)\n    sys.exit()\n\n\ndef valid(p: TPos):\n    if p[0] < 0 or p[0] > n - 1:\n        return False\n    if p[1] < 0 or p[1] > n - 1:\n        return False\n    return True\n\n\ndef expand_state(\n    s,\n    j,\n    visited,\n    g_function,\n    close_list_anchor,\n    close_list_inad,\n    open_list,\n    back_pointer,\n):\n    for itera in range(n_heuristic):\n        open_list[itera].remove_element(s)\n    # print(\"s\", s)\n    # print(\"j\", j)\n    (x, y) = s\n    left = (x - 1, y)\n    right = (x + 1, y)\n    up = (x, y + 1)\n    down = (x, y - 1)\n\n    for neighbours in [left, right, up, down]:\n        if neighbours not in blocks:\n            if valid(neighbours) and neighbours not in visited:\n                # print(\"neighbour\", neighbours)\n                visited.add(neighbours)\n                back_pointer[neighbours] = -1\n                g_function[neighbours] = float(\"inf\")\n\n            if valid(neighbours) and g_function[neighbours] > g_function[s] + 1:\n                g_function[neighbours] = g_function[s] + 1\n                back_pointer[neighbours] = s\n                if neighbours not in close_list_anchor:\n                    open_list[0].put(neighbours, key(neighbours, 0, goal, g_function))\n                    if neighbours not in close_list_inad:\n                        for var in range(1, n_heuristic):\n                            if key(neighbours, var, goal, g_function) <= W2 * key(\n                                neighbours, 0, goal, g_function\n                            ):\n                                open_list[j].put(\n                                    neighbours, key(neighbours, var, goal, g_function)\n                                )\n\n\ndef make_common_ground():\n    some_list = []\n    for x in range(1, 5):\n        for y in range(1, 6):\n            some_list.append((x, y))\n\n    for x in range(15, 20):\n        some_list.append((x, 17))\n\n    for x in range(10, 19):\n        for y in range(1, 15):\n            some_list.append((x, y))\n\n    # L block\n    for x in range(1, 4):\n        for y in range(12, 19):\n            some_list.append((x, y))\n    for x in range(3, 13):\n        for y in range(16, 19):\n            some_list.append((x, y))\n    return some_list\n\n\nheuristics = {0: consistent_heuristic, 1: heuristic_1, 2: heuristic_2}\n\nblocks_blk = [\n    (0, 1),\n    (1, 1),\n    (2, 1),\n    (3, 1),\n    (4, 1),\n    (5, 1),\n    (6, 1),\n    (7, 1),\n    (8, 1),\n    (9, 1),\n    (10, 1),\n    (11, 1),\n    (12, 1),\n    (13, 1),\n    (14, 1),\n    (15, 1),\n    (16, 1),\n    (17, 1),\n    (18, 1),\n    (19, 1),\n]\nblocks_all = make_common_ground()\n\n\nblocks = blocks_blk\n# hyper parameters\nW1 = 1\nW2 = 1\nn = 20\nn_heuristic = 3  # one consistent and two other inconsistent\n\n# start and end destination\nstart = (0, 0)\ngoal = (n - 1, n - 1)\n\nt = 1\n\n\ndef multi_a_star(start: TPos, goal: TPos, n_heuristic: int):\n    g_function = {start: 0, goal: float(\"inf\")}\n    back_pointer = {start: -1, goal: -1}\n    open_list = []\n    visited = set()\n\n    for i in range(n_heuristic):\n        open_list.append(PriorityQueue())\n        open_list[i].put(start, key(start, i, goal, g_function))\n\n    close_list_anchor: list[int] = []\n    close_list_inad: list[int] = []\n    while open_list[0].minkey() < float(\"inf\"):\n        for i in range(1, n_heuristic):\n            # print(open_list[0].minkey(), open_list[i].minkey())\n            if open_list[i].minkey() <= W2 * open_list[0].minkey():\n                global t\n                t += 1\n                if g_function[goal] <= open_list[i].minkey():\n                    if g_function[goal] < float(\"inf\"):\n                        do_something(back_pointer, goal, start)\n                else:\n                    _, get_s = open_list[i].top_show()\n                    visited.add(get_s)\n                    expand_state(\n                        get_s,\n                        i,\n                        visited,\n                        g_function,\n                        close_list_anchor,\n                        close_list_inad,\n                        open_list,\n                        back_pointer,\n                    )\n                    close_list_inad.append(get_s)\n            elif g_function[goal] <= open_list[0].minkey():\n                if g_function[goal] < float(\"inf\"):\n                    do_something(back_pointer, goal, start)\n            else:\n                get_s = open_list[0].top_show()\n                visited.add(get_s)\n                expand_state(\n                    get_s,\n                    0,\n                    visited,\n                    g_function,\n                    close_list_anchor,\n                    close_list_inad,\n                    open_list,\n                    back_pointer,\n                )\n                close_list_anchor.append(get_s)\n    print(\"No path found to goal\")\n    print()\n    for i in range(n - 1, -1, -1):\n        for j in range(n):\n            if (j, i) in blocks:\n                print(\"#\", end=\" \")\n            elif (j, i) in back_pointer:\n                if (j, i) == (n - 1, n - 1):\n                    print(\"*\", end=\" \")\n                else:\n                    print(\"-\", end=\" \")\n            else:\n                print(\"*\", end=\" \")\n            if (j, i) == (n - 1, n - 1):\n                print(\"<-- End position\", end=\" \")\n        print()\n    print(\"^\")\n    print(\"Start position\")\n    print()\n    print(\"# is an obstacle\")\n    print(\"- is the path taken by algorithm\")\n\n\nif __name__ == \"__main__\":\n    multi_a_star(start, goal, n_heuristic)\n", "graphs/markov_chain.py": "from __future__ import annotations\n\nfrom collections import Counter\nfrom random import random\n\n\nclass MarkovChainGraphUndirectedUnweighted:\n    \"\"\"\n    Undirected Unweighted Graph for running Markov Chain Algorithm\n    \"\"\"\n\n    def __init__(self):\n        self.connections = {}\n\n    def add_node(self, node: str) -> None:\n        self.connections[node] = {}\n\n    def add_transition_probability(\n        self, node1: str, node2: str, probability: float\n    ) -> None:\n        if node1 not in self.connections:\n            self.add_node(node1)\n        if node2 not in self.connections:\n            self.add_node(node2)\n        self.connections[node1][node2] = probability\n\n    def get_nodes(self) -> list[str]:\n        return list(self.connections)\n\n    def transition(self, node: str) -> str:\n        current_probability = 0\n        random_value = random()\n\n        for dest in self.connections[node]:\n            current_probability += self.connections[node][dest]\n            if current_probability > random_value:\n                return dest\n        return \"\"\n\n\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n    \"\"\"\n    Running Markov Chain algorithm and calculating the number of times each node is\n    visited\n\n    >>> transitions = [\n    ... ('a', 'a', 0.9),\n    ... ('a', 'b', 0.075),\n    ... ('a', 'c', 0.025),\n    ... ('b', 'a', 0.15),\n    ... ('b', 'b', 0.8),\n    ... ('b', 'c', 0.05),\n    ... ('c', 'a', 0.25),\n    ... ('c', 'b', 0.25),\n    ... ('c', 'c', 0.5)\n    ... ]\n\n    >>> result = get_transitions('a', transitions, 5000)\n\n    >>> result['a'] > result['b'] > result['c']\n    True\n    \"\"\"\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, node2, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/minimum_spanning_tree_prims.py": "import sys\nfrom collections import defaultdict\n\n\nclass Heap:\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:  # noqa: SIM114\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = (\n                    heap[start],\n                    positions[start],\n                )\n                heap[start], positions[start] = temp, temp1\n\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(\n                    positions[smallest_child], self.get_position(positions[start])\n                )\n                self.set_position(positions[start], temp)\n\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    # Update function if value of any node in min-heap decreases\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index - 1) / 2)\n\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\n\n\ndef prisms_algorithm(adjacency_list):\n    \"\"\"\n    >>> adjacency_list = {0: [[1, 1], [3, 3]],\n    ...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],\n    ...                   2: [[1, 6], [4, 5], [5, 2]],\n    ...                   3: [[0, 3], [1, 5], [4, 1]],\n    ...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],\n    ...                   5: [[2, 2], [4, 4]]}\n    >>> prisms_algorithm(adjacency_list)\n    [(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]\n    \"\"\"\n\n    heap = Heap()\n\n    visited = [0] * len(adjacency_list)\n    nbr_tv = [-1] * len(adjacency_list)  # Neighboring Tree Vertex of selected vertex\n    # Minimum Distance of explored vertex with neighboring vertex of partial tree\n    # formed in graph\n    distance_tv = []  # Heap of Distance of vertices from their neighboring vertex\n    positions = []\n\n    for vertex in range(len(adjacency_list)):\n        distance_tv.append(sys.maxsize)\n        positions.append(vertex)\n        heap.node_position.append(vertex)\n\n    tree_edges = []\n    visited[0] = 1\n    distance_tv[0] = sys.maxsize\n    for neighbor, distance in adjacency_list[0]:\n        nbr_tv[neighbor] = 0\n        distance_tv[neighbor] = distance\n    heap.heapify(distance_tv, positions)\n\n    for _ in range(1, len(adjacency_list)):\n        vertex = heap.delete_minimum(distance_tv, positions)\n        if visited[vertex] == 0:\n            tree_edges.append((nbr_tv[vertex], vertex))\n            visited[vertex] = 1\n            for neighbor, distance in adjacency_list[vertex]:\n                if (\n                    visited[neighbor] == 0\n                    and distance < distance_tv[heap.get_position(neighbor)]\n                ):\n                    distance_tv[heap.get_position(neighbor)] = distance\n                    heap.bottom_to_top(\n                        distance, heap.get_position(neighbor), distance_tv, positions\n                    )\n                    nbr_tv[neighbor] = vertex\n    return tree_edges\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    # < --------- Prims Algorithm --------- >\n    edges_number = int(input(\"Enter number of edges: \").strip())\n    adjacency_list = defaultdict(list)\n    for _ in range(edges_number):\n        edge = [int(x) for x in input().strip().split()]\n        adjacency_list[edge[0]].append([edge[1], edge[2]])\n        adjacency_list[edge[1]].append([edge[0], edge[2]])\n    print(prisms_algorithm(adjacency_list))\n", "graphs/dinic.py": "INF = float(\"inf\")\n\n\nclass Dinic:\n    def __init__(self, n):\n        self.lvl = [0] * n\n        self.ptr = [0] * n\n        self.q = [0] * n\n        self.adj = [[] for _ in range(n)]\n\n    \"\"\"\n    Here we will add our edges containing with the following parameters:\n    vertex closest to source, vertex closest to sink and flow capacity\n    through that edge ...\n    \"\"\"\n\n    def add_edge(self, a, b, c, rcap=0):\n        self.adj[a].append([b, len(self.adj[b]), c, 0])\n        self.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])\n\n    # This is a sample depth first search to be used at max_flow\n    def depth_first_search(self, vertex, sink, flow):\n        if vertex == sink or not flow:\n            return flow\n\n        for i in range(self.ptr[vertex], len(self.adj[vertex])):\n            e = self.adj[vertex][i]\n            if self.lvl[e[0]] == self.lvl[vertex] + 1:\n                p = self.depth_first_search(e[0], sink, min(flow, e[2] - e[3]))\n                if p:\n                    self.adj[vertex][i][3] += p\n                    self.adj[e[0]][e[1]][3] -= p\n                    return p\n            self.ptr[vertex] = self.ptr[vertex] + 1\n        return 0\n\n    # Here we calculate the flow that reaches the sink\n    def max_flow(self, source, sink):\n        flow, self.q[0] = 0, source\n        for l in range(31):  # l = 30 maybe faster for random data  # noqa: E741\n            while True:\n                self.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)\n                qi, qe, self.lvl[source] = 0, 1, 1\n                while qi < qe and not self.lvl[sink]:\n                    v = self.q[qi]\n                    qi += 1\n                    for e in self.adj[v]:\n                        if not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):\n                            self.q[qe] = e[0]\n                            qe += 1\n                            self.lvl[e[0]] = self.lvl[v] + 1\n\n                p = self.depth_first_search(source, sink, INF)\n                while p:\n                    flow += p\n                    p = self.depth_first_search(source, sink, INF)\n\n                if not self.lvl[sink]:\n                    break\n\n        return flow\n\n\n# Example to use\n\n\"\"\"\nWill be a bipartite graph, than it has the vertices near the source(4)\nand the vertices near the sink(4)\n\"\"\"\n# Here we make a graphs with 10 vertex(source and sink includes)\ngraph = Dinic(10)\nsource = 0\nsink = 9\n\"\"\"\nNow we add the vertices next to the font in the font with 1 capacity in this edge\n(source -> source vertices)\n\"\"\"\nfor vertex in range(1, 5):\n    graph.add_edge(source, vertex, 1)\n\"\"\"\nWe will do the same thing for the vertices near the sink, but from vertex to sink\n(sink vertices -> sink)\n\"\"\"\nfor vertex in range(5, 9):\n    graph.add_edge(vertex, sink, 1)\n\"\"\"\nFinally we add the verices near the sink to the vertices near the source.\n(source vertices -> sink vertices)\n\"\"\"\nfor vertex in range(1, 5):\n    graph.add_edge(vertex, vertex + 4, 1)\n\n# Now we can know that is the maximum flow(source -> sink)\nprint(graph.max_flow(source, sink))\n", "graphs/deep_clone_graph.py": "\"\"\"\nLeetCode 133. Clone Graph\nhttps://leetcode.com/problems/clone-graph/\n\nGiven a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its\nneighbors.\n\"\"\"\n\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    value: int = 0\n    neighbors: list[\"Node\"] | None = None\n\n    def __post_init__(self) -> None:\n        \"\"\"\n        >>> Node(3).neighbors\n        []\n        \"\"\"\n        self.neighbors = self.neighbors or []\n\n    def __hash__(self) -> int:\n        \"\"\"\n        >>> hash(Node(3)) != 0\n        True\n        \"\"\"\n        return id(self)\n\n\ndef clone_graph(node: Node | None) -> Node | None:\n    \"\"\"\n    This function returns a clone of a connected undirected graph.\n    >>> clone_graph(Node(1))\n    Node(value=1, neighbors=[])\n    >>> clone_graph(Node(1, [Node(2)]))\n    Node(value=1, neighbors=[Node(value=2, neighbors=[])])\n    >>> clone_graph(None) is None\n    True\n    \"\"\"\n    if not node:\n        return None\n\n    originals_to_clones = {}  # map nodes to clones\n\n    stack = [node]\n\n    while stack:\n        original = stack.pop()\n\n        if original in originals_to_clones:\n            continue\n\n        originals_to_clones[original] = Node(original.value)\n\n        stack.extend(original.neighbors or [])\n\n    for original, clone in originals_to_clones.items():\n        for neighbor in original.neighbors or []:\n            cloned_neighbor = originals_to_clones[neighbor]\n\n            if not clone.neighbors:\n                clone.neighbors = []\n\n            clone.neighbors.append(cloned_neighbor)\n\n    return originals_to_clones[node]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/greedy_min_vertex_cover.py": "\"\"\"\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\n* Description: Approximization algorithm for minimum vertex cover problem.\n               Greedy Approach. Uses graphs represented with an adjacency list\nURL: https://mathworld.wolfram.com/MinimumVertexCover.html\nURL: https://cs.stackexchange.com/questions/129017/greedy-algorithm-for-vertex-cover\n\"\"\"\n\nimport heapq\n\n\ndef greedy_min_vertex_cover(graph: dict) -> set[int]:\n    \"\"\"\n    Greedy APX Algorithm for min Vertex Cover\n    @input: graph (graph stored in an adjacency list where each vertex\n            is represented with an integer)\n    @example:\n    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    >>> greedy_min_vertex_cover(graph)\n    {0, 1, 2, 4}\n    \"\"\"\n    # queue used to store nodes and their rank\n    queue: list[list] = []\n\n    # for each node and his adjacency list add them and the rank of the node to queue\n    # using heapq module the queue will be filled like a Priority Queue\n    # heapq works with a min priority queue, so I used -1*len(v) to build it\n    for key, value in graph.items():\n        # O(log(n))\n        heapq.heappush(queue, [-1 * len(value), (key, value)])\n\n    # chosen_vertices = set of chosen vertices\n    chosen_vertices = set()\n\n    # while queue isn't empty and there are still edges\n    #   (queue[0][0] is the rank of the node with max rank)\n    while queue and queue[0][0] != 0:\n        # extract vertex with max rank from queue and add it to chosen_vertices\n        argmax = heapq.heappop(queue)[1][0]\n        chosen_vertices.add(argmax)\n\n        # Remove all arcs adjacent to argmax\n        for elem in queue:\n            # if v haven't adjacent node, skip\n            if elem[0] == 0:\n                continue\n            # if argmax is reachable from elem\n            # remove argmax from elem's adjacent list and update his rank\n            if argmax in elem[1][1]:\n                index = elem[1][1].index(argmax)\n                del elem[1][1][index]\n                elem[0] += 1\n        # re-order the queue\n        heapq.heapify(queue)\n    return chosen_vertices\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}\n    print(f\"Minimum vertex cover:\\n{greedy_min_vertex_cover(graph)}\")\n", "graphs/dijkstra_alternate.py": "from __future__ import annotations\n\n\nclass Graph:\n    def __init__(self, vertices: int) -> None:\n        \"\"\"\n        >>> graph = Graph(2)\n        >>> graph.vertices\n        2\n        >>> len(graph.graph)\n        2\n        >>> len(graph.graph[0])\n        2\n        \"\"\"\n        self.vertices = vertices\n        self.graph = [[0] * vertices for _ in range(vertices)]\n\n    def print_solution(self, distances_from_source: list[int]) -> None:\n        \"\"\"\n        >>> Graph(0).print_solution([])  # doctest: +NORMALIZE_WHITESPACE\n        Vertex \t Distance from Source\n        \"\"\"\n        print(\"Vertex \\t Distance from Source\")\n        for vertex in range(self.vertices):\n            print(vertex, \"\\t\\t\", distances_from_source[vertex])\n\n    def minimum_distance(\n        self, distances_from_source: list[int], visited: list[bool]\n    ) -> int:\n        \"\"\"\n        A utility function to find the vertex with minimum distance value, from the set\n        of vertices not yet included in shortest path tree.\n\n        >>> Graph(3).minimum_distance([1, 2, 3], [False, False, True])\n        0\n        \"\"\"\n\n        # Initialize minimum distance for next node\n        minimum = 1e7\n        min_index = 0\n\n        # Search not nearest vertex not in the shortest path tree\n        for vertex in range(self.vertices):\n            if distances_from_source[vertex] < minimum and visited[vertex] is False:\n                minimum = distances_from_source[vertex]\n                min_index = vertex\n        return min_index\n\n    def dijkstra(self, source: int) -> None:\n        \"\"\"\n        Function that implements Dijkstra's single source shortest path algorithm for a\n        graph represented using adjacency matrix representation.\n\n        >>> Graph(4).dijkstra(1)  # doctest: +NORMALIZE_WHITESPACE\n        Vertex  Distance from Source\n        0 \t\t 10000000\n        1 \t\t 0\n        2 \t\t 10000000\n        3 \t\t 10000000\n        \"\"\"\n\n        distances = [int(1e7)] * self.vertices  # distances from the source\n        distances[source] = 0\n        visited = [False] * self.vertices\n\n        for _ in range(self.vertices):\n            u = self.minimum_distance(distances, visited)\n            visited[u] = True\n\n            # Update dist value of the adjacent vertices\n            # of the picked vertex only if the current\n            # distance is greater than new distance and\n            # the vertex in not in the shortest path tree\n            for v in range(self.vertices):\n                if (\n                    self.graph[u][v] > 0\n                    and visited[v] is False\n                    and distances[v] > distances[u] + self.graph[u][v]\n                ):\n                    distances[v] = distances[u] + self.graph[u][v]\n\n        self.print_solution(distances)\n\n\nif __name__ == \"__main__\":\n    graph = Graph(9)\n    graph.graph = [\n        [0, 4, 0, 0, 0, 0, 0, 8, 0],\n        [4, 0, 8, 0, 0, 0, 0, 11, 0],\n        [0, 8, 0, 7, 0, 4, 0, 0, 2],\n        [0, 0, 7, 0, 9, 14, 0, 0, 0],\n        [0, 0, 0, 9, 0, 10, 0, 0, 0],\n        [0, 0, 4, 14, 10, 0, 2, 0, 0],\n        [0, 0, 0, 0, 0, 2, 0, 1, 6],\n        [8, 11, 0, 0, 0, 0, 1, 0, 7],\n        [0, 0, 2, 0, 0, 0, 6, 7, 0],\n    ]\n    graph.dijkstra(0)\n", "graphs/frequent_pattern_graph_miner.py": "\"\"\"\nFP-GraphMiner - A Fast Frequent Pattern Mining Algorithm for Network Graphs\n\nA novel Frequent Pattern Graph Mining algorithm, FP-GraphMiner, that compactly\nrepresents a set of network graphs as a Frequent Pattern Graph (or FP-Graph).\nThis graph can be used to efficiently mine frequent subgraphs including maximal\nfrequent subgraphs and maximum common subgraphs.\n\nURL: https://www.researchgate.net/publication/235255851\n\"\"\"\n\n# fmt: off\nedge_array = [\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12', 'cd-e2', 'ce-e4',\n     'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3', 'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3'],\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'cd-e2', 'de-e1', 'df-e8',\n     'ef-e3', 'eg-e2', 'fg-e6'],\n    ['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'de-e1', 'df-e8', 'dg-e5', 'ef-e3', 'eg-e2',\n     'eh-e12', 'fg-e6', 'fh-e10', 'gh-e6'],\n    ['ab-e1', 'ac-e3', 'bc-e4', 'bd-e2', 'bh-e12', 'cd-e2', 'df-e8', 'dh-e10'],\n    ['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'cd-e2', 'ce-e4', 'de-e1', 'df-e8',\n     'dg-e5', 'ef-e3', 'eg-e2', 'fg-e6']\n]\n# fmt: on\n\n\ndef get_distinct_edge(edge_array):\n    \"\"\"\n    Return Distinct edges from edge array of multiple graphs\n    >>> sorted(get_distinct_edge(edge_array))\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    \"\"\"\n    distinct_edge = set()\n    for row in edge_array:\n        for item in row:\n            distinct_edge.add(item[0])\n    return list(distinct_edge)\n\n\ndef get_bitcode(edge_array, distinct_edge):\n    \"\"\"\n    Return bitcode of distinct_edge\n    \"\"\"\n    bitcode = [\"0\"] * len(edge_array)\n    for i, row in enumerate(edge_array):\n        for item in row:\n            if distinct_edge in item[0]:\n                bitcode[i] = \"1\"\n                break\n    return \"\".join(bitcode)\n\n\ndef get_frequency_table(edge_array):\n    \"\"\"\n    Returns Frequency Table\n    \"\"\"\n    distinct_edge = get_distinct_edge(edge_array)\n    frequency_table = {}\n\n    for item in distinct_edge:\n        bit = get_bitcode(edge_array, item)\n        # print('bit',bit)\n        # bt=''.join(bit)\n        s = bit.count(\"1\")\n        frequency_table[item] = [s, bit]\n    # Store [Distinct edge, WT(Bitcode), Bitcode] in descending order\n    sorted_frequency_table = [\n        [k, v[0], v[1]]\n        for k, v in sorted(frequency_table.items(), key=lambda v: v[1][0], reverse=True)\n    ]\n    return sorted_frequency_table\n\n\ndef get_nodes(frequency_table):\n    \"\"\"\n    Returns nodes\n    format nodes={bitcode:edges that represent the bitcode}\n    >>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],\n    ...            ['bd', 5, '11111'], ['bc', 5, '11111']])\n    {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}\n    \"\"\"\n    nodes = {}\n    for _, item in enumerate(frequency_table):\n        nodes.setdefault(item[2], []).append(item[0])\n    return nodes\n\n\ndef get_cluster(nodes):\n    \"\"\"\n    Returns cluster\n    format cluster:{WT(bitcode):nodes with same WT}\n    \"\"\"\n    cluster = {}\n    for key, value in nodes.items():\n        cluster.setdefault(key.count(\"1\"), {})[key] = value\n    return cluster\n\n\ndef get_support(cluster):\n    \"\"\"\n    Returns support\n    >>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},\n    ...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},\n    ...              3: {'11001': ['ad'], '10101': ['dg']},\n    ...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],\n    ...                  '10001': ['ce']},\n    ...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})\n    [100.0, 80.0, 60.0, 40.0, 20.0]\n    \"\"\"\n    return [i * 100 / len(cluster) for i in cluster]\n\n\ndef print_all() -> None:\n    print(\"\\nNodes\\n\")\n    for key, value in nodes.items():\n        print(key, value)\n    print(\"\\nSupport\\n\")\n    print(support)\n    print(\"\\n Cluster \\n\")\n    for key, value in sorted(cluster.items(), reverse=True):\n        print(key, value)\n    print(\"\\n Graph\\n\")\n    for key, value in graph.items():\n        print(key, value)\n    print(\"\\n Edge List of Frequent subgraphs \\n\")\n    for edge_list in freq_subgraph_edge_list:\n        print(edge_list)\n\n\ndef create_edge(nodes, graph, cluster, c1):\n    \"\"\"\n    create edge between the nodes\n    \"\"\"\n    for i in cluster[c1]:\n        count = 0\n        c2 = c1 + 1\n        while c2 < max(cluster.keys()):\n            for j in cluster[c2]:\n                \"\"\"\n                creates edge only if the condition satisfies\n                \"\"\"\n                if int(i, 2) & int(j, 2) == int(i, 2):\n                    if tuple(nodes[i]) in graph:\n                        graph[tuple(nodes[i])].append(nodes[j])\n                    else:\n                        graph[tuple(nodes[i])] = [nodes[j]]\n                    count += 1\n            if count == 0:\n                c2 = c2 + 1\n            else:\n                break\n\n\ndef construct_graph(cluster, nodes):\n    x = cluster[max(cluster.keys())]\n    cluster[max(cluster.keys()) + 1] = \"Header\"\n    graph = {}\n    for i in x:\n        if ([\"Header\"],) in graph:\n            graph[([\"Header\"],)].append(x[i])\n        else:\n            graph[([\"Header\"],)] = [x[i]]\n    for i in x:\n        graph[(x[i],)] = [[\"Header\"]]\n    i = 1\n    while i < max(cluster) - 1:\n        create_edge(nodes, graph, cluster, i)\n        i = i + 1\n    return graph\n\n\ndef my_dfs(graph, start, end, path=None):\n    \"\"\"\n    find different DFS walk from given node to Header node\n    \"\"\"\n    path = (path or []) + [start]\n    if start == end:\n        paths.append(path)\n    for node in graph[start]:\n        if tuple(node) not in path:\n            my_dfs(graph, tuple(node), end, path)\n\n\ndef find_freq_subgraph_given_support(s, cluster, graph):\n    \"\"\"\n    find edges of multiple frequent subgraphs\n    \"\"\"\n    k = int(s / 100 * (len(cluster) - 1))\n    for i in cluster[k]:\n        my_dfs(graph, tuple(cluster[k][i]), ([\"Header\"],))\n\n\ndef freq_subgraphs_edge_list(paths):\n    \"\"\"\n    returns Edge list for frequent subgraphs\n    \"\"\"\n    freq_sub_el = []\n    for edges in paths:\n        el = []\n        for j in range(len(edges) - 1):\n            temp = list(edges[j])\n            for e in temp:\n                edge = (e[0], e[1])\n                el.append(edge)\n        freq_sub_el.append(el)\n    return freq_sub_el\n\n\ndef preprocess(edge_array):\n    \"\"\"\n    Preprocess the edge array\n    >>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',\n    ...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',\n    ...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])\n\n    \"\"\"\n    for i in range(len(edge_array)):\n        for j in range(len(edge_array[i])):\n            t = edge_array[i][j].split(\"-\")\n            edge_array[i][j] = t\n\n\nif __name__ == \"__main__\":\n    preprocess(edge_array)\n    frequency_table = get_frequency_table(edge_array)\n    nodes = get_nodes(frequency_table)\n    cluster = get_cluster(nodes)\n    support = get_support(cluster)\n    graph = construct_graph(cluster, nodes)\n    find_freq_subgraph_given_support(60, cluster, graph)\n    paths: list = []\n    freq_subgraph_edge_list = freq_subgraphs_edge_list(paths)\n    print_all()\n", "graphs/strongly_connected_components.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Strongly_connected_component\n\nFinding strongly connected components in directed graph\n\n\"\"\"\n\ntest_graph_1 = {0: [2, 3], 1: [0], 2: [1], 3: [4], 4: []}\n\ntest_graph_2 = {0: [1, 2, 3], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3]}\n\n\ndef topology_sort(\n    graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to sort graph\n    At this time graph is the same as input\n    >>> topology_sort(test_graph_1, 0, 5 * [False])\n    [1, 2, 4, 3, 0]\n    >>> topology_sort(test_graph_2, 0, 6 * [False])\n    [2, 1, 5, 4, 3, 0]\n    \"\"\"\n\n    visited[vert] = True\n    order = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            order += topology_sort(graph, neighbour, visited)\n\n    order.append(vert)\n\n    return order\n\n\ndef find_components(\n    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]\n) -> list[int]:\n    \"\"\"\n    Use depth first search to find strongly connected\n    vertices. Now graph is reversed\n    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])\n    [0, 1, 2]\n    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])\n    [0, 2, 1]\n    \"\"\"\n\n    visited[vert] = True\n    component = [vert]\n\n    for neighbour in reversed_graph[vert]:\n        if not visited[neighbour]:\n            component += find_components(reversed_graph, neighbour, visited)\n\n    return component\n\n\ndef strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:\n    \"\"\"\n    This function takes graph as a parameter\n    and then returns the list of strongly connected components\n    >>> strongly_connected_components(test_graph_1)\n    [[0, 1, 2], [3], [4]]\n    >>> strongly_connected_components(test_graph_2)\n    [[0, 2, 1], [3, 5, 4]]\n    \"\"\"\n\n    visited = len(graph) * [False]\n    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}\n\n    for vert, neighbours in graph.items():\n        for neighbour in neighbours:\n            reversed_graph[neighbour].append(vert)\n\n    order = []\n    for i, was_visited in enumerate(visited):\n        if not was_visited:\n            order += topology_sort(graph, i, visited)\n\n    components_list = []\n    visited = len(graph) * [False]\n\n    for i in range(len(graph)):\n        vert = order[len(graph) - i - 1]\n        if not visited[vert]:\n            component = find_components(reversed_graph, vert, visited)\n            components_list.append(component)\n\n    return components_list\n", "graphs/graphs_floyd_warshall.py": "# floyd_warshall.py\n\"\"\"\nThe problem is to find the shortest distance between all pairs of vertices in a\nweighted directed graph that can have negative edge weights.\n\"\"\"\n\n\ndef _print_dist(dist, v):\n    print(\"\\nThe shortest path matrix using Floyd Warshall algorithm\\n\")\n    for i in range(v):\n        for j in range(v):\n            if dist[i][j] != float(\"inf\"):\n                print(int(dist[i][j]), end=\"\\t\")\n            else:\n                print(\"INF\", end=\"\\t\")\n        print()\n\n\ndef floyd_warshall(graph, v):\n    \"\"\"\n    :param graph: 2D array calculated from weight[edge[i, j]]\n    :type graph: List[List[float]]\n    :param v: number of vertices\n    :type v: int\n    :return: shortest distance between all vertex pairs\n    distance[u][v] will contain the shortest distance from vertex u to v.\n\n    1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).\n    3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +\n        distance[k][j]) for each possible pair i, j of vertices.\n    4. The above is repeated for each vertex k in the graph.\n    5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is\n        updated to the next vertex[i][k].\n    \"\"\"\n\n    dist = [[float(\"inf\") for _ in range(v)] for _ in range(v)]\n\n    for i in range(v):\n        for j in range(v):\n            dist[i][j] = graph[i][j]\n\n            # check vertex k against all other vertices (i, j)\n    for k in range(v):\n        # looping through rows of graph array\n        for i in range(v):\n            # looping through columns of graph array\n            for j in range(v):\n                if (\n                    dist[i][k] != float(\"inf\")\n                    and dist[k][j] != float(\"inf\")\n                    and dist[i][k] + dist[k][j] < dist[i][j]\n                ):\n                    dist[i][j] = dist[i][k] + dist[k][j]\n\n    _print_dist(dist, v)\n    return dist, v\n\n\nif __name__ == \"__main__\":\n    v = int(input(\"Enter number of vertices: \"))\n    e = int(input(\"Enter number of edges: \"))\n\n    graph = [[float(\"inf\") for i in range(v)] for j in range(v)]\n\n    for i in range(v):\n        graph[i][i] = 0.0\n\n        # src and dst are indices that must be within the array size graph[e][v]\n        # failure to follow this will result in an error\n    for i in range(e):\n        print(\"\\nEdge \", i + 1)\n        src = int(input(\"Enter source:\"))\n        dst = int(input(\"Enter destination:\"))\n        weight = float(input(\"Enter weight:\"))\n        graph[src][dst] = weight\n\n    floyd_warshall(graph, v)\n\n    # Example Input\n    # Enter number of vertices: 3\n    # Enter number of edges: 2\n\n    # # generated graph from vertex and edge inputs\n    # [[inf, inf, inf], [inf, inf, inf], [inf, inf, inf]]\n    # [[0.0, inf, inf], [inf, 0.0, inf], [inf, inf, 0.0]]\n\n    # specify source, destination and weight for edge #1\n    # Edge  1\n    # Enter source:1\n    # Enter destination:2\n    # Enter weight:2\n\n    # specify source, destination and weight for edge #2\n    # Edge  2\n    # Enter source:2\n    # Enter destination:1\n    # Enter weight:1\n\n    # # Expected Output from the vertice, edge and src, dst, weight inputs!!\n    # 0\t\tINF\tINF\n    # INF\t0\t2\n    # INF\t1\t0\n", "graphs/bidirectional_breadth_first_search.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Bidirectional_search\n\"\"\"\n\nfrom __future__ import annotations\n\nimport time\n\nPath = list[tuple[int, int]]\n\ngrid = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0],\n]\n\ndelta = [[-1, 0], [0, -1], [1, 0], [0, 1]]  # up, left, down, right\n\n\nclass Node:\n    def __init__(\n        self, pos_x: int, pos_y: int, goal_x: int, goal_y: int, parent: Node | None\n    ):\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n        self.pos = (pos_y, pos_x)\n        self.goal_x = goal_x\n        self.goal_y = goal_y\n        self.parent = parent\n\n\nclass BreadthFirstSearch:\n    \"\"\"\n    # Comment out slow pytests...\n    # 9.15s call     graphs/bidirectional_breadth_first_search.py:: \\\n    #                graphs.bidirectional_breadth_first_search.BreadthFirstSearch\n    # >>> bfs = BreadthFirstSearch((0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    # >>> (bfs.start.pos_y + delta[3][0], bfs.start.pos_x + delta[3][1])\n    (0, 1)\n    # >>> [x.pos for x in bfs.get_successors(bfs.start)]\n    [(1, 0), (0, 1)]\n    # >>> (bfs.start.pos_y + delta[2][0], bfs.start.pos_x + delta[2][1])\n    (1, 0)\n    # >>> bfs.retrace_path(bfs.start)\n    [(0, 0)]\n    # >>> bfs.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 1),\n     (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (6, 5), (6, 6)]\n    \"\"\"\n\n    def __init__(self, start: tuple[int, int], goal: tuple[int, int]):\n        self.start = Node(start[1], start[0], goal[1], goal[0], None)\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], None)\n\n        self.node_queue = [self.start]\n        self.reached = False\n\n    def search(self) -> Path | None:\n        while self.node_queue:\n            current_node = self.node_queue.pop(0)\n\n            if current_node.pos == self.target.pos:\n                self.reached = True\n                return self.retrace_path(current_node)\n\n            successors = self.get_successors(current_node)\n\n            for node in successors:\n                self.node_queue.append(node)\n\n        if not self.reached:\n            return [self.start.pos]\n        return None\n\n    def get_successors(self, parent: Node) -> list[Node]:\n        \"\"\"\n        Returns a list of successors (both in the grid and free spaces)\n        \"\"\"\n        successors = []\n        for action in delta:\n            pos_x = parent.pos_x + action[1]\n            pos_y = parent.pos_y + action[0]\n            if not (0 <= pos_x <= len(grid[0]) - 1 and 0 <= pos_y <= len(grid) - 1):\n                continue\n\n            if grid[pos_y][pos_x] != 0:\n                continue\n\n            successors.append(\n                Node(pos_x, pos_y, self.target.pos_y, self.target.pos_x, parent)\n            )\n        return successors\n\n    def retrace_path(self, node: Node | None) -> Path:\n        \"\"\"\n        Retrace the path from parents to parents until start node\n        \"\"\"\n        current_node = node\n        path = []\n        while current_node is not None:\n            path.append((current_node.pos_y, current_node.pos_x))\n            current_node = current_node.parent\n        path.reverse()\n        return path\n\n\nclass BidirectionalBreadthFirstSearch:\n    \"\"\"\n    >>> bd_bfs = BidirectionalBreadthFirstSearch((0, 0), (len(grid) - 1,\n    ...                                                   len(grid[0]) - 1))\n    >>> bd_bfs.fwd_bfs.start.pos == bd_bfs.bwd_bfs.target.pos\n    True\n    >>> bd_bfs.retrace_bidirectional_path(bd_bfs.fwd_bfs.start,\n    ...                                     bd_bfs.bwd_bfs.start)\n    [(0, 0)]\n    >>> bd_bfs.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3),\n     (2, 4), (3, 4), (3, 5), (3, 6), (4, 6), (5, 6), (6, 6)]\n    \"\"\"\n\n    def __init__(self, start, goal):\n        self.fwd_bfs = BreadthFirstSearch(start, goal)\n        self.bwd_bfs = BreadthFirstSearch(goal, start)\n        self.reached = False\n\n    def search(self) -> Path | None:\n        while self.fwd_bfs.node_queue or self.bwd_bfs.node_queue:\n            current_fwd_node = self.fwd_bfs.node_queue.pop(0)\n            current_bwd_node = self.bwd_bfs.node_queue.pop(0)\n\n            if current_bwd_node.pos == current_fwd_node.pos:\n                self.reached = True\n                return self.retrace_bidirectional_path(\n                    current_fwd_node, current_bwd_node\n                )\n\n            self.fwd_bfs.target = current_bwd_node\n            self.bwd_bfs.target = current_fwd_node\n\n            successors = {\n                self.fwd_bfs: self.fwd_bfs.get_successors(current_fwd_node),\n                self.bwd_bfs: self.bwd_bfs.get_successors(current_bwd_node),\n            }\n\n            for bfs in [self.fwd_bfs, self.bwd_bfs]:\n                for node in successors[bfs]:\n                    bfs.node_queue.append(node)\n\n        if not self.reached:\n            return [self.fwd_bfs.start.pos]\n        return None\n\n    def retrace_bidirectional_path(self, fwd_node: Node, bwd_node: Node) -> Path:\n        fwd_path = self.fwd_bfs.retrace_path(fwd_node)\n        bwd_path = self.bwd_bfs.retrace_path(bwd_node)\n        bwd_path.pop()\n        bwd_path.reverse()\n        path = fwd_path + bwd_path\n        return path\n\n\nif __name__ == \"__main__\":\n    # all coordinates are given in format [y,x]\n    import doctest\n\n    doctest.testmod()\n    init = (0, 0)\n    goal = (len(grid) - 1, len(grid[0]) - 1)\n    for elem in grid:\n        print(elem)\n\n    start_bfs_time = time.time()\n    bfs = BreadthFirstSearch(init, goal)\n    path = bfs.search()\n    bfs_time = time.time() - start_bfs_time\n\n    print(\"Unidirectional BFS computation time : \", bfs_time)\n\n    start_bd_bfs_time = time.time()\n    bd_bfs = BidirectionalBreadthFirstSearch(init, goal)\n    bd_path = bd_bfs.search()\n    bd_bfs_time = time.time() - start_bd_bfs_time\n\n    print(\"Bidirectional BFS computation time : \", bd_bfs_time)\n", "graphs/basic_graphs.py": "from collections import deque\n\n\ndef _input(message):\n    return input(message).strip().split(\" \")\n\n\ndef initialize_unweighted_directed_graph(\n    node_count: int, edge_count: int\n) -> dict[int, list[int]]:\n    graph: dict[int, list[int]] = {}\n    for i in range(node_count):\n        graph[i + 1] = []\n\n    for e in range(edge_count):\n        x, y = (int(i) for i in _input(f\"Edge {e + 1}: <node1> <node2> \"))\n        graph[x].append(y)\n    return graph\n\n\ndef initialize_unweighted_undirected_graph(\n    node_count: int, edge_count: int\n) -> dict[int, list[int]]:\n    graph: dict[int, list[int]] = {}\n    for i in range(node_count):\n        graph[i + 1] = []\n\n    for e in range(edge_count):\n        x, y = (int(i) for i in _input(f\"Edge {e + 1}: <node1> <node2> \"))\n        graph[x].append(y)\n        graph[y].append(x)\n    return graph\n\n\ndef initialize_weighted_undirected_graph(\n    node_count: int, edge_count: int\n) -> dict[int, list[tuple[int, int]]]:\n    graph: dict[int, list[tuple[int, int]]] = {}\n    for i in range(node_count):\n        graph[i + 1] = []\n\n    for e in range(edge_count):\n        x, y, w = (int(i) for i in _input(f\"Edge {e + 1}: <node1> <node2> <weight> \"))\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    return graph\n\n\nif __name__ == \"__main__\":\n    n, m = (int(i) for i in _input(\"Number of nodes and edges: \"))\n\n    graph_choice = int(\n        _input(\n            \"Press 1 or 2 or 3 \\n\"\n            \"1. Unweighted directed \\n\"\n            \"2. Unweighted undirected \\n\"\n            \"3. Weighted undirected \\n\"\n        )[0]\n    )\n\n    g = {\n        1: initialize_unweighted_directed_graph,\n        2: initialize_unweighted_undirected_graph,\n        3: initialize_weighted_undirected_graph,\n    }[graph_choice](n, m)\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Depth First Search.\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  vis - Set of visited nodes\n                S - Traversal Stack\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef dfs(g, s):\n    vis, _s = {s}, [s]\n    print(s)\n    while _s:\n        flag = 0\n        for i in g[_s[-1]]:\n            if i not in vis:\n                _s.append(i)\n                vis.add(i)\n                flag = 1\n                print(i)\n                break\n        if not flag:\n            _s.pop()\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Breadth First Search.\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  vis - Set of visited nodes\n                Q - Traversal Stack\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef bfs(g, s):\n    vis, q = {s}, deque([s])\n    print(s)\n    while q:\n        u = q.popleft()\n        for v in g[u]:\n            if v not in vis:\n                vis.add(v)\n                q.append(v)\n                print(v)\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Dijkstra's shortest path Algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\n                known - Set of knows nodes\n                path - Preceding node in path\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef dijk(g, s):\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for i in dist:\n            if i not in known and dist[i] < mini:\n                mini = dist[i]\n                u = i\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and dist[u] + v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = dist[u] + v[1]\n                path[v[0]] = u\n    for i in dist:\n        if i != s:\n            print(dist[i])\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Topological Sort\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef topo(g, ind=None, q=None):\n    if q is None:\n        q = [1]\n    if ind is None:\n        ind = [0] * (len(g) + 1)  # SInce oth Index is ignored\n        for u in g:\n            for v in g[u]:\n                ind[v] += 1\n        q = deque()\n        for i in g:\n            if ind[i] == 0:\n                q.append(i)\n    if len(q) == 0:\n        return\n    v = q.popleft()\n    print(v)\n    for w in g[v]:\n        ind[w] -= 1\n        if ind[w] == 0:\n            q.append(w)\n    topo(g, ind, q)\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Reading an Adjacency matrix\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef adjm():\n    r\"\"\"\n    Reading an Adjacency matrix\n\n    Parameters:\n        None\n\n    Returns:\n        tuple: A tuple containing a list of edges and number of edges\n\n    Example:\n    >>> # Simulate user input for 3 nodes\n    >>> input_data = \"4\\n0 1 0 1\\n1 0 1 0\\n0 1 0 1\\n1 0 1 0\\n\"\n    >>> import sys,io\n    >>> original_input = sys.stdin\n    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n    >>> adjm()\n    ([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4)\n    >>> sys.stdin = original_input  # Restore original stdin\n    \"\"\"\n    n = int(input().strip())\n    a = []\n    for _ in range(n):\n        a.append(tuple(map(int, input().strip().split())))\n    return a, n\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Floyd Warshall's algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\n                known - Set of knows nodes\n                path - Preceding node in path\n\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef floy(a_and_n):\n    (a, n) = a_and_n\n    dist = list(a)\n    path = [[0] * n for i in range(n)]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    path[i][k] = k\n    print(dist)\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Prim's MST Algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to nearest node\n                known - Set of knows nodes\n                path - Preceding node in path\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef prim(g, s):\n    dist, known, path = {s: 0}, set(), {s: 0}\n    while True:\n        if len(known) == len(g) - 1:\n            break\n        mini = 100000\n        for i in dist:\n            if i not in known and dist[i] < mini:\n                mini = dist[i]\n                u = i\n        known.add(u)\n        for v in g[u]:\n            if v[0] not in known and v[1] < dist.get(v[0], 100000):\n                dist[v[0]] = v[1]\n                path[v[0]] = u\n    return dist\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Accepting Edge list\n        Vars :  n - Number of nodes\n                m - Number of edges\n        Returns : l - Edge list\n                n - Number of Nodes\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef edglist():\n    r\"\"\"\n    Get the edges and number of edges from the user\n\n    Parameters:\n        None\n\n    Returns:\n        tuple: A tuple containing a list of edges and number of edges\n\n    Example:\n    >>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4)\n    >>> input_data = \"4 3\\n1 2\\n2 3\\n3 4\\n\"\n    >>> import sys,io\n    >>> original_input = sys.stdin\n    >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing\n    >>> edglist()\n    ([(1, 2), (2, 3), (3, 4)], 4)\n    >>> sys.stdin = original_input  # Restore original stdin\n    \"\"\"\n    n, m = tuple(map(int, input().split(\" \")))\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split(\" \"))))\n    return edges, n\n\n\n\"\"\"\n--------------------------------------------------------------------------------\n    Kruskal's MST Algorithm\n        Args :  E - Edge list\n                n - Number of Nodes\n        Vars :  s - Set of all nodes as unique disjoint sets (initially)\n--------------------------------------------------------------------------------\n\"\"\"\n\n\ndef krusk(e_and_n):\n    \"\"\"\n    Sort edges on the basis of distance\n    \"\"\"\n    (e, n) = e_and_n\n    e.sort(reverse=True, key=lambda x: x[2])\n    s = [{i} for i in range(1, n + 1)]\n    while True:\n        if len(s) == 1:\n            break\n        print(s)\n        x = e.pop()\n        for i in range(len(s)):\n            if x[0] in s[i]:\n                break\n        for j in range(len(s)):\n            if x[1] in s[j]:\n                if i == j:\n                    break\n                s[j].update(s[i])\n                s.pop(i)\n                break\n\n\ndef find_isolated_nodes(graph):\n    \"\"\"\n    Find the isolated node in the graph\n\n    Parameters:\n    graph (dict): A dictionary representing a graph.\n\n    Returns:\n    list: A list of isolated nodes.\n\n    Examples:\n    >>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}\n    >>> find_isolated_nodes(graph1)\n    [4]\n\n    >>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []}\n    >>> find_isolated_nodes(graph2)\n    ['D']\n\n    >>> graph3 = {'X': [], 'Y': [], 'Z': []}\n    >>> find_isolated_nodes(graph3)\n    ['X', 'Y', 'Z']\n\n    >>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}\n    >>> find_isolated_nodes(graph4)\n    []\n\n    >>> graph5 = {}\n    >>> find_isolated_nodes(graph5)\n    []\n    \"\"\"\n    isolated = []\n    for node in graph:\n        if not graph[node]:\n            isolated.append(node)\n    return isolated\n", "graphs/gale_shapley_bigraph.py": "from __future__ import annotations\n\n\ndef stable_matching(\n    donor_pref: list[list[int]], recipient_pref: list[list[int]]\n) -> list[int]:\n    \"\"\"\n    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects\n    prefer each other over their partner.  The function accepts the preferences of\n    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and\n    returns a list where the index position corresponds to the donor and value at the\n    index is the organ recipient.\n\n    To better understand the algorithm, see also:\n    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).\n    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).\n\n    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]\n    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]\n    >>> stable_matching(donor_pref, recipient_pref)\n    [1, 2, 3, 0]\n    \"\"\"\n    assert len(donor_pref) == len(recipient_pref)\n\n    n = len(donor_pref)\n    unmatched_donors = list(range(n))\n    donor_record = [-1] * n  # who the donor has donated to\n    rec_record = [-1] * n  # who the recipient has received from\n    num_donations = [0] * n\n\n    while unmatched_donors:\n        donor = unmatched_donors[0]\n        donor_preference = donor_pref[donor]\n        recipient = donor_preference[num_donations[donor]]\n        num_donations[donor] += 1\n        rec_preference = recipient_pref[recipient]\n        prev_donor = rec_record[recipient]\n\n        if prev_donor != -1:\n            if rec_preference.index(prev_donor) > rec_preference.index(donor):\n                rec_record[recipient] = donor\n                donor_record[donor] = recipient\n                unmatched_donors.append(prev_donor)\n                unmatched_donors.remove(donor)\n        else:\n            rec_record[recipient] = donor\n            donor_record[donor] = recipient\n            unmatched_donors.remove(donor)\n    return donor_record\n", "graphs/bi_directional_dijkstra.py": "\"\"\"\nBi-directional Dijkstra's algorithm.\n\nA bi-directional approach is an efficient and\nless time consuming optimization for Dijkstra's\nsearching algorithm\n\nReference: shorturl.at/exHM7\n\"\"\"\n\n# Author: Swayam Singh (https://github.com/practice404)\n\nfrom queue import PriorityQueue\nfrom typing import Any\n\nimport numpy as np\n\n\ndef pass_and_relaxation(\n    graph: dict,\n    v: str,\n    visited_forward: set,\n    visited_backward: set,\n    cst_fwd: dict,\n    cst_bwd: dict,\n    queue: PriorityQueue,\n    parent: dict,\n    shortest_distance: float,\n) -> float:\n    for nxt, d in graph[v]:\n        if nxt in visited_forward:\n            continue\n        old_cost_f = cst_fwd.get(nxt, np.inf)\n        new_cost_f = cst_fwd[v] + d\n        if new_cost_f < old_cost_f:\n            queue.put((new_cost_f, nxt))\n            cst_fwd[nxt] = new_cost_f\n            parent[nxt] = v\n        if (\n            nxt in visited_backward\n            and cst_fwd[v] + d + cst_bwd[nxt] < shortest_distance\n        ):\n            shortest_distance = cst_fwd[v] + d + cst_bwd[nxt]\n    return shortest_distance\n\n\ndef bidirectional_dij(\n    source: str, destination: str, graph_forward: dict, graph_backward: dict\n) -> int:\n    \"\"\"\n    Bi-directional Dijkstra's algorithm.\n\n    Returns:\n        shortest_path_distance (int): length of the shortest path.\n\n    Warnings:\n        If the destination is not reachable, function returns -1\n\n    >>> bidirectional_dij(\"E\", \"F\", graph_fwd, graph_bwd)\n    3\n    \"\"\"\n    shortest_path_distance = -1\n\n    visited_forward = set()\n    visited_backward = set()\n    cst_fwd = {source: 0}\n    cst_bwd = {destination: 0}\n    parent_forward = {source: None}\n    parent_backward = {destination: None}\n    queue_forward: PriorityQueue[Any] = PriorityQueue()\n    queue_backward: PriorityQueue[Any] = PriorityQueue()\n\n    shortest_distance = np.inf\n\n    queue_forward.put((0, source))\n    queue_backward.put((0, destination))\n\n    if source == destination:\n        return 0\n\n    while not queue_forward.empty() and not queue_backward.empty():\n        _, v_fwd = queue_forward.get()\n        visited_forward.add(v_fwd)\n\n        _, v_bwd = queue_backward.get()\n        visited_backward.add(v_bwd)\n\n        shortest_distance = pass_and_relaxation(\n            graph_forward,\n            v_fwd,\n            visited_forward,\n            visited_backward,\n            cst_fwd,\n            cst_bwd,\n            queue_forward,\n            parent_forward,\n            shortest_distance,\n        )\n\n        shortest_distance = pass_and_relaxation(\n            graph_backward,\n            v_bwd,\n            visited_backward,\n            visited_forward,\n            cst_bwd,\n            cst_fwd,\n            queue_backward,\n            parent_backward,\n            shortest_distance,\n        )\n\n        if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance:\n            break\n\n    if shortest_distance != np.inf:\n        shortest_path_distance = shortest_distance\n    return shortest_path_distance\n\n\ngraph_fwd = {\n    \"B\": [[\"C\", 1]],\n    \"C\": [[\"D\", 1]],\n    \"D\": [[\"F\", 1]],\n    \"E\": [[\"B\", 1], [\"G\", 2]],\n    \"F\": [],\n    \"G\": [[\"F\", 1]],\n}\ngraph_bwd = {\n    \"B\": [[\"E\", 1]],\n    \"C\": [[\"B\", 1]],\n    \"D\": [[\"C\", 1]],\n    \"F\": [[\"D\", 1], [\"G\", 1]],\n    \"E\": [[None, np.inf]],\n    \"G\": [[\"E\", 2]],\n}\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/boruvka.py": "\"\"\"Bor\u016fvka's algorithm.\n\nDetermines the minimum spanning tree (MST) of a graph using the Bor\u016fvka's algorithm.\nBor\u016fvka's algorithm is a greedy algorithm for finding a minimum spanning tree in a\nconnected graph, or a minimum spanning forest if a graph that is not connected.\n\nThe time complexity of this algorithm is O(ELogV), where E represents the number\nof edges, while V represents the number of nodes.\nO(number_of_edges Log number_of_nodes)\n\nThe space complexity of this algorithm is O(V + E), since we have to keep a couple\nof lists whose sizes are equal to the number of nodes, as well as keep all the\nedges of a graph inside of the data structure itself.\n\nBor\u016fvka's algorithm gives us pretty much the same result as other MST Algorithms -\nthey all find the minimum spanning tree, and the time complexity is approximately\nthe same.\n\nOne advantage that Bor\u016fvka's algorithm has compared to the alternatives is that it\ndoesn't need to presort the edges or maintain a priority queue in order to find the\nminimum spanning tree.\nEven though that doesn't help its complexity, since it still passes the edges logE\ntimes, it is a bit simpler to code.\n\nDetails: https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n\nclass Graph:\n    def __init__(self, num_of_nodes: int) -> None:\n        \"\"\"\n        Arguments:\n            num_of_nodes - the number of nodes in the graph\n        Attributes:\n            m_num_of_nodes - the number of nodes in the graph.\n            m_edges - the list of edges.\n            m_component - the dictionary which stores the index of the component which\n            a node belongs to.\n        \"\"\"\n\n        self.m_num_of_nodes = num_of_nodes\n        self.m_edges: list[list[int]] = []\n        self.m_component: dict[int, int] = {}\n\n    def add_edge(self, u_node: int, v_node: int, weight: int) -> None:\n        \"\"\"Adds an edge in the format [first, second, edge weight] to graph.\"\"\"\n\n        self.m_edges.append([u_node, v_node, weight])\n\n    def find_component(self, u_node: int) -> int:\n        \"\"\"Propagates a new component throughout a given component.\"\"\"\n\n        if self.m_component[u_node] == u_node:\n            return u_node\n        return self.find_component(self.m_component[u_node])\n\n    def set_component(self, u_node: int) -> None:\n        \"\"\"Finds the component index of a given node\"\"\"\n\n        if self.m_component[u_node] != u_node:\n            for k in self.m_component:\n                self.m_component[k] = self.find_component(k)\n\n    def union(self, component_size: list[int], u_node: int, v_node: int) -> None:\n        \"\"\"Union finds the roots of components for two nodes, compares the components\n        in terms of size, and attaches the smaller one to the larger one to form\n        single component\"\"\"\n\n        if component_size[u_node] <= component_size[v_node]:\n            self.m_component[u_node] = v_node\n            component_size[v_node] += component_size[u_node]\n            self.set_component(u_node)\n\n        elif component_size[u_node] >= component_size[v_node]:\n            self.m_component[v_node] = self.find_component(u_node)\n            component_size[u_node] += component_size[v_node]\n            self.set_component(v_node)\n\n    def boruvka(self) -> None:\n        \"\"\"Performs Bor\u016fvka's algorithm to find MST.\"\"\"\n\n        # Initialize additional lists required to algorithm.\n        component_size = []\n        mst_weight = 0\n\n        minimum_weight_edge: list[Any] = [-1] * self.m_num_of_nodes\n\n        # A list of components (initialized to all of the nodes)\n        for node in range(self.m_num_of_nodes):\n            self.m_component.update({node: node})\n            component_size.append(1)\n\n        num_of_components = self.m_num_of_nodes\n\n        while num_of_components > 1:\n            for edge in self.m_edges:\n                u, v, w = edge\n\n                u_component = self.m_component[u]\n                v_component = self.m_component[v]\n\n                if u_component != v_component:\n                    \"\"\"If the current minimum weight edge of component u doesn't\n                    exist (is -1), or if it's greater than the edge we're\n                    observing right now, we will assign the value of the edge\n                    we're observing to it.\n\n                    If the current minimum weight edge of component v doesn't\n                    exist (is -1), or if it's greater than the edge we're\n                    observing right now, we will assign the value of the edge\n                    we're observing to it\"\"\"\n\n                    for component in (u_component, v_component):\n                        if (\n                            minimum_weight_edge[component] == -1\n                            or minimum_weight_edge[component][2] > w\n                        ):\n                            minimum_weight_edge[component] = [u, v, w]\n\n            for edge in minimum_weight_edge:\n                if isinstance(edge, list):\n                    u, v, w = edge\n\n                    u_component = self.m_component[u]\n                    v_component = self.m_component[v]\n\n                    if u_component != v_component:\n                        mst_weight += w\n                        self.union(component_size, u_component, v_component)\n                        print(f\"Added edge [{u} - {v}]\\nAdded weight: {w}\\n\")\n                        num_of_components -= 1\n\n            minimum_weight_edge = [-1] * self.m_num_of_nodes\n        print(f\"The total weight of the minimal spanning tree is: {mst_weight}\")\n\n\ndef test_vector() -> None:\n    \"\"\"\n    >>> g = Graph(8)\n    >>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),\n    ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):\n    ...        g.add_edge(*u_v_w)\n    >>> g.boruvka()\n    Added edge [0 - 3]\n    Added weight: 5\n    <BLANKLINE>\n    Added edge [0 - 1]\n    Added weight: 10\n    <BLANKLINE>\n    Added edge [2 - 3]\n    Added weight: 4\n    <BLANKLINE>\n    Added edge [4 - 7]\n    Added weight: 5\n    <BLANKLINE>\n    Added edge [4 - 5]\n    Added weight: 10\n    <BLANKLINE>\n    Added edge [6 - 7]\n    Added weight: 4\n    <BLANKLINE>\n    Added edge [3 - 4]\n    Added weight: 8\n    <BLANKLINE>\n    The total weight of the minimal spanning tree is: 46\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/minimum_spanning_tree_boruvka.py": "class Graph:\n    \"\"\"\n    Data structure to store graphs (based on adjacency lists)\n    \"\"\"\n\n    def __init__(self):\n        self.num_vertices = 0\n        self.num_edges = 0\n        self.adjacency = {}\n\n    def add_vertex(self, vertex):\n        \"\"\"\n        Adds a vertex to the graph\n\n        \"\"\"\n        if vertex not in self.adjacency:\n            self.adjacency[vertex] = {}\n            self.num_vertices += 1\n\n    def add_edge(self, head, tail, weight):\n        \"\"\"\n        Adds an edge to the graph\n\n        \"\"\"\n\n        self.add_vertex(head)\n        self.add_vertex(tail)\n\n        if head == tail:\n            return\n\n        self.adjacency[head][tail] = weight\n        self.adjacency[tail][head] = weight\n\n    def distinct_weight(self):\n        \"\"\"\n        For Boruvks's algorithm the weights should be distinct\n        Converts the weights to be distinct\n\n        \"\"\"\n        edges = self.get_edges()\n        for edge in edges:\n            head, tail, weight = edge\n            edges.remove((tail, head, weight))\n        for i in range(len(edges)):\n            edges[i] = list(edges[i])\n\n        edges.sort(key=lambda e: e[2])\n        for i in range(len(edges) - 1):\n            if edges[i][2] >= edges[i + 1][2]:\n                edges[i + 1][2] = edges[i][2] + 1\n        for edge in edges:\n            head, tail, weight = edge\n            self.adjacency[head][tail] = weight\n            self.adjacency[tail][head] = weight\n\n    def __str__(self):\n        \"\"\"\n        Returns string representation of the graph\n        \"\"\"\n        string = \"\"\n        for tail in self.adjacency:\n            for head in self.adjacency[tail]:\n                weight = self.adjacency[head][tail]\n                string += f\"{head} -> {tail} == {weight}\\n\"\n        return string.rstrip(\"\\n\")\n\n    def get_edges(self):\n        \"\"\"\n        Returna all edges in the graph\n        \"\"\"\n        output = []\n        for tail in self.adjacency:\n            for head in self.adjacency[tail]:\n                output.append((tail, head, self.adjacency[head][tail]))\n        return output\n\n    def get_vertices(self):\n        \"\"\"\n        Returns all vertices in the graph\n        \"\"\"\n        return self.adjacency.keys()\n\n    @staticmethod\n    def build(vertices=None, edges=None):\n        \"\"\"\n        Builds a graph from the given set of vertices and edges\n\n        \"\"\"\n        g = Graph()\n        if vertices is None:\n            vertices = []\n        if edges is None:\n            edge = []\n        for vertex in vertices:\n            g.add_vertex(vertex)\n        for edge in edges:\n            g.add_edge(*edge)\n        return g\n\n    class UnionFind:\n        \"\"\"\n        Disjoint set Union and Find for Boruvka's algorithm\n        \"\"\"\n\n        def __init__(self):\n            self.parent = {}\n            self.rank = {}\n\n        def __len__(self):\n            return len(self.parent)\n\n        def make_set(self, item):\n            if item in self.parent:\n                return self.find(item)\n\n            self.parent[item] = item\n            self.rank[item] = 0\n            return item\n\n        def find(self, item):\n            if item not in self.parent:\n                return self.make_set(item)\n            if item != self.parent[item]:\n                self.parent[item] = self.find(self.parent[item])\n            return self.parent[item]\n\n        def union(self, item1, item2):\n            root1 = self.find(item1)\n            root2 = self.find(item2)\n\n            if root1 == root2:\n                return root1\n\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n                return root1\n\n            if self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n                return root2\n\n            if self.rank[root1] == self.rank[root2]:\n                self.rank[root1] += 1\n                self.parent[root2] = root1\n                return root1\n            return None\n\n    @staticmethod\n    def boruvka_mst(graph):\n        \"\"\"\n        Implementation of Boruvka's algorithm\n        >>> g = Graph()\n        >>> g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]])\n        >>> g.distinct_weight()\n        >>> bg = Graph.boruvka_mst(g)\n        >>> print(bg)\n        1 -> 0 == 1\n        2 -> 0 == 2\n        0 -> 1 == 1\n        0 -> 2 == 2\n        3 -> 2 == 3\n        2 -> 3 == 3\n        \"\"\"\n        num_components = graph.num_vertices\n\n        union_find = Graph.UnionFind()\n        mst_edges = []\n        while num_components > 1:\n            cheap_edge = {}\n            for vertex in graph.get_vertices():\n                cheap_edge[vertex] = -1\n\n            edges = graph.get_edges()\n            for edge in edges:\n                head, tail, weight = edge\n                edges.remove((tail, head, weight))\n            for edge in edges:\n                head, tail, weight = edge\n                set1 = union_find.find(head)\n                set2 = union_find.find(tail)\n                if set1 != set2:\n                    if cheap_edge[set1] == -1 or cheap_edge[set1][2] > weight:\n                        cheap_edge[set1] = [head, tail, weight]\n\n                    if cheap_edge[set2] == -1 or cheap_edge[set2][2] > weight:\n                        cheap_edge[set2] = [head, tail, weight]\n            for vertex in cheap_edge:\n                if cheap_edge[vertex] != -1:\n                    head, tail, weight = cheap_edge[vertex]\n                    if union_find.find(head) != union_find.find(tail):\n                        union_find.union(head, tail)\n                        mst_edges.append(cheap_edge[vertex])\n                        num_components = num_components - 1\n        mst = Graph.build(edges=mst_edges)\n        return mst\n", "graphs/random_graph_generator.py": "\"\"\"\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\n* Description: Random graphs generator.\n               Uses graphs represented with an adjacency list.\n\nURL: https://en.wikipedia.org/wiki/Random_graph\n\"\"\"\n\nimport random\n\n\ndef random_graph(\n    vertices_number: int, probability: float, directed: bool = False\n) -> dict:\n    \"\"\"\n    Generate a random graph\n    @input: vertices_number (number of vertices),\n            probability (probability that a generic edge (u,v) exists),\n            directed (if True: graph will be a directed graph,\n                      otherwise it will be an undirected graph)\n    @examples:\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5)\n    {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}\n    >>> random.seed(1)\n    >>> random_graph(4, 0.5, True)\n    {0: [1], 1: [2, 3], 2: [3], 3: []}\n    \"\"\"\n    graph: dict = {i: [] for i in range(vertices_number)}\n\n    # if probability is greater or equal than 1, then generate a complete graph\n    if probability >= 1:\n        return complete_graph(vertices_number)\n    # if probability is lower or equal than 0, then return a graph without edges\n    if probability <= 0:\n        return graph\n\n    # for each couple of nodes, add an edge from u to v\n    # if the number randomly generated is greater than probability probability\n    for i in range(vertices_number):\n        for j in range(i + 1, vertices_number):\n            if random.random() < probability:\n                graph[i].append(j)\n                if not directed:\n                    # if the graph is undirected, add an edge in from j to i, either\n                    graph[j].append(i)\n    return graph\n\n\ndef complete_graph(vertices_number: int) -> dict:\n    \"\"\"\n    Generate a complete graph with vertices_number vertices.\n    @input: vertices_number (number of vertices),\n            directed (False if the graph is undirected, True otherwise)\n    @example:\n    >>> complete_graph(3)\n    {0: [1, 2], 1: [0, 2], 2: [0, 1]}\n    \"\"\"\n    return {\n        i: [j for j in range(vertices_number) if i != j] for i in range(vertices_number)\n    }\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/a_star.py": "from __future__ import annotations\n\nDIRECTIONS = [\n    [-1, 0],  # left\n    [0, -1],  # down\n    [1, 0],  # right\n    [0, 1],  # up\n]\n\n\n# function to search the path\ndef search(\n    grid: list[list[int]],\n    init: list[int],\n    goal: list[int],\n    cost: int,\n    heuristic: list[list[int]],\n) -> tuple[list[list[int]], list[list[int]]]:\n    \"\"\"\n    Search for a path on a grid avoiding obstacles.\n    >>> grid = [[0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 0, 0],\n    ...         [0, 1, 0, 0, 1, 0],\n    ...         [0, 0, 0, 0, 1, 0]]\n    >>> init = [0, 0]\n    >>> goal = [len(grid) - 1, len(grid[0]) - 1]\n    >>> cost = 1\n    >>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))]\n    >>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]\n    >>> for i in range(len(grid)):\n    ...     for j in range(len(grid[0])):\n    ...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])\n    ...         if grid[i][j] == 1:\n    ...             heuristic[i][j] = 99\n    >>> path, action = search(grid, init, goal, cost, heuristic)\n    >>> path  # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3],\n    [2, 3], [2, 4], [2, 5], [3, 5], [4, 5]]\n    >>> action  # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3],\n    [2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]\n    \"\"\"\n    closed = [\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\n    ]  # the reference grid\n    closed[init[0]][init[1]] = 1\n    action = [\n        [0 for col in range(len(grid[0]))] for row in range(len(grid))\n    ]  # the action grid\n\n    x = init[0]\n    y = init[1]\n    g = 0\n    f = g + heuristic[x][y]  # cost from starting cell to destination cell\n    cell = [[f, g, x, y]]\n\n    found = False  # flag that is set when search is complete\n    resign = False  # flag set if we can't find expand\n\n    while not found and not resign:\n        if len(cell) == 0:\n            raise ValueError(\"Algorithm is unable to find solution\")\n        else:  # to choose the least costliest action so as to move closer to the goal\n            cell.sort()\n            cell.reverse()\n            next_cell = cell.pop()\n            x = next_cell[2]\n            y = next_cell[3]\n            g = next_cell[1]\n\n            if x == goal[0] and y == goal[1]:\n                found = True\n            else:\n                for i in range(len(DIRECTIONS)):  # to try out different valid actions\n                    x2 = x + DIRECTIONS[i][0]\n                    y2 = y + DIRECTIONS[i][1]\n                    if (\n                        x2 >= 0\n                        and x2 < len(grid)\n                        and y2 >= 0\n                        and y2 < len(grid[0])\n                        and closed[x2][y2] == 0\n                        and grid[x2][y2] == 0\n                    ):\n                        g2 = g + cost\n                        f2 = g2 + heuristic[x2][y2]\n                        cell.append([f2, g2, x2, y2])\n                        closed[x2][y2] = 1\n                        action[x2][y2] = i\n    invpath = []\n    x = goal[0]\n    y = goal[1]\n    invpath.append([x, y])  # we get the reverse path from here\n    while x != init[0] or y != init[1]:\n        x2 = x - DIRECTIONS[action[x][y]][0]\n        y2 = y - DIRECTIONS[action[x][y]][1]\n        x = x2\n        y = y2\n        invpath.append([x, y])\n\n    path = []\n    for i in range(len(invpath)):\n        path.append(invpath[len(invpath) - 1 - i])\n    return path, action\n\n\nif __name__ == \"__main__\":\n    grid = [\n        [0, 1, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0],  # 0 are free path whereas 1's are obstacles\n        [0, 1, 0, 0, 0, 0],\n        [0, 1, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1, 0],\n    ]\n\n    init = [0, 0]\n    # all coordinates are given in format [y,x]\n    goal = [len(grid) - 1, len(grid[0]) - 1]\n    cost = 1\n\n    # the cost map which pushes the path closer to the goal\n    heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])\n            if grid[i][j] == 1:\n                # added extra penalty in the heuristic map\n                heuristic[i][j] = 99\n\n    path, action = search(grid, init, goal, cost, heuristic)\n\n    print(\"ACTION MAP\")\n    for i in range(len(action)):\n        print(action[i])\n\n    for i in range(len(path)):\n        print(path[i])\n", "graphs/check_bipatrite.py": "from collections import defaultdict, deque\n\n\ndef is_bipartite_dfs(graph: defaultdict[int, list[int]]) -> bool:\n    \"\"\"\n    Check if a graph is bipartite using depth-first search (DFS).\n\n    Args:\n        graph: Adjacency list representing the graph.\n\n    Returns:\n        True if bipartite, False otherwise.\n\n    Checks if the graph can be divided into two sets of vertices, such that no two\n    vertices within the same set are connected by an edge.\n\n    Examples:\n    # FIXME: This test should pass.\n    >>> is_bipartite_dfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 4]}))\n    Traceback (most recent call last):\n        ...\n    RuntimeError: dictionary changed size during iteration\n    >>> is_bipartite_dfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 1]}))\n    False\n    >>> is_bipartite_dfs({})\n    True\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n    >>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\n    False\n    >>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\n    True\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n    >>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 0\n\n    # FIXME: This test should fails with KeyError: 4.\n    >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\n    False\n    >>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: -1\n    >>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\n    True\n    >>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 0\n\n    # FIXME: This test should fails with TypeError: list indices must be integers or...\n    >>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\n    True\n    >>> is_bipartite_dfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 1\n    >>> is_bipartite_dfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 'b'\n    \"\"\"\n\n    def depth_first_search(node: int, color: int) -> bool:\n        \"\"\"\n        Perform Depth-First Search (DFS) on the graph starting from a node.\n\n        Args:\n            node: The current node being visited.\n            color: The color assigned to the current node.\n\n        Returns:\n            True if the graph is bipartite starting from the current node,\n            False otherwise.\n        \"\"\"\n        if visited[node] == -1:\n            visited[node] = color\n            for neighbor in graph[node]:\n                if not depth_first_search(neighbor, 1 - color):\n                    return False\n        return visited[node] == color\n\n    visited: defaultdict[int, int] = defaultdict(lambda: -1)\n    for node in graph:\n        if visited[node] == -1 and not depth_first_search(node, 0):\n            return False\n    return True\n\n\ndef is_bipartite_bfs(graph: defaultdict[int, list[int]]) -> bool:\n    \"\"\"\n    Check if a graph is bipartite using a breadth-first search (BFS).\n\n    Args:\n        graph: Adjacency list representing the graph.\n\n    Returns:\n        True if bipartite, False otherwise.\n\n    Check if the graph can be divided into two sets of vertices, such that no two\n    vertices within the same set are connected by an edge.\n\n    Examples:\n    # FIXME: This test should pass.\n    >>> is_bipartite_bfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 4]}))\n    Traceback (most recent call last):\n        ...\n    RuntimeError: dictionary changed size during iteration\n    >>> is_bipartite_bfs(defaultdict(list, {0: [1, 2], 1: [0, 2], 2: [0, 1]}))\n    False\n    >>> is_bipartite_bfs({})\n    True\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    True\n    >>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})\n    False\n    >>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})\n    True\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    False\n    >>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 0\n\n    # FIXME: This test should fails with KeyError: 4.\n    >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})\n    False\n    >>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: -1\n    >>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})\n    True\n    >>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 0\n\n    # FIXME: This test should fails with TypeError: list indices must be integers or...\n    >>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})\n    True\n    >>> is_bipartite_bfs({\"a\": [1, 3], \"b\": [0, 2], \"c\": [1, 3], \"d\": [0, 2]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 1\n    >>> is_bipartite_bfs({0: [\"b\", \"d\"], 1: [\"a\", \"c\"], 2: [\"b\", \"d\"], 3: [\"a\", \"c\"]})\n    Traceback (most recent call last):\n        ...\n    KeyError: 'b'\n    \"\"\"\n    visited: defaultdict[int, int] = defaultdict(lambda: -1)\n    for node in graph:\n        if visited[node] == -1:\n            queue: deque[int] = deque()\n            queue.append(node)\n            visited[node] = 0\n            while queue:\n                curr_node = queue.popleft()\n                for neighbor in graph[curr_node]:\n                    if visited[neighbor] == -1:\n                        visited[neighbor] = 1 - visited[curr_node]\n                        queue.append(neighbor)\n                    elif visited[neighbor] == visited[curr_node]:\n                        return False\n    return True\n\n\nif __name__ == \"__main\":\n    import doctest\n\n    result = doctest.testmod()\n    if result.failed:\n        print(f\"{result.failed} test(s) failed.\")\n    else:\n        print(\"All tests passed!\")\n", "graphs/page_rank.py": "\"\"\"\nAuthor: https://github.com/bhushan-borole\n\"\"\"\n\n\"\"\"\nThe input graph for the algorithm is:\n\n  A B C\nA 0 1 1\nB 0 0 1\nC 1 0 0\n\n\"\"\"\n\ngraph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.inbound = []\n        self.outbound = []\n\n    def add_inbound(self, node):\n        self.inbound.append(node)\n\n    def add_outbound(self, node):\n        self.outbound.append(node)\n\n    def __repr__(self):\n        return f\"<node={self.name} inbound={self.inbound} outbound={self.outbound}>\"\n\n\ndef page_rank(nodes, limit=3, d=0.85):\n    ranks = {}\n    for node in nodes:\n        ranks[node.name] = 1\n\n    outbounds = {}\n    for node in nodes:\n        outbounds[node.name] = len(node.outbound)\n\n    for i in range(limit):\n        print(f\"======= Iteration {i + 1} =======\")\n        for _, node in enumerate(nodes):\n            ranks[node.name] = (1 - d) + d * sum(\n                ranks[ib] / outbounds[ib] for ib in node.inbound\n            )\n        print(ranks)\n\n\ndef main():\n    names = list(input(\"Enter Names of the Nodes: \").split())\n\n    nodes = [Node(name) for name in names]\n\n    for ri, row in enumerate(graph):\n        for ci, col in enumerate(row):\n            if col == 1:\n                nodes[ci].add_inbound(names[ri])\n                nodes[ri].add_outbound(names[ci])\n\n    print(\"======= Nodes =======\")\n    for node in nodes:\n        print(node)\n\n    page_rank(nodes)\n\n\nif __name__ == \"__main__\":\n    main()\n", "graphs/articulation_points.py": "# Finding Articulation Points in Undirected Graph\ndef compute_ap(graph):\n    n = len(graph)\n    out_edge_count = 0\n    low = [0] * n\n    visited = [False] * n\n    is_art = [False] * n\n\n    def dfs(root, at, parent, out_edge_count):\n        if parent == root:\n            out_edge_count += 1\n        visited[at] = True\n        low[at] = at\n\n        for to in graph[at]:\n            if to == parent:\n                pass\n            elif not visited[to]:\n                out_edge_count = dfs(root, to, at, out_edge_count)\n                low[at] = min(low[at], low[to])\n\n                # AP found via bridge\n                if at < low[to]:\n                    is_art[at] = True\n                # AP found via cycle\n                if at == low[to]:\n                    is_art[at] = True\n            else:\n                low[at] = min(low[at], to)\n        return out_edge_count\n\n    for i in range(n):\n        if not visited[i]:\n            out_edge_count = 0\n            out_edge_count = dfs(i, i, -1, out_edge_count)\n            is_art[i] = out_edge_count > 1\n\n    for x in range(len(is_art)):\n        if is_art[x] is True:\n            print(x)\n\n\n# Adjacency list of graph\ngraph = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3, 5],\n    3: [2, 4],\n    4: [3],\n    5: [2, 6, 8],\n    6: [5, 7],\n    7: [6, 8],\n    8: [5, 7],\n}\ncompute_ap(graph)\n", "graphs/eulerian_path_and_circuit_for_undirected_graph.py": "# Eulerian Path is a path in graph that visits every edge exactly once.\n# Eulerian Circuit is an Eulerian Path which starts and ends on the same\n# vertex.\n# time complexity is O(V+E)\n# space complexity is O(VE)\n\n\n# using dfs for finding eulerian path traversal\ndef dfs(u, graph, visited_edge, path=None):\n    path = (path or []) + [u]\n    for v in graph[u]:\n        if visited_edge[u][v] is False:\n            visited_edge[u][v], visited_edge[v][u] = True, True\n            path = dfs(v, graph, visited_edge, path)\n    return path\n\n\n# for checking in graph has euler path or circuit\ndef check_circuit_or_path(graph, max_node):\n    odd_degree_nodes = 0\n    odd_node = -1\n    for i in range(max_node):\n        if i not in graph:\n            continue\n        if len(graph[i]) % 2 == 1:\n            odd_degree_nodes += 1\n            odd_node = i\n    if odd_degree_nodes == 0:\n        return 1, odd_node\n    if odd_degree_nodes == 2:\n        return 2, odd_node\n    return 3, odd_node\n\n\ndef check_euler(graph, max_node):\n    visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]\n    check, odd_node = check_circuit_or_path(graph, max_node)\n    if check == 3:\n        print(\"graph is not Eulerian\")\n        print(\"no path\")\n        return\n    start_node = 1\n    if check == 2:\n        start_node = odd_node\n        print(\"graph has a Euler path\")\n    if check == 1:\n        print(\"graph has a Euler cycle\")\n    path = dfs(start_node, graph, visited_edge)\n    print(path)\n\n\ndef main():\n    g1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}\n    g2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}\n    g3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}\n    g4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}\n    g5 = {\n        1: [],\n        2: [],\n        # all degree is zero\n    }\n    max_node = 10\n    check_euler(g1, max_node)\n    check_euler(g2, max_node)\n    check_euler(g3, max_node)\n    check_euler(g4, max_node)\n    check_euler(g5, max_node)\n\n\nif __name__ == \"__main__\":\n    main()\n", "graphs/dijkstra_algorithm.py": "# Title: Dijkstra's Algorithm for finding single source shortest path from scratch\n# Author: Shubham Malik\n# References: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n\nimport math\nimport sys\n\n# For storing the vertex set to retrieve node with the lowest distance\n\n\nclass PriorityQueue:\n    # Based on Min Heap\n    def __init__(self):\n        \"\"\"\n        Priority queue class constructor method.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.cur_size\n        0\n        >>> priority_queue_test.array\n        []\n        >>> priority_queue_test.pos\n        {}\n        \"\"\"\n        self.cur_size = 0\n        self.array = []\n        self.pos = {}  # To store the pos of node in array\n\n    def is_empty(self):\n        \"\"\"\n        Conditional boolean method to determine if the priority queue is empty or not.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.is_empty()\n        True\n        >>> priority_queue_test.insert((2, 'A'))\n        >>> priority_queue_test.is_empty()\n        False\n        \"\"\"\n        return self.cur_size == 0\n\n    def min_heapify(self, idx):\n        \"\"\"\n        Sorts the queue array so that the minimum element is root.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.cur_size = 3\n        >>> priority_queue_test.pos = {'A': 0, 'B': 1, 'C': 2}\n\n        >>> priority_queue_test.array = [(5, 'A'), (10, 'B'), (15, 'C')]\n        >>> priority_queue_test.min_heapify(0)\n        Traceback (most recent call last):\n            ...\n        TypeError: 'list' object is not callable\n        >>> priority_queue_test.array\n        [(5, 'A'), (10, 'B'), (15, 'C')]\n\n        >>> priority_queue_test.array = [(10, 'A'), (5, 'B'), (15, 'C')]\n        >>> priority_queue_test.min_heapify(0)\n        Traceback (most recent call last):\n            ...\n        TypeError: 'list' object is not callable\n        >>> priority_queue_test.array\n        [(10, 'A'), (5, 'B'), (15, 'C')]\n\n        >>> priority_queue_test.array = [(10, 'A'), (15, 'B'), (5, 'C')]\n        >>> priority_queue_test.min_heapify(0)\n        Traceback (most recent call last):\n            ...\n        TypeError: 'list' object is not callable\n        >>> priority_queue_test.array\n        [(10, 'A'), (15, 'B'), (5, 'C')]\n\n        >>> priority_queue_test.array = [(10, 'A'), (5, 'B')]\n        >>> priority_queue_test.cur_size = len(priority_queue_test.array)\n        >>> priority_queue_test.pos = {'A': 0, 'B': 1}\n        >>> priority_queue_test.min_heapify(0)\n        Traceback (most recent call last):\n            ...\n        TypeError: 'list' object is not callable\n        >>> priority_queue_test.array\n        [(10, 'A'), (5, 'B')]\n        \"\"\"\n        lc = self.left(idx)\n        rc = self.right(idx)\n        if lc < self.cur_size and self.array(lc)[0] < self.array[idx][0]:\n            smallest = lc\n        else:\n            smallest = idx\n        if rc < self.cur_size and self.array(rc)[0] < self.array[smallest][0]:\n            smallest = rc\n        if smallest != idx:\n            self.swap(idx, smallest)\n            self.min_heapify(smallest)\n\n    def insert(self, tup):\n        \"\"\"\n        Inserts a node into the Priority Queue.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.insert((10, 'A'))\n        >>> priority_queue_test.array\n        [(10, 'A')]\n        >>> priority_queue_test.insert((15, 'B'))\n        >>> priority_queue_test.array\n        [(10, 'A'), (15, 'B')]\n        >>> priority_queue_test.insert((5, 'C'))\n        >>> priority_queue_test.array\n        [(5, 'C'), (10, 'A'), (15, 'B')]\n        \"\"\"\n        self.pos[tup[1]] = self.cur_size\n        self.cur_size += 1\n        self.array.append((sys.maxsize, tup[1]))\n        self.decrease_key((sys.maxsize, tup[1]), tup[0])\n\n    def extract_min(self):\n        \"\"\"\n        Removes and returns the min element at top of priority queue.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]\n        >>> priority_queue_test.cur_size = len(priority_queue_test.array)\n        >>> priority_queue_test.pos = {'A': 0, 'B': 1}\n        >>> priority_queue_test.insert((5, 'C'))\n        >>> priority_queue_test.extract_min()\n        'C'\n        >>> priority_queue_test.array[0]\n        (15, 'B')\n        \"\"\"\n        min_node = self.array[0][1]\n        self.array[0] = self.array[self.cur_size - 1]\n        self.cur_size -= 1\n        self.min_heapify(1)\n        del self.pos[min_node]\n        return min_node\n\n    def left(self, i):\n        \"\"\"\n        Returns the index of left child\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.left(0)\n        1\n        >>> priority_queue_test.left(1)\n        3\n        \"\"\"\n        return 2 * i + 1\n\n    def right(self, i):\n        \"\"\"\n        Returns the index of right child\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.right(0)\n        2\n        >>> priority_queue_test.right(1)\n        4\n        \"\"\"\n        return 2 * i + 2\n\n    def par(self, i):\n        \"\"\"\n        Returns the index of parent\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.par(1)\n        0\n        >>> priority_queue_test.par(2)\n        1\n        >>> priority_queue_test.par(4)\n        2\n        \"\"\"\n        return math.floor(i / 2)\n\n    def swap(self, i, j):\n        \"\"\"\n        Swaps array elements at indices i and j, update the pos{}\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]\n        >>> priority_queue_test.cur_size = len(priority_queue_test.array)\n        >>> priority_queue_test.pos = {'A': 0, 'B': 1}\n        >>> priority_queue_test.swap(0, 1)\n        >>> priority_queue_test.array\n        [(15, 'B'), (10, 'A')]\n        >>> priority_queue_test.pos\n        {'A': 1, 'B': 0}\n        \"\"\"\n        self.pos[self.array[i][1]] = j\n        self.pos[self.array[j][1]] = i\n        temp = self.array[i]\n        self.array[i] = self.array[j]\n        self.array[j] = temp\n\n    def decrease_key(self, tup, new_d):\n        \"\"\"\n        Decrease the key value for a given tuple, assuming the new_d is at most old_d.\n\n        Examples:\n        >>> priority_queue_test = PriorityQueue()\n        >>> priority_queue_test.array = [(10, 'A'), (15, 'B')]\n        >>> priority_queue_test.cur_size = len(priority_queue_test.array)\n        >>> priority_queue_test.pos = {'A': 0, 'B': 1}\n        >>> priority_queue_test.decrease_key((10, 'A'), 5)\n        >>> priority_queue_test.array\n        [(5, 'A'), (15, 'B')]\n        \"\"\"\n        idx = self.pos[tup[1]]\n        # assuming the new_d is at most old_d\n        self.array[idx] = (new_d, tup[1])\n        while idx > 0 and self.array[self.par(idx)][0] > self.array[idx][0]:\n            self.swap(idx, self.par(idx))\n            idx = self.par(idx)\n\n\nclass Graph:\n    def __init__(self, num):\n        \"\"\"\n        Graph class constructor\n\n        Examples:\n        >>> graph_test = Graph(1)\n        >>> graph_test.num_nodes\n        1\n        >>> graph_test.dist\n        [0]\n        >>> graph_test.par\n        [-1]\n        >>> graph_test.adjList\n        {}\n        \"\"\"\n        self.adjList = {}  # To store graph: u -> (v,w)\n        self.num_nodes = num  # Number of nodes in graph\n        # To store the distance from source vertex\n        self.dist = [0] * self.num_nodes\n        self.par = [-1] * self.num_nodes  # To store the path\n\n    def add_edge(self, u, v, w):\n        \"\"\"\n        Add edge going from node u to v and v to u with weight w: u (w)-> v, v (w) -> u\n\n        Examples:\n        >>> graph_test = Graph(1)\n        >>> graph_test.add_edge(1, 2, 1)\n        >>> graph_test.add_edge(2, 3, 2)\n        >>> graph_test.adjList\n        {1: [(2, 1)], 2: [(1, 1), (3, 2)], 3: [(2, 2)]}\n        \"\"\"\n        # Check if u already in graph\n        if u in self.adjList:\n            self.adjList[u].append((v, w))\n        else:\n            self.adjList[u] = [(v, w)]\n\n        # Assuming undirected graph\n        if v in self.adjList:\n            self.adjList[v].append((u, w))\n        else:\n            self.adjList[v] = [(u, w)]\n\n    def show_graph(self):\n        \"\"\"\n        Show the graph: u -> v(w)\n\n        Examples:\n        >>> graph_test = Graph(1)\n        >>> graph_test.add_edge(1, 2, 1)\n        >>> graph_test.show_graph()\n        1 -> 2(1)\n        2 -> 1(1)\n        >>> graph_test.add_edge(2, 3, 2)\n        >>> graph_test.show_graph()\n        1 -> 2(1)\n        2 -> 1(1) -> 3(2)\n        3 -> 2(2)\n        \"\"\"\n        for u in self.adjList:\n            print(u, \"->\", \" -> \".join(str(f\"{v}({w})\") for v, w in self.adjList[u]))\n\n    def dijkstra(self, src):\n        \"\"\"\n        Dijkstra algorithm\n\n        Examples:\n        >>> graph_test = Graph(3)\n        >>> graph_test.add_edge(0, 1, 2)\n        >>> graph_test.add_edge(1, 2, 2)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 2\n        Node 2 has distance: 4\n        >>> graph_test.dist\n        [0, 2, 4]\n\n        >>> graph_test = Graph(2)\n        >>> graph_test.add_edge(0, 1, 2)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 2\n        >>> graph_test.dist\n        [0, 2]\n\n        >>> graph_test = Graph(3)\n        >>> graph_test.add_edge(0, 1, 2)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 2\n        Node 2 has distance: 0\n        >>> graph_test.dist\n        [0, 2, 0]\n\n        >>> graph_test = Graph(3)\n        >>> graph_test.add_edge(0, 1, 2)\n        >>> graph_test.add_edge(1, 2, 2)\n        >>> graph_test.add_edge(0, 2, 1)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 2\n        Node 2 has distance: 1\n        >>> graph_test.dist\n        [0, 2, 1]\n\n        >>> graph_test = Graph(4)\n        >>> graph_test.add_edge(0, 1, 4)\n        >>> graph_test.add_edge(1, 2, 2)\n        >>> graph_test.add_edge(2, 3, 1)\n        >>> graph_test.add_edge(0, 2, 3)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 4\n        Node 2 has distance: 3\n        Node 3 has distance: 4\n        >>> graph_test.dist\n        [0, 4, 3, 4]\n\n        >>> graph_test = Graph(4)\n        >>> graph_test.add_edge(0, 1, 4)\n        >>> graph_test.add_edge(1, 2, 2)\n        >>> graph_test.add_edge(2, 3, 1)\n        >>> graph_test.add_edge(0, 2, 7)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 4\n        Node 2 has distance: 6\n        Node 3 has distance: 7\n        >>> graph_test.dist\n        [0, 4, 6, 7]\n        \"\"\"\n        # Flush old junk values in par[]\n        self.par = [-1] * self.num_nodes\n        # src is the source node\n        self.dist[src] = 0\n        q = PriorityQueue()\n        q.insert((0, src))  # (dist from src, node)\n        for u in self.adjList:\n            if u != src:\n                self.dist[u] = sys.maxsize  # Infinity\n                self.par[u] = -1\n\n        while not q.is_empty():\n            u = q.extract_min()  # Returns node with the min dist from source\n            # Update the distance of all the neighbours of u and\n            # if their prev dist was INFINITY then push them in Q\n            for v, w in self.adjList[u]:\n                new_dist = self.dist[u] + w\n                if self.dist[v] > new_dist:\n                    if self.dist[v] == sys.maxsize:\n                        q.insert((new_dist, v))\n                    else:\n                        q.decrease_key((self.dist[v], v), new_dist)\n                    self.dist[v] = new_dist\n                    self.par[v] = u\n\n        # Show the shortest distances from src\n        self.show_distances(src)\n\n    def show_distances(self, src):\n        \"\"\"\n        Show the distances from src to all other nodes in a graph\n\n        Examples:\n        >>> graph_test = Graph(1)\n        >>> graph_test.show_distances(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        \"\"\"\n        print(f\"Distance from node: {src}\")\n        for u in range(self.num_nodes):\n            print(f\"Node {u} has distance: {self.dist[u]}\")\n\n    def show_path(self, src, dest):\n        \"\"\"\n        Shows the shortest path from src to dest.\n        WARNING: Use it *after* calling dijkstra.\n\n        Examples:\n        >>> graph_test = Graph(4)\n        >>> graph_test.add_edge(0, 1, 1)\n        >>> graph_test.add_edge(1, 2, 2)\n        >>> graph_test.add_edge(2, 3, 3)\n        >>> graph_test.dijkstra(0)\n        Distance from node: 0\n        Node 0 has distance: 0\n        Node 1 has distance: 1\n        Node 2 has distance: 3\n        Node 3 has distance: 6\n        >>> graph_test.show_path(0, 3)  # doctest: +NORMALIZE_WHITESPACE\n        ----Path to reach 3 from 0----\n        0 -> 1 -> 2 -> 3\n        Total cost of path:  6\n        \"\"\"\n        path = []\n        cost = 0\n        temp = dest\n        # Backtracking from dest to src\n        while self.par[temp] != -1:\n            path.append(temp)\n            if temp != src:\n                for v, w in self.adjList[temp]:\n                    if v == self.par[temp]:\n                        cost += w\n                        break\n            temp = self.par[temp]\n        path.append(src)\n        path.reverse()\n\n        print(f\"----Path to reach {dest} from {src}----\")\n        for u in path:\n            print(f\"{u}\", end=\" \")\n            if u != dest:\n                print(\"-> \", end=\"\")\n\n        print(\"\\nTotal cost of path: \", cost)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    graph = Graph(9)\n    graph.add_edge(0, 1, 4)\n    graph.add_edge(0, 7, 8)\n    graph.add_edge(1, 2, 8)\n    graph.add_edge(1, 7, 11)\n    graph.add_edge(2, 3, 7)\n    graph.add_edge(2, 8, 2)\n    graph.add_edge(2, 5, 4)\n    graph.add_edge(3, 4, 9)\n    graph.add_edge(3, 5, 14)\n    graph.add_edge(4, 5, 10)\n    graph.add_edge(5, 6, 2)\n    graph.add_edge(6, 7, 1)\n    graph.add_edge(6, 8, 6)\n    graph.add_edge(7, 8, 7)\n    graph.show_graph()\n    graph.dijkstra(0)\n    graph.show_path(0, 4)\n\n# OUTPUT\n# 0 -> 1(4) -> 7(8)\n# 1 -> 0(4) -> 2(8) -> 7(11)\n# 7 -> 0(8) -> 1(11) -> 6(1) -> 8(7)\n# 2 -> 1(8) -> 3(7) -> 8(2) -> 5(4)\n# 3 -> 2(7) -> 4(9) -> 5(14)\n# 8 -> 2(2) -> 6(6) -> 7(7)\n# 5 -> 2(4) -> 3(14) -> 4(10) -> 6(2)\n# 4 -> 3(9) -> 5(10)\n# 6 -> 5(2) -> 7(1) -> 8(6)\n# Distance from node: 0\n# Node 0 has distance: 0\n# Node 1 has distance: 4\n# Node 2 has distance: 12\n# Node 3 has distance: 19\n# Node 4 has distance: 21\n# Node 5 has distance: 11\n# Node 6 has distance: 9\n# Node 7 has distance: 8\n# Node 8 has distance: 14\n# ----Path to reach 4 from 0----\n# 0 -> 7 -> 6 -> 5 -> 4\n# Total cost of path:  21\n", "graphs/karger.py": "\"\"\"\nAn implementation of Karger's Algorithm for partitioning a graph.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\n\n# Adjacency list representation of this graph:\n# https://en.wikipedia.org/wiki/File:Single_run_of_Karger%E2%80%99s_Mincut_algorithm.svg\nTEST_GRAPH = {\n    \"1\": [\"2\", \"3\", \"4\", \"5\"],\n    \"2\": [\"1\", \"3\", \"4\", \"5\"],\n    \"3\": [\"1\", \"2\", \"4\", \"5\", \"10\"],\n    \"4\": [\"1\", \"2\", \"3\", \"5\", \"6\"],\n    \"5\": [\"1\", \"2\", \"3\", \"4\", \"7\"],\n    \"6\": [\"7\", \"8\", \"9\", \"10\", \"4\"],\n    \"7\": [\"6\", \"8\", \"9\", \"10\", \"5\"],\n    \"8\": [\"6\", \"7\", \"9\", \"10\"],\n    \"9\": [\"6\", \"7\", \"8\", \"10\"],\n    \"10\": [\"6\", \"7\", \"8\", \"9\", \"3\"],\n}\n\n\ndef partition_graph(graph: dict[str, list[str]]) -> set[tuple[str, str]]:\n    \"\"\"\n    Partitions a graph using Karger's Algorithm. Implemented from\n    pseudocode found here:\n    https://en.wikipedia.org/wiki/Karger%27s_algorithm.\n    This function involves random choices, meaning it will not give\n    consistent outputs.\n\n    Args:\n        graph: A dictionary containing adacency lists for the graph.\n            Nodes must be strings.\n\n    Returns:\n        The cutset of the cut found by Karger's Algorithm.\n\n    >>> graph = {'0':['1'], '1':['0']}\n    >>> partition_graph(graph)\n    {('0', '1')}\n    \"\"\"\n    # Dict that maps contracted nodes to a list of all the nodes it \"contains.\"\n    contracted_nodes = {node: {node} for node in graph}\n\n    graph_copy = {node: graph[node][:] for node in graph}\n\n    while len(graph_copy) > 2:\n        # Choose a random edge.\n        u = random.choice(list(graph_copy.keys()))\n        v = random.choice(graph_copy[u])\n\n        # Contract edge (u, v) to new node uv\n        uv = u + v\n        uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))\n        uv_neighbors.remove(u)\n        uv_neighbors.remove(v)\n        graph_copy[uv] = uv_neighbors\n        for neighbor in uv_neighbors:\n            graph_copy[neighbor].append(uv)\n\n        contracted_nodes[uv] = set(contracted_nodes[u].union(contracted_nodes[v]))\n\n        # Remove nodes u and v.\n        del graph_copy[u]\n        del graph_copy[v]\n        for neighbor in uv_neighbors:\n            if u in graph_copy[neighbor]:\n                graph_copy[neighbor].remove(u)\n            if v in graph_copy[neighbor]:\n                graph_copy[neighbor].remove(v)\n\n    # Find cutset.\n    groups = [contracted_nodes[node] for node in graph_copy]\n    return {\n        (node, neighbor)\n        for node in groups[0]\n        for neighbor in graph[node]\n        if neighbor in groups[1]\n    }\n\n\nif __name__ == \"__main__\":\n    print(partition_graph(TEST_GRAPH))\n", "graphs/connected_components.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Component_(graph_theory)\n\nFinding connected components in graph\n\n\"\"\"\n\ntest_graph_1 = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5, 6], 5: [4, 6], 6: [4, 5]}\n\ntest_graph_2 = {0: [1, 2, 3], 1: [0, 3], 2: [0], 3: [0, 1], 4: [], 5: []}\n\n\ndef dfs(graph: dict, vert: int, visited: list) -> list:\n    \"\"\"\n    Use depth first search to find all vertices\n    being in the same component as initial vertex\n    >>> dfs(test_graph_1, 0, 5 * [False])\n    [0, 1, 3, 2]\n    >>> dfs(test_graph_2, 0, 6 * [False])\n    [0, 1, 3, 2]\n    \"\"\"\n\n    visited[vert] = True\n    connected_verts = []\n\n    for neighbour in graph[vert]:\n        if not visited[neighbour]:\n            connected_verts += dfs(graph, neighbour, visited)\n\n    return [vert, *connected_verts]\n\n\ndef connected_components(graph: dict) -> list:\n    \"\"\"\n    This function takes graph as a parameter\n    and then returns the list of connected components\n    >>> connected_components(test_graph_1)\n    [[0, 1, 3, 2], [4, 5, 6]]\n    >>> connected_components(test_graph_2)\n    [[0, 1, 3, 2], [4], [5]]\n    \"\"\"\n\n    graph_size = len(graph)\n    visited = graph_size * [False]\n    components_list = []\n\n    for i in range(graph_size):\n        if not visited[i]:\n            i_connected = dfs(graph, i, visited)\n            components_list.append(i_connected)\n\n    return components_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/kahns_algorithm_topo.py": "def topological_sort(graph):\n    \"\"\"\n    Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph\n    using BFS\n    \"\"\"\n    indegree = [0] * len(graph)\n    queue = []\n    topo = []\n    cnt = 0\n\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n\n    for i in range(len(indegree)):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        vertex = queue.pop(0)\n        cnt += 1\n        topo.append(vertex)\n        for x in graph[vertex]:\n            indegree[x] -= 1\n            if indegree[x] == 0:\n                queue.append(x)\n\n    if cnt != len(graph):\n        print(\"Cycle exists\")\n    else:\n        print(topo)\n\n\n# Adjacency List of Graph\ngraph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}\ntopological_sort(graph)\n", "graphs/graph_list.py": "#!/usr/bin/env python3\n\n# Author: OMKAR PATHAK, Nwachukwu Chidiebere\n\n# Use a Python dictionary to construct the graph.\nfrom __future__ import annotations\n\nfrom pprint import pformat\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass GraphAdjacencyList(Generic[T]):\n    \"\"\"\n    Adjacency List type Graph Data Structure that accounts for directed and undirected\n    Graphs.  Initialize graph object indicating whether it's directed or undirected.\n\n    Directed graph example:\n    >>> d_graph = GraphAdjacencyList()\n    >>> print(d_graph)\n    {}\n    >>> d_graph.add_edge(0, 1)\n    {0: [1], 1: []}\n    >>> d_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5)\n    {0: [1], 1: [2, 4, 5], 2: [], 4: [], 5: []}\n    >>> d_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7)\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\n    >>> d_graph\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\n    >>> print(repr(d_graph))\n    {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}\n\n    Undirected graph example:\n    >>> u_graph = GraphAdjacencyList(directed=False)\n    >>> u_graph.add_edge(0, 1)\n    {0: [1], 1: [0]}\n    >>> u_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5)\n    {0: [1], 1: [0, 2, 4, 5], 2: [1], 4: [1], 5: [1]}\n    >>> u_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7)\n    {0: [1, 2], 1: [0, 2, 4, 5], 2: [1, 0, 6, 7], 4: [1], 5: [1], 6: [2], 7: [2]}\n    >>> u_graph.add_edge(4, 5)\n    {0: [1, 2],\n     1: [0, 2, 4, 5],\n     2: [1, 0, 6, 7],\n     4: [1, 5],\n     5: [1, 4],\n     6: [2],\n     7: [2]}\n    >>> print(u_graph)\n    {0: [1, 2],\n     1: [0, 2, 4, 5],\n     2: [1, 0, 6, 7],\n     4: [1, 5],\n     5: [1, 4],\n     6: [2],\n     7: [2]}\n    >>> print(repr(u_graph))\n    {0: [1, 2],\n     1: [0, 2, 4, 5],\n     2: [1, 0, 6, 7],\n     4: [1, 5],\n     5: [1, 4],\n     6: [2],\n     7: [2]}\n     >>> char_graph = GraphAdjacencyList(directed=False)\n     >>> char_graph.add_edge('a', 'b')\n     {'a': ['b'], 'b': ['a']}\n     >>> char_graph.add_edge('b', 'c').add_edge('b', 'e').add_edge('b', 'f')\n     {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}\n     >>> char_graph\n     {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}\n    \"\"\"\n\n    def __init__(self, directed: bool = True) -> None:\n        \"\"\"\n        Parameters:\n        directed: (bool) Indicates if graph is directed or undirected. Default is True.\n        \"\"\"\n\n        self.adj_list: dict[T, list[T]] = {}  # dictionary of lists\n        self.directed = directed\n\n    def add_edge(\n        self, source_vertex: T, destination_vertex: T\n    ) -> GraphAdjacencyList[T]:\n        \"\"\"\n        Connects vertices together. Creates and Edge from source vertex to destination\n        vertex.\n        Vertices will be created if not found in graph\n        \"\"\"\n\n        if not self.directed:  # For undirected graphs\n            # if both source vertex and destination vertex are both present in the\n            # adjacency list, add destination vertex to source vertex list of adjacent\n            # vertices and add source vertex to destination vertex list of adjacent\n            # vertices.\n            if source_vertex in self.adj_list and destination_vertex in self.adj_list:\n                self.adj_list[source_vertex].append(destination_vertex)\n                self.adj_list[destination_vertex].append(source_vertex)\n            # if only source vertex is present in adjacency list, add destination vertex\n            # to source vertex list of adjacent vertices, then create a new vertex with\n            # destination vertex as key and assign a list containing the source vertex\n            # as it's first adjacent vertex.\n            elif source_vertex in self.adj_list:\n                self.adj_list[source_vertex].append(destination_vertex)\n                self.adj_list[destination_vertex] = [source_vertex]\n            # if only destination vertex is present in adjacency list, add source vertex\n            # to destination vertex list of adjacent vertices, then create a new vertex\n            # with source vertex as key and assign a list containing the source vertex\n            # as it's first adjacent vertex.\n            elif destination_vertex in self.adj_list:\n                self.adj_list[destination_vertex].append(source_vertex)\n                self.adj_list[source_vertex] = [destination_vertex]\n            # if both source vertex and destination vertex are not present in adjacency\n            # list, create a new vertex with source vertex as key and assign a list\n            # containing the destination vertex as it's first adjacent vertex also\n            # create a new vertex with destination vertex as key and assign a list\n            # containing the source vertex as it's first adjacent vertex.\n            else:\n                self.adj_list[source_vertex] = [destination_vertex]\n                self.adj_list[destination_vertex] = [source_vertex]\n        # For directed graphs\n        # if both source vertex and destination vertex are present in adjacency\n        # list, add destination vertex to source vertex list of adjacent vertices.\n        elif source_vertex in self.adj_list and destination_vertex in self.adj_list:\n            self.adj_list[source_vertex].append(destination_vertex)\n        # if only source vertex is present in adjacency list, add destination\n        # vertex to source vertex list of adjacent vertices and create a new vertex\n        # with destination vertex as key, which has no adjacent vertex\n        elif source_vertex in self.adj_list:\n            self.adj_list[source_vertex].append(destination_vertex)\n            self.adj_list[destination_vertex] = []\n        # if only destination vertex is present in adjacency list, create a new\n        # vertex with source vertex as key and assign a list containing destination\n        # vertex as first adjacent vertex\n        elif destination_vertex in self.adj_list:\n            self.adj_list[source_vertex] = [destination_vertex]\n        # if both source vertex and destination vertex are not present in adjacency\n        # list, create a new vertex with source vertex as key and a list containing\n        # destination vertex as it's first adjacent vertex. Then create a new vertex\n        # with destination vertex as key, which has no adjacent vertex\n        else:\n            self.adj_list[source_vertex] = [destination_vertex]\n            self.adj_list[destination_vertex] = []\n\n        return self\n\n    def __repr__(self) -> str:\n        return pformat(self.adj_list)\n", "graphs/kahns_algorithm_long.py": "# Finding longest distance in Directed Acyclic Graph using KahnsAlgorithm\ndef longest_distance(graph):\n    indegree = [0] * len(graph)\n    queue = []\n    long_dist = [1] * len(graph)\n\n    for values in graph.values():\n        for i in values:\n            indegree[i] += 1\n\n    for i in range(len(indegree)):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        vertex = queue.pop(0)\n        for x in graph[vertex]:\n            indegree[x] -= 1\n\n            if long_dist[vertex] + 1 > long_dist[x]:\n                long_dist[x] = long_dist[vertex] + 1\n\n            if indegree[x] == 0:\n                queue.append(x)\n\n    print(max(long_dist))\n\n\n# Adjacency list of Graph\ngraph = {0: [2, 3, 4], 1: [2, 7], 2: [5], 3: [5, 7], 4: [7], 5: [6], 6: [7], 7: []}\nlongest_distance(graph)\n", "graphs/breadth_first_search.py": "#!/usr/bin/python\n\n\"\"\"Author: OMKAR PATHAK\"\"\"\n\nfrom __future__ import annotations\n\nfrom queue import Queue\n\n\nclass Graph:\n    def __init__(self) -> None:\n        self.vertices: dict[int, list[int]] = {}\n\n    def print_graph(self) -> None:\n        \"\"\"\n        prints adjacency list representation of graaph\n        >>> g = Graph()\n        >>> g.print_graph()\n        >>> g.add_edge(0, 1)\n        >>> g.print_graph()\n        0  :  1\n        \"\"\"\n        for i in self.vertices:\n            print(i, \" : \", \" -> \".join([str(j) for j in self.vertices[i]]))\n\n    def add_edge(self, from_vertex: int, to_vertex: int) -> None:\n        \"\"\"\n        adding the edge between two vertices\n        >>> g = Graph()\n        >>> g.print_graph()\n        >>> g.add_edge(0, 1)\n        >>> g.print_graph()\n        0  :  1\n        \"\"\"\n        if from_vertex in self.vertices:\n            self.vertices[from_vertex].append(to_vertex)\n        else:\n            self.vertices[from_vertex] = [to_vertex]\n\n    def bfs(self, start_vertex: int) -> set[int]:\n        \"\"\"\n        >>> g = Graph()\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 1)\n        >>> g.add_edge(0, 2)\n        >>> g.add_edge(1, 2)\n        >>> g.add_edge(2, 0)\n        >>> g.add_edge(2, 3)\n        >>> g.add_edge(3, 3)\n        >>> sorted(g.bfs(2))\n        [0, 1, 2, 3]\n        \"\"\"\n        # initialize set for storing already visited vertices\n        visited = set()\n\n        # create a first in first out queue to store all the vertices for BFS\n        queue: Queue = Queue()\n\n        # mark the source node as visited and enqueue it\n        visited.add(start_vertex)\n        queue.put(start_vertex)\n\n        while not queue.empty():\n            vertex = queue.get()\n\n            # loop through all adjacent vertex and enqueue it if not yet visited\n            for adjacent_vertex in self.vertices[vertex]:\n                if adjacent_vertex not in visited:\n                    queue.put(adjacent_vertex)\n                    visited.add(adjacent_vertex)\n        return visited\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(verbose=True)\n\n    g = Graph()\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(1, 2)\n    g.add_edge(2, 0)\n    g.add_edge(2, 3)\n    g.add_edge(3, 3)\n\n    g.print_graph()\n    # 0  :  1 -> 2\n    # 1  :  2\n    # 2  :  0 -> 3\n    # 3  :  3\n\n    assert sorted(g.bfs(2)) == [0, 1, 2, 3]\n", "graphs/tarjans_scc.py": "from collections import deque\n\n\ndef tarjan(g: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Tarjan's algo for finding strongly connected components in a directed graph\n\n    Uses two main attributes of each node to track reachability, the index of that node\n    within a component(index), and the lowest index reachable from that node(lowlink).\n\n    We then perform a dfs of the each component making sure to update these parameters\n    for each node and saving the nodes we visit on the way.\n\n    If ever we find that the lowest reachable node from a current node is equal to the\n    index of the current node then it must be the root of a strongly connected\n    component and so we save it and it's equireachable vertices as a strongly\n    connected component.\n\n    Complexity: strong_connect() is called at most once for each node and has a\n    complexity of O(|E|) as it is DFS.\n    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)\n\n    >>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]])\n    [[4, 3, 1, 2, 0]]\n    >>> tarjan([[], [], [], []])\n    [[0], [1], [2], [3]]\n    >>> a = [0, 1, 2, 3, 4, 5, 4]\n    >>> b = [1, 0, 3, 2, 5, 4, 0]\n    >>> n = 7\n    >>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted(\n    ...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1])))))\n    True\n    >>> a = [0, 1, 2, 3, 4, 5, 6]\n    >>> b = [0, 1, 2, 3, 4, 5, 6]\n    >>> sorted(tarjan(create_graph(n, list(zip(a, b)))))\n    [[0], [1], [2], [3], [4], [5], [6]]\n    \"\"\"\n\n    n = len(g)\n    stack: deque[int] = deque()\n    on_stack = [False for _ in range(n)]\n    index_of = [-1 for _ in range(n)]\n    lowlink_of = index_of[:]\n\n    def strong_connect(v: int, index: int, components: list[list[int]]) -> int:\n        index_of[v] = index  # the number when this node is seen\n        lowlink_of[v] = index  # lowest rank node reachable from here\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n\n        for w in g[v]:\n            if index_of[w] == -1:\n                index = strong_connect(w, index, components)\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n            elif on_stack[w]:\n                lowlink_of[v] = (\n                    lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]\n                )\n\n        if lowlink_of[v] == index_of[v]:\n            component = []\n            w = stack.pop()\n            on_stack[w] = False\n            component.append(w)\n            while w != v:\n                w = stack.pop()\n                on_stack[w] = False\n                component.append(w)\n            components.append(component)\n        return index\n\n    components: list[list[int]] = []\n    for v in range(n):\n        if index_of[v] == -1:\n            strong_connect(v, 0, components)\n\n    return components\n\n\ndef create_graph(n: int, edges: list[tuple[int, int]]) -> list[list[int]]:\n    \"\"\"\n    >>> n = 7\n    >>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6]\n    >>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5]\n    >>> edges = list(zip(source, target))\n    >>> create_graph(n, edges)\n    [[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]\n    \"\"\"\n    g: list[list[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        g[u].append(v)\n    return g\n\n\nif __name__ == \"__main__\":\n    # Test\n    n_vertices = 7\n    source = [0, 0, 1, 2, 3, 3, 4, 4, 6]\n    target = [1, 3, 2, 0, 1, 4, 5, 6, 5]\n    edges = list(zip(source, target))\n    g = create_graph(n_vertices, edges)\n\n    assert [[5], [6], [4], [3, 2, 1, 0]] == tarjan(g)\n", "graphs/minimum_spanning_tree_kruskal.py": "def kruskal(\n    num_nodes: int, edges: list[tuple[int, int, int]]\n) -> list[tuple[int, int, int]]:\n    \"\"\"\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])\n    [(2, 3, 1), (0, 1, 3), (1, 2, 5)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])\n    [(2, 3, 1), (0, 2, 1), (0, 1, 3)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),\n    ... (2, 1, 1)])\n    [(2, 3, 1), (0, 2, 1), (2, 1, 1)]\n    \"\"\"\n    edges = sorted(edges, key=lambda edge: edge[2])\n\n    parent = list(range(num_nodes))\n\n    def find_parent(i):\n        if i != parent[i]:\n            parent[i] = find_parent(parent[i])\n        return parent[i]\n\n    minimum_spanning_tree_cost = 0\n    minimum_spanning_tree = []\n\n    for edge in edges:\n        parent_a = find_parent(edge[0])\n        parent_b = find_parent(edge[1])\n        if parent_a != parent_b:\n            minimum_spanning_tree_cost += edge[2]\n            minimum_spanning_tree.append(edge)\n            parent[parent_a] = parent_b\n\n    return minimum_spanning_tree\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    num_nodes, num_edges = list(map(int, input().strip().split()))\n    edges = []\n\n    for _ in range(num_edges):\n        node1, node2, cost = (int(x) for x in input().strip().split())\n        edges.append((node1, node2, cost))\n\n    kruskal(num_nodes, edges)\n", "graphs/dijkstra_binary_grid.py": "\"\"\"\nThis script implements the Dijkstra algorithm on a binary grid.\nThe grid consists of 0s and 1s, where 1 represents\na walkable node and 0 represents an obstacle.\nThe algorithm finds the shortest path from a start node to a destination node.\nDiagonal movement can be allowed or disallowed.\n\"\"\"\n\nfrom heapq import heappop, heappush\n\nimport numpy as np\n\n\ndef dijkstra(\n    grid: np.ndarray,\n    source: tuple[int, int],\n    destination: tuple[int, int],\n    allow_diagonal: bool,\n) -> tuple[float | int, list[tuple[int, int]]]:\n    \"\"\"\n    Implements Dijkstra's algorithm on a binary grid.\n\n    Args:\n        grid (np.ndarray): A 2D numpy array representing the grid.\n        1 represents a walkable node and 0 represents an obstacle.\n        source (Tuple[int, int]): A tuple representing the start node.\n        destination (Tuple[int, int]): A tuple representing the\n        destination node.\n        allow_diagonal (bool): A boolean determining whether\n        diagonal movements are allowed.\n\n    Returns:\n        Tuple[Union[float, int], List[Tuple[int, int]]]:\n        The shortest distance from the start node to the destination node\n        and the shortest path as a list of nodes.\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False)\n    (4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True)\n    (2.0, [(0, 0), (1, 1), (2, 2)])\n\n    >>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False)\n    (4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])\n    \"\"\"\n    rows, cols = grid.shape\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    if allow_diagonal:\n        dx += [-1, -1, 1, 1]\n        dy += [-1, 1, -1, 1]\n\n    queue, visited = [(0, source)], set()\n    matrix = np.full((rows, cols), np.inf)\n    matrix[source] = 0\n    predecessors = np.empty((rows, cols), dtype=object)\n    predecessors[source] = None\n\n    while queue:\n        (dist, (x, y)) = heappop(queue)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n\n        if (x, y) == destination:\n            path = []\n            while (x, y) != source:\n                path.append((x, y))\n                x, y = predecessors[x, y]\n            path.append(source)  # add the source manually\n            path.reverse()\n            return matrix[destination], path\n\n        for i in range(len(dx)):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < rows and 0 <= ny < cols:\n                next_node = grid[nx][ny]\n                if next_node == 1 and matrix[nx, ny] > dist + 1:\n                    heappush(queue, (dist + 1, (nx, ny)))\n                    matrix[nx, ny] = dist + 1\n                    predecessors[nx, ny] = (x, y)\n\n    return np.inf, []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/greedy_best_first.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Best-first_search#Greedy_BFS\n\"\"\"\n\nfrom __future__ import annotations\n\nPath = list[tuple[int, int]]\n\n# 0's are free path whereas 1's are obstacles\nTEST_GRIDS = [\n    [\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0],\n        [1, 0, 1, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0],\n    ],\n    [\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0],\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0],\n    ],\n]\n\ndelta = ([-1, 0], [0, -1], [1, 0], [0, 1])  # up, left, down, right\n\n\nclass Node:\n    \"\"\"\n    >>> k = Node(0, 0, 4, 5, 0, None)\n    >>> k.calculate_heuristic()\n    9\n    >>> n = Node(1, 4, 3, 4, 2, None)\n    >>> n.calculate_heuristic()\n    2\n    >>> l = [k, n]\n    >>> n == l[0]\n    False\n    >>> l.sort()\n    >>> n == l[0]\n    True\n    \"\"\"\n\n    def __init__(\n        self,\n        pos_x: int,\n        pos_y: int,\n        goal_x: int,\n        goal_y: int,\n        g_cost: float,\n        parent: Node | None,\n    ):\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n        self.pos = (pos_y, pos_x)\n        self.goal_x = goal_x\n        self.goal_y = goal_y\n        self.g_cost = g_cost\n        self.parent = parent\n        self.f_cost = self.calculate_heuristic()\n\n    def calculate_heuristic(self) -> float:\n        \"\"\"\n        The heuristic here is the Manhattan Distance\n        Could elaborate to offer more than one choice\n        \"\"\"\n        dx = abs(self.pos_x - self.goal_x)\n        dy = abs(self.pos_y - self.goal_y)\n        return dx + dy\n\n    def __lt__(self, other) -> bool:\n        return self.f_cost < other.f_cost\n\n    def __eq__(self, other) -> bool:\n        return self.pos == other.pos\n\n\nclass GreedyBestFirst:\n    \"\"\"\n    >>> grid = TEST_GRIDS[2]\n    >>> gbf = GreedyBestFirst(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    >>> [x.pos for x in gbf.get_successors(gbf.start)]\n    [(1, 0), (0, 1)]\n    >>> (gbf.start.pos_y + delta[3][0], gbf.start.pos_x + delta[3][1])\n    (0, 1)\n    >>> (gbf.start.pos_y + delta[2][0], gbf.start.pos_x + delta[2][1])\n    (1, 0)\n    >>> gbf.retrace_path(gbf.start)\n    [(0, 0)]\n    >>> gbf.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3),\n     (4, 4)]\n    \"\"\"\n\n    def __init__(\n        self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]\n    ):\n        self.grid = grid\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\n\n        self.open_nodes = [self.start]\n        self.closed_nodes: list[Node] = []\n\n        self.reached = False\n\n    def search(self) -> Path | None:\n        \"\"\"\n        Search for the path,\n        if a path is not found, only the starting position is returned\n        \"\"\"\n        while self.open_nodes:\n            # Open Nodes are sorted using __lt__\n            self.open_nodes.sort()\n            current_node = self.open_nodes.pop(0)\n\n            if current_node.pos == self.target.pos:\n                self.reached = True\n                return self.retrace_path(current_node)\n\n            self.closed_nodes.append(current_node)\n            successors = self.get_successors(current_node)\n\n            for child_node in successors:\n                if child_node in self.closed_nodes:\n                    continue\n\n                if child_node not in self.open_nodes:\n                    self.open_nodes.append(child_node)\n\n        if not self.reached:\n            return [self.start.pos]\n        return None\n\n    def get_successors(self, parent: Node) -> list[Node]:\n        \"\"\"\n        Returns a list of successors (both in the grid and free spaces)\n        \"\"\"\n        return [\n            Node(\n                pos_x,\n                pos_y,\n                self.target.pos_x,\n                self.target.pos_y,\n                parent.g_cost + 1,\n                parent,\n            )\n            for action in delta\n            if (\n                0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])\n                and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)\n                and self.grid[pos_y][pos_x] == 0\n            )\n        ]\n\n    def retrace_path(self, node: Node | None) -> Path:\n        \"\"\"\n        Retrace the path from parents to parents until start node\n        \"\"\"\n        current_node = node\n        path = []\n        while current_node is not None:\n            path.append((current_node.pos_y, current_node.pos_x))\n            current_node = current_node.parent\n        path.reverse()\n        return path\n\n\nif __name__ == \"__main__\":\n    for idx, grid in enumerate(TEST_GRIDS):\n        print(f\"==grid-{idx + 1}==\")\n\n        init = (0, 0)\n        goal = (len(grid) - 1, len(grid[0]) - 1)\n        for elem in grid:\n            print(elem)\n\n        print(\"------\")\n\n        greedy_bf = GreedyBestFirst(grid, init, goal)\n        path = greedy_bf.search()\n        if path:\n            for pos_x, pos_y in path:\n                grid[pos_x][pos_y] = 2\n\n            for elem in grid:\n                print(elem)\n", "graphs/__init__.py": "", "graphs/dijkstra.py": "\"\"\"\npseudo-code\n\nDIJKSTRA(graph G, start vertex s, destination vertex d):\n\n//all nodes initially unexplored\n\n1 -  let H = min heap data structure, initialized with 0 and s [here 0 indicates\n     the distance from start vertex s]\n2 -  while H is non-empty:\n3 -    remove the first node and cost of H, call it U and cost\n4 -    if U has been previously explored:\n5 -      go to the while loop, line 2 //Once a node is explored there is no need\n         to make it again\n6 -    mark U as explored\n7 -    if U is d:\n8 -      return cost // total cost from start to destination vertex\n9 -    for each edge(U, V): c=cost of edge(U,V) // for V in graph[U]\n10 -     if V explored:\n11 -       go to next V in line 9\n12 -     total_cost = cost + c\n13 -     add (total_cost,V) to H\n\nYou can think at cost as a distance where Dijkstra finds the shortest distance\nbetween vertices s and v in a graph G. The use of a min heap as H guarantees\nthat if a vertex has already been explored there will be no other path with\nshortest distance, that happens because heapq.heappop will always return the\nnext vertex with the shortest distance, considering that the heap stores not\nonly the distance between previous vertex and current vertex but the entire\ndistance between each vertex that makes up the path from start vertex to target\nvertex.\n\"\"\"\n\nimport heapq\n\n\ndef dijkstra(graph, start, end):\n    \"\"\"Return the cost of the shortest path between vertices start and end.\n\n    >>> dijkstra(G, \"E\", \"C\")\n    6\n    >>> dijkstra(G2, \"E\", \"F\")\n    3\n    >>> dijkstra(G3, \"E\", \"F\")\n    3\n    \"\"\"\n\n    heap = [(0, start)]  # cost from start node,end node\n    visited = set()\n    while heap:\n        (cost, u) = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == end:\n            return cost\n        for v, c in graph[u]:\n            if v in visited:\n                continue\n            next_item = cost + c\n            heapq.heappush(heap, (next_item, v))\n    return -1\n\n\nG = {\n    \"A\": [[\"B\", 2], [\"C\", 5]],\n    \"B\": [[\"A\", 2], [\"D\", 3], [\"E\", 1], [\"F\", 1]],\n    \"C\": [[\"A\", 5], [\"F\", 3]],\n    \"D\": [[\"B\", 3]],\n    \"E\": [[\"B\", 4], [\"F\", 3]],\n    \"F\": [[\"C\", 3], [\"E\", 3]],\n}\n\nr\"\"\"\nLayout of G2:\n\nE -- 1 --> B -- 1 --> C -- 1 --> D -- 1 --> F\n \\                                         /\\\n  \\                                        ||\n    ----------------- 3 --------------------\n\"\"\"\nG2 = {\n    \"B\": [[\"C\", 1]],\n    \"C\": [[\"D\", 1]],\n    \"D\": [[\"F\", 1]],\n    \"E\": [[\"B\", 1], [\"F\", 3]],\n    \"F\": [],\n}\n\nr\"\"\"\nLayout of G3:\n\nE -- 1 --> B -- 1 --> C -- 1 --> D -- 1 --> F\n \\                                         /\\\n  \\                                        ||\n    -------- 2 ---------> G ------- 1 ------\n\"\"\"\nG3 = {\n    \"B\": [[\"C\", 1]],\n    \"C\": [[\"D\", 1]],\n    \"D\": [[\"F\", 1]],\n    \"E\": [[\"B\", 1], [\"G\", 2]],\n    \"F\": [],\n    \"G\": [[\"F\", 1]],\n}\n\nshort_distance = dijkstra(G, \"E\", \"C\")\nprint(short_distance)  # E -- 3 --> F -- 3 --> C == 6\n\nshort_distance = dijkstra(G2, \"E\", \"F\")\nprint(short_distance)  # E -- 3 --> F == 3\n\nshort_distance = dijkstra(G3, \"E\", \"F\")\nprint(short_distance)  # E -- 2 --> G -- 1 --> F == 3\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "graphs/minimum_spanning_tree_kruskal2.py": "from __future__ import annotations\n\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass DisjointSetTreeNode(Generic[T]):\n    # Disjoint Set Node to store the parent and rank\n    def __init__(self, data: T) -> None:\n        self.data = data\n        self.parent = self\n        self.rank = 0\n\n\nclass DisjointSetTree(Generic[T]):\n    # Disjoint Set DataStructure\n    def __init__(self) -> None:\n        # map from node name to the node object\n        self.map: dict[T, DisjointSetTreeNode[T]] = {}\n\n    def make_set(self, data: T) -> None:\n        # create a new set with x as its member\n        self.map[data] = DisjointSetTreeNode(data)\n\n    def find_set(self, data: T) -> DisjointSetTreeNode[T]:\n        # find the set x belongs to (with path-compression)\n        elem_ref = self.map[data]\n        if elem_ref != elem_ref.parent:\n            elem_ref.parent = self.find_set(elem_ref.parent.data)\n        return elem_ref.parent\n\n    def link(\n        self, node1: DisjointSetTreeNode[T], node2: DisjointSetTreeNode[T]\n    ) -> None:\n        # helper function for union operation\n        if node1.rank > node2.rank:\n            node2.parent = node1\n        else:\n            node1.parent = node2\n            if node1.rank == node2.rank:\n                node2.rank += 1\n\n    def union(self, data1: T, data2: T) -> None:\n        # merge 2 disjoint sets\n        self.link(self.find_set(data1), self.find_set(data2))\n\n\nclass GraphUndirectedWeighted(Generic[T]):\n    def __init__(self) -> None:\n        # connections: map from the node to the neighbouring nodes (with weights)\n        self.connections: dict[T, dict[T, int]] = {}\n\n    def add_node(self, node: T) -> None:\n        # add a node ONLY if its not present in the graph\n        if node not in self.connections:\n            self.connections[node] = {}\n\n    def add_edge(self, node1: T, node2: T, weight: int) -> None:\n        # add an edge with the given weight\n        self.add_node(node1)\n        self.add_node(node2)\n        self.connections[node1][node2] = weight\n        self.connections[node2][node1] = weight\n\n    def kruskal(self) -> GraphUndirectedWeighted[T]:\n        # Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\n        \"\"\"\n        Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n\n        Example:\n        >>> g1 = GraphUndirectedWeighted[int]()\n        >>> g1.add_edge(1, 2, 1)\n        >>> g1.add_edge(2, 3, 2)\n        >>> g1.add_edge(3, 4, 1)\n        >>> g1.add_edge(3, 5, 100) # Removed in MST\n        >>> g1.add_edge(4, 5, 5)\n        >>> assert 5 in g1.connections[3]\n        >>> mst = g1.kruskal()\n        >>> assert 5 not in mst.connections[3]\n\n        >>> g2 = GraphUndirectedWeighted[str]()\n        >>> g2.add_edge('A', 'B', 1)\n        >>> g2.add_edge('B', 'C', 2)\n        >>> g2.add_edge('C', 'D', 1)\n        >>> g2.add_edge('C', 'E', 100) # Removed in MST\n        >>> g2.add_edge('D', 'E', 5)\n        >>> assert 'E' in g2.connections[\"C\"]\n        >>> mst = g2.kruskal()\n        >>> assert 'E' not in mst.connections['C']\n        \"\"\"\n\n        # getting the edges in ascending order of weights\n        edges = []\n        seen = set()\n        for start in self.connections:\n            for end in self.connections[start]:\n                if (start, end) not in seen:\n                    seen.add((end, start))\n                    edges.append((start, end, self.connections[start][end]))\n        edges.sort(key=lambda x: x[2])\n\n        # creating the disjoint set\n        disjoint_set = DisjointSetTree[T]()\n        for node in self.connections:\n            disjoint_set.make_set(node)\n\n        # MST generation\n        num_edges = 0\n        index = 0\n        graph = GraphUndirectedWeighted[T]()\n        while num_edges < len(self.connections) - 1:\n            u, v, w = edges[index]\n            index += 1\n            parent_u = disjoint_set.find_set(u)\n            parent_v = disjoint_set.find_set(v)\n            if parent_u != parent_v:\n                num_edges += 1\n                graph.add_edge(u, v, w)\n                disjoint_set.union(u, v)\n        return graph\n", "graphs/ant_colony_optimization_algorithms.py": "\"\"\"\nUse an ant colony optimization algorithm to solve the travelling salesman problem (TSP)\nwhich asks the following question:\n\"Given a list of cities and the distances between each pair of cities, what is the\n shortest possible route that visits each city exactly once and returns to the origin\n city?\"\n\nhttps://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms\nhttps://en.wikipedia.org/wiki/Travelling_salesman_problem\n\nAuthor: Clark\n\"\"\"\n\nimport copy\nimport random\n\ncities = {\n    0: [0, 0],\n    1: [0, 5],\n    2: [3, 8],\n    3: [8, 10],\n    4: [12, 8],\n    5: [12, 4],\n    6: [8, 0],\n    7: [6, 2],\n}\n\n\ndef main(\n    cities: dict[int, list[int]],\n    ants_num: int,\n    iterations_num: int,\n    pheromone_evaporation: float,\n    alpha: float,\n    beta: float,\n    q: float,  # Pheromone system parameters Q, which is a constant\n) -> tuple[list[int], float]:\n    \"\"\"\n    Ant colony algorithm main function\n    >>> main(cities=cities, ants_num=10, iterations_num=20,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    >>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> main(cities={}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    Traceback (most recent call last):\n      ...\n    StopIteration\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([], inf)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0,\n    ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)\n    ([], inf)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,\n    ...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10)\n    ([0, 1, 0], 5.656854249492381)\n    \"\"\"\n    # Initialize the pheromone matrix\n    cities_num = len(cities)\n    pheromone = [[1.0] * cities_num] * cities_num\n\n    best_path: list[int] = []\n    best_distance = float(\"inf\")\n    for _ in range(iterations_num):\n        ants_route = []\n        for _ in range(ants_num):\n            unvisited_cities = copy.deepcopy(cities)\n            current_city = {next(iter(cities.keys())): next(iter(cities.values()))}\n            del unvisited_cities[next(iter(current_city.keys()))]\n            ant_route = [next(iter(current_city.keys()))]\n            while unvisited_cities:\n                current_city, unvisited_cities = city_select(\n                    pheromone, current_city, unvisited_cities, alpha, beta\n                )\n                ant_route.append(next(iter(current_city.keys())))\n            ant_route.append(0)\n            ants_route.append(ant_route)\n\n        pheromone, best_path, best_distance = pheromone_update(\n            pheromone,\n            cities,\n            pheromone_evaporation,\n            ants_route,\n            q,\n            best_path,\n            best_distance,\n        )\n    return best_path, best_distance\n\n\ndef distance(city1: list[int], city2: list[int]) -> float:\n    \"\"\"\n    Calculate the distance between two coordinate points\n    >>> distance([0, 0], [3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, 4] )\n    5.0\n    >>> distance([0, 0], [-3, -4] )\n    5.0\n    \"\"\"\n    return (((city1[0] - city2[0]) ** 2) + ((city1[1] - city2[1]) ** 2)) ** 0.5\n\n\ndef pheromone_update(\n    pheromone: list[list[float]],\n    cities: dict[int, list[int]],\n    pheromone_evaporation: float,\n    ants_route: list[list[int]],\n    q: float,  # Pheromone system parameters Q, which is a constant\n    best_path: list[int],\n    best_distance: float,\n) -> tuple[list[list[float]], list[int], float]:\n    \"\"\"\n    Update pheromones on the route and update the best route\n    >>>\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)\n    >>> pheromone_update(pheromone=[],\n    ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],\n    ...                  cities={}, pheromone_evaporation=0.7,\n    ...                  ants_route=[[0, 1, 0]], q=10, best_path=[],\n    ...                  best_distance=float(\"inf\"))\n    Traceback (most recent call last):\n      ...\n    KeyError: 0\n    \"\"\"\n    for a in range(len(cities)):  # Update the volatilization of pheromone on all routes\n        for b in range(len(cities)):\n            pheromone[a][b] *= pheromone_evaporation\n    for ant_route in ants_route:\n        total_distance = 0.0\n        for i in range(len(ant_route) - 1):  # Calculate total distance\n            total_distance += distance(cities[ant_route[i]], cities[ant_route[i + 1]])\n        delta_pheromone = q / total_distance\n        for i in range(len(ant_route) - 1):  # Update pheromones\n            pheromone[ant_route[i]][ant_route[i + 1]] += delta_pheromone\n            pheromone[ant_route[i + 1]][ant_route[i]] = pheromone[ant_route[i]][\n                ant_route[i + 1]\n            ]\n\n        if total_distance < best_distance:\n            best_path = ant_route\n            best_distance = total_distance\n\n    return pheromone, best_path, best_distance\n\n\ndef city_select(\n    pheromone: list[list[float]],\n    current_city: dict[int, list[int]],\n    unvisited_cities: dict[int, list[int]],\n    alpha: float,\n    beta: float,\n) -> tuple[dict[int, list[int]], dict[int, list[int]]]:\n    \"\"\"\n    Choose the next city for ants\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    ({1: [2, 2]}, {})\n    >>> city_select(pheromone=[], current_city={0: [0,0]},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={},\n    ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    StopIteration\n    >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},\n    ...             unvisited_cities={}, alpha=1.0, beta=5.0)\n    Traceback (most recent call last):\n      ...\n    IndexError: list index out of range\n    \"\"\"\n    probabilities = []\n    for city in unvisited_cities:\n        city_distance = distance(\n            unvisited_cities[city], next(iter(current_city.values()))\n        )\n        probability = (pheromone[city][next(iter(current_city.keys()))] ** alpha) * (\n            (1 / city_distance) ** beta\n        )\n        probabilities.append(probability)\n\n    chosen_city_i = random.choices(\n        list(unvisited_cities.keys()), weights=probabilities\n    )[0]\n    chosen_city = {chosen_city_i: unvisited_cities[chosen_city_i]}\n    del unvisited_cities[next(iter(chosen_city.keys()))]\n    return chosen_city, unvisited_cities\n\n\nif __name__ == \"__main__\":\n    best_path, best_distance = main(\n        cities=cities,\n        ants_num=10,\n        iterations_num=20,\n        pheromone_evaporation=0.7,\n        alpha=1.0,\n        beta=5.0,\n        q=10,\n    )\n\n    print(f\"{best_path = }\")\n    print(f\"{best_distance = }\")\n", "graphs/dijkstra_2.py": "def print_dist(dist, v):\n    print(\"\\nVertex Distance\")\n    for i in range(v):\n        if dist[i] != float(\"inf\"):\n            print(i, \"\\t\", int(dist[i]), end=\"\\t\")\n        else:\n            print(i, \"\\t\", \"INF\", end=\"\\t\")\n        print()\n\n\ndef min_dist(mdist, vset, v):\n    min_val = float(\"inf\")\n    min_ind = -1\n    for i in range(v):\n        if (not vset[i]) and mdist[i] < min_val:\n            min_ind = i\n            min_val = mdist[i]\n    return min_ind\n\n\ndef dijkstra(graph, v, src):\n    mdist = [float(\"inf\") for _ in range(v)]\n    vset = [False for _ in range(v)]\n    mdist[src] = 0.0\n\n    for _ in range(v - 1):\n        u = min_dist(mdist, vset, v)\n        vset[u] = True\n\n        for i in range(v):\n            if (\n                (not vset[i])\n                and graph[u][i] != float(\"inf\")\n                and mdist[u] + graph[u][i] < mdist[i]\n            ):\n                mdist[i] = mdist[u] + graph[u][i]\n\n    print_dist(mdist, i)\n\n\nif __name__ == \"__main__\":\n    V = int(input(\"Enter number of vertices: \").strip())\n    E = int(input(\"Enter number of edges: \").strip())\n\n    graph = [[float(\"inf\") for i in range(V)] for j in range(V)]\n\n    for i in range(V):\n        graph[i][i] = 0.0\n\n    for i in range(E):\n        print(\"\\nEdge \", i + 1)\n        src = int(input(\"Enter source:\").strip())\n        dst = int(input(\"Enter destination:\").strip())\n        weight = float(input(\"Enter weight:\").strip())\n        graph[src][dst] = weight\n\n    gsrc = int(input(\"\\nEnter shortest path source:\").strip())\n    dijkstra(graph, V, gsrc)\n", "graphs/g_topological_sort.py": "# Author: Phyllipe Bezerra (https://github.com/pmba)\n\nclothes = {\n    0: \"underwear\",\n    1: \"pants\",\n    2: \"belt\",\n    3: \"suit\",\n    4: \"shoe\",\n    5: \"socks\",\n    6: \"shirt\",\n    7: \"tie\",\n    8: \"watch\",\n}\n\ngraph = [[1, 4], [2, 4], [3], [], [], [4], [2, 7], [3], []]\n\nvisited = [0 for x in range(len(graph))]\nstack = []\n\n\ndef print_stack(stack, clothes):\n    order = 1\n    while stack:\n        current_clothing = stack.pop()\n        print(order, clothes[current_clothing])\n        order += 1\n\n\ndef depth_first_search(u, visited, graph):\n    visited[u] = 1\n    for v in graph[u]:\n        if not visited[v]:\n            depth_first_search(v, visited, graph)\n\n    stack.append(u)\n\n\ndef topological_sort(graph, visited):\n    for v in range(len(graph)):\n        if not visited[v]:\n            depth_first_search(v, visited, graph)\n\n\nif __name__ == \"__main__\":\n    topological_sort(graph, visited)\n    print(stack)\n    print_stack(stack, clothes)\n", "cellular_automata/game_of_life.py": "\"\"\"Conway's Game Of Life, Author Anurag Kumar(mailto:anuragkumarak95@gmail.com)\n\nRequirements:\n  - numpy\n  - random\n  - time\n  - matplotlib\n\nPython:\n  - 3.5\n\nUsage:\n  - $python3 game_of_life <canvas_size:int>\n\nGame-Of-Life Rules:\n\n 1.\n Any live cell with fewer than two live neighbours\n dies, as if caused by under-population.\n 2.\n Any live cell with two or three live neighbours lives\n on to the next generation.\n 3.\n Any live cell with more than three live neighbours\n dies, as if by over-population.\n 4.\n Any dead cell with exactly three live neighbours be-\n comes a live cell, as if by reproduction.\n\"\"\"\n\nimport random\nimport sys\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nusage_doc = \"Usage of script: script_name <size_of_canvas:int>\"\n\nchoice = [0] * 100 + [1] * 10\nrandom.shuffle(choice)\n\n\ndef create_canvas(size: int) -> list[list[bool]]:\n    canvas = [[False for i in range(size)] for j in range(size)]\n    return canvas\n\n\ndef seed(canvas: list[list[bool]]) -> None:\n    for i, row in enumerate(canvas):\n        for j, _ in enumerate(row):\n            canvas[i][j] = bool(random.getrandbits(1))\n\n\ndef run(canvas: list[list[bool]]) -> list[list[bool]]:\n    \"\"\"\n    This function runs the rules of game through all points, and changes their\n    status accordingly.(in the same canvas)\n    @Args:\n    --\n    canvas : canvas of population to run the rules on.\n\n    @returns:\n    --\n    canvas of population after one step\n    \"\"\"\n    current_canvas = np.array(canvas)\n    next_gen_canvas = np.array(create_canvas(current_canvas.shape[0]))\n    for r, row in enumerate(current_canvas):\n        for c, pt in enumerate(row):\n            next_gen_canvas[r][c] = __judge_point(\n                pt, current_canvas[r - 1 : r + 2, c - 1 : c + 2]\n            )\n\n    return next_gen_canvas.tolist()\n\n\ndef __judge_point(pt: bool, neighbours: list[list[bool]]) -> bool:\n    dead = 0\n    alive = 0\n    # finding dead or alive neighbours count.\n    for i in neighbours:\n        for status in i:\n            if status:\n                alive += 1\n            else:\n                dead += 1\n\n    # handling duplicate entry for focus pt.\n    if pt:\n        alive -= 1\n    else:\n        dead -= 1\n\n    # running the rules of game here.\n    state = pt\n    if pt:\n        if alive < 2:\n            state = False\n        elif alive in {2, 3}:\n            state = True\n        elif alive > 3:\n            state = False\n    elif alive == 3:\n        state = True\n\n    return state\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        raise Exception(usage_doc)\n\n    canvas_size = int(sys.argv[1])\n    # main working structure of this module.\n    c = create_canvas(canvas_size)\n    seed(c)\n    fig, ax = plt.subplots()\n    fig.show()\n    cmap = ListedColormap([\"w\", \"k\"])\n    try:\n        while True:\n            c = run(c)\n            ax.matshow(c, cmap=cmap)\n            fig.canvas.draw()\n            ax.cla()\n    except KeyboardInterrupt:\n        # do nothing.\n        pass\n", "cellular_automata/wa_tor.py": "\"\"\"\nWa-Tor algorithm (1984)\n\n@ https://en.wikipedia.org/wiki/Wa-Tor\n@ https://beltoforion.de/en/wator/\n@ https://beltoforion.de/en/wator/images/wator_medium.webm\n\nThis solution aims to completely remove any systematic approach\nto the Wa-Tor planet, and utilise fully random methods.\n\nThe constants are a working set that allows the Wa-Tor planet\nto result in one of the three possible results.\n\"\"\"\n\nfrom collections.abc import Callable\nfrom random import randint, shuffle\nfrom time import sleep\nfrom typing import Literal\n\nWIDTH = 50  # Width of the Wa-Tor planet\nHEIGHT = 50  # Height of the Wa-Tor planet\n\nPREY_INITIAL_COUNT = 30  # The initial number of prey entities\nPREY_REPRODUCTION_TIME = 5  # The chronons before reproducing\n\nPREDATOR_INITIAL_COUNT = 50  # The initial number of predator entities\n# The initial energy value of predator entities\nPREDATOR_INITIAL_ENERGY_VALUE = 15\n# The energy value provided when consuming prey\nPREDATOR_FOOD_VALUE = 5\nPREDATOR_REPRODUCTION_TIME = 20  # The chronons before reproducing\n\nMAX_ENTITIES = 500  # The max number of organisms on the board\n# The number of entities to delete from the unbalanced side\nDELETE_UNBALANCED_ENTITIES = 50\n\n\nclass Entity:\n    \"\"\"\n    Represents an entity (either prey or predator).\n\n    >>> e = Entity(True, coords=(0, 0))\n    >>> e.prey\n    True\n    >>> e.coords\n    (0, 0)\n    >>> e.alive\n    True\n    \"\"\"\n\n    def __init__(self, prey: bool, coords: tuple[int, int]) -> None:\n        self.prey = prey\n        # The (row, col) pos of the entity\n        self.coords = coords\n\n        self.remaining_reproduction_time = (\n            PREY_REPRODUCTION_TIME if prey else PREDATOR_REPRODUCTION_TIME\n        )\n        self.energy_value = None if prey is True else PREDATOR_INITIAL_ENERGY_VALUE\n        self.alive = True\n\n    def reset_reproduction_time(self) -> None:\n        \"\"\"\n        >>> e = Entity(True, coords=(0, 0))\n        >>> e.reset_reproduction_time()\n        >>> e.remaining_reproduction_time == PREY_REPRODUCTION_TIME\n        True\n        >>> e = Entity(False, coords=(0, 0))\n        >>> e.reset_reproduction_time()\n        >>> e.remaining_reproduction_time == PREDATOR_REPRODUCTION_TIME\n        True\n        \"\"\"\n        self.remaining_reproduction_time = (\n            PREY_REPRODUCTION_TIME if self.prey is True else PREDATOR_REPRODUCTION_TIME\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"\n        >>> Entity(prey=True, coords=(1, 1))\n        Entity(prey=True, coords=(1, 1), remaining_reproduction_time=5)\n        >>> Entity(prey=False, coords=(2, 1))  # doctest: +NORMALIZE_WHITESPACE\n        Entity(prey=False, coords=(2, 1),\n        remaining_reproduction_time=20, energy_value=15)\n        \"\"\"\n        repr_ = (\n            f\"Entity(prey={self.prey}, coords={self.coords}, \"\n            f\"remaining_reproduction_time={self.remaining_reproduction_time}\"\n        )\n        if self.energy_value is not None:\n            repr_ += f\", energy_value={self.energy_value}\"\n        return f\"{repr_})\"\n\n\nclass WaTor:\n    \"\"\"\n    Represents the main Wa-Tor algorithm.\n\n    :attr time_passed: A function that is called every time\n        time passes (a chronon) in order to visually display\n        the new Wa-Tor planet. The time_passed function can block\n        using time.sleep to slow the algorithm progression.\n\n    >>> wt = WaTor(10, 15)\n    >>> wt.width\n    10\n    >>> wt.height\n    15\n    >>> len(wt.planet)\n    15\n    >>> len(wt.planet[0])\n    10\n    >>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT\n    True\n    \"\"\"\n\n    time_passed: Callable[[\"WaTor\", int], None] | None\n\n    def __init__(self, width: int, height: int) -> None:\n        self.width = width\n        self.height = height\n        self.time_passed = None\n\n        self.planet: list[list[Entity | None]] = [[None] * width for _ in range(height)]\n\n        # Populate planet with predators and prey randomly\n        for _ in range(PREY_INITIAL_COUNT):\n            self.add_entity(prey=True)\n        for _ in range(PREDATOR_INITIAL_COUNT):\n            self.add_entity(prey=False)\n        self.set_planet(self.planet)\n\n    def set_planet(self, planet: list[list[Entity | None]]) -> None:\n        \"\"\"\n        Ease of access for testing\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> planet = [\n        ... [None, None, None],\n        ... [None, Entity(True, coords=(1, 1)), None]\n        ... ]\n        >>> wt.set_planet(planet)\n        >>> wt.planet == planet\n        True\n        >>> wt.width\n        3\n        >>> wt.height\n        2\n        \"\"\"\n        self.planet = planet\n        self.width = len(planet[0])\n        self.height = len(planet)\n\n    def add_entity(self, prey: bool) -> None:\n        \"\"\"\n        Adds an entity, making sure the entity does\n        not override another entity\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> wt.set_planet([[None, None], [None, None]])\n        >>> wt.add_entity(True)\n        >>> len(wt.get_entities())\n        1\n        >>> wt.add_entity(False)\n        >>> len(wt.get_entities())\n        2\n        \"\"\"\n        while True:\n            row, col = randint(0, self.height - 1), randint(0, self.width - 1)\n            if self.planet[row][col] is None:\n                self.planet[row][col] = Entity(prey=prey, coords=(row, col))\n                return\n\n    def get_entities(self) -> list[Entity]:\n        \"\"\"\n        Returns a list of all the entities within the planet.\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT\n        True\n        \"\"\"\n        return [entity for column in self.planet for entity in column if entity]\n\n    def balance_predators_and_prey(self) -> None:\n        \"\"\"\n        Balances predators and preys so that prey\n        can not dominate the predators, blocking up\n        space for them to reproduce.\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> for i in range(2000):\n        ...     row, col = i // HEIGHT, i % WIDTH\n        ...     wt.planet[row][col] = Entity(True, coords=(row, col))\n        >>> entities = len(wt.get_entities())\n        >>> wt.balance_predators_and_prey()\n        >>> len(wt.get_entities()) == entities\n        False\n        \"\"\"\n        entities = self.get_entities()\n        shuffle(entities)\n\n        if len(entities) >= MAX_ENTITIES - MAX_ENTITIES / 10:\n            prey = [entity for entity in entities if entity.prey]\n            predators = [entity for entity in entities if not entity.prey]\n\n            prey_count, predator_count = len(prey), len(predators)\n\n            entities_to_purge = (\n                prey[:DELETE_UNBALANCED_ENTITIES]\n                if prey_count > predator_count\n                else predators[:DELETE_UNBALANCED_ENTITIES]\n            )\n            for entity in entities_to_purge:\n                self.planet[entity.coords[0]][entity.coords[1]] = None\n\n    def get_surrounding_prey(self, entity: Entity) -> list[Entity]:\n        \"\"\"\n        Returns all the prey entities around (N, S, E, W) a predator entity.\n\n        Subtly different to the try_to_move_to_unoccupied square.\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> wt.set_planet([\n        ... [None, Entity(True, (0, 1)), None],\n        ... [None, Entity(False, (1, 1)), None],\n        ... [None, Entity(True, (2, 1)), None]])\n        >>> wt.get_surrounding_prey(\n        ... Entity(False, (1, 1)))  # doctest: +NORMALIZE_WHITESPACE\n        [Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5),\n        Entity(prey=True, coords=(2, 1), remaining_reproduction_time=5)]\n        >>> wt.set_planet([[Entity(False, (0, 0))]])\n        >>> wt.get_surrounding_prey(Entity(False, (0, 0)))\n        []\n        >>> wt.set_planet([\n        ... [Entity(True, (0, 0)), Entity(False, (1, 0)), Entity(False, (2, 0))],\n        ... [None, Entity(False, (1, 1)), Entity(True, (2, 1))],\n        ... [None, None, None]])\n        >>> wt.get_surrounding_prey(Entity(False, (1, 0)))\n        [Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5)]\n        \"\"\"\n        row, col = entity.coords\n        adjacent: list[tuple[int, int]] = [\n            (row - 1, col),  # North\n            (row + 1, col),  # South\n            (row, col - 1),  # West\n            (row, col + 1),  # East\n        ]\n\n        return [\n            ent\n            for r, c in adjacent\n            if 0 <= r < self.height\n            and 0 <= c < self.width\n            and (ent := self.planet[r][c]) is not None\n            and ent.prey\n        ]\n\n    def move_and_reproduce(\n        self, entity: Entity, direction_orders: list[Literal[\"N\", \"E\", \"S\", \"W\"]]\n    ) -> None:\n        \"\"\"\n        Attempts to move to an unoccupied neighbouring square\n        in either of the four directions (North, South, East, West).\n        If the move was successful and the remaining_reproduction time is\n        equal to 0, then a new prey or predator can also be created\n        in the previous square.\n\n        :param direction_orders: Ordered list (like priority queue) depicting\n                            order to attempt to move. Removes any systematic\n                            approach of checking neighbouring squares.\n\n        >>> planet = [\n        ... [None, None, None],\n        ... [None, Entity(True, coords=(1, 1)), None],\n        ... [None, None, None]\n        ... ]\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> wt.set_planet(planet)\n        >>> wt.move_and_reproduce(Entity(True, coords=(1, 1)), direction_orders=[\"N\"])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[None, Entity(prey=True, coords=(0, 1), remaining_reproduction_time=4), None],\n        [None, None, None],\n        [None, None, None]]\n        >>> wt.planet[0][0] = Entity(True, coords=(0, 0))\n        >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),\n        ... direction_orders=[\"N\", \"W\", \"E\", \"S\"])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None,\n        Entity(prey=True, coords=(0, 2), remaining_reproduction_time=4)],\n        [None, None, None],\n        [None, None, None]]\n        >>> wt.planet[0][1] = wt.planet[0][2]\n        >>> wt.planet[0][2] = None\n        >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),\n        ... direction_orders=[\"N\", \"W\", \"S\", \"E\"])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None, None],\n        [None, Entity(prey=True, coords=(1, 1), remaining_reproduction_time=4), None],\n        [None, None, None]]\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> reproducable_entity = Entity(False, coords=(0, 1))\n        >>> reproducable_entity.remaining_reproduction_time = 0\n        >>> wt.planet = [[None, reproducable_entity]]\n        >>> wt.move_and_reproduce(reproducable_entity,\n        ... direction_orders=[\"N\", \"W\", \"S\", \"E\"])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[Entity(prey=False, coords=(0, 0),\n        remaining_reproduction_time=20, energy_value=15),\n        Entity(prey=False, coords=(0, 1), remaining_reproduction_time=20,\n        energy_value=15)]]\n        \"\"\"\n        row, col = coords = entity.coords\n\n        adjacent_squares: dict[Literal[\"N\", \"E\", \"S\", \"W\"], tuple[int, int]] = {\n            \"N\": (row - 1, col),  # North\n            \"S\": (row + 1, col),  # South\n            \"W\": (row, col - 1),  # West\n            \"E\": (row, col + 1),  # East\n        }\n        # Weight adjacent locations\n        adjacent: list[tuple[int, int]] = []\n        for order in direction_orders:\n            adjacent.append(adjacent_squares[order])\n\n        for r, c in adjacent:\n            if (\n                0 <= r < self.height\n                and 0 <= c < self.width\n                and self.planet[r][c] is None\n            ):\n                # Move entity to empty adjacent square\n                self.planet[r][c] = entity\n                self.planet[row][col] = None\n                entity.coords = (r, c)\n                break\n\n        # (2.) See if it possible to reproduce in previous square\n        if coords != entity.coords and entity.remaining_reproduction_time <= 0:\n            # Check if the entities on the planet is less than the max limit\n            if len(self.get_entities()) < MAX_ENTITIES:\n                # Reproduce in previous square\n                self.planet[row][col] = Entity(prey=entity.prey, coords=coords)\n                entity.reset_reproduction_time()\n        else:\n            entity.remaining_reproduction_time -= 1\n\n    def perform_prey_actions(\n        self, entity: Entity, direction_orders: list[Literal[\"N\", \"E\", \"S\", \"W\"]]\n    ) -> None:\n        \"\"\"\n        Performs the actions for a prey entity\n\n        For prey the rules are:\n          1. At each chronon, a prey moves randomly to one of the adjacent unoccupied\n            squares. If there are no free squares, no movement takes place.\n          2. Once a prey has survived a certain number of chronons it may reproduce.\n            This is done as it moves to a neighbouring square,\n            leaving behind a new prey in its old position.\n            Its reproduction time is also reset to zero.\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> reproducable_entity = Entity(True, coords=(0, 1))\n        >>> reproducable_entity.remaining_reproduction_time = 0\n        >>> wt.planet = [[None, reproducable_entity]]\n        >>> wt.perform_prey_actions(reproducable_entity,\n        ... direction_orders=[\"N\", \"W\", \"S\", \"E\"])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5),\n        Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5)]]\n        \"\"\"\n        self.move_and_reproduce(entity, direction_orders)\n\n    def perform_predator_actions(\n        self,\n        entity: Entity,\n        occupied_by_prey_coords: tuple[int, int] | None,\n        direction_orders: list[Literal[\"N\", \"E\", \"S\", \"W\"]],\n    ) -> None:\n        \"\"\"\n        Performs the actions for a predator entity\n\n        :param occupied_by_prey_coords: Move to this location if there is prey there\n\n        For predators the rules are:\n          1. At each chronon, a predator moves randomly to an adjacent square occupied\n            by a prey. If there is none, the predator moves to a random adjacent\n            unoccupied square. If there are no free squares, no movement takes place.\n          2. At each chronon, each predator is deprived of a unit of energy.\n          3. Upon reaching zero energy, a predator dies.\n          4. If a predator moves to a square occupied by a prey,\n            it eats the prey and earns a certain amount of energy.\n          5. Once a predator has survived a certain number of chronons\n          it may reproduce in exactly the same way as the prey.\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> wt.set_planet([[Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1))]])\n        >>> wt.perform_predator_actions(Entity(False, coords=(0, 1)), (0, 0), [])\n        >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE\n        [[Entity(prey=False, coords=(0, 0),\n        remaining_reproduction_time=20, energy_value=19), None]]\n        \"\"\"\n        assert entity.energy_value is not None  # [type checking]\n\n        # (3.) If the entity has 0 energy, it will die\n        if entity.energy_value == 0:\n            self.planet[entity.coords[0]][entity.coords[1]] = None\n            return\n\n        # (1.) Move to entity if possible\n        if occupied_by_prey_coords is not None:\n            # Kill the prey\n            prey = self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]]\n            assert prey is not None\n            prey.alive = False\n\n            # Move onto prey\n            self.planet[occupied_by_prey_coords[0]][occupied_by_prey_coords[1]] = entity\n            self.planet[entity.coords[0]][entity.coords[1]] = None\n\n            entity.coords = occupied_by_prey_coords\n            # (4.) Eats the prey and earns energy\n            entity.energy_value += PREDATOR_FOOD_VALUE\n        else:\n            # (5.) If it has survived the certain number of chronons it will also\n            # reproduce in this function\n            self.move_and_reproduce(entity, direction_orders)\n\n        # (2.) Each chronon, the predator is deprived of a unit of energy\n        entity.energy_value -= 1\n\n    def run(self, *, iteration_count: int) -> None:\n        \"\"\"\n        Emulate time passing by looping iteration_count times\n\n        >>> wt = WaTor(WIDTH, HEIGHT)\n        >>> wt.run(iteration_count=PREDATOR_INITIAL_ENERGY_VALUE - 1)\n        >>> len(list(filter(lambda entity: entity.prey is False,\n        ... wt.get_entities()))) >= PREDATOR_INITIAL_COUNT\n        True\n        \"\"\"\n        for iter_num in range(iteration_count):\n            # Generate list of all entities in order to randomly\n            # pop an entity at a time to simulate true randomness\n            # This removes the systematic approach of iterating\n            # through each entity width by height\n            all_entities = self.get_entities()\n\n            for __ in range(len(all_entities)):\n                entity = all_entities.pop(randint(0, len(all_entities) - 1))\n                if entity.alive is False:\n                    continue\n\n                directions: list[Literal[\"N\", \"E\", \"S\", \"W\"]] = [\"N\", \"E\", \"S\", \"W\"]\n                shuffle(directions)  # Randomly shuffle directions\n\n                if entity.prey:\n                    self.perform_prey_actions(entity, directions)\n                else:\n                    # Create list of surrounding prey\n                    surrounding_prey = self.get_surrounding_prey(entity)\n                    surrounding_prey_coords = None\n\n                    if surrounding_prey:\n                        # Again, randomly shuffle directions\n                        shuffle(surrounding_prey)\n                        surrounding_prey_coords = surrounding_prey[0].coords\n\n                    self.perform_predator_actions(\n                        entity, surrounding_prey_coords, directions\n                    )\n\n            # Balance out the predators and prey\n            self.balance_predators_and_prey()\n\n            if self.time_passed is not None:\n                # Call time_passed function for Wa-Tor planet\n                # visualisation in a terminal or a graph.\n                self.time_passed(self, iter_num)\n\n\ndef visualise(wt: WaTor, iter_number: int, *, colour: bool = True) -> None:\n    \"\"\"\n    Visually displays the Wa-Tor planet using\n    an ascii code in terminal to clear and re-print\n    the Wa-Tor planet at intervals.\n\n    Uses ascii colour codes to colourfully display\n    the predators and prey.\n\n    (0x60f197) Prey = #\n    (0xfffff) Predator = x\n\n    >>> wt = WaTor(30, 30)\n    >>> wt.set_planet([\n    ... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None],\n    ... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))],\n    ... [None, Entity(True, coords=(2, 1)), None]\n    ... ])\n    >>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE\n    #  x  .\n    x  .  x\n    .  #  .\n    <BLANKLINE>\n    Iteration: 0 | Prey count: 2 | Predator count: 3 |\n    \"\"\"\n    if colour:\n        __import__(\"os\").system(\"\")\n        print(\"\\x1b[0;0H\\x1b[2J\\x1b[?25l\")\n\n    reprint = \"\\x1b[0;0H\" if colour else \"\"\n    ansi_colour_end = \"\\x1b[0m \" if colour else \" \"\n\n    planet = wt.planet\n    output = \"\"\n\n    # Iterate over every entity in the planet\n    for row in planet:\n        for entity in row:\n            if entity is None:\n                output += \" . \"\n            else:\n                if colour is True:\n                    output += (\n                        \"\\x1b[38;2;96;241;151m\"\n                        if entity.prey\n                        else \"\\x1b[38;2;255;255;15m\"\n                    )\n                output += f\" {'#' if entity.prey else 'x'}{ansi_colour_end}\"\n\n        output += \"\\n\"\n\n    entities = wt.get_entities()\n    prey_count = sum(entity.prey for entity in entities)\n\n    print(\n        f\"{output}\\n Iteration: {iter_number} | Prey count: {prey_count} | \"\n        f\"Predator count: {len(entities) - prey_count} | {reprint}\"\n    )\n    # Block the thread to be able to visualise seeing the algorithm\n    sleep(0.05)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    wt = WaTor(WIDTH, HEIGHT)\n    wt.time_passed = visualise\n    wt.run(iteration_count=100_000)\n", "cellular_automata/conways_game_of_life.py": "\"\"\"\nConway's Game of Life implemented in Python.\nhttps://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom PIL import Image\n\n# Define glider example\nGLIDER = [\n    [0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0],\n]\n\n# Define blinker example\nBLINKER = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n\n\ndef new_generation(cells: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates the next generation for a given state of Conway's Game of Life.\n    >>> new_generation(BLINKER)\n    [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\n    \"\"\"\n    next_generation = []\n    for i in range(len(cells)):\n        next_generation_row = []\n        for j in range(len(cells[i])):\n            # Get the number of live neighbours\n            neighbour_count = 0\n            if i > 0 and j > 0:\n                neighbour_count += cells[i - 1][j - 1]\n            if i > 0:\n                neighbour_count += cells[i - 1][j]\n            if i > 0 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i - 1][j + 1]\n            if j > 0:\n                neighbour_count += cells[i][j - 1]\n            if j < len(cells[i]) - 1:\n                neighbour_count += cells[i][j + 1]\n            if i < len(cells) - 1 and j > 0:\n                neighbour_count += cells[i + 1][j - 1]\n            if i < len(cells) - 1:\n                neighbour_count += cells[i + 1][j]\n            if i < len(cells) - 1 and j < len(cells[i]) - 1:\n                neighbour_count += cells[i + 1][j + 1]\n\n            # Rules of the game of life (excerpt from Wikipedia):\n            # 1. Any live cell with two or three live neighbours survives.\n            # 2. Any dead cell with three live neighbours becomes a live cell.\n            # 3. All other live cells die in the next generation.\n            #    Similarly, all other dead cells stay dead.\n            alive = cells[i][j] == 1\n            if (\n                (alive and 2 <= neighbour_count <= 3)\n                or not alive\n                and neighbour_count == 3\n            ):\n                next_generation_row.append(1)\n            else:\n                next_generation_row.append(0)\n\n        next_generation.append(next_generation_row)\n    return next_generation\n\n\ndef generate_images(cells: list[list[int]], frames: int) -> list[Image.Image]:\n    \"\"\"\n    Generates a list of images of subsequent Game of Life states.\n    \"\"\"\n    images = []\n    for _ in range(frames):\n        # Create output image\n        img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n        pixels = img.load()\n\n        # Save cells to image\n        for x in range(len(cells)):\n            for y in range(len(cells[0])):\n                colour = 255 - cells[y][x] * 255\n                pixels[x, y] = (colour, colour, colour)\n\n        # Save image\n        images.append(img)\n        cells = new_generation(cells)\n    return images\n\n\nif __name__ == \"__main__\":\n    images = generate_images(GLIDER, 16)\n    images[0].save(\"out.gif\", save_all=True, append_images=images[1:])\n", "cellular_automata/nagel_schrekenberg.py": "\"\"\"\nSimulate the evolution of a highway with only one road that is a loop.\nThe highway is divided in cells, each cell can have at most one car in it.\nThe highway is a loop so when a car comes to one end, it will come out on the other.\nEach car is represented by its speed (from 0 to 5).\n\nSome information about speed:\n    -1 means that the cell on the highway is empty\n    0 to 5 are the speed of the cars with 0 being the lowest and 5 the highest\n\nhighway: list[int]  Where every position and speed of every car will be stored\nprobability         The probability that a driver will slow down\ninitial_speed       The speed of the cars a the start\nfrequency           How many cells there are between two cars at the start\nmax_speed           The maximum speed a car can go to\nnumber_of_cells     How many cell are there in the highway\nnumber_of_update    How many times will the position be updated\n\nMore information here: https://en.wikipedia.org/wiki/Nagel%E2%80%93Schreckenberg_model\n\nExamples for doctest:\n>>> simulate(construct_highway(6, 3, 0), 2, 0, 2)\n[[0, -1, -1, 0, -1, -1], [-1, 1, -1, -1, 1, -1], [-1, -1, 1, -1, -1, 1]]\n>>> simulate(construct_highway(5, 2, -2), 3, 0, 2)\n[[0, -1, 0, -1, 0], [0, -1, 0, -1, -1], [0, -1, -1, 1, -1], [-1, 1, -1, 0, -1]]\n\"\"\"\n\nfrom random import randint, random\n\n\ndef construct_highway(\n    number_of_cells: int,\n    frequency: int,\n    initial_speed: int,\n    random_frequency: bool = False,\n    random_speed: bool = False,\n    max_speed: int = 5,\n) -> list:\n    \"\"\"\n    Build the highway following the parameters given\n    >>> construct_highway(10, 2, 6)\n    [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]\n    >>> construct_highway(10, 10, 2)\n    [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]\n    \"\"\"\n\n    highway = [[-1] * number_of_cells]  # Create a highway without any car\n    i = 0\n    initial_speed = max(initial_speed, 0)\n    while i < number_of_cells:\n        highway[0][i] = (\n            randint(0, max_speed) if random_speed else initial_speed\n        )  # Place the cars\n        i += (\n            randint(1, max_speed * 2) if random_frequency else frequency\n        )  # Arbitrary number, may need tuning\n    return highway\n\n\ndef get_distance(highway_now: list, car_index: int) -> int:\n    \"\"\"\n    Get the distance between a car (at index car_index) and the next car\n    >>> get_distance([6, -1, 6, -1, 6], 2)\n    1\n    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)\n    3\n    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)\n    4\n    \"\"\"\n\n    distance = 0\n    cells = highway_now[car_index + 1 :]\n    for cell in range(len(cells)):  # May need a better name for this\n        if cells[cell] != -1:  # If the cell is not empty then\n            return distance  # we have the distance we wanted\n        distance += 1\n    # Here if the car is near the end of the highway\n    return distance + get_distance(highway_now, -1)\n\n\ndef update(highway_now: list, probability: float, max_speed: int) -> list:\n    \"\"\"\n    Update the speed of the cars\n    >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]\n    >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)\n    [-1, -1, 3, -1, -1, -1, -1, 1]\n    \"\"\"\n\n    number_of_cells = len(highway_now)\n    # Beforce calculations, the highway is empty\n    next_highway = [-1] * number_of_cells\n\n    for car_index in range(number_of_cells):\n        if highway_now[car_index] != -1:\n            # Add 1 to the current speed of the car and cap the speed\n            next_highway[car_index] = min(highway_now[car_index] + 1, max_speed)\n            # Number of empty cell before the next car\n            dn = get_distance(highway_now, car_index) - 1\n            # We can't have the car causing an accident\n            next_highway[car_index] = min(next_highway[car_index], dn)\n            if random() < probability:\n                # Randomly, a driver will slow down\n                next_highway[car_index] = max(next_highway[car_index] - 1, 0)\n    return next_highway\n\n\ndef simulate(\n    highway: list, number_of_update: int, probability: float, max_speed: int\n) -> list:\n    \"\"\"\n    The main function, it will simulate the evolution of the highway\n    >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)\n    [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]\n    >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)\n    [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]\n    \"\"\"\n\n    number_of_cells = len(highway[0])\n\n    for i in range(number_of_update):\n        next_speeds_calculated = update(highway[i], probability, max_speed)\n        real_next_speeds = [-1] * number_of_cells\n\n        for car_index in range(number_of_cells):\n            speed = next_speeds_calculated[car_index]\n            if speed != -1:\n                # Change the position based on the speed (with % to create the loop)\n                index = (car_index + speed) % number_of_cells\n                # Commit the change of position\n                real_next_speeds[index] = speed\n        highway.append(real_next_speeds)\n\n    return highway\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "cellular_automata/one_dimensional.py": "\"\"\"\nReturn an image of 16 generations of one-dimensional cellular automata based on a given\nruleset number\nhttps://mathworld.wolfram.com/ElementaryCellularAutomaton.html\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom PIL import Image\n\n# Define the first generation of cells\n# fmt: off\nCELLS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\n# fmt: on\n\n\ndef format_ruleset(ruleset: int) -> list[int]:\n    \"\"\"\n    >>> format_ruleset(11100)\n    [0, 0, 0, 1, 1, 1, 0, 0]\n    >>> format_ruleset(0)\n    [0, 0, 0, 0, 0, 0, 0, 0]\n    >>> format_ruleset(11111111)\n    [1, 1, 1, 1, 1, 1, 1, 1]\n    \"\"\"\n    return [int(c) for c in f\"{ruleset:08}\"[:8]]\n\n\ndef new_generation(cells: list[list[int]], rule: list[int], time: int) -> list[int]:\n    population = len(cells[0])  # 31\n    next_generation = []\n    for i in range(population):\n        # Get the neighbors of each cell\n        # Handle neighbours outside bounds by using 0 as their value\n        left_neighbor = 0 if i == 0 else cells[time][i - 1]\n        right_neighbor = 0 if i == population - 1 else cells[time][i + 1]\n        # Define a new cell and add it to the new generation\n        situation = 7 - int(f\"{left_neighbor}{cells[time][i]}{right_neighbor}\", 2)\n        next_generation.append(rule[situation])\n    return next_generation\n\n\ndef generate_image(cells: list[list[int]]) -> Image.Image:\n    \"\"\"\n    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.\n    >>> from random import random\n    >>> cells = [[random() for w in range(31)] for h in range(16)]\n    >>> img = generate_image(cells)\n    >>> isinstance(img, Image.Image)\n    True\n    >>> img.width, img.height\n    (31, 16)\n    \"\"\"\n    # Create the output image\n    img = Image.new(\"RGB\", (len(cells[0]), len(cells)))\n    pixels = img.load()\n    # Generates image\n    for w in range(img.width):\n        for h in range(img.height):\n            color = 255 - int(255 * cells[h][w])\n            pixels[w, h] = (color, color, color)\n    return img\n\n\nif __name__ == \"__main__\":\n    rule_num = bin(int(input(\"Rule:\\n\").strip()))[2:]\n    rule = format_ruleset(int(rule_num))\n    for time in range(16):\n        CELLS.append(new_generation(CELLS, rule, time))\n    img = generate_image(CELLS)\n    # Uncomment to save the image\n    # img.save(f\"rule_{rule_num}.png\")\n    img.show()\n", "cellular_automata/__init__.py": "", "cellular_automata/langtons_ant.py": "\"\"\"\nLangton's ant\n\n@ https://en.wikipedia.org/wiki/Langton%27s_ant\n@ https://upload.wikimedia.org/wikipedia/commons/0/09/LangtonsAntAnimated.gif\n\"\"\"\n\nfrom functools import partial\n\nfrom matplotlib import pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\nWIDTH = 80\nHEIGHT = 80\n\n\nclass LangtonsAnt:\n    \"\"\"\n    Represents the main LangonsAnt algorithm.\n\n    >>> la = LangtonsAnt(2, 2)\n    >>> la.board\n    [[True, True], [True, True]]\n    >>> la.ant_position\n    (1, 1)\n    \"\"\"\n\n    def __init__(self, width: int, height: int) -> None:\n        # Each square is either True or False where True is white and False is black\n        self.board = [[True] * width for _ in range(height)]\n        self.ant_position: tuple[int, int] = (width // 2, height // 2)\n\n        # Initially pointing left (similar to the wikipedia image)\n        # (0 = 0\u00b0 | 1 = 90\u00b0 | 2 = 180 \u00b0 | 3 = 270\u00b0)\n        self.ant_direction: int = 3\n\n    def move_ant(self, axes: plt.Axes | None, display: bool, _frame: int) -> None:\n        \"\"\"\n        Performs three tasks:\n            1. The ant turns either clockwise or anti-clockwise according to the colour\n            of the square that it is currently on. If the square is white, the ant\n            turns clockwise, and if the square is black the ant turns anti-clockwise\n            2. The ant moves one square in the direction that it is currently facing\n            3. The square the ant was previously on is inverted (White -> Black and\n            Black -> White)\n\n        If display is True, the board will also be displayed on the axes\n\n        >>> la = LangtonsAnt(2, 2)\n        >>> la.move_ant(None, True, 0)\n        >>> la.board\n        [[True, True], [True, False]]\n        >>> la.move_ant(None, True, 0)\n        >>> la.board\n        [[True, False], [True, False]]\n        \"\"\"\n        directions = {\n            0: (-1, 0),  # 0\u00b0\n            1: (0, 1),  # 90\u00b0\n            2: (1, 0),  # 180\u00b0\n            3: (0, -1),  # 270\u00b0\n        }\n        x, y = self.ant_position\n\n        # Turn clockwise or anti-clockwise according to colour of square\n        if self.board[x][y] is True:\n            # The square is white so turn 90\u00b0 clockwise\n            self.ant_direction = (self.ant_direction + 1) % 4\n        else:\n            # The square is black so turn 90\u00b0 anti-clockwise\n            self.ant_direction = (self.ant_direction - 1) % 4\n\n        # Move ant\n        move_x, move_y = directions[self.ant_direction]\n        self.ant_position = (x + move_x, y + move_y)\n\n        # Flip colour of square\n        self.board[x][y] = not self.board[x][y]\n\n        if display and axes:\n            # Display the board on the axes\n            axes.get_xaxis().set_ticks([])\n            axes.get_yaxis().set_ticks([])\n            axes.imshow(self.board, cmap=\"gray\", interpolation=\"nearest\")\n\n    def display(self, frames: int = 100_000) -> None:\n        \"\"\"\n        Displays the board without delay in a matplotlib plot\n        to visually understand and track the ant.\n\n        >>> _ = LangtonsAnt(WIDTH, HEIGHT)\n        \"\"\"\n        fig, ax = plt.subplots()\n        # Assign animation to a variable to prevent it from getting garbage collected\n        self.animation = FuncAnimation(\n            fig, partial(self.move_ant, ax, True), frames=frames, interval=1\n        )\n        plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    LangtonsAnt(WIDTH, HEIGHT).display()\n", "blockchain/diophantine_equation.py": "from __future__ import annotations\n\nfrom maths.greatest_common_divisor import greatest_common_divisor\n\n\ndef diophantine(a: int, b: int, c: int) -> tuple[float, float]:\n    \"\"\"\n    Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the\n    diophantine equation a*x + b*y = c has a solution (where x and y are integers)\n    iff greatest_common_divisor(a,b) divides c.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    >>> diophantine(10,6,14)\n    (-7.0, 14.0)\n\n    >>> diophantine(391,299,-69)\n    (9.0, -12.0)\n\n    But above equation has one more solution i.e., x = -4, y = 5.\n    That's why we need diophantine all solution function.\n\n    \"\"\"\n\n    assert (\n        c % greatest_common_divisor(a, b) == 0\n    )  # greatest_common_divisor(a,b) is in maths directory\n    (d, x, y) = extended_gcd(a, b)  # extended_gcd(a,b) function implemented below\n    r = c / d\n    return (r * x, r * y)\n\n\ndef diophantine_all_soln(a: int, b: int, c: int, n: int = 2) -> None:\n    \"\"\"\n    Lemma : if n|ab and gcd(a,n) = 1, then n|b.\n\n    Finding All solutions of Diophantine Equations:\n\n    Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of\n    Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the\n    solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,\n    where t is an arbitrary integer.\n\n    n is the number of solution you want, n = 2 by default\n\n    >>> diophantine_all_soln(10, 6, 14)\n    -7.0 14.0\n    -4.0 9.0\n\n    >>> diophantine_all_soln(10, 6, 14, 4)\n    -7.0 14.0\n    -4.0 9.0\n    -1.0 4.0\n    2.0 -1.0\n\n    >>> diophantine_all_soln(391, 299, -69, n = 4)\n    9.0 -12.0\n    22.0 -29.0\n    35.0 -46.0\n    48.0 -63.0\n\n    \"\"\"\n    (x0, y0) = diophantine(a, b, c)  # Initial value\n    d = greatest_common_divisor(a, b)\n    p = a // d\n    q = b // d\n\n    for i in range(n):\n        x = x0 + i * q\n        y = y0 - i * p\n        print(x, y)\n\n\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers\n    x and y, then d = gcd(a,b)\n\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    \"\"\"\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"diophantine\", verbose=True)\n    testmod(name=\"diophantine_all_soln\", verbose=True)\n    testmod(name=\"extended_gcd\", verbose=True)\n    testmod(name=\"greatest_common_divisor\", verbose=True)\n", "blockchain/__init__.py": "", "hashes/hamming_code.py": "# Author: Jo\u00e3o Gustavo A. Amorim & Gabriel Kunz\n# Author email: joaogustavoamorim@gmail.com and gabriel-kunz@uergs.edu.br\n# Coding date:  apr 2019\n# Black: True\n\n\"\"\"\n* This code implement the Hamming code:\n    https://en.wikipedia.org/wiki/Hamming_code - In telecommunication,\nHamming codes are a family of linear error-correcting codes. Hamming\ncodes can detect up to two-bit errors or correct one-bit errors\nwithout detection of uncorrected errors. By contrast, the simple\nparity code cannot correct errors, and can detect only an odd number\nof bits in error. Hamming codes are perfect codes, that is, they\nachieve the highest possible rate for codes with their block length\nand minimum distance of three.\n\n* the implemented code consists of:\n    * a function responsible for encoding the message (emitterConverter)\n        * return the encoded message\n    * a function responsible for decoding the message (receptorConverter)\n        * return the decoded message and a ack of data integrity\n\n* how to use:\n        to be used you must declare how many parity bits (sizePari)\n    you want to include in the message.\n        it is desired (for test purposes) to select a bit to be set\n    as an error. This serves to check whether the code is working correctly.\n        Lastly, the variable of the message/word that must be desired to be\n    encoded (text).\n\n* how this work:\n        declaration of variables (sizePari, be, text)\n\n        converts the message/word (text) to binary using the\n    text_to_bits function\n        encodes the message using the rules of hamming encoding\n        decodes the message using the rules of hamming encoding\n        print the original message, the encoded message and the\n    decoded message\n\n        forces an error in the coded text variable\n        decodes the message that was forced the error\n        print the original message, the encoded message, the bit changed\n    message and the decoded message\n\"\"\"\n\n# Imports\nimport numpy as np\n\n\n# Functions of binary conversion--------------------------------------\ndef text_to_bits(text, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_to_bits(\"msg\")\n    '011011010111001101100111'\n    \"\"\"\n    bits = bin(int.from_bytes(text.encode(encoding, errors), \"big\"))[2:]\n    return bits.zfill(8 * ((len(bits) + 7) // 8))\n\n\ndef text_from_bits(bits, encoding=\"utf-8\", errors=\"surrogatepass\"):\n    \"\"\"\n    >>> text_from_bits('011011010111001101100111')\n    'msg'\n    \"\"\"\n    n = int(bits, 2)\n    return n.to_bytes((n.bit_length() + 7) // 8, \"big\").decode(encoding, errors) or \"\\0\"\n\n\n# Functions of hamming code-------------------------------------------\ndef emitter_converter(size_par, data):\n    \"\"\"\n    :param size_par: how many parity bits the message must have\n    :param data:  information bits\n    :return: message to be transmitted by unreliable medium\n            - bits of information merged with parity bits\n\n    >>> emitter_converter(4, \"101010111111\")\n    ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']\n    >>> emitter_converter(5, \"101010111111\")\n    Traceback (most recent call last):\n        ...\n    ValueError: size of parity don't match with size of data\n    \"\"\"\n    if size_par + len(data) <= 2**size_par - (len(data) - 1):\n        raise ValueError(\"size of parity don't match with size of data\")\n\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data) + 1)]\n\n    # sorted information data for the size of the output data\n    data_ord = []\n    # data position template + parity\n    data_out_gab = []\n    # parity bit counter\n    qtd_bp = 0\n    # counter position of data bits\n    cont_data = 0\n\n    for x in range(1, size_par + len(data) + 1):\n        # Performs a template of bit positions - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par:\n            if (np.log(x) / np.log(2)).is_integer():\n                data_out_gab.append(\"P\")\n                qtd_bp = qtd_bp + 1\n            else:\n                data_out_gab.append(\"D\")\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a given parity\n        cont_bo = 0\n        # counter to control the loop reading\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(cont_bo % 2)\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # parity bit counter\n    for x in range(size_par + len(data)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    return data_out\n\n\ndef receptor_converter(size_par, data):\n    \"\"\"\n    >>> receptor_converter(4, \"1111010010111111\")\n    (['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)\n    \"\"\"\n    # data position template + parity\n    data_out_gab = []\n    # Parity bit counter\n    qtd_bp = 0\n    # Counter p data bit reading\n    cont_data = 0\n    # list of parity received\n    parity_received = []\n    data_output = []\n\n    for i, item in enumerate(data, 1):\n        # Performs a template of bit positions - who should be given,\n        #  and who should be parity\n        if qtd_bp < size_par and (np.log(i) / np.log(2)).is_integer():\n            data_out_gab.append(\"P\")\n            qtd_bp = qtd_bp + 1\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_output.append(item)\n        else:\n            parity_received.append(item)\n\n    # -----------calculates the parity with the data\n    data_out = []\n    parity = []\n    bin_pos = [bin(x)[2:] for x in range(1, size_par + len(data_output) + 1)]\n\n    #  sorted information data for the size of the output data\n    data_ord = []\n    # Data position feedback + parity\n    data_out_gab = []\n    # Parity bit counter\n    qtd_bp = 0\n    # Counter p data bit reading\n    cont_data = 0\n\n    for x in range(1, size_par + len(data_output) + 1):\n        # Performs a template position of bits - who should be given,\n        # and who should be parity\n        if qtd_bp < size_par and (np.log(x) / np.log(2)).is_integer():\n            data_out_gab.append(\"P\")\n            qtd_bp = qtd_bp + 1\n        else:\n            data_out_gab.append(\"D\")\n\n        # Sorts the data to the new output size\n        if data_out_gab[-1] == \"D\":\n            data_ord.append(data_output[cont_data])\n            cont_data += 1\n        else:\n            data_ord.append(None)\n\n    # Calculates parity\n    qtd_bp = 0  # parity bit counter\n    for bp in range(1, size_par + 1):\n        # Bit counter one for a certain parity\n        cont_bo = 0\n        for cont_loop, x in enumerate(data_ord):\n            if x is not None:\n                try:\n                    aux = (bin_pos[cont_loop])[-1 * (bp)]\n                except IndexError:\n                    aux = \"0\"\n                if aux == \"1\" and x == \"1\":\n                    cont_bo += 1\n        parity.append(str(cont_bo % 2))\n\n        qtd_bp += 1\n\n    # Mount the message\n    cont_bp = 0  # Parity bit counter\n    for x in range(size_par + len(data_output)):\n        if data_ord[x] is None:\n            data_out.append(str(parity[cont_bp]))\n            cont_bp += 1\n        else:\n            data_out.append(data_ord[x])\n\n    ack = parity_received == parity\n    return data_output, ack\n\n\n# ---------------------------------------------------------------------\n\"\"\"\n# Example how to use\n\n# number of parity bits\nsizePari = 4\n\n# location of the bit that will be forced an error\nbe = 2\n\n# Message/word to be encoded and decoded with hamming\n# text = input(\"Enter the word to be read: \")\ntext = \"Message01\"\n\n# Convert the message to binary\nbinaryText = text_to_bits(text)\n\n# Prints the binary of the string\nprint(\"Text input in binary is '\" + binaryText + \"'\")\n\n# total transmitted bits\ntotalBits = len(binaryText) + sizePari\nprint(\"Size of data is \" + str(totalBits))\n\nprint(\"\\n --Message exchange--\")\nprint(\"Data to send ------------> \" + binaryText)\ndataOut = emitterConverter(sizePari, binaryText)\nprint(\"Data converted ----------> \" + \"\".join(dataOut))\ndataReceiv, ack = receptorConverter(sizePari, dataOut)\nprint(\n    \"Data receive ------------> \"\n    + \"\".join(dataReceiv)\n    + \"\\t\\t -- Data integrity: \"\n    + str(ack)\n)\n\n\nprint(\"\\n --Force error--\")\nprint(\"Data to send ------------> \" + binaryText)\ndataOut = emitterConverter(sizePari, binaryText)\nprint(\"Data converted ----------> \" + \"\".join(dataOut))\n\n# forces error\ndataOut[-be] = \"1\" * (dataOut[-be] == \"0\") + \"0\" * (dataOut[-be] == \"1\")\nprint(\"Data after transmission -> \" + \"\".join(dataOut))\ndataReceiv, ack = receptorConverter(sizePari, dataOut)\nprint(\n    \"Data receive ------------> \"\n    + \"\".join(dataReceiv)\n    + \"\\t\\t -- Data integrity: \"\n    + str(ack)\n)\n\"\"\"\n", "hashes/chaos_machine.py": "\"\"\"example of simple chaos machine\"\"\"\n\n# Chaos Machine (K, t, m)\nK = [0.33, 0.44, 0.55, 0.44, 0.33]\nt = 3\nm = 5\n\n# Buffer Space (with Parameters Space)\nbuffer_space: list[float] = []\nparams_space: list[float] = []\n\n# Machine Time\nmachine_time = 0\n\n\ndef push(seed):\n    global buffer_space, params_space, machine_time, K, m, t\n\n    # Choosing Dynamical Systems (All)\n    for key, value in enumerate(buffer_space):\n        # Evolution Parameter\n        e = float(seed / value)\n\n        # Control Theory: Orbit Change\n        value = (buffer_space[(key + 1) % m] + e) % 1\n\n        # Control Theory: Trajectory Change\n        r = (params_space[key] + e) % 1 + 3\n\n        # Modification (Transition Function) - Jumps\n        buffer_space[key] = round(float(r * value * (1 - value)), 10)\n        params_space[key] = r  # Saving to Parameters Space\n\n    # Logistic Map\n    assert max(buffer_space) < 1\n    assert max(params_space) < 4\n\n    # Machine Time\n    machine_time += 1\n\n\ndef pull():\n    global buffer_space, params_space, machine_time, K, m, t\n\n    # PRNG (Xorshift by George Marsaglia)\n    def xorshift(x, y):\n        x ^= y >> 13\n        y ^= x << 17\n        x ^= y >> 5\n        return x\n\n    # Choosing Dynamical Systems (Increment)\n    key = machine_time % m\n\n    # Evolution (Time Length)\n    for _ in range(t):\n        # Variables (Position + Parameters)\n        r = params_space[key]\n        value = buffer_space[key]\n\n        # Modification (Transition Function) - Flow\n        buffer_space[key] = round(float(r * value * (1 - value)), 10)\n        params_space[key] = (machine_time * 0.01 + r * 1.01) % 1 + 3\n\n    # Choosing Chaotic Data\n    x = int(buffer_space[(key + 2) % m] * (10**10))\n    y = int(buffer_space[(key - 2) % m] * (10**10))\n\n    # Machine Time\n    machine_time += 1\n\n    return xorshift(x, y) % 0xFFFFFFFF\n\n\ndef reset():\n    global buffer_space, params_space, machine_time, K, m, t\n\n    buffer_space = K\n    params_space = [0] * m\n    machine_time = 0\n\n\nif __name__ == \"__main__\":\n    # Initialization\n    reset()\n\n    # Pushing Data (Input)\n    import random\n\n    message = random.sample(range(0xFFFFFFFF), 100)\n    for chunk in message:\n        push(chunk)\n\n    # for controlling\n    inp = \"\"\n\n    # Pulling Data (Output)\n    while inp in (\"e\", \"E\"):\n        print(f\"{format(pull(), '#04x')}\")\n        print(buffer_space)\n        print(params_space)\n        inp = input(\"(e)exit? \").strip()\n", "hashes/djb2.py": "\"\"\"\nThis algorithm (k=33) was first reported by Dan Bernstein many years ago in comp.lang.c\nAnother version of this algorithm (now favored by Bernstein) uses xor:\n    hash(i) = hash(i - 1) * 33 ^ str[i];\n\n    First Magic constant 33:\n    It has never been adequately explained.\n    It's magic because it works better than many other constants, prime or not.\n\n    Second Magic Constant 5381:\n\n    1. odd number\n    2. prime number\n    3. deficient number\n    4. 001/010/100/000/101 b\n\n    source: http://www.cse.yorku.ca/~oz/hash.html\n\"\"\"\n\n\ndef djb2(s: str) -> int:\n    \"\"\"\n    Implementation of djb2 hash algorithm that\n    is popular because of it's magic constants.\n\n    >>> djb2('Algorithms')\n    3782405311\n\n    >>> djb2('scramble bits')\n    1609059040\n    \"\"\"\n    hash_value = 5381\n    for x in s:\n        hash_value = ((hash_value << 5) + hash_value) + ord(x)\n    return hash_value & 0xFFFFFFFF\n", "hashes/luhn.py": "\"\"\"Luhn Algorithm\"\"\"\n\nfrom __future__ import annotations\n\n\ndef is_luhn(string: str) -> bool:\n    \"\"\"\n    Perform Luhn validation on an input string\n    Algorithm:\n    * Double every other digit starting from 2nd last digit.\n    * Subtract 9 if number is greater than 9.\n    * Sum the numbers\n    *\n    >>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,\n    ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,\n    ...     79927398719)\n    >>> [is_luhn(str(test_case)) for test_case in test_cases]\n    [False, False, False, True, False, False, False, False, False, False]\n    \"\"\"\n    check_digit: int\n    _vector: list[str] = list(string)\n    __vector, check_digit = _vector[:-1], int(_vector[-1])\n    vector: list[int] = [int(digit) for digit in __vector]\n\n    vector.reverse()\n    for i, digit in enumerate(vector):\n        if i & 1 == 0:\n            doubled: int = digit * 2\n            if doubled > 9:\n                doubled -= 9\n            check_digit += doubled\n        else:\n            check_digit += digit\n\n    return check_digit % 10 == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    assert is_luhn(\"79927398713\")\n    assert not is_luhn(\"79927398714\")\n", "hashes/elf.py": "def elf_hash(data: str) -> int:\n    \"\"\"\n    Implementation of ElfHash Algorithm, a variant of PJW hash function.\n\n    >>> elf_hash('lorem ipsum')\n    253956621\n    \"\"\"\n    hash_ = x = 0\n    for letter in data:\n        hash_ = (hash_ << 4) + ord(letter)\n        x = hash_ & 0xF0000000\n        if x != 0:\n            hash_ ^= x >> 24\n        hash_ &= ~x\n    return hash_\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "hashes/sha256.py": "# Author: M. Yathurshan\n# Black Formatter: True\n\n\"\"\"\nImplementation of SHA256 Hash function in a Python class and provides utilities\nto find hash of string or hash of text from a file.\n\nUsage: python sha256.py --string \"Hello World!!\"\n       python sha256.py --file \"hello_world.txt\"\n       When run without any arguments,\n       it prints the hash of the string \"Hello World!! Welcome to Cryptography\"\n\nReferences:\nhttps://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/\nhttps://en.wikipedia.org/wiki/SHA-2\n\"\"\"\n\nimport argparse\nimport struct\nimport unittest\n\n\nclass SHA256:\n    \"\"\"\n    Class to contain the entire pipeline for SHA1 Hashing Algorithm\n\n    >>> SHA256(b'Python').hash\n    '18885f27b5af9012df19e496460f9294d5ab76128824c6f993787004f6d9a7db'\n\n    >>> SHA256(b'hello world').hash\n    'b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9'\n    \"\"\"\n\n    def __init__(self, data: bytes) -> None:\n        self.data = data\n\n        # Initialize hash values\n        self.hashes = [\n            0x6A09E667,\n            0xBB67AE85,\n            0x3C6EF372,\n            0xA54FF53A,\n            0x510E527F,\n            0x9B05688C,\n            0x1F83D9AB,\n            0x5BE0CD19,\n        ]\n\n        # Initialize round constants\n        self.round_constants = [\n            0x428A2F98,\n            0x71374491,\n            0xB5C0FBCF,\n            0xE9B5DBA5,\n            0x3956C25B,\n            0x59F111F1,\n            0x923F82A4,\n            0xAB1C5ED5,\n            0xD807AA98,\n            0x12835B01,\n            0x243185BE,\n            0x550C7DC3,\n            0x72BE5D74,\n            0x80DEB1FE,\n            0x9BDC06A7,\n            0xC19BF174,\n            0xE49B69C1,\n            0xEFBE4786,\n            0x0FC19DC6,\n            0x240CA1CC,\n            0x2DE92C6F,\n            0x4A7484AA,\n            0x5CB0A9DC,\n            0x76F988DA,\n            0x983E5152,\n            0xA831C66D,\n            0xB00327C8,\n            0xBF597FC7,\n            0xC6E00BF3,\n            0xD5A79147,\n            0x06CA6351,\n            0x14292967,\n            0x27B70A85,\n            0x2E1B2138,\n            0x4D2C6DFC,\n            0x53380D13,\n            0x650A7354,\n            0x766A0ABB,\n            0x81C2C92E,\n            0x92722C85,\n            0xA2BFE8A1,\n            0xA81A664B,\n            0xC24B8B70,\n            0xC76C51A3,\n            0xD192E819,\n            0xD6990624,\n            0xF40E3585,\n            0x106AA070,\n            0x19A4C116,\n            0x1E376C08,\n            0x2748774C,\n            0x34B0BCB5,\n            0x391C0CB3,\n            0x4ED8AA4A,\n            0x5B9CCA4F,\n            0x682E6FF3,\n            0x748F82EE,\n            0x78A5636F,\n            0x84C87814,\n            0x8CC70208,\n            0x90BEFFFA,\n            0xA4506CEB,\n            0xBEF9A3F7,\n            0xC67178F2,\n        ]\n\n        self.preprocessed_data = self.preprocessing(self.data)\n        self.final_hash()\n\n    @staticmethod\n    def preprocessing(data: bytes) -> bytes:\n        padding = b\"\\x80\" + (b\"\\x00\" * (63 - (len(data) + 8) % 64))\n        big_endian_integer = struct.pack(\">Q\", (len(data) * 8))\n        return data + padding + big_endian_integer\n\n    def final_hash(self) -> None:\n        # Convert into blocks of 64 bytes\n        self.blocks = [\n            self.preprocessed_data[x : x + 64]\n            for x in range(0, len(self.preprocessed_data), 64)\n        ]\n\n        for block in self.blocks:\n            # Convert the given block into a list of 4 byte integers\n            words = list(struct.unpack(\">16L\", block))\n            # add 48 0-ed integers\n            words += [0] * 48\n\n            a, b, c, d, e, f, g, h = self.hashes\n\n            for index in range(64):\n                if index > 15:\n                    # modify the zero-ed indexes at the end of the array\n                    s0 = (\n                        self.ror(words[index - 15], 7)\n                        ^ self.ror(words[index - 15], 18)\n                        ^ (words[index - 15] >> 3)\n                    )\n                    s1 = (\n                        self.ror(words[index - 2], 17)\n                        ^ self.ror(words[index - 2], 19)\n                        ^ (words[index - 2] >> 10)\n                    )\n\n                    words[index] = (\n                        words[index - 16] + s0 + words[index - 7] + s1\n                    ) % 0x100000000\n\n                # Compression\n                s1 = self.ror(e, 6) ^ self.ror(e, 11) ^ self.ror(e, 25)\n                ch = (e & f) ^ ((~e & (0xFFFFFFFF)) & g)\n                temp1 = (\n                    h + s1 + ch + self.round_constants[index] + words[index]\n                ) % 0x100000000\n                s0 = self.ror(a, 2) ^ self.ror(a, 13) ^ self.ror(a, 22)\n                maj = (a & b) ^ (a & c) ^ (b & c)\n                temp2 = (s0 + maj) % 0x100000000\n\n                h, g, f, e, d, c, b, a = (\n                    g,\n                    f,\n                    e,\n                    ((d + temp1) % 0x100000000),\n                    c,\n                    b,\n                    a,\n                    ((temp1 + temp2) % 0x100000000),\n                )\n\n            mutated_hash_values = [a, b, c, d, e, f, g, h]\n\n            # Modify final values\n            self.hashes = [\n                ((element + mutated_hash_values[index]) % 0x100000000)\n                for index, element in enumerate(self.hashes)\n            ]\n\n        self.hash = \"\".join([hex(value)[2:].zfill(8) for value in self.hashes])\n\n    def ror(self, value: int, rotations: int) -> int:\n        \"\"\"\n        Right rotate a given unsigned number by a certain amount of rotations\n        \"\"\"\n        return 0xFFFFFFFF & (value << (32 - rotations)) | (value >> rotations)\n\n\nclass SHA256HashTest(unittest.TestCase):\n    \"\"\"\n    Test class for the SHA256 class. Inherits the TestCase class from unittest\n    \"\"\"\n\n    def test_match_hashes(self) -> None:\n        import hashlib\n\n        msg = bytes(\"Test String\", \"utf-8\")\n        assert SHA256(msg).hash == hashlib.sha256(msg).hexdigest()\n\n\ndef main() -> None:\n    \"\"\"\n    Provides option 'string' or 'file' to take input\n    and prints the calculated SHA-256 hash\n    \"\"\"\n\n    # unittest.main()\n\n    import doctest\n\n    doctest.testmod()\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-s\",\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\n        \"-f\", \"--file\", dest=\"input_file\", help=\"Hash contents of a file\"\n    )\n\n    args = parser.parse_args()\n\n    input_string = args.input_string\n\n    # hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n\n    print(SHA256(hash_input).hash)\n\n\nif __name__ == \"__main__\":\n    main()\n", "hashes/enigma_machine.py": "alphabets = [chr(i) for i in range(32, 126)]\ngear_one = list(range(len(alphabets)))\ngear_two = list(range(len(alphabets)))\ngear_three = list(range(len(alphabets)))\nreflector = list(reversed(range(len(alphabets))))\ncode = []\ngear_one_pos = gear_two_pos = gear_three_pos = 0\n\n\ndef rotator():\n    global gear_one_pos\n    global gear_two_pos\n    global gear_three_pos\n    i = gear_one[0]\n    gear_one.append(i)\n    del gear_one[0]\n    gear_one_pos += 1\n    if gear_one_pos % int(len(alphabets)) == 0:\n        i = gear_two[0]\n        gear_two.append(i)\n        del gear_two[0]\n        gear_two_pos += 1\n        if gear_two_pos % int(len(alphabets)) == 0:\n            i = gear_three[0]\n            gear_three.append(i)\n            del gear_three[0]\n            gear_three_pos += 1\n\n\ndef engine(input_character):\n    target = alphabets.index(input_character)\n    target = gear_one[target]\n    target = gear_two[target]\n    target = gear_three[target]\n    target = reflector[target]\n    target = gear_three.index(target)\n    target = gear_two.index(target)\n    target = gear_one.index(target)\n    code.append(alphabets[target])\n    rotator()\n\n\nif __name__ == \"__main__\":\n    decode = list(input(\"Type your message:\\n\"))\n    while True:\n        try:\n            token = int(input(\"Please set token:(must be only digits)\\n\"))\n            break\n        except Exception as error:\n            print(error)\n    for _ in range(token):\n        rotator()\n    for j in decode:\n        engine(j)\n    print(\"\\n\" + \"\".join(code))\n    print(\n        f\"\\nYour Token is {token} please write it down.\\nIf you want to decode \"\n        \"this message again you should input same digits as token!\"\n    )\n", "hashes/sha1.py": "\"\"\"\nImplementation of the SHA1 hash function and gives utilities to find hash of string or\nhash of text from a file. Also contains a Test class to verify that the generated hash\nmatches what is returned by the hashlib library\n\nUsage: python sha1.py --string \"Hello World!!\"\n       python sha1.py --file \"hello_world.txt\"\n       When run without any arguments, it prints the hash of the string \"Hello World!!\n       Welcome to Cryptography\"\n\nSHA1 hash or SHA1 sum of a string is a cryptographic function, which means it is easy\nto calculate forwards but extremely difficult to calculate backwards. What this means\nis you can easily calculate the hash of a string, but it is extremely difficult to know\nthe original string if you have its hash. This property is useful for communicating\nsecurely, send encrypted messages and is very useful in payment systems, blockchain and\ncryptocurrency etc.\n\nThe algorithm as described in the reference:\nFirst we start with a message. The message is padded and the length of the message\nis added to the end. It is then split into blocks of 512 bits or 64 bytes. The blocks\nare then processed one at a time. Each block must be expanded and compressed.\nThe value after each compression is added to a 160-bit buffer called the current hash\nstate. After the last block is processed, the current hash state is returned as\nthe final hash.\n\nReference: https://deadhacker.com/2006/02/21/sha-1-illustrated/\n\"\"\"\n\nimport argparse\nimport hashlib  # hashlib is only used inside the Test class\nimport struct\n\n\nclass SHA1Hash:\n    \"\"\"\n    Class to contain the entire pipeline for SHA1 hashing algorithm\n    >>> SHA1Hash(bytes('Allan', 'utf-8')).final_hash()\n    '872af2d8ac3d8695387e7c804bf0e02c18df9e6e'\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initiates the variables data and h. h is a list of 5 8-digit hexadecimal\n        numbers corresponding to\n        (1732584193, 4023233417, 2562383102, 271733878, 3285377520)\n        respectively. We will start with this as a message digest. 0x is how you write\n        hexadecimal numbers in Python\n        \"\"\"\n        self.data = data\n        self.h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]\n\n    @staticmethod\n    def rotate(n, b):\n        \"\"\"\n        Static method to be used inside other methods. Left rotates n by b.\n        >>> SHA1Hash('').rotate(12,2)\n        48\n        \"\"\"\n        return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF\n\n    def padding(self):\n        \"\"\"\n        Pads the input message with zeros so that padded_data has 64 bytes or 512 bits\n        \"\"\"\n        padding = b\"\\x80\" + b\"\\x00\" * (63 - (len(self.data) + 8) % 64)\n        padded_data = self.data + padding + struct.pack(\">Q\", 8 * len(self.data))\n        return padded_data\n\n    def split_blocks(self):\n        \"\"\"\n        Returns a list of bytestrings each of length 64\n        \"\"\"\n        return [\n            self.padded_data[i : i + 64] for i in range(0, len(self.padded_data), 64)\n        ]\n\n    # @staticmethod\n    def expand_block(self, block):\n        \"\"\"\n        Takes a bytestring-block of length 64, unpacks it to a list of integers and\n        returns a list of 80 integers after some bit operations\n        \"\"\"\n        w = list(struct.unpack(\">16L\", block)) + [0] * 64\n        for i in range(16, 80):\n            w[i] = self.rotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)\n        return w\n\n    def final_hash(self):\n        \"\"\"\n        Calls all the other methods to process the input. Pads the data, then splits\n        into blocks and then does a series of operations for each block (including\n        expansion).\n        For each block, the variable h that was initialized is copied to a,b,c,d,e\n        and these 5 variables a,b,c,d,e undergo several changes. After all the blocks\n        are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1]\n        and so on. This h becomes our final hash which is returned.\n        \"\"\"\n        self.padded_data = self.padding()\n        self.blocks = self.split_blocks()\n        for block in self.blocks:\n            expanded_block = self.expand_block(block)\n            a, b, c, d, e = self.h\n            for i in range(80):\n                if 0 <= i < 20:\n                    f = (b & c) | ((~b) & d)\n                    k = 0x5A827999\n                elif 20 <= i < 40:\n                    f = b ^ c ^ d\n                    k = 0x6ED9EBA1\n                elif 40 <= i < 60:\n                    f = (b & c) | (b & d) | (c & d)\n                    k = 0x8F1BBCDC\n                elif 60 <= i < 80:\n                    f = b ^ c ^ d\n                    k = 0xCA62C1D6\n                a, b, c, d, e = (\n                    self.rotate(a, 5) + f + e + k + expanded_block[i] & 0xFFFFFFFF,\n                    a,\n                    self.rotate(b, 30),\n                    c,\n                    d,\n                )\n            self.h = (\n                self.h[0] + a & 0xFFFFFFFF,\n                self.h[1] + b & 0xFFFFFFFF,\n                self.h[2] + c & 0xFFFFFFFF,\n                self.h[3] + d & 0xFFFFFFFF,\n                self.h[4] + e & 0xFFFFFFFF,\n            )\n        return (\"{:08x}\" * 5).format(*self.h)\n\n\ndef test_sha1_hash():\n    msg = b\"Test String\"\n    assert SHA1Hash(msg).final_hash() == hashlib.sha1(msg).hexdigest()  # noqa: S324\n\n\ndef main():\n    \"\"\"\n    Provides option 'string' or 'file' to take input and prints the calculated SHA1\n    hash. unittest.main() has been commented out because we probably don't want to run\n    the test each time.\n    \"\"\"\n    # unittest.main()\n    parser = argparse.ArgumentParser(description=\"Process some strings or files\")\n    parser.add_argument(\n        \"--string\",\n        dest=\"input_string\",\n        default=\"Hello World!! Welcome to Cryptography\",\n        help=\"Hash the string\",\n    )\n    parser.add_argument(\"--file\", dest=\"input_file\", help=\"Hash contents of a file\")\n    args = parser.parse_args()\n    input_string = args.input_string\n    # In any case hash input should be a bytestring\n    if args.input_file:\n        with open(args.input_file, \"rb\") as f:\n            hash_input = f.read()\n    else:\n        hash_input = bytes(input_string, \"utf-8\")\n    print(SHA1Hash(hash_input).final_hash())\n\n\nif __name__ == \"__main__\":\n    main()\n    import doctest\n\n    doctest.testmod()\n", "hashes/md5.py": "\"\"\"\nThe MD5 algorithm is a hash function that's commonly used as a checksum to\ndetect data corruption. The algorithm works by processing a given message in\nblocks of 512 bits, padding the message as needed. It uses the blocks to operate\na 128-bit state and performs a total of 64 such operations. Note that all values\nare little-endian, so inputs are converted as needed.\n\nAlthough MD5 was used as a cryptographic hash function in the past, it's since\nbeen cracked, so it shouldn't be used for security purposes.\n\nFor more info, see https://en.wikipedia.org/wiki/MD5\n\"\"\"\n\nfrom collections.abc import Generator\nfrom math import sin\n\n\ndef to_little_endian(string_32: bytes) -> bytes:\n    \"\"\"\n    Converts the given string to little-endian in groups of 8 chars.\n\n    Arguments:\n        string_32 {[string]} -- [32-char string]\n\n    Raises:\n        ValueError -- [input is not 32 char]\n\n    Returns:\n        32-char little-endian string\n    >>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw')\n    b'pqrstuvwhijklmno90abcdfg12345678'\n    >>> to_little_endian(b'1234567890')\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be of length 32\n    \"\"\"\n    if len(string_32) != 32:\n        raise ValueError(\"Input must be of length 32\")\n\n    little_endian = b\"\"\n    for i in [3, 2, 1, 0]:\n        little_endian += string_32[8 * i : 8 * i + 8]\n    return little_endian\n\n\ndef reformat_hex(i: int) -> bytes:\n    \"\"\"\n    Converts the given non-negative integer to hex string.\n\n    Example: Suppose the input is the following:\n        i = 1234\n\n        The input is 0x000004d2 in hex, so the little-endian hex string is\n        \"d2040000\".\n\n    Arguments:\n        i {[int]} -- [integer]\n\n    Raises:\n        ValueError -- [input is negative]\n\n    Returns:\n        8-char little-endian hex string\n\n    >>> reformat_hex(1234)\n    b'd2040000'\n    >>> reformat_hex(666)\n    b'9a020000'\n    >>> reformat_hex(0)\n    b'00000000'\n    >>> reformat_hex(1234567890)\n    b'd2029649'\n    >>> reformat_hex(1234567890987654321)\n    b'b11c6cb1'\n    >>> reformat_hex(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    hex_rep = format(i, \"08x\")[-8:]\n    little_endian_hex = b\"\"\n    for i in [3, 2, 1, 0]:\n        little_endian_hex += hex_rep[2 * i : 2 * i + 2].encode(\"utf-8\")\n    return little_endian_hex\n\n\ndef preprocess(message: bytes) -> bytes:\n    \"\"\"\n    Preprocesses the message string:\n    - Convert message to bit string\n    - Pad bit string to a multiple of 512 chars:\n        - Append a 1\n        - Append 0's until length = 448 (mod 512)\n        - Append length of original message (64 chars)\n\n    Example: Suppose the input is the following:\n        message = \"a\"\n\n        The message bit string is \"01100001\", which is 8 bits long. Thus, the\n        bit string needs 439 bits of padding so that\n        (bit_string + \"1\" + padding) = 448 (mod 512).\n        The message length is \"000010000...0\" in 64-bit little-endian binary.\n        The combined bit string is then 512 bits long.\n\n    Arguments:\n        message {[string]} -- [message string]\n\n    Returns:\n        processed bit string padded to a multiple of 512 chars\n\n    >>> preprocess(b\"a\") == (b\"01100001\" + b\"1\" +\n    ...                     (b\"0\" * 439) + b\"00001000\" + (b\"0\" * 56))\n    True\n    >>> preprocess(b\"\") == b\"1\" + (b\"0\" * 447) + (b\"0\" * 64)\n    True\n    \"\"\"\n    bit_string = b\"\"\n    for char in message:\n        bit_string += format(char, \"08b\").encode(\"utf-8\")\n    start_len = format(len(bit_string), \"064b\").encode(\"utf-8\")\n\n    # Pad bit_string to a multiple of 512 chars\n    bit_string += b\"1\"\n    while len(bit_string) % 512 != 448:\n        bit_string += b\"0\"\n    bit_string += to_little_endian(start_len[32:]) + to_little_endian(start_len[:32])\n\n    return bit_string\n\n\ndef get_block_words(bit_string: bytes) -> Generator[list[int], None, None]:\n    \"\"\"\n    Splits bit string into blocks of 512 chars and yields each block as a list\n    of 32-bit words\n\n    Example: Suppose the input is the following:\n        bit_string =\n            \"000000000...0\" +  # 0x00 (32 bits, padded to the right)\n            \"000000010...0\" +  # 0x01 (32 bits, padded to the right)\n            \"000000100...0\" +  # 0x02 (32 bits, padded to the right)\n            \"000000110...0\" +  # 0x03 (32 bits, padded to the right)\n            ...\n            \"000011110...0\"    # 0x0a (32 bits, padded to the right)\n\n        Then len(bit_string) == 512, so there'll be 1 block. The block is split\n        into 32-bit words, and each word is converted to little endian. The\n        first word is interpreted as 0 in decimal, the second word is\n        interpreted as 1 in decimal, etc.\n\n        Thus, block_words == [[0, 1, 2, 3, ..., 15]].\n\n    Arguments:\n        bit_string {[string]} -- [bit string with multiple of 512 as length]\n\n    Raises:\n        ValueError -- [length of bit string isn't multiple of 512]\n\n    Yields:\n        a list of 16 32-bit words\n\n    >>> test_string = (\"\".join(format(n << 24, \"032b\") for n in range(16))\n    ...                  .encode(\"utf-8\"))\n    >>> list(get_block_words(test_string))\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]\n    >>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4\n    True\n    >>> list(get_block_words(b\"1\" * 512)) == [[4294967295] * 16]\n    True\n    >>> list(get_block_words(b\"\"))\n    []\n    >>> list(get_block_words(b\"1111\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must have length that's a multiple of 512\n    \"\"\"\n    if len(bit_string) % 512 != 0:\n        raise ValueError(\"Input must have length that's a multiple of 512\")\n\n    for pos in range(0, len(bit_string), 512):\n        block = bit_string[pos : pos + 512]\n        block_words = []\n        for i in range(0, 512, 32):\n            block_words.append(int(to_little_endian(block[i : i + 32]), 2))\n        yield block_words\n\n\ndef not_32(i: int) -> int:\n    \"\"\"\n    Perform bitwise NOT on given int.\n\n    Arguments:\n        i {[int]} -- [given int]\n\n    Raises:\n        ValueError -- [input is negative]\n\n    Returns:\n        Result of bitwise NOT on i\n\n    >>> not_32(34)\n    4294967261\n    >>> not_32(1234)\n    4294966061\n    >>> not_32(4294966061)\n    1234\n    >>> not_32(0)\n    4294967295\n    >>> not_32(1)\n    4294967294\n    >>> not_32(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n\n    i_str = format(i, \"032b\")\n    new_str = \"\"\n    for c in i_str:\n        new_str += \"1\" if c == \"0\" else \"0\"\n    return int(new_str, 2)\n\n\ndef sum_32(a: int, b: int) -> int:\n    \"\"\"\n    Add two numbers as 32-bit ints.\n\n    Arguments:\n        a {[int]} -- [first given int]\n        b {[int]} -- [second given int]\n\n    Returns:\n        (a + b) as an unsigned 32-bit int\n\n    >>> sum_32(1, 1)\n    2\n    >>> sum_32(2, 3)\n    5\n    >>> sum_32(0, 0)\n    0\n    >>> sum_32(-1, -1)\n    4294967294\n    >>> sum_32(4294967295, 1)\n    0\n    \"\"\"\n    return (a + b) % 2**32\n\n\ndef left_rotate_32(i: int, shift: int) -> int:\n    \"\"\"\n    Rotate the bits of a given int left by a given amount.\n\n    Arguments:\n        i {[int]} -- [given int]\n        shift {[int]} -- [shift amount]\n\n    Raises:\n        ValueError -- [either given int or shift is negative]\n\n    Returns:\n        `i` rotated to the left by `shift` bits\n\n    >>> left_rotate_32(1234, 1)\n    2468\n    >>> left_rotate_32(1111, 4)\n    17776\n    >>> left_rotate_32(2147483648, 1)\n    1\n    >>> left_rotate_32(2147483648, 3)\n    4\n    >>> left_rotate_32(4294967295, 4)\n    4294967295\n    >>> left_rotate_32(1234, 0)\n    1234\n    >>> left_rotate_32(0, 0)\n    0\n    >>> left_rotate_32(-1, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be non-negative\n    >>> left_rotate_32(0, -1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Shift must be non-negative\n    \"\"\"\n    if i < 0:\n        raise ValueError(\"Input must be non-negative\")\n    if shift < 0:\n        raise ValueError(\"Shift must be non-negative\")\n    return ((i << shift) ^ (i >> (32 - shift))) % 2**32\n\n\ndef md5_me(message: bytes) -> bytes:\n    \"\"\"\n    Returns the 32-char MD5 hash of a given message.\n\n    Reference: https://en.wikipedia.org/wiki/MD5#Algorithm\n\n    Arguments:\n        message {[string]} -- [message]\n\n    Returns:\n        32-char MD5 hash string\n\n    >>> md5_me(b\"\")\n    b'd41d8cd98f00b204e9800998ecf8427e'\n    >>> md5_me(b\"The quick brown fox jumps over the lazy dog\")\n    b'9e107d9d372bb6826bd81d3542a419d6'\n    >>> md5_me(b\"The quick brown fox jumps over the lazy dog.\")\n    b'e4d909c290d0fb1ca068ffaddf22cbd0'\n\n    >>> import hashlib\n    >>> from string import ascii_letters\n    >>> msgs = [b\"\", ascii_letters.encode(\"utf-8\"), \"\u00dc\u00f1\u00ee\u00e7\u00f8\u2202\u00e9\".encode(\"utf-8\"),\n    ...         b\"The quick brown fox jumps over the lazy dog.\"]\n    >>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode(\"utf-8\") for msg in msgs)\n    True\n    \"\"\"\n\n    # Convert to bit string, add padding and append message length\n    bit_string = preprocess(message)\n\n    added_consts = [int(2**32 * abs(sin(i + 1))) for i in range(64)]\n\n    # Starting states\n    a0 = 0x67452301\n    b0 = 0xEFCDAB89\n    c0 = 0x98BADCFE\n    d0 = 0x10325476\n\n    shift_amounts = [\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        7,\n        12,\n        17,\n        22,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        5,\n        9,\n        14,\n        20,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        4,\n        11,\n        16,\n        23,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n        6,\n        10,\n        15,\n        21,\n    ]\n\n    # Process bit string in chunks, each with 16 32-char words\n    for block_words in get_block_words(bit_string):\n        a = a0\n        b = b0\n        c = c0\n        d = d0\n\n        # Hash current chunk\n        for i in range(64):\n            if i <= 15:\n                # f = (b & c) | (not_32(b) & d)     # Alternate definition for f\n                f = d ^ (b & (c ^ d))\n                g = i\n            elif i <= 31:\n                # f = (d & b) | (not_32(d) & c)     # Alternate definition for f\n                f = c ^ (d & (b ^ c))\n                g = (5 * i + 1) % 16\n            elif i <= 47:\n                f = b ^ c ^ d\n                g = (3 * i + 5) % 16\n            else:\n                f = c ^ (b | not_32(d))\n                g = (7 * i) % 16\n            f = (f + a + added_consts[i] + block_words[g]) % 2**32\n            a = d\n            d = c\n            c = b\n            b = sum_32(b, left_rotate_32(f, shift_amounts[i]))\n\n        # Add hashed chunk to running total\n        a0 = sum_32(a0, a)\n        b0 = sum_32(b0, b)\n        c0 = sum_32(c0, c)\n        d0 = sum_32(d0, d)\n\n    digest = reformat_hex(a0) + reformat_hex(b0) + reformat_hex(c0) + reformat_hex(d0)\n    return digest\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "hashes/adler32.py": "\"\"\"\nAdler-32 is a checksum algorithm which was invented by Mark Adler in 1995.\nCompared to a cyclic redundancy check of the same length, it trades reliability for\nspeed (preferring the latter).\nAdler-32 is more reliable than Fletcher-16, and slightly less reliable than\nFletcher-32.[2]\n\nsource: https://en.wikipedia.org/wiki/Adler-32\n\"\"\"\n\nMOD_ADLER = 65521\n\n\ndef adler32(plain_text: str) -> int:\n    \"\"\"\n    Function implements adler-32 hash.\n    Iterates and evaluates a new value for each character\n\n    >>> adler32('Algorithms')\n    363791387\n\n    >>> adler32('go adler em all')\n    708642122\n    \"\"\"\n    a = 1\n    b = 0\n    for plain_chr in plain_text:\n        a = (a + ord(plain_chr)) % MOD_ADLER\n        b = (b + a) % MOD_ADLER\n    return (b << 16) | a\n", "hashes/fletcher16.py": "\"\"\"\nThe Fletcher checksum is an algorithm for computing a position-dependent\nchecksum devised by John G. Fletcher (1934-2012) at Lawrence Livermore Labs\nin the late 1970s.[1] The objective of the Fletcher checksum was to\nprovide error-detection properties approaching those of a cyclic\nredundancy check but with the lower computational effort associated\nwith summation techniques.\n\nSource: https://en.wikipedia.org/wiki/Fletcher%27s_checksum\n\"\"\"\n\n\ndef fletcher16(text: str) -> int:\n    \"\"\"\n    Loop through every character in the data and add to two sums.\n\n    >>> fletcher16('hello world')\n    6752\n    >>> fletcher16('onethousandfourhundredthirtyfour')\n    28347\n    >>> fletcher16('The quick brown fox jumps over the lazy dog.')\n    5655\n    \"\"\"\n    data = bytes(text, \"ascii\")\n    sum1 = 0\n    sum2 = 0\n    for character in data:\n        sum1 = (sum1 + character) % 255\n        sum2 = (sum1 + sum2) % 255\n    return (sum2 << 8) | sum1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "hashes/__init__.py": "", "hashes/sdbm.py": "\"\"\"\nThis algorithm was created for sdbm (a public-domain reimplementation of ndbm)\ndatabase library.\nIt was found to do well in scrambling bits, causing better distribution of the keys\nand fewer splits.\nIt also happens to be a good general hashing function with good distribution.\nThe actual function (pseudo code) is:\n    for i in i..len(str):\n        hash(i) = hash(i - 1) * 65599 + str[i];\n\nWhat is included below is the faster version used in gawk. [there is even a faster,\nduff-device version]\nThe magic constant 65599 was picked out of thin air while experimenting with\ndifferent constants.\nIt turns out to be a prime.\nThis is one of the algorithms used in berkeley db (see sleepycat) and elsewhere.\n\nsource: http://www.cse.yorku.ca/~oz/hash.html\n\"\"\"\n\n\ndef sdbm(plain_text: str) -> int:\n    \"\"\"\n    Function implements sdbm hash, easy to use, great for bits scrambling.\n    iterates over each character in the given string and applies function to each of\n    them.\n\n    >>> sdbm('Algorithms')\n    1462174910723540325254304520539387479031000036\n\n    >>> sdbm('scramble bits')\n    730247649148944819640658295400555317318720608290373040936089\n    \"\"\"\n    hash_value = 0\n    for plain_chr in plain_text:\n        hash_value = (\n            ord(plain_chr) + (hash_value << 6) + (hash_value << 16) - hash_value\n        )\n    return hash_value\n", "compression/peak_signal_to_noise_ratio.py": "\"\"\"\nPeak signal-to-noise ratio - PSNR\n    https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio\nSource:\nhttps://tutorials.techonical.com/how-to-calculate-psnr-value-of-two-images-using-python\n\"\"\"\n\nimport math\nimport os\n\nimport cv2\nimport numpy as np\n\nPIXEL_MAX = 255.0\n\n\ndef peak_signal_to_noise_ratio(original: float, contrast: float) -> float:\n    mse = np.mean((original - contrast) ** 2)\n    if mse == 0:\n        return 100\n\n    return 20 * math.log10(PIXEL_MAX / math.sqrt(mse))\n\n\ndef main() -> None:\n    dir_path = os.path.dirname(os.path.realpath(__file__))\n    # Loading images (original image and compressed image)\n    original = cv2.imread(os.path.join(dir_path, \"image_data/original_image.png\"))\n    contrast = cv2.imread(os.path.join(dir_path, \"image_data/compressed_image.png\"), 1)\n\n    original2 = cv2.imread(os.path.join(dir_path, \"image_data/PSNR-example-base.png\"))\n    contrast2 = cv2.imread(\n        os.path.join(dir_path, \"image_data/PSNR-example-comp-10.jpg\"), 1\n    )\n\n    # Value expected: 29.73dB\n    print(\"-- First Test --\")\n    print(f\"PSNR value is {peak_signal_to_noise_ratio(original, contrast)} dB\")\n\n    # # Value expected: 31.53dB (Wikipedia Example)\n    print(\"\\n-- Second Test --\")\n    print(f\"PSNR value is {peak_signal_to_noise_ratio(original2, contrast2)} dB\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "compression/lempel_ziv_decompress.py": "\"\"\"\nOne of the several implementations of Lempel-Ziv-Welch decompression algorithm\nhttps://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n\"\"\"\n\nimport math\nimport sys\n\n\ndef read_file_binary(file_path: str) -> str:\n    \"\"\"\n    Reads given file as bytes and returns them as a long string\n    \"\"\"\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()\n\n\ndef decompress_data(data_bits: str) -> str:\n    \"\"\"\n    Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        lexicon[curr_string] = last_match_id + \"0\"\n\n        if math.log2(index).is_integer():\n            new_lex = {}\n            for curr_key in list(lexicon):\n                new_lex[\"0\" + curr_key] = lexicon.pop(curr_key)\n            lexicon = new_lex\n\n        lexicon[bin(index)[2:]] = last_match_id + \"1\"\n        index += 1\n        curr_string = \"\"\n    return result\n\n\ndef write_file_binary(file_path: str, to_write: str) -> None:\n    \"\"\"\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\n    file\n    \"\"\"\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array[:-1]:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()\n\n\ndef remove_prefix(data_bits: str) -> str:\n    \"\"\"\n    Removes size prefix, that compressed file should have\n    Returns the result\n    \"\"\"\n    counter = 0\n    for letter in data_bits:\n        if letter == \"1\":\n            break\n        counter += 1\n\n    data_bits = data_bits[counter:]\n    data_bits = data_bits[counter + 1 :]\n    return data_bits\n\n\ndef compress(source_path: str, destination_path: str) -> None:\n    \"\"\"\n    Reads source file, decompresses it and writes the result in destination file\n    \"\"\"\n    data_bits = read_file_binary(source_path)\n    data_bits = remove_prefix(data_bits)\n    decompressed = decompress_data(data_bits)\n    write_file_binary(destination_path, decompressed)\n\n\nif __name__ == \"__main__\":\n    compress(sys.argv[1], sys.argv[2])\n", "compression/lz77.py": "\"\"\"\nLZ77 compression algorithm\n- lossless data compression published in papers by Abraham Lempel and Jacob Ziv in 1977\n- also known as LZ1 or sliding-window compression\n- form the basis for many variations including LZW, LZSS, LZMA and others\n\nIt uses a \u201csliding window\u201d method. Within the sliding window we have:\n  - search buffer\n  - look ahead buffer\nlen(sliding_window) = len(search_buffer) + len(look_ahead_buffer)\n\nLZ77 manages a dictionary that uses triples composed of:\n    - Offset into search buffer, it's the distance between the start of a phrase and\n      the beginning of a file.\n    - Length of the match, it's the number of characters that make up a phrase.\n    - The indicator is represented by a character that is going to be encoded next.\n\nAs a file is parsed, the dictionary is dynamically updated to reflect the compressed\ndata contents and size.\n\nExamples:\n\"cabracadabrarrarrad\" <-> [(0, 0, 'c'), (0, 0, 'a'), (0, 0, 'b'), (0, 0, 'r'),\n                           (3, 1, 'c'), (2, 1, 'd'), (7, 4, 'r'), (3, 5, 'd')]\n\"ababcbababaa\" <-> [(0, 0, 'a'), (0, 0, 'b'), (2, 2, 'c'), (4, 3, 'a'), (2, 2, 'a')]\n\"aacaacabcabaaac\" <-> [(0, 0, 'a'), (1, 1, 'c'), (3, 4, 'b'), (3, 3, 'a'), (1, 2, 'c')]\n\nSources:\nen.wikipedia.org/wiki/LZ77_and_LZ78\n\"\"\"\n\nfrom dataclasses import dataclass\n\n__version__ = \"0.1\"\n__author__ = \"Lucia Harcekova\"\n\n\n@dataclass\nclass Token:\n    \"\"\"\n    Dataclass representing triplet called token consisting of length, offset\n    and indicator. This triplet is used during LZ77 compression.\n    \"\"\"\n\n    offset: int\n    length: int\n    indicator: str\n\n    def __repr__(self) -> str:\n        \"\"\"\n        >>> token = Token(1, 2, \"c\")\n        >>> repr(token)\n        '(1, 2, c)'\n        >>> str(token)\n        '(1, 2, c)'\n        \"\"\"\n        return f\"({self.offset}, {self.length}, {self.indicator})\"\n\n\nclass LZ77Compressor:\n    \"\"\"\n    Class containing compress and decompress methods using LZ77 compression algorithm.\n    \"\"\"\n\n    def __init__(self, window_size: int = 13, lookahead_buffer_size: int = 6) -> None:\n        self.window_size = window_size\n        self.lookahead_buffer_size = lookahead_buffer_size\n        self.search_buffer_size = self.window_size - self.lookahead_buffer_size\n\n    def compress(self, text: str) -> list[Token]:\n        \"\"\"\n        Compress the given string text using LZ77 compression algorithm.\n\n        Args:\n            text: string to be compressed\n\n        Returns:\n            output: the compressed text as a list of Tokens\n\n        >>> lz77_compressor = LZ77Compressor()\n        >>> str(lz77_compressor.compress(\"ababcbababaa\"))\n        '[(0, 0, a), (0, 0, b), (2, 2, c), (4, 3, a), (2, 2, a)]'\n        >>> str(lz77_compressor.compress(\"aacaacabcabaaac\"))\n        '[(0, 0, a), (1, 1, c), (3, 4, b), (3, 3, a), (1, 2, c)]'\n        \"\"\"\n\n        output = []\n        search_buffer = \"\"\n\n        # while there are still characters in text to compress\n        while text:\n            # find the next encoding phrase\n            # - triplet with offset, length, indicator (the next encoding character)\n            token = self._find_encoding_token(text, search_buffer)\n\n            # update the search buffer:\n            # - add new characters from text into it\n            # - check if size exceed the max search buffer size, if so, drop the\n            #   oldest elements\n            search_buffer += text[: token.length + 1]\n            if len(search_buffer) > self.search_buffer_size:\n                search_buffer = search_buffer[-self.search_buffer_size :]\n\n            # update the text\n            text = text[token.length + 1 :]\n\n            # append the token to output\n            output.append(token)\n\n        return output\n\n    def decompress(self, tokens: list[Token]) -> str:\n        \"\"\"\n        Convert the list of tokens into an output string.\n\n        Args:\n            tokens: list containing triplets (offset, length, char)\n\n        Returns:\n            output: decompressed text\n\n        Tests:\n            >>> lz77_compressor = LZ77Compressor()\n            >>> lz77_compressor.decompress([Token(0, 0, 'c'), Token(0, 0, 'a'),\n            ... Token(0, 0, 'b'), Token(0, 0, 'r'), Token(3, 1, 'c'),\n            ... Token(2, 1, 'd'), Token(7, 4, 'r'), Token(3, 5, 'd')])\n            'cabracadabrarrarrad'\n            >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(0, 0, 'b'),\n            ... Token(2, 2, 'c'), Token(4, 3, 'a'), Token(2, 2, 'a')])\n            'ababcbababaa'\n            >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(1, 1, 'c'),\n            ... Token(3, 4, 'b'), Token(3, 3, 'a'), Token(1, 2, 'c')])\n            'aacaacabcabaaac'\n        \"\"\"\n\n        output = \"\"\n\n        for token in tokens:\n            for _ in range(token.length):\n                output += output[-token.offset]\n            output += token.indicator\n\n        return output\n\n    def _find_encoding_token(self, text: str, search_buffer: str) -> Token:\n        \"\"\"Finds the encoding token for the first character in the text.\n\n        Tests:\n            >>> lz77_compressor = LZ77Compressor()\n            >>> lz77_compressor._find_encoding_token(\"abrarrarrad\", \"abracad\").offset\n            7\n            >>> lz77_compressor._find_encoding_token(\"adabrarrarrad\", \"cabrac\").length\n            1\n            >>> lz77_compressor._find_encoding_token(\"abc\", \"xyz\").offset\n            0\n            >>> lz77_compressor._find_encoding_token(\"\", \"xyz\").offset\n            Traceback (most recent call last):\n                ...\n            ValueError: We need some text to work with.\n            >>> lz77_compressor._find_encoding_token(\"abc\", \"\").offset\n            0\n        \"\"\"\n\n        if not text:\n            raise ValueError(\"We need some text to work with.\")\n\n        # Initialise result parameters to default values\n        length, offset = 0, 0\n\n        if not search_buffer:\n            return Token(offset, length, text[length])\n\n        for i, character in enumerate(search_buffer):\n            found_offset = len(search_buffer) - i\n            if character == text[0]:\n                found_length = self._match_length_from_index(text, search_buffer, 0, i)\n                # if the found length is bigger than the current or if it's equal,\n                # which means it's offset is smaller: update offset and length\n                if found_length >= length:\n                    offset, length = found_offset, found_length\n\n        return Token(offset, length, text[length])\n\n    def _match_length_from_index(\n        self, text: str, window: str, text_index: int, window_index: int\n    ) -> int:\n        \"\"\"Calculate the longest possible match of text and window characters from\n        text_index in text and window_index in window.\n\n        Args:\n            text: _description_\n            window: sliding window\n            text_index: index of character in text\n            window_index: index of character in sliding window\n\n        Returns:\n            The maximum match between text and window, from given indexes.\n\n        Tests:\n            >>> lz77_compressor = LZ77Compressor(13, 6)\n            >>> lz77_compressor._match_length_from_index(\"rarrad\", \"adabrar\", 0, 4)\n            5\n            >>> lz77_compressor._match_length_from_index(\"adabrarrarrad\",\n            ...     \"cabrac\", 0, 1)\n            1\n        \"\"\"\n        if not text or text[text_index] != window[window_index]:\n            return 0\n        return 1 + self._match_length_from_index(\n            text, window + text[text_index], text_index + 1, window_index + 1\n        )\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    # Initialize compressor class\n    lz77_compressor = LZ77Compressor(window_size=13, lookahead_buffer_size=6)\n\n    # Example\n    TEXT = \"cabracadabrarrarrad\"\n    compressed_text = lz77_compressor.compress(TEXT)\n    print(lz77_compressor.compress(\"ababcbababaa\"))\n    decompressed_text = lz77_compressor.decompress(compressed_text)\n    assert decompressed_text == TEXT, \"The LZ77 algorithm returned the invalid result.\"\n", "compression/burrows_wheeler.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform\n\nThe Burrows-Wheeler transform (BWT, also called block-sorting compression)\nrearranges a character string into runs of similar characters. This is useful\nfor compression, since it tends to be easy to compress a string that has runs\nof repeated characters by techniques such as move-to-front transform and\nrun-length encoding. More importantly, the transformation is reversible,\nwithout needing to store any additional data except the position of the first\noriginal character. The BWT is thus a \"free\" method of improving the efficiency\nof text compression algorithms, costing only some extra computation.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TypedDict\n\n\nclass BWTTransformDict(TypedDict):\n    bwt_string: str\n    idx_original_string: int\n\n\ndef all_rotations(s: str) -> list[str]:\n    \"\"\"\n    :param s: The string that will be rotated len(s) times.\n    :return: A list with the rotations.\n    :raises TypeError: If s is not an instance of str.\n    Examples:\n\n    >>> all_rotations(\"^BANANA|\") # doctest: +NORMALIZE_WHITESPACE\n    ['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',\n    'A|^BANAN', '|^BANANA']\n    >>> all_rotations(\"a_asa_da_casa\") # doctest: +NORMALIZE_WHITESPACE\n    ['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',\n    'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',\n    '_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',\n    'aa_asa_da_cas']\n    >>> all_rotations(\"panamabanana\") # doctest: +NORMALIZE_WHITESPACE\n    ['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',\n    'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',\n    'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']\n    >>> all_rotations(5)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter s type must be str.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n\n    return [s[i:] + s[:i] for i in range(len(s))]\n\n\ndef bwt_transform(s: str) -> BWTTransformDict:\n    \"\"\"\n    :param s: The string that will be used at bwt algorithm\n    :return: the string composed of the last char of each row of the ordered\n    rotations and the index of the original string at ordered rotations list\n    :raises TypeError: If the s parameter type is not str\n    :raises ValueError: If the s parameter is empty\n    Examples:\n\n    >>> bwt_transform(\"^BANANA\")\n    {'bwt_string': 'BNN^AAA', 'idx_original_string': 6}\n    >>> bwt_transform(\"a_asa_da_casa\")\n    {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}\n    >>> bwt_transform(\"panamabanana\")\n    {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}\n    >>> bwt_transform(4)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter s type must be str.\n    >>> bwt_transform('')\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter s must not be empty.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"The parameter s type must be str.\")\n    if not s:\n        raise ValueError(\"The parameter s must not be empty.\")\n\n    rotations = all_rotations(s)\n    rotations.sort()  # sort the list of rotations in alphabetically order\n    # make a string composed of the last char of each rotation\n    response: BWTTransformDict = {\n        \"bwt_string\": \"\".join([word[-1] for word in rotations]),\n        \"idx_original_string\": rotations.index(s),\n    }\n    return response\n\n\ndef reverse_bwt(bwt_string: str, idx_original_string: int) -> str:\n    \"\"\"\n    :param bwt_string: The string returned from bwt algorithm execution\n    :param idx_original_string: A 0-based index of the string that was used to\n    generate bwt_string at ordered rotations list\n    :return: The string used to generate bwt_string when bwt was executed\n    :raises TypeError: If the bwt_string parameter type is not str\n    :raises ValueError: If the bwt_string parameter is empty\n    :raises TypeError: If the idx_original_string type is not int or if not\n    possible to cast it to int\n    :raises ValueError: If the idx_original_string value is lower than 0 or\n    greater than len(bwt_string) - 1\n\n    >>> reverse_bwt(\"BNN^AAA\", 6)\n    '^BANANA'\n    >>> reverse_bwt(\"aaaadss_c__aa\", 3)\n    'a_asa_da_casa'\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11)\n    'panamabanana'\n    >>> reverse_bwt(4, 11)\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter bwt_string type must be str.\n    >>> reverse_bwt(\"\", 11)\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter bwt_string must not be empty.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", \"asd\") # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: The parameter idx_original_string type must be int or passive\n    of cast to int.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter idx_original_string must not be lower than 0.\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 12) # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: The parameter idx_original_string must be lower than\n    len(bwt_string).\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11.0)\n    'panamabanana'\n    >>> reverse_bwt(\"mnpbnnaaaaaa\", 11.4)\n    'panamabanana'\n    \"\"\"\n    if not isinstance(bwt_string, str):\n        raise TypeError(\"The parameter bwt_string type must be str.\")\n    if not bwt_string:\n        raise ValueError(\"The parameter bwt_string must not be empty.\")\n    try:\n        idx_original_string = int(idx_original_string)\n    except ValueError:\n        raise TypeError(\n            \"The parameter idx_original_string type must be int or passive\"\n            \" of cast to int.\"\n        )\n    if idx_original_string < 0:\n        raise ValueError(\"The parameter idx_original_string must not be lower than 0.\")\n    if idx_original_string >= len(bwt_string):\n        raise ValueError(\n            \"The parameter idx_original_string must be lower than len(bwt_string).\"\n        )\n\n    ordered_rotations = [\"\"] * len(bwt_string)\n    for _ in range(len(bwt_string)):\n        for i in range(len(bwt_string)):\n            ordered_rotations[i] = bwt_string[i] + ordered_rotations[i]\n        ordered_rotations.sort()\n    return ordered_rotations[idx_original_string]\n\n\nif __name__ == \"__main__\":\n    entry_msg = \"Provide a string that I will generate its BWT transform: \"\n    s = input(entry_msg).strip()\n    result = bwt_transform(s)\n    print(\n        f\"Burrows Wheeler transform for string '{s}' results \"\n        f\"in '{result['bwt_string']}'\"\n    )\n    original_string = reverse_bwt(result[\"bwt_string\"], result[\"idx_original_string\"])\n    print(\n        f\"Reversing Burrows Wheeler transform for entry '{result['bwt_string']}' \"\n        f\"we get original string '{original_string}'\"\n    )\n", "compression/huffman.py": "from __future__ import annotations\n\nimport sys\n\n\nclass Letter:\n    def __init__(self, letter: str, freq: int):\n        self.letter: str = letter\n        self.freq: int = freq\n        self.bitstring: dict[str, str] = {}\n\n    def __repr__(self) -> str:\n        return f\"{self.letter}:{self.freq}\"\n\n\nclass TreeNode:\n    def __init__(self, freq: int, left: Letter | TreeNode, right: Letter | TreeNode):\n        self.freq: int = freq\n        self.left: Letter | TreeNode = left\n        self.right: Letter | TreeNode = right\n\n\ndef parse_file(file_path: str) -> list[Letter]:\n    \"\"\"\n    Read the file and build a dict of all letters and their\n    frequencies, then convert the dict into a list of Letters.\n    \"\"\"\n    chars: dict[str, int] = {}\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            chars[c] = chars[c] + 1 if c in chars else 1\n    return sorted((Letter(c, f) for c, f in chars.items()), key=lambda x: x.freq)\n\n\ndef build_tree(letters: list[Letter]) -> Letter | TreeNode:\n    \"\"\"\n    Run through the list of Letters and build the min heap\n    for the Huffman Tree.\n    \"\"\"\n    response: list[Letter | TreeNode] = list(letters)\n    while len(response) > 1:\n        left = response.pop(0)\n        right = response.pop(0)\n        total_freq = left.freq + right.freq\n        node = TreeNode(total_freq, left, right)\n        response.append(node)\n        response.sort(key=lambda x: x.freq)\n    return response[0]\n\n\ndef traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]:\n    \"\"\"\n    Recursively traverse the Huffman Tree to set each\n    Letter's bitstring dictionary, and return the list of Letters\n    \"\"\"\n    if isinstance(root, Letter):\n        root.bitstring[root.letter] = bitstring\n        return [root]\n    treenode: TreeNode = root\n    letters = []\n    letters += traverse_tree(treenode.left, bitstring + \"0\")\n    letters += traverse_tree(treenode.right, bitstring + \"1\")\n    return letters\n\n\ndef huffman(file_path: str) -> None:\n    \"\"\"\n    Parse the file, build the tree, then run through the file\n    again, using the letters dictionary to find and print out the\n    bitstring for each letter.\n    \"\"\"\n    letters_list = parse_file(file_path)\n    root = build_tree(letters_list)\n    letters = {\n        k: v for letter in traverse_tree(root, \"\") for k, v in letter.bitstring.items()\n    }\n    print(f\"Huffman Coding  of {file_path}: \")\n    with open(file_path) as f:\n        while True:\n            c = f.read(1)\n            if not c:\n                break\n            print(letters[c], end=\" \")\n    print()\n\n\nif __name__ == \"__main__\":\n    # pass the file path to the huffman function\n    huffman(sys.argv[1])\n", "compression/__init__.py": "", "compression/run_length_encoding.py": "# https://en.wikipedia.org/wiki/Run-length_encoding\n\n\ndef run_length_encode(text: str) -> list:\n    \"\"\"\n    Performs Run Length Encoding\n    >>> run_length_encode(\"AAAABBBCCDAA\")\n    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]\n    >>> run_length_encode(\"A\")\n    [('A', 1)]\n    >>> run_length_encode(\"AA\")\n    [('A', 2)]\n    >>> run_length_encode(\"AAADDDDDDFFFCCCAAVVVV\")\n    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]\n    \"\"\"\n    encoded = []\n    count = 1\n\n    for i in range(len(text)):\n        if i + 1 < len(text) and text[i] == text[i + 1]:\n            count += 1\n        else:\n            encoded.append((text[i], count))\n            count = 1\n\n    return encoded\n\n\ndef run_length_decode(encoded: list) -> str:\n    \"\"\"\n    Performs Run Length Decoding\n    >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])\n    'AAAABBBCCDAA'\n    >>> run_length_decode([('A', 1)])\n    'A'\n    >>> run_length_decode([('A', 2)])\n    'AA'\n    >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])\n    'AAADDDDDDFFFCCCAAVVVV'\n    \"\"\"\n    return \"\".join(char * length for char, length in encoded)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"run_length_encode\", verbose=True)\n    testmod(name=\"run_length_decode\", verbose=True)\n", "compression/lempel_ziv.py": "\"\"\"\nOne of the several implementations of Lempel-Ziv-Welch compression algorithm\nhttps://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch\n\"\"\"\n\nimport math\nimport os\nimport sys\n\n\ndef read_file_binary(file_path: str) -> str:\n    \"\"\"\n    Reads given file as bytes and returns them as a long string\n    \"\"\"\n    result = \"\"\n    try:\n        with open(file_path, \"rb\") as binary_file:\n            data = binary_file.read()\n        for dat in data:\n            curr_byte = f\"{dat:08b}\"\n            result += curr_byte\n        return result\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()\n\n\ndef add_key_to_lexicon(\n    lexicon: dict[str, str], curr_string: str, index: int, last_match_id: str\n) -> None:\n    \"\"\"\n    Adds new strings (curr_string + \"0\",  curr_string + \"1\") to the lexicon\n    \"\"\"\n    lexicon.pop(curr_string)\n    lexicon[curr_string + \"0\"] = last_match_id\n\n    if math.log2(index).is_integer():\n        for curr_key in lexicon:\n            lexicon[curr_key] = \"0\" + lexicon[curr_key]\n\n    lexicon[curr_string + \"1\"] = bin(index)[2:]\n\n\ndef compress_data(data_bits: str) -> str:\n    \"\"\"\n    Compresses given data_bits using Lempel-Ziv-Welch compression algorithm\n    and returns the result as a string\n    \"\"\"\n    lexicon = {\"0\": \"0\", \"1\": \"1\"}\n    result, curr_string = \"\", \"\"\n    index = len(lexicon)\n\n    for i in range(len(data_bits)):\n        curr_string += data_bits[i]\n        if curr_string not in lexicon:\n            continue\n\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n        add_key_to_lexicon(lexicon, curr_string, index, last_match_id)\n        index += 1\n        curr_string = \"\"\n\n    while curr_string != \"\" and curr_string not in lexicon:\n        curr_string += \"0\"\n\n    if curr_string != \"\":\n        last_match_id = lexicon[curr_string]\n        result += last_match_id\n\n    return result\n\n\ndef add_file_length(source_path: str, compressed: str) -> str:\n    \"\"\"\n    Adds given file's length in front (using Elias  gamma coding) of the compressed\n    string\n    \"\"\"\n    file_length = os.path.getsize(source_path)\n    file_length_binary = bin(file_length)[2:]\n    length_length = len(file_length_binary)\n\n    return \"0\" * (length_length - 1) + file_length_binary + compressed\n\n\ndef write_file_binary(file_path: str, to_write: str) -> None:\n    \"\"\"\n    Writes given to_write string (should only consist of 0's and 1's) as bytes in the\n    file\n    \"\"\"\n    byte_length = 8\n    try:\n        with open(file_path, \"wb\") as opened_file:\n            result_byte_array = [\n                to_write[i : i + byte_length]\n                for i in range(0, len(to_write), byte_length)\n            ]\n\n            if len(result_byte_array[-1]) % byte_length == 0:\n                result_byte_array.append(\"10000000\")\n            else:\n                result_byte_array[-1] += \"1\" + \"0\" * (\n                    byte_length - len(result_byte_array[-1]) - 1\n                )\n\n            for elem in result_byte_array:\n                opened_file.write(int(elem, 2).to_bytes(1, byteorder=\"big\"))\n    except OSError:\n        print(\"File not accessible\")\n        sys.exit()\n\n\ndef compress(source_path: str, destination_path: str) -> None:\n    \"\"\"\n    Reads source file, compresses it and writes the compressed result in destination\n    file\n    \"\"\"\n    data_bits = read_file_binary(source_path)\n    compressed = compress_data(data_bits)\n    compressed = add_file_length(source_path, compressed)\n    write_file_binary(destination_path, compressed)\n\n\nif __name__ == \"__main__\":\n    compress(sys.argv[1], sys.argv[2])\n", "geodesy/lamberts_ellipsoidal_distance.py": "from math import atan, cos, radians, sin, tan\n\nfrom .haversine_distance import haversine_distance\n\nAXIS_A = 6378137.0\nAXIS_B = 6356752.314245\nEQUATORIAL_RADIUS = 6378137\n\n\ndef lamberts_ellipsoidal_distance(\n    lat1: float, lon1: float, lat2: float, lon2: float\n) -> float:\n    \"\"\"\n    Calculate the shortest distance along the surface of an ellipsoid between\n    two points on the surface of earth given longitudes and latitudes\n    https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\n\n    NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,\n        sigma\n\n    Representing the earth as an ellipsoid allows us to approximate distances between\n    points on the surface much better than a sphere. Ellipsoidal formulas treat the\n    Earth as an oblate ellipsoid which means accounting for the flattening that happens\n    at the North and South poles. Lambert's formulae provide accuracy on the order of\n    10 meteres over thousands of kilometeres. Other methods can provide\n    millimeter-level accuracy but this is a simpler method to calculate long range\n    distances without increasing computational intensity.\n\n    Args:\n        lat1, lon1: latitude and longitude of coordinate 1\n        lat2, lon2: latitude and longitude of coordinate 2\n    Returns:\n        geographical distance between two points in metres\n\n    >>> from collections import namedtuple\n    >>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\n    >>> NEW_YORK = point_2d(40.713019, -74.012647)\n    >>> VENICE = point_2d(45.443012, 12.313071)\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n    '254,351 meters'\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters\"\n    '4,138,992 meters'\n    >>> f\"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters\"\n    '9,737,326 meters'\n    \"\"\"\n\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\n    # Distance in metres(m)\n    # Equation Parameters\n    # https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\n    # Parametric latitudes\n    # https://en.wikipedia.org/wiki/Latitude#Parametric_(or_reduced)_latitude\n    b_lat1 = atan((1 - flattening) * tan(radians(lat1)))\n    b_lat2 = atan((1 - flattening) * tan(radians(lat2)))\n\n    # Compute central angle between two points\n    # using haversine theta. sigma =  haversine_distance / equatorial radius\n    sigma = haversine_distance(lat1, lon1, lat2, lon2) / EQUATORIAL_RADIUS\n\n    # Intermediate P and Q values\n    p_value = (b_lat1 + b_lat2) / 2\n    q_value = (b_lat2 - b_lat1) / 2\n\n    # Intermediate X value\n    # X = (sigma - sin(sigma)) * sin^2Pcos^2Q / cos^2(sigma/2)\n    x_numerator = (sin(p_value) ** 2) * (cos(q_value) ** 2)\n    x_demonimator = cos(sigma / 2) ** 2\n    x_value = (sigma - sin(sigma)) * (x_numerator / x_demonimator)\n\n    # Intermediate Y value\n    # Y = (sigma + sin(sigma)) * cos^2Psin^2Q / sin^2(sigma/2)\n    y_numerator = (cos(p_value) ** 2) * (sin(q_value) ** 2)\n    y_denominator = sin(sigma / 2) ** 2\n    y_value = (sigma + sin(sigma)) * (y_numerator / y_denominator)\n\n    return EQUATORIAL_RADIUS * (sigma - ((flattening / 2) * (x_value + y_value)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "geodesy/haversine_distance.py": "from math import asin, atan, cos, radians, sin, sqrt, tan\n\nAXIS_A = 6378137.0\nAXIS_B = 6356752.314245\nRADIUS = 6378137\n\n\ndef haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    Calculate great circle distance between two points in a sphere,\n    given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula\n\n    We know that the globe is \"sort of\" spherical, so a path between two points\n    isn't exactly a straight line. We need to account for the Earth's curvature\n    when calculating distance from point A to B. This effect is negligible for\n    small distances but adds up as distance increases. The Haversine method treats\n    the earth as a sphere which allows us to \"project\" the two points A and B\n    onto the surface of that sphere and approximate the spherical distance between\n    them. Since the Earth is not a perfect sphere, other methods which model the\n    Earth's ellipsoidal nature are more accurate but a quick and modifiable\n    computation like Haversine can be handy for shorter range distances.\n\n    Args:\n        lat1, lon1: latitude and longitude of coordinate 1\n        lat2, lon2: latitude and longitude of coordinate 2\n    Returns:\n        geographical distance between two points in metres\n    >>> from collections import namedtuple\n    >>> point_2d = namedtuple(\"point_2d\", \"lat lon\")\n    >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)\n    >>> YOSEMITE = point_2d(37.864742, -119.537521)\n    >>> f\"{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters\"\n    '254,352 meters'\n    \"\"\"\n    # CONSTANTS per WGS84 https://en.wikipedia.org/wiki/World_Geodetic_System\n    # Distance in metres(m)\n    # Equation parameters\n    # Equation https://en.wikipedia.org/wiki/Haversine_formula#Formulation\n    flattening = (AXIS_A - AXIS_B) / AXIS_A\n    phi_1 = atan((1 - flattening) * tan(radians(lat1)))\n    phi_2 = atan((1 - flattening) * tan(radians(lat2)))\n    lambda_1 = radians(lon1)\n    lambda_2 = radians(lon2)\n    # Equation\n    sin_sq_phi = sin((phi_2 - phi_1) / 2)\n    sin_sq_lambda = sin((lambda_2 - lambda_1) / 2)\n    # Square both values\n    sin_sq_phi *= sin_sq_phi\n    sin_sq_lambda *= sin_sq_lambda\n    h_value = sqrt(sin_sq_phi + (cos(phi_1) * cos(phi_2) * sin_sq_lambda))\n    return 2 * RADIUS * asin(h_value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "geodesy/__init__.py": "", "backtracking/sum_of_subsets.py": "\"\"\"\nThe sum-of-subsetsproblem states that a set of non-negative integers, and a\nvalue M, determine all possible subsets of the given set whose summation sum\nequal to given M.\n\nSummation of the chosen numbers must be equal to given number M and one number\ncan be used only once.\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef generate_sum_of_subsets_soln(nums: list[int], max_sum: int) -> list[list[int]]:\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result\n\n\ndef create_state_space_tree(\n    nums: list[int],\n    max_sum: int,\n    num_index: int,\n    path: list[int],\n    result: list[list[int]],\n    remaining_nums_sum: int,\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    It terminates the branching of a node when any of the two conditions\n    given below satisfy.\n    This algorithm follows depth-fist-search and backtracks when the node is not\n    branchable.\n\n    \"\"\"\n    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:\n        return\n    if sum(path) == max_sum:\n        result.append(path)\n        return\n    for index in range(num_index, len(nums)):\n        create_state_space_tree(\n            nums,\n            max_sum,\n            index + 1,\n            [*path, nums[index]],\n            result,\n            remaining_nums_sum - nums[index],\n        )\n\n\n\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nnums = list(map(int, input().split()))\nprint(\"Enter max_sum sum\")\nmax_sum = int(input())\n\n\"\"\"\nnums = [3, 34, 4, 12, 5, 2]\nmax_sum = 9\nresult = generate_sum_of_subsets_soln(nums, max_sum)\nprint(*result)\n", "backtracking/power_sum.py": "\"\"\"\nProblem source: https://www.hackerrank.com/challenges/the-power-sum/problem\nFind the number of ways that a given integer X, can be expressed as the sum\nof the Nth powers of unique, natural numbers. For example, if X=13 and N=2.\nWe have to find all combinations of unique squares adding up to 13.\nThe only solution is 2^2+3^2. Constraints: 1<=X<=1000, 2<=N<=10.\n\"\"\"\n\n\ndef backtrack(\n    needed_sum: int,\n    power: int,\n    current_number: int,\n    current_sum: int,\n    solutions_count: int,\n) -> tuple[int, int]:\n    \"\"\"\n    >>> backtrack(13, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(10, 3, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(20, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(15, 10, 1, 0, 0)\n    (0, 0)\n    >>> backtrack(16, 2, 1, 0, 0)\n    (0, 1)\n    >>> backtrack(20, 1, 1, 0, 0)\n    (0, 64)\n    \"\"\"\n    if current_sum == needed_sum:\n        # If the sum of the powers is equal to needed_sum, then we have a solution.\n        solutions_count += 1\n        return current_sum, solutions_count\n\n    i_to_n = current_number**power\n    if current_sum + i_to_n <= needed_sum:\n        # If the sum of the powers is less than needed_sum, then continue adding powers.\n        current_sum += i_to_n\n        current_sum, solutions_count = backtrack(\n            needed_sum, power, current_number + 1, current_sum, solutions_count\n        )\n        current_sum -= i_to_n\n    if i_to_n < needed_sum:\n        # If the power of i is less than needed_sum, then try with the next power.\n        current_sum, solutions_count = backtrack(\n            needed_sum, power, current_number + 1, current_sum, solutions_count\n        )\n    return current_sum, solutions_count\n\n\ndef solve(needed_sum: int, power: int) -> int:\n    \"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\n    if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):\n        raise ValueError(\n            \"Invalid input\\n\"\n            \"needed_sum must be between 1 and 1000, power between 2 and 10.\"\n        )\n\n    return backtrack(needed_sum, power, 1, 0, 0)[1]  # Return the solutions_count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "backtracking/all_permutations.py": "\"\"\"\nIn this problem, we want to determine all possible permutations\nof the given sequence. We use backtracking to solve this problem.\n\nTime complexity: O(n! * n),\nwhere n denotes the length of the given sequence.\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef generate_all_permutations(sequence: list[int | str]) -> None:\n    create_state_space_tree(sequence, [], 0, [0 for i in range(len(sequence))])\n\n\ndef create_state_space_tree(\n    sequence: list[int | str],\n    current_sequence: list[int | str],\n    index: int,\n    index_used: list[int],\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly len(sequence) - index children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which permutations are generated.\n    :param current_sequence: The current permutation being built.\n    :param index: The current index in the sequence.\n    :param index_used: list to track which elements are used in permutation.\n\n    Example 1:\n    >>> sequence = [1, 2, 3]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n\n    Example 2:\n    >>> sequence = [\"A\", \"B\", \"C\"]\n    >>> current_sequence = []\n    >>> index_used = [False, False, False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    ['A', 'B', 'C']\n    ['A', 'C', 'B']\n    ['B', 'A', 'C']\n    ['B', 'C', 'A']\n    ['C', 'A', 'B']\n    ['C', 'B', 'A']\n\n    Example 3:\n    >>> sequence = [1]\n    >>> current_sequence = []\n    >>> index_used = [False]\n    >>> create_state_space_tree(sequence, current_sequence, 0, index_used)\n    [1]\n    \"\"\"\n\n    if index == len(sequence):\n        print(current_sequence)\n        return\n\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False\n\n\n\"\"\"\nremove the comment to take an input from the user\n\nprint(\"Enter the elements\")\nsequence = list(map(int, input().split()))\n\"\"\"\n\nsequence: list[int | str] = [3, 1, 2, 4]\ngenerate_all_permutations(sequence)\n\nsequence_2: list[int | str] = [\"A\", \"B\", \"C\"]\ngenerate_all_permutations(sequence_2)\n", "backtracking/hamiltonian_cycle.py": "\"\"\"\nA Hamiltonian cycle (Hamiltonian circuit) is a graph cycle\nthrough a graph that visits each node exactly once.\nDetermining whether such paths and cycles exist in graphs\nis the 'Hamiltonian path problem', which is NP-complete.\n\nWikipedia: https://en.wikipedia.org/wiki/Hamiltonian_path\n\"\"\"\n\n\ndef valid_connection(\n    graph: list[list[int]], next_ver: int, curr_ind: int, path: list[int]\n) -> bool:\n    \"\"\"\n    Checks whether it is possible to add next into path by validating 2 statements\n    1. There should be path between current and next vertex\n    2. Next vertex should not be in path\n    If both validations succeed we return True, saying that it is possible to connect\n    this vertices, otherwise we return False\n\n    Case 1:Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    True\n\n    Case 2: Same graph, but trying to connect to node that is already in path\n    >>> path = [0, 1, 2, 4, -1, 0]\n    >>> curr_ind = 4\n    >>> next_ver = 1\n    >>> valid_connection(graph, next_ver, curr_ind, path)\n    False\n    \"\"\"\n\n    # 1. Validate that path exists between current and next vertices\n    if graph[path[curr_ind - 1]][next_ver] == 0:\n        return False\n\n    # 2. Validate that next vertex is not already in path\n    return not any(vertex == next_ver for vertex in path)\n\n\ndef util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:\n    \"\"\"\n    Pseudo-Code\n    Base Case:\n    1. Check if we visited all of vertices\n        1.1 If last visited vertex has path to starting vertex return True either\n            return False\n    Recursive Step:\n    2. Iterate over each vertex\n        Check if next vertex is valid for transiting from current vertex\n            2.1 Remember next vertex as next transition\n            2.2 Do recursive call and check if going to this vertex solves problem\n            2.3 If next vertex leads to solution return True\n            2.4 Else backtrack, delete remembered vertex\n\n    Case 1: Use exact graph as in main function, with initialized values\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, -1, -1, -1, -1, 0]\n    >>> curr_ind = 1\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2: Use exact graph as in previous case, but in the properties taken from\n        middle of calculation\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> path = [0, 1, 2, -1, -1, 0]\n    >>> curr_ind = 3\n    >>> util_hamilton_cycle(graph, path, curr_ind)\n    True\n    >>> path\n    [0, 1, 2, 4, 3, 0]\n    \"\"\"\n\n    # Base Case\n    if curr_ind == len(graph):\n        # return whether path exists between current and starting vertices\n        return graph[path[curr_ind - 1]][path[0]] == 1\n\n    # Recursive Step\n    for next_ver in range(len(graph)):\n        if valid_connection(graph, next_ver, curr_ind, path):\n            # Insert current vertex  into path as next transition\n            path[curr_ind] = next_ver\n            # Validate created path\n            if util_hamilton_cycle(graph, path, curr_ind + 1):\n                return True\n            # Backtrack\n            path[curr_ind] = -1\n    return False\n\n\ndef hamilton_cycle(graph: list[list[int]], start_index: int = 0) -> list[int]:\n    r\"\"\"\n    Wrapper function to call subroutine called util_hamilton_cycle,\n    which will either return array of vertices indicating hamiltonian cycle\n    or an empty list indicating that hamiltonian cycle was not found.\n    Case 1:\n    Following graph consists of 5 edges.\n    If we look closely, we can see that there are multiple Hamiltonian cycles.\n    For example one result is when we iterate like:\n    (0)->(1)->(2)->(4)->(3)->(0)\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> hamilton_cycle(graph)\n    [0, 1, 2, 4, 3, 0]\n\n    Case 2:\n    Same Graph as it was in Case 1, changed starting index from default to 3\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)---------(4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 1],\n    ...          [0, 1, 1, 1, 0]]\n    >>> hamilton_cycle(graph, 3)\n    [3, 0, 1, 2, 4, 3]\n\n    Case 3:\n    Following Graph is exactly what it was before, but edge 3-4 is removed.\n    Result is that there is no Hamiltonian Cycle anymore.\n\n    (0)---(1)---(2)\n     |   /   \\   |\n     |  /     \\  |\n     | /       \\ |\n     |/         \\|\n    (3)         (4)\n    >>> graph = [[0, 1, 0, 1, 0],\n    ...          [1, 0, 1, 1, 1],\n    ...          [0, 1, 0, 0, 1],\n    ...          [1, 1, 0, 0, 0],\n    ...          [0, 1, 1, 0, 0]]\n    >>> hamilton_cycle(graph,4)\n    []\n    \"\"\"\n\n    # Initialize path with -1, indicating that we have not visited them yet\n    path = [-1] * (len(graph) + 1)\n    # initialize start and end of path with starting index\n    path[0] = path[-1] = start_index\n    # evaluate and if we find answer return path either return empty array\n    return path if util_hamilton_cycle(graph, path, 1) else []\n", "backtracking/all_combinations.py": "\"\"\"\nIn this problem, we want to determine all possible combinations of k\nnumbers out of 1 ... n. We use backtracking to solve this problem.\n\nTime complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!))),\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom itertools import combinations\n\n\ndef combination_lists(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> combination_lists(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    return [list(x) for x in combinations(range(1, n + 1), k)]\n\n\ndef generate_all_combinations(n: int, k: int) -> list[list[int]]:\n    \"\"\"\n    >>> generate_all_combinations(n=4, k=2)\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    >>> generate_all_combinations(n=0, k=0)\n    [[]]\n    >>> generate_all_combinations(n=10, k=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: k must not be negative\n    >>> generate_all_combinations(n=-1, k=10)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must not be negative\n    >>> generate_all_combinations(n=5, k=4)\n    [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]\n    >>> from itertools import combinations\n    >>> all(generate_all_combinations(n, k) == combination_lists(n, k)\n    ...     for n in range(1, 6) for k in range(1, 6))\n    True\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must not be negative\")\n    if n < 0:\n        raise ValueError(\"n must not be negative\")\n\n    result: list[list[int]] = []\n    create_all_state(1, n, k, [], result)\n    return result\n\n\ndef create_all_state(\n    increment: int,\n    total_number: int,\n    level: int,\n    current_list: list[int],\n    total_list: list[list[int]],\n) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(generate_all_combinations(n=4, k=2))\n    tests = ((n, k) for n in range(1, 5) for k in range(1, 5))\n    for n, k in tests:\n        print(n, k, generate_all_combinations(n, k) == combination_lists(n, k))\n\n    print(\"Benchmark:\")\n    from timeit import timeit\n\n    for func in (\"combination_lists\", \"generate_all_combinations\"):\n        print(f\"{func:>25}(): {timeit(f'{func}(n=4, k = 2)', globals=globals())}\")\n", "backtracking/n_queens.py": "\"\"\"\n\nThe nqueens problem is of placing N queens on a N * N\nchess board such that no queen can attack any other queens placed\non that chess board.\nThis means that one queen cannot have any other queen on its horizontal, vertical and\ndiagonal lines.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nsolution = []\n\n\ndef is_safe(board: list[list[int]], row: int, column: int) -> bool:\n    \"\"\"\n    This function returns a boolean value True if it is safe to place a queen there\n    considering the current state of the board.\n\n    Parameters:\n    board (2D matrix): The chessboard\n    row, column: Coordinates of the cell on the board\n\n    Returns:\n    Boolean Value\n\n    >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    True\n    >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)\n    False\n    \"\"\"\n\n    n = len(board)  # Size of the board\n\n    # Check if there is any queen in the same row, column,\n    # left upper diagonal, and right upper diagonal\n    return (\n        all(board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, n)))\n        and all(\n            board[i][j] != 1 for i, j in zip(range(row, -1, -1), range(column, -1, -1))\n        )\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, n)))\n        and all(board[i][j] != 1 for i, j in zip(range(row, n), range(column, -1, -1)))\n    )\n\n\ndef solve(board: list[list[int]], row: int) -> bool:\n    \"\"\"\n    This function creates a state space tree and calls the safe function until it\n    receives a False Boolean and terminates that branch and backtracks to the next\n    possible solution branch.\n    \"\"\"\n    if row >= len(board):\n        \"\"\"\n        If the row number exceeds N, we have a board with a successful combination\n        and that combination is appended to the solution list and the board is printed.\n        \"\"\"\n        solution.append(board)\n        printboard(board)\n        print()\n        return True\n    for i in range(len(board)):\n        \"\"\"\n        For every row, it iterates through each column to check if it is feasible to\n        place a queen there.\n        If all the combinations for that particular branch are successful, the board is\n        reinitialized for the next possible combination.\n        \"\"\"\n        if is_safe(board, row, i):\n            board[row][i] = 1\n            solve(board, row + 1)\n            board[row][i] = 0\n    return False\n\n\ndef printboard(board: list[list[int]]) -> None:\n    \"\"\"\n    Prints the boards that have a successful combination.\n    \"\"\"\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 1:\n                print(\"Q\", end=\" \")  # Queen is present\n            else:\n                print(\".\", end=\" \")  # Empty cell\n        print()\n\n\n# Number of queens (e.g., n=8 for an 8x8 board)\nn = 8\nboard = [[0 for i in range(n)] for j in range(n)]\nsolve(board, 0)\nprint(\"The total number of solutions are:\", len(solution))\n", "backtracking/sudoku.py": "\"\"\"\nGiven a partially filled 9x9 2D array, the objective is to fill a 9x9\nsquare grid with digits numbered 1 to 9, so that every row, column, and\nand each of the nine 3x3 sub-grids contains all of the digits.\n\nThis can be solved using Backtracking and is similar to n-queens.\nWe check to see if a cell is safe or not and recursively call the\nfunction on the next column to see if it returns True. if yes, we\nhave solved the puzzle. else, we backtrack and place another number\nin that cell and repeat this process.\n\"\"\"\n\nfrom __future__ import annotations\n\nMatrix = list[list[int]]\n\n# assigning initial values to the grid\ninitial_grid: Matrix = [\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0],\n]\n\n# a grid with no solution\nno_solution: Matrix = [\n    [5, 0, 6, 5, 0, 8, 4, 0, 3],\n    [5, 2, 0, 0, 0, 0, 0, 0, 2],\n    [1, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0],\n]\n\n\ndef is_safe(grid: Matrix, row: int, column: int, n: int) -> bool:\n    \"\"\"\n    This function checks the grid to see if each row,\n    column, and the 3x3 subgrids contain the digit 'n'.\n    It returns False if it is not 'safe' (a duplicate digit\n    is found) else returns True if it is 'safe'\n    \"\"\"\n    for i in range(9):\n        if n in {grid[row][i], grid[i][column]}:\n            return False\n\n    for i in range(3):\n        for j in range(3):\n            if grid[(row - row % 3) + i][(column - column % 3) + j] == n:\n                return False\n\n    return True\n\n\ndef find_empty_location(grid: Matrix) -> tuple[int, int] | None:\n    \"\"\"\n    This function finds an empty location so that we can assign a number\n    for that particular row and column.\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if grid[i][j] == 0:\n                return i, j\n    return None\n\n\ndef sudoku(grid: Matrix) -> Matrix | None:\n    \"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\n    if location := find_empty_location(grid):\n        row, column = location\n    else:\n        # If the location is ``None``, then the grid is solved.\n        return grid\n\n    for digit in range(1, 10):\n        if is_safe(grid, row, column, digit):\n            grid[row][column] = digit\n\n            if sudoku(grid) is not None:\n                return grid\n\n            grid[row][column] = 0\n\n    return None\n\n\ndef print_solution(grid: Matrix) -> None:\n    \"\"\"\n    A function to print the solution in the form\n    of a 9x9 grid\n    \"\"\"\n    for row in grid:\n        for cell in row:\n            print(cell, end=\" \")\n        print()\n\n\nif __name__ == \"__main__\":\n    # make a copy of grid so that you can compare with the unmodified grid\n    for example_grid in (initial_grid, no_solution):\n        print(\"\\nExample grid:\\n\" + \"=\" * 20)\n        print_solution(example_grid)\n        print(\"\\nExample grid solution:\")\n        solution = sudoku(example_grid)\n        if solution is not None:\n            print_solution(solution)\n        else:\n            print(\"Cannot find a solution.\")\n", "backtracking/minimax.py": "\"\"\"\nMinimax helps to achieve maximum score in a game by checking all possible moves\ndepth is current depth in game tree.\n\nnodeIndex is index of current node in scores[].\nif move is of maximizer return true else false\nleaves of game tree is stored in scores[]\nheight is maximum height of Game tree\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\n\ndef minimax(\n    depth: int, node_index: int, is_max: bool, scores: list[int], height: float\n) -> int:\n    \"\"\"\n    This function implements the minimax algorithm, which helps achieve the optimal\n    score for a player in a two-player game by checking all possible moves.\n    If the player is the maximizer, then the score is maximized.\n    If the player is the minimizer, then the score is minimized.\n\n    Parameters:\n    - depth: Current depth in the game tree.\n    - node_index: Index of the current node in the scores list.\n    - is_max: A boolean indicating whether the current move\n              is for the maximizer (True) or minimizer (False).\n    - scores: A list containing the scores of the leaves of the game tree.\n    - height: The maximum height of the game tree.\n\n    Returns:\n    - An integer representing the optimal score for the current player.\n\n    >>> import math\n    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    65\n    >>> minimax(-1, 0, True, scores, height)\n    Traceback (most recent call last):\n        ...\n    ValueError: Depth cannot be less than 0\n    >>> minimax(0, 0, True, [], 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Scores cannot be empty\n    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]\n    >>> height = math.log(len(scores), 2)\n    >>> minimax(0, 0, True, scores, height)\n    12\n    \"\"\"\n\n    if depth < 0:\n        raise ValueError(\"Depth cannot be less than 0\")\n    if len(scores) == 0:\n        raise ValueError(\"Scores cannot be empty\")\n\n    # Base case: If the current depth equals the height of the tree,\n    # return the score of the current node.\n    if depth == height:\n        return scores[node_index]\n\n    # If it's the maximizer's turn, choose the maximum score\n    # between the two possible moves.\n    if is_max:\n        return max(\n            minimax(depth + 1, node_index * 2, False, scores, height),\n            minimax(depth + 1, node_index * 2 + 1, False, scores, height),\n        )\n\n    # If it's the minimizer's turn, choose the minimum score\n    # between the two possible moves.\n    return min(\n        minimax(depth + 1, node_index * 2, True, scores, height),\n        minimax(depth + 1, node_index * 2 + 1, True, scores, height),\n    )\n\n\ndef main() -> None:\n    # Sample scores and height calculation\n    scores = [90, 23, 6, 33, 21, 65, 123, 34423]\n    height = math.log(len(scores), 2)\n\n    # Calculate and print the optimal value using the minimax algorithm\n    print(\"Optimal value : \", end=\"\")\n    print(minimax(0, 0, True, scores, height))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "backtracking/knight_tour.py": "# Knight Tour Intro: https://www.youtube.com/watch?v=ab_dY3dZFHM\n\nfrom __future__ import annotations\n\n\ndef get_valid_pos(position: tuple[int, int], n: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Find all the valid positions a knight can move to from the current position.\n\n    >>> get_valid_pos((1, 3), 4)\n    [(2, 1), (0, 1), (3, 2)]\n    \"\"\"\n\n    y, x = position\n    positions = [\n        (y + 1, x + 2),\n        (y - 1, x + 2),\n        (y + 1, x - 2),\n        (y - 1, x - 2),\n        (y + 2, x + 1),\n        (y + 2, x - 1),\n        (y - 2, x + 1),\n        (y - 2, x - 1),\n    ]\n    permissible_positions = []\n\n    for position in positions:\n        y_test, x_test = position\n        if 0 <= y_test < n and 0 <= x_test < n:\n            permissible_positions.append(position)\n\n    return permissible_positions\n\n\ndef is_complete(board: list[list[int]]) -> bool:\n    \"\"\"\n    Check if the board (matrix) has been completely filled with non-zero values.\n\n    >>> is_complete([[1]])\n    True\n\n    >>> is_complete([[1, 2], [3, 0]])\n    False\n    \"\"\"\n\n    return not any(elem == 0 for row in board for elem in row)\n\n\ndef open_knight_tour_helper(\n    board: list[list[int]], pos: tuple[int, int], curr: int\n) -> bool:\n    \"\"\"\n    Helper function to solve knight tour problem.\n    \"\"\"\n\n    if is_complete(board):\n        return True\n\n    for position in get_valid_pos(pos, len(board)):\n        y, x = position\n\n        if board[y][x] == 0:\n            board[y][x] = curr + 1\n            if open_knight_tour_helper(board, position, curr + 1):\n                return True\n            board[y][x] = 0\n\n    return False\n\n\ndef open_knight_tour(n: int) -> list[list[int]]:\n    \"\"\"\n    Find the solution for the knight tour problem for a board of size n. Raises\n    ValueError if the tour cannot be performed for the given size.\n\n    >>> open_knight_tour(1)\n    [[1]]\n\n    >>> open_knight_tour(2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Open Knight Tour cannot be performed on a board of size 2\n    \"\"\"\n\n    board = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n            if open_knight_tour_helper(board, (i, j), 1):\n                return board\n            board[i][j] = 0\n\n    msg = f\"Open Knight Tour cannot be performed on a board of size {n}\"\n    raise ValueError(msg)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "backtracking/rat_in_maze.py": "from __future__ import annotations\n\n\ndef solve_maze(\n    maze: list[list[int]],\n    source_row: int,\n    source_column: int,\n    destination_row: int,\n    destination_column: int,\n) -> list[list[int]]:\n    \"\"\"\n    This method solves the \"rat in maze\" problem.\n    Parameters :\n        - maze: A two dimensional matrix of zeros and ones.\n        - source_row: The row index of the starting point.\n        - source_column: The column index of the starting point.\n        - destination_row: The row index of the destination point.\n        - destination_column: The column index of the destination point.\n    Returns:\n        - solution: A 2D matrix representing the solution path if it exists.\n    Raises:\n        - ValueError: If no solution exists or if the source or\n            destination coordinates are invalid.\n    Description:\n        This method navigates through a maze represented as an n by n matrix,\n        starting from a specified source cell and\n        aiming to reach a destination cell.\n        The maze consists of walls (1s) and open paths (0s).\n        By providing custom row and column values, the source and destination\n        cells can be adjusted.\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [1, 0, 1, 0, 1],\n    ...         [0, 0, 1, 0, 0],\n    ...         [1, 0, 0, 1, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 1],\n    [1, 1, 1, 0, 1],\n    [1, 1, 1, 0, 0],\n    [1, 1, 1, 1, 0]]\n\n    Note:\n        In the output maze, the zeros (0s) represent one of the possible\n        paths from the source to the destination.\n\n    >>> maze = [[0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 1],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 0, 0, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0]]\n\n    >>> maze = [[0, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[0, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE\n    [[1, 0, 0],\n    [1, 1, 0],\n    [1, 1, 0]]\n\n    >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],\n    ...         [1, 0, 1, 0, 0, 1, 1, 1],\n    ...         [0, 1, 0, 1, 0, 0, 1, 0],\n    ...         [1, 1, 1, 0, 0, 1, 0, 1],\n    ...         [0, 1, 0, 0, 1, 0, 1, 1],\n    ...         [0, 0, 0, 1, 1, 1, 0, 1],\n    ...         [0, 1, 0, 1, 0, 1, 1, 1],\n    ...         [1, 1, 0, 0, 0, 0, 0, 1]]\n    >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE\n    [[1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 1, 1, 0, 1, 1, 1],\n    [1, 1, 1, 0, 0, 1, 1, 1],\n    [1, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1],\n    [1, 1, 0, 1, 1, 1, 1, 1]]\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 1],\n    ...         [1, 0, 1]]\n    >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 0],\n    ...         [1, 1]]\n    >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution exists!\n\n    >>> maze = [[0, 1],\n    ...         [1, 0]]\n    >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n\n    >>> maze = [[1, 0, 0],\n    ...         [0, 1, 0],\n    ...         [1, 0, 0]]\n    >>> solve_maze(maze,0,1,len(maze),len(maze)-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid source or destination coordinates\n    \"\"\"\n    size = len(maze)\n    # Check if source and destination coordinates are Invalid.\n    if not (0 <= source_row <= size - 1 and 0 <= source_column <= size - 1) or (\n        not (0 <= destination_row <= size - 1 and 0 <= destination_column <= size - 1)\n    ):\n        raise ValueError(\"Invalid source or destination coordinates\")\n    # We need to create solution object to save path.\n    solutions = [[1 for _ in range(size)] for _ in range(size)]\n    solved = run_maze(\n        maze, source_row, source_column, destination_row, destination_column, solutions\n    )\n    if solved:\n        return solutions\n    else:\n        raise ValueError(\"No solution exists!\")\n\n\ndef run_maze(\n    maze: list[list[int]],\n    i: int,\n    j: int,\n    destination_row: int,\n    destination_column: int,\n    solutions: list[list[int]],\n) -> bool:\n    \"\"\"\n    This method is recursive starting from (i, j) and going in one of four directions:\n    up, down, left, right.\n    If a path is found to destination it returns True otherwise it returns False.\n    Parameters\n        maze: A two dimensional matrix of zeros and ones.\n        i, j : coordinates of matrix\n        solutions: A two dimensional matrix of solutions.\n    Returns:\n        Boolean if path is found True, Otherwise False.\n    \"\"\"\n    size = len(maze)\n    # Final check point.\n    if i == destination_row and j == destination_column and maze[i][j] == 0:\n        solutions[i][j] = 0\n        return True\n\n    lower_flag = (not i < 0) and (not j < 0)  # Check lower bounds\n    upper_flag = (i < size) and (j < size)  # Check upper bounds\n\n    if lower_flag and upper_flag:\n        # check for already visited and block points.\n        block_flag = (solutions[i][j]) and (not maze[i][j])\n        if block_flag:\n            # check visited\n            solutions[i][j] = 0\n\n            # check for directions\n            if (\n                run_maze(maze, i + 1, j, destination_row, destination_column, solutions)\n                or run_maze(\n                    maze, i, j + 1, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i - 1, j, destination_row, destination_column, solutions\n                )\n                or run_maze(\n                    maze, i, j - 1, destination_row, destination_column, solutions\n                )\n            ):\n                return True\n\n            solutions[i][j] = 1\n            return False\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)\n", "backtracking/generate_parentheses.py": "\"\"\"\nauthor: Aayush Soni\nGiven n pairs of parentheses, write a function to generate all\ncombinations of well-formed parentheses.\nInput: n = 2\nOutput: [\"(())\",\"()()\"]\nLeetcode link: https://leetcode.com/problems/generate-parentheses/description/\n\"\"\"\n\n\ndef backtrack(\n    partial: str, open_count: int, close_count: int, n: int, result: list[str]\n) -> None:\n    \"\"\"\n    Generate valid combinations of balanced parentheses using recursion.\n\n    :param partial: A string representing the current combination.\n    :param open_count: An integer representing the count of open parentheses.\n    :param close_count: An integer representing the count of close parentheses.\n    :param n: An integer representing the total number of pairs.\n    :param result: A list to store valid combinations.\n    :return: None\n\n    This function uses recursion to explore all possible combinations,\n    ensuring that at each step, the parentheses remain balanced.\n\n    Example:\n    >>> result = []\n    >>> backtrack(\"\", 0, 0, 2, result)\n    >>> result\n    ['(())', '()()']\n    \"\"\"\n    if len(partial) == 2 * n:\n        # When the combination is complete, add it to the result.\n        result.append(partial)\n        return\n\n    if open_count < n:\n        # If we can add an open parenthesis, do so, and recurse.\n        backtrack(partial + \"(\", open_count + 1, close_count, n, result)\n\n    if close_count < open_count:\n        # If we can add a close parenthesis (it won't make the combination invalid),\n        # do so, and recurse.\n        backtrack(partial + \")\", open_count, close_count + 1, n, result)\n\n\ndef generate_parenthesis(n: int) -> list[str]:\n    \"\"\"\n    Generate valid combinations of balanced parentheses for a given n.\n\n    :param n: An integer representing the number of pairs of parentheses.\n    :return: A list of strings with valid combinations.\n\n    This function uses a recursive approach to generate the combinations.\n\n    Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.\n    Space Complexity: O(n) - where 'n' is the number of pairs.\n\n    Example 1:\n    >>> generate_parenthesis(3)\n    ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Example 2:\n    >>> generate_parenthesis(1)\n    ['()']\n    \"\"\"\n\n    result: list[str] = []\n    backtrack(\"\", 0, 0, n, result)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "backtracking/match_word_pattern.py": "def match_word_pattern(pattern: str, input_string: str) -> bool:\n    \"\"\"\n    Determine if a given pattern matches a string using backtracking.\n\n    pattern: The pattern to match.\n    input_string: The string to match against the pattern.\n    return: True if the pattern matches the string, False otherwise.\n\n    >>> match_word_pattern(\"aba\", \"GraphTreesGraph\")\n    True\n\n    >>> match_word_pattern(\"xyx\", \"PythonRubyPython\")\n    True\n\n    >>> match_word_pattern(\"GG\", \"PythonJavaPython\")\n    False\n    \"\"\"\n\n    def backtrack(pattern_index: int, str_index: int) -> bool:\n        \"\"\"\n        >>> backtrack(0, 0)\n        True\n\n        >>> backtrack(0, 1)\n        True\n\n        >>> backtrack(0, 4)\n        False\n        \"\"\"\n        if pattern_index == len(pattern) and str_index == len(input_string):\n            return True\n        if pattern_index == len(pattern) or str_index == len(input_string):\n            return False\n        char = pattern[pattern_index]\n        if char in pattern_map:\n            mapped_str = pattern_map[char]\n            if input_string.startswith(mapped_str, str_index):\n                return backtrack(pattern_index + 1, str_index + len(mapped_str))\n            else:\n                return False\n        for end in range(str_index + 1, len(input_string) + 1):\n            substr = input_string[str_index:end]\n            if substr in str_map:\n                continue\n            pattern_map[char] = substr\n            str_map[substr] = char\n            if backtrack(pattern_index + 1, end):\n                return True\n            del pattern_map[char]\n            del str_map[substr]\n        return False\n\n    pattern_map: dict[str, str] = {}\n    str_map: dict[str, str] = {}\n    return backtrack(0, 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "backtracking/__init__.py": "", "backtracking/word_search.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 24, 2022\n\nTask:\nGiven an m x n grid of characters board and a string word,\nreturn true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells,\nwhere adjacent cells are horizontally or vertically neighboring.\nThe same letter cell may not be used more than once.\n\nExample:\n\nMatrix:\n---------\n|A|B|C|E|\n|S|F|C|S|\n|A|D|E|E|\n---------\n\nWord:\n\"ABCCED\"\n\nResult:\nTrue\n\nImplementation notes: Use backtracking approach.\nAt each point, check all neighbors to try to find the next letter of the word.\n\nleetcode: https://leetcode.com/problems/word-search/\n\n\"\"\"\n\n\ndef get_point_key(len_board: int, len_board_column: int, row: int, column: int) -> int:\n    \"\"\"\n    Returns the hash key of matrix indexes.\n\n    >>> get_point_key(10, 20, 1, 0)\n    200\n    \"\"\"\n\n    return len_board * len_board_column * row + column\n\n\ndef exits_word(\n    board: list[list[str]],\n    word: str,\n    row: int,\n    column: int,\n    word_index: int,\n    visited_points_set: set[int],\n) -> bool:\n    \"\"\"\n    Return True if it's possible to search the word suffix\n    starting from the word_index.\n\n    >>> exits_word([[\"A\"]], \"B\", 0, 0, 0, set())\n    False\n    \"\"\"\n\n    if board[row][column] != word[word_index]:\n        return False\n\n    if word_index == len(word) - 1:\n        return True\n\n    traverts_directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    len_board = len(board)\n    len_board_column = len(board[0])\n    for direction in traverts_directions:\n        next_i = row + direction[0]\n        next_j = column + direction[1]\n        if not (0 <= next_i < len_board and 0 <= next_j < len_board_column):\n            continue\n\n        key = get_point_key(len_board, len_board_column, next_i, next_j)\n        if key in visited_points_set:\n            continue\n\n        visited_points_set.add(key)\n        if exits_word(board, word, next_i, next_j, word_index + 1, visited_points_set):\n            return True\n\n        visited_points_set.remove(key)\n\n    return False\n\n\ndef word_exists(board: list[list[str]], word: str) -> bool:\n    \"\"\"\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCCED\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"SEE\")\n    True\n    >>> word_exists([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"ABCB\")\n    False\n    >>> word_exists([[\"A\"]], \"A\")\n    True\n    >>> word_exists([[\"B\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"A\", \"B\", \"A\"]], \"ABB\")\n    False\n    >>> word_exists([[\"A\"]], 123)\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[\"A\"]], \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The word parameter should be a string of length greater than 0.\n    >>> word_exists([[]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    >>> word_exists([[\"A\"], [21]], \"AB\")\n    Traceback (most recent call last):\n        ...\n    ValueError: The board should be a non empty matrix of single chars strings.\n    \"\"\"\n\n    # Validate board\n    board_error_message = (\n        \"The board should be a non empty matrix of single chars strings.\"\n    )\n\n    len_board = len(board)\n    if not isinstance(board, list) or len(board) == 0:\n        raise ValueError(board_error_message)\n\n    for row in board:\n        if not isinstance(row, list) or len(row) == 0:\n            raise ValueError(board_error_message)\n\n        for item in row:\n            if not isinstance(item, str) or len(item) != 1:\n                raise ValueError(board_error_message)\n\n    # Validate word\n    if not isinstance(word, str) or len(word) == 0:\n        raise ValueError(\n            \"The word parameter should be a string of length greater than 0.\"\n        )\n\n    len_board_column = len(board[0])\n    for i in range(len_board):\n        for j in range(len_board_column):\n            if exits_word(\n                board, word, i, j, 0, {get_point_key(len_board, len_board_column, i, j)}\n            ):\n                return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "backtracking/n_queens_math.py": "r\"\"\"\nProblem:\n\nThe n queens problem is: placing N queens on a N * N chess board such that no queen\ncan attack any other queens placed on that chess board.  This means that one queen\ncannot have any other queen on its horizontal, vertical and diagonal lines.\n\nSolution:\n\nTo solve this problem we will use simple math. First we know the queen can move in all\nthe possible ways, we can simplify it in this: vertical, horizontal, diagonal left and\n diagonal right.\n\nWe can visualize it like this:\n\nleft diagonal = \\\nright diagonal = /\n\nOn a chessboard vertical movement could be the rows and horizontal movement could be\nthe columns.\n\nIn programming we can use an array, and in this array each index could be the rows and\neach value in the array could be the column. For example:\n\n    . Q . .     We have this chessboard with one queen in each column and each queen\n    . . . Q     can't attack to each other.\n    Q . . .     The array for this example would look like this: [1, 3, 0, 2]\n    . . Q .\n\nSo if we use an array and we verify that each value in the array is different to each\nother we know that at least the queens can't attack each other in horizontal and\nvertical.\n\nAt this point we have it halfway completed and we will treat the chessboard as a\nCartesian plane.  Hereinafter we are going to remember basic math, so in the school we\nlearned this formula:\n\n    Slope of a line:\n\n           y2 - y1\n     m = ----------\n          x2 - x1\n\nThis formula allow us to get the slope. For the angles 45\u00ba (right diagonal) and 135\u00ba\n(left diagonal) this formula gives us m = 1, and m = -1 respectively.\n\nSee::\nhttps://www.enotes.com/homework-help/write-equation-line-that-hits-origin-45-degree-1474860\n\nThen we have this other formula:\n\nSlope intercept:\n\ny = mx + b\n\nb is where the line crosses the Y axis (to get more information see:\nhttps://www.mathsisfun.com/y_intercept.html), if we change the formula to solve for b\nwe would have:\n\ny - mx = b\n\nAnd since we already have the m values for the angles 45\u00ba and 135\u00ba, this formula would\nlook like this:\n\n45\u00ba: y - (1)x = b\n45\u00ba: y - x = b\n\n135\u00ba: y - (-1)x = b\n135\u00ba: y + x = b\n\ny = row\nx = column\n\nApplying these two formulas we can check if a queen in some position is being attacked\nfor another one or vice versa.\n\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef depth_first_search(\n    possible_board: list[int],\n    diagonal_right_collisions: list[int],\n    diagonal_left_collisions: list[int],\n    boards: list[list[str]],\n    n: int,\n) -> None:\n    \"\"\"\n    >>> boards = []\n    >>> depth_first_search([], [], [], boards, 4)\n    >>> for board in boards:\n    ...     print(board)\n    ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n    ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']\n    \"\"\"\n\n    # Get next row in the current board (possible_board) to fill it with a queen\n    row = len(possible_board)\n\n    # If row is equal to the size of the board it means there are a queen in each row in\n    # the current board (possible_board)\n    if row == n:\n        # We convert the variable possible_board that looks like this: [1, 3, 0, 2] to\n        # this: ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n    # We iterate each column in the row to find all possible results in each row\n    for col in range(n):\n        # We apply that we learned previously. First we check that in the current board\n        # (possible_board) there are not other same value because if there is it means\n        # that there are a collision in vertical. Then we apply the two formulas we\n        # learned before:\n        #\n        # 45\u00ba: y - x = b or 45: row - col = b\n        # 135\u00ba: y + x = b or row + col = b.\n        #\n        # And we verify if the results of this two formulas not exist in their variables\n        # respectively.  (diagonal_right_collisions, diagonal_left_collisions)\n        #\n        # If any or these are True it means there is a collision so we continue to the\n        # next value in the for loop.\n        if (\n            col in possible_board\n            or row - col in diagonal_right_collisions\n            or row + col in diagonal_left_collisions\n        ):\n            continue\n\n        # If it is False we call dfs function again and we update the inputs\n        depth_first_search(\n            [*possible_board, col],\n            [*diagonal_right_collisions, row - col],\n            [*diagonal_left_collisions, row + col],\n            boards,\n            n,\n        )\n\n\ndef n_queens_solution(n: int) -> None:\n    boards: list[list[str]] = []\n    depth_first_search([], [], [], boards, n)\n\n    # Print all the boards\n    for board in boards:\n        for column in board:\n            print(column)\n        print(\"\")\n\n    print(len(boards), \"solutions were found.\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    n_queens_solution(4)\n", "backtracking/combination_sum.py": "\"\"\"\nIn the Combination Sum problem, we are given a list consisting of distinct integers.\nWe need to find all the combinations whose sum equals to target given.\nWe can use an element more than one.\n\nTime complexity(Average Case): O(n!)\n\nConstraints:\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40\n\"\"\"\n\n\ndef backtrack(\n    candidates: list, path: list, answer: list, target: int, previous_index: int\n) -> None:\n    \"\"\"\n    A recursive function that searches for possible combinations. Backtracks in case\n    of a bigger current combination value than the target value.\n\n    Parameters\n    ----------\n    previous_index: Last index from the previous search\n    target: The value we need to obtain by summing our integers in the path list.\n    answer: A list of possible combinations\n    path: Current combination\n    candidates: A list of integers we can use.\n    \"\"\"\n    if target == 0:\n        answer.append(path.copy())\n    else:\n        for index in range(previous_index, len(candidates)):\n            if target >= candidates[index]:\n                path.append(candidates[index])\n                backtrack(candidates, path, answer, target - candidates[index], index)\n                path.pop(len(path) - 1)\n\n\ndef combination_sum(candidates: list, target: int) -> list:\n    \"\"\"\n    >>> combination_sum([2, 3, 5], 8)\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    >>> combination_sum([2, 3, 6, 7], 7)\n    [[2, 2, 3], [7]]\n    >>> combination_sum([-8, 2.3, 0], 1)\n    Traceback (most recent call last):\n        ...\n    RecursionError: maximum recursion depth exceeded\n    \"\"\"\n    path = []  # type: list[int]\n    answer = []  # type: list[int]\n    backtrack(candidates, path, answer, target, 0)\n    return answer\n\n\ndef main() -> None:\n    print(combination_sum([-8, 2.3, 0], 1))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "backtracking/crossword_puzzle_solver.py": "# https://www.geeksforgeeks.org/solve-crossword-puzzle/\n\n\ndef is_valid(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> bool:\n    \"\"\"\n    Check if a word can be placed at the given position.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, True)\n    True\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> is_valid(puzzle, 'word', 0, 0, False)\n    True\n    \"\"\"\n    for i in range(len(word)):\n        if vertical:\n            if row + i >= len(puzzle) or puzzle[row + i][col] != \"\":\n                return False\n        elif col + i >= len(puzzle[0]) or puzzle[row][col + i] != \"\":\n            return False\n    return True\n\n\ndef place_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    \"\"\"\n    Place a word at the given position.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> place_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]\n    \"\"\"\n    for i, char in enumerate(word):\n        if vertical:\n            puzzle[row + i][col] = char\n        else:\n            puzzle[row][col + i] = char\n\n\ndef remove_word(\n    puzzle: list[list[str]], word: str, row: int, col: int, vertical: bool\n) -> None:\n    \"\"\"\n    Remove a word from the given position.\n\n    >>> puzzle = [\n    ...     ['w', '', '', ''],\n    ...     ['o', '', '', ''],\n    ...     ['r', '', '', ''],\n    ...     ['d', '', '', '']\n    ... ]\n    >>> remove_word(puzzle, 'word', 0, 0, True)\n    >>> puzzle\n    [['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]\n    \"\"\"\n    for i in range(len(word)):\n        if vertical:\n            puzzle[row + i][col] = \"\"\n        else:\n            puzzle[row][col + i] = \"\"\n\n\ndef solve_crossword(puzzle: list[list[str]], words: list[str]) -> bool:\n    \"\"\"\n    Solve the crossword puzzle using backtracking.\n\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n\n    >>> words = ['word', 'four', 'more', 'last']\n    >>> solve_crossword(puzzle, words)\n    True\n    >>> puzzle = [\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', ''],\n    ...     ['', '', '', '']\n    ... ]\n    >>> words = ['word', 'four', 'more', 'paragraphs']\n    >>> solve_crossword(puzzle, words)\n    False\n    \"\"\"\n    for row in range(len(puzzle)):\n        for col in range(len(puzzle[0])):\n            if puzzle[row][col] == \"\":\n                for word in words:\n                    for vertical in [True, False]:\n                        if is_valid(puzzle, word, row, col, vertical):\n                            place_word(puzzle, word, row, col, vertical)\n                            words.remove(word)\n                            if solve_crossword(puzzle, words):\n                                return True\n                            words.append(word)\n                            remove_word(puzzle, word, row, col, vertical)\n                return False\n    return True\n\n\nif __name__ == \"__main__\":\n    PUZZLE = [[\"\"] * 3 for _ in range(3)]\n    WORDS = [\"cat\", \"dog\", \"car\"]\n\n    if solve_crossword(PUZZLE, WORDS):\n        print(\"Solution found:\")\n        for row in PUZZLE:\n            print(\" \".join(row))\n    else:\n        print(\"No solution found:\")\n", "backtracking/coloring.py": "\"\"\"\nGraph Coloring also called \"m coloring problem\"\nconsists of coloring a given graph with at most m colors\nsuch that no adjacent vertices are assigned the same color\n\nWikipedia: https://en.wikipedia.org/wiki/Graph_coloring\n\"\"\"\n\n\ndef valid_coloring(\n    neighbours: list[int], colored_vertices: list[int], color: int\n) -> bool:\n    \"\"\"\n    For each neighbour check if the coloring constraint is satisfied\n    If any of the neighbours fail the constraint return False\n    If all neighbours validate the constraint return True\n\n    >>> neighbours = [0,1,0,1,0]\n    >>> colored_vertices = [0, 2, 1, 2, 0]\n\n    >>> color = 1\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    True\n\n    >>> color = 2\n    >>> valid_coloring(neighbours, colored_vertices, color)\n    False\n    \"\"\"\n    # Does any neighbour not satisfy the constraints\n    return not any(\n        neighbour == 1 and colored_vertices[i] == color\n        for i, neighbour in enumerate(neighbours)\n    )\n\n\ndef util_color(\n    graph: list[list[int]], max_colors: int, colored_vertices: list[int], index: int\n) -> bool:\n    \"\"\"\n    Pseudo-Code\n\n    Base Case:\n    1. Check if coloring is complete\n        1.1 If complete return True (meaning that we successfully colored the graph)\n\n    Recursive Step:\n    2. Iterates over each color:\n        Check if the current coloring is valid:\n            2.1. Color given vertex\n            2.2. Do recursive call, check if this coloring leads to a solution\n            2.4. if current coloring leads to a solution return\n            2.5. Uncolor given vertex\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n    >>> max_colors = 3\n    >>> colored_vertices = [0, 1, 0, 0, 0]\n    >>> index = 3\n\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    True\n\n    >>> max_colors = 2\n    >>> util_color(graph, max_colors, colored_vertices, index)\n    False\n    \"\"\"\n\n    # Base Case\n    if index == len(graph):\n        return True\n\n    # Recursive Step\n    for i in range(max_colors):\n        if valid_coloring(graph[index], colored_vertices, i):\n            # Color current vertex\n            colored_vertices[index] = i\n            # Validate coloring\n            if util_color(graph, max_colors, colored_vertices, index + 1):\n                return True\n            # Backtrack\n            colored_vertices[index] = -1\n    return False\n\n\ndef color(graph: list[list[int]], max_colors: int) -> list[int]:\n    \"\"\"\n    Wrapper function to call subroutine called util_color\n    which will either return True or False.\n    If True is returned colored_vertices list is filled with correct colorings\n\n    >>> graph = [[0, 1, 0, 0, 0],\n    ...          [1, 0, 1, 0, 1],\n    ...          [0, 1, 0, 1, 0],\n    ...          [0, 1, 1, 0, 0],\n    ...          [0, 1, 0, 0, 0]]\n\n    >>> max_colors = 3\n    >>> color(graph, max_colors)\n    [0, 1, 0, 2, 0]\n\n    >>> max_colors = 2\n    >>> color(graph, max_colors)\n    []\n    \"\"\"\n    colored_vertices = [-1] * len(graph)\n\n    if util_color(graph, max_colors, colored_vertices, 0):\n        return colored_vertices\n\n    return []\n", "backtracking/all_subsequences.py": "\"\"\"\nIn this problem, we want to determine all possible subsequences\nof the given sequence. We use backtracking to solve this problem.\n\nTime complexity: O(2^n),\nwhere n denotes the length of the given sequence.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n\ndef generate_all_subsequences(sequence: list[Any]) -> None:\n    create_state_space_tree(sequence, [], 0)\n\n\ndef create_state_space_tree(\n    sequence: list[Any], current_subsequence: list[Any], index: int\n) -> None:\n    \"\"\"\n    Creates a state space tree to iterate through each branch using DFS.\n    We know that each state has exactly two children.\n    It terminates when it reaches the end of the given sequence.\n\n    :param sequence: The input sequence for which subsequences are generated.\n    :param current_subsequence: The current subsequence being built.\n    :param index: The current index in the sequence.\n\n    Example:\n    >>> sequence = [3, 2, 1]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [1]\n    [2]\n    [2, 1]\n    [3]\n    [3, 1]\n    [3, 2]\n    [3, 2, 1]\n\n    >>> sequence = [\"A\", \"B\"]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    ['B']\n    ['A']\n    ['A', 'B']\n\n    >>> sequence = []\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n\n    >>> sequence = [1, 2, 3, 4]\n    >>> current_subsequence = []\n    >>> create_state_space_tree(sequence, current_subsequence, 0)\n    []\n    [4]\n    [3]\n    [3, 4]\n    [2]\n    [2, 4]\n    [2, 3]\n    [2, 3, 4]\n    [1]\n    [1, 4]\n    [1, 3]\n    [1, 3, 4]\n    [1, 2]\n    [1, 2, 4]\n    [1, 2, 3]\n    [1, 2, 3, 4]\n    \"\"\"\n\n    if index == len(sequence):\n        print(current_subsequence)\n        return\n\n    create_state_space_tree(sequence, current_subsequence, index + 1)\n    current_subsequence.append(sequence[index])\n    create_state_space_tree(sequence, current_subsequence, index + 1)\n    current_subsequence.pop()\n\n\nif __name__ == \"__main__\":\n    seq: list[Any] = [1, 2, 3]\n    generate_all_subsequences(seq)\n\n    seq.clear()\n    seq.extend([\"A\", \"B\", \"C\"])\n    generate_all_subsequences(seq)\n", "financial/price_plus_tax.py": "\"\"\"\nCalculate price plus tax of a good or service given its price and a tax rate.\n\"\"\"\n\n\ndef price_plus_tax(price: float, tax_rate: float) -> float:\n    \"\"\"\n    >>> price_plus_tax(100, 0.25)\n    125.0\n    >>> price_plus_tax(125.50, 0.05)\n    131.775\n    \"\"\"\n    return price * (1 + tax_rate)\n\n\nif __name__ == \"__main__\":\n    print(f\"{price_plus_tax(100, 0.25) = }\")\n    print(f\"{price_plus_tax(125.50, 0.05) = }\")\n", "financial/exponential_moving_average.py": "\"\"\"\nCalculate the exponential moving average (EMA) on the series of stock prices.\nWikipedia Reference: https://en.wikipedia.org/wiki/Exponential_smoothing\nhttps://www.investopedia.com/terms/e/ema.asp#toc-what-is-an-exponential\n-moving-average-ema\n\nExponential moving average is used in finance to analyze changes stock prices.\nEMA is used in conjunction with Simple moving average (SMA), EMA reacts to the\nchanges in the value quicker than SMA, which is one of the advantages of using EMA.\n\"\"\"\n\nfrom collections.abc import Iterator\n\n\ndef exponential_moving_average(\n    stock_prices: Iterator[float], window_size: int\n) -> Iterator[float]:\n    \"\"\"\n    Yields exponential moving averages of the given stock prices.\n    >>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3))\n    (2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)\n\n    :param stock_prices: A stream of stock prices\n    :param window_size: The number of stock prices that will trigger a new calculation\n                        of the exponential average (window_size > 0)\n    :return: Yields a sequence of exponential moving averages\n\n    Formula:\n\n    st = alpha * xt + (1 - alpha) * st_prev\n\n    Where,\n    st : Exponential moving average at timestamp t\n    xt : stock price in from the stock prices at timestamp t\n    st_prev : Exponential moving average at timestamp t-1\n    alpha : 2/(1 + window_size) - smoothing factor\n\n    Exponential moving average (EMA) is a rule of thumb technique for\n    smoothing time series data using an exponential window function.\n    \"\"\"\n\n    if window_size <= 0:\n        raise ValueError(\"window_size must be > 0\")\n\n    # Calculating smoothing factor\n    alpha = 2 / (1 + window_size)\n\n    # Exponential average at timestamp t\n    moving_average = 0.0\n\n    for i, stock_price in enumerate(stock_prices):\n        if i <= window_size:\n            # Assigning simple moving average till the window_size for the first time\n            # is reached\n            moving_average = (moving_average + stock_price) * 0.5 if i else stock_price\n        else:\n            # Calculating exponential moving average based on current timestamp data\n            # point and previous exponential average value\n            moving_average = (alpha * stock_price) + ((1 - alpha) * moving_average)\n        yield moving_average\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    stock_prices = [2.0, 5, 3, 8.2, 6, 9, 10]\n    window_size = 3\n    result = tuple(exponential_moving_average(iter(stock_prices), window_size))\n    print(f\"{stock_prices = }\")\n    print(f\"{window_size = }\")\n    print(f\"{result = }\")\n", "financial/interest.py": "# https://www.investopedia.com\n\nfrom __future__ import annotations\n\n\ndef simple_interest(\n    principal: float, daily_interest_rate: float, days_between_payments: float\n) -> float:\n    \"\"\"\n    >>> simple_interest(18000.0, 0.06, 3)\n    3240.0\n    >>> simple_interest(0.5, 0.06, 3)\n    0.09\n    >>> simple_interest(18000.0, 0.01, 10)\n    1800.0\n    >>> simple_interest(18000.0, 0.0, 3)\n    0.0\n    >>> simple_interest(5500.0, 0.01, 100)\n    5500.0\n    >>> simple_interest(10000.0, -0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: daily_interest_rate must be >= 0\n    >>> simple_interest(-10000.0, 0.06, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    >>> simple_interest(5500.0, 0.01, -5)\n    Traceback (most recent call last):\n        ...\n    ValueError: days_between_payments must be > 0\n    \"\"\"\n    if days_between_payments <= 0:\n        raise ValueError(\"days_between_payments must be > 0\")\n    if daily_interest_rate < 0:\n        raise ValueError(\"daily_interest_rate must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n    return principal * daily_interest_rate * days_between_payments\n\n\ndef compound_interest(\n    principal: float,\n    nominal_annual_interest_rate_percentage: float,\n    number_of_compounding_periods: float,\n) -> float:\n    \"\"\"\n    >>> compound_interest(10000.0, 0.05, 3)\n    1576.2500000000014\n    >>> compound_interest(10000.0, 0.05, 1)\n    500.00000000000045\n    >>> compound_interest(0.5, 0.05, 3)\n    0.07881250000000006\n    >>> compound_interest(10000.0, 0.06, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: number_of_compounding_periods must be > 0\n    >>> compound_interest(10000.0, -3.5, 3.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: nominal_annual_interest_rate_percentage must be >= 0\n    >>> compound_interest(-5500.0, 0.01, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    \"\"\"\n    if number_of_compounding_periods <= 0:\n        raise ValueError(\"number_of_compounding_periods must be > 0\")\n    if nominal_annual_interest_rate_percentage < 0:\n        raise ValueError(\"nominal_annual_interest_rate_percentage must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n\n    return principal * (\n        (1 + nominal_annual_interest_rate_percentage) ** number_of_compounding_periods\n        - 1\n    )\n\n\ndef apr_interest(\n    principal: float,\n    nominal_annual_percentage_rate: float,\n    number_of_years: float,\n) -> float:\n    \"\"\"\n    >>> apr_interest(10000.0, 0.05, 3)\n    1618.223072263547\n    >>> apr_interest(10000.0, 0.05, 1)\n    512.6749646744732\n    >>> apr_interest(0.5, 0.05, 3)\n    0.08091115361317736\n    >>> apr_interest(10000.0, 0.06, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: number_of_years must be > 0\n    >>> apr_interest(10000.0, -3.5, 3.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: nominal_annual_percentage_rate must be >= 0\n    >>> apr_interest(-5500.0, 0.01, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: principal must be > 0\n    \"\"\"\n    if number_of_years <= 0:\n        raise ValueError(\"number_of_years must be > 0\")\n    if nominal_annual_percentage_rate < 0:\n        raise ValueError(\"nominal_annual_percentage_rate must be >= 0\")\n    if principal <= 0:\n        raise ValueError(\"principal must be > 0\")\n\n    return compound_interest(\n        principal, nominal_annual_percentage_rate / 365, number_of_years * 365\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "financial/equated_monthly_installments.py": "\"\"\"\nProgram to calculate the amortization amount per month, given\n- Principal borrowed\n- Rate of interest per annum\n- Years to repay the loan\n\nWikipedia Reference: https://en.wikipedia.org/wiki/Equated_monthly_installment\n\"\"\"\n\n\ndef equated_monthly_installments(\n    principal: float, rate_per_annum: float, years_to_repay: int\n) -> float:\n    \"\"\"\n    Formula for amortization amount per month:\n    A = p * r * (1 + r)^n / ((1 + r)^n - 1)\n    where p is the principal, r is the rate of interest per month\n    and n is the number of payments\n\n    >>> equated_monthly_installments(25000, 0.12, 3)\n    830.3577453212793\n    >>> equated_monthly_installments(25000, 0.12, 10)\n    358.67737100646826\n    >>> equated_monthly_installments(0, 0.12, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Principal borrowed must be > 0\n    >>> equated_monthly_installments(25000, -1, 3)\n    Traceback (most recent call last):\n        ...\n    Exception: Rate of interest must be >= 0\n    >>> equated_monthly_installments(25000, 0.12, 0)\n    Traceback (most recent call last):\n        ...\n    Exception: Years to repay must be an integer > 0\n    \"\"\"\n    if principal <= 0:\n        raise Exception(\"Principal borrowed must be > 0\")\n    if rate_per_annum < 0:\n        raise Exception(\"Rate of interest must be >= 0\")\n    if years_to_repay <= 0 or not isinstance(years_to_repay, int):\n        raise Exception(\"Years to repay must be an integer > 0\")\n\n    # Yearly rate is divided by 12 to get monthly rate\n    rate_per_month = rate_per_annum / 12\n\n    # Years to repay is multiplied by 12 to get number of payments as payment is monthly\n    number_of_payments = years_to_repay * 12\n\n    return (\n        principal\n        * rate_per_month\n        * (1 + rate_per_month) ** number_of_payments\n        / ((1 + rate_per_month) ** number_of_payments - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "financial/present_value.py": "\"\"\"\nReference: https://www.investopedia.com/terms/p/presentvalue.asp\n\nAn algorithm that calculates the present value of a stream of yearly cash flows given...\n1. The discount rate (as a decimal, not a percent)\n2. An array of cash flows, with the index of the cash flow being the associated year\n\nNote: This algorithm assumes that cash flows are paid at the end of the specified year\n\"\"\"\n\n\ndef present_value(discount_rate: float, cash_flows: list[float]) -> float:\n    \"\"\"\n    >>> present_value(0.13, [10, 20.70, -293, 297])\n    4.69\n    >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])\n    -42739.63\n    >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])\n    175519.15\n    >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])\n    Traceback (most recent call last):\n        ...\n    ValueError: Discount rate cannot be negative\n    >>> present_value(0.03, [])\n    Traceback (most recent call last):\n        ...\n    ValueError: Cash flows list cannot be empty\n    \"\"\"\n    if discount_rate < 0:\n        raise ValueError(\"Discount rate cannot be negative\")\n    if not cash_flows:\n        raise ValueError(\"Cash flows list cannot be empty\")\n    present_value = sum(\n        cash_flow / ((1 + discount_rate) ** i) for i, cash_flow in enumerate(cash_flows)\n    )\n    return round(present_value, ndigits=2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "financial/simple_moving_average.py": "\"\"\"\nThe Simple Moving Average (SMA) is a statistical calculation used to analyze data points\nby creating a constantly updated average price over a specific time period.\nIn finance, SMA is often used in time series analysis to smooth out price data\nand identify trends.\n\nReference: https://en.wikipedia.org/wiki/Moving_average\n\"\"\"\n\nfrom collections.abc import Sequence\n\n\ndef simple_moving_average(\n    data: Sequence[float], window_size: int\n) -> list[float | None]:\n    \"\"\"\n    Calculate the simple moving average (SMA) for some given time series data.\n\n    :param data: A list of numerical data points.\n    :param window_size: An integer representing the size of the SMA window.\n    :return: A list of SMA values with the same length as the input data.\n\n    Examples:\n    >>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3)\n    >>> [round(value, 2) if value is not None else None for value in sma]\n    [None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0]\n    >>> simple_moving_average([10, 12, 15], 5)\n    [None, None, None]\n    >>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Window size must be a positive integer\n    \"\"\"\n    if window_size < 1:\n        raise ValueError(\"Window size must be a positive integer\")\n\n    sma: list[float | None] = []\n\n    for i in range(len(data)):\n        if i < window_size - 1:\n            sma.append(None)  # SMA not available for early data points\n        else:\n            window = data[i - window_size + 1 : i + 1]\n            sma_value = sum(window) / window_size\n            sma.append(sma_value)\n    return sma\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Example data (replace with your own time series data)\n    data = [10, 12, 15, 13, 14, 16, 18, 17, 19, 21]\n\n    # Specify the window size for the SMA\n    window_size = 3\n\n    # Calculate the Simple Moving Average\n    sma_values = simple_moving_average(data, window_size)\n\n    # Print the SMA values\n    print(\"Simple Moving Average (SMA) Values:\")\n    for i, value in enumerate(sma_values):\n        if value is not None:\n            print(f\"Day {i + 1}: {value:.2f}\")\n        else:\n            print(f\"Day {i + 1}: Not enough data for SMA\")\n", "financial/__init__.py": "", "bit_manipulation/gray_code_sequence.py": "def gray_code(bit_count: int) -> list:\n    \"\"\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\"\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence\n\n\ndef gray_code_sequence_string(bit_count: int) -> list:\n    \"\"\"\n    Will output the n-bit grey sequence as a\n    string of bits\n\n    >>> gray_code_sequence_string(2)\n    ['00', '01', '11', '10']\n\n    >>> gray_code_sequence_string(1)\n    ['0', '1']\n    \"\"\"\n\n    # The approach is a recursive one\n    # Base case achieved when either n = 0 or n=1\n    if bit_count == 0:\n        return [\"0\"]\n\n    if bit_count == 1:\n        return [\"0\", \"1\"]\n\n    seq_len = 1 << bit_count  # defines the length of the sequence\n    # 1<< n is equivalent to 2^n\n\n    # recursive answer will generate answer for n-1 bits\n    smaller_sequence = gray_code_sequence_string(bit_count - 1)\n\n    sequence = []\n\n    # append 0 to first half of the smaller sequence generated\n    for i in range(seq_len // 2):\n        generated_no = \"0\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    # append 1 to second half ... start from the end of the list\n    for i in reversed(range(seq_len // 2)):\n        generated_no = \"1\" + smaller_sequence[i]\n        sequence.append(generated_no)\n\n    return sequence\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_xor_operator.py": "# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\n\n\ndef binary_xor(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary xor operation on the integers provided.\n\n    >>> binary_xor(25, 32)\n    '0b111001'\n    >>> binary_xor(37, 50)\n    '0b010111'\n    >>> binary_xor(21, 30)\n    '0b01011'\n    >>> binary_xor(58, 73)\n    '0b1110011'\n    >>> binary_xor(0, 255)\n    '0b11111111'\n    >>> binary_xor(256, 256)\n    '0b000000000'\n    >>> binary_xor(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_xor(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_xor(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]  # remove the leading \"0b\"\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a != char_b))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_and_operator.py": "# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\n\n\ndef binary_and(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary,\n    return a binary number that is the\n    result of a binary and operation on the integers provided.\n\n    >>> binary_and(25, 32)\n    '0b000000'\n    >>> binary_and(37, 50)\n    '0b100000'\n    >>> binary_and(21, 30)\n    '0b10100'\n    >>> binary_and(58, 73)\n    '0b0001000'\n    >>> binary_and(0, 255)\n    '0b00000000'\n    >>> binary_and(256, 256)\n    '0b100000000'\n    >>> binary_and(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_and(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Unknown format code 'b' for object of type 'float'\n    >>> binary_and(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n\n    a_binary = format(a, \"b\")\n    b_binary = format(b, \"b\")\n\n    max_len = max(len(a_binary), len(b_binary))\n\n    return \"0b\" + \"\".join(\n        str(int(char_a == \"1\" and char_b == \"1\"))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/swap_all_odd_and_even_bits.py": "def show_bits(before: int, after: int) -> str:\n    \"\"\"\n    >>> print(show_bits(0, 0xFFFF))\n        0: 00000000\n    65535: 1111111111111111\n    \"\"\"\n    return f\"{before:>5}: {before:08b}\\n{after:>5}: {after:08b}\"\n\n\ndef swap_odd_even_bits(num: int) -> int:\n    \"\"\"\n    1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and\n       odd bits (1, 3, 5, 7, etc.) in the input number.\n    2. We then right-shift the even bits by 1 position and left-shift the odd bits by\n       1 position to swap them.\n    3. Finally, we combine the swapped even and odd bits using a bitwise OR operation\n       to obtain the final result.\n    >>> print(show_bits(0, swap_odd_even_bits(0)))\n        0: 00000000\n        0: 00000000\n    >>> print(show_bits(1, swap_odd_even_bits(1)))\n        1: 00000001\n        2: 00000010\n    >>> print(show_bits(2, swap_odd_even_bits(2)))\n        2: 00000010\n        1: 00000001\n    >>> print(show_bits(3, swap_odd_even_bits(3)))\n        3: 00000011\n        3: 00000011\n    >>> print(show_bits(4, swap_odd_even_bits(4)))\n        4: 00000100\n        8: 00001000\n    >>> print(show_bits(5, swap_odd_even_bits(5)))\n        5: 00000101\n       10: 00001010\n    >>> print(show_bits(6, swap_odd_even_bits(6)))\n        6: 00000110\n        9: 00001001\n    >>> print(show_bits(23, swap_odd_even_bits(23)))\n       23: 00010111\n       43: 00101011\n    \"\"\"\n    # Get all even bits - 0xAAAAAAAA is a 32-bit number with all even bits set to 1\n    even_bits = num & 0xAAAAAAAA\n\n    # Get all odd bits - 0x55555555 is a 32-bit number with all odd bits set to 1\n    odd_bits = num & 0x55555555\n\n    # Right shift even bits and left shift odd bits and swap them\n    return even_bits >> 1 | odd_bits << 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    for i in (-1, 0, 1, 2, 3, 4, 23, 24):\n        print(show_bits(i, swap_odd_even_bits(i)), \"\\n\")\n", "bit_manipulation/is_power_of_two.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 1, 2022\n\nTask:\nGiven a positive int number. Return True if this number is power of 2\nor False otherwise.\n\nImplementation notes: Use bit manipulation.\nFor example if the number is the power of two it's bits representation:\nn     = 0..100..00\nn - 1 = 0..011..11\n\nn & (n - 1) - no intersections = 0\n\"\"\"\n\n\ndef is_power_of_two(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 2 or False otherwise.\n\n    >>> is_power_of_two(0)\n    True\n    >>> is_power_of_two(1)\n    True\n    >>> is_power_of_two(2)\n    True\n    >>> is_power_of_two(4)\n    True\n    >>> is_power_of_two(6)\n    False\n    >>> is_power_of_two(8)\n    True\n    >>> is_power_of_two(17)\n    False\n    >>> is_power_of_two(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must not be negative\n    >>> is_power_of_two(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for &: 'float' and 'float'\n\n    # Test all powers of 2 from 0 to 10,000\n    >>> all(is_power_of_two(int(2 ** i)) for i in range(10000))\n    True\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"number must not be negative\")\n    return number & (number - 1) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/missing_number.py": "def find_missing_number(nums: list[int]) -> int:\n    \"\"\"\n    Finds the missing number in a list of consecutive integers.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The missing number.\n\n    Example:\n        >>> find_missing_number([0, 1, 3, 4])\n        2\n        >>> find_missing_number([4, 3, 1, 0])\n        2\n        >>> find_missing_number([-4, -3, -1, 0])\n        -2\n        >>> find_missing_number([-2, 2, 1, 3, 0])\n        -1\n        >>> find_missing_number([1, 3, 4, 5, 6])\n        2\n        >>> find_missing_number([6, 5, 4, 2, 1])\n        3\n        >>> find_missing_number([6, 1, 5, 3, 4])\n        2\n    \"\"\"\n    low = min(nums)\n    high = max(nums)\n    missing_number = high\n\n    for i in range(low, high):\n        missing_number ^= i ^ nums[i - low]\n\n    return missing_number\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/power_of_4.py": "\"\"\"\n\nTask:\nGiven a positive int number. Return True if this number is power of 4\nor False otherwise.\n\nImplementation notes: Use bit manipulation.\nFor example if the number is the power of 2 it's bits representation:\nn     = 0..100..00\nn - 1 = 0..011..11\n\nn & (n - 1) - no intersections = 0\nIf the number is a power of 4 then it should be a power of 2\nand the set bit should be at an odd position.\n\"\"\"\n\n\ndef power_of_4(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 4 or False otherwise.\n\n    >>> power_of_4(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1)\n    True\n    >>> power_of_4(2)\n    False\n    >>> power_of_4(4)\n    True\n    >>> power_of_4(6)\n    False\n    >>> power_of_4(8)\n    False\n    >>> power_of_4(17)\n    False\n    >>> power_of_4(64)\n    True\n    >>> power_of_4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be an integer\n\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_or_operator.py": "# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm\n\n\ndef binary_or(a: int, b: int) -> str:\n    \"\"\"\n    Take in 2 integers, convert them to binary, and return a binary number that is the\n    result of a binary or operation on the integers provided.\n\n    >>> binary_or(25, 32)\n    '0b111001'\n    >>> binary_or(37, 50)\n    '0b110111'\n    >>> binary_or(21, 30)\n    '0b11111'\n    >>> binary_or(58, 73)\n    '0b1111011'\n    >>> binary_or(0, 255)\n    '0b11111111'\n    >>> binary_or(0, 256)\n    '0b100000000'\n    >>> binary_or(0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of both inputs must be positive\n    >>> binary_or(0, 1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binary_or(\"0\", \"1\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"the value of both inputs must be positive\")\n    a_binary = str(bin(a))[2:]  # remove the leading \"0b\"\n    b_binary = str(bin(b))[2:]\n    max_len = max(len(a_binary), len(b_binary))\n    return \"0b\" + \"\".join(\n        str(int(\"1\" in (char_a, char_b)))\n        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/reverse_bits.py": "def get_reverse_bit_string(number: int) -> str:\n    \"\"\"\n    return the bit string of an integer\n\n    >>> get_reverse_bit_string(9)\n    '10010000000000000000000000000000'\n    >>> get_reverse_bit_string(43)\n    '11010100000000000000000000000000'\n    >>> get_reverse_bit_string(2873)\n    '10011100110100000000000000000000'\n    >>> get_reverse_bit_string(\"this is not a number\")\n    Traceback (most recent call last):\n        ...\n    TypeError: operation can not be conducted on a object of type str\n    \"\"\"\n    if not isinstance(number, int):\n        msg = (\n            \"operation can not be conducted on a object of type \"\n            f\"{type(number).__name__}\"\n        )\n        raise TypeError(msg)\n    bit_string = \"\"\n    for _ in range(32):\n        bit_string += str(number % 2)\n        number = number >> 1\n    return bit_string\n\n\ndef reverse_bit(number: int) -> str:\n    \"\"\"\n    Take in an 32 bit integer, reverse its bits,\n    return a string of reverse bits\n\n    result of a reverse_bit and operation on the integer provided.\n\n    >>> reverse_bit(25)\n    '00000000000000000000000000011001'\n    >>> reverse_bit(37)\n    '00000000000000000000000000100101'\n    >>> reverse_bit(21)\n    '00000000000000000000000000010101'\n    >>> reverse_bit(58)\n    '00000000000000000000000000111010'\n    >>> reverse_bit(0)\n    '00000000000000000000000000000000'\n    >>> reverse_bit(256)\n    '00000000000000000000000100000000'\n    >>> reverse_bit(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be positive\n\n    >>> reverse_bit(1.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n\n    >>> reverse_bit(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must be positive\")\n    elif isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    elif isinstance(number, str):\n        raise TypeError(\"'<' not supported between instances of 'str' and 'int'\")\n    result = 0\n    # iterator over [1 to 32],since we are dealing with 32 bit integer\n    for _ in range(1, 33):\n        # left shift the bits by unity\n        result = result << 1\n        # get the end bit\n        end_bit = number % 2\n        # right shift the bits by unity\n        number = number >> 1\n        # add that bit to our ans\n        result = result | end_bit\n    return get_reverse_bit_string(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/index_of_rightmost_set_bit.py": "# Reference: https://www.geeksforgeeks.org/position-of-rightmost-set-bit/\n\n\ndef get_index_of_rightmost_set_bit(number: int) -> int:\n    \"\"\"\n    Take in a positive integer 'number'.\n    Returns the zero-based index of first set bit in that 'number' from right.\n    Returns -1, If no set bit found.\n\n    >>> get_index_of_rightmost_set_bit(0)\n    -1\n    >>> get_index_of_rightmost_set_bit(5)\n    0\n    >>> get_index_of_rightmost_set_bit(36)\n    2\n    >>> get_index_of_rightmost_set_bit(8)\n    3\n    >>> get_index_of_rightmost_set_bit(-18)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_index_of_rightmost_set_bit(1.25)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    intermediate = number & ~(number - 1)\n    index = 0\n    while intermediate:\n        intermediate >>= 1\n        index += 1\n    return index - 1\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Finding the index of rightmost set bit has some very peculiar use-cases,\n    especially in finding missing or/and repeating numbers in a list of\n    positive integers.\n    \"\"\"\n    import doctest\n\n    doctest.testmod(verbose=True)\n", "bit_manipulation/binary_count_trailing_zeros.py": "from math import log2\n\n\ndef binary_count_trailing_zeros(a: int) -> int:\n    \"\"\"\n    Take in 1 integer, return a number that is\n    the number of trailing zeros in binary representation of that number.\n\n    >>> binary_count_trailing_zeros(25)\n    0\n    >>> binary_count_trailing_zeros(36)\n    2\n    >>> binary_count_trailing_zeros(16)\n    4\n    >>> binary_count_trailing_zeros(58)\n    1\n    >>> binary_count_trailing_zeros(4294967296)\n    32\n    >>> binary_count_trailing_zeros(0)\n    0\n    >>> binary_count_trailing_zeros(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value must be a positive integer\n    >>> binary_count_trailing_zeros(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_trailing_zeros(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return 0 if (a == 0) else int(log2(a & -a))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_shifts.py": "# Information on binary shifts:\n# https://docs.python.org/3/library/stdtypes.html#bitwise-operations-on-integer-types\n# https://www.interviewcake.com/concept/java/bit-shift\n\n\ndef logical_left_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in 2 positive integers.\n    'number' is the integer to be logically left shifted 'shift_amount' times.\n    i.e. (number << shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_left_shift(0, 1)\n    '0b00'\n    >>> logical_left_shift(1, 1)\n    '0b10'\n    >>> logical_left_shift(1, 5)\n    '0b100000'\n    >>> logical_left_shift(17, 2)\n    '0b1000100'\n    >>> logical_left_shift(1983, 4)\n    '0b111101111110000'\n    >>> logical_left_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))\n    binary_number += \"0\" * shift_amount\n    return binary_number\n\n\ndef logical_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in positive 2 integers.\n    'number' is the integer to be logically right shifted 'shift_amount' times.\n    i.e. (number >>> shift_amount)\n    Return the shifted binary representation.\n\n    >>> logical_right_shift(0, 1)\n    '0b0'\n    >>> logical_right_shift(1, 1)\n    '0b0'\n    >>> logical_right_shift(1, 5)\n    '0b0'\n    >>> logical_right_shift(17, 2)\n    '0b100'\n    >>> logical_right_shift(1983, 4)\n    '0b1111011'\n    >>> logical_right_shift(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: both inputs must be positive integers\n    \"\"\"\n    if number < 0 or shift_amount < 0:\n        raise ValueError(\"both inputs must be positive integers\")\n\n    binary_number = str(bin(number))[2:]\n    if shift_amount >= len(binary_number):\n        return \"0b0\"\n    shifted_binary_number = binary_number[: len(binary_number) - shift_amount]\n    return \"0b\" + shifted_binary_number\n\n\ndef arithmetic_right_shift(number: int, shift_amount: int) -> str:\n    \"\"\"\n    Take in 2 integers.\n    'number' is the integer to be arithmetically right shifted 'shift_amount' times.\n    i.e. (number >> shift_amount)\n    Return the shifted binary representation.\n\n    >>> arithmetic_right_shift(0, 1)\n    '0b00'\n    >>> arithmetic_right_shift(1, 1)\n    '0b00'\n    >>> arithmetic_right_shift(-1, 1)\n    '0b11'\n    >>> arithmetic_right_shift(17, 2)\n    '0b000100'\n    >>> arithmetic_right_shift(-17, 2)\n    '0b111011'\n    >>> arithmetic_right_shift(-1983, 4)\n    '0b111110000100'\n    \"\"\"\n    if number >= 0:  # Get binary representation of positive number\n        binary_number = \"0\" + str(bin(number)).strip(\"-\")[2:]\n    else:  # Get binary (2's complement) representation of negative number\n        binary_number_length = len(bin(number)[3:])  # Find 2's complement of number\n        binary_number = bin(abs(number) - (1 << binary_number_length))[3:]\n        binary_number = (\n            \"1\" + \"0\" * (binary_number_length - len(binary_number)) + binary_number\n        )\n\n    if shift_amount >= len(binary_number):\n        return \"0b\" + binary_number[0] * len(binary_number)\n    return (\n        \"0b\"\n        + binary_number[0] * shift_amount\n        + binary_number[: len(binary_number) - shift_amount]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_coded_decimal.py": "def binary_coded_decimal(number: int) -> str:\n    \"\"\"\n    Find binary coded decimal (bcd) of integer base 10.\n    Each digit of the number is represented by a 4-bit binary.\n    Example:\n    >>> binary_coded_decimal(-2)\n    '0b0000'\n    >>> binary_coded_decimal(-1)\n    '0b0000'\n    >>> binary_coded_decimal(0)\n    '0b0000'\n    >>> binary_coded_decimal(3)\n    '0b0011'\n    >>> binary_coded_decimal(2)\n    '0b0010'\n    >>> binary_coded_decimal(12)\n    '0b00010010'\n    >>> binary_coded_decimal(987)\n    '0b100110000111'\n    \"\"\"\n    return \"0b\" + \"\".join(\n        str(bin(int(digit)))[2:].zfill(4) for digit in str(max(0, number))\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/numbers_different_signs.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 30, 2022\n\nTask:\nGiven two int numbers. Return True these numbers have opposite signs\nor False otherwise.\n\nImplementation notes: Use bit manipulation.\nUse XOR for two numbers.\n\"\"\"\n\n\ndef different_signs(num1: int, num2: int) -> bool:\n    \"\"\"\n    Return True if numbers have opposite signs False otherwise.\n\n    >>> different_signs(1, -1)\n    True\n    >>> different_signs(1, 1)\n    False\n    >>> different_signs(1000000000000000000000000000, -1000000000000000000000000000)\n    True\n    >>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000)\n    True\n    >>> different_signs(50, 278)\n    False\n    >>> different_signs(0, 2)\n    False\n    >>> different_signs(2, 0)\n    False\n    \"\"\"\n    return num1 ^ num2 < 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/highest_set_bit.py": "def get_highest_set_bit_position(number: int) -> int:\n    \"\"\"\n    Returns position of the highest set bit of a number.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious\n    >>> get_highest_set_bit_position(25)\n    5\n    >>> get_highest_set_bit_position(37)\n    6\n    >>> get_highest_set_bit_position(1)\n    1\n    >>> get_highest_set_bit_position(4)\n    3\n    >>> get_highest_set_bit_position(0)\n    0\n    >>> get_highest_set_bit_position(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be an 'int' type\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input value must be an 'int' type\")\n\n    position = 0\n    while number:\n        position += 1\n        number >>= 1\n\n    return position\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/single_bit_manipulation_operations.py": "#!/usr/bin/env python3\n\n\"\"\"Provide the functionality to manipulate a single bit.\"\"\"\n\n\ndef set_bit(number: int, position: int) -> int:\n    \"\"\"\n    Set the bit at position to 1.\n\n    Details: perform bitwise or for given number and X.\n    Where X is a number with all the bits - zeroes and bit on given\n    position - one.\n\n    >>> set_bit(0b1101, 1) # 0b1111\n    15\n    >>> set_bit(0b0, 5) # 0b100000\n    32\n    >>> set_bit(0b1111, 1) # 0b1111\n    15\n    \"\"\"\n    return number | (1 << position)\n\n\ndef clear_bit(number: int, position: int) -> int:\n    \"\"\"\n    Set the bit at position to 0.\n\n    Details: perform bitwise and for given number and X.\n    Where X is a number with all the bits - ones and bit on given\n    position - zero.\n\n    >>> clear_bit(0b10010, 1) # 0b10000\n    16\n    >>> clear_bit(0b0, 5) # 0b0\n    0\n    \"\"\"\n    return number & ~(1 << position)\n\n\ndef flip_bit(number: int, position: int) -> int:\n    \"\"\"\n    Flip the bit at position.\n\n    Details: perform bitwise xor for given number and X.\n    Where X is a number with all the bits - zeroes and bit on given\n    position - one.\n\n    >>> flip_bit(0b101, 1) # 0b111\n    7\n    >>> flip_bit(0b101, 0) # 0b100\n    4\n    \"\"\"\n    return number ^ (1 << position)\n\n\ndef is_bit_set(number: int, position: int) -> bool:\n    \"\"\"\n    Is the bit at position set?\n\n    Details: Shift the bit at position to be the first (smallest) bit.\n    Then check if the first bit is set by anding the shifted number with 1.\n\n    >>> is_bit_set(0b1010, 0)\n    False\n    >>> is_bit_set(0b1010, 1)\n    True\n    >>> is_bit_set(0b1010, 2)\n    False\n    >>> is_bit_set(0b1010, 3)\n    True\n    >>> is_bit_set(0b0, 17)\n    False\n    \"\"\"\n    return ((number >> position) & 1) == 1\n\n\ndef get_bit(number: int, position: int) -> int:\n    \"\"\"\n    Get the bit at the given position\n\n    Details: perform bitwise and for the given number and X,\n    Where X is a number with all the bits - zeroes and bit on given position - one.\n    If the result is not equal to 0, then the bit on the given position is 1, else 0.\n\n    >>> get_bit(0b1010, 0)\n    0\n    >>> get_bit(0b1010, 1)\n    1\n    >>> get_bit(0b1010, 2)\n    0\n    >>> get_bit(0b1010, 3)\n    1\n    \"\"\"\n    return int((number & (1 << position)) != 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/is_even.py": "def is_even(number: int) -> bool:\n    \"\"\"\n    return true if the input integer is even\n    Explanation: Lets take a look at the following decimal to binary conversions\n    2 => 10\n    14 => 1110\n    100 => 1100100\n    3 => 11\n    13 => 1101\n    101 => 1100101\n    from the above examples we can observe that\n    for all the odd integers there is always 1 set bit at the end\n    also, 1 in binary can be represented as 001, 00001, or 0000001\n    so for any odd integer n => n&1 is always equals 1 else the integer is even\n\n    >>> is_even(1)\n    False\n    >>> is_even(4)\n    True\n    >>> is_even(9)\n    False\n    >>> is_even(15)\n    False\n    >>> is_even(40)\n    True\n    >>> is_even(100)\n    True\n    >>> is_even(101)\n    False\n    \"\"\"\n    return number & 1 == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/count_number_of_one_bits.py": "from timeit import timeit\n\n\ndef get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)\n    3\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)\n    4\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)\n    0\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)\n    1\n    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        number &= number - 1\n        result += 1\n    return result\n\n\ndef get_set_bits_count_using_modulo_operator(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer\n    >>> get_set_bits_count_using_modulo_operator(25)\n    3\n    >>> get_set_bits_count_using_modulo_operator(37)\n    3\n    >>> get_set_bits_count_using_modulo_operator(21)\n    3\n    >>> get_set_bits_count_using_modulo_operator(58)\n    4\n    >>> get_set_bits_count_using_modulo_operator(0)\n    0\n    >>> get_set_bits_count_using_modulo_operator(256)\n    1\n    >>> get_set_bits_count_using_modulo_operator(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be negative\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"the value of input must not be negative\")\n    result = 0\n    while number:\n        if number % 2 == 1:\n            result += 1\n        number >>= 1\n    return result\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark code for comparing 2 functions, with different length int values.\n    Brian Kernighan's algorithm is consistently faster than using modulo_operator.\n    \"\"\"\n\n    def do_benchmark(number: int) -> None:\n        setup = \"import __main__ as z\"\n        print(f\"Benchmark when {number = }:\")\n        print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n        print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",\n            setup=setup,\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n\n    for number in (25, 37, 58, 0):\n        do_benchmark(number)\n        print()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "bit_manipulation/largest_pow_of_two_le_num.py": "\"\"\"\nAuthor  : Naman Sharma\nDate    : October 2, 2023\n\nTask:\nTo Find the largest power of 2 less than or equal to a given number.\n\nImplementation notes: Use bit manipulation.\nWe start from 1 & left shift the set bit to check if (res<<1)<=number.\nEach left bit shift represents a pow of 2.\n\nFor example:\nnumber: 15\nres:    1   0b1\n        2   0b10\n        4   0b100\n        8   0b1000\n        16  0b10000 (Exit)\n\"\"\"\n\n\ndef largest_pow_of_two_le_num(number: int) -> int:\n    \"\"\"\n    Return the largest power of two less than or equal to a number.\n\n    >>> largest_pow_of_two_le_num(0)\n    0\n    >>> largest_pow_of_two_le_num(1)\n    1\n    >>> largest_pow_of_two_le_num(-1)\n    0\n    >>> largest_pow_of_two_le_num(3)\n    2\n    >>> largest_pow_of_two_le_num(15)\n    8\n    >>> largest_pow_of_two_le_num(99)\n    64\n    >>> largest_pow_of_two_le_num(178)\n    128\n    >>> largest_pow_of_two_le_num(999999)\n    524288\n    >>> largest_pow_of_two_le_num(99.9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    \"\"\"\n    if isinstance(number, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    if number <= 0:\n        return 0\n    res = 1\n    while (res << 1) <= number:\n        res <<= 1\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/count_1s_brian_kernighan_method.py": "def get_1s_count(number: int) -> int:\n    \"\"\"\n    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.\n    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n    >>> get_1s_count(25)\n    3\n    >>> get_1s_count(37)\n    3\n    >>> get_1s_count(21)\n    3\n    >>> get_1s_count(58)\n    4\n    >>> get_1s_count(0)\n    0\n    >>> get_1s_count(256)\n    1\n    >>> get_1s_count(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(0.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> get_1s_count(\"25\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    count = 0\n    while number:\n        # This way we arrive at next set bit (next 1) instead of looping\n        # through each bit and checking for 1s hence the\n        # loop won't run 32 times it will only run the number of `1` times\n        number &= number - 1\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/bitwise_addition_recursive.py": "\"\"\"\nCalculates the sum of two non-negative integers using bitwise operators\nWikipedia explanation: https://en.wikipedia.org/wiki/Binary_number\n\"\"\"\n\n\ndef bitwise_addition_recursive(number: int, other_number: int) -> int:\n    \"\"\"\n    >>> bitwise_addition_recursive(4, 5)\n    9\n    >>> bitwise_addition_recursive(8, 9)\n    17\n    >>> bitwise_addition_recursive(0, 4)\n    4\n    >>> bitwise_addition_recursive(4.5, 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4', 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive('4.5', 9)\n    Traceback (most recent call last):\n        ...\n    TypeError: Both arguments MUST be integers!\n    >>> bitwise_addition_recursive(-1, 9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both arguments MUST be non-negative!\n    >>> bitwise_addition_recursive(1, -9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both arguments MUST be non-negative!\n    \"\"\"\n\n    if not isinstance(number, int) or not isinstance(other_number, int):\n        raise TypeError(\"Both arguments MUST be integers!\")\n\n    if number < 0 or other_number < 0:\n        raise ValueError(\"Both arguments MUST be non-negative!\")\n\n    bitwise_sum = number ^ other_number\n    carry = number & other_number\n\n    if carry == 0:\n        return bitwise_sum\n\n    return bitwise_addition_recursive(bitwise_sum, carry << 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/find_previous_power_of_two.py": "def find_previous_power_of_two(number: int) -> int:\n    \"\"\"\n    Find the largest power of two that is less than or equal to a given integer.\n    https://stackoverflow.com/questions/1322510\n\n    >>> [find_previous_power_of_two(i) for i in range(18)]\n    [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]\n    >>> find_previous_power_of_two(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    >>> find_previous_power_of_two(10.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if number == 0:\n        return 0\n    power = 1\n    while power <= number:\n        power <<= 1  # Equivalent to multiplying by 2\n    return power >> 1 if number > 1 else 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/__init__.py": "", "bit_manipulation/excess_3_code.py": "def excess_3_code(number: int) -> str:\n    \"\"\"\n    Find excess-3 code of integer base 10.\n    Add 3 to all digits in a decimal number then convert to a binary-coded decimal.\n    https://en.wikipedia.org/wiki/Excess-3\n\n    >>> excess_3_code(0)\n    '0b0011'\n    >>> excess_3_code(3)\n    '0b0110'\n    >>> excess_3_code(2)\n    '0b0101'\n    >>> excess_3_code(20)\n    '0b01010011'\n    >>> excess_3_code(120)\n    '0b010001010011'\n    \"\"\"\n    num = \"\"\n    for digit in str(max(0, number)):\n        num += str(bin(int(digit) + 3))[2:].zfill(4)\n    return \"0b\" + num\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_twos_complement.py": "# Information on 2's complement: https://en.wikipedia.org/wiki/Two%27s_complement\n\n\ndef twos_complement(number: int) -> str:\n    \"\"\"\n    Take in a negative integer 'number'.\n    Return the two's complement representation of 'number'.\n\n    >>> twos_complement(0)\n    '0b0'\n    >>> twos_complement(-1)\n    '0b11'\n    >>> twos_complement(-5)\n    '0b1011'\n    >>> twos_complement(-17)\n    '0b101111'\n    >>> twos_complement(-207)\n    '0b100110001'\n    >>> twos_complement(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: input must be a negative integer\n    \"\"\"\n    if number > 0:\n        raise ValueError(\"input must be a negative integer\")\n    binary_number_length = len(bin(number)[3:])\n    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\n    twos_complement_number = (\n        (\n            \"1\"\n            + \"0\" * (binary_number_length - len(twos_complement_number))\n            + twos_complement_number\n        )\n        if number < 0\n        else \"0\"\n    )\n    return \"0b\" + twos_complement_number\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "bit_manipulation/binary_count_setbits.py": "def binary_count_setbits(a: int) -> int:\n    \"\"\"\n    Take in 1 integer, return a number that is\n    the number of 1's in binary representation of that number.\n\n    >>> binary_count_setbits(25)\n    3\n    >>> binary_count_setbits(36)\n    2\n    >>> binary_count_setbits(16)\n    1\n    >>> binary_count_setbits(58)\n    4\n    >>> binary_count_setbits(4294967295)\n    32\n    >>> binary_count_setbits(0)\n    0\n    >>> binary_count_setbits(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value must be a positive integer\n    >>> binary_count_setbits(0.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a 'int' type\n    >>> binary_count_setbits(\"0\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Input value must be a positive integer\")\n    elif isinstance(a, float):\n        raise TypeError(\"Input value must be a 'int' type\")\n    return bin(a).count(\"1\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/quine_mc_cluskey.py": "from __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Literal\n\n\ndef compare_string(string1: str, string2: str) -> str | Literal[False]:\n    \"\"\"\n    >>> compare_string('0010','0110')\n    '0_10'\n\n    >>> compare_string('0110','1101')\n    False\n    \"\"\"\n    list1 = list(string1)\n    list2 = list(string2)\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] != list2[i]:\n            count += 1\n            list1[i] = \"_\"\n    if count > 1:\n        return False\n    else:\n        return \"\".join(list1)\n\n\ndef check(binary: list[str]) -> list[str]:\n    \"\"\"\n    >>> check(['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    pi = []\n    while True:\n        check1 = [\"$\"] * len(binary)\n        temp = []\n        for i in range(len(binary)):\n            for j in range(i + 1, len(binary)):\n                k = compare_string(binary[i], binary[j])\n                if k is False:\n                    check1[i] = \"*\"\n                    check1[j] = \"*\"\n                    temp.append(\"X\")\n        for i in range(len(binary)):\n            if check1[i] == \"$\":\n                pi.append(binary[i])\n        if len(temp) == 0:\n            return pi\n        binary = list(set(temp))\n\n\ndef decimal_to_binary(no_of_variable: int, minterms: Sequence[float]) -> list[str]:\n    \"\"\"\n    >>> decimal_to_binary(3,[1.5])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    for minterm in minterms:\n        string = \"\"\n        for _ in range(no_of_variable):\n            string = str(minterm % 2) + string\n            minterm //= 2\n        temp.append(string)\n    return temp\n\n\ndef is_for_table(string1: str, string2: str, count: int) -> bool:\n    \"\"\"\n    >>> is_for_table('__1','011',2)\n    True\n\n    >>> is_for_table('01_','001',1)\n    False\n    \"\"\"\n    list1 = list(string1)\n    list2 = list(string2)\n    count_n = sum(item1 != item2 for item1, item2 in zip(list1, list2))\n    return count_n == count\n\n\ndef selection(chart: list[list[int]], prime_implicants: list[str]) -> list[str]:\n    \"\"\"\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n\n    >>> selection([[1]],['0.00.01.5'])\n    ['0.00.01.5']\n    \"\"\"\n    temp = []\n    select = [0] * len(chart)\n    for i in range(len(chart[0])):\n        count = sum(row[i] == 1 for row in chart)\n        if count == 1:\n            rem = max(j for j, row in enumerate(chart) if row[i] == 1)\n            select[rem] = 1\n    for i, item in enumerate(select):\n        if item != 1:\n            continue\n        for j in range(len(chart[0])):\n            if chart[i][j] != 1:\n                continue\n            for row in chart:\n                row[j] = 0\n        temp.append(prime_implicants[i])\n    while True:\n        counts = [chart[i].count(1) for i in range(len(chart))]\n        max_n = max(counts)\n        rem = counts.index(max_n)\n\n        if max_n == 0:\n            return temp\n\n        temp.append(prime_implicants[rem])\n\n        for j in range(len(chart[0])):\n            if chart[rem][j] != 1:\n                continue\n            for i in range(len(chart)):\n                chart[i][j] = 0\n\n\ndef prime_implicant_chart(\n    prime_implicants: list[str], binary: list[str]\n) -> list[list[int]]:\n    \"\"\"\n    >>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])\n    [[1]]\n    \"\"\"\n    chart = [[0 for x in range(len(binary))] for x in range(len(prime_implicants))]\n    for i in range(len(prime_implicants)):\n        count = prime_implicants[i].count(\"_\")\n        for j in range(len(binary)):\n            if is_for_table(prime_implicants[i], binary[j], count):\n                chart[i][j] = 1\n\n    return chart\n\n\ndef main() -> None:\n    no_of_variable = int(input(\"Enter the no. of variables\\n\"))\n    minterms = [\n        float(x)\n        for x in input(\n            \"Enter the decimal representation of Minterms 'Spaces Separated'\\n\"\n        ).split()\n    ]\n    binary = decimal_to_binary(no_of_variable, minterms)\n\n    prime_implicants = check(binary)\n    print(\"Prime Implicants are:\")\n    print(prime_implicants)\n    chart = prime_implicant_chart(prime_implicants, binary)\n\n    essential_prime_implicants = selection(chart, prime_implicants)\n    print(\"Essential Prime Implicants are:\")\n    print(essential_prime_implicants)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "boolean_algebra/nimply_gate.py": "\"\"\"\nAn NIMPLY Gate is a logic gate in boolean algebra which results to 0 if\neither input 1 is 0, or if input 1 is 1, then it is 0 only if input 2 is 1.\nIt is false if input 1 implies input 2. It is the negated form of imply\n\nFollowing is the truth table of an NIMPLY Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    0   |\n    |    0    |    1    |    0   |\n    |    1    |    0    |    1   |\n    |    1    |    1    |    0   |\n    ------------------------------\n\nRefer - https://en.wikipedia.org/wiki/NIMPLY_gate\n\"\"\"\n\n\ndef nimply_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate NIMPLY of the input values\n\n    >>> nimply_gate(0, 0)\n    0\n    >>> nimply_gate(0, 1)\n    0\n    >>> nimply_gate(1, 0)\n    1\n    >>> nimply_gate(1, 1)\n    0\n    \"\"\"\n    return int(input_1 == 1 and input_2 == 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/karnaugh_map_simplification.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Karnaugh_map\nhttps://www.allaboutcircuits.com/technical-articles/karnaugh-map-boolean-algebraic-simplification-technique\n\"\"\"\n\n\ndef simplify_kmap(kmap: list[list[int]]) -> str:\n    \"\"\"\n    Simplify the Karnaugh map.\n    >>> simplify_kmap(kmap=[[0, 1], [1, 1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 0], [0, 0]])\n    ''\n    >>> simplify_kmap(kmap=[[0, 1], [1, -1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 2]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 1.1]])\n    \"A'B + AB' + AB\"\n    >>> simplify_kmap(kmap=[[0, 1], [1, 'a']])\n    \"A'B + AB' + AB\"\n    \"\"\"\n    simplified_f = []\n    for a, row in enumerate(kmap):\n        for b, item in enumerate(row):\n            if item:\n                term = (\"A\" if a else \"A'\") + (\"B\" if b else \"B'\")\n                simplified_f.append(term)\n    return \" + \".join(simplified_f)\n\n\ndef main() -> None:\n    \"\"\"\n    Main function to create and simplify a K-Map.\n\n    >>> main()\n    [0, 1]\n    [1, 1]\n    Simplified Expression:\n    A'B + AB' + AB\n    \"\"\"\n    kmap = [[0, 1], [1, 1]]\n\n    # Manually generate the product of [0, 1] and [0, 1]\n\n    for row in kmap:\n        print(row)\n\n    print(\"Simplified Expression:\")\n    print(simplify_kmap(kmap))\n\n\nif __name__ == \"__main__\":\n    main()\n    print(f\"{simplify_kmap(kmap=[[0, 1], [1, 1]]) = }\")\n", "boolean_algebra/imply_gate.py": "\"\"\"\nAn IMPLY Gate is a logic gate in boolean algebra which results to 1 if\neither input 1 is 0, or if input 1 is 1, then the output is 1 only if input 2 is 1.\nIt is true if input 1 implies input 2.\n\nFollowing is the truth table of an IMPLY Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    1   |\n    |    0    |    1    |    1   |\n    |    1    |    0    |    0   |\n    |    1    |    1    |    1   |\n    ------------------------------\n\nRefer - https://en.wikipedia.org/wiki/IMPLY_gate\n\"\"\"\n\n\ndef imply_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate IMPLY of the input values\n\n    >>> imply_gate(0, 0)\n    1\n    >>> imply_gate(0, 1)\n    1\n    >>> imply_gate(1, 0)\n    0\n    >>> imply_gate(1, 1)\n    1\n    \"\"\"\n    return int(input_1 == 0 or input_2 == 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/nand_gate.py": "\"\"\"\nA NAND Gate is a logic gate in boolean algebra which results to 0 (False) if both\nthe inputs are 1, and 1 (True) otherwise. It's similar to adding\na NOT gate along with an AND gate.\nFollowing is the truth table of a NAND Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    1   |\n    |    0    |    1    |    1   |\n    |    1    |    0    |    1   |\n    |    1    |    1    |    0   |\n    ------------------------------\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef nand_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate NAND of the input values\n    >>> nand_gate(0, 0)\n    1\n    >>> nand_gate(0, 1)\n    1\n    >>> nand_gate(1, 0)\n    1\n    >>> nand_gate(1, 1)\n    0\n    \"\"\"\n    return int(not (input_1 and input_2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/not_gate.py": "\"\"\"\nA NOT Gate is a logic gate in boolean algebra which results to 0 (False) if the\ninput is high, and 1 (True) if the input is low.\nFollowing is the truth table of a XOR Gate:\n    ------------------------------\n    | Input   |  Output |\n    ------------------------------\n    |    0    |    1    |\n    |    1    |    0    |\n    ------------------------------\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef not_gate(input_1: int) -> int:\n    \"\"\"\n    Calculate NOT of the input values\n    >>> not_gate(0)\n    1\n    >>> not_gate(1)\n    0\n    \"\"\"\n\n    return 1 if input_1 == 0 else 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/or_gate.py": "\"\"\"\nAn OR Gate is a logic gate in boolean algebra which results to 0 (False) if both the\ninputs are 0, and 1 (True) otherwise.\nFollowing is the truth table of an AND Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    0   |\n    |    0    |    1    |    1   |\n    |    1    |    0    |    1   |\n    |    1    |    1    |    1   |\n    ------------------------------\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef or_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate OR of the input values\n    >>> or_gate(0, 0)\n    0\n    >>> or_gate(0, 1)\n    1\n    >>> or_gate(1, 0)\n    1\n    >>> or_gate(1, 1)\n    1\n    \"\"\"\n    return int((input_1, input_2).count(1) != 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/multiplexer.py": "def mux(input0: int, input1: int, select: int) -> int:\n    \"\"\"\n    Implement a 2-to-1 Multiplexer.\n\n    :param input0: The first input value (0 or 1).\n    :param input1: The second input value (0 or 1).\n    :param select: The select signal (0 or 1) to choose between input0 and input1.\n    :return: The output based on the select signal.  input1 if select else input0.\n\n    https://www.electrically4u.com/solved-problems-on-multiplexer\n    https://en.wikipedia.org/wiki/Multiplexer\n\n    >>> mux(0, 1, 0)\n    0\n    >>> mux(0, 1, 1)\n    1\n    >>> mux(1, 0, 0)\n    1\n    >>> mux(1, 0, 1)\n    0\n    >>> mux(2, 1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    >>> mux(0, -1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    >>> mux(0, 1, 1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inputs and select signal must be 0 or 1\n    \"\"\"\n    if all(i in (0, 1) for i in (input0, input1, select)):\n        return input1 if select else input0\n    raise ValueError(\"Inputs and select signal must be 0 or 1\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/__init__.py": "", "boolean_algebra/xor_gate.py": "\"\"\"\nA XOR Gate is a logic gate in boolean algebra which results to 1 (True) if only one of\nthe two inputs is 1, and 0 (False) if an even number of inputs are 1.\nFollowing is the truth table of a XOR Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    0   |\n    |    0    |    1    |    1   |\n    |    1    |    0    |    1   |\n    |    1    |    1    |    0   |\n    ------------------------------\n\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef xor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    calculate xor of the input values\n\n    >>> xor_gate(0, 0)\n    0\n    >>> xor_gate(0, 1)\n    1\n    >>> xor_gate(1, 0)\n    1\n    >>> xor_gate(1, 1)\n    0\n    \"\"\"\n    return (input_1, input_2).count(0) % 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/xnor_gate.py": "\"\"\"\nA XNOR Gate is a logic gate in boolean algebra which results to 0 (False) if both the\ninputs are different, and 1 (True), if the inputs are same.\nIt's similar to adding a NOT gate to an XOR gate\n\nFollowing is the truth table of a XNOR Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    1   |\n    |    0    |    1    |    0   |\n    |    1    |    0    |    0   |\n    |    1    |    1    |    1   |\n    ------------------------------\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef xnor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate XOR of the input values\n    >>> xnor_gate(0, 0)\n    1\n    >>> xnor_gate(0, 1)\n    0\n    >>> xnor_gate(1, 0)\n    0\n    >>> xnor_gate(1, 1)\n    1\n    \"\"\"\n    return 1 if input_1 == input_2 else 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "boolean_algebra/nor_gate.py": "\"\"\"\nA NOR Gate is a logic gate in boolean algebra which results in false(0) if any of the\ninputs is 1, and True(1) if all inputs are 0.\nFollowing is the truth table of a NOR Gate:\n    Truth Table of NOR Gate:\n    | Input 1  | Input 2  |  Output  |\n    |    0     |    0     |    1     |\n    |    0     |    1     |    0     |\n    |    1     |    0     |    0     |\n    |    1     |    1     |    0     |\n\n    Code provided by Akshaj Vishwanathan\nhttps://www.geeksforgeeks.org/logic-gates-in-python\n\"\"\"\n\nfrom collections.abc import Callable\n\n\ndef nor_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    >>> nor_gate(0, 0)\n    1\n    >>> nor_gate(0, 1)\n    0\n    >>> nor_gate(1, 0)\n    0\n    >>> nor_gate(1, 1)\n    0\n    >>> nor_gate(0.0, 0.0)\n    1\n    >>> nor_gate(0, -7)\n    0\n    \"\"\"\n    return int(input_1 == input_2 == 0)\n\n\ndef truth_table(func: Callable) -> str:\n    \"\"\"\n    >>> print(truth_table(nor_gate))\n    Truth Table of NOR Gate:\n    | Input 1  | Input 2  |  Output  |\n    |    0     |    0     |    1     |\n    |    0     |    1     |    0     |\n    |    1     |    0     |    0     |\n    |    1     |    1     |    0     |\n    \"\"\"\n\n    def make_table_row(items: list | tuple) -> str:\n        \"\"\"\n        >>> make_table_row((\"One\", \"Two\", \"Three\"))\n        '|   One    |   Two    |  Three   |'\n        \"\"\"\n        return f\"| {' | '.join(f'{item:^8}' for item in items)} |\"\n\n    return \"\\n\".join(\n        (\n            \"Truth Table of NOR Gate:\",\n            make_table_row((\"Input 1\", \"Input 2\", \"Output\")),\n            *[make_table_row((i, j, func(i, j))) for i in (0, 1) for j in (0, 1)],\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(truth_table(nor_gate))\n", "boolean_algebra/and_gate.py": "\"\"\"\nAn AND Gate is a logic gate in boolean algebra which results to 1 (True) if both the\ninputs are 1, and 0 (False) otherwise.\n\nFollowing is the truth table of an AND Gate:\n    ------------------------------\n    | Input 1 | Input 2 | Output |\n    ------------------------------\n    |    0    |    0    |    0   |\n    |    0    |    1    |    0   |\n    |    1    |    0    |    0   |\n    |    1    |    1    |    1   |\n    ------------------------------\n\nRefer - https://www.geeksforgeeks.org/logic-gates-in-python/\n\"\"\"\n\n\ndef and_gate(input_1: int, input_2: int) -> int:\n    \"\"\"\n    Calculate AND of the input values\n\n    >>> and_gate(0, 0)\n    0\n    >>> and_gate(0, 1)\n    0\n    >>> and_gate(1, 0)\n    0\n    >>> and_gate(1, 1)\n    1\n    \"\"\"\n    return int(input_1 and input_2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/fractional_cover_problem.py": "# https://en.wikipedia.org/wiki/Set_cover_problem\n\nfrom dataclasses import dataclass\nfrom operator import attrgetter\n\n\n@dataclass\nclass Item:\n    weight: int\n    value: int\n\n    @property\n    def ratio(self) -> float:\n        \"\"\"\n        Return the value-to-weight ratio for the item.\n\n        Returns:\n            float: The value-to-weight ratio for the item.\n\n        Examples:\n        >>> Item(10, 65).ratio\n        6.5\n\n        >>> Item(20, 100).ratio\n        5.0\n\n        >>> Item(30, 120).ratio\n        4.0\n        \"\"\"\n        return self.value / self.weight\n\n\ndef fractional_cover(items: list[Item], capacity: int) -> float:\n    \"\"\"\n    Solve the Fractional Cover Problem.\n\n    Args:\n        items: A list of items, where each item has weight and value attributes.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        The maximum value that can be obtained by selecting fractions of items to cover\n        the knapsack's capacity.\n\n    Raises:\n        ValueError: If capacity is negative.\n\n    Examples:\n    >>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)\n    240.0\n\n    >>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)\n    135.0\n\n    >>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)\n    280.0\n\n    >>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)\n    180.0\n\n    >>> fractional_cover(items=[], capacity=50)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=5)\n    30.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=1)\n    6.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=0)\n    0.0\n\n    >>> fractional_cover(items=[Item(10, 60)], capacity=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacity cannot be negative\n    \"\"\"\n    if capacity < 0:\n        raise ValueError(\"Capacity cannot be negative\")\n\n    total_value = 0.0\n    remaining_capacity = capacity\n\n    # Sort the items by their value-to-weight ratio in descending order\n    for item in sorted(items, key=attrgetter(\"ratio\"), reverse=True):\n        if remaining_capacity == 0:\n            break\n\n        weight_taken = min(item.weight, remaining_capacity)\n        total_value += weight_taken * item.ratio\n        remaining_capacity -= weight_taken\n\n    return total_value\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    if result := doctest.testmod().failed:\n        print(f\"{result} test(s) failed\")\n    else:\n        print(\"All tests passed\")\n", "greedy_methods/fractional_knapsack_2.py": "# https://en.wikipedia.org/wiki/Continuous_knapsack_problem\n# https://www.guru99.com/fractional-knapsack-problem-greedy.html\n# https://medium.com/walkinthecode/greedy-algorithm-fractional-knapsack-problem-9aba1daecc93\n\nfrom __future__ import annotations\n\n\ndef fractional_knapsack(\n    value: list[int], weight: list[int], capacity: int\n) -> tuple[float, list[float]]:\n    \"\"\"\n    >>> value = [1, 3, 5, 7, 9]\n    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]\n    >>> fractional_knapsack(value, weight, 5)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 15)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 25)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, 26)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack(value, weight, -1)\n    (-90.0, [0, 0, 0, 0, -10.0])\n    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)\n    (16, [1, 1, 1, 1])\n    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)\n    (25, [1, 1, 1, 1, 1])\n    >>> fractional_knapsack([], [], 30)\n    (0, [])\n    \"\"\"\n    index = list(range(len(value)))\n    ratio = [v / w for v, w in zip(value, weight)]\n    index.sort(key=lambda i: ratio[i], reverse=True)\n\n    max_value: float = 0\n    fractions: list[float] = [0] * len(value)\n    for i in index:\n        if weight[i] <= capacity:\n            fractions[i] = 1\n            max_value += value[i]\n            capacity -= weight[i]\n        else:\n            fractions[i] = capacity / weight[i]\n            max_value += value[i] * capacity / weight[i]\n            break\n\n    return max_value, fractions\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/optimal_merge_pattern.py": "\"\"\"\nThis is a pure Python implementation of the greedy-merge-sort algorithm\nreference: https://www.geeksforgeeks.org/optimal-file-merge-patterns/\n\nFor doctests run following command:\npython3 -m doctest -v greedy_merge_sort.py\n\nObjective\nMerge a set of sorted files of different length into a single sorted file.\nWe need to find an optimal solution, where the resultant file\nwill be generated in minimum time.\n\nApproach\nIf the number of sorted files are given, there are many ways\nto merge them into a single sorted file.\nThis merge can be performed pair wise.\nTo merge a m-record file and a n-record file requires possibly m+n record moves\nthe optimal choice being,\nmerge the two smallest files together at each step (greedy approach).\n\"\"\"\n\n\ndef optimal_merge_pattern(files: list) -> float:\n    \"\"\"Function to merge all the files with optimum cost\n\n    Args:\n        files [list]: A list of sizes of different files to be merged\n\n    Returns:\n        optimal_merge_cost [int]: Optimal cost to merge all those files\n\n    Examples:\n    >>> optimal_merge_pattern([2, 3, 4])\n    14\n    >>> optimal_merge_pattern([5, 10, 20, 30, 30])\n    205\n    >>> optimal_merge_pattern([8, 8, 8, 8, 8])\n    96\n    \"\"\"\n    optimal_merge_cost = 0\n    while len(files) > 1:\n        temp = 0\n        # Consider two files with minimum cost to be merged\n        for _ in range(2):\n            min_index = files.index(min(files))\n            temp += files[min_index]\n            files.pop(min_index)\n        files.append(temp)\n        optimal_merge_cost += temp\n    return optimal_merge_cost\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/minimum_waiting_time.py": "\"\"\"\nCalculate the minimum waiting time using a greedy algorithm.\nreference: https://www.youtube.com/watch?v=Sf3eiO12eJs\n\nFor doctests run following command:\npython -m doctest -v minimum_waiting_time.py\n\nThe minimum_waiting_time function uses a greedy algorithm to calculate the minimum\ntime for queries to complete. It sorts the list in non-decreasing order, calculates\nthe waiting time for each query by multiplying its position in the list with the\nsum of all remaining query times, and returns the total waiting time. A doctest\nensures that the function produces the correct output.\n\"\"\"\n\n\ndef minimum_waiting_time(queries: list[int]) -> int:\n    \"\"\"\n    This function takes a list of query times and returns the minimum waiting time\n    for all queries to be completed.\n\n    Args:\n        queries: A list of queries measured in picoseconds\n\n    Returns:\n        total_waiting_time: Minimum waiting time measured in picoseconds\n\n    Examples:\n    >>> minimum_waiting_time([3, 2, 1, 2, 6])\n    17\n    >>> minimum_waiting_time([3, 2, 1])\n    4\n    >>> minimum_waiting_time([1, 2, 3, 4])\n    10\n    >>> minimum_waiting_time([5, 5, 5, 5])\n    30\n    >>> minimum_waiting_time([])\n    0\n    \"\"\"\n    n = len(queries)\n    if n in (0, 1):\n        return 0\n    return sum(query * (n - i - 1) for i, query in enumerate(sorted(queries)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/smallest_range.py": "\"\"\"\nsmallest_range function takes a list of sorted integer lists and finds the smallest\nrange that includes at least one number from each list, using a min heap for efficiency.\n\"\"\"\n\nfrom heapq import heappop, heappush\nfrom sys import maxsize\n\n\ndef smallest_range(nums: list[list[int]]) -> list[int]:\n    \"\"\"\n    Find the smallest range from each list in nums.\n\n    Uses min heap for efficiency. The range includes at least one number from each list.\n\n    Args:\n        nums: List of k sorted integer lists.\n\n    Returns:\n        list: Smallest range as a two-element list.\n\n    Examples:\n    >>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]])\n    [20, 24]\n    >>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])\n    [1, 1]\n    >>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3)))\n    [1, 1]\n    >>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3)))\n    [-1, 1]\n    >>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [3, 7]\n    >>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    [0, 0]\n    >>> smallest_range([[], [], []])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n\n    min_heap: list[tuple[int, int, int]] = []\n    current_max = -maxsize - 1\n\n    for i, items in enumerate(nums):\n        heappush(min_heap, (items[0], i, 0))\n        current_max = max(current_max, items[0])\n\n    # Initialize smallest_range with large integer values\n    smallest_range = [-maxsize - 1, maxsize]\n\n    while min_heap:\n        current_min, list_index, element_index = heappop(min_heap)\n\n        if current_max - current_min < smallest_range[1] - smallest_range[0]:\n            smallest_range = [current_min, current_max]\n\n        if element_index == len(nums[list_index]) - 1:\n            break\n\n        next_element = nums[list_index][element_index + 1]\n        heappush(min_heap, (next_element, list_index, element_index + 1))\n        current_max = max(current_max, next_element)\n\n    return smallest_range\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(f\"{smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])}\")  # Output: [1, 1]\n", "greedy_methods/minimum_coin_change.py": "\"\"\"\nTest cases:\nDo you want to enter your denominations ? (Y/N) :N\nEnter the change you want to make in Indian Currency: 987\nFollowing is minimal  change for 987 :\n500 100 100 100 100 50 20 10 5 2\n\nDo you want to enter your denominations ? (Y/N) :Y\nEnter number of denomination:10\n1\n5\n10\n20\n50\n100\n200\n500\n1000\n2000\nEnter the change you want to make: 18745\nFollowing is minimal  change for 18745 :\n2000 2000 2000 2000 2000 2000 2000 2000 2000 500 200 20 20 5\n\nDo you want to enter your denominations ? (Y/N) :N\nEnter the change you want to make: 0\nThe total value cannot be zero or negative.\nDo you want to enter your denominations ? (Y/N) :N\nEnter the change you want to make: -98\nThe total value cannot be zero or negative.\n\nDo you want to enter your denominations ? (Y/N) :Y\nEnter number of denomination:5\n1\n5\n100\n500\n1000\nEnter the change you want to make: 456\nFollowing is minimal   change for 456 :\n100 100 100 100 5 5 5 5 5 5 5 5 5 5 5 1\n\"\"\"\n\n\ndef find_minimum_change(denominations: list[int], value: str) -> list[int]:\n    \"\"\"\n    Find the minimum change from the given denominations and value\n    >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)\n    [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)\n    [500, 100, 100, 100, 100, 50, 20, 10, 5, 2]\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)\n    []\n    >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)\n    []\n    >>> find_minimum_change([1, 5, 100, 500, 1000], 456)\n    [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]\n    \"\"\"\n    total_value = int(value)\n\n    # Initialize Result\n    answer = []\n\n    # Traverse through all denomination\n    for denomination in reversed(denominations):\n        # Find denominations\n        while int(total_value) >= int(denomination):\n            total_value -= int(denomination)\n            answer.append(denomination)  # Append the \"answers\" array\n\n    return answer\n\n\n# Driver Code\nif __name__ == \"__main__\":\n    denominations = []\n    value = \"0\"\n\n    if (\n        input(\"Do you want to enter your denominations ? (yY/n): \").strip().lower()\n        == \"y\"\n    ):\n        n = int(input(\"Enter the number of denominations you want to add: \").strip())\n\n        for i in range(n):\n            denominations.append(int(input(f\"Denomination {i}: \").strip()))\n        value = input(\"Enter the change you want to make in Indian Currency: \").strip()\n    else:\n        # All denominations of Indian Currency if user does not enter\n        denominations = [1, 2, 5, 10, 20, 50, 100, 500, 2000]\n        value = input(\"Enter the change you want to make: \").strip()\n\n    if int(value) == 0 or int(value) < 0:\n        print(\"The total value cannot be zero or negative.\")\n\n    else:\n        print(f\"Following is minimal change for {value}: \")\n        answer = find_minimum_change(denominations, value)\n        # Print result\n        for i in range(len(answer)):\n            print(answer[i], end=\" \")\n", "greedy_methods/gas_station.py": "\"\"\"\nTask:\nThere are n gas stations along a circular route, where the amount of gas\nat the ith station is gas_quantities[i].\n\nYou have a car with an unlimited gas tank and it costs costs[i] of gas\nto travel from the ith station to its next (i + 1)th station.\nYou begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays gas_quantities and costs, return the starting\ngas station's index if you can travel around the circuit once\nin the clockwise direction otherwise, return -1.\nIf there exists a solution, it is guaranteed to be unique\n\nReference: https://leetcode.com/problems/gas-station/description\n\nImplementation notes:\nFirst, check whether the total gas is enough to complete the journey. If not, return -1.\nHowever, if there is enough gas, it is guaranteed that there is a valid\nstarting index to reach the end of the journey.\nGreedily calculate the net gain (gas_quantity - cost) at each station.\nIf the net gain ever goes below 0 while iterating through the stations,\nstart checking from the next station.\n\n\"\"\"\n\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass GasStation:\n    gas_quantity: int\n    cost: int\n\n\ndef get_gas_stations(\n    gas_quantities: list[int], costs: list[int]\n) -> tuple[GasStation, ...]:\n    \"\"\"\n    This function returns a tuple of gas stations.\n\n    Args:\n        gas_quantities: Amount of gas available at each station\n        costs: The cost of gas required to move from one station to the next\n\n    Returns:\n        A tuple of gas stations\n\n    >>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])\n    >>> len(gas_stations)\n    5\n    >>> gas_stations[0]\n    GasStation(gas_quantity=1, cost=3)\n    >>> gas_stations[-1]\n    GasStation(gas_quantity=5, cost=2)\n    \"\"\"\n    return tuple(\n        GasStation(quantity, cost) for quantity, cost in zip(gas_quantities, costs)\n    )\n\n\ndef can_complete_journey(gas_stations: tuple[GasStation, ...]) -> int:\n    \"\"\"\n    This function returns the index from which to start the journey\n    in order to reach the end.\n\n    Args:\n        gas_quantities [list]: Amount of gas available at each station\n        cost [list]: The cost of gas required to move from one station to the next\n\n    Returns:\n        start [int]: start index needed to complete the journey\n\n    Examples:\n    >>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))\n    3\n    >>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3]))\n    -1\n    \"\"\"\n    total_gas = sum(gas_station.gas_quantity for gas_station in gas_stations)\n    total_cost = sum(gas_station.cost for gas_station in gas_stations)\n    if total_gas < total_cost:\n        return -1\n\n    start = 0\n    net = 0\n    for i, gas_station in enumerate(gas_stations):\n        net += gas_station.gas_quantity - gas_station.cost\n        if net < 0:\n            start = i + 1\n            net = 0\n    return start\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/fractional_knapsack.py": "from bisect import bisect\nfrom itertools import accumulate\n\n\ndef frac_knapsack(vl, wt, w, n):\n    \"\"\"\n    >>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3)\n    240.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4)\n    105.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4)\n    60.0\n    >>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4)\n    60.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4)\n    0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4)\n    0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4)\n    95.0\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4)\n    130\n    >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400)\n    95.0\n    >>> frac_knapsack(\"ABCD\", [5, 4, 6, 3], 8, 400)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for /: 'str' and 'int'\n    \"\"\"\n\n    r = sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True)\n    vl, wt = [i[0] for i in r], [i[1] for i in r]\n    acc = list(accumulate(wt))\n    k = bisect(acc, w)\n    return (\n        0\n        if k == 0\n        else sum(vl[:k]) + (w - acc[k - 1]) * (vl[k]) / (wt[k])\n        if k != n\n        else sum(vl[:k])\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "greedy_methods/__init__.py": "", "greedy_methods/best_time_to_buy_and_sell_stock.py": "\"\"\"\nGiven a list of stock prices calculate the maximum profit that can be made from a\nsingle buy and sell of one share of stock.  We only allowed to complete one buy\ntransaction and one sell transaction but must buy before we sell.\n\nExample : prices = [7, 1, 5, 3, 6, 4]\nmax_profit will return 5 - which is by buying at price 1 and selling at price 6.\n\nThis problem can be solved using the concept of \"GREEDY ALGORITHM\".\n\nWe iterate over the price array once, keeping track of the lowest price point\n(buy) and the maximum profit we can get at each point.  The greedy choice at each point\nis to either buy at the current price if it's less than our current buying price, or\nsell at the current price if the profit is more than our current maximum profit.\n\"\"\"\n\n\ndef max_profit(prices: list[int]) -> int:\n    \"\"\"\n    >>> max_profit([7, 1, 5, 3, 6, 4])\n    5\n    >>> max_profit([7, 6, 4, 3, 1])\n    0\n    \"\"\"\n    if not prices:\n        return 0\n\n    min_price = prices[0]\n    max_profit: int = 0\n\n    for price in prices:\n        min_price = min(price, min_price)\n        max_profit = max(price - min_price, max_profit)\n\n    return max_profit\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(max_profit([7, 1, 5, 3, 6, 4]))\n", "computer_vision/harris_corner.py": "import cv2\nimport numpy as np\n\n\"\"\"\nHarris Corner Detector\nhttps://en.wikipedia.org/wiki/Harris_Corner_Detector\n\"\"\"\n\n\nclass HarrisCorner:\n    def __init__(self, k: float, window_size: int):\n        \"\"\"\n        k : is an empirically determined constant in [0.04,0.06]\n        window_size : neighbourhoods considered\n        \"\"\"\n\n        if k in (0.04, 0.06):\n            self.k = k\n            self.window_size = window_size\n        else:\n            raise ValueError(\"invalid k value\")\n\n    def __str__(self) -> str:\n        return str(self.k)\n\n    def detect(self, img_path: str) -> tuple[cv2.Mat, list[list[int]]]:\n        \"\"\"\n        Returns the image with corners identified\n        img_path  : path of the image\n        output : list of the corner positions, image\n        \"\"\"\n\n        img = cv2.imread(img_path, 0)\n        h, w = img.shape\n        corner_list: list[list[int]] = []\n        color_img = img.copy()\n        color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)\n        dy, dx = np.gradient(img)\n        ixx = dx**2\n        iyy = dy**2\n        ixy = dx * dy\n        k = 0.04\n        offset = self.window_size // 2\n        for y in range(offset, h - offset):\n            for x in range(offset, w - offset):\n                wxx = ixx[\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\n                ].sum()\n                wyy = iyy[\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\n                ].sum()\n                wxy = ixy[\n                    y - offset : y + offset + 1, x - offset : x + offset + 1\n                ].sum()\n\n                det = (wxx * wyy) - (wxy**2)\n                trace = wxx + wyy\n                r = det - k * (trace**2)\n                # Can change the value\n                if r > 0.5:\n                    corner_list.append([x, y, r])\n                    color_img.itemset((y, x, 0), 0)\n                    color_img.itemset((y, x, 1), 0)\n                    color_img.itemset((y, x, 2), 255)\n        return color_img, corner_list\n\n\nif __name__ == \"__main__\":\n    edge_detect = HarrisCorner(0.04, 3)\n    color_img, _ = edge_detect.detect(\"path_to_image\")\n    cv2.imwrite(\"detect.png\", color_img)\n", "computer_vision/pooling_functions.py": "# Source : https://computersciencewiki.org/index.php/Max-pooling_/_Pooling\n# Importing the libraries\nimport numpy as np\nfrom PIL import Image\n\n\n# Maxpooling Function\ndef maxpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform maxpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of maxpooled matrix\n    Sample Input Output:\n    >>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 6.,  8.],\n           [14., 16.]])\n    >>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[241., 180.],\n           [241., 157.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    maxpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape maxpool_shape\n    updated_arr = np.zeros((maxpool_shape, maxpool_shape))\n\n    while i < arr.shape[0]:\n        if i + size > arr.shape[0]:\n            # if the end of the matrix is reached, break\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the maximum of the pooling matrix\n            updated_arr[mat_i][mat_j] = np.max(arr[i : i + size, j : j + size])\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr\n\n\n# Averagepooling Function\ndef avgpooling(arr: np.ndarray, size: int, stride: int) -> np.ndarray:\n    \"\"\"\n    This function is used to perform avgpooling on the input array of 2D matrix(image)\n    Args:\n        arr: numpy array\n        size: size of pooling matrix\n        stride: the number of pixels shifts over the input matrix\n    Returns:\n        numpy array of avgpooled matrix\n    Sample Input Output:\n    >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)\n    array([[ 3.,  5.],\n           [11., 13.]])\n    >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)\n    array([[161., 102.],\n           [114.,  69.]])\n    \"\"\"\n    arr = np.array(arr)\n    if arr.shape[0] != arr.shape[1]:\n        raise ValueError(\"The input array is not a square matrix\")\n    i = 0\n    j = 0\n    mat_i = 0\n    mat_j = 0\n\n    # compute the shape of the output matrix\n    avgpool_shape = (arr.shape[0] - size) // stride + 1\n    # initialize the output matrix with zeros of shape avgpool_shape\n    updated_arr = np.zeros((avgpool_shape, avgpool_shape))\n\n    while i < arr.shape[0]:\n        # if the end of the matrix is reached, break\n        if i + size > arr.shape[0]:\n            break\n        while j < arr.shape[1]:\n            # if the end of the matrix is reached, break\n            if j + size > arr.shape[1]:\n                break\n            # compute the average of the pooling matrix\n            updated_arr[mat_i][mat_j] = int(np.average(arr[i : i + size, j : j + size]))\n            # shift the pooling matrix by stride of column pixels\n            j += stride\n            mat_j += 1\n\n        # shift the pooling matrix by stride of row pixels\n        i += stride\n        mat_i += 1\n        # reset the column index to 0\n        j = 0\n        mat_j = 0\n\n    return updated_arr\n\n\n# Main Function\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"avgpooling\", verbose=True)\n\n    # Loading the image\n    image = Image.open(\"path_to_image\")\n\n    # Converting the image to numpy array and maxpooling, displaying the result\n    # Ensure that the image is a square matrix\n\n    Image.fromarray(maxpooling(np.array(image), size=3, stride=2)).show()\n\n    # Converting the image to numpy array and averagepooling, displaying the result\n    # Ensure that the image is a square matrix\n\n    Image.fromarray(avgpooling(np.array(image), size=3, stride=2)).show()\n", "computer_vision/cnn_classification.py": "\"\"\"\nConvolutional Neural Network\n\nObjective : To train a CNN model detect if TB is present in Lung X-ray or not.\n\nResources CNN Theory :\n    https://en.wikipedia.org/wiki/Convolutional_neural_network\nResources Tensorflow : https://www.tensorflow.org/tutorials/images/cnn\n\nDownload dataset from :\nhttps://lhncbc.nlm.nih.gov/LHC-publications/pubs/TuberculosisChestXrayImageDataSets.html\n\n1. Download the dataset folder and create two folder training set and test set\nin the parent dataset folder\n2. Move 30-40 image from both TB positive and TB Negative folder\nin the test set folder\n3. The labels of the images will be extracted from the folder name\nthe image is present in.\n\n\"\"\"\n\n# Part 1 - Building the CNN\n\nimport numpy as np\n\n# Importing the Keras libraries and packages\nimport tensorflow as tf\nfrom keras import layers, models\n\nif __name__ == \"__main__\":\n    # Initialising the CNN\n    # (Sequential- Building the model layer by layer)\n    classifier = models.Sequential()\n\n    # Step 1 - Convolution\n    # Here 64,64 is the length & breadth of dataset images and 3 is for the RGB channel\n    # (3,3) is the kernel size (filter matrix)\n    classifier.add(\n        layers.Conv2D(32, (3, 3), input_shape=(64, 64, 3), activation=\"relu\")\n    )\n\n    # Step 2 - Pooling\n    classifier.add(layers.MaxPooling2D(pool_size=(2, 2)))\n\n    # Adding a second convolutional layer\n    classifier.add(layers.Conv2D(32, (3, 3), activation=\"relu\"))\n    classifier.add(layers.MaxPooling2D(pool_size=(2, 2)))\n\n    # Step 3 - Flattening\n    classifier.add(layers.Flatten())\n\n    # Step 4 - Full connection\n    classifier.add(layers.Dense(units=128, activation=\"relu\"))\n    classifier.add(layers.Dense(units=1, activation=\"sigmoid\"))\n\n    # Compiling the CNN\n    classifier.compile(\n        optimizer=\"adam\", loss=\"binary_crossentropy\", metrics=[\"accuracy\"]\n    )\n\n    # Part 2 - Fitting the CNN to the images\n\n    # Load Trained model weights\n\n    # from keras.models import load_model\n    # regressor=load_model('cnn.h5')\n\n    train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(\n        rescale=1.0 / 255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True\n    )\n\n    test_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1.0 / 255)\n\n    training_set = train_datagen.flow_from_directory(\n        \"dataset/training_set\", target_size=(64, 64), batch_size=32, class_mode=\"binary\"\n    )\n\n    test_set = test_datagen.flow_from_directory(\n        \"dataset/test_set\", target_size=(64, 64), batch_size=32, class_mode=\"binary\"\n    )\n\n    classifier.fit_generator(\n        training_set, steps_per_epoch=5, epochs=30, validation_data=test_set\n    )\n\n    classifier.save(\"cnn.h5\")\n\n    # Part 3 - Making new predictions\n\n    test_image = tf.keras.preprocessing.image.load_img(\n        \"dataset/single_prediction/image.png\", target_size=(64, 64)\n    )\n    test_image = tf.keras.preprocessing.image.img_to_array(test_image)\n    test_image = np.expand_dims(test_image, axis=0)\n    result = classifier.predict(test_image)\n    # training_set.class_indices\n    if result[0][0] == 0:\n        prediction = \"Normal\"\n    if result[0][0] == 1:\n        prediction = \"Abnormality detected\"\n", "computer_vision/haralick_descriptors.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Image_texture\nhttps://en.wikipedia.org/wiki/Co-occurrence_matrix#Application_to_image_analysis\n\"\"\"\n\nimport imageio.v2 as imageio\nimport numpy as np\n\n\ndef root_mean_square_error(original: np.ndarray, reference: np.ndarray) -> float:\n    \"\"\"Simple implementation of Root Mean Squared Error\n    for two N dimensional numpy arrays.\n\n    Examples:\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))\n        0.0\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))\n        0.816496580927726\n        >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))\n        3.1622776601683795\n    \"\"\"\n    return np.sqrt(((original - reference) ** 2).mean())\n\n\ndef normalize_image(\n    image: np.ndarray, cap: float = 255.0, data_type: np.dtype = np.uint8\n) -> np.ndarray:\n    \"\"\"\n    Normalizes image in Numpy 2D array format, between ranges 0-cap,\n    as to fit uint8 type.\n\n    Args:\n        image: 2D numpy array representing image as matrix, with values in any range\n        cap: Maximum cap amount for normalization\n        data_type: numpy data type to set output variable to\n    Returns:\n        return 2D numpy array of type uint8, corresponding to limited range matrix\n\n    Examples:\n        >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),\n        ...                 cap=1.0, data_type=np.float64)\n        array([[0.        , 0.11111111, 0.22222222],\n               [0.33333333, 0.44444444, 1.        ]])\n        >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))\n        array([[127, 127,  85],\n               [  0, 255,  42]], dtype=uint8)\n    \"\"\"\n    normalized = (image - np.min(image)) / (np.max(image) - np.min(image)) * cap\n    return normalized.astype(data_type)\n\n\ndef normalize_array(array: np.ndarray, cap: float = 1) -> np.ndarray:\n    \"\"\"Normalizes a 1D array, between ranges 0-cap.\n\n    Args:\n        array: List containing values to be normalized between cap range.\n        cap: Maximum cap amount for normalization.\n    Returns:\n        return 1D numpy array, corresponding to limited range array\n\n    Examples:\n        >>> normalize_array(np.array([2, 3, 5, 7]))\n        array([0. , 0.2, 0.6, 1. ])\n        >>> normalize_array(np.array([[5], [7], [11], [13]]))\n        array([[0.  ],\n               [0.25],\n               [0.75],\n               [1.  ]])\n    \"\"\"\n    diff = np.max(array) - np.min(array)\n    return (array - np.min(array)) / (1 if diff == 0 else diff) * cap\n\n\ndef grayscale(image: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Uses luminance weights to transform RGB channel to greyscale, by\n    taking the dot product between the channel and the weights.\n\n    Example:\n        >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                     [[56,  56,  56], [128, 255, 107]]]))\n        array([[158,  97],\n               [ 56, 200]], dtype=uint8)\n    \"\"\"\n    return np.dot(image[:, :, 0:3], [0.299, 0.587, 0.114]).astype(np.uint8)\n\n\ndef binarize(image: np.ndarray, threshold: float = 127.0) -> np.ndarray:\n    \"\"\"\n    Binarizes a grayscale image based on a given threshold value,\n    setting values to 1 or 0 accordingly.\n\n    Examples:\n        >>> binarize(np.array([[128, 255], [101, 156]]))\n        array([[1, 1],\n               [0, 1]])\n        >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)\n        array([[0, 1],\n               [1, 0]])\n    \"\"\"\n    return np.where(image > threshold, 1, 0)\n\n\ndef transform(\n    image: np.ndarray, kind: str, kernel: np.ndarray | None = None\n) -> np.ndarray:\n    \"\"\"\n    Simple image transformation using one of two available filter functions:\n    Erosion and Dilation.\n\n    Args:\n        image: binarized input image, onto which to apply transformation\n        kind: Can be either 'erosion', in which case the :func:np.max\n              function is called, or 'dilation', when :func:np.min is used instead.\n        kernel: n x n kernel with shape < :attr:image.shape,\n              to be used when applying convolution to original image\n\n    Returns:\n        returns a numpy array with same shape as input image,\n        corresponding to applied binary transformation.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> transform(img, 'erosion')\n        array([[1, 1],\n               [1, 1]], dtype=uint8)\n        >>> transform(img, 'dilation')\n        array([[0, 0],\n               [0, 0]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        kernel = np.ones((3, 3))\n\n    if kind == \"erosion\":\n        constant = 1\n        apply = np.max\n    else:\n        constant = 0\n        apply = np.min\n\n    center_x, center_y = (x // 2 for x in kernel.shape)\n\n    # Use padded image when applying convolution\n    # to not go out of bounds of the original the image\n    transformed = np.zeros(image.shape, dtype=np.uint8)\n    padded = np.pad(image, 1, \"constant\", constant_values=constant)\n\n    for x in range(center_x, padded.shape[0] - center_x):\n        for y in range(center_y, padded.shape[1] - center_y):\n            center = padded[\n                x - center_x : x + center_x + 1, y - center_y : y + center_y + 1\n            ]\n            # Apply transformation method to the centered section of the image\n            transformed[x - center_x, y - center_y] = apply(center[kernel == 1])\n\n    return transformed\n\n\ndef opening_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Opening filter, defined as the sequence of\n    erosion and then a dilation filter on the same image.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> opening_filter(img)\n        array([[1, 1],\n               [1, 1]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        np.ones((3, 3))\n\n    return transform(transform(image, \"dilation\", kernel), \"erosion\", kernel)\n\n\ndef closing_filter(image: np.ndarray, kernel: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Opening filter, defined as the sequence of\n    dilation and then erosion filter on the same image.\n\n    Examples:\n        >>> img = np.array([[1, 0.5], [0.2, 0.7]])\n        >>> img = binarize(img, threshold=0.5)\n        >>> closing_filter(img)\n        array([[0, 0],\n               [0, 0]], dtype=uint8)\n    \"\"\"\n    if kernel is None:\n        kernel = np.ones((3, 3))\n    return transform(transform(image, \"erosion\", kernel), \"dilation\", kernel)\n\n\ndef binary_mask(\n    image_gray: np.ndarray, image_map: np.ndarray\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Apply binary mask, or thresholding based\n    on bit mask value (mapping mask is binary).\n\n    Returns the mapped true value mask and its complementary false value mask.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> binary_mask(gray, morphological)\n        (array([[1, 1],\n               [1, 1]], dtype=uint8), array([[158,  97],\n               [ 56, 200]], dtype=uint8))\n    \"\"\"\n    true_mask, false_mask = image_gray.copy(), image_gray.copy()\n    true_mask[image_map == 1] = 1\n    false_mask[image_map == 0] = 0\n\n    return true_mask, false_mask\n\n\ndef matrix_concurrency(image: np.ndarray, coordinate: tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Calculate sample co-occurrence matrix based on input image\n    as well as selected coordinates on image.\n\n    Implementation is made using basic iteration,\n    as function to be performed (np.max) is non-linear and therefore\n    not callable on the frequency domain.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> mask_1 = binary_mask(gray, morphological)[0]\n        >>> matrix_concurrency(mask_1, (0, 1))\n        array([[0., 0.],\n               [0., 0.]])\n    \"\"\"\n    matrix = np.zeros([np.max(image) + 1, np.max(image) + 1])\n\n    offset_x, offset_y = coordinate\n\n    for x in range(1, image.shape[0] - 1):\n        for y in range(1, image.shape[1] - 1):\n            base_pixel = image[x, y]\n            offset_pixel = image[x + offset_x, y + offset_y]\n\n            matrix[base_pixel, offset_pixel] += 1\n    matrix_sum = np.sum(matrix)\n    return matrix / (1 if matrix_sum == 0 else matrix_sum)\n\n\ndef haralick_descriptors(matrix: np.ndarray) -> list[float]:\n    \"\"\"Calculates all 8 Haralick descriptors based on co-occurrence input matrix.\n    All descriptors are as follows:\n    Maximum probability, Inverse Difference, Homogeneity, Entropy,\n    Energy, Dissimilarity, Contrast and Correlation\n\n    Args:\n        matrix: Co-occurrence matrix to use as base for calculating descriptors.\n\n    Returns:\n        Reverse ordered list of resulting descriptors\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> mask_1 = binary_mask(gray, morphological)[0]\n        >>> concurrency = matrix_concurrency(mask_1, (0, 1))\n        >>> haralick_descriptors(concurrency)\n        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    \"\"\"\n    # Function np.indices could be used for bigger input types,\n    # but np.ogrid works just fine\n    i, j = np.ogrid[0 : matrix.shape[0], 0 : matrix.shape[1]]  # np.indices()\n\n    # Pre-calculate frequent multiplication and subtraction\n    prod = np.multiply(i, j)\n    sub = np.subtract(i, j)\n\n    # Calculate numerical value of Maximum Probability\n    maximum_prob = np.max(matrix)\n    # Using the definition for each descriptor individually to calculate its matrix\n    correlation = prod * matrix\n    energy = np.power(matrix, 2)\n    contrast = matrix * np.power(sub, 2)\n\n    dissimilarity = matrix * np.abs(sub)\n    inverse_difference = matrix / (1 + np.abs(sub))\n    homogeneity = matrix / (1 + np.power(sub, 2))\n    entropy = -(matrix[matrix > 0] * np.log(matrix[matrix > 0]))\n\n    # Sum values for descriptors ranging from the first one to the last,\n    # as all are their respective origin matrix and not the resulting value yet.\n    return [\n        maximum_prob,\n        correlation.sum(),\n        energy.sum(),\n        contrast.sum(),\n        dissimilarity.sum(),\n        inverse_difference.sum(),\n        homogeneity.sum(),\n        entropy.sum(),\n    ]\n\n\ndef get_descriptors(\n    masks: tuple[np.ndarray, np.ndarray], coordinate: tuple[int, int]\n) -> np.ndarray:\n    \"\"\"\n    Calculate all Haralick descriptors for a sequence of\n    different co-occurrence matrices, given input masks and coordinates.\n\n    Example:\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> get_descriptors(binary_mask(gray, morphological), (0, 1))\n        array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n    \"\"\"\n    descriptors = np.array(\n        [haralick_descriptors(matrix_concurrency(mask, coordinate)) for mask in masks]\n    )\n\n    # Concatenate each individual descriptor into\n    # one single list containing sequence of descriptors\n    return np.concatenate(descriptors, axis=None)\n\n\ndef euclidean(point_1: np.ndarray, point_2: np.ndarray) -> np.float32:\n    \"\"\"\n    Simple method for calculating the euclidean distance between two points,\n    with type np.ndarray.\n\n    Example:\n        >>> a = np.array([1, 0, -2])\n        >>> b = np.array([2, -1, 1])\n        >>> euclidean(a, b)\n        3.3166247903554\n    \"\"\"\n    return np.sqrt(np.sum(np.square(point_1 - point_2)))\n\n\ndef get_distances(descriptors: np.ndarray, base: int) -> list[tuple[int, float]]:\n    \"\"\"\n    Calculate all Euclidean distances between a selected base descriptor\n    and all other Haralick descriptors\n    The resulting comparison is return in decreasing order,\n    showing which descriptor is the most similar to the selected base.\n\n    Args:\n        descriptors: Haralick descriptors to compare with base index\n        base: Haralick descriptor index to use as base when calculating respective\n        euclidean distance to other descriptors.\n\n    Returns:\n        Ordered distances between descriptors\n\n    Example:\n        >>> index = 1\n        >>> img = np.array([[[108, 201, 72], [255, 11,  127]],\n        ...                 [[56,  56,  56], [128, 255, 107]]])\n        >>> gray = grayscale(img)\n        >>> binary = binarize(gray)\n        >>> morphological = opening_filter(binary)\n        >>> get_distances(get_descriptors(\n        ...                 binary_mask(gray, morphological), (0, 1)),\n        ...               index)\n        [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), \\\n(6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), \\\n(13, 0.0), (14, 0.0), (15, 0.0)]\n    \"\"\"\n    distances = np.array(\n        [euclidean(descriptor, descriptors[base]) for descriptor in descriptors]\n    )\n    # Normalize distances between range [0, 1]\n    normalized_distances: list[float] = normalize_array(distances, 1).tolist()\n    enum_distances = list(enumerate(normalized_distances))\n    enum_distances.sort(key=lambda tup: tup[1], reverse=True)\n    return enum_distances\n\n\nif __name__ == \"__main__\":\n    # Index to compare haralick descriptors to\n    index = int(input())\n    q_value_list = [int(value) for value in input().split()]\n    q_value = (q_value_list[0], q_value_list[1])\n\n    # Format is the respective filter to apply,\n    # can be either 1 for the opening filter or else for the closing\n    parameters = {\"format\": int(input()), \"threshold\": int(input())}\n\n    # Number of images to perform methods on\n    b_number = int(input())\n\n    files, descriptors = [], []\n\n    for _ in range(b_number):\n        file = input().rstrip()\n        files.append(file)\n\n        # Open given image and calculate morphological filter,\n        # respective masks and correspondent Harralick Descriptors.\n        image = imageio.imread(file).astype(np.float32)\n        gray = grayscale(image)\n        threshold = binarize(gray, parameters[\"threshold\"])\n\n        morphological = (\n            opening_filter(threshold)\n            if parameters[\"format\"] == 1\n            else closing_filter(threshold)\n        )\n        masks = binary_mask(gray, morphological)\n        descriptors.append(get_descriptors(masks, q_value))\n\n    # Transform ordered distances array into a sequence of indexes\n    # corresponding to original file position\n    distances = get_distances(np.array(descriptors), index)\n    indexed_distances = np.array(distances).astype(np.uint8)[:, 0]\n\n    # Finally, print distances considering the Haralick descriptions from the base\n    # file to all other images using the morphology method of choice.\n    print(f\"Query: {files[index]}\")\n    print(\"Ranking:\")\n    for idx, file_idx in enumerate(indexed_distances):\n        print(f\"({idx}) {files[file_idx]}\", end=\"\\n\")\n", "computer_vision/mean_threshold.py": "from PIL import Image\n\n\"\"\"\nMean thresholding algorithm for image processing\nhttps://en.wikipedia.org/wiki/Thresholding_(image_processing)\n\"\"\"\n\n\ndef mean_threshold(image: Image) -> Image:\n    \"\"\"\n    image: is a grayscale PIL image object\n    \"\"\"\n    height, width = image.size\n    mean = 0\n    pixels = image.load()\n    for i in range(width):\n        for j in range(height):\n            pixel = pixels[j, i]\n            mean += pixel\n    mean //= width * height\n\n    for j in range(width):\n        for i in range(height):\n            pixels[i, j] = 255 if pixels[i, j] > mean else 0\n    return image\n\n\nif __name__ == \"__main__\":\n    image = mean_threshold(Image.open(\"path_to_image\").convert(\"L\"))\n    image.save(\"output_image_path\")\n", "computer_vision/flip_augmentation.py": "import glob\nimport os\nimport random\nfrom string import ascii_lowercase, digits\n\nimport cv2\n\n\"\"\"\nFlip image and bounding box for computer vision task\nhttps://paperswithcode.com/method/randomhorizontalflip\n\"\"\"\n\n# Params\nLABEL_DIR = \"\"\nIMAGE_DIR = \"\"\nOUTPUT_DIR = \"\"\nFLIP_TYPE = 1  # (0 is vertical, 1 is horizontal)\n\n\ndef main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMAGE_DIR)\n    print(\"Processing...\")\n    new_images, new_annos, paths = update_image_and_anno(img_paths, annos, FLIP_TYPE)\n\n    for index, image in enumerate(new_images):\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = paths[index].split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_FLIP_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Success {index+1}/{len(new_images)} with {file_name}\")\n        annos_list = []\n        for anno in new_annos[index]:\n            obj = f\"{anno[0]} {anno[1]} {anno[2]} {anno[3]} {anno[4]}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))\n\n\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            boxes.append(\n                [\n                    int(obj[0]),\n                    float(obj[1]),\n                    float(obj[2]),\n                    float(obj[3]),\n                    float(obj[4]),\n                ]\n            )\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels\n\n\ndef update_image_and_anno(\n    img_list: list, anno_list: list, flip_type: int = 1\n) -> tuple[list, list, list]:\n    \"\"\"\n    - img_list <type: list>: list of all images\n    - anno_list <type: list>: list of all annotations of specific image\n    - flip_type <type: int>: 0 is vertical, 1 is horizontal\n    Return:\n        - new_imgs_list <type: narray>: image after resize\n        - new_annos_lists <type: list>: list of new annotation after scale\n        - path_list <type: list>: list the name of image file\n    \"\"\"\n    new_annos_lists = []\n    path_list = []\n    new_imgs_list = []\n    for idx in range(len(img_list)):\n        new_annos = []\n        path = img_list[idx]\n        path_list.append(path)\n        img_annos = anno_list[idx]\n        img = cv2.imread(path)\n        if flip_type == 1:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                x_center_new = 1 - bbox[1]\n                new_annos.append([bbox[0], x_center_new, bbox[2], bbox[3], bbox[4]])\n        elif flip_type == 0:\n            new_img = cv2.flip(img, flip_type)\n            for bbox in img_annos:\n                y_center_new = 1 - bbox[2]\n                new_annos.append([bbox[0], bbox[1], y_center_new, bbox[3], bbox[4]])\n        new_annos_lists.append(new_annos)\n        new_imgs_list.append(new_img)\n    return new_imgs_list, new_annos_lists, path_list\n\n\ndef random_chars(number_char: int = 32) -> str:\n    \"\"\"\n    Automatic generate random 32 characters.\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n    >>> len(random_chars(32))\n    32\n    \"\"\"\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))\n\n\nif __name__ == \"__main__\":\n    main()\n    print(\"DONE \u2705\")\n", "computer_vision/__init__.py": "", "computer_vision/mosaic_augmentation.py": "\"\"\"Source: https://github.com/jason9075/opencv-mosaic-data-aug\"\"\"\n\nimport glob\nimport os\nimport random\nfrom string import ascii_lowercase, digits\n\nimport cv2\nimport numpy as np\n\n# Parameters\nOUTPUT_SIZE = (720, 1280)  # Height, Width\nSCALE_RANGE = (0.4, 0.6)  # if height or width lower than this scale, drop it.\nFILTER_TINY_SCALE = 1 / 100\nLABEL_DIR = \"\"\nIMG_DIR = \"\"\nOUTPUT_DIR = \"\"\nNUMBER_IMAGES = 250\n\n\ndef main() -> None:\n    \"\"\"\n    Get images list and annotations list from input dir.\n    Update new images and annotations.\n    Save images and annotations in output dir.\n    \"\"\"\n    img_paths, annos = get_dataset(LABEL_DIR, IMG_DIR)\n    for index in range(NUMBER_IMAGES):\n        idxs = random.sample(range(len(annos)), 4)\n        new_image, new_annos, path = update_image_and_anno(\n            img_paths,\n            annos,\n            idxs,\n            OUTPUT_SIZE,\n            SCALE_RANGE,\n            filter_scale=FILTER_TINY_SCALE,\n        )\n\n        # Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n        letter_code = random_chars(32)\n        file_name = path.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        file_root = f\"{OUTPUT_DIR}/{file_name}_MOSAIC_{letter_code}\"\n        cv2.imwrite(f\"{file_root}.jpg\", new_image, [cv2.IMWRITE_JPEG_QUALITY, 85])\n        print(f\"Succeeded {index+1}/{NUMBER_IMAGES} with {file_name}\")\n        annos_list = []\n        for anno in new_annos:\n            width = anno[3] - anno[1]\n            height = anno[4] - anno[2]\n            x_center = anno[1] + width / 2\n            y_center = anno[2] + height / 2\n            obj = f\"{anno[0]} {x_center} {y_center} {width} {height}\"\n            annos_list.append(obj)\n        with open(f\"{file_root}.txt\", \"w\") as outfile:\n            outfile.write(\"\\n\".join(line for line in annos_list))\n\n\ndef get_dataset(label_dir: str, img_dir: str) -> tuple[list, list]:\n    \"\"\"\n    - label_dir <type: str>: Path to label include annotation of images\n    - img_dir <type: str>: Path to folder contain images\n    Return <type: list>: List of images path and labels\n    \"\"\"\n    img_paths = []\n    labels = []\n    for label_file in glob.glob(os.path.join(label_dir, \"*.txt\")):\n        label_name = label_file.split(os.sep)[-1].rsplit(\".\", 1)[0]\n        with open(label_file) as in_file:\n            obj_lists = in_file.readlines()\n        img_path = os.path.join(img_dir, f\"{label_name}.jpg\")\n\n        boxes = []\n        for obj_list in obj_lists:\n            obj = obj_list.rstrip(\"\\n\").split(\" \")\n            xmin = float(obj[1]) - float(obj[3]) / 2\n            ymin = float(obj[2]) - float(obj[4]) / 2\n            xmax = float(obj[1]) + float(obj[3]) / 2\n            ymax = float(obj[2]) + float(obj[4]) / 2\n\n            boxes.append([int(obj[0]), xmin, ymin, xmax, ymax])\n        if not boxes:\n            continue\n        img_paths.append(img_path)\n        labels.append(boxes)\n    return img_paths, labels\n\n\ndef update_image_and_anno(\n    all_img_list: list,\n    all_annos: list,\n    idxs: list[int],\n    output_size: tuple[int, int],\n    scale_range: tuple[float, float],\n    filter_scale: float = 0.0,\n) -> tuple[list, list, str]:\n    \"\"\"\n    - all_img_list <type: list>: list of all images\n    - all_annos <type: list>: list of all annotations of specific image\n    - idxs <type: list>: index of image in list\n    - output_size <type: tuple>: size of output image (Height, Width)\n    - scale_range <type: tuple>: range of scale image\n    - filter_scale <type: float>: the condition of downscale image and bounding box\n    Return:\n        - output_img <type: narray>: image after resize\n        - new_anno <type: list>: list of new annotation after scale\n        - path[0] <type: string>: get the name of image file\n    \"\"\"\n    output_img = np.zeros([output_size[0], output_size[1], 3], dtype=np.uint8)\n    scale_x = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\n    scale_y = scale_range[0] + random.random() * (scale_range[1] - scale_range[0])\n    divid_point_x = int(scale_x * output_size[1])\n    divid_point_y = int(scale_y * output_size[0])\n\n    new_anno = []\n    path_list = []\n    for i, index in enumerate(idxs):\n        path = all_img_list[index]\n        path_list.append(path)\n        img_annos = all_annos[index]\n        img = cv2.imread(path)\n        if i == 0:  # top-left\n            img = cv2.resize(img, (divid_point_x, divid_point_y))\n            output_img[:divid_point_y, :divid_point_x, :] = img\n            for bbox in img_annos:\n                xmin = bbox[1] * scale_x\n                ymin = bbox[2] * scale_y\n                xmax = bbox[3] * scale_x\n                ymax = bbox[4] * scale_y\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        elif i == 1:  # top-right\n            img = cv2.resize(img, (output_size[1] - divid_point_x, divid_point_y))\n            output_img[:divid_point_y, divid_point_x : output_size[1], :] = img\n            for bbox in img_annos:\n                xmin = scale_x + bbox[1] * (1 - scale_x)\n                ymin = bbox[2] * scale_y\n                xmax = scale_x + bbox[3] * (1 - scale_x)\n                ymax = bbox[4] * scale_y\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        elif i == 2:  # bottom-left\n            img = cv2.resize(img, (divid_point_x, output_size[0] - divid_point_y))\n            output_img[divid_point_y : output_size[0], :divid_point_x, :] = img\n            for bbox in img_annos:\n                xmin = bbox[1] * scale_x\n                ymin = scale_y + bbox[2] * (1 - scale_y)\n                xmax = bbox[3] * scale_x\n                ymax = scale_y + bbox[4] * (1 - scale_y)\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n        else:  # bottom-right\n            img = cv2.resize(\n                img, (output_size[1] - divid_point_x, output_size[0] - divid_point_y)\n            )\n            output_img[\n                divid_point_y : output_size[0], divid_point_x : output_size[1], :\n            ] = img\n            for bbox in img_annos:\n                xmin = scale_x + bbox[1] * (1 - scale_x)\n                ymin = scale_y + bbox[2] * (1 - scale_y)\n                xmax = scale_x + bbox[3] * (1 - scale_x)\n                ymax = scale_y + bbox[4] * (1 - scale_y)\n                new_anno.append([bbox[0], xmin, ymin, xmax, ymax])\n\n    # Remove bounding box small than scale of filter\n    if filter_scale > 0:\n        new_anno = [\n            anno\n            for anno in new_anno\n            if filter_scale < (anno[3] - anno[1]) and filter_scale < (anno[4] - anno[2])\n        ]\n\n    return output_img, new_anno, path_list[0]\n\n\ndef random_chars(number_char: int) -> str:\n    \"\"\"\n    Automatic generate random 32 characters.\n    Get random string code: '7b7ad245cdff75241935e4dd860f3bad'\n    >>> len(random_chars(32))\n    32\n    \"\"\"\n    assert number_char > 1, \"The number of character should greater than 1\"\n    letter_code = ascii_lowercase + digits\n    return \"\".join(random.choice(letter_code) for _ in range(number_char))\n\n\nif __name__ == \"__main__\":\n    main()\n    print(\"DONE \u2705\")\n", "computer_vision/horn_schunck.py": "\"\"\"\nThe Horn-Schunck method estimates the optical flow for every single pixel of\na sequence of images.\nIt works by assuming brightness constancy between two consecutive frames\nand smoothness in the optical flow.\n\nUseful resources:\nWikipedia: https://en.wikipedia.org/wiki/Horn%E2%80%93Schunck_method\nPaper: http://image.diku.dk/imagecanon/material/HornSchunckOptical_Flow.pdf\n\"\"\"\n\nfrom typing import SupportsIndex\n\nimport numpy as np\nfrom scipy.ndimage import convolve\n\n\ndef warp(\n    image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray\n) -> np.ndarray:\n    \"\"\"\n    Warps the pixels of an image into a new image using the horizontal and vertical\n    flows.\n    Pixels that are warped from an invalid location are set to 0.\n\n    Parameters:\n        image: Grayscale image\n        horizontal_flow: Horizontal flow\n        vertical_flow: Vertical flow\n\n    Returns: Warped image\n\n    >>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]), \\\n    np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]), \\\n    np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))\n    array([[0, 0, 0],\n           [3, 1, 0],\n           [0, 2, 3]])\n    \"\"\"\n    flow = np.stack((horizontal_flow, vertical_flow), 2)\n\n    # Create a grid of all pixel coordinates and subtract the flow to get the\n    # target pixels coordinates\n    grid = np.stack(\n        np.meshgrid(np.arange(0, image.shape[1]), np.arange(0, image.shape[0])), 2\n    )\n    grid = np.round(grid - flow).astype(np.int32)\n\n    # Find the locations outside of the original image\n    invalid = (grid < 0) | (grid >= np.array([image.shape[1], image.shape[0]]))\n    grid[invalid] = 0\n\n    warped = image[grid[:, :, 1], grid[:, :, 0]]\n\n    # Set pixels at invalid locations to 0\n    warped[invalid[:, :, 0] | invalid[:, :, 1]] = 0\n\n    return warped\n\n\ndef horn_schunck(\n    image0: np.ndarray,\n    image1: np.ndarray,\n    num_iter: SupportsIndex,\n    alpha: float | None = None,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    This function performs the Horn-Schunck algorithm and returns the estimated\n    optical flow. It is assumed that the input images are grayscale and\n    normalized to be in [0, 1].\n\n    Parameters:\n        image0: First image of the sequence\n        image1: Second image of the sequence\n        alpha: Regularization constant\n        num_iter: Number of iterations performed\n\n    Returns: estimated horizontal & vertical flow\n\n    >>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]), \\\n    np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).\\\n    astype(np.int32)\n    array([[[ 0, -1, -1],\n            [ 0, -1, -1]],\n    <BLANKLINE>\n           [[ 0,  0,  0],\n            [ 0,  0,  0]]], dtype=int32)\n    \"\"\"\n    if alpha is None:\n        alpha = 0.1\n\n    # Initialize flow\n    horizontal_flow = np.zeros_like(image0)\n    vertical_flow = np.zeros_like(image0)\n\n    # Prepare kernels for the calculation of the derivatives and the average velocity\n    kernel_x = np.array([[-1, 1], [-1, 1]]) * 0.25\n    kernel_y = np.array([[-1, -1], [1, 1]]) * 0.25\n    kernel_t = np.array([[1, 1], [1, 1]]) * 0.25\n    kernel_laplacian = np.array(\n        [[1 / 12, 1 / 6, 1 / 12], [1 / 6, 0, 1 / 6], [1 / 12, 1 / 6, 1 / 12]]\n    )\n\n    # Iteratively refine the flow\n    for _ in range(num_iter):\n        warped_image = warp(image0, horizontal_flow, vertical_flow)\n        derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)\n        derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)\n        derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)\n\n        avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)\n        avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)\n\n        # This updates the flow as proposed in the paper (Step 12)\n        update = (\n            derivative_x * avg_horizontal_velocity\n            + derivative_y * avg_vertical_velocity\n            + derivative_t\n        )\n        update = update / (alpha**2 + derivative_x**2 + derivative_y**2)\n\n        horizontal_flow = avg_horizontal_velocity - derivative_x * update\n        vertical_flow = avg_vertical_velocity - derivative_y * update\n\n    return horizontal_flow, vertical_flow\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "fractals/sierpinski_triangle.py": "\"\"\"\nAuthor Anurag Kumar | anuragkumarak95@gmail.com | git/anuragkumarak95\n\nSimple example of fractal generation using recursion.\n\nWhat is the Sierpi\u0144ski Triangle?\n    The Sierpi\u0144ski triangle (sometimes spelled Sierpinski), also called the\nSierpi\u0144ski gasket or Sierpi\u0144ski sieve, is a fractal attractive fixed set with\nthe overall shape of an equilateral triangle, subdivided recursively into\nsmaller equilateral triangles. Originally constructed as a curve, this is one of\nthe basic examples of self-similar sets\u2014that is, it is a mathematically\ngenerated pattern that is reproducible at any magnification or reduction. It is\nnamed after the Polish mathematician Wac\u0142aw Sierpi\u0144ski, but appeared as a\ndecorative pattern many centuries before the work of Sierpi\u0144ski.\n\n\nUsage: python sierpinski_triangle.py <int:depth_for_fractal>\n\nCredits:\n    The above description is taken from\n    https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle\n    This code was written by editing the code from\n    https://www.riannetrujillo.com/blog/python-fractal/\n\"\"\"\n\nimport sys\nimport turtle\n\n\ndef get_mid(p1: tuple[float, float], p2: tuple[float, float]) -> tuple[float, float]:\n    \"\"\"\n    Find the midpoint of two points\n\n    >>> get_mid((0, 0), (2, 2))\n    (1.0, 1.0)\n    >>> get_mid((-3, -3), (3, 3))\n    (0.0, 0.0)\n    >>> get_mid((1, 0), (3, 2))\n    (2.0, 1.0)\n    >>> get_mid((0, 0), (1, 1))\n    (0.5, 0.5)\n    >>> get_mid((0, 0), (0, 0))\n    (0.0, 0.0)\n    \"\"\"\n    return (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2\n\n\ndef triangle(\n    vertex1: tuple[float, float],\n    vertex2: tuple[float, float],\n    vertex3: tuple[float, float],\n    depth: int,\n) -> None:\n    \"\"\"\n    Recursively draw the Sierpinski triangle given the vertices of the triangle\n    and the recursion depth\n    \"\"\"\n    my_pen.up()\n    my_pen.goto(vertex1[0], vertex1[1])\n    my_pen.down()\n    my_pen.goto(vertex2[0], vertex2[1])\n    my_pen.goto(vertex3[0], vertex3[1])\n    my_pen.goto(vertex1[0], vertex1[1])\n\n    if depth == 0:\n        return\n\n    triangle(vertex1, get_mid(vertex1, vertex2), get_mid(vertex1, vertex3), depth - 1)\n    triangle(vertex2, get_mid(vertex1, vertex2), get_mid(vertex2, vertex3), depth - 1)\n    triangle(vertex3, get_mid(vertex3, vertex2), get_mid(vertex1, vertex3), depth - 1)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        raise ValueError(\n            \"Correct format for using this script: \"\n            \"python fractals.py <int:depth_for_fractal>\"\n        )\n    my_pen = turtle.Turtle()\n    my_pen.ht()\n    my_pen.speed(5)\n    my_pen.pencolor(\"red\")\n\n    vertices = [(-175, -125), (0, 175), (175, -125)]  # vertices of triangle\n    triangle(vertices[0], vertices[1], vertices[2], int(sys.argv[1]))\n    turtle.Screen().exitonclick()\n", "fractals/koch_snowflake.py": "\"\"\"\nDescription\n    The Koch snowflake is a fractal curve and one of the earliest fractals to\n    have been described. The Koch snowflake can be built up iteratively, in a\n    sequence of stages. The first stage is an equilateral triangle, and each\n    successive stage is formed by adding outward bends to each side of the\n    previous stage, making smaller equilateral triangles.\n    This can be achieved through the following steps for each line:\n        1. divide the line segment into three segments of equal length.\n        2. draw an equilateral triangle that has the middle segment from step 1\n        as its base and points outward.\n        3. remove the line segment that is the base of the triangle from step 2.\n    (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake )\n    (for a more detailed explanation and an implementation in the\n    Processing language, see  https://natureofcode.com/book/chapter-8-fractals/\n    #84-the-koch-curve-and-the-arraylist-technique )\n\nRequirements (pip):\n    - matplotlib\n    - numpy\n\"\"\"\n\nfrom __future__ import annotations\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# initial triangle of Koch snowflake\nVECTOR_1 = np.array([0, 0])\nVECTOR_2 = np.array([0.5, 0.8660254])\nVECTOR_3 = np.array([1, 0])\nINITIAL_VECTORS = [VECTOR_1, VECTOR_2, VECTOR_3, VECTOR_1]\n\n# uncomment for simple Koch curve instead of Koch snowflake\n# INITIAL_VECTORS = [VECTOR_1, VECTOR_3]\n\n\ndef iterate(initial_vectors: list[np.ndarray], steps: int) -> list[np.ndarray]:\n    \"\"\"\n    Go through the number of iterations determined by the argument \"steps\".\n    Be careful with high values (above 5) since the time to calculate increases\n    exponentially.\n    >>> iterate([np.array([0, 0]), np.array([1, 0])], 1)\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    vectors = initial_vectors\n    for _ in range(steps):\n        vectors = iteration_step(vectors)\n    return vectors\n\n\ndef iteration_step(vectors: list[np.ndarray]) -> list[np.ndarray]:\n    \"\"\"\n    Loops through each pair of adjacent vectors. Each line between two adjacent\n    vectors is divided into 4 segments by adding 3 additional vectors in-between\n    the original two vectors. The vector in the middle is constructed through a\n    60 degree rotation so it is bent outwards.\n    >>> iteration_step([np.array([0, 0]), np.array([1, 0])])\n    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , \\\n0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]\n    \"\"\"\n    new_vectors = []\n    for i, start_vector in enumerate(vectors[:-1]):\n        end_vector = vectors[i + 1]\n        new_vectors.append(start_vector)\n        difference_vector = end_vector - start_vector\n        new_vectors.append(start_vector + difference_vector / 3)\n        new_vectors.append(\n            start_vector + difference_vector / 3 + rotate(difference_vector / 3, 60)\n        )\n        new_vectors.append(start_vector + difference_vector * 2 / 3)\n    new_vectors.append(vectors[-1])\n    return new_vectors\n\n\ndef rotate(vector: np.ndarray, angle_in_degrees: float) -> np.ndarray:\n    \"\"\"\n    Standard rotation of a 2D vector with a rotation matrix\n    (see https://en.wikipedia.org/wiki/Rotation_matrix )\n    >>> rotate(np.array([1, 0]), 60)\n    array([0.5      , 0.8660254])\n    >>> rotate(np.array([1, 0]), 90)\n    array([6.123234e-17, 1.000000e+00])\n    \"\"\"\n    theta = np.radians(angle_in_degrees)\n    c, s = np.cos(theta), np.sin(theta)\n    rotation_matrix = np.array(((c, -s), (s, c)))\n    return np.dot(rotation_matrix, vector)\n\n\ndef plot(vectors: list[np.ndarray]) -> None:\n    \"\"\"\n    Utility function to plot the vectors using matplotlib.pyplot\n    No doctest was implemented since this function does not have a return value\n    \"\"\"\n    # avoid stretched display of graph\n    axes = plt.gca()\n    axes.set_aspect(\"equal\")\n\n    # matplotlib.pyplot.plot takes a list of all x-coordinates and a list of all\n    # y-coordinates as inputs, which are constructed from the vector-list using\n    # zip()\n    x_coordinates, y_coordinates = zip(*vectors)\n    plt.plot(x_coordinates, y_coordinates)\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    processed_vectors = iterate(INITIAL_VECTORS, 5)\n    plot(processed_vectors)\n", "fractals/mandelbrot.py": "\"\"\"\nThe Mandelbrot set is the set of complex numbers \"c\" for which the series\n\"z_(n+1) = z_n * z_n + c\" does not diverge, i.e. remains bounded. Thus, a\ncomplex number \"c\" is a member of the Mandelbrot set if, when starting with\n\"z_0 = 0\" and applying the iteration repeatedly, the absolute value of\n\"z_n\" remains bounded for all \"n > 0\". Complex numbers can be written as\n\"a + b*i\": \"a\" is the real component, usually drawn on the x-axis, and \"b*i\"\nis the imaginary component, usually drawn on the y-axis. Most visualizations\nof the Mandelbrot set use a color-coding to indicate after how many steps in\nthe series the numbers outside the set diverge. Images of the Mandelbrot set\nexhibit an elaborate and infinitely complicated boundary that reveals\nprogressively ever-finer recursive detail at increasing magnifications, making\nthe boundary of the Mandelbrot set a fractal curve.\n(description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set )\n(see also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set )\n\"\"\"\n\nimport colorsys\n\nfrom PIL import Image\n\n\ndef get_distance(x: float, y: float, max_step: int) -> float:\n    \"\"\"\n    Return the relative distance (= step/max_step) after which the complex number\n    constituted by this x-y-pair diverges. Members of the Mandelbrot set do not\n    diverge so their distance is 1.\n\n    >>> get_distance(0, 0, 50)\n    1.0\n    >>> get_distance(0.5, 0.5, 50)\n    0.061224489795918366\n    >>> get_distance(2, 0, 50)\n    0.0\n    \"\"\"\n    a = x\n    b = y\n    for step in range(max_step):  # noqa: B007\n        a_new = a * a - b * b + x\n        b = 2 * a * b + y\n        a = a_new\n\n        # divergence happens for all complex number with an absolute value\n        # greater than 4\n        if a * a + b * b > 4:\n            break\n    return step / (max_step - 1)\n\n\ndef get_black_and_white_rgb(distance: float) -> tuple:\n    \"\"\"\n    Black&white color-coding that ignores the relative distance. The Mandelbrot\n    set is black, everything else is white.\n\n    >>> get_black_and_white_rgb(0)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(0.5)\n    (255, 255, 255)\n    >>> get_black_and_white_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return (255, 255, 255)\n\n\ndef get_color_coded_rgb(distance: float) -> tuple:\n    \"\"\"\n    Color-coding taking the relative distance into account. The Mandelbrot set\n    is black.\n\n    >>> get_color_coded_rgb(0)\n    (255, 0, 0)\n    >>> get_color_coded_rgb(0.5)\n    (0, 255, 255)\n    >>> get_color_coded_rgb(1)\n    (0, 0, 0)\n    \"\"\"\n    if distance == 1:\n        return (0, 0, 0)\n    else:\n        return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(distance, 1, 1))\n\n\ndef get_image(\n    image_width: int = 800,\n    image_height: int = 600,\n    figure_center_x: float = -0.6,\n    figure_center_y: float = 0,\n    figure_width: float = 3.2,\n    max_step: int = 50,\n    use_distance_color_coding: bool = True,\n) -> Image.Image:\n    \"\"\"\n    Function to generate the image of the Mandelbrot set. Two types of coordinates\n    are used: image-coordinates that refer to the pixels and figure-coordinates\n    that refer to the complex numbers inside and outside the Mandelbrot set. The\n    figure-coordinates in the arguments of this function determine which section\n    of the Mandelbrot set is viewed. The main area of the Mandelbrot set is\n    roughly between \"-1.5 < x < 0.5\" and \"-1 < y < 1\" in the figure-coordinates.\n\n    Commenting out tests that slow down pytest...\n    # 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image\n    # >>> get_image().load()[0,0]\n    (255, 0, 0)\n    # >>> get_image(use_distance_color_coding = False).load()[0,0]\n    (255, 255, 255)\n    \"\"\"\n    img = Image.new(\"RGB\", (image_width, image_height))\n    pixels = img.load()\n\n    # loop through the image-coordinates\n    for image_x in range(image_width):\n        for image_y in range(image_height):\n            # determine the figure-coordinates based on the image-coordinates\n            figure_height = figure_width / image_width * image_height\n            figure_x = figure_center_x + (image_x / image_width - 0.5) * figure_width\n            figure_y = figure_center_y + (image_y / image_height - 0.5) * figure_height\n\n            distance = get_distance(figure_x, figure_y, max_step)\n\n            # color the corresponding pixel based on the selected coloring-function\n            if use_distance_color_coding:\n                pixels[image_x, image_y] = get_color_coded_rgb(distance)\n            else:\n                pixels[image_x, image_y] = get_black_and_white_rgb(distance)\n\n    return img\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # colored version, full figure\n    img = get_image()\n\n    # uncomment for colored version, different section, zoomed in\n    # img = get_image(figure_center_x = -0.6, figure_center_y = -0.4,\n    # figure_width = 0.8)\n\n    # uncomment for black and white version, full figure\n    # img = get_image(use_distance_color_coding = False)\n\n    # uncomment to save the image\n    # img.save(\"mandelbrot.png\")\n\n    img.show()\n", "fractals/vicsek.py": "\"\"\"Authors Bastien Capiaux & Mehdi Oudghiri\n\nThe Vicsek fractal algorithm is a recursive algorithm that creates a\npattern known as the Vicsek fractal or the Vicsek square.\nIt is based on the concept of self-similarity, where the pattern at each\nlevel of recursion resembles the overall pattern.\nThe algorithm involves dividing a square into 9 equal smaller squares,\nremoving the center square, and then repeating this process on the remaining 8 squares.\nThis results in a pattern that exhibits self-similarity and has a\nsquare-shaped outline with smaller squares within it.\n\nSource: https://en.wikipedia.org/wiki/Vicsek_fractal\n\"\"\"\n\nimport turtle\n\n\ndef draw_cross(x: float, y: float, length: float):\n    \"\"\"\n    Draw a cross at the specified position and with the specified length.\n    \"\"\"\n    turtle.up()\n    turtle.goto(x - length / 2, y - length / 6)\n    turtle.down()\n    turtle.seth(0)\n    turtle.begin_fill()\n    for _ in range(4):\n        turtle.fd(length / 3)\n        turtle.right(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n        turtle.fd(length / 3)\n        turtle.left(90)\n    turtle.end_fill()\n\n\ndef draw_fractal_recursive(x: float, y: float, length: float, depth: float):\n    \"\"\"\n    Recursively draw the Vicsek fractal at the specified position, with the\n    specified length and depth.\n    \"\"\"\n    if depth == 0:\n        draw_cross(x, y, length)\n        return\n\n    draw_fractal_recursive(x, y, length / 3, depth - 1)\n    draw_fractal_recursive(x + length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x - length / 3, y, length / 3, depth - 1)\n    draw_fractal_recursive(x, y + length / 3, length / 3, depth - 1)\n    draw_fractal_recursive(x, y - length / 3, length / 3, depth - 1)\n\n\ndef set_color(rgb: str):\n    turtle.color(rgb)\n\n\ndef draw_vicsek_fractal(x: float, y: float, length: float, depth: float, color=\"blue\"):\n    \"\"\"\n    Draw the Vicsek fractal at the specified position, with the specified\n    length and depth.\n    \"\"\"\n    turtle.speed(0)\n    turtle.hideturtle()\n    set_color(color)\n    draw_fractal_recursive(x, y, length, depth)\n    turtle.Screen().update()\n\n\ndef main():\n    draw_vicsek_fractal(0, 0, 800, 4)\n\n    turtle.done()\n\n\nif __name__ == \"__main__\":\n    main()\n", "fractals/julia_sets.py": "\"\"\"Author Alexandre De Zotti\n\nDraws Julia sets of quadratic polynomials and exponential maps.\n More specifically, this iterates the function a fixed number of times\n then plots whether the absolute value of the last iterate is greater than\n a fixed threshold (named \"escape radius\"). For the exponential map this is not\n really an escape radius but rather a convenient way to approximate the Julia\n set with bounded orbits.\n\nThe examples presented here are:\n- The Cauliflower Julia set, see e.g.\nhttps://en.wikipedia.org/wiki/File:Julia_z2%2B0,25.png\n- Other examples from https://en.wikipedia.org/wiki/Julia_set\n- An exponential map Julia set, ambiantly homeomorphic to the examples in\nhttps://www.math.univ-toulouse.fr/~cheritat/GalII/galery.html\n and\nhttps://ddd.uab.cat/pub/pubmat/02141493v43n1/02141493v43n1p27.pdf\n\nRemark: Some overflow runtime warnings are suppressed. This is because of the\n way the iteration loop is implemented, using numpy's efficient computations.\n Overflows and infinites are replaced after each step by a large number.\n\"\"\"\n\nimport warnings\nfrom collections.abc import Callable\nfrom typing import Any\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nc_cauliflower = 0.25 + 0.0j\nc_polynomial_1 = -0.4 + 0.6j\nc_polynomial_2 = -0.1 + 0.651j\nc_exponential = -2.0\nnb_iterations = 56\nwindow_size = 2.0\nnb_pixels = 666\n\n\ndef eval_exponential(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate $e^z + c$.\n    >>> eval_exponential(0, 0)\n    1.0\n    >>> abs(eval_exponential(1, np.pi*1.j)) < 1e-15\n    True\n    >>> abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15\n    True\n    \"\"\"\n    return np.exp(z_values) + c_parameter\n\n\ndef eval_quadratic_polynomial(c_parameter: complex, z_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    >>> eval_quadratic_polynomial(0, 2)\n    4\n    >>> eval_quadratic_polynomial(-1, 1)\n    0\n    >>> round(eval_quadratic_polynomial(1.j, 0).imag)\n    1\n    >>> round(eval_quadratic_polynomial(1.j, 0).real)\n    0\n    \"\"\"\n    return z_values * z_values + c_parameter\n\n\ndef prepare_grid(window_size: float, nb_pixels: int) -> np.ndarray:\n    \"\"\"\n    Create a grid of complex values of size nb_pixels*nb_pixels with real and\n     imaginary parts ranging from -window_size to window_size (inclusive).\n    Returns a numpy array.\n\n    >>> prepare_grid(1,3)\n    array([[-1.-1.j, -1.+0.j, -1.+1.j],\n           [ 0.-1.j,  0.+0.j,  0.+1.j],\n           [ 1.-1.j,  1.+0.j,  1.+1.j]])\n    \"\"\"\n    x = np.linspace(-window_size, window_size, nb_pixels)\n    x = x.reshape((nb_pixels, 1))\n    y = np.linspace(-window_size, window_size, nb_pixels)\n    y = y.reshape((1, nb_pixels))\n    return x + 1.0j * y\n\n\ndef iterate_function(\n    eval_function: Callable[[Any, np.ndarray], np.ndarray],\n    function_params: Any,\n    nb_iterations: int,\n    z_0: np.ndarray,\n    infinity: float | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Iterate the function \"eval_function\" exactly nb_iterations times.\n    The first argument of the function is a parameter which is contained in\n    function_params. The variable z_0 is an array that contains the initial\n    values to iterate from.\n    This function returns the final iterates.\n\n    >>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape\n    (3,)\n    >>> np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[0])\n    0j\n    >>> np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[1])\n    (1+0j)\n    >>> np.round(iterate_function(eval_quadratic_polynomial,\n    ... 0,\n    ... 3,\n    ... np.array([0,1,2]))[2])\n    (256+0j)\n    \"\"\"\n\n    z_n = z_0.astype(\"complex64\")\n    for _ in range(nb_iterations):\n        z_n = eval_function(function_params, z_n)\n        if infinity is not None:\n            np.nan_to_num(z_n, copy=False, nan=infinity)\n            z_n[abs(z_n) == np.inf] = infinity\n    return z_n\n\n\ndef show_results(\n    function_label: str,\n    function_params: Any,\n    escape_radius: float,\n    z_final: np.ndarray,\n) -> None:\n    \"\"\"\n    Plots of whether the absolute value of z_final is greater than\n    the value of escape_radius. Adds the function_label and function_params to\n    the title.\n\n    >>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))\n    \"\"\"\n\n    abs_z_final = (abs(z_final)).transpose()\n    abs_z_final[:, :] = abs_z_final[::-1, :]\n    plt.matshow(abs_z_final < escape_radius)\n    plt.title(f\"Julia set of ${function_label}$, $c={function_params}$\")\n    plt.show()\n\n\ndef ignore_overflow_warnings() -> None:\n    \"\"\"\n    Ignore some overflow and invalid value warnings.\n\n    >>> ignore_overflow_warnings()\n    \"\"\"\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in multiply\"\n    )\n    warnings.filterwarnings(\n        \"ignore\",\n        category=RuntimeWarning,\n        message=\"invalid value encountered in multiply\",\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in absolute\"\n    )\n    warnings.filterwarnings(\n        \"ignore\", category=RuntimeWarning, message=\"overflow encountered in exp\"\n    )\n\n\nif __name__ == \"__main__\":\n    z_0 = prepare_grid(window_size, nb_pixels)\n\n    ignore_overflow_warnings()  # See file header for explanations\n\n    nb_iterations = 24\n    escape_radius = 2 * abs(c_cauliflower) + 1\n    z_final = iterate_function(\n        eval_quadratic_polynomial,\n        c_cauliflower,\n        nb_iterations,\n        z_0,\n        infinity=1.1 * escape_radius,\n    )\n    show_results(\"z^2+c\", c_cauliflower, escape_radius, z_final)\n\n    nb_iterations = 64\n    escape_radius = 2 * abs(c_polynomial_1) + 1\n    z_final = iterate_function(\n        eval_quadratic_polynomial,\n        c_polynomial_1,\n        nb_iterations,\n        z_0,\n        infinity=1.1 * escape_radius,\n    )\n    show_results(\"z^2+c\", c_polynomial_1, escape_radius, z_final)\n\n    nb_iterations = 161\n    escape_radius = 2 * abs(c_polynomial_2) + 1\n    z_final = iterate_function(\n        eval_quadratic_polynomial,\n        c_polynomial_2,\n        nb_iterations,\n        z_0,\n        infinity=1.1 * escape_radius,\n    )\n    show_results(\"z^2+c\", c_polynomial_2, escape_radius, z_final)\n\n    nb_iterations = 12\n    escape_radius = 10000.0\n    z_final = iterate_function(\n        eval_exponential,\n        c_exponential,\n        nb_iterations,\n        z_0 + 2,\n        infinity=1.0e10,\n    )\n    show_results(\"e^z+c\", c_exponential, escape_radius, z_final)\n", "fractals/__init__.py": "", "knapsack/greedy_knapsack.py": "# To get an insight into Greedy Algorithm through the Knapsack problem\n\n\n\"\"\"\nA shopkeeper has bags of wheat that each have different weights and different profits.\neg.\nprofit 5 8 7 1 12 3 4\nweight 2 7 1 6  4 2 5\nmax_weight 100\n\nConstraints:\nmax_weight > 0\nprofit[i] >= 0\nweight[i] >= 0\nCalculate the maximum profit that the shopkeeper can make given maxmum weight that can\nbe carried.\n\"\"\"\n\n\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError(\"The length of profit and weight must be same.\")\n    if max_weight <= 0:\n        raise ValueError(\"max_weight must greater than zero.\")\n    if any(p < 0 for p in profit):\n        raise ValueError(\"Profit can not be negative.\")\n    if any(w < 0 for w in weight):\n        raise ValueError(\"Weight can not be negative.\")\n\n    # List created to store profit gained for the 1kg in case of each weight\n    # respectively.  Calculate and append profit/weight for each element.\n    profit_by_weight = [p / w for p, w in zip(profit, weight)]\n\n    # Creating a copy of the list and sorting profit/weight in ascending order\n    sorted_profit_by_weight = sorted(profit_by_weight)\n\n    # declaring useful variables\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n\n    # loop till the total weight do not reach max limit e.g. 15 kg and till i<length\n    while limit <= max_weight and i < length:\n        # flag value for encountered greatest element in sorted_profit_by_weight\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n\n        # check if the weight encountered is less than the total weight\n        # encountered before.\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            # Adding profit gained for the given weight 1 ===\n            # weight[index]/weight[index]\n            gain += 1 * profit[index]\n        else:\n            # Since the weight encountered is greater than limit, therefore take the\n            # required number of remaining kgs and calculate profit for it.\n            # weight remaining / weight[index]\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain\n\n\nif __name__ == \"__main__\":\n    print(\n        \"Input profits, weights, and then max_weight (all positive ints) separated by \"\n        \"spaces.\"\n    )\n\n    profit = [int(x) for x in input(\"Input profits separated by spaces: \").split()]\n    weight = [int(x) for x in input(\"Input weights separated by spaces: \").split()]\n    max_weight = int(input(\"Max weight allowed: \"))\n\n    # Function Call\n    calc_profit(profit, weight, max_weight)\n", "knapsack/recursive_approach_knapsack.py": "# To get an insight into naive recursive way to solve the Knapsack problem\n\n\n\"\"\"\nA shopkeeper has bags of wheat that each have different weights and different profits.\neg.\nno_of_items 4\nprofit 5 4 8 6\nweight 1 2 4 5\nmax_weight 5\nConstraints:\nmax_weight > 0\nprofit[i] >= 0\nweight[i] >= 0\nCalculate the maximum profit that the shopkeeper can make given maxmum weight that can\nbe carried.\n\"\"\"\n\n\ndef knapsack(\n    weights: list, values: list, number_of_items: int, max_weight: int, index: int\n) -> int:\n    \"\"\"\n    Function description is as follows-\n    :param weights: Take a list of weights\n    :param values: Take a list of profits corresponding to the weights\n    :param number_of_items: number of items available to pick from\n    :param max_weight: Maximum weight that could be carried\n    :param index: the element we are looking at\n    :return: Maximum expected gain\n    >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)\n    13\n    >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)\n    27\n    \"\"\"\n    if index == number_of_items:\n        return 0\n    ans1 = 0\n    ans2 = 0\n    ans1 = knapsack(weights, values, number_of_items, max_weight, index + 1)\n    if weights[index] <= max_weight:\n        ans2 = values[index] + knapsack(\n            weights, values, number_of_items, max_weight - weights[index], index + 1\n        )\n    return max(ans1, ans2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "knapsack/knapsack.py": "\"\"\"A naive recursive implementation of 0-1 Knapsack Problem\nhttps://en.wikipedia.org/wiki/Knapsack_problem\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int:\n    \"\"\"\n    Returns the maximum value that can be put in a knapsack of a capacity cap,\n    whereby each weight w has a specific value val.\n\n    >>> cap = 50\n    >>> val = [60, 100, 120]\n    >>> w = [10, 20, 30]\n    >>> c = len(val)\n    >>> knapsack(cap, w, val, c)\n    220\n\n    The result is 220 cause the values of 100 and 120 got the weight of 50\n    which is the limit of the capacity.\n    \"\"\"\n\n    # Base Case\n    if counter == 0 or capacity == 0:\n        return 0\n\n    # If weight of the nth item is more than Knapsack of capacity,\n    #   then this item cannot be included in the optimal solution,\n    # else return the maximum of two cases:\n    #   (1) nth item included\n    #   (2) not included\n    if weights[counter - 1] > capacity:\n        return knapsack(capacity, weights, values, counter - 1)\n    else:\n        left_capacity = capacity - weights[counter - 1]\n        new_value_included = values[counter - 1] + knapsack(\n            left_capacity, weights, values, counter - 1\n        )\n        without_new_value = knapsack(capacity, weights, values, counter - 1)\n        return max(new_value_included, without_new_value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "knapsack/__init__.py": "", "dynamic_programming/matrix_chain_multiplication.py": "\"\"\"\nFind the minimum number of multiplications needed to multiply chain of matrices.\nReference: https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/\n\nThe algorithm has interesting real-world applications. Example:\n1. Image transformations in Computer Graphics as images are composed of matrix.\n2. Solve complex polynomial equations in the field of algebra using least processing\n   power.\n3. Calculate overall impact of macroeconomic decisions as economic equations involve a\n   number of variables.\n4. Self-driving car navigation can be made more accurate as matrix multiplication can\n   accurately determine position and orientation of obstacles in short time.\n\nPython doctests can be run with the following command:\npython -m doctest -v matrix_chain_multiply.py\n\nGiven a sequence arr[] that represents chain of 2D matrices such that the dimension of\nthe ith matrix is arr[i-1]*arr[i].\nSo suppose arr = [40, 20, 30, 10, 30] means we have 4 matrices of dimensions\n40*20, 20*30, 30*10 and 10*30.\n\nmatrix_chain_multiply() returns an integer denoting minimum number of multiplications to\nmultiply the chain.\n\nWe do not need to perform actual multiplication here.\nWe only need to decide the order in which to perform the multiplication.\n\nHints:\n1. Number of multiplications (ie cost) to multiply 2 matrices\nof size m*p and p*n is m*p*n.\n2. Cost of matrix multiplication is associative ie (M1*M2)*M3 != M1*(M2*M3)\n3. Matrix multiplication is not commutative. So, M1*M2 does not mean M2*M1 can be done.\n4. To determine the required order, we can try different combinations.\nSo, this problem has overlapping sub-problems and can be solved using recursion.\nWe use Dynamic Programming for optimal time complexity.\n\nExample input:\narr = [40, 20, 30, 10, 30]\noutput: 26000\n\"\"\"\n\nfrom collections.abc import Iterator\nfrom contextlib import contextmanager\nfrom functools import cache\nfrom sys import maxsize\n\n\ndef matrix_chain_multiply(arr: list[int]) -> int:\n    \"\"\"\n    Find the minimum number of multiplcations required to multiply the chain of matrices\n\n    Args:\n        arr: The input array of integers.\n\n    Returns:\n        Minimum number of multiplications needed to multiply the chain\n\n    Examples:\n        >>> matrix_chain_multiply([1, 2, 3, 4, 3])\n        30\n        >>> matrix_chain_multiply([10])\n        0\n        >>> matrix_chain_multiply([10, 20])\n        0\n        >>> matrix_chain_multiply([19, 2, 19])\n        722\n        >>> matrix_chain_multiply(list(range(1, 100)))\n        323398\n\n        # >>> matrix_chain_multiply(list(range(1, 251)))\n        # 2626798\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n    # initialising 2D dp matrix\n    n = len(arr)\n    dp = [[maxsize for j in range(n)] for i in range(n)]\n    # we want minimum cost of multiplication of matrices\n    # of dimension (i*k) and (k*j). This cost is arr[i-1]*arr[k]*arr[j].\n    for i in range(n - 1, 0, -1):\n        for j in range(i, n):\n            if i == j:\n                dp[i][j] = 0\n                continue\n            for k in range(i, j):\n                dp[i][j] = min(\n                    dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]\n                )\n\n    return dp[1][n - 1]\n\n\ndef matrix_chain_order(dims: list[int]) -> int:\n    \"\"\"\n    Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication\n    The dynamic programming solution is faster than cached the recursive solution and\n    can handle larger inputs.\n    >>> matrix_chain_order([1, 2, 3, 4, 3])\n    30\n    >>> matrix_chain_order([10])\n    0\n    >>> matrix_chain_order([10, 20])\n    0\n    >>> matrix_chain_order([19, 2, 19])\n    722\n    >>> matrix_chain_order(list(range(1, 100)))\n    323398\n\n    # >>> matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised\n    # 2626798\n    \"\"\"\n\n    @cache\n    def a(i: int, j: int) -> int:\n        return min(\n            (a(i, k) + dims[i] * dims[k] * dims[j] + a(k, j) for k in range(i + 1, j)),\n            default=0,\n        )\n\n    return a(0, len(dims) - 1)\n\n\n@contextmanager\ndef elapsed_time(msg: str) -> Iterator:\n    # print(f\"Starting: {msg}\")\n    from time import perf_counter_ns\n\n    start = perf_counter_ns()\n    yield\n    print(f\"Finished: {msg} in {(perf_counter_ns() - start) / 10 ** 9} seconds.\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    with elapsed_time(\"matrix_chain_order\"):\n        print(f\"{matrix_chain_order(list(range(1, 251))) = }\")\n    with elapsed_time(\"matrix_chain_multiply\"):\n        print(f\"{matrix_chain_multiply(list(range(1, 251))) = }\")\n    with elapsed_time(\"matrix_chain_order\"):\n        print(f\"{matrix_chain_order(list(range(1, 251))) = }\")\n    with elapsed_time(\"matrix_chain_multiply\"):\n        print(f\"{matrix_chain_multiply(list(range(1, 251))) = }\")\n", "dynamic_programming/k_means_clustering_tensorflow.py": "from random import shuffle\n\nimport tensorflow as tf\nfrom numpy import array\n\n\ndef tf_k_means_cluster(vectors, noofclusters):\n    \"\"\"\n    K-Means Clustering using TensorFlow.\n    'vectors' should be a n*k 2-D NumPy array, where n is the number\n    of vectors of dimensionality k.\n    'noofclusters' should be an integer.\n    \"\"\"\n\n    noofclusters = int(noofclusters)\n    assert noofclusters < len(vectors)\n\n    # Find out the dimensionality\n    dim = len(vectors[0])\n\n    # Will help select random centroids from among the available vectors\n    vector_indices = list(range(len(vectors)))\n    shuffle(vector_indices)\n\n    # GRAPH OF COMPUTATION\n    # We initialize a new graph and set it as the default during each run\n    # of this algorithm. This ensures that as this function is called\n    # multiple times, the default graph doesn't keep getting crowded with\n    # unused ops and Variables from previous function calls.\n\n    graph = tf.Graph()\n\n    with graph.as_default():\n        # SESSION OF COMPUTATION\n\n        sess = tf.Session()\n\n        ##CONSTRUCTING THE ELEMENTS OF COMPUTATION\n\n        ##First lets ensure we have a Variable vector for each centroid,\n        ##initialized to one of the vectors from the available data points\n        centroids = [\n            tf.Variable(vectors[vector_indices[i]]) for i in range(noofclusters)\n        ]\n        ##These nodes will assign the centroid Variables the appropriate\n        ##values\n        centroid_value = tf.placeholder(\"float64\", [dim])\n        cent_assigns = []\n        for centroid in centroids:\n            cent_assigns.append(tf.assign(centroid, centroid_value))\n\n        ##Variables for cluster assignments of individual vectors(initialized\n        ##to 0 at first)\n        assignments = [tf.Variable(0) for i in range(len(vectors))]\n        ##These nodes will assign an assignment Variable the appropriate\n        ##value\n        assignment_value = tf.placeholder(\"int32\")\n        cluster_assigns = []\n        for assignment in assignments:\n            cluster_assigns.append(tf.assign(assignment, assignment_value))\n\n        ##Now lets construct the node that will compute the mean\n        # The placeholder for the input\n        mean_input = tf.placeholder(\"float\", [None, dim])\n        # The Node/op takes the input and computes a mean along the 0th\n        # dimension, i.e. the list of input vectors\n        mean_op = tf.reduce_mean(mean_input, 0)\n\n        ##Node for computing Euclidean distances\n        # Placeholders for input\n        v1 = tf.placeholder(\"float\", [dim])\n        v2 = tf.placeholder(\"float\", [dim])\n        euclid_dist = tf.sqrt(tf.reduce_sum(tf.pow(tf.sub(v1, v2), 2)))\n\n        ##This node will figure out which cluster to assign a vector to,\n        ##based on Euclidean distances of the vector from the centroids.\n        # Placeholder for input\n        centroid_distances = tf.placeholder(\"float\", [noofclusters])\n        cluster_assignment = tf.argmin(centroid_distances, 0)\n\n        ##INITIALIZING STATE VARIABLES\n\n        ##This will help initialization of all Variables defined with respect\n        ##to the graph. The Variable-initializer should be defined after\n        ##all the Variables have been constructed, so that each of them\n        ##will be included in the initialization.\n        init_op = tf.initialize_all_variables()\n\n        # Initialize all variables\n        sess.run(init_op)\n\n        ##CLUSTERING ITERATIONS\n\n        # Now perform the Expectation-Maximization steps of K-Means clustering\n        # iterations. To keep things simple, we will only do a set number of\n        # iterations, instead of using a Stopping Criterion.\n        noofiterations = 100\n        for _ in range(noofiterations):\n            ##EXPECTATION STEP\n            ##Based on the centroid locations till last iteration, compute\n            ##the _expected_ centroid assignments.\n            # Iterate over each vector\n            for vector_n in range(len(vectors)):\n                vect = vectors[vector_n]\n                # Compute Euclidean distance between this vector and each\n                # centroid. Remember that this list cannot be named\n                #'centroid_distances', since that is the input to the\n                # cluster assignment node.\n                distances = [\n                    sess.run(euclid_dist, feed_dict={v1: vect, v2: sess.run(centroid)})\n                    for centroid in centroids\n                ]\n                # Now use the cluster assignment node, with the distances\n                # as the input\n                assignment = sess.run(\n                    cluster_assignment, feed_dict={centroid_distances: distances}\n                )\n                # Now assign the value to the appropriate state variable\n                sess.run(\n                    cluster_assigns[vector_n], feed_dict={assignment_value: assignment}\n                )\n\n            ##MAXIMIZATION STEP\n            # Based on the expected state computed from the Expectation Step,\n            # compute the locations of the centroids so as to maximize the\n            # overall objective of minimizing within-cluster Sum-of-Squares\n            for cluster_n in range(noofclusters):\n                # Collect all the vectors assigned to this cluster\n                assigned_vects = [\n                    vectors[i]\n                    for i in range(len(vectors))\n                    if sess.run(assignments[i]) == cluster_n\n                ]\n                # Compute new centroid location\n                new_location = sess.run(\n                    mean_op, feed_dict={mean_input: array(assigned_vects)}\n                )\n                # Assign value to appropriate variable\n                sess.run(\n                    cent_assigns[cluster_n], feed_dict={centroid_value: new_location}\n                )\n\n        # Return centroids and assignments\n        centroids = sess.run(centroids)\n        assignments = sess.run(assignments)\n        return centroids, assignments\n", "dynamic_programming/minimum_tickets_cost.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : November 1, 2022\n\nTask:\nGiven a list of days when you need to travel. Each day is integer from 1 to 365.\nYou are able to use tickets for 1 day, 7 days and 30 days.\nEach ticket has a cost.\n\nFind the minimum cost you need to travel every day in the given list of days.\n\nImplementation notes:\nimplementation Dynamic Programming up bottom approach.\n\nRuntime complexity: O(n)\n\nThe implementation was tested on the\nleetcode: https://leetcode.com/problems/minimum-cost-for-tickets/\n\n\nMinimum Cost For Tickets\nDynamic Programming: up -> down.\n\"\"\"\n\nimport functools\n\n\ndef mincost_tickets(days: list[int], costs: list[int]) -> int:\n    \"\"\"\n    >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])\n    11\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])\n    17\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    24\n\n    >>> mincost_tickets([2], [2, 90, 150])\n    2\n\n    >>> mincost_tickets([], [2, 90, 150])\n    0\n\n    >>> mincost_tickets('hello', [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([], 'world')\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter days should be a list of integers\n\n    >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be greater than 0\n\n    >>> mincost_tickets([2, 367], [2, 90, 150])\n    Traceback (most recent call last):\n     ...\n    ValueError: All days elements should be less than 366\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([], [])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n\n    >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])\n    Traceback (most recent call last):\n     ...\n    ValueError: The parameter costs should be a list of three integers\n    \"\"\"\n\n    # Validation\n    if not isinstance(days, list) or not all(isinstance(day, int) for day in days):\n        raise ValueError(\"The parameter days should be a list of integers\")\n\n    if len(costs) != 3 or not all(isinstance(cost, int) for cost in costs):\n        raise ValueError(\"The parameter costs should be a list of three integers\")\n\n    if len(days) == 0:\n        return 0\n\n    if min(days) <= 0:\n        raise ValueError(\"All days elements should be greater than 0\")\n\n    if max(days) >= 366:\n        raise ValueError(\"All days elements should be less than 366\")\n\n    days_set = set(days)\n\n    @functools.cache\n    def dynamic_programming(index: int) -> int:\n        if index > 365:\n            return 0\n\n        if index not in days_set:\n            return dynamic_programming(index + 1)\n\n        return min(\n            costs[0] + dynamic_programming(index + 1),\n            costs[1] + dynamic_programming(index + 7),\n            costs[2] + dynamic_programming(index + 30),\n        )\n\n    return dynamic_programming(1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/bitmask.py": "\"\"\"\n\nThis is a Python implementation for questions involving task assignments between people.\nHere Bitmasking and DP are used for solving this.\n\nQuestion :-\nWe have N tasks and M people. Each person in M can do only certain of these tasks. Also\na person can do only one task and a task is performed only by one person.\nFind the total no of ways in which the tasks can be distributed.\n\"\"\"\n\nfrom collections import defaultdict\n\n\nclass AssignmentUsingBitmask:\n    def __init__(self, task_performed, total):\n        self.total_tasks = total  # total no of tasks (N)\n\n        # DP table will have a dimension of (2^M)*N\n        # initially all values are set to -1\n        self.dp = [\n            [-1 for i in range(total + 1)] for j in range(2 ** len(task_performed))\n        ]\n\n        self.task = defaultdict(list)  # stores the list of persons for each task\n\n        # final_mask is used to check if all persons are included by setting all bits\n        # to 1\n        self.final_mask = (1 << len(task_performed)) - 1\n\n    def count_ways_until(self, mask, task_no):\n        # if mask == self.finalmask all persons are distributed tasks, return 1\n        if mask == self.final_mask:\n            return 1\n\n        # if not everyone gets the task and no more tasks are available, return 0\n        if task_no > self.total_tasks:\n            return 0\n\n        # if case already considered\n        if self.dp[mask][task_no] != -1:\n            return self.dp[mask][task_no]\n\n        # Number of ways when we don't this task in the arrangement\n        total_ways_util = self.count_ways_until(mask, task_no + 1)\n\n        # now assign the tasks one by one to all possible persons and recursively\n        # assign for the remaining tasks.\n        if task_no in self.task:\n            for p in self.task[task_no]:\n                # if p is already given a task\n                if mask & (1 << p):\n                    continue\n\n                # assign this task to p and change the mask value. And recursively\n                # assign tasks with the new mask value.\n                total_ways_util += self.count_ways_until(mask | (1 << p), task_no + 1)\n\n        # save the value.\n        self.dp[mask][task_no] = total_ways_util\n\n        return self.dp[mask][task_no]\n\n    def count_no_of_ways(self, task_performed):\n        # Store the list of persons for each task\n        for i in range(len(task_performed)):\n            for j in task_performed[i]:\n                self.task[j].append(i)\n\n        # call the function to fill the DP table, final answer is stored in dp[0][1]\n        return self.count_ways_until(0, 1)\n\n\nif __name__ == \"__main__\":\n    total_tasks = 5  # total no of tasks (the value of N)\n\n    # the list of tasks that can be done by M persons.\n    task_performed = [[1, 3, 4], [1, 2, 5], [3, 4]]\n    print(\n        AssignmentUsingBitmask(task_performed, total_tasks).count_no_of_ways(\n            task_performed\n        )\n    )\n    \"\"\"\n    For the particular example the tasks can be distributed as\n    (1,2,3), (1,2,4), (1,5,3), (1,5,4), (3,1,4),\n    (3,2,4), (3,5,4), (4,1,3), (4,2,3), (4,5,3)\n    total 10\n    \"\"\"\n", "dynamic_programming/minimum_size_subarray_sum.py": "import sys\n\n\ndef minimum_subarray_sum(target: int, numbers: list[int]) -> int:\n    \"\"\"\n    Return the length of the shortest contiguous subarray in a list of numbers whose sum\n    is at least target.  Reference: https://stackoverflow.com/questions/8269916\n\n    >>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])\n    2\n    >>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])\n    4\n    >>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])\n    0\n    >>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7])\n    2\n    >>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5])\n    1\n    >>> minimum_subarray_sum(0, [])\n    0\n    >>> minimum_subarray_sum(0, [1, 2, 3])\n    1\n    >>> minimum_subarray_sum(10, [10, 20, 30])\n    1\n    >>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10])\n    1\n    >>> minimum_subarray_sum(6, [])\n    0\n    >>> minimum_subarray_sum(2, [1, 2, 3])\n    1\n    >>> minimum_subarray_sum(-6, [])\n    0\n    >>> minimum_subarray_sum(-6, [3, 4, 5])\n    1\n    >>> minimum_subarray_sum(8, None)\n    0\n    >>> minimum_subarray_sum(2, \"ABC\")\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    \"\"\"\n    if not numbers:\n        return 0\n    if target == 0 and target in numbers:\n        return 0\n    if not isinstance(numbers, (list, tuple)) or not all(\n        isinstance(number, int) for number in numbers\n    ):\n        raise ValueError(\"numbers must be an iterable of integers\")\n\n    left = right = curr_sum = 0\n    min_len = sys.maxsize\n\n    while right < len(numbers):\n        curr_sum += numbers[right]\n        while curr_sum >= target and left <= right:\n            min_len = min(min_len, right - left + 1)\n            curr_sum -= numbers[left]\n            left += 1\n        right += 1\n\n    return 0 if min_len == sys.maxsize else min_len\n", "dynamic_programming/trapped_water.py": "\"\"\"\nGiven an array of non-negative integers representing an elevation map where the width\nof each bar is 1, this program calculates how much rainwater can be trapped.\n\nExample - height = (0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)\nOutput: 6\nThis problem can be solved using the concept of \"DYNAMIC PROGRAMMING\".\n\nWe calculate the maximum height of bars on the left and right of every bar in array.\nThen iterate over the width of structure and at each index.\nThe amount of water that will be stored is equal to minimum of maximum height of bars\non both sides minus height of bar at current position.\n\"\"\"\n\n\ndef trapped_rainwater(heights: tuple[int, ...]) -> int:\n    \"\"\"\n    The trapped_rainwater function calculates the total amount of rainwater that can be\n    trapped given an array of bar heights.\n    It uses a dynamic programming approach, determining the maximum height of bars on\n    both sides for each bar, and then computing the trapped water above each bar.\n    The function returns the total trapped water.\n\n    >>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1))\n    6\n    >>> trapped_rainwater((7, 1, 5, 3, 6, 4))\n    9\n    >>> trapped_rainwater((7, 1, 5, 3, 6, -1))\n    Traceback (most recent call last):\n        ...\n    ValueError: No height can be negative\n    \"\"\"\n    if not heights:\n        return 0\n    if any(h < 0 for h in heights):\n        raise ValueError(\"No height can be negative\")\n    length = len(heights)\n\n    left_max = [0] * length\n    left_max[0] = heights[0]\n    for i, height in enumerate(heights[1:], start=1):\n        left_max[i] = max(height, left_max[i - 1])\n\n    right_max = [0] * length\n    right_max[-1] = heights[-1]\n    for i in range(length - 2, -1, -1):\n        right_max[i] = max(heights[i], right_max[i + 1])\n\n    return sum(\n        min(left, right) - height\n        for left, right, height in zip(left_max, right_max, heights)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)) = }\")\n    print(f\"{trapped_rainwater((7, 1, 5, 3, 6, 4)) = }\")\n", "dynamic_programming/word_break.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : December 12, 2022\n\nTask:\nGiven a string and a list of words, return true if the string can be\nsegmented into a space-separated sequence of one or more words.\n\nNote that the same word may be reused\nmultiple times in the segmentation.\n\nImplementation notes: Trie + Dynamic programming up -> down.\nThe Trie will be used to store the words. It will be useful for scanning\navailable words for the current position in the string.\n\nLeetcode:\nhttps://leetcode.com/problems/word-break/description/\n\nRuntime: O(n * n)\nSpace: O(n)\n\"\"\"\n\nimport functools\nfrom typing import Any\n\n\ndef word_break(string: str, words: list[str]) -> bool:\n    \"\"\"\n    Return True if numbers have opposite signs False otherwise.\n\n    >>> word_break(\"applepenapple\", [\"apple\",\"pen\"])\n    True\n    >>> word_break(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\n    False\n    >>> word_break(\"cars\", [\"car\",\"ca\",\"rs\"])\n    True\n    >>> word_break('abc', [])\n    False\n    >>> word_break(123, ['a'])\n    Traceback (most recent call last):\n        ...\n    ValueError: the string should be not empty string\n    >>> word_break('', ['a'])\n    Traceback (most recent call last):\n        ...\n    ValueError: the string should be not empty string\n    >>> word_break('abc', [123])\n    Traceback (most recent call last):\n        ...\n    ValueError: the words should be a list of non-empty strings\n    >>> word_break('abc', [''])\n    Traceback (most recent call last):\n        ...\n    ValueError: the words should be a list of non-empty strings\n    \"\"\"\n\n    # Validation\n    if not isinstance(string, str) or len(string) == 0:\n        raise ValueError(\"the string should be not empty string\")\n\n    if not isinstance(words, list) or not all(\n        isinstance(item, str) and len(item) > 0 for item in words\n    ):\n        raise ValueError(\"the words should be a list of non-empty strings\")\n\n    # Build trie\n    trie: dict[str, Any] = {}\n    word_keeper_key = \"WORD_KEEPER\"\n\n    for word in words:\n        trie_node = trie\n        for c in word:\n            if c not in trie_node:\n                trie_node[c] = {}\n\n            trie_node = trie_node[c]\n\n        trie_node[word_keeper_key] = True\n\n    len_string = len(string)\n\n    # Dynamic programming method\n    @functools.cache\n    def is_breakable(index: int) -> bool:\n        \"\"\"\n        >>> string = 'a'\n        >>> is_breakable(1)\n        True\n        \"\"\"\n        if index == len_string:\n            return True\n\n        trie_node = trie\n        for i in range(index, len_string):\n            trie_node = trie_node.get(string[i], None)\n\n            if trie_node is None:\n                return False\n\n            if trie_node.get(word_keeper_key, False) and is_breakable(i + 1):\n                return True\n\n        return False\n\n    return is_breakable(0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/rod_cutting.py": "\"\"\"\nThis module provides two implementations for the rod-cutting problem:\n1. A naive recursive implementation which has an exponential runtime\n2. Two dynamic programming implementations which have quadratic runtime\n\nThe rod-cutting problem is the problem of finding the maximum possible revenue\nobtainable from a rod of length ``n`` given a list of prices for each integral piece\nof the rod. The maximum revenue can thus be obtained by cutting the rod and selling the\npieces separately or not cutting it at all if the price of it is the maximum obtainable.\n\n\"\"\"\n\n\ndef naive_cut_rod_recursive(n: int, prices: list):\n    \"\"\"\n    Solves the rod-cutting problem via naively without using the benefit of dynamic\n    programming. The results is the same sub-problems are solved several times\n    leading to an exponential runtime\n\n    Runtime: O(2^n)\n\n    Arguments\n    -------\n    n: int, the length of the rod\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\n    price for a rod of length ``i``\n\n    Returns\n    -------\n    The maximum revenue obtainable for a rod of length n given the list of prices\n    for each piece.\n\n    Examples\n    --------\n    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])\n    10\n    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n\n    _enforce_args(n, prices)\n    if n == 0:\n        return 0\n    max_revue = float(\"-inf\")\n    for i in range(1, n + 1):\n        max_revue = max(\n            max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices)\n        )\n\n    return max_revue\n\n\ndef top_down_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting\n    problem via memoization. This function serves as a wrapper for\n    _top_down_cut_rod_recursive\n\n    Runtime: O(n^2)\n\n    Arguments\n    --------\n    n: int, the length of the rod\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\n    price for a rod of length ``i``\n\n    Note\n    ----\n    For convenience and because Python's lists using 0-indexing, length(max_rev) =\n    n + 1, to accommodate for the revenue obtainable from a rod of length 0.\n\n    Returns\n    -------\n    The maximum revenue obtainable for a rod of length n given the list of prices\n    for each piece.\n\n    Examples\n    -------\n    >>> top_down_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    return _top_down_cut_rod_recursive(n, prices, max_rev)\n\n\ndef _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):\n    \"\"\"\n    Constructs a top-down dynamic programming solution for the rod-cutting problem\n    via memoization.\n\n    Runtime: O(n^2)\n\n    Arguments\n    --------\n    n: int, the length of the rod\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\n    price for a rod of length ``i``\n    max_rev: list, the computed maximum revenue for a piece of rod.\n    ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\n\n    Returns\n    -------\n    The maximum revenue obtainable for a rod of length n given the list of prices\n    for each piece.\n    \"\"\"\n    if max_rev[n] >= 0:\n        return max_rev[n]\n    elif n == 0:\n        return 0\n    else:\n        max_revenue = float(\"-inf\")\n        for i in range(1, n + 1):\n            max_revenue = max(\n                max_revenue,\n                prices[i - 1] + _top_down_cut_rod_recursive(n - i, prices, max_rev),\n            )\n\n        max_rev[n] = max_revenue\n\n    return max_rev[n]\n\n\ndef bottom_up_cut_rod(n: int, prices: list):\n    \"\"\"\n    Constructs a bottom-up dynamic programming solution for the rod-cutting problem\n\n    Runtime: O(n^2)\n\n    Arguments\n    ----------\n    n: int, the maximum length of the rod.\n    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\n    price for a rod of length ``i``\n\n    Returns\n    -------\n    The maximum revenue obtainable from cutting a rod of length n given\n    the prices for each piece of rod p.\n\n    Examples\n    -------\n    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])\n    10\n    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\n    30\n    \"\"\"\n    _enforce_args(n, prices)\n\n    # length(max_rev) = n + 1, to accommodate for the revenue obtainable from a rod of\n    # length 0.\n    max_rev = [float(\"-inf\") for _ in range(n + 1)]\n    max_rev[0] = 0\n\n    for i in range(1, n + 1):\n        max_revenue_i = max_rev[i]\n        for j in range(1, i + 1):\n            max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\n\n        max_rev[i] = max_revenue_i\n\n    return max_rev[n]\n\n\ndef _enforce_args(n: int, prices: list):\n    \"\"\"\n    Basic checks on the arguments to the rod-cutting algorithms\n\n    n: int, the length of the rod\n    prices: list, the price list for each piece of rod.\n\n    Throws ValueError:\n\n    if n is negative or there are fewer items in the price list than the length of\n    the rod\n    \"\"\"\n    if n < 0:\n        msg = f\"n must be greater than or equal to 0. Got n = {n}\"\n        raise ValueError(msg)\n\n    if n > len(prices):\n        msg = (\n            \"Each integral piece of rod must have a corresponding price. \"\n            f\"Got n = {n} but length of prices = {len(prices)}\"\n        )\n        raise ValueError(msg)\n\n\ndef main():\n    prices = [6, 10, 12, 15, 20, 23]\n    n = len(prices)\n\n    # the best revenue comes from cutting the rod into 6 pieces, each\n    # of length 1 resulting in a revenue of 6 * 6 = 36.\n    expected_max_revenue = 36\n\n    max_rev_top_down = top_down_cut_rod(n, prices)\n    max_rev_bottom_up = bottom_up_cut_rod(n, prices)\n    max_rev_naive = naive_cut_rod_recursive(n, prices)\n\n    assert expected_max_revenue == max_rev_top_down\n    assert max_rev_top_down == max_rev_bottom_up\n    assert max_rev_bottom_up == max_rev_naive\n\n\nif __name__ == \"__main__\":\n    main()\n", "dynamic_programming/tribonacci.py": "# Tribonacci sequence using Dynamic Programming\n\n\ndef tribonacci(num: int) -> list[int]:\n    \"\"\"\n    Given a number, return first n Tribonacci Numbers.\n    >>> tribonacci(5)\n    [0, 0, 1, 1, 2]\n    >>> tribonacci(8)\n    [0, 0, 1, 1, 2, 4, 7, 13]\n    \"\"\"\n    dp = [0] * num\n    dp[2] = 1\n\n    for i in range(3, num):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/wildcard_matching.py": "\"\"\"\nAuthor  : ilyas dahhou\nDate    : Oct 7, 2023\n\nTask:\nGiven an input string and a pattern, implement wildcard pattern matching with support\nfor '?' and '*' where:\n'?' matches any single character.\n'*' matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\nRuntime complexity: O(m * n)\n\nThe implementation was tested on the\nleetcode: https://leetcode.com/problems/wildcard-matching/\n\"\"\"\n\n\ndef is_match(string: str, pattern: str) -> bool:\n    \"\"\"\n    >>> is_match(\"\", \"\")\n    True\n    >>> is_match(\"aa\", \"a\")\n    False\n    >>> is_match(\"abc\", \"abc\")\n    True\n    >>> is_match(\"abc\", \"*c\")\n    True\n    >>> is_match(\"abc\", \"a*\")\n    True\n    >>> is_match(\"abc\", \"*a*\")\n    True\n    >>> is_match(\"abc\", \"?b?\")\n    True\n    >>> is_match(\"abc\", \"*?\")\n    True\n    >>> is_match(\"abc\", \"a*d\")\n    False\n    >>> is_match(\"abc\", \"a*c?\")\n    False\n    >>> is_match('baaabab','*****ba*****ba')\n    False\n    >>> is_match('baaabab','*****ba*****ab')\n    True\n    >>> is_match('aa','*')\n    True\n    \"\"\"\n    dp = [[False] * (len(pattern) + 1) for _ in string + \"1\"]\n    dp[0][0] = True\n    # Fill in the first row\n    for j, char in enumerate(pattern, 1):\n        if char == \"*\":\n            dp[0][j] = dp[0][j - 1]\n    # Fill in the rest of the DP table\n    for i, s_char in enumerate(string, 1):\n        for j, p_char in enumerate(pattern, 1):\n            if p_char in (s_char, \"?\"):\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[len(string)][len(pattern)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{is_match('baaabab','*****ba*****ab') = }\")\n", "dynamic_programming/iterating_through_submasks.py": "\"\"\"\nAuthor : Syed Faizan (3rd Year Student IIIT Pune)\ngithub : faizan2700\nYou are given a bitmask m and you want to efficiently iterate through all of\nits submasks. The mask s is submask of m if only bits that were included in\nbitmask are set\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef list_of_submasks(mask: int) -> list[int]:\n    \"\"\"\n    Args:\n        mask : number which shows mask ( always integer > 0, zero does not have any\n            submasks )\n\n    Returns:\n        all_submasks : the list of submasks of mask (mask s is called submask of mask\n        m if only bits that were included in original mask are set\n\n    Raises:\n        AssertionError: mask not positive integer\n\n    >>> list_of_submasks(15)\n    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    >>> list_of_submasks(13)\n    [13, 12, 9, 8, 5, 4, 1]\n    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input -7\n    >>> list_of_submasks(0)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: mask needs to be positive integer, your input 0\n\n    \"\"\"\n\n    assert (\n        isinstance(mask, int) and mask > 0\n    ), f\"mask needs to be positive integer, your input {mask}\"\n\n    \"\"\"\n    first submask iterated will be mask itself then operation will be performed\n    to get other submasks till we reach empty submask that is zero ( zero is not\n    included in final submasks list )\n    \"\"\"\n    all_submasks = []\n    submask = mask\n\n    while submask:\n        all_submasks.append(submask)\n        submask = (submask - 1) & mask\n\n    return all_submasks\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/max_product_subarray.py": "def max_product_subarray(numbers: list[int]) -> int:\n    \"\"\"\n    Returns the maximum product that can be obtained by multiplying a\n    contiguous subarray of the given integer list `nums`.\n\n    Example:\n    >>> max_product_subarray([2, 3, -2, 4])\n    6\n    >>> max_product_subarray((-2, 0, -1))\n    0\n    >>> max_product_subarray([2, 3, -2, 4, -1])\n    48\n    >>> max_product_subarray([-1])\n    -1\n    >>> max_product_subarray([0])\n    0\n    >>> max_product_subarray([])\n    0\n    >>> max_product_subarray(\"\")\n    0\n    >>> max_product_subarray(None)\n    0\n    >>> max_product_subarray([2, 3, -2, 4.5, -1])\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    >>> max_product_subarray(\"ABC\")\n    Traceback (most recent call last):\n        ...\n    ValueError: numbers must be an iterable of integers\n    \"\"\"\n    if not numbers:\n        return 0\n\n    if not isinstance(numbers, (list, tuple)) or not all(\n        isinstance(number, int) for number in numbers\n    ):\n        raise ValueError(\"numbers must be an iterable of integers\")\n\n    max_till_now = min_till_now = max_prod = numbers[0]\n\n    for i in range(1, len(numbers)):\n        # update the maximum and minimum subarray products\n        number = numbers[i]\n        if number < 0:\n            max_till_now, min_till_now = min_till_now, max_till_now\n        max_till_now = max(number, max_till_now * number)\n        min_till_now = min(number, min_till_now * number)\n\n        # update the maximum product found till now\n        max_prod = max(max_prod, max_till_now)\n\n    return max_prod\n", "dynamic_programming/palindrome_partitioning.py": "\"\"\"\nGiven a string s, partition s such that every substring of the\npartition is a palindrome.\nFind the minimum cuts needed for a palindrome partitioning of s.\n\nTime Complexity: O(n^2)\nSpace Complexity: O(n^2)\nFor other explanations refer to: https://www.youtube.com/watch?v=_H8V5hJUGd0\n\"\"\"\n\n\ndef find_minimum_partitions(string: str) -> int:\n    \"\"\"\n    Returns the minimum cuts needed for a palindrome partitioning of string\n\n    >>> find_minimum_partitions(\"aab\")\n    1\n    >>> find_minimum_partitions(\"aaa\")\n    0\n    >>> find_minimum_partitions(\"ababbbabbababa\")\n    3\n    \"\"\"\n    length = len(string)\n    cut = [0] * length\n    is_palindromic = [[False for i in range(length)] for j in range(length)]\n    for i, c in enumerate(string):\n        mincut = i\n        for j in range(i + 1):\n            if c == string[j] and (i - j < 2 or is_palindromic[j + 1][i - 1]):\n                is_palindromic[j][i] = True\n                mincut = min(mincut, 0 if j == 0 else (cut[j - 1] + 1))\n        cut[i] = mincut\n    return cut[length - 1]\n\n\nif __name__ == \"__main__\":\n    s = input(\"Enter the string: \").strip()\n    ans = find_minimum_partitions(s)\n    print(f\"Minimum number of partitions required for the '{s}' is {ans}\")\n", "dynamic_programming/regex_match.py": "\"\"\"\nRegex matching check if a text matches pattern or not.\nPattern:\n    '.' Matches any single character.\n    '*' Matches zero or more of the preceding element.\nMore info:\n    https://medium.com/trick-the-interviwer/regular-expression-matching-9972eb74c03\n\"\"\"\n\n\ndef recursive_match(text: str, pattern: str) -> bool:\n    \"\"\"\n    Recursive matching algorithm.\n\n    Time complexity: O(2 ^ (|text| + |pattern|))\n    Space complexity: Recursion depth is O(|text| + |pattern|).\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: True if text matches pattern, False otherwise.\n\n    >>> recursive_match('abc', 'a.c')\n    True\n    >>> recursive_match('abc', 'af*.c')\n    True\n    >>> recursive_match('abc', 'a.c*')\n    True\n    >>> recursive_match('abc', 'a.c*d')\n    False\n    >>> recursive_match('aa', '.*')\n    True\n    \"\"\"\n    if not pattern:\n        return not text\n\n    if not text:\n        return pattern[-1] == \"*\" and recursive_match(text, pattern[:-2])\n\n    if text[-1] == pattern[-1] or pattern[-1] == \".\":\n        return recursive_match(text[:-1], pattern[:-1])\n\n    if pattern[-1] == \"*\":\n        return recursive_match(text[:-1], pattern) or recursive_match(\n            text, pattern[:-2]\n        )\n\n    return False\n\n\ndef dp_match(text: str, pattern: str) -> bool:\n    \"\"\"\n    Dynamic programming matching algorithm.\n\n    Time complexity: O(|text| * |pattern|)\n    Space complexity: O(|text| * |pattern|)\n\n    :param text: Text to match.\n    :param pattern: Pattern to match.\n    :return: True if text matches pattern, False otherwise.\n\n    >>> dp_match('abc', 'a.c')\n    True\n    >>> dp_match('abc', 'af*.c')\n    True\n    >>> dp_match('abc', 'a.c*')\n    True\n    >>> dp_match('abc', 'a.c*d')\n    False\n    >>> dp_match('aa', '.*')\n    True\n    \"\"\"\n    m = len(text)\n    n = len(pattern)\n    dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        dp[0][j] = pattern[j - 1] == \"*\" and dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] in {\".\", text[i - 1]}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == \"*\":\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] in {\".\", text[i - 1]}:\n                    dp[i][j] |= dp[i - 1][j]\n            else:\n                dp[i][j] = False\n\n    return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/abbreviation.py": "\"\"\"\nhttps://www.hackerrank.com/challenges/abbr/problem\nYou can perform the following operation on some string, :\n\n1. Capitalize zero or more of 's lowercase letters at some index i\n   (i.e., make them uppercase).\n2. Delete all of the remaining lowercase letters in .\n\nExample:\na=daBcd and b=\"ABC\"\ndaBcd -> capitalize a and c(dABCd) -> remove d (ABC)\n\"\"\"\n\n\ndef abbr(a: str, b: str) -> bool:\n    \"\"\"\n    >>> abbr(\"daBcd\", \"ABC\")\n    True\n    >>> abbr(\"dBcd\", \"ABC\")\n    False\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        for j in range(m + 1):\n            if dp[i][j]:\n                if j < m and a[i].upper() == b[j]:\n                    dp[i + 1][j + 1] = True\n                if a[i].islower():\n                    dp[i + 1][j] = True\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/longest_palindromic_subsequence.py": "\"\"\"\nauthor: Sanket Kittad\nGiven a string s, find the longest palindromic subsequence's length in s.\nInput: s = \"bbbab\"\nOutput: 4\nExplanation: One possible longest palindromic subsequence is \"bbbb\".\nLeetcode link: https://leetcode.com/problems/longest-palindromic-subsequence/description/\n\"\"\"\n\n\ndef longest_palindromic_subsequence(input_string: str) -> int:\n    \"\"\"\n    This function returns the longest palindromic subsequence in a string\n    >>> longest_palindromic_subsequence(\"bbbab\")\n    4\n    >>> longest_palindromic_subsequence(\"bbabcbcab\")\n    7\n    \"\"\"\n    n = len(input_string)\n    rev = input_string[::-1]\n    m = len(rev)\n    dp = [[-1] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    # create and initialise dp array\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If characters at i and j are the same\n            # include them in the palindromic subsequence\n            if input_string[i - 1] == rev[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][m]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/longest_increasing_subsequence_o_nlogn.py": "#############################\n# Author: Aravind Kashyap\n# File: lis.py\n# comments: This programme outputs the Longest Strictly Increasing Subsequence in\n#           O(NLogN) Where N is the Number of elements in the list\n#############################\nfrom __future__ import annotations\n\n\ndef ceil_index(v, left, right, key):\n    while right - left > 1:\n        middle = (left + right) // 2\n        if v[middle] >= key:\n            right = middle\n        else:\n            left = middle\n    return right\n\n\ndef longest_increasing_subsequence_length(v: list[int]) -> int:\n    \"\"\"\n    >>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])\n    6\n    >>> longest_increasing_subsequence_length([])\n    0\n    >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,\n    ...                                     3, 11, 7, 15])\n    6\n    >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])\n    1\n    \"\"\"\n    if len(v) == 0:\n        return 0\n\n    tail = [0] * len(v)\n    length = 1\n\n    tail[0] = v[0]\n\n    for i in range(1, len(v)):\n        if v[i] < tail[0]:\n            tail[0] = v[i]\n        elif v[i] > tail[length - 1]:\n            tail[length] = v[i]\n            length += 1\n        else:\n            tail[ceil_index(tail, -1, length - 1, v[i])] = v[i]\n\n    return length\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/minimum_squares_to_represent_a_number.py": "import math\nimport sys\n\n\ndef minimum_squares_to_represent_a_number(number: int) -> int:\n    \"\"\"\n    Count the number of minimum squares to represent a number\n    >>> minimum_squares_to_represent_a_number(25)\n    1\n    >>> minimum_squares_to_represent_a_number(37)\n    2\n    >>> minimum_squares_to_represent_a_number(21)\n    3\n    >>> minimum_squares_to_represent_a_number(58)\n    2\n    >>> minimum_squares_to_represent_a_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must not be a negative number\n    >>> minimum_squares_to_represent_a_number(0)\n    1\n    >>> minimum_squares_to_represent_a_number(12.34)\n    Traceback (most recent call last):\n        ...\n    ValueError: the value of input must be a natural number\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"the value of input must be a natural number\")\n    if number < 0:\n        raise ValueError(\"the value of input must not be a negative number\")\n    if number == 0:\n        return 1\n    answers = [-1] * (number + 1)\n    answers[0] = 0\n    for i in range(1, number + 1):\n        answer = sys.maxsize\n        root = int(math.sqrt(i))\n        for j in range(1, root + 1):\n            current_answer = 1 + answers[i - (j**2)]\n            answer = min(answer, current_answer)\n        answers[i] = answer\n    return answers[number]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/smith_waterman.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm\nThe Smith-Waterman algorithm is a dynamic programming algorithm used for sequence\nalignment. It is particularly useful for finding similarities between two sequences,\nsuch as DNA or protein sequences. In this implementation, gaps are penalized\nlinearly, meaning that the score is reduced by a fixed amount for each gap introduced\nin the alignment. However, it's important to note that the Smith-Waterman algorithm\nsupports other gap penalty methods as well.\n\"\"\"\n\n\ndef score_function(\n    source_char: str,\n    target_char: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> int:\n    \"\"\"\n    Calculate the score for a character pair based on whether they match or mismatch.\n    Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the\n    characters is a gap.\n    >>> score_function('A', 'A')\n    1\n    >>> score_function('A', 'C')\n    -1\n    >>> score_function('-', 'A')\n    -2\n    >>> score_function('A', '-')\n    -2\n    >>> score_function('-', '-')\n    -2\n    \"\"\"\n    if \"-\" in (source_char, target_char):\n        return gap\n    return match if source_char == target_char else mismatch\n\n\ndef smith_waterman(\n    query: str,\n    subject: str,\n    match: int = 1,\n    mismatch: int = -1,\n    gap: int = -2,\n) -> list[list[int]]:\n    \"\"\"\n    Perform the Smith-Waterman local sequence alignment algorithm.\n    Returns a 2D list representing the score matrix. Each value in the matrix\n    corresponds to the score of the best local alignment ending at that point.\n    >>> smith_waterman('ACAC', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('acac', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('ACAC', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('acac', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n    >>> smith_waterman('ACAC', '')\n    [[0], [0], [0], [0], [0]]\n    >>> smith_waterman('', 'CA')\n    [[0, 0, 0]]\n    >>> smith_waterman('ACAC', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('acac', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('ACAC', 'ca')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('acac', 'CA')\n    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]\n\n    >>> smith_waterman('ACAC', '')\n    [[0], [0], [0], [0], [0]]\n\n    >>> smith_waterman('', 'CA')\n    [[0, 0, 0]]\n\n    >>> smith_waterman('AGT', 'AGT')\n    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n\n    >>> smith_waterman('AGT', 'GTA')\n    [[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n    >>> smith_waterman('AGT', 'GTC')\n    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]\n\n    >>> smith_waterman('AGT', 'G')\n    [[0, 0], [0, 0], [0, 1], [0, 0]]\n\n    >>> smith_waterman('G', 'AGT')\n    [[0, 0, 0, 0], [0, 0, 1, 0]]\n\n    >>> smith_waterman('AGT', 'AGTCT')\n    [[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]\n\n    >>> smith_waterman('AGTCT', 'AGT')\n    [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]\n\n    >>> smith_waterman('AGTCT', 'GTC')\n    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]\n    \"\"\"\n    # make both query and subject uppercase\n    query = query.upper()\n    subject = subject.upper()\n\n    # Initialize score matrix\n    m = len(query)\n    n = len(subject)\n    score = [[0] * (n + 1) for _ in range(m + 1)]\n    kwargs = {\"match\": match, \"mismatch\": mismatch, \"gap\": gap}\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Calculate scores for each cell\n            match = score[i - 1][j - 1] + score_function(\n                query[i - 1], subject[j - 1], **kwargs\n            )\n            delete = score[i - 1][j] + gap\n            insert = score[i][j - 1] + gap\n\n            # Take maximum score\n            score[i][j] = max(0, match, delete, insert)\n\n    return score\n\n\ndef traceback(score: list[list[int]], query: str, subject: str) -> str:\n    r\"\"\"\n    Perform traceback to find the optimal local alignment.\n    Starts from the highest scoring cell in the matrix and traces back recursively\n    until a 0 score is found. Returns the alignment strings.\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA')\n    'CA\\nCA'\n    >>> traceback([[0, 0, 0]], 'ACAC', '')\n    ''\n    \"\"\"\n    # make both query and subject uppercase\n    query = query.upper()\n    subject = subject.upper()\n    # find the indices of the maximum value in the score matrix\n    max_value = float(\"-inf\")\n    i_max = j_max = 0\n    for i, row in enumerate(score):\n        for j, value in enumerate(row):\n            if value > max_value:\n                max_value = value\n                i_max, j_max = i, j\n    # Traceback logic to find optimal alignment\n    i = i_max\n    j = j_max\n    align1 = \"\"\n    align2 = \"\"\n    gap = score_function(\"-\", \"-\")\n    # guard against empty query or subject\n    if i == 0 or j == 0:\n        return \"\"\n    while i > 0 and j > 0:\n        if score[i][j] == score[i - 1][j - 1] + score_function(\n            query[i - 1], subject[j - 1]\n        ):\n            # optimal path is a diagonal take both letters\n            align1 = query[i - 1] + align1\n            align2 = subject[j - 1] + align2\n            i -= 1\n            j -= 1\n        elif score[i][j] == score[i - 1][j] + gap:\n            # optimal path is a vertical\n            align1 = query[i - 1] + align1\n            align2 = f\"-{align2}\"\n            i -= 1\n        else:\n            # optimal path is a horizontal\n            align1 = f\"-{align1}\"\n            align2 = subject[j - 1] + align2\n            j -= 1\n\n    return f\"{align1}\\n{align2}\"\n\n\nif __name__ == \"__main__\":\n    query = \"HEAGAWGHEE\"\n    subject = \"PAWHEAE\"\n\n    score = smith_waterman(query, subject, match=1, mismatch=-1, gap=-2)\n    print(traceback(score, query, subject))\n", "dynamic_programming/max_non_adjacent_sum.py": "# Video Explanation: https://www.youtube.com/watch?v=6w60Zi1NtL8&feature=emb_logo\n\nfrom __future__ import annotations\n\n\ndef maximum_non_adjacent_sum(nums: list[int]) -> int:\n    \"\"\"\n    Find the maximum non-adjacent sum of the integers in the nums input list\n\n    >>> maximum_non_adjacent_sum([1, 2, 3])\n    4\n    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])\n    18\n    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])\n    0\n    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])\n    500\n    \"\"\"\n    if not nums:\n        return 0\n    max_including = nums[0]\n    max_excluding = 0\n    for num in nums[1:]:\n        max_including, max_excluding = (\n            max_excluding + num,\n            max(max_including, max_excluding),\n        )\n    return max(max_excluding, max_including)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/minimum_steps_to_one.py": "\"\"\"\nYouTube Explanation: https://www.youtube.com/watch?v=f2xi3c1S95M\n\nGiven an integer n, return the minimum steps from n to 1\n\nAVAILABLE STEPS:\n    * Decrement by 1\n    * if n is divisible by 2, divide by 2\n    * if n is divisible by 3, divide by 3\n\n\nExample 1: n = 10\n10 -> 9 -> 3 -> 1\nResult: 3 steps\n\nExample 2: n = 15\n15 -> 5 -> 4 -> 2 -> 1\nResult: 4 steps\n\nExample 3: n = 6\n6 -> 2 -> 1\nResult: 2 step\n\"\"\"\n\nfrom __future__ import annotations\n\n__author__ = \"Alexander Joslin\"\n\n\ndef min_steps_to_one(number: int) -> int:\n    \"\"\"\n    Minimum steps to 1 implemented using tabulation.\n    >>> min_steps_to_one(10)\n    3\n    >>> min_steps_to_one(15)\n    4\n    >>> min_steps_to_one(6)\n    2\n\n    :param number:\n    :return int:\n    \"\"\"\n\n    if number <= 0:\n        msg = f\"n must be greater than 0. Got n = {number}\"\n        raise ValueError(msg)\n\n    table = [number + 1] * (number + 1)\n\n    # starting position\n    table[1] = 0\n    for i in range(1, number):\n        table[i + 1] = min(table[i + 1], table[i] + 1)\n        # check if out of bounds\n        if i * 2 <= number:\n            table[i * 2] = min(table[i * 2], table[i] + 1)\n        # check if out of bounds\n        if i * 3 <= number:\n            table[i * 3] = min(table[i * 3], table[i] + 1)\n    return table[number]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/all_construct.py": "\"\"\"\nProgram to list all the ways a target string can be\nconstructed from the given list of substrings\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef all_construct(target: str, word_bank: list[str] | None = None) -> list[list[str]]:\n    \"\"\"\n        returns the list containing all the possible\n        combinations a string(target) can be constructed from\n        the given list of substrings(word_bank)\n    >>> all_construct(\"hello\", [\"he\", \"l\", \"o\"])\n    [['he', 'l', 'l', 'o']]\n    >>> all_construct(\"purple\",[\"purp\",\"p\",\"ur\",\"le\",\"purpl\"])\n    [['purp', 'le'], ['p', 'ur', 'p', 'le']]\n    \"\"\"\n\n    word_bank = word_bank or []\n    # create a table\n    table_size: int = len(target) + 1\n\n    table: list[list[list[str]]] = []\n    for _ in range(table_size):\n        table.append([])\n    # seed value\n    table[0] = [[]]  # because empty string has empty combination\n\n    # iterate through the indices\n    for i in range(table_size):\n        # condition\n        if table[i] != []:\n            for word in word_bank:\n                # slice condition\n                if target[i : i + len(word)] == word:\n                    new_combinations: list[list[str]] = [\n                        [word, *way] for way in table[i]\n                    ]\n                    # adds the word to every combination the current position holds\n                    # now,push that combination to the table[i+len(word)]\n                    table[i + len(word)] += new_combinations\n\n    # combinations are in reverse order so reverse for better output\n    for combination in table[len(target)]:\n        combination.reverse()\n\n    return table[len(target)]\n\n\nif __name__ == \"__main__\":\n    print(all_construct(\"jwajalapa\", [\"jwa\", \"j\", \"w\", \"a\", \"la\", \"lapa\"]))\n    print(all_construct(\"rajamati\", [\"s\", \"raj\", \"amat\", \"raja\", \"ma\", \"i\", \"t\"]))\n    print(\n        all_construct(\n            \"hexagonosaurus\",\n            [\"h\", \"ex\", \"hex\", \"ag\", \"ago\", \"ru\", \"auru\", \"rus\", \"go\", \"no\", \"o\", \"s\"],\n        )\n    )\n", "dynamic_programming/catalan_numbers.py": "\"\"\"\nPrint all the Catalan numbers from 0 to n, n being the user input.\n\n * The Catalan numbers are a sequence of positive integers that\n * appear in many counting problems in combinatorics [1]. Such\n * problems include counting [2]:\n * - The number of Dyck words of length 2n\n * - The number well-formed expressions with n pairs of parentheses\n *   (e.g., `()()` is valid but `())(` is not)\n * - The number of different ways n + 1 factors can be completely\n *   parenthesized (e.g., for n = 2, C(n) = 2 and (ab)c and a(bc)\n *   are the two valid ways to parenthesize.\n * - The number of full binary trees with n + 1 leaves\n\n * A Catalan number satisfies the following recurrence relation\n * which we will use in this algorithm [1].\n * C(0) = C(1) = 1\n * C(n) = sum(C(i).C(n-i-1)), from i = 0 to n-1\n\n * In addition, the n-th Catalan number can be calculated using\n * the closed form formula below [1]:\n * C(n) = (1 / (n + 1)) * (2n choose n)\n\n * Sources:\n *  [1] https://brilliant.org/wiki/catalan-numbers/\n *  [2] https://en.wikipedia.org/wiki/Catalan_number\n\"\"\"\n\n\ndef catalan_numbers(upper_limit: int) -> \"list[int]\":\n    \"\"\"\n    Return a list of the Catalan number sequence from 0 through `upper_limit`.\n\n    >>> catalan_numbers(5)\n    [1, 1, 2, 5, 14, 42]\n    >>> catalan_numbers(2)\n    [1, 1, 2]\n    >>> catalan_numbers(-1)\n    Traceback (most recent call last):\n    ValueError: Limit for the Catalan sequence must be \u2265 0\n    \"\"\"\n    if upper_limit < 0:\n        raise ValueError(\"Limit for the Catalan sequence must be \u2265 0\")\n\n    catalan_list = [0] * (upper_limit + 1)\n\n    # Base case: C(0) = C(1) = 1\n    catalan_list[0] = 1\n    if upper_limit > 0:\n        catalan_list[1] = 1\n\n    # Recurrence relation: C(i) = sum(C(j).C(i-j-1)), from j = 0 to i\n    for i in range(2, upper_limit + 1):\n        for j in range(i):\n            catalan_list[i] += catalan_list[j] * catalan_list[i - j - 1]\n\n    return catalan_list\n\n\nif __name__ == \"__main__\":\n    print(\"\\n********* Catalan Numbers Using Dynamic Programming ************\\n\")\n    print(\"\\n*** Enter -1 at any time to quit ***\")\n    print(\"\\nEnter the upper limit (\u2265 0) for the Catalan number sequence: \", end=\"\")\n    try:\n        while True:\n            N = int(input().strip())\n            if N < 0:\n                print(\"\\n********* Goodbye!! ************\")\n                break\n            else:\n                print(f\"The Catalan numbers from 0 through {N} are:\")\n                print(catalan_numbers(N))\n                print(\"Try another upper limit for the sequence: \", end=\"\")\n    except (NameError, ValueError):\n        print(\"\\n********* Invalid input, goodbye! ************\\n\")\n\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/min_distance_up_bottom.py": "\"\"\"\nAuthor  : Alexander Pantyukhin\nDate    : October 14, 2022\nThis is an implementation of the up-bottom approach to find edit distance.\nThe implementation was tested on Leetcode: https://leetcode.com/problems/edit-distance/\n\nLevinstein distance\nDynamic Programming: up -> down.\n\"\"\"\n\nimport functools\n\n\ndef min_distance_up_bottom(word1: str, word2: str) -> int:\n    \"\"\"\n    >>> min_distance_up_bottom(\"intention\", \"execution\")\n    5\n    >>> min_distance_up_bottom(\"intention\", \"\")\n    9\n    >>> min_distance_up_bottom(\"\", \"\")\n    0\n    >>> min_distance_up_bottom(\"zooicoarchaeologist\", \"zoologist\")\n    10\n    \"\"\"\n    len_word1 = len(word1)\n    len_word2 = len(word2)\n\n    @functools.cache\n    def min_distance(index1: int, index2: int) -> int:\n        # if first word index overflows - delete all from the second word\n        if index1 >= len_word1:\n            return len_word2 - index2\n        # if second word index overflows - delete all from the first word\n        if index2 >= len_word2:\n            return len_word1 - index1\n        diff = int(word1[index1] != word2[index2])  # current letters not identical\n        return min(\n            1 + min_distance(index1 + 1, index2),\n            1 + min_distance(index1, index2 + 1),\n            diff + min_distance(index1 + 1, index2 + 1),\n        )\n\n    return min_distance(0, 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/longest_common_substring.py": "\"\"\"\nLongest Common Substring Problem Statement: Given two sequences, find the\nlongest common substring present in both of them. A substring is\nnecessarily continuous.\nExample: \"abcdef\" and \"xabded\" have two longest common substrings, \"ab\" or \"de\".\nTherefore, algorithm should return any one of them.\n\"\"\"\n\n\ndef longest_common_substring(text1: str, text2: str) -> str:\n    \"\"\"\n    Finds the longest common substring between two strings.\n    >>> longest_common_substring(\"\", \"\")\n    ''\n    >>> longest_common_substring(\"a\",\"\")\n    ''\n    >>> longest_common_substring(\"\", \"a\")\n    ''\n    >>> longest_common_substring(\"a\", \"a\")\n    'a'\n    >>> longest_common_substring(\"abcdef\", \"bcd\")\n    'bcd'\n    >>> longest_common_substring(\"abcdef\", \"xabded\")\n    'ab'\n    >>> longest_common_substring(\"GeeksforGeeks\", \"GeeksQuiz\")\n    'Geeks'\n    >>> longest_common_substring(\"abcdxyz\", \"xyzabcd\")\n    'abcd'\n    >>> longest_common_substring(\"zxabcdezy\", \"yzabcdezx\")\n    'abcdez'\n    >>> longest_common_substring(\"OldSite:GeeksforGeeks.org\", \"NewSite:GeeksQuiz.com\")\n    'Site:Geeks'\n    >>> longest_common_substring(1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: longest_common_substring() takes two strings for inputs\n    \"\"\"\n\n    if not (isinstance(text1, str) and isinstance(text2, str)):\n        raise ValueError(\"longest_common_substring() takes two strings for inputs\")\n\n    text1_length = len(text1)\n    text2_length = len(text2)\n\n    dp = [[0] * (text2_length + 1) for _ in range(text1_length + 1)]\n    ans_index = 0\n    ans_length = 0\n\n    for i in range(1, text1_length + 1):\n        for j in range(1, text2_length + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n                if dp[i][j] > ans_length:\n                    ans_index = i\n                    ans_length = dp[i][j]\n\n    return text1[ans_index - ans_length : ans_index]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/climbing_stairs.py": "#!/usr/bin/env python3\n\n\ndef climb_stairs(number_of_steps: int) -> int:\n    \"\"\"\n    LeetCdoe No.70: Climbing Stairs\n    Distinct ways to climb a number_of_steps staircase where each time you can either\n    climb 1 or 2 steps.\n\n    Args:\n        number_of_steps: number of steps on the staircase\n\n    Returns:\n        Distinct ways to climb a number_of_steps staircase\n\n    Raises:\n        AssertionError: number_of_steps not positive integer\n\n    >>> climb_stairs(3)\n    3\n    >>> climb_stairs(1)\n    1\n    >>> climb_stairs(-7)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError: number_of_steps needs to be positive integer, your input -7\n    \"\"\"\n    assert (\n        isinstance(number_of_steps, int) and number_of_steps > 0\n    ), f\"number_of_steps needs to be positive integer, your input {number_of_steps}\"\n    if number_of_steps == 1:\n        return 1\n    previous, current = 1, 1\n    for _ in range(number_of_steps - 1):\n        current, previous = current + previous, current\n    return current\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/subset_generation.py": "def subset_combinations(elements: list[int], n: int) -> list:\n    \"\"\"\n    Compute n-element combinations from a given list using dynamic programming.\n    Args:\n        elements: The list of elements from which combinations will be generated.\n        n: The number of elements in each combination.\n    Returns:\n        A list of tuples, each representing a combination of n elements.\n        >>> subset_combinations(elements=[10, 20, 30, 40], n=2)\n        [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]\n        >>> subset_combinations(elements=[1, 2, 3], n=1)\n        [(1,), (2,), (3,)]\n        >>> subset_combinations(elements=[1, 2, 3], n=3)\n        [(1, 2, 3)]\n        >>> subset_combinations(elements=[42], n=1)\n        [(42,)]\n        >>> subset_combinations(elements=[6, 7, 8, 9], n=4)\n        [(6, 7, 8, 9)]\n        >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)\n        [()]\n        >>> subset_combinations(elements=[1, 2, 3, 4], n=2)\n        [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n        >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)\n        [(1, 'apple'), (1, 3.14), ('apple', 3.14)]\n        >>> subset_combinations(elements=['single'], n=0)\n        [()]\n        >>> subset_combinations(elements=[], n=9)\n        []\n        >>> from itertools import combinations\n        >>> all(subset_combinations(items, n) == list(combinations(items, n))\n        ...     for items, n in (\n        ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),\n        ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),\n        ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))\n        True\n    \"\"\"\n    r = len(elements)\n    if n > r:\n        return []\n\n    dp: list[list[tuple]] = [[] for _ in range(r + 1)]\n\n    dp[0].append(())\n\n    for i in range(1, r + 1):\n        for j in range(i, 0, -1):\n            for prev_combination in dp[j - 1]:\n                dp[j].append((*prev_combination, elements[i - 1]))\n\n    try:\n        return sorted(dp[n])\n    except TypeError:\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(f\"{subset_combinations(elements=[10, 20, 30, 40], n=2) = }\")\n", "dynamic_programming/fast_fibonacci.py": "#!/usr/bin/env python3\n\n\"\"\"\nThis program calculates the nth Fibonacci number in O(log(n)).\nIt's possible to calculate F(1_000_000) in less than a second.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\n\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    return F(n)\n    >>> [fibonacci(i) for i in range(13)]\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Negative arguments are not supported\")\n    return _fib(n)[0]\n\n\n# returns (F(n), F(n-1))\ndef _fib(n: int) -> tuple[int, int]:\n    if n == 0:  # (F(0), F(1))\n        return (0, 1)\n\n    # F(2n) = F(n)[2F(n+1) - F(n)]\n    # F(2n+1) = F(n+1)^2+F(n)^2\n    a, b = _fib(n // 2)\n    c = a * (b * 2 - a)\n    d = a * a + b * b\n    return (d, c + d) if n % 2 else (c, d)\n\n\nif __name__ == \"__main__\":\n    n = int(sys.argv[1])\n    print(f\"fibonacci({n}) is {fibonacci(n)}\")\n", "dynamic_programming/knapsack.py": "\"\"\"\nGiven weights and values of n items, put these items in a knapsack of\ncapacity W to get the maximum total value in the knapsack.\n\nNote that only the integer weights 0-1 knapsack problem is solvable\nusing dynamic programming.\n\"\"\"\n\n\ndef mf_knapsack(i, wt, val, j):\n    \"\"\"\n    This code involves the concept of memory functions. Here we solve the subproblems\n    which are needed unlike the below example\n    F is a 2D array with -1s filled up\n    \"\"\"\n    global f  # a global dp table for knapsack\n    if f[i][j] < 0:\n        if j < wt[i - 1]:\n            val = mf_knapsack(i - 1, wt, val, j)\n        else:\n            val = max(\n                mf_knapsack(i - 1, wt, val, j),\n                mf_knapsack(i - 1, wt, val, j - wt[i - 1]) + val[i - 1],\n            )\n        f[i][j] = val\n    return f[i][j]\n\n\ndef knapsack(w, wt, val, n):\n    dp = [[0] * (w + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w_ in range(1, w + 1):\n            if wt[i - 1] <= w_:\n                dp[i][w_] = max(val[i - 1] + dp[i - 1][w_ - wt[i - 1]], dp[i - 1][w_])\n            else:\n                dp[i][w_] = dp[i - 1][w_]\n\n    return dp[n][w_], dp\n\n\ndef knapsack_with_example_solution(w: int, wt: list, val: list):\n    \"\"\"\n    Solves the integer weights knapsack problem returns one of\n    the several possible optimal subsets.\n\n    Parameters\n    ---------\n\n    W: int, the total maximum weight for the given knapsack problem.\n    wt: list, the vector of weights for all items where wt[i] is the weight\n    of the i-th item.\n    val: list, the vector of values for all items where val[i] is the value\n    of the i-th item\n\n    Returns\n    -------\n    optimal_val: float, the optimal value for the given knapsack problem\n    example_optional_set: set, the indices of one of the optimal subsets\n    which gave rise to the optimal value.\n\n    Examples\n    -------\n    >>> knapsack_with_example_solution(10, [1, 3, 5, 2], [10, 20, 100, 22])\n    (142, {2, 3, 4})\n    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4, 4])\n    (8, {3, 4})\n    >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4])\n    Traceback (most recent call last):\n        ...\n    ValueError: The number of weights must be the same as the number of values.\n    But got 4 weights and 3 values\n    \"\"\"\n    if not (isinstance(wt, (list, tuple)) and isinstance(val, (list, tuple))):\n        raise ValueError(\n            \"Both the weights and values vectors must be either lists or tuples\"\n        )\n\n    num_items = len(wt)\n    if num_items != len(val):\n        msg = (\n            \"The number of weights must be the same as the number of values.\\n\"\n            f\"But got {num_items} weights and {len(val)} values\"\n        )\n        raise ValueError(msg)\n    for i in range(num_items):\n        if not isinstance(wt[i], int):\n            msg = (\n                \"All weights must be integers but got weight of \"\n                f\"type {type(wt[i])} at index {i}\"\n            )\n            raise TypeError(msg)\n\n    optimal_val, dp_table = knapsack(w, wt, val, num_items)\n    example_optional_set: set = set()\n    _construct_solution(dp_table, wt, num_items, w, example_optional_set)\n\n    return optimal_val, example_optional_set\n\n\ndef _construct_solution(dp: list, wt: list, i: int, j: int, optimal_set: set):\n    \"\"\"\n    Recursively reconstructs one of the optimal subsets given\n    a filled DP table and the vector of weights\n\n    Parameters\n    ---------\n\n    dp: list of list, the table of a solved integer weight dynamic programming problem\n\n    wt: list or tuple, the vector of weights of the items\n    i: int, the index of the item under consideration\n    j: int, the current possible maximum weight\n    optimal_set: set, the optimal subset so far. This gets modified by the function.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    # for the current item i at a maximum weight j to be part of an optimal subset,\n    # the optimal value at (i, j) must be greater than the optimal value at (i-1, j).\n    # where i - 1 means considering only the previous items at the given maximum weight\n    if i > 0 and j > 0:\n        if dp[i - 1][j] == dp[i][j]:\n            _construct_solution(dp, wt, i - 1, j, optimal_set)\n        else:\n            optimal_set.add(i)\n            _construct_solution(dp, wt, i - 1, j - wt[i - 1], optimal_set)\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Adding test case for knapsack\n    \"\"\"\n    val = [3, 2, 4, 4]\n    wt = [4, 3, 2, 3]\n    n = 4\n    w = 6\n    f = [[0] * (w + 1)] + [[0] + [-1] * (w + 1) for _ in range(n + 1)]\n    optimal_solution, _ = knapsack(w, wt, val, n)\n    print(optimal_solution)\n    print(mf_knapsack(n, wt, val, w))  # switched the n and w\n\n    # testing the dynamic programming problem with example\n    # the optimal subset for the above example are items 3 and 4\n    optimal_solution, optimal_subset = knapsack_with_example_solution(w, wt, val)\n    assert optimal_solution == 8\n    assert optimal_subset == {3, 4}\n    print(\"optimal_value = \", optimal_solution)\n    print(\"An optimal subset corresponding to the optimal value\", optimal_subset)\n", "dynamic_programming/minimum_partition.py": "\"\"\"\nPartition a set into two subsets such that the difference of subset sums is minimum\n\"\"\"\n\n\ndef find_min(numbers: list[int]) -> int:\n    \"\"\"\n    >>> find_min([1, 2, 3, 4, 5])\n    1\n    >>> find_min([5, 5, 5, 5, 5])\n    5\n    >>> find_min([5, 5, 5, 5])\n    0\n    >>> find_min([3])\n    3\n    >>> find_min([])\n    0\n    >>> find_min([1, 2, 3, 4])\n    0\n    >>> find_min([0, 0, 0, 0])\n    0\n    >>> find_min([-1, -5, 5, 1])\n    0\n    >>> find_min([-1, -5, 5, 1])\n    0\n    >>> find_min([9, 9, 9, 9, 9])\n    9\n    >>> find_min([1, 5, 10, 3])\n    1\n    >>> find_min([-1, 0, 1])\n    0\n    >>> find_min(range(10, 0, -1))\n    1\n    >>> find_min([-1])\n    Traceback (most recent call last):\n        --\n    IndexError: list assignment index out of range\n    >>> find_min([0, 0, 0, 1, 2, -4])\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> find_min([-1, -5, -10, -3])\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    \"\"\"\n    n = len(numbers)\n    s = sum(numbers)\n\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, s + 1):\n        dp[0][i] = False\n\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if numbers[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - numbers[i - 1]]\n\n    for j in range(int(s / 2), -1, -1):\n        if dp[n][j] is True:\n            diff = s - 2 * j\n            break\n\n    return diff\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "dynamic_programming/fibonacci.py": "\"\"\"\nThis is a pure Python implementation of Dynamic Programming solution to the fibonacci\nsequence problem.\n\"\"\"\n\n\nclass Fibonacci:\n    def __init__(self) -> None:\n        self.sequence = [0, 1]\n\n    def get(self, index: int) -> list:\n        \"\"\"\n        Get the Fibonacci number of `index`. If the number does not exist,\n        calculate all missing numbers leading up to the number of `index`.\n\n        >>> Fibonacci().get(10)\n        [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n        >>> Fibonacci().get(5)\n        [0, 1, 1, 2, 3]\n        \"\"\"\n        if (difference := index - (len(self.sequence) - 2)) >= 1:\n            for _ in range(difference):\n                self.sequence.append(self.sequence[-1] + self.sequence[-2])\n        return self.sequence[:index]\n\n\ndef main() -> None:\n    print(\n        \"Fibonacci Series Using Dynamic Programming\\n\",\n        \"Enter the index of the Fibonacci number you want to calculate \",\n        \"in the prompt below. (To exit enter exit or Ctrl-C)\\n\",\n        sep=\"\",\n    )\n    fibonacci = Fibonacci()\n\n    while True:\n        prompt: str = input(\">> \")\n        if prompt in {\"exit\", \"quit\"}:\n            break\n\n        try:\n            index: int = int(prompt)\n        except ValueError:\n            print(\"Enter a number or 'exit'\")\n            continue\n\n        print(fibonacci.get(index))\n\n\nif __name__ == \"__main__\":\n    main()\n", "dynamic_programming/viterbi.py": "from typing import Any\n\n\ndef viterbi(\n    observations_space: list,\n    states_space: list,\n    initial_probabilities: dict,\n    transition_probabilities: dict,\n    emission_probabilities: dict,\n) -> list:\n    \"\"\"\n        Viterbi Algorithm, to find the most likely path of\n        states from the start and the expected output.\n        https://en.wikipedia.org/wiki/Viterbi_algorithm\n    sdafads\n        Wikipedia example\n        >>> observations = [\"normal\", \"cold\", \"dizzy\"]\n        >>> states = [\"Healthy\", \"Fever\"]\n        >>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n        >>> trans_p = {\n        ...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n        ...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n        ... }\n        >>> emit_p = {\n        ...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n        ...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n        ... }\n        >>> viterbi(observations, states, start_p, trans_p, emit_p)\n        ['Healthy', 'Healthy', 'Fever']\n\n        >>> viterbi((), states, start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n        >>> viterbi(observations, (), start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n        >>> viterbi(observations, states, {}, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n        >>> viterbi(observations, states, start_p, {}, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n        >>> viterbi(observations, states, start_p, trans_p, {})\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n        >>> viterbi(\"invalid\", states, start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: observations_space must be a list\n\n        >>> viterbi([\"valid\", 123], states, start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: observations_space must be a list of strings\n\n        >>> viterbi(observations, \"invalid\", start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: states_space must be a list\n\n        >>> viterbi(observations, [\"valid\", 123], start_p, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: states_space must be a list of strings\n\n        >>> viterbi(observations, states, \"invalid\", trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: initial_probabilities must be a dict\n\n        >>> viterbi(observations, states, {2:2}, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: initial_probabilities all keys must be strings\n\n        >>> viterbi(observations, states, {\"a\":2}, trans_p, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: initial_probabilities all values must be float\n\n        >>> viterbi(observations, states, start_p, \"invalid\", emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: transition_probabilities must be a dict\n\n        >>> viterbi(observations, states, start_p, {\"a\":2}, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: transition_probabilities all values must be dict\n\n        >>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: transition_probabilities all keys must be strings\n\n        >>> viterbi(observations, states, start_p, {\"a\":{2:2}}, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: transition_probabilities all keys must be strings\n\n        >>> viterbi(observations, states, start_p, {\"a\":{\"b\":2}}, emit_p)\n        Traceback (most recent call last):\n            ...\n        ValueError: transition_probabilities nested dictionary all values must be float\n\n        >>> viterbi(observations, states, start_p, trans_p, \"invalid\")\n        Traceback (most recent call last):\n            ...\n        ValueError: emission_probabilities must be a dict\n\n        >>> viterbi(observations, states, start_p, trans_p, None)\n        Traceback (most recent call last):\n            ...\n        ValueError: There's an empty parameter\n\n    \"\"\"\n    _validation(\n        observations_space,\n        states_space,\n        initial_probabilities,\n        transition_probabilities,\n        emission_probabilities,\n    )\n    # Creates data structures and fill initial step\n    probabilities: dict = {}\n    pointers: dict = {}\n    for state in states_space:\n        observation = observations_space[0]\n        probabilities[(state, observation)] = (\n            initial_probabilities[state] * emission_probabilities[state][observation]\n        )\n        pointers[(state, observation)] = None\n\n    # Fills the data structure with the probabilities of\n    # different transitions and pointers to previous states\n    for o in range(1, len(observations_space)):\n        observation = observations_space[o]\n        prior_observation = observations_space[o - 1]\n        for state in states_space:\n            # Calculates the argmax for probability function\n            arg_max = \"\"\n            max_probability = -1\n            for k_state in states_space:\n                probability = (\n                    probabilities[(k_state, prior_observation)]\n                    * transition_probabilities[k_state][state]\n                    * emission_probabilities[state][observation]\n                )\n                if probability > max_probability:\n                    max_probability = probability\n                    arg_max = k_state\n\n            # Update probabilities and pointers dicts\n            probabilities[(state, observation)] = (\n                probabilities[(arg_max, prior_observation)]\n                * transition_probabilities[arg_max][state]\n                * emission_probabilities[state][observation]\n            )\n\n            pointers[(state, observation)] = arg_max\n\n    # The final observation\n    final_observation = observations_space[len(observations_space) - 1]\n\n    # argmax for given final observation\n    arg_max = \"\"\n    max_probability = -1\n    for k_state in states_space:\n        probability = probabilities[(k_state, final_observation)]\n        if probability > max_probability:\n            max_probability = probability\n            arg_max = k_state\n    last_state = arg_max\n\n    # Process pointers backwards\n    previous = last_state\n    result = []\n    for o in range(len(observations_space) - 1, -1, -1):\n        result.append(previous)\n        previous = pointers[previous, observations_space[o]]\n    result.reverse()\n\n    return result\n\n\ndef _validation(\n    observations_space: Any,\n    states_space: Any,\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> observations = [\"normal\", \"cold\", \"dizzy\"]\n    >>> states = [\"Healthy\", \"Fever\"]\n    >>> start_p = {\"Healthy\": 0.6, \"Fever\": 0.4}\n    >>> trans_p = {\n    ...     \"Healthy\": {\"Healthy\": 0.7, \"Fever\": 0.3},\n    ...     \"Fever\": {\"Healthy\": 0.4, \"Fever\": 0.6},\n    ... }\n    >>> emit_p = {\n    ...     \"Healthy\": {\"normal\": 0.5, \"cold\": 0.4, \"dizzy\": 0.1},\n    ...     \"Fever\": {\"normal\": 0.1, \"cold\": 0.3, \"dizzy\": 0.6},\n    ... }\n    >>> _validation(observations, states, start_p, trans_p, emit_p)\n\n    >>> _validation([], states, start_p, trans_p, emit_p)\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    \"\"\"\n    _validate_not_empty(\n        observations_space,\n        states_space,\n        initial_probabilities,\n        transition_probabilities,\n        emission_probabilities,\n    )\n    _validate_lists(observations_space, states_space)\n    _validate_dicts(\n        initial_probabilities, transition_probabilities, emission_probabilities\n    )\n\n\ndef _validate_not_empty(\n    observations_space: Any,\n    states_space: Any,\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5},\n    ... {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n\n    >>> _validate_not_empty([\"a\"], [\"b\"], {\"c\":0.5}, {}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    >>> _validate_not_empty([\"a\"], [\"b\"], None, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: There's an empty parameter\n    \"\"\"\n    if not all(\n        [\n            observations_space,\n            states_space,\n            initial_probabilities,\n            transition_probabilities,\n            emission_probabilities,\n        ]\n    ):\n        raise ValueError(\"There's an empty parameter\")\n\n\ndef _validate_lists(observations_space: Any, states_space: Any) -> None:\n    \"\"\"\n    >>> _validate_lists([\"a\"], [\"b\"])\n\n    >>> _validate_lists(1234, [\"b\"])\n    Traceback (most recent call last):\n            ...\n    ValueError: observations_space must be a list\n\n    >>> _validate_lists([\"a\"], [3])\n    Traceback (most recent call last):\n            ...\n    ValueError: states_space must be a list of strings\n    \"\"\"\n    _validate_list(observations_space, \"observations_space\")\n    _validate_list(states_space, \"states_space\")\n\n\ndef _validate_list(_object: Any, var_name: str) -> None:\n    \"\"\"\n    >>> _validate_list([\"a\"], \"mock_name\")\n\n    >>> _validate_list(\"a\", \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a list\n    >>> _validate_list([0.5], \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a list of strings\n\n    \"\"\"\n    if not isinstance(_object, list):\n        msg = f\"{var_name} must be a list\"\n        raise ValueError(msg)\n    else:\n        for x in _object:\n            if not isinstance(x, str):\n                msg = f\"{var_name} must be a list of strings\"\n                raise ValueError(msg)\n\n\ndef _validate_dicts(\n    initial_probabilities: Any,\n    transition_probabilities: Any,\n    emission_probabilities: Any,\n) -> None:\n    \"\"\"\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n\n    >>> _validate_dicts(\"invalid\", {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: initial_probabilities must be a dict\n    >>> _validate_dicts({\"c\":0.5}, {2: {\"e\": 0.6}}, {\"f\": {\"g\": 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: transition_probabilities all keys must be strings\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {2: 0.7}})\n    Traceback (most recent call last):\n            ...\n    ValueError: emission_probabilities all keys must be strings\n    >>> _validate_dicts({\"c\":0.5}, {\"d\": {\"e\": 0.6}}, {\"f\": {\"g\": \"h\"}})\n    Traceback (most recent call last):\n            ...\n    ValueError: emission_probabilities nested dictionary all values must be float\n    \"\"\"\n    _validate_dict(initial_probabilities, \"initial_probabilities\", float)\n    _validate_nested_dict(transition_probabilities, \"transition_probabilities\")\n    _validate_nested_dict(emission_probabilities, \"emission_probabilities\")\n\n\ndef _validate_nested_dict(_object: Any, var_name: str) -> None:\n    \"\"\"\n    >>> _validate_nested_dict({\"a\":{\"b\": 0.5}}, \"mock_name\")\n\n    >>> _validate_nested_dict(\"invalid\", \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a dict\n    >>> _validate_nested_dict({\"a\": 8}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all values must be dict\n    >>> _validate_nested_dict({\"a\":{2: 0.5}}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all keys must be strings\n    >>> _validate_nested_dict({\"a\":{\"b\": 4}}, \"mock_name\")\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name nested dictionary all values must be float\n    \"\"\"\n    _validate_dict(_object, var_name, dict)\n    for x in _object.values():\n        _validate_dict(x, var_name, float, True)\n\n\ndef _validate_dict(\n    _object: Any, var_name: str, value_type: type, nested: bool = False\n) -> None:\n    \"\"\"\n    >>> _validate_dict({\"b\": 0.5}, \"mock_name\", float)\n\n    >>> _validate_dict(\"invalid\", \"mock_name\", float)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name must be a dict\n    >>> _validate_dict({\"a\": 8}, \"mock_name\", dict)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all values must be dict\n    >>> _validate_dict({2: 0.5}, \"mock_name\",float, True)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name all keys must be strings\n    >>> _validate_dict({\"b\": 4}, \"mock_name\", float,True)\n    Traceback (most recent call last):\n            ...\n    ValueError: mock_name nested dictionary all values must be float\n    \"\"\"\n    if not isinstance(_object, dict):\n        msg = f\"{var_name} must be a dict\"\n        raise ValueError(msg)\n    if not all(isinstance(x, str) for x in _object):\n        msg = f\"{var_name} all keys must be strings\"\n        raise ValueError(msg)\n    if not all(isinstance(x, value_type) for x in _object.values()):\n        nested_text = \"nested dictionary \" if nested else \"\"\n        msg = f\"{var_name} {nested_text}all values must be {value_type.__name__}\"\n        raise ValueError(msg)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "dynamic_programming/minimum_coin_change.py": "\"\"\"\nYou have m types of coins available in infinite quantities\nwhere the value of each coins is given in the array S=[S0,... Sm-1]\nCan you determine number of ways of making change for n units using\nthe given types of coins?\nhttps://www.hackerrank.com/challenges/coin-change/problem\n\"\"\"\n\n\ndef dp_count(s, n):\n    \"\"\"\n    >>> dp_count([1, 2, 3], 4)\n    4\n    >>> dp_count([1, 2, 3], 7)\n    8\n    >>> dp_count([2, 5, 3, 6], 10)\n    5\n    >>> dp_count([10], 99)\n    0\n    >>> dp_count([4, 5, 6], 0)\n    1\n    >>> dp_count([1, 2, 3], -5)\n    0\n    \"\"\"\n    if n < 0:\n        return 0\n    # table[i] represents the number of ways to get to amount i\n    table = [0] * (n + 1)\n\n    # There is exactly 1 way to get to zero(You pick no coins).\n    table[0] = 1\n\n    # Pick all coins one by one and update table[] values\n    # after the index greater than or equal to the value of the\n    # picked coin\n    for coin_val in s:\n        for j in range(coin_val, n + 1):\n            table[j] += table[j - coin_val]\n\n    return table[n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/combination_sum_iv.py": "\"\"\"\nQuestion:\nYou are given an array of distinct integers and you have to tell how many\ndifferent ways of selecting the elements from the array are there such that\nthe sum of chosen elements is equal to the target number tar.\n\nExample\n\nInput:\nN = 3\ntarget = 5\narray = [1, 2, 5]\n\nOutput:\n9\n\nApproach:\nThe basic idea is to go over recursively to find the way such that the sum\nof chosen elements is \u201ctar\u201d. For every element, we have two choices\n    1. Include the element in our set of chosen elements.\n    2. Don't include the element in our set of chosen elements.\n\"\"\"\n\n\ndef combination_sum_iv(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in exponential Time Complexity.\n\n    >>> combination_sum_iv([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations(target: int) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        return sum(count_of_possible_combinations(target - item) for item in array)\n\n    return count_of_possible_combinations(target)\n\n\ndef combination_sum_iv_dp_array(array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations, and returns the count\n    of possible combination in O(N^2) Time Complexity as we are using Dynamic\n    programming array here.\n\n    >>> combination_sum_iv_dp_array([1,2,5], 5)\n    9\n    \"\"\"\n\n    def count_of_possible_combinations_with_dp_array(\n        target: int, dp_array: list[int]\n    ) -> int:\n        if target < 0:\n            return 0\n        if target == 0:\n            return 1\n        if dp_array[target] != -1:\n            return dp_array[target]\n        answer = sum(\n            count_of_possible_combinations_with_dp_array(target - item, dp_array)\n            for item in array\n        )\n        dp_array[target] = answer\n        return answer\n\n    dp_array = [-1] * (target + 1)\n    return count_of_possible_combinations_with_dp_array(target, dp_array)\n\n\ndef combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:\n    \"\"\"\n    Function checks the all possible combinations with using bottom up approach,\n    and returns the count of possible combination in O(N^2) Time Complexity\n    as we are using Dynamic programming array here.\n\n    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)\n    9\n    \"\"\"\n\n    dp_array = [0] * (target + 1)\n    dp_array[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(n):\n            if i - array[j] >= 0:\n                dp_array[i] += dp_array[i - array[j]]\n\n    return dp_array[target]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    target = 5\n    array = [1, 2, 5]\n    print(combination_sum_iv(array, target))\n", "dynamic_programming/fizz_buzz.py": "# https://en.wikipedia.org/wiki/Fizz_buzz#Programming\n\n\ndef fizz_buzz(number: int, iterations: int) -> str:\n    \"\"\"\n    Plays FizzBuzz.\n    Prints Fizz if number is a multiple of 3.\n    Prints Buzz if its a multiple of 5.\n    Prints FizzBuzz if its a multiple of both 3 and 5 or 15.\n    Else Prints The Number Itself.\n    >>> fizz_buzz(1,7)\n    '1 2 Fizz 4 Buzz Fizz 7 '\n    >>> fizz_buzz(1,0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(-5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(10,-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be done more than 0 times to play FizzBuzz\n    >>> fizz_buzz(1.5,5)\n    Traceback (most recent call last):\n        ...\n    ValueError: starting number must be\n                             and integer and be more than 0\n    >>> fizz_buzz(1,5.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: iterations must be defined as integers\n    \"\"\"\n    if not isinstance(iterations, int):\n        raise ValueError(\"iterations must be defined as integers\")\n    if not isinstance(number, int) or not number >= 1:\n        raise ValueError(\n            \"\"\"starting number must be\n                         and integer and be more than 0\"\"\"\n        )\n    if not iterations >= 1:\n        raise ValueError(\"Iterations must be done more than 0 times to play FizzBuzz\")\n\n    out = \"\"\n    while number <= iterations:\n        if number % 3 == 0:\n            out += \"Fizz\"\n        if number % 5 == 0:\n            out += \"Buzz\"\n        if 0 not in (number % 3, number % 5):\n            out += str(number)\n\n        # print(out)\n        number += 1\n        out += \" \"\n    return out\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/matrix_chain_order.py": "import sys\n\n\"\"\"\nDynamic Programming\nImplementation of Matrix Chain Multiplication\nTime Complexity: O(n^3)\nSpace Complexity: O(n^2)\n\"\"\"\n\n\ndef matrix_chain_order(array):\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n\n            matrix[a][b] = sys.maxsize\n            for c in range(a, b):\n                cost = (\n                    matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                )\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return matrix, sol\n\n\n# Print order of matrix with Ai as Matrix\ndef print_optiomal_solution(optimal_solution, i, j):\n    if i == j:\n        print(\"A\" + str(i), end=\" \")\n    else:\n        print(\"(\", end=\" \")\n        print_optiomal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optiomal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(\")\", end=\" \")\n\n\ndef main():\n    array = [30, 35, 15, 5, 10, 20, 25]\n    n = len(array)\n    # Size of matrix created from above array will be\n    # 30*35 35*15 15*5 5*10 10*20 20*25\n    matrix, optimal_solution = matrix_chain_order(array)\n\n    print(\"No. of Operation required: \" + str(matrix[1][n - 1]))\n    print_optiomal_solution(optimal_solution, 1, n - 1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "dynamic_programming/optimal_binary_search_tree.py": "#!/usr/bin/env python3\n\n# This Python program implements an optimal binary search tree (abbreviated BST)\n# building dynamic programming algorithm that delivers O(n^2) performance.\n#\n# The goal of the optimal BST problem is to build a low-cost BST for a\n# given set of nodes, each with its own key and frequency. The frequency\n# of the node is defined as how many time the node is being searched.\n# The search cost of binary search tree is given by this formula:\n#\n# cost(1, n) = sum{i = 1 to n}((depth(node_i) + 1) * node_i_freq)\n#\n# where n is number of nodes in the BST. The characteristic of low-cost\n# BSTs is having a faster overall search time than other implementations.\n# The reason for their fast search time is that the nodes with high\n# frequencies will be placed near the root of the tree while the nodes\n# with low frequencies will be placed near the leaves of the tree thus\n# reducing search time in the most frequent instances.\nimport sys\nfrom random import randint\n\n\nclass Node:\n    \"\"\"Binary Search Tree Node\"\"\"\n\n    def __init__(self, key, freq):\n        self.key = key\n        self.freq = freq\n\n    def __str__(self):\n        \"\"\"\n        >>> str(Node(1, 2))\n        'Node(key=1, freq=2)'\n        \"\"\"\n        return f\"Node(key={self.key}, freq={self.freq})\"\n\n\ndef print_binary_search_tree(root, key, i, j, parent, is_left):\n    \"\"\"\n    Recursive function to print a BST from a root table.\n\n    >>> key = [3, 8, 9, 10, 17, 21]\n    >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3], \\\n                [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]\n    >>> print_binary_search_tree(root, key, 0, 5, -1, False)\n    8 is the root of the binary search tree.\n    3 is the left child of key 8.\n    10 is the right child of key 8.\n    9 is the left child of key 10.\n    21 is the right child of key 10.\n    17 is the left child of key 21.\n    \"\"\"\n    if i > j or i < 0 or j > len(root) - 1:\n        return\n\n    node = root[i][j]\n    if parent == -1:  # root does not have a parent\n        print(f\"{key[node]} is the root of the binary search tree.\")\n    elif is_left:\n        print(f\"{key[node]} is the left child of key {parent}.\")\n    else:\n        print(f\"{key[node]} is the right child of key {parent}.\")\n\n    print_binary_search_tree(root, key, i, node - 1, key[node], True)\n    print_binary_search_tree(root, key, node + 1, j, key[node], False)\n\n\ndef find_optimal_binary_search_tree(nodes):\n    \"\"\"\n    This function calculates and prints the optimal binary search tree.\n    The dynamic programming algorithm below runs in O(n^2) time.\n    Implemented from CLRS (Introduction to Algorithms) book.\n    https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n\n    >>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50), \\\n                                         Node(42, 3), Node(25, 40), Node(37, 30)])\n    Binary search tree nodes:\n    Node(key=10, freq=34)\n    Node(key=12, freq=8)\n    Node(key=20, freq=50)\n    Node(key=25, freq=40)\n    Node(key=37, freq=30)\n    Node(key=42, freq=3)\n    <BLANKLINE>\n    The cost of optimal BST for given tree nodes is 324.\n    20 is the root of the binary search tree.\n    10 is the left child of key 20.\n    12 is the right child of key 10.\n    25 is the right child of key 20.\n    37 is the right child of key 25.\n    42 is the right child of key 37.\n    \"\"\"\n    # Tree nodes must be sorted first, the code below sorts the keys in\n    # increasing order and rearrange its frequencies accordingly.\n    nodes.sort(key=lambda node: node.key)\n\n    n = len(nodes)\n\n    keys = [nodes[i].key for i in range(n)]\n    freqs = [nodes[i].freq for i in range(n)]\n\n    # This 2D array stores the overall tree cost (which's as minimized as possible);\n    # for a single key, cost is equal to frequency of the key.\n    dp = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\n    # sum[i][j] stores the sum of key frequencies between i and j inclusive in nodes\n    # array\n    total = [[freqs[i] if i == j else 0 for j in range(n)] for i in range(n)]\n    # stores tree roots that will be used later for constructing binary search tree\n    root = [[i if i == j else 0 for j in range(n)] for i in range(n)]\n\n    for interval_length in range(2, n + 1):\n        for i in range(n - interval_length + 1):\n            j = i + interval_length - 1\n\n            dp[i][j] = sys.maxsize  # set the value to \"infinity\"\n            total[i][j] = total[i][j - 1] + freqs[j]\n\n            # Apply Knuth's optimization\n            # Loop without optimization: for r in range(i, j + 1):\n            for r in range(root[i][j - 1], root[i + 1][j] + 1):  # r is a temporal root\n                left = dp[i][r - 1] if r != i else 0  # optimal cost for left subtree\n                right = dp[r + 1][j] if r != j else 0  # optimal cost for right subtree\n                cost = left + total[i][j] + right\n\n                if dp[i][j] > cost:\n                    dp[i][j] = cost\n                    root[i][j] = r\n\n    print(\"Binary search tree nodes:\")\n    for node in nodes:\n        print(node)\n\n    print(f\"\\nThe cost of optimal BST for given tree nodes is {dp[0][n - 1]}.\")\n    print_binary_search_tree(root, keys, 0, n - 1, -1, False)\n\n\ndef main():\n    # A sample binary search tree\n    nodes = [Node(i, randint(1, 50)) for i in range(10, 0, -1)]\n    find_optimal_binary_search_tree(nodes)\n\n\nif __name__ == \"__main__\":\n    main()\n", "dynamic_programming/sum_of_subset.py": "def is_sum_subset(arr: list[int], required_sum: int) -> bool:\n    \"\"\"\n    >>> is_sum_subset([2, 4, 6, 8], 5)\n    False\n    >>> is_sum_subset([2, 4, 6, 8], 14)\n    True\n    \"\"\"\n    # a subset value says 1 if that subset sum can be formed else 0\n    # initially no subsets can be formed hence False/0\n    arr_len = len(arr)\n    subset = [[False] * (required_sum + 1) for _ in range(arr_len + 1)]\n\n    # for each arr value, a sum of zero(0) can be formed by not taking any element\n    # hence True/1\n    for i in range(arr_len + 1):\n        subset[i][0] = True\n\n    # sum is not zero and set is empty then false\n    for i in range(1, required_sum + 1):\n        subset[0][i] = False\n\n    for i in range(1, arr_len + 1):\n        for j in range(1, required_sum + 1):\n            if arr[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            if arr[i - 1] <= j:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]\n\n    return subset[arr_len][required_sum]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/longest_increasing_subsequence.py": "\"\"\"\nAuthor  : Mehdi ALAOUI\n\nThis is a pure Python implementation of Dynamic Programming solution to the longest\nincreasing subsequence of a given sequence.\n\nThe problem is  :\nGiven an array, to find the longest and increasing sub-array in that given array and\nreturn it.\nExample: [10, 22, 9, 33, 21, 50, 41, 60, 80] as input will return\n         [10, 22, 33, 41, 60, 80] as output\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef longest_subsequence(array: list[int]) -> list[int]:  # This function is recursive\n    \"\"\"\n    Some examples\n    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])\n    [10, 22, 33, 41, 60, 80]\n    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])\n    [1, 2, 3, 9]\n    >>> longest_subsequence([9, 8, 7, 6, 5, 7])\n    [8]\n    >>> longest_subsequence([1, 1, 1])\n    [1, 1, 1]\n    >>> longest_subsequence([])\n    []\n    \"\"\"\n    array_length = len(array)\n    # If the array contains only one element, we return it (it's the stop condition of\n    # recursion)\n    if array_length <= 1:\n        return array\n        # Else\n    pivot = array[0]\n    is_found = False\n    i = 1\n    longest_subseq: list[int] = []\n    while not is_found and i < array_length:\n        if array[i] < pivot:\n            is_found = True\n            temp_array = [element for element in array[i:] if element >= array[i]]\n            temp_array = longest_subsequence(temp_array)\n            if len(temp_array) > len(longest_subseq):\n                longest_subseq = temp_array\n        else:\n            i += 1\n\n    temp_array = [element for element in array[1:] if element >= pivot]\n    temp_array = [pivot, *longest_subsequence(temp_array)]\n    if len(temp_array) > len(longest_subseq):\n        return temp_array\n    else:\n        return longest_subseq\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/minimum_cost_path.py": "# Youtube Explanation: https://www.youtube.com/watch?v=lBRtnuxg-gU\n\nfrom __future__ import annotations\n\n\ndef minimum_cost_path(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Find the minimum cost traced by all possible paths from top left to bottom right in\n    a given matrix\n\n    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])\n    6\n\n    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])\n    7\n    \"\"\"\n\n    # preprocessing the first row\n    for i in range(1, len(matrix[0])):\n        matrix[0][i] += matrix[0][i - 1]\n\n    # preprocessing the first column\n    for i in range(1, len(matrix)):\n        matrix[i][0] += matrix[i - 1][0]\n\n    # updating the path cost for current position\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])\n\n    return matrix[-1][-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/__init__.py": "", "dynamic_programming/largest_divisible_subset.py": "from __future__ import annotations\n\n\ndef largest_divisible_subset(items: list[int]) -> list[int]:\n    \"\"\"\n    Algorithm to find the biggest subset in the given array such that for any 2 elements\n    x and y in the subset, either x divides y or y divides x.\n    >>> largest_divisible_subset([1, 16, 7, 8, 4])\n    [16, 8, 4, 1]\n    >>> largest_divisible_subset([1, 2, 3])\n    [2, 1]\n    >>> largest_divisible_subset([-1, -2, -3])\n    [-3]\n    >>> largest_divisible_subset([1, 2, 4, 8])\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset((1, 2, 4, 8))\n    [8, 4, 2, 1]\n    >>> largest_divisible_subset([1, 1, 1])\n    [1, 1, 1]\n    >>> largest_divisible_subset([0, 0, 0])\n    [0, 0, 0]\n    >>> largest_divisible_subset([-1, -1, -1])\n    [-1, -1, -1]\n    >>> largest_divisible_subset([])\n    []\n    \"\"\"\n    # Sort the array in ascending order as the sequence does not matter we only have to\n    # pick up a subset.\n    items = sorted(items)\n\n    number_of_items = len(items)\n\n    # Initialize memo with 1s and hash with increasing numbers\n    memo = [1] * number_of_items\n    hash_array = list(range(number_of_items))\n\n    # Iterate through the array\n    for i, item in enumerate(items):\n        for prev_index in range(i):\n            if ((items[prev_index] != 0 and item % items[prev_index]) == 0) and (\n                (1 + memo[prev_index]) > memo[i]\n            ):\n                memo[i] = 1 + memo[prev_index]\n                hash_array[i] = prev_index\n\n    ans = -1\n    last_index = -1\n\n    # Find the maximum length and its corresponding index\n    for i, memo_item in enumerate(memo):\n        if memo_item > ans:\n            ans = memo_item\n            last_index = i\n\n    # Reconstruct the divisible subset\n    if last_index == -1:\n        return []\n    result = [items[last_index]]\n    while hash_array[last_index] != last_index:\n        last_index = hash_array[last_index]\n        result.append(items[last_index])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n    items = [1, 16, 7, 8, 4]\n    print(\n        f\"The longest divisible subset of {items} is {largest_divisible_subset(items)}.\"\n    )\n", "dynamic_programming/floyd_warshall.py": "import math\n\n\nclass Graph:\n    def __init__(self, n=0):  # a graph with Node 0,1,...,N-1\n        self.n = n\n        self.w = [\n            [math.inf for j in range(n)] for i in range(n)\n        ]  # adjacency matrix for weight\n        self.dp = [\n            [math.inf for j in range(n)] for i in range(n)\n        ]  # dp[i][j] stores minimum distance from i to j\n\n    def add_edge(self, u, v, w):\n        self.dp[u][v] = w\n\n    def floyd_warshall(self):\n        for k in range(self.n):\n            for i in range(self.n):\n                for j in range(self.n):\n                    self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])\n\n    def show_min(self, u, v):\n        return self.dp[u][v]\n\n\nif __name__ == \"__main__\":\n    graph = Graph(5)\n    graph.add_edge(0, 2, 9)\n    graph.add_edge(0, 4, 10)\n    graph.add_edge(1, 3, 5)\n    graph.add_edge(2, 3, 7)\n    graph.add_edge(3, 0, 10)\n    graph.add_edge(3, 1, 2)\n    graph.add_edge(3, 2, 1)\n    graph.add_edge(3, 4, 6)\n    graph.add_edge(4, 1, 3)\n    graph.add_edge(4, 2, 4)\n    graph.add_edge(4, 3, 9)\n    graph.floyd_warshall()\n    graph.show_min(1, 4)\n    graph.show_min(0, 3)\n", "dynamic_programming/longest_common_subsequence.py": "\"\"\"\nLCS Problem Statement: Given two sequences, find the length of longest subsequence\npresent in both of them.  A subsequence is a sequence that appears in the same relative\norder, but not necessarily continuous.\nExample:\"abc\", \"abg\" are subsequences of \"abcdefgh\".\n\"\"\"\n\n\ndef longest_common_subsequence(x: str, y: str):\n    \"\"\"\n    Finds the longest common subsequence between two strings. Also returns the\n    The subsequence found\n\n    Parameters\n    ----------\n\n    x: str, one of the strings\n    y: str, the other string\n\n    Returns\n    -------\n    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)\n    Seq: str, the subsequence found\n\n    >>> longest_common_subsequence(\"programming\", \"gaming\")\n    (6, 'gaming')\n    >>> longest_common_subsequence(\"physics\", \"smartphone\")\n    (2, 'ph')\n    >>> longest_common_subsequence(\"computer\", \"food\")\n    (1, 'o')\n    \"\"\"\n    # find the length of strings\n\n    assert x is not None\n    assert y is not None\n\n    m = len(x)\n    n = len(y)\n\n    # declaring the array for storing the dp values\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            match = 1 if x[i - 1] == y[j - 1] else 0\n\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + match)\n\n    seq = \"\"\n    i, j = m, n\n    while i > 0 and j > 0:\n        match = 1 if x[i - 1] == y[j - 1] else 0\n\n        if dp[i][j] == dp[i - 1][j - 1] + match:\n            if match == 1:\n                seq = x[i - 1] + seq\n            i -= 1\n            j -= 1\n        elif dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return dp[m][n], seq\n\n\nif __name__ == \"__main__\":\n    a = \"AGGTAB\"\n    b = \"GXTXAYB\"\n    expected_ln = 4\n    expected_subseq = \"GTAB\"\n\n    ln, subseq = longest_common_subsequence(a, b)\n    print(\"len =\", ln, \", sub-sequence =\", subseq)\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/edit_distance.py": "\"\"\"\nAuthor  : Turfa Auliarachman\nDate    : October 12, 2016\n\nThis is a pure Python implementation of Dynamic Programming solution to the edit\ndistance problem.\n\nThe problem is :\nGiven two strings A and B. Find the minimum number of operations to string B such that\nA = B. The permitted operations are removal,  insertion, and substitution.\n\"\"\"\n\n\nclass EditDistance:\n    \"\"\"\n    Use :\n    solver              = EditDistance()\n    editDistanceResult  = solver.solve(firstString, secondString)\n    \"\"\"\n\n    def __init__(self):\n        self.word1 = \"\"\n        self.word2 = \"\"\n        self.dp = []\n\n    def __min_dist_top_down_dp(self, m: int, n: int) -> int:\n        if m == -1:\n            return n + 1\n        elif n == -1:\n            return m + 1\n        elif self.dp[m][n] > -1:\n            return self.dp[m][n]\n        else:\n            if self.word1[m] == self.word2[n]:\n                self.dp[m][n] = self.__min_dist_top_down_dp(m - 1, n - 1)\n            else:\n                insert = self.__min_dist_top_down_dp(m, n - 1)\n                delete = self.__min_dist_top_down_dp(m - 1, n)\n                replace = self.__min_dist_top_down_dp(m - 1, n - 1)\n                self.dp[m][n] = 1 + min(insert, delete, replace)\n\n            return self.dp[m][n]\n\n    def min_dist_top_down(self, word1: str, word2: str) -> int:\n        \"\"\"\n        >>> EditDistance().min_dist_top_down(\"intention\", \"execution\")\n        5\n        >>> EditDistance().min_dist_top_down(\"intention\", \"\")\n        9\n        >>> EditDistance().min_dist_top_down(\"\", \"\")\n        0\n        \"\"\"\n        self.word1 = word1\n        self.word2 = word2\n        self.dp = [[-1 for _ in range(len(word2))] for _ in range(len(word1))]\n\n        return self.__min_dist_top_down_dp(len(word1) - 1, len(word2) - 1)\n\n    def min_dist_bottom_up(self, word1: str, word2: str) -> int:\n        \"\"\"\n        >>> EditDistance().min_dist_bottom_up(\"intention\", \"execution\")\n        5\n        >>> EditDistance().min_dist_bottom_up(\"intention\", \"\")\n        9\n        >>> EditDistance().min_dist_bottom_up(\"\", \"\")\n        0\n        \"\"\"\n        self.word1 = word1\n        self.word2 = word2\n        m = len(word1)\n        n = len(word2)\n        self.dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:  # first string is empty\n                    self.dp[i][j] = j\n                elif j == 0:  # second string is empty\n                    self.dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:  # last characters are equal\n                    self.dp[i][j] = self.dp[i - 1][j - 1]\n                else:\n                    insert = self.dp[i][j - 1]\n                    delete = self.dp[i - 1][j]\n                    replace = self.dp[i - 1][j - 1]\n                    self.dp[i][j] = 1 + min(insert, delete, replace)\n        return self.dp[m][n]\n\n\nif __name__ == \"__main__\":\n    solver = EditDistance()\n\n    print(\"****************** Testing Edit Distance DP Algorithm ******************\")\n    print()\n\n    S1 = input(\"Enter the first string: \").strip()\n    S2 = input(\"Enter the second string: \").strip()\n\n    print()\n    print(f\"The minimum edit distance is: {solver.min_dist_top_down(S1, S2)}\")\n    print(f\"The minimum edit distance is: {solver.min_dist_bottom_up(S1, S2)}\")\n    print()\n    print(\"*************** End of Testing Edit Distance DP Algorithm ***************\")\n", "dynamic_programming/max_subarray_sum.py": "\"\"\"\nThe maximum subarray sum problem is the task of finding the maximum sum that can be\nobtained from a contiguous subarray within a given array of numbers. For example, given\nthe array [-2, 1, -3, 4, -1, 2, 1, -5, 4], the contiguous subarray with the maximum sum\nis [4, -1, 2, 1], so the maximum subarray sum is 6.\n\nKadane's algorithm is a simple dynamic programming algorithm that solves the maximum\nsubarray sum problem in O(n) time and O(1) space.\n\nReference: https://en.wikipedia.org/wiki/Maximum_subarray_problem\n\"\"\"\n\nfrom collections.abc import Sequence\n\n\ndef max_subarray_sum(\n    arr: Sequence[float], allow_empty_subarrays: bool = False\n) -> float:\n    \"\"\"\n    Solves the maximum subarray sum problem using Kadane's algorithm.\n    :param arr: the given array of numbers\n    :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays\n\n    >>> max_subarray_sum([2, 8, 9])\n    19\n    >>> max_subarray_sum([0, 0])\n    0\n    >>> max_subarray_sum([-1.0, 0.0, 1.0])\n    1.0\n    >>> max_subarray_sum([1, 2, 3, 4, -2])\n    10\n    >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\n    6\n    >>> max_subarray_sum([2, 3, -9, 8, -2])\n    8\n    >>> max_subarray_sum([-2, -3, -1, -4, -6])\n    -1\n    >>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)\n    0\n    >>> max_subarray_sum([])\n    0\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_sum = 0 if allow_empty_subarrays else float(\"-inf\")\n    curr_sum = 0.0\n    for num in arr:\n        curr_sum = max(0 if allow_empty_subarrays else num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    print(f\"{max_subarray_sum(nums) = }\")\n", "dynamic_programming/factorial.py": "# Factorial of a number using memoization\n\nfrom functools import lru_cache\n\n\n@lru_cache\ndef factorial(num: int) -> int:\n    \"\"\"\n    >>> factorial(7)\n    5040\n    >>> factorial(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Number should not be negative.\n    >>> [factorial(i) for i in range(10)]\n    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"Number should not be negative.\")\n\n    return 1 if num in (0, 1) else num * factorial(num - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "dynamic_programming/integer_partition.py": "\"\"\"\nThe number of partitions of a number n into at least k parts equals the number of\npartitions into exactly k parts plus the number of partitions into at least k-1 parts.\nSubtracting 1 from each part of a partition of n into k parts gives a partition of n-k\ninto k parts. These two facts together are used for this algorithm.\n* https://en.wikipedia.org/wiki/Partition_(number_theory)\n* https://en.wikipedia.org/wiki/Partition_function_(number_theory)\n\"\"\"\n\n\ndef partition(m: int) -> int:\n    \"\"\"\n    >>> partition(5)\n    7\n    >>> partition(7)\n    15\n    >>> partition(100)\n    190569292\n    >>> partition(1_000)\n    24061467864032622473692149727991\n    >>> partition(-7)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> partition(0)\n    Traceback (most recent call last):\n        ...\n    IndexError: list assignment index out of range\n    >>> partition(7.8)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    memo: list[list[int]] = [[0 for _ in range(m)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        memo[i][0] = 1\n\n    for n in range(m + 1):\n        for k in range(1, m):\n            memo[n][k] += memo[n][k - 1]\n            if n - k > 0:\n                memo[n][k] += memo[n - k - 1][k]\n\n    return memo[m][m - 1]\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    if len(sys.argv) == 1:\n        try:\n            n = int(input(\"Enter a number: \").strip())\n            print(partition(n))\n        except ValueError:\n            print(\"Please enter a number.\")\n    else:\n        try:\n            n = int(sys.argv[1])\n            print(partition(n))\n        except ValueError:\n            print(\"Please pass a number.\")\n", "sorts/exchange_sort.py": "def exchange_sort(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Uses exchange sort to sort a list of numbers.\n    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n    >>> exchange_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([-1, -2, -3])\n    [-3, -2, -1]\n    >>> exchange_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> exchange_sort([0, 10, -2, 5, 3])\n    [-2, 0, 3, 5, 10]\n    >>> exchange_sort([])\n    []\n    \"\"\"\n    numbers_length = len(numbers)\n    for i in range(numbers_length):\n        for j in range(i + 1, numbers_length):\n            if numbers[j] < numbers[i]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    return numbers\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(exchange_sort(unsorted))\n", "sorts/wiggle_sort.py": "\"\"\"\nWiggle Sort.\n\nGiven an unsorted array nums, reorder it such\nthat nums[0] < nums[1] > nums[2] < nums[3]....\nFor example:\nif input numbers = [3, 5, 2, 1, 6, 4]\none possible Wiggle Sorted answer is [3, 5, 1, 6, 2, 4].\n\"\"\"\n\n\ndef wiggle_sort(nums: list) -> list:\n    \"\"\"\n    Python implementation of wiggle.\n    Example:\n    >>> wiggle_sort([0, 5, 3, 2, 2])\n    [0, 5, 2, 3, 2]\n    >>> wiggle_sort([])\n    []\n    >>> wiggle_sort([-2, -5, -45])\n    [-45, -2, -5]\n    >>> wiggle_sort([-2.1, -5.68, -45.11])\n    [-45.11, -2.1, -5.68]\n    \"\"\"\n    for i, _ in enumerate(nums):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n    return nums\n\n\nif __name__ == \"__main__\":\n    print(\"Enter the array elements:\")\n    array = list(map(int, input().split()))\n    print(\"The unsorted array is:\")\n    print(array)\n    print(\"Array after Wiggle sort:\")\n    print(wiggle_sort(array))\n", "sorts/strand_sort.py": "import operator\n\n\ndef strand_sort(arr: list, reverse: bool = False, solution: list | None = None) -> list:\n    \"\"\"\n    Strand sort implementation\n    source: https://en.wikipedia.org/wiki/Strand_sort\n\n    :param arr: Unordered input list\n    :param reverse: Descent ordering flag\n    :param solution: Ordered items container\n\n    Examples:\n    >>> strand_sort([4, 2, 5, 3, 0, 1])\n    [0, 1, 2, 3, 4, 5]\n\n    >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)\n    [5, 4, 3, 2, 1, 0]\n    \"\"\"\n    _operator = operator.lt if reverse else operator.gt\n    solution = solution or []\n\n    if not arr:\n        return solution\n\n    sublist = [arr.pop(0)]\n    for i, item in enumerate(arr):\n        if _operator(item, sublist[-1]):\n            sublist.append(item)\n            arr.pop(i)\n\n    #  merging sublist into solution list\n    if not solution:\n        solution.extend(sublist)\n    else:\n        while sublist:\n            item = sublist.pop(0)\n            for i, xx in enumerate(solution):\n                if not _operator(item, xx):\n                    solution.insert(i, item)\n                    break\n            else:\n                solution.append(item)\n\n    strand_sort(arr, reverse, solution)\n    return solution\n\n\nif __name__ == \"__main__\":\n    assert strand_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]\n    assert strand_sort([4, 3, 5, 1, 2], reverse=True) == [5, 4, 3, 2, 1]\n", "sorts/msd_radix_sort.py": "\"\"\"\nPython implementation of the MSD radix sort algorithm.\nIt used the binary representation of the integers to sort\nthem.\nhttps://en.wikipedia.org/wiki/Radix_sort\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef msd_radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of the MSD radix sort algorithm. Only works\n    with positive integers\n    :param list_of_ints: A list of integers\n    :return: Returns the sorted list\n    >>> msd_radix_sort([40, 12, 1, 100, 4])\n    [1, 4, 12, 40, 100]\n    >>> msd_radix_sort([])\n    []\n    >>> msd_radix_sort([123, 345, 123, 80])\n    [80, 123, 123, 345]\n    >>> msd_radix_sort([1209, 834598, 1, 540402, 45])\n    [1, 45, 1209, 540402, 834598]\n    >>> msd_radix_sort([-1, 34, 45])\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n    if not list_of_ints:\n        return []\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    return _msd_radix_sort(list_of_ints, most_bits)\n\n\ndef _msd_radix_sort(list_of_ints: list[int], bit_position: int) -> list[int]:\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    :param list_of_ints: A list of integers\n    :param bit_position: the position of the bit that gets compared\n    :return: Returns a partially sorted list\n    >>> _msd_radix_sort([45, 2, 32], 1)\n    [2, 32, 45]\n    >>> _msd_radix_sort([10, 4, 12], 2)\n    [4, 12, 10]\n    \"\"\"\n    if bit_position == 0 or len(list_of_ints) in [0, 1]:\n        return list_of_ints\n\n    zeros = []\n    ones = []\n    # Split numbers based on bit at bit_position from the right\n    for number in list_of_ints:\n        if (number >> (bit_position - 1)) & 1:\n            # number has a one at bit bit_position\n            ones.append(number)\n        else:\n            # number has a zero at bit bit_position\n            zeros.append(number)\n\n    # recursively split both lists further\n    zeros = _msd_radix_sort(zeros, bit_position - 1)\n    ones = _msd_radix_sort(ones, bit_position - 1)\n\n    # recombine lists\n    res = zeros\n    res.extend(ones)\n\n    return res\n\n\ndef msd_radix_sort_inplace(list_of_ints: list[int]):\n    \"\"\"\n    Inplace implementation of the MSD radix sort algorithm.\n    Sorts based on the binary representation of the integers.\n    >>> lst = [1, 345, 23, 89, 0, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = [1, 43, 0, 0, 0, 24, 3, 3]\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == sorted(lst)\n    True\n    >>> lst = []\n    >>> msd_radix_sort_inplace(lst)\n    >>> lst == []\n    True\n    >>> lst = [-1, 34, 23, 4, -42]\n    >>> msd_radix_sort_inplace(lst)\n    Traceback (most recent call last):\n        ...\n    ValueError: All numbers must be positive\n    \"\"\"\n\n    length = len(list_of_ints)\n    if not list_of_ints or length == 1:\n        return\n\n    if min(list_of_ints) < 0:\n        raise ValueError(\"All numbers must be positive\")\n\n    most_bits = max(len(bin(x)[2:]) for x in list_of_ints)\n    _msd_radix_sort_inplace(list_of_ints, most_bits, 0, length)\n\n\ndef _msd_radix_sort_inplace(\n    list_of_ints: list[int], bit_position: int, begin_index: int, end_index: int\n):\n    \"\"\"\n    Sort the given list based on the bit at bit_position. Numbers with a\n    0 at that position will be at the start of the list, numbers with a\n    1 at the end.\n    >>> lst = [45, 2, 32, 24, 534, 2932]\n    >>> _msd_radix_sort_inplace(lst, 1, 0, 3)\n    >>> lst == [32, 2, 45, 24, 534, 2932]\n    True\n    >>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756]\n    >>> _msd_radix_sort_inplace(lst, 2, 4, 7)\n    >>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756]\n    True\n    \"\"\"\n    if bit_position == 0 or end_index - begin_index <= 1:\n        return\n\n    bit_position -= 1\n\n    i = begin_index\n    j = end_index - 1\n    while i <= j:\n        changed = False\n        if not (list_of_ints[i] >> bit_position) & 1:\n            # found zero at the beginning\n            i += 1\n            changed = True\n        if (list_of_ints[j] >> bit_position) & 1:\n            # found one at the end\n            j -= 1\n            changed = True\n\n        if changed:\n            continue\n\n        list_of_ints[i], list_of_ints[j] = list_of_ints[j], list_of_ints[i]\n        j -= 1\n        if j != i:\n            i += 1\n\n    _msd_radix_sort_inplace(list_of_ints, bit_position, begin_index, i)\n    _msd_radix_sort_inplace(list_of_ints, bit_position, i, end_index)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/cycle_sort.py": "\"\"\"\nCode contributed by Honey Sharma\nSource: https://en.wikipedia.org/wiki/Cycle_sort\n\"\"\"\n\n\ndef cycle_sort(array: list) -> list:\n    \"\"\"\n    >>> cycle_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n\n    >>> cycle_sort([-4, 20, 0, -50, 100, -1])\n    [-50, -4, -1, 0, 20, 100]\n\n    >>> cycle_sort([-.1, -.2, 1.3, -.8])\n    [-0.8, -0.2, -0.1, 1.3]\n\n    >>> cycle_sort([])\n    []\n    \"\"\"\n    array_len = len(array)\n    for cycle_start in range(array_len - 1):\n        item = array[cycle_start]\n\n        pos = cycle_start\n        for i in range(cycle_start + 1, array_len):\n            if array[i] < item:\n                pos += 1\n\n        if pos == cycle_start:\n            continue\n\n        while item == array[pos]:\n            pos += 1\n\n        array[pos], item = item, array[pos]\n        while pos != cycle_start:\n            pos = cycle_start\n            for i in range(cycle_start + 1, array_len):\n                if array[i] < item:\n                    pos += 1\n\n            while item == array[pos]:\n                pos += 1\n\n            array[pos], item = item, array[pos]\n\n    return array\n\n\nif __name__ == \"__main__\":\n    assert cycle_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert cycle_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]\n", "sorts/recursive_insertion_sort.py": "\"\"\"\nA recursive implementation of the insertion sort algorithm\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef rec_insertion_sort(collection: list, n: int):\n    \"\"\"\n    Given a collection of numbers and its length, sorts the collections\n    in ascending order\n\n    :param collection: A mutable collection of comparable elements\n    :param n: The length of collections\n\n    >>> col = [1, 2, 1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1, 1, 2]\n\n    >>> col = [2, 1, 0, -1, -2]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [-2, -1, 0, 1, 2]\n\n    >>> col = [1]\n    >>> rec_insertion_sort(col, len(col))\n    >>> col\n    [1]\n    \"\"\"\n    # Checks if the entire collection has been sorted\n    if len(collection) <= 1 or n <= 1:\n        return\n\n    insert_next(collection, n - 1)\n    rec_insertion_sort(collection, n - 1)\n\n\ndef insert_next(collection: list, index: int):\n    \"\"\"\n    Inserts the '(index-1)th' element into place\n\n    >>> col = [3, 2, 4, 2]\n    >>> insert_next(col, 1)\n    >>> col\n    [2, 3, 4, 2]\n\n    >>> col = [3, 2, 3]\n    >>> insert_next(col, 2)\n    >>> col\n    [3, 2, 3]\n\n    >>> col = []\n    >>> insert_next(col, 1)\n    >>> col\n    []\n    \"\"\"\n    # Checks order between adjacent elements\n    if index >= len(collection) or collection[index - 1] <= collection[index]:\n        return\n\n    # Swaps adjacent elements since they are not in ascending order\n    collection[index - 1], collection[index] = (\n        collection[index],\n        collection[index - 1],\n    )\n\n    insert_next(collection, index + 1)\n\n\nif __name__ == \"__main__\":\n    numbers = input(\"Enter integers separated by spaces: \")\n    number_list: list[int] = [int(num) for num in numbers.split()]\n    rec_insertion_sort(number_list, len(number_list))\n    print(number_list)\n", "sorts/gnome_sort.py": "\"\"\"\nGnome Sort Algorithm (A.K.A. Stupid Sort)\n\nThis algorithm iterates over a list comparing an element with the previous one.\nIf order is not respected, it swaps element backward until order is respected with\nprevious element.  It resumes the initial iteration from element new position.\n\nFor doctests run following command:\npython3 -m doctest -v gnome_sort.py\n\nFor manual testing run:\npython3 gnome_sort.py\n\"\"\"\n\n\ndef gnome_sort(lst: list) -> list:\n    \"\"\"\n    Pure implementation of the gnome sort algorithm in Python\n\n    Take some mutable ordered collection with heterogeneous comparable items inside as\n    arguments, return the same collection ordered by ascending.\n\n    Examples:\n    >>> gnome_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> gnome_sort([])\n    []\n\n    >>> gnome_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    >>> \"\".join(gnome_sort(list(set(\"Gnomes are stupid!\"))))\n    ' !Gadeimnoprstu'\n    \"\"\"\n    if len(lst) <= 1:\n        return lst\n\n    i = 1\n\n    while i < len(lst):\n        if lst[i - 1] <= lst[i]:\n            i += 1\n        else:\n            lst[i - 1], lst[i] = lst[i], lst[i - 1]\n            i -= 1\n            if i == 0:\n                i = 1\n\n    return lst\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(gnome_sort(unsorted))\n", "sorts/topological_sort.py": "\"\"\"Topological Sort.\"\"\"\n\n#     a\n#    / \\\n#   b  c\n#  / \\\n# d  e\nedges: dict[str, list[str]] = {\n    \"a\": [\"c\", \"b\"],\n    \"b\": [\"d\", \"e\"],\n    \"c\": [],\n    \"d\": [],\n    \"e\": [],\n}\nvertices: list[str] = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n\n\ndef topological_sort(start: str, visited: list[str], sort: list[str]) -> list[str]:\n    \"\"\"Perform topological sort on a directed acyclic graph.\"\"\"\n    current = start\n    # add current to visited\n    visited.append(current)\n    neighbors = edges[current]\n    for neighbor in neighbors:\n        # if neighbor not in visited, visit\n        if neighbor not in visited:\n            sort = topological_sort(neighbor, visited, sort)\n    # if all neighbors visited add current to sort\n    sort.append(current)\n    # if all vertices haven't been visited select a new one to visit\n    if len(visited) != len(vertices):\n        for vertice in vertices:\n            if vertice not in visited:\n                sort = topological_sort(vertice, visited, sort)\n    # return sort\n    return sort\n\n\nif __name__ == \"__main__\":\n    sort = topological_sort(\"a\", [], [])\n    print(sort)\n", "sorts/natural_sort.py": "from __future__ import annotations\n\nimport re\n\n\ndef natural_sort(input_list: list[str]) -> list[str]:\n    \"\"\"\n    Sort the given list of strings in the way that humans expect.\n\n    The normal Python sort algorithm sorts lexicographically,\n    so you might not get the results that you expect...\n\n    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']\n    >>> sorted(example1)\n    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']\n    >>> # The natural sort algorithm sort based on meaning and not computer code point.\n    >>> natural_sort(example1)\n    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']\n\n    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> sorted(example2)\n    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']\n    >>> natural_sort(example2)\n    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']\n    \"\"\"\n\n    def alphanum_key(key):\n        return [int(s) if s.isdigit() else s.lower() for s in re.split(\"([0-9]+)\", key)]\n\n    return sorted(input_list, key=alphanum_key)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/radix_sort.py": "\"\"\"\nThis is a pure Python implementation of the radix sort algorithm\n\nSource: https://en.wikipedia.org/wiki/Radix_sort\n\"\"\"\n\nfrom __future__ import annotations\n\nRADIX = 10\n\n\ndef radix_sort(list_of_ints: list[int]) -> list[int]:\n    \"\"\"\n    Examples:\n    >>> radix_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> radix_sort(list(range(15))) == sorted(range(15))\n    True\n    >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))\n    True\n    >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])\n    True\n    \"\"\"\n    placement = 1\n    max_digit = max(list_of_ints)\n    while placement <= max_digit:\n        # declare and initialize empty buckets\n        buckets: list[list] = [[] for _ in range(RADIX)]\n        # split list_of_ints between the buckets\n        for i in list_of_ints:\n            tmp = int((i / placement) % RADIX)\n            buckets[tmp].append(i)\n        # put each buckets' contents into list_of_ints\n        a = 0\n        for b in range(RADIX):\n            for i in buckets[b]:\n                list_of_ints[a] = i\n                a += 1\n        # move to next\n        placement *= RADIX\n    return list_of_ints\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/comb_sort.py": "\"\"\"\nThis is pure Python implementation of comb sort algorithm.\nComb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz\nDobosiewicz in 1980.  It was rediscovered by Stephen Lacey and Richard Box in 1991.\nComb sort improves on bubble sort algorithm.\nIn bubble sort, distance (or gap) between two compared elements is always one.\nComb sort improvement is that gap can be much more than 1, in order to prevent slowing\ndown by small values\nat the end of a list.\n\nMore info on: https://en.wikipedia.org/wiki/Comb_sort\n\nFor doctests run following command:\npython -m doctest -v comb_sort.py\nor\npython3 -m doctest -v comb_sort.py\n\nFor manual testing run:\npython comb_sort.py\n\"\"\"\n\n\ndef comb_sort(data: list) -> list:\n    \"\"\"Pure implementation of comb sort algorithm in Python\n    :param data: mutable collection with comparable items\n    :return: the same collection in ascending order\n    Examples:\n    >>> comb_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> comb_sort([])\n    []\n    >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])\n    [-15, -7, 0, 2, 3, 8, 45, 99]\n    \"\"\"\n    shrink_factor = 1.3\n    gap = len(data)\n    completed = False\n\n    while not completed:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            completed = True\n\n        index = 0\n        while index + gap < len(data):\n            if data[index] > data[index + gap]:\n                # Swap values\n                data[index], data[index + gap] = data[index + gap], data[index]\n                completed = False\n            index += 1\n\n    return data\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(comb_sort(unsorted))\n", "sorts/selection_sort.py": "def selection_sort(collection: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list in ascending order using the selection sort algorithm.\n\n    :param collection: A list of integers to be sorted.\n    :return: The sorted list.\n\n    Examples:\n    >>> selection_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> selection_sort([])\n    []\n\n    >>> selection_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    length = len(collection)\n    for i in range(length - 1):\n        min_index = i\n        for k in range(i + 1, length):\n            if collection[k] < collection[min_index]:\n                min_index = k\n        if min_index != i:\n            collection[i], collection[min_index] = collection[min_index], collection[i]\n    return collection\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    sorted_list = selection_sort(unsorted)\n    print(\"Sorted List:\", sorted_list)\n", "sorts/merge_insertion_sort.py": "\"\"\"\nThis is a pure Python implementation of the merge-insertion sort algorithm\nSource: https://en.wikipedia.org/wiki/Merge-insertion_sort\n\nFor doctests run following command:\npython3 -m doctest -v merge_insertion_sort.py\nor\npython -m doctest -v merge_insertion_sort.py\n\nFor manual testing run:\npython3 merge_insertion_sort.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef binary_search_insertion(sorted_list, item):\n    \"\"\"\n    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)\n    [1, 2, 4, 7, 9, 10]\n    \"\"\"\n    left = 0\n    right = len(sorted_list) - 1\n    while left <= right:\n        middle = (left + right) // 2\n        if left == right:\n            if sorted_list[middle] < item:\n                left = middle + 1\n            break\n        elif sorted_list[middle] < item:\n            left = middle + 1\n        else:\n            right = middle - 1\n    sorted_list.insert(left, item)\n    return sorted_list\n\n\ndef merge(left, right):\n    \"\"\"\n    >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    result = []\n    while left and right:\n        if left[0][0] < right[0][0]:\n            result.append(left.pop(0))\n        else:\n            result.append(right.pop(0))\n    return result + left + right\n\n\ndef sortlist_2d(list_2d):\n    \"\"\"\n    >>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]])\n    [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]\n    \"\"\"\n    length = len(list_2d)\n    if length <= 1:\n        return list_2d\n    middle = length // 2\n    return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))\n\n\ndef merge_insertion_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of merge-insertion sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> merge_insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_insertion_sort([99])\n    [99]\n\n    >>> merge_insertion_sort([-2, -5, -45])\n    [-45, -5, -2]\n\n    Testing with all permutations on range(0,5):\n    >>> import itertools\n    >>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))\n    >>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)\n    True\n    \"\"\"\n\n    if len(collection) <= 1:\n        return collection\n\n    \"\"\"\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    \"\"\"\n    two_paired_list = []\n    has_last_odd_item = False\n    for i in range(0, len(collection), 2):\n        if i == len(collection) - 1:\n            has_last_odd_item = True\n        else:\n            \"\"\"\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            \"\"\"\n            if collection[i] < collection[i + 1]:\n                two_paired_list.append([collection[i], collection[i + 1]])\n            else:\n                two_paired_list.append([collection[i + 1], collection[i]])\n\n    \"\"\"\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    \"\"\"\n    sorted_list_2d = sortlist_2d(two_paired_list)\n\n    \"\"\"\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    \"\"\"\n    result = [i[0] for i in sorted_list_2d]\n\n    \"\"\"\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    \"\"\"\n    result.append(sorted_list_2d[-1][1])\n\n    \"\"\"\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    \"\"\"\n    if has_last_odd_item:\n        pivot = collection[-1]\n        result = binary_search_insertion(result, pivot)\n\n    \"\"\"\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    \"\"\"\n    is_last_odd_item_inserted_before_this_index = False\n    for i in range(len(sorted_list_2d) - 1):\n        if result[i] == collection[-1] and has_last_odd_item:\n            is_last_odd_item_inserted_before_this_index = True\n        pivot = sorted_list_2d[i][1]\n        # If last_odd_item is inserted before the item's index,\n        # you should forward index one more.\n        if is_last_odd_item_inserted_before_this_index:\n            result = result[: i + 2] + binary_search_insertion(result[i + 2 :], pivot)\n        else:\n            result = result[: i + 1] + binary_search_insertion(result[i + 1 :], pivot)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(merge_insertion_sort(unsorted))\n", "sorts/quick_sort_3_partition.py": "def quick_sort_3partition(sorting: list, left: int, right: int) -> None:\n    if right <= left:\n        return\n    a = i = left\n    b = right\n    pivot = sorting[left]\n    while i <= b:\n        if sorting[i] < pivot:\n            sorting[a], sorting[i] = sorting[i], sorting[a]\n            a += 1\n            i += 1\n        elif sorting[i] > pivot:\n            sorting[b], sorting[i] = sorting[i], sorting[b]\n            b -= 1\n        else:\n            i += 1\n    quick_sort_3partition(sorting, left, a - 1)\n    quick_sort_3partition(sorting, b + 1, right)\n\n\ndef quick_sort_lomuto_partition(sorting: list, left: int, right: int) -> None:\n    \"\"\"\n    A pure Python implementation of quick sort algorithm(in-place)\n    with Lomuto partition scheme:\n    https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme\n\n    :param sorting: sort list\n    :param left: left endpoint of sorting\n    :param right: right endpoint of sorting\n    :return: None\n\n    Examples:\n    >>> nums1 = [0, 5, 3, 1, 2]\n    >>> quick_sort_lomuto_partition(nums1, 0, 4)\n    >>> nums1\n    [0, 1, 2, 3, 5]\n    >>> nums2 = []\n    >>> quick_sort_lomuto_partition(nums2, 0, 0)\n    >>> nums2\n    []\n    >>> nums3 = [-2, 5, 0, -4]\n    >>> quick_sort_lomuto_partition(nums3, 0, 3)\n    >>> nums3\n    [-4, -2, 0, 5]\n    \"\"\"\n    if left < right:\n        pivot_index = lomuto_partition(sorting, left, right)\n        quick_sort_lomuto_partition(sorting, left, pivot_index - 1)\n        quick_sort_lomuto_partition(sorting, pivot_index + 1, right)\n\n\ndef lomuto_partition(sorting: list, left: int, right: int) -> int:\n    \"\"\"\n    Example:\n    >>> lomuto_partition([1,5,7,6], 0, 3)\n    2\n    \"\"\"\n    pivot = sorting[right]\n    store_index = left\n    for i in range(left, right):\n        if sorting[i] < pivot:\n            sorting[store_index], sorting[i] = sorting[i], sorting[store_index]\n            store_index += 1\n    sorting[right], sorting[store_index] = sorting[store_index], sorting[right]\n    return store_index\n\n\ndef three_way_radix_quicksort(sorting: list) -> list:\n    \"\"\"\n    Three-way radix quicksort:\n    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort\n    First divide the list into three parts.\n    Then recursively sort the \"less than\" and \"greater than\" partitions.\n\n    >>> three_way_radix_quicksort([])\n    []\n    >>> three_way_radix_quicksort([1])\n    [1]\n    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])\n    [-5, -2, -2, 0, 1, 1]\n    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])\n    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]\n    \"\"\"\n    if len(sorting) <= 1:\n        return sorting\n    return (\n        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])\n        + [i for i in sorting if i == sorting[0]]\n        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    quick_sort_3partition(unsorted, 0, len(unsorted) - 1)\n    print(unsorted)\n", "sorts/tim_sort.py": "def binary_search(lst, item, start, end):\n    if start == end:\n        return start if lst[start] > item else start + 1\n    if start > end:\n        return start\n\n    mid = (start + end) // 2\n    if lst[mid] < item:\n        return binary_search(lst, item, mid + 1, end)\n    elif lst[mid] > item:\n        return binary_search(lst, item, start, mid - 1)\n    else:\n        return mid\n\n\ndef insertion_sort(lst):\n    length = len(lst)\n\n    for index in range(1, length):\n        value = lst[index]\n        pos = binary_search(lst, value, 0, index - 1)\n        lst = lst[:pos] + [value] + lst[pos:index] + lst[index + 1 :]\n\n    return lst\n\n\ndef merge(left, right):\n    if not left:\n        return right\n\n    if not right:\n        return left\n\n    if left[0] < right[0]:\n        return [left[0], *merge(left[1:], right)]\n\n    return [right[0], *merge(left, right[1:])]\n\n\ndef tim_sort(lst):\n    \"\"\"\n    >>> tim_sort(\"Python\")\n    ['P', 'h', 'n', 'o', 't', 'y']\n    >>> tim_sort((1.1, 1, 0, -1, -1.1))\n    [-1.1, -1, 0, 1, 1.1]\n    >>> tim_sort(list(reversed(list(range(7)))))\n    [0, 1, 2, 3, 4, 5, 6]\n    >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])\n    True\n    >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])\n    True\n    \"\"\"\n    length = len(lst)\n    runs, sorted_runs = [], []\n    new_run = [lst[0]]\n    sorted_array = []\n    i = 1\n    while i < length:\n        if lst[i] < lst[i - 1]:\n            runs.append(new_run)\n            new_run = [lst[i]]\n        else:\n            new_run.append(lst[i])\n        i += 1\n    runs.append(new_run)\n\n    for run in runs:\n        sorted_runs.append(insertion_sort(run))\n    for run in sorted_runs:\n        sorted_array = merge(sorted_array, run)\n\n    return sorted_array\n\n\ndef main():\n    lst = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]\n    sorted_lst = tim_sort(lst)\n    print(sorted_lst)\n\n\nif __name__ == \"__main__\":\n    main()\n", "sorts/bogo_sort.py": "\"\"\"\nThis is a pure Python implementation of the bogosort algorithm,\nalso known as permutation sort, stupid sort, slowsort, shotgun sort, or monkey sort.\nBogosort generates random permutations until it guesses the correct one.\n\nMore info on: https://en.wikipedia.org/wiki/Bogosort\n\nFor doctests run following command:\npython -m doctest -v bogo_sort.py\nor\npython3 -m doctest -v bogo_sort.py\nFor manual testing run:\npython bogo_sort.py\n\"\"\"\n\nimport random\n\n\ndef bogo_sort(collection):\n    \"\"\"Pure implementation of the bogosort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> bogo_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> bogo_sort([])\n    []\n    >>> bogo_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def is_sorted(collection):\n        for i in range(len(collection) - 1):\n            if collection[i] > collection[i + 1]:\n                return False\n        return True\n\n    while not is_sorted(collection):\n        random.shuffle(collection)\n    return collection\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(bogo_sort(unsorted))\n", "sorts/iterative_merge_sort.py": "\"\"\"\nImplementation of iterative merge sort in Python\nAuthor: Aman Gupta\n\nFor doctests run following command:\npython3 -m doctest -v iterative_merge_sort.py\n\nFor manual testing run:\npython3 iterative_merge_sort.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef merge(input_list: list, low: int, mid: int, high: int) -> list:\n    \"\"\"\n    sorting left-half and right-half individually\n    then merging them into result\n    \"\"\"\n    result = []\n    left, right = input_list[low:mid], input_list[mid : high + 1]\n    while left and right:\n        result.append((left if left[0] <= right[0] else right).pop(0))\n    input_list[low : high + 1] = result + left + right\n    return input_list\n\n\n# iteration over the unsorted list\ndef iter_merge_sort(input_list: list) -> list:\n    \"\"\"\n    Return a sorted copy of the input list\n\n    >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])\n    [1, 2, 5, 7, 7, 8, 9]\n    >>> iter_merge_sort([1])\n    [1]\n    >>> iter_merge_sort([2, 1])\n    [1, 2]\n    >>> iter_merge_sort([2, 1, 3])\n    [1, 2, 3]\n    >>> iter_merge_sort([4, 3, 2, 1])\n    [1, 2, 3, 4]\n    >>> iter_merge_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> iter_merge_sort(['c', 'b', 'a'])\n    ['a', 'b', 'c']\n    >>> iter_merge_sort([0.3, 0.2, 0.1])\n    [0.1, 0.2, 0.3]\n    >>> iter_merge_sort(['dep', 'dang', 'trai'])\n    ['dang', 'dep', 'trai']\n    >>> iter_merge_sort([6])\n    [6]\n    >>> iter_merge_sort([])\n    []\n    >>> iter_merge_sort([-2, -9, -1, -4])\n    [-9, -4, -2, -1]\n    >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])\n    [-1.1, -1, 0.0, 1, 1.1]\n    >>> iter_merge_sort(['c', 'b', 'a'])\n    ['a', 'b', 'c']\n    >>> iter_merge_sort('cba')\n    ['a', 'b', 'c']\n    \"\"\"\n    if len(input_list) <= 1:\n        return input_list\n    input_list = list(input_list)\n\n    # iteration for two-way merging\n    p = 2\n    while p <= len(input_list):\n        # getting low, high and middle value for merge-sort of single list\n        for i in range(0, len(input_list), p):\n            low = i\n            high = i + p - 1\n            mid = (low + high + 1) // 2\n            input_list = merge(input_list, low, mid, high)\n        # final merge of last two parts\n        if p * 2 >= len(input_list):\n            mid = i\n            input_list = merge(input_list, 0, mid, len(input_list) - 1)\n            break\n        p *= 2\n\n    return input_list\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    if user_input == \"\":\n        unsorted = []\n    else:\n        unsorted = [int(item.strip()) for item in user_input.split(\",\")]\n    print(iter_merge_sort(unsorted))\n", "sorts/insertion_sort.py": "\"\"\"\nA pure Python implementation of the insertion sort algorithm\n\nThis algorithm sorts a collection by comparing adjacent elements.\nWhen it finds that order is not respected, it moves the element compared\nbackward until the order is correct.  It then goes back directly to the\nelement's initial position resuming forward comparison.\n\nFor doctests run following command:\npython3 -m doctest -v insertion_sort.py\n\nFor manual testing run:\npython3 insertion_sort.py\n\"\"\"\n\nfrom collections.abc import MutableSequence\nfrom typing import Any, Protocol, TypeVar\n\n\nclass Comparable(Protocol):\n    def __lt__(self, other: Any, /) -> bool: ...\n\n\nT = TypeVar(\"T\", bound=Comparable)\n\n\ndef insertion_sort(collection: MutableSequence[T]) -> MutableSequence[T]:\n    \"\"\"A pure Python implementation of the insertion sort algorithm\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> insertion_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> insertion_sort([]) == sorted([])\n    True\n    >>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])\n    True\n    >>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 100)\n    >>> insertion_sort(collection) == sorted(collection)\n    True\n    >>> import string\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> insertion_sort(collection) == sorted(collection)\n    True\n    \"\"\"\n\n    for insert_index in range(1, len(collection)):\n        insert_value = collection[insert_index]\n        while insert_index > 0 and insert_value < collection[insert_index - 1]:\n            collection[insert_index] = collection[insert_index - 1]\n            insert_index -= 1\n        collection[insert_index] = insert_value\n    return collection\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(f\"{insertion_sort(unsorted) = }\")\n", "sorts/double_sort.py": "from typing import Any\n\n\ndef double_sort(collection: list[Any]) -> list[Any]:\n    \"\"\"This sorting algorithm sorts an array using the principle of bubble sort,\n    but does it both from left to right and right to left.\n    Hence, it's called \"Double sort\"\n    :param collection: mutable ordered sequence of elements\n    :return: the same collection in ascending order\n    Examples:\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])\n    [-7, -6, -5, -4, -3, -2, -1]\n    >>> double_sort([])\n    []\n    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])\n    [-6, -5, -4, -3, -2, -1]\n    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])\n    True\n    \"\"\"\n    no_of_elements = len(collection)\n    for _ in range(\n        int(((no_of_elements - 1) / 2) + 1)\n    ):  # we don't need to traverse to end of list as\n        for j in range(no_of_elements - 1):\n            # apply the bubble sort algorithm from left to right (or forwards)\n            if collection[j + 1] < collection[j]:\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n            # apply the bubble sort algorithm from right to left (or backwards)\n            if collection[no_of_elements - 1 - j] < collection[no_of_elements - 2 - j]:\n                (\n                    collection[no_of_elements - 1 - j],\n                    collection[no_of_elements - 2 - j],\n                ) = (\n                    collection[no_of_elements - 2 - j],\n                    collection[no_of_elements - 1 - j],\n                )\n    return collection\n\n\nif __name__ == \"__main__\":\n    # allow the user to input the elements of the list on one line\n    unsorted = [int(x) for x in input(\"Enter the list to be sorted: \").split() if x]\n    print(\"the sorted list is\")\n    print(f\"{double_sort(unsorted) = }\")\n", "sorts/dutch_national_flag_sort.py": "\"\"\"\nA pure implementation of Dutch national flag (DNF) sort algorithm in Python.\nDutch National Flag algorithm is an algorithm originally designed by Edsger Dijkstra.\nIt is the most optimal sort for 3 unique values (eg. 0, 1, 2) in a sequence.  DNF can\nsort a sequence of n size with [0 <= a[i] <= 2] at guaranteed O(n) complexity in a\nsingle pass.\n\nThe flag of the Netherlands consists of three colors: white, red, and blue.\nThe task is to randomly arrange balls of white, red, and blue in such a way that balls\nof the same color are placed together.  DNF sorts a sequence of 0, 1, and 2's in linear\ntime that does not consume any extra space.  This algorithm can be implemented only on\na sequence that contains three unique elements.\n\n1) Time complexity is O(n).\n2) Space complexity is O(1).\n\nMore info on: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n\nFor doctests run following command:\npython3 -m doctest -v dutch_national_flag_sort.py\n\nFor manual testing run:\npython dnf_sort.py\n\"\"\"\n\n# Python program to sort a sequence containing only 0, 1 and 2 in a single pass.\nred = 0  # The first color of the flag.\nwhite = 1  # The second color of the flag.\nblue = 2  # The third color of the flag.\ncolors = (red, white, blue)\n\n\ndef dutch_national_flag_sort(sequence: list) -> list:\n    \"\"\"\n    A pure Python implementation of Dutch National Flag sort algorithm.\n    :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence\n    :return: The same collection in ascending order\n\n    >>> dutch_national_flag_sort([])\n    []\n    >>> dutch_national_flag_sort([0])\n    [0]\n    >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])\n    [0, 0, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]\n    >>> dutch_national_flag_sort(\"abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort(\"Abacab\")\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])\n    Traceback (most recent call last):\n      ...\n    ValueError: The elements inside the sequence must contains only (0, 1, 2) values\n    \"\"\"\n    if not sequence:\n        return []\n    if len(sequence) == 1:\n        return list(sequence)\n    low = 0\n    high = len(sequence) - 1\n    mid = 0\n    while mid <= high:\n        if sequence[mid] == colors[0]:\n            sequence[low], sequence[mid] = sequence[mid], sequence[low]\n            low += 1\n            mid += 1\n        elif sequence[mid] == colors[1]:\n            mid += 1\n        elif sequence[mid] == colors[2]:\n            sequence[mid], sequence[high] = sequence[high], sequence[mid]\n            high -= 1\n        else:\n            msg = f\"The elements inside the sequence must contains only {colors} values\"\n            raise ValueError(msg)\n    return sequence\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    user_input = input(\"Enter numbers separated by commas:\\n\").strip()\n    unsorted = [int(item.strip()) for item in user_input.split(\",\")]\n    print(f\"{dutch_national_flag_sort(unsorted)}\")\n", "sorts/binary_insertion_sort.py": "\"\"\"\nThis is a pure Python implementation of the binary insertion sort algorithm\n\nFor doctests run following command:\npython -m doctest -v binary_insertion_sort.py\nor\npython3 -m doctest -v binary_insertion_sort.py\n\nFor manual testing run:\npython binary_insertion_sort.py\n\"\"\"\n\n\ndef binary_insertion_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the binary insertion sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Examples:\n    >>> binary_insertion_sort([0, 4, 1234, 4, 1])\n    [0, 1, 4, 4, 1234]\n    >>> binary_insertion_sort([]) == sorted([])\n    True\n    >>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3])\n    True\n    >>> lst = ['d', 'a', 'b', 'e', 'c']\n    >>> binary_insertion_sort(lst) == sorted(lst)\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 100)\n    >>> binary_insertion_sort(collection) == sorted(collection)\n    True\n    >>> import string\n    >>> collection = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> binary_insertion_sort(collection) == sorted(collection)\n    True\n    \"\"\"\n\n    n = len(collection)\n    for i in range(1, n):\n        value_to_insert = collection[i]\n        low = 0\n        high = i - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if value_to_insert < collection[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        for j in range(i, low, -1):\n            collection[j] = collection[j - 1]\n        collection[low] = value_to_insert\n    return collection\n\n\nif __name__ == \"__main\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    try:\n        unsorted = [int(item) for item in user_input.split(\",\")]\n    except ValueError:\n        print(\"Invalid input. Please enter valid integers separated by commas.\")\n        raise\n    print(f\"{binary_insertion_sort(unsorted) = }\")\n", "sorts/recursive_quick_sort.py": "def quick_sort(data: list) -> list:\n    \"\"\"\n    >>> for data in ([2, 1, 0], [2.2, 1.1, 0], \"quick_sort\"):\n    ...     quick_sort(data) == sorted(data)\n    True\n    True\n    True\n    \"\"\"\n    if len(data) <= 1:\n        return data\n    else:\n        return [\n            *quick_sort([e for e in data[1:] if e <= data[0]]),\n            data[0],\n            *quick_sort([e for e in data[1:] if e > data[0]]),\n        ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/recursive_mergesort_array.py": "\"\"\"A merge sort which accepts an array as input and recursively\nsplits an array in half and sorts and combines them.\n\"\"\"\n\n\"\"\"https://en.wikipedia.org/wiki/Merge_sort \"\"\"\n\n\ndef merge(arr: list[int]) -> list[int]:\n    \"\"\"Return a sorted array.\n    >>> merge([10,9,8,7,6,5,4,3,2,1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge([1,2,3,4,5,6,7,8,9,10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> merge([10,22,1,2,3,9,15,23])\n    [1, 2, 3, 9, 10, 15, 22, 23]\n    >>> merge([100])\n    [100]\n    >>> merge([])\n    []\n    \"\"\"\n    if len(arr) > 1:\n        middle_length = len(arr) // 2  # Finds the middle of the array\n        left_array = arr[\n            :middle_length\n        ]  # Creates an array of the elements in the first half.\n        right_array = arr[\n            middle_length:\n        ]  # Creates an array of the elements in the second half.\n        left_size = len(left_array)\n        right_size = len(right_array)\n        merge(left_array)  # Starts sorting the left.\n        merge(right_array)  # Starts sorting the right\n        left_index = 0  # Left Counter\n        right_index = 0  # Right Counter\n        index = 0  # Position Counter\n        while (\n            left_index < left_size and right_index < right_size\n        ):  # Runs until the lowers size of the left and right are sorted.\n            if left_array[left_index] < right_array[right_index]:\n                arr[index] = left_array[left_index]\n                left_index += 1\n            else:\n                arr[index] = right_array[right_index]\n                right_index += 1\n            index += 1\n        while (\n            left_index < left_size\n        ):  # Adds the left over elements in the left half of the array\n            arr[index] = left_array[left_index]\n            left_index += 1\n            index += 1\n        while (\n            right_index < right_size\n        ):  # Adds the left over elements in the right half of the array\n            arr[index] = right_array[right_index]\n            right_index += 1\n            index += 1\n    return arr\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/shrink_shell_sort.py": "\"\"\"\nThis function implements the shell sort algorithm\nwhich is slightly faster than its pure implementation.\n\nThis shell sort is implemented using a gap, which\nshrinks by a certain factor each iteration. In this\nimplementation, the gap is initially set to the\nlength of the collection. The gap is then reduced by\na certain factor (1.3) each iteration.\n\nFor each iteration, the algorithm compares elements\nthat are a certain number of positions apart\n(determined by the gap). If the element at the higher\nposition is greater than the element at the lower\nposition, the two elements are swapped. The process\nis repeated until the gap is equal to 1.\n\nThe reason this is more efficient is that it reduces\nthe number of comparisons that need to be made. By\nusing a smaller gap, the list is sorted more quickly.\n\"\"\"\n\n\ndef shell_sort(collection: list) -> list:\n    \"\"\"Implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([3, 2, 1])\n    [1, 2, 3]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([1])\n    [1]\n    \"\"\"\n\n    # Choose an initial gap value\n    gap = len(collection)\n\n    # Set the gap value to be decreased by a factor of 1.3\n    # after each iteration\n    shrink = 1.3\n\n    # Continue sorting until the gap is 1\n    while gap > 1:\n        # Decrease the gap value\n        gap = int(gap / shrink)\n\n        # Sort the elements using insertion sort\n        for i in range(gap, len(collection)):\n            temp = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > temp:\n                collection[j] = collection[j - gap]\n                j -= gap\n            collection[j] = temp\n\n    return collection\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "sorts/pigeonhole_sort.py": "# Python program to implement Pigeonhole Sorting in python\n\n# Algorithm for the pigeonhole sorting\n\n\ndef pigeonhole_sort(a):\n    \"\"\"\n    >>> a = [8, 3, 2, 7, 4, 6, 8]\n    >>> b = sorted(a)  # a nondestructive sort\n    >>> pigeonhole_sort(a)  # a destructive sort\n    >>> a == b\n    True\n    \"\"\"\n    # size of range of values in the list (ie, number of pigeonholes we need)\n\n    min_val = min(a)  # min() finds the minimum value\n    max_val = max(a)  # max() finds the maximum value\n\n    size = max_val - min_val + 1  # size is difference of max and min values plus one\n\n    # list of pigeonholes of size equal to the variable size\n    holes = [0] * size\n\n    # Populate the pigeonholes.\n    for x in a:\n        assert isinstance(x, int), \"integers only please\"\n        holes[x - min_val] += 1\n\n    # Putting the elements back into the array in an order.\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            a[i] = count + min_val\n            i += 1\n\n\ndef main():\n    a = [8, 3, 2, 7, 4, 6, 8]\n    pigeonhole_sort(a)\n    print(\"Sorted order is:\", \" \".join(a))\n\n\nif __name__ == \"__main__\":\n    main()\n", "sorts/cocktail_shaker_sort.py": "\"\"\"\nAn implementation of the cocktail shaker sort algorithm in pure Python.\n\nhttps://en.wikipedia.org/wiki/Cocktail_shaker_sort\n\"\"\"\n\n\ndef cocktail_shaker_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sorts a list using the Cocktail Shaker Sort algorithm.\n\n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n\n    >>> cocktail_shaker_sort([4, 5, 2, 1, 2])\n    [1, 2, 2, 4, 5]\n    >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])\n    [-4, 0, 1, 2, 5, 11]\n    >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])\n    [-2.4, 0.1, 2.2, 4.4]\n    >>> cocktail_shaker_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> cocktail_shaker_sort([-4, -5, -24, -7, -11])\n    [-24, -11, -7, -5, -4]\n    >>> cocktail_shaker_sort([\"elderberry\", \"banana\", \"date\", \"apple\", \"cherry\"])\n    ['apple', 'banana', 'cherry', 'date', 'elderberry']\n    >>> cocktail_shaker_sort((-4, -5, -24, -7, -11))\n    Traceback (most recent call last):\n        ...\n    TypeError: 'tuple' object does not support item assignment\n    \"\"\"\n    start, end = 0, len(arr) - 1\n\n    while start < end:\n        swapped = False\n\n        # Pass from left to right\n        for i in range(start, end):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        end -= 1  # Decrease the end pointer after each pass\n\n        # Pass from right to left\n        for i in range(end, start, -1):\n            if arr[i] < arr[i - 1]:\n                arr[i], arr[i - 1] = arr[i - 1], arr[i]\n                swapped = True\n\n        if not swapped:\n            break\n\n        start += 1  # Increase the start pointer after each pass\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(f\"{cocktail_shaker_sort(unsorted) = }\")\n", "sorts/odd_even_sort.py": "\"\"\"\nOdd even sort implementation.\n\nhttps://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\n\"\"\"\n\n\ndef odd_even_sort(input_list: list) -> list:\n    \"\"\"\n    Sort input with odd even sort.\n\n    This algorithm uses the same idea of bubblesort,\n    but by first dividing in two phase (odd and even).\n    Originally developed for use on parallel processors\n    with local interconnections.\n    :param collection: mutable ordered sequence of elements\n    :return: same collection in ascending order\n    Examples:\n    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])\n    [1, 2, 3, 4, 5]\n    >>> odd_even_sort([])\n    []\n    >>> odd_even_sort([-10 ,-1 ,10 ,2])\n    [-10, -1, 2, 10]\n    >>> odd_even_sort([1 ,2 ,3 ,4])\n    [1, 2, 3, 4]\n    \"\"\"\n    is_sorted = False\n    while is_sorted is False:  # Until all the indices are traversed keep looping\n        is_sorted = True\n        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n\n        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices\n            if input_list[i] > input_list[i + 1]:\n                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]\n                # swapping if elements not in order\n                is_sorted = False\n    return input_list\n\n\nif __name__ == \"__main__\":\n    print(\"Enter list to be sorted\")\n    input_list = [int(x) for x in input().split()]\n    # inputing elements of the list in one line\n    sorted_list = odd_even_sort(input_list)\n    print(\"The sorted list is\")\n    print(sorted_list)\n", "sorts/patience_sort.py": "from __future__ import annotations\n\nfrom bisect import bisect_left\nfrom functools import total_ordering\nfrom heapq import merge\n\n\"\"\"\nA pure Python implementation of the patience sort algorithm\n\nFor more information: https://en.wikipedia.org/wiki/Patience_sorting\n\nThis algorithm is based on the card game patience\n\nFor doctests run following command:\npython3 -m doctest -v patience_sort.py\n\nFor manual testing run:\npython3 patience_sort.py\n\"\"\"\n\n\n@total_ordering\nclass Stack(list):\n    def __lt__(self, other):\n        return self[-1] < other[-1]\n\n    def __eq__(self, other):\n        return self[-1] == other[-1]\n\n\ndef patience_sort(collection: list) -> list:\n    \"\"\"A pure implementation of patience sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> patience_sort([1, 9, 5, 21, 17, 6])\n    [1, 5, 6, 9, 17, 21]\n\n    >>> patience_sort([])\n    []\n\n    >>> patience_sort([-3, -17, -48])\n    [-48, -17, -3]\n    \"\"\"\n    stacks: list[Stack] = []\n    # sort into stacks\n    for element in collection:\n        new_stacks = Stack([element])\n        i = bisect_left(stacks, new_stacks)\n        if i != len(stacks):\n            stacks[i].append(element)\n        else:\n            stacks.append(new_stacks)\n\n    # use a heap-based merge to merge stack efficiently\n    collection[:] = merge(*(reversed(stack) for stack in stacks))\n    return collection\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(patience_sort(unsorted))\n", "sorts/odd_even_transposition_single_threaded.py": "\"\"\"\nSource: https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\n\nThis is a non-parallelized implementation of odd-even transposition sort.\n\nNormally the swaps in each set happen simultaneously, without that the algorithm\nis no better than bubble sort.\n\"\"\"\n\n\ndef odd_even_transposition(arr: list) -> list:\n    \"\"\"\n    >>> odd_even_transposition([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n\n    >>> odd_even_transposition([13, 11, 18, 0, -1])\n    [-1, 0, 11, 13, 18]\n\n    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])\n    [-2.9, -0.1, 0.1, 1.1]\n    \"\"\"\n    arr_size = len(arr)\n    for _ in range(arr_size):\n        for i in range(_ % 2, arr_size - 1, 2):\n            if arr[i + 1] < arr[i]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = list(range(10, 0, -1))\n    print(f\"Original: {arr}. Sorted: {odd_even_transposition(arr)}\")\n", "sorts/slowsort.py": "\"\"\"\nSlowsort is a sorting algorithm. It is of humorous nature and not useful.\nIt's based on the principle of multiply and surrender,\na tongue-in-cheek joke of divide and conquer.\nIt was published in 1986 by Andrei Broder and Jorge Stolfi\nin their paper Pessimal Algorithms and Simplexity Analysis\n(a parody of optimal algorithms and complexity analysis).\n\nSource: https://en.wikipedia.org/wiki/Slowsort\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef slowsort(sequence: list, start: int | None = None, end: int | None = None) -> None:\n    \"\"\"\n    Sorts sequence[start..end] (both inclusive) in-place.\n    start defaults to 0 if not given.\n    end defaults to len(sequence) - 1 if not given.\n    It returns None.\n    >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq\n    [1, 2, 3, 4, 4, 5, 5, 6]\n    >>> seq = []; slowsort(seq); seq\n    []\n    >>> seq = [2]; slowsort(seq); seq\n    [2]\n    >>> seq = [1, 2, 3, 4]; slowsort(seq); seq\n    [1, 2, 3, 4]\n    >>> seq = [4, 3, 2, 1]; slowsort(seq); seq\n    [1, 2, 3, 4]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq\n    [9, 8, 2, 3, 4, 5, 6, 7, 1, 0]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq\n    [5, 6, 7, 8, 9, 4, 3, 2, 1, 0]\n    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq\n    [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    \"\"\"\n    if start is None:\n        start = 0\n\n    if end is None:\n        end = len(sequence) - 1\n\n    if start >= end:\n        return\n\n    mid = (start + end) // 2\n\n    slowsort(sequence, start, mid)\n    slowsort(sequence, mid + 1, end)\n\n    if sequence[end] < sequence[mid]:\n        sequence[end], sequence[mid] = sequence[mid], sequence[end]\n\n    slowsort(sequence, start, end - 1)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "sorts/tree_sort.py": "\"\"\"\nTree_sort algorithm.\n\nBuild a Binary Search Tree and then iterate thru it to get a sorted list.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    val: int\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[int]:\n        if self.left:\n            yield from self.left\n        yield self.val\n        if self.right:\n            yield from self.right\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def insert(self, val: int) -> None:\n        if val < self.val:\n            if self.left is None:\n                self.left = Node(val)\n            else:\n                self.left.insert(val)\n        elif val > self.val:\n            if self.right is None:\n                self.right = Node(val)\n            else:\n                self.right.insert(val)\n\n\ndef tree_sort(arr: list[int]) -> tuple[int, ...]:\n    \"\"\"\n    >>> tree_sort([])\n    ()\n    >>> tree_sort((1,))\n    (1,)\n    >>> tree_sort((1, 2))\n    (1, 2)\n    >>> tree_sort([5, 2, 7])\n    (2, 5, 7)\n    >>> tree_sort((5, -4, 9, 2, 7))\n    (-4, 2, 5, 7, 9)\n    >>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7])\n    (-1, 1, 2, 4, 5, 6, 7, 37)\n\n    # >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1)))\n    # True\n    \"\"\"\n    if len(arr) == 0:\n        return tuple(arr)\n    root = Node(arr[0])\n    for item in arr[1:]:\n        root.insert(item)\n    return tuple(root)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{tree_sort([5, 6, 1, -1, 4, 37, -3, 7]) = }\")\n", "sorts/pigeon_sort.py": "\"\"\"\nThis is an implementation of Pigeon Hole Sort.\nFor doctests run following command:\n\npython3 -m doctest -v pigeon_sort.py\nor\npython -m doctest -v pigeon_sort.py\n\nFor manual testing run:\npython pigeon_sort.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef pigeon_sort(array: list[int]) -> list[int]:\n    \"\"\"\n    Implementation of pigeon hole sort algorithm\n    :param array: Collection of comparable items\n    :return: Collection sorted in ascending order\n    >>> pigeon_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pigeon_sort([])\n    []\n    >>> pigeon_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(array) == 0:\n        return array\n\n    _min, _max = min(array), max(array)\n\n    # Compute the variables\n    holes_range = _max - _min + 1\n    holes, holes_repeat = [0] * holes_range, [0] * holes_range\n\n    # Make the sorting.\n    for i in array:\n        index = i - _min\n        holes[index] = i\n        holes_repeat[index] += 1\n\n    # Makes the array back by replacing the numbers.\n    index = 0\n    for i in range(holes_range):\n        while holes_repeat[i] > 0:\n            array[index] = holes[i]\n            index += 1\n            holes_repeat[i] -= 1\n\n    # Returns the sorted array.\n    return array\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    user_input = input(\"Enter numbers separated by comma:\\n\")\n    unsorted = [int(x) for x in user_input.split(\",\")]\n    print(pigeon_sort(unsorted))\n", "sorts/counting_sort.py": "\"\"\"\nThis is pure Python implementation of counting sort algorithm\nFor doctests run following command:\npython -m doctest -v counting_sort.py\nor\npython3 -m doctest -v counting_sort.py\nFor manual testing run:\npython counting_sort.py\n\"\"\"\n\n\ndef counting_sort(collection):\n    \"\"\"Pure implementation of counting sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n    Examples:\n    >>> counting_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> counting_sort([])\n    []\n    >>> counting_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # if the collection is empty, returns empty\n    if collection == []:\n        return []\n\n    # get some information about the collection\n    coll_len = len(collection)\n    coll_max = max(collection)\n    coll_min = min(collection)\n\n    # create the counting array\n    counting_arr_length = coll_max + 1 - coll_min\n    counting_arr = [0] * counting_arr_length\n\n    # count how much a number appears in the collection\n    for number in collection:\n        counting_arr[number - coll_min] += 1\n\n    # sum each position with it's predecessors. now, counting_arr[i] tells\n    # us how many elements <= i has in the collection\n    for i in range(1, counting_arr_length):\n        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]\n\n    # create the output collection\n    ordered = [0] * coll_len\n\n    # place the elements in the output, respecting the original order (stable\n    # sort) from end to begin, updating counting_arr\n    for i in reversed(range(coll_len)):\n        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]\n        counting_arr[collection[i] - coll_min] -= 1\n\n    return ordered\n\n\ndef counting_sort_string(string):\n    \"\"\"\n    >>> counting_sort_string(\"thisisthestring\")\n    'eghhiiinrsssttt'\n    \"\"\"\n    return \"\".join([chr(i) for i in counting_sort([ord(c) for c in string])])\n\n\nif __name__ == \"__main__\":\n    # Test string sort\n    assert counting_sort_string(\"thisisthestring\") == \"eghhiiinrsssttt\"\n\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(counting_sort(unsorted))\n", "sorts/circle_sort.py": "\"\"\"\nThis is a Python implementation of the circle sort algorithm\n\nFor doctests run following command:\npython3 -m doctest -v circle_sort.py\n\nFor manual testing run:\npython3 circle_sort.py\n\"\"\"\n\n\ndef circle_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of circle sort algorithm\n\n    :param collection: a mutable collection of comparable items in any order\n    :return: the same collection in ascending order\n\n    Examples:\n    >>> circle_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> circle_sort([])\n    []\n    >>> circle_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])\n    >>> all(sorted(collection) == circle_sort(collection) for collection in collections)\n    True\n    \"\"\"\n\n    if len(collection) < 2:\n        return collection\n\n    def circle_sort_util(collection: list, low: int, high: int) -> bool:\n        \"\"\"\n        >>> arr = [5,4,3,2,1]\n        >>> circle_sort_util(lst, 0, 2)\n        True\n        >>> arr\n        [3, 4, 5, 2, 1]\n        \"\"\"\n\n        swapped = False\n\n        if low == high:\n            return swapped\n\n        left = low\n        right = high\n\n        while left < right:\n            if collection[left] > collection[right]:\n                collection[left], collection[right] = (\n                    collection[right],\n                    collection[left],\n                )\n                swapped = True\n\n            left += 1\n            right -= 1\n\n        if left == right and collection[left] > collection[right + 1]:\n            collection[left], collection[right + 1] = (\n                collection[right + 1],\n                collection[left],\n            )\n\n            swapped = True\n\n        mid = low + int((high - low) / 2)\n        left_swap = circle_sort_util(collection, low, mid)\n        right_swap = circle_sort_util(collection, mid + 1, high)\n\n        return swapped or left_swap or right_swap\n\n    is_not_sorted = True\n\n    while is_not_sorted is True:\n        is_not_sorted = circle_sort_util(collection, 0, len(collection) - 1)\n\n    return collection\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(circle_sort(unsorted))\n", "sorts/stooge_sort.py": "def stooge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Examples:\n    >>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])\n    [-7.1, -1, 0, 2, 2, 18.1]\n\n    >>> stooge_sort([])\n    []\n    \"\"\"\n    stooge(arr, 0, len(arr) - 1)\n    return arr\n\n\ndef stooge(arr: list[int], i: int, h: int) -> None:\n    if i >= h:\n        return\n\n    # If first element is smaller than the last then swap them\n    if arr[i] > arr[h]:\n        arr[i], arr[h] = arr[h], arr[i]\n\n    # If there are more than 2 elements in the array\n    if h - i + 1 > 2:\n        t = (int)((h - i + 1) / 3)\n\n        # Recursively sort first 2/3 elements\n        stooge(arr, i, (h - t))\n\n        # Recursively sort last 2/3 elements\n        stooge(arr, i + t, (h))\n\n        # Recursively sort first 2/3 elements\n        stooge(arr, i, (h - t))\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(stooge_sort(unsorted))\n", "sorts/bubble_sort.py": "from typing import Any\n\n\ndef bubble_sort_iterative(collection: list[Any]) -> list[Any]:\n    \"\"\"Pure implementation of bubble sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> bubble_sort_iterative([0, 5, 2, 3, 2])\n    [0, 2, 2, 3, 5]\n    >>> bubble_sort_iterative([])\n    []\n    >>> bubble_sort_iterative([-2, -45, -5])\n    [-45, -5, -2]\n    >>> bubble_sort_iterative([-23, 0, 6, -4, 34])\n    [-23, -4, 0, 6, 34]\n    >>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\n    True\n    >>> bubble_sort_iterative([]) == sorted([])\n    True\n    >>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5])\n    True\n    >>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\n    True\n    >>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\n    True\n    >>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c'])\n    ['a', 'b', 'c', 'x', 'y', 'z']\n    >>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n    >>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6])\n    [1, 2, 3.3, 4.4, 5, 6, 7.7]\n    >>> import random\n    >>> collection_arg = random.sample(range(-50, 50), 100)\n    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\n    True\n    >>> import string\n    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)\n    True\n    \"\"\"\n    length = len(collection)\n    for i in reversed(range(length)):\n        swapped = False\n        for j in range(i):\n            if collection[j] > collection[j + 1]:\n                swapped = True\n                collection[j], collection[j + 1] = collection[j + 1], collection[j]\n        if not swapped:\n            break  # Stop iteration if the collection is sorted.\n    return collection\n\n\ndef bubble_sort_recursive(collection: list[Any]) -> list[Any]:\n    \"\"\"It is similar iterative bubble sort but recursive.\n\n    :param collection: mutable ordered sequence of elements\n    :return: the same list in ascending order\n\n    Examples:\n    >>> bubble_sort_recursive([0, 5, 2, 3, 2])\n    [0, 2, 2, 3, 5]\n    >>> bubble_sort_iterative([])\n    []\n    >>> bubble_sort_recursive([-2, -45, -5])\n    [-45, -5, -2]\n    >>> bubble_sort_recursive([-23, 0, 6, -4, 34])\n    [-23, -4, 0, 6, 34]\n    >>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])\n    True\n    >>> bubble_sort_recursive([]) == sorted([])\n    True\n    >>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5])\n    True\n    >>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])\n    True\n    >>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])\n    True\n    >>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c'])\n    ['a', 'b', 'c', 'x', 'y', 'z']\n    >>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n    >>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6])\n    [1, 2, 3.3, 4.4, 5, 6, 7.7]\n    >>> import random\n    >>> collection_arg = random.sample(range(-50, 50), 100)\n    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\n    True\n    >>> import string\n    >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)\n    >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)\n    True\n    \"\"\"\n    length = len(collection)\n    swapped = False\n    for i in range(length - 1):\n        if collection[i] > collection[i + 1]:\n            collection[i], collection[i + 1] = collection[i + 1], collection[i]\n            swapped = True\n\n    return collection if not swapped else bubble_sort_recursive(collection)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    from random import sample\n    from timeit import timeit\n\n    doctest.testmod()\n\n    # Benchmark: Iterative seems slightly faster than recursive.\n    num_runs = 10_000\n    unsorted = sample(range(-50, 50), 100)\n    timer_iterative = timeit(\n        \"bubble_sort_iterative(unsorted[:])\", globals=globals(), number=num_runs\n    )\n    print(\"\\nIterative bubble sort:\")\n    print(*bubble_sort_iterative(unsorted), sep=\",\")\n    print(f\"Processing time (iterative): {timer_iterative:.5f}s for {num_runs:,} runs\")\n\n    unsorted = sample(range(-50, 50), 100)\n    timer_recursive = timeit(\n        \"bubble_sort_recursive(unsorted[:])\", globals=globals(), number=num_runs\n    )\n    print(\"\\nRecursive bubble sort:\")\n    print(*bubble_sort_recursive(unsorted), sep=\",\")\n    print(f\"Processing time (recursive): {timer_recursive:.5f}s for {num_runs:,} runs\")\n", "sorts/bead_sort.py": "\"\"\"\nBead sort only works for sequences of non-negative integers.\nhttps://en.wikipedia.org/wiki/Bead_sort\n\"\"\"\n\n\ndef bead_sort(sequence: list) -> list:\n    \"\"\"\n    >>> bead_sort([6, 11, 12, 4, 1, 5])\n    [1, 4, 5, 6, 11, 12]\n\n    >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    >>> bead_sort([5, 0, 4, 3])\n    [0, 3, 4, 5]\n\n    >>> bead_sort([8, 2, 1])\n    [1, 2, 8]\n\n    >>> bead_sort([1, .9, 0.0, 0, -1, -.9])\n    Traceback (most recent call last):\n        ...\n    TypeError: Sequence must be list of non-negative integers\n\n    >>> bead_sort(\"Hello world\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Sequence must be list of non-negative integers\n    \"\"\"\n    if any(not isinstance(x, int) or x < 0 for x in sequence):\n        raise TypeError(\"Sequence must be list of non-negative integers\")\n    for _ in range(len(sequence)):\n        for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):  # noqa: RUF007\n            if rod_upper > rod_lower:\n                sequence[i] -= rod_upper - rod_lower\n                sequence[i + 1] += rod_upper - rod_lower\n    return sequence\n\n\nif __name__ == \"__main__\":\n    assert bead_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert bead_sort([7, 9, 4, 3, 5]) == [3, 4, 5, 7, 9]\n", "sorts/heap_sort.py": "\"\"\"\nThis is a pure Python implementation of the heap sort algorithm.\n\nFor doctests run following command:\npython -m doctest -v heap_sort.py\nor\npython3 -m doctest -v heap_sort.py\n\nFor manual testing run:\npython heap_sort.py\n\"\"\"\n\n\ndef heapify(unsorted, index, heap_size):\n    largest = index\n    left_index = 2 * index + 1\n    right_index = 2 * index + 2\n    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:\n        largest = left_index\n\n    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:\n        largest = right_index\n\n    if largest != index:\n        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]\n        heapify(unsorted, largest, heap_size)\n\n\ndef heap_sort(unsorted):\n    \"\"\"\n    Pure implementation of the heap sort algorithm in Python\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> heap_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> heap_sort([])\n    []\n\n    >>> heap_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    n = len(unsorted)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(unsorted, i, n)\n    for i in range(n - 1, 0, -1):\n        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]\n        heapify(unsorted, 0, i)\n    return unsorted\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(heap_sort(unsorted))\n", "sorts/merge_sort.py": "\"\"\"\nThis is a pure Python implementation of the merge sort algorithm.\n\nFor doctests run following command:\npython -m doctest -v merge_sort.py\nor\npython3 -m doctest -v merge_sort.py\nFor manual testing run:\npython merge_sort.py\n\"\"\"\n\n\ndef merge_sort(collection: list) -> list:\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    :param collection: A mutable ordered collection with comparable items.\n    :return: The same collection ordered in ascending order.\n\n    Time Complexity: O(n log n)\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> merge_sort([])\n    []\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n\n    def merge(left: list, right: list) -> list:\n        \"\"\"\n        Merge two sorted lists into a single sorted list.\n\n        :param left: Left collection\n        :param right: Right collection\n        :return: Merged result\n        \"\"\"\n        result = []\n        while left and right:\n            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        result.extend(left)\n        result.extend(right)\n        return result\n\n    if len(collection) <= 1:\n        return collection\n    mid_index = len(collection) // 2\n    return merge(merge_sort(collection[:mid_index]), merge_sort(collection[mid_index:]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    try:\n        user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n        unsorted = [int(item) for item in user_input.split(\",\")]\n        sorted_list = merge_sort(unsorted)\n        print(*sorted_list, sep=\",\")\n    except ValueError:\n        print(\"Invalid input. Please enter valid integers separated by commas.\")\n", "sorts/shell_sort.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Shellsort#Pseudocode\n\"\"\"\n\n\ndef shell_sort(collection: list[int]) -> list[int]:\n    \"\"\"Pure implementation of shell sort algorithm in Python\n    :param collection:  Some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return:  the same collection ordered by ascending\n\n    >>> shell_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> shell_sort([])\n    []\n    >>> shell_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    # Marcin Ciura's gap sequence\n\n    gaps = [701, 301, 132, 57, 23, 10, 4, 1]\n    for gap in gaps:\n        for i in range(gap, len(collection)):\n            insert_value = collection[i]\n            j = i\n            while j >= gap and collection[j - gap] > insert_value:\n                collection[j] = collection[j - gap]\n                j -= gap\n            if j != i:\n                collection[j] = insert_value\n    return collection\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(shell_sort(unsorted))\n", "sorts/__init__.py": "", "sorts/odd_even_transposition_parallel.py": "\"\"\"\nThis is an implementation of odd-even transposition sort.\n\nIt works by performing a series of parallel swaps between odd and even pairs of\nvariables in the list.\n\nThis implementation represents each variable in the list with a process and\neach process communicates with its neighboring processes in the list to perform\ncomparisons.\nThey are synchronized with locks and message passing but other forms of\nsynchronization could be used.\n\"\"\"\n\nimport multiprocessing as mp\n\n# lock used to ensure that two processes do not access a pipe at the same time\n# NOTE This breaks testing on build runner. May work better locally\n# process_lock = mp.Lock()\n\n\"\"\"\nThe function run by the processes that sorts the list\n\nposition = the position in the list the process represents, used to know which\n            neighbor we pass our value to\nvalue = the initial value at list[position]\nLSend, RSend = the pipes we use to send to our left and right neighbors\nLRcv, RRcv = the pipes we use to receive from our left and right neighbors\nresultPipe = the pipe used to send results back to main\n\"\"\"\n\n\ndef oe_process(\n    position,\n    value,\n    l_send,\n    r_send,\n    lr_cv,\n    rr_cv,\n    result_pipe,\n    multiprocessing_context,\n):\n    process_lock = multiprocessing_context.Lock()\n\n    # we perform n swaps since after n swaps we know we are sorted\n    # we *could* stop early if we are sorted already, but it takes as long to\n    # find out we are sorted as it does to sort the list with this algorithm\n    for i in range(10):\n        if (i + position) % 2 == 0 and r_send is not None:\n            # send your value to your right neighbor\n            with process_lock:\n                r_send[1].send(value)\n\n            # receive your right neighbor's value\n            with process_lock:\n                temp = rr_cv[0].recv()\n\n            # take the lower value since you are on the left\n            value = min(value, temp)\n        elif (i + position) % 2 != 0 and l_send is not None:\n            # send your value to your left neighbor\n            with process_lock:\n                l_send[1].send(value)\n\n            # receive your left neighbor's value\n            with process_lock:\n                temp = lr_cv[0].recv()\n\n            # take the higher value since you are on the right\n            value = max(value, temp)\n    # after all swaps are performed, send the values back to main\n    result_pipe[1].send(value)\n\n\n\"\"\"\nthe function which creates the processes that perform the parallel swaps\n\narr = the list to be sorted\n\"\"\"\n\n\ndef odd_even_transposition(arr):\n    \"\"\"\n    >>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1]))\n    True\n    >>> odd_even_transposition([\"a\", \"x\", \"c\"]) == sorted([\"x\", \"a\", \"c\"])\n    True\n    >>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8])\n    True\n    >>> odd_even_transposition([False, True, False]) == sorted([False, False, True])\n    True\n    >>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True])\n    False\n    >>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0])\n    True\n    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list)\n    True\n    >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]\n    >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1])\n    False\n    \"\"\"\n    # spawn method is considered safer than fork\n    multiprocessing_context = mp.get_context(\"spawn\")\n\n    process_array_ = []\n    result_pipe = []\n    # initialize the list of pipes where the values will be retrieved\n    for _ in arr:\n        result_pipe.append(multiprocessing_context.Pipe())\n    # creates the processes\n    # the first and last process only have one neighbor so they are made outside\n    # of the loop\n    temp_rs = multiprocessing_context.Pipe()\n    temp_rr = multiprocessing_context.Pipe()\n    process_array_.append(\n        multiprocessing_context.Process(\n            target=oe_process,\n            args=(\n                0,\n                arr[0],\n                None,\n                temp_rs,\n                None,\n                temp_rr,\n                result_pipe[0],\n                multiprocessing_context,\n            ),\n        )\n    )\n    temp_lr = temp_rs\n    temp_ls = temp_rr\n\n    for i in range(1, len(arr) - 1):\n        temp_rs = multiprocessing_context.Pipe()\n        temp_rr = multiprocessing_context.Pipe()\n        process_array_.append(\n            multiprocessing_context.Process(\n                target=oe_process,\n                args=(\n                    i,\n                    arr[i],\n                    temp_ls,\n                    temp_rs,\n                    temp_lr,\n                    temp_rr,\n                    result_pipe[i],\n                    multiprocessing_context,\n                ),\n            )\n        )\n        temp_lr = temp_rs\n        temp_ls = temp_rr\n\n    process_array_.append(\n        multiprocessing_context.Process(\n            target=oe_process,\n            args=(\n                len(arr) - 1,\n                arr[len(arr) - 1],\n                temp_ls,\n                None,\n                temp_lr,\n                None,\n                result_pipe[len(arr) - 1],\n                multiprocessing_context,\n            ),\n        )\n    )\n\n    # start the processes\n    for p in process_array_:\n        p.start()\n\n    # wait for the processes to end and write their values to the list\n    for p in range(len(result_pipe)):\n        arr[p] = result_pipe[p][0].recv()\n        process_array_[p].join()\n    return arr\n\n\n# creates a reverse sorted list and sorts it\ndef main():\n    arr = list(range(10, 0, -1))\n    print(\"Initial List\")\n    print(*arr)\n    arr = odd_even_transposition(arr)\n    print(\"Sorted List\\n\")\n    print(*arr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "sorts/external_sort.py": "#!/usr/bin/env python\n\n#\n# Sort large text files in a minimum amount of memory\n#\nimport argparse\nimport os\n\n\nclass FileSplitter:\n    BLOCK_FILENAME_FORMAT = \"block_{0}.dat\"\n\n    def __init__(self, filename):\n        self.filename = filename\n        self.block_filenames = []\n\n    def write_block(self, data, block_number):\n        filename = self.BLOCK_FILENAME_FORMAT.format(block_number)\n        with open(filename, \"w\") as file:\n            file.write(data)\n        self.block_filenames.append(filename)\n\n    def get_block_filenames(self):\n        return self.block_filenames\n\n    def split(self, block_size, sort_key=None):\n        i = 0\n        with open(self.filename) as file:\n            while True:\n                lines = file.readlines(block_size)\n\n                if lines == []:\n                    break\n\n                if sort_key is None:\n                    lines.sort()\n                else:\n                    lines.sort(key=sort_key)\n\n                self.write_block(\"\".join(lines), i)\n                i += 1\n\n    def cleanup(self):\n        map(os.remove, self.block_filenames)\n\n\nclass NWayMerge:\n    def select(self, choices):\n        min_index = -1\n        min_str = None\n\n        for i in range(len(choices)):\n            if min_str is None or choices[i] < min_str:\n                min_index = i\n\n        return min_index\n\n\nclass FilesArray:\n    def __init__(self, files):\n        self.files = files\n        self.empty = set()\n        self.num_buffers = len(files)\n        self.buffers = {i: None for i in range(self.num_buffers)}\n\n    def get_dict(self):\n        return {\n            i: self.buffers[i] for i in range(self.num_buffers) if i not in self.empty\n        }\n\n    def refresh(self):\n        for i in range(self.num_buffers):\n            if self.buffers[i] is None and i not in self.empty:\n                self.buffers[i] = self.files[i].readline()\n\n                if self.buffers[i] == \"\":\n                    self.empty.add(i)\n                    self.files[i].close()\n\n        if len(self.empty) == self.num_buffers:\n            return False\n\n        return True\n\n    def unshift(self, index):\n        value = self.buffers[index]\n        self.buffers[index] = None\n\n        return value\n\n\nclass FileMerger:\n    def __init__(self, merge_strategy):\n        self.merge_strategy = merge_strategy\n\n    def merge(self, filenames, outfilename, buffer_size):\n        buffers = FilesArray(self.get_file_handles(filenames, buffer_size))\n        with open(outfilename, \"w\", buffer_size) as outfile:\n            while buffers.refresh():\n                min_index = self.merge_strategy.select(buffers.get_dict())\n                outfile.write(buffers.unshift(min_index))\n\n    def get_file_handles(self, filenames, buffer_size):\n        files = {}\n\n        for i in range(len(filenames)):\n            files[i] = open(filenames[i], \"r\", buffer_size)  # noqa: UP015\n\n        return files\n\n\nclass ExternalSort:\n    def __init__(self, block_size):\n        self.block_size = block_size\n\n    def sort(self, filename, sort_key=None):\n        num_blocks = self.get_number_blocks(filename, self.block_size)\n        splitter = FileSplitter(filename)\n        splitter.split(self.block_size, sort_key)\n\n        merger = FileMerger(NWayMerge())\n        buffer_size = self.block_size / (num_blocks + 1)\n        merger.merge(splitter.get_block_filenames(), filename + \".out\", buffer_size)\n\n        splitter.cleanup()\n\n    def get_number_blocks(self, filename, block_size):\n        return (os.stat(filename).st_size / block_size) + 1\n\n\ndef parse_memory(string):\n    if string[-1].lower() == \"k\":\n        return int(string[:-1]) * 1024\n    elif string[-1].lower() == \"m\":\n        return int(string[:-1]) * 1024 * 1024\n    elif string[-1].lower() == \"g\":\n        return int(string[:-1]) * 1024 * 1024 * 1024\n    else:\n        return int(string)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-m\", \"--mem\", help=\"amount of memory to use for sorting\", default=\"100M\"\n    )\n    parser.add_argument(\n        \"filename\", metavar=\"<filename>\", nargs=1, help=\"name of file to sort\"\n    )\n    args = parser.parse_args()\n\n    sorter = ExternalSort(parse_memory(args.mem))\n    sorter.sort(args.filename[0])\n\n\nif __name__ == \"__main__\":\n    main()\n", "sorts/intro_sort.py": "\"\"\"\nIntrospective Sort is a hybrid sort (Quick Sort + Heap Sort + Insertion Sort)\nif the size of the list is under 16, use insertion sort\nhttps://en.wikipedia.org/wiki/Introsort\n\"\"\"\n\nimport math\n\n\ndef insertion_sort(array: list, start: int = 0, end: int = 0) -> list:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> insertion_sort(array, 0, len(array))\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> array = [21, 15, 11, 45, -2, -11, 46]\n    >>> insertion_sort(array, 0, len(array))\n    [-11, -2, 11, 15, 21, 45, 46]\n    >>> array = [-2, 0, 89, 11, 48, 79, 12]\n    >>> insertion_sort(array, 0, len(array))\n    [-2, 0, 11, 12, 48, 79, 89]\n    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n    >>> insertion_sort(array, 0, len(array))\n    ['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z']\n    >>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45]\n    >>> insertion_sort(array, 0, len(array))\n    [-45.03, 0, 1.7, 73.56, 73.568, 89.45]\n    \"\"\"\n    end = end or len(array)\n    for i in range(start, end):\n        temp_index = i\n        temp_index_value = array[i]\n        while temp_index != start and temp_index_value < array[temp_index - 1]:\n            array[temp_index] = array[temp_index - 1]\n            temp_index -= 1\n        array[temp_index] = temp_index_value\n    return array\n\n\ndef heapify(array: list, index: int, heap_size: int) -> None:  # Max Heap\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> heapify(array, len(array) // 2, len(array))\n    \"\"\"\n    largest = index\n    left_index = 2 * index + 1  # Left Node\n    right_index = 2 * index + 2  # Right Node\n\n    if left_index < heap_size and array[largest] < array[left_index]:\n        largest = left_index\n\n    if right_index < heap_size and array[largest] < array[right_index]:\n        largest = right_index\n\n    if largest != index:\n        array[index], array[largest] = array[largest], array[index]\n        heapify(array, largest, heap_size)\n\n\ndef heap_sort(array: list) -> list:\n    \"\"\"\n    >>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52])\n    [-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103]\n    >>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v'])\n    ['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z']\n    >>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7])\n    [-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]\n    \"\"\"\n    n = len(array)\n\n    for i in range(n // 2, -1, -1):\n        heapify(array, i, n)\n\n    for i in range(n - 1, 0, -1):\n        array[i], array[0] = array[0], array[i]\n        heapify(array, 0, i)\n\n    return array\n\n\ndef median_of_3(\n    array: list, first_index: int, middle_index: int, last_index: int\n) -> int:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    12\n    >>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    13\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16]\n    >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)\n    14\n    \"\"\"\n    if (array[first_index] > array[middle_index]) != (\n        array[first_index] > array[last_index]\n    ):\n        return array[first_index]\n    elif (array[middle_index] > array[first_index]) != (\n        array[middle_index] > array[last_index]\n    ):\n        return array[middle_index]\n    else:\n        return array[last_index]\n\n\ndef partition(array: list, low: int, high: int, pivot: int) -> int:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> partition(array, 0, len(array), 12)\n    8\n    >>> array = [21, 15, 11, 45, -2, -11, 46]\n    >>> partition(array, 0, len(array), 15)\n    3\n    >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']\n    >>> partition(array, 0, len(array), 'p')\n    5\n    >>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]\n    >>> partition(array, 0, len(array), 2.879)\n    6\n    \"\"\"\n    i = low\n    j = high\n    while True:\n        while array[i] < pivot:\n            i += 1\n        j -= 1\n        while pivot < array[j]:\n            j -= 1\n        if i >= j:\n            return i\n        array[i], array[j] = array[j], array[i]\n        i += 1\n\n\ndef sort(array: list) -> list:\n    \"\"\"\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: the same collection ordered by ascending\n\n    Examples:\n    >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    >>> sort([-1, -5, -3, -13, -44])\n    [-44, -13, -5, -3, -1]\n    >>> sort([])\n    []\n    >>> sort([5])\n    [5]\n    >>> sort([-3, 0, -7, 6, 23, -34])\n    [-34, -7, -3, 0, 6, 23]\n    >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])\n    [0.3, 1.0, 1.7, 2.1, 3.3]\n    >>> sort(['d', 'a', 'b', 'e', 'c'])\n    ['a', 'b', 'c', 'd', 'e']\n    \"\"\"\n    if len(array) == 0:\n        return array\n    max_depth = 2 * math.ceil(math.log2(len(array)))\n    size_threshold = 16\n    return intro_sort(array, 0, len(array), size_threshold, max_depth)\n\n\ndef intro_sort(\n    array: list, start: int, end: int, size_threshold: int, max_depth: int\n) -> list:\n    \"\"\"\n    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]\n    >>> max_depth = 2 * math.ceil(math.log2(len(array)))\n    >>> intro_sort(array, 0, len(array), 16, max_depth)\n    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]\n    \"\"\"\n    while end - start > size_threshold:\n        if max_depth == 0:\n            return heap_sort(array)\n        max_depth -= 1\n        pivot = median_of_3(array, start, start + ((end - start) // 2) + 1, end - 1)\n        p = partition(array, start, end, pivot)\n        intro_sort(array, p, end, size_threshold, max_depth)\n        end = p\n    return insertion_sort(array, start, end)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    user_input = input(\"Enter numbers separated by a comma : \").strip()\n    unsorted = [float(item) for item in user_input.split(\",\")]\n    print(f\"{sort(unsorted) = }\")\n", "sorts/bitonic_sort.py": "\"\"\"\nPython program for Bitonic Sort.\n\nNote that this program works only when size of input is a power of 2.\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef comp_and_swap(array: list[int], index1: int, index2: int, direction: int) -> None:\n    \"\"\"Compare the value at given index1 and index2 of the array and swap them as per\n    the given direction.\n\n    The parameter direction indicates the sorting direction, ASCENDING(1) or\n    DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are\n    interchanged.\n\n    >>> arr = [12, 42, -21, 1]\n    >>> comp_and_swap(arr, 1, 2, 1)\n    >>> arr\n    [12, -21, 42, 1]\n\n    >>> comp_and_swap(arr, 1, 2, 0)\n    >>> arr\n    [12, 42, -21, 1]\n\n    >>> comp_and_swap(arr, 0, 3, 1)\n    >>> arr\n    [1, 42, -21, 12]\n\n    >>> comp_and_swap(arr, 0, 3, 0)\n    >>> arr\n    [12, 42, -21, 1]\n    \"\"\"\n    if (direction == 1 and array[index1] > array[index2]) or (\n        direction == 0 and array[index1] < array[index2]\n    ):\n        array[index1], array[index2] = array[index2], array[index1]\n\n\ndef bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:\n    \"\"\"\n    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in\n    descending if direction = 0.\n    The sequence to be sorted starts at index position low, the parameter length is the\n    number of elements to be sorted.\n\n    >>> arr = [12, 42, -21, 1]\n    >>> bitonic_merge(arr, 0, 4, 1)\n    >>> arr\n    [-21, 1, 12, 42]\n\n    >>> bitonic_merge(arr, 0, 4, 0)\n    >>> arr\n    [42, 12, 1, -21]\n    \"\"\"\n    if length > 1:\n        middle = int(length / 2)\n        for i in range(low, low + middle):\n            comp_and_swap(array, i, i + middle, direction)\n        bitonic_merge(array, low, middle, direction)\n        bitonic_merge(array, low + middle, middle, direction)\n\n\ndef bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:\n    \"\"\"\n    This function first produces a bitonic sequence by recursively sorting its two\n    halves in opposite sorting orders, and then calls bitonic_merge to make them in the\n    same order.\n\n    >>> arr = [12, 34, 92, -23, 0, -121, -167, 145]\n    >>> bitonic_sort(arr, 0, 8, 1)\n    >>> arr\n    [-167, -121, -23, 0, 12, 34, 92, 145]\n\n    >>> bitonic_sort(arr, 0, 8, 0)\n    >>> arr\n    [145, 92, 34, 12, 0, -23, -121, -167]\n    \"\"\"\n    if length > 1:\n        middle = int(length / 2)\n        bitonic_sort(array, low, middle, 1)\n        bitonic_sort(array, low + middle, middle, 0)\n        bitonic_merge(array, low, length, direction)\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item.strip()) for item in user_input.split(\",\")]\n\n    bitonic_sort(unsorted, 0, len(unsorted), 1)\n    print(\"\\nSorted array in ascending order is: \", end=\"\")\n    print(*unsorted, sep=\", \")\n\n    bitonic_merge(unsorted, 0, len(unsorted), 0)\n    print(\"Sorted array in descending order is: \", end=\"\")\n    print(*unsorted, sep=\", \")\n", "sorts/unknown_sort.py": "\"\"\"\nPython implementation of a sort algorithm.\nBest Case Scenario : O(n)\nWorst Case Scenario : O(n^2) because native Python functions:min, max and remove are\nalready O(n)\n\"\"\"\n\n\ndef merge_sort(collection):\n    \"\"\"Pure implementation of the fastest merge sort algorithm in Python\n\n    :param collection: some mutable ordered collection with heterogeneous\n    comparable items inside\n    :return: a collection ordered by ascending\n\n    Examples:\n    >>> merge_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n\n    >>> merge_sort([])\n    []\n\n    >>> merge_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    start, end = [], []\n    while len(collection) > 1:\n        min_one, max_one = min(collection), max(collection)\n        start.append(min_one)\n        end.append(max_one)\n        collection.remove(min_one)\n        collection.remove(max_one)\n    end.reverse()\n    return start + collection + end\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(*merge_sort(unsorted), sep=\",\")\n", "sorts/pancake_sort.py": "\"\"\"\nThis is a pure Python implementation of the pancake sort algorithm\nFor doctests run following command:\npython3 -m doctest -v pancake_sort.py\nor\npython -m doctest -v pancake_sort.py\nFor manual testing run:\npython pancake_sort.py\n\"\"\"\n\n\ndef pancake_sort(arr):\n    \"\"\"Sort Array with Pancake Sort.\n    :param arr: Collection containing comparable items\n    :return: Collection ordered in ascending order of items\n    Examples:\n    >>> pancake_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> pancake_sort([])\n    []\n    >>> pancake_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    cur = len(arr)\n    while cur > 1:\n        # Find the maximum number in arr\n        mi = arr.index(max(arr[0:cur]))\n        # Reverse from 0 to mi\n        arr = arr[mi::-1] + arr[mi + 1 : len(arr)]\n        # Reverse whole list\n        arr = arr[cur - 1 :: -1] + arr[cur : len(arr)]\n        cur -= 1\n    return arr\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n    print(pancake_sort(unsorted))\n", "sorts/quick_sort.py": "\"\"\"\nA pure Python implementation of the quick sort algorithm\n\nFor doctests run following command:\npython3 -m doctest -v quick_sort.py\n\nFor manual testing run:\npython3 quick_sort.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom random import randrange\n\n\ndef quick_sort(collection: list) -> list:\n    \"\"\"A pure Python implementation of quicksort algorithm.\n\n    :param collection: a mutable collection of comparable items\n    :return: the same collection ordered in ascending order\n\n    Examples:\n    >>> quick_sort([0, 5, 3, 2, 2])\n    [0, 2, 2, 3, 5]\n    >>> quick_sort([])\n    []\n    >>> quick_sort([-2, 5, 0, -45])\n    [-45, -2, 0, 5]\n    \"\"\"\n    # Base case: if the collection has 0 or 1 elements, it is already sorted\n    if len(collection) < 2:\n        return collection\n\n    # Randomly select a pivot index and remove the pivot element from the collection\n    pivot_index = randrange(len(collection))\n    pivot = collection.pop(pivot_index)\n\n    # Partition the remaining elements into two groups: lesser or equal, and greater\n    lesser = [item for item in collection if item <= pivot]\n    greater = [item for item in collection if item > pivot]\n\n    # Recursively sort the lesser and greater groups, and combine with the pivot\n    return [*quick_sort(lesser), pivot, *quick_sort(greater)]\n\n\nif __name__ == \"__main__\":\n    # Get user input and convert it into a list of integers\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    unsorted = [int(item) for item in user_input.split(\",\")]\n\n    # Print the result of sorting the user-provided list\n    print(quick_sort(unsorted))\n", "sorts/bucket_sort.py": "#!/usr/bin/env python3\n\"\"\"\nIllustrate how to implement bucket sort algorithm.\n\nAuthor: OMKAR PATHAK\nThis program will illustrate how to implement bucket sort algorithm\n\nWikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works\nby distributing the elements of an array into a number of buckets.\nEach bucket is then sorted individually, either using a different sorting\nalgorithm, or by recursively applying the bucket sorting algorithm. It is a\ndistribution sort, and is a cousin of radix sort in the most to least\nsignificant digit flavour.\nBucket sort is a generalization of pigeonhole sort. Bucket sort can be\nimplemented with comparisons and therefore can also be considered a\ncomparison sort algorithm. The computational complexity estimates involve the\nnumber of buckets.\n\nTime Complexity of Solution:\nWorst case scenario occurs when all the elements are placed in a single bucket.\nThe overall performance would then be dominated by the algorithm used to sort each\nbucket. In this case, O(n log n), because of TimSort\n\nAverage Case O(n + (n^2)/k + k), where k is the number of buckets\n\nIf k = O(n), time complexity is O(n)\n\nSource: https://en.wikipedia.org/wiki/Bucket_sort\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef bucket_sort(my_list: list, bucket_count: int = 10) -> list:\n    \"\"\"\n    >>> data = [-1, 2, -5, 0]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [9, 8, 7, 6, -12]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> data = [.4, 1.2, .1, .2, -.9]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> bucket_sort([]) == sorted([])\n    True\n    >>> data = [-1e10, 1e10]\n    >>> bucket_sort(data) == sorted(data)\n    True\n    >>> import random\n    >>> collection = random.sample(range(-50, 50), 50)\n    >>> bucket_sort(collection) == sorted(collection)\n    True\n    \"\"\"\n\n    if len(my_list) == 0 or bucket_count <= 0:\n        return []\n\n    min_value, max_value = min(my_list), max(my_list)\n    bucket_size = (max_value - min_value) / bucket_count\n    buckets: list[list] = [[] for _ in range(bucket_count)]\n\n    for val in my_list:\n        index = min(int((val - min_value) / bucket_size), bucket_count - 1)\n        buckets[index].append(val)\n\n    return [val for bucket in buckets for val in sorted(bucket)]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    assert bucket_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]\n    assert bucket_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]\n", "linear_programming/__init__.py": "", "linear_programming/simplex.py": "\"\"\"\nPython implementation of the simplex algorithm for solving linear programs in\ntabular form with\n- `>=`, `<=`, and `=` constraints and\n- each variable `x1, x2, ...>= 0`.\n\nSee https://gist.github.com/imengus/f9619a568f7da5bc74eaf20169a24d98 for how to\nconvert linear programs to simplex tableaus, and the steps taken in the simplex\nalgorithm.\n\nResources:\nhttps://en.wikipedia.org/wiki/Simplex_algorithm\nhttps://tinyurl.com/simplex4beginners\n\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\n\n\nclass Tableau:\n    \"\"\"Operate on simplex tableaus\n\n    >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4]]), 2, 2)\n    Traceback (most recent call last):\n    ...\n    TypeError: Tableau must have type float64\n\n    >>> Tableau(np.array([[-1,-1,0,0,-1],[1,3,1,0,4],[3,1,0,1,4.]]), 2, 2)\n    Traceback (most recent call last):\n    ...\n    ValueError: RHS must be > 0\n\n    >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]), -2, 2)\n    Traceback (most recent call last):\n    ...\n    ValueError: number of (artificial) variables must be a natural number\n    \"\"\"\n\n    # Max iteration number to prevent cycling\n    maxiter = 100\n\n    def __init__(\n        self, tableau: np.ndarray, n_vars: int, n_artificial_vars: int\n    ) -> None:\n        if tableau.dtype != \"float64\":\n            raise TypeError(\"Tableau must have type float64\")\n\n        # Check if RHS is negative\n        if not (tableau[:, -1] >= 0).all():\n            raise ValueError(\"RHS must be > 0\")\n\n        if n_vars < 2 or n_artificial_vars < 0:\n            raise ValueError(\n                \"number of (artificial) variables must be a natural number\"\n            )\n\n        self.tableau = tableau\n        self.n_rows, n_cols = tableau.shape\n\n        # Number of decision variables x1, x2, x3...\n        self.n_vars, self.n_artificial_vars = n_vars, n_artificial_vars\n\n        # 2 if there are >= or == constraints (nonstandard), 1 otherwise (std)\n        self.n_stages = (self.n_artificial_vars > 0) + 1\n\n        # Number of slack variables added to make inequalities into equalities\n        self.n_slack = n_cols - self.n_vars - self.n_artificial_vars - 1\n\n        # Objectives for each stage\n        self.objectives = [\"max\"]\n\n        # In two stage simplex, first minimise then maximise\n        if self.n_artificial_vars:\n            self.objectives.append(\"min\")\n\n        self.col_titles = self.generate_col_titles()\n\n        # Index of current pivot row and column\n        self.row_idx = None\n        self.col_idx = None\n\n        # Does objective row only contain (non)-negative values?\n        self.stop_iter = False\n\n    def generate_col_titles(self) -> list[str]:\n        \"\"\"Generate column titles for tableau of specific dimensions\n\n        >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),\n        ... 2, 0).generate_col_titles()\n        ['x1', 'x2', 's1', 's2', 'RHS']\n\n        >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),\n        ... 2, 2).generate_col_titles()\n        ['x1', 'x2', 'RHS']\n        \"\"\"\n        args = (self.n_vars, self.n_slack)\n\n        # decision | slack\n        string_starts = [\"x\", \"s\"]\n        titles = []\n        for i in range(2):\n            for j in range(args[i]):\n                titles.append(string_starts[i] + str(j + 1))\n        titles.append(\"RHS\")\n        return titles\n\n    def find_pivot(self) -> tuple[Any, Any]:\n        \"\"\"Finds the pivot row and column.\n        >>> Tableau(np.array([[-2,1,0,0,0], [3,1,1,0,6], [1,2,0,1,7.]]),\n        ... 2, 0).find_pivot()\n        (1, 0)\n        \"\"\"\n        objective = self.objectives[-1]\n\n        # Find entries of highest magnitude in objective rows\n        sign = (objective == \"min\") - (objective == \"max\")\n        col_idx = np.argmax(sign * self.tableau[0, :-1])\n\n        # Choice is only valid if below 0 for maximise, and above for minimise\n        if sign * self.tableau[0, col_idx] <= 0:\n            self.stop_iter = True\n            return 0, 0\n\n        # Pivot row is chosen as having the lowest quotient when elements of\n        # the pivot column divide the right-hand side\n\n        # Slice excluding the objective rows\n        s = slice(self.n_stages, self.n_rows)\n\n        # RHS\n        dividend = self.tableau[s, -1]\n\n        # Elements of pivot column within slice\n        divisor = self.tableau[s, col_idx]\n\n        # Array filled with nans\n        nans = np.full(self.n_rows - self.n_stages, np.nan)\n\n        # If element in pivot column is greater than zero, return\n        # quotient or nan otherwise\n        quotients = np.divide(dividend, divisor, out=nans, where=divisor > 0)\n\n        # Arg of minimum quotient excluding the nan values. n_stages is added\n        # to compensate for earlier exclusion of objective columns\n        row_idx = np.nanargmin(quotients) + self.n_stages\n        return row_idx, col_idx\n\n    def pivot(self, row_idx: int, col_idx: int) -> np.ndarray:\n        \"\"\"Pivots on value on the intersection of pivot row and column.\n\n        >>> Tableau(np.array([[-2,-3,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]),\n        ... 2, 2).pivot(1, 0).tolist()\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [[0.0, 3.0, 2.0, 0.0, 8.0],\n        [1.0, 3.0, 1.0, 0.0, 4.0],\n        [0.0, -8.0, -3.0, 1.0, -8.0]]\n        \"\"\"\n        # Avoid changes to original tableau\n        piv_row = self.tableau[row_idx].copy()\n\n        piv_val = piv_row[col_idx]\n\n        # Entry becomes 1\n        piv_row *= 1 / piv_val\n\n        # Variable in pivot column becomes basic, ie the only non-zero entry\n        for idx, coeff in enumerate(self.tableau[:, col_idx]):\n            self.tableau[idx] += -coeff * piv_row\n        self.tableau[row_idx] = piv_row\n        return self.tableau\n\n    def change_stage(self) -> np.ndarray:\n        \"\"\"Exits first phase of the two-stage method by deleting artificial\n        rows and columns, or completes the algorithm if exiting the standard\n        case.\n\n        >>> Tableau(np.array([\n        ... [3, 3, -1, -1, 0, 0, 4],\n        ... [2, 1, 0, 0, 0, 0, 0.],\n        ... [1, 2, -1, 0, 1, 0, 2],\n        ... [2, 1, 0, -1, 0, 1, 2]\n        ... ]), 2, 2).change_stage().tolist()\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [[2.0, 1.0, 0.0, 0.0, 0.0],\n        [1.0, 2.0, -1.0, 0.0, 2.0],\n        [2.0, 1.0, 0.0, -1.0, 2.0]]\n        \"\"\"\n        # Objective of original objective row remains\n        self.objectives.pop()\n\n        if not self.objectives:\n            return self.tableau\n\n        # Slice containing ids for artificial columns\n        s = slice(-self.n_artificial_vars - 1, -1)\n\n        # Delete the artificial variable columns\n        self.tableau = np.delete(self.tableau, s, axis=1)\n\n        # Delete the objective row of the first stage\n        self.tableau = np.delete(self.tableau, 0, axis=0)\n\n        self.n_stages = 1\n        self.n_rows -= 1\n        self.n_artificial_vars = 0\n        self.stop_iter = False\n        return self.tableau\n\n    def run_simplex(self) -> dict[Any, Any]:\n        \"\"\"Operate on tableau until objective function cannot be\n        improved further.\n\n        # Standard linear program:\n        Max:  x1 +  x2\n        ST:   x1 + 3x2 <= 4\n             3x1 +  x2 <= 4\n        >>> Tableau(np.array([[-1,-1,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]),\n        ... 2, 0).run_simplex()\n        {'P': 2.0, 'x1': 1.0, 'x2': 1.0}\n\n        # Standard linear program with 3 variables:\n        Max: 3x1 +  x2 + 3x3\n        ST:  2x1 +  x2 +  x3 \u2264 2\n              x1 + 2x2 + 3x3 \u2264 5\n             2x1 + 2x2 +  x3 \u2264 6\n        >>> Tableau(np.array([\n        ... [-3,-1,-3,0,0,0,0],\n        ... [2,1,1,1,0,0,2],\n        ... [1,2,3,0,1,0,5],\n        ... [2,2,1,0,0,1,6.]\n        ... ]),3,0).run_simplex() # doctest: +ELLIPSIS\n        {'P': 5.4, 'x1': 0.199..., 'x3': 1.6}\n\n\n        # Optimal tableau input:\n        >>> Tableau(np.array([\n        ... [0, 0, 0.25, 0.25, 2],\n        ... [0, 1, 0.375, -0.125, 1],\n        ... [1, 0, -0.125, 0.375, 1]\n        ... ]), 2, 0).run_simplex()\n        {'P': 2.0, 'x1': 1.0, 'x2': 1.0}\n\n        # Non-standard: >= constraints\n        Max: 2x1 + 3x2 +  x3\n        ST:   x1 +  x2 +  x3 <= 40\n             2x1 +  x2 -  x3 >= 10\n                 -  x2 +  x3 >= 10\n        >>> Tableau(np.array([\n        ... [2, 0, 0, 0, -1, -1, 0, 0, 20],\n        ... [-2, -3, -1, 0, 0, 0, 0, 0, 0],\n        ... [1, 1, 1, 1, 0, 0, 0, 0, 40],\n        ... [2, 1, -1, 0, -1, 0, 1, 0, 10],\n        ... [0, -1, 1, 0, 0, -1, 0, 1, 10.]\n        ... ]), 3, 2).run_simplex()\n        {'P': 70.0, 'x1': 10.0, 'x2': 10.0, 'x3': 20.0}\n\n        # Non standard: minimisation and equalities\n        Min: x1 +  x2\n        ST: 2x1 +  x2 = 12\n            6x1 + 5x2 = 40\n        >>> Tableau(np.array([\n        ... [8, 6, 0, 0, 52],\n        ... [1, 1, 0, 0, 0],\n        ... [2, 1, 1, 0, 12],\n        ... [6, 5, 0, 1, 40.],\n        ... ]), 2, 2).run_simplex()\n        {'P': 7.0, 'x1': 5.0, 'x2': 2.0}\n\n\n        # Pivot on slack variables\n        Max: 8x1 + 6x2\n        ST:   x1 + 3x2 <= 33\n             4x1 + 2x2 <= 48\n             2x1 + 4x2 <= 48\n              x1 +  x2 >= 10\n             x1        >= 2\n        >>> Tableau(np.array([\n        ... [2, 1, 0, 0, 0, -1, -1, 0, 0, 12.0],\n        ... [-8, -6, 0, 0, 0, 0, 0, 0, 0, 0.0],\n        ... [1, 3, 1, 0, 0, 0, 0, 0, 0, 33.0],\n        ... [4, 2, 0, 1, 0, 0, 0, 0, 0, 60.0],\n        ... [2, 4, 0, 0, 1, 0, 0, 0, 0, 48.0],\n        ... [1, 1, 0, 0, 0, -1, 0, 1, 0, 10.0],\n        ... [1, 0, 0, 0, 0, 0, -1, 0, 1, 2.0]\n        ... ]), 2, 2).run_simplex() # doctest: +ELLIPSIS\n        {'P': 132.0, 'x1': 12.000... 'x2': 5.999...}\n        \"\"\"\n        # Stop simplex algorithm from cycling.\n        for _ in range(Tableau.maxiter):\n            # Completion of each stage removes an objective. If both stages\n            # are complete, then no objectives are left\n            if not self.objectives:\n                # Find the values of each variable at optimal solution\n                return self.interpret_tableau()\n\n            row_idx, col_idx = self.find_pivot()\n\n            # If there are no more negative values in objective row\n            if self.stop_iter:\n                # Delete artificial variable columns and rows. Update attributes\n                self.tableau = self.change_stage()\n            else:\n                self.tableau = self.pivot(row_idx, col_idx)\n        return {}\n\n    def interpret_tableau(self) -> dict[str, float]:\n        \"\"\"Given the final tableau, add the corresponding values of the basic\n        decision variables to the `output_dict`\n        >>> Tableau(np.array([\n        ... [0,0,0.875,0.375,5],\n        ... [0,1,0.375,-0.125,1],\n        ... [1,0,-0.125,0.375,1]\n        ... ]),2, 0).interpret_tableau()\n        {'P': 5.0, 'x1': 1.0, 'x2': 1.0}\n        \"\"\"\n        # P = RHS of final tableau\n        output_dict = {\"P\": abs(self.tableau[0, -1])}\n\n        for i in range(self.n_vars):\n            # Gives indices of nonzero entries in the ith column\n            nonzero = np.nonzero(self.tableau[:, i])\n            n_nonzero = len(nonzero[0])\n\n            # First entry in the nonzero indices\n            nonzero_rowidx = nonzero[0][0]\n            nonzero_val = self.tableau[nonzero_rowidx, i]\n\n            # If there is only one nonzero value in column, which is one\n            if n_nonzero == 1 and nonzero_val == 1:\n                rhs_val = self.tableau[nonzero_rowidx, -1]\n                output_dict[self.col_titles[i]] = rhs_val\n        return output_dict\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "web_programming/search_books_by_isbn.py": "\"\"\"\nGet book and author data from https://openlibrary.org\n\nISBN: https://en.wikipedia.org/wiki/International_Standard_Book_Number\n\"\"\"\n\nfrom json import JSONDecodeError  # Workaround for requests.exceptions.JSONDecodeError\n\nimport requests\n\n\ndef get_openlibrary_data(olid: str = \"isbn/0140328726\") -> dict:\n    \"\"\"\n    Given an 'isbn/0140328726', return book data from Open Library as a Python dict.\n    Given an '/authors/OL34184A', return authors data as a Python dict.\n    This code must work for olids with or without a leading slash ('/').\n\n    # Comment out doctests if they take too long or have results that may change\n    # >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS\n    {'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...\n    # >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS\n    {'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...\n    \"\"\"\n    new_olid = olid.strip().strip(\"/\")  # Remove leading/trailing whitespace & slashes\n    if new_olid.count(\"/\") != 1:\n        msg = f\"{olid} is not a valid Open Library olid\"\n        raise ValueError(msg)\n    return requests.get(f\"https://openlibrary.org/{new_olid}.json\", timeout=10).json()\n\n\ndef summarize_book(ol_book_data: dict) -> dict:\n    \"\"\"\n    Given Open Library book data, return a summary as a Python dict.\n    \"\"\"\n    desired_keys = {\n        \"title\": \"Title\",\n        \"publish_date\": \"Publish date\",\n        \"authors\": \"Authors\",\n        \"number_of_pages\": \"Number of pages:\",\n        \"first_sentence\": \"First sentence\",\n        \"isbn_10\": \"ISBN (10)\",\n        \"isbn_13\": \"ISBN (13)\",\n    }\n    data = {better_key: ol_book_data[key] for key, better_key in desired_keys.items()}\n    data[\"Authors\"] = [\n        get_openlibrary_data(author[\"key\"])[\"name\"] for author in data[\"Authors\"]\n    ]\n    data[\"First sentence\"] = data[\"First sentence\"][\"value\"]\n    for key, value in data.items():\n        if isinstance(value, list):\n            data[key] = \", \".join(value)\n    return data\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    while True:\n        isbn = input(\"\\nEnter the ISBN code to search (or 'quit' to stop): \").strip()\n        if isbn.lower() in (\"\", \"q\", \"quit\", \"exit\", \"stop\"):\n            break\n\n        if len(isbn) not in (10, 13) or not isbn.isdigit():\n            print(f\"Sorry, {isbn} is not a valid ISBN.  Please, input a valid ISBN.\")\n            continue\n\n        print(f\"\\nSearching Open Library for ISBN: {isbn}...\\n\")\n\n        try:\n            book_summary = summarize_book(get_openlibrary_data(f\"isbn/{isbn}\"))\n            print(\"\\n\".join(f\"{key}: {value}\" for key, value in book_summary.items()))\n        except JSONDecodeError:  # Workaround for requests.exceptions.RequestException:\n            print(f\"Sorry, there are no results for ISBN: {isbn}.\")\n", "web_programming/world_covid19_stats.py": "#!/usr/bin/env python3\n\n\"\"\"\nProvide the current worldwide COVID-19 statistics.\nThis data is being scrapped from 'https://www.worldometers.info/coronavirus/'.\n\"\"\"\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef world_covid19_stats(url: str = \"https://www.worldometers.info/coronavirus\") -> dict:\n    \"\"\"\n    Return a dict of current worldwide COVID-19 statistics\n    \"\"\"\n    soup = BeautifulSoup(requests.get(url, timeout=10).text, \"html.parser\")\n    keys = soup.findAll(\"h1\")\n    values = soup.findAll(\"div\", {\"class\": \"maincounter-number\"})\n    keys += soup.findAll(\"span\", {\"class\": \"panel-title\"})\n    values += soup.findAll(\"div\", {\"class\": \"number-table-main\"})\n    return {key.text.strip(): value.text.strip() for key, value in zip(keys, values)}\n\n\nif __name__ == \"__main__\":\n    print(\"\\033[1m COVID-19 Status of the World \\033[0m\\n\")\n    print(\"\\n\".join(f\"{key}\\n{value}\" for key, value in world_covid19_stats().items()))\n", "web_programming/reddit.py": "from __future__ import annotations\n\nimport requests\n\nvalid_terms = set(\n    \"\"\"approved_at_utc approved_by author_flair_background_color\nauthor_flair_css_class author_flair_richtext author_flair_template_id author_fullname\nauthor_premium can_mod_post category clicked content_categories created_utc downs\nedited gilded gildings hidden hide_score is_created_from_ads_ui is_meta\nis_original_content is_reddit_media_domain is_video link_flair_css_class\nlink_flair_richtext link_flair_text link_flair_text_color media_embed mod_reason_title\nname permalink pwls quarantine saved score secure_media secure_media_embed selftext\nsubreddit subreddit_name_prefixed subreddit_type thumbnail title top_awarded_type\ntotal_awards_received ups upvote_ratio url user_reports\"\"\".split()\n)\n\n\ndef get_subreddit_data(\n    subreddit: str, limit: int = 1, age: str = \"new\", wanted_data: list | None = None\n) -> dict:\n    \"\"\"\n    subreddit : Subreddit to query\n    limit : Number of posts to fetch\n    age : [\"new\", \"top\", \"hot\"]\n    wanted_data : Get only the required data in the list\n    \"\"\"\n    wanted_data = wanted_data or []\n    if invalid_search_terms := \", \".join(sorted(set(wanted_data) - valid_terms)):\n        msg = f\"Invalid search term: {invalid_search_terms}\"\n        raise ValueError(msg)\n    response = requests.get(\n        f\"https://reddit.com/r/{subreddit}/{age}.json?limit={limit}\",\n        headers={\"User-agent\": \"A random string\"},\n        timeout=10,\n    )\n    if response.status_code == 429:\n        raise requests.HTTPError(response=response)\n\n    data = response.json()\n    if not wanted_data:\n        return {id_: data[\"data\"][\"children\"][id_] for id_ in range(limit)}\n\n    data_dict = {}\n    for id_ in range(limit):\n        data_dict[id_] = {\n            item: data[\"data\"][\"children\"][id_][\"data\"][item] for item in wanted_data\n        }\n    return data_dict\n\n\nif __name__ == \"__main__\":\n    # If you get Error 429, that means you are rate limited.Try after some time\n    print(get_subreddit_data(\"learnpython\", wanted_data=[\"title\", \"url\", \"selftext\"]))\n", "web_programming/current_stock_price.py": "import requests\nfrom bs4 import BeautifulSoup\n\n\ndef stock_price(symbol: str = \"AAPL\") -> str:\n    url = f\"https://finance.yahoo.com/quote/{symbol}?p={symbol}\"\n    yahoo_finance_source = requests.get(\n        url, headers={\"USER-AGENT\": \"Mozilla/5.0\"}, timeout=10\n    ).text\n    soup = BeautifulSoup(yahoo_finance_source, \"html.parser\")\n    specific_fin_streamer_tag = soup.find(\"fin-streamer\", {\"data-test\": \"qsp-price\"})\n\n    if specific_fin_streamer_tag:\n        text = specific_fin_streamer_tag.get_text()\n        return text\n    return \"No <fin-streamer> tag with the specified data-test attribute found.\"\n\n\n# Search for the symbol at https://finance.yahoo.com/lookup\nif __name__ == \"__main__\":\n    for symbol in \"AAPL AMZN IBM GOOG MSFT ORCL\".split():\n        print(f\"Current {symbol:<4} stock price is {stock_price(symbol):>8}\")\n", "web_programming/open_google_results.py": "import webbrowser\nfrom sys import argv\nfrom urllib.parse import parse_qs, quote\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\n\nif __name__ == \"__main__\":\n    query = \"%20\".join(argv[1:]) if len(argv) > 1 else quote(str(input(\"Search: \")))\n\n    print(\"Googling.....\")\n\n    url = f\"https://www.google.com/search?q={query}&num=100\"\n\n    res = requests.get(\n        url,\n        headers={\"User-Agent\": str(UserAgent().random)},\n        timeout=10,\n    )\n\n    try:\n        link = (\n            BeautifulSoup(res.text, \"html.parser\")\n            .find(\"div\", attrs={\"class\": \"yuRUbf\"})\n            .find(\"a\")\n            .get(\"href\")\n        )\n\n    except AttributeError:\n        link = parse_qs(\n            BeautifulSoup(res.text, \"html.parser\")\n            .find(\"div\", attrs={\"class\": \"kCrYT\"})\n            .find(\"a\")\n            .get(\"href\")\n        )[\"url\"][0]\n\n    webbrowser.open(link)\n", "web_programming/get_imdb_top_250_movies_csv.py": "from __future__ import annotations\n\nimport csv\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef get_imdb_top_250_movies(url: str = \"\") -> dict[str, float]:\n    url = url or \"https://www.imdb.com/chart/top/?ref_=nv_mv_250\"\n    soup = BeautifulSoup(requests.get(url, timeout=10).text, \"html.parser\")\n    titles = soup.find_all(\"td\", attrs=\"titleColumn\")\n    ratings = soup.find_all(\"td\", class_=\"ratingColumn imdbRating\")\n    return {\n        title.a.text: float(rating.strong.text)\n        for title, rating in zip(titles, ratings)\n    }\n\n\ndef write_movies(filename: str = \"IMDb_Top_250_Movies.csv\") -> None:\n    movies = get_imdb_top_250_movies()\n    with open(filename, \"w\", newline=\"\") as out_file:\n        writer = csv.writer(out_file)\n        writer.writerow([\"Movie title\", \"IMDb rating\"])\n        for title, rating in movies.items():\n            writer.writerow([title, rating])\n\n\nif __name__ == \"__main__\":\n    write_movies()\n", "web_programming/co2_emission.py": "\"\"\"\nGet CO2 emission data from the UK CarbonIntensity API\n\"\"\"\n\nfrom datetime import date\n\nimport requests\n\nBASE_URL = \"https://api.carbonintensity.org.uk/intensity\"\n\n\n# Emission in the last half hour\ndef fetch_last_half_hour() -> str:\n    last_half_hour = requests.get(BASE_URL, timeout=10).json()[\"data\"][0]\n    return last_half_hour[\"intensity\"][\"actual\"]\n\n\n# Emissions in a specific date range\ndef fetch_from_to(start, end) -> list:\n    return requests.get(f\"{BASE_URL}/{start}/{end}\", timeout=10).json()[\"data\"]\n\n\nif __name__ == \"__main__\":\n    for entry in fetch_from_to(start=date(2020, 10, 1), end=date(2020, 10, 3)):\n        print(\"from {from} to {to}: {intensity[actual]}\".format(**entry))\n    print(f\"{fetch_last_half_hour() = }\")\n", "web_programming/fetch_bbc_news.py": "# Created by sarathkaul on 12/11/19\n\nimport requests\n\n_NEWS_API = \"https://newsapi.org/v1/articles?source=bbc-news&sortBy=top&apiKey=\"\n\n\ndef fetch_bbc_news(bbc_news_api_key: str) -> None:\n    # fetching a list of articles in json format\n    bbc_news_page = requests.get(_NEWS_API + bbc_news_api_key, timeout=10).json()\n    # each article in the list is a dict\n    for i, article in enumerate(bbc_news_page[\"articles\"], 1):\n        print(f\"{i}.) {article['title']}\")\n\n\nif __name__ == \"__main__\":\n    fetch_bbc_news(bbc_news_api_key=\"<Your BBC News API key goes here>\")\n", "web_programming/currency_converter.py": "\"\"\"\nThis is used to convert the currency using the Amdoren Currency API\nhttps://www.amdoren.com\n\"\"\"\n\nimport os\n\nimport requests\n\nURL_BASE = \"https://www.amdoren.com/api/currency.php\"\n\n\n# Currency and their description\nlist_of_currencies = \"\"\"\nAED\tUnited Arab Emirates Dirham\nAFN\tAfghan Afghani\nALL\tAlbanian Lek\nAMD\tArmenian Dram\nANG\tNetherlands Antillean Guilder\nAOA\tAngolan Kwanza\nARS\tArgentine Peso\nAUD\tAustralian Dollar\nAWG\tAruban Florin\nAZN\tAzerbaijani Manat\nBAM\tBosnia & Herzegovina Convertible Mark\nBBD\tBarbadian Dollar\nBDT\tBangladeshi Taka\nBGN\tBulgarian Lev\nBHD\tBahraini Dinar\nBIF\tBurundian Franc\nBMD\tBermudian Dollar\nBND\tBrunei Dollar\nBOB\tBolivian Boliviano\nBRL\tBrazilian Real\nBSD\tBahamian Dollar\nBTN\tBhutanese Ngultrum\nBWP\tBotswana Pula\nBYN\tBelarus Ruble\nBZD\tBelize Dollar\nCAD\tCanadian Dollar\nCDF\tCongolese Franc\nCHF\tSwiss Franc\nCLP\tChilean Peso\nCNY\tChinese Yuan\nCOP\tColombian Peso\nCRC\tCosta Rican Colon\nCUC\tCuban Convertible Peso\nCVE\tCape Verdean Escudo\nCZK\tCzech Republic Koruna\nDJF\tDjiboutian Franc\nDKK\tDanish Krone\nDOP\tDominican Peso\nDZD\tAlgerian Dinar\nEGP\tEgyptian Pound\nERN\tEritrean Nakfa\nETB\tEthiopian Birr\nEUR\tEuro\nFJD\tFiji Dollar\nGBP\tBritish Pound Sterling\nGEL\tGeorgian Lari\nGHS\tGhanaian Cedi\nGIP\tGibraltar Pound\nGMD\tGambian Dalasi\nGNF\tGuinea Franc\nGTQ\tGuatemalan Quetzal\nGYD\tGuyanaese Dollar\nHKD\tHong Kong Dollar\nHNL\tHonduran Lempira\nHRK\tCroatian Kuna\nHTG\tHaiti Gourde\nHUF\tHungarian Forint\nIDR\tIndonesian Rupiah\nILS\tIsraeli Shekel\nINR\tIndian Rupee\nIQD\tIraqi Dinar\nIRR\tIranian Rial\nISK\tIcelandic Krona\nJMD\tJamaican Dollar\nJOD\tJordanian Dinar\nJPY\tJapanese Yen\nKES\tKenyan Shilling\nKGS\tKyrgystani Som\nKHR\tCambodian Riel\nKMF\tComorian Franc\nKPW\tNorth Korean Won\nKRW\tSouth Korean Won\nKWD\tKuwaiti Dinar\nKYD\tCayman Islands Dollar\nKZT\tKazakhstan Tenge\nLAK\tLaotian Kip\nLBP\tLebanese Pound\nLKR\tSri Lankan Rupee\nLRD\tLiberian Dollar\nLSL\tLesotho Loti\nLYD\tLibyan Dinar\nMAD\tMoroccan Dirham\nMDL\tMoldovan Leu\nMGA\tMalagasy Ariary\nMKD\tMacedonian Denar\nMMK\tMyanma Kyat\nMNT\tMongolian Tugrik\nMOP\tMacau Pataca\nMRO\tMauritanian Ouguiya\nMUR\tMauritian Rupee\nMVR\tMaldivian Rufiyaa\nMWK\tMalawi Kwacha\nMXN\tMexican Peso\nMYR\tMalaysian Ringgit\nMZN\tMozambican Metical\nNAD\tNamibian Dollar\nNGN\tNigerian Naira\nNIO\tNicaragua Cordoba\nNOK\tNorwegian Krone\nNPR\tNepalese Rupee\nNZD\tNew Zealand Dollar\nOMR\tOmani Rial\nPAB\tPanamanian Balboa\nPEN\tPeruvian Nuevo Sol\nPGK\tPapua New Guinean Kina\nPHP\tPhilippine Peso\nPKR\tPakistani Rupee\nPLN\tPolish Zloty\nPYG\tParaguayan Guarani\nQAR\tQatari Riyal\nRON\tRomanian Leu\nRSD\tSerbian Dinar\nRUB\tRussian Ruble\nRWF\tRwanda Franc\nSAR\tSaudi Riyal\nSBD\tSolomon Islands Dollar\nSCR\tSeychellois Rupee\nSDG\tSudanese Pound\nSEK\tSwedish Krona\nSGD\tSingapore Dollar\nSHP\tSaint Helena Pound\nSLL\tSierra Leonean Leone\nSOS\tSomali Shilling\nSRD\tSurinamese Dollar\nSSP\tSouth Sudanese Pound\nSTD\tSao Tome and Principe Dobra\nSYP\tSyrian Pound\nSZL\tSwazi Lilangeni\nTHB\tThai Baht\nTJS\tTajikistan Somoni\nTMT\tTurkmenistani Manat\nTND\tTunisian Dinar\nTOP\tTonga Paanga\nTRY\tTurkish Lira\nTTD\tTrinidad and Tobago Dollar\nTWD\tNew Taiwan Dollar\nTZS\tTanzanian Shilling\nUAH\tUkrainian Hryvnia\nUGX\tUgandan Shilling\nUSD\tUnited States Dollar\nUYU\tUruguayan Peso\nUZS\tUzbekistan Som\nVEF\tVenezuelan Bolivar\nVND\tVietnamese Dong\nVUV\tVanuatu Vatu\nWST\tSamoan Tala\nXAF\tCentral African CFA franc\nXCD\tEast Caribbean Dollar\nXOF\tWest African CFA franc\nXPF\tCFP Franc\nYER\tYemeni Rial\nZAR\tSouth African Rand\nZMW\tZambian Kwacha\n\"\"\"\n\n\ndef convert_currency(\n    from_: str = \"USD\", to: str = \"INR\", amount: float = 1.0, api_key: str = \"\"\n) -> str:\n    \"\"\"https://www.amdoren.com/currency-api/\"\"\"\n    # Instead of manually generating parameters\n    params = locals()\n    # from is a reserved keyword\n    params[\"from\"] = params.pop(\"from_\")\n    res = requests.get(URL_BASE, params=params, timeout=10).json()\n    return str(res[\"amount\"]) if res[\"error\"] == 0 else res[\"error_message\"]\n\n\nif __name__ == \"__main__\":\n    TESTING = os.getenv(\"CI\", \"\")\n    API_KEY = os.getenv(\"AMDOREN_API_KEY\", \"\")\n\n    if not API_KEY and not TESTING:\n        raise KeyError(\n            \"API key must be provided in the 'AMDOREN_API_KEY' environment variable.\"\n        )\n\n    print(\n        convert_currency(\n            input(\"Enter from currency: \").strip(),\n            input(\"Enter to currency: \").strip(),\n            float(input(\"Enter the amount: \").strip()),\n            API_KEY,\n        )\n    )\n", "web_programming/crawl_google_scholar_citation.py": "\"\"\"\nGet the citation from google scholar\nusing title and year of publication, and volume and pages of journal.\n\"\"\"\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef get_citation(base_url: str, params: dict) -> str:\n    \"\"\"\n    Return the citation number.\n    \"\"\"\n    soup = BeautifulSoup(\n        requests.get(base_url, params=params, timeout=10).content, \"html.parser\"\n    )\n    div = soup.find(\"div\", attrs={\"class\": \"gs_ri\"})\n    anchors = div.find(\"div\", attrs={\"class\": \"gs_fl\"}).find_all(\"a\")\n    return anchors[2].get_text()\n\n\nif __name__ == \"__main__\":\n    params = {\n        \"title\": (\n            \"Precisely geometry controlled microsupercapacitors for ultrahigh areal \"\n            \"capacitance, volumetric capacitance, and energy density\"\n        ),\n        \"journal\": \"Chem. Mater.\",\n        \"volume\": 30,\n        \"pages\": \"3979-3990\",\n        \"year\": 2018,\n        \"hl\": \"en\",\n    }\n    print(get_citation(\"https://scholar.google.com/scholar_lookup\", params=params))\n", "web_programming/get_top_billionaires.py": "\"\"\"\nCAUTION: You may get a json.decoding error.\nThis works for some of us but fails for others.\n\"\"\"\n\nfrom datetime import UTC, date, datetime\n\nimport requests\nfrom rich import box\nfrom rich import console as rich_console\nfrom rich import table as rich_table\n\nLIMIT = 10\nTODAY = datetime.now(tz=UTC)\nAPI_URL = (\n    \"https://www.forbes.com/forbesapi/person/rtb/0/position/true.json\"\n    \"?fields=personName,gender,source,countryOfCitizenship,birthDate,finalWorth\"\n    f\"&limit={LIMIT}\"\n)\n\n\ndef years_old(birth_timestamp: int, today: date | None = None) -> int:\n    \"\"\"\n    Calculate the age in years based on the given birth date.  Only the year, month,\n    and day are used in the calculation.  The time of day is ignored.\n\n    Args:\n        birth_timestamp: The date of birth.\n        today: (useful for writing tests) or if None then datetime.date.today().\n\n    Returns:\n        int: The age in years.\n\n    Examples:\n    >>> today = date(2024, 1, 12)\n    >>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today)\n    64\n    >>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today)\n    53\n    >>> all(\n    ...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i\n    ...     for i in range(1, 111)\n    ... )\n    True\n    \"\"\"\n    today = today or TODAY.date()\n    birth_date = datetime.fromtimestamp(birth_timestamp, tz=UTC).date()\n    return (today.year - birth_date.year) - (\n        (today.month, today.day) < (birth_date.month, birth_date.day)\n    )\n\n\ndef get_forbes_real_time_billionaires() -> list[dict[str, int | str]]:\n    \"\"\"\n    Get the top 10 real-time billionaires using Forbes API.\n\n    Returns:\n        List of top 10 realtime billionaires data.\n    \"\"\"\n    response_json = requests.get(API_URL, timeout=10).json()\n    return [\n        {\n            \"Name\": person[\"personName\"],\n            \"Source\": person[\"source\"],\n            \"Country\": person[\"countryOfCitizenship\"],\n            \"Gender\": person[\"gender\"],\n            \"Worth ($)\": f\"{person['finalWorth'] / 1000:.1f} Billion\",\n            \"Age\": str(years_old(person[\"birthDate\"] / 1000)),\n        }\n        for person in response_json[\"personList\"][\"personsLists\"]\n    ]\n\n\ndef display_billionaires(forbes_billionaires: list[dict[str, int | str]]) -> None:\n    \"\"\"\n    Display Forbes real-time billionaires in a rich table.\n\n    Args:\n        forbes_billionaires (list): Forbes top 10 real-time billionaires\n    \"\"\"\n\n    table = rich_table.Table(\n        title=f\"Forbes Top {LIMIT} Real-Time Billionaires at {TODAY:%Y-%m-%d %H:%M}\",\n        style=\"green\",\n        highlight=True,\n        box=box.SQUARE,\n    )\n    for key in forbes_billionaires[0]:\n        table.add_column(key)\n\n    for billionaire in forbes_billionaires:\n        table.add_row(*billionaire.values())\n\n    rich_console.Console().print(table)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    display_billionaires(get_forbes_real_time_billionaires())\n", "web_programming/giphy.py": "#!/usr/bin/env python3\nimport requests\n\ngiphy_api_key = \"YOUR API KEY\"\n# Can be fetched from https://developers.giphy.com/dashboard/\n\n\ndef get_gifs(query: str, api_key: str = giphy_api_key) -> list:\n    \"\"\"\n    Get a list of URLs of GIFs based on a given query..\n    \"\"\"\n    formatted_query = \"+\".join(query.split())\n    url = f\"https://api.giphy.com/v1/gifs/search?q={formatted_query}&api_key={api_key}\"\n    gifs = requests.get(url, timeout=10).json()[\"data\"]\n    return [gif[\"url\"] for gif in gifs]\n\n\nif __name__ == \"__main__\":\n    print(\"\\n\".join(get_gifs(\"space ship\")))\n", "web_programming/emails_from_url.py": "\"\"\"Get the site emails from URL.\"\"\"\n\nfrom __future__ import annotations\n\n__author__ = \"Muhammad Umer Farooq\"\n__license__ = \"MIT\"\n__version__ = \"1.0.0\"\n__maintainer__ = \"Muhammad Umer Farooq\"\n__email__ = \"contact@muhammadumerfarooq.me\"\n__status__ = \"Alpha\"\n\nimport re\nfrom html.parser import HTMLParser\nfrom urllib import parse\n\nimport requests\n\n\nclass Parser(HTMLParser):\n    def __init__(self, domain: str) -> None:\n        super().__init__()\n        self.urls: list[str] = []\n        self.domain = domain\n\n    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:\n        \"\"\"\n        This function parse html to take takes url from tags\n        \"\"\"\n        # Only parse the 'anchor' tag.\n        if tag == \"a\":\n            # Check the list of defined attributes.\n            for name, value in attrs:\n                # If href is defined, not empty nor # print it and not already in urls.\n                if (\n                    name == \"href\"\n                    and value != \"#\"\n                    and value != \"\"\n                    and value not in self.urls\n                ):\n                    url = parse.urljoin(self.domain, value)\n                    self.urls.append(url)\n\n\n# Get main domain name (example.com)\ndef get_domain_name(url: str) -> str:\n    \"\"\"\n    This function get the main domain name\n\n    >>> get_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n    'c.d'\n    >>> get_domain_name(\"Not a URL!\")\n    ''\n    \"\"\"\n    return \".\".join(get_sub_domain_name(url).split(\".\")[-2:])\n\n\n# Get sub domain name (sub.example.com)\ndef get_sub_domain_name(url: str) -> str:\n    \"\"\"\n    >>> get_sub_domain_name(\"https://a.b.c.d/e/f?g=h,i=j#k\")\n    'a.b.c.d'\n    >>> get_sub_domain_name(\"Not a URL!\")\n    ''\n    \"\"\"\n    return parse.urlparse(url).netloc\n\n\ndef emails_from_url(url: str = \"https://github.com\") -> list[str]:\n    \"\"\"\n    This function takes url and return all valid urls\n    \"\"\"\n    # Get the base domain from the url\n    domain = get_domain_name(url)\n\n    # Initialize the parser\n    parser = Parser(domain)\n\n    try:\n        # Open URL\n        r = requests.get(url, timeout=10)\n\n        # pass the raw HTML to the parser to get links\n        parser.feed(r.text)\n\n        # Get links and loop through\n        valid_emails = set()\n        for link in parser.urls:\n            # open URL.\n            # read = requests.get(link)\n            try:\n                read = requests.get(link, timeout=10)\n                # Get the valid email.\n                emails = re.findall(\"[a-zA-Z0-9]+@\" + domain, read.text)\n                # If not in list then append it.\n                for email in emails:\n                    valid_emails.add(email)\n            except ValueError:\n                pass\n    except ValueError:\n        raise SystemExit(1)\n\n    # Finally return a sorted list of email addresses with no duplicates.\n    return sorted(valid_emails)\n\n\nif __name__ == \"__main__\":\n    emails = emails_from_url(\"https://github.com\")\n    print(f\"{len(emails)} emails found:\")\n    print(\"\\n\".join(sorted(emails)))\n", "web_programming/fetch_github_info.py": "#!/usr/bin/env python3\n\"\"\"\nCreated by sarathkaul on 14/11/19\nUpdated by lawric1 on 24/11/20\n\nAuthentication will be made via access token.\nTo generate your personal access token visit https://github.com/settings/tokens.\n\nNOTE:\nNever hardcode any credential information in the code. Always use an environment\nfile to store the private information and use the `os` module to get the information\nduring runtime.\n\nCreate a \".env\" file in the root directory and write these two lines in that file\nwith your token::\n\n#!/usr/bin/env bash\nexport USER_TOKEN=\"\"\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom typing import Any\n\nimport requests\n\nBASE_URL = \"https://api.github.com\"\n\n# https://docs.github.com/en/free-pro-team@latest/rest/reference/users#get-the-authenticated-user\nAUTHENTICATED_USER_ENDPOINT = BASE_URL + \"/user\"\n\n# https://github.com/settings/tokens\nUSER_TOKEN = os.environ.get(\"USER_TOKEN\", \"\")\n\n\ndef fetch_github_info(auth_token: str) -> dict[Any, Any]:\n    \"\"\"\n    Fetch GitHub info of a user using the requests module\n    \"\"\"\n    headers = {\n        \"Authorization\": f\"token {auth_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    return requests.get(AUTHENTICATED_USER_ENDPOINT, headers=headers, timeout=10).json()\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    if USER_TOKEN:\n        for key, value in fetch_github_info(USER_TOKEN).items():\n            print(f\"{key}: {value}\")\n    else:\n        raise ValueError(\"'USER_TOKEN' field cannot be empty.\")\n", "web_programming/instagram_crawler.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport json\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\n\nheaders = {\"UserAgent\": UserAgent().random}\n\n\ndef extract_user_profile(script) -> dict:\n    \"\"\"\n    May raise json.decoder.JSONDecodeError\n    \"\"\"\n    data = script.contents[0]\n    info = json.loads(data[data.find('{\"config\"') : -1])\n    return info[\"entry_data\"][\"ProfilePage\"][0][\"graphql\"][\"user\"]\n\n\nclass InstagramUser:\n    \"\"\"\n    Class Instagram crawl instagram user information\n\n    Usage: (doctest failing on GitHub Actions)\n    # >>> instagram_user = InstagramUser(\"github\")\n    # >>> instagram_user.is_verified\n    True\n    # >>> instagram_user.biography\n    'Built for developers.'\n    \"\"\"\n\n    def __init__(self, username):\n        self.url = f\"https://www.instagram.com/{username}/\"\n        self.user_data = self.get_json()\n\n    def get_json(self) -> dict:\n        \"\"\"\n        Return a dict of user information\n        \"\"\"\n        html = requests.get(self.url, headers=headers, timeout=10).text\n        scripts = BeautifulSoup(html, \"html.parser\").find_all(\"script\")\n        try:\n            return extract_user_profile(scripts[4])\n        except (json.decoder.JSONDecodeError, KeyError):\n            return extract_user_profile(scripts[3])\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}('{self.username}')\"\n\n    def __str__(self) -> str:\n        return f\"{self.fullname} ({self.username}) is {self.biography}\"\n\n    @property\n    def username(self) -> str:\n        return self.user_data[\"username\"]\n\n    @property\n    def fullname(self) -> str:\n        return self.user_data[\"full_name\"]\n\n    @property\n    def biography(self) -> str:\n        return self.user_data[\"biography\"]\n\n    @property\n    def email(self) -> str:\n        return self.user_data[\"business_email\"]\n\n    @property\n    def website(self) -> str:\n        return self.user_data[\"external_url\"]\n\n    @property\n    def number_of_followers(self) -> int:\n        return self.user_data[\"edge_followed_by\"][\"count\"]\n\n    @property\n    def number_of_followings(self) -> int:\n        return self.user_data[\"edge_follow\"][\"count\"]\n\n    @property\n    def number_of_posts(self) -> int:\n        return self.user_data[\"edge_owner_to_timeline_media\"][\"count\"]\n\n    @property\n    def profile_picture_url(self) -> str:\n        return self.user_data[\"profile_pic_url_hd\"]\n\n    @property\n    def is_verified(self) -> bool:\n        return self.user_data[\"is_verified\"]\n\n    @property\n    def is_private(self) -> bool:\n        return self.user_data[\"is_private\"]\n\n\ndef test_instagram_user(username: str = \"github\") -> None:\n    \"\"\"\n    A self running doctest\n    >>> test_instagram_user()\n    \"\"\"\n    import os\n\n    if os.environ.get(\"CI\"):\n        return  # test failing on GitHub Actions\n    instagram_user = InstagramUser(username)\n    assert instagram_user.user_data\n    assert isinstance(instagram_user.user_data, dict)\n    assert instagram_user.username == username\n    if username != \"github\":\n        return\n    assert instagram_user.fullname == \"GitHub\"\n    assert instagram_user.biography == \"Built for developers.\"\n    assert instagram_user.number_of_posts > 150\n    assert instagram_user.number_of_followers > 120000\n    assert instagram_user.number_of_followings > 15\n    assert instagram_user.email == \"support@github.com\"\n    assert instagram_user.website == \"https://github.com/readme\"\n    assert instagram_user.profile_picture_url.startswith(\"https://instagram.\")\n    assert instagram_user.is_verified is True\n    assert instagram_user.is_private is False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    instagram_user = InstagramUser(\"github\")\n    print(instagram_user)\n    print(f\"{instagram_user.number_of_posts = }\")\n    print(f\"{instagram_user.number_of_followers = }\")\n    print(f\"{instagram_user.number_of_followings = }\")\n    print(f\"{instagram_user.email = }\")\n    print(f\"{instagram_user.website = }\")\n    print(f\"{instagram_user.profile_picture_url = }\")\n    print(f\"{instagram_user.is_verified = }\")\n    print(f\"{instagram_user.is_private = }\")\n", "web_programming/daily_horoscope.py": "import requests\nfrom bs4 import BeautifulSoup\n\n\ndef horoscope(zodiac_sign: int, day: str) -> str:\n    url = (\n        \"https://www.horoscope.com/us/horoscopes/general/\"\n        f\"horoscope-general-daily-{day}.aspx?sign={zodiac_sign}\"\n    )\n    soup = BeautifulSoup(requests.get(url, timeout=10).content, \"html.parser\")\n    return soup.find(\"div\", class_=\"main-horoscope\").p.text\n\n\nif __name__ == \"__main__\":\n    print(\"Daily Horoscope. \\n\")\n    print(\n        \"enter your Zodiac sign number:\\n\",\n        \"1. Aries\\n\",\n        \"2. Taurus\\n\",\n        \"3. Gemini\\n\",\n        \"4. Cancer\\n\",\n        \"5. Leo\\n\",\n        \"6. Virgo\\n\",\n        \"7. Libra\\n\",\n        \"8. Scorpio\\n\",\n        \"9. Sagittarius\\n\",\n        \"10. Capricorn\\n\",\n        \"11. Aquarius\\n\",\n        \"12. Pisces\\n\",\n    )\n    zodiac_sign = int(input(\"number> \").strip())\n    print(\"choose some day:\\n\", \"yesterday\\n\", \"today\\n\", \"tomorrow\\n\")\n    day = input(\"enter the day> \")\n    horoscope_text = horoscope(zodiac_sign, day)\n    print(horoscope_text)\n", "web_programming/crawl_google_results.py": "import sys\nimport webbrowser\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\n\nif __name__ == \"__main__\":\n    print(\"Googling.....\")\n    url = \"https://www.google.com/search?q=\" + \" \".join(sys.argv[1:])\n    res = requests.get(url, headers={\"UserAgent\": UserAgent().random}, timeout=10)\n    # res.raise_for_status()\n    with open(\"project1a.html\", \"wb\") as out_file:  # only for knowing the class\n        for data in res.iter_content(10000):\n            out_file.write(data)\n    soup = BeautifulSoup(res.text, \"html.parser\")\n    links = list(soup.select(\".eZt8xd\"))[:5]\n\n    print(len(links))\n    for link in links:\n        if link.text == \"Maps\":\n            webbrowser.open(link.get(\"href\"))\n        else:\n            webbrowser.open(f\"https://google.com{link.get('href')}\")\n", "web_programming/fetch_well_rx_price.py": "\"\"\"\n\nScrape the price and pharmacy name for a prescription drug from rx site\nafter providing the drug name and zipcode.\n\n\"\"\"\n\nfrom urllib.error import HTTPError\n\nfrom bs4 import BeautifulSoup\nfrom requests import exceptions, get\n\nBASE_URL = \"https://www.wellrx.com/prescriptions/{0}/{1}/?freshSearch=true\"\n\n\ndef fetch_pharmacy_and_price_list(drug_name: str, zip_code: str) -> list | None:\n    \"\"\"[summary]\n\n    This function will take input of drug name and zipcode,\n    then request to the BASE_URL site.\n    Get the page data and scrape it to the generate the\n    list of lowest prices for the prescription drug.\n\n    Args:\n        drug_name (str): [Drug name]\n        zip_code(str): [Zip code]\n\n    Returns:\n        list: [List of pharmacy name and price]\n\n    >>> fetch_pharmacy_and_price_list(None, None)\n\n    >>> fetch_pharmacy_and_price_list(None, 30303)\n\n    >>> fetch_pharmacy_and_price_list(\"eliquis\", None)\n\n    \"\"\"\n\n    try:\n        # Has user provided both inputs?\n        if not drug_name or not zip_code:\n            return None\n\n        request_url = BASE_URL.format(drug_name, zip_code)\n        response = get(request_url, timeout=10)\n\n        # Is the response ok?\n        response.raise_for_status()\n\n        # Scrape the data using bs4\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # This list will store the name and price.\n        pharmacy_price_list = []\n\n        # Fetch all the grids that contains the items.\n        grid_list = soup.find_all(\"div\", {\"class\": \"grid-x pharmCard\"})\n        if grid_list and len(grid_list) > 0:\n            for grid in grid_list:\n                # Get the pharmacy price.\n                pharmacy_name = grid.find(\"p\", {\"class\": \"list-title\"}).text\n\n                # Get price of the drug.\n                price = grid.find(\"span\", {\"p\", \"price price-large\"}).text\n\n                pharmacy_price_list.append(\n                    {\n                        \"pharmacy_name\": pharmacy_name,\n                        \"price\": price,\n                    }\n                )\n\n        return pharmacy_price_list\n\n    except (HTTPError, exceptions.RequestException, ValueError):\n        return None\n\n\nif __name__ == \"__main__\":\n    # Enter a drug name and a zip code\n    drug_name = input(\"Enter drug name: \").strip()\n    zip_code = input(\"Enter zip code: \").strip()\n\n    pharmacy_price_list: list | None = fetch_pharmacy_and_price_list(\n        drug_name, zip_code\n    )\n\n    if pharmacy_price_list:\n        print(f\"\\nSearch results for {drug_name} at location {zip_code}:\")\n        for pharmacy_price in pharmacy_price_list:\n            name = pharmacy_price[\"pharmacy_name\"]\n            price = pharmacy_price[\"price\"]\n\n            print(f\"Pharmacy: {name} Price: {price}\")\n    else:\n        print(f\"No results found for {drug_name}\")\n", "web_programming/get_user_tweets.py": "import csv\n\nimport tweepy\n\n# Twitter API credentials\nconsumer_key = \"\"\nconsumer_secret = \"\"\naccess_key = \"\"\naccess_secret = \"\"\n\n\ndef get_all_tweets(screen_name: str) -> None:\n    # authorize twitter, initialize tweepy\n    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\n    auth.set_access_token(access_key, access_secret)\n    api = tweepy.API(auth)\n\n    # initialize a list to hold all the tweepy Tweets\n    alltweets = []\n\n    # make initial request for most recent tweets (200 is the maximum allowed count)\n    new_tweets = api.user_timeline(screen_name=screen_name, count=200)\n\n    # save most recent tweets\n    alltweets.extend(new_tweets)\n\n    # save the id of the oldest tweet less one\n    oldest = alltweets[-1].id - 1\n\n    # keep grabbing tweets until there are no tweets left to grab\n    while len(new_tweets) > 0:\n        print(f\"getting tweets before {oldest}\")\n\n        # all subsequent requests use the max_id param to prevent duplicates\n        new_tweets = api.user_timeline(\n            screen_name=screen_name, count=200, max_id=oldest\n        )\n\n        # save most recent tweets\n        alltweets.extend(new_tweets)\n\n        # update the id of the oldest tweet less one\n        oldest = alltweets[-1].id - 1\n\n        print(f\"...{len(alltweets)} tweets downloaded so far\")\n\n    # transform the tweepy tweets into a 2D array that will populate the csv\n    outtweets = [[tweet.id_str, tweet.created_at, tweet.text] for tweet in alltweets]\n\n    # write the csv\n    with open(f\"new_{screen_name}_tweets.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow([\"id\", \"created_at\", \"text\"])\n        writer.writerows(outtweets)\n\n\nif __name__ == \"__main__\":\n    # pass in the username of the account you want to download\n    get_all_tweets(\"FirePing32\")\n", "web_programming/get_ip_geolocation.py": "import requests\n\n\n# Function to get geolocation data for an IP address\ndef get_ip_geolocation(ip_address: str) -> str:\n    try:\n        # Construct the URL for the IP geolocation API\n        url = f\"https://ipinfo.io/{ip_address}/json\"\n\n        # Send a GET request to the API\n        response = requests.get(url, timeout=10)\n\n        # Check if the HTTP request was successful\n        response.raise_for_status()\n\n        # Parse the response as JSON\n        data = response.json()\n\n        # Check if city, region, and country information is available\n        if \"city\" in data and \"region\" in data and \"country\" in data:\n            location = f\"Location: {data['city']}, {data['region']}, {data['country']}\"\n        else:\n            location = \"Location data not found.\"\n\n        return location\n    except requests.exceptions.RequestException as e:\n        # Handle network-related exceptions\n        return f\"Request error: {e}\"\n    except ValueError as e:\n        # Handle JSON parsing errors\n        return f\"JSON parsing error: {e}\"\n\n\nif __name__ == \"__main__\":\n    # Prompt the user to enter an IP address\n    ip_address = input(\"Enter an IP address: \")\n\n    # Get the geolocation data and print it\n    location = get_ip_geolocation(ip_address)\n    print(location)\n", "web_programming/current_weather.py": "import requests\n\n# Put your API key(s) here\nOPENWEATHERMAP_API_KEY = \"\"\nWEATHERSTACK_API_KEY = \"\"\n\n# Define the URL for the APIs with placeholders\nOPENWEATHERMAP_URL_BASE = \"https://api.openweathermap.org/data/2.5/weather\"\nWEATHERSTACK_URL_BASE = \"http://api.weatherstack.com/current\"\n\n\ndef current_weather(location: str) -> list[dict]:\n    \"\"\"\n    >>> current_weather(\"location\")\n    Traceback (most recent call last):\n        ...\n    ValueError: No API keys provided or no valid data returned.\n    \"\"\"\n    weather_data = []\n    if OPENWEATHERMAP_API_KEY:\n        params_openweathermap = {\"q\": location, \"appid\": OPENWEATHERMAP_API_KEY}\n        response_openweathermap = requests.get(\n            OPENWEATHERMAP_URL_BASE, params=params_openweathermap, timeout=10\n        )\n        weather_data.append({\"OpenWeatherMap\": response_openweathermap.json()})\n    if WEATHERSTACK_API_KEY:\n        params_weatherstack = {\"query\": location, \"access_key\": WEATHERSTACK_API_KEY}\n        response_weatherstack = requests.get(\n            WEATHERSTACK_URL_BASE, params=params_weatherstack, timeout=10\n        )\n        weather_data.append({\"Weatherstack\": response_weatherstack.json()})\n    if not weather_data:\n        raise ValueError(\"No API keys provided or no valid data returned.\")\n    return weather_data\n\n\nif __name__ == \"__main__\":\n    from pprint import pprint\n\n    location = \"to be determined...\"\n    while location:\n        location = input(\"Enter a location (city name or latitude,longitude): \").strip()\n        if location:\n            try:\n                weather_data = current_weather(location)\n                for forecast in weather_data:\n                    pprint(forecast)\n            except ValueError as e:\n                print(repr(e))\n                location = \"\"\n", "web_programming/slack_message.py": "# Created by sarathkaul on 12/11/19\n\nimport requests\n\n\ndef send_slack_message(message_body: str, slack_url: str) -> None:\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(\n        slack_url, json={\"text\": message_body}, headers=headers, timeout=10\n    )\n    if response.status_code != 200:\n        msg = (\n            \"Request to slack returned an error \"\n            f\"{response.status_code}, the response is:\\n{response.text}\"\n        )\n        raise ValueError(msg)\n\n\nif __name__ == \"__main__\":\n    # Set the slack url to the one provided by Slack when you create the webhook at\n    # https://my.slack.com/services/new/incoming-webhook/\n    send_slack_message(\"<YOUR MESSAGE BODY>\", \"<SLACK CHANNEL URL>\")\n", "web_programming/download_images_from_google_query.py": "import json\nimport os\nimport re\nimport sys\nimport urllib.request\n\nimport requests\nfrom bs4 import BeautifulSoup\n\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n    \" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582\"\n}\n\n\ndef download_images_from_google_query(query: str = \"dhaka\", max_images: int = 5) -> int:\n    \"\"\"\n    Searches google using the provided query term and downloads the images in a folder.\n\n    Args:\n         query : The image search term to be provided by the user. Defaults to\n        \"dhaka\".\n        image_numbers : [description]. Defaults to 5.\n\n    Returns:\n        The number of images successfully downloaded.\n\n    # Comment out slow (4.20s call) doctests\n    # >>> download_images_from_google_query()\n    5\n    # >>> download_images_from_google_query(\"potato\")\n    5\n    \"\"\"\n    max_images = min(max_images, 50)  # Prevent abuse!\n    params = {\n        \"q\": query,\n        \"tbm\": \"isch\",\n        \"hl\": \"en\",\n        \"ijn\": \"0\",\n    }\n\n    html = requests.get(\n        \"https://www.google.com/search\", params=params, headers=headers, timeout=10\n    )\n    soup = BeautifulSoup(html.text, \"html.parser\")\n    matched_images_data = \"\".join(\n        re.findall(r\"AF_initDataCallback\\(([^<]+)\\);\", str(soup.select(\"script\")))\n    )\n\n    matched_images_data_fix = json.dumps(matched_images_data)\n    matched_images_data_json = json.loads(matched_images_data_fix)\n\n    matched_google_image_data = re.findall(\n        r\"\\[\\\"GRID_STATE0\\\",null,\\[\\[1,\\[0,\\\".*?\\\",(.*),\\\"All\\\",\",\n        matched_images_data_json,\n    )\n    if not matched_google_image_data:\n        return 0\n\n    removed_matched_google_images_thumbnails = re.sub(\n        r\"\\[\\\"(https\\:\\/\\/encrypted-tbn0\\.gstatic\\.com\\/images\\?.*?)\\\",\\d+,\\d+\\]\",\n        \"\",\n        str(matched_google_image_data),\n    )\n\n    matched_google_full_resolution_images = re.findall(\n        r\"(?:'|,),\\[\\\"(https:|http.*?)\\\",\\d+,\\d+\\]\",\n        removed_matched_google_images_thumbnails,\n    )\n    for index, fixed_full_res_image in enumerate(matched_google_full_resolution_images):\n        if index >= max_images:\n            return index\n        original_size_img_not_fixed = bytes(fixed_full_res_image, \"ascii\").decode(\n            \"unicode-escape\"\n        )\n        original_size_img = bytes(original_size_img_not_fixed, \"ascii\").decode(\n            \"unicode-escape\"\n        )\n        opener = urllib.request.build_opener()\n        opener.addheaders = [\n            (\n                \"User-Agent\",\n                \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n                \" (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582\",\n            )\n        ]\n        urllib.request.install_opener(opener)\n        path_name = f\"query_{query.replace(' ', '_')}\"\n        if not os.path.exists(path_name):\n            os.makedirs(path_name)\n        urllib.request.urlretrieve(  # noqa: S310\n            original_size_img, f\"{path_name}/original_size_img_{index}.jpg\"\n        )\n    return index\n\n\nif __name__ == \"__main__\":\n    try:\n        image_count = download_images_from_google_query(sys.argv[1])\n        print(f\"{image_count} images were downloaded to disk.\")\n    except IndexError:\n        print(\"Please provide a search term.\")\n        raise\n", "web_programming/fetch_anime_and_play.py": "import requests\nfrom bs4 import BeautifulSoup, NavigableString, Tag\nfrom fake_useragent import UserAgent\n\nBASE_URL = \"https://ww1.gogoanime2.org\"\n\n\ndef search_scraper(anime_name: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of anime after scraping the site.\n\n    >>> type(search_scraper(\"demon_slayer\"))\n    <class 'list'>\n\n    Args:\n        anime_name (str): [Name of anime]\n\n    Raises:\n        e: [Raises exception on failure]\n\n    Returns:\n        [list]: [List of animes]\n    \"\"\"\n\n    # concat the name to form the search url.\n    search_url = f\"{BASE_URL}/search/{anime_name}\"\n\n    response = requests.get(\n        search_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )  # request the url.\n\n    # Is the response ok?\n    response.raise_for_status()\n\n    # parse with soup.\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # get list of anime\n    anime_ul = soup.find(\"ul\", {\"class\": \"items\"})\n    if anime_ul is None or isinstance(anime_ul, NavigableString):\n        msg = f\"Could not find and anime with name {anime_name}\"\n        raise ValueError(msg)\n    anime_li = anime_ul.children\n\n    # for each anime, insert to list. the name and url.\n    anime_list = []\n    for anime in anime_li:\n        if isinstance(anime, Tag):\n            anime_url = anime.find(\"a\")\n            if anime_url is None or isinstance(anime_url, NavigableString):\n                continue\n            anime_title = anime.find(\"a\")\n            if anime_title is None or isinstance(anime_title, NavigableString):\n                continue\n\n            anime_list.append({\"title\": anime_title[\"title\"], \"url\": anime_url[\"href\"]})\n\n    return anime_list\n\n\ndef search_anime_episode_list(episode_endpoint: str) -> list:\n    \"\"\"[summary]\n\n    Take an url and\n    return list of episodes after scraping the site\n    for an url.\n\n    >>> type(search_anime_episode_list(\"/anime/kimetsu-no-yaiba\"))\n    <class 'list'>\n\n    Args:\n        episode_endpoint (str): [Endpoint of episode]\n\n    Raises:\n        e: [description]\n\n    Returns:\n        [list]: [List of episodes]\n    \"\"\"\n\n    request_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = requests.get(\n        url=request_url, headers={\"UserAgent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # With this id. get the episode list.\n    episode_page_ul = soup.find(\"ul\", {\"id\": \"episode_related\"})\n    if episode_page_ul is None or isinstance(episode_page_ul, NavigableString):\n        msg = f\"Could not find any anime eposiodes with name {anime_name}\"\n        raise ValueError(msg)\n    episode_page_li = episode_page_ul.children\n\n    episode_list = []\n    for episode in episode_page_li:\n        if isinstance(episode, Tag):\n            url = episode.find(\"a\")\n            if url is None or isinstance(url, NavigableString):\n                continue\n            title = episode.find(\"div\", {\"class\": \"name\"})\n            if title is None or isinstance(title, NavigableString):\n                continue\n\n            episode_list.append(\n                {\"title\": title.text.replace(\" \", \"\"), \"url\": url[\"href\"]}\n            )\n\n    return episode_list\n\n\ndef get_anime_episode(episode_endpoint: str) -> list:\n    \"\"\"[summary]\n\n    Get click url and download url from episode url\n\n    >>> type(get_anime_episode(\"/watch/kimetsu-no-yaiba/1\"))\n    <class 'list'>\n\n    Args:\n        episode_endpoint (str): [Endpoint of episode]\n\n    Raises:\n        e: [description]\n\n    Returns:\n        [list]: [List of download and watch url]\n    \"\"\"\n\n    episode_page_url = f\"{BASE_URL}{episode_endpoint}\"\n\n    response = requests.get(\n        url=episode_page_url, headers={\"User-Agent\": UserAgent().chrome}, timeout=10\n    )\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    url = soup.find(\"iframe\", {\"id\": \"playerframe\"})\n    if url is None or isinstance(url, NavigableString):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n\n    episode_url = url[\"src\"]\n    if not isinstance(episode_url, str):\n        msg = f\"Could not find url and download url from {episode_endpoint}\"\n        raise RuntimeError(msg)\n    download_url = episode_url.replace(\"/embed/\", \"/playlist/\") + \".m3u8\"\n\n    return [f\"{BASE_URL}{episode_url}\", f\"{BASE_URL}{download_url}\"]\n\n\nif __name__ == \"__main__\":\n    anime_name = input(\"Enter anime name: \").strip()\n    anime_list = search_scraper(anime_name)\n    print(\"\\n\")\n\n    if len(anime_list) == 0:\n        print(\"No anime found with this name\")\n    else:\n        print(f\"Found {len(anime_list)} results: \")\n        for i, anime in enumerate(anime_list):\n            anime_title = anime[\"title\"]\n            print(f\"{i+1}. {anime_title}\")\n\n        anime_choice = int(input(\"\\nPlease choose from the following list: \").strip())\n        chosen_anime = anime_list[anime_choice - 1]\n        print(f\"You chose {chosen_anime['title']}. Searching for episodes...\")\n\n        episode_list = search_anime_episode_list(chosen_anime[\"url\"])\n        if len(episode_list) == 0:\n            print(\"No episode found for this anime\")\n        else:\n            print(f\"Found {len(episode_list)} results: \")\n            for i, episode in enumerate(episode_list):\n                print(f\"{i+1}. {episode['title']}\")\n\n            episode_choice = int(input(\"\\nChoose an episode by serial no: \").strip())\n            chosen_episode = episode_list[episode_choice - 1]\n            print(f\"You chose {chosen_episode['title']}. Searching...\")\n\n            episode_url, download_url = get_anime_episode(chosen_episode[\"url\"])\n            print(f\"\\nTo watch, ctrl+click on {episode_url}.\")\n            print(f\"To download, ctrl+click on {download_url}.\")\n", "web_programming/covid_stats_via_xpath.py": "\"\"\"\nThis is to show simple COVID19 info fetching from worldometers site using lxml\n* The main motivation to use lxml in place of bs4 is that it is faster and therefore\nmore convenient to use in Python web projects (e.g. Django or Flask-based)\n\"\"\"\n\nfrom typing import NamedTuple\n\nimport requests\nfrom lxml import html\n\n\nclass CovidData(NamedTuple):\n    cases: int\n    deaths: int\n    recovered: int\n\n\ndef covid_stats(url: str = \"https://www.worldometers.info/coronavirus/\") -> CovidData:\n    xpath_str = '//div[@class = \"maincounter-number\"]/span/text()'\n    return CovidData(\n        *html.fromstring(requests.get(url, timeout=10).content).xpath(xpath_str)\n    )\n\n\nfmt = \"\"\"Total COVID-19 cases in the world: {}\nTotal deaths due to COVID-19 in the world: {}\nTotal COVID-19 patients recovered in the world: {}\"\"\"\nprint(fmt.format(*covid_stats()))\n", "web_programming/fetch_jobs.py": "\"\"\"\nScraping jobs given job title and location from indeed website\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\n\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = \"https://www.indeed.co.in/jobs?q=mobile+app+development&l=\"\n\n\ndef fetch_jobs(location: str = \"mumbai\") -> Generator[tuple[str, str], None, None]:\n    soup = BeautifulSoup(\n        requests.get(url + location, timeout=10).content, \"html.parser\"\n    )\n    # This attribute finds out all the specifics listed in a job\n    for job in soup.find_all(\"div\", attrs={\"data-tn-component\": \"organicJob\"}):\n        job_title = job.find(\"a\", attrs={\"data-tn-element\": \"jobTitle\"}).text.strip()\n        company_name = job.find(\"span\", {\"class\": \"company\"}).text.strip()\n        yield job_title, company_name\n\n\nif __name__ == \"__main__\":\n    for i, job in enumerate(fetch_jobs(\"Bangalore\"), 1):\n        print(f\"Job {i:>2} is {job[0]} at {job[1]}\")\n", "web_programming/recaptcha_verification.py": "\"\"\"\nRecaptcha is a free captcha service offered by Google in order to secure websites and\nforms.  At https://www.google.com/recaptcha/admin/create you can create new recaptcha\nkeys and see the keys that your have already created.\n* Keep in mind that recaptcha doesn't work with localhost\nWhen you create a recaptcha key, your will get two separate keys: ClientKey & SecretKey.\nClientKey should be kept in your site's front end\nSecretKey should be kept in your site's  back end\n\n# An example HTML login form with recaptcha tag is shown below\n\n    <form action=\"\" method=\"post\">\n        <h2 class=\"text-center\">Log in</h2>\n        {% csrf_token %}\n        <div class=\"form-group\">\n            <input type=\"text\" name=\"username\" required=\"required\">\n        </div>\n        <div class=\"form-group\">\n            <input type=\"password\" name=\"password\" required=\"required\">\n        </div>\n        <div class=\"form-group\">\n            <button type=\"submit\">Log in</button>\n        </div>\n        <!-- Below is the recaptcha tag of html -->\n        <div class=\"g-recaptcha\" data-sitekey=\"ClientKey\"></div>\n    </form>\n\n    <!-- Below is the recaptcha script to be kept inside html tag -->\n    <script src=\"https://www.google.com/recaptcha/api.js\" async defer></script>\n\nBelow a Django function for the views.py file contains a login form for demonstrating\nrecaptcha verification.\n\"\"\"\n\nimport requests\n\ntry:\n    from django.contrib.auth import authenticate, login\n    from django.shortcuts import redirect, render\nexcept ImportError:\n    authenticate = login = render = redirect = print\n\n\ndef login_using_recaptcha(request):\n    # Enter your recaptcha secret key here\n    secret_key = \"secretKey\"  # noqa: S105\n    url = \"https://www.google.com/recaptcha/api/siteverify\"\n\n    # when method is not POST, direct user to login page\n    if request.method != \"POST\":\n        return render(request, \"login.html\")\n\n    # from the frontend, get username, password, and client_key\n    username = request.POST.get(\"username\")\n    password = request.POST.get(\"password\")\n    client_key = request.POST.get(\"g-recaptcha-response\")\n\n    # post recaptcha response to Google's recaptcha api\n    response = requests.post(\n        url, data={\"secret\": secret_key, \"response\": client_key}, timeout=10\n    )\n    # if the recaptcha api verified our keys\n    if response.json().get(\"success\", False):\n        # authenticate the user\n        user_in_database = authenticate(request, username=username, password=password)\n        if user_in_database:\n            login(request, user_in_database)\n            return redirect(\"/your-webpage\")\n    return render(request, \"login.html\")\n", "web_programming/get_top_hn_posts.py": "from __future__ import annotations\n\nimport requests\n\n\ndef get_hackernews_story(story_id: str) -> dict:\n    url = f\"https://hacker-news.firebaseio.com/v0/item/{story_id}.json?print=pretty\"\n    return requests.get(url, timeout=10).json()\n\n\ndef hackernews_top_stories(max_stories: int = 10) -> list[dict]:\n    \"\"\"\n    Get the top max_stories posts from HackerNews - https://news.ycombinator.com/\n    \"\"\"\n    url = \"https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty\"\n    story_ids = requests.get(url, timeout=10).json()[:max_stories]\n    return [get_hackernews_story(story_id) for story_id in story_ids]\n\n\ndef hackernews_top_stories_as_markdown(max_stories: int = 10) -> str:\n    stories = hackernews_top_stories(max_stories)\n    return \"\\n\".join(\"* [{title}]({url})\".format(**story) for story in stories)\n\n\nif __name__ == \"__main__\":\n    print(hackernews_top_stories_as_markdown())\n", "web_programming/__init__.py": "", "web_programming/fetch_quotes.py": "\"\"\"\nThis file fetches quotes from the \" ZenQuotes API \".\nIt does not require any API key as it uses free tier.\n\nFor more details and premium features visit:\n    https://zenquotes.io/\n\"\"\"\n\nimport pprint\n\nimport requests\n\nAPI_ENDPOINT_URL = \"https://zenquotes.io/api\"\n\n\ndef quote_of_the_day() -> list:\n    return requests.get(API_ENDPOINT_URL + \"/today\", timeout=10).json()\n\n\ndef random_quotes() -> list:\n    return requests.get(API_ENDPOINT_URL + \"/random\", timeout=10).json()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    response object has all the info with the quote\n    To retrieve the actual quote access the response.json() object as below\n    response.json() is a list of json object\n        response.json()[0]['q'] = actual quote.\n        response.json()[0]['a'] = author name.\n        response.json()[0]['h'] = in html format.\n    \"\"\"\n    response = random_quotes()\n    pprint.pprint(response)\n", "web_programming/random_anime_character.py": "import os\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\n\nheaders = {\"UserAgent\": UserAgent().random}\nURL = \"https://www.mywaifulist.moe/random\"\n\n\ndef save_image(image_url: str, image_title: str) -> None:\n    \"\"\"\n    Saves the image of anime character\n    \"\"\"\n    image = requests.get(image_url, headers=headers, timeout=10)\n    with open(image_title, \"wb\") as file:\n        file.write(image.content)\n\n\ndef random_anime_character() -> tuple[str, str, str]:\n    \"\"\"\n    Returns the Title, Description, and Image Title of a random anime character .\n    \"\"\"\n    soup = BeautifulSoup(\n        requests.get(URL, headers=headers, timeout=10).text, \"html.parser\"\n    )\n    title = soup.find(\"meta\", attrs={\"property\": \"og:title\"}).attrs[\"content\"]\n    image_url = soup.find(\"meta\", attrs={\"property\": \"og:image\"}).attrs[\"content\"]\n    description = soup.find(\"p\", id=\"description\").get_text()\n    _, image_extension = os.path.splitext(os.path.basename(image_url))\n    image_title = title.strip().replace(\" \", \"_\")\n    image_title = f\"{image_title}{image_extension}\"\n    save_image(image_url, image_title)\n    return (title, description, image_title)\n\n\nif __name__ == \"__main__\":\n    title, desc, image_title = random_anime_character()\n    print(f\"{title}\\n\\n{desc}\\n\\nImage saved : {image_title}\")\n", "web_programming/instagram_video.py": "from datetime import UTC, datetime\n\nimport requests\n\n\ndef download_video(url: str) -> bytes:\n    base_url = \"https://downloadgram.net/wp-json/wppress/video-downloader/video?url=\"\n    video_url = requests.get(base_url + url, timeout=10).json()[0][\"urls\"][0][\"src\"]\n    return requests.get(video_url, timeout=10).content\n\n\nif __name__ == \"__main__\":\n    url = input(\"Enter Video/IGTV url: \").strip()\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H:%M:%S}.mp4\"\n    with open(file_name, \"wb\") as fp:\n        fp.write(download_video(url))\n    print(f\"Done. Video saved to disk as {file_name}.\")\n", "web_programming/instagram_pic.py": "from datetime import UTC, datetime\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n\ndef download_image(url: str) -> str:\n    \"\"\"\n    Download an image from a given URL by scraping the 'og:image' meta tag.\n\n    Parameters:\n        url: The URL to scrape.\n\n    Returns:\n        A message indicating the result of the operation.\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        return f\"An error occurred during the HTTP request to {url}: {e!r}\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    image_meta_tag = soup.find(\"meta\", {\"property\": \"og:image\"})\n    if not image_meta_tag:\n        return \"No meta tag with property 'og:image' was found.\"\n\n    image_url = image_meta_tag.get(\"content\")\n    if not image_url:\n        return f\"Image URL not found in meta tag {image_meta_tag}.\"\n\n    try:\n        image_data = requests.get(image_url, timeout=10).content\n    except requests.exceptions.RequestException as e:\n        return f\"An error occurred during the HTTP request to {image_url}: {e!r}\"\n    if not image_data:\n        return f\"Failed to download the image from {image_url}.\"\n\n    file_name = f\"{datetime.now(tz=UTC).astimezone():%Y-%m-%d_%H:%M:%S}.jpg\"\n    with open(file_name, \"wb\") as out_file:\n        out_file.write(image_data)\n    return f\"Image downloaded and saved in the file {file_name}\"\n\n\nif __name__ == \"__main__\":\n    url = input(\"Enter image URL: \").strip() or \"https://www.instagram.com\"\n    print(f\"download_image({url}): {download_image(url)}\")\n", "geometry/geometry.py": "from __future__ import annotations\n\nimport math\nfrom dataclasses import dataclass, field\nfrom types import NoneType\nfrom typing import Self\n\n# Building block classes\n\n\n@dataclass\nclass Angle:\n    \"\"\"\n    An Angle in degrees (unit of measurement)\n\n    >>> Angle()\n    Angle(degrees=90)\n    >>> Angle(45.5)\n    Angle(degrees=45.5)\n    >>> Angle(-1)\n    Traceback (most recent call last):\n        ...\n    TypeError: degrees must be a numeric value between 0 and 360.\n    >>> Angle(361)\n    Traceback (most recent call last):\n        ...\n    TypeError: degrees must be a numeric value between 0 and 360.\n    \"\"\"\n\n    degrees: float = 90\n\n    def __post_init__(self) -> None:\n        if not isinstance(self.degrees, (int, float)) or not 0 <= self.degrees <= 360:\n            raise TypeError(\"degrees must be a numeric value between 0 and 360.\")\n\n\n@dataclass\nclass Side:\n    \"\"\"\n    A side of a two dimensional Shape such as Polygon, etc.\n    adjacent_sides: a list of sides which are adjacent to the current side\n    angle: the angle in degrees between each adjacent side\n    length: the length of the current side in meters\n\n    >>> Side(5)\n    Side(length=5, angle=Angle(degrees=90), next_side=None)\n    >>> Side(5, Angle(45.6))\n    Side(length=5, angle=Angle(degrees=45.6), next_side=None)\n    >>> Side(5, Angle(45.6), Side(1, Angle(2)))  # doctest: +ELLIPSIS\n    Side(length=5, angle=Angle(degrees=45.6), next_side=Side(length=1, angle=Angle(d...\n    \"\"\"\n\n    length: float\n    angle: Angle = field(default_factory=Angle)\n    next_side: Side | None = None\n\n    def __post_init__(self) -> None:\n        if not isinstance(self.length, (int, float)) or self.length <= 0:\n            raise TypeError(\"length must be a positive numeric value.\")\n        if not isinstance(self.angle, Angle):\n            raise TypeError(\"angle must be an Angle object.\")\n        if not isinstance(self.next_side, (Side, NoneType)):\n            raise TypeError(\"next_side must be a Side or None.\")\n\n\n@dataclass\nclass Ellipse:\n    \"\"\"\n    A geometric Ellipse on a 2D surface\n\n    >>> Ellipse(5, 10)\n    Ellipse(major_radius=5, minor_radius=10)\n    >>> Ellipse(5, 10) is Ellipse(5, 10)\n    False\n    >>> Ellipse(5, 10) == Ellipse(5, 10)\n    True\n    \"\"\"\n\n    major_radius: float\n    minor_radius: float\n\n    @property\n    def area(self) -> float:\n        \"\"\"\n        >>> Ellipse(5, 10).area\n        157.07963267948966\n        \"\"\"\n        return math.pi * self.major_radius * self.minor_radius\n\n    @property\n    def perimeter(self) -> float:\n        \"\"\"\n        >>> Ellipse(5, 10).perimeter\n        47.12388980384689\n        \"\"\"\n        return math.pi * (self.major_radius + self.minor_radius)\n\n\nclass Circle(Ellipse):\n    \"\"\"\n    A geometric Circle on a 2D surface\n\n    >>> Circle(5)\n    Circle(radius=5)\n    >>> Circle(5) is Circle(5)\n    False\n    >>> Circle(5) == Circle(5)\n    True\n    >>> Circle(5).area\n    78.53981633974483\n    >>> Circle(5).perimeter\n    31.41592653589793\n    \"\"\"\n\n    def __init__(self, radius: float) -> None:\n        super().__init__(radius, radius)\n        self.radius = radius\n\n    def __repr__(self) -> str:\n        return f\"Circle(radius={self.radius})\"\n\n    @property\n    def diameter(self) -> float:\n        \"\"\"\n        >>> Circle(5).diameter\n        10\n        \"\"\"\n        return self.radius * 2\n\n    def max_parts(self, num_cuts: float) -> float:\n        \"\"\"\n        Return the maximum number of parts that circle can be divided into if cut\n        'num_cuts' times.\n\n        >>> circle = Circle(5)\n        >>> circle.max_parts(0)\n        1.0\n        >>> circle.max_parts(7)\n        29.0\n        >>> circle.max_parts(54)\n        1486.0\n        >>> circle.max_parts(22.5)\n        265.375\n        >>> circle.max_parts(-222)\n        Traceback (most recent call last):\n            ...\n        TypeError: num_cuts must be a positive numeric value.\n        >>> circle.max_parts(\"-222\")\n        Traceback (most recent call last):\n            ...\n        TypeError: num_cuts must be a positive numeric value.\n        \"\"\"\n        if not isinstance(num_cuts, (int, float)) or num_cuts < 0:\n            raise TypeError(\"num_cuts must be a positive numeric value.\")\n        return (num_cuts + 2 + num_cuts**2) * 0.5\n\n\n@dataclass\nclass Polygon:\n    \"\"\"\n    An abstract class which represents Polygon on a 2D surface.\n\n    >>> Polygon()\n    Polygon(sides=[])\n    \"\"\"\n\n    sides: list[Side] = field(default_factory=list)\n\n    def add_side(self, side: Side) -> Self:\n        \"\"\"\n        >>> Polygon().add_side(Side(5))\n        Polygon(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None)])\n        \"\"\"\n        self.sides.append(side)\n        return self\n\n    def get_side(self, index: int) -> Side:\n        \"\"\"\n        >>> Polygon().get_side(0)\n        Traceback (most recent call last):\n            ...\n        IndexError: list index out of range\n        >>> Polygon().add_side(Side(5)).get_side(-1)\n        Side(length=5, angle=Angle(degrees=90), next_side=None)\n        \"\"\"\n        return self.sides[index]\n\n    def set_side(self, index: int, side: Side) -> Self:\n        \"\"\"\n        >>> Polygon().set_side(0, Side(5))\n        Traceback (most recent call last):\n            ...\n        IndexError: list assignment index out of range\n        >>> Polygon().add_side(Side(5)).set_side(0, Side(10))\n        Polygon(sides=[Side(length=10, angle=Angle(degrees=90), next_side=None)])\n        \"\"\"\n        self.sides[index] = side\n        return self\n\n\nclass Rectangle(Polygon):\n    \"\"\"\n    A geometric rectangle on a 2D surface.\n\n    >>> rectangle_one = Rectangle(5, 10)\n    >>> rectangle_one.perimeter()\n    30\n    >>> rectangle_one.area()\n    50\n    \"\"\"\n\n    def __init__(self, short_side_length: float, long_side_length: float) -> None:\n        super().__init__()\n        self.short_side_length = short_side_length\n        self.long_side_length = long_side_length\n        self.post_init()\n\n    def post_init(self) -> None:\n        \"\"\"\n        >>> Rectangle(5, 10)  # doctest: +NORMALIZE_WHITESPACE\n        Rectangle(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None),\n        Side(length=10, angle=Angle(degrees=90), next_side=None)])\n        \"\"\"\n        self.short_side = Side(self.short_side_length)\n        self.long_side = Side(self.long_side_length)\n        super().add_side(self.short_side)\n        super().add_side(self.long_side)\n\n    def perimeter(self) -> float:\n        return (self.short_side.length + self.long_side.length) * 2\n\n    def area(self) -> float:\n        return self.short_side.length * self.long_side.length\n\n\n@dataclass\nclass Square(Rectangle):\n    \"\"\"\n    a structure which represents a\n    geometrical square on a 2D surface\n    >>> square_one = Square(5)\n    >>> square_one.perimeter()\n    20\n    >>> square_one.area()\n    25\n    \"\"\"\n\n    def __init__(self, side_length: float) -> None:\n        super().__init__(side_length, side_length)\n\n    def perimeter(self) -> float:\n        return super().perimeter()\n\n    def area(self) -> float:\n        return super().area()\n\n\nif __name__ == \"__main__\":\n    __import__(\"doctest\").testmod()\n", "geometry/__init__.py": "", "maths/juggler_sequence.py": "\"\"\"\n== Juggler Sequence ==\nJuggler sequence start with any positive integer n. The next term is\nobtained as follows:\n    If n term is even, the next term is floor value of square root of n .\n    If n is odd, the next term is floor value of 3 time the square root of n.\n\nhttps://en.wikipedia.org/wiki/Juggler_sequence\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\nimport math\n\n\ndef juggler_sequence(number: int) -> list[int]:\n    \"\"\"\n    >>> juggler_sequence(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be a positive integer\n    >>> juggler_sequence(1)\n    [1]\n    >>> juggler_sequence(2)\n    [2, 1]\n    >>> juggler_sequence(3)\n    [3, 5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(5)\n    [5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(10)\n    [10, 3, 5, 11, 36, 6, 2, 1]\n    >>> juggler_sequence(25)\n    [25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1]\n    >>> juggler_sequence(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    >>> juggler_sequence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be a positive integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be a positive integer\"\n        raise ValueError(msg)\n    sequence = [number]\n    while number != 1:\n        if number % 2 == 0:\n            number = math.floor(math.sqrt(number))\n        else:\n            number = math.floor(\n                math.sqrt(number) * math.sqrt(number) * math.sqrt(number)\n            )\n        sequence.append(number)\n    return sequence\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/zellers_congruence.py": "import argparse\nimport datetime\n\n\ndef zeller(date_input: str) -> str:\n    \"\"\"\n    Zellers Congruence Algorithm\n    Find the day of the week for nearly any Gregorian or Julian calendar date\n\n    >>> zeller('01-31-2010')\n    'Your date 01-31-2010, is a Sunday!'\n\n    Validate out of range month\n    >>> zeller('13-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Month must be between 1 - 12\n    >>> zeller('.2-31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.2'\n\n    Validate out of range date:\n    >>> zeller('01-33-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date must be between 1 - 31\n    >>> zeller('01-.4-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: '.4'\n\n    Validate second separator:\n    >>> zeller('01-31*2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate first separator:\n    >>> zeller('01^31-2010')\n    Traceback (most recent call last):\n        ...\n    ValueError: Date separator must be '-' or '/'\n\n    Validate out of range year:\n    >>> zeller('01-31-8999')\n    Traceback (most recent call last):\n        ...\n    ValueError: Year out of range. There has to be some sort of limit...right?\n\n    Test null input:\n    >>> zeller()\n    Traceback (most recent call last):\n        ...\n    TypeError: zeller() missing 1 required positional argument: 'date_input'\n\n    Test length of date_input:\n    >>> zeller('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\n    >>> zeller('01-31-19082939')\n    Traceback (most recent call last):\n        ...\n    ValueError: Must be 10 characters long\"\"\"\n\n    # Days of the week for response\n    days = {\n        \"0\": \"Sunday\",\n        \"1\": \"Monday\",\n        \"2\": \"Tuesday\",\n        \"3\": \"Wednesday\",\n        \"4\": \"Thursday\",\n        \"5\": \"Friday\",\n        \"6\": \"Saturday\",\n    }\n\n    convert_datetime_days = {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 0}\n\n    # Validate\n    if not 0 < len(date_input) < 11:\n        raise ValueError(\"Must be 10 characters long\")\n\n    # Get month\n    m: int = int(date_input[0] + date_input[1])\n    # Validate\n    if not 0 < m < 13:\n        raise ValueError(\"Month must be between 1 - 12\")\n\n    sep_1: str = date_input[2]\n    # Validate\n    if sep_1 not in [\"-\", \"/\"]:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n\n    # Get day\n    d: int = int(date_input[3] + date_input[4])\n    # Validate\n    if not 0 < d < 32:\n        raise ValueError(\"Date must be between 1 - 31\")\n\n    # Get second separator\n    sep_2: str = date_input[5]\n    # Validate\n    if sep_2 not in [\"-\", \"/\"]:\n        raise ValueError(\"Date separator must be '-' or '/'\")\n\n    # Get year\n    y: int = int(date_input[6] + date_input[7] + date_input[8] + date_input[9])\n    # Arbitrary year range\n    if not 45 < y < 8500:\n        raise ValueError(\n            \"Year out of range. There has to be some sort of limit...right?\"\n        )\n\n    # Get datetime obj for validation\n    dt_ck = datetime.date(int(y), int(m), int(d))\n\n    # Start math\n    if m <= 2:\n        y = y - 1\n        m = m + 12\n    # maths var\n    c: int = int(str(y)[:2])\n    k: int = int(str(y)[2:])\n    t: int = int(2.6 * m - 5.39)\n    u: int = int(c / 4)\n    v: int = int(k / 4)\n    x: int = int(d + k)\n    z: int = int(t + u + v + x)\n    w: int = int(z - (2 * c))\n    f: int = round(w % 7)\n    # End math\n\n    # Validate math\n    if f != convert_datetime_days[dt_ck.weekday()]:\n        raise AssertionError(\"The date was evaluated incorrectly. Contact developer.\")\n\n    # Response\n    response: str = f\"Your date {date_input}, is a {days[str(f)]}!\"\n    return response\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    parser = argparse.ArgumentParser(\n        description=(\n            \"Find out what day of the week nearly any date is or was. Enter \"\n            \"date as a string in the mm-dd-yyyy or mm/dd/yyyy format\"\n        )\n    )\n    parser.add_argument(\n        \"date_input\", type=str, help=\"Date as a string (mm-dd-yyyy or mm/dd/yyyy)\"\n    )\n    args = parser.parse_args()\n    zeller(args.date_input)\n", "maths/hardy_ramanujanalgo.py": "# This theorem states that the number of prime factors of n\n# will be approximately log(log(n)) for most natural numbers n\n\nimport math\n\n\ndef exact_prime_factor_count(n: int) -> int:\n    \"\"\"\n    >>> exact_prime_factor_count(51242183)\n    3\n    \"\"\"\n    count = 0\n    if n % 2 == 0:\n        count += 1\n        while n % 2 == 0:\n            n = int(n / 2)\n    # the n input value must be odd so that\n    # we can skip one element (ie i += 2)\n\n    i = 3\n\n    while i <= int(math.sqrt(n)):\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n = int(n / i)\n        i = i + 2\n\n    # this condition checks the prime\n    # number n is greater than 2\n\n    if n > 2:\n        count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    n = 51242183\n    print(f\"The number of distinct prime factors is/are {exact_prime_factor_count(n)}\")\n    print(f\"The value of log(log(n)) is {math.log(math.log(n)):.4f}\")\n\n    \"\"\"\n    The number of distinct prime factors is/are 3\n    The value of log(log(n)) is 2.8765\n    \"\"\"\n", "maths/mobius_function.py": "\"\"\"\nReferences: https://en.wikipedia.org/wiki/M%C3%B6bius_function\nReferences: wikipedia:square free number\npsf/black : True\nruff : True\n\"\"\"\n\nfrom maths.is_square_free import is_square_free\nfrom maths.prime_factors import prime_factors\n\n\ndef mobius(n: int) -> int:\n    \"\"\"\n    Mobius function\n    >>> mobius(24)\n    0\n    >>> mobius(-1)\n    1\n    >>> mobius('asd')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> mobius(10**400)\n    0\n    >>> mobius(10**-400)\n    1\n    >>> mobius(-1424)\n    1\n    >>> mobius([1, '2', 2.0])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    factors = prime_factors(n)\n    if is_square_free(factors):\n        return -1 if len(factors) % 2 else 1\n    return 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/trapezoidal_rule.py": "\"\"\"\nNumerical integration or quadrature for a smooth function f with known values at x_i\n\nThis method is the classical approach of suming 'Equally Spaced Abscissas'\n\nmethod 1:\n\"extended trapezoidal rule\"\n\n\"\"\"\n\n\ndef method_1(boundary, steps):\n    # \"extended trapezoidal rule\"\n    # int(f) = dx/2 * (f1 + 2f2 + ... + fn)\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 2.0) * f(a)\n    for i in x_i:\n        # print(i)\n        y += h * f(i)\n    y += (h / 2.0) * f(b)\n    return y\n\n\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h\n\n\ndef f(x):  # enter your function here\n    y = (x - 0) * (x - 0)\n    return y\n\n\ndef main():\n    a = 0.0  # Lower bound of integration\n    b = 1.0  # Upper bound of integration\n    steps = 10.0  # define number of steps or resolution\n    boundary = [a, b]  # define boundary of integration\n    y = method_1(boundary, steps)\n    print(f\"y = {y}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/primelib.py": "\"\"\"\nCreated on Thu Oct  5 16:44:23 2017\n\n@author: Christian Bender\n\nThis Python library contains some useful functions to deal with\nprime numbers and whole numbers.\n\nOverview:\n\nis_prime(number)\nsieve_er(N)\nget_prime_numbers(N)\nprime_factorization(number)\ngreatest_prime_factor(number)\nsmallest_prime_factor(number)\nget_prime(n)\nget_primes_between(pNumber1, pNumber2)\n\n----\n\nis_even(number)\nis_odd(number)\nkg_v(number1, number2)  // least common multiple\nget_divisors(number)    // all divisors of 'number' inclusive 1, number\nis_perfect_number(number)\n\nNEW-FUNCTIONS\n\nsimplify_fraction(numerator, denominator)\nfactorial (n) // n!\nfib (n) // calculate the n-th fibonacci term.\n\n-----\n\ngoldbach(number)  // Goldbach's assumption\n\n\"\"\"\n\nfrom math import sqrt\n\nfrom maths.greatest_common_divisor import gcd_by_iterative\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"\n    input: positive integer 'number'\n    returns true if 'number' is prime otherwise false.\n\n    >>> is_prime(3)\n    True\n    >>> is_prime(10)\n    False\n    >>> is_prime(97)\n    True\n    >>> is_prime(9991)\n    False\n    >>> is_prime(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    >>> is_prime(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (\n        number >= 0\n    ), \"'number' must been an int and positive\"\n\n    status = True\n\n    # 0 and 1 are none primes.\n    if number <= 1:\n        status = False\n\n    for divisor in range(2, int(round(sqrt(number))) + 1):\n        # if 'number' divisible by 'divisor' then sets 'status'\n        # of false and break up the loop.\n        if number % divisor == 0:\n            status = False\n            break\n\n    # precondition\n    assert isinstance(status, bool), \"'status' must been from type bool\"\n\n    return status\n\n\n# ------------------------------------------\n\n\ndef sieve_er(n):\n    \"\"\"\n    input: positive integer 'N' > 2\n    returns a list of prime numbers from 2 up to N.\n\n    This function implements the algorithm called\n    sieve of erathostenes.\n\n    >>> sieve_er(8)\n    [2, 3, 5, 7]\n    >>> sieve_er(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    >>> sieve_er(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n > 2), \"'N' must been an int and > 2\"\n\n    # beginList: contains all natural numbers from 2 up to N\n    begin_list = list(range(2, n + 1))\n\n    ans = []  # this list will be returns.\n\n    # actual sieve of erathostenes\n    for i in range(len(begin_list)):\n        for j in range(i + 1, len(begin_list)):\n            if (begin_list[i] != 0) and (begin_list[j] % begin_list[i] == 0):\n                begin_list[j] = 0\n\n    # filters actual prime numbers.\n    ans = [x for x in begin_list if x != 0]\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans\n\n\n# --------------------------------\n\n\ndef get_prime_numbers(n):\n    \"\"\"\n    input: positive integer 'N' > 2\n    returns a list of prime numbers from 2 up to N (inclusive)\n    This function is more efficient as function 'sieveEr(...)'\n\n    >>> get_prime_numbers(8)\n    [2, 3, 5, 7]\n    >>> get_prime_numbers(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    >>> get_prime_numbers(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'N' must been an int and > 2\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n > 2), \"'N' must been an int and > 2\"\n\n    ans = []\n\n    # iterates over all numbers between 2 up to N+1\n    # if a number is prime then appends to list 'ans'\n    for number in range(2, n + 1):\n        if is_prime(number):\n            ans.append(number)\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans\n\n\n# -----------------------------------------\n\n\ndef prime_factorization(number):\n    \"\"\"\n    input: positive integer 'number'\n    returns a list of the prime number factors of 'number'\n\n    >>> prime_factorization(0)\n    [0]\n    >>> prime_factorization(8)\n    [2, 2, 2]\n    >>> prime_factorization(287)\n    [7, 41]\n    >>> prime_factorization(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> prime_factorization(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and number >= 0, \"'number' must been an int and >= 0\"\n\n    ans = []  # this list will be returns of the function.\n\n    # potential prime number factors.\n\n    factor = 2\n\n    quotient = number\n\n    if number in {0, 1}:\n        ans.append(number)\n\n    # if 'number' not prime then builds the prime factorization of 'number'\n    elif not is_prime(number):\n        while quotient != 1:\n            if is_prime(factor) and (quotient % factor == 0):\n                ans.append(factor)\n                quotient /= factor\n            else:\n                factor += 1\n\n    else:\n        ans.append(number)\n\n    # precondition\n    assert isinstance(ans, list), \"'ans' must been from type list\"\n\n    return ans\n\n\n# -----------------------------------------\n\n\ndef greatest_prime_factor(number):\n    \"\"\"\n    input: positive integer 'number' >= 0\n    returns the greatest prime number factor of 'number'\n\n    >>> greatest_prime_factor(0)\n    0\n    >>> greatest_prime_factor(8)\n    2\n    >>> greatest_prime_factor(287)\n    41\n    >>> greatest_prime_factor(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> greatest_prime_factor(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (\n        number >= 0\n    ), \"'number' must been an int and >= 0\"\n\n    ans = 0\n\n    # prime factorization of 'number'\n    prime_factors = prime_factorization(number)\n\n    ans = max(prime_factors)\n\n    # precondition\n    assert isinstance(ans, int), \"'ans' must been from type int\"\n\n    return ans\n\n\n# ----------------------------------------------\n\n\ndef smallest_prime_factor(number):\n    \"\"\"\n    input: integer 'number' >= 0\n    returns the smallest prime number factor of 'number'\n\n    >>> smallest_prime_factor(0)\n    0\n    >>> smallest_prime_factor(8)\n    2\n    >>> smallest_prime_factor(287)\n    7\n    >>> smallest_prime_factor(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    >>> smallest_prime_factor(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (\n        number >= 0\n    ), \"'number' must been an int and >= 0\"\n\n    ans = 0\n\n    # prime factorization of 'number'\n    prime_factors = prime_factorization(number)\n\n    ans = min(prime_factors)\n\n    # precondition\n    assert isinstance(ans, int), \"'ans' must been from type int\"\n\n    return ans\n\n\n# ----------------------\n\n\ndef is_even(number):\n    \"\"\"\n    input: integer 'number'\n    returns true if 'number' is even, otherwise false.\n\n    >>> is_even(0)\n    True\n    >>> is_even(8)\n    True\n    >>> is_even(287)\n    False\n    >>> is_even(-1)\n    False\n    >>> is_even(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int), \"'number' must been an int\"\n    assert isinstance(number % 2 == 0, bool), \"compare must been from type bool\"\n\n    return number % 2 == 0\n\n\n# ------------------------\n\n\ndef is_odd(number):\n    \"\"\"\n    input: integer 'number'\n    returns true if 'number' is odd, otherwise false.\n\n    >>> is_odd(0)\n    False\n    >>> is_odd(8)\n    False\n    >>> is_odd(287)\n    True\n    >>> is_odd(-1)\n    True\n    >>> is_odd(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int), \"'number' must been an int\"\n    assert isinstance(number % 2 != 0, bool), \"compare must been from type bool\"\n\n    return number % 2 != 0\n\n\n# ------------------------\n\n\ndef goldbach(number):\n    \"\"\"\n    Goldbach's assumption\n    input: a even positive integer 'number' > 2\n    returns a list of two prime numbers whose sum is equal to 'number'\n\n    >>> goldbach(8)\n    [3, 5]\n    >>> goldbach(824)\n    [3, 821]\n    >>> goldbach(0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    >>> goldbach(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    >>> goldbach(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int, even and > 2\n    \"\"\"\n\n    # precondition\n    assert (\n        isinstance(number, int) and (number > 2) and is_even(number)\n    ), \"'number' must been an int, even and > 2\"\n\n    ans = []  # this list will returned\n\n    # creates a list of prime numbers between 2 up to 'number'\n    prime_numbers = get_prime_numbers(number)\n    len_pn = len(prime_numbers)\n\n    # run variable for while-loops.\n    i = 0\n    j = None\n\n    # exit variable. for break up the loops\n    loop = True\n\n    while i < len_pn and loop:\n        j = i + 1\n\n        while j < len_pn and loop:\n            if prime_numbers[i] + prime_numbers[j] == number:\n                loop = False\n                ans.append(prime_numbers[i])\n                ans.append(prime_numbers[j])\n\n            j += 1\n\n        i += 1\n\n    # precondition\n    assert (\n        isinstance(ans, list)\n        and (len(ans) == 2)\n        and (ans[0] + ans[1] == number)\n        and is_prime(ans[0])\n        and is_prime(ans[1])\n    ), \"'ans' must contains two primes. And sum of elements must been eq 'number'\"\n\n    return ans\n\n\n# ----------------------------------------------\n\n\ndef kg_v(number1, number2):\n    \"\"\"\n    Least common multiple\n    input: two positive integer 'number1' and 'number2'\n    returns the least common multiple of 'number1' and 'number2'\n\n    >>> kg_v(8,10)\n    40\n    >>> kg_v(824,67)\n    55208\n    >>> kg_v(1, 10)\n    10\n    >>> kg_v(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: kg_v() missing 1 required positional argument: 'number2'\n    >>> kg_v(10,-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number1' and 'number2' must been positive integer.\n    >>> kg_v(\"test\",\"test2\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number1' and 'number2' must been positive integer.\n    \"\"\"\n\n    # precondition\n    assert (\n        isinstance(number1, int)\n        and isinstance(number2, int)\n        and (number1 >= 1)\n        and (number2 >= 1)\n    ), \"'number1' and 'number2' must been positive integer.\"\n\n    ans = 1  # actual answer that will be return.\n\n    # for kgV (x,1)\n    if number1 > 1 and number2 > 1:\n        # builds the prime factorization of 'number1' and 'number2'\n        prime_fac_1 = prime_factorization(number1)\n        prime_fac_2 = prime_factorization(number2)\n\n    elif number1 == 1 or number2 == 1:\n        prime_fac_1 = []\n        prime_fac_2 = []\n        ans = max(number1, number2)\n\n    count1 = 0\n    count2 = 0\n\n    done = []  # captured numbers int both 'primeFac1' and 'primeFac2'\n\n    # iterates through primeFac1\n    for n in prime_fac_1:\n        if n not in done:\n            if n in prime_fac_2:\n                count1 = prime_fac_1.count(n)\n                count2 = prime_fac_2.count(n)\n\n                for _ in range(max(count1, count2)):\n                    ans *= n\n\n            else:\n                count1 = prime_fac_1.count(n)\n\n                for _ in range(count1):\n                    ans *= n\n\n            done.append(n)\n\n    # iterates through primeFac2\n    for n in prime_fac_2:\n        if n not in done:\n            count2 = prime_fac_2.count(n)\n\n            for _ in range(count2):\n                ans *= n\n\n            done.append(n)\n\n    # precondition\n    assert isinstance(ans, int) and (\n        ans >= 0\n    ), \"'ans' must been from type int and positive\"\n\n    return ans\n\n\n# ----------------------------------\n\n\ndef get_prime(n):\n    \"\"\"\n    Gets the n-th prime number.\n    input: positive integer 'n' >= 0\n    returns the n-th prime number, beginning at index 0\n\n    >>> get_prime(0)\n    2\n    >>> get_prime(8)\n    23\n    >>> get_prime(824)\n    6337\n    >>> get_prime(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been a positive int\n    >>> get_prime(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been a positive int\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'number' must been a positive int\"\n\n    index = 0\n    ans = 2  # this variable holds the answer\n\n    while index < n:\n        index += 1\n\n        ans += 1  # counts to the next number\n\n        # if ans not prime then\n        # runs to the next prime number.\n        while not is_prime(ans):\n            ans += 1\n\n    # precondition\n    assert isinstance(ans, int) and is_prime(\n        ans\n    ), \"'ans' must been a prime number and from type int\"\n\n    return ans\n\n\n# ---------------------------------------------------\n\n\ndef get_primes_between(p_number_1, p_number_2):\n    \"\"\"\n    input: prime numbers 'pNumber1' and 'pNumber2'\n            pNumber1 < pNumber2\n    returns a list of all prime numbers between 'pNumber1' (exclusive)\n            and 'pNumber2' (exclusive)\n\n    >>> get_primes_between(3, 67)\n    [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    >>> get_primes_between(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: get_primes_between() missing 1 required positional argument: 'p_number_2'\n    >>> get_primes_between(0, 1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\n    >>> get_primes_between(-1, 3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    >>> get_primes_between(\"test\",\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and positive\n    \"\"\"\n\n    # precondition\n    assert (\n        is_prime(p_number_1) and is_prime(p_number_2) and (p_number_1 < p_number_2)\n    ), \"The arguments must been prime numbers and 'pNumber1' < 'pNumber2'\"\n\n    number = p_number_1 + 1  # jump to the next number\n\n    ans = []  # this list will be returns.\n\n    # if number is not prime then\n    # fetch the next prime number.\n    while not is_prime(number):\n        number += 1\n\n    while number < p_number_2:\n        ans.append(number)\n\n        number += 1\n\n        # fetch the next prime number.\n        while not is_prime(number):\n            number += 1\n\n    # precondition\n    assert (\n        isinstance(ans, list)\n        and ans[0] != p_number_1\n        and ans[len(ans) - 1] != p_number_2\n    ), \"'ans' must been a list without the arguments\"\n\n    # 'ans' contains not 'pNumber1' and 'pNumber2' !\n    return ans\n\n\n# ----------------------------------------------------\n\n\ndef get_divisors(n):\n    \"\"\"\n    input: positive integer 'n' >= 1\n    returns all divisors of n (inclusive 1 and 'n')\n\n    >>> get_divisors(8)\n    [1, 2, 4, 8]\n    >>> get_divisors(824)\n    [1, 2, 4, 8, 103, 206, 412, 824]\n    >>> get_divisors(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been int and >= 1\n    >>> get_divisors(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been int and >= 1\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 1), \"'n' must been int and >= 1\"\n\n    ans = []  # will be returned.\n\n    for divisor in range(1, n + 1):\n        if n % divisor == 0:\n            ans.append(divisor)\n\n    # precondition\n    assert ans[0] == 1 and ans[len(ans) - 1] == n, \"Error in function getDivisiors(...)\"\n\n    return ans\n\n\n# ----------------------------------------------------\n\n\ndef is_perfect_number(number):\n    \"\"\"\n    input: positive integer 'number' > 1\n    returns true if 'number' is a perfect number otherwise false.\n\n    >>> is_perfect_number(28)\n    True\n    >>> is_perfect_number(824)\n    False\n    >>> is_perfect_number(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 1\n    >>> is_perfect_number(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'number' must been an int and >= 1\n    \"\"\"\n\n    # precondition\n    assert isinstance(number, int) and (\n        number > 1\n    ), \"'number' must been an int and >= 1\"\n\n    divisors = get_divisors(number)\n\n    # precondition\n    assert (\n        isinstance(divisors, list)\n        and (divisors[0] == 1)\n        and (divisors[len(divisors) - 1] == number)\n    ), \"Error in help-function getDivisiors(...)\"\n\n    # summed all divisors up to 'number' (exclusive), hence [:-1]\n    return sum(divisors[:-1]) == number\n\n\n# ------------------------------------------------------------\n\n\ndef simplify_fraction(numerator, denominator):\n    \"\"\"\n    input: two integer 'numerator' and 'denominator'\n    assumes: 'denominator' != 0\n    returns: a tuple with simplify numerator and denominator.\n\n    >>> simplify_fraction(10, 20)\n    (1, 2)\n    >>> simplify_fraction(10, -1)\n    (10, -1)\n    >>> simplify_fraction(\"test\",\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: The arguments must been from type int and 'denominator' != 0\n    \"\"\"\n\n    # precondition\n    assert (\n        isinstance(numerator, int)\n        and isinstance(denominator, int)\n        and (denominator != 0)\n    ), \"The arguments must been from type int and 'denominator' != 0\"\n\n    # build the greatest common divisor of numerator and denominator.\n    gcd_of_fraction = gcd_by_iterative(abs(numerator), abs(denominator))\n\n    # precondition\n    assert (\n        isinstance(gcd_of_fraction, int)\n        and (numerator % gcd_of_fraction == 0)\n        and (denominator % gcd_of_fraction == 0)\n    ), \"Error in function gcd_by_iterative(...,...)\"\n\n    return (numerator // gcd_of_fraction, denominator // gcd_of_fraction)\n\n\n# -----------------------------------------------------------------\n\n\ndef factorial(n):\n    \"\"\"\n    input: positive integer 'n'\n    returns the factorial of 'n' (n!)\n\n    >>> factorial(0)\n    1\n    >>> factorial(20)\n    2432902008176640000\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been a int and >= 0\n    >>> factorial(\"test\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: 'n' must been a int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'n' must been a int and >= 0\"\n\n    ans = 1  # this will be return.\n\n    for factor in range(1, n + 1):\n        ans *= factor\n\n    return ans\n\n\n# -------------------------------------------------------------------\n\n\ndef fib(n: int) -> int:\n    \"\"\"\n    input: positive integer 'n'\n    returns the n-th fibonacci term , indexing by 0\n\n    >>> fib(0)\n    1\n    >>> fib(5)\n    8\n    >>> fib(20)\n    10946\n    >>> fib(99)\n    354224848179261915075\n    >>> fib(-1)\n    Traceback (most recent call last):\n    ...\n    AssertionError: 'n' must been an int and >= 0\n    >>> fib(\"test\")\n    Traceback (most recent call last):\n    ...\n    AssertionError: 'n' must been an int and >= 0\n    \"\"\"\n\n    # precondition\n    assert isinstance(n, int) and (n >= 0), \"'n' must been an int and >= 0\"\n\n    tmp = 0\n    fib1 = 1\n    ans = 1  # this will be return\n\n    for _ in range(n - 1):\n        tmp = ans\n        ans += fib1\n        fib1 = tmp\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/sum_of_geometric_progression.py": "def sum_of_geometric_progression(\n    first_term: int, common_ratio: int, num_of_terms: int\n) -> float:\n    \"\"\" \"\n    Return the sum of n terms in a geometric progression.\n    >>> sum_of_geometric_progression(1, 2, 10)\n    1023.0\n    >>> sum_of_geometric_progression(1, 10, 5)\n    11111.0\n    >>> sum_of_geometric_progression(0, 2, 10)\n    0.0\n    >>> sum_of_geometric_progression(1, 0, 10)\n    1.0\n    >>> sum_of_geometric_progression(1, 2, 0)\n    -0.0\n    >>> sum_of_geometric_progression(-1, 2, 10)\n    -1023.0\n    >>> sum_of_geometric_progression(1, -2, 10)\n    -341.0\n    >>> sum_of_geometric_progression(1, 2, -10)\n    -0.9990234375\n    \"\"\"\n    if common_ratio == 1:\n        # Formula for sum if common ratio is 1\n        return num_of_terms * first_term\n\n    # Formula for finding sum of n terms of a GeometricProgression\n    return (first_term / (1 - common_ratio)) * (1 - common_ratio**num_of_terms)\n", "maths/manhattan_distance.py": "def manhattan_distance(point_a: list, point_b: list) -> float:\n    \"\"\"\n    Expectts two list of numbers representing two points in the same\n    n-dimensional space\n\n    https://en.wikipedia.org/wiki/Taxicab_geometry\n\n    >>> manhattan_distance([1,1], [2,2])\n    2.0\n    >>> manhattan_distance([1.5,1.5], [2,2])\n    1.0\n    >>> manhattan_distance([1.5,1.5], [2.5,2])\n    1.5\n    >>> manhattan_distance([-3, -3, -3], [0, 0, 0])\n    9.0\n    >>> manhattan_distance([1,1], None)\n    Traceback (most recent call last):\n        ...\n    ValueError: Missing an input\n    >>> manhattan_distance([1,1], [2, 2, 2])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must be in the same n-dimensional space\n    >>> manhattan_distance([1,\"one\"], [2, 2, 2])\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> manhattan_distance(1, [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> manhattan_distance([1,1], \"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(a - b) for a, b in zip(point_a, point_b)))\n\n\ndef _validate_point(point: list[float]) -> None:\n    \"\"\"\n    >>> _validate_point(None)\n    Traceback (most recent call last):\n         ...\n    ValueError: Missing an input\n    >>> _validate_point([1,\"one\"])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> _validate_point(1)\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> _validate_point(\"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n    if point:\n        if isinstance(point, list):\n            for item in point:\n                if not isinstance(item, (int, float)):\n                    msg = (\n                        \"Expected a list of numbers as input, found \"\n                        f\"{type(item).__name__}\"\n                    )\n                    raise TypeError(msg)\n        else:\n            msg = f\"Expected a list of numbers as input, found {type(point).__name__}\"\n            raise TypeError(msg)\n    else:\n        raise ValueError(\"Missing an input\")\n\n\ndef manhattan_distance_one_liner(point_a: list, point_b: list) -> float:\n    \"\"\"\n    Version with one liner\n\n    >>> manhattan_distance_one_liner([1,1], [2,2])\n    2.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2,2])\n    1.0\n    >>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])\n    1.5\n    >>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])\n    9.0\n    >>> manhattan_distance_one_liner([1,1], None)\n    Traceback (most recent call last):\n         ...\n    ValueError: Missing an input\n    >>> manhattan_distance_one_liner([1,1], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    ValueError: Both points must be in the same n-dimensional space\n    >>> manhattan_distance_one_liner([1,\"one\"], [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    >>> manhattan_distance_one_liner(1, [2, 2, 2])\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found int\n    >>> manhattan_distance_one_liner([1,1], \"not_a_list\")\n    Traceback (most recent call last):\n         ...\n    TypeError: Expected a list of numbers as input, found str\n    \"\"\"\n\n    _validate_point(point_a)\n    _validate_point(point_b)\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must be in the same n-dimensional space\")\n\n    return float(sum(abs(x - y) for x, y in zip(point_a, point_b)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/modular_exponential.py": "\"\"\"\nModular Exponential.\nModular exponentiation is a type of exponentiation performed over a modulus.\nFor more explanation, please check\nhttps://en.wikipedia.org/wiki/Modular_exponentiation\n\"\"\"\n\n\"\"\"Calculate Modular Exponential.\"\"\"\n\n\ndef modular_exponential(base: int, power: int, mod: int):\n    \"\"\"\n    >>> modular_exponential(5, 0, 10)\n    1\n    >>> modular_exponential(2, 8, 7)\n    4\n    >>> modular_exponential(3, -2, 9)\n    -1\n    \"\"\"\n\n    if power < 0:\n        return -1\n    base %= mod\n    result = 1\n\n    while power > 0:\n        if power & 1:\n            result = (result * base) % mod\n        power = power >> 1\n        base = (base * base) % mod\n\n    return result\n\n\ndef main():\n    \"\"\"Call Modular Exponential Function.\"\"\"\n    print(modular_exponential(3, 200, 13))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    main()\n", "maths/triplet_sum.py": "\"\"\"\nGiven an array of integers and another integer target,\nwe are required to find a triplet from the array such that it's sum is equal to\nthe target.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom itertools import permutations\nfrom random import randint\nfrom timeit import repeat\n\n\ndef make_dataset() -> tuple[list[int], int]:\n    arr = [randint(-1000, 1000) for i in range(10)]\n    r = randint(-5000, 5000)\n    return (arr, r)\n\n\ndataset = make_dataset()\n\n\ndef triplet_sum1(arr: list[int], target: int) -> tuple[int, ...]:\n    \"\"\"\n    Returns a triplet in the array with sum equal to target,\n    else (0, 0, 0).\n    >>> triplet_sum1([13, 29, 7, 23, 5], 35)\n    (5, 7, 23)\n    >>> triplet_sum1([37, 9, 19, 50, 44], 65)\n    (9, 19, 37)\n    >>> arr = [6, 47, 27, 1, 15]\n    >>> target = 11\n    >>> triplet_sum1(arr, target)\n    (0, 0, 0)\n    \"\"\"\n    for triplet in permutations(arr, 3):\n        if sum(triplet) == target:\n            return tuple(sorted(triplet))\n    return (0, 0, 0)\n\n\ndef triplet_sum2(arr: list[int], target: int) -> tuple[int, int, int]:\n    \"\"\"\n    Returns a triplet in the array with sum equal to target,\n    else (0, 0, 0).\n    >>> triplet_sum2([13, 29, 7, 23, 5], 35)\n    (5, 7, 23)\n    >>> triplet_sum2([37, 9, 19, 50, 44], 65)\n    (9, 19, 37)\n    >>> arr = [6, 47, 27, 1, 15]\n    >>> target = 11\n    >>> triplet_sum2(arr, target)\n    (0, 0, 0)\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 1):\n        left, right = i + 1, n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return (arr[i], arr[left], arr[right])\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            elif arr[i] + arr[left] + arr[right] > target:\n                right -= 1\n    return (0, 0, 0)\n\n\ndef solution_times() -> tuple[float, float]:\n    setup_code = \"\"\"\nfrom __main__ import dataset, triplet_sum1, triplet_sum2\n\"\"\"\n    test_code1 = \"\"\"\ntriplet_sum1(*dataset)\n\"\"\"\n    test_code2 = \"\"\"\ntriplet_sum2(*dataset)\n\"\"\"\n    times1 = repeat(setup=setup_code, stmt=test_code1, repeat=5, number=10000)\n    times2 = repeat(setup=setup_code, stmt=test_code2, repeat=5, number=10000)\n    return (min(times1), min(times2))\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    times = solution_times()\n    print(f\"The time for naive implementation is {times[0]}.\")\n    print(f\"The time for optimized implementation is {times[1]}.\")\n", "maths/monte_carlo_dice.py": "from __future__ import annotations\n\nimport random\n\n\nclass Dice:\n    NUM_SIDES = 6\n\n    def __init__(self):\n        \"\"\"Initialize a six sided dice\"\"\"\n        self.sides = list(range(1, Dice.NUM_SIDES + 1))\n\n    def roll(self):\n        return random.choice(self.sides)\n\n\ndef throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:\n    \"\"\"\n    Return probability list of all possible sums when throwing dice.\n\n    >>> random.seed(0)\n    >>> throw_dice(10, 1)\n    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]\n    >>> throw_dice(100, 1)\n    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]\n    >>> throw_dice(1000, 1)\n    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]\n    >>> throw_dice(10000, 1)\n    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]\n    >>> throw_dice(10000, 2)\n    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]\n    \"\"\"\n    dices = [Dice() for i in range(num_dice)]\n    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)\n    for _ in range(num_throws):\n        count_of_sum[sum(dice.roll() for dice in dices)] += 1\n    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]\n    return probability[num_dice:]  # remove probability of sums that never appear\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/basic_maths.py": "\"\"\"Implementation of Basic Math in Python.\"\"\"\n\nimport math\n\n\ndef prime_factors(n: int) -> list:\n    \"\"\"Find Prime Factors.\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive integers have prime factors\n    >>> prime_factors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive integers have prime factors\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive integers have prime factors\")\n    pf = []\n    while n % 2 == 0:\n        pf.append(2)\n        n = int(n / 2)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            pf.append(i)\n            n = int(n / i)\n    if n > 2:\n        pf.append(n)\n    return pf\n\n\ndef number_of_divisors(n: int) -> int:\n    \"\"\"Calculate Number of Divisors of an Integer.\n    >>> number_of_divisors(100)\n    9\n    >>> number_of_divisors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> number_of_divisors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    div = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    div *= temp\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        div *= temp\n    if n > 1:\n        div *= 2\n    return div\n\n\ndef sum_of_divisors(n: int) -> int:\n    \"\"\"Calculate Sum of Divisors.\n    >>> sum_of_divisors(100)\n    217\n    >>> sum_of_divisors(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> sum_of_divisors(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = 1\n    temp = 1\n    while n % 2 == 0:\n        temp += 1\n        n = int(n / 2)\n    if temp > 1:\n        s *= (2**temp - 1) / (2 - 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        temp = 1\n        while n % i == 0:\n            temp += 1\n            n = int(n / i)\n        if temp > 1:\n            s *= (i**temp - 1) / (i - 1)\n    return int(s)\n\n\ndef euler_phi(n: int) -> int:\n    \"\"\"Calculate Euler's Phi Function.\n    >>> euler_phi(100)\n    40\n    >>> euler_phi(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    >>> euler_phi(-10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only positive numbers are accepted\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Only positive numbers are accepted\")\n    s = n\n    for x in set(prime_factors(n)):\n        s *= (x - 1) / x\n    return int(s)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/decimal_isolate.py": "\"\"\"\nIsolate the Decimal part of a Number\nhttps://stackoverflow.com/questions/3886402/how-to-get-numbers-after-decimal-point\n\"\"\"\n\n\ndef decimal_isolate(number: float, digit_amount: int) -> float:\n    \"\"\"\n    Isolates the decimal part of a number.\n    If digitAmount > 0 round to that decimal place, else print the entire decimal.\n    >>> decimal_isolate(1.53, 0)\n    0.53\n    >>> decimal_isolate(35.345, 1)\n    0.3\n    >>> decimal_isolate(35.345, 2)\n    0.34\n    >>> decimal_isolate(35.345, 3)\n    0.345\n    >>> decimal_isolate(-14.789, 3)\n    -0.789\n    >>> decimal_isolate(0, 2)\n    0\n    >>> decimal_isolate(-14.123, 1)\n    -0.1\n    >>> decimal_isolate(-14.123, 2)\n    -0.12\n    >>> decimal_isolate(-14.123, 3)\n    -0.123\n    \"\"\"\n    if digit_amount > 0:\n        return round(number - int(number), digit_amount)\n    return number - int(number)\n\n\nif __name__ == \"__main__\":\n    print(decimal_isolate(1.53, 0))\n    print(decimal_isolate(35.345, 1))\n    print(decimal_isolate(35.345, 2))\n    print(decimal_isolate(35.345, 3))\n    print(decimal_isolate(-14.789, 3))\n    print(decimal_isolate(0, 2))\n    print(decimal_isolate(-14.123, 1))\n    print(decimal_isolate(-14.123, 2))\n    print(decimal_isolate(-14.123, 3))\n", "maths/josephus_problem.py": "\"\"\"\nThe Josephus problem is a famous theoretical problem related to a certain\ncounting-out game. This module provides functions to solve the Josephus problem\nfor num_people and a step_size.\n\nThe Josephus problem is defined as follows:\n- num_people are standing in a circle.\n- Starting with a specified person, you count around the circle,\n  skipping a fixed number of people (step_size).\n- The person at which you stop counting is eliminated from the circle.\n- The counting continues until only one person remains.\n\nFor more information about the Josephus problem, refer to:\nhttps://en.wikipedia.org/wiki/Josephus_problem\n\"\"\"\n\n\ndef josephus_recursive(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size recursively.\n\n    Args:\n        num_people: A positive integer representing the number of people.\n        step_size: A positive integer representing the step size for elimination.\n\n    Returns:\n        The position of the last person remaining.\n\n    Raises:\n        ValueError: If num_people or step_size is not a positive integer.\n\n    Examples:\n        >>> josephus_recursive(7, 3)\n        3\n        >>> josephus_recursive(10, 2)\n        4\n        >>> josephus_recursive(0, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(1.9, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(-2, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(7, 0)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(7, -2)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(1_000, 0.01)\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n        >>> josephus_recursive(\"cat\", \"dog\")\n        Traceback (most recent call last):\n            ...\n        ValueError: num_people or step_size is not a positive integer.\n    \"\"\"\n    if (\n        not isinstance(num_people, int)\n        or not isinstance(step_size, int)\n        or num_people <= 0\n        or step_size <= 0\n    ):\n        raise ValueError(\"num_people or step_size is not a positive integer.\")\n\n    if num_people == 1:\n        return 0\n\n    return (josephus_recursive(num_people - 1, step_size) + step_size) % num_people\n\n\ndef find_winner(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Find the winner of the Josephus problem for num_people and a step_size.\n\n    Args:\n        num_people (int): Number of people.\n        step_size (int): Step size for elimination.\n\n    Returns:\n        int: The position of the last person remaining (1-based index).\n\n    Examples:\n        >>> find_winner(7, 3)\n        4\n        >>> find_winner(10, 2)\n        5\n    \"\"\"\n    return josephus_recursive(num_people, step_size) + 1\n\n\ndef josephus_iterative(num_people: int, step_size: int) -> int:\n    \"\"\"\n    Solve the Josephus problem for num_people and a step_size iteratively.\n\n    Args:\n        num_people (int): The number of people in the circle.\n        step_size (int): The number of steps to take before eliminating someone.\n\n    Returns:\n        int: The position of the last person standing.\n\n    Examples:\n        >>> josephus_iterative(5, 2)\n        3\n        >>> josephus_iterative(7, 3)\n        4\n    \"\"\"\n    circle = list(range(1, num_people + 1))\n    current = 0\n\n    while len(circle) > 1:\n        current = (current + step_size - 1) % len(circle)\n        circle.pop(current)\n\n    return circle[0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/continued_fraction.py": "\"\"\"\nFinding the continuous fraction for a rational number using python\n\nhttps://en.wikipedia.org/wiki/Continued_fraction\n\"\"\"\n\nfrom fractions import Fraction\nfrom math import floor\n\n\ndef continued_fraction(num: Fraction) -> list[int]:\n    \"\"\"\n    :param num:\n    Fraction of the number whose continued fractions to be found.\n    Use Fraction(str(number)) for more accurate results due to\n    float inaccuracies.\n\n    :return:\n    The continued fraction of rational number.\n    It is the all commas in the (n + 1)-tuple notation.\n\n    >>> continued_fraction(Fraction(2))\n    [2]\n    >>> continued_fraction(Fraction(\"3.245\"))\n    [3, 4, 12, 4]\n    >>> continued_fraction(Fraction(\"2.25\"))\n    [2, 4]\n    >>> continued_fraction(1/Fraction(\"2.25\"))\n    [0, 2, 4]\n    >>> continued_fraction(Fraction(\"415/93\"))\n    [4, 2, 6, 7]\n    >>> continued_fraction(Fraction(0))\n    [0]\n    >>> continued_fraction(Fraction(0.75))\n    [0, 1, 3]\n    >>> continued_fraction(Fraction(\"-2.25\"))    # -2.25 = -3 + 0.75\n    [-3, 1, 3]\n    \"\"\"\n    numerator, denominator = num.as_integer_ratio()\n    continued_fraction_list: list[int] = []\n    while True:\n        integer_part = floor(numerator / denominator)\n        continued_fraction_list.append(integer_part)\n        numerator -= integer_part * denominator\n        if numerator == 0:\n            break\n        numerator, denominator = denominator, numerator\n\n    return continued_fraction_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(\"Continued Fraction of 0.84375 is: \", continued_fraction(Fraction(\"0.84375\")))\n", "maths/find_max.py": "from __future__ import annotations\n\n\ndef find_max_iterative(nums: list[int | float]) -> int | float:\n    \"\"\"\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_iterative(nums) == max(nums)\n    True\n    True\n    True\n    True\n    >>> find_max_iterative([2, 4, 9, 7, 19, 94, 5])\n    94\n    >>> find_max_iterative([])\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_iterative() arg is an empty sequence\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_iterative() arg is an empty sequence\")\n    max_num = nums[0]\n    for x in nums:\n        if x > max_num:\n            max_num = x\n    return max_num\n\n\n# Divide and Conquer algorithm\ndef find_max_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find max value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: max in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)\n    True\n    >>> find_max_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_max_recursive() arg is an empty sequence\n    >>> find_max_recursive(nums, 0, len(nums)) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_max_recursive(nums, -len(nums), -1) == max(nums)\n    True\n    >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_max_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_max = find_max_recursive(nums, left, mid)  # find max in range[left, mid]\n    right_max = find_max_recursive(\n        nums, mid + 1, right\n    )  # find max in range[mid + 1, right]\n\n    return left_max if left_max >= right_max else right_max\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n", "maths/extended_euclidean_algorithm.py": "\"\"\"\nExtended Euclidean Algorithm.\n\nFinds 2 numbers a and b such that it satisfies\nthe equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\nhttps://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\"\"\"\n\n# @Author: S. Sharma <silentcat>\n# @Date:   2019-02-25T12:08:53-06:00\n# @Email:  silentcat@protonmail.com\n# @Last modified by:   pikulet\n# @Last modified time: 2020-10-02\nfrom __future__ import annotations\n\nimport sys\n\n\ndef extended_euclidean_algorithm(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n\n    Finds 2 numbers a and b such that it satisfies\n    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)\n\n    >>> extended_euclidean_algorithm(1, 24)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(8, 14)\n    (2, -1)\n\n    >>> extended_euclidean_algorithm(240, 46)\n    (-9, 47)\n\n    >>> extended_euclidean_algorithm(1, -4)\n    (1, 0)\n\n    >>> extended_euclidean_algorithm(-2, -4)\n    (-1, 0)\n\n    >>> extended_euclidean_algorithm(0, -4)\n    (0, -1)\n\n    >>> extended_euclidean_algorithm(2, 0)\n    (1, 0)\n\n    \"\"\"\n    # base cases\n    if abs(a) == 1:\n        return a, 0\n    elif abs(b) == 1:\n        return 0, b\n\n    old_remainder, remainder = a, b\n    old_coeff_a, coeff_a = 1, 0\n    old_coeff_b, coeff_b = 0, 1\n\n    while remainder != 0:\n        quotient = old_remainder // remainder\n        old_remainder, remainder = remainder, old_remainder - quotient * remainder\n        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a\n        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b\n\n    # sign correction for negative numbers\n    if a < 0:\n        old_coeff_a = -old_coeff_a\n    if b < 0:\n        old_coeff_b = -old_coeff_b\n\n    return old_coeff_a, old_coeff_b\n\n\ndef main():\n    \"\"\"Call Extended Euclidean Algorithm.\"\"\"\n    if len(sys.argv) < 3:\n        print(\"2 integer arguments required\")\n        return 1\n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n    print(extended_euclidean_algorithm(a, b))\n    return 0\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n", "maths/average_mode.py": "from typing import Any\n\n\ndef mode(input_list: list) -> list[Any]:\n    \"\"\"This function returns the mode(Mode as in the measures of\n    central tendency) of the input data.\n\n    The input list may contain any Datastructure or any Datatype.\n\n    >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])\n    [2]\n    >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])\n    [2, 4]\n    >>> mode([\"x\", \"y\", \"y\", \"z\"])\n    ['y']\n    >>> mode([\"x\", \"x\" , \"y\", \"y\", \"z\"])\n    ['x', 'y']\n    \"\"\"\n    if not input_list:\n        return []\n    result = [input_list.count(value) for value in input_list]\n    y = max(result)  # Gets the maximum count in the input list.\n    # Gets values of modes\n    return sorted({input_list[i] for i, value in enumerate(result) if value == y})\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/chebyshev_distance.py": "def chebyshev_distance(point_a: list[float], point_b: list[float]) -> float:\n    \"\"\"\n    This function calculates the Chebyshev distance (also known as the\n    Chessboard distance) between two n-dimensional points represented as lists.\n\n    https://en.wikipedia.org/wiki/Chebyshev_distance\n\n    >>> chebyshev_distance([1.0, 1.0], [2.0, 2.0])\n    1.0\n    >>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2])\n    14.2\n    >>> chebyshev_distance([1.0], [2.0, 2.0])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must have the same dimension.\")\n\n    return max(abs(a - b) for a, b in zip(point_a, point_b))\n", "maths/integer_square_root.py": "\"\"\"\nInteger Square Root Algorithm -- An efficient method to calculate the square root of a\nnon-negative integer 'num' rounded down to the nearest integer. It uses a binary search\napproach to find the integer square root without using any built-in exponent functions\nor operators.\n* https://en.wikipedia.org/wiki/Integer_square_root\n* https://docs.python.org/3/library/math.html#math.isqrt\nNote:\n    - This algorithm is designed for non-negative integers only.\n    - The result is rounded down to the nearest integer.\n    - The algorithm has a time complexity of O(log(x)).\n    - Original algorithm idea based on binary search.\n\"\"\"\n\n\ndef integer_square_root(num: int) -> int:\n    \"\"\"\n    Returns the integer square root of a non-negative integer num.\n    Args:\n        num: A non-negative integer.\n    Returns:\n        The integer square root of num.\n    Raises:\n        ValueError: If num is not an integer or is negative.\n    >>> [integer_square_root(i) for i in range(18)]\n    [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]\n    >>> integer_square_root(625)\n    25\n    >>> integer_square_root(2_147_483_647)\n    46340\n    >>> from math import isqrt\n    >>> all(integer_square_root(i) == isqrt(i) for i in range(20))\n    True\n    >>> integer_square_root(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(1.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    >>> integer_square_root(\"0\")\n    Traceback (most recent call last):\n        ...\n    ValueError: num must be non-negative integer\n    \"\"\"\n    if not isinstance(num, int) or num < 0:\n        raise ValueError(\"num must be non-negative integer\")\n\n    if num < 2:\n        return num\n\n    left_bound = 0\n    right_bound = num // 2\n\n    while left_bound <= right_bound:\n        mid = left_bound + (right_bound - left_bound) // 2\n        mid_squared = mid * mid\n        if mid_squared == num:\n            return mid\n\n        if mid_squared < num:\n            left_bound = mid + 1\n        else:\n            right_bound = mid - 1\n\n    return right_bound\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/binary_exponentiation.py": "\"\"\"\nBinary Exponentiation\n\nThis is a method to find a^b in O(log b) time complexity and is one of the most commonly\nused methods of exponentiation. The method is also useful for modular exponentiation,\nwhen the solution to (a^b) % c is required.\n\nTo calculate a^b:\n- If b is even, then a^b = (a * a)^(b / 2)\n- If b is odd, then a^b = a * a^(b - 1)\nRepeat until b = 1 or b = 0\n\nFor modular exponentiation, we use the fact that (a * b) % c = ((a % c) * (b % c)) % c\n\"\"\"\n\n\ndef binary_exp_recursive(base: float, exponent: int) -> float:\n    \"\"\"\n    Computes a^b recursively, where a is the base and b is the exponent\n\n    >>> binary_exp_recursive(3, 5)\n    243\n    >>> binary_exp_recursive(11, 13)\n    34522712143931\n    >>> binary_exp_recursive(-1, 3)\n    -1\n    >>> binary_exp_recursive(0, 5)\n    0\n    >>> binary_exp_recursive(3, 1)\n    3\n    >>> binary_exp_recursive(3, 0)\n    1\n    >>> binary_exp_recursive(1.5, 4)\n    5.0625\n    >>> binary_exp_recursive(3, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return binary_exp_recursive(base, exponent - 1) * base\n\n    b = binary_exp_recursive(base, exponent // 2)\n    return b * b\n\n\ndef binary_exp_iterative(base: float, exponent: int) -> float:\n    \"\"\"\n    Computes a^b iteratively, where a is the base and b is the exponent\n\n    >>> binary_exp_iterative(3, 5)\n    243\n    >>> binary_exp_iterative(11, 13)\n    34522712143931\n    >>> binary_exp_iterative(-1, 3)\n    -1\n    >>> binary_exp_iterative(0, 5)\n    0\n    >>> binary_exp_iterative(3, 1)\n    3\n    >>> binary_exp_iterative(3, 0)\n    1\n    >>> binary_exp_iterative(1.5, 4)\n    5.0625\n    >>> binary_exp_iterative(3, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res *= base\n\n        base *= base\n        exponent >>= 1\n\n    return res\n\n\ndef binary_exp_mod_recursive(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c recursively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_recursive(3, 4, 5)\n    1\n    >>> binary_exp_mod_recursive(11, 13, 7)\n    4\n    >>> binary_exp_mod_recursive(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_recursive(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_recursive(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    if exponent == 0:\n        return 1\n\n    if exponent % 2 == 1:\n        return (binary_exp_mod_recursive(base, exponent - 1, modulus) * base) % modulus\n\n    r = binary_exp_mod_recursive(base, exponent // 2, modulus)\n    return (r * r) % modulus\n\n\ndef binary_exp_mod_iterative(base: float, exponent: int, modulus: int) -> float:\n    \"\"\"\n    Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the\n    modulus\n\n    >>> binary_exp_mod_iterative(3, 4, 5)\n    1\n    >>> binary_exp_mod_iterative(11, 13, 7)\n    4\n    >>> binary_exp_mod_iterative(1.5, 4, 3)\n    2.0625\n    >>> binary_exp_mod_iterative(7, -1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Exponent must be a non-negative integer\n    >>> binary_exp_mod_iterative(7, 13, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Modulus must be a positive integer\n    \"\"\"\n    if exponent < 0:\n        raise ValueError(\"Exponent must be a non-negative integer\")\n    if modulus <= 0:\n        raise ValueError(\"Modulus must be a positive integer\")\n\n    res: int | float = 1\n    while exponent > 0:\n        if exponent & 1:\n            res = ((res % modulus) * (base % modulus)) % modulus\n\n        base *= base\n        exponent >>= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    from timeit import timeit\n\n    a = 1269380576\n    b = 374\n    c = 34\n\n    runs = 100_000\n    print(\n        timeit(\n            f\"binary_exp_recursive({a}, {b})\",\n            setup=\"from __main__ import binary_exp_recursive\",\n            number=runs,\n        )\n    )\n    print(\n        timeit(\n            f\"binary_exp_iterative({a}, {b})\",\n            setup=\"from __main__ import binary_exp_iterative\",\n            number=runs,\n        )\n    )\n    print(\n        timeit(\n            f\"binary_exp_mod_recursive({a}, {b}, {c})\",\n            setup=\"from __main__ import binary_exp_mod_recursive\",\n            number=runs,\n        )\n    )\n    print(\n        timeit(\n            f\"binary_exp_mod_iterative({a}, {b}, {c})\",\n            setup=\"from __main__ import binary_exp_mod_iterative\",\n            number=runs,\n        )\n    )\n", "maths/eulers_totient.py": "# Eulers Totient function finds the number of relative primes of a number n from 1 to n\ndef totient(n: int) -> list:\n    \"\"\"\n    >>> n = 10\n    >>> totient_calculation = totient(n)\n    >>> for i in range(1, n):\n    ...     print(f\"{i} has {totient_calculation[i]} relative primes.\")\n    1 has 0 relative primes.\n    2 has 1 relative primes.\n    3 has 2 relative primes.\n    4 has 2 relative primes.\n    5 has 4 relative primes.\n    6 has 2 relative primes.\n    7 has 6 relative primes.\n    8 has 4 relative primes.\n    9 has 6 relative primes.\n    \"\"\"\n    is_prime = [True for i in range(n + 1)]\n    totients = [i - 1 for i in range(n + 1)]\n    primes = []\n    for i in range(2, n + 1):\n        if is_prime[i]:\n            primes.append(i)\n        for j in range(len(primes)):\n            if i * primes[j] >= n:\n                break\n            is_prime[i * primes[j]] = False\n\n            if i % primes[j] == 0:\n                totients[i * primes[j]] = totients[i] * primes[j]\n                break\n\n            totients[i * primes[j]] = totients[i] * (primes[j] - 1)\n\n    return totients\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/is_square_free.py": "\"\"\"\nReferences: wikipedia:square free number\npsf/black : True\nruff : True\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef is_square_free(factors: list[int]) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes a list of prime factors as input.\n    returns True if the factors are square free.\n    >>> is_square_free([1, 1, 2, 3, 4])\n    False\n\n    These are wrong but should return some value\n    it simply checks for repetition in the numbers.\n    >>> is_square_free([1, 3, 4, 'sd', 0.0])\n    True\n\n    >>> is_square_free([1, 0.5, 2, 0.0])\n    True\n    >>> is_square_free([1, 2, 2, 5])\n    False\n    >>> is_square_free('asd')\n    True\n    >>> is_square_free(24)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'int' object is not iterable\n    \"\"\"\n    return len(set(factors)) == len(factors)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/prime_factors.py": "\"\"\"\npython/black : True\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef prime_factors(n: int) -> list[int]:\n    \"\"\"\n    Returns prime factors of n as a list.\n\n    >>> prime_factors(0)\n    []\n    >>> prime_factors(100)\n    [2, 2, 5, 5]\n    >>> prime_factors(2560)\n    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n    >>> prime_factors(10**-2)\n    []\n    >>> prime_factors(0.02)\n    []\n    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE\n    >>> x == [2]*241 + [5]*241\n    True\n    >>> prime_factors(10**-354)\n    []\n    >>> prime_factors('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> prime_factors([1,2,'hello'])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n\n    \"\"\"\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/persistence.py": "def multiplicative_persistence(num: int) -> int:\n    \"\"\"\n    Return the persistence of a given number.\n\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\n\n    >>> multiplicative_persistence(217)\n    2\n    >>> multiplicative_persistence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: multiplicative_persistence() does not accept negative values\n    >>> multiplicative_persistence(\"long number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: multiplicative_persistence() only accepts integral values\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise ValueError(\"multiplicative_persistence() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"multiplicative_persistence() does not accept negative values\")\n\n    steps = 0\n    num_string = str(num)\n\n    while len(num_string) != 1:\n        numbers = [int(i) for i in num_string]\n\n        total = 1\n        for i in range(len(numbers)):\n            total *= numbers[i]\n\n        num_string = str(total)\n\n        steps += 1\n    return steps\n\n\ndef additive_persistence(num: int) -> int:\n    \"\"\"\n    Return the persistence of a given number.\n\n    https://en.wikipedia.org/wiki/Persistence_of_a_number\n\n    >>> additive_persistence(199)\n    3\n    >>> additive_persistence(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: additive_persistence() does not accept negative values\n    >>> additive_persistence(\"long number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: additive_persistence() only accepts integral values\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise ValueError(\"additive_persistence() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"additive_persistence() does not accept negative values\")\n\n    steps = 0\n    num_string = str(num)\n\n    while len(num_string) != 1:\n        numbers = [int(i) for i in num_string]\n\n        total = 0\n        for i in range(len(numbers)):\n            total += numbers[i]\n\n        num_string = str(total)\n\n        steps += 1\n    return steps\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/fast_inverse_sqrt.py": "\"\"\"\nFast inverse square root (1/sqrt(x)) using the Quake III algorithm.\nReference: https://en.wikipedia.org/wiki/Fast_inverse_square_root\nAccuracy: https://en.wikipedia.org/wiki/Fast_inverse_square_root#Accuracy\n\"\"\"\n\nimport struct\n\n\ndef fast_inverse_sqrt(number: float) -> float:\n    \"\"\"\n    Compute the fast inverse square root of a floating-point number using the famous\n    Quake III algorithm.\n\n    :param float number: Input number for which to calculate the inverse square root.\n    :return float: The fast inverse square root of the input number.\n\n    Example:\n    >>> fast_inverse_sqrt(10)\n    0.3156857923527257\n    >>> fast_inverse_sqrt(4)\n    0.49915357479239103\n    >>> fast_inverse_sqrt(4.1)\n    0.4932849504615651\n    >>> fast_inverse_sqrt(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive number.\n    >>> fast_inverse_sqrt(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive number.\n    >>> from math import isclose, sqrt\n    >>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132)\n    ...     for i in range(50, 60))\n    True\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"Input must be a positive number.\")\n    i = struct.unpack(\">i\", struct.pack(\">f\", number))[0]\n    i = 0x5F3759DF - (i >> 1)\n    y = struct.unpack(\">f\", struct.pack(\">i\", i))[0]\n    return y * (1.5 - 0.5 * number * y * y)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    # https://en.wikipedia.org/wiki/Fast_inverse_square_root#Accuracy\n    from math import sqrt\n\n    for i in range(5, 101, 5):\n        print(f\"{i:>3}: {(1 / sqrt(i)) - fast_inverse_sqrt(i):.5f}\")\n", "maths/dual_number_automatic_differentiation.py": "from math import factorial\n\n\"\"\"\nhttps://en.wikipedia.org/wiki/Automatic_differentiation#Automatic_differentiation_using_dual_numbers\nhttps://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives.html\n\nNote this only works for basic functions, f(x) where the power of x is positive.\n\"\"\"\n\n\nclass Dual:\n    def __init__(self, real, rank):\n        self.real = real\n        if isinstance(rank, int):\n            self.duals = [1] * rank\n        else:\n            self.duals = rank\n\n    def __repr__(self):\n        return (\n            f\"{self.real}+\"\n            f\"{'+'.join(str(dual)+'E'+str(n+1)for n,dual in enumerate(self.duals))}\"\n        )\n\n    def reduce(self):\n        cur = self.duals.copy()\n        while cur[-1] == 0:\n            cur.pop(-1)\n        return Dual(self.real, cur)\n\n    def __add__(self, other):\n        if not isinstance(other, Dual):\n            return Dual(self.real + other, self.duals)\n        s_dual = self.duals.copy()\n        o_dual = other.duals.copy()\n        if len(s_dual) > len(o_dual):\n            o_dual.extend([1] * (len(s_dual) - len(o_dual)))\n        elif len(s_dual) < len(o_dual):\n            s_dual.extend([1] * (len(o_dual) - len(s_dual)))\n        new_duals = []\n        for i in range(len(s_dual)):\n            new_duals.append(s_dual[i] + o_dual[i])\n        return Dual(self.real + other.real, new_duals)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        return self + other * -1\n\n    def __mul__(self, other):\n        if not isinstance(other, Dual):\n            new_duals = []\n            for i in self.duals:\n                new_duals.append(i * other)\n            return Dual(self.real * other, new_duals)\n        new_duals = [0] * (len(self.duals) + len(other.duals) + 1)\n        for i, item in enumerate(self.duals):\n            for j, jtem in enumerate(other.duals):\n                new_duals[i + j + 1] += item * jtem\n        for k in range(len(self.duals)):\n            new_duals[k] += self.duals[k] * other.real\n        for index in range(len(other.duals)):\n            new_duals[index] += other.duals[index] * self.real\n        return Dual(self.real * other.real, new_duals)\n\n    __rmul__ = __mul__\n\n    def __truediv__(self, other):\n        if not isinstance(other, Dual):\n            new_duals = []\n            for i in self.duals:\n                new_duals.append(i / other)\n            return Dual(self.real / other, new_duals)\n        raise ValueError\n\n    def __floordiv__(self, other):\n        if not isinstance(other, Dual):\n            new_duals = []\n            for i in self.duals:\n                new_duals.append(i // other)\n            return Dual(self.real // other, new_duals)\n        raise ValueError\n\n    def __pow__(self, n):\n        if n < 0 or isinstance(n, float):\n            raise ValueError(\"power must be a positive integer\")\n        if n == 0:\n            return 1\n        if n == 1:\n            return self\n        x = self\n        for _ in range(n - 1):\n            x *= self\n        return x\n\n\ndef differentiate(func, position, order):\n    \"\"\"\n    >>> differentiate(lambda x: x**2, 2, 2)\n    2\n    >>> differentiate(lambda x: x**2 * x**4, 9, 2)\n    196830\n    >>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4)\n    7605.0\n    >>> differentiate(lambda y: y ** 2, 4, 3)\n    0\n    >>> differentiate(8, 8, 8)\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires a function as input for func\n    >>> differentiate(lambda x: x **2, \"\", 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires a float as input for position\n    >>> differentiate(lambda x: x**2, 3, \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: differentiate() requires an int as input for order\n    \"\"\"\n    if not callable(func):\n        raise ValueError(\"differentiate() requires a function as input for func\")\n    if not isinstance(position, (float, int)):\n        raise ValueError(\"differentiate() requires a float as input for position\")\n    if not isinstance(order, int):\n        raise ValueError(\"differentiate() requires an int as input for order\")\n    d = Dual(position, 1)\n    result = func(d)\n    if order == 0:\n        return result.real\n    return result.duals[order - 1] * factorial(order)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    def f(y):\n        return y**2 * y**4\n\n    print(differentiate(f, 9, 2))\n", "maths/bailey_borwein_plouffe.py": "def bailey_borwein_plouffe(digit_position: int, precision: int = 1000) -> str:\n    \"\"\"\n    Implement a popular pi-digit-extraction algorithm known as the\n    Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.\n    Wikipedia page:\n    https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n    @param digit_position: a positive integer representing the position of the digit to\n    extract.\n    The digit immediately after the decimal point is located at position 1.\n    @param precision: number of terms in the second summation to calculate.\n    A higher number reduces the chance of an error but increases the runtime.\n    @return: a hexadecimal digit representing the digit at the nth position\n    in pi's decimal expansion.\n\n    >>> \"\".join(bailey_borwein_plouffe(i) for i in range(1, 11))\n    '243f6a8885'\n    >>> bailey_borwein_plouffe(5, 10000)\n    '6'\n    >>> bailey_borwein_plouffe(-10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(1.7)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    >>> bailey_borwein_plouffe(2, -10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    >>> bailey_borwein_plouffe(2, 1.6)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    \"\"\"\n    if (not isinstance(digit_position, int)) or (digit_position <= 0):\n        raise ValueError(\"Digit position must be a positive integer\")\n    elif (not isinstance(precision, int)) or (precision < 0):\n        raise ValueError(\"Precision must be a nonnegative integer\")\n\n    # compute an approximation of (16 ** (n - 1)) * pi whose fractional part is mostly\n    # accurate\n    sum_result = (\n        4 * _subsum(digit_position, 1, precision)\n        - 2 * _subsum(digit_position, 4, precision)\n        - _subsum(digit_position, 5, precision)\n        - _subsum(digit_position, 6, precision)\n    )\n\n    # return the first hex digit of the fractional part of the result\n    return hex(int((sum_result % 1) * 16))[2:]\n\n\ndef _subsum(\n    digit_pos_to_extract: int, denominator_addend: int, precision: int\n) -> float:\n    # only care about first digit of fractional part; don't need decimal\n    \"\"\"\n    Private helper function to implement the summation\n    functionality.\n    @param digit_pos_to_extract: digit position to extract\n    @param denominator_addend: added to denominator of fractions in the formula\n    @param precision: same as precision in main function\n    @return: floating-point number whose integer part is not important\n    \"\"\"\n    total = 0.0\n    for sum_index in range(digit_pos_to_extract + precision):\n        denominator = 8 * sum_index + denominator_addend\n        if sum_index < digit_pos_to_extract:\n            # if the exponential term is an integer and we mod it by the denominator\n            # before dividing, only the integer part of the sum will change;\n            # the fractional part will not\n            exponential_term = pow(\n                16, digit_pos_to_extract - 1 - sum_index, denominator\n            )\n        else:\n            exponential_term = pow(16, digit_pos_to_extract - 1 - sum_index)\n        total += exponential_term / denominator\n    return total\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/entropy.py": "#!/usr/bin/env python3\n\n\"\"\"\nImplementation of entropy of information\nhttps://en.wikipedia.org/wiki/Entropy_(information_theory)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom string import ascii_lowercase\n\n\ndef calculate_prob(text: str) -> None:\n    \"\"\"\n    This method takes path and two dict as argument\n    and than calculates entropy of them.\n    :param dict:\n    :param dict:\n    :return: Prints\n    1) Entropy of information based on 1 alphabet\n    2) Entropy of information based on couples of 2 alphabet\n    3) print Entropy of H(X n|Xn-1)\n\n    Text from random books. Also, random quotes.\n    >>> text = (\"Behind Winston's back the voice \"\n    ...         \"from the telescreen was still \"\n    ...         \"babbling and the overfulfilment\")\n    >>> calculate_prob(text)\n    4.0\n    6.0\n    2.0\n\n    >>> text = (\"The Ministry of Truth\u2014Minitrue, in Newspeak [Newspeak was the official\"\n    ...         \"face in elegant lettering, the three\")\n    >>> calculate_prob(text)\n    4.0\n    5.0\n    1.0\n    >>> text = (\"Had repulsive dashwoods suspicion sincerity but advantage now him. \"\n    ...         \"Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. \"\n    ...         \"You greatest jointure saw horrible. He private he on be imagine \"\n    ...         \"suppose. Fertile beloved evident through no service elderly is. Blind \"\n    ...         \"there if every no so at. Own neglected you preferred way sincerity \"\n    ...         \"delivered his attempted. To of message cottage windows do besides \"\n    ...         \"against uncivil.  Delightful unreserved impossible few estimating \"\n    ...         \"men favourable see entreaties. She propriety immediate was improving. \"\n    ...         \"He or entrance humoured likewise moderate. Much nor game son say \"\n    ...         \"feel. Fat make met can must form into gate. Me we offending prevailed \"\n    ...         \"discovery.\")\n    >>> calculate_prob(text)\n    4.0\n    7.0\n    3.0\n    \"\"\"\n    single_char_strings, two_char_strings = analyze_text(text)\n    my_alphas = list(\" \" + ascii_lowercase)\n    # what is our total sum of probabilities.\n    all_sum = sum(single_char_strings.values())\n\n    # one length string\n    my_fir_sum = 0\n    # for each alpha we go in our dict and if it is in it we calculate entropy\n    for ch in my_alphas:\n        if ch in single_char_strings:\n            my_str = single_char_strings[ch]\n            prob = my_str / all_sum\n            my_fir_sum += prob * math.log2(prob)  # entropy formula.\n\n    # print entropy\n    print(f\"{round(-1 * my_fir_sum):.1f}\")\n\n    # two len string\n    all_sum = sum(two_char_strings.values())\n    my_sec_sum = 0\n    # for each alpha (two in size) calculate entropy.\n    for ch0 in my_alphas:\n        for ch1 in my_alphas:\n            sequence = ch0 + ch1\n            if sequence in two_char_strings:\n                my_str = two_char_strings[sequence]\n                prob = int(my_str) / all_sum\n                my_sec_sum += prob * math.log2(prob)\n\n    # print second entropy\n    print(f\"{round(-1 * my_sec_sum):.1f}\")\n\n    # print the difference between them\n    print(f\"{round((-1 * my_sec_sum) - (-1 * my_fir_sum)):.1f}\")\n\n\ndef analyze_text(text: str) -> tuple[dict, dict]:\n    \"\"\"\n    Convert text input into two dicts of counts.\n    The first dictionary stores the frequency of single character strings.\n    The second dictionary stores the frequency of two character strings.\n    \"\"\"\n    single_char_strings = Counter()  # type: ignore[var-annotated]\n    two_char_strings = Counter()  # type: ignore[var-annotated]\n    single_char_strings[text[-1]] += 1\n\n    # first case when we have space at start.\n    two_char_strings[\" \" + text[0]] += 1\n    for i in range(len(text) - 1):\n        single_char_strings[text[i]] += 1\n        two_char_strings[text[i : i + 2]] += 1\n    return single_char_strings, two_char_strings\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n    # text = (\n    #     \"Had repulsive dashwoods suspicion sincerity but advantage now him. Remark \"\n    #     \"easily garret nor nay. Civil those mrs enjoy shy fat merry. You greatest \"\n    #     \"jointure saw horrible. He private he on be imagine suppose. Fertile \"\n    #     \"beloved evident through no service elderly is. Blind there if every no so \"\n    #     \"at. Own neglected you preferred way sincerity delivered his attempted. To \"\n    #     \"of message cottage windows do besides against uncivil.  Delightful \"\n    #     \"unreserved impossible few estimating men favourable see entreaties. She \"\n    #     \"propriety immediate was improving. He or entrance humoured likewise \"\n    #     \"moderate. Much nor game son say feel. Fat make met can must form into \"\n    #     \"gate. Me we offending prevailed discovery. \"\n    # )\n\n    # calculate_prob(text)\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/perfect_cube.py": "def perfect_cube(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not.\n\n    >>> perfect_cube(27)\n    True\n    >>> perfect_cube(4)\n    False\n    \"\"\"\n    val = n ** (1 / 3)\n    return (val * val * val) == n\n\n\ndef perfect_cube_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect cube or not using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_cube_binary_search(27)\n    True\n    >>> perfect_cube_binary_search(64)\n    True\n    >>> perfect_cube_binary_search(4)\n    False\n    >>> perfect_cube_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    >>> perfect_cube_binary_search(0.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: perfect_cube_binary_search() only accepts integers\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"perfect_cube_binary_search() only accepts integers\")\n    if n < 0:\n        n = -n\n    left = 0\n    right = n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid * mid == n:\n            return True\n        elif mid * mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/sin.py": "\"\"\"\nCalculate sin function.\n\nIt's not a perfect function so I am rounding the result to 10 decimal places by default.\n\nFormula: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...\nWhere: x = angle in randians.\n\nSource:\n    https://www.homeschoolmath.net/teaching/sine_calculator.php\n\n\"\"\"\n\nfrom math import factorial, radians\n\n\ndef sin(\n    angle_in_degrees: float, accuracy: int = 18, rounded_values_count: int = 10\n) -> float:\n    \"\"\"\n    Implement sin function.\n\n    >>> sin(0.0)\n    0.0\n    >>> sin(90.0)\n    1.0\n    >>> sin(180.0)\n    0.0\n    >>> sin(270.0)\n    -1.0\n    >>> sin(0.68)\n    0.0118679603\n    >>> sin(1.97)\n    0.0343762121\n    >>> sin(64.0)\n    0.8987940463\n    >>> sin(9999.0)\n    -0.9876883406\n    >>> sin(-689.0)\n    0.5150380749\n    >>> sin(89.7)\n    0.9999862922\n    \"\"\"\n    # Simplify the angle to be between 360 and -360 degrees.\n    angle_in_degrees = angle_in_degrees - ((angle_in_degrees // 360.0) * 360.0)\n\n    # Converting from degrees to radians\n    angle_in_radians = radians(angle_in_degrees)\n\n    result = angle_in_radians\n    a = 3\n    b = -1\n\n    for _ in range(accuracy):\n        result += (b * (angle_in_radians**a)) / factorial(a)\n\n        b = -b  # One positive term and the next will be negative and so on...\n        a += 2  # Increased by 2 for every term.\n\n    return round(result, rounded_values_count)\n\n\nif __name__ == \"__main__\":\n    __import__(\"doctest\").testmod()\n", "maths/ceil.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\n\"\"\"\n\n\ndef ceil(x: float) -> int:\n    \"\"\"\n    Return the ceiling of x as an Integral.\n\n    :param x: the number\n    :return: the smallest integer >= x.\n\n    >>> import math\n    >>> all(ceil(n) == math.ceil(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) <= 0 else int(x) + 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/euclidean_distance.py": "from __future__ import annotations\n\nimport typing\nfrom collections.abc import Iterable\n\nimport numpy as np\n\nVector = typing.Union[Iterable[float], Iterable[int], np.ndarray]  # noqa: UP007\nVectorOut = typing.Union[np.float64, int, float]  # noqa: UP007\n\n\ndef euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> euclidean_distance((0, 0), (2, 2))\n    2.8284271247461903\n    >>> euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2]))\n    3.4641016151377544\n    >>> euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]))\n    8.0\n    >>> euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8])\n    8.0\n    \"\"\"\n    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))\n\n\ndef euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:\n    \"\"\"\n    Calculate the distance between the two endpoints of two vectors without numpy.\n    A vector is defined as a list, tuple, or numpy 1D array.\n    >>> euclidean_distance_no_np((0, 0), (2, 2))\n    2.8284271247461903\n    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])\n    8.0\n    \"\"\"\n    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)\n\n\nif __name__ == \"__main__\":\n\n    def benchmark() -> None:\n        \"\"\"\n        Benchmarks\n        \"\"\"\n        from timeit import timeit\n\n        print(\"Without Numpy\")\n        print(\n            timeit(\n                \"euclidean_distance_no_np([1, 2, 3], [4, 5, 6])\",\n                number=10000,\n                globals=globals(),\n            )\n        )\n        print(\"With Numpy\")\n        print(\n            timeit(\n                \"euclidean_distance([1, 2, 3], [4, 5, 6])\",\n                number=10000,\n                globals=globals(),\n            )\n        )\n\n    benchmark()\n", "maths/lucas_series.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Lucas_number\n\"\"\"\n\n\ndef recursive_lucas_number(n_th_number: int) -> int:\n    \"\"\"\n    Returns the nth lucas number\n    >>> recursive_lucas_number(1)\n    1\n    >>> recursive_lucas_number(20)\n    15127\n    >>> recursive_lucas_number(0)\n    2\n    >>> recursive_lucas_number(25)\n    167761\n    >>> recursive_lucas_number(-1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: recursive_lucas_number accepts only integer arguments.\n    \"\"\"\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"recursive_lucas_number accepts only integer arguments.\")\n    if n_th_number == 0:\n        return 2\n    if n_th_number == 1:\n        return 1\n\n    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(\n        n_th_number - 2\n    )\n\n\ndef dynamic_lucas_number(n_th_number: int) -> int:\n    \"\"\"\n    Returns the nth lucas number\n    >>> dynamic_lucas_number(1)\n    1\n    >>> dynamic_lucas_number(20)\n    15127\n    >>> dynamic_lucas_number(0)\n    2\n    >>> dynamic_lucas_number(25)\n    167761\n    >>> dynamic_lucas_number(-1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: dynamic_lucas_number accepts only integer arguments.\n    \"\"\"\n    if not isinstance(n_th_number, int):\n        raise TypeError(\"dynamic_lucas_number accepts only integer arguments.\")\n    a, b = 2, 1\n    for _ in range(n_th_number):\n        a, b = b, a + b\n    return a\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    n = int(input(\"Enter the number of terms in lucas series:\\n\").strip())\n    print(\"Using recursive function to calculate lucas series:\")\n    print(\" \".join(str(recursive_lucas_number(i)) for i in range(n)))\n    print(\"\\nUsing dynamic function to calculate lucas series:\")\n    print(\" \".join(str(dynamic_lucas_number(i)) for i in range(n)))\n", "maths/twin_prime.py": "\"\"\"\n== Twin Prime ==\nA number n+2 is said to be a Twin prime of number n if\nboth n and n+2 are prime.\n\nExamples of Twin pairs: (3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), ...\nhttps://en.wikipedia.org/wiki/Twin_prime\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\nfrom maths.prime_check import is_prime\n\n\ndef twin_prime(number: int) -> int:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns n+2 if n and n+2 are prime numbers and -1 otherwise.\n    >>> twin_prime(3)\n    5\n    >>> twin_prime(4)\n    -1\n    >>> twin_prime(5)\n    7\n    >>> twin_prime(17)\n    19\n    >>> twin_prime(0)\n    -1\n    >>> twin_prime(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if is_prime(number) and is_prime(number + 2):\n        return number + 2\n    else:\n        return -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/matrix_exponentiation.py": "\"\"\"Matrix Exponentiation\"\"\"\n\nimport timeit\n\n\"\"\"\nMatrix Exponentiation is a technique to solve linear recurrences in logarithmic time.\nYou read more about it here:\nhttps://zobayer.blogspot.com/2010/11/matrix-exponentiation.html\nhttps://www.hackerearth.com/practice/notes/matrix-exponentiation-1/\n\"\"\"\n\n\nclass Matrix:\n    def __init__(self, arg):\n        if isinstance(arg, list):  # Initializes a matrix identical to the one provided.\n            self.t = arg\n            self.n = len(arg)\n        else:  # Initializes a square matrix of the given size and set values to zero.\n            self.n = arg\n            self.t = [[0 for _ in range(self.n)] for _ in range(self.n)]\n\n    def __mul__(self, b):\n        matrix = Matrix(self.n)\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(self.n):\n                    matrix.t[i][j] += self.t[i][k] * b.t[k][j]\n        return matrix\n\n\ndef modular_exponentiation(a, b):\n    matrix = Matrix([[1, 0], [0, 1]])\n    while b > 0:\n        if b & 1:\n            matrix *= a\n        a *= a\n        b >>= 1\n    return matrix\n\n\ndef fibonacci_with_matrix_exponentiation(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n    matrix = Matrix([[1, 1], [1, 0]])\n    matrix = modular_exponentiation(matrix, n - 2)\n    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]\n\n\ndef simple_fibonacci(n, f1, f2):\n    # Trivial Cases\n    if n == 1:\n        return f1\n    elif n == 2:\n        return f2\n\n    fn_1 = f1\n    fn_2 = f2\n    n -= 2\n\n    while n > 0:\n        fn_1, fn_2 = fn_1 + fn_2, fn_1\n        n -= 1\n\n    return fn_1\n\n\ndef matrix_exponentiation_time():\n    setup = \"\"\"\nfrom random import randint\nfrom __main__ import fibonacci_with_matrix_exponentiation\n\"\"\"\n    code = \"fibonacci_with_matrix_exponentiation(randint(1,70000), 1, 1)\"\n    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)\n    print(\"With matrix exponentiation the average execution time is \", exec_time / 100)\n    return exec_time\n\n\ndef simple_fibonacci_time():\n    setup = \"\"\"\nfrom random import randint\nfrom __main__ import simple_fibonacci\n\"\"\"\n    code = \"simple_fibonacci(randint(1,70000), 1, 1)\"\n    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)\n    print(\n        \"Without matrix exponentiation the average execution time is \", exec_time / 100\n    )\n    return exec_time\n\n\ndef main():\n    matrix_exponentiation_time()\n    simple_fibonacci_time()\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/binary_multiplication.py": "\"\"\"\nBinary Multiplication\nThis is a method to find a*b in a time complexity of O(log b)\nThis is one of the most commonly used methods of finding result of multiplication.\nAlso useful in cases where solution to (a*b)%c is required,\nwhere a,b,c can be numbers over the computers calculation limits.\nDone using iteration, can also be done using recursion\n\nLet's say you need to calculate a * b\nRULE 1 : a * b = (a+a) * (b/2) ---- example : 4 * 4 = (4+4) * (4/2) = 8 * 2\nRULE 2 : IF b is odd, then ---- a * b = a + (a * (b - 1)), where (b - 1) is even.\nOnce b is even, repeat the process to get a * b\nRepeat the process until b = 1 or b = 0, because a*1 = a and a*0 = 0\n\nAs far as the modulo is concerned,\nthe fact : (a+b) % c = ((a%c) + (b%c)) % c\nNow apply RULE 1 or 2, whichever is required.\n\n@author chinmoy159\n\"\"\"\n\n\ndef binary_multiply(a: int, b: int) -> int:\n    \"\"\"\n    Multiply 'a' and 'b' using bitwise multiplication.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: a * b\n\n    Examples:\n    >>> binary_multiply(2, 3)\n    6\n    >>> binary_multiply(5, 0)\n    0\n    >>> binary_multiply(3, 4)\n    12\n    >>> binary_multiply(10, 5)\n    50\n    >>> binary_multiply(0, 5)\n    0\n    >>> binary_multiply(2, 1)\n    2\n    >>> binary_multiply(1, 10)\n    10\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res += a\n\n        a += a\n        b >>= 1\n\n    return res\n\n\ndef binary_mod_multiply(a: int, b: int, modulus: int) -> int:\n    \"\"\"\n    Calculate (a * b) % c using binary multiplication and modular arithmetic.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    modulus (int): The modulus.\n\n    Returns:\n    int: (a * b) % modulus.\n\n    Examples:\n    >>> binary_mod_multiply(2, 3, 5)\n    1\n    >>> binary_mod_multiply(5, 0, 7)\n    0\n    >>> binary_mod_multiply(3, 4, 6)\n    0\n    >>> binary_mod_multiply(10, 5, 13)\n    11\n    >>> binary_mod_multiply(2, 1, 5)\n    2\n    >>> binary_mod_multiply(1, 10, 3)\n    1\n    \"\"\"\n    res = 0\n    while b > 0:\n        if b & 1:\n            res = ((res % modulus) + (a % modulus)) % modulus\n\n        a += a\n        b >>= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/area_under_curve.py": "\"\"\"\nApproximates the area under the curve using the trapezoidal rule\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> f\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\"\n    '10.000'\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> f\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\"\n    '192.0000'\n    >>> f\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\"\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3 + x**2\n\n    print(\"f(x) = x^3 + x^2\")\n    print(\"The area between the curve, x = -5, x = 5 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\")\n        i *= 10\n", "maths/double_factorial.py": "def double_factorial_recursive(n: int) -> int:\n    \"\"\"\n    Compute double factorial using recursive method.\n    Recursion can be costly for large numbers.\n\n    To learn about the theory behind this algorithm:\n    https://en.wikipedia.org/wiki/Double_factorial\n\n    >>> from math import prod\n    >>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20))\n    True\n    >>> double_factorial_recursive(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_recursive() only accepts integral values\n    >>> double_factorial_recursive(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_recursive() not defined for negative values\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"double_factorial_recursive() only accepts integral values\")\n    if n < 0:\n        raise ValueError(\"double_factorial_recursive() not defined for negative values\")\n    return 1 if n <= 1 else n * double_factorial_recursive(n - 2)\n\n\ndef double_factorial_iterative(num: int) -> int:\n    \"\"\"\n    Compute double factorial using iterative method.\n\n    To learn about the theory behind this algorithm:\n    https://en.wikipedia.org/wiki/Double_factorial\n\n    >>> from math import prod\n    >>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20))\n    True\n    >>> double_factorial_iterative(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_iterative() only accepts integral values\n    >>> double_factorial_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: double_factorial_iterative() not defined for negative values\n    \"\"\"\n    if not isinstance(num, int):\n        raise ValueError(\"double_factorial_iterative() only accepts integral values\")\n    if num < 0:\n        raise ValueError(\"double_factorial_iterative() not defined for negative values\")\n    value = 1\n    for i in range(num, 0, -2):\n        value *= i\n    return value\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/sum_of_digits.py": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number.\n    >>> sum_of_digits(12345)\n    15\n    >>> sum_of_digits(123)\n    6\n    >>> sum_of_digits(-123)\n    6\n    >>> sum_of_digits(0)\n    0\n    \"\"\"\n    n = abs(n)\n    res = 0\n    while n > 0:\n        res += n % 10\n        n //= 10\n    return res\n\n\ndef sum_of_digits_recursion(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number using recursion\n    >>> sum_of_digits_recursion(12345)\n    15\n    >>> sum_of_digits_recursion(123)\n    6\n    >>> sum_of_digits_recursion(-123)\n    6\n    >>> sum_of_digits_recursion(0)\n    0\n    \"\"\"\n    n = abs(n)\n    return n if n < 10 else n % 10 + sum_of_digits(n // 10)\n\n\ndef sum_of_digits_compact(n: int) -> int:\n    \"\"\"\n    Find the sum of digits of a number\n    >>> sum_of_digits_compact(12345)\n    15\n    >>> sum_of_digits_compact(123)\n    6\n    >>> sum_of_digits_compact(-123)\n    6\n    >>> sum_of_digits_compact(0)\n    0\n    \"\"\"\n    return sum(int(c) for c in str(abs(n)))\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call:56} = {func(value)} -- {timing:.4f} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (sum_of_digits, sum_of_digits_recursion, sum_of_digits_compact):\n            benchmark_a_function(func, value)\n        print()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "maths/kth_lexicographic_permutation.py": "def kth_permutation(k, n):\n    \"\"\"\n    Finds k'th lexicographic permutation (in increasing order) of\n    0,1,2,...n-1 in O(n^2) time.\n\n    Examples:\n    First permutation is always 0,1,2,...n\n    >>> kth_permutation(0,5)\n    [0, 1, 2, 3, 4]\n\n    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],\n    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],\n    [1,2,3,0], [1,3,0,2]\n    >>> kth_permutation(10,4)\n    [1, 3, 0, 2]\n    \"\"\"\n    # Factorails from 1! to (n-1)!\n    factorials = [1]\n    for i in range(2, n):\n        factorials.append(factorials[-1] * i)\n    assert 0 <= k < factorials[-1] * n, \"k out of bounds\"\n\n    permutation = []\n    elements = list(range(n))\n\n    # Find permutation\n    while factorials:\n        factorial = factorials.pop()\n        number, k = divmod(k, factorial)\n        permutation.append(elements[number])\n        elements.remove(elements[number])\n    permutation.append(elements[0])\n\n    return permutation\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/odd_sieve.py": "from itertools import compress, repeat\nfrom math import ceil, sqrt\n\n\ndef odd_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns the prime numbers < `num`. The prime numbers are calculated using an\n    odd sieve implementation of the Sieve of Eratosthenes algorithm\n    (see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\n    >>> odd_sieve(2)\n    []\n    >>> odd_sieve(3)\n    [2]\n    >>> odd_sieve(10)\n    [2, 3, 5, 7]\n    >>> odd_sieve(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    \"\"\"\n\n    if num <= 2:\n        return []\n    if num == 3:\n        return [2]\n\n    # Odd sieve for numbers in range [3, num - 1]\n    sieve = bytearray(b\"\\x01\") * ((num >> 1) - 1)\n\n    for i in range(3, int(sqrt(num)) + 1, 2):\n        if sieve[(i >> 1) - 1]:\n            i_squared = i**2\n            sieve[(i_squared >> 1) - 1 :: i] = repeat(\n                0, ceil((num - i_squared) / (i << 1))\n            )\n\n    return [2, *list(compress(range(3, num, 2), sieve))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/points_are_collinear_3d.py": "\"\"\"\nCheck if three points are collinear in 3D.\n\nIn short, the idea is that we are able to create a triangle using three points,\nand the area of that triangle can determine if the three points are collinear or not.\n\n\nFirst, we create two vectors with the same initial point from the three points,\nthen we will calculate the cross-product of them.\n\nThe length of the cross vector is numerically equal to the area of a parallelogram.\n\nFinally, the area of the triangle is equal to half of the area of the parallelogram.\n\nSince we are only differentiating between zero and anything else,\nwe can get rid of the square root when calculating the length of the vector,\nand also the division by two at the end.\n\nFrom a second perspective, if the two vectors are parallel and overlapping,\nwe can't get a nonzero perpendicular vector,\nsince there will be an infinite number of orthogonal vectors.\n\nTo simplify the solution we will not calculate the length,\nbut we will decide directly from the vector whether it is equal to (0, 0, 0) or not.\n\n\nRead More:\n    https://math.stackexchange.com/a/1951650\n\"\"\"\n\nVector3d = tuple[float, float, float]\nPoint3d = tuple[float, float, float]\n\n\ndef create_vector(end_point1: Point3d, end_point2: Point3d) -> Vector3d:\n    \"\"\"\n    Pass two points to get the vector from them in the form (x, y, z).\n\n    >>> create_vector((0, 0, 0), (1, 1, 1))\n    (1, 1, 1)\n    >>> create_vector((45, 70, 24), (47, 32, 1))\n    (2, -38, -23)\n    >>> create_vector((-14, -1, -8), (-7, 6, 4))\n    (7, 7, 12)\n    \"\"\"\n    x = end_point2[0] - end_point1[0]\n    y = end_point2[1] - end_point1[1]\n    z = end_point2[2] - end_point1[2]\n    return (x, y, z)\n\n\ndef get_3d_vectors_cross(ab: Vector3d, ac: Vector3d) -> Vector3d:\n    \"\"\"\n    Get the cross of the two vectors AB and AC.\n\n    I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.\n\n    Read More:\n        https://en.wikipedia.org/wiki/Cross_product\n        https://en.wikipedia.org/wiki/Determinant\n\n    >>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))\n    (-55, 22, 11)\n    >>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))\n    (0, 0, 0)\n    >>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))\n    (-36, -48, 27)\n    >>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))\n    (-123.2594, 277.15110000000004, 129.11260000000001)\n    \"\"\"\n    x = ab[1] * ac[2] - ab[2] * ac[1]  # *i\n    y = (ab[0] * ac[2] - ab[2] * ac[0]) * -1  # *j\n    z = ab[0] * ac[1] - ab[1] * ac[0]  # *k\n    return (x, y, z)\n\n\ndef is_zero_vector(vector: Vector3d, accuracy: int) -> bool:\n    \"\"\"\n    Check if vector is equal to (0, 0, 0) or not.\n\n    Since the algorithm is very accurate, we will never get a zero vector,\n    so we need to round the vector axis,\n    because we want a result that is either True or False.\n    In other applications, we can return a float that represents the collinearity ratio.\n\n    >>> is_zero_vector((0, 0, 0), accuracy=10)\n    True\n    >>> is_zero_vector((15, 74, 32), accuracy=10)\n    False\n    >>> is_zero_vector((-15, -74, -32), accuracy=10)\n    False\n    \"\"\"\n    return tuple(round(x, accuracy) for x in vector) == (0, 0, 0)\n\n\ndef are_collinear(a: Point3d, b: Point3d, c: Point3d, accuracy: int = 10) -> bool:\n    \"\"\"\n    Check if three points are collinear or not.\n\n    1- Create two vectors AB and AC.\n    2- Get the cross vector of the two vectors.\n    3- Calculate the length of the cross vector.\n    4- If the length is zero then the points are collinear, else they are not.\n\n    The use of the accuracy parameter is explained in is_zero_vector docstring.\n\n    >>> are_collinear((4.802293498137402, 3.536233125455244, 0),\n    ...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),\n    ...               (1.530169574640268, -2.447927606600034, 3.343487096469054))\n    True\n    >>> are_collinear((-6, -2, 6),\n    ...               (6.200213806439997, -4.930157614926678, -4.482371908289856),\n    ...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))\n    True\n    >>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),\n    ...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),\n    ...               (1.962903518985307, 3.741415730125627, 7))\n    False\n    >>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),\n    ...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),\n    ...               (-2.564606140206386, 3.937845170672183, 7))\n    False\n    \"\"\"\n    ab = create_vector(a, b)\n    ac = create_vector(a, c)\n    return is_zero_vector(get_3d_vectors_cross(ab, ac), accuracy)\n", "maths/dodecahedron.py": "# dodecahedron.py\n\n\"\"\"\nA regular dodecahedron is a three-dimensional figure made up of\n12 pentagon faces having the same equal size.\n\"\"\"\n\n\ndef dodecahedron_surface_area(edge: float) -> float:\n    \"\"\"\n    Calculates the surface area of a regular dodecahedron\n    a = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2)\n    where:\n    a --> is the area of the dodecahedron\n    e --> is the length of the edge\n    reference-->\"Dodecahedron\" Study.com\n    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n    :param edge: length of the edge of the dodecahedron\n    :type edge: float\n    :return: the surface area of the dodecahedron as a float\n\n\n    Tests:\n    >>> dodecahedron_surface_area(5)\n    516.1432201766901\n    >>> dodecahedron_surface_area(10)\n    2064.5728807067603\n    >>> dodecahedron_surface_area(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive.\n    \"\"\"\n\n    if edge <= 0 or not isinstance(edge, int):\n        raise ValueError(\"Length must be a positive.\")\n    return 3 * ((25 + 10 * (5 ** (1 / 2))) ** (1 / 2)) * (edge**2)\n\n\ndef dodecahedron_volume(edge: float) -> float:\n    \"\"\"\n    Calculates the volume of a regular dodecahedron\n    v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)\n    where:\n    v --> is the volume of the dodecahedron\n    e --> is the length of the edge\n    reference-->\"Dodecahedron\" Study.com\n    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>\n\n    :param edge: length of the edge of the dodecahedron\n    :type edge: float\n    :return: the volume of the dodecahedron as a float\n\n    Tests:\n    >>> dodecahedron_volume(5)\n    957.8898700780791\n    >>> dodecahedron_volume(10)\n    7663.118960624633\n    >>> dodecahedron_volume(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive.\n    \"\"\"\n\n    if edge <= 0 or not isinstance(edge, int):\n        raise ValueError(\"Length must be a positive.\")\n    return ((15 + (7 * (5 ** (1 / 2)))) / 4) * (edge**3)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/two_sum.py": "\"\"\"\nGiven an array of integers, return indices of the two numbers such that they add up to\na specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the\nsame element twice.\n\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_sum([15, 2, 11, 7], 13)\n    [1, 2]\n    >>> two_sum([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_sum([7, 15, 11, 2], 18)\n    [0, 2]\n    >>> two_sum([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_sum([2, 7, 11, 15], 8)\n    []\n    >>> two_sum([3 * i for i in range(10)], 19)\n    []\n    \"\"\"\n    chk_map: dict[int, int] = {}\n    for index, val in enumerate(nums):\n        compl = target - val\n        if compl in chk_map:\n            return [chk_map[compl], index]\n        chk_map[val] = index\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{two_sum([2, 7, 11, 15], 9) = }\")\n", "maths/volume.py": "\"\"\"\nFind the volume of various shapes.\n* https://en.wikipedia.org/wiki/Volume\n* https://en.wikipedia.org/wiki/Spherical_cap\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom math import pi, pow\n\n\ndef vol_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cube.\n    >>> vol_cube(1)\n    1.0\n    >>> vol_cube(3)\n    27.0\n    >>> vol_cube(0)\n    0.0\n    >>> vol_cube(1.6)\n    4.096000000000001\n    >>> vol_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"vol_cube() only accepts non-negative values\")\n    return pow(side_length, 3)\n\n\ndef vol_spherical_cap(height: float, radius: float) -> float:\n    \"\"\"\n    Calculate the volume of the spherical cap.\n    >>> vol_spherical_cap(1, 2)\n    5.235987755982988\n    >>> vol_spherical_cap(1.6, 2.6)\n    16.621119532592402\n    >>> vol_spherical_cap(0, 0)\n    0.0\n    >>> vol_spherical_cap(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spherical_cap() only accepts non-negative values\n    >>> vol_spherical_cap(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spherical_cap() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_spherical_cap() only accepts non-negative values\")\n    # Volume is 1/3 pi * height squared * (3 * radius - height)\n    return 1 / 3 * pi * pow(height, 2) * (3 * radius - height)\n\n\ndef vol_spheres_intersect(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    \"\"\"\n    Calculate the volume of the intersection of two spheres.\n    The intersection is composed by two spherical caps and therefore its volume is the\n    sum of the volumes of the spherical caps. First, it calculates the heights (h1, h2)\n    of the spherical caps, then the two volumes and it returns the sum.\n    The height formulas are\n    h1 = (radius_1 - radius_2 + centers_distance)\n       * (radius_1 + radius_2 - centers_distance)\n       / (2 * centers_distance)\n    h2 = (radius_2 - radius_1 + centers_distance)\n       * (radius_2 + radius_1 - centers_distance)\n       / (2 * centers_distance)\n    if centers_distance is 0 then it returns the volume of the smallers sphere\n    :return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n    >>> vol_spheres_intersect(2, 2, 1)\n    21.205750411731103\n    >>> vol_spheres_intersect(2.6, 2.6, 1.6)\n    40.71504079052372\n    >>> vol_spheres_intersect(0, 0, 0)\n    0.0\n    >>> vol_spheres_intersect(-2, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    >>> vol_spheres_intersect(2, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    >>> vol_spheres_intersect(2, 2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_intersect() only accepts non-negative values\n    \"\"\"\n    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:\n        raise ValueError(\"vol_spheres_intersect() only accepts non-negative values\")\n    if centers_distance == 0:\n        return vol_sphere(min(radius_1, radius_2))\n\n    h1 = (\n        (radius_1 - radius_2 + centers_distance)\n        * (radius_1 + radius_2 - centers_distance)\n        / (2 * centers_distance)\n    )\n    h2 = (\n        (radius_2 - radius_1 + centers_distance)\n        * (radius_2 + radius_1 - centers_distance)\n        / (2 * centers_distance)\n    )\n\n    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)\n\n\ndef vol_spheres_union(\n    radius_1: float, radius_2: float, centers_distance: float\n) -> float:\n    \"\"\"\n    Calculate the volume of the union of two spheres that possibly intersect.\n    It is the sum of sphere A and sphere B minus their intersection.\n    First, it calculates the volumes (v1, v2) of the spheres,\n    then the volume of the intersection (i) and it returns the sum v1+v2-i.\n    If centers_distance is 0 then it returns the volume of the larger sphere\n    :return vol_sphere(radius_1) + vol_sphere(radius_2)\n                - vol_spheres_intersect(radius_1, radius_2, centers_distance)\n\n    >>> vol_spheres_union(2, 2, 1)\n    45.814892864851146\n    >>> vol_spheres_union(1.56, 2.2, 1.4)\n    48.77802773671288\n    >>> vol_spheres_union(0, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius\n    >>> vol_spheres_union('1.56', '2.2', '1.4')\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'str' and 'int'\n    >>> vol_spheres_union(1, None, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'NoneType' and 'int'\n    \"\"\"\n\n    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:\n        raise ValueError(\n            \"vol_spheres_union() only accepts non-negative values, non-zero radius\"\n        )\n\n    if centers_distance == 0:\n        return vol_sphere(max(radius_1, radius_2))\n\n    return (\n        vol_sphere(radius_1)\n        + vol_sphere(radius_2)\n        - vol_spheres_intersect(radius_1, radius_2, centers_distance)\n    )\n\n\ndef vol_cuboid(width: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cuboid.\n    :return multiple of width, length and height\n    >>> vol_cuboid(1, 1, 1)\n    1.0\n    >>> vol_cuboid(1, 2, 3)\n    6.0\n    >>> vol_cuboid(1.6, 2.6, 3.6)\n    14.976\n    >>> vol_cuboid(0, 0, 0)\n    0.0\n    >>> vol_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    >>> vol_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cuboid() only accepts non-negative values\n    \"\"\"\n    if width < 0 or height < 0 or length < 0:\n        raise ValueError(\"vol_cuboid() only accepts non-negative values\")\n    return float(width * height * length)\n\n\ndef vol_cone(area_of_base: float, height: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Cone.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n    :return (1/3) * area_of_base * height\n    >>> vol_cone(10, 3)\n    10.0\n    >>> vol_cone(1, 1)\n    0.3333333333333333\n    >>> vol_cone(1.6, 1.6)\n    0.8533333333333335\n    >>> vol_cone(0, 0)\n    0.0\n    >>> vol_cone(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cone() only accepts non-negative values\n    >>> vol_cone(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_cone() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_cone() only accepts non-negative values\")\n    return area_of_base * height / 3.0\n\n\ndef vol_right_circ_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Right Circular Cone.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n    :return (1/3) * pi * radius^2 * height\n    >>> vol_right_circ_cone(2, 3)\n    12.566370614359172\n    >>> vol_right_circ_cone(0, 0)\n    0.0\n    >>> vol_right_circ_cone(1.6, 1.6)\n    4.289321169701265\n    >>> vol_right_circ_cone(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_right_circ_cone() only accepts non-negative values\n    >>> vol_right_circ_cone(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_right_circ_cone() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_right_circ_cone() only accepts non-negative values\")\n    return pi * pow(radius, 2) * height / 3.0\n\n\ndef vol_prism(area_of_base: float, height: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Prism.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)\n    :return V = Bh\n    >>> vol_prism(10, 2)\n    20.0\n    >>> vol_prism(11, 1)\n    11.0\n    >>> vol_prism(1.6, 1.6)\n    2.5600000000000005\n    >>> vol_prism(0, 0)\n    0.0\n    >>> vol_prism(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_prism() only accepts non-negative values\n    >>> vol_prism(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_prism() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_prism() only accepts non-negative values\")\n    return float(area_of_base * height)\n\n\ndef vol_pyramid(area_of_base: float, height: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Pyramid.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)\n    :return  (1/3) * Bh\n    >>> vol_pyramid(10, 3)\n    10.0\n    >>> vol_pyramid(1.5, 3)\n    1.5\n    >>> vol_pyramid(1.6, 1.6)\n    0.8533333333333335\n    >>> vol_pyramid(0, 0)\n    0.0\n    >>> vol_pyramid(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_pyramid() only accepts non-negative values\n    >>> vol_pyramid(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_pyramid() only accepts non-negative values\n    \"\"\"\n    if height < 0 or area_of_base < 0:\n        raise ValueError(\"vol_pyramid() only accepts non-negative values\")\n    return area_of_base * height / 3.0\n\n\ndef vol_sphere(radius: float) -> float:\n    \"\"\"\n    Calculate the Volume of a Sphere.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n    :return (4/3) * pi * r^3\n    >>> vol_sphere(5)\n    523.5987755982989\n    >>> vol_sphere(1)\n    4.1887902047863905\n    >>> vol_sphere(1.6)\n    17.15728467880506\n    >>> vol_sphere(0)\n    0.0\n    >>> vol_sphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_sphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"vol_sphere() only accepts non-negative values\")\n    # Volume is 4/3 * pi * radius cubed\n    return 4 / 3 * pi * pow(radius, 3)\n\n\ndef vol_hemisphere(radius: float) -> float:\n    \"\"\"Calculate the volume of a hemisphere\n    Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere\n    Other references: https://www.cuemath.com/geometry/hemisphere\n    :return 2/3 * pi * radius^3\n    >>> vol_hemisphere(1)\n    2.0943951023931953\n    >>> vol_hemisphere(7)\n    718.377520120866\n    >>> vol_hemisphere(1.6)\n    8.57864233940253\n    >>> vol_hemisphere(0)\n    0.0\n    >>> vol_hemisphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hemisphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"vol_hemisphere() only accepts non-negative values\")\n    # Volume is radius cubed * pi * 2/3\n    return pow(radius, 3) * pi * 2 / 3\n\n\ndef vol_circular_cylinder(radius: float, height: float) -> float:\n    \"\"\"Calculate the Volume of a Circular Cylinder.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\n    :return pi * radius^2 * height\n    >>> vol_circular_cylinder(1, 1)\n    3.141592653589793\n    >>> vol_circular_cylinder(4, 3)\n    150.79644737231007\n    >>> vol_circular_cylinder(1.6, 1.6)\n    12.867963509103795\n    >>> vol_circular_cylinder(0, 0)\n    0.0\n    >>> vol_circular_cylinder(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_circular_cylinder() only accepts non-negative values\n    >>> vol_circular_cylinder(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_circular_cylinder() only accepts non-negative values\n    \"\"\"\n    if height < 0 or radius < 0:\n        raise ValueError(\"vol_circular_cylinder() only accepts non-negative values\")\n    # Volume is radius squared * height * pi\n    return pow(radius, 2) * height * pi\n\n\ndef vol_hollow_circular_cylinder(\n    inner_radius: float, outer_radius: float, height: float\n) -> float:\n    \"\"\"Calculate the Volume of a Hollow Circular Cylinder.\n    >>> vol_hollow_circular_cylinder(1, 2, 3)\n    28.274333882308138\n    >>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6)\n    47.50088092227767\n    >>> vol_hollow_circular_cylinder(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_hollow_circular_cylinder() only accepts non-negative values\n    >>> vol_hollow_circular_cylinder(2, 1, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: outer_radius must be greater than inner_radius\n    >>> vol_hollow_circular_cylinder(0, 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: outer_radius must be greater than inner_radius\n    \"\"\"\n    # Volume - (outer_radius squared - inner_radius squared) * pi * height\n    if inner_radius < 0 or outer_radius < 0 or height < 0:\n        raise ValueError(\n            \"vol_hollow_circular_cylinder() only accepts non-negative values\"\n        )\n    if outer_radius <= inner_radius:\n        raise ValueError(\"outer_radius must be greater than inner_radius\")\n    return pi * (pow(outer_radius, 2) - pow(inner_radius, 2)) * height\n\n\ndef vol_conical_frustum(height: float, radius_1: float, radius_2: float) -> float:\n    \"\"\"Calculate the Volume of a Conical Frustum.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Frustum\n\n    >>> vol_conical_frustum(45, 7, 28)\n    48490.482608158454\n    >>> vol_conical_frustum(1, 1, 2)\n    7.330382858376184\n    >>> vol_conical_frustum(1.6, 2.6, 3.6)\n    48.7240076620753\n    >>> vol_conical_frustum(0, 0, 0)\n    0.0\n    >>> vol_conical_frustum(-2, 2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    >>> vol_conical_frustum(2, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    >>> vol_conical_frustum(2, 2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_conical_frustum() only accepts non-negative values\n    \"\"\"\n    # Volume is 1/3 * pi * height *\n    #           (radius_1 squared + radius_2 squared + radius_1 * radius_2)\n    if radius_1 < 0 or radius_2 < 0 or height < 0:\n        raise ValueError(\"vol_conical_frustum() only accepts non-negative values\")\n    return (\n        1\n        / 3\n        * pi\n        * height\n        * (pow(radius_1, 2) + pow(radius_2, 2) + radius_1 * radius_2)\n    )\n\n\ndef vol_torus(torus_radius: float, tube_radius: float) -> float:\n    \"\"\"Calculate the Volume of a Torus.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Torus\n    :return 2pi^2 * torus_radius * tube_radius^2\n    >>> vol_torus(1, 1)\n    19.739208802178716\n    >>> vol_torus(4, 3)\n    710.6115168784338\n    >>> vol_torus(3, 4)\n    947.4820225045784\n    >>> vol_torus(1.6, 1.6)\n    80.85179925372404\n    >>> vol_torus(0, 0)\n    0.0\n    >>> vol_torus(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_torus() only accepts non-negative values\n    >>> vol_torus(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_torus() only accepts non-negative values\n    \"\"\"\n    if torus_radius < 0 or tube_radius < 0:\n        raise ValueError(\"vol_torus() only accepts non-negative values\")\n    return 2 * pow(pi, 2) * torus_radius * pow(tube_radius, 2)\n\n\ndef vol_icosahedron(tri_side: float) -> float:\n    \"\"\"Calculate the Volume of an Icosahedron.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron\n\n    >>> from math import isclose\n    >>> isclose(vol_icosahedron(2.5), 34.088984228514256)\n    True\n    >>> isclose(vol_icosahedron(10), 2181.694990624912374)\n    True\n    >>> isclose(vol_icosahedron(5), 272.711873828114047)\n    True\n    >>> isclose(vol_icosahedron(3.49), 92.740688412033628)\n    True\n    >>> vol_icosahedron(0)\n    0.0\n    >>> vol_icosahedron(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_icosahedron() only accepts non-negative values\n    >>> vol_icosahedron(-0.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: vol_icosahedron() only accepts non-negative values\n    \"\"\"\n    if tri_side < 0:\n        raise ValueError(\"vol_icosahedron() only accepts non-negative values\")\n    return tri_side**3 * (3 + 5**0.5) * 5 / 12\n\n\ndef main():\n    \"\"\"Print the Results of Various Volume Calculations.\"\"\"\n    print(\"Volumes:\")\n    print(f\"Cube: {vol_cube(2) = }\")  # = 8\n    print(f\"Cuboid: {vol_cuboid(2, 2, 2) = }\")  # = 8\n    print(f\"Cone: {vol_cone(2, 2) = }\")  # ~= 1.33\n    print(f\"Right Circular Cone: {vol_right_circ_cone(2, 2) = }\")  # ~= 8.38\n    print(f\"Prism: {vol_prism(2, 2) = }\")  # = 4\n    print(f\"Pyramid: {vol_pyramid(2, 2) = }\")  # ~= 1.33\n    print(f\"Sphere: {vol_sphere(2) = }\")  # ~= 33.5\n    print(f\"Hemisphere: {vol_hemisphere(2) = }\")  # ~= 16.75\n    print(f\"Circular Cylinder: {vol_circular_cylinder(2, 2) = }\")  # ~= 25.1\n    print(f\"Torus: {vol_torus(2, 2) = }\")  # ~= 157.9\n    print(f\"Conical Frustum: {vol_conical_frustum(2, 2, 4) = }\")  # ~= 58.6\n    print(f\"Spherical cap: {vol_spherical_cap(1, 2) = }\")  # ~= 5.24\n    print(f\"Spheres intersetion: {vol_spheres_intersect(2, 2, 1) = }\")  # ~= 21.21\n    print(f\"Spheres union: {vol_spheres_union(2, 2, 1) = }\")  # ~= 45.81\n    print(\n        f\"Hollow Circular Cylinder: {vol_hollow_circular_cylinder(1, 2, 3) = }\"\n    )  # ~= 28.3\n    print(f\"Icosahedron: {vol_icosahedron(2.5) = }\")  # ~=34.09\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/max_sum_sliding_window.py": "\"\"\"\nGiven an array of integer elements and an integer 'k', we are required to find the\nmaximum sum of 'k' consecutive elements in the array.\n\nInstead of using a nested for loop, in a Brute force approach we will use a technique\ncalled 'Window sliding technique' where the nested loops can be converted to a single\nloop to reduce time complexity.\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef max_sum_in_array(array: list[int], k: int) -> int:\n    \"\"\"\n    Returns the maximum sum of k consecutive elements\n    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    24\n    >>> k = 10\n    >>> max_sum_in_array(arr,k)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Input\n    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]\n    >>> k = 4\n    >>> max_sum_in_array(arr, k)\n    27\n    \"\"\"\n    if len(array) < k or k < 0:\n        raise ValueError(\"Invalid Input\")\n    max_sum = current_sum = sum(array[:k])\n    for i in range(len(array) - k):\n        current_sum = current_sum - array[i] + array[i + k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n    from random import randint\n\n    testmod()\n    array = [randint(-1000, 1000) for i in range(100)]\n    k = randint(0, 110)\n    print(f\"The maximum sum of {k} consecutive elements is {max_sum_in_array(array,k)}\")\n", "maths/sum_of_arithmetic_series.py": "# DarkCoder\ndef sum_of_series(first_term: int, common_diff: int, num_of_terms: int) -> float:\n    \"\"\"\n    Find the sum of n terms in an arithmetic progression.\n\n    >>> sum_of_series(1, 1, 10)\n    55.0\n    >>> sum_of_series(1, 10, 100)\n    49600.0\n    \"\"\"\n    total = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)\n    # formula for sum of series\n    return total\n\n\ndef main():\n    print(sum_of_series(1, 1, 10))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/chinese_remainder_theorem.py": "\"\"\"\nChinese Remainder Theorem:\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\ntwo such integers, then n1=n2(mod ab)\n\nAlgorithm :\n\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n2. Take n = ra*by + rb*ax\n\"\"\"\n\nfrom __future__ import annotations\n\n\n# Extended Euclid\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n\n# Uses ExtendedEuclid to find inverses\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem(5,1,7,3)\n    31\n\n    Explanation : 31 is the smallest number such that\n                (i)  When we divide it by 5, we get remainder 1\n                (ii) When we divide it by 7, we get remainder 3\n\n    >>> chinese_remainder_theorem(6,1,4,3)\n    14\n\n    \"\"\"\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\n# ----------SAME SOLUTION USING InvertModulo instead ExtendedEuclid----------------\n\n\n# This function find the inverses of a i.e., a^(-1)\ndef invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n# Same a above using InvertingModulo\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem2(5,1,7,3)\n    31\n\n    >>> chinese_remainder_theorem2(6,1,4,3)\n    14\n\n    \"\"\"\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"chinese_remainder_theorem\", verbose=True)\n    testmod(name=\"chinese_remainder_theorem2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)\n", "maths/power_using_recursion.py": "\"\"\"\n== Raise base to the power of exponent using recursion ==\n    Input -->\n        Enter the base: 3\n        Enter the exponent: 4\n    Output  -->\n        3 to the power of 4 is 81\n    Input -->\n        Enter the base: 2\n        Enter the exponent: 0\n    Output -->\n        2 to the power of 0 is 1\n\"\"\"\n\n\ndef power(base: int, exponent: int) -> float:\n    \"\"\"\n    Calculate the power of a base raised to an exponent.\n\n    >>> power(3, 4)\n    81\n    >>> power(2, 0)\n    1\n    >>> all(power(base, exponent) == pow(base, exponent)\n    ...     for base in range(-10, 10) for exponent in range(10))\n    True\n    >>> power('a', 1)\n    'a'\n    >>> power('a', 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: can't multiply sequence by non-int of type 'str'\n    >>> power('a', 'b')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    >>> power(2, -1)\n    Traceback (most recent call last):\n        ...\n    RecursionError: maximum recursion depth exceeded\n    \"\"\"\n    return base * power(base, (exponent - 1)) if exponent else 1\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(\"Raise base to the power of exponent using recursion...\")\n    base = int(input(\"Enter the base: \").strip())\n    exponent = int(input(\"Enter the exponent: \").strip())\n    result = power(base, abs(exponent))\n    if exponent < 0:  # power() does not properly deal w/ negative exponents\n        result = 1 / result\n    print(f\"{base} to the power of {exponent} is {result}\")\n", "maths/qr_decomposition.py": "import numpy as np\n\n\ndef qr_householder(a: np.ndarray):\n    \"\"\"Return a QR-decomposition of the matrix A using Householder reflection.\n\n    The QR-decomposition decomposes the matrix A of shape (m, n) into an\n    orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of\n    shape (m, n).  Note that the matrix A does not have to be square.  This\n    method of decomposing A uses the Householder reflection, which is\n    numerically stable and of complexity O(n^3).\n\n    https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections\n\n    Arguments:\n    A -- a numpy.ndarray of shape (m, n)\n\n    Note: several optimizations can be made for numeric efficiency, but this is\n    intended to demonstrate how it would be represented in a mathematics\n    textbook.  In cases where efficiency is particularly important, an optimized\n    version from BLAS should be used.\n\n    >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)\n    >>> Q, R = qr_householder(A)\n\n    >>> # check that the decomposition is correct\n    >>> np.allclose(Q@R, A)\n    True\n\n    >>> # check that Q is orthogonal\n    >>> np.allclose(Q@Q.T, np.eye(A.shape[0]))\n    True\n    >>> np.allclose(Q.T@Q, np.eye(A.shape[0]))\n    True\n\n    >>> # check that R is upper triangular\n    >>> np.allclose(np.triu(R), R)\n    True\n    \"\"\"\n    m, n = a.shape\n    t = min(m, n)\n    q = np.eye(m)\n    r = a.copy()\n\n    for k in range(t - 1):\n        # select a column of modified matrix A':\n        x = r[k:, [k]]\n        # construct first basis vector\n        e1 = np.zeros_like(x)\n        e1[0] = 1.0\n        # determine scaling factor\n        alpha = np.linalg.norm(x)\n        # construct vector v for Householder reflection\n        v = x + np.sign(x[0]) * alpha * e1\n        v /= np.linalg.norm(v)\n\n        # construct the Householder matrix\n        q_k = np.eye(m - k) - 2.0 * v @ v.T\n        # pad with ones and zeros as necessary\n        q_k = np.block([[np.eye(k), np.zeros((k, m - k))], [np.zeros((m - k, k)), q_k]])\n\n        q = q @ q_k.T\n        r = q_k @ r\n\n    return q, r\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/remove_digit.py": "def remove_digit(num: int) -> int:\n    \"\"\"\n\n    returns the biggest possible result\n    that can be achieved by removing\n    one digit from the given number\n\n    >>> remove_digit(152)\n    52\n    >>> remove_digit(6385)\n    685\n    >>> remove_digit(-11)\n    1\n    >>> remove_digit(2222222)\n    222222\n    >>> remove_digit(\"2222222\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    >>> remove_digit(\"string input\")\n    Traceback (most recent call last):\n    TypeError: only integers accepted as input\n    \"\"\"\n\n    if not isinstance(num, int):\n        raise TypeError(\"only integers accepted as input\")\n    else:\n        num_str = str(abs(num))\n        num_transpositions = [list(num_str) for char in range(len(num_str))]\n        for index in range(len(num_str)):\n            num_transpositions[index].pop(index)\n        return max(\n            int(\"\".join(list(transposition))) for transposition in num_transpositions\n        )\n\n\nif __name__ == \"__main__\":\n    __import__(\"doctest\").testmod()\n", "maths/radians.py": "from math import pi\n\n\ndef radians(degree: float) -> float:\n    \"\"\"\n    Converts the given angle from degrees to radians\n    https://en.wikipedia.org/wiki/Radian\n\n    >>> radians(180)\n    3.141592653589793\n    >>> radians(92)\n    1.6057029118347832\n    >>> radians(274)\n    4.782202150464463\n    >>> radians(109.82)\n    1.9167205845401725\n\n    >>> from math import radians as math_radians\n    >>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361))\n    True\n    \"\"\"\n\n    return degree / (180 / pi)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "maths/print_multiplication_table.py": "def multiplication_table(number: int, number_of_terms: int) -> str:\n    \"\"\"\n    Prints the multiplication table of a given number till the given number of terms\n\n    >>> print(multiplication_table(3, 5))\n    3 * 1 = 3\n    3 * 2 = 6\n    3 * 3 = 9\n    3 * 4 = 12\n    3 * 5 = 15\n\n    >>> print(multiplication_table(-4, 6))\n    -4 * 1 = -4\n    -4 * 2 = -8\n    -4 * 3 = -12\n    -4 * 4 = -16\n    -4 * 5 = -20\n    -4 * 6 = -24\n    \"\"\"\n    return \"\\n\".join(\n        f\"{number} * {i} = {number * i}\" for i in range(1, number_of_terms + 1)\n    )\n\n\nif __name__ == \"__main__\":\n    print(multiplication_table(number=5, number_of_terms=10))\n", "maths/sylvester_sequence.py": "\"\"\"\n\nCalculates the nth number in Sylvester's sequence\n\nSource:\n    https://en.wikipedia.org/wiki/Sylvester%27s_sequence\n\n\"\"\"\n\n\ndef sylvester(number: int) -> int:\n    \"\"\"\n    :param number: nth number to calculate in the sequence\n    :return: the nth number in Sylvester's sequence\n\n    >>> sylvester(8)\n    113423713055421844361000443\n\n    >>> sylvester(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of [n=-1] has to be > 0\n\n    >>> sylvester(8.0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: The input value of [n=8.0] is not an integer\n    \"\"\"\n    assert isinstance(number, int), f\"The input value of [n={number}] is not an integer\"\n\n    if number == 1:\n        return 2\n    elif number < 1:\n        msg = f\"The input value of [n={number}] has to be > 0\"\n        raise ValueError(msg)\n    else:\n        num = sylvester(number - 1)\n        lower = num - 1\n        upper = num\n        return lower * upper + 1\n\n\nif __name__ == \"__main__\":\n    print(f\"The 8th number in Sylvester's sequence: {sylvester(8)}\")\n", "maths/liouville_lambda.py": "\"\"\"\n== Liouville Lambda Function ==\nThe Liouville Lambda function, denoted by \u03bb(n)\nand \u03bb(n) is 1 if n is the product of an even number of prime numbers,\nand -1 if it is the product of an odd number of primes.\n\nhttps://en.wikipedia.org/wiki/Liouville_function\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\nfrom maths.prime_factors import prime_factors\n\n\ndef liouville_lambda(number: int) -> int:\n    \"\"\"\n    This functions takes an integer number as input.\n    returns 1 if n has even number of prime factors and -1 otherwise.\n    >>> liouville_lambda(10)\n    1\n    >>> liouville_lambda(11)\n    -1\n    >>> liouville_lambda(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> liouville_lambda(11.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=11.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return -1 if len(prime_factors(number)) % 2 else 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/number_of_digits.py": "import math\nfrom timeit import timeit\n\n\ndef num_digits(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n\n    >>> num_digits(12345)\n    5\n    >>> num_digits(123)\n    3\n    >>> num_digits(0)\n    1\n    >>> num_digits(-1)\n    1\n    >>> num_digits(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    digits = 0\n    n = abs(n)\n    while True:\n        n = n // 10\n        digits += 1\n        if n == 0:\n            break\n    return digits\n\n\ndef num_digits_fast(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used as logarithm for negative numbers is not defined.\n\n    >>> num_digits_fast(12345)\n    5\n    >>> num_digits_fast(123)\n    3\n    >>> num_digits_fast(0)\n    1\n    >>> num_digits_fast(-1)\n    1\n    >>> num_digits_fast(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return 1 if n == 0 else math.floor(math.log(abs(n), 10) + 1)\n\n\ndef num_digits_faster(n: int) -> int:\n    \"\"\"\n    Find the number of digits in a number.\n    abs() is used for negative numbers\n\n    >>> num_digits_faster(12345)\n    5\n    >>> num_digits_faster(123)\n    3\n    >>> num_digits_faster(0)\n    1\n    >>> num_digits_faster(-1)\n    1\n    >>> num_digits_faster(-123456)\n    6\n    >>> num_digits('123')  # Raises a TypeError for non-integer input\n    Traceback (most recent call last):\n        ...\n    TypeError: Input must be an integer\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n\n    return len(str(abs(n)))\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        print(f\"{call}: {func(value)} -- {timing} seconds\")\n\n    for value in (262144, 1125899906842624, 1267650600228229401496703205376):\n        for func in (num_digits, num_digits_fast, num_digits_faster):\n            benchmark_a_function(func, value)\n        print()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "maths/binomial_distribution.py": "\"\"\"For more information about the Binomial Distribution -\nhttps://en.wikipedia.org/wiki/Binomial_distribution\"\"\"\n\nfrom math import factorial\n\n\ndef binomial_distribution(successes: int, trials: int, prob: float) -> float:\n    \"\"\"\n    Return probability of k successes out of n tries, with p probability for one\n    success\n\n    The function uses the factorial function in order to calculate the binomial\n    coefficient\n\n    >>> binomial_distribution(3, 5, 0.7)\n    0.30870000000000003\n    >>> binomial_distribution (2, 4, 0.5)\n    0.375\n    \"\"\"\n    if successes > trials:\n        raise ValueError(\"\"\"successes must be lower or equal to trials\"\"\")\n    if trials < 0 or successes < 0:\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not isinstance(successes, int) or not isinstance(trials, int):\n        raise ValueError(\"the function is defined for non-negative integers\")\n    if not 0 < prob < 1:\n        raise ValueError(\"prob has to be in range of 1 - 0\")\n    probability = (prob**successes) * ((1 - prob) ** (trials - successes))\n    # Calculate the binomial coefficient: n! / k!(n-k)!\n    coefficient = float(factorial(trials))\n    coefficient /= factorial(successes) * factorial(trials - successes)\n    return probability * coefficient\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(\"Probability of 2 successes out of 4 trails\")\n    print(\"with probability of 0.75 is:\", end=\" \")\n    print(binomial_distribution(2, 4, 0.75))\n", "maths/allocation_number.py": "\"\"\"\nIn a multi-threaded download, this algorithm could be used to provide\neach worker thread with a block of non-overlapping bytes to download.\nFor example:\n    for i in allocation_list:\n        requests.get(url,headers={'Range':f'bytes={i}'})\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef allocation_num(number_of_bytes: int, partitions: int) -> list[str]:\n    \"\"\"\n    Divide a number of bytes into x partitions.\n    :param number_of_bytes: the total of bytes.\n    :param partitions: the number of partition need to be allocated.\n    :return: list of bytes to be assigned to each worker thread\n\n    >>> allocation_num(16647, 4)\n    ['1-4161', '4162-8322', '8323-12483', '12484-16647']\n    >>> allocation_num(50000, 5)\n    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']\n    >>> allocation_num(888, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions can not > number_of_bytes!\n    >>> allocation_num(888, -4)\n    Traceback (most recent call last):\n        ...\n    ValueError: partitions must be a positive number!\n    \"\"\"\n    if partitions <= 0:\n        raise ValueError(\"partitions must be a positive number!\")\n    if partitions > number_of_bytes:\n        raise ValueError(\"partitions can not > number_of_bytes!\")\n    bytes_per_partition = number_of_bytes // partitions\n    allocation_list = []\n    for i in range(partitions):\n        start_bytes = i * bytes_per_partition + 1\n        end_bytes = (\n            number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition\n        )\n        allocation_list.append(f\"{start_bytes}-{end_bytes}\")\n    return allocation_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/perfect_number.py": "\"\"\"\n== Perfect Number ==\nIn number theory, a perfect number is a positive integer that is equal to the sum of\nits positive divisors, excluding the number itself.\nFor example: 6 ==> divisors[1, 2, 3, 6]\n    Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6\n    So, 6 is a Perfect Number\n\nOther examples of Perfect Numbers: 28, 486, ...\n\nhttps://en.wikipedia.org/wiki/Perfect_number\n\"\"\"\n\n\ndef perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number otherwise, False.\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(\"Program to check whether a number is a Perfect number or not...\")\n    try:\n        number = int(input(\"Enter a positive integer: \").strip())\n    except ValueError:\n        msg = \"number must an integer\"\n        print(msg)\n        raise ValueError(msg)\n\n    print(f\"{number} is {'' if perfect(number) else 'not '}a Perfect Number.\")\n", "maths/prime_numbers.py": "import math\nfrom collections.abc import Generator\n\n\ndef slow_primes(max_n: int) -> Generator[int, None, None]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(slow_primes(0))\n    []\n    >>> list(slow_primes(-1))\n    []\n    >>> list(slow_primes(-10))\n    []\n    >>> list(slow_primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(slow_primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(slow_primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(slow_primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        for j in range(2, i):\n            if (i % j) == 0:\n                break\n        else:\n            yield i\n\n\ndef primes(max_n: int) -> Generator[int, None, None]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(primes(0))\n    []\n    >>> list(primes(-1))\n    []\n    >>> list(primes(-10))\n    []\n    >>> list(primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1)))\n    for i in (n for n in numbers if n > 1):\n        # only need to check for factors up to sqrt(i)\n        bound = int(math.sqrt(i)) + 1\n        for j in range(2, bound):\n            if (i % j) == 0:\n                break\n        else:\n            yield i\n\n\ndef fast_primes(max_n: int) -> Generator[int, None, None]:\n    \"\"\"\n    Return a list of all primes numbers up to max.\n    >>> list(fast_primes(0))\n    []\n    >>> list(fast_primes(-1))\n    []\n    >>> list(fast_primes(-10))\n    []\n    >>> list(fast_primes(25))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> list(fast_primes(11))\n    [2, 3, 5, 7, 11]\n    >>> list(fast_primes(33))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    >>> list(fast_primes(1000))[-1]\n    997\n    \"\"\"\n    numbers: Generator = (i for i in range(1, (max_n + 1), 2))\n    # It's useless to test even numbers as they will not be prime\n    if max_n > 2:\n        yield 2  # Because 2 will not be tested, it's necessary to yield it now\n    for i in (n for n in numbers if n > 1):\n        bound = int(math.sqrt(i)) + 1\n        for j in range(3, bound, 2):\n            # As we removed the even numbers, we don't need them now\n            if (i % j) == 0:\n                break\n        else:\n            yield i\n\n\ndef benchmark():\n    \"\"\"\n    Let's benchmark our functions side-by-side...\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import slow_primes, primes, fast_primes\"\n    print(timeit(\"slow_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n    print(timeit(\"fast_primes(1_000_000_000_000)\", setup=setup, number=1_000_000))\n\n\nif __name__ == \"__main__\":\n    number = int(input(\"Calculate primes up to:\\n>> \").strip())\n    for ret in primes(number):\n        print(ret)\n    benchmark()\n", "maths/floor.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\n\"\"\"\n\n\ndef floor(x: float) -> int:\n    \"\"\"\n    Return the floor of x as an Integral.\n    :param x: the number\n    :return: the largest integer <= x.\n    >>> import math\n    >>> all(floor(n) == math.floor(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) >= 0 else int(x) - 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/tanh.py": "\"\"\"\nThis script demonstrates the implementation of the tangent hyperbolic\nor tanh function.\n\nThe function takes a vector of K real numbers as input and\nthen (e^x - e^(-x))/(e^x + e^(-x)). After through tanh, the\nelement of the vector mostly -1 between 1.\n\nScript inspired from its corresponding Wikipedia article\nhttps://en.wikipedia.org/wiki/Activation_function\n\"\"\"\n\nimport numpy as np\n\n\ndef tangent_hyperbolic(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n        Implements the tanh function\n\n        Parameters:\n            vector: np.ndarray\n\n        Returns:\n            tanh (np.array): The input numpy array after applying tanh.\n\n        mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1\n\n    Examples:\n        >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))\n        array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])\n\n        >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))\n        array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])\n\n    \"\"\"\n\n    return (2 / (1 + np.exp(-2 * vector))) - 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/area.py": "\"\"\"\nFind the area of various geometric shapes\nWikipedia reference: https://en.wikipedia.org/wiki/Area\n\"\"\"\n\nfrom math import pi, sqrt, tan\n\n\ndef surface_area_cube(side_length: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cube.\n\n    >>> surface_area_cube(1)\n    6\n    >>> surface_area_cube(1.6)\n    15.360000000000003\n    >>> surface_area_cube(0)\n    0\n    >>> surface_area_cube(3)\n    54\n    >>> surface_area_cube(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cube() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"surface_area_cube() only accepts non-negative values\")\n    return 6 * side_length**2\n\n\ndef surface_area_cuboid(length: float, breadth: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cuboid.\n\n    >>> surface_area_cuboid(1, 2, 3)\n    22\n    >>> surface_area_cuboid(0, 0, 0)\n    0\n    >>> surface_area_cuboid(1.6, 2.6, 3.6)\n    38.56\n    >>> surface_area_cuboid(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    >>> surface_area_cuboid(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    >>> surface_area_cuboid(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cuboid() only accepts non-negative values\n    \"\"\"\n    if length < 0 or breadth < 0 or height < 0:\n        raise ValueError(\"surface_area_cuboid() only accepts non-negative values\")\n    return 2 * ((length * breadth) + (breadth * height) + (length * height))\n\n\ndef surface_area_sphere(radius: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Sphere.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n    Formula: 4 * pi * r^2\n\n    >>> surface_area_sphere(5)\n    314.1592653589793\n    >>> surface_area_sphere(1)\n    12.566370614359172\n    >>> surface_area_sphere(1.6)\n    32.169908772759484\n    >>> surface_area_sphere(0)\n    0.0\n    >>> surface_area_sphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_sphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"surface_area_sphere() only accepts non-negative values\")\n    return 4 * pi * radius**2\n\n\ndef surface_area_hemisphere(radius: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Hemisphere.\n    Formula: 3 * pi * r^2\n\n    >>> surface_area_hemisphere(5)\n    235.61944901923448\n    >>> surface_area_hemisphere(1)\n    9.42477796076938\n    >>> surface_area_hemisphere(0)\n    0.0\n    >>> surface_area_hemisphere(1.1)\n    11.40398133253095\n    >>> surface_area_hemisphere(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_hemisphere() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"surface_area_hemisphere() only accepts non-negative values\")\n    return 3 * pi * radius**2\n\n\ndef surface_area_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cone.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cone\n    Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)\n\n    >>> surface_area_cone(10, 24)\n    1130.9733552923256\n    >>> surface_area_cone(6, 8)\n    301.59289474462014\n    >>> surface_area_cone(1.6, 2.6)\n    23.387862992395807\n    >>> surface_area_cone(0, 0)\n    0.0\n    >>> surface_area_cone(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    >>> surface_area_cone(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    >>> surface_area_cone(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cone() only accepts non-negative values\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"surface_area_cone() only accepts non-negative values\")\n    return pi * radius * (radius + (height**2 + radius**2) ** 0.5)\n\n\ndef surface_area_conical_frustum(\n    radius_1: float, radius_2: float, height: float\n) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Conical Frustum.\n\n    >>> surface_area_conical_frustum(1, 2, 3)\n    45.511728065337266\n    >>> surface_area_conical_frustum(4, 5, 6)\n    300.7913575056268\n    >>> surface_area_conical_frustum(0, 0, 0)\n    0.0\n    >>> surface_area_conical_frustum(1.6, 2.6, 3.6)\n    78.57907060751548\n    >>> surface_area_conical_frustum(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    >>> surface_area_conical_frustum(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    >>> surface_area_conical_frustum(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_conical_frustum() only accepts non-negative values\n    \"\"\"\n    if radius_1 < 0 or radius_2 < 0 or height < 0:\n        raise ValueError(\n            \"surface_area_conical_frustum() only accepts non-negative values\"\n        )\n    slant_height = (height**2 + (radius_1 - radius_2) ** 2) ** 0.5\n    return pi * ((slant_height * (radius_1 + radius_2)) + radius_1**2 + radius_2**2)\n\n\ndef surface_area_cylinder(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the Surface Area of a Cylinder.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder\n    Formula: 2 * pi * r * (h + r)\n\n    >>> surface_area_cylinder(7, 10)\n    747.6990515543707\n    >>> surface_area_cylinder(1.6, 2.6)\n    42.22300526424682\n    >>> surface_area_cylinder(0, 0)\n    0.0\n    >>> surface_area_cylinder(6, 8)\n    527.7875658030853\n    >>> surface_area_cylinder(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    >>> surface_area_cylinder(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    >>> surface_area_cylinder(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_cylinder() only accepts non-negative values\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"surface_area_cylinder() only accepts non-negative values\")\n    return 2 * pi * radius * (height + radius)\n\n\ndef surface_area_torus(torus_radius: float, tube_radius: float) -> float:\n    \"\"\"Calculate the Area of a Torus.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Torus\n    :return 4pi^2 * torus_radius * tube_radius\n    >>> surface_area_torus(1, 1)\n    39.47841760435743\n    >>> surface_area_torus(4, 3)\n    473.7410112522892\n    >>> surface_area_torus(3, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() does not support spindle or self intersecting tori\n    >>> surface_area_torus(1.6, 1.6)\n    101.06474906715503\n    >>> surface_area_torus(0, 0)\n    0.0\n    >>> surface_area_torus(-1, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() only accepts non-negative values\n    >>> surface_area_torus(1, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: surface_area_torus() only accepts non-negative values\n    \"\"\"\n    if torus_radius < 0 or tube_radius < 0:\n        raise ValueError(\"surface_area_torus() only accepts non-negative values\")\n    if torus_radius < tube_radius:\n        raise ValueError(\n            \"surface_area_torus() does not support spindle or self intersecting tori\"\n        )\n    return 4 * pow(pi, 2) * torus_radius * tube_radius\n\n\ndef area_rectangle(length: float, width: float) -> float:\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    >>> area_rectangle(10, 20)\n    200\n    >>> area_rectangle(1.6, 2.6)\n    4.16\n    >>> area_rectangle(0, 0)\n    0\n    >>> area_rectangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    >>> area_rectangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rectangle() only accepts non-negative values\n    \"\"\"\n    if length < 0 or width < 0:\n        raise ValueError(\"area_rectangle() only accepts non-negative values\")\n    return length * width\n\n\ndef area_square(side_length: float) -> float:\n    \"\"\"\n    Calculate the area of a square.\n\n    >>> area_square(10)\n    100\n    >>> area_square(0)\n    0\n    >>> area_square(1.6)\n    2.5600000000000005\n    >>> area_square(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_square() only accepts non-negative values\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"area_square() only accepts non-negative values\")\n    return side_length**2\n\n\ndef area_triangle(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n\n    >>> area_triangle(10, 10)\n    50.0\n    >>> area_triangle(1.6, 2.6)\n    2.08\n    >>> area_triangle(0, 0)\n    0.0\n    >>> area_triangle(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    >>> area_triangle(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_triangle() only accepts non-negative values\")\n    return (base * height) / 2\n\n\ndef area_triangle_three_sides(side1: float, side2: float, side3: float) -> float:\n    \"\"\"\n    Calculate area of triangle when the length of 3 sides are known.\n    This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula\n\n    >>> area_triangle_three_sides(5, 12, 13)\n    30.0\n    >>> area_triangle_three_sides(10, 11, 12)\n    51.521233486786784\n    >>> area_triangle_three_sides(0, 0, 0)\n    0.0\n    >>> area_triangle_three_sides(1.6, 2.6, 3.6)\n    1.8703742940919619\n    >>> area_triangle_three_sides(-1, -2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle_three_sides() only accepts non-negative values\n    >>> area_triangle_three_sides(1, -2, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_triangle_three_sides() only accepts non-negative values\n    >>> area_triangle_three_sides(2, 4, 7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    >>> area_triangle_three_sides(2, 7, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    >>> area_triangle_three_sides(7, 2, 4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Given three sides do not form a triangle\n    \"\"\"\n    if side1 < 0 or side2 < 0 or side3 < 0:\n        raise ValueError(\"area_triangle_three_sides() only accepts non-negative values\")\n    elif side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:\n        raise ValueError(\"Given three sides do not form a triangle\")\n    semi_perimeter = (side1 + side2 + side3) / 2\n    area = sqrt(\n        semi_perimeter\n        * (semi_perimeter - side1)\n        * (semi_perimeter - side2)\n        * (semi_perimeter - side3)\n    )\n    return area\n\n\ndef area_parallelogram(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    >>> area_parallelogram(10, 20)\n    200\n    >>> area_parallelogram(1.6, 2.6)\n    4.16\n    >>> area_parallelogram(0, 0)\n    0\n    >>> area_parallelogram(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    >>> area_parallelogram(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    >>> area_parallelogram(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_parallelogram() only accepts non-negative values\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"area_parallelogram() only accepts non-negative values\")\n    return base * height\n\n\ndef area_trapezium(base1: float, base2: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a trapezium.\n\n    >>> area_trapezium(10, 20, 30)\n    450.0\n    >>> area_trapezium(1.6, 2.6, 3.6)\n    7.5600000000000005\n    >>> area_trapezium(0, 0, 0)\n    0.0\n    >>> area_trapezium(-1, -2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, 2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, -2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(1, -2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    >>> area_trapezium(-1, 2, -3)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_trapezium() only accepts non-negative values\n    \"\"\"\n    if base1 < 0 or base2 < 0 or height < 0:\n        raise ValueError(\"area_trapezium() only accepts non-negative values\")\n    return 1 / 2 * (base1 + base2) * height\n\n\ndef area_circle(radius: float) -> float:\n    \"\"\"\n    Calculate the area of a circle.\n\n    >>> area_circle(20)\n    1256.6370614359173\n    >>> area_circle(1.6)\n    8.042477193189871\n    >>> area_circle(0)\n    0.0\n    >>> area_circle(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_circle() only accepts non-negative values\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"area_circle() only accepts non-negative values\")\n    return pi * radius**2\n\n\ndef area_ellipse(radius_x: float, radius_y: float) -> float:\n    \"\"\"\n    Calculate the area of a ellipse.\n\n    >>> area_ellipse(10, 10)\n    314.1592653589793\n    >>> area_ellipse(10, 20)\n    628.3185307179587\n    >>> area_ellipse(0, 0)\n    0.0\n    >>> area_ellipse(1.6, 2.6)\n    13.06902543893354\n    >>> area_ellipse(-10, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    >>> area_ellipse(-10, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_ellipse() only accepts non-negative values\n    \"\"\"\n    if radius_x < 0 or radius_y < 0:\n        raise ValueError(\"area_ellipse() only accepts non-negative values\")\n    return pi * radius_x * radius_y\n\n\ndef area_rhombus(diagonal_1: float, diagonal_2: float) -> float:\n    \"\"\"\n    Calculate the area of a rhombus.\n\n    >>> area_rhombus(10, 20)\n    100.0\n    >>> area_rhombus(1.6, 2.6)\n    2.08\n    >>> area_rhombus(0, 0)\n    0.0\n    >>> area_rhombus(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    >>> area_rhombus(1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    >>> area_rhombus(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_rhombus() only accepts non-negative values\n    \"\"\"\n    if diagonal_1 < 0 or diagonal_2 < 0:\n        raise ValueError(\"area_rhombus() only accepts non-negative values\")\n    return 1 / 2 * diagonal_1 * diagonal_2\n\n\ndef area_reg_polygon(sides: int, length: float) -> float:\n    \"\"\"\n    Calculate the area of a regular polygon.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons\n    Formula: (n*s^2*cot(pi/n))/4\n\n    >>> area_reg_polygon(3, 10)\n    43.301270189221945\n    >>> area_reg_polygon(4, 10)\n    100.00000000000001\n    >>> area_reg_polygon(0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    >>> area_reg_polygon(-1, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    >>> area_reg_polygon(5, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts non-negative values as \\\nlength of a side\n    >>> area_reg_polygon(-1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: area_reg_polygon() only accepts integers greater than or equal to \\\nthree as number of sides\n    \"\"\"\n    if not isinstance(sides, int) or sides < 3:\n        raise ValueError(\n            \"area_reg_polygon() only accepts integers greater than or \\\nequal to three as number of sides\"\n        )\n    elif length < 0:\n        raise ValueError(\n            \"area_reg_polygon() only accepts non-negative values as \\\nlength of a side\"\n        )\n    return (sides * length**2) / (4 * tan(pi / sides))\n    return (sides * length**2) / (4 * tan(pi / sides))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)  # verbose so we can see methods missing tests\n\n    print(\"[DEMO] Areas of various geometric shapes: \\n\")\n    print(f\"Rectangle: {area_rectangle(10, 20) = }\")\n    print(f\"Square: {area_square(10) = }\")\n    print(f\"Triangle: {area_triangle(10, 10) = }\")\n    print(f\"Triangle: {area_triangle_three_sides(5, 12, 13) = }\")\n    print(f\"Parallelogram: {area_parallelogram(10, 20) = }\")\n    print(f\"Rhombus: {area_rhombus(10, 20) = }\")\n    print(f\"Trapezium: {area_trapezium(10, 20, 30) = }\")\n    print(f\"Circle: {area_circle(20) = }\")\n    print(f\"Ellipse: {area_ellipse(10, 20) = }\")\n    print(\"\\nSurface Areas of various geometric shapes: \\n\")\n    print(f\"Cube: {surface_area_cube(20) = }\")\n    print(f\"Cuboid: {surface_area_cuboid(10, 20, 30) = }\")\n    print(f\"Sphere: {surface_area_sphere(20) = }\")\n    print(f\"Hemisphere: {surface_area_hemisphere(20) = }\")\n    print(f\"Cone: {surface_area_cone(10, 20) = }\")\n    print(f\"Conical Frustum: {surface_area_conical_frustum(10, 20, 30) = }\")\n    print(f\"Cylinder: {surface_area_cylinder(10, 20) = }\")\n    print(f\"Torus: {surface_area_torus(20, 10) = }\")\n    print(f\"Equilateral Triangle: {area_reg_polygon(3, 10) = }\")\n    print(f\"Square: {area_reg_polygon(4, 10) = }\")\n    print(f\"Reqular Pentagon: {area_reg_polygon(5, 10) = }\")\n", "maths/arc_length.py": "from math import pi\n\n\ndef arc_length(angle: int, radius: int) -> float:\n    \"\"\"\n    >>> arc_length(45, 5)\n    3.9269908169872414\n    >>> arc_length(120, 15)\n    31.415926535897928\n    >>> arc_length(90, 10)\n    15.707963267948966\n    \"\"\"\n    return 2 * pi * radius * (angle / 360)\n\n\nif __name__ == \"__main__\":\n    print(arc_length(90, 10))\n", "maths/quadratic_equations_complex_numbers.py": "from __future__ import annotations\n\nfrom cmath import sqrt\n\n\ndef quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:\n    \"\"\"\n    Given the numerical coefficients a, b and c,\n    calculates the roots for any quadratic equation of the form ax^2 + bx + c\n\n    >>> quadratic_roots(a=1, b=3, c=-4)\n    (1.0, -4.0)\n    >>> quadratic_roots(5, 6, 1)\n    (-0.2, -1.0)\n    >>> quadratic_roots(1, -6, 25)\n    ((3+4j), (3-4j))\n    \"\"\"\n\n    if a == 0:\n        raise ValueError(\"Coefficient 'a' must not be zero.\")\n    delta = b * b - 4 * a * c\n\n    root_1 = (-b + sqrt(delta)) / (2 * a)\n    root_2 = (-b - sqrt(delta)) / (2 * a)\n\n    return (\n        root_1.real if not root_1.imag else root_1,\n        root_2.real if not root_2.imag else root_2,\n    )\n\n\ndef main():\n    solution1, solution2 = quadratic_roots(a=5, b=6, c=1)\n    print(f\"The solutions are: {solution1} and {solution2}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/addition_without_arithmetic.py": "\"\"\"\nIllustrate how to add the integer without arithmetic operation\nAuthor: suraj Kumar\nTime Complexity: 1\nhttps://en.wikipedia.org/wiki/Bitwise_operation\n\"\"\"\n\n\ndef add(first: int, second: int) -> int:\n    \"\"\"\n    Implementation of addition of integer\n\n    Examples:\n    >>> add(3, 5)\n    8\n    >>> add(13, 5)\n    18\n    >>> add(-7, 2)\n    -5\n    >>> add(0, -7)\n    -7\n    >>> add(-321, 0)\n    -321\n    \"\"\"\n    while second != 0:\n        c = first & second\n        first ^= second\n        second = c << 1\n    return first\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    first = int(input(\"Enter the first number: \").strip())\n    second = int(input(\"Enter the second number: \").strip())\n    print(f\"{add(first, second) = }\")\n", "maths/pi_generator.py": "def calculate_pi(limit: int) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n    Leibniz Formula for Pi\n\n    The Leibniz formula is the special case arctan(1) = pi / 4.\n    Leibniz's formula converges extremely slowly: it exhibits sublinear convergence.\n\n    Convergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)\n\n    We cannot try to prove against an interrupted, uncompleted generation.\n    https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour\n    The errors can in fact be predicted, but those calculations also approach infinity\n    for accuracy.\n\n    Our output will be a string so that we can definitely store all digits.\n\n    >>> import math\n    >>> float(calculate_pi(15)) == math.pi\n    True\n\n    Since we cannot predict errors or interrupt any infinite alternating series\n    generation since they approach infinity, or interrupt any alternating series, we'll\n    need math.isclose()\n\n    >>> math.isclose(float(calculate_pi(50)), math.pi)\n    True\n    >>> math.isclose(float(calculate_pi(100)), math.pi)\n    True\n\n    Since math.pi contains only 16 digits, here are some tests with known values:\n\n    >>> calculate_pi(50)\n    '3.14159265358979323846264338327950288419716939937510'\n    >>> calculate_pi(80)\n    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'\n    \"\"\"\n    # Variables used for the iteration process\n    q = 1\n    r = 0\n    t = 1\n    k = 1\n    n = 3\n    m = 3\n\n    decimal = limit\n    counter = 0\n\n    result = \"\"\n\n    # We can't compare against anything if we make a generator,\n    # so we'll stick with plain return logic\n    while counter != decimal + 1:\n        if 4 * q + r - t < n * t:\n            result += str(n)\n            if counter == 0:\n                result += \".\"\n\n            if decimal == counter:\n                break\n\n            counter += 1\n            nr = 10 * (r - n * t)\n            n = ((10 * (3 * q + r)) // t) - 10 * n\n            q *= 10\n            r = nr\n        else:\n            nr = (2 * q + r) * m\n            nn = (q * (7 * k) + 2 + (r * m)) // (t * m)\n            q *= k\n            t *= m\n            m += 2\n            k += 1\n            n = nn\n            r = nr\n    return result\n\n\ndef main() -> None:\n    print(f\"{calculate_pi(50) = }\")\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/three_sum.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/3SUM\n\"\"\"\n\n\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    \"\"\"\n    Find all unique triplets in a sorted array of integers that sum up to zero.\n\n    Args:\n        nums: A sorted list of integers.\n\n    Returns:\n        A list of lists containing unique triplets that sum up to zero.\n\n    >>> three_sum([-1, 0, 1, 2, -1, -4])\n    [[-1, -1, 2], [-1, 0, 1]]\n    >>> three_sum([1, 2, 3, 4])\n    []\n    \"\"\"\n    nums.sort()\n    ans = []\n    for i in range(len(nums) - 2):\n        if i == 0 or (nums[i] != nums[i - 1]):\n            low, high, c = i + 1, len(nums) - 1, 0 - nums[i]\n            while low < high:\n                if nums[low] + nums[high] == c:\n                    ans.append([nums[i], nums[low], nums[high]])\n\n                    while low < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low < high and nums[high] == nums[high - 1]:\n                        high -= 1\n\n                    low += 1\n                    high -= 1\n                elif nums[low] + nums[high] < c:\n                    low += 1\n                else:\n                    high -= 1\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/decimal_to_fraction.py": "def decimal_to_fraction(decimal: float | str) -> tuple[int, int]:\n    \"\"\"\n    Return a decimal number in its simplest fraction form\n    >>> decimal_to_fraction(2)\n    (2, 1)\n    >>> decimal_to_fraction(89.)\n    (89, 1)\n    >>> decimal_to_fraction(\"67\")\n    (67, 1)\n    >>> decimal_to_fraction(\"45.0\")\n    (45, 1)\n    >>> decimal_to_fraction(1.5)\n    (3, 2)\n    >>> decimal_to_fraction(\"6.25\")\n    (25, 4)\n    >>> decimal_to_fraction(\"78td\")\n    Traceback (most recent call last):\n    ValueError: Please enter a valid number\n    \"\"\"\n    try:\n        decimal = float(decimal)\n    except ValueError:\n        raise ValueError(\"Please enter a valid number\")\n    fractional_part = decimal - int(decimal)\n    if fractional_part == 0:\n        return int(decimal), 1\n    else:\n        number_of_frac_digits = len(str(decimal).split(\".\")[1])\n        numerator = int(decimal * (10**number_of_frac_digits))\n        denominator = 10**number_of_frac_digits\n        divisor, dividend = denominator, numerator\n        while True:\n            remainder = dividend % divisor\n            if remainder == 0:\n                break\n            dividend, divisor = divisor, remainder\n        numerator, denominator = numerator / divisor, denominator / divisor\n        return int(numerator), int(denominator)\n\n\nif __name__ == \"__main__\":\n    print(f\"{decimal_to_fraction(2) = }\")\n    print(f\"{decimal_to_fraction(89.0) = }\")\n    print(f\"{decimal_to_fraction('67') = }\")\n    print(f\"{decimal_to_fraction('45.0') = }\")\n    print(f\"{decimal_to_fraction(1.5) = }\")\n    print(f\"{decimal_to_fraction('6.25') = }\")\n    print(f\"{decimal_to_fraction('78td') = }\")\n", "maths/germain_primes.py": "\"\"\"\nA Sophie Germain prime is any prime p, where 2p + 1 is also prime.\nThe second number, 2p + 1 is called a safe prime.\n\nExamples of Germain primes include: 2, 3, 5, 11, 23\n\nTheir corresponding safe primes: 5, 7, 11, 23, 47\nhttps://en.wikipedia.org/wiki/Safe_and_Sophie_Germain_primes\n\"\"\"\n\nfrom maths.prime_check import is_prime\n\n\ndef is_germain_prime(number: int) -> bool:\n    \"\"\"Checks if input number and 2*number + 1 are prime.\n\n    >>> is_germain_prime(3)\n    True\n    >>> is_germain_prime(11)\n    True\n    >>> is_germain_prime(4)\n    False\n    >>> is_germain_prime(23)\n    True\n    >>> is_germain_prime(13)\n    False\n    >>> is_germain_prime(20)\n    False\n    >>> is_germain_prime('abc')\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a positive integer. Input value: abc\n    \"\"\"\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return is_prime(number) and is_prime(2 * number + 1)\n\n\ndef is_safe_prime(number: int) -> bool:\n    \"\"\"Checks if input number and (number - 1)/2 are prime.\n    The smallest safe prime is 5, with the Germain prime is 2.\n\n    >>> is_safe_prime(5)\n    True\n    >>> is_safe_prime(11)\n    True\n    >>> is_safe_prime(1)\n    False\n    >>> is_safe_prime(2)\n    False\n    >>> is_safe_prime(3)\n    False\n    >>> is_safe_prime(47)\n    True\n    >>> is_safe_prime('abc')\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value must be a positive integer. Input value: abc\n    \"\"\"\n    if not isinstance(number, int) or number < 1:\n        msg = f\"Input value must be a positive integer. Input value: {number}\"\n        raise TypeError(msg)\n\n    return (number - 1) % 2 == 0 and is_prime(number) and is_prime((number - 1) // 2)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "maths/average_median.py": "from __future__ import annotations\n\n\ndef median(nums: list) -> int | float:\n    \"\"\"\n    Find median of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Median\n\n    >>> median([0])\n    0\n    >>> median([4, 1, 3, 2])\n    2.5\n    >>> median([2, 70, 6, 50, 20, 8, 4])\n    8\n\n    Args:\n        nums: List of nums\n\n    Returns:\n        Median.\n    \"\"\"\n    # The sorted function returns list[SupportsRichComparisonT@sorted]\n    # which does not support `+`\n    sorted_list: list[int] = sorted(nums)\n    length = len(sorted_list)\n    mid_index = length >> 1\n    return (\n        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2\n        if length % 2 == 0\n        else sorted_list[mid_index]\n    )\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/factors.py": "from doctest import testmod\nfrom math import sqrt\n\n\ndef factors_of_a_number(num: int) -> list:\n    \"\"\"\n    >>> factors_of_a_number(1)\n    [1]\n    >>> factors_of_a_number(5)\n    [1, 5]\n    >>> factors_of_a_number(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> factors_of_a_number(-24)\n    []\n    \"\"\"\n    facs: list[int] = []\n    if num < 1:\n        return facs\n    facs.append(1)\n    if num == 1:\n        return facs\n    facs.append(num)\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:  # If i is a factor of num\n            facs.append(i)\n            d = num // i  # num//i is the other factor of num\n            if d != i:  # If d and i are distinct\n                facs.append(d)  # we have found another factor\n    facs.sort()\n    return facs\n\n\nif __name__ == \"__main__\":\n    testmod(name=\"factors_of_a_number\", verbose=True)\n", "maths/radix2_fft.py": "\"\"\"\nFast Polynomial Multiplication using radix-2 fast Fourier Transform.\n\"\"\"\n\nimport mpmath  # for roots of unity\nimport numpy as np\n\n\nclass FFT:\n    \"\"\"\n    Fast Polynomial Multiplication using radix-2 fast Fourier Transform.\n\n    Reference:\n    https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case\n\n    For polynomials of degree m and n the algorithms has complexity\n    O(n*logn + m*logm)\n\n    The main part of the algorithm is split in two parts:\n        1) __DFT: We compute the discrete fourier transform (DFT) of A and B using a\n        bottom-up dynamic approach -\n        2) __multiply: Once we obtain the DFT of A*B, we can similarly\n        invert it to obtain A*B\n\n    The class FFT takes two polynomials A and B with complex coefficients as arguments;\n    The two polynomials should be represented as a sequence of coefficients starting\n    from the free term. Thus, for instance x + 2*x^3 could be represented as\n    [0,1,0,2] or (0,1,0,2). The constructor adds some zeros at the end so that the\n    polynomials have the same length which is a power of 2 at least the length of\n    their product.\n\n    Example:\n\n    Create two polynomials as sequences\n    >>> A = [0, 1, 0, 2]  # x+2x^3\n    >>> B = (2, 3, 4, 0)  # 2+3x+4x^2\n\n    Create an FFT object with them\n    >>> x = FFT(A, B)\n\n    Print product\n    >>> x.product  # 2x + 3x^2 + 8x^3 + 4x^4 + 6x^5\n    [(-0+0j), (2+0j), (3+0j), (8+0j), (6+0j), (8+0j)]\n\n    __str__ test\n    >>> print(x)\n    A = 0*x^0 + 1*x^1 + 2*x^0 + 3*x^2\n    B = 0*x^2 + 1*x^3 + 2*x^4\n    A*B = 0*x^(-0+0j) + 1*x^(2+0j) + 2*x^(3+0j) + 3*x^(8+0j) + 4*x^(6+0j) + 5*x^(8+0j)\n    \"\"\"\n\n    def __init__(self, poly_a=None, poly_b=None):\n        # Input as list\n        self.polyA = list(poly_a or [0])[:]\n        self.polyB = list(poly_b or [0])[:]\n\n        # Remove leading zero coefficients\n        while self.polyA[-1] == 0:\n            self.polyA.pop()\n        self.len_A = len(self.polyA)\n\n        while self.polyB[-1] == 0:\n            self.polyB.pop()\n        self.len_B = len(self.polyB)\n\n        # Add 0 to make lengths equal a power of 2\n        self.c_max_length = int(\n            2 ** np.ceil(np.log2(len(self.polyA) + len(self.polyB) - 1))\n        )\n\n        while len(self.polyA) < self.c_max_length:\n            self.polyA.append(0)\n        while len(self.polyB) < self.c_max_length:\n            self.polyB.append(0)\n        # A complex root used for the fourier transform\n        self.root = complex(mpmath.root(x=1, n=self.c_max_length, k=1))\n\n        # The product\n        self.product = self.__multiply()\n\n    # Discrete fourier transform of A and B\n    def __dft(self, which):\n        dft = [[x] for x in self.polyA] if which == \"A\" else [[x] for x in self.polyB]\n        # Corner case\n        if len(dft) <= 1:\n            return dft[0]\n        #\n        next_ncol = self.c_max_length // 2\n        while next_ncol > 0:\n            new_dft = [[] for i in range(next_ncol)]\n            root = self.root**next_ncol\n\n            # First half of next step\n            current_root = 1\n            for j in range(self.c_max_length // (next_ncol * 2)):\n                for i in range(next_ncol):\n                    new_dft[i].append(dft[i][j] + current_root * dft[i + next_ncol][j])\n                current_root *= root\n            # Second half of next step\n            current_root = 1\n            for j in range(self.c_max_length // (next_ncol * 2)):\n                for i in range(next_ncol):\n                    new_dft[i].append(dft[i][j] - current_root * dft[i + next_ncol][j])\n                current_root *= root\n            # Update\n            dft = new_dft\n            next_ncol = next_ncol // 2\n        return dft[0]\n\n    # multiply the DFTs of  A and B and find A*B\n    def __multiply(self):\n        dft_a = self.__dft(\"A\")\n        dft_b = self.__dft(\"B\")\n        inverce_c = [[dft_a[i] * dft_b[i] for i in range(self.c_max_length)]]\n        del dft_a\n        del dft_b\n\n        # Corner Case\n        if len(inverce_c[0]) <= 1:\n            return inverce_c[0]\n        # Inverse DFT\n        next_ncol = 2\n        while next_ncol <= self.c_max_length:\n            new_inverse_c = [[] for i in range(next_ncol)]\n            root = self.root ** (next_ncol // 2)\n            current_root = 1\n            # First half of next step\n            for j in range(self.c_max_length // next_ncol):\n                for i in range(next_ncol // 2):\n                    # Even positions\n                    new_inverse_c[i].append(\n                        (\n                            inverce_c[i][j]\n                            + inverce_c[i][j + self.c_max_length // next_ncol]\n                        )\n                        / 2\n                    )\n                    # Odd positions\n                    new_inverse_c[i + next_ncol // 2].append(\n                        (\n                            inverce_c[i][j]\n                            - inverce_c[i][j + self.c_max_length // next_ncol]\n                        )\n                        / (2 * current_root)\n                    )\n                current_root *= root\n            # Update\n            inverce_c = new_inverse_c\n            next_ncol *= 2\n        # Unpack\n        inverce_c = [round(x[0].real, 8) + round(x[0].imag, 8) * 1j for x in inverce_c]\n\n        # Remove leading 0's\n        while inverce_c[-1] == 0:\n            inverce_c.pop()\n        return inverce_c\n\n    # Overwrite __str__ for print(); Shows A, B and A*B\n    def __str__(self):\n        a = \"A = \" + \" + \".join(\n            f\"{coef}*x^{i}\" for coef, i in enumerate(self.polyA[: self.len_A])\n        )\n        b = \"B = \" + \" + \".join(\n            f\"{coef}*x^{i}\" for coef, i in enumerate(self.polyB[: self.len_B])\n        )\n        c = \"A*B = \" + \" + \".join(\n            f\"{coef}*x^{i}\" for coef, i in enumerate(self.product)\n        )\n\n        return f\"{a}\\n{b}\\n{c}\"\n\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/largest_of_very_large_numbers.py": "# Author: Abhijeeth S\n\nimport math\n\n\ndef res(x, y):\n    \"\"\"\n    Reduces large number to a more manageable number\n    >>> res(5, 7)\n    4.892790030352132\n    >>> res(0, 5)\n    0\n    >>> res(3, 0)\n    1\n    >>> res(-1, 5)\n    Traceback (most recent call last):\n    ...\n    ValueError: math domain error\n    \"\"\"\n    if 0 not in (x, y):\n        # We use the relation x^y = y*log10(x), where 10 is the base.\n        return y * math.log10(x)\n    elif x == 0:  # 0 raised to any number is 0\n        return 0\n    elif y == 0:\n        return 1  # any number raised to 0 is 1\n    raise AssertionError(\"This should never happen\")\n\n\nif __name__ == \"__main__\":  # Main function\n    # Read two numbers from input and typecast them to int using map function.\n    # Here x is the base and y is the power.\n    prompt = \"Enter the base and the power separated by a comma: \"\n    x1, y1 = map(int, input(prompt).split(\",\"))\n    x2, y2 = map(int, input(prompt).split(\",\"))\n\n    # We find the log of each number, using the function res(), which takes two\n    # arguments.\n    res1 = res(x1, y1)\n    res2 = res(x2, y2)\n\n    # We check for the largest number\n    if res1 > res2:\n        print(\"Largest number is\", x1, \"^\", y1)\n    elif res2 > res1:\n        print(\"Largest number is\", x2, \"^\", y2)\n    else:\n        print(\"Both are equal\")\n", "maths/combinations.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Combination\n\"\"\"\n\n\ndef combinations(n: int, k: int) -> int:\n    \"\"\"\n    Returns the number of different combinations of k length which can\n    be made from n values, where n >= k.\n\n    Examples:\n    >>> combinations(10,5)\n    252\n\n    >>> combinations(6,3)\n    20\n\n    >>> combinations(20,5)\n    15504\n\n    >>> combinations(52, 5)\n    2598960\n\n    >>> combinations(0, 0)\n    1\n\n    >>> combinations(-4, -5)\n    ...\n    Traceback (most recent call last):\n    ValueError: Please enter positive integers for n and k where n >= k\n    \"\"\"\n\n    # If either of the conditions are true, the function is being asked\n    # to calculate a factorial of a negative number, which is not possible\n    if n < k or k < 0:\n        raise ValueError(\"Please enter positive integers for n and k where n >= k\")\n    res = 1\n    for i in range(k):\n        res *= n - i\n        res //= i + 1\n    return res\n\n\nif __name__ == \"__main__\":\n    print(\n        \"The number of five-card hands possible from a standard\",\n        f\"fifty-two card deck is: {combinations(52, 5)}\\n\",\n    )\n\n    print(\n        \"If a class of 40 students must be arranged into groups of\",\n        f\"4 for group projects, there are {combinations(40, 4)} ways\",\n        \"to arrange them.\\n\",\n    )\n\n    print(\n        \"If 10 teams are competing in a Formula One race, there\",\n        f\"are {combinations(10, 3)} ways that first, second and\",\n        \"third place can be awarded.\",\n    )\n", "maths/pi_monte_carlo_estimation.py": "import random\n\n\nclass Point:\n    def __init__(self, x: float, y: float) -> None:\n        self.x = x\n        self.y = y\n\n    def is_in_unit_circle(self) -> bool:\n        \"\"\"\n        True, if the point lies in the unit circle\n        False, otherwise\n        \"\"\"\n        return (self.x**2 + self.y**2) <= 1\n\n    @classmethod\n    def random_unit_square(cls):\n        \"\"\"\n        Generates a point randomly drawn from the unit square [0, 1) x [0, 1).\n        \"\"\"\n        return cls(x=random.random(), y=random.random())\n\n\ndef estimate_pi(number_of_simulations: int) -> float:\n    \"\"\"\n    Generates an estimate of the mathematical constant PI.\n    See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview\n\n    The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from\n    the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:\n\n        P[U in unit circle] = 1/4 PI\n\n    and therefore\n\n        PI = 4 * P[U in unit circle]\n\n    We can get an estimate of the probability P[U in unit circle].\n    See https://en.wikipedia.org/wiki/Empirical_probability by:\n\n        1. Draw a point uniformly from the unit square.\n        2. Repeat the first step n times and count the number of points in the unit\n            circle, which is called m.\n        3. An estimate of P[U in unit circle] is m/n\n    \"\"\"\n    if number_of_simulations < 1:\n        raise ValueError(\"At least one simulation is necessary to estimate PI.\")\n\n    number_in_unit_circle = 0\n    for _ in range(number_of_simulations):\n        random_point = Point.random_unit_square()\n\n        if random_point.is_in_unit_circle():\n            number_in_unit_circle += 1\n\n    return 4 * number_in_unit_circle / number_of_simulations\n\n\nif __name__ == \"__main__\":\n    # import doctest\n\n    # doctest.testmod()\n    from math import pi\n\n    prompt = \"Please enter the desired number of Monte Carlo simulations: \"\n    my_pi = estimate_pi(int(input(prompt).strip()))\n    print(f\"An estimate of PI is {my_pi} with an error of {abs(my_pi - pi)}\")\n", "maths/joint_probability_distribution.py": "\"\"\"\nCalculate joint probability distribution\nhttps://en.wikipedia.org/wiki/Joint_probability_distribution\n\"\"\"\n\n\ndef joint_probability_distribution(\n    x_values: list[int],\n    y_values: list[int],\n    x_probabilities: list[float],\n    y_probabilities: list[float],\n) -> dict:\n    \"\"\"\n    >>> joint_distribution =  joint_probability_distribution(\n    ...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]\n    ... )\n    >>> from math import isclose\n    >>> isclose(joint_distribution.pop((1, 8)), 0.14)\n    True\n    >>> joint_distribution\n    {(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}\n    \"\"\"\n    return {\n        (x, y): x_prob * y_prob\n        for x, x_prob in zip(x_values, x_probabilities)\n        for y, y_prob in zip(y_values, y_probabilities)\n    }\n\n\n# Function to calculate the expectation (mean)\ndef expectation(values: list, probabilities: list) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3)\n    True\n    \"\"\"\n    return sum(x * p for x, p in zip(values, probabilities))\n\n\n# Function to calculate the variance\ndef variance(values: list[int], probabilities: list[float]) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(variance([1,2],[0.7,0.3]), 0.21)\n    True\n    \"\"\"\n    mean = expectation(values, probabilities)\n    return sum((x - mean) ** 2 * p for x, p in zip(values, probabilities))\n\n\n# Function to calculate the covariance\ndef covariance(\n    x_values: list[int],\n    y_values: list[int],\n    x_probabilities: list[float],\n    y_probabilities: list[float],\n) -> float:\n    \"\"\"\n    >>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2])\n    -2.7755575615628914e-17\n    \"\"\"\n    mean_x = expectation(x_values, x_probabilities)\n    mean_y = expectation(y_values, y_probabilities)\n    return sum(\n        (x - mean_x) * (y - mean_y) * px * py\n        for x, px in zip(x_values, x_probabilities)\n        for y, py in zip(y_values, y_probabilities)\n    )\n\n\n# Function to calculate the standard deviation\ndef standard_deviation(variance: float) -> float:\n    \"\"\"\n    >>> standard_deviation(0.21)\n    0.458257569495584\n    \"\"\"\n    return variance**0.5\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    # Input values for X and Y\n    x_vals = input(\"Enter values of X separated by spaces: \").split()\n    y_vals = input(\"Enter values of Y separated by spaces: \").split()\n\n    # Convert input values to integers\n    x_values = [int(x) for x in x_vals]\n    y_values = [int(y) for y in y_vals]\n\n    # Input probabilities for X and Y\n    x_probs = input(\"Enter probabilities for X separated by spaces: \").split()\n    y_probs = input(\"Enter probabilities for Y separated by spaces: \").split()\n    assert len(x_values) == len(x_probs)\n    assert len(y_values) == len(y_probs)\n\n    # Convert input probabilities to floats\n    x_probabilities = [float(p) for p in x_probs]\n    y_probabilities = [float(p) for p in y_probs]\n\n    # Calculate the joint probability distribution\n    jpd = joint_probability_distribution(\n        x_values, y_values, x_probabilities, y_probabilities\n    )\n\n    # Print the joint probability distribution\n    print(\n        \"\\n\".join(\n            f\"P(X={x}, Y={y}) = {probability}\" for (x, y), probability in jpd.items()\n        )\n    )\n    mean_xy = expectation(\n        [x * y for x in x_values for y in y_values],\n        [px * py for px in x_probabilities for py in y_probabilities],\n    )\n    print(f\"x mean: {expectation(x_values, x_probabilities) = }\")\n    print(f\"y mean: {expectation(y_values, y_probabilities) = }\")\n    print(f\"xy mean: {mean_xy}\")\n    print(f\"x: {variance(x_values, x_probabilities) = }\")\n    print(f\"y: {variance(y_values, y_probabilities) = }\")\n    print(f\"{covariance(x_values, y_values, x_probabilities, y_probabilities) = }\")\n    print(f\"x: {standard_deviation(variance(x_values, x_probabilities)) = }\")\n    print(f\"y: {standard_deviation(variance(y_values, y_probabilities)) = }\")\n", "maths/average_absolute_deviation.py": "def average_absolute_deviation(nums: list[int]) -> float:\n    \"\"\"\n    Return the average absolute deviation of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Average_absolute_deviation\n\n    >>> average_absolute_deviation([0])\n    0.0\n    >>> average_absolute_deviation([4, 1, 3, 2])\n    1.0\n    >>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0])\n    20.0\n    >>> average_absolute_deviation([-20, 0, 30, 15])\n    16.25\n    >>> average_absolute_deviation([])\n    Traceback (most recent call last):\n        ...\n    ValueError: List is empty\n    \"\"\"\n    if not nums:  # Makes sure that the list is not empty\n        raise ValueError(\"List is empty\")\n\n    average = sum(nums) / len(nums)  # Calculate the average\n    return sum(abs(x - average) for x in nums) / len(nums)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/abs.py": "\"\"\"Absolute Value.\"\"\"\n\n\ndef abs_val(num: float) -> float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_min([0,5,1,11])\n    0\n    >>> abs_min([3,-10,-2])\n    -2\n    >>> abs_min([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_min() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_min() arg is an empty sequence\")\n    j = x[0]\n    for i in x:\n        if abs_val(i) < abs_val(j):\n            j = i\n    return j\n\n\ndef abs_max(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    >>> abs_max([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_max() arg is an empty sequence\")\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j\n\n\ndef abs_max_sort(x: list[int]) -> int:\n    \"\"\"\n    >>> abs_max_sort([0,5,1,11])\n    11\n    >>> abs_max_sort([3,-10,-2])\n    -10\n    >>> abs_max_sort([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max_sort() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError(\"abs_max_sort() arg is an empty sequence\")\n    return sorted(x, key=abs)[-1]\n\n\ndef test_abs_val():\n    \"\"\"\n    >>> test_abs_val()\n    \"\"\"\n    assert abs_val(0) == 0\n    assert abs_val(34) == 34\n    assert abs_val(-100000000000) == 100000000000\n\n    a = [-3, -1, 2, -11]\n    assert abs_max(a) == -11\n    assert abs_max_sort(a) == -11\n    assert abs_min(a) == -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    test_abs_val()\n    print(abs_val(-34))  # --> 34\n", "maths/jaccard_similarity.py": "\"\"\"\nThe Jaccard similarity coefficient is a commonly used indicator of the\nsimilarity between two sets. Let U be a set and A and B be subsets of U,\nthen the Jaccard index/similarity is defined to be the ratio of the number\nof elements of their intersection and the number of elements of their union.\n\nInspired from Wikipedia and\nthe book Mining of Massive Datasets [MMDS 2nd Edition, Chapter 3]\n\nhttps://en.wikipedia.org/wiki/Jaccard_index\nhttps://mmds.org\n\nJaccard similarity is widely used with MinHashing.\n\"\"\"\n\n\ndef jaccard_similarity(\n    set_a: set[str] | list[str] | tuple[str],\n    set_b: set[str] | list[str] | tuple[str],\n    alternative_union=False,\n):\n    \"\"\"\n    Finds the jaccard similarity between two sets.\n    Essentially, its intersection over union.\n\n    The alternative way to calculate this is to take union as sum of the\n    number of items in the two sets. This will lead to jaccard similarity\n    of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]\n\n    Parameters:\n        :set_a (set,list,tuple): A non-empty set/list\n        :set_b (set,list,tuple): A non-empty set/list\n        :alternativeUnion (boolean): If True, use sum of number of\n        items as union\n\n    Output:\n        (float) The jaccard similarity between the two sets.\n\n    Examples:\n    >>> set_a = {'a', 'b', 'c', 'd', 'e'}\n    >>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'}\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> jaccard_similarity(set_a, set_a)\n    1.0\n    >>> jaccard_similarity(set_a, set_a, True)\n    0.5\n    >>> set_a = ['a', 'b', 'c', 'd', 'e']\n    >>> set_b = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> set_b = ['a', 'b', 'c', 'd', 'e']\n    >>> jaccard_similarity(set_a, set_b)\n    0.375\n    >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')\n    >>> set_b = ['a', 'b', 'c', 'd']\n    >>> jaccard_similarity(set_a, set_b, True)\n    0.2\n    >>> set_a = {'a', 'b'}\n    >>> set_b = ['c', 'd']\n    >>> jaccard_similarity(set_a, set_b)\n    Traceback (most recent call last):\n        ...\n    ValueError: Set a and b must either both be sets or be either a list or a tuple.\n    \"\"\"\n\n    if isinstance(set_a, set) and isinstance(set_b, set):\n        intersection_length = len(set_a.intersection(set_b))\n\n        if alternative_union:\n            union_length = len(set_a) + len(set_b)\n        else:\n            union_length = len(set_a.union(set_b))\n\n        return intersection_length / union_length\n\n    elif isinstance(set_a, (list, tuple)) and isinstance(set_b, (list, tuple)):\n        intersection = [element for element in set_a if element in set_b]\n\n        if alternative_union:\n            return len(intersection) / (len(set_a) + len(set_b))\n        else:\n            # Cast set_a to list because tuples cannot be mutated\n            union = list(set_a) + [element for element in set_b if element not in set_a]\n            return len(intersection) / len(union)\n    raise ValueError(\n        \"Set a and b must either both be sets or be either a list or a tuple.\"\n    )\n\n\nif __name__ == \"__main__\":\n    set_a = {\"a\", \"b\", \"c\", \"d\", \"e\"}\n    set_b = {\"c\", \"d\", \"e\", \"f\", \"h\", \"i\"}\n    print(jaccard_similarity(set_a, set_b))\n", "maths/line_length.py": "from __future__ import annotations\n\nimport math\nfrom collections.abc import Callable\n\n\ndef line_length(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Approximates the arc length of a line segment by treating the curve as a\n    sequence of linear lines and summing their lengths\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return x\n    >>> f\"{line_length(f, 0, 1, 10):.6f}\"\n    '1.414214'\n\n    >>> def f(x):\n    ...    return 1\n    >>> f\"{line_length(f, -5.5, 4.5):.6f}\"\n    '10.000000'\n\n    >>> def f(x):\n    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10\n    >>> f\"{line_length(f, 0.0, 10.0, 10000):.6f}\"\n    '69.534930'\n    \"\"\"\n\n    x1 = x_start\n    fx1 = fnc(x_start)\n    length = 0.0\n\n    for _ in range(steps):\n        # Approximates curve as a sequence of linear lines and sums their length\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        length += math.hypot(x2 - x1, fx2 - fx1)\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n\n    return length\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return math.sin(10 * x)\n\n    print(\"f(x) = sin(10 * x)\")\n    print(\"The length of the curve from x = -10 to x = 10 is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"With {i} steps: {line_length(f, -10, 10, i)}\")\n        i *= 10\n", "maths/gcd_of_n_numbers.py": "\"\"\"\nGcd of N Numbers\nReference: https://en.wikipedia.org/wiki/Greatest_common_divisor\n\"\"\"\n\nfrom collections import Counter\n\n\ndef get_factors(\n    number: int, factors: Counter | None = None, factor: int = 2\n) -> Counter:\n    \"\"\"\n    this is a recursive function for get all factors of number\n    >>> get_factors(45)\n    Counter({3: 2, 5: 1})\n    >>> get_factors(2520)\n    Counter({2: 3, 3: 2, 5: 1, 7: 1})\n    >>> get_factors(23)\n    Counter({23: 1})\n    >>> get_factors(0)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(-1)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n    >>> get_factors(1.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be integer and greater than zero\n\n    factor can be all numbers from 2 to number that we check if number % factor == 0\n    if it is equal to zero, we check again with number // factor\n    else we increase factor by one\n    \"\"\"\n\n    match number:\n        case int(number) if number == 1:\n            return Counter({1: 1})\n        case int(num) if number > 0:\n            number = num\n        case _:\n            raise TypeError(\"number must be integer and greater than zero\")\n\n    factors = factors or Counter()\n\n    if number == factor:  # break condition\n        # all numbers are factors of itself\n        factors[factor] += 1\n        return factors\n\n    if number % factor > 0:\n        # if it is greater than zero\n        # so it is not a factor of number and we check next number\n        return get_factors(number, factors, factor + 1)\n\n    factors[factor] += 1\n    # else we update factors (that is Counter(dict-like) type) and check again\n    return get_factors(number // factor, factors, factor)\n\n\ndef get_greatest_common_divisor(*numbers: int) -> int:\n    \"\"\"\n    get gcd of n numbers:\n    >>> get_greatest_common_divisor(18, 45)\n    9\n    >>> get_greatest_common_divisor(23, 37)\n    1\n    >>> get_greatest_common_divisor(2520, 8350)\n    10\n    >>> get_greatest_common_divisor(-10, 20)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    >>> get_greatest_common_divisor(1.5, 2)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    >>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    1\n    >>> get_greatest_common_divisor(\"1\", 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    Traceback (most recent call last):\n        ...\n    Exception: numbers must be integer and greater than zero\n    \"\"\"\n\n    # we just need factors, not numbers itself\n    try:\n        same_factors, *factors = map(get_factors, numbers)\n    except TypeError as e:\n        raise Exception(\"numbers must be integer and greater than zero\") from e\n\n    for factor in factors:\n        same_factors &= factor\n        # get common factor between all\n        # `&` return common elements with smaller value (for Counter type)\n\n    # now, same_factors is something like {2: 2, 3: 4} that means 2 * 2 * 3 * 3 * 3 * 3\n    mult = 1\n    # power each factor and multiply\n    # for {2: 2, 3: 4}, it is [4, 81] and then 324\n    for m in [factor**power for factor, power in same_factors.items()]:\n        mult *= m\n    return mult\n\n\nif __name__ == \"__main__\":\n    print(get_greatest_common_divisor(18, 45))  # 9\n", "maths/find_min.py": "from __future__ import annotations\n\n\ndef find_min_iterative(nums: list[int | float]) -> int | float:\n    \"\"\"\n    Find Minimum Number in a List\n    :param nums: contains elements\n    :return: min number in list\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_min_iterative(nums) == min(nums)\n    True\n    True\n    True\n    True\n    >>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])\n    -56\n    >>> find_min_iterative([])\n    Traceback (most recent call last):\n        ...\n    ValueError: find_min_iterative() arg is an empty sequence\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_min_iterative() arg is an empty sequence\")\n    min_num = nums[0]\n    for num in nums:\n        min_num = min(min_num, num)\n    return min_num\n\n\n# Divide and Conquer algorithm\ndef find_min_recursive(nums: list[int | float], left: int, right: int) -> int | float:\n    \"\"\"\n    find min value in list\n    :param nums: contains elements\n    :param left: index of first element\n    :param right: index of last element\n    :return: min in nums\n\n    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):\n    ...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\n    True\n    True\n    True\n    True\n    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n    >>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums)\n    True\n    >>> find_min_recursive([], 0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: find_min_recursive() arg is an empty sequence\n    >>> find_min_recursive(nums, 0, len(nums)) == min(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    >>> find_min_recursive(nums, -len(nums), -1) == min(nums)\n    True\n    >>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums)\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    if len(nums) == 0:\n        raise ValueError(\"find_min_recursive() arg is an empty sequence\")\n    if (\n        left >= len(nums)\n        or left < -len(nums)\n        or right >= len(nums)\n        or right < -len(nums)\n    ):\n        raise IndexError(\"list index out of range\")\n    if left == right:\n        return nums[left]\n    mid = (left + right) >> 1  # the middle\n    left_min = find_min_recursive(nums, left, mid)  # find min in range[left, mid]\n    right_min = find_min_recursive(\n        nums, mid + 1, right\n    )  # find min in range[mid + 1, right]\n\n    return left_min if left_min <= right_min else right_min\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n", "maths/is_ip_v4_address_valid.py": "\"\"\"\nIs IP v4 address valid?\nA valid IP address must be four octets in the form of A.B.C.D,\nwhere A,B,C and D are numbers from 0-254\nfor example: 192.168.23.1, 172.254.254.254 are valid IP address\n             192.168.255.0, 255.192.3.121 are invalid IP address\n\"\"\"\n\n\ndef is_ip_v4_address_valid(ip_v4_address: str) -> bool:\n    \"\"\"\n    print \"Valid IP address\" If IP is valid.\n    or\n    print \"Invalid IP address\" If IP is invalid.\n\n    >>> is_ip_v4_address_valid(\"192.168.0.23\")\n    True\n\n    >>> is_ip_v4_address_valid(\"192.255.15.8\")\n    False\n\n    >>> is_ip_v4_address_valid(\"172.100.0.8\")\n    True\n\n    >>> is_ip_v4_address_valid(\"254.255.0.255\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.33333333.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.-3.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.3.4.5\")\n    False\n\n    >>> is_ip_v4_address_valid(\"1.2.A.4\")\n    False\n\n    >>> is_ip_v4_address_valid(\"0.0.0.0\")\n    True\n\n    >>> is_ip_v4_address_valid(\"1.2.3.\")\n    False\n    \"\"\"\n    octets = [int(i) for i in ip_v4_address.split(\".\") if i.isdigit()]\n    return len(octets) == 4 and all(0 <= int(octet) <= 254 for octet in octets)\n\n\nif __name__ == \"__main__\":\n    ip = input().strip()\n    valid_or_invalid = \"valid\" if is_ip_v4_address_valid(ip) else \"invalid\"\n    print(f\"{ip} is a {valid_or_invalid} IP v4 address.\")\n", "maths/simultaneous_linear_equation_solver.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Augmented_matrix\n\nThis algorithm solves simultaneous linear equations of the form\n\u03bba + \u03bbb + \u03bbc + \u03bbd + ... = y as [\u03bb, \u03bb, \u03bb, \u03bb, ..., y]\nWhere \u03bb & y are individual coefficients, the no. of equations = no. of coefficients - 1\n\nNote in order to work there must exist 1 equation where all instances of \u03bb and y != 0\n\"\"\"\n\n\ndef simplify(current_set: list[list]) -> list[list]:\n    \"\"\"\n    >>> simplify([[1, 2, 3], [4, 5, 6]])\n    [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]\n    >>> simplify([[5, 2, 5], [5, 1, 10]])\n    [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]\n    \"\"\"\n    # Divide each row by magnitude of first term --> creates 'unit' matrix\n    duplicate_set = current_set.copy()\n    for row_index, row in enumerate(duplicate_set):\n        magnitude = row[0]\n        for column_index, column in enumerate(row):\n            if magnitude == 0:\n                current_set[row_index][column_index] = column\n                continue\n            current_set[row_index][column_index] = column / magnitude\n    # Subtract to cancel term\n    first_row = current_set[0]\n    final_set = [first_row]\n    current_set = current_set[1::]\n    for row in current_set:\n        temp_row = []\n        # If first term is 0, it is already in form we want, so we preserve it\n        if row[0] == 0:\n            final_set.append(row)\n            continue\n        for column_index in range(len(row)):\n            temp_row.append(first_row[column_index] - row[column_index])\n        final_set.append(temp_row)\n    # Create next recursion iteration set\n    if len(final_set[0]) != 3:\n        current_first_row = final_set[0]\n        current_first_column = []\n        next_iteration = []\n        for row in final_set[1::]:\n            current_first_column.append(row[0])\n            next_iteration.append(row[1::])\n        resultant = simplify(next_iteration)\n        for i in range(len(resultant)):\n            resultant[i].insert(0, current_first_column[i])\n        resultant.insert(0, current_first_row)\n        final_set = resultant\n    return final_set\n\n\ndef solve_simultaneous(equations: list[list]) -> list:\n    \"\"\"\n    >>> solve_simultaneous([[1, 2, 3],[4, 5, 6]])\n    [-1.0, 2.0]\n    >>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]])\n    [6.4, 1.2, 10.6]\n    >>> solve_simultaneous([])\n    Traceback (most recent call last):\n        ...\n    IndexError: solve_simultaneous() requires n lists of length n+1\n    >>> solve_simultaneous([[1, 2, 3],[1, 2]])\n    Traceback (most recent call last):\n        ...\n    IndexError: solve_simultaneous() requires n lists of length n+1\n    >>> solve_simultaneous([[1, 2, 3],[\"a\", 7, 8]])\n    Traceback (most recent call last):\n        ...\n    ValueError: solve_simultaneous() requires lists of integers\n    >>> solve_simultaneous([[0, 2, 3],[4, 0, 6]])\n    Traceback (most recent call last):\n        ...\n    ValueError: solve_simultaneous() requires at least 1 full equation\n    \"\"\"\n    if len(equations) == 0:\n        raise IndexError(\"solve_simultaneous() requires n lists of length n+1\")\n    _length = len(equations) + 1\n    if any(len(item) != _length for item in equations):\n        raise IndexError(\"solve_simultaneous() requires n lists of length n+1\")\n    for row in equations:\n        if any(not isinstance(column, (int, float)) for column in row):\n            raise ValueError(\"solve_simultaneous() requires lists of integers\")\n    if len(equations) == 1:\n        return [equations[0][-1] / equations[0][0]]\n    data_set = equations.copy()\n    if any(0 in row for row in data_set):\n        temp_data = data_set.copy()\n        full_row = []\n        for row_index, row in enumerate(temp_data):\n            if 0 not in row:\n                full_row = data_set.pop(row_index)\n                break\n        if not full_row:\n            raise ValueError(\"solve_simultaneous() requires at least 1 full equation\")\n        data_set.insert(0, full_row)\n    useable_form = data_set.copy()\n    simplified = simplify(useable_form)\n    simplified = simplified[::-1]\n    solutions: list = []\n    for row in simplified:\n        current_solution = row[-1]\n        if not solutions:\n            if row[-2] == 0:\n                solutions.append(0)\n                continue\n            solutions.append(current_solution / row[-2])\n            continue\n        temp_row = row.copy()[: len(row) - 1 :]\n        while temp_row[0] == 0:\n            temp_row.pop(0)\n        if len(temp_row) == 0:\n            solutions.append(0)\n            continue\n        temp_row = temp_row[1::]\n        temp_row = temp_row[::-1]\n        for column_index, column in enumerate(temp_row):\n            current_solution -= column * solutions[column_index]\n        solutions.append(current_solution)\n    final = []\n    for item in solutions:\n        final.append(float(round(item, 5)))\n    return final[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    eq = [\n        [2, 1, 1, 1, 1, 4],\n        [1, 2, 1, 1, 1, 5],\n        [1, 1, 2, 1, 1, 6],\n        [1, 1, 1, 2, 1, 7],\n        [1, 1, 1, 1, 2, 8],\n    ]\n    print(solve_simultaneous(eq))\n    print(solve_simultaneous([[4, 2]]))\n", "maths/interquartile_range.py": "\"\"\"\nAn implementation of interquartile range (IQR) which is a measure of statistical\ndispersion, which is the spread of the data.\n\nThe function takes the list of numeric values as input and returns the IQR.\n\nScript inspired by this Wikipedia article:\nhttps://en.wikipedia.org/wiki/Interquartile_range\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef find_median(nums: list[int | float]) -> float:\n    \"\"\"\n    This is the implementation of the median.\n    :param nums: The list of numeric nums\n    :return: Median of the list\n    >>> find_median(nums=([1, 2, 2, 3, 4]))\n    2\n    >>> find_median(nums=([1, 2, 2, 3, 4, 4]))\n    2.5\n    >>> find_median(nums=([-1, 2, 0, 3, 4, -4]))\n    1.5\n    >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))\n    2.65\n    \"\"\"\n    div, mod = divmod(len(nums), 2)\n    if mod:\n        return nums[div]\n    return (nums[div] + nums[(div) - 1]) / 2\n\n\ndef interquartile_range(nums: list[int | float]) -> float:\n    \"\"\"\n    Return the interquartile range for a list of numeric values.\n    :param nums: The list of numeric values.\n    :return: interquartile range\n\n    >>> interquartile_range(nums=[4, 1, 2, 3, 2])\n    2.0\n    >>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45])\n    17.0\n    >>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1])\n    17.2\n    >>> interquartile_range(nums = [0, 0, 0, 0, 0])\n    0.0\n    >>> interquartile_range(nums=[])\n    Traceback (most recent call last):\n    ...\n    ValueError: The list is empty. Provide a non-empty list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty. Provide a non-empty list.\")\n    nums.sort()\n    length = len(nums)\n    div, mod = divmod(length, 2)\n    q1 = find_median(nums[:div])\n    half_length = sum((div, mod))\n    q3 = find_median(nums[half_length:length])\n    return q3 - q1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/euler_modified.py": "from collections.abc import Callable\n\nimport numpy as np\n\n\ndef euler_modified(\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate solution at each step to an ODE using Euler's Modified Method\n    The Euler Method is straightforward to implement, but can't give accurate solutions.\n    So, some changes were proposed to improve accuracy.\n\n    https://en.wikipedia.org/wiki/Euler_method\n\n    Arguments:\n    ode_func -- The ode as a function of x and y\n    y0 -- the initial value for y\n    x0 -- the initial value for x\n    stepsize -- the increment value for x\n    x_end -- the end value for x\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f1(x, y):\n    ...     return -2*x*(y**2)\n    >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)\n    >>> y[-1]\n    0.503338255442106\n    >>> import math\n    >>> def f2(x, y):\n    ...     return -2*y + (x**3)*math.exp(-2*x)\n    >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)\n    >>> y[-1]\n    0.5525976431951775\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        y_get = y[k] + step_size * ode_func(x, y[k])\n        y[k + 1] = y[k] + (\n            (step_size / 2) * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))\n        )\n        x += step_size\n\n    return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/fibonacci.py": "\"\"\"\nCalculates the Fibonacci sequence using iteration, recursion, memoization,\nand a simplified form of Binet's formula\n\nNOTE 1: the iterative, recursive, memoization functions are more accurate than\nthe Binet's formula function because the Binet formula function  uses floats\n\nNOTE 2: the Binet's formula function is much more limited in the size of inputs\nthat it can handle due to the size limitations of Python floats\n\nSee benchmark numbers in __main__ for performance comparisons/\nhttps://en.wikipedia.org/wiki/Fibonacci_number for more information\n\"\"\"\n\nimport functools\nfrom collections.abc import Iterator\nfrom math import sqrt\nfrom time import time\n\n\ndef time_func(func, *args, **kwargs):\n    \"\"\"\n    Times the execution of a function with parameters\n    \"\"\"\n    start = time()\n    output = func(*args, **kwargs)\n    end = time()\n    if int(end - start) > 0:\n        print(f\"{func.__name__} runtime: {(end - start):0.4f} s\")\n    else:\n        print(f\"{func.__name__} runtime: {(end - start) * 1000:0.4f} ms\")\n    return output\n\n\ndef fib_iterative_yield(n: int) -> Iterator[int]:\n    \"\"\"\n    Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield\n    >>> list(fib_iterative_yield(0))\n    [0]\n    >>> tuple(fib_iterative_yield(1))\n    (0, 1)\n    >>> tuple(fib_iterative_yield(5))\n    (0, 1, 1, 2, 3, 5)\n    >>> tuple(fib_iterative_yield(10))\n    (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)\n    >>> tuple(fib_iterative_yield(-1))\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    a, b = 0, 1\n    yield a\n    for _ in range(n):\n        yield b\n        a, b = b, a + b\n\n\ndef fib_iterative(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using iteration\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n == 0:\n        return [0]\n    fib = [0, 1]\n    for _ in range(n - 1):\n        fib.append(fib[-1] + fib[-2])\n    return fib\n\n\ndef fib_recursive(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using recursion\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n\n    def fib_recursive_term(i: int) -> int:\n        \"\"\"\n        Calculates the i-th (0-indexed) Fibonacci number using recursion\n        >>> fib_recursive_term(0)\n        0\n        >>> fib_recursive_term(1)\n        1\n        >>> fib_recursive_term(5)\n        5\n        >>> fib_recursive_term(10)\n        55\n        >>> fib_recursive_term(-1)\n        Traceback (most recent call last):\n            ...\n        Exception: n is negative\n        \"\"\"\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]\n\n\ndef fib_recursive_cached(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using recursion\n    >>> fib_iterative(0)\n    [0]\n    >>> fib_iterative(1)\n    [0, 1]\n    >>> fib_iterative(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_iterative(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n\n    @functools.cache\n    def fib_recursive_term(i: int) -> int:\n        \"\"\"\n        Calculates the i-th (0-indexed) Fibonacci number using recursion\n        \"\"\"\n        if i < 0:\n            raise ValueError(\"n is negative\")\n        if i < 2:\n            return i\n        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)\n\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    return [fib_recursive_term(i) for i in range(n + 1)]\n\n\ndef fib_memoization(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using memoization\n    >>> fib_memoization(0)\n    [0]\n    >>> fib_memoization(1)\n    [0, 1]\n    >>> fib_memoization(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_memoization(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    # Cache must be outside recursuive function\n    # other it will reset every time it calls itself.\n    cache: dict[int, int] = {0: 0, 1: 1, 2: 1}  # Prefilled cache\n\n    def rec_fn_memoized(num: int) -> int:\n        if num in cache:\n            return cache[num]\n\n        value = rec_fn_memoized(num - 1) + rec_fn_memoized(num - 2)\n        cache[num] = value\n        return value\n\n    return [rec_fn_memoized(i) for i in range(n + 1)]\n\n\ndef fib_binet(n: int) -> list[int]:\n    \"\"\"\n    Calculates the first n (0-indexed) Fibonacci numbers using a simplified form\n    of Binet's formula:\n    https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding\n\n    NOTE 1: this function diverges from fib_iterative at around n = 71, likely\n    due to compounding floating-point arithmetic errors\n\n    NOTE 2: this function doesn't accept n >= 1475 because it overflows\n    thereafter due to the size limitations of Python floats\n    >>> fib_binet(0)\n    [0]\n    >>> fib_binet(1)\n    [0, 1]\n    >>> fib_binet(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib_binet(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> fib_binet(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is negative\n    >>> fib_binet(1475)\n    Traceback (most recent call last):\n        ...\n    ValueError: n is too large\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n is negative\")\n    if n >= 1475:\n        raise ValueError(\"n is too large\")\n    sqrt_5 = sqrt(5)\n    phi = (1 + sqrt_5) / 2\n    return [round(phi**i / sqrt_5) for i in range(n + 1)]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    # Time on an M1 MacBook Pro -- Fastest to slowest\n    num = 30\n    time_func(fib_iterative_yield, num)  # 0.0012 ms\n    time_func(fib_iterative, num)  # 0.0031 ms\n    time_func(fib_binet, num)  # 0.0062 ms\n    time_func(fib_memoization, num)  # 0.0100 ms\n    time_func(fib_recursive_cached, num)  # 0.0153 ms\n    time_func(fib_recursive, num)  # 257.0910 ms\n", "maths/check_polygon.py": "from __future__ import annotations\n\n\ndef check_polygon(nums: list[float]) -> bool:\n    \"\"\"\n    Takes list of possible side lengths and determines whether a\n    two-dimensional polygon with such side lengths can exist.\n\n    Returns a boolean value for the < comparison\n    of the largest side length with sum of the rest.\n    Wiki: https://en.wikipedia.org/wiki/Triangle_inequality\n\n    >>> check_polygon([6, 10, 5])\n    True\n    >>> check_polygon([3, 7, 13, 2])\n    False\n    >>> check_polygon([1, 4.3, 5.2, 12.2])\n    False\n    >>> nums = [3, 7, 13, 2]\n    >>> _ = check_polygon(nums) #   Run function, do not show answer in output\n    >>> nums #  Check numbers are not reordered\n    [3, 7, 13, 2]\n    >>> check_polygon([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Monogons and Digons are not polygons in the Euclidean space\n    >>> check_polygon([-2, 5, 6])\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be greater than 0\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"Monogons and Digons are not polygons in the Euclidean space\")\n    if any(i <= 0 for i in nums):\n        raise ValueError(\"All values must be greater than 0\")\n    copy_nums = nums.copy()\n    copy_nums.sort()\n    return copy_nums[-1] < sum(copy_nums[:-1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/modular_division.py": "from __future__ import annotations\n\n\ndef modular_division(a: int, b: int, n: int) -> int:\n    \"\"\"\n    Modular Division :\n    An efficient algorithm for dividing b by a modulo n.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should\n    return an integer x such that 0\u2264x\u2264n-1, and  b/a=x(modn) (that is, b=ax(modn)).\n\n    Theorem:\n    a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n    This find x = b*a^(-1) mod n\n    Uses ExtendedEuclid to find the inverse of a\n\n    >>> modular_division(4,8,5)\n    2\n\n    >>> modular_division(3,8,5)\n    1\n\n    >>> modular_division(4, 11, 5)\n    4\n\n    \"\"\"\n    assert n > 1\n    assert a > 0\n    assert greatest_common_divisor(a, n) == 1\n    (d, t, s) = extended_gcd(n, a)  # Implemented below\n    x = (b * s) % n\n    return x\n\n\ndef invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    This function find the inverses of a i.e., a^(-1)\n\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, x) = extended_euclid(a, n)  # Implemented below\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n# ------------------ Finding Modular division using invert_modulo -------------------\n\n\ndef modular_division2(a: int, b: int, n: int) -> int:\n    \"\"\"\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\n\n    >>> modular_division2(4,8,5)\n    2\n\n    >>> modular_division2(3,8,5)\n    1\n\n    >>> modular_division2(4, 11, 5)\n    4\n\n    \"\"\"\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    return x\n\n\ndef extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n    \"\"\"\n    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    >>> extended_gcd(10, 6)\n    (2, -1, 2)\n\n    >>> extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    \"\"\"\n    assert a >= 0\n    assert b >= 0\n\n    if b == 0:\n        d, x, y = a, 1, 0\n    else:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    assert a % d == 0\n    assert b % d == 0\n    assert d == a * x + b * y\n\n    return (d, x, y)\n\n\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    Extended Euclid\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid's Algorithm\n\n    >>> greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    >>> greatest_common_divisor(121, 11)\n    11\n\n    \"\"\"\n    if a < b:\n        a, b = b, a\n\n    while a % b != 0:\n        a, b = b, a % b\n\n    return b\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"modular_division\", verbose=True)\n    testmod(name=\"modular_division2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_gcd\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)\n    testmod(name=\"greatest_common_divisor\", verbose=True)\n", "maths/segmented_sieve.py": "\"\"\"Segmented Sieve.\"\"\"\n\nimport math\n\n\ndef sieve(n: int) -> list[int]:\n    \"\"\"\n    Segmented Sieve.\n\n    Examples:\n    >>> sieve(8)\n    [2, 3, 5, 7]\n\n    >>> sieve(27)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\n    >>> sieve(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number 0 must instead be a positive integer\n\n    >>> sieve(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number -1 must instead be a positive integer\n\n    >>> sieve(22.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Number 22.2 must instead be a positive integer\n    \"\"\"\n\n    if n <= 0 or isinstance(n, float):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    in_prime = []\n    start = 2\n    end = int(math.sqrt(n))  # Size of every segment\n    temp = [True] * (end + 1)\n    prime = []\n\n    while start <= end:\n        if temp[start] is True:\n            in_prime.append(start)\n            for i in range(start * start, end + 1, start):\n                temp[i] = False\n        start += 1\n    prime += in_prime\n\n    low = end + 1\n    high = min(2 * end, n)\n\n    while low <= n:\n        temp = [True] * (high - low + 1)\n        for each in in_prime:\n            t = math.floor(low / each) * each\n            if t < low:\n                t += each\n\n            for j in range(t, high + 1, each):\n                temp[j - low] = False\n\n        for j in range(len(temp)):\n            if temp[j] is True:\n                prime.append(j + low)\n\n        low = high + 1\n        high = min(high + end, n)\n\n    return prime\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(f\"{sieve(10**6) = }\")\n", "maths/prime_sieve_eratosthenes.py": "\"\"\"\nSieve of Eratosthenes\n\nInput: n = 10\nOutput: 2 3 5 7\n\nInput: n = 20\nOutput: 2 3 5 7 11 13 17 19\n\nyou can read in detail about this at\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\"\"\"\n\n\ndef prime_sieve_eratosthenes(num: int) -> list[int]:\n    \"\"\"\n    Print the prime numbers up to n\n\n    >>> prime_sieve_eratosthenes(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve_eratosthenes(20)\n    [2, 3, 5, 7, 11, 13, 17, 19]\n    >>> prime_sieve_eratosthenes(2)\n    [2]\n    >>> prime_sieve_eratosthenes(1)\n    []\n    >>> prime_sieve_eratosthenes(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input must be a positive integer\n    \"\"\"\n\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    primes = [True] * (num + 1)\n\n    p = 2\n    while p * p <= num:\n        if primes[p]:\n            for i in range(p * p, num + 1, p):\n                primes[i] = False\n        p += 1\n\n    return [prime for prime in range(2, num + 1) if primes[prime]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    user_num = int(input(\"Enter a positive integer: \").strip())\n    print(prime_sieve_eratosthenes(user_num))\n", "maths/maclaurin_series.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Taylor_series#Trigonometric_functions\n\"\"\"\n\nfrom math import factorial, pi\n\n\ndef maclaurin_sin(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of sin\n\n    :param theta: the angle to which sin is found\n    :param accuracy: the degree of accuracy wanted minimum\n    :return: the value of sine in radians\n\n\n    >>> from math import isclose, sin\n    >>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_sin(10)\n    -0.5440211108893691\n    >>> maclaurin_sin(-10)\n    0.5440211108893704\n    >>> maclaurin_sin(10, 15)\n    -0.544021110889369\n    >>> maclaurin_sin(-10, 15)\n    0.5440211108893704\n    >>> maclaurin_sin(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires either an int or float for theta\n    >>> maclaurin_sin(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    >>> maclaurin_sin(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_sin() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_sin() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_sin() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum(\n        (-1) ** r * theta ** (2 * r + 1) / factorial(2 * r + 1) for r in range(accuracy)\n    )\n\n\ndef maclaurin_cos(theta: float, accuracy: int = 30) -> float:\n    \"\"\"\n    Finds the maclaurin approximation of cos\n\n    :param theta: the angle to which cos is found\n    :param accuracy: the degree of accuracy wanted\n    :return: the value of cosine in radians\n\n\n    >>> from math import isclose, cos\n    >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))\n    True\n    >>> maclaurin_cos(5)\n    0.2836621854632268\n    >>> maclaurin_cos(-5)\n    0.2836621854632265\n    >>> maclaurin_cos(10, 15)\n    -0.8390715290764524\n    >>> maclaurin_cos(-10, 15)\n    -0.8390715290764521\n    >>> maclaurin_cos(\"10\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires either an int or float for theta\n    >>> maclaurin_cos(10, -30)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, 30.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    >>> maclaurin_cos(10, \"30\")\n    Traceback (most recent call last):\n        ...\n    ValueError: maclaurin_cos() requires a positive int for accuracy\n    \"\"\"\n\n    if not isinstance(theta, (int, float)):\n        raise ValueError(\"maclaurin_cos() requires either an int or float for theta\")\n\n    if not isinstance(accuracy, int) or accuracy <= 0:\n        raise ValueError(\"maclaurin_cos() requires a positive int for accuracy\")\n\n    theta = float(theta)\n    div = theta // (2 * pi)\n    theta -= 2 * div * pi\n    return sum((-1) ** r * theta ** (2 * r) / factorial(2 * r) for r in range(accuracy))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(maclaurin_sin(10))\n    print(maclaurin_sin(-10))\n    print(maclaurin_sin(10, 15))\n    print(maclaurin_sin(-10, 15))\n\n    print(maclaurin_cos(5))\n    print(maclaurin_cos(-5))\n    print(maclaurin_cos(10, 15))\n    print(maclaurin_cos(-10, 15))\n", "maths/pythagoras.py": "\"\"\"Uses Pythagoras theorem to calculate the distance between two points in space.\"\"\"\n\nimport math\n\n\nclass Point:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __repr__(self) -> str:\n        return f\"Point({self.x}, {self.y}, {self.z})\"\n\n\ndef distance(a: Point, b: Point) -> float:\n    \"\"\"\n    >>> point1 = Point(2, -1, 7)\n    >>> point2 = Point(1, -3, 5)\n    >>> print(f\"Distance from {point1} to {point2} is {distance(point1, point2)}\")\n    Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0\n    \"\"\"\n    return math.sqrt(abs((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/average_mean.py": "from __future__ import annotations\n\n\ndef mean(nums: list) -> float:\n    \"\"\"\n    Find mean of a list of numbers.\n    Wiki: https://en.wikipedia.org/wiki/Mean\n\n    >>> mean([3, 6, 9, 12, 15, 18, 21])\n    12.0\n    >>> mean([5, 10, 15, 20, 25, 30, 35])\n    20.0\n    >>> mean([1, 2, 3, 4, 5, 6, 7, 8])\n    4.5\n    >>> mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: List is empty\n    \"\"\"\n    if not nums:\n        raise ValueError(\"List is empty\")\n    return sum(nums) / len(nums)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/monte_carlo.py": "\"\"\"\n@author: MatteoRaso\n\"\"\"\n\nfrom collections.abc import Callable\nfrom math import pi, sqrt\nfrom random import uniform\nfrom statistics import mean\n\n\ndef pi_estimator(iterations: int):\n    \"\"\"\n    An implementation of the Monte Carlo method used to find pi.\n    1. Draw a 2x2 square centred at (0,0).\n    2. Inscribe a circle within the square.\n    3. For each iteration, place a dot anywhere in the square.\n       a. Record the number of dots within the circle.\n    4. After all the dots are placed, divide the dots in the circle by the total.\n    5. Multiply this value by 4 to get your estimate of pi.\n    6. Print the estimated and numpy value of pi\n    \"\"\"\n\n    # A local function to see if a dot lands in the circle.\n    def is_in_circle(x: float, y: float) -> bool:\n        distance_from_centre = sqrt((x**2) + (y**2))\n        # Our circle has a radius of 1, so a distance\n        # greater than 1 would land outside the circle.\n        return distance_from_centre <= 1\n\n    # The proportion of guesses that landed in the circle\n    proportion = mean(\n        int(is_in_circle(uniform(-1.0, 1.0), uniform(-1.0, 1.0)))\n        for _ in range(iterations)\n    )\n    # The ratio of the area for circle to square is pi/4.\n    pi_estimate = proportion * 4\n    print(f\"The estimated value of pi is {pi_estimate}\")\n    print(f\"The numpy value of pi is {pi}\")\n    print(f\"The total error is {abs(pi - pi_estimate)}\")\n\n\ndef area_under_curve_estimator(\n    iterations: int,\n    function_to_integrate: Callable[[float], float],\n    min_value: float = 0.0,\n    max_value: float = 1.0,\n) -> float:\n    \"\"\"\n    An implementation of the Monte Carlo method to find area under\n       a single variable non-negative real-valued continuous function,\n       say f(x), where x lies within a continuous bounded interval,\n       say [min_value, max_value], where min_value and max_value are\n       finite numbers\n    1. Let x be a uniformly distributed random variable between min_value to\n       max_value\n    2. Expected value of f(x) =\n       (integrate f(x) from min_value to max_value)/(max_value - min_value)\n    3. Finding expected value of f(x):\n        a. Repeatedly draw x from uniform distribution\n        b. Evaluate f(x) at each of the drawn x values\n        c. Expected value = average of the function evaluations\n    4. Estimated value of integral = Expected value * (max_value - min_value)\n    5. Returns estimated value\n    \"\"\"\n\n    return mean(\n        function_to_integrate(uniform(min_value, max_value)) for _ in range(iterations)\n    ) * (max_value - min_value)\n\n\ndef area_under_line_estimator_check(\n    iterations: int, min_value: float = 0.0, max_value: float = 1.0\n) -> None:\n    \"\"\"\n    Checks estimation error for area_under_curve_estimator function\n    for f(x) = x where x lies within min_value to max_value\n    1. Calls \"area_under_curve_estimator\" function\n    2. Compares with the expected value\n    3. Prints estimated, expected and error value\n    \"\"\"\n\n    def identity_function(x: float) -> float:\n        \"\"\"\n        Represents identity function\n        >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]\n        [-2.0, -1.0, 0.0, 1.0, 2.0]\n        \"\"\"\n        return x\n\n    estimated_value = area_under_curve_estimator(\n        iterations, identity_function, min_value, max_value\n    )\n    expected_value = (max_value * max_value - min_value * min_value) / 2\n\n    print(\"******************\")\n    print(f\"Estimating area under y=x where x varies from {min_value} to {max_value}\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {expected_value}\")\n    print(f\"Total error is {abs(estimated_value - expected_value)}\")\n    print(\"******************\")\n\n\ndef pi_estimator_using_area_under_curve(iterations: int) -> None:\n    \"\"\"\n    Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi\n    \"\"\"\n\n    def function_to_integrate(x: float) -> float:\n        \"\"\"\n        Represents semi-circle with radius 2\n        >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]\n        [0.0, 2.0, 0.0]\n        \"\"\"\n        return sqrt(4.0 - x * x)\n\n    estimated_value = area_under_curve_estimator(\n        iterations, function_to_integrate, 0.0, 2.0\n    )\n\n    print(\"******************\")\n    print(\"Estimating pi using area_under_curve_estimator\")\n    print(f\"Estimated value is {estimated_value}\")\n    print(f\"Expected value is {pi}\")\n    print(f\"Total error is {abs(estimated_value - pi)}\")\n    print(\"******************\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/least_common_multiple.py": "import unittest\nfrom timeit import timeit\n\nfrom maths.greatest_common_divisor import greatest_common_divisor\n\n\ndef least_common_multiple_slow(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n\n    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple\n\n    >>> least_common_multiple_slow(5, 2)\n    10\n    >>> least_common_multiple_slow(12, 76)\n    228\n    \"\"\"\n    max_num = first_num if first_num >= second_num else second_num\n    common_mult = max_num\n    while (common_mult % first_num > 0) or (common_mult % second_num > 0):\n        common_mult += max_num\n    return common_mult\n\n\ndef least_common_multiple_fast(first_num: int, second_num: int) -> int:\n    \"\"\"\n    Find the least common multiple of two numbers.\n    https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor\n    >>> least_common_multiple_fast(5,2)\n    10\n    >>> least_common_multiple_fast(12,76)\n    228\n    \"\"\"\n    return first_num // greatest_common_divisor(first_num, second_num) * second_num\n\n\ndef benchmark():\n    setup = (\n        \"from __main__ import least_common_multiple_slow, least_common_multiple_fast\"\n    )\n    print(\n        \"least_common_multiple_slow():\",\n        timeit(\"least_common_multiple_slow(1000, 999)\", setup=setup),\n    )\n    print(\n        \"least_common_multiple_fast():\",\n        timeit(\"least_common_multiple_fast(1000, 999)\", setup=setup),\n    )\n\n\nclass TestLeastCommonMultiple(unittest.TestCase):\n    test_inputs = (\n        (10, 20),\n        (13, 15),\n        (4, 31),\n        (10, 42),\n        (43, 34),\n        (5, 12),\n        (12, 25),\n        (10, 25),\n        (6, 9),\n    )\n    expected_results = (20, 195, 124, 210, 1462, 60, 300, 50, 18)\n\n    def test_lcm_function(self):\n        for i, (first_num, second_num) in enumerate(self.test_inputs):\n            slow_result = least_common_multiple_slow(first_num, second_num)\n            fast_result = least_common_multiple_fast(first_num, second_num)\n            with self.subTest(i=i):\n                assert slow_result == self.expected_results[i]\n                assert fast_result == self.expected_results[i]\n\n\nif __name__ == \"__main__\":\n    benchmark()\n    unittest.main()\n", "maths/two_pointer.py": "\"\"\"\nGiven a sorted array of integers, return indices of the two numbers such\nthat they add up to a specific target using the two pointers technique.\n\nYou may assume that each input would have exactly one solution, and you\nmay not use the same element twice.\n\nThis is an alternative solution of the two-sum problem, which uses a\nmap to solve the problem. Hence can not solve the issue if there is a\nconstraint not use the same index twice. [1]\n\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\n[1]: https://github.com/TheAlgorithms/Python/blob/master/other/two_sum.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef two_pointer(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    >>> two_pointer([2, 7, 11, 15], 9)\n    [0, 1]\n    >>> two_pointer([2, 7, 11, 15], 17)\n    [0, 3]\n    >>> two_pointer([2, 7, 11, 15], 18)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 26)\n    [2, 3]\n    >>> two_pointer([1, 3, 3], 6)\n    [1, 2]\n    >>> two_pointer([2, 7, 11, 15], 8)\n    []\n    >>> two_pointer([3 * i for i in range(10)], 19)\n    []\n    >>> two_pointer([1, 2, 3], 6)\n    []\n    \"\"\"\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] < target:\n            i = i + 1\n        else:\n            j = j - 1\n\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{two_pointer([2, 7, 11, 15], 9) = }\")\n", "maths/pollard_rho.py": "from __future__ import annotations\n\nfrom math import gcd\n\n\ndef pollard_rho(\n    num: int,\n    seed: int = 2,\n    step: int = 1,\n    attempts: int = 3,\n) -> int | None:\n    \"\"\"\n    Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.\n    The returned factor may be composite and require further factorization.\n    If the algorithm will return None if it fails to find a factor within\n    the specified number of attempts or within the specified number of steps.\n    If ``num`` is prime, this algorithm is guaranteed to return None.\n    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n\n    >>> pollard_rho(18446744073709551617)\n    274177\n    >>> pollard_rho(97546105601219326301)\n    9876543191\n    >>> pollard_rho(100)\n    2\n    >>> pollard_rho(17)\n    >>> pollard_rho(17**3)\n    17\n    >>> pollard_rho(17**3, attempts=1)\n    >>> pollard_rho(3*5*7)\n    21\n    >>> pollard_rho(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value cannot be less than 2\n    \"\"\"\n    # A value less than 2 can cause an infinite loop in the algorithm.\n    if num < 2:\n        raise ValueError(\"The input value cannot be less than 2\")\n\n    # Because of the relationship between ``f(f(x))`` and ``f(x)``, this\n    # algorithm struggles to find factors that are divisible by two.\n    # As a workaround, we specifically check for two and even inputs.\n    #   See: https://math.stackexchange.com/a/2856214/165820\n    if num > 2 and num % 2 == 0:\n        return 2\n\n    # Pollard's Rho algorithm requires a function that returns pseudorandom\n    # values between 0 <= X < ``num``.  It doesn't need to be random in the\n    # sense that the output value is cryptographically secure or difficult\n    # to calculate, it only needs to be random in the sense that all output\n    # values should be equally likely to appear.\n    # For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``\n    # However, the success of Pollard's algorithm isn't guaranteed and is\n    # determined in part by the initial seed and the chosen random function.\n    # To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``\n    # where ``C`` is a value that we can modify between each attempt.\n    def rand_fn(value: int, step: int, modulus: int) -> int:\n        \"\"\"\n        Returns a pseudorandom value modulo ``modulus`` based on the\n        input ``value`` and attempt-specific ``step`` size.\n\n        >>> rand_fn(0, 0, 0)\n        Traceback (most recent call last):\n            ...\n        ZeroDivisionError: integer division or modulo by zero\n        >>> rand_fn(1, 2, 3)\n        0\n        >>> rand_fn(0, 10, 7)\n        3\n        >>> rand_fn(1234, 1, 17)\n        16\n        \"\"\"\n        return (pow(value, 2) + step) % modulus\n\n    for _ in range(attempts):\n        # These track the position within the cycle detection logic.\n        tortoise = seed\n        hare = seed\n\n        while True:\n            # At each iteration, the tortoise moves one step and the hare moves two.\n            tortoise = rand_fn(tortoise, step, num)\n            hare = rand_fn(hare, step, num)\n            hare = rand_fn(hare, step, num)\n\n            # At some point both the tortoise and the hare will enter a cycle whose\n            # length ``p`` is a divisor of ``num``.  Once in that cycle, at some point\n            # the tortoise and hare will end up on the same value modulo ``p``.\n            # We can detect when this happens because the position difference between\n            # the tortoise and the hare will share a common divisor with ``num``.\n            divisor = gcd(hare - tortoise, num)\n\n            if divisor == 1:\n                # No common divisor yet, just keep searching.\n                continue\n            # We found a common divisor!\n            elif divisor == num:\n                # Unfortunately, the divisor is ``num`` itself and is useless.\n                break\n            else:\n                # The divisor is a nontrivial factor of ``num``!\n                return divisor\n\n        # If we made it here, then this attempt failed.\n        # We need to pick a new starting seed for the tortoise and hare\n        # in addition to a new step value for the random function.\n        # To keep this example implementation deterministic, the\n        # new values will be generated based on currently available\n        # values instead of using something like ``random.randint``.\n\n        # We can use the hare's position as the new seed.\n        # This is actually what Richard Brent's the \"optimized\" variant does.\n        seed = hare\n\n        # The new step value for the random function can just be incremented.\n        # At first the results will be similar to what the old function would\n        # have produced, but the value will quickly diverge after a bit.\n        step += 1\n\n    # We haven't found a divisor within the requested number of attempts.\n    # We were unlucky or ``num`` itself is actually prime.\n    return None\n\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"num\",\n        type=int,\n        help=\"The value to find a divisor of\",\n    )\n    parser.add_argument(\n        \"--attempts\",\n        type=int,\n        default=3,\n        help=\"The number of attempts before giving up\",\n    )\n    args = parser.parse_args()\n\n    divisor = pollard_rho(args.num, attempts=args.attempts)\n    if divisor is None:\n        print(f\"{args.num} is probably prime\")\n    else:\n        quotient = args.num // divisor\n        print(f\"{args.num} = {divisor} * {quotient}\")\n", "maths/sieve_of_eratosthenes.py": "\"\"\"\nSieve of Eratosthones\n\nThe sieve of Eratosthenes is an algorithm used to find prime numbers, less than or\nequal to a given value.\nIllustration:\nhttps://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\nReference: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\ndoctest provider: Bruno Simas Hadlich (https://github.com/brunohadlich)\nAlso thanks to Dmitry (https://github.com/LizardWizzard) for finding the problem\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\n\ndef prime_sieve(num: int) -> list[int]:\n    \"\"\"\n    Returns a list with all prime numbers up to n.\n\n    >>> prime_sieve(50)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    >>> prime_sieve(25)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    >>> prime_sieve(10)\n    [2, 3, 5, 7]\n    >>> prime_sieve(9)\n    [2, 3, 5, 7]\n    >>> prime_sieve(2)\n    [2]\n    >>> prime_sieve(1)\n    []\n    \"\"\"\n\n    if num <= 0:\n        msg = f\"{num}: Invalid input, please enter a positive integer.\"\n        raise ValueError(msg)\n\n    sieve = [True] * (num + 1)\n    prime = []\n    start = 2\n    end = int(math.sqrt(num))\n\n    while start <= end:\n        # If start is a prime\n        if sieve[start] is True:\n            prime.append(start)\n\n            # Set multiples of start be False\n            for i in range(start * start, num + 1, start):\n                if sieve[i] is True:\n                    sieve[i] = False\n\n        start += 1\n\n    for j in range(end + 1, num + 1):\n        if sieve[j] is True:\n            prime.append(j)\n\n    return prime\n\n\nif __name__ == \"__main__\":\n    print(prime_sieve(int(input(\"Enter a positive integer: \").strip())))\n", "maths/karatsuba.py": "\"\"\"Multiply two numbers using Karatsuba algorithm\"\"\"\n\n\ndef karatsuba(a: int, b: int) -> int:\n    \"\"\"\n    >>> karatsuba(15463, 23489) == 15463 * 23489\n    True\n    >>> karatsuba(3, 9) == 3 * 9\n    True\n    \"\"\"\n    if len(str(a)) == 1 or len(str(b)) == 1:\n        return a * b\n\n    m1 = max(len(str(a)), len(str(b)))\n    m2 = m1 // 2\n\n    a1, a2 = divmod(a, 10**m2)\n    b1, b2 = divmod(b, 10**m2)\n\n    x = karatsuba(a2, b2)\n    y = karatsuba((a1 + a2), (b1 + b2))\n    z = karatsuba(a1, b1)\n\n    return (z * 10 ** (2 * m2)) + ((y - z - x) * 10 ** (m2)) + (x)\n\n\ndef main():\n    print(karatsuba(15463, 23489))\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/sum_of_harmonic_series.py": "def sum_of_harmonic_progression(\n    first_term: float, common_difference: float, number_of_terms: int\n) -> float:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)\n\n    Find the sum of n terms in an harmonic progression.  The calculation starts with the\n    first_term and loops adding the common difference of Arithmetic Progression by which\n    the given Harmonic Progression is linked.\n\n    >>> sum_of_harmonic_progression(1 / 2, 2, 2)\n    0.75\n    >>> sum_of_harmonic_progression(1 / 5, 5, 5)\n    0.45666666666666667\n    \"\"\"\n    arithmetic_progression = [1 / first_term]\n    first_term = 1 / first_term\n    for _ in range(number_of_terms - 1):\n        first_term += common_difference\n        arithmetic_progression.append(first_term)\n    harmonic_series = [1 / step for step in arithmetic_progression]\n    return sum(harmonic_series)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(sum_of_harmonic_progression(1 / 2, 2, 2))\n", "maths/polynomial_evaluation.py": "from collections.abc import Sequence\n\n\ndef evaluate_poly(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial f(x) at specified point x and return the value.\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    return sum(c * (x**i) for i, c in enumerate(poly))\n\n\ndef horner(poly: Sequence[float], x: float) -> float:\n    \"\"\"Evaluate a polynomial at specified point using Horner's method.\n\n    In terms of computational complexity, Horner's method is an efficient method\n    of evaluating a polynomial. It avoids the use of expensive exponentiation,\n    and instead uses only multiplication and addition to evaluate the polynomial\n    in O(n), where n is the degree of the polynomial.\n\n    https://en.wikipedia.org/wiki/Horner's_method\n\n    Arguments:\n    poly -- the coefficients of a polynomial as an iterable in order of\n            ascending degree\n    x -- the point at which to evaluate the polynomial\n\n    >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)\n    79800.0\n    \"\"\"\n    result = 0.0\n    for coeff in reversed(poly):\n        result = result * x + coeff\n    return result\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Example:\n    >>> poly = (0.0, 0.0, 5.0, 9.3, 7.0)  # f(x) = 7.0x^4 + 9.3x^3 + 5.0x^2\n    >>> x = -13.0\n    >>> # f(-13) = 7.0(-13)^4 + 9.3(-13)^3 + 5.0(-13)^2 = 180339.9\n    >>> evaluate_poly(poly, x)\n    180339.9\n    \"\"\"\n    poly = (0.0, 0.0, 5.0, 9.3, 7.0)\n    x = 10.0\n    print(evaluate_poly(poly, x))\n    print(horner(poly, x))\n", "maths/softmax.py": "\"\"\"\nThis script demonstrates the implementation of the Softmax function.\n\nIts a function that takes as input a vector of K real numbers, and normalizes\nit into a probability distribution consisting of K probabilities proportional\nto the exponentials of the input numbers. After softmax, the elements of the\nvector always sum up to 1.\n\nScript inspired from its corresponding Wikipedia article\nhttps://en.wikipedia.org/wiki/Softmax_function\n\"\"\"\n\nimport numpy as np\n\n\ndef softmax(vector):\n    \"\"\"\n    Implements the softmax function\n\n    Parameters:\n        vector (np.array,list,tuple): A  numpy array of shape (1,n)\n        consisting of real values or a similar list,tuple\n\n\n    Returns:\n        softmax_vec (np.array): The input numpy array  after applying\n        softmax.\n\n    The softmax vector adds up to one. We need to ceil to mitigate for\n    precision\n    >>> np.ceil(np.sum(softmax([1,2,3,4])))\n    1.0\n\n    >>> vec = np.array([5,5])\n    >>> softmax(vec)\n    array([0.5, 0.5])\n\n    >>> softmax([0])\n    array([1.])\n    \"\"\"\n\n    # Calculate e^x for each x in your vector where e is Euler's\n    # number (approximately 2.718)\n    exponent_vector = np.exp(vector)\n\n    # Add up the all the exponentials\n    sum_of_exponents = np.sum(exponent_vector)\n\n    # Divide every exponent by the sum of all exponents\n    softmax_vector = exponent_vector / sum_of_exponents\n\n    return softmax_vector\n\n\nif __name__ == \"__main__\":\n    print(softmax((0,)))\n", "maths/__init__.py": "", "maths/chudnovsky_algorithm.py": "from decimal import Decimal, getcontext\nfrom math import ceil, factorial\n\n\ndef pi(precision: int) -> str:\n    \"\"\"\n    The Chudnovsky algorithm is a fast method for calculating the digits of PI,\n    based on Ramanujan's PI formulae.\n\n    https://en.wikipedia.org/wiki/Chudnovsky_algorithm\n\n    PI = constant_term / ((multinomial_term * linear_term) / exponential_term)\n        where constant_term = 426880 * sqrt(10005)\n\n    The linear_term and the exponential_term can be defined iteratively as follows:\n        L_k+1 = L_k + 545140134            where L_0 = 13591409\n        X_k+1 = X_k * -262537412640768000  where X_0 = 1\n\n    The multinomial_term is defined as follows:\n        6k! / ((3k)! * (k!) ^ 3)\n            where k is the k_th iteration.\n\n    This algorithm correctly calculates around 14 digits of PI per iteration\n\n    >>> pi(10)\n    '3.14159265'\n    >>> pi(100)\n    '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'\n    >>> pi('hello')\n    Traceback (most recent call last):\n        ...\n    TypeError: Undefined for non-integers\n    >>> pi(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Undefined for non-natural numbers\n    \"\"\"\n\n    if not isinstance(precision, int):\n        raise TypeError(\"Undefined for non-integers\")\n    elif precision < 1:\n        raise ValueError(\"Undefined for non-natural numbers\")\n\n    getcontext().prec = precision\n    num_iterations = ceil(precision / 14)\n    constant_term = 426880 * Decimal(10005).sqrt()\n    exponential_term = 1\n    linear_term = 13591409\n    partial_sum = Decimal(linear_term)\n    for k in range(1, num_iterations):\n        multinomial_term = factorial(6 * k) // (factorial(3 * k) * factorial(k) ** 3)\n        linear_term += 545140134\n        exponential_term *= -262537412640768000\n        partial_sum += Decimal(multinomial_term * linear_term) / exponential_term\n    return str(constant_term / partial_sum)[:-1]\n\n\nif __name__ == \"__main__\":\n    n = 50\n    print(f\"The first {n} digits of pi is: {pi(n)}\")\n", "maths/sock_merchant.py": "from collections import Counter\n\n\ndef sock_merchant(colors: list[int]) -> int:\n    \"\"\"\n    >>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])\n    3\n    >>> sock_merchant([1, 1, 3, 3])\n    2\n    \"\"\"\n    return sum(socks_by_color // 2 for socks_by_color in Counter(colors).values())\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    colors = [int(x) for x in input(\"Enter socks by color :\").rstrip().split()]\n    print(f\"sock_merchant({colors}) = {sock_merchant(colors)}\")\n", "maths/collatz_sequence.py": "\"\"\"\nThe Collatz conjecture is a famous unsolved problem in mathematics. Given a starting\npositive integer, define the following sequence:\n- If the current term n is even, then the next term is n/2.\n- If the current term n is odd, then the next term is 3n + 1.\nThe conjecture claims that this sequence will always reach 1 for any starting number.\n\nOther names for this problem include the 3n + 1 problem, the Ulam conjecture, Kakutani's\nproblem, the Thwaites conjecture, Hasse's algorithm, the Syracuse problem, and the\nhailstone sequence.\n\nReference: https://en.wikipedia.org/wiki/Collatz_conjecture\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\n\n\ndef collatz_sequence(n: int) -> Generator[int, None, None]:\n    \"\"\"\n    Generate the Collatz sequence starting at n.\n    >>> tuple(collatz_sequence(2.1))\n    Traceback (most recent call last):\n        ...\n    Exception: Sequence only defined for positive integers\n    >>> tuple(collatz_sequence(0))\n    Traceback (most recent call last):\n        ...\n    Exception: Sequence only defined for positive integers\n    >>> tuple(collatz_sequence(4))\n    (4, 2, 1)\n    >>> tuple(collatz_sequence(11))\n    (11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    >>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE\n    (31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137,\n    412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593,\n    1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425,\n    1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644,\n    1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732,\n    866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,\n    160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    >>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE\n    (43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26,\n    13, 40, 20, 10, 5, 16, 8, 4, 2, 1)\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise Exception(\"Sequence only defined for positive integers\")\n\n    yield n\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        yield n\n\n\ndef main():\n    n = int(input(\"Your number: \"))\n    sequence = tuple(collatz_sequence(n))\n    print(sequence)\n    print(f\"Collatz sequence from {n} took {len(sequence)} steps.\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/aliquot_sum.py": "def aliquot_sum(input_num: int) -> int:\n    \"\"\"\n    Finds the aliquot sum of an input integer, where the\n    aliquot sum of a number n is defined as the sum of all\n    natural numbers less than n that divide n evenly. For\n    example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is\n    a simple O(n) implementation.\n    @param input_num: a positive integer whose aliquot sum is to be found\n    @return: the aliquot sum of input_num, if input_num is positive.\n    Otherwise, raise a ValueError\n    Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum\n\n    >>> aliquot_sum(15)\n    9\n    >>> aliquot_sum(6)\n    6\n    >>> aliquot_sum(-1)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be positive\n    >>> aliquot_sum(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be positive\n    >>> aliquot_sum(1.6)\n    Traceback (most recent call last):\n      ...\n    ValueError: Input must be an integer\n    >>> aliquot_sum(12)\n    16\n    >>> aliquot_sum(1)\n    0\n    >>> aliquot_sum(19)\n    1\n    \"\"\"\n    if not isinstance(input_num, int):\n        raise ValueError(\"Input must be an integer\")\n    if input_num <= 0:\n        raise ValueError(\"Input must be positive\")\n    return sum(\n        divisor for divisor in range(1, input_num // 2 + 1) if input_num % divisor == 0\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/is_int_palindrome.py": "def is_int_palindrome(num: int) -> bool:\n    \"\"\"\n    Returns whether `num` is a palindrome or not\n    (see for reference https://en.wikipedia.org/wiki/Palindromic_number).\n\n    >>> is_int_palindrome(-121)\n    False\n    >>> is_int_palindrome(0)\n    True\n    >>> is_int_palindrome(10)\n    False\n    >>> is_int_palindrome(11)\n    True\n    >>> is_int_palindrome(101)\n    True\n    >>> is_int_palindrome(120)\n    False\n    \"\"\"\n    if num < 0:\n        return False\n\n    num_copy: int = num\n    rev_num: int = 0\n    while num > 0:\n        rev_num = rev_num * 10 + (num % 10)\n        num //= 10\n\n    return num_copy == rev_num\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/signum.py": "\"\"\"\nSignum function -- https://en.wikipedia.org/wiki/Sign_function\n\"\"\"\n\n\ndef signum(num: float) -> int:\n    \"\"\"\n    Applies signum function on the number\n\n    Custom test cases:\n    >>> signum(-10)\n    -1\n    >>> signum(10)\n    1\n    >>> signum(0)\n    0\n    >>> signum(-20.5)\n    -1\n    >>> signum(20.5)\n    1\n    >>> signum(-1e-6)\n    -1\n    >>> signum(1e-6)\n    1\n    >>> signum(\"Hello\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    >>> signum([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'list' and 'int'\n    \"\"\"\n    if num < 0:\n        return -1\n    return 1 if num else 0\n\n\ndef test_signum() -> None:\n    \"\"\"\n    Tests the signum function\n    >>> test_signum()\n    \"\"\"\n    assert signum(5) == 1\n    assert signum(-5) == -1\n    assert signum(0) == 0\n    assert signum(10.5) == 1\n    assert signum(-10.5) == -1\n    assert signum(1e-6) == 1\n    assert signum(-1e-6) == -1\n    assert signum(123456789) == 1\n    assert signum(-123456789) == -1\n\n\nif __name__ == \"__main__\":\n    print(signum(12))\n    print(signum(-12))\n    print(signum(0))\n", "maths/binomial_coefficient.py": "def binomial_coefficient(n: int, r: int) -> int:\n    \"\"\"\n    Find binomial coefficient using Pascal's triangle.\n\n    Calculate C(n, r) using Pascal's triangle.\n\n    :param n: The total number of items.\n    :param r: The number of items to choose.\n    :return: The binomial coefficient C(n, r).\n\n    >>> binomial_coefficient(10, 5)\n    252\n    >>> binomial_coefficient(10, 0)\n    1\n    >>> binomial_coefficient(0, 10)\n    1\n    >>> binomial_coefficient(10, 10)\n    1\n    >>> binomial_coefficient(5, 2)\n    10\n    >>> binomial_coefficient(5, 6)\n    0\n    >>> binomial_coefficient(3, 5)\n    0\n    >>> binomial_coefficient(-2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(5, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n and r must be non-negative integers\n    >>> binomial_coefficient(10.1, 5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> binomial_coefficient(10, 5.1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    if n < 0 or r < 0:\n        raise ValueError(\"n and r must be non-negative integers\")\n    if 0 in (n, r):\n        return 1\n    c = [0 for i in range(r + 1)]\n    # nc0 = 1\n    c[0] = 1\n    for i in range(1, n + 1):\n        # to compute current row from previous row.\n        j = min(i, r)\n        while j > 0:\n            c[j] += c[j - 1]\n            j -= 1\n    return c[r]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(binomial_coefficient(n=10, r=5))\n", "maths/gaussian.py": "\"\"\"\nReference: https://en.wikipedia.org/wiki/Gaussian_function\n\"\"\"\n\nfrom numpy import exp, pi, sqrt\n\n\ndef gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> int:\n    \"\"\"\n    >>> gaussian(1)\n    0.24197072451914337\n\n    >>> gaussian(24)\n    3.342714441794458e-126\n\n    >>> gaussian(1, 4, 2)\n    0.06475879783294587\n\n    >>> gaussian(1, 5, 3)\n    0.05467002489199788\n\n    Supports NumPy Arrays\n    Use numpy.meshgrid with this to generate gaussian blur on images.\n    >>> import numpy as np\n    >>> x = np.arange(15)\n    >>> gaussian(x)\n    array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,\n           1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,\n           5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,\n           2.14638374e-32, 7.99882776e-38, 1.09660656e-43])\n\n    >>> gaussian(15)\n    5.530709549844416e-50\n\n    >>> gaussian([1,2, 'string'])\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'list' and 'float'\n\n    >>> gaussian('hello world')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'float'\n\n    >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    OverflowError: (34, 'Result too large')\n\n    >>> gaussian(10**-326)\n    0.3989422804014327\n\n    >>> gaussian(2523, mu=234234, sigma=3425)\n    0.0\n    \"\"\"\n    return 1 / sqrt(2 * pi * sigma**2) * exp(-((x - mu) ** 2) / (2 * sigma**2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/gamma.py": "\"\"\"\nGamma function is a very useful tool in math and physics.\nIt helps calculating complex integral in a convenient way.\nfor more info: https://en.wikipedia.org/wiki/Gamma_function\nIn mathematics, the gamma function is one commonly\nused extension of the factorial function to complex numbers.\nThe gamma function is defined for all complex numbers except\nthe non-positive integers\nPython's Standard Library math.gamma() function overflows around gamma(171.624).\n\"\"\"\n\nimport math\n\nfrom numpy import inf\nfrom scipy.integrate import quad\n\n\ndef gamma_iterative(num: float) -> float:\n    \"\"\"\n    Calculates the value of Gamma function of num\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n\n    >>> gamma_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(9)\n    40320.0\n    >>> from math import gamma as math_gamma\n    >>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001\n    ...     for i in range(1, 50))\n    True\n    >>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001\n    True\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n\n    return quad(integrand, 0, inf, args=(num))[0]\n\n\ndef integrand(x: float, z: float) -> float:\n    return math.pow(x, z - 1) * math.exp(-x)\n\n\ndef gamma_recursive(num: float) -> float:\n    \"\"\"\n    Calculates the value of Gamma function of num\n    where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).\n    Implemented using recursion\n    Examples:\n    >>> from math import isclose, gamma as math_gamma\n    >>> gamma_recursive(0.5)\n    1.7724538509055159\n    >>> gamma_recursive(1)\n    1.0\n    >>> gamma_recursive(2)\n    1.0\n    >>> gamma_recursive(3.5)\n    3.3233509704478426\n    >>> gamma_recursive(171.5)\n    9.483367566824795e+307\n    >>> all(isclose(gamma_recursive(num), math_gamma(num))\n    ...     for num in (0.5, 2, 3.5, 171.5))\n    True\n    >>> gamma_recursive(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(-1.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    >>> gamma_recursive(172)\n    Traceback (most recent call last):\n        ...\n    OverflowError: math range error\n    >>> gamma_recursive(1.1)\n    Traceback (most recent call last):\n        ...\n    NotImplementedError: num must be an integer or a half-integer\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"math domain error\")\n    if num > 171.5:\n        raise OverflowError(\"math range error\")\n    elif num - int(num) not in (0, 0.5):\n        raise NotImplementedError(\"num must be an integer or a half-integer\")\n    elif num == 0.5:\n        return math.sqrt(math.pi)\n    else:\n        return 1.0 if num == 1 else (num - 1) * gamma_recursive(num - 1)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    num = 1.0\n    while num:\n        num = float(input(\"Gamma of: \"))\n        print(f\"gamma_iterative({num}) = {gamma_iterative(num)}\")\n        print(f\"gamma_recursive({num}) = {gamma_recursive(num)}\")\n        print(\"\\nEnter 0 to exit...\")\n", "maths/fermat_little_theorem.py": "# Python program to show the usage of Fermat's little theorem in a division\n# According to Fermat's little theorem, (a / b) mod p always equals\n# a * (b ^ (p - 2)) mod p\n# Here we assume that p is a prime number, b divides a, and p doesn't divide b\n# Wikipedia reference: https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n\n\ndef binary_exponentiation(a: int, n: float, mod: int) -> int:\n    if n == 0:\n        return 1\n\n    elif n % 2 == 1:\n        return (binary_exponentiation(a, n - 1, mod) * a) % mod\n\n    else:\n        b = binary_exponentiation(a, n / 2, mod)\n        return (b * b) % mod\n\n\n# a prime number\np = 701\n\na = 1000000000\nb = 10\n\n# using binary exponentiation function, O(log(p)):\nprint((a / b) % p == (a * binary_exponentiation(b, p - 2, p)) % p)\n\n# using Python operators:\nprint((a / b) % p == (a * b ** (p - 2)) % p)\n", "maths/perfect_square.py": "import math\n\n\ndef perfect_square(num: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square number or not\n    :param num: the number to be checked\n    :return: True if number is square number, otherwise False\n\n    >>> perfect_square(9)\n    True\n    >>> perfect_square(16)\n    True\n    >>> perfect_square(1)\n    True\n    >>> perfect_square(0)\n    True\n    >>> perfect_square(10)\n    False\n    \"\"\"\n    return math.sqrt(num) * math.sqrt(num) == num\n\n\ndef perfect_square_binary_search(n: int) -> bool:\n    \"\"\"\n    Check if a number is perfect square using binary search.\n    Time complexity : O(Log(n))\n    Space complexity: O(1)\n\n    >>> perfect_square_binary_search(9)\n    True\n    >>> perfect_square_binary_search(16)\n    True\n    >>> perfect_square_binary_search(1)\n    True\n    >>> perfect_square_binary_search(0)\n    True\n    >>> perfect_square_binary_search(10)\n    False\n    >>> perfect_square_binary_search(-1)\n    False\n    >>> perfect_square_binary_search(1.1)\n    False\n    >>> perfect_square_binary_search(\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'str'\n    >>> perfect_square_binary_search(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'NoneType'\n    >>> perfect_square_binary_search([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<=' not supported between instances of 'int' and 'list'\n    \"\"\"\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid**2 == n:\n            return True\n        elif mid**2 > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/sumset.py": "\"\"\"\n\nCalculates the SumSet of two sets of numbers (A and B)\n\nSource:\n    https://en.wikipedia.org/wiki/Sumset\n\n\"\"\"\n\n\ndef sumset(set_a: set, set_b: set) -> set:\n    \"\"\"\n    :param first set: a set of numbers\n    :param second set: a set of numbers\n    :return: the nth number in Sylvester's sequence\n\n    >>> sumset({1, 2, 3}, {4, 5, 6})\n    {5, 6, 7, 8, 9}\n\n    >>> sumset({1, 2, 3}, {4, 5, 6, 7})\n    {5, 6, 7, 8, 9, 10}\n\n    >>> sumset({1, 2, 3, 4}, 3)\n    Traceback (most recent call last):\n    ...\n    AssertionError: The input value of [set_b=3] is not a set\n    \"\"\"\n    assert isinstance(set_a, set), f\"The input value of [set_a={set_a}] is not a set\"\n    assert isinstance(set_b, set), f\"The input value of [set_b={set_b}] is not a set\"\n\n    return {a + b for a in set_a for b in set_b}\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "maths/base_neg2_conversion.py": "def decimal_to_negative_base_2(num: int) -> int:\n    \"\"\"\n    This function returns the number negative base 2\n        of the decimal number of the input data.\n\n    Args:\n        int: The decimal number to convert.\n\n    Returns:\n        int: The negative base 2 number.\n\n    Examples:\n        >>> decimal_to_negative_base_2(0)\n        0\n        >>> decimal_to_negative_base_2(-19)\n        111101\n        >>> decimal_to_negative_base_2(4)\n        100\n        >>> decimal_to_negative_base_2(7)\n        11011\n    \"\"\"\n    if num == 0:\n        return 0\n    ans = \"\"\n    while num != 0:\n        num, rem = divmod(num, -2)\n        if rem < 0:\n            rem += 2\n            num += 1\n        ans = str(rem) + ans\n    return int(ans)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/spearman_rank_correlation_coefficient.py": "from collections.abc import Sequence\n\n\ndef assign_ranks(data: Sequence[float]) -> list[int]:\n    \"\"\"\n    Assigns ranks to elements in the array.\n\n    :param data: List of floats.\n    :return: List of ints representing the ranks.\n\n    Example:\n    >>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1])\n    [3, 1, 4, 2, 5]\n\n    >>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0])\n    [3, 1, 5, 2, 4]\n    \"\"\"\n    ranked_data = sorted((value, index) for index, value in enumerate(data))\n    ranks = [0] * len(data)\n\n    for position, (_, index) in enumerate(ranked_data):\n        ranks[index] = position + 1\n\n    return ranks\n\n\ndef calculate_spearman_rank_correlation(\n    variable_1: Sequence[float], variable_2: Sequence[float]\n) -> float:\n    \"\"\"\n    Calculates Spearman's rank correlation coefficient.\n\n    :param variable_1: List of floats representing the first variable.\n    :param variable_2: List of floats representing the second variable.\n    :return: Spearman's rank correlation coefficient.\n\n    Example Usage:\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [5, 4, 3, 2, 1]\n    >>> calculate_spearman_rank_correlation(x, y)\n    -1.0\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [2, 4, 6, 8, 10]\n    >>> calculate_spearman_rank_correlation(x, y)\n    1.0\n\n    >>> x = [1, 2, 3, 4, 5]\n    >>> y = [5, 1, 2, 9, 5]\n    >>> calculate_spearman_rank_correlation(x, y)\n    0.6\n    \"\"\"\n    n = len(variable_1)\n    rank_var1 = assign_ranks(variable_1)\n    rank_var2 = assign_ranks(variable_2)\n\n    # Calculate differences of ranks\n    d = [rx - ry for rx, ry in zip(rank_var1, rank_var2)]\n\n    # Calculate the sum of squared differences\n    d_squared = sum(di**2 for di in d)\n\n    # Calculate the Spearman's rank correlation coefficient\n    rho = 1 - (6 * d_squared) / (n * (n**2 - 1))\n\n    return rho\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Example usage:\n    print(\n        f\"{calculate_spearman_rank_correlation([1, 2, 3, 4, 5], [2, 4, 6, 8, 10]) = }\"\n    )\n\n    print(f\"{calculate_spearman_rank_correlation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) = }\")\n\n    print(f\"{calculate_spearman_rank_correlation([1, 2, 3, 4, 5], [5, 1, 2, 9, 5]) = }\")\n", "maths/euler_method.py": "from collections.abc import Callable\n\nimport numpy as np\n\n\ndef explicit_euler(\n    ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float\n) -> np.ndarray:\n    \"\"\"Calculate numeric solution at each step to an ODE using Euler's Method\n\n    For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.\n\n    Args:\n        ode_func (Callable):  The ordinary differential equation\n            as a function of x and y.\n        y0 (float): The initial value for y.\n        x0 (float): The initial value for x.\n        step_size (float): The increment value for x.\n        x_end (float): The final value of x to be calculated.\n\n    Returns:\n        np.ndarray: Solution of y for every step in x.\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f(x, y):\n    ...     return y\n    >>> y0 = 1\n    >>> y = explicit_euler(f, y0, 0.0, 0.01, 5)\n    >>> y[-1]\n    144.77277243257308\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / step_size))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        y[k + 1] = y[k] + step_size * ode_func(x, y[k])\n        x += step_size\n\n    return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/sigmoid.py": "\"\"\"\nThis script demonstrates the implementation of the Sigmoid function.\n\nThe function takes a vector of K real numbers as input and then 1 / (1 + exp(-x)).\nAfter through Sigmoid, the element of the vector mostly 0 between 1. or 1 between -1.\n\nScript inspired from its corresponding Wikipedia article\nhttps://en.wikipedia.org/wiki/Sigmoid_function\n\"\"\"\n\nimport numpy as np\n\n\ndef sigmoid(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the sigmoid function\n\n    Parameters:\n        vector (np.array): A  numpy array of shape (1,n)\n        consisting of real values\n\n    Returns:\n        sigmoid_vec (np.array): The input numpy array, after applying\n        sigmoid.\n\n    Examples:\n    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))\n    array([0.26894142, 0.73105858, 0.88079708])\n\n    >>> sigmoid(np.array([0.0]))\n    array([0.5])\n    \"\"\"\n    return 1 / (1 + np.exp(-vector))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/minkowski_distance.py": "def minkowski_distance(\n    point_a: list[float],\n    point_b: list[float],\n    order: int,\n) -> float:\n    \"\"\"\n    This function calculates the Minkowski distance for a given order between\n    two n-dimensional points represented as lists. For the case of order = 1,\n    the Minkowski distance degenerates to the Manhattan distance. For\n    order = 2, the usual Euclidean distance is obtained.\n\n    https://en.wikipedia.org/wiki/Minkowski_distance\n\n    Note: due to floating point calculation errors the output of this\n    function may be inaccurate.\n\n    >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)\n    2.0\n    >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)\n    8.0\n    >>> import numpy as np\n    >>> np.isclose(5.0, minkowski_distance([5.0], [0.0], 3))\n    True\n    >>> minkowski_distance([1.0], [2.0], -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The order must be greater than or equal to 1.\n    >>> minkowski_distance([1.0], [1.0, 2.0], 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both points must have the same dimension.\n    \"\"\"\n    if order < 1:\n        raise ValueError(\"The order must be greater than or equal to 1.\")\n\n    if len(point_a) != len(point_b):\n        raise ValueError(\"Both points must have the same dimension.\")\n\n    return sum(abs(a - b) ** order for a, b in zip(point_a, point_b)) ** (1 / order)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/prime_check.py": "\"\"\"Prime Check.\"\"\"\n\nimport math\nimport unittest\n\nimport pytest\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    >>> is_prime(16.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    >>> is_prime(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    \"\"\"\n\n    # precondition\n    if not isinstance(number, int) or not number >= 0:\n        raise ValueError(\"is_prime() only accepts positive integers\")\n\n    if 1 < number < 4:\n        # 2 and 3 are primes\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        # Negatives, 0, 1, all even numbers, all multiples of 3 are not primes\n        return False\n\n    # All primes number are in format of 6k +/- 1\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True\n\n\nclass Test(unittest.TestCase):\n    def test_primes(self):\n        assert is_prime(2)\n        assert is_prime(3)\n        assert is_prime(5)\n        assert is_prime(7)\n        assert is_prime(11)\n        assert is_prime(13)\n        assert is_prime(17)\n        assert is_prime(19)\n        assert is_prime(23)\n        assert is_prime(29)\n\n    def test_not_primes(self):\n        with pytest.raises(ValueError):\n            is_prime(-19)\n        assert not is_prime(\n            0\n        ), \"Zero doesn't have any positive factors, primes must have exactly two.\"\n        assert not is_prime(\n            1\n        ), \"One only has 1 positive factor, primes must have exactly two.\"\n        assert not is_prime(2 * 2)\n        assert not is_prime(2 * 3)\n        assert not is_prime(3 * 3)\n        assert not is_prime(3 * 5)\n        assert not is_prime(3 * 5 * 7)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "maths/factorial.py": "\"\"\"\nFactorial of a positive integer -- https://en.wikipedia.org/wiki/Factorial\n\"\"\"\n\n\ndef factorial(number: int) -> int:\n    \"\"\"\n    Calculate the factorial of specified number (n!).\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    >>> factorial(1)\n    1\n    >>> factorial(6)\n    720\n    >>> factorial(0)\n    1\n    \"\"\"\n    if number != int(number):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if number < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    value = 1\n    for i in range(1, number + 1):\n        value *= i\n    return value\n\n\ndef factorial_recursive(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a positive integer\n    https://en.wikipedia.org/wiki/Factorial\n\n    >>> import math\n    >>> all(factorial(i) == math.factorial(i) for i in range(20))\n    True\n    >>> factorial(0.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() only accepts integral values\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: factorial() not defined for negative values\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"factorial() only accepts integral values\")\n    if n < 0:\n        raise ValueError(\"factorial() not defined for negative values\")\n    return 1 if n in {0, 1} else n * factorial(n - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    n = int(input(\"Enter a positive integer: \").strip() or 0)\n    print(f\"factorial{n} is {factorial(n)}\")\n", "maths/polynomials/single_indeterminate_operations.py": "\"\"\"\n\nThis module implements a single indeterminate polynomials class\nwith some basic operations\n\nReference: https://en.wikipedia.org/wiki/Polynomial\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import MutableSequence\n\n\nclass Polynomial:\n    def __init__(self, degree: int, coefficients: MutableSequence[float]) -> None:\n        \"\"\"\n        The coefficients should be in order of degree, from smallest to largest.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> p = Polynomial(2, [1, 2, 3, 4])\n        Traceback (most recent call last):\n        ...\n        ValueError: The number of coefficients should be equal to the degree + 1.\n\n        \"\"\"\n        if len(coefficients) != degree + 1:\n            raise ValueError(\n                \"The number of coefficients should be equal to the degree + 1.\"\n            )\n\n        self.coefficients: list[float] = list(coefficients)\n        self.degree = degree\n\n    def __add__(self, polynomial_2: Polynomial) -> Polynomial:\n        \"\"\"\n        Polynomial addition\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> q = Polynomial(2, [1, 2, 3])\n        >>> p + q\n        6x^2 + 4x + 2\n        \"\"\"\n\n        if self.degree > polynomial_2.degree:\n            coefficients = self.coefficients[:]\n            for i in range(polynomial_2.degree + 1):\n                coefficients[i] += polynomial_2.coefficients[i]\n            return Polynomial(self.degree, coefficients)\n        else:\n            coefficients = polynomial_2.coefficients[:]\n            for i in range(self.degree + 1):\n                coefficients[i] += self.coefficients[i]\n            return Polynomial(polynomial_2.degree, coefficients)\n\n    def __sub__(self, polynomial_2: Polynomial) -> Polynomial:\n        \"\"\"\n        Polynomial subtraction\n        >>> p = Polynomial(2, [1, 2, 4])\n        >>> q = Polynomial(2, [1, 2, 3])\n        >>> p - q\n        1x^2\n        \"\"\"\n        return self + polynomial_2 * Polynomial(0, [-1])\n\n    def __neg__(self) -> Polynomial:\n        \"\"\"\n        Polynomial negation\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> -p\n         - 3x^2 - 2x - 1\n        \"\"\"\n        return Polynomial(self.degree, [-c for c in self.coefficients])\n\n    def __mul__(self, polynomial_2: Polynomial) -> Polynomial:\n        \"\"\"\n        Polynomial multiplication\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> q = Polynomial(2, [1, 2, 3])\n        >>> p * q\n        9x^4 + 12x^3 + 10x^2 + 4x + 1\n        \"\"\"\n        coefficients: list[float] = [0] * (self.degree + polynomial_2.degree + 1)\n        for i in range(self.degree + 1):\n            for j in range(polynomial_2.degree + 1):\n                coefficients[i + j] += (\n                    self.coefficients[i] * polynomial_2.coefficients[j]\n                )\n\n        return Polynomial(self.degree + polynomial_2.degree, coefficients)\n\n    def evaluate(self, substitution: float) -> float:\n        \"\"\"\n        Evaluates the polynomial at x.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> p.evaluate(2)\n        17\n        \"\"\"\n        result: int | float = 0\n        for i in range(self.degree + 1):\n            result += self.coefficients[i] * (substitution**i)\n        return result\n\n    def __str__(self) -> str:\n        \"\"\"\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> print(p)\n        3x^2 + 2x + 1\n        \"\"\"\n        polynomial = \"\"\n        for i in range(self.degree, -1, -1):\n            if self.coefficients[i] == 0:\n                continue\n            elif self.coefficients[i] > 0:\n                if polynomial:\n                    polynomial += \" + \"\n            else:\n                polynomial += \" - \"\n\n            if i == 0:\n                polynomial += str(abs(self.coefficients[i]))\n            elif i == 1:\n                polynomial += str(abs(self.coefficients[i])) + \"x\"\n            else:\n                polynomial += str(abs(self.coefficients[i])) + \"x^\" + str(i)\n\n        return polynomial\n\n    def __repr__(self) -> str:\n        \"\"\"\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> p\n        3x^2 + 2x + 1\n        \"\"\"\n        return self.__str__()\n\n    def derivative(self) -> Polynomial:\n        \"\"\"\n        Returns the derivative of the polynomial.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> p.derivative()\n        6x + 2\n        \"\"\"\n        coefficients: list[float] = [0] * self.degree\n        for i in range(self.degree):\n            coefficients[i] = self.coefficients[i + 1] * (i + 1)\n        return Polynomial(self.degree - 1, coefficients)\n\n    def integral(self, constant: float = 0) -> Polynomial:\n        \"\"\"\n        Returns the integral of the polynomial.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> p.integral()\n        1.0x^3 + 1.0x^2 + 1.0x\n        \"\"\"\n        coefficients: list[float] = [0] * (self.degree + 2)\n        coefficients[0] = constant\n        for i in range(self.degree + 1):\n            coefficients[i + 1] = self.coefficients[i] / (i + 1)\n        return Polynomial(self.degree + 1, coefficients)\n\n    def __eq__(self, polynomial_2: object) -> bool:\n        \"\"\"\n        Checks if two polynomials are equal.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> q = Polynomial(2, [1, 2, 3])\n        >>> p == q\n        True\n        \"\"\"\n        if not isinstance(polynomial_2, Polynomial):\n            return False\n\n        if self.degree != polynomial_2.degree:\n            return False\n\n        for i in range(self.degree + 1):\n            if self.coefficients[i] != polynomial_2.coefficients[i]:\n                return False\n\n        return True\n\n    def __ne__(self, polynomial_2: object) -> bool:\n        \"\"\"\n        Checks if two polynomials are not equal.\n        >>> p = Polynomial(2, [1, 2, 3])\n        >>> q = Polynomial(2, [1, 2, 3])\n        >>> p != q\n        False\n        \"\"\"\n        return not self.__eq__(polynomial_2)\n", "maths/polynomials/__init__.py": "", "maths/series/hexagonal_numbers.py": "\"\"\"\nA hexagonal number sequence is a sequence of figurate numbers\nwhere the nth hexagonal number h\u2099 is the number of distinct dots\nin a pattern of dots consisting of the outlines of regular\nhexagons with sides up to n dots, when the hexagons are overlaid\nso that they share one vertex.\n\n    Calculates the hexagonal numbers sequence with a formula\n        h\u2099 = n(2n-1)\n        where:\n        h\u2099 --> is nth element of the sequence\n        n --> is the number of element in the sequence\n        reference-->\"Hexagonal number\" Wikipedia\n        <https://en.wikipedia.org/wiki/Hexagonal_number>\n\"\"\"\n\n\ndef hexagonal_numbers(length: int) -> list[int]:\n    \"\"\"\n    :param len: max number of elements\n    :type len: int\n    :return: Hexagonal numbers as a list\n\n    Tests:\n    >>> hexagonal_numbers(10)\n    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\n    >>> hexagonal_numbers(5)\n    [0, 1, 6, 15, 28]\n    >>> hexagonal_numbers(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive integer.\n    \"\"\"\n\n    if length <= 0 or not isinstance(length, int):\n        raise ValueError(\"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]\n\n\nif __name__ == \"__main__\":\n    print(hexagonal_numbers(length=5))\n    print(hexagonal_numbers(length=10))\n", "maths/series/geometric.py": "\"\"\"\nGeometric Mean\nReference :  https://en.wikipedia.org/wiki/Geometric_mean\n\nGeometric series\nReference: https://en.wikipedia.org/wiki/Geometric_series\n\"\"\"\n\n\ndef is_geometric_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is geometric series or not\n    >>> is_geometric_series([2, 4, 8])\n    True\n    >>> is_geometric_series([3, 6, 12, 24])\n    True\n    >>> is_geometric_series([1, 2, 3])\n    False\n    >>> is_geometric_series([0, 0, 3])\n    False\n    >>> is_geometric_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    >>> is_geometric_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    try:\n        common_ratio = series[1] / series[0]\n        for index in range(len(series) - 1):\n            if series[index + 1] / series[index] != common_ratio:\n                return False\n    except ZeroDivisionError:\n        return False\n    return True\n\n\ndef geometric_mean(series: list) -> float:\n    \"\"\"\n    return the geometric mean of series\n\n    >>> geometric_mean([2, 4, 8])\n    3.9999999999999996\n    >>> geometric_mean([3, 6, 12, 24])\n    8.48528137423857\n    >>> geometric_mean([4, 8, 16])\n    7.999999999999999\n    >>> geometric_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 8]\n    >>> geometric_mean([1, 2, 3])\n    1.8171205928321397\n    >>> geometric_mean([0, 2, 3])\n    0.0\n    >>> geometric_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 8]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 1\n    for value in series:\n        answer *= value\n    return pow(answer, 1 / len(series))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/series/arithmetic.py": "\"\"\"\nArithmetic mean\nReference: https://en.wikipedia.org/wiki/Arithmetic_mean\n\nArithmetic series\nReference: https://en.wikipedia.org/wiki/Arithmetic_series\n(The URL above will redirect you to arithmetic progression)\n\"\"\"\n\n\ndef is_arithmetic_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is arithmetic series or not\n    >>> is_arithmetic_series([2, 4, 6])\n    True\n    >>> is_arithmetic_series([3, 6, 12, 24])\n    False\n    >>> is_arithmetic_series([1, 2, 3])\n    True\n    >>> is_arithmetic_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> is_arithmetic_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1:\n        return True\n    common_diff = series[1] - series[0]\n    for index in range(len(series) - 1):\n        if series[index + 1] - series[index] != common_diff:\n            return False\n    return True\n\n\ndef arithmetic_mean(series: list) -> float:\n    \"\"\"\n    return the arithmetic mean of series\n\n    >>> arithmetic_mean([2, 4, 6])\n    4.0\n    >>> arithmetic_mean([3, 6, 9, 12])\n    7.5\n    >>> arithmetic_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> arithmetic_mean([4, 8, 1])\n    4.333333333333333\n    >>> arithmetic_mean([1, 2, 3])\n    2.0\n    >>> arithmetic_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += val\n    return answer / len(series)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/series/p_series.py": "\"\"\"\nThis is a pure Python implementation of the P-Series algorithm\nhttps://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#P-series\nFor doctests run following command:\npython -m doctest -v p_series.py\nor\npython3 -m doctest -v p_series.py\nFor manual testing run:\npython3 p_series.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef p_series(nth_term: float | str, power: float | str) -> list[str]:\n    \"\"\"\n    Pure Python implementation of P-Series algorithm\n    :return: The P-Series starting from 1 to last (nth) term\n    Examples:\n    >>> p_series(5, 2)\n    ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']\n    >>> p_series(-5, 2)\n    []\n    >>> p_series(5, -2)\n    ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']\n    >>> p_series(\"\", 1000)\n    ['']\n    >>> p_series(0, 0)\n    []\n    >>> p_series(1, 1)\n    ['1']\n    \"\"\"\n    if nth_term == \"\":\n        return [\"\"]\n    nth_term = int(nth_term)\n    power = int(power)\n    series: list[str] = []\n    for temp in range(int(nth_term)):\n        series.append(f\"1 / {pow(temp + 1, int(power))}\" if series else \"1\")\n    return series\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    nth_term = int(input(\"Enter the last number (nth term) of the P-Series\"))\n    power = int(input(\"Enter the power for  P-Series\"))\n    print(\"Formula of P-Series => 1+1/2^p+1/3^p ..... 1/n^p\")\n    print(p_series(nth_term, power))\n", "maths/series/geometric_series.py": "\"\"\"\nThis is a pure Python implementation of the Geometric Series algorithm\nhttps://en.wikipedia.org/wiki/Geometric_series\nRun the doctests with the following command:\npython3 -m doctest -v geometric_series.py\nor\npython -m doctest -v geometric_series.py\nFor manual testing run:\npython3 geometric_series.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef geometric_series(\n    nth_term: float,\n    start_term_a: float,\n    common_ratio_r: float,\n) -> list[float]:\n    \"\"\"\n    Pure Python implementation of Geometric Series algorithm\n\n    :param nth_term: The last term (nth term of Geometric Series)\n    :param start_term_a : The first term of Geometric Series\n    :param common_ratio_r : The common ratio between all the terms\n    :return: The Geometric Series starting from first term a and multiple of common\n        ration with first term with increase in power till last term (nth term)\n    Examples:\n    >>> geometric_series(4, 2, 2)\n    [2, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.0, 2.0, 2.0)\n    [2.0, 4.0, 8.0, 16.0]\n    >>> geometric_series(4.1, 2.1, 2.1)\n    [2.1, 4.41, 9.261000000000001, 19.448100000000004]\n    >>> geometric_series(4, 2, -2)\n    [2, -4.0, 8.0, -16.0]\n    >>> geometric_series(4, -2, 2)\n    [-2, -4.0, -8.0, -16.0]\n    >>> geometric_series(-4, 2, 2)\n    []\n    >>> geometric_series(0, 100, 500)\n    []\n    >>> geometric_series(1, 1, 1)\n    [1]\n    >>> geometric_series(0, 0, 0)\n    []\n    \"\"\"\n    if not all((nth_term, start_term_a, common_ratio_r)):\n        return []\n    series: list[float] = []\n    power = 1\n    multiple = common_ratio_r\n    for _ in range(int(nth_term)):\n        if not series:\n            series.append(start_term_a)\n        else:\n            power += 1\n            series.append(float(start_term_a * multiple))\n            multiple = pow(float(common_ratio_r), power)\n    return series\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    nth_term = float(input(\"Enter the last number (n term) of the Geometric Series\"))\n    start_term_a = float(input(\"Enter the starting term (a) of the Geometric Series\"))\n    common_ratio_r = float(\n        input(\"Enter the common ratio between two terms (r) of the Geometric Series\")\n    )\n    print(\"Formula of Geometric Series => a + ar + ar^2 ... +ar^n\")\n    print(geometric_series(nth_term, start_term_a, common_ratio_r))\n", "maths/series/harmonic.py": "\"\"\"\nHarmonic mean\nReference: https://en.wikipedia.org/wiki/Harmonic_mean\n\nHarmonic series\nReference: https://en.wikipedia.org/wiki/Harmonic_series(mathematics)\n\"\"\"\n\n\ndef is_harmonic_series(series: list) -> bool:\n    \"\"\"\n    checking whether the input series is arithmetic series or not\n    >>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])\n    True\n    >>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])\n    False\n    >>> is_harmonic_series([1, 2, 3])\n    False\n    >>> is_harmonic_series([1/2, 1/3, 1/4])\n    True\n    >>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])\n    True\n    >>> is_harmonic_series(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [1, 2/3, 2]\n    >>> is_harmonic_series([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n    >>> is_harmonic_series([0])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series cannot have 0 as an element\n    >>> is_harmonic_series([1,2,0,6])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series cannot have 0 as an element\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [1, 2/3, 2]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    if len(series) == 1 and series[0] != 0:\n        return True\n    rec_series = []\n    series_len = len(series)\n    for i in range(series_len):\n        if series[i] == 0:\n            raise ValueError(\"Input series cannot have 0 as an element\")\n        rec_series.append(1 / series[i])\n    common_diff = rec_series[1] - rec_series[0]\n    for index in range(2, series_len):\n        if rec_series[index] - rec_series[index - 1] != common_diff:\n            return False\n    return True\n\n\ndef harmonic_mean(series: list) -> float:\n    \"\"\"\n    return the harmonic mean of series\n\n    >>> harmonic_mean([1, 4, 4])\n    2.0\n    >>> harmonic_mean([3, 6, 9, 12])\n    5.759999999999999\n    >>> harmonic_mean(4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input series is not valid, valid series - [2, 4, 6]\n    >>> harmonic_mean([1, 2, 3])\n    1.6363636363636365\n    >>> harmonic_mean([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Input list must be a non empty list\n\n    \"\"\"\n    if not isinstance(series, list):\n        raise ValueError(\"Input series is not valid, valid series - [2, 4, 6]\")\n    if len(series) == 0:\n        raise ValueError(\"Input list must be a non empty list\")\n    answer = 0\n    for val in series:\n        answer += 1 / val\n    return len(series) / answer\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/series/harmonic_series.py": "\"\"\"\nThis is a pure Python implementation of the Harmonic Series algorithm\nhttps://en.wikipedia.org/wiki/Harmonic_series_(mathematics)\n\nFor doctests run following command:\npython -m doctest -v harmonic_series.py\nor\npython3 -m doctest -v harmonic_series.py\n\nFor manual testing run:\npython3 harmonic_series.py\n\"\"\"\n\n\ndef harmonic_series(n_term: str) -> list:\n    \"\"\"Pure Python implementation of Harmonic Series algorithm\n\n    :param n_term: The last (nth) term of Harmonic Series\n    :return: The Harmonic Series starting from 1 to last (nth) term\n\n    Examples:\n    >>> harmonic_series(5)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.0)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(5.1)\n    ['1', '1/2', '1/3', '1/4', '1/5']\n    >>> harmonic_series(-5)\n    []\n    >>> harmonic_series(0)\n    []\n    >>> harmonic_series(1)\n    ['1']\n    \"\"\"\n    if n_term == \"\":\n        return []\n    series: list = []\n    for temp in range(int(n_term)):\n        series.append(f\"1/{temp + 1}\" if series else \"1\")\n    return series\n\n\nif __name__ == \"__main__\":\n    nth_term = input(\"Enter the last number (nth term) of the Harmonic Series\")\n    print(\"Formula of Harmonic Series => 1+1/2+1/3 ..... 1/n\")\n    print(harmonic_series(nth_term))\n", "maths/series/__init__.py": "", "maths/special_numbers/polygonal_numbers.py": "def polygonal_num(num: int, sides: int) -> int:\n    \"\"\"\n    Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and\n    `sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).\n\n    >>> polygonal_num(0, 3)\n    0\n    >>> polygonal_num(3, 3)\n    6\n    >>> polygonal_num(5, 4)\n    25\n    >>> polygonal_num(2, 5)\n    5\n    >>> polygonal_num(-1, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.\n    >>> polygonal_num(0, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input: num must be >= 0 and sides must be >= 3.\n    \"\"\"\n    if num < 0 or sides < 3:\n        raise ValueError(\"Invalid input: num must be >= 0 and sides must be >= 3.\")\n\n    return ((sides - 2) * num**2 - (sides - 4) * num) // 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/krishnamurthy_number.py": "\"\"\"\n == Krishnamurthy Number ==\nIt is also known as Peterson Number\nA Krishnamurthy Number is a number whose sum of the\nfactorial of the digits equals to the original\nnumber itself.\n\nFor example: 145 = 1! + 4! + 5!\n    So, 145 is a Krishnamurthy Number\n\"\"\"\n\n\ndef factorial(digit: int) -> int:\n    \"\"\"\n    >>> factorial(3)\n    6\n    >>> factorial(0)\n    1\n    >>> factorial(5)\n    120\n    \"\"\"\n\n    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))\n\n\ndef krishnamurthy(number: int) -> bool:\n    \"\"\"\n    >>> krishnamurthy(145)\n    True\n    >>> krishnamurthy(240)\n    False\n    >>> krishnamurthy(1)\n    True\n    \"\"\"\n\n    fact_sum = 0\n    duplicate = number\n    while duplicate > 0:\n        duplicate, digit = divmod(duplicate, 10)\n        fact_sum += factorial(digit)\n    return fact_sum == number\n\n\nif __name__ == \"__main__\":\n    print(\"Program to check whether a number is a Krisnamurthy Number or not.\")\n    number = int(input(\"Enter number: \").strip())\n    print(\n        f\"{number} is {'' if krishnamurthy(number) else 'not '}a Krishnamurthy Number.\"\n    )\n", "maths/special_numbers/hexagonal_number.py": "\"\"\"\n== Hexagonal Number ==\nThe nth hexagonal number hn is the number of distinct dots\nin a pattern of dots consisting of the outlines of regular\nhexagons with sides up to n dots, when the hexagons are\noverlaid so that they share one vertex.\n\nhttps://en.wikipedia.org/wiki/Hexagonal_number\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\n\n\ndef hexagonal(number: int) -> int:\n    \"\"\"\n    :param number: nth hexagonal number to calculate\n    :return: the nth hexagonal number\n    Note: A hexagonal number is only defined for positive integers\n    >>> hexagonal(4)\n    28\n    >>> hexagonal(11)\n    231\n    >>> hexagonal(22)\n    946\n    >>> hexagonal(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> hexagonal(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a positive integer\n    >>> hexagonal(11.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=11.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    return number * (2 * number - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/triangular_numbers.py": "\"\"\"\nA triangular number or triangle number counts objects arranged in an\nequilateral triangle. This module provides a function to generate n'th\ntriangular number.\n\nFor more information about triangular numbers, refer to:\nhttps://en.wikipedia.org/wiki/Triangular_number\n\"\"\"\n\n\ndef triangular_number(position: int) -> int:\n    \"\"\"\n    Generate the triangular number at the specified position.\n\n    Args:\n        position (int): The position of the triangular number to generate.\n\n    Returns:\n        int: The triangular number at the specified position.\n\n    Raises:\n        ValueError: If `position` is negative.\n\n    Examples:\n    >>> triangular_number(1)\n    1\n    >>> triangular_number(3)\n    6\n    >>> triangular_number(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: param `position` must be non-negative\n    \"\"\"\n    if position < 0:\n        raise ValueError(\"param `position` must be non-negative\")\n\n    return position * (position + 1) // 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/proth_number.py": "\"\"\"\nCalculate the nth Proth number\nSource:\n    https://handwiki.org/wiki/Proth_number\n\"\"\"\n\nimport math\n\n\ndef proth(number: int) -> int:\n    \"\"\"\n    :param number: nth number to calculate in the sequence\n    :return: the nth number in Proth number\n    Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3\n    >>> proth(6)\n    25\n    >>> proth(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be > 0\n    >>> proth(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> proth(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n    elif number == 1:\n        return 3\n    elif number == 2:\n        return 5\n    else:\n        \"\"\"\n        +1 for binary starting at 0 i.e. 2^0, 2^1, etc.\n        +1 to start the sequence at the 3rd Proth number\n        Hence, we have a +2 in the below statement\n        \"\"\"\n        block_index = int(math.log(number // 3, 2)) + 2\n\n        proth_list = [3, 5]\n        proth_index = 2\n        increment = 3\n        for block in range(1, block_index):\n            for _ in range(increment):\n                proth_list.append(2 ** (block + 1) + proth_list[proth_index - 1])\n                proth_index += 1\n            increment *= 2\n\n    return proth_list[number - 1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    for number in range(11):\n        value = 0\n        try:\n            value = proth(number)\n        except ValueError:\n            print(f\"ValueError: there is no {number}th Proth number\")\n            continue\n\n        print(f\"The {number}th Proth number: {value}\")\n", "maths/special_numbers/carmichael_number.py": "\"\"\"\n== Carmichael Numbers ==\nA number n is said to be a Carmichael number if it\nsatisfies the following modular arithmetic condition:\n\n    power(b, n-1) MOD n = 1,\n    for all b ranging from 1 to n such that b and\n    n are relatively prime, i.e, gcd(b, n) = 1\n\nExamples of Carmichael Numbers: 561, 1105, ...\nhttps://en.wikipedia.org/wiki/Carmichael_number\n\"\"\"\n\nfrom maths.greatest_common_divisor import greatest_common_divisor\n\n\ndef power(x: int, y: int, mod: int) -> int:\n    \"\"\"\n    Examples:\n    >>> power(2, 15, 3)\n    2\n    >>> power(5, 1, 30)\n    5\n    \"\"\"\n\n    if y == 0:\n        return 1\n    temp = power(x, y // 2, mod) % mod\n    temp = (temp * temp) % mod\n    if y % 2 == 1:\n        temp = (temp * x) % mod\n    return temp\n\n\ndef is_carmichael_number(n: int) -> bool:\n    \"\"\"\n    Examples:\n    >>> is_carmichael_number(4)\n    False\n    >>> is_carmichael_number(561)\n    True\n    >>> is_carmichael_number(562)\n    False\n    >>> is_carmichael_number(900)\n    False\n    >>> is_carmichael_number(1105)\n    True\n    >>> is_carmichael_number(8911)\n    True\n    >>> is_carmichael_number(5.1)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 5.1 must instead be a positive integer\n\n    >>> is_carmichael_number(-7)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number -7 must instead be a positive integer\n\n    >>> is_carmichael_number(0)\n    Traceback (most recent call last):\n         ...\n    ValueError: Number 0 must instead be a positive integer\n    \"\"\"\n\n    if n <= 0 or not isinstance(n, int):\n        msg = f\"Number {n} must instead be a positive integer\"\n        raise ValueError(msg)\n\n    return all(\n        power(b, n - 1, n) == 1\n        for b in range(2, n)\n        if greatest_common_divisor(b, n) == 1\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    number = int(input(\"Enter number: \").strip())\n    if is_carmichael_number(number):\n        print(f\"{number} is a Carmichael Number.\")\n    else:\n        print(f\"{number} is not a Carmichael Number.\")\n", "maths/special_numbers/perfect_number.py": "\"\"\"\n== Perfect Number ==\nIn number theory, a perfect number is a positive integer that is equal to the sum of\nits positive divisors, excluding the number itself.\nFor example: 6 ==> divisors[1, 2, 3, 6]\n    Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6\n    So, 6 is a Perfect Number\n\nOther examples of Perfect Numbers: 28, 486, ...\n\nhttps://en.wikipedia.org/wiki/Perfect_number\n\"\"\"\n\n\ndef perfect(number: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect number.\n\n    A perfect number is a positive integer that is equal to the sum of its proper\n    divisors (excluding itself).\n\n    Args:\n        number: The number to be checked.\n\n    Returns:\n        True if the number is a perfect number, False otherwise.\n\n    Start from 1 because dividing by 0 will raise ZeroDivisionError.\n    A number at most can be divisible by the half of the number except the number\n    itself. For example, 6 is at most can be divisible by 3 except by 6 itself.\n\n    Examples:\n    >>> perfect(27)\n    False\n    >>> perfect(28)\n    True\n    >>> perfect(29)\n    False\n    >>> perfect(6)\n    True\n    >>> perfect(12)\n    False\n    >>> perfect(496)\n    True\n    >>> perfect(8128)\n    True\n    >>> perfect(0)\n    False\n    >>> perfect(-1)\n    False\n    >>> perfect(12.34)\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    >>> perfect(\"Hello\")\n    Traceback (most recent call last):\n      ...\n    ValueError: number must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        raise ValueError(\"number must be an integer\")\n    if number <= 0:\n        return False\n    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(\"Program to check whether a number is a Perfect number or not...\")\n    try:\n        number = int(input(\"Enter a positive integer: \").strip())\n    except ValueError:\n        msg = \"number must be an integer\"\n        print(msg)\n        raise ValueError(msg)\n\n    print(f\"{number} is {'' if perfect(number) else 'not '}a Perfect Number.\")\n", "maths/special_numbers/armstrong_numbers.py": "\"\"\"\nAn Armstrong number is equal to the sum of its own digits each raised to the\npower of the number of digits.\n\nFor example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\n\nArmstrong numbers are also called Narcissistic numbers and Pluperfect numbers.\n\nOn-Line Encyclopedia of Integer Sequences entry: https://oeis.org/A005188\n\"\"\"\n\nPASSING = (1, 153, 370, 371, 1634, 24678051, 115132219018763992565095597973971522401)\nFAILING: tuple = (-153, -1, 0, 1.2, 200, \"A\", [], {}, None)\n\n\ndef armstrong_number(n: int) -> bool:\n    \"\"\"\n    Return True if n is an Armstrong number or False if it is not.\n\n    >>> all(armstrong_number(n) for n in PASSING)\n    True\n    >>> any(armstrong_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Initialization of sum and number of digits.\n    total = 0\n    number_of_digits = 0\n    temp = n\n    # Calculation of digits of the number\n    number_of_digits = len(str(n))\n    # Dividing number into separate digits and find Armstrong number\n    temp = n\n    while temp > 0:\n        rem = temp % 10\n        total += rem**number_of_digits\n        temp //= 10\n    return n == total\n\n\ndef pluperfect_number(n: int) -> bool:\n    \"\"\"Return True if n is a pluperfect number or False if it is not\n\n    >>> all(armstrong_number(n) for n in PASSING)\n    True\n    >>> any(armstrong_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n\n    # Init a \"histogram\" of the digits\n    digit_histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    digit_total = 0\n    total = 0\n    temp = n\n    while temp > 0:\n        temp, rem = divmod(temp, 10)\n        digit_histogram[rem] += 1\n        digit_total += 1\n\n    for cnt, i in zip(digit_histogram, range(len(digit_histogram))):\n        total += cnt * i**digit_total\n\n    return n == total\n\n\ndef narcissistic_number(n: int) -> bool:\n    \"\"\"Return True if n is a narcissistic number or False if it is not.\n\n    >>> all(armstrong_number(n) for n in PASSING)\n    True\n    >>> any(armstrong_number(n) for n in FAILING)\n    False\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n    expo = len(str(n))  # the power that all digits will be raised to\n    # check if sum of each digit multiplied expo times is equal to number\n    return n == sum(int(i) ** expo for i in str(n))\n\n\ndef main():\n    \"\"\"\n    Request that user input an integer and tell them if it is Armstrong number.\n    \"\"\"\n    num = int(input(\"Enter an integer to see if it is an Armstrong number: \").strip())\n    print(f\"{num} is {'' if armstrong_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if narcissistic_number(num) else 'not '}an Armstrong number.\")\n    print(f\"{num} is {'' if pluperfect_number(num) else 'not '}an Armstrong number.\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "maths/special_numbers/bell_numbers.py": "\"\"\"\nBell numbers represent the number of ways to partition a set into non-empty\nsubsets. This module provides functions to calculate Bell numbers for sets of\nintegers. In other words, the first (n + 1) Bell numbers.\n\nFor more information about Bell numbers, refer to:\nhttps://en.wikipedia.org/wiki/Bell_number\n\"\"\"\n\n\ndef bell_numbers(max_set_length: int) -> list[int]:\n    \"\"\"\n    Calculate Bell numbers for the sets of lengths from 0 to max_set_length.\n    In other words, calculate first (max_set_length + 1) Bell numbers.\n\n    Args:\n        max_set_length (int): The maximum length of the sets for which\n        Bell numbers are calculated.\n\n    Returns:\n        list: A list of Bell numbers for sets of lengths from 0 to max_set_length.\n\n    Examples:\n    >>> bell_numbers(0)\n    [1]\n    >>> bell_numbers(1)\n    [1, 1]\n    >>> bell_numbers(5)\n    [1, 1, 2, 5, 15, 52]\n    \"\"\"\n    if max_set_length < 0:\n        raise ValueError(\"max_set_length must be non-negative\")\n\n    bell = [0] * (max_set_length + 1)\n    bell[0] = 1\n\n    for i in range(1, max_set_length + 1):\n        for j in range(i):\n            bell[i] += _binomial_coefficient(i - 1, j) * bell[j]\n\n    return bell\n\n\ndef _binomial_coefficient(total_elements: int, elements_to_choose: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(total_elements, elements_to_choose)\n\n    Args:\n        total_elements (int): The total number of elements.\n        elements_to_choose (int): The number of elements to choose.\n\n    Returns:\n        int: The binomial coefficient C(total_elements, elements_to_choose).\n\n    Examples:\n    >>> _binomial_coefficient(5, 2)\n    10\n    >>> _binomial_coefficient(6, 3)\n    20\n    \"\"\"\n    if elements_to_choose in {0, total_elements}:\n        return 1\n\n    if elements_to_choose > total_elements - elements_to_choose:\n        elements_to_choose = total_elements - elements_to_choose\n\n    coefficient = 1\n    for i in range(elements_to_choose):\n        coefficient *= total_elements - i\n        coefficient //= i + 1\n\n    return coefficient\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/automorphic_number.py": "\"\"\"\n== Automorphic Numbers ==\nA number n is said to be a Automorphic number if\nthe square of n \"ends\" in the same digits as n itself.\n\nExamples of Automorphic Numbers: 0, 1, 5, 6, 25, 76, 376, 625, 9376, 90625, ...\nhttps://en.wikipedia.org/wiki/Automorphic_number\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\n# Time Complexity : O(log10n)\n\n\ndef is_automorphic_number(number: int) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns True if the number is automorphic.\n    >>> is_automorphic_number(-1)\n    False\n    >>> is_automorphic_number(0)\n    True\n    >>> is_automorphic_number(5)\n    True\n    >>> is_automorphic_number(6)\n    True\n    >>> is_automorphic_number(7)\n    False\n    >>> is_automorphic_number(25)\n    True\n    >>> is_automorphic_number(259918212890625)\n    True\n    >>> is_automorphic_number(259918212890636)\n    False\n    >>> is_automorphic_number(740081787109376)\n    True\n    >>> is_automorphic_number(5.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=5.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 0:\n        return False\n    number_square = number * number\n    while number > 0:\n        if number % 10 != number_square % 10:\n            return False\n        number //= 10\n        number_square //= 10\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/harshad_numbers.py": "\"\"\"\nA harshad number (or more specifically an n-harshad number) is a number that's\ndivisible by the sum of its digits in some given base n.\nReference: https://en.wikipedia.org/wiki/Harshad_number\n\"\"\"\n\n\ndef int_to_base(number: int, base: int) -> str:\n    \"\"\"\n    Convert a given positive decimal integer to base 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> int_to_base(23, 2)\n    '10111'\n    >>> int_to_base(58, 5)\n    '213'\n    >>> int_to_base(167, 16)\n    'A7'\n    >>> # bases below 2 and beyond 36 will error\n    >>> int_to_base(98, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> int_to_base(98, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = \"\"\n\n    if number < 0:\n        raise ValueError(\"number must be a positive integer\")\n\n    while number > 0:\n        number, remainder = divmod(number, base)\n        result = digits[remainder] + result\n\n    if result == \"\":\n        result = \"0\"\n\n    return result\n\n\ndef sum_of_digits(num: int, base: int) -> str:\n    \"\"\"\n    Calculate the sum of digit values in a positive integer\n    converted to the given 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> sum_of_digits(103, 12)\n    '13'\n    >>> sum_of_digits(1275, 4)\n    '30'\n    >>> sum_of_digits(6645, 2)\n    '1001'\n    >>> # bases below 2 and beyond 36 will error\n    >>> sum_of_digits(543, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> sum_of_digits(543, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    num_str = int_to_base(num, base)\n    res = sum(int(char, base) for char in num_str)\n    res_str = int_to_base(res, base)\n    return res_str\n\n\ndef harshad_numbers_in_base(limit: int, base: int) -> list[str]:\n    \"\"\"\n    Finds all Harshad numbers smaller than num in base 'base'.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> harshad_numbers_in_base(15, 2)\n    ['1', '10', '100', '110', '1000', '1010', '1100']\n    >>> harshad_numbers_in_base(12, 34)\n    ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']\n    >>> harshad_numbers_in_base(12, 4)\n    ['1', '2', '3', '10', '12', '20', '21']\n    >>> # bases below 2 and beyond 36 will error\n    >>> harshad_numbers_in_base(234, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> harshad_numbers_in_base(234, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if limit < 0:\n        return []\n\n    numbers = [\n        int_to_base(i, base)\n        for i in range(1, limit)\n        if i % int(sum_of_digits(i, base), base) == 0\n    ]\n\n    return numbers\n\n\ndef is_harshad_number_in_base(num: int, base: int) -> bool:\n    \"\"\"\n    Determines whether n in base 'base' is a harshad number.\n    Where 'base' ranges from 2 to 36.\n\n    Examples:\n    >>> is_harshad_number_in_base(18, 10)\n    True\n    >>> is_harshad_number_in_base(21, 10)\n    True\n    >>> is_harshad_number_in_base(-21, 5)\n    False\n    >>> # bases below 2 and beyond 36 will error\n    >>> is_harshad_number_in_base(45, 37)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    >>> is_harshad_number_in_base(45, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'base' must be between 2 and 36 inclusive\n    \"\"\"\n\n    if base < 2 or base > 36:\n        raise ValueError(\"'base' must be between 2 and 36 inclusive\")\n\n    if num < 0:\n        return False\n\n    n = int_to_base(num, base)\n    d = sum_of_digits(num, base)\n    return int(n, base) % int(d, base) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/weird_number.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Weird_number\n\nFun fact: The set of weird numbers has positive asymptotic density.\n\"\"\"\n\nfrom math import sqrt\n\n\ndef factors(number: int) -> list[int]:\n    \"\"\"\n    >>> factors(12)\n    [1, 2, 3, 4, 6]\n    >>> factors(1)\n    [1]\n    >>> factors(100)\n    [1, 2, 4, 5, 10, 20, 25, 50]\n\n    # >>> factors(-12)\n    # [1, 2, 3, 4, 6]\n    \"\"\"\n\n    values = [1]\n    for i in range(2, int(sqrt(number)) + 1, 1):\n        if number % i == 0:\n            values.append(i)\n            if int(number // i) != i:\n                values.append(int(number // i))\n    return sorted(values)\n\n\ndef abundant(n: int) -> bool:\n    \"\"\"\n    >>> abundant(0)\n    True\n    >>> abundant(1)\n    False\n    >>> abundant(12)\n    True\n    >>> abundant(13)\n    False\n    >>> abundant(20)\n    True\n\n    # >>> abundant(-12)\n    # True\n    \"\"\"\n    return sum(factors(n)) > n\n\n\ndef semi_perfect(number: int) -> bool:\n    \"\"\"\n    >>> semi_perfect(0)\n    True\n    >>> semi_perfect(1)\n    True\n    >>> semi_perfect(12)\n    True\n    >>> semi_perfect(13)\n    False\n\n    # >>> semi_perfect(-12)\n    # True\n    \"\"\"\n    values = factors(number)\n    r = len(values)\n    subset = [[0 for i in range(number + 1)] for j in range(r + 1)]\n    for i in range(r + 1):\n        subset[i][0] = True\n\n    for i in range(1, number + 1):\n        subset[0][i] = False\n\n    for i in range(1, r + 1):\n        for j in range(1, number + 1):\n            if j < values[i - 1]:\n                subset[i][j] = subset[i - 1][j]\n            else:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - values[i - 1]]\n\n    return subset[r][number] != 0\n\n\ndef weird(number: int) -> bool:\n    \"\"\"\n    >>> weird(0)\n    False\n    >>> weird(70)\n    True\n    >>> weird(77)\n    False\n    \"\"\"\n    return abundant(number) and not semi_perfect(number)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n    for number in (69, 70, 71):\n        print(f\"{number} is {'' if weird(number) else 'not '}weird.\")\n", "maths/special_numbers/pronic_number.py": "\"\"\"\n== Pronic Number ==\nA number n is said to be a Proic number if\nthere exists an integer m such that n = m * (m + 1)\n\nExamples of Proic Numbers: 0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110 ...\nhttps://en.wikipedia.org/wiki/Pronic_number\n\"\"\"\n\n# Author : Akshay Dubey (https://github.com/itsAkshayDubey)\n\n\ndef is_pronic(number: int) -> bool:\n    \"\"\"\n    # doctest: +NORMALIZE_WHITESPACE\n    This functions takes an integer number as input.\n    returns True if the number is pronic.\n    >>> is_pronic(-1)\n    False\n    >>> is_pronic(0)\n    True\n    >>> is_pronic(2)\n    True\n    >>> is_pronic(5)\n    False\n    >>> is_pronic(6)\n    True\n    >>> is_pronic(8)\n    False\n    >>> is_pronic(30)\n    True\n    >>> is_pronic(32)\n    False\n    >>> is_pronic(2147441940)\n    True\n    >>> is_pronic(9223372033963249500)\n    True\n    >>> is_pronic(6.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=6.0] must be an integer\n    \"\"\"\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n    if number < 0 or number % 2 == 1:\n        return False\n    number_sqrt = int(number**0.5)\n    return number == number_sqrt * (number_sqrt + 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/ugly_numbers.py": "\"\"\"\nUgly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence\n1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \u2026 shows the first 11 ugly numbers. By convention,\n1 is included.\nGiven an integer n, we have to find the nth ugly number.\n\nFor more details, refer this article\nhttps://www.geeksforgeeks.org/ugly-numbers/\n\"\"\"\n\n\ndef ugly_numbers(n: int) -> int:\n    \"\"\"\n    Returns the nth ugly number.\n    >>> ugly_numbers(100)\n    1536\n    >>> ugly_numbers(0)\n    1\n    >>> ugly_numbers(20)\n    36\n    >>> ugly_numbers(-5)\n    1\n    >>> ugly_numbers(-5.5)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    \"\"\"\n    ugly_nums = [1]\n\n    i2, i3, i5 = 0, 0, 0\n    next_2 = ugly_nums[i2] * 2\n    next_3 = ugly_nums[i3] * 3\n    next_5 = ugly_nums[i5] * 5\n\n    for _ in range(1, n):\n        next_num = min(next_2, next_3, next_5)\n        ugly_nums.append(next_num)\n        if next_num == next_2:\n            i2 += 1\n            next_2 = ugly_nums[i2] * 2\n        if next_num == next_3:\n            i3 += 1\n            next_3 = ugly_nums[i3] * 3\n        if next_num == next_5:\n            i5 += 1\n            next_5 = ugly_nums[i5] * 5\n    return ugly_nums[-1]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(verbose=True)\n    print(f\"{ugly_numbers(200) = }\")\n", "maths/special_numbers/__init__.py": "", "maths/special_numbers/happy_number.py": "def is_happy_number(number: int) -> bool:\n    \"\"\"\n    A happy number is a number which eventually reaches 1 when replaced by the sum of\n    the square of each digit.\n\n    :param number: The number to check for happiness.\n    :return: True if the number is a happy number, False otherwise.\n\n    >>> is_happy_number(19)\n    True\n    >>> is_happy_number(2)\n    False\n    >>> is_happy_number(23)\n    True\n    >>> is_happy_number(1)\n    True\n    >>> is_happy_number(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=0 must be a positive integer\n    >>> is_happy_number(-19)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=-19 must be a positive integer\n    >>> is_happy_number(19.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number=19.1 must be a positive integer\n    >>> is_happy_number(\"happy\")\n    Traceback (most recent call last):\n        ...\n    ValueError: number='happy' must be a positive integer\n    \"\"\"\n    if not isinstance(number, int) or number <= 0:\n        msg = f\"{number=} must be a positive integer\"\n        raise ValueError(msg)\n\n    seen = set()\n    while number != 1 and number not in seen:\n        seen.add(number)\n        number = sum(int(digit) ** 2 for digit in str(number))\n    return number == 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/special_numbers/hamming_numbers.py": "\"\"\"\nA Hamming number is a positive integer of the form 2^i*3^j*5^k, for some\nnon-negative integers i, j, and k. They are often referred to as regular numbers.\nMore info at: https://en.wikipedia.org/wiki/Regular_number.\n\"\"\"\n\n\ndef hamming(n_element: int) -> list:\n    \"\"\"\n    This function creates an ordered list of n length as requested, and afterwards\n    returns the last value of the list. It must be given a positive integer.\n\n    :param n_element: The number of elements on the list\n    :return: The nth element of the list\n\n    >>> hamming(5)\n    [1, 2, 3, 4, 5]\n    >>> hamming(10)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]\n    >>> hamming(15)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]\n    \"\"\"\n    n_element = int(n_element)\n    if n_element < 1:\n        my_error = ValueError(\"a should be a positive number\")\n        raise my_error\n\n    hamming_list = [1]\n    i, j, k = (0, 0, 0)\n    index = 1\n    while index < n_element:\n        while hamming_list[i] * 2 <= hamming_list[-1]:\n            i += 1\n        while hamming_list[j] * 3 <= hamming_list[-1]:\n            j += 1\n        while hamming_list[k] * 5 <= hamming_list[-1]:\n            k += 1\n        hamming_list.append(\n            min(hamming_list[i] * 2, hamming_list[j] * 3, hamming_list[k] * 5)\n        )\n        index += 1\n    return hamming_list\n\n\nif __name__ == \"__main__\":\n    n = input(\"Enter the last number (nth term) of the Hamming Number Series: \")\n    print(\"Formula of Hamming Number Series => 2^i * 3^j * 5^k\")\n    hamming_numbers = hamming(int(n))\n    print(\"-----------------------------------------------------\")\n    print(f\"The list with nth numbers is: {hamming_numbers}\")\n    print(\"-----------------------------------------------------\")\n", "maths/special_numbers/catalan_number.py": "\"\"\"\n\nCalculate the nth Catalan number\n\nSource:\n    https://en.wikipedia.org/wiki/Catalan_number\n\n\"\"\"\n\n\ndef catalan(number: int) -> int:\n    \"\"\"\n    :param number: nth catalan number to calculate\n    :return: the nth catalan number\n    Note: A catalan number is only defined for positive integers\n\n    >>> catalan(5)\n    14\n    >>> catalan(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=0] must be > 0\n    >>> catalan(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value of [number=-1] must be > 0\n    >>> catalan(5.0)\n    Traceback (most recent call last):\n        ...\n    TypeError: Input value of [number=5.0] must be an integer\n    \"\"\"\n\n    if not isinstance(number, int):\n        msg = f\"Input value of [number={number}] must be an integer\"\n        raise TypeError(msg)\n\n    if number < 1:\n        msg = f\"Input value of [number={number}] must be > 0\"\n        raise ValueError(msg)\n\n    current_number = 1\n\n    for i in range(1, number):\n        current_number *= 4 * i - 2\n        current_number //= i + 1\n\n    return current_number\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/bisection_2.py": "\"\"\"\nGiven a function on floating number f(x) and two floating numbers `a` and `b` such that\nf(a) * f(b) < 0 and f(x) is continuous in [a, b].\nHere f(x) represents algebraic or transcendental equation.\nFind root of function in interval [a, b] (Or find a value of x such that f(x) is 0)\n\nhttps://en.wikipedia.org/wiki/Bisection_method\n\"\"\"\n\n\ndef equation(x: float) -> float:\n    \"\"\"\n    >>> equation(5)\n    -15\n    >>> equation(0)\n    10\n    >>> equation(-5)\n    -15\n    >>> equation(0.1)\n    9.99\n    >>> equation(-0.1)\n    9.99\n    \"\"\"\n    return 10 - x * x\n\n\ndef bisection(a: float, b: float) -> float:\n    \"\"\"\n    >>> bisection(-2, 5)\n    3.1611328125\n    >>> bisection(0, 6)\n    3.158203125\n    >>> bisection(2, 3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong space!\n    \"\"\"\n    # Bolzano theory in order to find if there is a root between a and b\n    if equation(a) * equation(b) >= 0:\n        raise ValueError(\"Wrong space!\")\n\n    c = a\n    while (b - a) >= 0.01:\n        # Find middle point\n        c = (a + b) / 2\n        # Check if middle point is root\n        if equation(c) == 0.0:\n            break\n        # Decide the side to repeat the steps\n        if equation(c) * equation(a) < 0:\n            b = c\n        else:\n            a = c\n    return c\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(bisection(-2, 5))\n    print(bisection(0, 6))\n", "maths/numerical_analysis/integration_by_simpson_approx.py": "\"\"\"\nAuthor : Syed Faizan ( 3rd Year IIIT Pune )\nGithub : faizan2700\n\nPurpose : You have one function f(x) which takes float integer and returns\nfloat you have to integrate the function in limits a to b.\nThe approximation proposed by Thomas Simpsons in 1743 is one way to calculate\nintegration.\n\n( read article : https://cp-algorithms.com/num_methods/simpson-integration.html )\n\nsimpson_integration() takes function,lower_limit=a,upper_limit=b,precision and\nreturns the integration of function in given limit.\n\"\"\"\n\n# constants\n# the more the number of steps the more accurate\nN_STEPS = 1000\n\n\ndef f(x: float) -> float:\n    return x * x\n\n\n\"\"\"\nSummary of Simpson Approximation :\n\nBy simpsons integration :\n1. integration of fxdx with limit a to b is =\n    f(x0) + 4 * f(x1) + 2 * f(x2) + 4 * f(x3) + 2 * f(x4)..... + f(xn)\nwhere x0 = a\nxi = a + i * h\nxn = b\n\"\"\"\n\n\ndef simpson_integration(function, a: float, b: float, precision: int = 4) -> float:\n    \"\"\"\n    Args:\n        function : the function which's integration is desired\n        a : the lower limit of integration\n        b : upper limit of integration\n        precision : precision of the result,error required default is 4\n\n    Returns:\n        result : the value of the approximated integration of function in range a to b\n\n    Raises:\n        AssertionError: function is not callable\n        AssertionError: a is not float or integer\n        AssertionError: function should return float or integer\n        AssertionError: b is not float or integer\n        AssertionError: precision is not positive integer\n\n    >>> simpson_integration(lambda x : x*x,1,2,3)\n    2.333\n\n    >>> simpson_integration(lambda x : x*x,'wrong_input',2,3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: a should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,'wrong_input',3)\n    Traceback (most recent call last):\n        ...\n    AssertionError: b should be float or integer your input : wrong_input\n\n    >>> simpson_integration(lambda x : x*x,1,2,'wrong_input')\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : wrong_input\n    >>> simpson_integration('wrong_input',2,3,4)\n    Traceback (most recent call last):\n        ...\n    AssertionError: the function(object) passed should be callable your input : ...\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,1)\n    -2.8\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,0)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : 0\n\n    >>> simpson_integration(lambda x : x*x,3.45,3.2,-1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: precision should be positive integer your input : -1\n\n    \"\"\"\n    assert callable(\n        function\n    ), f\"the function(object) passed should be callable your input : {function}\"\n    assert isinstance(a, (float, int)), f\"a should be float or integer your input : {a}\"\n    assert isinstance(function(a), (float, int)), (\n        \"the function should return integer or float return type of your function, \"\n        f\"{type(a)}\"\n    )\n    assert isinstance(b, (float, int)), f\"b should be float or integer your input : {b}\"\n    assert (\n        isinstance(precision, int) and precision > 0\n    ), f\"precision should be positive integer your input : {precision}\"\n\n    # just applying the formula of simpson for approximate integration written in\n    # mentioned article in first comment of this file and above this function\n\n    h = (b - a) / N_STEPS\n    result = function(a) + function(b)\n\n    for i in range(1, N_STEPS):\n        a1 = a + h * i\n        result += function(a1) * (4 if i % 2 else 2)\n\n    result *= h / 3\n    return round(result, precision)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/simpson_rule.py": "\"\"\"\nNumerical integration or quadrature for a smooth function f with known values at x_i\n\nThis method is the classical approach of summing 'Equally Spaced Abscissas'\n\nmethod 2:\n\"Simpson Rule\"\n\n\"\"\"\n\n\ndef method_2(boundary: list[int], steps: int) -> float:\n    # \"Simpson Rule\"\n    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)\n    \"\"\"\n    Calculate the definite integral of a function using Simpson's Rule.\n    :param boundary: A list containing the lower and upper bounds of integration.\n    :param steps: The number of steps or resolution for the integration.\n    :return: The approximate integral value.\n\n    >>> round(method_2([0, 2, 4], 10), 10)\n    2.6666666667\n    >>> round(method_2([2, 0], 10), 10)\n    -0.2666666667\n    >>> round(method_2([-2, -1], 10), 10)\n    2.172\n    >>> round(method_2([0, 1], 10), 10)\n    0.3333333333\n    >>> round(method_2([0, 2], 10), 10)\n    2.6666666667\n    >>> round(method_2([0, 2], 100), 10)\n    2.5621226667\n    >>> round(method_2([0, 1], 1000), 10)\n    0.3320026653\n    >>> round(method_2([0, 2], 0), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    >>> round(method_2([0, 2], -10), 10)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Number of steps must be greater than zero\n    \"\"\"\n    if steps <= 0:\n        raise ZeroDivisionError(\"Number of steps must be greater than zero\")\n\n    h = (boundary[1] - boundary[0]) / steps\n    a = boundary[0]\n    b = boundary[1]\n    x_i = make_points(a, b, h)\n    y = 0.0\n    y += (h / 3.0) * f(a)\n    cnt = 2\n    for i in x_i:\n        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)\n        cnt += 1\n    y += (h / 3.0) * f(b)\n    return y\n\n\ndef make_points(a, b, h):\n    x = a + h\n    while x < (b - h):\n        yield x\n        x = x + h\n\n\ndef f(x):  # enter your function here\n    y = (x - 0) * (x - 0)\n    return y\n\n\ndef main():\n    a = 0.0  # Lower bound of integration\n    b = 1.0  # Upper bound of integration\n    steps = 10.0  # number of steps or resolution\n    boundary = [a, b]  # boundary of integration\n    y = method_2(boundary, steps)\n    print(f\"y = {y}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "maths/numerical_analysis/secant_method.py": "\"\"\"\nImplementing Secant method in Python\nAuthor: dimgrichr\n\"\"\"\n\nfrom math import exp\n\n\ndef f(x: float) -> float:\n    \"\"\"\n    >>> f(5)\n    39.98652410600183\n    \"\"\"\n    return 8 * x - 2 * exp(-x)\n\n\ndef secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:\n    \"\"\"\n    >>> secant_method(1, 3, 2)\n    0.2139409276214589\n    \"\"\"\n    x0 = lower_bound\n    x1 = upper_bound\n    for _ in range(repeats):\n        x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))\n    return x1\n\n\nif __name__ == \"__main__\":\n    print(f\"Example: {secant_method(1, 3, 2)}\")\n", "maths/numerical_analysis/adams_bashforth.py": "\"\"\"\nUse the Adams-Bashforth methods to solve Ordinary Differential Equations.\n\nhttps://en.wikipedia.org/wiki/Linear_multistep_method\nAuthor : Ravi Kumar\n\"\"\"\n\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\n\nimport numpy as np\n\n\n@dataclass\nclass AdamsBashforth:\n    \"\"\"\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initials: List containing initial required values of x.\n    y_initials: List containing initial required values of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns: Solution of y at each nodal point\n\n    >>> def f(x, y):\n    ...     return x + y\n    >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0.2, 1], 0.2, 1)  # doctest: +ELLIPSIS\n    AdamsBashforth(func=..., x_initials=[0, 0.2, 0.4], y_initials=[0, 0.2, 1], step...)\n    >>> AdamsBashforth(f, [0, 0.2, 1], [0, 0, 0.04], 0.2, 1).step_2()\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than the initial values of x.\n\n    >>> AdamsBashforth(f, [0, 0.2, 0.3], [0, 0, 0.04], 0.2, 1).step_3()\n    Traceback (most recent call last):\n        ...\n    ValueError: x-values must be equally spaced according to step size.\n\n    >>> AdamsBashforth(f,[0,0.2,0.4,0.6,0.8],[0,0,0.04,0.128,0.307],-0.2,1).step_5()\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n\n    func: Callable[[float, float], float]\n    x_initials: list[float]\n    y_initials: list[float]\n    step_size: float\n    x_final: float\n\n    def __post_init__(self) -> None:\n        if self.x_initials[-1] >= self.x_final:\n            raise ValueError(\n                \"The final value of x must be greater than the initial values of x.\"\n            )\n\n        if self.step_size <= 0:\n            raise ValueError(\"Step size must be positive.\")\n\n        if not all(\n            round(x1 - x0, 10) == self.step_size\n            for x0, x1 in zip(self.x_initials, self.x_initials[1:])\n        ):\n            raise ValueError(\"x-values must be equally spaced according to step size.\")\n\n    def step_2(self) -> np.ndarray:\n        \"\"\"\n        >>> def f(x, y):\n        ...     return x\n        >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_2()\n        array([0.  , 0.  , 0.06, 0.16, 0.3 , 0.48])\n\n        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_2()\n        Traceback (most recent call last):\n            ...\n        ValueError: Insufficient initial points information.\n        \"\"\"\n\n        if len(self.x_initials) != 2 or len(self.y_initials) != 2:\n            raise ValueError(\"Insufficient initial points information.\")\n\n        x_0, x_1 = self.x_initials[:2]\n        y_0, y_1 = self.y_initials[:2]\n\n        n = int((self.x_final - x_1) / self.step_size)\n        y = np.zeros(n + 2)\n        y[0] = y_0\n        y[1] = y_1\n\n        for i in range(n):\n            y[i + 2] = y[i + 1] + (self.step_size / 2) * (\n                3 * self.func(x_1, y[i + 1]) - self.func(x_0, y[i])\n            )\n            x_0 = x_1\n            x_1 += self.step_size\n\n        return y\n\n    def step_3(self) -> np.ndarray:\n        \"\"\"\n        >>> def f(x, y):\n        ...     return x + y\n        >>> y = AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_3()\n        >>> y[3]\n        0.15533333333333332\n\n        >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_3()\n        Traceback (most recent call last):\n            ...\n        ValueError: Insufficient initial points information.\n        \"\"\"\n        if len(self.x_initials) != 3 or len(self.y_initials) != 3:\n            raise ValueError(\"Insufficient initial points information.\")\n\n        x_0, x_1, x_2 = self.x_initials[:3]\n        y_0, y_1, y_2 = self.y_initials[:3]\n\n        n = int((self.x_final - x_2) / self.step_size)\n        y = np.zeros(n + 4)\n        y[0] = y_0\n        y[1] = y_1\n        y[2] = y_2\n\n        for i in range(n + 1):\n            y[i + 3] = y[i + 2] + (self.step_size / 12) * (\n                23 * self.func(x_2, y[i + 2])\n                - 16 * self.func(x_1, y[i + 1])\n                + 5 * self.func(x_0, y[i])\n            )\n            x_0 = x_1\n            x_1 = x_2\n            x_2 += self.step_size\n\n        return y\n\n    def step_4(self) -> np.ndarray:\n        \"\"\"\n        >>> def f(x,y):\n        ...     return x + y\n        >>> y = AdamsBashforth(\n        ...    f, [0, 0.2, 0.4, 0.6], [0, 0, 0.04, 0.128], 0.2, 1).step_4()\n        >>> y[4]\n        0.30699999999999994\n        >>> y[5]\n        0.5771083333333333\n\n        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_4()\n        Traceback (most recent call last):\n            ...\n        ValueError: Insufficient initial points information.\n        \"\"\"\n\n        if len(self.x_initials) != 4 or len(self.y_initials) != 4:\n            raise ValueError(\"Insufficient initial points information.\")\n\n        x_0, x_1, x_2, x_3 = self.x_initials[:4]\n        y_0, y_1, y_2, y_3 = self.y_initials[:4]\n\n        n = int((self.x_final - x_3) / self.step_size)\n        y = np.zeros(n + 4)\n        y[0] = y_0\n        y[1] = y_1\n        y[2] = y_2\n        y[3] = y_3\n\n        for i in range(n):\n            y[i + 4] = y[i + 3] + (self.step_size / 24) * (\n                55 * self.func(x_3, y[i + 3])\n                - 59 * self.func(x_2, y[i + 2])\n                + 37 * self.func(x_1, y[i + 1])\n                - 9 * self.func(x_0, y[i])\n            )\n            x_0 = x_1\n            x_1 = x_2\n            x_2 = x_3\n            x_3 += self.step_size\n\n        return y\n\n    def step_5(self) -> np.ndarray:\n        \"\"\"\n        >>> def f(x,y):\n        ...     return x + y\n        >>> y = AdamsBashforth(\n        ...     f, [0, 0.2, 0.4, 0.6, 0.8], [0, 0.02140, 0.02140, 0.22211, 0.42536],\n        ...     0.2, 1).step_5()\n        >>> y[-1]\n        0.05436839444444452\n\n        >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_5()\n        Traceback (most recent call last):\n            ...\n        ValueError: Insufficient initial points information.\n        \"\"\"\n\n        if len(self.x_initials) != 5 or len(self.y_initials) != 5:\n            raise ValueError(\"Insufficient initial points information.\")\n\n        x_0, x_1, x_2, x_3, x_4 = self.x_initials[:5]\n        y_0, y_1, y_2, y_3, y_4 = self.y_initials[:5]\n\n        n = int((self.x_final - x_4) / self.step_size)\n        y = np.zeros(n + 6)\n        y[0] = y_0\n        y[1] = y_1\n        y[2] = y_2\n        y[3] = y_3\n        y[4] = y_4\n\n        for i in range(n + 1):\n            y[i + 5] = y[i + 4] + (self.step_size / 720) * (\n                1901 * self.func(x_4, y[i + 4])\n                - 2774 * self.func(x_3, y[i + 3])\n                - 2616 * self.func(x_2, y[i + 2])\n                - 1274 * self.func(x_1, y[i + 1])\n                + 251 * self.func(x_0, y[i])\n            )\n            x_0 = x_1\n            x_1 = x_2\n            x_2 = x_3\n            x_3 = x_4\n            x_4 += self.step_size\n\n        return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/runge_kutta.py": "import numpy as np\n\n\ndef runge_kutta(f, y0, x0, h, x_end):\n    \"\"\"\n    Calculate the numeric solution at each step to the ODE f(x, y) using RK4\n\n    https://en.wikipedia.org/wiki/Runge-Kutta_methods\n\n    Arguments:\n    f -- The ode as a function of x and y\n    y0 -- the initial value for y\n    x0 -- the initial value for x\n    h -- the stepsize\n    x_end -- the end value for x\n\n    >>> # the exact solution is math.exp(x)\n    >>> def f(x, y):\n    ...     return y\n    >>> y0 = 1\n    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)\n    >>> y[-1]\n    148.41315904125113\n    \"\"\"\n    n = int(np.ceil((x_end - x0) / h))\n    y = np.zeros((n + 1,))\n    y[0] = y0\n    x = x0\n\n    for k in range(n):\n        k1 = f(x, y[k])\n        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)\n        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)\n        k4 = f(x + h, y[k] + h * k3)\n        y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)\n        x += h\n\n    return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/runge_kutta_gills.py": "\"\"\"\nUse the Runge-Kutta-Gill's method of order 4 to solve Ordinary Differential Equations.\n\nhttps://www.geeksforgeeks.org/gills-4th-order-method-to-solve-differential-equations/\nAuthor : Ravi Kumar\n\"\"\"\n\nfrom collections.abc import Callable\nfrom math import sqrt\n\nimport numpy as np\n\n\ndef runge_kutta_gills(\n    func: Callable[[float, float], float],\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    >>> def f(x, y):\n    ...     return (x-y)/2\n    >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)\n    >>> y[-1]\n    3.4104259225717537\n\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)\n    >>> y\n    array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])\n\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(n + 1)\n    y[0] = y_initial\n    for i in range(n):\n        k1 = step_size * func(x_initial, y[i])\n        k2 = step_size * func(x_initial + step_size / 2, y[i] + k1 / 2)\n        k3 = step_size * func(\n            x_initial + step_size / 2,\n            y[i] + (-0.5 + 1 / sqrt(2)) * k1 + (1 - 1 / sqrt(2)) * k2,\n        )\n        k4 = step_size * func(\n            x_initial + step_size, y[i] - (1 / sqrt(2)) * k2 + (1 + 1 / sqrt(2)) * k3\n        )\n\n        y[i + 1] = y[i] + (k1 + (2 - sqrt(2)) * k2 + (2 + sqrt(2)) * k3 + k4) / 6\n        x_initial += step_size\n    return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/newton_forward_interpolation.py": "# https://www.geeksforgeeks.org/newton-forward-backward-interpolation/\nfrom __future__ import annotations\n\nimport math\n\n\n# for calculating u value\ndef ucal(u: float, p: int) -> float:\n    \"\"\"\n    >>> ucal(1, 2)\n    0\n    >>> ucal(1.1, 2)\n    0.11000000000000011\n    >>> ucal(1.2, 2)\n    0.23999999999999994\n    \"\"\"\n    temp = u\n    for i in range(1, p):\n        temp = temp * (u - i)\n    return temp\n\n\ndef main() -> None:\n    n = int(input(\"enter the numbers of values: \"))\n    y: list[list[float]] = []\n    for _ in range(n):\n        y.append([])\n    for i in range(n):\n        for j in range(n):\n            y[i].append(j)\n            y[i][j] = 0\n\n    print(\"enter the values of parameters in a list: \")\n    x = list(map(int, input().split()))\n\n    print(\"enter the values of corresponding parameters: \")\n    for i in range(n):\n        y[i][0] = float(input())\n\n    value = int(input(\"enter the value to interpolate: \"))\n    u = (value - x[0]) / (x[1] - x[0])\n\n    # for calculating forward difference table\n\n    for i in range(1, n):\n        for j in range(n - i):\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]\n\n    summ = y[0][0]\n    for i in range(1, n):\n        summ += (ucal(u, i) * y[0][i]) / math.factorial(i)\n\n    print(f\"the value at {value} is {summ}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "maths/numerical_analysis/numerical_integration.py": "\"\"\"\nApproximates the area under the curve using the trapezoidal rule\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)\n    '10.000'\n\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)\n    '192.0000'\n\n    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3\n\n    print(\"f(x) = x^3\")\n    print(\"The area between the curve, x = -10, x = 10 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        area = trapezoidal_area(f, -5, 5, i)\n        print(f\"with {i} steps: {area}\")\n        i *= 10\n", "maths/numerical_analysis/bisection.py": "from collections.abc import Callable\n\n\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid\n\n\ndef f(x: float) -> float:\n    return x**3 - 2 * x - 5\n\n\nif __name__ == \"__main__\":\n    print(bisection(f, 1, 1000))\n\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/runge_kutta_fehlberg_45.py": "\"\"\"\nUse the Runge-Kutta-Fehlberg method to solve Ordinary Differential Equations.\n\"\"\"\n\nfrom collections.abc import Callable\n\nimport numpy as np\n\n\ndef runge_kutta_fehlberg_45(\n    func: Callable,\n    x_initial: float,\n    y_initial: float,\n    step_size: float,\n    x_final: float,\n) -> np.ndarray:\n    \"\"\"\n    Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45)\n    of order 5.\n\n    https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method\n\n    args:\n    func: An ordinary differential equation (ODE) as function of x and y.\n    x_initial: The initial value of x.\n    y_initial: The initial value of y.\n    step_size: The increment value of x.\n    x_final: The final value of x.\n\n    Returns:\n        Solution of y at each nodal point\n\n    # exact value of y[1] is tan(0.2) = 0.2027100937470787\n    >>> def f(x, y):\n    ...     return 1 + y**2\n    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1)\n    >>> y[1]\n    0.2027100937470787\n    >>> def f(x,y):\n    ...     return x\n    >>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0)\n    >>> y[1]\n    -0.18000000000000002\n    >>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'int' object is not callable\n    >>> def f(x, y):\n    ...     return x + y\n    >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The final value of x must be greater than initial value of x.\n    >>> def f(x, y):\n    ...     return x\n    >>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Step size must be positive.\n    \"\"\"\n    if x_initial >= x_final:\n        raise ValueError(\n            \"The final value of x must be greater than initial value of x.\"\n        )\n\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive.\")\n\n    n = int((x_final - x_initial) / step_size)\n    y = np.zeros(\n        (n + 1),\n    )\n    x = np.zeros(n + 1)\n    y[0] = y_initial\n    x[0] = x_initial\n    for i in range(n):\n        k1 = step_size * func(x[i], y[i])\n        k2 = step_size * func(x[i] + step_size / 4, y[i] + k1 / 4)\n        k3 = step_size * func(\n            x[i] + (3 / 8) * step_size, y[i] + (3 / 32) * k1 + (9 / 32) * k2\n        )\n        k4 = step_size * func(\n            x[i] + (12 / 13) * step_size,\n            y[i] + (1932 / 2197) * k1 - (7200 / 2197) * k2 + (7296 / 2197) * k3,\n        )\n        k5 = step_size * func(\n            x[i] + step_size,\n            y[i] + (439 / 216) * k1 - 8 * k2 + (3680 / 513) * k3 - (845 / 4104) * k4,\n        )\n        k6 = step_size * func(\n            x[i] + step_size / 2,\n            y[i]\n            - (8 / 27) * k1\n            + 2 * k2\n            - (3544 / 2565) * k3\n            + (1859 / 4104) * k4\n            - (11 / 40) * k5,\n        )\n        y[i + 1] = (\n            y[i]\n            + (16 / 135) * k1\n            + (6656 / 12825) * k3\n            + (28561 / 56430) * k4\n            - (9 / 50) * k5\n            + (2 / 55) * k6\n        )\n        x[i + 1] = step_size + x[i]\n    return y\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/proper_fractions.py": "from math import gcd\n\n\ndef proper_fractions(denominator: int) -> list[str]:\n    \"\"\"\n    this algorithm returns a list of proper fractions, in the\n    range between 0 and 1, which can be formed with the given denominator\n    https://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions\n\n    >>> proper_fractions(10)\n    ['1/10', '3/10', '7/10', '9/10']\n    >>> proper_fractions(5)\n    ['1/5', '2/5', '3/5', '4/5']\n    >>> proper_fractions(-15)\n    Traceback (most recent call last):\n        ...\n    ValueError: The Denominator Cannot be less than 0\n    >>> proper_fractions(0)\n    []\n    >>> proper_fractions(1.2)\n    Traceback (most recent call last):\n        ...\n    ValueError: The Denominator must be an integer\n    \"\"\"\n\n    if denominator < 0:\n        raise ValueError(\"The Denominator Cannot be less than 0\")\n    elif isinstance(denominator, float):\n        raise ValueError(\"The Denominator must be an integer\")\n    return [\n        f\"{numerator}/{denominator}\"\n        for numerator in range(1, denominator)\n        if gcd(numerator, denominator) == 1\n    ]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "maths/numerical_analysis/nevilles_method.py": "\"\"\"\nPython program to show how to interpolate and evaluate a polynomial\nusing Neville's method.\nNeville's method evaluates a polynomial that passes through a\ngiven set of x and y points for a particular x value (x0) using the\nNewton polynomial form.\nReference:\n    https://rpubs.com/aaronsc32/nevilles-method-polynomial-interpolation\n\"\"\"\n\n\ndef neville_interpolate(x_points: list, y_points: list, x0: int) -> list:\n    \"\"\"\n       Interpolate and evaluate a polynomial using Neville's method.\n       Arguments:\n           x_points, y_points: Iterables of x and corresponding y points through\n            which the polynomial passes.\n           x0: The value of x to evaluate the polynomial for.\n       Return Value: A list of the approximated value and the Neville iterations\n           table respectively.\n    >>> import pprint\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]\n    10.0\n    >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])\n    [[0, 6, 0, 0, 0],\n     [0, 7, 0, 0, 0],\n     [0, 8, 104.0, 0, 0],\n     [0, 9, 104.0, 104.0, 0],\n     [0, 11, 104.0, 104.0, 104.0]]\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]\n    104.0\n    >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'str' and 'int'\n    \"\"\"\n    n = len(x_points)\n    q = [[0] * n for i in range(n)]\n    for i in range(n):\n        q[i][1] = y_points[i]\n\n    for i in range(2, n):\n        for j in range(i, n):\n            q[j][i] = (\n                (x0 - x_points[j - i + 1]) * q[j][i - 1]\n                - (x0 - x_points[j]) * q[j - 1][i - 1]\n            ) / (x_points[j] - x_points[j - i + 1])\n\n    return [q[n - 1][n - 1], q]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "maths/numerical_analysis/square_root.py": "import math\n\n\ndef fx(x: float, a: float) -> float:\n    return math.pow(x, 2) - a\n\n\ndef fx_derivative(x: float) -> float:\n    return 2 * x\n\n\ndef get_initial_point(a: float) -> float:\n    start = 2.0\n\n    while start <= a:\n        start = math.pow(start, 2)\n\n    return start\n\n\ndef square_root_iterative(\n    a: float, max_iter: int = 9999, tolerance: float = 1e-14\n) -> float:\n    \"\"\"\n    Square root approximated using Newton's method.\n    https://en.wikipedia.org/wiki/Newton%27s_method\n\n    >>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500))\n    True\n\n    >>> square_root_iterative(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n\n    >>> square_root_iterative(4)\n    2.0\n\n    >>> square_root_iterative(3.2)\n    1.788854381999832\n\n    >>> square_root_iterative(140)\n    11.832159566199232\n    \"\"\"\n\n    if a < 0:\n        raise ValueError(\"math domain error\")\n\n    value = get_initial_point(a)\n\n    for _ in range(max_iter):\n        prev_value = value\n        value = value - fx(value, a) / fx_derivative(value)\n        if abs(prev_value - value) < tolerance:\n            return value\n\n    return value\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "maths/numerical_analysis/__init__.py": "", "maths/numerical_analysis/intersection.py": "import math\nfrom collections.abc import Callable\n\n\ndef intersection(function: Callable[[float], float], x0: float, x1: float) -> float:\n    \"\"\"\n    function is the f we want to find its root\n    x0 and x1 are two random starting points\n    >>> intersection(lambda x: x ** 3 - 1, -5, 5)\n    0.9999999999954654\n    >>> intersection(lambda x: x ** 3 - 1, 5, 5)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: float division by zero, could not find root\n    >>> intersection(lambda x: x ** 3 - 1, 100, 200)\n    1.0000000000003888\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    0.9999999998088019\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    2.9999999998088023\n    >>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    3.0000000001786042\n    >>> intersection(math.sin, -math.pi, math.pi)\n    0.0\n    >>> intersection(math.cos, -math.pi, math.pi)\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: float division by zero, could not find root\n    \"\"\"\n    x_n: float = x0\n    x_n1: float = x1\n    while True:\n        if x_n == x_n1 or function(x_n1) == function(x_n):\n            raise ZeroDivisionError(\"float division by zero, could not find root\")\n        x_n2: float = x_n1 - (\n            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))\n        )\n        if abs(x_n2 - x_n1) < 10**-5:\n            return x_n2\n        x_n = x_n1\n        x_n1 = x_n2\n\n\ndef f(x: float) -> float:\n    return math.pow(x, 3) - (2 * x) - 5\n\n\nif __name__ == \"__main__\":\n    print(intersection(f, 3, 3.5))\n", "maths/numerical_analysis/newton_raphson.py": "\"\"\"\nThe Newton-Raphson method (aka the Newton method) is a root-finding algorithm that\napproximates a root of a given real-valued function f(x). It is an iterative method\ngiven by the formula\n\nx_{n + 1} = x_n + f(x_n) / f'(x_n)\n\nwith the precision of the approximation increasing as the number of iterations increase.\n\nReference: https://en.wikipedia.org/wiki/Newton%27s_method\n\"\"\"\n\nfrom collections.abc import Callable\n\nRealFunc = Callable[[float], float]\n\n\ndef calc_derivative(f: RealFunc, x: float, delta_x: float = 1e-3) -> float:\n    \"\"\"\n    Approximate the derivative of a function f(x) at a point x using the finite\n    difference method\n\n    >>> import math\n    >>> tolerance = 1e-5\n    >>> derivative = calc_derivative(lambda x: x**2, 2)\n    >>> math.isclose(derivative, 4, abs_tol=tolerance)\n    True\n    >>> derivative = calc_derivative(math.sin, 0)\n    >>> math.isclose(derivative, 1, abs_tol=tolerance)\n    True\n    \"\"\"\n    return (f(x + delta_x / 2) - f(x - delta_x / 2)) / delta_x\n\n\ndef newton_raphson(\n    f: RealFunc,\n    x0: float = 0,\n    max_iter: int = 100,\n    step: float = 1e-6,\n    max_error: float = 1e-6,\n    log_steps: bool = False,\n) -> tuple[float, float, list[float]]:\n    \"\"\"\n    Find a root of the given function f using the Newton-Raphson method.\n\n    :param f: A real-valued single-variable function\n    :param x0: Initial guess\n    :param max_iter: Maximum number of iterations\n    :param step: Step size of x, used to approximate f'(x)\n    :param max_error: Maximum approximation error\n    :param log_steps: bool denoting whether to log intermediate steps\n\n    :return: A tuple containing the approximation, the error, and the intermediate\n        steps. If log_steps is False, then an empty list is returned for the third\n        element of the tuple.\n\n    :raises ZeroDivisionError: The derivative approaches 0.\n    :raises ArithmeticError: No solution exists, or the solution isn't found before the\n        iteration limit is reached.\n\n    >>> import math\n    >>> tolerance = 1e-15\n    >>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)\n    >>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)\n    >>> math.isclose(root, math.e, abs_tol=tolerance)\n    True\n    >>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)\n    >>> math.isclose(root, 0, abs_tol=tolerance)\n    True\n    >>> newton_raphson(math.cos, 0)\n    Traceback (most recent call last):\n    ...\n    ZeroDivisionError: No converging solution found, zero derivative\n    >>> newton_raphson(lambda x: x**2 + 1, 2)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No converging solution found, iteration limit reached\n    \"\"\"\n\n    def f_derivative(x: float) -> float:\n        return calc_derivative(f, x, step)\n\n    a = x0  # Set initial guess\n    steps = []\n    for _ in range(max_iter):\n        if log_steps:  # Log intermediate steps\n            steps.append(a)\n\n        error = abs(f(a))\n        if error < max_error:\n            return a, error, steps\n\n        if f_derivative(a) == 0:\n            raise ZeroDivisionError(\"No converging solution found, zero derivative\")\n        a -= f(a) / f_derivative(a)  # Calculate next estimate\n    raise ArithmeticError(\"No converging solution found, iteration limit reached\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n    from math import exp, tanh\n\n    doctest.testmod()\n\n    def func(x: float) -> float:\n        return tanh(x) ** 2 - exp(3 * x)\n\n    solution, err, steps = newton_raphson(\n        func, x0=10, max_iter=100, step=1e-6, log_steps=True\n    )\n    print(f\"{solution=}, {err=}\")\n    print(\"\\n\".join(str(x) for x in steps))\n", "maths/images/__init__.py": "", "file_transfer/send_file.py": "def send_file(filename: str = \"mytext.txt\", testing: bool = False) -> None:\n    import socket\n\n    port = 12312  # Reserve a port for your service.\n    sock = socket.socket()  # Create a socket object\n    host = socket.gethostname()  # Get local machine name\n    sock.bind((host, port))  # Bind to the port\n    sock.listen(5)  # Now wait for client connection.\n\n    print(\"Server listening....\")\n\n    while True:\n        conn, addr = sock.accept()  # Establish connection with client.\n        print(f\"Got connection from {addr}\")\n        data = conn.recv(1024)\n        print(f\"Server received: {data = }\")\n\n        with open(filename, \"rb\") as in_file:\n            data = in_file.read(1024)\n            while data:\n                conn.send(data)\n                print(f\"Sent {data!r}\")\n                data = in_file.read(1024)\n\n        print(\"Done sending\")\n        conn.close()\n        if testing:  # Allow the test to complete\n            break\n\n    sock.shutdown(1)\n    sock.close()\n\n\nif __name__ == \"__main__\":\n    send_file()\n", "file_transfer/receive_file.py": "import socket\n\n\ndef main():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    host = socket.gethostname()\n    port = 12312\n\n    sock.connect((host, port))\n    sock.send(b\"Hello server!\")\n\n    with open(\"Received_file\", \"wb\") as out_file:\n        print(\"File opened\")\n        print(\"Receiving data...\")\n        while True:\n            data = sock.recv(1024)\n            if not data:\n                break\n            out_file.write(data)\n\n    print(\"Successfully received the file\")\n    sock.close()\n    print(\"Connection closed\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "file_transfer/__init__.py": "", "scripts/validate_solutions.py": "#!/usr/bin/env python3\nimport hashlib\nimport importlib.util\nimport json\nimport os\nimport pathlib\nfrom types import ModuleType\n\nimport pytest\nimport requests\n\nPROJECT_EULER_DIR_PATH = pathlib.Path.cwd().joinpath(\"project_euler\")\nPROJECT_EULER_ANSWERS_PATH = pathlib.Path.cwd().joinpath(\n    \"scripts\", \"project_euler_answers.json\"\n)\n\nwith open(PROJECT_EULER_ANSWERS_PATH) as file_handle:\n    PROBLEM_ANSWERS: dict[str, str] = json.load(file_handle)\n\n\ndef convert_path_to_module(file_path: pathlib.Path) -> ModuleType:\n    \"\"\"Converts a file path to a Python module\"\"\"\n    spec = importlib.util.spec_from_file_location(file_path.name, str(file_path))\n    module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]\n    spec.loader.exec_module(module)  # type: ignore[union-attr]\n    return module\n\n\ndef all_solution_file_paths() -> list[pathlib.Path]:\n    \"\"\"Collects all the solution file path in the Project Euler directory\"\"\"\n    solution_file_paths = []\n    for problem_dir_path in PROJECT_EULER_DIR_PATH.iterdir():\n        if problem_dir_path.is_file() or problem_dir_path.name.startswith(\"_\"):\n            continue\n        for file_path in problem_dir_path.iterdir():\n            if file_path.suffix != \".py\" or file_path.name.startswith((\"_\", \"test\")):\n                continue\n            solution_file_paths.append(file_path)\n    return solution_file_paths\n\n\ndef get_files_url() -> str:\n    \"\"\"Return the pull request number which triggered this action.\"\"\"\n    with open(os.environ[\"GITHUB_EVENT_PATH\"]) as file:\n        event = json.load(file)\n    return event[\"pull_request\"][\"url\"] + \"/files\"\n\n\ndef added_solution_file_path() -> list[pathlib.Path]:\n    \"\"\"Collects only the solution file path which got added in the current\n    pull request.\n\n    This will only be triggered if the script is ran from GitHub Actions.\n    \"\"\"\n    solution_file_paths = []\n    headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": \"token \" + os.environ[\"GITHUB_TOKEN\"],\n    }\n    files = requests.get(get_files_url(), headers=headers, timeout=10).json()\n    for file in files:\n        filepath = pathlib.Path.cwd().joinpath(file[\"filename\"])\n        if (\n            filepath.suffix != \".py\"\n            or filepath.name.startswith((\"_\", \"test\"))\n            or not filepath.name.startswith(\"sol\")\n        ):\n            continue\n        solution_file_paths.append(filepath)\n    return solution_file_paths\n\n\ndef collect_solution_file_paths() -> list[pathlib.Path]:\n    # Return only if there are any, otherwise default to all solutions\n    if (\n        os.environ.get(\"CI\")\n        and os.environ.get(\"GITHUB_EVENT_NAME\") == \"pull_request\"\n        and (filepaths := added_solution_file_path())\n    ):\n        return filepaths\n    return all_solution_file_paths()\n\n\n@pytest.mark.parametrize(\n    \"solution_path\",\n    collect_solution_file_paths(),\n    ids=lambda path: f\"{path.parent.name}/{path.name}\",\n)\ndef test_project_euler(solution_path: pathlib.Path) -> None:\n    \"\"\"Testing for all Project Euler solutions\"\"\"\n    # problem_[extract this part] and pad it with zeroes for width 3\n    problem_number: str = solution_path.parent.name[8:].zfill(3)\n    expected: str = PROBLEM_ANSWERS[problem_number]\n    solution_module = convert_path_to_module(solution_path)\n    answer = str(solution_module.solution())\n    answer = hashlib.sha256(answer.encode()).hexdigest()\n    assert (\n        answer == expected\n    ), f\"Expected solution to {problem_number} to have hash {expected}, got {answer}\"\n", "scripts/build_directory_md.py": "#!/usr/bin/env python3\n\nimport os\nfrom collections.abc import Iterator\n\n\ndef good_file_paths(top_dir: str = \".\") -> Iterator[str]:\n    for dir_path, dir_names, filenames in os.walk(top_dir):\n        dir_names[:] = [\n            d\n            for d in dir_names\n            if d != \"scripts\" and d[0] not in \"._\" and \"venv\" not in d\n        ]\n        for filename in filenames:\n            if filename == \"__init__.py\":\n                continue\n            if os.path.splitext(filename)[1] in (\".py\", \".ipynb\"):\n                yield os.path.join(dir_path, filename).lstrip(\"./\")\n\n\ndef md_prefix(i):\n    return f\"{i * '  '}*\" if i else \"\\n##\"\n\n\ndef print_path(old_path: str, new_path: str) -> str:\n    old_parts = old_path.split(os.sep)\n    for i, new_part in enumerate(new_path.split(os.sep)):\n        if (i + 1 > len(old_parts) or old_parts[i] != new_part) and new_part:\n            print(f\"{md_prefix(i)} {new_part.replace('_', ' ').title()}\")\n    return new_path\n\n\ndef print_directory_md(top_dir: str = \".\") -> None:\n    old_path = \"\"\n    for filepath in sorted(good_file_paths(top_dir)):\n        filepath, filename = os.path.split(filepath)\n        if filepath != old_path:\n            old_path = print_path(old_path, filepath)\n        indent = (filepath.count(os.sep) + 1) if filepath else 0\n        url = f\"{filepath}/{filename}\".replace(\" \", \"%20\")\n        filename = os.path.splitext(filename.replace(\"_\", \" \").title())[0]\n        print(f\"{md_prefix(indent)} [{filename}]({url})\")\n\n\nif __name__ == \"__main__\":\n    print_directory_md(\".\")\n", "scripts/validate_filenames.py": "#!/usr/bin/env python3\nimport os\n\ntry:\n    from .build_directory_md import good_file_paths\nexcept ImportError:\n    from build_directory_md import good_file_paths  # type: ignore[no-redef]\n\nfilepaths = list(good_file_paths())\nassert filepaths, \"good_file_paths() failed!\"\n\nupper_files = [file for file in filepaths if file != file.lower()]\nif upper_files:\n    print(f\"{len(upper_files)} files contain uppercase characters:\")\n    print(\"\\n\".join(upper_files) + \"\\n\")\n\nspace_files = [file for file in filepaths if \" \" in file]\nif space_files:\n    print(f\"{len(space_files)} files contain space characters:\")\n    print(\"\\n\".join(space_files) + \"\\n\")\n\nhyphen_files = [file for file in filepaths if \"-\" in file]\nif hyphen_files:\n    print(f\"{len(hyphen_files)} files contain hyphen characters:\")\n    print(\"\\n\".join(hyphen_files) + \"\\n\")\n\nnodir_files = [file for file in filepaths if os.sep not in file]\nif nodir_files:\n    print(f\"{len(nodir_files)} files are not in a directory:\")\n    print(\"\\n\".join(nodir_files) + \"\\n\")\n\nbad_files = len(upper_files + space_files + hyphen_files + nodir_files)\nif bad_files:\n    import sys\n\n    sys.exit(bad_files)\n", "scripts/__init__.py": "", "fuzzy_logic/fuzzy_operations.py": "\"\"\"\nBy @Shreya123714\n\nhttps://en.wikipedia.org/wiki/Fuzzy_set\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n@dataclass\nclass FuzzySet:\n    \"\"\"\n    A class for representing and manipulating triangular fuzzy sets.\n    Attributes:\n        name: The name or label of the fuzzy set.\n        left_boundary: The left boundary of the fuzzy set.\n        peak: The peak (central) value of the fuzzy set.\n        right_boundary: The right boundary of the fuzzy set.\n    Methods:\n        membership(x): Calculate the membership value of an input 'x' in the fuzzy set.\n        union(other): Calculate the union of this fuzzy set with another fuzzy set.\n        intersection(other): Calculate the intersection of this fuzzy set with another.\n        complement(): Calculate the complement (negation) of this fuzzy set.\n        plot(): Plot the membership function of the fuzzy set.\n\n    >>> sheru = FuzzySet(\"Sheru\", 0.4, 1, 0.6)\n    >>> sheru\n    FuzzySet(name='Sheru', left_boundary=0.4, peak=1, right_boundary=0.6)\n    >>> str(sheru)\n    'Sheru: [0.4, 1, 0.6]'\n\n    >>> siya = FuzzySet(\"Siya\", 0.5, 1, 0.7)\n    >>> siya\n    FuzzySet(name='Siya', left_boundary=0.5, peak=1, right_boundary=0.7)\n\n    # Complement Operation\n    >>> sheru.complement()\n    FuzzySet(name='\u00acSheru', left_boundary=0.4, peak=0.6, right_boundary=0)\n    >>> siya.complement()  # doctest: +NORMALIZE_WHITESPACE\n    FuzzySet(name='\u00acSiya', left_boundary=0.30000000000000004, peak=0.5,\n     right_boundary=0)\n\n    # Intersection Operation\n    >>> siya.intersection(sheru)\n    FuzzySet(name='Siya \u2229 Sheru', left_boundary=0.5, peak=0.6, right_boundary=1.0)\n\n    # Membership Operation\n    >>> sheru.membership(0.5)\n    0.16666666666666663\n    >>> sheru.membership(0.6)\n    0.0\n\n    # Union Operations\n    >>> siya.union(sheru)\n    FuzzySet(name='Siya U Sheru', left_boundary=0.4, peak=0.7, right_boundary=1.0)\n    \"\"\"\n\n    name: str\n    left_boundary: float\n    peak: float\n    right_boundary: float\n\n    def __str__(self) -> str:\n        \"\"\"\n        >>> FuzzySet(\"fuzzy_set\", 0.1, 0.2, 0.3)\n        FuzzySet(name='fuzzy_set', left_boundary=0.1, peak=0.2, right_boundary=0.3)\n        \"\"\"\n        return (\n            f\"{self.name}: [{self.left_boundary}, {self.peak}, {self.right_boundary}]\"\n        )\n\n    def complement(self) -> FuzzySet:\n        \"\"\"\n        Calculate the complement (negation) of this fuzzy set.\n        Returns:\n            FuzzySet: A new fuzzy set representing the complement.\n\n        >>> FuzzySet(\"fuzzy_set\", 0.1, 0.2, 0.3).complement()\n        FuzzySet(name='\u00acfuzzy_set', left_boundary=0.7, peak=0.9, right_boundary=0.8)\n        \"\"\"\n        return FuzzySet(\n            f\"\u00ac{self.name}\",\n            1 - self.right_boundary,\n            1 - self.left_boundary,\n            1 - self.peak,\n        )\n\n    def intersection(self, other) -> FuzzySet:\n        \"\"\"\n        Calculate the intersection of this fuzzy set\n        with another fuzzy set.\n        Args:\n            other: Another fuzzy set to intersect with.\n        Returns:\n            A new fuzzy set representing the intersection.\n\n        >>> FuzzySet(\"a\", 0.1, 0.2, 0.3).intersection(FuzzySet(\"b\", 0.4, 0.5, 0.6))\n        FuzzySet(name='a \u2229 b', left_boundary=0.4, peak=0.3, right_boundary=0.35)\n        \"\"\"\n        return FuzzySet(\n            f\"{self.name} \u2229 {other.name}\",\n            max(self.left_boundary, other.left_boundary),\n            min(self.right_boundary, other.right_boundary),\n            (self.peak + other.peak) / 2,\n        )\n\n    def membership(self, x: float) -> float:\n        \"\"\"\n        Calculate the membership value of an input 'x' in the fuzzy set.\n        Returns:\n            The membership value of 'x' in the fuzzy set.\n\n        >>> a = FuzzySet(\"a\", 0.1, 0.2, 0.3)\n        >>> a.membership(0.09)\n        0.0\n        >>> a.membership(0.1)\n        0.0\n        >>> a.membership(0.11)\n        0.09999999999999995\n        >>> a.membership(0.4)\n        0.0\n        >>> FuzzySet(\"A\", 0, 0.5, 1).membership(0.1)\n        0.2\n        >>> FuzzySet(\"B\", 0.2, 0.7, 1).membership(0.6)\n        0.8\n        \"\"\"\n        if x <= self.left_boundary or x >= self.right_boundary:\n            return 0.0\n        elif self.left_boundary < x <= self.peak:\n            return (x - self.left_boundary) / (self.peak - self.left_boundary)\n        elif self.peak < x < self.right_boundary:\n            return (self.right_boundary - x) / (self.right_boundary - self.peak)\n        msg = f\"Invalid value {x} for fuzzy set {self}\"\n        raise ValueError(msg)\n\n    def union(self, other) -> FuzzySet:\n        \"\"\"\n        Calculate the union of this fuzzy set with another fuzzy set.\n        Args:\n            other (FuzzySet): Another fuzzy set to union with.\n        Returns:\n            FuzzySet: A new fuzzy set representing the union.\n\n        >>> FuzzySet(\"a\", 0.1, 0.2, 0.3).union(FuzzySet(\"b\", 0.4, 0.5, 0.6))\n        FuzzySet(name='a U b', left_boundary=0.1, peak=0.6, right_boundary=0.35)\n        \"\"\"\n        return FuzzySet(\n            f\"{self.name} U {other.name}\",\n            min(self.left_boundary, other.left_boundary),\n            max(self.right_boundary, other.right_boundary),\n            (self.peak + other.peak) / 2,\n        )\n\n    def plot(self):\n        \"\"\"\n        Plot the membership function of the fuzzy set.\n        \"\"\"\n        x = np.linspace(0, 1, 1000)\n        y = [self.membership(xi) for xi in x]\n\n        plt.plot(x, y, label=self.name)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    a = FuzzySet(\"A\", 0, 0.5, 1)\n    b = FuzzySet(\"B\", 0.2, 0.7, 1)\n\n    a.plot()\n    b.plot()\n\n    plt.xlabel(\"x\")\n    plt.ylabel(\"Membership\")\n    plt.legend()\n    plt.show()\n\n    union_ab = a.union(b)\n    intersection_ab = a.intersection(b)\n    complement_a = a.complement()\n\n    union_ab.plot()\n    intersection_ab.plot()\n    complement_a.plot()\n\n    plt.xlabel(\"x\")\n    plt.ylabel(\"Membership\")\n    plt.legend()\n    plt.show()\n", "fuzzy_logic/__init__.py": "", "ciphers/trifid_cipher.py": "\"\"\"\nThe trifid cipher uses a table to fractionate each plaintext letter into a trigram,\nmixes the constituents of the trigrams, and then applies the table in reverse to turn\nthese mixed trigrams into ciphertext letters.\n\nhttps://en.wikipedia.org/wiki/Trifid_cipher\n\"\"\"\n\nfrom __future__ import annotations\n\n# fmt: off\nTEST_CHARACTER_TO_NUMBER = {\n    \"A\": \"111\", \"B\": \"112\", \"C\": \"113\", \"D\": \"121\", \"E\": \"122\", \"F\": \"123\", \"G\": \"131\",\n    \"H\": \"132\", \"I\": \"133\", \"J\": \"211\", \"K\": \"212\", \"L\": \"213\", \"M\": \"221\", \"N\": \"222\",\n    \"O\": \"223\", \"P\": \"231\", \"Q\": \"232\", \"R\": \"233\", \"S\": \"311\", \"T\": \"312\", \"U\": \"313\",\n    \"V\": \"321\", \"W\": \"322\", \"X\": \"323\", \"Y\": \"331\", \"Z\": \"332\", \"+\": \"333\",\n}\n# fmt: off\n\nTEST_NUMBER_TO_CHARACTER = {val: key for key, val in TEST_CHARACTER_TO_NUMBER.items()}\n\n\ndef __encrypt_part(message_part: str, character_to_number: dict[str, str]) -> str:\n    \"\"\"\n    Arrange the triagram value of each letter of 'message_part' vertically and join\n    them horizontally.\n\n    >>> __encrypt_part('ASK', TEST_CHARACTER_TO_NUMBER)\n    '132111112'\n    \"\"\"\n    one, two, three = \"\", \"\", \"\"\n    for each in (character_to_number[character] for character in message_part):\n        one += each[0]\n        two += each[1]\n        three += each[2]\n\n    return one + two + three\n\n\ndef __decrypt_part(\n    message_part: str, character_to_number: dict[str, str]\n) -> tuple[str, str, str]:\n    \"\"\"\n    Convert each letter of the input string into their respective trigram values, join\n    them and split them into three equal groups of strings which are returned.\n\n    >>> __decrypt_part('ABCDE', TEST_CHARACTER_TO_NUMBER)\n    ('11111', '21131', '21122')\n    \"\"\"\n    this_part = \"\".join(character_to_number[character] for character in message_part)\n    result = []\n    tmp = \"\"\n    for digit in this_part:\n        tmp += digit\n        if len(tmp) == len(message_part):\n            result.append(tmp)\n            tmp = \"\"\n\n    return result[0], result[1], result[2]\n\n\ndef __prepare(\n    message: str, alphabet: str\n) -> tuple[str, str, dict[str, str], dict[str, str]]:\n    \"\"\"\n    A helper function that generates the triagrams and assigns each letter of the\n    alphabet to its corresponding triagram and stores this in a dictionary\n    (\"character_to_number\" and \"number_to_character\") after confirming if the\n    alphabet's length is 27.\n\n    >>> test = __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxYZ+')\n    >>> expected = ('IAMABOY','ABCDEFGHIJKLMNOPQRSTUVWXYZ+',\n    ... TEST_CHARACTER_TO_NUMBER, TEST_NUMBER_TO_CHARACTER)\n    >>> test == expected\n    True\n\n    Testing with incomplete alphabet\n    >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVw')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'Length of alphabet has to be 27.'\n\n    Testing with extra long alphabets\n    >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxyzzwwtyyujjgfd')\n    Traceback (most recent call last):\n        ...\n    KeyError: 'Length of alphabet has to be 27.'\n\n    Testing with punctuations that are not in the given alphabet\n    >>> __prepare('am i a boy?','abCdeFghijkLmnopqrStuVwxYZ+')\n    Traceback (most recent call last):\n        ...\n    ValueError: Each message character has to be included in alphabet!\n\n    Testing with numbers\n    >>> __prepare(500,'abCdeFghijkLmnopqrStuVwxYZ+')\n    Traceback (most recent call last):\n        ...\n    AttributeError: 'int' object has no attribute 'replace'\n    \"\"\"\n    # Validate message and alphabet, set to upper and remove spaces\n    alphabet = alphabet.replace(\" \", \"\").upper()\n    message = message.replace(\" \", \"\").upper()\n\n    # Check length and characters\n    if len(alphabet) != 27:\n        raise KeyError(\"Length of alphabet has to be 27.\")\n    if any(char not in alphabet for char in message):\n        raise ValueError(\"Each message character has to be included in alphabet!\")\n\n    # Generate dictionares\n    character_to_number = dict(zip(alphabet, TEST_CHARACTER_TO_NUMBER.values()))\n    number_to_character = {\n        number: letter for letter, number in character_to_number.items()\n    }\n\n    return message, alphabet, character_to_number, number_to_character\n\n\ndef encrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    \"\"\"\n    encrypt_message\n    ===============\n\n    Encrypts a message using the trifid_cipher. Any punctuatuions that\n    would be used should be added to the alphabet.\n\n    PARAMETERS\n    ----------\n\n    *   message: The message you want to encrypt.\n    *   alphabet (optional): The characters to be used for the cipher .\n    *   period (optional): The number of characters you want in a group whilst\n        encrypting.\n\n    >>> encrypt_message('I am a boy')\n    'BCDGBQY'\n\n    >>> encrypt_message(' ')\n    ''\n\n    >>> encrypt_message('   aide toi le c  iel      ta id  era    ',\n    ... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n    'FMJFVOISSUFTFPUFEQQC'\n\n    \"\"\"\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    encrypted_numeric = \"\"\n    for i in range(0, len(message) + 1, period):\n        encrypted_numeric += __encrypt_part(\n            message[i : i + period], character_to_number\n        )\n\n    encrypted = \"\"\n    for i in range(0, len(encrypted_numeric), 3):\n        encrypted += number_to_character[encrypted_numeric[i : i + 3]]\n    return encrypted\n\n\ndef decrypt_message(\n    message: str, alphabet: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.\", period: int = 5\n) -> str:\n    \"\"\"\n    decrypt_message\n    ===============\n\n    Decrypts a trifid_cipher encrypted message .\n\n    PARAMETERS\n    ----------\n\n    *   message: The message you want to decrypt .\n    *   alphabet (optional): The characters used for the cipher.\n    *   period (optional): The number of characters used in grouping when it\n        was encrypted.\n\n    >>> decrypt_message('BCDGBQY')\n    'IAMABOY'\n\n    Decrypting with your own alphabet and period\n    >>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5)\n    'AIDETOILECIELTAIDERA'\n    \"\"\"\n    message, alphabet, character_to_number, number_to_character = __prepare(\n        message, alphabet\n    )\n\n    decrypted_numeric = []\n    for i in range(0, len(message), period):\n        a, b, c = __decrypt_part(message[i : i + period], character_to_number)\n\n        for j in range(len(a)):\n            decrypted_numeric.append(a[j] + b[j] + c[j])\n\n    return \"\".join(number_to_character[each] for each in decrypted_numeric)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    msg = \"DEFEND THE EAST WALL OF THE CASTLE.\"\n    encrypted = encrypt_message(msg, \"EPSDUCVWYM.ZLKXNBTFGORIJHAQ\")\n    decrypted = decrypt_message(encrypted, \"EPSDUCVWYM.ZLKXNBTFGORIJHAQ\")\n    print(f\"Encrypted: {encrypted}\\nDecrypted: {decrypted}\")\n", "ciphers/beaufort_cipher.py": "\"\"\"\nAuthor: Mohit Radadiya\n\"\"\"\n\nfrom string import ascii_uppercase\n\ndict1 = {char: i for i, char in enumerate(ascii_uppercase)}\ndict2 = dict(enumerate(ascii_uppercase))\n\n\n# This function generates the key in\n# a cyclic manner until it's length isn't\n# equal to the length of original text\ndef generate_key(message: str, key: str) -> str:\n    \"\"\"\n    >>> generate_key(\"THE GERMAN ATTACK\",\"SECRET\")\n    'SECRETSECRETSECRE'\n    \"\"\"\n    x = len(message)\n    i = 0\n    while True:\n        if x == i:\n            i = 0\n        if len(key) == len(message):\n            break\n        key += key[i]\n        i += 1\n    return key\n\n\n# This function returns the encrypted text\n# generated with the help of the key\ndef cipher_text(message: str, key_new: str) -> str:\n    \"\"\"\n    >>> cipher_text(\"THE GERMAN ATTACK\",\"SECRETSECRETSECRE\")\n    'BDC PAYUWL JPAIYI'\n    \"\"\"\n    cipher_text = \"\"\n    i = 0\n    for letter in message:\n        if letter == \" \":\n            cipher_text += \" \"\n        else:\n            x = (dict1[letter] - dict1[key_new[i]]) % 26\n            i += 1\n            cipher_text += dict2[x]\n    return cipher_text\n\n\n# This function decrypts the encrypted text\n# and returns the original text\ndef original_text(cipher_text: str, key_new: str) -> str:\n    \"\"\"\n    >>> original_text(\"BDC PAYUWL JPAIYI\",\"SECRETSECRETSECRE\")\n    'THE GERMAN ATTACK'\n    \"\"\"\n    or_txt = \"\"\n    i = 0\n    for letter in cipher_text:\n        if letter == \" \":\n            or_txt += \" \"\n        else:\n            x = (dict1[letter] + dict1[key_new[i]] + 26) % 26\n            i += 1\n            or_txt += dict2[x]\n    return or_txt\n\n\ndef main() -> None:\n    message = \"THE GERMAN ATTACK\"\n    key = \"SECRET\"\n    key_new = generate_key(message, key)\n    s = cipher_text(message, key_new)\n    print(f\"Encrypted Text = {s}\")\n    print(f\"Original Text = {original_text(s, key_new)}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/simple_keyword_cypher.py": "def remove_duplicates(key: str) -> str:\n    \"\"\"\n    Removes duplicate alphabetic characters in a keyword (letter is ignored after its\n        first appearance).\n    :param key: Keyword to use\n    :return: String with duplicates removed\n    >>> remove_duplicates('Hello World!!')\n    'Helo Wrd'\n    \"\"\"\n\n    key_no_dups = \"\"\n    for ch in key:\n        if ch == \" \" or ch not in key_no_dups and ch.isalpha():\n            key_no_dups += ch\n    return key_no_dups\n\n\ndef create_cipher_map(key: str) -> dict[str, str]:\n    \"\"\"\n    Returns a cipher map given a keyword.\n    :param key: keyword to use\n    :return: dictionary cipher map\n    \"\"\"\n    # Create a list of the letters in the alphabet\n    alphabet = [chr(i + 65) for i in range(26)]\n    # Remove duplicate characters from key\n    key = remove_duplicates(key.upper())\n    offset = len(key)\n    # First fill cipher with key characters\n    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}\n    # Then map remaining characters in alphabet to\n    # the alphabet from the beginning\n    for i in range(len(cipher_alphabet), 26):\n        char = alphabet[i - offset]\n        # Ensure we are not mapping letters to letters previously mapped\n        while char in key:\n            offset -= 1\n            char = alphabet[i - offset]\n        cipher_alphabet[alphabet[i]] = char\n    return cipher_alphabet\n\n\ndef encipher(message: str, cipher_map: dict[str, str]) -> str:\n    \"\"\"\n    Enciphers a message given a cipher map.\n    :param message: Message to encipher\n    :param cipher_map: Cipher map\n    :return: enciphered string\n    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))\n    'CYJJM VMQJB!!'\n    \"\"\"\n    return \"\".join(cipher_map.get(ch, ch) for ch in message.upper())\n\n\ndef decipher(message: str, cipher_map: dict[str, str]) -> str:\n    \"\"\"\n    Deciphers a message given a cipher map\n    :param message: Message to decipher\n    :param cipher_map: Dictionary mapping to use\n    :return: Deciphered string\n    >>> cipher_map = create_cipher_map('Goodbye!!')\n    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)\n    'HELLO WORLD!!'\n    \"\"\"\n    # Reverse our cipher mappings\n    rev_cipher_map = {v: k for k, v in cipher_map.items()}\n    return \"\".join(rev_cipher_map.get(ch, ch) for ch in message.upper())\n\n\ndef main() -> None:\n    \"\"\"\n    Handles I/O\n    :return: void\n    \"\"\"\n    message = input(\"Enter message to encode or decode: \").strip()\n    key = input(\"Enter keyword: \").strip()\n    option = input(\"Encipher or decipher? E/D:\").strip()[0].lower()\n    try:\n        func = {\"e\": encipher, \"d\": decipher}[option]\n    except KeyError:\n        raise KeyError(\"invalid input option\")\n    cipher_map = create_cipher_map(key)\n    print(func(message, cipher_map))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/xor_cipher.py": "\"\"\"\nauthor: Christian Bender\ndate: 21.12.2017\nclass: XORCipher\n\nThis class implements the XOR-cipher algorithm and provides\nsome useful methods for encrypting and decrypting strings and\nfiles.\n\nOverview about methods\n\n- encrypt : list of char\n- decrypt : list of char\n- encrypt_string : str\n- decrypt_string : str\n- encrypt_file : boolean\n- decrypt_file : boolean\n\"\"\"\n\nfrom __future__ import annotations\n\n\nclass XORCipher:\n    def __init__(self, key: int = 0):\n        \"\"\"\n        simple constructor that receives a key or uses\n        default key = 0\n        \"\"\"\n\n        # private field\n        self.__key = key\n\n    def encrypt(self, content: str, key: int) -> list[str]:\n        \"\"\"\n        input: 'content' of type string and 'key' of type int\n        output: encrypted string 'content' as a list of chars\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n\n        Empty list\n        >>> XORCipher().encrypt(\"\", 5)\n        []\n\n        One key\n        >>> XORCipher().encrypt(\"hallo welt\", 1)\n        ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']\n\n        Normal key\n        >>> XORCipher().encrypt(\"HALLO WELT\", 32)\n        ['h', 'a', 'l', 'l', 'o', '\\\\x00', 'w', 'e', 'l', 't']\n\n        Key greater than 255\n        >>> XORCipher().encrypt(\"hallo welt\", 256)\n        ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']\n        \"\"\"\n\n        # precondition\n        assert isinstance(key, int)\n        assert isinstance(content, str)\n\n        key = key or self.__key or 1\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        return [chr(ord(ch) ^ key) for ch in content]\n\n    def decrypt(self, content: str, key: int) -> list[str]:\n        \"\"\"\n        input: 'content' of type list and 'key' of type int\n        output: decrypted string 'content' as a list of chars\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n\n        Empty list\n        >>> XORCipher().decrypt(\"\", 5)\n        []\n\n        One key\n        >>> XORCipher().decrypt(\"hallo welt\", 1)\n        ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']\n\n        Normal key\n        >>> XORCipher().decrypt(\"HALLO WELT\", 32)\n        ['h', 'a', 'l', 'l', 'o', '\\\\x00', 'w', 'e', 'l', 't']\n\n        Key greater than 255\n        >>> XORCipher().decrypt(\"hallo welt\", 256)\n        ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']\n        \"\"\"\n\n        # precondition\n        assert isinstance(key, int)\n        assert isinstance(content, str)\n\n        key = key or self.__key or 1\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        return [chr(ord(ch) ^ key) for ch in content]\n\n    def encrypt_string(self, content: str, key: int = 0) -> str:\n        \"\"\"\n        input: 'content' of type string and 'key' of type int\n        output: encrypted string 'content'\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n\n        Empty list\n        >>> XORCipher().encrypt_string(\"\", 5)\n        ''\n\n        One key\n        >>> XORCipher().encrypt_string(\"hallo welt\", 1)\n        'i`mmn!vdmu'\n\n        Normal key\n        >>> XORCipher().encrypt_string(\"HALLO WELT\", 32)\n        'hallo\\\\x00welt'\n\n        Key greater than 255\n        >>> XORCipher().encrypt_string(\"hallo welt\", 256)\n        'hallo welt'\n        \"\"\"\n\n        # precondition\n        assert isinstance(key, int)\n        assert isinstance(content, str)\n\n        key = key or self.__key or 1\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        # This will be returned\n        ans = \"\"\n\n        for ch in content:\n            ans += chr(ord(ch) ^ key)\n\n        return ans\n\n    def decrypt_string(self, content: str, key: int = 0) -> str:\n        \"\"\"\n        input: 'content' of type string and 'key' of type int\n        output: decrypted string 'content'\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n\n        Empty list\n        >>> XORCipher().decrypt_string(\"\", 5)\n        ''\n\n        One key\n        >>> XORCipher().decrypt_string(\"hallo welt\", 1)\n        'i`mmn!vdmu'\n\n        Normal key\n        >>> XORCipher().decrypt_string(\"HALLO WELT\", 32)\n        'hallo\\\\x00welt'\n\n        Key greater than 255\n        >>> XORCipher().decrypt_string(\"hallo welt\", 256)\n        'hallo welt'\n        \"\"\"\n\n        # precondition\n        assert isinstance(key, int)\n        assert isinstance(content, str)\n\n        key = key or self.__key or 1\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        # This will be returned\n        ans = \"\"\n\n        for ch in content:\n            ans += chr(ord(ch) ^ key)\n\n        return ans\n\n    def encrypt_file(self, file: str, key: int = 0) -> bool:\n        \"\"\"\n        input: filename (str) and a key (int)\n        output: returns true if encrypt process was\n        successful otherwise false\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n        \"\"\"\n\n        # precondition\n        assert isinstance(file, str)\n        assert isinstance(key, int)\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        try:\n            with open(file) as fin, open(\"encrypt.out\", \"w+\") as fout:\n                # actual encrypt-process\n                for line in fin:\n                    fout.write(self.encrypt_string(line, key))\n\n        except OSError:\n            return False\n\n        return True\n\n    def decrypt_file(self, file: str, key: int) -> bool:\n        \"\"\"\n        input: filename (str) and a key (int)\n        output: returns true if decrypt process was\n        successful otherwise false\n        if key not passed the method uses the key by the constructor.\n        otherwise key = 1\n        \"\"\"\n\n        # precondition\n        assert isinstance(file, str)\n        assert isinstance(key, int)\n\n        # make sure key is an appropriate size\n        key %= 256\n\n        try:\n            with open(file) as fin, open(\"decrypt.out\", \"w+\") as fout:\n                # actual encrypt-process\n                for line in fin:\n                    fout.write(self.decrypt_string(line, key))\n\n        except OSError:\n            return False\n\n        return True\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n# Tests\n# crypt = XORCipher()\n# key = 67\n\n# # test encrypt\n# print(crypt.encrypt(\"hallo welt\",key))\n# # test decrypt\n# print(crypt.decrypt(crypt.encrypt(\"hallo welt\",key), key))\n\n# # test encrypt_string\n# print(crypt.encrypt_string(\"hallo welt\",key))\n\n# # test decrypt_string\n# print(crypt.decrypt_string(crypt.encrypt_string(\"hallo welt\",key),key))\n\n# if (crypt.encrypt_file(\"test.txt\",key)):\n#       print(\"encrypt successful\")\n# else:\n#       print(\"encrypt unsuccessful\")\n\n# if (crypt.decrypt_file(\"encrypt.out\",key)):\n#       print(\"decrypt successful\")\n# else:\n#       print(\"decrypt unsuccessful\")\n", "ciphers/diffie.py": "from __future__ import annotations\n\n\ndef find_primitive(modulus: int) -> int | None:\n    \"\"\"\n    Find a primitive root modulo modulus, if one exists.\n\n    Args:\n        modulus : The modulus for which to find a primitive root.\n\n    Returns:\n        The primitive root if one exists, or None if there is none.\n\n    Examples:\n    >>> find_primitive(7)  # Modulo 7 has primitive root 3\n    3\n    >>> find_primitive(11)  # Modulo 11 has primitive root 2\n    2\n    >>> find_primitive(8) == None # Modulo 8 has no primitive root\n    True\n    \"\"\"\n    for r in range(1, modulus):\n        li = []\n        for x in range(modulus - 1):\n            val = pow(r, x, modulus)\n            if val in li:\n                break\n            li.append(val)\n        else:\n            return r\n    return None\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    prime = int(input(\"Enter a prime number q: \"))\n    primitive_root = find_primitive(prime)\n    if primitive_root is None:\n        print(f\"Cannot find the primitive for the value: {primitive_root!r}\")\n    else:\n        a_private = int(input(\"Enter private key of A: \"))\n        a_public = pow(primitive_root, a_private, prime)\n        b_private = int(input(\"Enter private key of B: \"))\n        b_public = pow(primitive_root, b_private, prime)\n\n        a_secret = pow(b_public, a_private, prime)\n        b_secret = pow(a_public, b_private, prime)\n\n        print(\"The key value generated by A is: \", a_secret)\n        print(\"The key value generated by B is: \", b_secret)\n", "ciphers/baconian_cipher.py": "\"\"\"\nProgram to encode and decode Baconian or Bacon's Cipher\nWikipedia reference : https://en.wikipedia.org/wiki/Bacon%27s_cipher\n\"\"\"\n\nencode_dict = {\n    \"a\": \"AAAAA\",\n    \"b\": \"AAAAB\",\n    \"c\": \"AAABA\",\n    \"d\": \"AAABB\",\n    \"e\": \"AABAA\",\n    \"f\": \"AABAB\",\n    \"g\": \"AABBA\",\n    \"h\": \"AABBB\",\n    \"i\": \"ABAAA\",\n    \"j\": \"BBBAA\",\n    \"k\": \"ABAAB\",\n    \"l\": \"ABABA\",\n    \"m\": \"ABABB\",\n    \"n\": \"ABBAA\",\n    \"o\": \"ABBAB\",\n    \"p\": \"ABBBA\",\n    \"q\": \"ABBBB\",\n    \"r\": \"BAAAA\",\n    \"s\": \"BAAAB\",\n    \"t\": \"BAABA\",\n    \"u\": \"BAABB\",\n    \"v\": \"BBBAB\",\n    \"w\": \"BABAA\",\n    \"x\": \"BABAB\",\n    \"y\": \"BABBA\",\n    \"z\": \"BABBB\",\n    \" \": \" \",\n}\n\n\ndecode_dict = {value: key for key, value in encode_dict.items()}\n\n\ndef encode(word: str) -> str:\n    \"\"\"\n    Encodes to Baconian cipher\n\n    >>> encode(\"hello\")\n    'AABBBAABAAABABAABABAABBAB'\n    >>> encode(\"hello world\")\n    'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'\n    >>> encode(\"hello world!\")\n    Traceback (most recent call last):\n        ...\n    Exception: encode() accepts only letters of the alphabet and spaces\n    \"\"\"\n    encoded = \"\"\n    for letter in word.lower():\n        if letter.isalpha() or letter == \" \":\n            encoded += encode_dict[letter]\n        else:\n            raise Exception(\"encode() accepts only letters of the alphabet and spaces\")\n    return encoded\n\n\ndef decode(coded: str) -> str:\n    \"\"\"\n    Decodes from Baconian cipher\n\n    >>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB\")\n    'hello world'\n    >>> decode(\"AABBBAABAAABABAABABAABBAB\")\n    'hello'\n    >>> decode(\"AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!\")\n    Traceback (most recent call last):\n        ...\n    Exception: decode() accepts only 'A', 'B' and spaces\n    \"\"\"\n    if set(coded) - {\"A\", \"B\", \" \"} != set():\n        raise Exception(\"decode() accepts only 'A', 'B' and spaces\")\n    decoded = \"\"\n    for word in coded.split():\n        while len(word) != 0:\n            decoded += decode_dict[word[:5]]\n            word = word[5:]\n        decoded += \" \"\n    return decoded.strip()\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "ciphers/vernam_cipher.py": "def vernam_encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_encrypt(\"HELLO\",\"KEY\")\n    'RIJVS'\n    \"\"\"\n    ciphertext = \"\"\n    for i in range(len(plaintext)):\n        ct = ord(key[i % len(key)]) - 65 + ord(plaintext[i]) - 65\n        while ct > 25:\n            ct = ct - 26\n        ciphertext += chr(65 + ct)\n    return ciphertext\n\n\ndef vernam_decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    >>> vernam_decrypt(\"RIJVS\",\"KEY\")\n    'HELLO'\n    \"\"\"\n    decrypted_text = \"\"\n    for i in range(len(ciphertext)):\n        ct = ord(ciphertext[i]) - ord(key[i % len(key)])\n        while ct < 0:\n            ct = 26 + ct\n        decrypted_text += chr(65 + ct)\n    return decrypted_text\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n    # Example usage\n    plaintext = \"HELLO\"\n    key = \"KEY\"\n    encrypted_text = vernam_encrypt(plaintext, key)\n    decrypted_text = vernam_decrypt(encrypted_text, key)\n    print(\"\\n\\n\")\n    print(\"Plaintext:\", plaintext)\n    print(\"Encrypted:\", encrypted_text)\n    print(\"Decrypted:\", decrypted_text)\n", "ciphers/running_key_cipher.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Running_key_cipher\n\"\"\"\n\n\ndef running_key_encrypt(key: str, plaintext: str) -> str:\n    \"\"\"\n    Encrypts the plaintext using the Running Key Cipher.\n\n    :param key: The running key (long piece of text).\n    :param plaintext: The plaintext to be encrypted.\n    :return: The ciphertext.\n    \"\"\"\n    plaintext = plaintext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    ciphertext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(plaintext):\n        p = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        c = (p + k) % 26\n        ciphertext.append(chr(c + ord_a))\n\n    return \"\".join(ciphertext)\n\n\ndef running_key_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts the ciphertext using the Running Key Cipher.\n\n    :param key: The running key (long piece of text).\n    :param ciphertext: The ciphertext to be decrypted.\n    :return: The plaintext.\n    \"\"\"\n    ciphertext = ciphertext.replace(\" \", \"\").upper()\n    key = key.replace(\" \", \"\").upper()\n    key_length = len(key)\n    plaintext = []\n    ord_a = ord(\"A\")\n\n    for i, char in enumerate(ciphertext):\n        c = ord(char) - ord_a\n        k = ord(key[i % key_length]) - ord_a\n        p = (c - k) % 26\n        plaintext.append(chr(p + ord_a))\n\n    return \"\".join(plaintext)\n\n\ndef test_running_key_encrypt() -> None:\n    \"\"\"\n    >>> key = \"How does the duck know that? said Victor\"\n    >>> ciphertext = running_key_encrypt(key, \"DEFEND THIS\")\n    >>> running_key_decrypt(key, ciphertext) == \"DEFENDTHIS\"\n    True\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    test_running_key_encrypt()\n\n    plaintext = input(\"Enter the plaintext: \").upper()\n    print(f\"\\n{plaintext = }\")\n\n    key = \"How does the duck know that? said Victor\"\n    encrypted_text = running_key_encrypt(key, plaintext)\n    print(f\"{encrypted_text = }\")\n\n    decrypted_text = running_key_decrypt(key, encrypted_text)\n    print(f\"{decrypted_text = }\")\n", "ciphers/enigma_machine2.py": "\"\"\"\nWikipedia: https://en.wikipedia.org/wiki/Enigma_machine\nVideo explanation: https://youtu.be/QwQVMqfoB2E\nAlso check out Numberphile's and Computerphile's videos on this topic\n\nThis module contains function 'enigma' which emulates\nthe famous Enigma machine from WWII.\nModule includes:\n- enigma function\n- showcase of function usage\n- 9 randomly generated rotors\n- reflector (aka static rotor)\n- original alphabet\n\nCreated by TrapinchO\n\"\"\"\n\nfrom __future__ import annotations\n\nRotorPositionT = tuple[int, int, int]\nRotorSelectionT = tuple[str, str, str]\n\n\n# used alphabet --------------------------\n# from string.ascii_uppercase\nabc = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n# -------------------------- default selection --------------------------\n# rotors --------------------------\nrotor1 = \"EGZWVONAHDCLFQMSIPJBYUKXTR\"\nrotor2 = \"FOBHMDKEXQNRAULPGSJVTYICZW\"\nrotor3 = \"ZJXESIUQLHAVRMDOYGTNFWPBKC\"\n# reflector --------------------------\nreflector = {\n    \"A\": \"N\",\n    \"N\": \"A\",\n    \"B\": \"O\",\n    \"O\": \"B\",\n    \"C\": \"P\",\n    \"P\": \"C\",\n    \"D\": \"Q\",\n    \"Q\": \"D\",\n    \"E\": \"R\",\n    \"R\": \"E\",\n    \"F\": \"S\",\n    \"S\": \"F\",\n    \"G\": \"T\",\n    \"T\": \"G\",\n    \"H\": \"U\",\n    \"U\": \"H\",\n    \"I\": \"V\",\n    \"V\": \"I\",\n    \"J\": \"W\",\n    \"W\": \"J\",\n    \"K\": \"X\",\n    \"X\": \"K\",\n    \"L\": \"Y\",\n    \"Y\": \"L\",\n    \"M\": \"Z\",\n    \"Z\": \"M\",\n}\n\n# -------------------------- extra rotors --------------------------\nrotor4 = \"RMDJXFUWGISLHVTCQNKYPBEZOA\"\nrotor5 = \"SGLCPQWZHKXAREONTFBVIYJUDM\"\nrotor6 = \"HVSICLTYKQUBXDWAJZOMFGPREN\"\nrotor7 = \"RZWQHFMVDBKICJLNTUXAGYPSOE\"\nrotor8 = \"LFKIJODBEGAMQPXVUHYSTCZRWN\"\nrotor9 = \"KOAEGVDHXPQZMLFTYWJNBRCIUS\"\n\n\ndef _validator(\n    rotpos: RotorPositionT, rotsel: RotorSelectionT, pb: str\n) -> tuple[RotorPositionT, RotorSelectionT, dict[str, str]]:\n    \"\"\"\n    Checks if the values can be used for the 'enigma' function\n\n    >>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND')\n    ((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', \\\n'ZJXESIUQLHAVRMDOYGTNFWPBKC'), \\\n{'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})\n\n    :param rotpos: rotor_positon\n    :param rotsel: rotor_selection\n    :param pb: plugb -> validated and transformed\n    :return: (rotpos, rotsel, pb)\n    \"\"\"\n    # Checks if there are 3 unique rotors\n\n    if (unique_rotsel := len(set(rotsel))) < 3:\n        msg = f\"Please use 3 unique rotors (not {unique_rotsel})\"\n        raise Exception(msg)\n\n    # Checks if rotor positions are valid\n    rotorpos1, rotorpos2, rotorpos3 = rotpos\n    if not 0 < rotorpos1 <= len(abc):\n        msg = f\"First rotor position is not within range of 1..26 ({rotorpos1}\"\n        raise ValueError(msg)\n    if not 0 < rotorpos2 <= len(abc):\n        msg = f\"Second rotor position is not within range of 1..26 ({rotorpos2})\"\n        raise ValueError(msg)\n    if not 0 < rotorpos3 <= len(abc):\n        msg = f\"Third rotor position is not within range of 1..26 ({rotorpos3})\"\n        raise ValueError(msg)\n\n    # Validates string and returns dict\n    pbdict = _plugboard(pb)\n\n    return rotpos, rotsel, pbdict\n\n\ndef _plugboard(pbstring: str) -> dict[str, str]:\n    \"\"\"\n    https://en.wikipedia.org/wiki/Enigma_machine#Plugboard\n\n    >>> _plugboard('PICTURES')\n    {'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'}\n    >>> _plugboard('POLAND')\n    {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}\n\n    In the code, 'pb' stands for 'plugboard'\n\n    Pairs can be separated by spaces\n    :param pbstring: string containing plugboard setting for the Enigma machine\n    :return: dictionary containing converted pairs\n    \"\"\"\n\n    # tests the input string if it\n    # a) is type string\n    # b) has even length (so pairs can be made)\n    if not isinstance(pbstring, str):\n        msg = f\"Plugboard setting isn't type string ({type(pbstring)})\"\n        raise TypeError(msg)\n    elif len(pbstring) % 2 != 0:\n        msg = f\"Odd number of symbols ({len(pbstring)})\"\n        raise Exception(msg)\n    elif pbstring == \"\":\n        return {}\n\n    pbstring.replace(\" \", \"\")\n\n    # Checks if all characters are unique\n    tmppbl = set()\n    for i in pbstring:\n        if i not in abc:\n            msg = f\"'{i}' not in list of symbols\"\n            raise Exception(msg)\n        elif i in tmppbl:\n            msg = f\"Duplicate symbol ({i})\"\n            raise Exception(msg)\n        else:\n            tmppbl.add(i)\n    del tmppbl\n\n    # Created the dictionary\n    pb = {}\n    for j in range(0, len(pbstring) - 1, 2):\n        pb[pbstring[j]] = pbstring[j + 1]\n        pb[pbstring[j + 1]] = pbstring[j]\n\n    return pb\n\n\ndef enigma(\n    text: str,\n    rotor_position: RotorPositionT,\n    rotor_selection: RotorSelectionT = (rotor1, rotor2, rotor3),\n    plugb: str = \"\",\n) -> str:\n    \"\"\"\n    The only difference with real-world enigma is that I allowed string input.\n    All characters are converted to uppercase. (non-letter symbol are ignored)\n    How it works:\n    (for every letter in the message)\n\n    - Input letter goes into the plugboard.\n    If it is connected to another one, switch it.\n\n    - Letter goes through 3 rotors.\n    Each rotor can be represented as 2 sets of symbol, where one is shuffled.\n    Each symbol from the first set has corresponding symbol in\n    the second set and vice versa.\n\n    example:\n    | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F\n    | VKLEPDBGRNWTFCJOHQAMUZYIXS |\n\n    - Symbol then goes through reflector (static rotor).\n    There it is switched with paired symbol\n    The reflector can be represented as2 sets, each with half of the alphanet.\n    There are usually 10 pairs of letters.\n\n    Example:\n    | ABCDEFGHIJKLM | e.g. E is paired to X\n    | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa\n\n    - Letter then goes through the rotors again\n\n    - If the letter is connected to plugboard, it is switched.\n\n    - Return the letter\n\n    >>> enigma('Hello World!', (1, 2, 1), plugb='pictures')\n    'KORYH JUHHI!'\n    >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')\n    'HELLO, WORLD!'\n    >>> enigma('hello world!', (1, 1, 1), plugb='pictures')\n    'FPNCZ QWOBU!'\n    >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')\n    'HELLO WORLD'\n\n\n    :param text: input message\n    :param rotor_position: tuple with 3 values in range 1..26\n    :param rotor_selection: tuple with 3 rotors ()\n    :param plugb: string containing plugboard configuration (default '')\n    :return: en/decrypted string\n    \"\"\"\n\n    text = text.upper()\n    rotor_position, rotor_selection, plugboard = _validator(\n        rotor_position, rotor_selection, plugb.upper()\n    )\n\n    rotorpos1, rotorpos2, rotorpos3 = rotor_position\n    rotor1, rotor2, rotor3 = rotor_selection\n    rotorpos1 -= 1\n    rotorpos2 -= 1\n    rotorpos3 -= 1\n\n    result = []\n\n    # encryption/decryption process --------------------------\n    for symbol in text:\n        if symbol in abc:\n            # 1st plugboard --------------------------\n            if symbol in plugboard:\n                symbol = plugboard[symbol]\n\n            # rotor ra --------------------------\n            index = abc.index(symbol) + rotorpos1\n            symbol = rotor1[index % len(abc)]\n\n            # rotor rb --------------------------\n            index = abc.index(symbol) + rotorpos2\n            symbol = rotor2[index % len(abc)]\n\n            # rotor rc --------------------------\n            index = abc.index(symbol) + rotorpos3\n            symbol = rotor3[index % len(abc)]\n\n            # reflector --------------------------\n            # this is the reason you don't need another machine to decipher\n\n            symbol = reflector[symbol]\n\n            # 2nd rotors\n            symbol = abc[rotor3.index(symbol) - rotorpos3]\n            symbol = abc[rotor2.index(symbol) - rotorpos2]\n            symbol = abc[rotor1.index(symbol) - rotorpos1]\n\n            # 2nd plugboard\n            if symbol in plugboard:\n                symbol = plugboard[symbol]\n\n            # moves/resets rotor positions\n            rotorpos1 += 1\n            if rotorpos1 >= len(abc):\n                rotorpos1 = 0\n                rotorpos2 += 1\n            if rotorpos2 >= len(abc):\n                rotorpos2 = 0\n                rotorpos3 += 1\n            if rotorpos3 >= len(abc):\n                rotorpos3 = 0\n\n        # else:\n        #    pass\n        #    Error could be also raised\n        #    raise ValueError(\n        #       'Invalid symbol('+repr(symbol)+')')\n        result.append(symbol)\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    message = \"This is my Python script that emulates the Enigma machine from WWII.\"\n    rotor_pos = (1, 1, 1)\n    pb = \"pictures\"\n    rotor_sel = (rotor2, rotor4, rotor8)\n    en = enigma(message, rotor_pos, rotor_sel, pb)\n\n    print(\"Encrypted message:\", en)\n    print(\"Decrypted message:\", enigma(en, rotor_pos, rotor_sel, pb))\n", "ciphers/rot13.py": "def dencrypt(s: str, n: int = 13) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/ROT13\n\n    >>> msg = \"My secret bank account number is 173-52946 so don't tell anyone!!\"\n    >>> s = dencrypt(msg)\n    >>> s\n    \"Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!\"\n    >>> dencrypt(s) == msg\n    True\n    \"\"\"\n    out = \"\"\n    for c in s:\n        if \"A\" <= c <= \"Z\":\n            out += chr(ord(\"A\") + (ord(c) - ord(\"A\") + n) % 26)\n        elif \"a\" <= c <= \"z\":\n            out += chr(ord(\"a\") + (ord(c) - ord(\"a\") + n) % 26)\n        else:\n            out += c\n    return out\n\n\ndef main() -> None:\n    s0 = input(\"Enter message: \")\n\n    s1 = dencrypt(s0, 13)\n    print(\"Encryption:\", s1)\n\n    s2 = dencrypt(s1, 13)\n    print(\"Decryption: \", s2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/atbash.py": "\"\"\"https://en.wikipedia.org/wiki/Atbash\"\"\"\n\nimport string\n\n\ndef atbash_slow(sequence: str) -> str:\n    \"\"\"\n    >>> atbash_slow(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash_slow(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    output = \"\"\n    for i in sequence:\n        extract = ord(i)\n        if 65 <= extract <= 90:\n            output += chr(155 - extract)\n        elif 97 <= extract <= 122:\n            output += chr(219 - extract)\n        else:\n            output += i\n    return output\n\n\ndef atbash(sequence: str) -> str:\n    \"\"\"\n    >>> atbash(\"ABCDEFG\")\n    'ZYXWVUT'\n\n    >>> atbash(\"aW;;123BX\")\n    'zD;;123YC'\n    \"\"\"\n    letters = string.ascii_letters\n    letters_reversed = string.ascii_lowercase[::-1] + string.ascii_uppercase[::-1]\n    return \"\".join(\n        letters_reversed[letters.index(c)] if c in letters else c for c in sequence\n    )\n\n\ndef benchmark() -> None:\n    \"\"\"Let's benchmark our functions side-by-side...\"\"\"\n    from timeit import timeit\n\n    print(\"Running performance benchmarks...\")\n    setup = \"from string import printable ; from __main__ import atbash, atbash_slow\"\n    print(f\"> atbash_slow(): {timeit('atbash_slow(printable)', setup=setup)} seconds\")\n    print(f\">      atbash(): {timeit('atbash(printable)', setup=setup)} seconds\")\n\n\nif __name__ == \"__main__\":\n    for example in (\"ABCDEFGH\", \"123GGjj\", \"testStringtest\", \"with space\"):\n        print(f\"{example} encrypted in atbash: {atbash(example)}\")\n    benchmark()\n", "ciphers/base16.py": "def base16_encode(data: bytes) -> str:\n    \"\"\"\n    Encodes the given bytes into base16.\n\n    >>> base16_encode(b'Hello World!')\n    '48656C6C6F20576F726C6421'\n    >>> base16_encode(b'HELLO WORLD!')\n    '48454C4C4F20574F524C4421'\n    >>> base16_encode(b'')\n    ''\n    \"\"\"\n    # Turn the data into a list of integers (where each integer is a byte),\n    # Then turn each byte into its hexadecimal representation, make sure\n    # it is uppercase, and then join everything together and return it.\n    return \"\".join([hex(byte)[2:].zfill(2).upper() for byte in list(data)])\n\n\ndef base16_decode(data: str) -> bytes:\n    \"\"\"\n    Decodes the given base16 encoded data into bytes.\n\n    >>> base16_decode('48656C6C6F20576F726C6421')\n    b'Hello World!'\n    >>> base16_decode('48454C4C4F20574F524C4421')\n    b'HELLO WORLD!'\n    >>> base16_decode('')\n    b''\n    >>> base16_decode('486')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data does not have an even number of hex digits.\n    >>> base16_decode('48656c6c6f20576f726c6421')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    >>> base16_decode('This is not base64 encoded data.')\n    Traceback (most recent call last):\n      ...\n    ValueError: Base16 encoded data is invalid:\n    Data is not uppercase hex or it contains invalid characters.\n    \"\"\"\n    # Check data validity, following RFC3548\n    # https://www.ietf.org/rfc/rfc3548.txt\n    if (len(data) % 2) != 0:\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData does not have an even number of hex digits.\"\"\"\n        )\n    # Check the character set - the standard base16 alphabet\n    # is uppercase according to RFC3548 section 6\n    if not set(data) <= set(\"0123456789ABCDEF\"):\n        raise ValueError(\n            \"\"\"Base16 encoded data is invalid:\nData is not uppercase hex or it contains invalid characters.\"\"\"\n        )\n    # For every two hexadecimal digits (= a byte), turn it into an integer.\n    # Then, string the result together into bytes, and return it.\n    return bytes(int(data[i] + data[i + 1], 16) for i in range(0, len(data), 2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/rsa_cipher.py": "import os\nimport sys\n\nfrom . import rsa_key_generator as rkg\n\nDEFAULT_BLOCK_SIZE = 128\nBYTE_SIZE = 256\n\n\ndef get_blocks_from_text(\n    message: str, block_size: int = DEFAULT_BLOCK_SIZE\n) -> list[int]:\n    message_bytes = message.encode(\"ascii\")\n\n    block_ints = []\n    for block_start in range(0, len(message_bytes), block_size):\n        block_int = 0\n        for i in range(block_start, min(block_start + block_size, len(message_bytes))):\n            block_int += message_bytes[i] * (BYTE_SIZE ** (i % block_size))\n        block_ints.append(block_int)\n    return block_ints\n\n\ndef get_text_from_blocks(\n    block_ints: list[int], message_length: int, block_size: int = DEFAULT_BLOCK_SIZE\n) -> str:\n    message: list[str] = []\n    for block_int in block_ints:\n        block_message: list[str] = []\n        for i in range(block_size - 1, -1, -1):\n            if len(message) + i < message_length:\n                ascii_number = block_int // (BYTE_SIZE**i)\n                block_int = block_int % (BYTE_SIZE**i)\n                block_message.insert(0, chr(ascii_number))\n        message.extend(block_message)\n    return \"\".join(message)\n\n\ndef encrypt_message(\n    message: str, key: tuple[int, int], block_size: int = DEFAULT_BLOCK_SIZE\n) -> list[int]:\n    encrypted_blocks = []\n    n, e = key\n\n    for block in get_blocks_from_text(message, block_size):\n        encrypted_blocks.append(pow(block, e, n))\n    return encrypted_blocks\n\n\ndef decrypt_message(\n    encrypted_blocks: list[int],\n    message_length: int,\n    key: tuple[int, int],\n    block_size: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    decrypted_blocks = []\n    n, d = key\n    for block in encrypted_blocks:\n        decrypted_blocks.append(pow(block, d, n))\n    return get_text_from_blocks(decrypted_blocks, message_length, block_size)\n\n\ndef read_key_file(key_filename: str) -> tuple[int, int, int]:\n    with open(key_filename) as fo:\n        content = fo.read()\n    key_size, n, eor_d = content.split(\",\")\n    return (int(key_size), int(n), int(eor_d))\n\n\ndef encrypt_and_write_to_file(\n    message_filename: str,\n    key_filename: str,\n    message: str,\n    block_size: int = DEFAULT_BLOCK_SIZE,\n) -> str:\n    key_size, n, e = read_key_file(key_filename)\n    if key_size < block_size * 8:\n        sys.exit(\n            f\"ERROR: Block size is {block_size * 8} bits and key size is {key_size} \"\n            \"bits. The RSA cipher requires the block size to be equal to or greater \"\n            \"than the key size. Either decrease the block size or use different keys.\"\n        )\n\n    encrypted_blocks = [str(i) for i in encrypt_message(message, (n, e), block_size)]\n\n    encrypted_content = \",\".join(encrypted_blocks)\n    encrypted_content = f\"{len(message)}_{block_size}_{encrypted_content}\"\n    with open(message_filename, \"w\") as fo:\n        fo.write(encrypted_content)\n    return encrypted_content\n\n\ndef read_from_file_and_decrypt(message_filename: str, key_filename: str) -> str:\n    key_size, n, d = read_key_file(key_filename)\n    with open(message_filename) as fo:\n        content = fo.read()\n    message_length_str, block_size_str, encrypted_message = content.split(\"_\")\n    message_length = int(message_length_str)\n    block_size = int(block_size_str)\n\n    if key_size < block_size * 8:\n        sys.exit(\n            f\"ERROR: Block size is {block_size * 8} bits and key size is {key_size} \"\n            \"bits. The RSA cipher requires the block size to be equal to or greater \"\n            \"than the key size. Were the correct key file and encrypted file specified?\"\n        )\n\n    encrypted_blocks = []\n    for block in encrypted_message.split(\",\"):\n        encrypted_blocks.append(int(block))\n\n    return decrypt_message(encrypted_blocks, message_length, (n, d), block_size)\n\n\ndef main() -> None:\n    filename = \"encrypted_file.txt\"\n    response = input(r\"Encrypt\\Decrypt [e\\d]: \")\n\n    if response.lower().startswith(\"e\"):\n        mode = \"encrypt\"\n    elif response.lower().startswith(\"d\"):\n        mode = \"decrypt\"\n\n    if mode == \"encrypt\":\n        if not os.path.exists(\"rsa_pubkey.txt\"):\n            rkg.make_key_files(\"rsa\", 1024)\n\n        message = input(\"\\nEnter message: \")\n        pubkey_filename = \"rsa_pubkey.txt\"\n        print(f\"Encrypting and writing to {filename}...\")\n        encrypted_text = encrypt_and_write_to_file(filename, pubkey_filename, message)\n\n        print(\"\\nEncrypted text:\")\n        print(encrypted_text)\n\n    elif mode == \"decrypt\":\n        privkey_filename = \"rsa_privkey.txt\"\n        print(f\"Reading from {filename} and decrypting...\")\n        decrypted_text = read_from_file_and_decrypt(filename, privkey_filename)\n        print(\"writing decryption to rsa_decryption.txt...\")\n        with open(\"rsa_decryption.txt\", \"w\") as dec:\n            dec.write(decrypted_text)\n\n        print(\"\\nDecryption:\")\n        print(decrypted_text)\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/brute_force_caesar_cipher.py": "import string\n\n\ndef decrypt(message: str) -> None:\n    \"\"\"\n    >>> decrypt('TMDETUX PMDVU')\n    Decryption using Key #0: TMDETUX PMDVU\n    Decryption using Key #1: SLCDSTW OLCUT\n    Decryption using Key #2: RKBCRSV NKBTS\n    Decryption using Key #3: QJABQRU MJASR\n    Decryption using Key #4: PIZAPQT LIZRQ\n    Decryption using Key #5: OHYZOPS KHYQP\n    Decryption using Key #6: NGXYNOR JGXPO\n    Decryption using Key #7: MFWXMNQ IFWON\n    Decryption using Key #8: LEVWLMP HEVNM\n    Decryption using Key #9: KDUVKLO GDUML\n    Decryption using Key #10: JCTUJKN FCTLK\n    Decryption using Key #11: IBSTIJM EBSKJ\n    Decryption using Key #12: HARSHIL DARJI\n    Decryption using Key #13: GZQRGHK CZQIH\n    Decryption using Key #14: FYPQFGJ BYPHG\n    Decryption using Key #15: EXOPEFI AXOGF\n    Decryption using Key #16: DWNODEH ZWNFE\n    Decryption using Key #17: CVMNCDG YVMED\n    Decryption using Key #18: BULMBCF XULDC\n    Decryption using Key #19: ATKLABE WTKCB\n    Decryption using Key #20: ZSJKZAD VSJBA\n    Decryption using Key #21: YRIJYZC URIAZ\n    Decryption using Key #22: XQHIXYB TQHZY\n    Decryption using Key #23: WPGHWXA SPGYX\n    Decryption using Key #24: VOFGVWZ ROFXW\n    Decryption using Key #25: UNEFUVY QNEWV\n    \"\"\"\n    for key in range(len(string.ascii_uppercase)):\n        translated = \"\"\n        for symbol in message:\n            if symbol in string.ascii_uppercase:\n                num = string.ascii_uppercase.find(symbol)\n                num = num - key\n                if num < 0:\n                    num = num + len(string.ascii_uppercase)\n                translated = translated + string.ascii_uppercase[num]\n            else:\n                translated = translated + symbol\n        print(f\"Decryption using Key #{key}: {translated}\")\n\n\ndef main() -> None:\n    message = input(\"Encrypted message: \")\n    message = message.upper()\n    decrypt(message)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/bifid.py": "#!/usr/bin/env python3\n\n\"\"\"\nThe Bifid Cipher uses a Polybius Square to encipher a message in a way that\nmakes it fairly difficult to decipher without knowing the secret.\n\nhttps://www.braingle.com/brainteasers/codes/bifid.php\n\"\"\"\n\nimport numpy as np\n\nSQUARE = [\n    [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    [\"f\", \"g\", \"h\", \"i\", \"k\"],\n    [\"l\", \"m\", \"n\", \"o\", \"p\"],\n    [\"q\", \"r\", \"s\", \"t\", \"u\"],\n    [\"v\", \"w\", \"x\", \"y\", \"z\"],\n]\n\n\nclass BifidCipher:\n    def __init__(self) -> None:\n        self.SQUARE = np.array(SQUARE)\n\n    def letter_to_numbers(self, letter: str) -> np.ndarray:\n        \"\"\"\n        Return the pair of numbers that represents the given letter in the\n        polybius square\n\n        >>> np.array_equal(BifidCipher().letter_to_numbers('a'), [1,1])\n        True\n\n        >>> np.array_equal(BifidCipher().letter_to_numbers('u'), [4,5])\n        True\n        \"\"\"\n        index1, index2 = np.where(letter == self.SQUARE)\n        indexes = np.concatenate([index1 + 1, index2 + 1])\n        return indexes\n\n    def numbers_to_letter(self, index1: int, index2: int) -> str:\n        \"\"\"\n        Return the letter corresponding to the position [index1, index2] in\n        the polybius square\n\n        >>> BifidCipher().numbers_to_letter(4, 5) == \"u\"\n        True\n\n        >>> BifidCipher().numbers_to_letter(1, 1) == \"a\"\n        True\n        \"\"\"\n        letter = self.SQUARE[index1 - 1, index2 - 1]\n        return letter\n\n    def encode(self, message: str) -> str:\n        \"\"\"\n        Return the encoded version of message according to the polybius cipher\n\n        >>> BifidCipher().encode('testmessage') == 'qtltbdxrxlk'\n        True\n\n        >>> BifidCipher().encode('Test Message') == 'qtltbdxrxlk'\n        True\n\n        >>> BifidCipher().encode('test j') == BifidCipher().encode('test i')\n        True\n        \"\"\"\n        message = message.lower()\n        message = message.replace(\" \", \"\")\n        message = message.replace(\"j\", \"i\")\n\n        first_step = np.empty((2, len(message)))\n        for letter_index in range(len(message)):\n            numbers = self.letter_to_numbers(message[letter_index])\n\n            first_step[0, letter_index] = numbers[0]\n            first_step[1, letter_index] = numbers[1]\n\n        second_step = first_step.reshape(2 * len(message))\n        encoded_message = \"\"\n        for numbers_index in range(len(message)):\n            index1 = int(second_step[numbers_index * 2])\n            index2 = int(second_step[(numbers_index * 2) + 1])\n            letter = self.numbers_to_letter(index1, index2)\n            encoded_message = encoded_message + letter\n\n        return encoded_message\n\n    def decode(self, message: str) -> str:\n        \"\"\"\n        Return the decoded version of message according to the polybius cipher\n\n        >>> BifidCipher().decode('qtltbdxrxlk') == 'testmessage'\n        True\n        \"\"\"\n        message = message.lower()\n        message.replace(\" \", \"\")\n        first_step = np.empty(2 * len(message))\n        for letter_index in range(len(message)):\n            numbers = self.letter_to_numbers(message[letter_index])\n            first_step[letter_index * 2] = numbers[0]\n            first_step[letter_index * 2 + 1] = numbers[1]\n\n        second_step = first_step.reshape((2, len(message)))\n        decoded_message = \"\"\n        for numbers_index in range(len(message)):\n            index1 = int(second_step[0, numbers_index])\n            index2 = int(second_step[1, numbers_index])\n            letter = self.numbers_to_letter(index1, index2)\n            decoded_message = decoded_message + letter\n\n        return decoded_message\n", "ciphers/playfair_cipher.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Playfair_cipher#Description\n\nThe Playfair cipher was developed by Charles Wheatstone in 1854\nIt's use was heavily promotedby Lord Playfair, hence its name\n\nSome features of the Playfair cipher are:\n\n1) It was the first literal diagram substitution cipher\n2) It is a manual symmetric encryption technique\n3) It is a multiple letter encryption cipher\n\nThe implementation in the code below encodes alphabets only.\nIt removes spaces, special characters and numbers from the\ncode.\n\nPlayfair is no longer used by military forces because of known\ninsecurities and of the advent of automated encryption devices.\nThis cipher is regarded as insecure since before World War I.\n\"\"\"\n\nimport itertools\nimport string\nfrom collections.abc import Generator, Iterable\n\n\ndef chunker(seq: Iterable[str], size: int) -> Generator[tuple[str, ...], None, None]:\n    it = iter(seq)\n    while True:\n        chunk = tuple(itertools.islice(it, size))\n        if not chunk:\n            return\n        yield chunk\n\n\ndef prepare_input(dirty: str) -> str:\n    \"\"\"\n    Prepare the plaintext by up-casing it\n    and separating repeated letters with X's\n    \"\"\"\n\n    dirty = \"\".join([c.upper() for c in dirty if c in string.ascii_letters])\n    clean = \"\"\n\n    if len(dirty) < 2:\n        return dirty\n\n    for i in range(len(dirty) - 1):\n        clean += dirty[i]\n\n        if dirty[i] == dirty[i + 1]:\n            clean += \"X\"\n\n    clean += dirty[-1]\n\n    if len(clean) & 1:\n        clean += \"X\"\n\n    return clean\n\n\ndef generate_table(key: str) -> list[str]:\n    # I and J are used interchangeably to allow\n    # us to use a 5x5 table (25 letters)\n    alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\"\n    # we're using a list instead of a '2d' array because it makes the math\n    # for setting up the table and doing the actual encoding/decoding simpler\n    table = []\n\n    # copy key chars into the table if they are in `alphabet` ignoring duplicates\n    for char in key.upper():\n        if char not in table and char in alphabet:\n            table.append(char)\n\n    # fill the rest of the table in with the remaining alphabet chars\n    for char in alphabet:\n        if char not in table:\n            table.append(char)\n\n    return table\n\n\ndef encode(plaintext: str, key: str) -> str:\n    \"\"\"\n    Encode the given plaintext using the Playfair cipher.\n    Takes the plaintext and the key as input and returns the encoded string.\n\n    >>> encode(\"Hello\", \"MONARCHY\")\n    'CFSUPM'\n    >>> encode(\"attack on the left flank\", \"EMERGENCY\")\n    'DQZSBYFSDZFMFNLOHFDRSG'\n    >>> encode(\"Sorry!\", \"SPECIAL\")\n    'AVXETX'\n    >>> encode(\"Number 1\", \"NUMBER\")\n    'UMBENF'\n    >>> encode(\"Photosynthesis!\", \"THE SUN\")\n    'OEMHQHVCHESUKE'\n    \"\"\"\n\n    table = generate_table(key)\n    plaintext = prepare_input(plaintext)\n    ciphertext = \"\"\n\n    for char1, char2 in chunker(plaintext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            ciphertext += table[row1 * 5 + (col1 + 1) % 5]\n            ciphertext += table[row2 * 5 + (col2 + 1) % 5]\n        elif col1 == col2:\n            ciphertext += table[((row1 + 1) % 5) * 5 + col1]\n            ciphertext += table[((row2 + 1) % 5) * 5 + col2]\n        else:  # rectangle\n            ciphertext += table[row1 * 5 + col2]\n            ciphertext += table[row2 * 5 + col1]\n\n    return ciphertext\n\n\ndef decode(ciphertext: str, key: str) -> str:\n    \"\"\"\n    Decode the input string using the provided key.\n\n    >>> decode(\"BMZFAZRZDH\", \"HAZARD\")\n    'FIREHAZARD'\n    >>> decode(\"HNBWBPQT\", \"AUTOMOBILE\")\n    'DRIVINGX'\n    >>> decode(\"SLYSSAQS\", \"CASTLE\")\n    'ATXTACKX'\n    \"\"\"\n\n    table = generate_table(key)\n    plaintext = \"\"\n\n    for char1, char2 in chunker(ciphertext, 2):\n        row1, col1 = divmod(table.index(char1), 5)\n        row2, col2 = divmod(table.index(char2), 5)\n\n        if row1 == row2:\n            plaintext += table[row1 * 5 + (col1 - 1) % 5]\n            plaintext += table[row2 * 5 + (col2 - 1) % 5]\n        elif col1 == col2:\n            plaintext += table[((row1 - 1) % 5) * 5 + col1]\n            plaintext += table[((row2 - 1) % 5) * 5 + col2]\n        else:  # rectangle\n            plaintext += table[row1 * 5 + col2]\n            plaintext += table[row2 * 5 + col1]\n\n    return plaintext\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(\"Encoded:\", encode(\"BYE AND THANKS\", \"GREETING\"))\n    print(\"Decoded:\", decode(\"CXRBANRLBALQ\", \"GREETING\"))\n", "ciphers/porta_cipher.py": "alphabet = {\n    \"A\": (\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\"),\n    \"B\": (\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\"),\n    \"C\": (\"ABCDEFGHIJKLM\", \"ZNOPQRSTUVWXY\"),\n    \"D\": (\"ABCDEFGHIJKLM\", \"ZNOPQRSTUVWXY\"),\n    \"E\": (\"ABCDEFGHIJKLM\", \"YZNOPQRSTUVWX\"),\n    \"F\": (\"ABCDEFGHIJKLM\", \"YZNOPQRSTUVWX\"),\n    \"G\": (\"ABCDEFGHIJKLM\", \"XYZNOPQRSTUVW\"),\n    \"H\": (\"ABCDEFGHIJKLM\", \"XYZNOPQRSTUVW\"),\n    \"I\": (\"ABCDEFGHIJKLM\", \"WXYZNOPQRSTUV\"),\n    \"J\": (\"ABCDEFGHIJKLM\", \"WXYZNOPQRSTUV\"),\n    \"K\": (\"ABCDEFGHIJKLM\", \"VWXYZNOPQRSTU\"),\n    \"L\": (\"ABCDEFGHIJKLM\", \"VWXYZNOPQRSTU\"),\n    \"M\": (\"ABCDEFGHIJKLM\", \"UVWXYZNOPQRST\"),\n    \"N\": (\"ABCDEFGHIJKLM\", \"UVWXYZNOPQRST\"),\n    \"O\": (\"ABCDEFGHIJKLM\", \"TUVWXYZNOPQRS\"),\n    \"P\": (\"ABCDEFGHIJKLM\", \"TUVWXYZNOPQRS\"),\n    \"Q\": (\"ABCDEFGHIJKLM\", \"STUVWXYZNOPQR\"),\n    \"R\": (\"ABCDEFGHIJKLM\", \"STUVWXYZNOPQR\"),\n    \"S\": (\"ABCDEFGHIJKLM\", \"RSTUVWXYZNOPQ\"),\n    \"T\": (\"ABCDEFGHIJKLM\", \"RSTUVWXYZNOPQ\"),\n    \"U\": (\"ABCDEFGHIJKLM\", \"QRSTUVWXYZNOP\"),\n    \"V\": (\"ABCDEFGHIJKLM\", \"QRSTUVWXYZNOP\"),\n    \"W\": (\"ABCDEFGHIJKLM\", \"PQRSTUVWXYZNO\"),\n    \"X\": (\"ABCDEFGHIJKLM\", \"PQRSTUVWXYZNO\"),\n    \"Y\": (\"ABCDEFGHIJKLM\", \"OPQRSTUVWXYZN\"),\n    \"Z\": (\"ABCDEFGHIJKLM\", \"OPQRSTUVWXYZN\"),\n}\n\n\ndef generate_table(key: str) -> list[tuple[str, str]]:\n    \"\"\"\n    >>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE\n    [('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),\n     ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),\n     ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]\n    \"\"\"\n    return [alphabet[char] for char in key.upper()]\n\n\ndef encrypt(key: str, words: str) -> str:\n    \"\"\"\n    >>> encrypt('marvin', 'jessica')\n    'QRACRWU'\n    \"\"\"\n    cipher = \"\"\n    count = 0\n    table = generate_table(key)\n    for char in words.upper():\n        cipher += get_opponent(table[count], char)\n        count = (count + 1) % len(table)\n    return cipher\n\n\ndef decrypt(key: str, words: str) -> str:\n    \"\"\"\n    >>> decrypt('marvin', 'QRACRWU')\n    'JESSICA'\n    \"\"\"\n    return encrypt(key, words)\n\n\ndef get_position(table: tuple[str, str], char: str) -> tuple[int, int]:\n    \"\"\"\n    >>> get_position(generate_table('marvin')[0], 'M')\n    (0, 12)\n    \"\"\"\n    # `char` is either in the 0th row or the 1st row\n    row = 0 if char in table[0] else 1\n    col = table[row].index(char)\n    return row, col\n\n\ndef get_opponent(table: tuple[str, str], char: str) -> str:\n    \"\"\"\n    >>> get_opponent(generate_table('marvin')[0], 'M')\n    'T'\n    \"\"\"\n    row, col = get_position(table, char.upper())\n    if row == 1:\n        return table[0][col]\n    else:\n        return table[1][col] if row == 0 else char\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()  # Fist ensure that all our tests are passing...\n    \"\"\"\n    Demo:\n\n    Enter key: marvin\n    Enter text to encrypt: jessica\n    Encrypted: QRACRWU\n    Decrypted with key: JESSICA\n    \"\"\"\n    key = input(\"Enter key: \").strip()\n    text = input(\"Enter text to encrypt: \").strip()\n    cipher_text = encrypt(key, text)\n\n    print(f\"Encrypted: {cipher_text}\")\n    print(f\"Decrypted with key: {decrypt(key, cipher_text)}\")\n", "ciphers/deterministic_miller_rabin.py": "\"\"\"Created by Nathan Damon, @bizzfitch on github\n>>> test_miller_rabin()\n\"\"\"\n\n\ndef miller_rabin(n: int, allow_probable: bool = False) -> bool:\n    \"\"\"Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.\n\n    Uses numerical analysis results to return whether or not the passed number\n    is prime. If the passed number is above the upper limit, and\n    allow_probable is True, then a return value of True indicates that n is\n    probably prime. This test does not allow False negatives- a return value\n    of False is ALWAYS composite.\n\n    Parameters\n    ----------\n    n : int\n        The integer to be tested. Since we usually care if a number is prime,\n        n < 2 returns False instead of raising a ValueError.\n    allow_probable: bool, default False\n        Whether or not to test n above the upper bound of the deterministic test.\n\n    Raises\n    ------\n    ValueError\n\n    Reference\n    ---------\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n    \"\"\"\n    if n == 2:\n        return True\n    if not n % 2 or n < 2:\n        return False\n    if n > 5 and n % 10 not in (1, 3, 7, 9):  # can quickly check last digit\n        return False\n    if n > 3_317_044_064_679_887_385_961_981 and not allow_probable:\n        raise ValueError(\n            \"Warning: upper bound of deterministic test is exceeded. \"\n            \"Pass allow_probable=True to allow probabilistic test. \"\n            \"A return value of True indicates a probable prime.\"\n        )\n    # array bounds provided by analysis\n    bounds = [\n        2_047,\n        1_373_653,\n        25_326_001,\n        3_215_031_751,\n        2_152_302_898_747,\n        3_474_749_660_383,\n        341_550_071_728_321,\n        1,\n        3_825_123_056_546_413_051,\n        1,\n        1,\n        318_665_857_834_031_151_167_461,\n        3_317_044_064_679_887_385_961_981,\n    ]\n\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    for idx, _p in enumerate(bounds, 1):\n        if n < _p:\n            # then we have our last prime to check\n            plist = primes[:idx]\n            break\n    d, s = n - 1, 0\n    # break up n -1 into a power of 2 (s) and\n    # remaining odd component\n    # essentially, solve for d * 2 ** s == n - 1\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    for prime in plist:\n        pr = False\n        for r in range(s):\n            m = pow(prime, d * 2**r, n)\n            # see article for analysis explanation for m\n            if (r == 0 and m == 1) or ((m + 1) % n == 0):\n                pr = True\n                # this loop will not determine compositeness\n                break\n        if pr:\n            continue\n        # if pr is False, then the above loop never evaluated to true,\n        # and the n MUST be composite\n        return False\n    return True\n\n\ndef test_miller_rabin() -> None:\n    \"\"\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\n    and a prime in each range.\n    \"\"\"\n    assert not miller_rabin(561)\n    assert miller_rabin(563)\n    # 2047\n\n    assert not miller_rabin(838_201)\n    assert miller_rabin(838_207)\n    # 1_373_653\n\n    assert not miller_rabin(17_316_001)\n    assert miller_rabin(17_316_017)\n    # 25_326_001\n\n    assert not miller_rabin(3_078_386_641)\n    assert miller_rabin(3_078_386_653)\n    # 3_215_031_751\n\n    assert not miller_rabin(1_713_045_574_801)\n    assert miller_rabin(1_713_045_574_819)\n    # 2_152_302_898_747\n\n    assert not miller_rabin(2_779_799_728_307)\n    assert miller_rabin(2_779_799_728_327)\n    # 3_474_749_660_383\n\n    assert not miller_rabin(113_850_023_909_441)\n    assert miller_rabin(113_850_023_909_527)\n    # 341_550_071_728_321\n\n    assert not miller_rabin(1_275_041_018_848_804_351)\n    assert miller_rabin(1_275_041_018_848_804_391)\n    # 3_825_123_056_546_413_051\n\n    assert not miller_rabin(79_666_464_458_507_787_791_867)\n    assert miller_rabin(79_666_464_458_507_787_791_951)\n    # 318_665_857_834_031_151_167_461\n\n    assert not miller_rabin(552_840_677_446_647_897_660_333)\n    assert miller_rabin(552_840_677_446_647_897_660_359)\n    # 3_317_044_064_679_887_385_961_981\n    # upper limit for probabilistic test\n\n\nif __name__ == \"__main__\":\n    test_miller_rabin()\n", "ciphers/base64.py": "B64_CHARSET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\n\ndef base64_encode(data: bytes) -> bytes:\n    \"\"\"Encodes data according to RFC4648.\n\n    The data is first transformed to binary and appended with binary digits so that its\n    length becomes a multiple of 6, then each 6 binary digits will match a character in\n    the B64_CHARSET string. The number of appended binary digits would later determine\n    how many \"=\" signs should be added, the padding.\n    For every 2 binary digits added, a \"=\" sign is added in the output.\n    We can add any binary digits to make it a multiple of 6, for instance, consider the\n    following example:\n    \"AA\" -> 0010100100101001 -> 001010 010010 1001\n    As can be seen above, 2 more binary digits should be added, so there's 4\n    possibilities here: 00, 01, 10 or 11.\n    That being said, Base64 encoding can be used in Steganography to hide data in these\n    appended digits.\n\n    >>> from base64 import b64encode\n    >>> a = b\"This pull request is part of Hacktoberfest20!\"\n    >>> b = b\"https://tools.ietf.org/html/rfc4648\"\n    >>> c = b\"A\"\n    >>> base64_encode(a) == b64encode(a)\n    True\n    >>> base64_encode(b) == b64encode(b)\n    True\n    >>> base64_encode(c) == b64encode(c)\n    True\n    >>> base64_encode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    TypeError: a bytes-like object is required, not 'str'\n    \"\"\"\n    # Make sure the supplied data is a bytes-like object\n    if not isinstance(data, bytes):\n        msg = f\"a bytes-like object is required, not '{data.__class__.__name__}'\"\n        raise TypeError(msg)\n\n    binary_stream = \"\".join(bin(byte)[2:].zfill(8) for byte in data)\n\n    padding_needed = len(binary_stream) % 6 != 0\n\n    if padding_needed:\n        # The padding that will be added later\n        padding = b\"=\" * ((6 - len(binary_stream) % 6) // 2)\n\n        # Append binary_stream with arbitrary binary digits (0's by default) to make its\n        # length a multiple of 6.\n        binary_stream += \"0\" * (6 - len(binary_stream) % 6)\n    else:\n        padding = b\"\"\n\n    # Encode every 6 binary digits to their corresponding Base64 character\n    return (\n        \"\".join(\n            B64_CHARSET[int(binary_stream[index : index + 6], 2)]\n            for index in range(0, len(binary_stream), 6)\n        ).encode()\n        + padding\n    )\n\n\ndef base64_decode(encoded_data: str) -> bytes:\n    \"\"\"Decodes data according to RFC4648.\n\n    This does the reverse operation of base64_encode.\n    We first transform the encoded data back to a binary stream, take off the\n    previously appended binary digits according to the padding, at this point we\n    would have a binary stream whose length is multiple of 8, the last step is\n    to convert every 8 bits to a byte.\n\n    >>> from base64 import b64decode\n    >>> a = \"VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh\"\n    >>> b = \"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg=\"\n    >>> c = \"QQ==\"\n    >>> base64_decode(a) == b64decode(a)\n    True\n    >>> base64_decode(b) == b64decode(b)\n    True\n    >>> base64_decode(c) == b64decode(c)\n    True\n    >>> base64_decode(\"abc\")\n    Traceback (most recent call last):\n      ...\n    AssertionError: Incorrect padding\n    \"\"\"\n    # Make sure encoded_data is either a string or a bytes-like object\n    if not isinstance(encoded_data, bytes) and not isinstance(encoded_data, str):\n        msg = (\n            \"argument should be a bytes-like object or ASCII string, \"\n            f\"not '{encoded_data.__class__.__name__}'\"\n        )\n        raise TypeError(msg)\n\n    # In case encoded_data is a bytes-like object, make sure it contains only\n    # ASCII characters so we convert it to a string object\n    if isinstance(encoded_data, bytes):\n        try:\n            encoded_data = encoded_data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            raise ValueError(\"base64 encoded data should only contain ASCII characters\")\n\n    padding = encoded_data.count(\"=\")\n\n    # Check if the encoded string contains non base64 characters\n    if padding:\n        assert all(\n            char in B64_CHARSET for char in encoded_data[:-padding]\n        ), \"Invalid base64 character(s) found.\"\n    else:\n        assert all(\n            char in B64_CHARSET for char in encoded_data\n        ), \"Invalid base64 character(s) found.\"\n\n    # Check the padding\n    assert len(encoded_data) % 4 == 0 and padding < 3, \"Incorrect padding\"\n\n    if padding:\n        # Remove padding if there is one\n        encoded_data = encoded_data[:-padding]\n\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )[: -padding * 2]\n    else:\n        binary_stream = \"\".join(\n            bin(B64_CHARSET.index(char))[2:].zfill(6) for char in encoded_data\n        )\n\n    data = [\n        int(binary_stream[index : index + 8], 2)\n        for index in range(0, len(binary_stream), 8)\n    ]\n\n    return bytes(data)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/mixed_keyword_cypher.py": "from string import ascii_uppercase\n\n\ndef mixed_keyword(\n    keyword: str, plaintext: str, verbose: bool = False, alphabet: str = ascii_uppercase\n) -> str:\n    \"\"\"\n    For keyword: hello\n\n    H E L O\n    A B C D\n    F G I J\n    K M N P\n    Q R S T\n    U V W X\n    Y Z\n    and map vertically\n\n    >>> mixed_keyword(\"college\", \"UNIVERSITY\", True)  # doctest: +NORMALIZE_WHITESPACE\n    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',\n     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',\n     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',\n     'Y': 'T', 'Z': 'Y'}\n    'XKJGUFMJST'\n\n    >>> mixed_keyword(\"college\", \"UNIVERSITY\", False)  # doctest: +NORMALIZE_WHITESPACE\n    'XKJGUFMJST'\n    \"\"\"\n    keyword = keyword.upper()\n    plaintext = plaintext.upper()\n    alphabet_set = set(alphabet)\n\n    # create a list of unique characters in the keyword - their order matters\n    # it determines how we will map plaintext characters to the ciphertext\n    unique_chars = []\n    for char in keyword:\n        if char in alphabet_set and char not in unique_chars:\n            unique_chars.append(char)\n    # the number of those unique characters will determine the number of rows\n    num_unique_chars_in_keyword = len(unique_chars)\n\n    # create a shifted version of the alphabet\n    shifted_alphabet = unique_chars + [\n        char for char in alphabet if char not in unique_chars\n    ]\n\n    # create a modified alphabet by splitting the shifted alphabet into rows\n    modified_alphabet = [\n        shifted_alphabet[k : k + num_unique_chars_in_keyword]\n        for k in range(0, 26, num_unique_chars_in_keyword)\n    ]\n\n    # map the alphabet characters to the modified alphabet characters\n    # going 'vertically' through the modified alphabet - consider columns first\n    mapping = {}\n    letter_index = 0\n    for column in range(num_unique_chars_in_keyword):\n        for row in modified_alphabet:\n            # if current row (the last one) is too short, break out of loop\n            if len(row) <= column:\n                break\n\n            # map current letter to letter in modified alphabet\n            mapping[alphabet[letter_index]] = row[column]\n            letter_index += 1\n\n    if verbose:\n        print(mapping)\n    # create the encrypted text by mapping the plaintext to the modified alphabet\n    return \"\".join(mapping.get(char, char) for char in plaintext)\n\n\nif __name__ == \"__main__\":\n    # example use\n    print(mixed_keyword(\"college\", \"UNIVERSITY\"))\n", "ciphers/hill_cipher.py": "\"\"\"\n\nHill Cipher:\nThe 'HillCipher' class below implements the Hill Cipher algorithm which uses\nmodern linear algebra techniques to encode and decode text using an encryption\nkey matrix.\n\nAlgorithm:\nLet the order of the encryption key be N (as it is a square matrix).\nYour text is divided into batches of length N and converted to numerical vectors\nby a simple mapping starting with A=0 and so on.\n\nThe key is then multiplied with the newly created batch vector to obtain the\nencoded vector. After each multiplication modular 36 calculations are performed\non the vectors so as to bring the numbers between 0 and 36 and then mapped with\ntheir corresponding alphanumerics.\n\nWhile decrypting, the decrypting key is found which is the inverse of the\nencrypting key modular 36. The same process is repeated for decrypting to get\nthe original message back.\n\nConstraints:\nThe determinant of the encryption key matrix must be relatively prime w.r.t 36.\n\nNote:\nThis implementation only considers alphanumerics in the text.  If the length of\nthe text to be encrypted is not a multiple of the break key(the length of one\nbatch of letters), the last character of the text is added to the text until the\nlength of the text reaches a multiple of the break_key. So the text after\ndecrypting might be a little different than the original text.\n\nReferences:\nhttps://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf\nhttps://www.youtube.com/watch?v=kfmNeskzs2o\nhttps://www.youtube.com/watch?v=4RhLNDqcjpA\n\n\"\"\"\n\nimport string\n\nimport numpy as np\n\nfrom maths.greatest_common_divisor import greatest_common_divisor\n\n\nclass HillCipher:\n    key_string = string.ascii_uppercase + string.digits\n    # This cipher takes alphanumerics into account\n    # i.e. a total of 36 characters\n\n    # take x and return x % len(key_string)\n    modulus = np.vectorize(lambda x: x % 36)\n\n    to_int = np.vectorize(round)\n\n    def __init__(self, encrypt_key: np.ndarray) -> None:\n        \"\"\"\n        encrypt_key is an NxN numpy array\n        \"\"\"\n        self.encrypt_key = self.modulus(encrypt_key)  # mod36 calc's on the encrypt key\n        self.check_determinant()  # validate the determinant of the encryption key\n        self.break_key = encrypt_key.shape[0]\n\n    def replace_letters(self, letter: str) -> int:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.replace_letters('T')\n        19\n        >>> hill_cipher.replace_letters('0')\n        26\n        \"\"\"\n        return self.key_string.index(letter)\n\n    def replace_digits(self, num: int) -> str:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.replace_digits(19)\n        'T'\n        >>> hill_cipher.replace_digits(26)\n        '0'\n        \"\"\"\n        return self.key_string[round(num)]\n\n    def check_determinant(self) -> None:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.check_determinant()\n        \"\"\"\n        det = round(np.linalg.det(self.encrypt_key))\n\n        if det < 0:\n            det = det % len(self.key_string)\n\n        req_l = len(self.key_string)\n        if greatest_common_divisor(det, len(self.key_string)) != 1:\n            msg = (\n                f\"determinant modular {req_l} of encryption key({det}) \"\n                f\"is not co prime w.r.t {req_l}.\\nTry another key.\"\n            )\n            raise ValueError(msg)\n\n    def process_text(self, text: str) -> str:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.process_text('Testing Hill Cipher')\n        'TESTINGHILLCIPHERR'\n        >>> hill_cipher.process_text('hello')\n        'HELLOO'\n        \"\"\"\n        chars = [char for char in text.upper() if char in self.key_string]\n\n        last = chars[-1]\n        while len(chars) % self.break_key != 0:\n            chars.append(last)\n\n        return \"\".join(chars)\n\n    def encrypt(self, text: str) -> str:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.encrypt('testing hill cipher')\n        'WHXYJOLM9C6XT085LL'\n        >>> hill_cipher.encrypt('hello')\n        '85FF00'\n        \"\"\"\n        text = self.process_text(text.upper())\n        encrypted = \"\"\n\n        for i in range(0, len(text) - self.break_key + 1, self.break_key):\n            batch = text[i : i + self.break_key]\n            vec = [self.replace_letters(char) for char in batch]\n            batch_vec = np.array([vec]).T\n            batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[\n                0\n            ]\n            encrypted_batch = \"\".join(\n                self.replace_digits(num) for num in batch_encrypted\n            )\n            encrypted += encrypted_batch\n\n        return encrypted\n\n    def make_decrypt_key(self) -> np.ndarray:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.make_decrypt_key()\n        array([[ 6, 25],\n               [ 5, 26]])\n        \"\"\"\n        det = round(np.linalg.det(self.encrypt_key))\n\n        if det < 0:\n            det = det % len(self.key_string)\n        det_inv = None\n        for i in range(len(self.key_string)):\n            if (det * i) % len(self.key_string) == 1:\n                det_inv = i\n                break\n\n        inv_key = (\n            det_inv * np.linalg.det(self.encrypt_key) * np.linalg.inv(self.encrypt_key)\n        )\n\n        return self.to_int(self.modulus(inv_key))\n\n    def decrypt(self, text: str) -> str:\n        \"\"\"\n        >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))\n        >>> hill_cipher.decrypt('WHXYJOLM9C6XT085LL')\n        'TESTINGHILLCIPHERR'\n        >>> hill_cipher.decrypt('85FF00')\n        'HELLOO'\n        \"\"\"\n        decrypt_key = self.make_decrypt_key()\n        text = self.process_text(text.upper())\n        decrypted = \"\"\n\n        for i in range(0, len(text) - self.break_key + 1, self.break_key):\n            batch = text[i : i + self.break_key]\n            vec = [self.replace_letters(char) for char in batch]\n            batch_vec = np.array([vec]).T\n            batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[0]\n            decrypted_batch = \"\".join(\n                self.replace_digits(num) for num in batch_decrypted\n            )\n            decrypted += decrypted_batch\n\n        return decrypted\n\n\ndef main() -> None:\n    n = int(input(\"Enter the order of the encryption key: \"))\n    hill_matrix = []\n\n    print(\"Enter each row of the encryption key with space separated integers\")\n    for _ in range(n):\n        row = [int(x) for x in input().split()]\n        hill_matrix.append(row)\n\n    hc = HillCipher(np.array(hill_matrix))\n\n    print(\"Would you like to encrypt or decrypt some text? (1 or 2)\")\n    option = input(\"\\n1. Encrypt\\n2. Decrypt\\n\")\n    if option == \"1\":\n        text_e = input(\"What text would you like to encrypt?: \")\n        print(\"Your encrypted text is:\")\n        print(hc.encrypt(text_e))\n    elif option == \"2\":\n        text_d = input(\"What text would you like to decrypt?: \")\n        print(\"Your decrypted text is:\")\n        print(hc.decrypt(text_d))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    main()\n", "ciphers/transposition_cipher_encrypt_decrypt_file.py": "import os\nimport sys\nimport time\n\nfrom . import transposition_cipher as trans_cipher\n\n\ndef main() -> None:\n    input_file = \"./prehistoric_men.txt\"\n    output_file = \"./Output.txt\"\n    key = int(input(\"Enter key: \"))\n    mode = input(\"Encrypt/Decrypt [e/d]: \")\n\n    if not os.path.exists(input_file):\n        print(f\"File {input_file} does not exist. Quitting...\")\n        sys.exit()\n    if os.path.exists(output_file):\n        print(f\"Overwrite {output_file}? [y/n]\")\n        response = input(\"> \")\n        if not response.lower().startswith(\"y\"):\n            sys.exit()\n\n    start_time = time.time()\n    if mode.lower().startswith(\"e\"):\n        with open(input_file) as f:\n            content = f.read()\n        translated = trans_cipher.encrypt_message(key, content)\n    elif mode.lower().startswith(\"d\"):\n        with open(output_file) as f:\n            content = f.read()\n        translated = trans_cipher.decrypt_message(key, content)\n\n    with open(output_file, \"w\") as output_obj:\n        output_obj.write(translated)\n\n    total_time = round(time.time() - start_time, 2)\n    print((\"Done (\", total_time, \"seconds )\"))\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/rabin_miller.py": "# Primality Testing with the Rabin-Miller Algorithm\n\nimport random\n\n\ndef rabin_miller(num: int) -> bool:\n    s = num - 1\n    t = 0\n\n    while s % 2 == 0:\n        s = s // 2\n        t += 1\n\n    for _ in range(5):\n        a = random.randrange(2, num - 1)\n        v = pow(a, s, num)\n        if v != 1:\n            i = 0\n            while v != (num - 1):\n                if i == t - 1:\n                    return False\n                else:\n                    i = i + 1\n                    v = (v**2) % num\n    return True\n\n\ndef is_prime_low_num(num: int) -> bool:\n    if num < 2:\n        return False\n\n    low_primes = [\n        2,\n        3,\n        5,\n        7,\n        11,\n        13,\n        17,\n        19,\n        23,\n        29,\n        31,\n        37,\n        41,\n        43,\n        47,\n        53,\n        59,\n        61,\n        67,\n        71,\n        73,\n        79,\n        83,\n        89,\n        97,\n        101,\n        103,\n        107,\n        109,\n        113,\n        127,\n        131,\n        137,\n        139,\n        149,\n        151,\n        157,\n        163,\n        167,\n        173,\n        179,\n        181,\n        191,\n        193,\n        197,\n        199,\n        211,\n        223,\n        227,\n        229,\n        233,\n        239,\n        241,\n        251,\n        257,\n        263,\n        269,\n        271,\n        277,\n        281,\n        283,\n        293,\n        307,\n        311,\n        313,\n        317,\n        331,\n        337,\n        347,\n        349,\n        353,\n        359,\n        367,\n        373,\n        379,\n        383,\n        389,\n        397,\n        401,\n        409,\n        419,\n        421,\n        431,\n        433,\n        439,\n        443,\n        449,\n        457,\n        461,\n        463,\n        467,\n        479,\n        487,\n        491,\n        499,\n        503,\n        509,\n        521,\n        523,\n        541,\n        547,\n        557,\n        563,\n        569,\n        571,\n        577,\n        587,\n        593,\n        599,\n        601,\n        607,\n        613,\n        617,\n        619,\n        631,\n        641,\n        643,\n        647,\n        653,\n        659,\n        661,\n        673,\n        677,\n        683,\n        691,\n        701,\n        709,\n        719,\n        727,\n        733,\n        739,\n        743,\n        751,\n        757,\n        761,\n        769,\n        773,\n        787,\n        797,\n        809,\n        811,\n        821,\n        823,\n        827,\n        829,\n        839,\n        853,\n        857,\n        859,\n        863,\n        877,\n        881,\n        883,\n        887,\n        907,\n        911,\n        919,\n        929,\n        937,\n        941,\n        947,\n        953,\n        967,\n        971,\n        977,\n        983,\n        991,\n        997,\n    ]\n\n    if num in low_primes:\n        return True\n\n    for prime in low_primes:\n        if (num % prime) == 0:\n            return False\n\n    return rabin_miller(num)\n\n\ndef generate_large_prime(keysize: int = 1024) -> int:\n    while True:\n        num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))\n        if is_prime_low_num(num):\n            return num\n\n\nif __name__ == \"__main__\":\n    num = generate_large_prime()\n    print((\"Prime number:\", num))\n    print((\"is_prime_low_num:\", is_prime_low_num(num)))\n", "ciphers/rsa_key_generator.py": "import os\nimport random\nimport sys\n\nfrom maths.greatest_common_divisor import gcd_by_iterative\n\nfrom . import cryptomath_module, rabin_miller\n\n\ndef main() -> None:\n    print(\"Making key files...\")\n    make_key_files(\"rsa\", 1024)\n    print(\"Key files generation successful.\")\n\n\ndef generate_key(key_size: int) -> tuple[tuple[int, int], tuple[int, int]]:\n    \"\"\"\n    >>> random.seed(0) # for repeatability\n    >>> public_key, private_key = generate_key(8)\n    >>> public_key\n    (26569, 239)\n    >>> private_key\n    (26569, 2855)\n    \"\"\"\n    p = rabin_miller.generate_large_prime(key_size)\n    q = rabin_miller.generate_large_prime(key_size)\n    n = p * q\n\n    # Generate e that is relatively prime to (p - 1) * (q - 1)\n    while True:\n        e = random.randrange(2 ** (key_size - 1), 2 ** (key_size))\n        if gcd_by_iterative(e, (p - 1) * (q - 1)) == 1:\n            break\n\n    # Calculate d that is mod inverse of e\n    d = cryptomath_module.find_mod_inverse(e, (p - 1) * (q - 1))\n\n    public_key = (n, e)\n    private_key = (n, d)\n    return (public_key, private_key)\n\n\ndef make_key_files(name: str, key_size: int) -> None:\n    if os.path.exists(f\"{name}_pubkey.txt\") or os.path.exists(f\"{name}_privkey.txt\"):\n        print(\"\\nWARNING:\")\n        print(\n            f'\"{name}_pubkey.txt\" or \"{name}_privkey.txt\" already exists. \\n'\n            \"Use a different name or delete these files and re-run this program.\"\n        )\n        sys.exit()\n\n    public_key, private_key = generate_key(key_size)\n    print(f\"\\nWriting public key to file {name}_pubkey.txt...\")\n    with open(f\"{name}_pubkey.txt\", \"w\") as out_file:\n        out_file.write(f\"{key_size},{public_key[0]},{public_key[1]}\")\n\n    print(f\"Writing private key to file {name}_privkey.txt...\")\n    with open(f\"{name}_privkey.txt\", \"w\") as out_file:\n        out_file.write(f\"{key_size},{private_key[0]},{private_key[1]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/diffie_hellman.py": "from binascii import hexlify\nfrom hashlib import sha256\nfrom os import urandom\n\n# RFC 3526 - More Modular Exponential (MODP) Diffie-Hellman groups for\n# Internet Key Exchange (IKE) https://tools.ietf.org/html/rfc3526\n\nprimes = {\n    # 1536-bit\n    5: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n            \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n            \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n            \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n            \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n            \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n            \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n    # 2048-bit\n    14: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n            \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n            \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n            \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n            \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n            \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n            \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\"\n            \"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\"\n            \"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\"\n            \"15728E5A8AACAA68FFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n    # 3072-bit\n    15: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n            \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n            \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n            \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n            \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n            \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n            \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\"\n            \"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\"\n            \"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\"\n            \"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\"\n            \"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\"\n            \"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\"\n            \"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\"\n            \"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\"\n            \"43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n    # 4096-bit\n    16: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n            \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n            \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n            \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n            \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n            \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n            \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\"\n            \"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\"\n            \"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\"\n            \"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\"\n            \"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\"\n            \"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\"\n            \"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\"\n            \"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\"\n            \"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7\"\n            \"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA\"\n            \"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6\"\n            \"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED\"\n            \"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9\"\n            \"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199\"\n            \"FFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n    # 6144-bit\n    17: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\"\n            \"8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\"\n            \"302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\"\n            \"A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\"\n            \"49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\"\n            \"FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\"\n            \"180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\"\n            \"3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\"\n            \"04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\"\n            \"B3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\"\n            \"1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\"\n            \"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\"\n            \"E0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\"\n            \"99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\"\n            \"04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\"\n            \"233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\"\n            \"D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\"\n            \"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406\"\n            \"AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918\"\n            \"DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151\"\n            \"2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03\"\n            \"F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F\"\n            \"BEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\"\n            \"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B\"\n            \"B7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632\"\n            \"387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E\"\n            \"6DCC4024FFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n    # 8192-bit\n    18: {\n        \"prime\": int(\n            \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n            \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n            \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n            \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n            \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n            \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n            \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n            \"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B\"\n            \"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9\"\n            \"DE2BCBF6955817183995497CEA956AE515D2261898FA0510\"\n            \"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64\"\n            \"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7\"\n            \"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B\"\n            \"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C\"\n            \"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31\"\n            \"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7\"\n            \"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA\"\n            \"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6\"\n            \"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED\"\n            \"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9\"\n            \"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\"\n            \"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD\"\n            \"F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831\"\n            \"179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B\"\n            \"DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF\"\n            \"5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6\"\n            \"D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3\"\n            \"23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\"\n            \"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328\"\n            \"06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C\"\n            \"DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE\"\n            \"12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4\"\n            \"38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300\"\n            \"741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568\"\n            \"3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9\"\n            \"22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B\"\n            \"4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A\"\n            \"062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36\"\n            \"4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1\"\n            \"B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92\"\n            \"4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47\"\n            \"9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71\"\n            \"60C980DD98EDD3DFFFFFFFFFFFFFFFFF\",\n            base=16,\n        ),\n        \"generator\": 2,\n    },\n}\n\n\nclass DiffieHellman:\n    \"\"\"\n    Class to represent the Diffie-Hellman key exchange protocol\n\n\n    >>> alice = DiffieHellman()\n    >>> bob = DiffieHellman()\n\n    >>> alice_private = alice.get_private_key()\n    >>> alice_public = alice.generate_public_key()\n\n    >>> bob_private = bob.get_private_key()\n    >>> bob_public = bob.generate_public_key()\n\n    >>> # generating shared key using the DH object\n    >>> alice_shared = alice.generate_shared_key(bob_public)\n    >>> bob_shared = bob.generate_shared_key(alice_public)\n\n    >>> assert alice_shared == bob_shared\n\n    >>> # generating shared key using static methods\n    >>> alice_shared = DiffieHellman.generate_shared_key_static(\n    ...     alice_private, bob_public\n    ... )\n    >>> bob_shared = DiffieHellman.generate_shared_key_static(\n    ...     bob_private, alice_public\n    ... )\n\n    >>> assert alice_shared == bob_shared\n    \"\"\"\n\n    # Current minimum recommendation is 2048 bit (group 14)\n    def __init__(self, group: int = 14) -> None:\n        if group not in primes:\n            raise ValueError(\"Unsupported Group\")\n        self.prime = primes[group][\"prime\"]\n        self.generator = primes[group][\"generator\"]\n\n        self.__private_key = int(hexlify(urandom(32)), base=16)\n\n    def get_private_key(self) -> str:\n        return hex(self.__private_key)[2:]\n\n    def generate_public_key(self) -> str:\n        public_key = pow(self.generator, self.__private_key, self.prime)\n        return hex(public_key)[2:]\n\n    def is_valid_public_key(self, key: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n        return (\n            2 <= key <= self.prime - 2\n            and pow(key, (self.prime - 1) // 2, self.prime) == 1\n        )\n\n    def generate_shared_key(self, other_key_str: str) -> str:\n        other_key = int(other_key_str, base=16)\n        if not self.is_valid_public_key(other_key):\n            raise ValueError(\"Invalid public key\")\n        shared_key = pow(other_key, self.__private_key, self.prime)\n        return sha256(str(shared_key).encode()).hexdigest()\n\n    @staticmethod\n    def is_valid_public_key_static(remote_public_key_str: int, prime: int) -> bool:\n        # check if the other public key is valid based on NIST SP800-56\n        return (\n            2 <= remote_public_key_str <= prime - 2\n            and pow(remote_public_key_str, (prime - 1) // 2, prime) == 1\n        )\n\n    @staticmethod\n    def generate_shared_key_static(\n        local_private_key_str: str, remote_public_key_str: str, group: int = 14\n    ) -> str:\n        local_private_key = int(local_private_key_str, base=16)\n        remote_public_key = int(remote_public_key_str, base=16)\n        prime = primes[group][\"prime\"]\n        if not DiffieHellman.is_valid_public_key_static(remote_public_key, prime):\n            raise ValueError(\"Invalid public key\")\n        shared_key = pow(remote_public_key, local_private_key, prime)\n        return sha256(str(shared_key).encode()).hexdigest()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/base32.py": "\"\"\"\nBase32 encoding and decoding\n\nhttps://en.wikipedia.org/wiki/Base32\n\"\"\"\n\nB32_CHARSET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n\n\ndef base32_encode(data: bytes) -> bytes:\n    \"\"\"\n    >>> base32_encode(b\"Hello World!\")\n    b'JBSWY3DPEBLW64TMMQQQ===='\n    >>> base32_encode(b\"123456\")\n    b'GEZDGNBVGY======'\n    >>> base32_encode(b\"some long complex string\")\n    b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='\n    \"\"\"\n    binary_data = \"\".join(bin(ord(d))[2:].zfill(8) for d in data.decode(\"utf-8\"))\n    binary_data = binary_data.ljust(5 * ((len(binary_data) // 5) + 1), \"0\")\n    b32_chunks = map(\"\".join, zip(*[iter(binary_data)] * 5))\n    b32_result = \"\".join(B32_CHARSET[int(chunk, 2)] for chunk in b32_chunks)\n    return bytes(b32_result.ljust(8 * ((len(b32_result) // 8) + 1), \"=\"), \"utf-8\")\n\n\ndef base32_decode(data: bytes) -> bytes:\n    \"\"\"\n    >>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')\n    b'Hello World!'\n    >>> base32_decode(b'GEZDGNBVGY======')\n    b'123456'\n    >>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')\n    b'some long complex string'\n    \"\"\"\n    binary_chunks = \"\".join(\n        bin(B32_CHARSET.index(_d))[2:].zfill(5)\n        for _d in data.decode(\"utf-8\").strip(\"=\")\n    )\n    binary_data = list(map(\"\".join, zip(*[iter(binary_chunks)] * 8)))\n    return bytes(\"\".join([chr(int(_d, 2)) for _d in binary_data]), \"utf-8\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/cryptomath_module.py": "from maths.greatest_common_divisor import gcd_by_iterative\n\n\ndef find_mod_inverse(a: int, m: int) -> int:\n    if gcd_by_iterative(a, m) != 1:\n        msg = f\"mod inverse of {a!r} and {m!r} does not exist\"\n        raise ValueError(msg)\n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    while v3 != 0:\n        q = u3 // v3\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    return u1 % m\n", "ciphers/polybius.py": "#!/usr/bin/env python3\n\n\"\"\"\nA Polybius Square is a table that allows someone to translate letters into numbers.\n\nhttps://www.braingle.com/brainteasers/codes/polybius.php\n\"\"\"\n\nimport numpy as np\n\nSQUARE = [\n    [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    [\"f\", \"g\", \"h\", \"i\", \"k\"],\n    [\"l\", \"m\", \"n\", \"o\", \"p\"],\n    [\"q\", \"r\", \"s\", \"t\", \"u\"],\n    [\"v\", \"w\", \"x\", \"y\", \"z\"],\n]\n\n\nclass PolybiusCipher:\n    def __init__(self) -> None:\n        self.SQUARE = np.array(SQUARE)\n\n    def letter_to_numbers(self, letter: str) -> np.ndarray:\n        \"\"\"\n        Return the pair of numbers that represents the given letter in the\n        polybius square\n        >>> np.array_equal(PolybiusCipher().letter_to_numbers('a'), [1,1])\n        True\n\n        >>> np.array_equal(PolybiusCipher().letter_to_numbers('u'), [4,5])\n        True\n        \"\"\"\n        index1, index2 = np.where(letter == self.SQUARE)\n        indexes = np.concatenate([index1 + 1, index2 + 1])\n        return indexes\n\n    def numbers_to_letter(self, index1: int, index2: int) -> str:\n        \"\"\"\n        Return the letter corresponding to the position [index1, index2] in\n        the polybius square\n\n        >>> PolybiusCipher().numbers_to_letter(4, 5) == \"u\"\n        True\n\n        >>> PolybiusCipher().numbers_to_letter(1, 1) == \"a\"\n        True\n        \"\"\"\n        return self.SQUARE[index1 - 1, index2 - 1]\n\n    def encode(self, message: str) -> str:\n        \"\"\"\n        Return the encoded version of message according to the polybius cipher\n\n        >>> PolybiusCipher().encode(\"test message\") == \"44154344 32154343112215\"\n        True\n\n        >>> PolybiusCipher().encode(\"Test Message\") == \"44154344 32154343112215\"\n        True\n        \"\"\"\n        message = message.lower()\n        message = message.replace(\"j\", \"i\")\n\n        encoded_message = \"\"\n        for letter_index in range(len(message)):\n            if message[letter_index] != \" \":\n                numbers = self.letter_to_numbers(message[letter_index])\n                encoded_message = encoded_message + str(numbers[0]) + str(numbers[1])\n            elif message[letter_index] == \" \":\n                encoded_message = encoded_message + \" \"\n\n        return encoded_message\n\n    def decode(self, message: str) -> str:\n        \"\"\"\n        Return the decoded version of message according to the polybius cipher\n\n        >>> PolybiusCipher().decode(\"44154344 32154343112215\") == \"test message\"\n        True\n\n        >>> PolybiusCipher().decode(\"4415434432154343112215\") == \"testmessage\"\n        True\n        \"\"\"\n        message = message.replace(\" \", \"  \")\n        decoded_message = \"\"\n        for numbers_index in range(int(len(message) / 2)):\n            if message[numbers_index * 2] != \" \":\n                index1 = message[numbers_index * 2]\n                index2 = message[numbers_index * 2 + 1]\n\n                letter = self.numbers_to_letter(int(index1), int(index2))\n                decoded_message = decoded_message + letter\n            elif message[numbers_index * 2] == \" \":\n                decoded_message = decoded_message + \" \"\n\n        return decoded_message\n", "ciphers/transposition_cipher.py": "import math\n\n\"\"\"\nIn cryptography, the TRANSPOSITION cipher is a method of encryption where the\npositions of plaintext are shifted a certain number(determined by the key) that\nfollows a regular system that results in the permuted text, known as the encrypted\ntext. The type of transposition cipher demonstrated under is the ROUTE cipher.\n\"\"\"\n\n\ndef main() -> None:\n    message = input(\"Enter message: \")\n    key = int(input(f\"Enter key [2-{len(message) - 1}]: \"))\n    mode = input(\"Encryption/Decryption [e/d]: \")\n\n    if mode.lower().startswith(\"e\"):\n        text = encrypt_message(key, message)\n    elif mode.lower().startswith(\"d\"):\n        text = decrypt_message(key, message)\n\n    # Append pipe symbol (vertical bar) to identify spaces at the end.\n    print(f\"Output:\\n{text + '|'}\")\n\n\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(6, 'Harshil Darji')\n    'Hlia rDsahrij'\n    \"\"\"\n    cipher_text = [\"\"] * key\n    for col in range(key):\n        pointer = col\n        while pointer < len(message):\n            cipher_text[col] += message[pointer]\n            pointer += key\n    return \"\".join(cipher_text)\n\n\ndef decrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(6, 'Hlia rDsahrij')\n    'Harshil Darji'\n    \"\"\"\n    num_cols = math.ceil(len(message) / key)\n    num_rows = key\n    num_shaded_boxes = (num_cols * num_rows) - len(message)\n    plain_text = [\"\"] * num_cols\n    col = 0\n    row = 0\n\n    for symbol in message:\n        plain_text[col] += symbol\n        col += 1\n\n        if (\n            (col == num_cols)\n            or (col == num_cols - 1)\n            and (row >= num_rows - num_shaded_boxes)\n        ):\n            col = 0\n            row += 1\n\n    return \"\".join(plain_text)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/a1z26.py": "\"\"\"\nConvert a string of characters to a sequence of numbers\ncorresponding to the character's position in the alphabet.\n\nhttps://www.dcode.fr/letter-number-cipher\nhttp://bestcodes.weebly.com/a1z26.html\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]\n\n\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)\n\n\ndef main() -> None:\n    encoded = encode(input(\"-> \").strip().lower())\n    print(\"Encoded: \", encoded)\n    print(\"Decoded:\", decode(encoded))\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/vigenere_cipher.py": "LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef main() -> None:\n    message = input(\"Enter message: \")\n    key = input(\"Enter key [alphanumeric]: \")\n    mode = input(\"Encrypt/Decrypt [e/d]: \")\n\n    if mode.lower().startswith(\"e\"):\n        mode = \"encrypt\"\n        translated = encrypt_message(key, message)\n    elif mode.lower().startswith(\"d\"):\n        mode = \"decrypt\"\n        translated = decrypt_message(key, message)\n\n    print(f\"\\n{mode.title()}ed message:\")\n    print(translated)\n\n\ndef encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.')\n    'Akij ra Odrjqqs Gaisq muod Mphumrs.'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")\n\n\ndef decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')\n    'This is Harshil Darji from Dharmaj.'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")\n\n\ndef translate_message(key: str, message: str, mode: str) -> str:\n    translated = []\n    key_index = 0\n    key = key.upper()\n\n    for symbol in message:\n        num = LETTERS.find(symbol.upper())\n        if num != -1:\n            if mode == \"encrypt\":\n                num += LETTERS.find(key[key_index])\n            elif mode == \"decrypt\":\n                num -= LETTERS.find(key[key_index])\n\n            num %= len(LETTERS)\n\n            if symbol.isupper():\n                translated.append(LETTERS[num])\n            elif symbol.islower():\n                translated.append(LETTERS[num].lower())\n\n            key_index += 1\n            if key_index == len(key):\n                key_index = 0\n        else:\n            translated.append(symbol)\n    return \"\".join(translated)\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/shuffled_shift_cipher.py": "from __future__ import annotations\n\nimport random\nimport string\n\n\nclass ShuffledShiftCipher:\n    \"\"\"\n    This algorithm uses the Caesar Cipher algorithm but removes the option to\n    use brute force to decrypt the message.\n\n    The passcode is a random password from the selection buffer of\n    1. uppercase letters of the English alphabet\n    2. lowercase letters of the English alphabet\n    3. digits from 0 to 9\n\n    Using unique characters from the passcode, the normal list of characters,\n    that can be allowed in the plaintext, is pivoted and shuffled. Refer to docstring\n    of __make_key_list() to learn more about the shuffling.\n\n    Then, using the passcode, a number is calculated which is used to encrypt the\n    plaintext message with the normal shift cipher method, only in this case, the\n    reference, to look back at while decrypting, is shuffled.\n\n    Each cipher object can possess an optional argument as passcode, without which a\n    new passcode is generated for that object automatically.\n    cip1 = ShuffledShiftCipher('d4usr9TWxw9wMD')\n    cip2 = ShuffledShiftCipher()\n    \"\"\"\n\n    def __init__(self, passcode: str | None = None) -> None:\n        \"\"\"\n        Initializes a cipher object with a passcode as it's entity\n        Note: No new passcode is generated if user provides a passcode\n        while creating the object\n        \"\"\"\n        self.__passcode = passcode or self.__passcode_creator()\n        self.__key_list = self.__make_key_list()\n        self.__shift_key = self.__make_shift_key()\n\n    def __str__(self) -> str:\n        \"\"\"\n        :return: passcode of the cipher object\n        \"\"\"\n        return \"\".join(self.__passcode)\n\n    def __neg_pos(self, iterlist: list[int]) -> list[int]:\n        \"\"\"\n        Mutates the list by changing the sign of each alternate element\n\n        :param iterlist: takes a list iterable\n        :return: the mutated list\n\n        \"\"\"\n        for i in range(1, len(iterlist), 2):\n            iterlist[i] *= -1\n        return iterlist\n\n    def __passcode_creator(self) -> list[str]:\n        \"\"\"\n        Creates a random password from the selection buffer of\n        1. uppercase letters of the English alphabet\n        2. lowercase letters of the English alphabet\n        3. digits from 0 to 9\n\n        :rtype: list\n        :return: a password of a random length between 10 to 20\n        \"\"\"\n        choices = string.ascii_letters + string.digits\n        password = [random.choice(choices) for _ in range(random.randint(10, 20))]\n        return password\n\n    def __make_key_list(self) -> list[str]:\n        \"\"\"\n        Shuffles the ordered character choices by pivoting at breakpoints\n        Breakpoints are the set of characters in the passcode\n\n        eg:\n            if, ABCDEFGHIJKLMNOPQRSTUVWXYZ are the possible characters\n            and CAMERA is the passcode\n            then, breakpoints = [A,C,E,M,R] # sorted set of characters from passcode\n            shuffled parts: [A,CB,ED,MLKJIHGF,RQPON,ZYXWVUTS]\n            shuffled __key_list : ACBEDMLKJIHGFRQPONZYXWVUTS\n\n        Shuffling only 26 letters of the english alphabet can generate 26!\n        combinations for the shuffled list. In the program we consider, a set of\n        97 characters (including letters, digits, punctuation and whitespaces),\n        thereby creating a possibility of 97! combinations (which is a 152 digit number\n        in itself), thus diminishing the possibility of a brute force approach.\n        Moreover, shift keys even introduce a multiple of 26 for a brute force approach\n        for each of the already 97! combinations.\n        \"\"\"\n        # key_list_options contain nearly all printable except few elements from\n        # string.whitespace\n        key_list_options = (\n            string.ascii_letters + string.digits + string.punctuation + \" \\t\\n\"\n        )\n\n        keys_l = []\n\n        # creates points known as breakpoints to break the key_list_options at those\n        # points and pivot each substring\n        breakpoints = sorted(set(self.__passcode))\n        temp_list: list[str] = []\n\n        # algorithm for creating a new shuffled list, keys_l, out of key_list_options\n        for i in key_list_options:\n            temp_list.extend(i)\n\n            # checking breakpoints at which to pivot temporary sublist and add it into\n            # keys_l\n            if i in breakpoints or i == key_list_options[-1]:\n                keys_l.extend(temp_list[::-1])\n                temp_list.clear()\n\n        # returning a shuffled keys_l to prevent brute force guessing of shift key\n        return keys_l\n\n    def __make_shift_key(self) -> int:\n        \"\"\"\n        sum() of the mutated list of ascii values of all characters where the\n        mutated list is the one returned by __neg_pos()\n        \"\"\"\n        num = sum(self.__neg_pos([ord(x) for x in self.__passcode]))\n        return num if num > 0 else len(self.__passcode)\n\n    def decrypt(self, encoded_message: str) -> str:\n        \"\"\"\n        Performs shifting of the encoded_message w.r.t. the shuffled __key_list\n        to create the decoded_message\n\n        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')\n        >>> ssc.decrypt(\"d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#\")\n        'Hello, this is a modified Caesar cipher'\n\n        \"\"\"\n        decoded_message = \"\"\n\n        # decoding shift like Caesar cipher algorithm implementing negative shift or\n        # reverse shift or left shift\n        for i in encoded_message:\n            position = self.__key_list.index(i)\n            decoded_message += self.__key_list[\n                (position - self.__shift_key) % -len(self.__key_list)\n            ]\n\n        return decoded_message\n\n    def encrypt(self, plaintext: str) -> str:\n        \"\"\"\n        Performs shifting of the plaintext w.r.t. the shuffled __key_list\n        to create the encoded_message\n\n        >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')\n        >>> ssc.encrypt('Hello, this is a modified Caesar cipher')\n        \"d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#\"\n\n        \"\"\"\n        encoded_message = \"\"\n\n        # encoding shift like Caesar cipher algorithm implementing positive shift or\n        # forward shift or right shift\n        for i in plaintext:\n            position = self.__key_list.index(i)\n            encoded_message += self.__key_list[\n                (position + self.__shift_key) % len(self.__key_list)\n            ]\n\n        return encoded_message\n\n\ndef test_end_to_end(msg: str = \"Hello, this is a modified Caesar cipher\") -> str:\n    \"\"\"\n    >>> test_end_to_end()\n    'Hello, this is a modified Caesar cipher'\n    \"\"\"\n    cip1 = ShuffledShiftCipher()\n    return cip1.decrypt(cip1.encrypt(msg))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/affine_cipher.py": "import random\nimport sys\n\nfrom maths.greatest_common_divisor import gcd_by_iterative\n\nfrom . import cryptomath_module as cryptomath\n\nSYMBOLS = (\n    r\"\"\" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`\"\"\"\n    r\"\"\"abcdefghijklmnopqrstuvwxyz{|}~\"\"\"\n)\n\n\ndef check_keys(key_a: int, key_b: int, mode: str) -> None:\n    if mode == \"encrypt\":\n        if key_a == 1:\n            sys.exit(\n                \"The affine cipher becomes weak when key \"\n                \"A is set to 1. Choose different key\"\n            )\n        if key_b == 0:\n            sys.exit(\n                \"The affine cipher becomes weak when key \"\n                \"B is set to 0. Choose different key\"\n            )\n    if key_a < 0 or key_b < 0 or key_b > len(SYMBOLS) - 1:\n        sys.exit(\n            \"Key A must be greater than 0 and key B must \"\n            f\"be between 0 and {len(SYMBOLS) - 1}.\"\n        )\n    if gcd_by_iterative(key_a, len(SYMBOLS)) != 1:\n        sys.exit(\n            f\"Key A {key_a} and the symbol set size {len(SYMBOLS)} \"\n            \"are not relatively prime. Choose a different key.\"\n        )\n\n\ndef encrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '\n    ...                       'substitution cipher.')\n    'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'\n    \"\"\"\n    key_a, key_b = divmod(key, len(SYMBOLS))\n    check_keys(key_a, key_b, \"encrypt\")\n    cipher_text = \"\"\n    for symbol in message:\n        if symbol in SYMBOLS:\n            sym_index = SYMBOLS.find(symbol)\n            cipher_text += SYMBOLS[(sym_index * key_a + key_b) % len(SYMBOLS)]\n        else:\n            cipher_text += symbol\n    return cipher_text\n\n\ndef decrypt_message(key: int, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'\n    ...                       '{xIp~{HL}Gi')\n    'The affine cipher is a type of monoalphabetic substitution cipher.'\n    \"\"\"\n    key_a, key_b = divmod(key, len(SYMBOLS))\n    check_keys(key_a, key_b, \"decrypt\")\n    plain_text = \"\"\n    mod_inverse_of_key_a = cryptomath.find_mod_inverse(key_a, len(SYMBOLS))\n    for symbol in message:\n        if symbol in SYMBOLS:\n            sym_index = SYMBOLS.find(symbol)\n            plain_text += SYMBOLS[\n                (sym_index - key_b) * mod_inverse_of_key_a % len(SYMBOLS)\n            ]\n        else:\n            plain_text += symbol\n    return plain_text\n\n\ndef get_random_key() -> int:\n    while True:\n        key_b = random.randint(2, len(SYMBOLS))\n        key_b = random.randint(2, len(SYMBOLS))\n        if gcd_by_iterative(key_b, len(SYMBOLS)) == 1 and key_b % len(SYMBOLS) != 0:\n            return key_b * len(SYMBOLS) + key_b\n\n\ndef main() -> None:\n    \"\"\"\n    >>> key = get_random_key()\n    >>> msg = \"This is a test!\"\n    >>> decrypt_message(key, encrypt_message(key, msg)) == msg\n    True\n    \"\"\"\n    message = input(\"Enter message: \").strip()\n    key = int(input(\"Enter key [2000 - 9000]: \").strip())\n    mode = input(\"Encrypt/Decrypt [E/D]: \").strip().lower()\n\n    if mode.startswith(\"e\"):\n        mode = \"encrypt\"\n        translated = encrypt_message(key, message)\n    elif mode.startswith(\"d\"):\n        mode = \"decrypt\"\n        translated = decrypt_message(key, message)\n    print(f\"\\n{mode.title()}ed text: \\n{translated}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    # main()\n", "ciphers/base85.py": "\"\"\"\nBase85 (Ascii85) encoding and decoding\n\nhttps://en.wikipedia.org/wiki/Ascii85\n\"\"\"\n\n\ndef _base10_to_85(d: int) -> str:\n    return \"\".join(chr(d % 85 + 33)) + _base10_to_85(d // 85) if d > 0 else \"\"\n\n\ndef _base85_to_10(digits: list) -> int:\n    return sum(char * 85**i for i, char in enumerate(reversed(digits)))\n\n\ndef ascii85_encode(data: bytes) -> bytes:\n    \"\"\"\n    >>> ascii85_encode(b\"\")\n    b''\n    >>> ascii85_encode(b\"12345\")\n    b'0etOA2#'\n    >>> ascii85_encode(b\"base 85\")\n    b'@UX=h+?24'\n    \"\"\"\n    binary_data = \"\".join(bin(ord(d))[2:].zfill(8) for d in data.decode(\"utf-8\"))\n    null_values = (32 * ((len(binary_data) // 32) + 1) - len(binary_data)) // 8\n    binary_data = binary_data.ljust(32 * ((len(binary_data) // 32) + 1), \"0\")\n    b85_chunks = [int(_s, 2) for _s in map(\"\".join, zip(*[iter(binary_data)] * 32))]\n    result = \"\".join(_base10_to_85(chunk)[::-1] for chunk in b85_chunks)\n    return bytes(result[:-null_values] if null_values % 4 != 0 else result, \"utf-8\")\n\n\ndef ascii85_decode(data: bytes) -> bytes:\n    \"\"\"\n    >>> ascii85_decode(b\"\")\n    b''\n    >>> ascii85_decode(b\"0etOA2#\")\n    b'12345'\n    >>> ascii85_decode(b\"@UX=h+?24\")\n    b'base 85'\n    \"\"\"\n    null_values = 5 * ((len(data) // 5) + 1) - len(data)\n    binary_data = data.decode(\"utf-8\") + \"u\" * null_values\n    b85_chunks = map(\"\".join, zip(*[iter(binary_data)] * 5))\n    b85_segments = [[ord(_s) - 33 for _s in chunk] for chunk in b85_chunks]\n    results = [bin(_base85_to_10(chunk))[2::].zfill(32) for chunk in b85_segments]\n    char_chunks = [\n        [chr(int(_s, 2)) for _s in map(\"\".join, zip(*[iter(r)] * 8))] for r in results\n    ]\n    result = \"\".join(\"\".join(char) for char in char_chunks)\n    offset = int(null_values % 5 == 0)\n    return bytes(result[: offset - null_values], \"utf-8\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/onepad_cipher.py": "import random\n\n\nclass Onepad:\n    @staticmethod\n    def encrypt(text: str) -> tuple[list[int], list[int]]:\n        \"\"\"\n        Function to encrypt text using pseudo-random numbers\n        >>> Onepad().encrypt(\"\")\n        ([], [])\n        >>> Onepad().encrypt([])\n        ([], [])\n        >>> random.seed(1)\n        >>> Onepad().encrypt(\" \")\n        ([6969], [69])\n        >>> random.seed(1)\n        >>> Onepad().encrypt(\"Hello\")\n        ([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])\n        >>> Onepad().encrypt(1)\n        Traceback (most recent call last):\n        ...\n        TypeError: 'int' object is not iterable\n        >>> Onepad().encrypt(1.1)\n        Traceback (most recent call last):\n        ...\n        TypeError: 'float' object is not iterable\n        \"\"\"\n        plain = [ord(i) for i in text]\n        key = []\n        cipher = []\n        for i in plain:\n            k = random.randint(1, 300)\n            c = (i + k) * k\n            cipher.append(c)\n            key.append(k)\n        return cipher, key\n\n    @staticmethod\n    def decrypt(cipher: list[int], key: list[int]) -> str:\n        \"\"\"\n        Function to decrypt text using pseudo-random numbers.\n        >>> Onepad().decrypt([], [])\n        ''\n        >>> Onepad().decrypt([35], [])\n        ''\n        >>> Onepad().decrypt([], [35])\n        Traceback (most recent call last):\n        ...\n        IndexError: list index out of range\n        >>> random.seed(1)\n        >>> Onepad().decrypt([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])\n        'Hello'\n        \"\"\"\n        plain = []\n        for i in range(len(key)):\n            p = int((cipher[i] - (key[i]) ** 2) / key[i])\n            plain.append(chr(p))\n        return \"\".join(plain)\n\n\nif __name__ == \"__main__\":\n    c, k = Onepad().encrypt(\"Hello\")\n    print(c, k)\n    print(Onepad().decrypt(c, k))\n", "ciphers/permutation_cipher.py": "\"\"\"\nThe permutation cipher, also called the transposition cipher, is a simple encryption\ntechnique that rearranges the characters in a message based on a secret key. It\ndivides the message into blocks and applies a permutation to the characters within\neach block according to the key. The key is a sequence of unique integers that\ndetermine the order of character rearrangement.\n\nFor more info: https://www.nku.edu/~christensen/1402%20permutation%20ciphers.pdf\n\"\"\"\n\nimport random\n\n\ndef generate_valid_block_size(message_length: int) -> int:\n    \"\"\"\n    Generate a valid block size that is a factor of the message length.\n\n    Args:\n        message_length (int): The length of the message.\n\n    Returns:\n        int: A valid block size.\n\n    Example:\n        >>> random.seed(1)\n        >>> generate_valid_block_size(12)\n        3\n    \"\"\"\n    block_sizes = [\n        block_size\n        for block_size in range(2, message_length + 1)\n        if message_length % block_size == 0\n    ]\n    return random.choice(block_sizes)\n\n\ndef generate_permutation_key(block_size: int) -> list[int]:\n    \"\"\"\n    Generate a random permutation key of a specified block size.\n\n    Args:\n        block_size (int): The size of each permutation block.\n\n    Returns:\n        list[int]: A list containing a random permutation of digits.\n\n    Example:\n        >>> random.seed(0)\n        >>> generate_permutation_key(4)\n        [2, 0, 1, 3]\n    \"\"\"\n    digits = list(range(block_size))\n    random.shuffle(digits)\n    return digits\n\n\ndef encrypt(\n    message: str, key: list[int] | None = None, block_size: int | None = None\n) -> tuple[str, list[int]]:\n    \"\"\"\n    Encrypt a message using a permutation cipher with block rearrangement using a key.\n\n    Args:\n        message (str): The plaintext message to be encrypted.\n        key (list[int]): The permutation key for decryption.\n        block_size (int): The size of each permutation block.\n\n    Returns:\n        tuple: A tuple containing the encrypted message and the encryption key.\n\n    Example:\n        >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n        >>> decrypted_message = decrypt(encrypted_message, key)\n        >>> decrypted_message\n        'HELLO WORLD'\n    \"\"\"\n    message = message.upper()\n    message_length = len(message)\n\n    if key is None or block_size is None:\n        block_size = generate_valid_block_size(message_length)\n        key = generate_permutation_key(block_size)\n\n    encrypted_message = \"\"\n\n    for i in range(0, message_length, block_size):\n        block = message[i : i + block_size]\n        rearranged_block = [block[digit] for digit in key]\n        encrypted_message += \"\".join(rearranged_block)\n\n    return encrypted_message, key\n\n\ndef decrypt(encrypted_message: str, key: list[int]) -> str:\n    \"\"\"\n    Decrypt an encrypted message using a permutation cipher with block rearrangement.\n\n    Args:\n        encrypted_message (str): The encrypted message.\n        key (list[int]): The permutation key for decryption.\n\n    Returns:\n        str: The decrypted plaintext message.\n\n    Example:\n        >>> encrypted_message, key = encrypt(\"HELLO WORLD\")\n        >>> decrypted_message = decrypt(encrypted_message, key)\n        >>> decrypted_message\n        'HELLO WORLD'\n    \"\"\"\n    key_length = len(key)\n    decrypted_message = \"\"\n\n    for i in range(0, len(encrypted_message), key_length):\n        block = encrypted_message[i : i + key_length]\n        original_block = [\"\"] * key_length\n        for j, digit in enumerate(key):\n            original_block[digit] = block[j]\n        decrypted_message += \"\".join(original_block)\n\n    return decrypted_message\n\n\ndef main() -> None:\n    \"\"\"\n    Driver function to pass message to get encrypted, then decrypted.\n\n    Example:\n    >>> main()\n    Decrypted message: HELLO WORLD\n    \"\"\"\n    message = \"HELLO WORLD\"\n    encrypted_message, key = encrypt(message)\n\n    decrypted_message = decrypt(encrypted_message, key)\n    print(f\"Decrypted message: {decrypted_message}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "ciphers/__init__.py": "", "ciphers/elgamal_key_generator.py": "import os\nimport random\nimport sys\n\nfrom . import cryptomath_module as cryptomath\nfrom . import rabin_miller\n\nmin_primitive_root = 3\n\n\n# I have written my code naively same as definition of primitive root\n# however every time I run this program, memory exceeded...\n# so I used 4.80 Algorithm in\n# Handbook of Applied Cryptography(CRC Press, ISBN : 0-8493-8523-7, October 1996)\n# and it seems to run nicely!\ndef primitive_root(p_val: int) -> int:\n    print(\"Generating primitive root of p\")\n    while True:\n        g = random.randrange(3, p_val)\n        if pow(g, 2, p_val) == 1:\n            continue\n        if pow(g, p_val, p_val) == 1:\n            continue\n        return g\n\n\ndef generate_key(key_size: int) -> tuple[tuple[int, int, int, int], tuple[int, int]]:\n    print(\"Generating prime p...\")\n    p = rabin_miller.generate_large_prime(key_size)  # select large prime number.\n    e_1 = primitive_root(p)  # one primitive root on modulo p.\n    d = random.randrange(3, p)  # private_key -> have to be greater than 2 for safety.\n    e_2 = cryptomath.find_mod_inverse(pow(e_1, d, p), p)\n\n    public_key = (key_size, e_1, e_2, p)\n    private_key = (key_size, d)\n\n    return public_key, private_key\n\n\ndef make_key_files(name: str, key_size: int) -> None:\n    if os.path.exists(f\"{name}_pubkey.txt\") or os.path.exists(f\"{name}_privkey.txt\"):\n        print(\"\\nWARNING:\")\n        print(\n            f'\"{name}_pubkey.txt\" or \"{name}_privkey.txt\" already exists. \\n'\n            \"Use a different name or delete these files and re-run this program.\"\n        )\n        sys.exit()\n\n    public_key, private_key = generate_key(key_size)\n    print(f\"\\nWriting public key to file {name}_pubkey.txt...\")\n    with open(f\"{name}_pubkey.txt\", \"w\") as fo:\n        fo.write(f\"{public_key[0]},{public_key[1]},{public_key[2]},{public_key[3]}\")\n\n    print(f\"Writing private key to file {name}_privkey.txt...\")\n    with open(f\"{name}_privkey.txt\", \"w\") as fo:\n        fo.write(f\"{private_key[0]},{private_key[1]}\")\n\n\ndef main() -> None:\n    print(\"Making key files...\")\n    make_key_files(\"elgamal\", 2048)\n    print(\"Key files generation successful\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/autokey.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Autokey_cipher\nAn autokey cipher (also known as the autoclave cipher) is a cipher that\nincorporates the message (the plaintext) into the key.\nThe key is generated from the message in some automated fashion,\nsometimes by selecting certain letters from the text or, more commonly,\nby adding a short primer key to the front of the message.\n\"\"\"\n\n\ndef encrypt(plaintext: str, key: str) -> str:\n    \"\"\"\n    Encrypt a given plaintext (string) and key (string), returning the\n    encrypted ciphertext.\n    >>> encrypt(\"hello world\", \"coffee\")\n    'jsqqs avvwo'\n    >>> encrypt(\"coffee is good as python\", \"TheAlgorithms\")\n    'vvjfpk wj ohvp su ddylsv'\n    >>> encrypt(\"coffee is good as python\", 2)\n    Traceback (most recent call last):\n        ...\n    TypeError: key must be a string\n    >>> encrypt(\"\", \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    ValueError: plaintext is empty\n    \"\"\"\n    if not isinstance(plaintext, str):\n        raise TypeError(\"plaintext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not plaintext:\n        raise ValueError(\"plaintext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key += plaintext\n    plaintext = plaintext.lower()\n    key = key.lower()\n    plaintext_iterator = 0\n    key_iterator = 0\n    ciphertext = \"\"\n    while plaintext_iterator < len(plaintext):\n        if (\n            ord(plaintext[plaintext_iterator]) < 97\n            or ord(plaintext[plaintext_iterator]) > 122\n        ):\n            ciphertext += plaintext[plaintext_iterator]\n            plaintext_iterator += 1\n        elif ord(key[key_iterator]) < 97 or ord(key[key_iterator]) > 122:\n            key_iterator += 1\n        else:\n            ciphertext += chr(\n                (\n                    (ord(plaintext[plaintext_iterator]) - 97 + ord(key[key_iterator]))\n                    - 97\n                )\n                % 26\n                + 97\n            )\n            key_iterator += 1\n            plaintext_iterator += 1\n    return ciphertext\n\n\ndef decrypt(ciphertext: str, key: str) -> str:\n    \"\"\"\n    Decrypt a given ciphertext (string) and key (string), returning the decrypted\n    ciphertext.\n    >>> decrypt(\"jsqqs avvwo\", \"coffee\")\n    'hello world'\n    >>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"TheAlgorithms\")\n    'coffee is good as python'\n    >>> decrypt(\"vvjfpk wj ohvp su ddylsv\", \"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: key is empty\n    >>> decrypt(527.26, \"TheAlgorithms\")\n    Traceback (most recent call last):\n        ...\n    TypeError: ciphertext must be a string\n    \"\"\"\n    if not isinstance(ciphertext, str):\n        raise TypeError(\"ciphertext must be a string\")\n    if not isinstance(key, str):\n        raise TypeError(\"key must be a string\")\n\n    if not ciphertext:\n        raise ValueError(\"ciphertext is empty\")\n    if not key:\n        raise ValueError(\"key is empty\")\n\n    key = key.lower()\n    ciphertext_iterator = 0\n    key_iterator = 0\n    plaintext = \"\"\n    while ciphertext_iterator < len(ciphertext):\n        if (\n            ord(ciphertext[ciphertext_iterator]) < 97\n            or ord(ciphertext[ciphertext_iterator]) > 122\n        ):\n            plaintext += ciphertext[ciphertext_iterator]\n        else:\n            plaintext += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key += chr(\n                (ord(ciphertext[ciphertext_iterator]) - ord(key[key_iterator])) % 26\n                + 97\n            )\n            key_iterator += 1\n        ciphertext_iterator += 1\n    return plaintext\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    operation = int(input(\"Type 1 to encrypt or 2 to decrypt:\"))\n    if operation == 1:\n        plaintext = input(\"Typeplaintext to be encrypted:\\n\")\n        key = input(\"Type the key:\\n\")\n        print(encrypt(plaintext, key))\n    elif operation == 2:\n        ciphertext = input(\"Type the ciphertext to be decrypted:\\n\")\n        key = input(\"Type the key:\\n\")\n        print(decrypt(ciphertext, key))\n    decrypt(\"jsqqs avvwo\", \"coffee\")\n", "ciphers/decrypt_caesar_with_chi_squared.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\n\ndef decrypt_caesar_with_chi_squared(\n    ciphertext: str,\n    cipher_alphabet: list[str] | None = None,\n    frequencies_dict: dict[str, float] | None = None,\n    case_sensitive: bool = False,\n) -> tuple[int, float, str]:\n    \"\"\"\n    Basic Usage\n    ===========\n    Arguments:\n    * ciphertext (str): the text to decode (encoded with the caesar cipher)\n\n    Optional Arguments:\n    * cipher_alphabet (list): the alphabet used for the cipher (each letter is\n      a string separated by commas)\n    * frequencies_dict (dict): a dictionary of word frequencies where keys are\n      the letters and values are a percentage representation of the frequency as\n      a decimal/float\n    * case_sensitive (bool): a boolean value: True if the case matters during\n      decryption, False if it doesn't\n\n    Returns:\n    * A tuple in the form of:\n      (\n        most_likely_cipher,\n        most_likely_cipher_chi_squared_value,\n        decoded_most_likely_cipher\n      )\n\n      where...\n      - most_likely_cipher is an integer representing the shift of the smallest\n        chi-squared statistic (most likely key)\n      - most_likely_cipher_chi_squared_value is a float representing the\n        chi-squared statistic of the most likely shift\n      - decoded_most_likely_cipher is a string with the decoded cipher\n        (decoded by the most_likely_cipher key)\n\n\n    The Chi-squared test\n    ====================\n\n    The caesar cipher\n    -----------------\n    The caesar cipher is a very insecure encryption algorithm, however it has\n    been used since Julius Caesar. The cipher is a simple substitution cipher\n    where each character in the plain text is replaced by a character in the\n    alphabet a certain number of characters after the original character. The\n    number of characters away is called the shift or key. For example:\n\n    Plain text: hello\n    Key: 1\n    Cipher text: ifmmp\n    (each letter in hello has been shifted one to the right in the eng. alphabet)\n\n    As you can imagine, this doesn't provide lots of security. In fact\n    decrypting ciphertext by brute-force is extremely easy even by hand. However\n     one way to do that is the chi-squared test.\n\n    The chi-squared test\n    -------------------\n    Each letter in the english alphabet has a frequency, or the amount of times\n    it shows up compared to other letters (usually expressed as a decimal\n    representing the percentage likelihood). The most common letter in the\n    english language is \"e\" with a frequency of 0.11162 or 11.162%. The test is\n    completed in the following fashion.\n\n    1. The ciphertext is decoded in a brute force way (every combination of the\n       26 possible combinations)\n    2. For every combination, for each letter in the combination, the average\n       amount of times the letter should appear the message is calculated by\n       multiplying the total number of characters by the frequency of the letter\n\n       For example:\n       In a message of 100 characters, e should appear around 11.162 times.\n\n     3. Then, to calculate the margin of error (the amount of times the letter\n        SHOULD appear with the amount of times the letter DOES appear), we use\n        the chi-squared test. The following formula is used:\n\n        Let:\n        - n be the number of times the letter actually appears\n        - p be the predicted value of the number of times the letter should\n          appear (see #2)\n        - let v be the chi-squared test result (referred to here as chi-squared\n          value/statistic)\n\n        (n - p)^2\n        --------- = v\n           p\n\n    4. Each chi squared value for each letter is then added up to the total.\n       The total is the chi-squared statistic for that encryption key.\n    5. The encryption key with the lowest chi-squared value is the most likely\n       to be the decoded answer.\n\n    Further Reading\n    ================\n\n    * http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-\n        statistic/\n    * https://en.wikipedia.org/wiki/Letter_frequency\n    * https://en.wikipedia.org/wiki/Chi-squared_test\n    * https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n    >>> decrypt_caesar_with_chi_squared(\n    ...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    (7, 3129.228005747531,\n     'why is the caesar cipher so popular? it is too easy to crack!')\n\n    >>> decrypt_caesar_with_chi_squared('crybd cdbsxq')\n    (10, 233.35343938980898, 'short string')\n\n    >>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)\n    (10, 233.35343938980898, 'Short String')\n\n    >>> decrypt_caesar_with_chi_squared(12)\n    Traceback (most recent call last):\n    AttributeError: 'int' object has no attribute 'lower'\n    \"\"\"\n    alphabet_letters = cipher_alphabet or [chr(i) for i in range(97, 123)]\n\n    # If the argument is None or the user provided an empty dictionary\n    if not frequencies_dict:\n        # Frequencies of letters in the english language (how much they show up)\n        frequencies = {\n            \"a\": 0.08497,\n            \"b\": 0.01492,\n            \"c\": 0.02202,\n            \"d\": 0.04253,\n            \"e\": 0.11162,\n            \"f\": 0.02228,\n            \"g\": 0.02015,\n            \"h\": 0.06094,\n            \"i\": 0.07546,\n            \"j\": 0.00153,\n            \"k\": 0.01292,\n            \"l\": 0.04025,\n            \"m\": 0.02406,\n            \"n\": 0.06749,\n            \"o\": 0.07507,\n            \"p\": 0.01929,\n            \"q\": 0.00095,\n            \"r\": 0.07587,\n            \"s\": 0.06327,\n            \"t\": 0.09356,\n            \"u\": 0.02758,\n            \"v\": 0.00978,\n            \"w\": 0.02560,\n            \"x\": 0.00150,\n            \"y\": 0.01994,\n            \"z\": 0.00077,\n        }\n    else:\n        # Custom frequencies dictionary\n        frequencies = frequencies_dict\n\n    if not case_sensitive:\n        ciphertext = ciphertext.lower()\n\n    # Chi squared statistic values\n    chi_squared_statistic_values: dict[int, tuple[float, str]] = {}\n\n    # cycle through all of the shifts\n    for shift in range(len(alphabet_letters)):\n        decrypted_with_shift = \"\"\n\n        # decrypt the message with the shift\n        for letter in ciphertext:\n            try:\n                # Try to index the letter in the alphabet\n                new_key = (alphabet_letters.index(letter.lower()) - shift) % len(\n                    alphabet_letters\n                )\n                decrypted_with_shift += (\n                    alphabet_letters[new_key].upper()\n                    if case_sensitive and letter.isupper()\n                    else alphabet_letters[new_key]\n                )\n            except ValueError:\n                # Append the character if it isn't in the alphabet\n                decrypted_with_shift += letter\n\n        chi_squared_statistic = 0.0\n\n        # Loop through each letter in the decoded message with the shift\n        for letter in decrypted_with_shift:\n            if case_sensitive:\n                letter = letter.lower()\n                if letter in frequencies:\n                    # Get the amount of times the letter occurs in the message\n                    occurrences = decrypted_with_shift.lower().count(letter)\n\n                    # Get the excepcted amount of times the letter should appear based\n                    # on letter frequencies\n                    expected = frequencies[letter] * occurrences\n\n                    # Complete the chi squared statistic formula\n                    chi_letter_value = ((occurrences - expected) ** 2) / expected\n\n                    # Add the margin of error to the total chi squared statistic\n                    chi_squared_statistic += chi_letter_value\n            elif letter.lower() in frequencies:\n                # Get the amount of times the letter occurs in the message\n                occurrences = decrypted_with_shift.count(letter)\n\n                # Get the excepcted amount of times the letter should appear based\n                # on letter frequencies\n                expected = frequencies[letter] * occurrences\n\n                # Complete the chi squared statistic formula\n                chi_letter_value = ((occurrences - expected) ** 2) / expected\n\n                # Add the margin of error to the total chi squared statistic\n                chi_squared_statistic += chi_letter_value\n\n        # Add the data to the chi_squared_statistic_values dictionary\n        chi_squared_statistic_values[shift] = (\n            chi_squared_statistic,\n            decrypted_with_shift,\n        )\n\n    # Get the most likely cipher by finding the cipher with the smallest chi squared\n    # statistic\n    def chi_squared_statistic_values_sorting_key(key: int) -> tuple[float, str]:\n        return chi_squared_statistic_values[key]\n\n    most_likely_cipher: int = min(\n        chi_squared_statistic_values,\n        key=chi_squared_statistic_values_sorting_key,\n    )\n\n    # Get all the data from the most likely cipher (key, decoded message)\n    (\n        most_likely_cipher_chi_squared_value,\n        decoded_most_likely_cipher,\n    ) = chi_squared_statistic_values[most_likely_cipher]\n\n    # Return the data on the most likely shift\n    return (\n        most_likely_cipher,\n        most_likely_cipher_chi_squared_value,\n        decoded_most_likely_cipher,\n    )\n", "ciphers/caesar_cipher.py": "from __future__ import annotations\n\nfrom string import ascii_letters\n\n\ndef encrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    encrypt\n    =======\n    Encodes a given string with the caesar cipher and returns the encoded\n    message\n\n    Parameters:\n    -----------\n    *   input_string: the plain-text that needs to be encoded\n    *   key: the number of letters to shift the message by\n\n    Optional:\n    *   alphabet (None): the alphabet used to encode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n    *   A string containing the encoded cipher-text\n\n    More on the caesar cipher\n    =========================\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where every character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\".\n\n    Example:\n    Say we have the following message:\n    \"Hello, captain\"\n\n    And our alphabet is made up of lower and uppercase letters:\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    And our shift is \"2\"\n\n    We can then encode the message, one letter at a time. \"H\" would become \"J\",\n    since \"J\" is two letters away, and so on. If the shift is ever two large, or\n    our letter is at the end of the alphabet, we just start at the beginning\n    (\"Z\" would shift to \"a\" then \"b\" and so on).\n\n    Our final message would be \"Jgnnq, ecrvckp\"\n\n    Further reading\n    ===============\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n    >>> encrypt('The quick brown fox jumps over the lazy dog', 8)\n    'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'\n\n    >>> encrypt('A very large key', 8000)\n    's nWjq dSjYW cWq'\n\n    >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'f qtbjwhfxj fqumfgjy'\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # The final result string\n    result = \"\"\n\n    for character in input_string:\n        if character not in alpha:\n            # Append without encryption if character is not in the alphabet\n            result += character\n        else:\n            # Get the index of the new key and make sure it isn't too large\n            new_key = (alpha.index(character) + key) % len(alpha)\n\n            # Append the encoded character to the alphabet\n            result += alpha[new_key]\n\n    return result\n\n\ndef decrypt(input_string: str, key: int, alphabet: str | None = None) -> str:\n    \"\"\"\n    decrypt\n    =======\n    Decodes a given string of cipher-text and returns the decoded plain-text\n\n    Parameters:\n    -----------\n    *   input_string: the cipher-text that needs to be decoded\n    *   key: the number of letters to shift the message backwards by to decode\n\n    Optional:\n    *   alphabet (None): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    Returns:\n    *   A string containing the decoded plain-text\n\n    More on the caesar cipher\n    =========================\n    The caesar cipher is named after Julius Caesar who used it when sending\n    secret military messages to his troops. This is a simple substitution cipher\n    where very character in the plain-text is shifted by a certain number known\n    as the \"key\" or \"shift\". Please keep in mind, here we will be focused on\n    decryption.\n\n    Example:\n    Say we have the following cipher-text:\n    \"Jgnnq, ecrvckp\"\n\n    And our alphabet is made up of lower and uppercase letters:\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    And our shift is \"2\"\n\n    To decode the message, we would do the same thing as encoding, but in\n    reverse. The first letter, \"J\" would become \"H\" (remember: we are decoding)\n    because \"H\" is two letters in reverse (to the left) of \"J\". We would\n    continue doing this. A letter like \"a\" would shift back to the end of\n    the alphabet, and would become \"Z\" or \"Y\" and so on.\n\n    Our final message would be \"Hello, captain\"\n\n    Further reading\n    ===============\n    *   https://en.m.wikipedia.org/wiki/Caesar_cipher\n\n    Doctests\n    ========\n    >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)\n    'The quick brown fox jumps over the lazy dog'\n\n    >>> decrypt('s nWjq dSjYW cWq', 8000)\n    'A very large key'\n\n    >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')\n    'a lowercase alphabet'\n    \"\"\"\n    # Turn on decode mode by making the key negative\n    key *= -1\n\n    return encrypt(input_string, key, alphabet)\n\n\ndef brute_force(input_string: str, alphabet: str | None = None) -> dict[int, str]:\n    \"\"\"\n    brute_force\n    ===========\n    Returns all the possible combinations of keys and the decoded strings in the\n    form of a dictionary\n\n    Parameters:\n    -----------\n    *   input_string: the cipher-text that needs to be used during brute-force\n\n    Optional:\n    *   alphabet:  (None): the alphabet used to decode the cipher, if not\n        specified, the standard english alphabet with upper and lowercase\n        letters is used\n\n    More about brute force\n    ======================\n    Brute force is when a person intercepts a message or password, not knowing\n    the key and tries every single combination. This is easy with the caesar\n    cipher since there are only all the letters in the alphabet. The more\n    complex the cipher, the larger amount of time it will take to do brute force\n\n    Ex:\n    Say we have a 5 letter alphabet (abcde), for simplicity and we intercepted the\n    following message:\n\n    \"dbc\"\n\n    we could then just write out every combination:\n    ecd... and so on, until we reach a combination that makes sense:\n    \"cab\"\n\n    Further reading\n    ===============\n    *   https://en.wikipedia.org/wiki/Brute_force\n\n    Doctests\n    ========\n    >>> brute_force(\"jFyuMy xIH'N vLONy zILwy Gy!\")[20]\n    \"Please don't brute force me!\"\n\n    >>> brute_force(1)\n    Traceback (most recent call last):\n    TypeError: 'int' object is not iterable\n    \"\"\"\n    # Set default alphabet to lower and upper case english chars\n    alpha = alphabet or ascii_letters\n\n    # To store data on all the combinations\n    brute_force_data = {}\n\n    # Cycle through each combination\n    for key in range(1, len(alpha) + 1):\n        # Decrypt the message and store the result in the data\n        brute_force_data[key] = decrypt(input_string, key, alpha)\n\n    return brute_force_data\n\n\nif __name__ == \"__main__\":\n    while True:\n        print(f'\\n{\"-\" * 10}\\n Menu\\n{\"-\" * 10}')\n        print(*[\"1.Encrypt\", \"2.Decrypt\", \"3.BruteForce\", \"4.Quit\"], sep=\"\\n\")\n\n        # get user input\n        choice = input(\"\\nWhat would you like to do?: \").strip() or \"4\"\n\n        # run functions based on what the user chose\n        if choice not in (\"1\", \"2\", \"3\", \"4\"):\n            print(\"Invalid choice, please enter a valid choice\")\n        elif choice == \"1\":\n            input_string = input(\"Please enter the string to be encrypted: \")\n            key = int(input(\"Please enter off-set: \").strip())\n\n            print(encrypt(input_string, key))\n        elif choice == \"2\":\n            input_string = input(\"Please enter the string to be decrypted: \")\n            key = int(input(\"Please enter off-set: \").strip())\n\n            print(decrypt(input_string, key))\n        elif choice == \"3\":\n            input_string = input(\"Please enter the string to be decrypted: \")\n            brute_force_data = brute_force(input_string)\n\n            for key, value in brute_force_data.items():\n                print(f\"Key: {key} | Message: {value}\")\n\n        elif choice == \"4\":\n            print(\"Goodbye.\")\n            break\n", "ciphers/rsa_factorization.py": "\"\"\"\nAn RSA prime factor algorithm.\n\nThe program can efficiently factor RSA prime number given the private key d and\npublic key e.\nSource: on page 3 of https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf\nMore readable source: https://www.di-mgt.com.au/rsa_factorize_n.html\nlarge number can take minutes to factor, therefore are not included in doctest.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\n\n\ndef rsafactor(d: int, e: int, n: int) -> list[int]:\n    \"\"\"\n    This function returns the factors of N, where p*q=N\n      Return: [p, q]\n\n    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.\n    The pair (N, e) is the public key. As its name suggests, it is public and is used to\n        encrypt messages.\n    The pair (N, d) is the secret key or private key and is known only to the recipient\n        of encrypted messages.\n\n    >>> rsafactor(3, 16971, 25777)\n    [149, 173]\n    >>> rsafactor(7331, 11, 27233)\n    [113, 241]\n    >>> rsafactor(4021, 13, 17711)\n    [89, 199]\n    \"\"\"\n    k = d * e - 1\n    p = 0\n    q = 0\n    while p == 0:\n        g = random.randint(2, n - 1)\n        t = k\n        while True:\n            if t % 2 == 0:\n                t = t // 2\n                x = (g**t) % n\n                y = math.gcd(x - 1, n)\n                if x > 1 and y > 1:\n                    p = y\n                    q = n // y\n                    break  # find the correct factors\n            else:\n                break  # t is not divisible by 2, break and choose another g\n    return sorted([p, q])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/rail_fence_cipher.py": "\"\"\"https://en.wikipedia.org/wiki/Rail_fence_cipher\"\"\"\n\n\ndef encrypt(input_string: str, key: int) -> str:\n    \"\"\"\n    Shuffles the character of a string by placing each of them\n    in a grid (the height is dependent on the key) in a zigzag\n    formation and reading it left to right.\n\n    >>> encrypt(\"Hello World\", 4)\n    'HWe olordll'\n\n    >>> encrypt(\"This is a message\", 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Height of grid can't be 0 or negative\n\n    >>> encrypt(b\"This is a byte string\", 5)\n    Traceback (most recent call last):\n        ...\n    TypeError: sequence item 0: expected str instance, int found\n    \"\"\"\n    temp_grid: list[list[str]] = [[] for _ in range(key)]\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1 or len(input_string) <= key:\n        return input_string\n\n    for position, character in enumerate(input_string):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(character)\n    grid = [\"\".join(row) for row in temp_grid]\n    output_string = \"\".join(grid)\n\n    return output_string\n\n\ndef decrypt(input_string: str, key: int) -> str:\n    \"\"\"\n    Generates a template based on the key and fills it in with\n    the characters of the input string and then reading it in\n    a zigzag formation.\n\n    >>> decrypt(\"HWe olordll\", 4)\n    'Hello World'\n\n    >>> decrypt(\"This is a message\", -10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Height of grid can't be 0 or negative\n\n    >>> decrypt(\"My key is very big\", 100)\n    'My key is very big'\n    \"\"\"\n    grid = []\n    lowest = key - 1\n\n    if key <= 0:\n        raise ValueError(\"Height of grid can't be 0 or negative\")\n    if key == 1:\n        return input_string\n\n    temp_grid: list[list[str]] = [[] for _ in range(key)]  # generates template\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        temp_grid[num].append(\"*\")\n\n    counter = 0\n    for row in temp_grid:  # fills in the characters\n        splice = input_string[counter : counter + len(row)]\n        grid.append(list(splice))\n        counter += len(row)\n\n    output_string = \"\"  # reads as zigzag\n    for position in range(len(input_string)):\n        num = position % (lowest * 2)  # puts it in bounds\n        num = min(num, lowest * 2 - num)  # creates zigzag pattern\n        output_string += grid[num][0]\n        grid[num].pop(0)\n    return output_string\n\n\ndef bruteforce(input_string: str) -> dict[int, str]:\n    \"\"\"Uses decrypt function by guessing every key\n\n    >>> bruteforce(\"HWe olordll\")[4]\n    'Hello World'\n    \"\"\"\n    results = {}\n    for key_guess in range(1, len(input_string)):  # tries every key\n        results[key_guess] = decrypt(input_string, key_guess)\n    return results\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "ciphers/morse_code.py": "#!/usr/bin/env python3\n\n\"\"\"\nPython program to translate to and from Morse code.\n\nhttps://en.wikipedia.org/wiki/Morse_code\n\"\"\"\n\n# fmt: off\nMORSE_CODE_DICT = {\n    \"A\": \".-\", \"B\": \"-...\", \"C\": \"-.-.\", \"D\": \"-..\", \"E\": \".\", \"F\": \"..-.\", \"G\": \"--.\",\n    \"H\": \"....\", \"I\": \"..\", \"J\": \".---\", \"K\": \"-.-\", \"L\": \".-..\", \"M\": \"--\", \"N\": \"-.\",\n    \"O\": \"---\", \"P\": \".--.\", \"Q\": \"--.-\", \"R\": \".-.\", \"S\": \"...\", \"T\": \"-\", \"U\": \"..-\",\n    \"V\": \"...-\", \"W\": \".--\", \"X\": \"-..-\", \"Y\": \"-.--\", \"Z\": \"--..\", \"1\": \".----\",\n    \"2\": \"..---\", \"3\": \"...--\", \"4\": \"....-\", \"5\": \".....\", \"6\": \"-....\", \"7\": \"--...\",\n    \"8\": \"---..\", \"9\": \"----.\", \"0\": \"-----\", \"&\": \".-...\", \"@\": \".--.-.\",\n    \":\": \"---...\", \",\": \"--..--\", \".\": \".-.-.-\", \"'\": \".----.\", '\"': \".-..-.\",\n    \"?\": \"..--..\", \"/\": \"-..-.\", \"=\": \"-...-\", \"+\": \".-.-.\", \"-\": \"-....-\",\n    \"(\": \"-.--.\", \")\": \"-.--.-\", \"!\": \"-.-.--\", \" \": \"/\"\n}  # Exclamation mark is not in ITU-R recommendation\n# fmt: on\nREVERSE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()}\n\n\ndef encrypt(message: str) -> str:\n    \"\"\"\n    >>> encrypt(\"Sos!\")\n    '... --- ... -.-.--'\n    >>> encrypt(\"SOS!\") == encrypt(\"sos!\")\n    True\n    \"\"\"\n    return \" \".join(MORSE_CODE_DICT[char] for char in message.upper())\n\n\ndef decrypt(message: str) -> str:\n    \"\"\"\n    >>> decrypt('... --- ... -.-.--')\n    'SOS!'\n    \"\"\"\n    return \"\".join(REVERSE_DICT[char] for char in message.split())\n\n\ndef main() -> None:\n    \"\"\"\n    >>> s = \"\".join(MORSE_CODE_DICT)\n    >>> decrypt(encrypt(s)) == s\n    True\n    \"\"\"\n    message = \"Morse code here!\"\n    print(message)\n    message = encrypt(message)\n    print(message)\n    message = decrypt(message)\n    print(message)\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/fractionated_morse_cipher.py": "\"\"\"\nPython program for the Fractionated Morse Cipher.\n\nThe Fractionated Morse cipher first converts the plaintext to Morse code,\nthen enciphers fixed-size blocks of Morse code back to letters.\nThis procedure means plaintext letters are mixed into the ciphertext letters,\nmaking it more secure than substitution ciphers.\n\nhttp://practicalcryptography.com/ciphers/fractionated-morse-cipher/\n\"\"\"\n\nimport string\n\nMORSE_CODE_DICT = {\n    \"A\": \".-\",\n    \"B\": \"-...\",\n    \"C\": \"-.-.\",\n    \"D\": \"-..\",\n    \"E\": \".\",\n    \"F\": \"..-.\",\n    \"G\": \"--.\",\n    \"H\": \"....\",\n    \"I\": \"..\",\n    \"J\": \".---\",\n    \"K\": \"-.-\",\n    \"L\": \".-..\",\n    \"M\": \"--\",\n    \"N\": \"-.\",\n    \"O\": \"---\",\n    \"P\": \".--.\",\n    \"Q\": \"--.-\",\n    \"R\": \".-.\",\n    \"S\": \"...\",\n    \"T\": \"-\",\n    \"U\": \"..-\",\n    \"V\": \"...-\",\n    \"W\": \".--\",\n    \"X\": \"-..-\",\n    \"Y\": \"-.--\",\n    \"Z\": \"--..\",\n    \" \": \"\",\n}\n\n# Define possible trigrams of Morse code\nMORSE_COMBINATIONS = [\n    \"...\",\n    \"..-\",\n    \"..x\",\n    \".-.\",\n    \".--\",\n    \".-x\",\n    \".x.\",\n    \".x-\",\n    \".xx\",\n    \"-..\",\n    \"-.-\",\n    \"-.x\",\n    \"--.\",\n    \"---\",\n    \"--x\",\n    \"-x.\",\n    \"-x-\",\n    \"-xx\",\n    \"x..\",\n    \"x.-\",\n    \"x.x\",\n    \"x-.\",\n    \"x--\",\n    \"x-x\",\n    \"xx.\",\n    \"xx-\",\n    \"xxx\",\n]\n\n# Create a reverse dictionary for Morse code\nREVERSE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()}\n\n\ndef encode_to_morse(plaintext: str) -> str:\n    \"\"\"Encode a plaintext message into Morse code.\n\n    Args:\n        plaintext: The plaintext message to encode.\n\n    Returns:\n        The Morse code representation of the plaintext message.\n\n    Example:\n        >>> encode_to_morse(\"defend the east\")\n        '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'\n    \"\"\"\n    return \"x\".join([MORSE_CODE_DICT.get(letter.upper(), \"\") for letter in plaintext])\n\n\ndef encrypt_fractionated_morse(plaintext: str, key: str) -> str:\n    \"\"\"Encrypt a plaintext message using Fractionated Morse Cipher.\n\n    Args:\n        plaintext: The plaintext message to encrypt.\n        key: The encryption key.\n\n    Returns:\n        The encrypted ciphertext.\n\n    Example:\n        >>> encrypt_fractionated_morse(\"defend the east\",\"Roundtable\")\n        'ESOAVVLJRSSTRX'\n\n    \"\"\"\n    morse_code = encode_to_morse(plaintext)\n    key = key.upper() + string.ascii_uppercase\n    key = \"\".join(sorted(set(key), key=key.find))\n\n    # Ensure morse_code length is a multiple of 3\n    padding_length = 3 - (len(morse_code) % 3)\n    morse_code += \"x\" * padding_length\n\n    fractionated_morse_dict = {v: k for k, v in zip(key, MORSE_COMBINATIONS)}\n    fractionated_morse_dict[\"xxx\"] = \"\"\n    encrypted_text = \"\".join(\n        [\n            fractionated_morse_dict[morse_code[i : i + 3]]\n            for i in range(0, len(morse_code), 3)\n        ]\n    )\n    return encrypted_text\n\n\ndef decrypt_fractionated_morse(ciphertext: str, key: str) -> str:\n    \"\"\"Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.\n\n    Args:\n        ciphertext: The ciphertext message to decrypt.\n        key: The decryption key.\n\n    Returns:\n        The decrypted plaintext message.\n\n    Example:\n        >>> decrypt_fractionated_morse(\"ESOAVVLJRSSTRX\",\"Roundtable\")\n        'DEFEND THE EAST'\n    \"\"\"\n    key = key.upper() + string.ascii_uppercase\n    key = \"\".join(sorted(set(key), key=key.find))\n\n    inverse_fractionated_morse_dict = dict(zip(key, MORSE_COMBINATIONS))\n    morse_code = \"\".join(\n        [inverse_fractionated_morse_dict.get(letter, \"\") for letter in ciphertext]\n    )\n    decrypted_text = \"\".join(\n        [REVERSE_DICT[code] for code in morse_code.split(\"x\")]\n    ).strip()\n    return decrypted_text\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Example usage of Fractionated Morse Cipher.\n    \"\"\"\n    plaintext = \"defend the east\"\n    print(\"Plain Text:\", plaintext)\n    key = \"ROUNDTABLE\"\n\n    ciphertext = encrypt_fractionated_morse(plaintext, key)\n    print(\"Encrypted:\", ciphertext)\n\n    decrypted_text = decrypt_fractionated_morse(ciphertext, key)\n    print(\"Decrypted:\", decrypted_text)\n", "ciphers/simple_substitution_cipher.py": "import random\nimport sys\n\nLETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef main() -> None:\n    message = input(\"Enter message: \")\n    key = \"LFWOAYUISVKMNXPBDCRJTQEGHZ\"\n    resp = input(\"Encrypt/Decrypt [e/d]: \")\n\n    check_valid_key(key)\n\n    if resp.lower().startswith(\"e\"):\n        mode = \"encrypt\"\n        translated = encrypt_message(key, message)\n    elif resp.lower().startswith(\"d\"):\n        mode = \"decrypt\"\n        translated = decrypt_message(key, message)\n\n    print(f\"\\n{mode.title()}ion: \\n{translated}\")\n\n\ndef check_valid_key(key: str) -> None:\n    key_list = list(key)\n    letters_list = list(LETTERS)\n    key_list.sort()\n    letters_list.sort()\n\n    if key_list != letters_list:\n        sys.exit(\"Error in the key or symbol set.\")\n\n\ndef encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')\n    'Ilcrism Olcvs'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")\n\n\ndef decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')\n    'Harshil Darji'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")\n\n\ndef translate_message(key: str, message: str, mode: str) -> str:\n    translated = \"\"\n    chars_a = LETTERS\n    chars_b = key\n\n    if mode == \"decrypt\":\n        chars_a, chars_b = chars_b, chars_a\n\n    for symbol in message:\n        if symbol.upper() in chars_a:\n            sym_index = chars_a.find(symbol.upper())\n            if symbol.isupper():\n                translated += chars_b[sym_index].upper()\n            else:\n                translated += chars_b[sym_index].lower()\n        else:\n            translated += symbol\n\n    return translated\n\n\ndef get_random_key() -> str:\n    key = list(LETTERS)\n    random.shuffle(key)\n    return \"\".join(key)\n\n\nif __name__ == \"__main__\":\n    main()\n", "ciphers/mono_alphabetic_ciphers.py": "from typing import Literal\n\nLETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef translate_message(\n    key: str, message: str, mode: Literal[\"encrypt\", \"decrypt\"]\n) -> str:\n    \"\"\"\n    >>> translate_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\",\"Hello World\",\"encrypt\")\n    'Pcssi Bidsm'\n    \"\"\"\n    chars_a = LETTERS if mode == \"decrypt\" else key\n    chars_b = key if mode == \"decrypt\" else LETTERS\n    translated = \"\"\n    # loop through each symbol in the message\n    for symbol in message:\n        if symbol.upper() in chars_a:\n            # encrypt/decrypt the symbol\n            sym_index = chars_a.find(symbol.upper())\n            if symbol.isupper():\n                translated += chars_b[sym_index].upper()\n            else:\n                translated += chars_b[sym_index].lower()\n        else:\n            # symbol is not in LETTERS, just add it\n            translated += symbol\n    return translated\n\n\ndef encrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> encrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n    'Pcssi Bidsm'\n    \"\"\"\n    return translate_message(key, message, \"encrypt\")\n\n\ndef decrypt_message(key: str, message: str) -> str:\n    \"\"\"\n    >>> decrypt_message(\"QWERTYUIOPASDFGHJKLZXCVBNM\", \"Hello World\")\n    'Itssg Vgksr'\n    \"\"\"\n    return translate_message(key, message, \"decrypt\")\n\n\ndef main() -> None:\n    message = \"Hello World\"\n    key = \"QWERTYUIOPASDFGHJKLZXCVBNM\"\n    mode = \"decrypt\"  # set to 'encrypt' or 'decrypt'\n\n    if mode == \"encrypt\":\n        translated = encrypt_message(key, message)\n    elif mode == \"decrypt\":\n        translated = decrypt_message(key, message)\n    print(f\"Using the key {key}, the {mode}ed message is: {translated}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "scheduling/highest_response_ratio_next.py": "\"\"\"\nHighest response ratio next (HRRN) scheduling is a non-preemptive discipline.\nIt was developed as modification of shortest job next or shortest job first (SJN or SJF)\nto mitigate the problem of process starvation.\nhttps://en.wikipedia.org/wiki/Highest_response_ratio_next\n\"\"\"\n\nfrom statistics import mean\n\nimport numpy as np\n\n\ndef calculate_turn_around_time(\n    process_name: list, arrival_time: list, burst_time: list, no_of_process: int\n) -> list:\n    \"\"\"\n    Calculate the turn around time of each processes\n\n    Return: The turn around time time for each process.\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [3, 5, 8], [2, 4, 6], 3)\n    [2, 4, 7]\n    >>> calculate_turn_around_time([\"A\", \"B\", \"C\"], [0, 2, 4], [3, 5, 7], 3)\n    [3, 6, 11]\n    \"\"\"\n\n    current_time = 0\n    # Number of processes finished\n    finished_process_count = 0\n    # Displays the finished process.\n    # If it is 0, the performance is completed if it is 1, before the performance.\n    finished_process = [0] * no_of_process\n    # List to include calculation results\n    turn_around_time = [0] * no_of_process\n\n    # Sort by arrival time.\n    burst_time = [burst_time[i] for i in np.argsort(arrival_time)]\n    process_name = [process_name[i] for i in np.argsort(arrival_time)]\n    arrival_time.sort()\n\n    while no_of_process > finished_process_count:\n        \"\"\"\n        If the current time is less than the arrival time of\n        the process that arrives first among the processes that have not been performed,\n        change the current time.\n        \"\"\"\n        i = 0\n        while finished_process[i] == 1:\n            i += 1\n        if current_time < arrival_time[i]:\n            current_time = arrival_time[i]\n\n        response_ratio = 0\n        # Index showing the location of the process being performed\n        loc = 0\n        # Saves the current response ratio.\n        temp = 0\n        for i in range(no_of_process):\n            if finished_process[i] == 0 and arrival_time[i] <= current_time:\n                temp = (burst_time[i] + (current_time - arrival_time[i])) / burst_time[\n                    i\n                ]\n            if response_ratio < temp:\n                response_ratio = temp\n                loc = i\n\n        # Calculate the turn around time\n        turn_around_time[loc] = current_time + burst_time[loc] - arrival_time[loc]\n        current_time += burst_time[loc]\n        # Indicates that the process has been performed.\n        finished_process[loc] = 1\n        # Increase finished_process_count by 1\n        finished_process_count += 1\n\n    return turn_around_time\n\n\ndef calculate_waiting_time(\n    process_name: list,  # noqa: ARG001\n    turn_around_time: list,\n    burst_time: list,\n    no_of_process: int,\n) -> list:\n    \"\"\"\n    Calculate the waiting time of each processes.\n\n    Return: The waiting time for each process.\n    >>> calculate_waiting_time([\"A\", \"B\", \"C\"], [2, 4, 7], [2, 4, 6], 3)\n    [0, 0, 1]\n    >>> calculate_waiting_time([\"A\", \"B\", \"C\"], [3, 6, 11], [3, 5, 7], 3)\n    [0, 1, 4]\n    \"\"\"\n\n    waiting_time = [0] * no_of_process\n    for i in range(no_of_process):\n        waiting_time[i] = turn_around_time[i] - burst_time[i]\n    return waiting_time\n\n\nif __name__ == \"__main__\":\n    no_of_process = 5\n    process_name = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    arrival_time = [1, 2, 3, 4, 5]\n    burst_time = [1, 2, 3, 4, 5]\n\n    turn_around_time = calculate_turn_around_time(\n        process_name, arrival_time, burst_time, no_of_process\n    )\n    waiting_time = calculate_waiting_time(\n        process_name, turn_around_time, burst_time, no_of_process\n    )\n\n    print(\"Process name \\tArrival time \\tBurst time \\tTurn around time \\tWaiting time\")\n    for i in range(no_of_process):\n        print(\n            f\"{process_name[i]}\\t\\t{arrival_time[i]}\\t\\t{burst_time[i]}\\t\\t\"\n            f\"{turn_around_time[i]}\\t\\t\\t{waiting_time[i]}\"\n        )\n\n    print(f\"average waiting time : {mean(waiting_time):.5f}\")\n    print(f\"average turn around time : {mean(turn_around_time):.5f}\")\n", "scheduling/job_sequence_with_deadline.py": "\"\"\"\nGiven a list of tasks, each with a deadline and reward, calculate which tasks can be\ncompleted to yield the maximum reward.  Each task takes one unit of time to complete,\nand we can only work on one task at a time.  Once a task has passed its deadline, it\ncan no longer be scheduled.\n\nExample :\ntasks_info = [(4, 20), (1, 10), (1, 40), (1, 30)]\nmax_tasks will return (2, [2, 0]) -\nScheduling these tasks would result in a reward of 40 + 20\n\nThis problem can be solved using the concept of \"GREEDY ALGORITHM\".\nTime Complexity - O(n log n)\nhttps://medium.com/@nihardudhat2000/job-sequencing-with-deadline-17ddbb5890b5\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom operator import attrgetter\n\n\n@dataclass\nclass Task:\n    task_id: int\n    deadline: int\n    reward: int\n\n\ndef max_tasks(tasks_info: list[tuple[int, int]]) -> list[int]:\n    \"\"\"\n    Create a list of Task objects that are sorted so the highest rewards come first.\n    Return a list of those task ids that can be completed before i becomes too high.\n    >>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])\n    [2, 0]\n    >>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])\n    [3, 2]\n    >>> max_tasks([(9, 10)])\n    [0]\n    >>> max_tasks([(-9, 10)])\n    []\n    >>> max_tasks([])\n    []\n    >>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])\n    []\n    >>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])\n    []\n    \"\"\"\n    tasks = sorted(\n        (\n            Task(task_id, deadline, reward)\n            for task_id, (deadline, reward) in enumerate(tasks_info)\n        ),\n        key=attrgetter(\"reward\"),\n        reverse=True,\n    )\n    return [task.task_id for i, task in enumerate(tasks, start=1) if task.deadline >= i]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)]) = }\")\n    print(f\"{max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)]) = }\")\n", "scheduling/round_robin.py": "\"\"\"\nRound Robin is a scheduling algorithm.\nIn Round Robin each process is assigned a fixed time slot in a cyclic way.\nhttps://en.wikipedia.org/wiki/Round-robin_scheduling\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom statistics import mean\n\n\ndef calculate_waiting_times(burst_times: list[int]) -> list[int]:\n    \"\"\"\n    Calculate the waiting times of a list of processes that have a specified duration.\n\n    Return: The waiting time for each process.\n    >>> calculate_waiting_times([10, 5, 8])\n    [13, 10, 13]\n    >>> calculate_waiting_times([4, 6, 3, 1])\n    [5, 8, 9, 6]\n    >>> calculate_waiting_times([12, 2, 10])\n    [12, 2, 12]\n    \"\"\"\n    quantum = 2\n    rem_burst_times = list(burst_times)\n    waiting_times = [0] * len(burst_times)\n    t = 0\n    while True:\n        done = True\n        for i, burst_time in enumerate(burst_times):\n            if rem_burst_times[i] > 0:\n                done = False\n                if rem_burst_times[i] > quantum:\n                    t += quantum\n                    rem_burst_times[i] -= quantum\n                else:\n                    t += rem_burst_times[i]\n                    waiting_times[i] = t - burst_time\n                    rem_burst_times[i] = 0\n        if done is True:\n            return waiting_times\n\n\ndef calculate_turn_around_times(\n    burst_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])\n    [1, 3, 6]\n    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])\n    [20, 9, 18]\n    \"\"\"\n    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]\n\n\nif __name__ == \"__main__\":\n    burst_times = [3, 5, 7]\n    waiting_times = calculate_waiting_times(burst_times)\n    turn_around_times = calculate_turn_around_times(burst_times, waiting_times)\n    print(\"Process ID \\tBurst Time \\tWaiting Time \\tTurnaround Time\")\n    for i, burst_time in enumerate(burst_times):\n        print(\n            f\"  {i + 1}\\t\\t  {burst_time}\\t\\t  {waiting_times[i]}\\t\\t  \"\n            f\"{turn_around_times[i]}\"\n        )\n    print(f\"\\nAverage waiting time = {mean(waiting_times):.5f}\")\n    print(f\"Average turn around time = {mean(turn_around_times):.5f}\")\n", "scheduling/multi_level_feedback_queue.py": "from collections import deque\n\n\nclass Process:\n    def __init__(self, process_name: str, arrival_time: int, burst_time: int) -> None:\n        self.process_name = process_name  # process name\n        self.arrival_time = arrival_time  # arrival time of the process\n        # completion time of finished process or last interrupted time\n        self.stop_time = arrival_time\n        self.burst_time = burst_time  # remaining burst time\n        self.waiting_time = 0  # total time of the process wait in ready queue\n        self.turnaround_time = 0  # time from arrival time to completion time\n\n\nclass MLFQ:\n    \"\"\"\n    MLFQ(Multi Level Feedback Queue)\n    https://en.wikipedia.org/wiki/Multilevel_feedback_queue\n    MLFQ has a lot of queues that have different priority\n    In this MLFQ,\n    The first Queue(0) to last second Queue(N-2) of MLFQ have Round Robin Algorithm\n    The last Queue(N-1) has First Come, First Served Algorithm\n    \"\"\"\n\n    def __init__(\n        self,\n        number_of_queues: int,\n        time_slices: list[int],\n        queue: deque[Process],\n        current_time: int,\n    ) -> None:\n        # total number of mlfq's queues\n        self.number_of_queues = number_of_queues\n        # time slice of queues that round robin algorithm applied\n        self.time_slices = time_slices\n        # unfinished process is in this ready_queue\n        self.ready_queue = queue\n        # current time\n        self.current_time = current_time\n        # finished process is in this sequence queue\n        self.finish_queue: deque[Process] = deque()\n\n    def calculate_sequence_of_finish_queue(self) -> list[str]:\n        \"\"\"\n        This method returns the sequence of finished processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> _ = mlfq.multi_level_feedback_queue()\n        >>> mlfq.calculate_sequence_of_finish_queue()\n        ['P2', 'P4', 'P1', 'P3']\n        \"\"\"\n        sequence = []\n        for i in range(len(self.finish_queue)):\n            sequence.append(self.finish_queue[i].process_name)\n        return sequence\n\n    def calculate_waiting_time(self, queue: list[Process]) -> list[int]:\n        \"\"\"\n        This method calculates waiting time of processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> _ = mlfq.multi_level_feedback_queue()\n        >>> mlfq.calculate_waiting_time([P1, P2, P3, P4])\n        [83, 17, 94, 101]\n        \"\"\"\n        waiting_times = []\n        for i in range(len(queue)):\n            waiting_times.append(queue[i].waiting_time)\n        return waiting_times\n\n    def calculate_turnaround_time(self, queue: list[Process]) -> list[int]:\n        \"\"\"\n        This method calculates turnaround time of processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> _ = mlfq.multi_level_feedback_queue()\n        >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])\n        [136, 34, 162, 125]\n        \"\"\"\n        turnaround_times = []\n        for i in range(len(queue)):\n            turnaround_times.append(queue[i].turnaround_time)\n        return turnaround_times\n\n    def calculate_completion_time(self, queue: list[Process]) -> list[int]:\n        \"\"\"\n        This method calculates completion time of processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> _ = mlfq.multi_level_feedback_queue()\n        >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])\n        [136, 34, 162, 125]\n        \"\"\"\n        completion_times = []\n        for i in range(len(queue)):\n            completion_times.append(queue[i].stop_time)\n        return completion_times\n\n    def calculate_remaining_burst_time_of_processes(\n        self, queue: deque[Process]\n    ) -> list[int]:\n        \"\"\"\n        This method calculate remaining burst time of processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> finish_queue, ready_queue = mlfq.round_robin(deque([P1, P2, P3, P4]), 17)\n        >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)\n        [0]\n        >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)\n        [36, 51, 7]\n        >>> finish_queue, ready_queue = mlfq.round_robin(ready_queue, 25)\n        >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)\n        [0, 0]\n        >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)\n        [11, 26]\n        \"\"\"\n        return [q.burst_time for q in queue]\n\n    def update_waiting_time(self, process: Process) -> int:\n        \"\"\"\n        This method updates waiting times of unfinished processes\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> mlfq.current_time = 10\n        >>> P1.stop_time = 5\n        >>> mlfq.update_waiting_time(P1)\n        5\n        \"\"\"\n        process.waiting_time += self.current_time - process.stop_time\n        return process.waiting_time\n\n    def first_come_first_served(self, ready_queue: deque[Process]) -> deque[Process]:\n        \"\"\"\n        FCFS(First Come, First Served)\n        FCFS will be applied to MLFQ's last queue\n        A first came process will be finished at first\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> _ = mlfq.first_come_first_served(mlfq.ready_queue)\n        >>> mlfq.calculate_sequence_of_finish_queue()\n        ['P1', 'P2', 'P3', 'P4']\n        \"\"\"\n        finished: deque[Process] = deque()  # sequence deque of finished process\n        while len(ready_queue) != 0:\n            cp = ready_queue.popleft()  # current process\n\n            # if process's arrival time is later than current time, update current time\n            if self.current_time < cp.arrival_time:\n                self.current_time += cp.arrival_time\n\n            # update waiting time of current process\n            self.update_waiting_time(cp)\n            # update current time\n            self.current_time += cp.burst_time\n            # finish the process and set the process's burst-time 0\n            cp.burst_time = 0\n            # set the process's turnaround time because it is finished\n            cp.turnaround_time = self.current_time - cp.arrival_time\n            # set the completion time\n            cp.stop_time = self.current_time\n            # add the process to queue that has finished queue\n            finished.append(cp)\n\n        self.finish_queue.extend(finished)  # add finished process to finish queue\n        # FCFS will finish all remaining processes\n        return finished\n\n    def round_robin(\n        self, ready_queue: deque[Process], time_slice: int\n    ) -> tuple[deque[Process], deque[Process]]:\n        \"\"\"\n        RR(Round Robin)\n        RR will be applied to MLFQ's all queues except last queue\n        All processes can't use CPU for time more than time_slice\n        If the process consume CPU up to time_slice, it will go back to ready queue\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> finish_queue, ready_queue = mlfq.round_robin(mlfq.ready_queue, 17)\n        >>> mlfq.calculate_sequence_of_finish_queue()\n        ['P2']\n        \"\"\"\n        finished: deque[Process] = deque()  # sequence deque of terminated process\n        # just for 1 cycle and unfinished processes will go back to queue\n        for _ in range(len(ready_queue)):\n            cp = ready_queue.popleft()  # current process\n\n            # if process's arrival time is later than current time, update current time\n            if self.current_time < cp.arrival_time:\n                self.current_time += cp.arrival_time\n\n            # update waiting time of unfinished processes\n            self.update_waiting_time(cp)\n            # if the burst time of process is bigger than time-slice\n            if cp.burst_time > time_slice:\n                # use CPU for only time-slice\n                self.current_time += time_slice\n                # update remaining burst time\n                cp.burst_time -= time_slice\n                # update end point time\n                cp.stop_time = self.current_time\n                # locate the process behind the queue because it is not finished\n                ready_queue.append(cp)\n            else:\n                # use CPU for remaining burst time\n                self.current_time += cp.burst_time\n                # set burst time 0 because the process is finished\n                cp.burst_time = 0\n                # set the finish time\n                cp.stop_time = self.current_time\n                # update the process' turnaround time because it is finished\n                cp.turnaround_time = self.current_time - cp.arrival_time\n                # add the process to queue that has finished queue\n                finished.append(cp)\n\n        self.finish_queue.extend(finished)  # add finished process to finish queue\n        # return finished processes queue and remaining processes queue\n        return finished, ready_queue\n\n    def multi_level_feedback_queue(self) -> deque[Process]:\n        \"\"\"\n        MLFQ(Multi Level Feedback Queue)\n        >>> P1 = Process(\"P1\", 0, 53)\n        >>> P2 = Process(\"P2\", 0, 17)\n        >>> P3 = Process(\"P3\", 0, 68)\n        >>> P4 = Process(\"P4\", 0, 24)\n        >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        >>> finish_queue = mlfq.multi_level_feedback_queue()\n        >>> mlfq.calculate_sequence_of_finish_queue()\n        ['P2', 'P4', 'P1', 'P3']\n        \"\"\"\n\n        #  all queues except last one have round_robin algorithm\n        for i in range(self.number_of_queues - 1):\n            finished, self.ready_queue = self.round_robin(\n                self.ready_queue, self.time_slices[i]\n            )\n        #  the last queue has first_come_first_served algorithm\n        self.first_come_first_served(self.ready_queue)\n\n        return self.finish_queue\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    P1 = Process(\"P1\", 0, 53)\n    P2 = Process(\"P2\", 0, 17)\n    P3 = Process(\"P3\", 0, 68)\n    P4 = Process(\"P4\", 0, 24)\n    number_of_queues = 3\n    time_slices = [17, 25]\n    queue = deque([P1, P2, P3, P4])\n\n    if len(time_slices) != number_of_queues - 1:\n        raise SystemExit(0)\n\n    doctest.testmod(extraglobs={\"queue\": deque([P1, P2, P3, P4])})\n\n    P1 = Process(\"P1\", 0, 53)\n    P2 = Process(\"P2\", 0, 17)\n    P3 = Process(\"P3\", 0, 68)\n    P4 = Process(\"P4\", 0, 24)\n    number_of_queues = 3\n    time_slices = [17, 25]\n    queue = deque([P1, P2, P3, P4])\n    mlfq = MLFQ(number_of_queues, time_slices, queue, 0)\n    finish_queue = mlfq.multi_level_feedback_queue()\n\n    # print total waiting times of processes(P1, P2, P3, P4)\n    print(\n        f\"waiting time:\\\n        \\t\\t\\t{MLFQ.calculate_waiting_time(mlfq, [P1, P2, P3, P4])}\"\n    )\n    # print completion times of processes(P1, P2, P3, P4)\n    print(\n        f\"completion time:\\\n        \\t\\t{MLFQ.calculate_completion_time(mlfq, [P1, P2, P3, P4])}\"\n    )\n    # print total turnaround times of processes(P1, P2, P3, P4)\n    print(\n        f\"turnaround time:\\\n        \\t\\t{MLFQ.calculate_turnaround_time(mlfq, [P1, P2, P3, P4])}\"\n    )\n    # print sequence of finished processes\n    print(\n        f\"sequence of finished processes:\\\n        {mlfq.calculate_sequence_of_finish_queue()}\"\n    )\n", "scheduling/job_sequencing_with_deadline.py": "def job_sequencing_with_deadlines(jobs: list) -> list:\n    \"\"\"\n    Function to find the maximum profit by doing jobs in a given time frame\n\n    Args:\n        jobs [list]: A list of tuples of (job_id, deadline, profit)\n\n    Returns:\n        max_profit [int]: Maximum profit that can be earned by doing jobs\n        in a given time frame\n\n    Examples:\n    >>> job_sequencing_with_deadlines(\n    ... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])\n    [2, 60]\n    >>> job_sequencing_with_deadlines(\n    ... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])\n    [2, 127]\n    \"\"\"\n\n    # Sort the jobs in descending order of profit\n    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)\n\n    # Create a list of size equal to the maximum deadline\n    # and initialize it with -1\n    max_deadline = max(jobs, key=lambda value: value[1])[1]\n    time_slots = [-1] * max_deadline\n\n    # Finding the maximum profit and the count of jobs\n    count = 0\n    max_profit = 0\n    for job in jobs:\n        # Find a free time slot for this job\n        # (Note that we start from the last possible slot)\n        for i in range(job[1] - 1, -1, -1):\n            if time_slots[i] == -1:\n                time_slots[i] = job[0]\n                count += 1\n                max_profit += job[2]\n                break\n    return [count, max_profit]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "scheduling/__init__.py": "", "scheduling/first_come_first_served.py": "# Implementation of First Come First Served scheduling algorithm\n# In this Algorithm we just care about the order that the processes arrived\n# without carring about their duration time\n# https://en.wikipedia.org/wiki/Scheduling_(computing)#First_come,_first_served\nfrom __future__ import annotations\n\n\ndef calculate_waiting_times(duration_times: list[int]) -> list[int]:\n    \"\"\"\n    This function calculates the waiting time of some processes that have a\n    specified duration time.\n        Return: The waiting time for each process.\n    >>> calculate_waiting_times([5, 10, 15])\n    [0, 5, 15]\n    >>> calculate_waiting_times([1, 2, 3, 4, 5])\n    [0, 1, 3, 6, 10]\n    >>> calculate_waiting_times([10, 3])\n    [0, 10]\n    \"\"\"\n    waiting_times = [0] * len(duration_times)\n    for i in range(1, len(duration_times)):\n        waiting_times[i] = duration_times[i - 1] + waiting_times[i - 1]\n    return waiting_times\n\n\ndef calculate_turnaround_times(\n    duration_times: list[int], waiting_times: list[int]\n) -> list[int]:\n    \"\"\"\n    This function calculates the turnaround time of some processes.\n        Return: The time difference between the completion time and the\n                arrival time.\n                Practically waiting_time + duration_time\n    >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])\n    [5, 15, 30]\n    >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])\n    [1, 3, 6, 10, 15]\n    >>> calculate_turnaround_times([10, 3], [0, 10])\n    [10, 13]\n    \"\"\"\n    return [\n        duration_time + waiting_times[i]\n        for i, duration_time in enumerate(duration_times)\n    ]\n\n\ndef calculate_average_turnaround_time(turnaround_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the turnaround times\n        Return: The average of the turnaround times.\n    >>> calculate_average_turnaround_time([0, 5, 16])\n    7.0\n    >>> calculate_average_turnaround_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_turnaround_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(turnaround_times) / len(turnaround_times)\n\n\ndef calculate_average_waiting_time(waiting_times: list[int]) -> float:\n    \"\"\"\n    This function calculates the average of the waiting times\n        Return: The average of the waiting times.\n    >>> calculate_average_waiting_time([0, 5, 16])\n    7.0\n    >>> calculate_average_waiting_time([1, 5, 8, 12])\n    6.5\n    >>> calculate_average_waiting_time([10, 24])\n    17.0\n    \"\"\"\n    return sum(waiting_times) / len(waiting_times)\n\n\nif __name__ == \"__main__\":\n    # process id's\n    processes = [1, 2, 3]\n\n    # ensure that we actually have processes\n    if len(processes) == 0:\n        print(\"Zero amount of processes\")\n        raise SystemExit(0)\n\n    # duration time of all processes\n    duration_times = [19, 8, 9]\n\n    # ensure we can match each id to a duration time\n    if len(duration_times) != len(processes):\n        print(\"Unable to match all id's with their duration time\")\n        raise SystemExit(0)\n\n    # get the waiting times and the turnaround times\n    waiting_times = calculate_waiting_times(duration_times)\n    turnaround_times = calculate_turnaround_times(duration_times, waiting_times)\n\n    # get the average times\n    average_waiting_time = calculate_average_waiting_time(waiting_times)\n    average_turnaround_time = calculate_average_turnaround_time(turnaround_times)\n\n    # print all the results\n    print(\"Process ID\\tDuration Time\\tWaiting Time\\tTurnaround Time\")\n    for i, process in enumerate(processes):\n        print(\n            f\"{process}\\t\\t{duration_times[i]}\\t\\t{waiting_times[i]}\\t\\t\"\n            f\"{turnaround_times[i]}\"\n        )\n    print(f\"Average waiting time = {average_waiting_time}\")\n    print(f\"Average turn around time = {average_turnaround_time}\")\n", "quantum/q_fourier_transform.py": "\"\"\"\nBuild the quantum fourier transform (qft) for a desire\nnumber of quantum bits using Qiskit framework. This\nexperiment run in IBM Q simulator with 10000 shots.\nThis circuit can be use as a building block to design\nthe Shor's algorithm in quantum computing. As well as,\nquantum phase estimation among others.\n.\nReferences:\nhttps://en.wikipedia.org/wiki/Quantum_Fourier_transform\nhttps://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html\n\"\"\"\n\nimport math\n\nimport numpy as np\nimport qiskit\nfrom qiskit import Aer, ClassicalRegister, QuantumCircuit, QuantumRegister, execute\n\n\ndef quantum_fourier_transform(number_of_qubits: int = 3) -> qiskit.result.counts.Counts:\n    \"\"\"\n    # >>> quantum_fourier_transform(2)\n    # {'00': 2500, '01': 2500, '11': 2500, '10': 2500}\n    # quantum circuit for number_of_qubits = 3:\n                                               \u250c\u2500\u2500\u2500\u2510\n    qr_0: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500X\u2500\n                \u2502                \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518 \u2502\n    qr_1: \u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\n          \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/4)  \u2502P(\u03c0/2) \u2514\u2500\u2500\u2500\u2518               \u2502\n    qr_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\n          \u2514\u2500\u2500\u2500\u2518\n    cr: 3/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    Args:\n        n : number of qubits\n    Returns:\n        qiskit.result.counts.Counts: distribute counts.\n\n    >>> quantum_fourier_transform(2)\n    {'00': 2500, '01': 2500, '10': 2500, '11': 2500}\n    >>> quantum_fourier_transform(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be > 0.\n    >>> quantum_fourier_transform('a')\n    Traceback (most recent call last):\n        ...\n    TypeError: number of qubits must be a integer.\n    >>> quantum_fourier_transform(100)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits too large to simulate(>10).\n    >>> quantum_fourier_transform(0.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: number of qubits must be exact integer.\n    \"\"\"\n    if isinstance(number_of_qubits, str):\n        raise TypeError(\"number of qubits must be a integer.\")\n    if number_of_qubits <= 0:\n        raise ValueError(\"number of qubits must be > 0.\")\n    if math.floor(number_of_qubits) != number_of_qubits:\n        raise ValueError(\"number of qubits must be exact integer.\")\n    if number_of_qubits > 10:\n        raise ValueError(\"number of qubits too large to simulate(>10).\")\n\n    qr = QuantumRegister(number_of_qubits, \"qr\")\n    cr = ClassicalRegister(number_of_qubits, \"cr\")\n\n    quantum_circuit = QuantumCircuit(qr, cr)\n\n    counter = number_of_qubits\n\n    for i in range(counter):\n        quantum_circuit.h(number_of_qubits - i - 1)\n        counter -= 1\n        for j in range(counter):\n            quantum_circuit.cp(np.pi / 2 ** (counter - j), j, counter)\n\n    for k in range(number_of_qubits // 2):\n        quantum_circuit.swap(k, number_of_qubits - k - 1)\n\n    # measure all the qubits\n    quantum_circuit.measure(qr, cr)\n    # simulate with 10000 shots\n    backend = Aer.get_backend(\"qasm_simulator\")\n    job = execute(quantum_circuit, backend, shots=10000)\n\n    return job.result().get_counts(quantum_circuit)\n\n\nif __name__ == \"__main__\":\n    print(\n        f\"Total count for quantum fourier transform state is: \\\n    {quantum_fourier_transform(3)}\"\n    )\n", "quantum/__init__.py": "", "digital_image_processing/convert_to_negative.py": "\"\"\"\nImplemented an algorithm using opencv to convert a colored image into its negative\n\"\"\"\n\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\n\n\ndef convert_to_negative(img):\n    # getting number of pixels in the image\n    pixel_h, pixel_v = img.shape[0], img.shape[1]\n\n    # converting each pixel's color to its negative\n    for i in range(pixel_h):\n        for j in range(pixel_v):\n            img[i][j] = [255, 255, 255] - img[i][j]\n\n    return img\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(\"image_data/lena.jpg\", 1)\n\n    # convert to its negative\n    neg = convert_to_negative(img)\n\n    # show result image\n    imshow(\"negative of original image\", img)\n    waitKey(0)\n    destroyAllWindows()\n", "digital_image_processing/change_brightness.py": "from PIL import Image\n\n\ndef change_brightness(img: Image, level: float) -> Image:\n    \"\"\"\n    Change the brightness of a PIL Image to a given level.\n    \"\"\"\n\n    def brightness(c: int) -> float:\n        \"\"\"\n        Fundamental Transformation/Operation that'll be performed on\n        every bit.\n        \"\"\"\n        return 128 + level + (c - 128)\n\n    if not -255.0 <= level <= 255.0:\n        raise ValueError(\"level must be between -255.0 (black) and 255.0 (white)\")\n    return img.point(brightness)\n\n\nif __name__ == \"__main__\":\n    # Load image\n    with Image.open(\"image_data/lena.jpg\") as img:\n        # Change brightness to 100\n        brigt_img = change_brightness(img, 100)\n        brigt_img.save(\"image_data/lena_brightness.png\", format=\"png\")\n", "digital_image_processing/index_calculation.py": "# Author: Jo\u00e3o Gustavo A. Amorim\n# Author email: joaogustavoamorim@gmail.com\n# Coding date:  jan 2019\n# python/black: True\n\n# Imports\nimport numpy as np\n\n\n# Class implemented to calculus the index\nclass IndexCalculation:\n    \"\"\"\n    # Class Summary\n            This algorithm consists in calculating vegetation indices, these\n        indices can be used for precision agriculture for example (or remote\n        sensing). There are functions to define the data and to calculate the\n        implemented indices.\n\n    # Vegetation index\n        https://en.wikipedia.org/wiki/Vegetation_Index\n        A Vegetation Index (VI) is a spectral transformation of two or more bands\n        designed to enhance the contribution of vegetation properties and allow\n        reliable spatial and temporal inter-comparisons of terrestrial\n        photosynthetic activity and canopy structural variations\n\n    # Information about channels (Wavelength range for each)\n        * nir - near-infrared\n            https://www.malvernpanalytical.com/br/products/technology/near-infrared-spectroscopy\n            Wavelength Range 700 nm to 2500 nm\n        * Red Edge\n            https://en.wikipedia.org/wiki/Red_edge\n            Wavelength Range 680 nm to 730 nm\n        * red\n            https://en.wikipedia.org/wiki/Color\n            Wavelength Range 635 nm to 700 nm\n        * blue\n            https://en.wikipedia.org/wiki/Color\n            Wavelength Range 450 nm to 490 nm\n        * green\n            https://en.wikipedia.org/wiki/Color\n            Wavelength Range 520 nm to 560 nm\n\n\n    # Implemented index list\n            #\"abbreviationOfIndexName\" -- list of channels used\n\n            #\"ARVI2\"            --  red, nir\n            #\"CCCI\"             --  red, redEdge, nir\n            #\"CVI\"              --  red, green, nir\n            #\"GLI\"              --  red, green, blue\n            #\"NDVI\"             --  red, nir\n            #\"BNDVI\"            --  blue, nir\n            #\"redEdgeNDVI\"      --  red, redEdge\n            #\"GNDVI\"            --  green, nir\n            #\"GBNDVI\"           --  green, blue, nir\n            #\"GRNDVI\"           --  red, green, nir\n            #\"RBNDVI\"           --  red, blue, nir\n            #\"PNDVI\"            --  red, green, blue, nir\n            #\"ATSAVI\"           --  red, nir\n            #\"BWDRVI\"           --  blue, nir\n            #\"CIgreen\"          --  green, nir\n            #\"CIrededge\"        --  redEdge, nir\n            #\"CI\"               --  red, blue\n            #\"CTVI\"             --  red, nir\n            #\"GDVI\"             --  green, nir\n            #\"EVI\"              --  red, blue, nir\n            #\"GEMI\"             --  red, nir\n            #\"GOSAVI\"           --  green, nir\n            #\"GSAVI\"            --  green, nir\n            #\"Hue\"              --  red, green, blue\n            #\"IVI\"              --  red, nir\n            #\"IPVI\"             --  red, nir\n            #\"I\"                --  red, green, blue\n            #\"RVI\"              --  red, nir\n            #\"MRVI\"             --  red, nir\n            #\"MSAVI\"            --  red, nir\n            #\"NormG\"            --  red, green, nir\n            #\"NormNIR\"          --  red, green, nir\n            #\"NormR\"            --  red, green, nir\n            #\"NGRDI\"            --  red, green\n            #\"RI\"               --  red, green\n            #\"S\"                --  red, green, blue\n            #\"IF\"               --  red, green, blue\n            #\"DVI\"              --  red, nir\n            #\"TVI\"              --  red, nir\n            #\"NDRE\"               --  redEdge, nir\n\n    #list of all index implemented\n        #allIndex = [\"ARVI2\", \"CCCI\", \"CVI\", \"GLI\", \"NDVI\", \"BNDVI\", \"redEdgeNDVI\",\n                    \"GNDVI\", \"GBNDVI\", \"GRNDVI\", \"RBNDVI\", \"PNDVI\", \"ATSAVI\",\n                    \"BWDRVI\", \"CIgreen\", \"CIrededge\", \"CI\", \"CTVI\", \"GDVI\", \"EVI\",\n                    \"GEMI\", \"GOSAVI\", \"GSAVI\", \"Hue\", \"IVI\", \"IPVI\", \"I\", \"RVI\",\n                    \"MRVI\", \"MSAVI\", \"NormG\", \"NormNIR\", \"NormR\", \"NGRDI\", \"RI\",\n                    \"S\", \"IF\", \"DVI\", \"TVI\", \"NDRE\"]\n\n    #list of index with not blue channel\n        #notBlueIndex = [\"ARVI2\", \"CCCI\", \"CVI\", \"NDVI\", \"redEdgeNDVI\", \"GNDVI\",\n                         \"GRNDVI\", \"ATSAVI\", \"CIgreen\", \"CIrededge\", \"CTVI\", \"GDVI\",\n                         \"GEMI\", \"GOSAVI\", \"GSAVI\", \"IVI\", \"IPVI\", \"RVI\", \"MRVI\",\n                         \"MSAVI\", \"NormG\", \"NormNIR\", \"NormR\", \"NGRDI\", \"RI\", \"DVI\",\n                         \"TVI\", \"NDRE\"]\n\n    #list of index just with RGB channels\n        #RGBIndex = [\"GLI\", \"CI\", \"Hue\", \"I\", \"NGRDI\", \"RI\", \"S\", \"IF\"]\n    \"\"\"\n\n    def __init__(self, red=None, green=None, blue=None, red_edge=None, nir=None):\n        self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)\n\n    def set_matricies(self, red=None, green=None, blue=None, red_edge=None, nir=None):\n        if red is not None:\n            self.red = red\n        if green is not None:\n            self.green = green\n        if blue is not None:\n            self.blue = blue\n        if red_edge is not None:\n            self.redEdge = red_edge\n        if nir is not None:\n            self.nir = nir\n        return True\n\n    def calculation(\n        self, index=\"\", red=None, green=None, blue=None, red_edge=None, nir=None\n    ):\n        \"\"\"\n        performs the calculation of the index with the values instantiated in the class\n        :str index: abbreviation of index name to perform\n        \"\"\"\n        self.set_matricies(red=red, green=green, blue=blue, red_edge=red_edge, nir=nir)\n        funcs = {\n            \"ARVI2\": self.arv12,\n            \"CCCI\": self.ccci,\n            \"CVI\": self.cvi,\n            \"GLI\": self.gli,\n            \"NDVI\": self.ndvi,\n            \"BNDVI\": self.bndvi,\n            \"redEdgeNDVI\": self.red_edge_ndvi,\n            \"GNDVI\": self.gndvi,\n            \"GBNDVI\": self.gbndvi,\n            \"GRNDVI\": self.grndvi,\n            \"RBNDVI\": self.rbndvi,\n            \"PNDVI\": self.pndvi,\n            \"ATSAVI\": self.atsavi,\n            \"BWDRVI\": self.bwdrvi,\n            \"CIgreen\": self.ci_green,\n            \"CIrededge\": self.ci_rededge,\n            \"CI\": self.ci,\n            \"CTVI\": self.ctvi,\n            \"GDVI\": self.gdvi,\n            \"EVI\": self.evi,\n            \"GEMI\": self.gemi,\n            \"GOSAVI\": self.gosavi,\n            \"GSAVI\": self.gsavi,\n            \"Hue\": self.hue,\n            \"IVI\": self.ivi,\n            \"IPVI\": self.ipvi,\n            \"I\": self.i,\n            \"RVI\": self.rvi,\n            \"MRVI\": self.mrvi,\n            \"MSAVI\": self.m_savi,\n            \"NormG\": self.norm_g,\n            \"NormNIR\": self.norm_nir,\n            \"NormR\": self.norm_r,\n            \"NGRDI\": self.ngrdi,\n            \"RI\": self.ri,\n            \"S\": self.s,\n            \"IF\": self._if,\n            \"DVI\": self.dvi,\n            \"TVI\": self.tvi,\n            \"NDRE\": self.ndre,\n        }\n\n        try:\n            return funcs[index]()\n        except KeyError:\n            print(\"Index not in the list!\")\n            return False\n\n    def arv12(self):\n        \"\"\"\n        Atmospherically Resistant Vegetation Index 2\n        https://www.indexdatabase.de/db/i-single.php?id=396\n        :return: index\n            -0.18+1.17*(self.nir-self.red)/(self.nir+self.red)\n        \"\"\"\n        return -0.18 + (1.17 * ((self.nir - self.red) / (self.nir + self.red)))\n\n    def ccci(self):\n        \"\"\"\n        Canopy Chlorophyll Content Index\n        https://www.indexdatabase.de/db/i-single.php?id=224\n        :return: index\n        \"\"\"\n        return ((self.nir - self.redEdge) / (self.nir + self.redEdge)) / (\n            (self.nir - self.red) / (self.nir + self.red)\n        )\n\n    def cvi(self):\n        \"\"\"\n        Chlorophyll vegetation index\n        https://www.indexdatabase.de/db/i-single.php?id=391\n        :return: index\n        \"\"\"\n        return self.nir * (self.red / (self.green**2))\n\n    def gli(self):\n        \"\"\"\n        self.green leaf index\n        https://www.indexdatabase.de/db/i-single.php?id=375\n        :return: index\n        \"\"\"\n        return (2 * self.green - self.red - self.blue) / (\n            2 * self.green + self.red + self.blue\n        )\n\n    def ndvi(self):\n        \"\"\"\n        Normalized Difference self.nir/self.red Normalized Difference Vegetation\n        Index, Calibrated NDVI - CDVI\n        https://www.indexdatabase.de/db/i-single.php?id=58\n        :return: index\n        \"\"\"\n        return (self.nir - self.red) / (self.nir + self.red)\n\n    def bndvi(self):\n        \"\"\"\n            Normalized Difference self.nir/self.blue self.blue-normalized difference\n        vegetation index\n        https://www.indexdatabase.de/db/i-single.php?id=135\n        :return: index\n        \"\"\"\n        return (self.nir - self.blue) / (self.nir + self.blue)\n\n    def red_edge_ndvi(self):\n        \"\"\"\n        Normalized Difference self.rededge/self.red\n        https://www.indexdatabase.de/db/i-single.php?id=235\n        :return: index\n        \"\"\"\n        return (self.redEdge - self.red) / (self.redEdge + self.red)\n\n    def gndvi(self):\n        \"\"\"\n        Normalized Difference self.nir/self.green self.green NDVI\n        https://www.indexdatabase.de/db/i-single.php?id=401\n        :return: index\n        \"\"\"\n        return (self.nir - self.green) / (self.nir + self.green)\n\n    def gbndvi(self):\n        \"\"\"\n        self.green-self.blue NDVI\n        https://www.indexdatabase.de/db/i-single.php?id=186\n        :return: index\n        \"\"\"\n        return (self.nir - (self.green + self.blue)) / (\n            self.nir + (self.green + self.blue)\n        )\n\n    def grndvi(self):\n        \"\"\"\n        self.green-self.red NDVI\n        https://www.indexdatabase.de/db/i-single.php?id=185\n        :return: index\n        \"\"\"\n        return (self.nir - (self.green + self.red)) / (\n            self.nir + (self.green + self.red)\n        )\n\n    def rbndvi(self):\n        \"\"\"\n        self.red-self.blue NDVI\n        https://www.indexdatabase.de/db/i-single.php?id=187\n        :return: index\n        \"\"\"\n        return (self.nir - (self.blue + self.red)) / (self.nir + (self.blue + self.red))\n\n    def pndvi(self):\n        \"\"\"\n        Pan NDVI\n        https://www.indexdatabase.de/db/i-single.php?id=188\n        :return: index\n        \"\"\"\n        return (self.nir - (self.green + self.red + self.blue)) / (\n            self.nir + (self.green + self.red + self.blue)\n        )\n\n    def atsavi(self, x=0.08, a=1.22, b=0.03):\n        \"\"\"\n        Adjusted transformed soil-adjusted VI\n        https://www.indexdatabase.de/db/i-single.php?id=209\n        :return: index\n        \"\"\"\n        return a * (\n            (self.nir - a * self.red - b)\n            / (a * self.nir + self.red - a * b + x * (1 + a**2))\n        )\n\n    def bwdrvi(self):\n        \"\"\"\n        self.blue-wide dynamic range vegetation index\n        https://www.indexdatabase.de/db/i-single.php?id=136\n        :return: index\n        \"\"\"\n        return (0.1 * self.nir - self.blue) / (0.1 * self.nir + self.blue)\n\n    def ci_green(self):\n        \"\"\"\n        Chlorophyll Index self.green\n        https://www.indexdatabase.de/db/i-single.php?id=128\n        :return: index\n        \"\"\"\n        return (self.nir / self.green) - 1\n\n    def ci_rededge(self):\n        \"\"\"\n        Chlorophyll Index self.redEdge\n        https://www.indexdatabase.de/db/i-single.php?id=131\n        :return: index\n        \"\"\"\n        return (self.nir / self.redEdge) - 1\n\n    def ci(self):\n        \"\"\"\n        Coloration Index\n        https://www.indexdatabase.de/db/i-single.php?id=11\n        :return: index\n        \"\"\"\n        return (self.red - self.blue) / self.red\n\n    def ctvi(self):\n        \"\"\"\n        Corrected Transformed Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=244\n        :return: index\n        \"\"\"\n        ndvi = self.ndvi()\n        return ((ndvi + 0.5) / (abs(ndvi + 0.5))) * (abs(ndvi + 0.5) ** (1 / 2))\n\n    def gdvi(self):\n        \"\"\"\n        Difference self.nir/self.green self.green Difference Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=27\n        :return: index\n        \"\"\"\n        return self.nir - self.green\n\n    def evi(self):\n        \"\"\"\n        Enhanced Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=16\n        :return: index\n        \"\"\"\n        return 2.5 * (\n            (self.nir - self.red) / (self.nir + 6 * self.red - 7.5 * self.blue + 1)\n        )\n\n    def gemi(self):\n        \"\"\"\n        Global Environment Monitoring Index\n        https://www.indexdatabase.de/db/i-single.php?id=25\n        :return: index\n        \"\"\"\n        n = (2 * (self.nir**2 - self.red**2) + 1.5 * self.nir + 0.5 * self.red) / (\n            self.nir + self.red + 0.5\n        )\n        return n * (1 - 0.25 * n) - (self.red - 0.125) / (1 - self.red)\n\n    def gosavi(self, y=0.16):\n        \"\"\"\n        self.green Optimized Soil Adjusted Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=29\n        mit Y = 0,16\n        :return: index\n        \"\"\"\n        return (self.nir - self.green) / (self.nir + self.green + y)\n\n    def gsavi(self, n=0.5):\n        \"\"\"\n        self.green Soil Adjusted Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=31\n        mit N = 0,5\n        :return: index\n        \"\"\"\n        return ((self.nir - self.green) / (self.nir + self.green + n)) * (1 + n)\n\n    def hue(self):\n        \"\"\"\n        Hue\n        https://www.indexdatabase.de/db/i-single.php?id=34\n        :return: index\n        \"\"\"\n        return np.arctan(\n            ((2 * self.red - self.green - self.blue) / 30.5) * (self.green - self.blue)\n        )\n\n    def ivi(self, a=None, b=None):\n        \"\"\"\n        Ideal vegetation index\n        https://www.indexdatabase.de/db/i-single.php?id=276\n        b=intercept of vegetation line\n        a=soil line slope\n        :return: index\n        \"\"\"\n        return (self.nir - b) / (a * self.red)\n\n    def ipvi(self):\n        \"\"\"\n        Infraself.red percentage vegetation index\n        https://www.indexdatabase.de/db/i-single.php?id=35\n        :return: index\n        \"\"\"\n        return (self.nir / ((self.nir + self.red) / 2)) * (self.ndvi() + 1)\n\n    def i(self):\n        \"\"\"\n        Intensity\n        https://www.indexdatabase.de/db/i-single.php?id=36\n        :return: index\n        \"\"\"\n        return (self.red + self.green + self.blue) / 30.5\n\n    def rvi(self):\n        \"\"\"\n        Ratio-Vegetation-Index\n        http://www.seos-project.eu/modules/remotesensing/remotesensing-c03-s01-p01.html\n        :return: index\n        \"\"\"\n        return self.nir / self.red\n\n    def mrvi(self):\n        \"\"\"\n        Modified Normalized Difference Vegetation Index RVI\n        https://www.indexdatabase.de/db/i-single.php?id=275\n        :return: index\n        \"\"\"\n        return (self.rvi() - 1) / (self.rvi() + 1)\n\n    def m_savi(self):\n        \"\"\"\n        Modified Soil Adjusted Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=44\n        :return: index\n        \"\"\"\n        return (\n            (2 * self.nir + 1)\n            - ((2 * self.nir + 1) ** 2 - 8 * (self.nir - self.red)) ** (1 / 2)\n        ) / 2\n\n    def norm_g(self):\n        \"\"\"\n        Norm G\n        https://www.indexdatabase.de/db/i-single.php?id=50\n        :return: index\n        \"\"\"\n        return self.green / (self.nir + self.red + self.green)\n\n    def norm_nir(self):\n        \"\"\"\n        Norm self.nir\n        https://www.indexdatabase.de/db/i-single.php?id=51\n        :return: index\n        \"\"\"\n        return self.nir / (self.nir + self.red + self.green)\n\n    def norm_r(self):\n        \"\"\"\n        Norm R\n        https://www.indexdatabase.de/db/i-single.php?id=52\n        :return: index\n        \"\"\"\n        return self.red / (self.nir + self.red + self.green)\n\n    def ngrdi(self):\n        \"\"\"\n            Normalized Difference self.green/self.red Normalized self.green self.red\n        difference index, Visible Atmospherically Resistant Indices self.green\n        (VIself.green)\n        https://www.indexdatabase.de/db/i-single.php?id=390\n        :return: index\n        \"\"\"\n        return (self.green - self.red) / (self.green + self.red)\n\n    def ri(self):\n        \"\"\"\n        Normalized Difference self.red/self.green self.redness Index\n        https://www.indexdatabase.de/db/i-single.php?id=74\n        :return: index\n        \"\"\"\n        return (self.red - self.green) / (self.red + self.green)\n\n    def s(self):\n        \"\"\"\n        Saturation\n        https://www.indexdatabase.de/db/i-single.php?id=77\n        :return: index\n        \"\"\"\n        max_value = np.max([np.max(self.red), np.max(self.green), np.max(self.blue)])\n        min_value = np.min([np.min(self.red), np.min(self.green), np.min(self.blue)])\n        return (max_value - min_value) / max_value\n\n    def _if(self):\n        \"\"\"\n        Shape Index\n        https://www.indexdatabase.de/db/i-single.php?id=79\n        :return: index\n        \"\"\"\n        return (2 * self.red - self.green - self.blue) / (self.green - self.blue)\n\n    def dvi(self):\n        \"\"\"\n        Simple Ratio self.nir/self.red Difference Vegetation Index, Vegetation Index\n        Number (VIN)\n        https://www.indexdatabase.de/db/i-single.php?id=12\n        :return: index\n        \"\"\"\n        return self.nir / self.red\n\n    def tvi(self):\n        \"\"\"\n        Transformed Vegetation Index\n        https://www.indexdatabase.de/db/i-single.php?id=98\n        :return: index\n        \"\"\"\n        return (self.ndvi() + 0.5) ** (1 / 2)\n\n    def ndre(self):\n        return (self.nir - self.redEdge) / (self.nir + self.redEdge)\n\n\n\"\"\"\n# genering a random matrices to test this class\nred     = np.ones((1000,1000, 1),dtype=\"float64\") * 46787\ngreen   = np.ones((1000,1000, 1),dtype=\"float64\") * 23487\nblue    = np.ones((1000,1000, 1),dtype=\"float64\") * 14578\nredEdge = np.ones((1000,1000, 1),dtype=\"float64\") * 51045\nnir     = np.ones((1000,1000, 1),dtype=\"float64\") * 52200\n\n# Examples of how to use the class\n\n# instantiating the class\ncl = IndexCalculation()\n\n# instantiating the class with the values\n#cl = indexCalculation(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\n\n# how set the values after instantiate the class cl, (for update the data or when don't\n# instantiating the class with the values)\ncl.setMatrices(red=red, green=green, blue=blue, redEdge=redEdge, nir=nir)\n\n# calculating the indices for the instantiated values in the class\n    # Note: the CCCI index can be changed to any index implemented in the class.\nindexValue_form1    = cl.calculation(\"CCCI\", red=red, green=green, blue=blue,\n                                     redEdge=redEdge, nir=nir).astype(np.float64)\nindexValue_form2    = cl.CCCI()\n\n# calculating the index with the values directly -- you can set just the values\n# preferred  note: the *calculation* function performs the function *setMatrices*\nindexValue_form3    = cl.calculation(\"CCCI\", red=red, green=green, blue=blue,\n                                     redEdge=redEdge, nir=nir).astype(np.float64)\n\nprint(\"Form 1: \"+np.array2string(indexValue_form1, precision=20, separator=', ',\n      floatmode='maxprec_equal'))\nprint(\"Form 2: \"+np.array2string(indexValue_form2, precision=20, separator=', ',\n      floatmode='maxprec_equal'))\nprint(\"Form 3: \"+np.array2string(indexValue_form3, precision=20, separator=', ',\n      floatmode='maxprec_equal'))\n\n# A list of examples results for different type of data at NDVI\n# float16 ->    0.31567383              #NDVI (red = 50, nir = 100)\n# float32 ->    0.31578946              #NDVI (red = 50, nir = 100)\n# float64 ->    0.3157894736842105      #NDVI (red = 50, nir = 100)\n# longdouble -> 0.3157894736842105      #NDVI (red = 50, nir = 100)\n\"\"\"\n", "digital_image_processing/__init__.py": "", "digital_image_processing/sepia.py": "\"\"\"\nImplemented an algorithm using opencv to tone an image with sepia technique\n\"\"\"\n\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\n\n\ndef make_sepia(img, factor: int):\n    \"\"\"\n    Function create sepia tone.\n    Source: https://en.wikipedia.org/wiki/Sepia_(color)\n    \"\"\"\n    pixel_h, pixel_v = img.shape[0], img.shape[1]\n\n    def to_grayscale(blue, green, red):\n        \"\"\"\n        Helper function to create pixel's greyscale representation\n        Src: https://pl.wikipedia.org/wiki/YUV\n        \"\"\"\n        return 0.2126 * red + 0.587 * green + 0.114 * blue\n\n    def normalize(value):\n        \"\"\"Helper function to normalize R/G/B value -> return 255 if value > 255\"\"\"\n        return min(value, 255)\n\n    for i in range(pixel_h):\n        for j in range(pixel_v):\n            greyscale = int(to_grayscale(*img[i][j]))\n            img[i][j] = [\n                normalize(greyscale),\n                normalize(greyscale + factor),\n                normalize(greyscale + 2 * factor),\n            ]\n\n    return img\n\n\nif __name__ == \"__main__\":\n    # read original image\n    images = {\n        percentage: imread(\"image_data/lena.jpg\", 1) for percentage in (10, 20, 30, 40)\n    }\n\n    for percentage, img in images.items():\n        make_sepia(img, percentage)\n\n    for percentage, img in images.items():\n        imshow(f\"Original image with sepia (factor: {percentage})\", img)\n\n    waitKey(0)\n    destroyAllWindows()\n", "digital_image_processing/change_contrast.py": "\"\"\"\nChanging contrast with PIL\n\nThis algorithm is used in\nhttps://noivce.pythonanywhere.com/ Python web app.\n\npsf/black: True\nruff : True\n\"\"\"\n\nfrom PIL import Image\n\n\ndef change_contrast(img: Image, level: int) -> Image:\n    \"\"\"\n    Function to change contrast\n    \"\"\"\n    factor = (259 * (level + 255)) / (255 * (259 - level))\n\n    def contrast(c: int) -> int:\n        \"\"\"\n        Fundamental Transformation/Operation that'll be performed on\n        every bit.\n        \"\"\"\n        return int(128 + factor * (c - 128))\n\n    return img.point(contrast)\n\n\nif __name__ == \"__main__\":\n    # Load image\n    with Image.open(\"image_data/lena.jpg\") as img:\n        # Change contrast to 170\n        cont_img = change_contrast(img, 170)\n        cont_img.save(\"image_data/lena_high_contrast.png\", format=\"png\")\n", "digital_image_processing/morphological_operations/dilation_operation.py": "from pathlib import Path\n\nimport numpy as np\nfrom PIL import Image\n\n\ndef rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return gray image from rgb image\n    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))\n    array([[187.6453]])\n    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))\n    array([[0.]])\n    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))\n    array([[3.0598]])\n    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\n    array([[159.0524,  90.0635, 117.6989]])\n    \"\"\"\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b\n\n\ndef gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return binary image from gray image\n    >>> gray_to_binary(np.array([[127, 255, 0]]))\n    array([[False,  True, False]])\n    >>> gray_to_binary(np.array([[0]]))\n    array([[False]])\n    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\n    array([[False, False, False]])\n    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\n    array([[False,  True, False],\n           [False,  True, False],\n           [False,  True, False]])\n    \"\"\"\n    return (gray > 127) & (gray <= 255)\n\n\ndef dilation(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return dilated image\n    >>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]]))\n    array([[False, False, False]])\n    >>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]]))\n    array([[False, False, False]])\n    \"\"\"\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation > 0)\n    return output\n\n\nif __name__ == \"__main__\":\n    # read original image\n    lena_path = Path(__file__).resolve().parent / \"image_data\" / \"lena.jpg\"\n    lena = np.array(Image.open(lena_path))\n    # kernel to be applied\n    structuring_element = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    output = dilation(gray_to_binary(rgb_to_gray(lena)), structuring_element)\n    # Save the output image\n    pil_img = Image.fromarray(output).convert(\"RGB\")\n    pil_img.save(\"result_dilation.png\")\n", "digital_image_processing/morphological_operations/erosion_operation.py": "from pathlib import Path\n\nimport numpy as np\nfrom PIL import Image\n\n\ndef rgb_to_gray(rgb: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return gray image from rgb image\n\n    >>> rgb_to_gray(np.array([[[127, 255, 0]]]))\n    array([[187.6453]])\n    >>> rgb_to_gray(np.array([[[0, 0, 0]]]))\n    array([[0.]])\n    >>> rgb_to_gray(np.array([[[2, 4, 1]]]))\n    array([[3.0598]])\n    >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))\n    array([[159.0524,  90.0635, 117.6989]])\n    \"\"\"\n    r, g, b = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    return 0.2989 * r + 0.5870 * g + 0.1140 * b\n\n\ndef gray_to_binary(gray: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return binary image from gray image\n\n    >>> gray_to_binary(np.array([[127, 255, 0]]))\n    array([[False,  True, False]])\n    >>> gray_to_binary(np.array([[0]]))\n    array([[False]])\n    >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))\n    array([[False, False, False]])\n    >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))\n    array([[False,  True, False],\n           [False,  True, False],\n           [False,  True, False]])\n    \"\"\"\n    return (gray > 127) & (gray <= 255)\n\n\ndef erosion(image: np.ndarray, kernel: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return eroded image\n\n    >>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]]))\n    array([[False, False, False]])\n    >>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]]))\n    array([[False, False, False]])\n    \"\"\"\n    output = np.zeros_like(image)\n    image_padded = np.zeros(\n        (image.shape[0] + kernel.shape[0] - 1, image.shape[1] + kernel.shape[1] - 1)\n    )\n\n    # Copy image to padded image\n    image_padded[kernel.shape[0] - 2 : -1 :, kernel.shape[1] - 2 : -1 :] = image\n\n    # Iterate over image & apply kernel\n    for x in range(image.shape[1]):\n        for y in range(image.shape[0]):\n            summation = (\n                kernel * image_padded[y : y + kernel.shape[0], x : x + kernel.shape[1]]\n            ).sum()\n            output[y, x] = int(summation == 5)\n    return output\n\n\nif __name__ == \"__main__\":\n    # read original image\n    lena_path = Path(__file__).resolve().parent / \"image_data\" / \"lena.jpg\"\n    lena = np.array(Image.open(lena_path))\n\n    # kernel to be applied\n    structuring_element = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n\n    # Apply erosion operation to a binary image\n    output = erosion(gray_to_binary(rgb_to_gray(lena)), structuring_element)\n\n    # Save the output image\n    pil_img = Image.fromarray(output).convert(\"RGB\")\n    pil_img.save(\"result_erosion.png\")\n", "digital_image_processing/morphological_operations/__init__.py": "", "digital_image_processing/filters/median_filter.py": "\"\"\"\nImplementation of median filter algorithm\n\"\"\"\n\nfrom cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey\nfrom numpy import divide, int8, multiply, ravel, sort, zeros_like\n\n\ndef median_filter(gray_img, mask=3):\n    \"\"\"\n    :param gray_img: gray image\n    :param mask: mask size\n    :return: image with median filter\n    \"\"\"\n    # set image borders\n    bd = int(mask / 2)\n    # copy image size\n    median_img = zeros_like(gray_img)\n    for i in range(bd, gray_img.shape[0] - bd):\n        for j in range(bd, gray_img.shape[1] - bd):\n            # get mask according with mask\n            kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])\n            # calculate mask median\n            median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]\n            median_img[i, j] = median\n    return median_img\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(\"../image_data/lena.jpg\")\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n\n    # get values with two different mask size\n    median3x3 = median_filter(gray, 3)\n    median5x5 = median_filter(gray, 5)\n\n    # show result images\n    imshow(\"median filter with 3x3 mask\", median3x3)\n    imshow(\"median filter with 5x5 mask\", median5x5)\n    waitKey(0)\n", "digital_image_processing/filters/bilateral_filter.py": "\"\"\"\nImplementation of Bilateral filter\n\nInputs:\n    img: A 2d image with values in between 0 and 1\n    varS: variance in space dimension.\n    varI: variance in Intensity.\n    N: Kernel size(Must be an odd number)\nOutput:\n    img:A 2d zero padded image with values in between 0 and 1\n\"\"\"\n\nimport math\nimport sys\n\nimport cv2\nimport numpy as np\n\n\ndef vec_gaussian(img: np.ndarray, variance: float) -> np.ndarray:\n    # For applying gaussian function for each element in matrix.\n    sigma = math.sqrt(variance)\n    cons = 1 / (sigma * math.sqrt(2 * math.pi))\n    return cons * np.exp(-((img / sigma) ** 2) * 0.5)\n\n\ndef get_slice(img: np.ndarray, x: int, y: int, kernel_size: int) -> np.ndarray:\n    half = kernel_size // 2\n    return img[x - half : x + half + 1, y - half : y + half + 1]\n\n\ndef get_gauss_kernel(kernel_size: int, spatial_variance: float) -> np.ndarray:\n    # Creates a gaussian kernel of given dimension.\n    arr = np.zeros((kernel_size, kernel_size))\n    for i in range(kernel_size):\n        for j in range(kernel_size):\n            arr[i, j] = math.sqrt(\n                abs(i - kernel_size // 2) ** 2 + abs(j - kernel_size // 2) ** 2\n            )\n    return vec_gaussian(arr, spatial_variance)\n\n\ndef bilateral_filter(\n    img: np.ndarray,\n    spatial_variance: float,\n    intensity_variance: float,\n    kernel_size: int,\n) -> np.ndarray:\n    img2 = np.zeros(img.shape)\n    gauss_ker = get_gauss_kernel(kernel_size, spatial_variance)\n    size_x, size_y = img.shape\n    for i in range(kernel_size // 2, size_x - kernel_size // 2):\n        for j in range(kernel_size // 2, size_y - kernel_size // 2):\n            img_s = get_slice(img, i, j, kernel_size)\n            img_i = img_s - img_s[kernel_size // 2, kernel_size // 2]\n            img_ig = vec_gaussian(img_i, intensity_variance)\n            weights = np.multiply(gauss_ker, img_ig)\n            vals = np.multiply(img_s, weights)\n            val = np.sum(vals) / np.sum(weights)\n            img2[i, j] = val\n    return img2\n\n\ndef parse_args(args: list) -> tuple:\n    filename = args[1] if args[1:] else \"../image_data/lena.jpg\"\n    spatial_variance = float(args[2]) if args[2:] else 1.0\n    intensity_variance = float(args[3]) if args[3:] else 1.0\n    if args[4:]:\n        kernel_size = int(args[4])\n        kernel_size = kernel_size + abs(kernel_size % 2 - 1)\n    else:\n        kernel_size = 5\n    return filename, spatial_variance, intensity_variance, kernel_size\n\n\nif __name__ == \"__main__\":\n    filename, spatial_variance, intensity_variance, kernel_size = parse_args(sys.argv)\n    img = cv2.imread(filename, 0)\n    cv2.imshow(\"input image\", img)\n\n    out = img / 255\n    out = out.astype(\"float32\")\n    out = bilateral_filter(out, spatial_variance, intensity_variance, kernel_size)\n    out = out * 255\n    out = np.uint8(out)\n    cv2.imshow(\"output image\", out)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n", "digital_image_processing/filters/gaussian_filter.py": "\"\"\"\nImplementation of gaussian filter algorithm\n\"\"\"\n\nfrom itertools import product\n\nfrom cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey\nfrom numpy import dot, exp, mgrid, pi, ravel, square, uint8, zeros\n\n\ndef gen_gaussian_kernel(k_size, sigma):\n    center = k_size // 2\n    x, y = mgrid[0 - center : k_size - center, 0 - center : k_size - center]\n    g = 1 / (2 * pi * sigma) * exp(-(square(x) + square(y)) / (2 * square(sigma)))\n    return g\n\n\ndef gaussian_filter(image, k_size, sigma):\n    height, width = image.shape[0], image.shape[1]\n    # dst image height and width\n    dst_height = height - k_size + 1\n    dst_width = width - k_size + 1\n\n    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows\n    image_array = zeros((dst_height * dst_width, k_size * k_size))\n    for row, (i, j) in enumerate(product(range(dst_height), range(dst_width))):\n        window = ravel(image[i : i + k_size, j : j + k_size])\n        image_array[row, :] = window\n\n    #  turn the kernel into shape(k*k, 1)\n    gaussian_kernel = gen_gaussian_kernel(k_size, sigma)\n    filter_array = ravel(gaussian_kernel)\n\n    # reshape and get the dst image\n    dst = dot(image_array, filter_array).reshape(dst_height, dst_width).astype(uint8)\n\n    return dst\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(r\"../image_data/lena.jpg\")\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n\n    # get values with two different mask size\n    gaussian3x3 = gaussian_filter(gray, 3, sigma=1)\n    gaussian5x5 = gaussian_filter(gray, 5, sigma=0.8)\n\n    # show result images\n    imshow(\"gaussian filter with 3x3 mask\", gaussian3x3)\n    imshow(\"gaussian filter with 5x5 mask\", gaussian5x5)\n    waitKey()\n", "digital_image_processing/filters/convolve.py": "# @Author  : lightXu\n# @File    : convolve.py\n# @Time    : 2019/7/8 0008 \u4e0b\u5348 16:13\nfrom cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey\nfrom numpy import array, dot, pad, ravel, uint8, zeros\n\n\ndef im2col(image, block_size):\n    rows, cols = image.shape\n    dst_height = cols - block_size[1] + 1\n    dst_width = rows - block_size[0] + 1\n    image_array = zeros((dst_height * dst_width, block_size[1] * block_size[0]))\n    row = 0\n    for i in range(dst_height):\n        for j in range(dst_width):\n            window = ravel(image[i : i + block_size[0], j : j + block_size[1]])\n            image_array[row, :] = window\n            row += 1\n\n    return image_array\n\n\ndef img_convolve(image, filter_kernel):\n    height, width = image.shape[0], image.shape[1]\n    k_size = filter_kernel.shape[0]\n    pad_size = k_size // 2\n    # Pads image with the edge values of array.\n    image_tmp = pad(image, pad_size, mode=\"edge\")\n\n    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows\n    image_array = im2col(image_tmp, (k_size, k_size))\n\n    #  turn the kernel into shape(k*k, 1)\n    kernel_array = ravel(filter_kernel)\n    # reshape and get the dst image\n    dst = dot(image_array, kernel_array).reshape(height, width)\n    return dst\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(r\"../image_data/lena.jpg\")\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n    # Laplace operator\n    Laplace_kernel = array([[0, 1, 0], [1, -4, 1], [0, 1, 0]])\n    out = img_convolve(gray, Laplace_kernel).astype(uint8)\n    imshow(\"Laplacian\", out)\n    waitKey(0)\n", "digital_image_processing/filters/laplacian_filter.py": "# @Author  : ojas-wani\n# @File    : laplacian_filter.py\n# @Date    : 10/04/2023\n\nimport numpy as np\nfrom cv2 import (\n    BORDER_DEFAULT,\n    COLOR_BGR2GRAY,\n    CV_64F,\n    cvtColor,\n    filter2D,\n    imread,\n    imshow,\n    waitKey,\n)\n\nfrom digital_image_processing.filters.gaussian_filter import gaussian_filter\n\n\ndef my_laplacian(src: np.ndarray, ksize: int) -> np.ndarray:\n    \"\"\"\n    :param src: the source image, which should be a grayscale or color image.\n    :param ksize: the size of the kernel used to compute the Laplacian filter,\n                  which can be 1, 3, 5, or 7.\n\n    >>> my_laplacian(src=np.array([]), ksize=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: ksize must be in (1, 3, 5, 7)\n    \"\"\"\n    kernels = {\n        1: np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]]),\n        3: np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]),\n        5: np.array(\n            [\n                [0, 0, -1, 0, 0],\n                [0, -1, -2, -1, 0],\n                [-1, -2, 16, -2, -1],\n                [0, -1, -2, -1, 0],\n                [0, 0, -1, 0, 0],\n            ]\n        ),\n        7: np.array(\n            [\n                [0, 0, 0, -1, 0, 0, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, -2, -7, -10, -7, -2, 0],\n                [-1, -3, -10, 68, -10, -3, -1],\n                [0, -2, -7, -10, -7, -2, 0],\n                [0, 0, -2, -3, -2, 0, 0],\n                [0, 0, 0, -1, 0, 0, 0],\n            ]\n        ),\n    }\n    if ksize not in kernels:\n        msg = f\"ksize must be in {tuple(kernels)}\"\n        raise ValueError(msg)\n\n    # Apply the Laplacian kernel using convolution\n    return filter2D(\n        src, CV_64F, kernels[ksize], 0, borderType=BORDER_DEFAULT, anchor=(0, 0)\n    )\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(r\"../image_data/lena.jpg\")\n\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n\n    # Applying gaussian filter\n    blur_image = gaussian_filter(gray, 3, sigma=1)\n\n    # Apply multiple Kernel to detect edges\n    laplacian_image = my_laplacian(ksize=3, src=blur_image)\n\n    imshow(\"Original image\", img)\n    imshow(\"Detected edges using laplacian filter\", laplacian_image)\n\n    waitKey(0)\n", "digital_image_processing/filters/__init__.py": "", "digital_image_processing/filters/gabor_filter.py": "# Implementation of the Gaborfilter\n# https://en.wikipedia.org/wiki/Gabor_filter\nimport numpy as np\nfrom cv2 import COLOR_BGR2GRAY, CV_8UC3, cvtColor, filter2D, imread, imshow, waitKey\n\n\ndef gabor_filter_kernel(\n    ksize: int, sigma: int, theta: int, lambd: int, gamma: int, psi: int\n) -> np.ndarray:\n    \"\"\"\n    :param ksize:   The kernelsize of the convolutional filter (ksize x ksize)\n    :param sigma:   standard deviation of the gaussian bell curve\n    :param theta:   The orientation of the normal to the parallel stripes\n                    of Gabor function.\n    :param lambd:   Wavelength of the sinusoidal component.\n    :param gamma:   The spatial aspect ratio and specifies the ellipticity\n                    of the support of Gabor function.\n    :param psi:     The phase offset of the sinusoidal function.\n\n    >>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist()\n    [[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, \\\n0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]\n\n    \"\"\"\n\n    # prepare kernel\n    # the kernel size have to be odd\n    if (ksize % 2) == 0:\n        ksize = ksize + 1\n    gabor = np.zeros((ksize, ksize), dtype=np.float32)\n\n    # each value\n    for y in range(ksize):\n        for x in range(ksize):\n            # distance from center\n            px = x - ksize // 2\n            py = y - ksize // 2\n\n            # degree to radiant\n            _theta = theta / 180 * np.pi\n            cos_theta = np.cos(_theta)\n            sin_theta = np.sin(_theta)\n\n            # get kernel x\n            _x = cos_theta * px + sin_theta * py\n\n            # get kernel y\n            _y = -sin_theta * px + cos_theta * py\n\n            # fill kernel\n            gabor[y, x] = np.exp(-(_x**2 + gamma**2 * _y**2) / (2 * sigma**2)) * np.cos(\n                2 * np.pi * _x / lambd + psi\n            )\n\n    return gabor\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    # read original image\n    img = imread(\"../image_data/lena.jpg\")\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n\n    # Apply multiple Kernel to detect edges\n    out = np.zeros(gray.shape[:2])\n    for theta in [0, 30, 60, 90, 120, 150]:\n        \"\"\"\n        ksize = 10\n        sigma = 8\n        lambd = 10\n        gamma = 0\n        psi = 0\n        \"\"\"\n        kernel_10 = gabor_filter_kernel(10, 8, theta, 10, 0, 0)\n        out += filter2D(gray, CV_8UC3, kernel_10)\n    out = out / out.max() * 255\n    out = out.astype(np.uint8)\n\n    imshow(\"Original\", gray)\n    imshow(\"Gabor filter with 20x20 mask and 6 directions\", out)\n\n    waitKey(0)\n", "digital_image_processing/filters/sobel_filter.py": "# @Author  : lightXu\n# @File    : sobel_filter.py\n# @Time    : 2019/7/8 0008 \u4e0b\u5348 16:26\nimport numpy as np\nfrom cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey\n\nfrom digital_image_processing.filters.convolve import img_convolve\n\n\ndef sobel_filter(image):\n    kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])\n\n    dst_x = np.abs(img_convolve(image, kernel_x))\n    dst_y = np.abs(img_convolve(image, kernel_y))\n    # modify the pix within [0, 255]\n    dst_x = dst_x * 255 / np.max(dst_x)\n    dst_y = dst_y * 255 / np.max(dst_y)\n\n    dst_xy = np.sqrt((np.square(dst_x)) + (np.square(dst_y)))\n    dst_xy = dst_xy * 255 / np.max(dst_xy)\n    dst = dst_xy.astype(np.uint8)\n\n    theta = np.arctan2(dst_y, dst_x)\n    return dst, theta\n\n\nif __name__ == \"__main__\":\n    # read original image\n    img = imread(\"../image_data/lena.jpg\")\n    # turn image in gray scale value\n    gray = cvtColor(img, COLOR_BGR2GRAY)\n\n    sobel_grad, sobel_theta = sobel_filter(gray)\n\n    # show result images\n    imshow(\"sobel filter\", sobel_grad)\n    imshow(\"sobel theta\", sobel_theta)\n    waitKey(0)\n", "digital_image_processing/filters/local_binary_pattern.py": "import cv2\nimport numpy as np\n\n\ndef get_neighbors_pixel(\n    image: np.ndarray, x_coordinate: int, y_coordinate: int, center: int\n) -> int:\n    \"\"\"\n    Comparing local neighborhood pixel value with threshold value of centre pixel.\n    Exception is required when neighborhood value of a center pixel value is null.\n    i.e. values present at boundaries.\n\n    :param image: The image we're working with\n    :param x_coordinate: x-coordinate of the  pixel\n    :param y_coordinate: The y coordinate of the pixel\n    :param center: center pixel value\n    :return: The value of the pixel is being returned.\n    \"\"\"\n\n    try:\n        return int(image[x_coordinate][y_coordinate] >= center)\n    except (IndexError, TypeError):\n        return 0\n\n\ndef local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:\n    \"\"\"\n    It takes an image, an x and y coordinate, and returns the\n    decimal value of the local binary patternof the pixel\n    at that coordinate\n\n    :param image: the image to be processed\n    :param x_coordinate: x coordinate of the pixel\n    :param y_coordinate: the y coordinate of the pixel\n    :return: The decimal value of the binary value of the pixels\n    around the center pixel.\n    \"\"\"\n    center = image[x_coordinate][y_coordinate]\n    powers = [1, 2, 4, 8, 16, 32, 64, 128]\n\n    # skip get_neighbors_pixel if center is null\n    if center is None:\n        return 0\n\n    # Starting from the top right, assigning value to pixels clockwise\n    binary_values = [\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center),\n        get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center),\n        get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center),\n    ]\n\n    # Converting the binary value to decimal.\n    return sum(\n        binary_value * power for binary_value, power in zip(binary_values, powers)\n    )\n\n\nif __name__ == \"__main__\":\n    # Reading the image and converting it to grayscale.\n    image = cv2.imread(\n        \"digital_image_processing/image_data/lena.jpg\", cv2.IMREAD_GRAYSCALE\n    )\n\n    # Create a numpy array as the same height and width of read image\n    lbp_image = np.zeros((image.shape[0], image.shape[1]))\n\n    # Iterating through the image and calculating the\n    # local binary pattern value for each pixel.\n    for i in range(image.shape[0]):\n        for j in range(image.shape[1]):\n            lbp_image[i][j] = local_binary_value(image, i, j)\n\n    cv2.imshow(\"local binary pattern\", lbp_image)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n", "digital_image_processing/histogram_equalization/__init__.py": "", "digital_image_processing/histogram_equalization/histogram_stretch.py": "\"\"\"\nCreated on Fri Sep 28 15:22:29 2018\n\n@author: Binish125\n\"\"\"\n\nimport copy\nimport os\n\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n\nclass ConstantStretch:\n    def __init__(self):\n        self.img = \"\"\n        self.original_image = \"\"\n        self.last_list = []\n        self.rem = 0\n        self.L = 256\n        self.sk = 0\n        self.k = 0\n        self.number_of_rows = 0\n        self.number_of_cols = 0\n\n    def stretch(self, input_image):\n        self.img = cv2.imread(input_image, 0)\n        self.original_image = copy.deepcopy(self.img)\n        x, _, _ = plt.hist(self.img.ravel(), 256, [0, 256], label=\"x\")\n        self.k = np.sum(x)\n        for i in range(len(x)):\n            prk = x[i] / self.k\n            self.sk += prk\n            last = (self.L - 1) * self.sk\n            if self.rem != 0:\n                self.rem = int(last % last)\n            last = int(last + 1 if self.rem >= 0.5 else last)\n            self.last_list.append(last)\n            self.number_of_rows = int(np.ma.count(self.img) / self.img[1].size)\n            self.number_of_cols = self.img[1].size\n        for i in range(self.number_of_cols):\n            for j in range(self.number_of_rows):\n                num = self.img[j][i]\n                if num != self.last_list[num]:\n                    self.img[j][i] = self.last_list[num]\n        cv2.imwrite(\"output_data/output.jpg\", self.img)\n\n    def plot_histogram(self):\n        plt.hist(self.img.ravel(), 256, [0, 256])\n\n    def show_image(self):\n        cv2.imshow(\"Output-Image\", self.img)\n        cv2.imshow(\"Input-Image\", self.original_image)\n        cv2.waitKey(5000)\n        cv2.destroyAllWindows()\n\n\nif __name__ == \"__main__\":\n    file_path = os.path.join(os.path.basename(__file__), \"image_data/input.jpg\")\n    stretcher = ConstantStretch()\n    stretcher.stretch(file_path)\n    stretcher.plot_histogram()\n    stretcher.show_image()\n", "digital_image_processing/dithering/burkes.py": "\"\"\"\nImplementation Burke's algorithm (dithering)\n\"\"\"\n\nimport numpy as np\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\n\n\nclass Burkes:\n    \"\"\"\n    Burke's algorithm is using for converting grayscale image to black and white version\n    Source: Source: https://en.wikipedia.org/wiki/Dither\n\n    Note:\n        * Best results are given with threshold= ~1/2 * max greyscale value.\n        * This implementation get RGB image and converts it to greyscale in runtime.\n    \"\"\"\n\n    def __init__(self, input_img, threshold: int):\n        self.min_threshold = 0\n        # max greyscale value for #FFFFFF\n        self.max_threshold = int(self.get_greyscale(255, 255, 255))\n\n        if not self.min_threshold < threshold < self.max_threshold:\n            msg = f\"Factor value should be from 0 to {self.max_threshold}\"\n            raise ValueError(msg)\n\n        self.input_img = input_img\n        self.threshold = threshold\n        self.width, self.height = self.input_img.shape[1], self.input_img.shape[0]\n\n        # error table size (+4 columns and +1 row) greater than input image because of\n        # lack of if statements\n        self.error_table = [\n            [0 for _ in range(self.height + 4)] for __ in range(self.width + 1)\n        ]\n        self.output_img = np.ones((self.width, self.height, 3), np.uint8) * 255\n\n    @classmethod\n    def get_greyscale(cls, blue: int, green: int, red: int) -> float:\n        \"\"\"\n        >>> Burkes.get_greyscale(3, 4, 5)\n        4.185\n        >>> Burkes.get_greyscale(0, 0, 0)\n        0.0\n        >>> Burkes.get_greyscale(255, 255, 255)\n        255.0\n        \"\"\"\n        \"\"\"\n        Formula from https://en.wikipedia.org/wiki/HSL_and_HSV\n        cf Lightness section, and Fig 13c.\n        We use the first of four possible.\n        \"\"\"\n        return 0.114 * blue + 0.587 * green + 0.299 * red\n\n    def process(self) -> None:\n        for y in range(self.height):\n            for x in range(self.width):\n                greyscale = int(self.get_greyscale(*self.input_img[y][x]))\n                if self.threshold > greyscale + self.error_table[y][x]:\n                    self.output_img[y][x] = (0, 0, 0)\n                    current_error = greyscale + self.error_table[y][x]\n                else:\n                    self.output_img[y][x] = (255, 255, 255)\n                    current_error = greyscale + self.error_table[y][x] - 255\n                \"\"\"\n                Burkes error propagation (`*` is current pixel):\n\n                                 *          8/32        4/32\n                2/32    4/32    8/32    4/32    2/32\n                \"\"\"\n                self.error_table[y][x + 1] += int(8 / 32 * current_error)\n                self.error_table[y][x + 2] += int(4 / 32 * current_error)\n                self.error_table[y + 1][x] += int(8 / 32 * current_error)\n                self.error_table[y + 1][x + 1] += int(4 / 32 * current_error)\n                self.error_table[y + 1][x + 2] += int(2 / 32 * current_error)\n                self.error_table[y + 1][x - 1] += int(4 / 32 * current_error)\n                self.error_table[y + 1][x - 2] += int(2 / 32 * current_error)\n\n\nif __name__ == \"__main__\":\n    # create Burke's instances with original images in greyscale\n    burkes_instances = [\n        Burkes(imread(\"image_data/lena.jpg\", 1), threshold)\n        for threshold in (1, 126, 130, 140)\n    ]\n\n    for burkes in burkes_instances:\n        burkes.process()\n\n    for burkes in burkes_instances:\n        imshow(\n            f\"Original image with dithering threshold: {burkes.threshold}\",\n            burkes.output_img,\n        )\n\n    waitKey(0)\n    destroyAllWindows()\n", "digital_image_processing/dithering/__init__.py": "", "digital_image_processing/resize/resize.py": "\"\"\"Multiple image resizing techniques\"\"\"\n\nimport numpy as np\nfrom cv2 import destroyAllWindows, imread, imshow, waitKey\n\n\nclass NearestNeighbour:\n    \"\"\"\n    Simplest and fastest version of image resizing.\n    Source: https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation\n    \"\"\"\n\n    def __init__(self, img, dst_width: int, dst_height: int):\n        if dst_width < 0 or dst_height < 0:\n            raise ValueError(\"Destination width/height should be > 0\")\n\n        self.img = img\n        self.src_w = img.shape[1]\n        self.src_h = img.shape[0]\n        self.dst_w = dst_width\n        self.dst_h = dst_height\n\n        self.ratio_x = self.src_w / self.dst_w\n        self.ratio_y = self.src_h / self.dst_h\n\n        self.output = self.output_img = (\n            np.ones((self.dst_h, self.dst_w, 3), np.uint8) * 255\n        )\n\n    def process(self):\n        for i in range(self.dst_h):\n            for j in range(self.dst_w):\n                self.output[i][j] = self.img[self.get_y(i)][self.get_x(j)]\n\n    def get_x(self, x: int) -> int:\n        \"\"\"\n        Get parent X coordinate for destination X\n        :param x: Destination X coordinate\n        :return: Parent X coordinate based on `x ratio`\n        >>> nn = NearestNeighbour(imread(\"digital_image_processing/image_data/lena.jpg\",\n        ...                              1), 100, 100)\n        >>> nn.ratio_x = 0.5\n        >>> nn.get_x(4)\n        2\n        \"\"\"\n        return int(self.ratio_x * x)\n\n    def get_y(self, y: int) -> int:\n        \"\"\"\n        Get parent Y coordinate for destination Y\n        :param y: Destination X coordinate\n        :return: Parent X coordinate based on `y ratio`\n        >>> nn = NearestNeighbour(imread(\"digital_image_processing/image_data/lena.jpg\",\n        ...                              1), 100, 100)\n        >>> nn.ratio_y = 0.5\n        >>> nn.get_y(4)\n        2\n        \"\"\"\n        return int(self.ratio_y * y)\n\n\nif __name__ == \"__main__\":\n    dst_w, dst_h = 800, 600\n    im = imread(\"image_data/lena.jpg\", 1)\n    n = NearestNeighbour(im, dst_w, dst_h)\n    n.process()\n\n    imshow(\n        f\"Image resized from: {im.shape[1]}x{im.shape[0]} to {dst_w}x{dst_h}\", n.output\n    )\n    waitKey(0)\n    destroyAllWindows()\n", "digital_image_processing/resize/__init__.py": "", "digital_image_processing/rotation/rotation.py": "from pathlib import Path\n\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n\ndef get_rotation(\n    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int\n) -> np.ndarray:\n    \"\"\"\n    Get image rotation\n    :param img: np.ndarray\n    :param pt1: 3x2 list\n    :param pt2: 3x2 list\n    :param rows: columns image shape\n    :param cols: rows image shape\n    :return: np.ndarray\n    \"\"\"\n    matrix = cv2.getAffineTransform(pt1, pt2)\n    return cv2.warpAffine(img, matrix, (rows, cols))\n\n\nif __name__ == \"__main__\":\n    # read original image\n    image = cv2.imread(\n        str(Path(__file__).resolve().parent.parent / \"image_data\" / \"lena.jpg\")\n    )\n    # turn image in gray scale value\n    gray_img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    # get image shape\n    img_rows, img_cols = gray_img.shape\n\n    # set different points to rotate image\n    pts1 = np.array([[50, 50], [200, 50], [50, 200]], np.float32)\n    pts2 = np.array([[10, 100], [200, 50], [100, 250]], np.float32)\n    pts3 = np.array([[50, 50], [150, 50], [120, 200]], np.float32)\n    pts4 = np.array([[10, 100], [80, 50], [180, 250]], np.float32)\n\n    # add all rotated images in a list\n    images = [\n        gray_img,\n        get_rotation(gray_img, pts1, pts2, img_rows, img_cols),\n        get_rotation(gray_img, pts2, pts3, img_rows, img_cols),\n        get_rotation(gray_img, pts2, pts4, img_rows, img_cols),\n    ]\n\n    # plot different image rotations\n    fig = plt.figure(1)\n    titles = [\"Original\", \"Rotation 1\", \"Rotation 2\", \"Rotation 3\"]\n    for i, image in enumerate(images):\n        plt.subplot(2, 2, i + 1), plt.imshow(image, \"gray\")\n        plt.title(titles[i])\n        plt.axis(\"off\")\n        plt.subplots_adjust(left=0.0, bottom=0.05, right=1.0, top=0.95)\n    plt.show()\n", "digital_image_processing/rotation/__init__.py": "", "digital_image_processing/edge_detection/canny.py": "import cv2\nimport numpy as np\n\nfrom digital_image_processing.filters.convolve import img_convolve\nfrom digital_image_processing.filters.sobel_filter import sobel_filter\n\nPI = 180\n\n\ndef gen_gaussian_kernel(k_size, sigma):\n    center = k_size // 2\n    x, y = np.mgrid[0 - center : k_size - center, 0 - center : k_size - center]\n    g = (\n        1\n        / (2 * np.pi * sigma)\n        * np.exp(-(np.square(x) + np.square(y)) / (2 * np.square(sigma)))\n    )\n    return g\n\n\ndef suppress_non_maximum(image_shape, gradient_direction, sobel_grad):\n    \"\"\"\n    Non-maximum suppression. If the edge strength of the current pixel is the largest\n    compared to the other pixels in the mask with the same direction, the value will be\n    preserved. Otherwise, the value will be suppressed.\n    \"\"\"\n    destination = np.zeros(image_shape)\n\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            direction = gradient_direction[row, col]\n\n            if (\n                0 <= direction < PI / 8\n                or 15 * PI / 8 <= direction <= 2 * PI\n                or 7 * PI / 8 <= direction <= 9 * PI / 8\n            ):\n                w = sobel_grad[row, col - 1]\n                e = sobel_grad[row, col + 1]\n                if sobel_grad[row, col] >= w and sobel_grad[row, col] >= e:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                PI / 8 <= direction < 3 * PI / 8\n                or 9 * PI / 8 <= direction < 11 * PI / 8\n            ):\n                sw = sobel_grad[row + 1, col - 1]\n                ne = sobel_grad[row - 1, col + 1]\n                if sobel_grad[row, col] >= sw and sobel_grad[row, col] >= ne:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                3 * PI / 8 <= direction < 5 * PI / 8\n                or 11 * PI / 8 <= direction < 13 * PI / 8\n            ):\n                n = sobel_grad[row - 1, col]\n                s = sobel_grad[row + 1, col]\n                if sobel_grad[row, col] >= n and sobel_grad[row, col] >= s:\n                    destination[row, col] = sobel_grad[row, col]\n\n            elif (\n                5 * PI / 8 <= direction < 7 * PI / 8\n                or 13 * PI / 8 <= direction < 15 * PI / 8\n            ):\n                nw = sobel_grad[row - 1, col - 1]\n                se = sobel_grad[row + 1, col + 1]\n                if sobel_grad[row, col] >= nw and sobel_grad[row, col] >= se:\n                    destination[row, col] = sobel_grad[row, col]\n\n    return destination\n\n\ndef detect_high_low_threshold(\n    image_shape, destination, threshold_low, threshold_high, weak, strong\n):\n    \"\"\"\n    High-Low threshold detection. If an edge pixel's gradient value is higher\n    than the high threshold value, it is marked as a strong edge pixel. If an\n    edge pixel's gradient value is smaller than the high threshold value and\n    larger than the low threshold value, it is marked as a weak edge pixel. If\n    an edge pixel's value is smaller than the low threshold value, it will be\n    suppressed.\n    \"\"\"\n    for row in range(1, image_shape[0] - 1):\n        for col in range(1, image_shape[1] - 1):\n            if destination[row, col] >= threshold_high:\n                destination[row, col] = strong\n            elif destination[row, col] <= threshold_low:\n                destination[row, col] = 0\n            else:\n                destination[row, col] = weak\n\n\ndef track_edge(image_shape, destination, weak, strong):\n    \"\"\"\n    Edge tracking. Usually a weak edge pixel caused from true edges will be connected\n    to a strong edge pixel while noise responses are unconnected. As long as there is\n    one strong edge pixel that is involved in its 8-connected neighborhood, that weak\n    edge point can be identified as one that should be preserved.\n    \"\"\"\n    for row in range(1, image_shape[0]):\n        for col in range(1, image_shape[1]):\n            if destination[row, col] == weak:\n                if 255 in (\n                    destination[row, col + 1],\n                    destination[row, col - 1],\n                    destination[row - 1, col],\n                    destination[row + 1, col],\n                    destination[row - 1, col - 1],\n                    destination[row + 1, col - 1],\n                    destination[row - 1, col + 1],\n                    destination[row + 1, col + 1],\n                ):\n                    destination[row, col] = strong\n                else:\n                    destination[row, col] = 0\n\n\ndef canny(image, threshold_low=15, threshold_high=30, weak=128, strong=255):\n    # gaussian_filter\n    gaussian_out = img_convolve(image, gen_gaussian_kernel(9, sigma=1.4))\n    # get the gradient and degree by sobel_filter\n    sobel_grad, sobel_theta = sobel_filter(gaussian_out)\n    gradient_direction = PI + np.rad2deg(sobel_theta)\n\n    destination = suppress_non_maximum(image.shape, gradient_direction, sobel_grad)\n\n    detect_high_low_threshold(\n        image.shape, destination, threshold_low, threshold_high, weak, strong\n    )\n\n    track_edge(image.shape, destination, weak, strong)\n\n    return destination\n\n\nif __name__ == \"__main__\":\n    # read original image in gray mode\n    lena = cv2.imread(r\"../image_data/lena.jpg\", 0)\n    # canny edge detection\n    canny_destination = canny(lena)\n    cv2.imshow(\"canny\", canny_destination)\n    cv2.waitKey(0)\n", "digital_image_processing/edge_detection/__init__.py": "", "divide_and_conquer/max_subarray.py": "\"\"\"\nThe maximum subarray problem is the task of finding the continuous subarray that has the\nmaximum sum within a given array of numbers. For example, given the array\n[-2, 1, -3, 4, -1, 2, 1, -5, 4], the contiguous subarray with the maximum sum is\n[4, -1, 2, 1], which has a sum of 6.\n\nThis divide-and-conquer algorithm finds the maximum subarray in O(n log n) time.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport time\nfrom collections.abc import Sequence\nfrom random import randint\n\nfrom matplotlib import pyplot as plt\n\n\ndef max_subarray(\n    arr: Sequence[float], low: int, high: int\n) -> tuple[int | None, int | None, float]:\n    \"\"\"\n    Solves the maximum subarray problem using divide and conquer.\n    :param arr:     the given array of numbers\n    :param low:     the start index\n    :param high:    the end index\n    :return:        the start index of the maximum subarray, the end index of the\n                    maximum subarray, and the maximum subarray sum\n\n    >>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (3, 6, 6)\n    >>> nums = [2, 8, 9]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 2, 19)\n    >>> nums = [0, 0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (0, 0, 0)\n    >>> nums = [-1.0, 0.0, 1.0]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, 1.0)\n    >>> nums = [-2, -3, -1, -4, -6]\n    >>> max_subarray(nums, 0, len(nums) - 1)\n    (2, 2, -1)\n    >>> max_subarray([], 0, 0)\n    (None, None, 0)\n    \"\"\"\n    if not arr:\n        return None, None, 0\n    if low == high:\n        return low, high, arr[low]\n\n    mid = (low + high) // 2\n    left_low, left_high, left_sum = max_subarray(arr, low, mid)\n    right_low, right_high, right_sum = max_subarray(arr, mid + 1, high)\n    cross_left, cross_right, cross_sum = max_cross_sum(arr, low, mid, high)\n    if left_sum >= right_sum and left_sum >= cross_sum:\n        return left_low, left_high, left_sum\n    elif right_sum >= left_sum and right_sum >= cross_sum:\n        return right_low, right_high, right_sum\n    return cross_left, cross_right, cross_sum\n\n\ndef max_cross_sum(\n    arr: Sequence[float], low: int, mid: int, high: int\n) -> tuple[int, int, float]:\n    left_sum, max_left = float(\"-inf\"), -1\n    right_sum, max_right = float(\"-inf\"), -1\n\n    summ: int | float = 0\n    for i in range(mid, low - 1, -1):\n        summ += arr[i]\n        if summ > left_sum:\n            left_sum = summ\n            max_left = i\n\n    summ = 0\n    for i in range(mid + 1, high + 1):\n        summ += arr[i]\n        if summ > right_sum:\n            right_sum = summ\n            max_right = i\n\n    return max_left, max_right, (left_sum + right_sum)\n\n\ndef time_max_subarray(input_size: int) -> float:\n    arr = [randint(1, input_size) for _ in range(input_size)]\n    start = time.time()\n    max_subarray(arr, 0, input_size - 1)\n    end = time.time()\n    return end - start\n\n\ndef plot_runtimes() -> None:\n    input_sizes = [10, 100, 1000, 10000, 50000, 100000, 200000, 300000, 400000, 500000]\n    runtimes = [time_max_subarray(input_size) for input_size in input_sizes]\n    print(\"No of Inputs\\t\\tTime Taken\")\n    for input_size, runtime in zip(input_sizes, runtimes):\n        print(input_size, \"\\t\\t\", runtime)\n    plt.plot(input_sizes, runtimes)\n    plt.xlabel(\"Number of Inputs\")\n    plt.ylabel(\"Time taken in seconds\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    A random simulation of this algorithm.\n    \"\"\"\n    from doctest import testmod\n\n    testmod()\n", "divide_and_conquer/power.py": "def actual_power(a: int, b: int):\n    \"\"\"\n    Function using divide and conquer to calculate a^b.\n    It only works for integer a,b.\n\n    :param a: The base of the power operation, an integer.\n    :param b: The exponent of the power operation, a non-negative integer.\n    :return: The result of a^b.\n\n    Examples:\n    >>> actual_power(3, 2)\n    9\n    >>> actual_power(5, 3)\n    125\n    >>> actual_power(2, 5)\n    32\n    >>> actual_power(7, 0)\n    1\n    \"\"\"\n    if b == 0:\n        return 1\n    if (b % 2) == 0:\n        return actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))\n    else:\n        return a * actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))\n\n\ndef power(a: int, b: int) -> float:\n    \"\"\"\n    :param a: The base (integer).\n    :param b: The exponent (integer).\n    :return: The result of a^b, as a float for negative exponents.\n\n    >>> power(4,6)\n    4096\n    >>> power(2,3)\n    8\n    >>> power(-2,3)\n    -8\n    >>> power(2,-3)\n    0.125\n    >>> power(-2,-3)\n    -0.125\n    \"\"\"\n    if b < 0:\n        return 1 / actual_power(a, b)\n    return actual_power(a, b)\n\n\nif __name__ == \"__main__\":\n    print(power(-2, -3))\n", "divide_and_conquer/strassen_matrix_multiplication.py": "from __future__ import annotations\n\nimport math\n\n\ndef default_matrix_multiplication(a: list, b: list) -> list:\n    \"\"\"\n    Multiplication only for 2x2 matrices\n    \"\"\"\n    if len(a) != 2 or len(a[0]) != 2 or len(b) != 2 or len(b[0]) != 2:\n        raise Exception(\"Matrices are not 2x2\")\n    new_matrix = [\n        [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n        [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],\n    ]\n    return new_matrix\n\n\ndef matrix_addition(matrix_a: list, matrix_b: list):\n    return [\n        [matrix_a[row][col] + matrix_b[row][col] for col in range(len(matrix_a[row]))]\n        for row in range(len(matrix_a))\n    ]\n\n\ndef matrix_subtraction(matrix_a: list, matrix_b: list):\n    return [\n        [matrix_a[row][col] - matrix_b[row][col] for col in range(len(matrix_a[row]))]\n        for row in range(len(matrix_a))\n    ]\n\n\ndef split_matrix(a: list) -> tuple[list, list, list, list]:\n    \"\"\"\n    Given an even length matrix, returns the top_left, top_right, bot_left, bot_right\n    quadrant.\n\n    >>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])\n    ([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])\n    >>> split_matrix([\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],\n    ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]\n    ... ])  # doctest: +NORMALIZE_WHITESPACE\n    ([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],\n      [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],\n      [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],\n      [8, 4, 1, 6]])\n    \"\"\"\n    if len(a) % 2 != 0 or len(a[0]) % 2 != 0:\n        raise Exception(\"Odd matrices are not supported!\")\n\n    matrix_length = len(a)\n    mid = matrix_length // 2\n\n    top_right = [[a[i][j] for j in range(mid, matrix_length)] for i in range(mid)]\n    bot_right = [\n        [a[i][j] for j in range(mid, matrix_length)] for i in range(mid, matrix_length)\n    ]\n\n    top_left = [[a[i][j] for j in range(mid)] for i in range(mid)]\n    bot_left = [[a[i][j] for j in range(mid)] for i in range(mid, matrix_length)]\n\n    return top_left, top_right, bot_left, bot_right\n\n\ndef matrix_dimensions(matrix: list) -> tuple[int, int]:\n    return len(matrix), len(matrix[0])\n\n\ndef print_matrix(matrix: list) -> None:\n    print(\"\\n\".join(str(line) for line in matrix))\n\n\ndef actual_strassen(matrix_a: list, matrix_b: list) -> list:\n    \"\"\"\n    Recursive function to calculate the product of two matrices, using the Strassen\n    Algorithm. It only supports square matrices of any size that is a power of 2.\n    \"\"\"\n    if matrix_dimensions(matrix_a) == (2, 2):\n        return default_matrix_multiplication(matrix_a, matrix_b)\n\n    a, b, c, d = split_matrix(matrix_a)\n    e, f, g, h = split_matrix(matrix_b)\n\n    t1 = actual_strassen(a, matrix_subtraction(f, h))\n    t2 = actual_strassen(matrix_addition(a, b), h)\n    t3 = actual_strassen(matrix_addition(c, d), e)\n    t4 = actual_strassen(d, matrix_subtraction(g, e))\n    t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))\n    t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))\n    t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))\n\n    top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)\n    top_right = matrix_addition(t1, t2)\n    bot_left = matrix_addition(t3, t4)\n    bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)\n\n    # construct the new matrix from our 4 quadrants\n    new_matrix = []\n    for i in range(len(top_right)):\n        new_matrix.append(top_left[i] + top_right[i])\n    for i in range(len(bot_right)):\n        new_matrix.append(bot_left[i] + bot_right[i])\n    return new_matrix\n\n\ndef strassen(matrix1: list, matrix2: list) -> list:\n    \"\"\"\n    >>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])\n    [[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]\n    >>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])\n    [[139, 163], [121, 134], [100, 121]]\n    \"\"\"\n    if matrix_dimensions(matrix1)[1] != matrix_dimensions(matrix2)[0]:\n        msg = (\n            \"Unable to multiply these matrices, please check the dimensions.\\n\"\n            f\"Matrix A: {matrix1}\\n\"\n            f\"Matrix B: {matrix2}\"\n        )\n        raise Exception(msg)\n    dimension1 = matrix_dimensions(matrix1)\n    dimension2 = matrix_dimensions(matrix2)\n\n    if dimension1[0] == dimension1[1] and dimension2[0] == dimension2[1]:\n        return [matrix1, matrix2]\n\n    maximum = max(*dimension1, *dimension2)\n    maxim = int(math.pow(2, math.ceil(math.log2(maximum))))\n    new_matrix1 = matrix1\n    new_matrix2 = matrix2\n\n    # Adding zeros to the matrices to convert them both into square matrices of equal\n    # dimensions that are a power of 2\n    for i in range(maxim):\n        if i < dimension1[0]:\n            for _ in range(dimension1[1], maxim):\n                new_matrix1[i].append(0)\n        else:\n            new_matrix1.append([0] * maxim)\n        if i < dimension2[0]:\n            for _ in range(dimension2[1], maxim):\n                new_matrix2[i].append(0)\n        else:\n            new_matrix2.append([0] * maxim)\n\n    final_matrix = actual_strassen(new_matrix1, new_matrix2)\n\n    # Removing the additional zeros\n    for i in range(maxim):\n        if i < dimension1[0]:\n            for _ in range(dimension2[1], maxim):\n                final_matrix[i].pop()\n        else:\n            final_matrix.pop()\n    return final_matrix\n\n\nif __name__ == \"__main__\":\n    matrix1 = [\n        [2, 3, 4, 5],\n        [6, 4, 3, 1],\n        [2, 3, 6, 7],\n        [3, 1, 2, 4],\n        [2, 3, 4, 5],\n        [6, 4, 3, 1],\n        [2, 3, 6, 7],\n        [3, 1, 2, 4],\n        [2, 3, 4, 5],\n        [6, 2, 3, 1],\n    ]\n    matrix2 = [[0, 2, 1, 1], [16, 2, 3, 3], [2, 2, 7, 7], [13, 11, 22, 4]]\n    print(strassen(matrix1, matrix2))\n", "divide_and_conquer/mergesort.py": "from __future__ import annotations\n\n\ndef merge(left_half: list, right_half: list) -> list:\n    \"\"\"Helper function for mergesort.\n\n    >>> left_half = [-2]\n    >>> right_half = [-1]\n    >>> merge(left_half, right_half)\n    [-2, -1]\n\n    >>> left_half = [1,2,3]\n    >>> right_half = [4,5,6]\n    >>> merge(left_half, right_half)\n    [1, 2, 3, 4, 5, 6]\n\n    >>> left_half = [-2]\n    >>> right_half = [-1]\n    >>> merge(left_half, right_half)\n    [-2, -1]\n\n    >>> left_half = [12, 15]\n    >>> right_half = [13, 14]\n    >>> merge(left_half, right_half)\n    [12, 13, 14, 15]\n\n    >>> left_half = []\n    >>> right_half = []\n    >>> merge(left_half, right_half)\n    []\n    \"\"\"\n    sorted_array = [None] * (len(right_half) + len(left_half))\n\n    pointer1 = 0  # pointer to current index for left Half\n    pointer2 = 0  # pointer to current index for the right Half\n    index = 0  # pointer to current index for the sorted array Half\n\n    while pointer1 < len(left_half) and pointer2 < len(right_half):\n        if left_half[pointer1] < right_half[pointer2]:\n            sorted_array[index] = left_half[pointer1]\n            pointer1 += 1\n            index += 1\n        else:\n            sorted_array[index] = right_half[pointer2]\n            pointer2 += 1\n            index += 1\n    while pointer1 < len(left_half):\n        sorted_array[index] = left_half[pointer1]\n        pointer1 += 1\n        index += 1\n\n    while pointer2 < len(right_half):\n        sorted_array[index] = right_half[pointer2]\n        pointer2 += 1\n        index += 1\n\n    return sorted_array\n\n\ndef merge_sort(array: list) -> list:\n    \"\"\"Returns a list of sorted array elements using merge sort.\n\n    >>> from random import shuffle\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n    >>> shuffle(array)\n    >>> merge_sort(array)\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\n\n    >>> shuffle(array)\n    >>> merge_sort(array)\n    [-200, -10, -2, 3, 11, 99, 100, 100000]\n\n    >>> array = [-200]\n    >>> merge_sort(array)\n    [-200]\n\n    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]\n    >>> shuffle(array)\n    >>> sorted(array) == merge_sort(array)\n    True\n\n    >>> array = [-2]\n    >>> merge_sort(array)\n    [-2]\n\n    >>> array = []\n    >>> merge_sort(array)\n    []\n\n    >>> array = [10000000, 1, -1111111111, 101111111112, 9000002]\n    >>> sorted(array) == merge_sort(array)\n    True\n    \"\"\"\n    if len(array) <= 1:\n        return array\n    # the actual formula to calculate the middle element = left + (right - left) // 2\n    # this avoids integer overflow in case of large N\n    middle = 0 + (len(array) - 0) // 2\n\n    # Split the array into halves till the array length becomes equal to One\n    # merge the arrays of single length returned by mergeSort function and\n    # pass them into the merge arrays function which merges the array\n    left_half = array[:middle]\n    right_half = array[middle:]\n\n    return merge(merge_sort(left_half), merge_sort(right_half))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "divide_and_conquer/heaps_algorithm_iterative.py": "\"\"\"\nHeap's (iterative) algorithm returns the list of all permutations possible from a list.\nIt minimizes movement by generating each permutation from the previous one\nby swapping only two elements.\nMore information:\nhttps://en.wikipedia.org/wiki/Heap%27s_algorithm.\n\"\"\"\n\n\ndef heaps(arr: list) -> list:\n    \"\"\"\n    Pure python implementation of the iterative Heap's algorithm,\n    returning all permutations of a list.\n    >>> heaps([])\n    [()]\n    >>> heaps([0])\n    [(0,)]\n    >>> heaps([-1, 1])\n    [(-1, 1), (1, -1)]\n    >>> heaps([1, 2, 3])\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n    >>> from itertools import permutations\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\n    True\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\n    True\n    \"\"\"\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(n: int, arr: list):\n        c = [0] * n\n        res.append(tuple(arr))\n\n        i = 0\n        while i < n:\n            if c[i] < i:\n                if i % 2 == 0:\n                    arr[0], arr[i] = arr[i], arr[0]\n                else:\n                    arr[c[i]], arr[i] = arr[i], arr[c[i]]\n                res.append(tuple(arr))\n                c[i] += 1\n                i = 0\n            else:\n                c[i] = 0\n                i += 1\n\n    generate(len(arr), arr)\n    return res\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    arr = [int(item) for item in user_input.split(\",\")]\n    print(heaps(arr))\n", "divide_and_conquer/closest_pair_of_points.py": "\"\"\"\nThe algorithm finds distance between closest pair of points\nin the given n points.\nApproach used -> Divide and conquer\nThe points are sorted based on Xco-ords and\nthen based on Yco-ords separately.\nAnd by applying divide and conquer approach,\nminimum distance is obtained recursively.\n\n>> Closest points can lie on different sides of partition.\nThis case handled by forming a strip of points\nwhose Xco-ords distance is less than closest_pair_dis\nfrom mid-point's Xco-ords. Points sorted based on Yco-ords\nare used in this step to reduce sorting time.\nClosest pair distance is found in the strip of points. (closest_in_strip)\n\nmin(closest_pair_dis, closest_in_strip) would be the final answer.\n\nTime complexity: O(n * log n)\n\"\"\"\n\n\ndef euclidean_distance_sqr(point1, point2):\n    \"\"\"\n    >>> euclidean_distance_sqr([1,2],[2,4])\n    5\n    \"\"\"\n    return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2\n\n\ndef column_based_sort(array, column=0):\n    \"\"\"\n    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)\n    [(3, 0), (5, 1), (4, 2)]\n    \"\"\"\n    return sorted(array, key=lambda x: x[column])\n\n\ndef dis_between_closest_pair(points, points_counts, min_dis=float(\"inf\")):\n    \"\"\"\n    brute force approach to find distance between closest pair points\n\n    Parameters :\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\n\n    Returns :\n    min_dis (float):  distance between closest pair of points\n\n    >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n    5\n\n    \"\"\"\n\n    for i in range(points_counts - 1):\n        for j in range(i + 1, points_counts):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            if current_dis < min_dis:\n                min_dis = current_dis\n    return min_dis\n\n\ndef dis_between_closest_in_strip(points, points_counts, min_dis=float(\"inf\")):\n    \"\"\"\n    closest pair of points in strip\n\n    Parameters :\n    points, points_count, min_dis (list(tuple(int, int)), int, int)\n\n    Returns :\n    min_dis (float):  distance btw closest pair of points in the strip (< min_dis)\n\n    >>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)\n    85\n    \"\"\"\n\n    for i in range(min(6, points_counts - 1), points_counts):\n        for j in range(max(0, i - 6), i):\n            current_dis = euclidean_distance_sqr(points[i], points[j])\n            if current_dis < min_dis:\n                min_dis = current_dis\n    return min_dis\n\n\ndef closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, points_counts):\n    \"\"\"divide and conquer approach\n\n    Parameters :\n    points, points_count (list(tuple(int, int)), int)\n\n    Returns :\n    (float):  distance btw closest pair of points\n\n    >>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)\n    8\n    \"\"\"\n\n    # base case\n    if points_counts <= 3:\n        return dis_between_closest_pair(points_sorted_on_x, points_counts)\n\n    # recursion\n    mid = points_counts // 2\n    closest_in_left = closest_pair_of_points_sqr(\n        points_sorted_on_x, points_sorted_on_y[:mid], mid\n    )\n    closest_in_right = closest_pair_of_points_sqr(\n        points_sorted_on_y, points_sorted_on_y[mid:], points_counts - mid\n    )\n    closest_pair_dis = min(closest_in_left, closest_in_right)\n\n    \"\"\"\n    cross_strip contains the points, whose Xcoords are at a\n    distance(< closest_pair_dis) from mid's Xcoord\n    \"\"\"\n\n    cross_strip = []\n    for point in points_sorted_on_x:\n        if abs(point[0] - points_sorted_on_x[mid][0]) < closest_pair_dis:\n            cross_strip.append(point)\n\n    closest_in_strip = dis_between_closest_in_strip(\n        cross_strip, len(cross_strip), closest_pair_dis\n    )\n    return min(closest_pair_dis, closest_in_strip)\n\n\ndef closest_pair_of_points(points, points_counts):\n    \"\"\"\n    >>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))\n    28.792360097775937\n    \"\"\"\n    points_sorted_on_x = column_based_sort(points, column=0)\n    points_sorted_on_y = column_based_sort(points, column=1)\n    return (\n        closest_pair_of_points_sqr(\n            points_sorted_on_x, points_sorted_on_y, points_counts\n        )\n    ) ** 0.5\n\n\nif __name__ == \"__main__\":\n    points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]\n    print(\"Distance:\", closest_pair_of_points(points, len(points)))\n", "divide_and_conquer/max_difference_pair.py": "def max_difference(a: list[int]) -> tuple[int, int]:\n    \"\"\"\n    We are given an array A[1..n] of integers, n >= 1. We want to\n    find a pair of indices (i, j) such that\n    1 <= i <= j <= n and A[j] - A[i] is as large as possible.\n\n    Explanation:\n    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/\n\n    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])\n    (1, 9)\n    \"\"\"\n    # base case\n    if len(a) == 1:\n        return a[0], a[0]\n    else:\n        # split A into half.\n        first = a[: len(a) // 2]\n        second = a[len(a) // 2 :]\n\n        # 2 sub problems, 1/2 of original size.\n        small1, big1 = max_difference(first)\n        small2, big2 = max_difference(second)\n\n        # get min of first and max of second\n        # linear time\n        min_first = min(first)\n        max_second = max(second)\n\n        # 3 cases, either (small1, big1),\n        # (min_first, max_second), (small2, big2)\n        # constant comparisons\n        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:\n            return small2, big2\n        elif big1 - small1 > max_second - min_first:\n            return small1, big1\n        else:\n            return min_first, max_second\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "divide_and_conquer/peak.py": "\"\"\"\nFinding the peak of a unimodal list using divide and conquer.\nA unimodal array is defined as follows: array is increasing up to index p,\nthen decreasing afterwards. (for p >= 1)\nAn obvious solution can be performed in O(n),\nto find the maximum of the array.\n(From Kleinberg and Tardos. Algorithm Design.\nAddison Wesley 2006: Chapter 5 Solved Exercise 1)\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef peak(lst: list[int]) -> int:\n    \"\"\"\n    Return the peak value of `lst`.\n    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])\n    5\n    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])\n    10\n    >>> peak([1, 9, 8, 7])\n    9\n    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])\n    7\n    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])\n    4\n    \"\"\"\n    # middle index\n    m = len(lst) // 2\n\n    # choose the middle 3 elements\n    three = lst[m - 1 : m + 2]\n\n    # if middle element is peak\n    if three[1] > three[0] and three[1] > three[2]:\n        return three[1]\n\n    # if increasing, recurse on right\n    elif three[0] < three[2]:\n        if len(lst[:m]) == 2:\n            m -= 1\n        return peak(lst[m:])\n\n    # decreasing\n    else:\n        if len(lst[:m]) == 2:\n            m += 1\n        return peak(lst[:m])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "divide_and_conquer/convex_hull.py": "\"\"\"\nThe convex hull problem is problem of finding all the vertices of convex polygon, P of\na set of points in a plane such that all the points are either on the vertices of P or\ninside P. TH convex hull problem has several applications in geometrical problems,\ncomputer graphics and game development.\n\nTwo algorithms have been implemented for the convex hull problem here.\n1. A brute-force algorithm which runs in O(n^3)\n2. A divide-and-conquer algorithm which runs in O(n log(n))\n\nThere are other several other algorithms for the convex hull problem\nwhich have not been implemented here, yet.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterable\n\n\nclass Point:\n    \"\"\"\n    Defines a 2-d point for use by all convex-hull algorithms.\n\n    Parameters\n    ----------\n    x: an int or a float, the x-coordinate of the 2-d point\n    y: an int or a float, the y-coordinate of the 2-d point\n\n    Examples\n    --------\n    >>> Point(1, 2)\n    (1.0, 2.0)\n    >>> Point(\"1\", \"2\")\n    (1.0, 2.0)\n    >>> Point(1, 2) > Point(0, 1)\n    True\n    >>> Point(1, 1) == Point(1, 1)\n    True\n    >>> Point(-0.5, 1) == Point(0.5, 1)\n    False\n    >>> Point(\"pi\", \"e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'pi'\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.x, self.y = float(x), float(y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __gt__(self, other):\n        if self.x > other.x:\n            return True\n        elif self.x == other.x:\n            return self.y > other.y\n        return False\n\n    def __lt__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        if self.x > other.x:\n            return True\n        elif self.x == other.x:\n            return self.y >= other.y\n        return False\n\n    def __le__(self, other):\n        if self.x < other.x:\n            return True\n        elif self.x == other.x:\n            return self.y <= other.y\n        return False\n\n    def __repr__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def __hash__(self):\n        return hash(self.x)\n\n\ndef _construct_points(\n    list_of_tuples: list[Point] | list[list[float]] | Iterable[list[float]],\n) -> list[Point]:\n    \"\"\"\n    constructs a list of points from an array-like object of numbers\n\n    Arguments\n    ---------\n\n    list_of_tuples: array-like object of type numbers. Acceptable types so far\n    are lists, tuples and sets.\n\n    Returns\n    --------\n    points: a list where each item is of type Point. This contains only objects\n    which can be converted into a Point.\n\n    Examples\n    -------\n    >>> _construct_points([[1, 1], [2, -1], [0.3, 4]])\n    [(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]\n    >>> _construct_points([1, 2])\n    Ignoring deformed point 1. All points must have at least 2 coordinates.\n    Ignoring deformed point 2. All points must have at least 2 coordinates.\n    []\n    >>> _construct_points([])\n    []\n    >>> _construct_points(None)\n    []\n    \"\"\"\n\n    points: list[Point] = []\n    if list_of_tuples:\n        for p in list_of_tuples:\n            if isinstance(p, Point):\n                points.append(p)\n            else:\n                try:\n                    points.append(Point(p[0], p[1]))\n                except (IndexError, TypeError):\n                    print(\n                        f\"Ignoring deformed point {p}. All points\"\n                        \" must have at least 2 coordinates.\"\n                    )\n    return points\n\n\ndef _validate_input(points: list[Point] | list[list[float]]) -> list[Point]:\n    \"\"\"\n    validates an input instance before a convex-hull algorithms uses it\n\n    Parameters\n    ---------\n    points: array-like, the 2d points to validate before using with\n    a convex-hull algorithm. The elements of points must be either lists, tuples or\n    Points.\n\n    Returns\n    -------\n    points: array_like, an iterable of all well-defined Points constructed passed in.\n\n\n    Exception\n    ---------\n    ValueError: if points is empty or None, or if a wrong data structure like a scalar\n                 is passed\n\n    TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.\n                The exception to this a set which we'll convert to a list before using\n\n\n    Examples\n    -------\n    >>> _validate_input([[1, 2]])\n    [(1.0, 2.0)]\n    >>> _validate_input([(1, 2)])\n    [(1.0, 2.0)]\n    >>> _validate_input([Point(2, 1), Point(-1, 2)])\n    [(2.0, 1.0), (-1.0, 2.0)]\n    >>> _validate_input([])\n    Traceback (most recent call last):\n        ...\n    ValueError: Expecting a list of points but got []\n    >>> _validate_input(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expecting an iterable object but got an non-iterable type 1\n    \"\"\"\n\n    if not hasattr(points, \"__iter__\"):\n        msg = f\"Expecting an iterable object but got an non-iterable type {points}\"\n        raise ValueError(msg)\n\n    if not points:\n        msg = f\"Expecting a list of points but got {points}\"\n        raise ValueError(msg)\n\n    return _construct_points(points)\n\n\ndef _det(a: Point, b: Point, c: Point) -> float:\n    \"\"\"\n    Computes the sign perpendicular distance of a 2d point c from a line segment\n    ab. The sign indicates the direction of c relative to ab.\n    A Positive value means c is above ab (to the left), while a negative value\n    means c is below ab (to the right). 0 means all three points are on a straight line.\n\n    As a side note, 0.5 * abs|det| is the area of triangle abc\n\n    Parameters\n    ----------\n    a: point, the point on the left end of line segment ab\n    b: point, the point on the right end of line segment ab\n    c: point, the point for which the direction and location is desired.\n\n    Returns\n    --------\n    det: float, abs(det) is the distance of c from ab. The sign\n    indicates which side of line segment ab c is. det is computed as\n    (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)\n\n    Examples\n    ----------\n    >>> _det(Point(1, 1), Point(1, 2), Point(1, 5))\n    0.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, 10))\n    100.0\n    >>> _det(Point(0, 0), Point(10, 0), Point(0, -10))\n    -100.0\n    \"\"\"\n\n    det = (a.x * b.y + b.x * c.y + c.x * a.y) - (a.y * b.x + b.y * c.x + c.y * a.x)\n    return det\n\n\ndef convex_hull_bf(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a brute force algorithm.\n    The algorithm basically considers all combinations of points (i, j) and uses the\n    definition of convexity to determine whether (i, j) is part of the convex hull or\n    not.  (i, j) is part of the convex hull if and only iff there are no points on both\n    sides of the line segment connecting the ij, and there is no point k such that k is\n    on either end of the ij.\n\n    Runtime: O(n^3) - definitely horrible\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n    convex_hull_recursive,\n\n     Examples\n     ---------\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])\n     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n     >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])\n     [(0.0, 0.0), (10.0, 0.0)]\n     >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n     ...                 [-0.75, 1]])\n     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n     >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n     ...                 (2, -1), (2, -4), (1, -3)])\n     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n\n    points = sorted(_validate_input(points))\n    n = len(points)\n    convex_set = set()\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            points_left_of_ij = points_right_of_ij = False\n            ij_part_of_convex_hull = True\n            for k in range(n):\n                if k not in {i, j}:\n                    det_k = _det(points[i], points[j], points[k])\n\n                    if det_k > 0:\n                        points_left_of_ij = True\n                    elif det_k < 0:\n                        points_right_of_ij = True\n                    # point[i], point[j], point[k] all lie on a straight line\n                    # if point[k] is to the left of point[i] or it's to the\n                    # right of point[j], then point[i], point[j] cannot be\n                    # part of the convex hull of A\n                    elif points[k] < points[i] or points[k] > points[j]:\n                        ij_part_of_convex_hull = False\n                        break\n\n                if points_left_of_ij and points_right_of_ij:\n                    ij_part_of_convex_hull = False\n                    break\n\n            if ij_part_of_convex_hull:\n                convex_set.update([points[i], points[j]])\n\n    return sorted(convex_set)\n\n\ndef convex_hull_recursive(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy\n    The algorithm exploits the geometric properties of the problem by repeatedly\n    partitioning the set of points into smaller hulls, and finding the convex hull of\n    these smaller hulls.  The union of the convex hull from smaller hulls is the\n    solution to the convex hull of the larger problem.\n\n    Parameter\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of  2d points for which the convex-hull is needed\n\n    Runtime: O(n log n)\n\n    Returns\n    -------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    Examples\n    ---------\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n    >>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])\n    [(0.0, 0.0), (10.0, 0.0)]\n    >>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n    ...                        [-0.75, 1]])\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n    >>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n    ...                        (2, -1), (2, -4), (1, -3)])\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n\n    \"\"\"\n    points = sorted(_validate_input(points))\n    n = len(points)\n\n    # divide all the points into an upper hull and a lower hull\n    # the left most point and the right most point are definitely\n    # members of the convex hull by definition.\n    # use these two anchors to divide all the points into two hulls,\n    # an upper hull and a lower hull.\n\n    # all points to the left (above) the line joining the extreme points belong to the\n    # upper hull\n    # all points to the right (below) the line joining the extreme points below to the\n    # lower hull\n    # ignore all points on the line joining the extreme points since they cannot be\n    # part of the convex hull\n\n    left_most_point = points[0]\n    right_most_point = points[n - 1]\n\n    convex_set = {left_most_point, right_most_point}\n    upper_hull = []\n    lower_hull = []\n\n    for i in range(1, n - 1):\n        det = _det(left_most_point, right_most_point, points[i])\n\n        if det > 0:\n            upper_hull.append(points[i])\n        elif det < 0:\n            lower_hull.append(points[i])\n\n    _construct_hull(upper_hull, left_most_point, right_most_point, convex_set)\n    _construct_hull(lower_hull, right_most_point, left_most_point, convex_set)\n\n    return sorted(convex_set)\n\n\ndef _construct_hull(\n    points: list[Point], left: Point, right: Point, convex_set: set[Point]\n) -> None:\n    \"\"\"\n\n    Parameters\n    ---------\n    points: list or None, the hull of points from which to choose the next convex-hull\n        point\n    left: Point, the point to the left  of line segment joining left and right\n    right: The point to the right of the line segment joining left and right\n    convex_set: set, the current convex-hull. The state of convex-set gets updated by\n        this function\n\n    Note\n    ----\n    For the line segment 'ab', 'a' is on the left and 'b' on the right.\n    but the reverse is true for the line segment 'ba'.\n\n    Returns\n    -------\n    Nothing, only updates the state of convex-set\n    \"\"\"\n    if points:\n        extreme_point = None\n        extreme_point_distance = float(\"-inf\")\n        candidate_points = []\n\n        for p in points:\n            det = _det(left, right, p)\n\n            if det > 0:\n                candidate_points.append(p)\n\n                if det > extreme_point_distance:\n                    extreme_point_distance = det\n                    extreme_point = p\n\n        if extreme_point:\n            _construct_hull(candidate_points, left, extreme_point, convex_set)\n            convex_set.add(extreme_point)\n            _construct_hull(candidate_points, extreme_point, right, convex_set)\n\n\ndef convex_hull_melkman(points: list[Point]) -> list[Point]:\n    \"\"\"\n    Constructs the convex hull of a set of 2D points using the melkman algorithm.\n    The algorithm works by iteratively inserting points of a simple polygonal chain\n    (meaning that no line segments between two consecutive points cross each other).\n    Sorting the points yields such a polygonal chain.\n\n    For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html\n\n    Runtime: O(n log n) - O(n) if points are already sorted in the input\n\n    Parameters\n    ---------\n    points: array-like of object of Points, lists or tuples.\n    The set of 2d points for which the convex-hull is needed\n\n    Returns\n    ------\n    convex_set: list, the convex-hull of points sorted in non-decreasing order.\n\n    See Also\n    --------\n\n    Examples\n    ---------\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])\n    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]\n    >>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])\n    [(0.0, 0.0), (10.0, 0.0)]\n    >>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],\n    ...                 [-0.75, 1]])\n    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n    >>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),\n    ...                 (2, -1), (2, -4), (1, -3)])\n    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]\n    \"\"\"\n    points = sorted(_validate_input(points))\n    n = len(points)\n\n    convex_hull = points[:2]\n    for i in range(2, n):\n        det = _det(convex_hull[1], convex_hull[0], points[i])\n        if det > 0:\n            convex_hull.insert(0, points[i])\n            break\n        elif det < 0:\n            convex_hull.append(points[i])\n            break\n        else:\n            convex_hull[1] = points[i]\n    i += 1\n\n    for j in range(i, n):\n        if (\n            _det(convex_hull[0], convex_hull[-1], points[j]) > 0\n            and _det(convex_hull[-1], convex_hull[0], points[1]) < 0\n        ):\n            # The point lies within the convex hull\n            continue\n\n        convex_hull.insert(0, points[j])\n        convex_hull.append(points[j])\n        while _det(convex_hull[0], convex_hull[1], convex_hull[2]) >= 0:\n            del convex_hull[1]\n        while _det(convex_hull[-1], convex_hull[-2], convex_hull[-3]) <= 0:\n            del convex_hull[-2]\n\n    # `convex_hull` is contains the convex hull in circular order\n    return sorted(convex_hull[1:] if len(convex_hull) > 3 else convex_hull)\n\n\ndef main():\n    points = [\n        (0, 3),\n        (2, 2),\n        (1, 1),\n        (2, 1),\n        (3, 0),\n        (0, 0),\n        (3, 3),\n        (2, -1),\n        (2, -4),\n        (1, -3),\n    ]\n    # the convex set of points is\n    # [(0, 0), (0, 3), (1, -3), (2, -4), (3, 0), (3, 3)]\n    results_bf = convex_hull_bf(points)\n\n    results_recursive = convex_hull_recursive(points)\n    assert results_bf == results_recursive\n\n    results_melkman = convex_hull_melkman(points)\n    assert results_bf == results_melkman\n\n    print(results_bf)\n\n\nif __name__ == \"__main__\":\n    main()\n", "divide_and_conquer/inversions.py": "\"\"\"\nGiven an array-like data structure A[1..n], how many pairs\n(i, j) for all 1 <= i < j <= n such that A[i] > A[j]? These pairs are\ncalled inversions. Counting the number of such inversions in an array-like\nobject is the important. Among other things, counting inversions can help\nus determine how close a given array is to being sorted.\nIn this implementation, I provide two algorithms, a divide-and-conquer\nalgorithm which runs in nlogn and the brute-force n^2 algorithm.\n\"\"\"\n\n\ndef count_inversions_bf(arr):\n    \"\"\"\n    Counts the number of inversions using a naive brute-force algorithm\n    Parameters\n    ----------\n    arr: arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    num_inversions: The total number of inversions in `arr`\n    Examples\n    ---------\n     >>> count_inversions_bf([1, 4, 2, 4, 1])\n     4\n     >>> count_inversions_bf([1, 1, 2, 4, 4])\n     0\n     >>> count_inversions_bf([])\n     0\n    \"\"\"\n\n    num_inversions = 0\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num_inversions += 1\n\n    return num_inversions\n\n\ndef count_inversions_recursive(arr):\n    \"\"\"\n    Counts the number of inversions using a divide-and-conquer algorithm\n    Parameters\n    -----------\n    arr: array-like, the list containing the items for which the number\n    of inversions is desired. The elements of `arr` must be comparable.\n    Returns\n    -------\n    C: a sorted copy of `arr`.\n    num_inversions: int, the total number of inversions in 'arr'\n    Examples\n    --------\n    >>> count_inversions_recursive([1, 4, 2, 4, 1])\n    ([1, 1, 2, 4, 4], 4)\n    >>> count_inversions_recursive([1, 1, 2, 4, 4])\n    ([1, 1, 2, 4, 4], 0)\n    >>> count_inversions_recursive([])\n    ([], 0)\n    \"\"\"\n    if len(arr) <= 1:\n        return arr, 0\n    mid = len(arr) // 2\n    p = arr[0:mid]\n    q = arr[mid:]\n\n    a, inversion_p = count_inversions_recursive(p)\n    b, inversions_q = count_inversions_recursive(q)\n    c, cross_inversions = _count_cross_inversions(a, b)\n\n    num_inversions = inversion_p + inversions_q + cross_inversions\n    return c, num_inversions\n\n\ndef _count_cross_inversions(p, q):\n    \"\"\"\n    Counts the inversions across two sorted arrays.\n    And combine the two arrays into one sorted array\n    For all 1<= i<=len(P) and for all 1 <= j <= len(Q),\n    if P[i] > Q[j], then (i, j) is a cross inversion\n    Parameters\n    ----------\n    P: array-like, sorted in non-decreasing order\n    Q: array-like, sorted in non-decreasing order\n    Returns\n    ------\n    R: array-like, a sorted array of the elements of `P` and `Q`\n    num_inversion: int, the number of inversions across `P` and `Q`\n    Examples\n    --------\n    >>> _count_cross_inversions([1, 2, 3], [0, 2, 5])\n    ([0, 1, 2, 2, 3, 5], 4)\n    >>> _count_cross_inversions([1, 2, 3], [3, 4, 5])\n    ([1, 2, 3, 3, 4, 5], 0)\n    \"\"\"\n\n    r = []\n    i = j = num_inversion = 0\n    while i < len(p) and j < len(q):\n        if p[i] > q[j]:\n            # if P[1] > Q[j], then P[k] > Q[k] for all  i < k <= len(P)\n            # These are all inversions. The claim emerges from the\n            # property that P is sorted.\n            num_inversion += len(p) - i\n            r.append(q[j])\n            j += 1\n        else:\n            r.append(p[i])\n            i += 1\n\n    if i < len(p):\n        r.extend(p[i:])\n    else:\n        r.extend(q[j:])\n\n    return r, num_inversion\n\n\ndef main():\n    arr_1 = [10, 2, 1, 5, 5, 2, 11]\n\n    # this arr has 8 inversions:\n    # (10, 2), (10, 1), (10, 5), (10, 5), (10, 2), (2, 1), (5, 2), (5, 2)\n\n    num_inversions_bf = count_inversions_bf(arr_1)\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\n\n    assert num_inversions_bf == num_inversions_recursive == 8\n\n    print(\"number of inversions = \", num_inversions_bf)\n\n    # testing an array with zero inversion (a sorted arr_1)\n\n    arr_1.sort()\n    num_inversions_bf = count_inversions_bf(arr_1)\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\n\n    assert num_inversions_bf == num_inversions_recursive == 0\n    print(\"number of inversions = \", num_inversions_bf)\n\n    # an empty list should also have zero inversions\n    arr_1 = []\n    num_inversions_bf = count_inversions_bf(arr_1)\n    _, num_inversions_recursive = count_inversions_recursive(arr_1)\n\n    assert num_inversions_bf == num_inversions_recursive == 0\n    print(\"number of inversions = \", num_inversions_bf)\n\n\nif __name__ == \"__main__\":\n    main()\n", "divide_and_conquer/__init__.py": "", "divide_and_conquer/heaps_algorithm.py": "\"\"\"\nHeap's algorithm returns the list of all permutations possible from a list.\nIt minimizes movement by generating each permutation from the previous one\nby swapping only two elements.\nMore information:\nhttps://en.wikipedia.org/wiki/Heap%27s_algorithm.\n\"\"\"\n\n\ndef heaps(arr: list) -> list:\n    \"\"\"\n    Pure python implementation of the Heap's algorithm (recursive version),\n    returning all permutations of a list.\n    >>> heaps([])\n    [()]\n    >>> heaps([0])\n    [(0,)]\n    >>> heaps([-1, 1])\n    [(-1, 1), (1, -1)]\n    >>> heaps([1, 2, 3])\n    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]\n    >>> from itertools import permutations\n    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))\n    True\n    >>> all(sorted(heaps(x)) == sorted(permutations(x))\n    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))\n    True\n    \"\"\"\n\n    if len(arr) <= 1:\n        return [tuple(arr)]\n\n    res = []\n\n    def generate(k: int, arr: list):\n        if k == 1:\n            res.append(tuple(arr[:]))\n            return\n\n        generate(k - 1, arr)\n\n        for i in range(k - 1):\n            if k % 2 == 0:  # k is even\n                arr[i], arr[k - 1] = arr[k - 1], arr[i]\n            else:  # k is odd\n                arr[0], arr[k - 1] = arr[k - 1], arr[0]\n            generate(k - 1, arr)\n\n    generate(len(arr), arr)\n    return res\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    arr = [int(item) for item in user_input.split(\",\")]\n    print(heaps(arr))\n", "divide_and_conquer/kth_order_statistic.py": "\"\"\"\nFind the kth smallest element in linear time using divide and conquer.\nRecall we can do this trivially in O(nlogn) time. Sort the list and\naccess kth element in constant time.\n\nThis is a divide and conquer algorithm that can find a solution in O(n) time.\n\nFor more information of this algorithm:\nhttps://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/08/Small08.pdf\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom random import choice\n\n\ndef random_pivot(lst):\n    \"\"\"\n    Choose a random pivot for the list.\n    We can use a more sophisticated algorithm here, such as the median-of-medians\n    algorithm.\n    \"\"\"\n    return choice(lst)\n\n\ndef kth_number(lst: list[int], k: int) -> int:\n    \"\"\"\n    Return the kth smallest number in lst.\n    >>> kth_number([2, 1, 3, 4, 5], 3)\n    3\n    >>> kth_number([2, 1, 3, 4, 5], 1)\n    1\n    >>> kth_number([2, 1, 3, 4, 5], 5)\n    5\n    >>> kth_number([3, 2, 5, 6, 7, 8], 2)\n    3\n    >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)\n    43\n    \"\"\"\n    # pick a pivot and separate into list based on pivot.\n    pivot = random_pivot(lst)\n\n    # partition based on pivot\n    # linear time\n    small = [e for e in lst if e < pivot]\n    big = [e for e in lst if e > pivot]\n\n    # if we get lucky, pivot might be the element we want.\n    # we can easily see this:\n    # small (elements smaller than k)\n    # + pivot (kth element)\n    # + big (elements larger than k)\n    if len(small) == k - 1:\n        return pivot\n    # pivot is in elements bigger than k\n    elif len(small) < k - 1:\n        return kth_number(big, k - len(small) - 1)\n    # pivot is in elements smaller than k\n    else:\n        return kth_number(small, k)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/kinetic_energy.py": "\"\"\"\nFind the kinetic energy of an object, given its mass and velocity.\n\nDescription : In physics, the kinetic energy of an object is the energy that it\npossesses due to its motion.It is defined as the work needed to accelerate a body of a\ngiven mass from rest to its stated velocity.Having gained this energy during its\nacceleration, the body maintains this kinetic energy unless its speed changes.The same\namount of work is done by the body when decelerating from its current speed to a state\nof rest.Formally, a kinetic energy is any term in a system's Lagrangian which includes\na derivative with respect to time.\n\nIn classical mechanics, the kinetic energy of a non-rotating object of mass m traveling\nat a speed v is \u00bdmv\u00b2.In relativistic mechanics, this is a good approximation only when\nv is much less than the speed of light.The standard unit of kinetic energy is the\njoule, while the English unit of kinetic energy is the foot-pound.\n\nReference : https://en.m.wikipedia.org/wiki/Kinetic_energy\n\"\"\"\n\n\ndef kinetic_energy(mass: float, velocity: float) -> float:\n    \"\"\"\n    Calculate kinetic energy.\n\n    The kinetic energy of a non-rotating object of mass m traveling at a speed v is \u00bdmv\u00b2\n\n    >>> kinetic_energy(10,10)\n    500.0\n    >>> kinetic_energy(0,10)\n    0.0\n    >>> kinetic_energy(10,0)\n    0.0\n    >>> kinetic_energy(20,-20)\n    4000.0\n    >>> kinetic_energy(0,0)\n    0.0\n    >>> kinetic_energy(2,2)\n    4.0\n    >>> kinetic_energy(100,100)\n    500000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of a body cannot be negative\")\n    return 0.5 * mass * abs(velocity) * abs(velocity)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n", "physics/center_of_mass.py": "\"\"\"\nCalculating the center of mass for a discrete system of particles, given their\npositions and masses.\n\nDescription:\n\nIn physics, the center of mass of a distribution of mass in space (sometimes referred\nto as the barycenter or balance point) is the unique point at any given time where the\nweighted relative position of the distributed mass sums to zero. This is the point to\nwhich a force may be applied to cause a linear acceleration without an angular\nacceleration.\n\nCalculations in mechanics are often simplified when formulated with respect to the\ncenter of mass. It is a hypothetical point where the entire mass of an object may be\nassumed to be concentrated to visualize its motion. In other words, the center of mass\nis the particle equivalent of a given object for the application of Newton's laws of\nmotion.\n\nIn the case of a system of particles P_i, i = 1, ..., n , each with mass m_i that are\nlocated in space with coordinates r_i, i = 1, ..., n , the coordinates R of the center\nof mass corresponds to:\n\nR = (\u03a3(mi * ri) / \u03a3(mi))\n\nReference: https://en.wikipedia.org/wiki/Center_of_mass\n\"\"\"\n\nfrom collections import namedtuple\n\nParticle = namedtuple(\"Particle\", \"x y z mass\")  # noqa: PYI024\nCoord3D = namedtuple(\"Coord3D\", \"x y z\")  # noqa: PYI024\n\n\ndef center_of_mass(particles: list[Particle]) -> Coord3D:\n    \"\"\"\n    Input Parameters\n    ----------------\n    particles: list(Particle):\n    A list of particles where each particle is a tuple with it's (x, y, z) position and\n    it's mass.\n\n    Returns\n    -------\n    Coord3D:\n    A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two\n    decimal places.\n\n    Examples\n    --------\n    >>> center_of_mass([\n    ...     Particle(1.5, 4, 3.4, 4),\n    ...     Particle(5, 6.8, 7, 8.1),\n    ...     Particle(9.4, 10.1, 11.6, 12)\n    ... ])\n    Coord3D(x=6.61, y=7.98, z=8.69)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Coord3D(x=6.33, y=7.33, z=8.33)\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, -4),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([\n    ...     Particle(1, 2, 3, 0),\n    ...     Particle(5, 6, 7, 8),\n    ...     Particle(9, 10, 11, 12)\n    ... ])\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass of all particles must be greater than 0\n\n    >>> center_of_mass([])\n    Traceback (most recent call last):\n        ...\n    ValueError: No particles provided\n    \"\"\"\n    if not particles:\n        raise ValueError(\"No particles provided\")\n\n    if any(particle.mass <= 0 for particle in particles):\n        raise ValueError(\"Mass of all particles must be greater than 0\")\n\n    total_mass = sum(particle.mass for particle in particles)\n\n    center_of_mass_x = round(\n        sum(particle.x * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_y = round(\n        sum(particle.y * particle.mass for particle in particles) / total_mass, 2\n    )\n    center_of_mass_z = round(\n        sum(particle.z * particle.mass for particle in particles) / total_mass, 2\n    )\n    return Coord3D(center_of_mass_x, center_of_mass_y, center_of_mass_z)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/malus_law.py": "import math\n\n\"\"\"\nFinding the intensity of light transmitted through a polariser using Malus Law\nand by taking initial intensity and angle between polariser and axis as input\n\nDescription : Malus's law, which is named after \u00c9tienne-Louis Malus,\nsays that when a perfect polarizer is placed in a polarized\nbeam of light, the irradiance, I, of the light that passes\nthrough is given by\n I=I'cos\u00b2\u03b8\nwhere I' is the initial intensity and \u03b8 is the angle between the light's\ninitial polarization direction and the axis of the polarizer.\nA beam of unpolarized light can be thought of as containing a\nuniform mixture of linear polarizations at all possible angles.\nSince the average value of cos\u00b2\u03b8 is 1/2, the transmission coefficient becomes\nI/I' = 1/2\nIn practice, some light is lost in the polarizer and the actual transmission\nwill be somewhat lower than this, around 38% for Polaroid-type polarizers but\nconsiderably higher (>49.9%) for some birefringent prism types.\nIf two polarizers are placed one after another (the second polarizer is\ngenerally called an analyzer), the mutual angle between their polarizing axes\ngives the value of \u03b8 in Malus's law. If the two axes are orthogonal, the\npolarizers are crossed and in theory no light is transmitted, though again\npractically speaking no polarizer is perfect and the transmission is not exactly\nzero (for example, crossed Polaroid sheets appear slightly blue in colour because\ntheir extinction ratio is better in the red). If a transparent object is placed\nbetween the crossed polarizers, any polarization effects present in the sample\n(such as birefringence) will be shown as an increase in transmission.\nThis effect is used in polarimetry to measure the optical activity of a sample.\nReal polarizers are also not perfect blockers of the polarization orthogonal to\ntheir polarization axis; the ratio of the transmission of the unwanted component\nto the wanted component is called the extinction ratio, and varies from around\n1:500 for Polaroid to about 1:106 for Glan-Taylor prism polarizers.\n\nReference : \"https://en.wikipedia.org/wiki/Polarizer#Malus's_law_and_other_properties\"\n\"\"\"\n\n\ndef malus_law(initial_intensity: float, angle: float) -> float:\n    \"\"\"\n    >>> round(malus_law(10,45),2)\n    5.0\n    >>> round(malus_law(100,60),2)\n    25.0\n    >>> round(malus_law(50,150),2)\n    37.5\n    >>> round(malus_law(75,270),2)\n    0.0\n    >>> round(malus_law(10,-900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: In Malus Law, the angle is in the range 0-360 degrees\n    >>> round(malus_law(10,900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: In Malus Law, the angle is in the range 0-360 degrees\n    >>> round(malus_law(-100,900),2)\n    Traceback (most recent call last):\n        ...\n    ValueError: The value of intensity cannot be negative\n    >>> round(malus_law(100,180),2)\n    100.0\n    >>> round(malus_law(100,360),2)\n    100.0\n    \"\"\"\n\n    if initial_intensity < 0:\n        raise ValueError(\"The value of intensity cannot be negative\")\n        # handling of negative values of initial intensity\n    if angle < 0 or angle > 360:\n        raise ValueError(\"In Malus Law, the angle is in the range 0-360 degrees\")\n        # handling of values out of allowed range\n    return initial_intensity * (math.cos(math.radians(angle)) ** 2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(name=\"malus_law\")\n", "physics/casimir_effect.py": "\"\"\"\nTitle : Finding the value of magnitude of either the Casimir force, the surface area\nof one of the plates or distance between the plates provided that the other\ntwo parameters are given.\n\nDescription : In quantum field theory, the Casimir effect is a physical force\nacting on the macroscopic boundaries of a confined space which arises from the\nquantum fluctuations of the field. It is a physical force exerted between separate\nobjects, which is due to neither charge, gravity, nor the exchange of particles,\nbut instead is due to resonance of all-pervasive energy fields in the intervening\nspace between the objects. Since the strength of the force falls off rapidly with\ndistance it is only measurable when the distance between the objects is extremely\nsmall. On a submicron scale, this force becomes so strong that it becomes the\ndominant force between uncharged conductors.\n\nDutch physicist Hendrik B. G. Casimir first proposed the existence of the force,\nand he formulated an experiment to detect it in 1948 while participating in research\nat Philips Research Labs. The classic form of his experiment used a pair of uncharged\nparallel metal plates in a vacuum, and successfully demonstrated the force to within\n15% of the value he had predicted according to his theory.\n\nThe Casimir force F for idealized, perfectly conducting plates of surface area\nA square meter and placed at a distance of a meter apart with vacuum between\nthem is expressed as -\n\nF = - ((Reduced Planck Constant \u210f) * c * Pi^2 * A) / (240 * a^4)\n\nHere, the negative sign indicates the force is attractive in nature. For the ease\nof calculation, only the magnitude of the force is considered.\n\nSource :\n- https://en.wikipedia.org/wiki/Casimir_effect\n- https://www.cs.mcgill.ca/~rwest/wikispeedia/wpcd/wp/c/Casimir_effect.htm\n- Casimir, H. B. ; Polder, D. (1948) \"The Influence of Retardation on the\n  London-van der Waals Forces\", Physical Review, vol. 73, Issue 4, pp. 360-372\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom math import pi\n\n# Define the Reduced Planck Constant \u210f (H bar), speed of light C, value of\n# Pi and the function\nREDUCED_PLANCK_CONSTANT = 1.054571817e-34  # unit of \u210f : J * s\n\nSPEED_OF_LIGHT = 3e8  # unit of c : m * s^-1\n\n\ndef casimir_force(force: float, area: float, distance: float) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force -> Casimir Force : magnitude in Newtons\n\n    area -> Surface area of each plate : magnitude in square meters\n\n    distance -> Distance between two plates : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> casimir_force(force = 0, area = 4, distance = 0.03)\n    {'force': 6.4248189174864216e-21}\n\n    >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)\n    {'distance': 1.0323056015031114e-05}\n\n    >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)\n    {'area': 0.06688838837354052}\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)\n    Traceback (most recent call last):\n        ...\n    ValueError: Distance can not be negative\n\n    >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Magnitude of force can not be negative\n    \"\"\"\n\n    if (force, area, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Magnitude of force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if area < 0:\n        raise ValueError(\"Area can not be negative\")\n    if force == 0:\n        force = (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (\n            240 * (distance) ** 4\n        )\n        return {\"force\": force}\n    elif area == 0:\n        area = (240 * force * (distance) ** 4) / (\n            REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2\n        )\n        return {\"area\": area}\n    elif distance == 0:\n        distance = (\n            (REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * pi**2 * area) / (240 * force)\n        ) ** (1 / 4)\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")\n\n\n# Run doctest\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/grahams_law.py": "\"\"\"\nTitle: Graham's Law of Effusion\n\nDescription: Graham's law of effusion states that the rate of effusion of a gas is\ninversely proportional to the square root of the molar mass of its particles:\n\nr1/r2 = sqrt(m2/m1)\n\nr1 = Rate of effusion for the first gas.\nr2 = Rate of effusion for the second gas.\nm1 = Molar mass of the first gas.\nm2 = Molar mass of the second gas.\n\n(Description adapted from https://en.wikipedia.org/wiki/Graham%27s_law)\n\"\"\"\n\nfrom math import pow, sqrt\n\n\ndef validate(*values: float) -> bool:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> validate(2.016, 4.002)\n    True\n    >>> validate(-2.016, 4.002)\n    False\n    >>> validate()\n    False\n    \"\"\"\n    result = len(values) > 0 and all(value > 0.0 for value in values)\n    return result\n\n\ndef effusion_ratio(molar_mass_1: float, molar_mass_2: float) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> effusion_ratio(2.016, 4.002)\n    1.408943\n    >>> effusion_ratio(-2.016, 4.002)\n    ValueError('Input Error: Molar mass values must greater than 0.')\n    >>> effusion_ratio(2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'\n    \"\"\"\n    return (\n        round(sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(molar_mass_1, molar_mass_2)\n        else ValueError(\"Input Error: Molar mass values must greater than 0.\")\n    )\n\n\ndef first_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> first_effusion_rate(1, 2.016, 4.002)\n    1.408943\n    >>> first_effusion_rate(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> first_effusion_rate(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_effusion_rate() missing 2 required positional arguments: \\\n'molar_mass_1' and 'molar_mass_2'\n    >>> first_effusion_rate(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_effusion_rate() missing 1 required positional argument: \\\n'molar_mass_2'\n    \"\"\"\n    return (\n        round(effusion_rate * sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )\n\n\ndef second_effusion_rate(\n    effusion_rate: float, molar_mass_1: float, molar_mass_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n    molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)\n\n    Returns:\n    --------\n    >>> second_effusion_rate(1, 2.016, 4.002)\n    0.709752\n    >>> second_effusion_rate(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> second_effusion_rate(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_effusion_rate() missing 2 required positional arguments: \\\n'molar_mass_1' and 'molar_mass_2'\n    >>> second_effusion_rate(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_effusion_rate() missing 1 required positional argument: \\\n'molar_mass_2'\n    \"\"\"\n    return (\n        round(effusion_rate / sqrt(molar_mass_2 / molar_mass_1), 6)\n        if validate(effusion_rate, molar_mass_1, molar_mass_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )\n\n\ndef first_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\n    Returns:\n    --------\n    >>> first_molar_mass(2, 1.408943, 0.709752)\n    0.507524\n    >>> first_molar_mass(-1, 2.016, 4.002)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> first_molar_mass(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 2 required positional arguments: \\\n'effusion_rate_1' and 'effusion_rate_2'\n    >>> first_molar_mass(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: first_molar_mass() missing 1 required positional argument: \\\n'effusion_rate_2'\n    \"\"\"\n    return (\n        round(molar_mass / pow(effusion_rate_1 / effusion_rate_2, 2), 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )\n\n\ndef second_molar_mass(\n    molar_mass: float, effusion_rate_1: float, effusion_rate_2: float\n) -> float | ValueError:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)\n    effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)\n    effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)\n\n    Returns:\n    --------\n    >>> second_molar_mass(2, 1.408943, 0.709752)\n    1.970351\n    >>> second_molar_mass(-2, 1.408943, 0.709752)\n    ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')\n    >>> second_molar_mass(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_molar_mass() missing 2 required positional arguments: \\\n'effusion_rate_1' and 'effusion_rate_2'\n    >>> second_molar_mass(1, 2.016)\n    Traceback (most recent call last):\n      ...\n    TypeError: second_molar_mass() missing 1 required positional argument: \\\n'effusion_rate_2'\n    \"\"\"\n    return (\n        round(pow(effusion_rate_1 / effusion_rate_2, 2) / molar_mass, 6)\n        if validate(molar_mass, effusion_rate_1, effusion_rate_2)\n        else ValueError(\n            \"Input Error: Molar mass and effusion rate values must greater than 0.\"\n        )\n    )\n", "physics/lens_formulae.py": "\"\"\"\nThis module has functions which calculate focal length of lens, distance of\nimage from the lens and distance of object from the lens.\nThe above is calculated using the lens formula.\n\nIn optics, the relationship between the distance of the image (v),\nthe distance of the object (u), and\nthe focal length (f) of the lens is given by the formula known as the Lens formula.\nThe Lens formula is applicable for convex as well as concave lenses. The formula\nis given as follows:\n\n-------------------\n| 1/f = 1/v + 1/u |\n-------------------\n\nWhere\n    f = focal length of the lens in meters.\n    v = distance of the image from the lens in meters.\n    u = distance of the object from the lens in meters.\n\nTo make our calculations easy few assumptions are made while deriving the formula\nwhich are important to keep in mind before solving this equation.\nThe assumptions are as follows:\n    1. The object O is a point object lying somewhere on the principle axis.\n    2. The lens is thin.\n    3. The aperture of the lens taken must be small.\n    4. The angles of incidence and angle of refraction should be small.\n\nSign convention is a set of rules to set signs for image distance, object distance,\nfocal length, etc\nfor mathematical analysis of image formation. According to it:\n    1. Object is always placed to the left of lens.\n    2. All distances are measured from the optical centre of the mirror.\n    3. Distances measured in the direction of the incident ray are positive and\n    the distances measured in the direction opposite\n    to that of the incident rays are negative.\n    4. Distances measured along y-axis above the principal axis are positive and\n    that measured along y-axis below the principal\n    axis are negative.\n\nNote: Sign convention can be reversed and will still give the correct results.\n\nReference for Sign convention:\nhttps://www.toppr.com/ask/content/concept/sign-convention-for-lenses-210246/\n\nReference for assumptions:\nhttps://testbook.com/physics/derivation-of-lens-maker-formula\n\"\"\"\n\n\ndef focal_length_of_lens(\n    object_distance_from_lens: float, image_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(focal_length_of_lens(10,4), 6.666666666666667)\n    True\n    >>> from math import isclose\n    >>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075)\n    True\n    >>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if object_distance_from_lens == 0 or image_distance_from_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    focal_length = 1 / (\n        (1 / image_distance_from_lens) - (1 / object_distance_from_lens)\n    )\n    return focal_length\n\n\ndef object_distance(\n    focal_length_of_lens: float, image_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(object_distance(10,40), -13.333333333333332)\n    True\n\n    >>> from math import isclose\n    >>> isclose(object_distance(6.2,1.5), 1.9787234042553192)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if image_distance_from_lens == 0 or focal_length_of_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n\n    object_distance = 1 / ((1 / image_distance_from_lens) - (1 / focal_length_of_lens))\n    return object_distance\n\n\ndef image_distance(\n    focal_length_of_lens: float, object_distance_from_lens: float\n) -> float:\n    \"\"\"\n    Doctests:\n    >>> from math import isclose\n    >>> isclose(image_distance(50,40), 22.22222222222222)\n    True\n    >>> from math import isclose\n    >>> isclose(image_distance(5.3,7.9), 3.1719696969696973)\n    True\n\n    >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n    if object_distance_from_lens == 0 or focal_length_of_lens == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    image_distance = 1 / ((1 / object_distance_from_lens) + (1 / focal_length_of_lens))\n    return image_distance\n", "physics/potential_energy.py": "from scipy.constants import g\n\n\"\"\"\nFinding the gravitational potential energy of an object with reference\nto the earth,by taking its mass and height above the ground as input\n\n\nDescription : Gravitational energy or gravitational potential energy\nis the potential energy a massive object has in relation to another\nmassive object due to gravity. It is the potential energy associated\nwith the gravitational field, which is released (converted into\nkinetic energy) when the objects fall towards each other.\nGravitational potential energy increases when two objects\nare brought further apart.\n\nFor two pairwise interacting point particles, the gravitational\npotential energy U is given by\nU=-GMm/R\nwhere M and m are the masses of the two particles, R is the distance\nbetween them, and G is the gravitational constant.\nClose to the Earth's surface, the gravitational field is approximately\nconstant, and the gravitational potential energy of an object reduces to\nU=mgh\nwhere m is the object's mass, g=GM/R\u00b2 is the gravity of Earth, and h is\nthe height of the object's center of mass above a chosen reference level.\n\nReference : \"https://en.m.wikipedia.org/wiki/Gravitational_energy\"\n\"\"\"\n\n\ndef potential_energy(mass: float, height: float) -> float:\n    # function will accept mass and height as parameters and return potential energy\n    \"\"\"\n    >>> potential_energy(10,10)\n    980.665\n    >>> potential_energy(0,5)\n    0.0\n    >>> potential_energy(8,0)\n    0.0\n    >>> potential_energy(10,5)\n    490.3325\n    >>> potential_energy(0,0)\n    0.0\n    >>> potential_energy(2,8)\n    156.9064\n    >>> potential_energy(20,100)\n    19613.3\n    \"\"\"\n    if mass < 0:\n        # handling of negative values of mass\n        raise ValueError(\"The mass of a body cannot be negative\")\n    if height < 0:\n        # handling of negative values of height\n        raise ValueError(\"The height above the ground cannot be negative\")\n    return mass * g * height\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"potential_energy\")\n", "physics/centripetal_force.py": "\"\"\"\nDescription : Centripetal force is the force acting on an object in\ncurvilinear motion directed towards the axis of rotation\nor centre of curvature.\n\nThe unit of centripetal force is newton.\n\nThe centripetal force is always directed perpendicular to the\ndirection of the object's displacement. Using Newton's second\nlaw of motion, it is found that the centripetal force of an object\nmoving in a circular path always acts towards the centre of the circle.\nThe Centripetal Force Formula is given as the product of mass (in kg)\nand tangential velocity (in meters per second) squared, divided by the\nradius (in meters) that implies that on doubling the tangential velocity,\nthe centripetal force will be quadrupled. Mathematically it is written as:\nF = mv\u00b2/r\nWhere, F is the Centripetal force, m is the mass of the object, v is the\nspeed or velocity of the object and r is the radius.\n\nReference: https://byjus.com/physics/centripetal-and-centrifugal-force/\n\"\"\"\n\n\ndef centripetal(mass: float, velocity: float, radius: float) -> float:\n    \"\"\"\n    The Centripetal Force formula is given as: (m*v*v)/r\n\n    >>> round(centripetal(15.5,-30,10),2)\n    1395.0\n    >>> round(centripetal(10,15,5),2)\n    450.0\n    >>> round(centripetal(20,-50,15),2)\n    3333.33\n    >>> round(centripetal(12.25,40,25),2)\n    784.0\n    >>> round(centripetal(50,100,50),2)\n    10000.0\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"The mass of the body cannot be negative\")\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive non zero integer\")\n    return (mass * (velocity) ** 2) / radius\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n", "physics/speeds_of_gas_molecules.py": "\"\"\"\nThe root-mean-square, average and most probable speeds of gas molecules are\nderived from the Maxwell-Boltzmann distribution. The Maxwell-Boltzmann\ndistribution is a probability distribution that describes the distribution of\nspeeds of particles in an ideal gas.\n\nThe distribution is given by the following equation:\n\n        -------------------------------------------------\n        | f(v) = (M/2\u03c0RT)^(3/2) * 4\u03c0v^2 * e^(-Mv^2/2RT) |\n        -------------------------------------------------\n\nwhere:\n    f(v) is the fraction of molecules with a speed v\n    M is the molar mass of the gas in kg/mol\n    R is the gas constant\n    T is the absolute temperature\n\nMore information about the Maxwell-Boltzmann distribution can be found here:\nhttps://en.wikipedia.org/wiki/Maxwell%E2%80%93Boltzmann_distribution\n\nThe average speed can be calculated by integrating the Maxwell-Boltzmann distribution\nfrom 0 to infinity and dividing by the total number of molecules. The result is:\n\n        ---------------------\n        | vavg = \u221a(8RT/\u03c0M)  |\n        ---------------------\n\nThe most probable speed is the speed at which the Maxwell-Boltzmann distribution\nis at its maximum. This can be found by differentiating the Maxwell-Boltzmann\ndistribution with respect to v and setting the result equal to zero. The result is:\n\n        ---------------------\n        | vmp = \u221a(2RT/M)    |\n        ---------------------\n\nThe root-mean-square speed is another measure of the average speed\nof the molecules in a gas. It is calculated by taking the square root\nof the average of the squares of the speeds of the molecules. The result is:\n\n        ---------------------\n        | vrms = \u221a(3RT/M)   |\n        ---------------------\n\nHere we have defined functions to calculate the average and\nmost probable speeds of molecules in a gas given the\ntemperature and molar mass of the gas.\n\"\"\"\n\n# import the constants R and pi from the scipy.constants library\nfrom scipy.constants import R, pi\n\n\ndef avg_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    Takes the temperature (in K) and molar mass (in kg/mol) of a gas\n    and returns the average speed of a molecule in the gas (in m/s).\n\n    Examples:\n    >>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n    454.3488755020387\n    >>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K\n    445.52572733919885\n    >>> avg_speed_of_molecule(-273, 0.028) # invalid temperature\n    Traceback (most recent call last):\n        ...\n    Exception: Absolute temperature cannot be less than 0 K\n    >>> avg_speed_of_molecule(273, 0) # invalid molar mass\n    Traceback (most recent call last):\n        ...\n    Exception: Molar mass should be greater than 0 kg/mol\n    \"\"\"\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (8 * R * temperature / (pi * molar_mass)) ** 0.5\n\n\ndef mps_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    Takes the temperature (in K) and molar mass (in kg/mol) of a gas\n    and returns the most probable speed of a molecule in the gas (in m/s).\n\n    Examples:\n    >>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K\n    402.65620701908966\n    >>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K\n    394.836895549922\n    >>> mps_speed_of_molecule(-273, 0.028) # invalid temperature\n    Traceback (most recent call last):\n        ...\n    Exception: Absolute temperature cannot be less than 0 K\n    >>> mps_speed_of_molecule(273, 0) # invalid molar mass\n    Traceback (most recent call last):\n        ...\n    Exception: Molar mass should be greater than 0 kg/mol\n    \"\"\"\n\n    if temperature < 0:\n        raise Exception(\"Absolute temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass should be greater than 0 kg/mol\")\n    return (2 * R * temperature / molar_mass) ** 0.5\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/horizontal_projectile_motion.py": "\"\"\"\nHorizontal Projectile Motion problem in physics.\nThis algorithm solves a specific problem in which\nthe motion starts from the ground as can be seen below:\n      (v = 0)\n               *  *\n           *          *\n        *                *\n      *                    *\n    *                        *\n   *                          *\nGROUND                      GROUND\nFor more info: https://en.wikipedia.org/wiki/Projectile_motion\n\"\"\"\n\n# Importing packages\nfrom math import radians as angle_to_radians\nfrom math import sin\n\n# Acceleration Constant on Earth (unit m/s^2)\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n\n    # Ensure valid instance\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError(\"Invalid velocity. Should be a positive number.\")\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Invalid angle. Range is 1-90 degrees.\")\n\n    # Ensure valid angle\n    if angle > 90 or angle < 1:\n        raise ValueError(\"Invalid angle. Range is 1-90 degrees.\")\n\n    # Ensure valid velocity\n    if init_velocity < 0:\n        raise ValueError(\"Invalid velocity. Should be a positive number.\")\n\n\ndef horizontal_distance(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity**2 * sin(radians) / g, 2)\n\n\ndef max_height(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity**2 * sin(radians) ** 2 / (2 * g), 2)\n\n\ndef total_time(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\n\n\ndef test_motion() -> None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n    # Get input from user\n    init_vel = float(input(\"Initial Velocity: \").strip())\n\n    # Get input from user\n    angle = float(input(\"angle: \").strip())\n\n    # Print results\n    print()\n    print(\"Results: \")\n    print(f\"Horizontal Distance: {horizontal_distance(init_vel, angle)!s} [m]\")\n    print(f\"Maximum Height: {max_height(init_vel, angle)!s} [m]\")\n    print(f\"Total Time: {total_time(init_vel, angle)!s} [s]\")\n", "physics/ideal_gas_law.py": "\"\"\"\nThe ideal gas law, also called the general gas equation, is the\nequation of state of a hypothetical ideal gas. It is a good approximation\nof the behavior of many gases under many conditions, although it has\nseveral limitations. It was first stated by Beno\u00eet Paul \u00c9mile Clapeyron\nin 1834 as a combination of the empirical Boyle's law, Charles's law,\nAvogadro's law, and Gay-Lussac's law.[1] The ideal gas law is often written\nin an empirical form:\n ------------\n | PV = nRT |\n ------------\nP\t=\tPressure (Pa)\nV\t=\tVolume (m^3)\nn\t=\tAmount of substance (mol)\nR\t=\tUniversal gas constant\nT\t=\tAbsolute temperature (Kelvin)\n\n(Description adapted from https://en.wikipedia.org/wiki/Ideal_gas_law )\n\"\"\"\n\nUNIVERSAL_GAS_CONSTANT = 8.314462  # Unit - J mol-1 K-1\n\n\ndef pressure_of_gas_system(moles: float, kelvin: float, volume: float) -> float:\n    \"\"\"\n    >>> pressure_of_gas_system(2, 100, 5)\n    332.57848\n    >>> pressure_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> pressure_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or kelvin < 0 or volume < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / volume\n\n\ndef volume_of_gas_system(moles: float, kelvin: float, pressure: float) -> float:\n    \"\"\"\n    >>> volume_of_gas_system(2, 100, 5)\n    332.57848\n    >>> volume_of_gas_system(0.5, 273, 0.004)\n    283731.01575\n    >>> volume_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or kelvin < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n    return moles * kelvin * UNIVERSAL_GAS_CONSTANT / pressure\n\n\ndef temperature_of_gas_system(moles: float, volume: float, pressure: float) -> float:\n    \"\"\"\n    >>> temperature_of_gas_system(2, 100, 5)\n    30.068090996146232\n    >>> temperature_of_gas_system(11, 5009, 1000)\n    54767.66101807144\n    >>> temperature_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if moles < 0 or volume < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n\n    return pressure * volume / (moles * UNIVERSAL_GAS_CONSTANT)\n\n\ndef moles_of_gas_system(kelvin: float, volume: float, pressure: float) -> float:\n    \"\"\"\n    >>> moles_of_gas_system(100, 5, 10)\n    0.06013618199229246\n    >>> moles_of_gas_system(110, 5009, 1000)\n    5476.766101807144\n    >>> moles_of_gas_system(3, -0.46, 23.5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter positive value.\n    \"\"\"\n    if kelvin < 0 or volume < 0 or pressure < 0:\n        raise ValueError(\"Invalid inputs. Enter positive value.\")\n\n    return pressure * volume / (kelvin * UNIVERSAL_GAS_CONSTANT)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "physics/mass_energy_equivalence.py": "\"\"\"\nTitle:\nFinding the energy equivalence of mass and mass equivalence of energy\nby Einstein's equation.\n\nDescription:\nEinstein's mass-energy equivalence is a pivotal concept in theoretical physics.\nIt asserts that energy (E) and mass (m) are directly related by the speed of\nlight in vacuum (c) squared, as described in the equation E = mc\u00b2. This means that\nmass and energy are interchangeable; a mass increase corresponds to an energy increase,\nand vice versa. This principle has profound implications in nuclear reactions,\nexplaining the release of immense energy from minuscule changes in atomic nuclei.\n\nEquations:\nE = mc\u00b2 and m = E/c\u00b2, where m is mass, E is Energy, c is speed of light in vacuum.\n\nReference:\nhttps://en.wikipedia.org/wiki/Mass%E2%80%93energy_equivalence\n\"\"\"\n\nfrom scipy.constants import c  # speed of light in vacuum (299792458 m/s)\n\n\ndef energy_from_mass(mass: float) -> float:\n    \"\"\"\n    Calculates the Energy equivalence of the Mass using E = mc\u00b2\n    in SI units J from Mass in kg.\n\n    mass (float): Mass of body.\n\n    Usage example:\n    >>> energy_from_mass(124.56)\n    1.11948945063458e+19\n    >>> energy_from_mass(320)\n    2.8760165719578165e+19\n    >>> energy_from_mass(0)\n    0.0\n    >>> energy_from_mass(-967.9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass can't be negative.\n\n    \"\"\"\n    if mass < 0:\n        raise ValueError(\"Mass can't be negative.\")\n    return mass * c**2\n\n\ndef mass_from_energy(energy: float) -> float:\n    \"\"\"\n    Calculates the Mass equivalence of the Energy using m = E/c\u00b2\n    in SI units kg from Energy in J.\n\n    energy (float): Mass of body.\n\n    Usage example:\n    >>> mass_from_energy(124.56)\n    1.3859169098203872e-15\n    >>> mass_from_energy(320)\n    3.560480179371579e-15\n    >>> mass_from_energy(0)\n    0.0\n    >>> mass_from_energy(-967.9)\n    Traceback (most recent call last):\n        ...\n    ValueError: Energy can't be negative.\n\n    \"\"\"\n    if energy < 0:\n        raise ValueError(\"Energy can't be negative.\")\n    return energy / c**2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/terminal_velocity.py": "\"\"\"\nTitle : Computing the terminal velocity of an object falling\n        through a fluid.\n\nTerminal velocity is defined as the highest velocity attained by an\nobject falling through a fluid. It is observed when the sum of drag force\nand buoyancy is equal to the downward gravity force acting on the\nobject. The acceleration of the object is zero as the net force acting on\nthe object is zero.\n\nVt = ((2 * m * g)/(p * A * Cd))^0.5\n\nwhere :\nVt = Terminal velocity (in m/s)\nm = Mass of the falling object (in Kg)\ng = Acceleration due to gravity (value taken : imported from scipy)\np = Density of the fluid through which the object is falling (in Kg/m^3)\nA = Projected area of the object (in m^2)\nCd = Drag coefficient (dimensionless)\n\nReference : https://byjus.com/physics/derivation-of-terminal-velocity/\n\"\"\"\n\nfrom scipy.constants import g\n\n\ndef terminal_velocity(\n    mass: float, density: float, area: float, drag_coefficient: float\n) -> float:\n    \"\"\"\n    >>> terminal_velocity(1, 25, 0.6, 0.77)\n    1.3031197996044768\n    >>> terminal_velocity(2, 100, 0.45, 0.23)\n    1.9467947148674276\n    >>> terminal_velocity(5, 50, 0.2, 0.5)\n    4.428690551393267\n    >>> terminal_velocity(-5, 50, -0.2, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    >>> terminal_velocity(3, -20, -1, 2)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    >>> terminal_velocity(-2, -1, -0.44, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: mass, density, area and the drag coefficient all need to be positive\n    \"\"\"\n    if mass <= 0 or density <= 0 or area <= 0 or drag_coefficient <= 0:\n        raise ValueError(\n            \"mass, density, area and the drag coefficient all need to be positive\"\n        )\n    return ((2 * mass * g) / (density * area * drag_coefficient)) ** 0.5\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/archimedes_principle_of_buoyant_force.py": "\"\"\"\nCalculate the buoyant force of any body completely or partially submerged in a static\nfluid.  This principle was discovered by the Greek mathematician Archimedes.\n\nEquation for calculating buoyant force:\nFb = p * V * g\n\nhttps://en.wikipedia.org/wiki/Archimedes%27_principle\n\"\"\"\n\n# Acceleration Constant on Earth (unit m/s^2)\ng = 9.80665  # Also available in scipy.constants.g\n\n\ndef archimedes_principle(\n    fluid_density: float, volume: float, gravity: float = g\n) -> float:\n    \"\"\"\n    Args:\n        fluid_density: density of fluid (kg/m^3)\n        volume: volume of object/liquid being displaced by the object (m^3)\n        gravity: Acceleration from gravity. Gravitational force on the system,\n            The default is Earth Gravity\n    returns:\n        the buoyant force on an object in Newtons\n\n    >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)\n    19600.0\n    >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)\n    4885.3\n    >>> archimedes_principle(fluid_density=997, volume=0.7)\n    6844.061035\n    >>> archimedes_principle(fluid_density=997, volume=-0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible object volume\n    >>> archimedes_principle(fluid_density=0, volume=0.7)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible fluid density\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)\n    0.0\n    >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Impossible gravity\n    \"\"\"\n\n    if fluid_density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if volume <= 0:\n        raise ValueError(\"Impossible object volume\")\n    if gravity < 0:\n        raise ValueError(\"Impossible gravity\")\n\n    return fluid_density * gravity * volume\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/doppler_frequency.py": "\"\"\"\nDoppler's effect\n\nThe Doppler effect (also Doppler shift) is the change in the frequency of a wave in\nrelation to an observer who is moving relative to the source of the wave.  The Doppler\neffect is named after the physicist Christian Doppler.  A common example of Doppler\nshift is the change of pitch heard when a vehicle sounding a horn approaches and\nrecedes from an observer.\n\nThe reason for the Doppler effect is that when the source of the waves is moving\ntowards the observer, each successive wave crest is emitted from a position closer to\nthe observer than the crest of the previous wave.  Therefore, each wave takes slightly\nless time to reach the observer than the previous wave. Hence, the time between the\narrivals of successive wave crests at the observer is reduced, causing an increase in\nthe frequency.  Similarly, if the source of waves is moving away from the observer,\neach wave is emitted from a position farther from the observer than the previous wave,\nso the arrival time between successive waves is increased, reducing the frequency.\n\nIf the source of waves is stationary but the observer is moving with respect to the\nsource, the transmission velocity of the waves changes (ie the rate at which the\nobserver receives waves) even if the wavelength and frequency emitted from the source\nremain constant.\n\nThese results are all summarized by the Doppler formula:\n\n    f = (f0 * (v + v0)) / (v - vs)\n\nwhere:\n    f: frequency of the wave\n    f0: frequency of the wave when the source is stationary\n    v: velocity of the wave in the medium\n    v0: velocity of the observer, positive if the observer is moving towards the source\n    vs: velocity of the source, positive if the source is moving towards the observer\n\nDoppler's effect has many applications in physics and engineering, such as radar,\nastronomy, medical imaging, and seismology.\n\nReferences:\nhttps://en.wikipedia.org/wiki/Doppler_effect\n\nNow, we will implement a function that calculates the frequency of a wave as a function\nof the frequency of the wave when the source is stationary, the velocity of the wave\nin the medium, the velocity of the observer and the velocity of the source.\n\"\"\"\n\n\ndef doppler_effect(\n    org_freq: float, wave_vel: float, obs_vel: float, src_vel: float\n) -> float:\n    \"\"\"\n    Input Parameters:\n    -----------------\n    org_freq: frequency of the wave when the source is stationary\n    wave_vel: velocity of the wave in the medium\n    obs_vel: velocity of the observer, +ve if the observer is moving towards the source\n    src_vel: velocity of the source, +ve if the source is moving towards the observer\n\n    Returns:\n    --------\n    f: frequency of the wave as perceived by the observer\n\n    Docstring Tests:\n    >>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source\n    103.03030303030303\n    >>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source\n    96.96969696969697\n    >>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer\n    103.125\n    >>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer\n    97.05882352941177\n    >>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other\n    106.25\n    >>> doppler_effect(100, 330, -10, -10)  # source and observer moving away\n    94.11764705882354\n    >>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave\n    Traceback (most recent call last):\n        ...\n    ZeroDivisionError: Division by zero implies vs=v and observer in front of the source\n    >>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)\n    >>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)\n    \"\"\"\n\n    if wave_vel == src_vel:\n        raise ZeroDivisionError(\n            \"Division by zero implies vs=v and observer in front of the source\"\n        )\n    doppler_freq = (org_freq * (wave_vel + obs_vel)) / (wave_vel - src_vel)\n    if doppler_freq <= 0:\n        raise ValueError(\n            \"Non-positive frequency implies vs>v or v0>v (in the opposite direction)\"\n        )\n    return doppler_freq\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/rainfall_intensity.py": "\"\"\"\nRainfall Intensity\n==================\nThis module contains functions to calculate the intensity of\na rainfall event for a given duration and return period.\n\nThis function uses the Sherman intensity-duration-frequency curve.\n\nReferences\n----------\n- Aparicio, F. (1997): Fundamentos de Hidrolog\u00eda de Superficie.\n    Balderas, M\u00e9xico, Limusa. 303 p.\n- https://en.wikipedia.org/wiki/Intensity-duration-frequency_curve\n\"\"\"\n\n\ndef rainfall_intensity(\n    coefficient_k: float,\n    coefficient_a: float,\n    coefficient_b: float,\n    coefficient_c: float,\n    return_period: float,\n    duration: float,\n) -> float:\n    \"\"\"\n    Calculate the intensity of a rainfall event for a given duration and return period.\n    It's based on the Sherman intensity-duration-frequency curve:\n\n    I = k * T^a / (D + b)^c\n\n    where:\n        I = Intensity of the rainfall event [mm/h]\n        k, a, b, c = Coefficients obtained through statistical distribution adjust\n        T = Return period in years\n        D = Rainfall event duration in minutes\n\n    Parameters\n    ----------\n    coefficient_k : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_a : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_b : float\n        Coefficient obtained through statistical distribution adjust.\n    coefficient_c : float\n        Coefficient obtained through statistical distribution adjust.\n    return_period : float\n        Return period in years.\n    duration : float\n        Rainfall event duration in minutes.\n\n    Returns\n    -------\n    intensity : float\n        Intensity of the rainfall event in mm/h.\n\n    Raises\n    ------\n    ValueError\n        If any of the parameters are not positive.\n\n    Examples\n    --------\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60)\n    49.83339231138578\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30)\n    77.36319588106228\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60)\n    43.382487747633625\n\n    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: All parameters must be positive.\n\n    \"\"\"\n    if (\n        coefficient_k <= 0\n        or coefficient_a <= 0\n        or coefficient_b <= 0\n        or coefficient_c <= 0\n        or return_period <= 0\n        or duration <= 0\n    ):\n        raise ValueError(\"All parameters must be positive.\")\n    intensity = (coefficient_k * (return_period**coefficient_a)) / (\n        (duration + coefficient_b) ** coefficient_c\n    )\n    return intensity\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/newtons_second_law_of_motion.py": "\"\"\"\nDescription :\nNewton's second law of motion pertains to the behavior of objects for which\nall existing forces are not balanced.\nThe second law states that the acceleration of an object is dependent upon two variables\n- the net force acting upon the object and the mass of the object.\nThe acceleration of an object depends directly\nupon the net force acting upon the object,\nand inversely upon the mass of the object.\nAs the force acting upon an object is increased,\nthe acceleration of the object is increased.\nAs the mass of an object is increased, the acceleration of the object is decreased.\nSource: https://www.physicsclassroom.com/class/newtlaws/Lesson-3/Newton-s-Second-Law\nFormulation: Fnet = m \u2022 a\nDiagrammatic Explanation:\n              Forces are unbalanced\n                        |\n                        |\n                        |\n                        V\n               There is acceleration\n                        /\\\n                       /  \\\n                      /    \\\n                     /      \\\n                    /        \\\n                   /          \\\n                  /            \\\n        __________________   ____ ________________\n        |The acceleration |  |The acceleration   |\n        |depends directly |  |depends inversely  |\n        |on the net Force |  |upon the object's  |\n        |_________________|  |mass_______________|\nUnits:\n1 Newton = 1 kg X meters / (seconds^2)\nHow to use?\nInputs:\n    ___________________________________________________\n   |Name         | Units                   | Type      |\n   |-------------|-------------------------|-----------|\n   |mass         | (in kgs)                | float     |\n   |-------------|-------------------------|-----------|\n   |acceleration | (in meters/(seconds^2)) | float     |\n   |_____________|_________________________|___________|\n\nOutput:\n    ___________________________________________________\n   |Name         | Units                   | Type      |\n   |-------------|-------------------------|-----------|\n   |force        | (in Newtons)            | float     |\n   |_____________|_________________________|___________|\n\n\"\"\"\n\n\ndef newtons_second_law_of_motion(mass: float, acceleration: float) -> float:\n    \"\"\"\n    >>> newtons_second_law_of_motion(10, 10)\n    100\n    >>> newtons_second_law_of_motion(2.0, 1)\n    2.0\n    \"\"\"\n    force = 0.0\n    try:\n        force = mass * acceleration\n    except Exception:\n        return -0.0\n    return force\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    # run doctest\n    doctest.testmod()\n\n    # demo\n    mass = 12.5\n    acceleration = 10\n    force = newtons_second_law_of_motion(mass, acceleration)\n    print(\"The force is \", force, \"N\")\n", "physics/photoelectric_effect.py": "\"\"\"\nThe photoelectric effect is the emission of electrons when electromagnetic radiation ,\nsuch as light, hits a material. Electrons emitted in this manner are called\nphotoelectrons.\n\nIn 1905, Einstein proposed a theory of the photoelectric effect using a concept that\nlight consists of tiny packets of energy known as photons or light quanta. Each packet\ncarries energy hv that is proportional to the frequency v of the corresponding\nelectromagnetic wave. The proportionality constant h has become known as the\nPlanck constant. In the range of kinetic energies of the electrons that are removed from\ntheir varying atomic bindings by the absorption of a photon of energy hv, the highest\nkinetic energy K_max is :\n\nK_max = hv-W\n\nHere, W is the minimum energy required to remove an electron from the surface of the\nmaterial. It is called the work function of the surface\n\nReference: https://en.wikipedia.org/wiki/Photoelectric_effect\n\n\"\"\"\n\nPLANCK_CONSTANT_JS = 6.6261 * pow(10, -34)  # in SI (Js)\nPLANCK_CONSTANT_EVS = 4.1357 * pow(10, -15)  # in eVs\n\n\ndef maximum_kinetic_energy(\n    frequency: float, work_function: float, in_ev: bool = False\n) -> float:\n    \"\"\"\n    Calculates the maximum kinetic energy of emitted electron from the surface.\n    if the maximum kinetic energy is zero then no electron will be emitted\n    or given electromagnetic wave frequency is small.\n\n    frequency (float): Frequency of electromagnetic wave.\n    work_function (float): Work function of the surface.\n    in_ev (optional)(bool): Pass True if values are in eV.\n\n    Usage example:\n    >>> maximum_kinetic_energy(1000000,2)\n    0\n    >>> maximum_kinetic_energy(1000000,2,True)\n    0\n    >>> maximum_kinetic_energy(10000000000000000,2,True)\n    39.357000000000006\n    >>> maximum_kinetic_energy(-9,20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Frequency can't be negative.\n\n    >>> maximum_kinetic_energy(1000,\"a\")\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for -: 'float' and 'str'\n\n    \"\"\"\n    if frequency < 0:\n        raise ValueError(\"Frequency can't be negative.\")\n    if in_ev:\n        return max(PLANCK_CONSTANT_EVS * frequency - work_function, 0)\n    return max(PLANCK_CONSTANT_JS * frequency - work_function, 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/coulombs_law.py": "\"\"\"\nCoulomb's law states that the magnitude of the electrostatic force of attraction\nor repulsion between two point charges is directly proportional to the product\nof the magnitudes of charges and inversely proportional to the square of the\ndistance between them.\n\nF = k * q1 * q2 / r^2\n\nk is Coulomb's constant and equals 1/(4\u03c0*\u03b50)\nq1 is charge of first body (C)\nq2 is charge of second body (C)\nr is distance between two charged bodies (m)\n\nReference: https://en.wikipedia.org/wiki/Coulomb%27s_law\n\"\"\"\n\n\ndef coulombs_law(q1: float, q2: float, radius: float) -> float:\n    \"\"\"\n    Calculate the electrostatic force of attraction or repulsion\n    between two point charges\n\n    >>> coulombs_law(15.5, 20, 15)\n    12382849136.06\n    >>> coulombs_law(1, 15, 5)\n    5392531075.38\n    >>> coulombs_law(20, -50, 15)\n    -39944674632.44\n    >>> coulombs_law(-5, -8, 10)\n    3595020716.92\n    >>> coulombs_law(50, 100, 50)\n    17975103584.6\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"The radius is always a positive number\")\n    return round(((8.9875517923 * 10**9) * q1 * q2) / (radius**2), 2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/in_static_equilibrium.py": "\"\"\"\nChecks if a system of forces is in static equilibrium.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom numpy import array, cos, cross, float64, radians, sin\nfrom numpy.typing import NDArray\n\n\ndef polar_force(\n    magnitude: float, angle: float, radian_mode: bool = False\n) -> list[float]:\n    \"\"\"\n    Resolves force along rectangular components.\n    (force, angle) => (force_x, force_y)\n    >>> import math\n    >>> force = polar_force(10, 45)\n    >>> math.isclose(force[0], 7.071067811865477)\n    True\n    >>> math.isclose(force[1], 7.0710678118654755)\n    True\n    >>> force = polar_force(10, 3.14, radian_mode=True)\n    >>> math.isclose(force[0], -9.999987317275396)\n    True\n    >>> math.isclose(force[1], 0.01592652916486828)\n    True\n    \"\"\"\n    if radian_mode:\n        return [magnitude * cos(angle), magnitude * sin(angle)]\n    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]\n\n\ndef in_static_equilibrium(\n    forces: NDArray[float64], location: NDArray[float64], eps: float = 10**-1\n) -> bool:\n    \"\"\"\n    Check if a system is in equilibrium.\n    It takes two numpy.array objects.\n    forces ==>  [\n                        [force1_x, force1_y],\n                        [force2_x, force2_y],\n                        ....]\n    location ==>  [\n                        [x1, y1],\n                        [x2, y2],\n                        ....]\n    >>> force = array([[1, 1], [-1, 2]])\n    >>> location = array([[1, 0], [10, 0]])\n    >>> in_static_equilibrium(force, location)\n    False\n    \"\"\"\n    # summation of moments is zero\n    moments: NDArray[float64] = cross(location, forces)\n    sum_moments: float = sum(moments)\n    return abs(sum_moments) < eps\n\n\nif __name__ == \"__main__\":\n    # Test to check if it works\n    forces = array(\n        [\n            polar_force(718.4, 180 - 30),\n            polar_force(879.54, 45),\n            polar_force(100, -90),\n        ]\n    )\n\n    location: NDArray[float64] = array([[0, 0], [0, 0], [0, 0]])\n\n    assert in_static_equilibrium(forces, location)\n\n    # Problem 1 in image_data/2D_problems.jpg\n    forces = array(\n        [\n            polar_force(30 * 9.81, 15),\n            polar_force(215, 180 - 45),\n            polar_force(264, 90 - 30),\n        ]\n    )\n\n    location = array([[0, 0], [0, 0], [0, 0]])\n\n    assert in_static_equilibrium(forces, location)\n\n    # Problem in image_data/2D_problems_1.jpg\n    forces = array([[0, -2000], [0, -1200], [0, 15600], [0, -12400]])\n\n    location = array([[0, 0], [6, 0], [10, 0], [12, 0]])\n\n    assert in_static_equilibrium(forces, location)\n\n    import doctest\n\n    doctest.testmod()\n", "physics/lorentz_transformation_four_vector.py": "\"\"\"\nLorentz transformations describe the transition between two inertial reference\nframes F and F', each of which is moving in some direction with respect to the\nother. This code only calculates Lorentz transformations for movement in the x\ndirection with no spatial rotation (i.e., a Lorentz boost in the x direction).\nThe Lorentz transformations are calculated here as linear transformations of\nfour-vectors [ct, x, y, z] described by Minkowski space. Note that t (time) is\nmultiplied by c (the speed of light) in the first entry of each four-vector.\n\nThus, if X = [ct; x; y; z] and X' = [ct'; x'; y'; z'] are the four-vectors for\ntwo inertial reference frames and X' moves in the x direction with velocity v\nwith respect to X, then the Lorentz transformation from X to X' is X' = BX,\nwhere\n\n    | y  -\u03b3\u03b2  0  0|\nB = |-\u03b3\u03b2  y   0  0|\n    | 0   0   1  0|\n    | 0   0   0  1|\n\nis the matrix describing the Lorentz boost between X and X',\ny = 1 / \u221a(1 - v\u00b2/c\u00b2) is the Lorentz factor, and \u03b2 = v/c is the velocity as\na fraction of c.\n\nReference: https://en.wikipedia.org/wiki/Lorentz_transformation\n\"\"\"\n\nfrom math import sqrt\n\nimport numpy as np\nfrom sympy import symbols\n\n# Coefficient\n# Speed of light (m/s)\nc = 299792458\n\n# Symbols\nct, x, y, z = symbols(\"ct x y z\")\n\n\n# Vehicle's speed divided by speed of light (no units)\ndef beta(velocity: float) -> float:\n    \"\"\"\n    Calculates \u03b2 = v/c, the given velocity as a fraction of c\n    >>> beta(c)\n    1.0\n    >>> beta(199792458)\n    0.666435904801848\n    >>> beta(1e5)\n    0.00033356409519815205\n    >>> beta(0.2)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    if velocity > c:\n        raise ValueError(\"Speed must not exceed light speed 299,792,458 [m/s]!\")\n    elif velocity < 1:\n        # Usually the speed should be much higher than 1 (c order of magnitude)\n        raise ValueError(\"Speed must be greater than or equal to 1!\")\n\n    return velocity / c\n\n\ndef gamma(velocity: float) -> float:\n    \"\"\"\n    Calculate the Lorentz factor y = 1 / \u221a(1 - v\u00b2/c\u00b2) for a given velocity\n    >>> gamma(4)\n    1.0000000000000002\n    >>> gamma(1e5)\n    1.0000000556325075\n    >>> gamma(3e7)\n    1.005044845777813\n    >>> gamma(2.8e8)\n    2.7985595722318277\n    >>> gamma(299792451)\n    4627.49902669495\n    >>> gamma(0.3)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    >>> gamma(2 * c)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    \"\"\"\n    return 1 / sqrt(1 - beta(velocity) ** 2)\n\n\ndef transformation_matrix(velocity: float) -> np.ndarray:\n    \"\"\"\n    Calculate the Lorentz transformation matrix for movement in the x direction:\n\n    | y  -\u03b3\u03b2  0  0|\n    |-\u03b3\u03b2  y   0  0|\n    | 0   0   1  0|\n    | 0   0   0  1|\n\n    where y is the Lorentz factor and \u03b2 is the velocity as a fraction of c\n    >>> transformation_matrix(29979245)\n    array([[ 1.00503781, -0.10050378,  0.        ,  0.        ],\n           [-0.10050378,  1.00503781,  0.        ,  0.        ],\n           [ 0.        ,  0.        ,  1.        ,  0.        ],\n           [ 0.        ,  0.        ,  0.        ,  1.        ]])\n    >>> transformation_matrix(19979245.2)\n    array([[ 1.00222811, -0.06679208,  0.        ,  0.        ],\n           [-0.06679208,  1.00222811,  0.        ,  0.        ],\n           [ 0.        ,  0.        ,  1.        ,  0.        ],\n           [ 0.        ,  0.        ,  0.        ,  1.        ]])\n    >>> transformation_matrix(1)\n    array([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,\n             0.00000000e+00],\n           [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,\n             0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,\n             0.00000000e+00],\n           [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,\n             1.00000000e+00]])\n    >>> transformation_matrix(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    >>> transformation_matrix(c * 1.5)\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    \"\"\"\n    return np.array(\n        [\n            [gamma(velocity), -gamma(velocity) * beta(velocity), 0, 0],\n            [-gamma(velocity) * beta(velocity), gamma(velocity), 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n        ]\n    )\n\n\ndef transform(velocity: float, event: np.ndarray | None = None) -> np.ndarray:\n    \"\"\"\n    Calculate a Lorentz transformation for movement in the x direction given a\n    velocity and a four-vector for an inertial reference frame\n\n    If no four-vector is given, then calculate the transformation symbolically\n    with variables\n    >>> transform(29979245, np.array([1, 2, 3, 4]))\n    array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])\n    >>> transform(29979245)\n    array([1.00503781498831*ct - 0.100503778816875*x,\n           -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(19879210.2)\n    array([1.0022057787097*ct - 0.066456172618675*x,\n           -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],\n          dtype=object)\n    >>> transform(299792459, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must not exceed light speed 299,792,458 [m/s]!\n    >>> transform(-1, np.array([1, 1, 1, 1]))\n    Traceback (most recent call last):\n      ...\n    ValueError: Speed must be greater than or equal to 1!\n    \"\"\"\n    # Ensure event is not empty\n    if event is None:\n        event = np.array([ct, x, y, z])  # Symbolic four vector\n    else:\n        event[0] *= c  # x0 is ct (speed of light * time)\n\n    return transformation_matrix(velocity) @ event\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Example of symbolic vector:\n    four_vector = transform(29979245)\n    print(\"Example of four vector: \")\n    print(f\"ct' = {four_vector[0]}\")\n    print(f\"x' = {four_vector[1]}\")\n    print(f\"y' = {four_vector[2]}\")\n    print(f\"z' = {four_vector[3]}\")\n\n    # Substitute symbols with numerical values\n    sub_dict = {ct: c, x: 1, y: 1, z: 1}\n    numerical_vector = [four_vector[i].subs(sub_dict) for i in range(4)]\n\n    print(f\"\\n{numerical_vector}\")\n", "physics/reynolds_number.py": "\"\"\"\nTitle : computing the Reynolds number to find\n        out the type of flow (laminar or turbulent)\n\nReynolds number is a dimensionless quantity that is used to determine\nthe type of flow pattern as laminar or turbulent while flowing through a\npipe. Reynolds number is defined by the ratio of inertial forces to that of\nviscous forces.\n\nR = Inertial Forces / Viscous Forces\nR = (p * V * D)/\u03bc\n\nwhere :\np = Density of fluid (in Kg/m^3)\nD = Diameter of pipe through which fluid flows (in m)\nV = Velocity of flow of the fluid (in m/s)\n\u03bc = Viscosity of the fluid (in Ns/m^2)\n\nIf the Reynolds number calculated is high (greater than 2000), then the\nflow through the pipe is said to be turbulent. If Reynolds number is low\n(less than 2000), the flow is said to be laminar. Numerically, these are\nacceptable values, although in general the laminar and turbulent flows\nare classified according to a range. Laminar flow falls below Reynolds\nnumber of 1100 and turbulent falls in a range greater than 2200.\nLaminar flow is the type of flow in which the fluid travels smoothly in\nregular paths. Conversely, turbulent flow isn't smooth and follows an\nirregular path with lots of mixing.\n\nReference : https://byjus.com/physics/reynolds-number/\n\"\"\"\n\n\ndef reynolds_number(\n    density: float, velocity: float, diameter: float, viscosity: float\n) -> float:\n    \"\"\"\n    >>> reynolds_number(900, 2.5, 0.05, 0.4)\n    281.25\n    >>> reynolds_number(450, 3.86, 0.078, 0.23)\n    589.0695652173912\n    >>> reynolds_number(234, -4.5, 0.3, 0.44)\n    717.9545454545454\n    >>> reynolds_number(-90, 2, 0.045, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: please ensure that density, diameter and viscosity are positive\n    >>> reynolds_number(0, 2, -0.4, -2)\n    Traceback (most recent call last):\n        ...\n    ValueError: please ensure that density, diameter and viscosity are positive\n    \"\"\"\n\n    if density <= 0 or diameter <= 0 or viscosity <= 0:\n        raise ValueError(\n            \"please ensure that density, diameter and viscosity are positive\"\n        )\n    return (density * abs(velocity) * diameter) / viscosity\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/n_body_simulation.py": "\"\"\"\nIn physics and astronomy, a gravitational N-body simulation is a simulation of a\ndynamical system of particles under the influence of gravity. The system\nconsists of a number of bodies, each of which exerts a gravitational force on all\nother bodies. These forces are calculated using Newton's law of universal\ngravitation. The Euler method is used at each time-step to calculate the change in\nvelocity and position brought about by these forces. Softening is used to prevent\nnumerical divergences when a particle comes too close to another (and the force\ngoes to infinity).\n(Description adapted from https://en.wikipedia.org/wiki/N-body_simulation )\n(See also http://www.shodor.org/refdesk/Resources/Algorithms/EulersMethod/ )\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\n\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\n\n# Frame rate of the animation\nINTERVAL = 20\n\n# Time between time steps in seconds\nDELTA_TIME = INTERVAL / 1000\n\n\nclass Body:\n    def __init__(\n        self,\n        position_x: float,\n        position_y: float,\n        velocity_x: float,\n        velocity_y: float,\n        mass: float = 1.0,\n        size: float = 1.0,\n        color: str = \"blue\",\n    ) -> None:\n        \"\"\"\n        The parameters \"size\" & \"color\" are not relevant for the simulation itself,\n        they are only used for plotting.\n        \"\"\"\n        self.position_x = position_x\n        self.position_y = position_y\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.mass = mass\n        self.size = size\n        self.color = color\n\n    @property\n    def position(self) -> tuple[float, float]:\n        return self.position_x, self.position_y\n\n    @property\n    def velocity(self) -> tuple[float, float]:\n        return self.velocity_x, self.velocity_y\n\n    def update_velocity(\n        self, force_x: float, force_y: float, delta_time: float\n    ) -> None:\n        \"\"\"\n        Euler algorithm for velocity\n\n        >>> body_1 = Body(0.,0.,0.,0.)\n        >>> body_1.update_velocity(1.,0.,1.)\n        >>> body_1.velocity\n        (1.0, 0.0)\n\n        >>> body_1.update_velocity(1.,0.,1.)\n        >>> body_1.velocity\n        (2.0, 0.0)\n\n        >>> body_2 = Body(0.,0.,5.,0.)\n        >>> body_2.update_velocity(0.,-10.,10.)\n        >>> body_2.velocity\n        (5.0, -100.0)\n\n        >>> body_2.update_velocity(0.,-10.,10.)\n        >>> body_2.velocity\n        (5.0, -200.0)\n        \"\"\"\n        self.velocity_x += force_x * delta_time\n        self.velocity_y += force_y * delta_time\n\n    def update_position(self, delta_time: float) -> None:\n        \"\"\"\n        Euler algorithm for position\n\n        >>> body_1 = Body(0.,0.,1.,0.)\n        >>> body_1.update_position(1.)\n        >>> body_1.position\n        (1.0, 0.0)\n\n        >>> body_1.update_position(1.)\n        >>> body_1.position\n        (2.0, 0.0)\n\n        >>> body_2 = Body(10.,10.,0.,-2.)\n        >>> body_2.update_position(1.)\n        >>> body_2.position\n        (10.0, 8.0)\n\n        >>> body_2.update_position(1.)\n        >>> body_2.position\n        (10.0, 6.0)\n        \"\"\"\n        self.position_x += self.velocity_x * delta_time\n        self.position_y += self.velocity_y * delta_time\n\n\nclass BodySystem:\n    \"\"\"\n    This class is used to hold the bodies, the gravitation constant, the time\n    factor and the softening factor. The time factor is used to control the speed\n    of the simulation. The softening factor is used for softening, a numerical\n    trick for N-body simulations to prevent numerical divergences when two bodies\n    get too close to each other.\n    \"\"\"\n\n    def __init__(\n        self,\n        bodies: list[Body],\n        gravitation_constant: float = 1.0,\n        time_factor: float = 1.0,\n        softening_factor: float = 0.0,\n    ) -> None:\n        self.bodies = bodies\n        self.gravitation_constant = gravitation_constant\n        self.time_factor = time_factor\n        self.softening_factor = softening_factor\n\n    def __len__(self) -> int:\n        return len(self.bodies)\n\n    def update_system(self, delta_time: float) -> None:\n        \"\"\"\n        For each body, loop through all other bodies to calculate the total\n        force they exert on it. Use that force to update the body's velocity.\n\n        >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\n        >>> len(body_system_1)\n        2\n        >>> body_system_1.update_system(1)\n        >>> body_system_1.bodies[0].position\n        (0.01, 0.0)\n        >>> body_system_1.bodies[0].velocity\n        (0.01, 0.0)\n\n        >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\n        >>> body_system_2.update_system(1)\n        >>> body_system_2.bodies[0].position\n        (-9.0, 0.0)\n        >>> body_system_2.bodies[0].velocity\n        (0.1, 0.0)\n        \"\"\"\n        for body1 in self.bodies:\n            force_x = 0.0\n            force_y = 0.0\n            for body2 in self.bodies:\n                if body1 != body2:\n                    dif_x = body2.position_x - body1.position_x\n                    dif_y = body2.position_y - body1.position_y\n\n                    # Calculation of the distance using Pythagoras's theorem\n                    # Extra factor due to the softening technique\n                    distance = (dif_x**2 + dif_y**2 + self.softening_factor) ** (1 / 2)\n\n                    # Newton's law of universal gravitation.\n                    force_x += (\n                        self.gravitation_constant * body2.mass * dif_x / distance**3\n                    )\n                    force_y += (\n                        self.gravitation_constant * body2.mass * dif_y / distance**3\n                    )\n\n            # Update the body's velocity once all the force components have been added\n            body1.update_velocity(force_x, force_y, delta_time * self.time_factor)\n\n        # Update the positions only after all the velocities have been updated\n        for body in self.bodies:\n            body.update_position(delta_time * self.time_factor)\n\n\ndef update_step(\n    body_system: BodySystem, delta_time: float, patches: list[plt.Circle]\n) -> None:\n    \"\"\"\n    Updates the body-system and applies the change to the patch-list used for plotting\n\n    >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])\n    >>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,\n    ... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS\n    >>> update_step(body_system_1, 1, patches_1)\n    >>> patches_1[0].center\n    (0.01, 0.0)\n\n    >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)\n    >>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,\n    ... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS\n    >>> update_step(body_system_2, 1, patches_2)\n    >>> patches_2[0].center\n    (-9.0, 0.0)\n    \"\"\"\n    # Update the positions of the bodies\n    body_system.update_system(delta_time)\n\n    # Update the positions of the patches\n    for patch, body in zip(patches, body_system.bodies):\n        patch.center = (body.position_x, body.position_y)\n\n\ndef plot(\n    title: str,\n    body_system: BodySystem,\n    x_start: float = -1,\n    x_end: float = 1,\n    y_start: float = -1,\n    y_end: float = 1,\n) -> None:\n    \"\"\"\n    Utility function to plot how the given body-system evolves over time.\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n    fig = plt.figure()\n    fig.canvas.manager.set_window_title(title)\n    ax = plt.axes(\n        xlim=(x_start, x_end), ylim=(y_start, y_end)\n    )  # Set section to be plotted\n    plt.gca().set_aspect(\"equal\")  # Fix aspect ratio\n\n    # Each body is drawn as a patch by the plt-function\n    patches = [\n        plt.Circle((body.position_x, body.position_y), body.size, fc=body.color)\n        for body in body_system.bodies\n    ]\n\n    for patch in patches:\n        ax.add_patch(patch)\n\n    # Function called at each step of the animation\n    def update(frame: int) -> list[plt.Circle]:  # noqa: ARG001\n        update_step(body_system, DELTA_TIME, patches)\n        return patches\n\n    anim = animation.FuncAnimation(  # noqa: F841\n        fig, update, interval=INTERVAL, blit=True\n    )\n\n    plt.show()\n\n\ndef example_1() -> BodySystem:\n    \"\"\"\n    Example 1: figure-8 solution to the 3-body-problem\n    This example can be seen as a test of the implementation: given the right\n    initial conditions, the bodies should move in a figure-8.\n    (initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)\n    >>> body_system = example_1()\n    >>> len(body_system)\n    3\n    \"\"\"\n\n    position_x = 0.9700436\n    position_y = -0.24308753\n    velocity_x = 0.466203685\n    velocity_y = 0.43236573\n\n    bodies1 = [\n        Body(position_x, position_y, velocity_x, velocity_y, size=0.2, color=\"red\"),\n        Body(-position_x, -position_y, velocity_x, velocity_y, size=0.2, color=\"green\"),\n        Body(0, 0, -2 * velocity_x, -2 * velocity_y, size=0.2, color=\"blue\"),\n    ]\n    return BodySystem(bodies1, time_factor=3)\n\n\ndef example_2() -> BodySystem:\n    \"\"\"\n    Example 2: Moon's orbit around the earth\n    This example can be seen as a test of the implementation: given the right\n    initial conditions, the moon should orbit around the earth as it actually does.\n    (mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth\n    and https://en.wikipedia.org/wiki/Moon)\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n\n    moon_mass = 7.3476e22\n    earth_mass = 5.972e24\n    velocity_dif = 1022\n    earth_moon_distance = 384399000\n    gravitation_constant = 6.674e-11\n\n    # Calculation of the respective velocities so that total impulse is zero,\n    # i.e. the two bodies together don't move\n    moon_velocity = earth_mass * velocity_dif / (earth_mass + moon_mass)\n    earth_velocity = moon_velocity - velocity_dif\n\n    moon = Body(-earth_moon_distance, 0, 0, moon_velocity, moon_mass, 10000000, \"grey\")\n    earth = Body(0, 0, 0, earth_velocity, earth_mass, 50000000, \"blue\")\n    return BodySystem([earth, moon], gravitation_constant, time_factor=1000000)\n\n\ndef example_3() -> BodySystem:\n    \"\"\"\n    Example 3: Random system with many bodies.\n    No doctest provided since this function does not have a return value.\n    \"\"\"\n\n    bodies = []\n    for _ in range(10):\n        velocity_x = random.uniform(-0.5, 0.5)\n        velocity_y = random.uniform(-0.5, 0.5)\n\n        # Bodies are created pairwise with opposite velocities so that the\n        # total impulse remains zero\n        bodies.append(\n            Body(\n                random.uniform(-0.5, 0.5),\n                random.uniform(-0.5, 0.5),\n                velocity_x,\n                velocity_y,\n                size=0.05,\n            )\n        )\n        bodies.append(\n            Body(\n                random.uniform(-0.5, 0.5),\n                random.uniform(-0.5, 0.5),\n                -velocity_x,\n                -velocity_y,\n                size=0.05,\n            )\n        )\n    return BodySystem(bodies, 0.01, 10, 0.1)\n\n\nif __name__ == \"__main__\":\n    plot(\"Figure-8 solution to the 3-body-problem\", example_1(), -2, 2, -2, 2)\n    plot(\n        \"Moon's orbit around the earth\",\n        example_2(),\n        -430000000,\n        430000000,\n        -430000000,\n        430000000,\n    )\n    plot(\"Random system with many bodies\", example_3(), -1.5, 1.5, -1.5, 1.5)\n", "physics/newtons_law_of_gravitation.py": "\"\"\"\nTitle : Finding the value of either Gravitational Force, one of the masses or distance\nprovided that the other three parameters are given.\n\nDescription : Newton's Law of Universal Gravitation explains the presence of force of\nattraction between bodies having a definite mass situated at a distance. It is usually\nstated as that, every particle attracts every other particle in the universe with a\nforce that is directly proportional to the product of their masses and inversely\nproportional to the square of the distance between their centers. The publication of the\ntheory has become known as the \"first great unification\", as it marked the unification\nof the previously described phenomena of gravity on Earth with known astronomical\nbehaviors.\n\nThe equation for the universal gravitation is as follows:\nF = (G * mass_1 * mass_2) / (distance)^2\n\nSource :\n- https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation\n- Newton (1687) \"Philosophi\u00e6 Naturalis Principia Mathematica\"\n\"\"\"\n\nfrom __future__ import annotations\n\n# Define the Gravitational Constant G and the function\nGRAVITATIONAL_CONSTANT = 6.6743e-11  # unit of G : m^3 * kg^-1 * s^-2\n\n\ndef gravitational_law(\n    force: float, mass_1: float, mass_2: float, distance: float\n) -> dict[str, float]:\n    \"\"\"\n    Input Parameters\n    ----------------\n    force : magnitude in Newtons\n\n    mass_1 : mass in Kilograms\n\n    mass_2 : mass in Kilograms\n\n    distance : distance in Meters\n\n    Returns\n    -------\n    result : dict name, value pair of the parameter having Zero as it's value\n\n    Returns the value of one of the parameters specified as 0, provided the values of\n    other parameters are given.\n    >>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20)\n    {'force': 8.342875e-12}\n\n    >>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048)\n    {'mass_1': 1.385816317292268e+19}\n\n    >>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584)\n    Traceback (most recent call last):\n        ...\n    ValueError: One and only one argument must be 0\n\n    >>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass can not be negative\n\n    >>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374)\n    Traceback (most recent call last):\n        ...\n    ValueError: Gravitational force can not be negative\n    \"\"\"\n\n    product_of_mass = mass_1 * mass_2\n\n    if (force, mass_1, mass_2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if force < 0:\n        raise ValueError(\"Gravitational force can not be negative\")\n    if distance < 0:\n        raise ValueError(\"Distance can not be negative\")\n    if mass_1 < 0 or mass_2 < 0:\n        raise ValueError(\"Mass can not be negative\")\n    if force == 0:\n        force = GRAVITATIONAL_CONSTANT * product_of_mass / (distance**2)\n        return {\"force\": force}\n    elif mass_1 == 0:\n        mass_1 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_2)\n        return {\"mass_1\": mass_1}\n    elif mass_2 == 0:\n        mass_2 = (force) * (distance**2) / (GRAVITATIONAL_CONSTANT * mass_1)\n        return {\"mass_2\": mass_2}\n    elif distance == 0:\n        distance = (GRAVITATIONAL_CONSTANT * product_of_mass / (force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"One and only one argument must be 0\")\n\n\n# Run doctest\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/basic_orbital_capture.py": "from math import pow, sqrt\n\nfrom scipy.constants import G, c, pi\n\n\"\"\"\nThese two functions will return the radii of impact for a target object\nof mass M and radius R as well as it's effective cross sectional area sigma.\nThat is to say any projectile with velocity v passing within sigma, will impact the\ntarget object with mass M. The derivation of which is given at the bottom\nof this file.\n\nThe derivation shows that a projectile does not need to aim directly at the target\nbody in order to hit it, as  R_capture>R_target. Astronomers refer to the effective\ncross section for capture as sigma=\u03c0*R_capture**2.\n\nThis algorithm does not account for an N-body problem.\n\n\"\"\"\n\n\ndef capture_radii(\n    target_body_radius: float, target_body_mass: float, projectile_velocity: float\n) -> float:\n    \"\"\"\n    Input Params:\n    -------------\n    target_body_radius: Radius of the central body SI units: meters | m\n    target_body_mass: Mass of the central body SI units: kilograms | kg\n    projectile_velocity: Velocity of object moving toward central body\n        SI units: meters/second | m/s\n    Returns:\n    --------\n    >>> capture_radii(6.957e8, 1.99e30, 25000.0)\n    17209590691.0\n    >>> capture_radii(-6.957e8, 1.99e30, 25000.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Radius cannot be less than 0\n    >>> capture_radii(6.957e8, -1.99e30, 25000.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Mass cannot be less than 0\n    >>> capture_radii(6.957e8, 1.99e30, c+1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot go beyond speed of light\n\n    Returned SI units:\n    ------------------\n    meters | m\n    \"\"\"\n\n    if target_body_mass < 0:\n        raise ValueError(\"Mass cannot be less than 0\")\n    if target_body_radius < 0:\n        raise ValueError(\"Radius cannot be less than 0\")\n    if projectile_velocity > c:\n        raise ValueError(\"Cannot go beyond speed of light\")\n\n    escape_velocity_squared = (2 * G * target_body_mass) / target_body_radius\n    capture_radius = target_body_radius * sqrt(\n        1 + escape_velocity_squared / pow(projectile_velocity, 2)\n    )\n    return round(capture_radius, 0)\n\n\ndef capture_area(capture_radius: float) -> float:\n    \"\"\"\n    Input Param:\n    ------------\n    capture_radius: The radius of orbital capture and impact for a central body of\n    mass M and a projectile moving towards it with velocity v\n        SI units: meters | m\n    Returns:\n    --------\n    >>> capture_area(17209590691)\n    9.304455331329126e+20\n    >>> capture_area(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot have a capture radius less than 0\n\n    Returned SI units:\n    ------------------\n    meters*meters | m**2\n    \"\"\"\n\n    if capture_radius < 0:\n        raise ValueError(\"Cannot have a capture radius less than 0\")\n    sigma = pi * pow(capture_radius, 2)\n    return round(sigma, 0)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n\n\"\"\"\nDerivation:\n\nLet: Mt=target mass, Rt=target radius, v=projectile_velocity,\n     r_0=radius of projectile at instant 0 to CM of target\n     v_p=v at closest approach,\n     r_p=radius from projectile to target CM at closest approach,\n     R_capture= radius of impact for projectile with velocity v\n\n(1)At time=0  the projectile's energy falling from infinity| E=K+U=0.5*m*(v**2)+0\n\n    E_initial=0.5*m*(v**2)\n\n(2)at time=0 the angular momentum of the projectile relative to CM target|\n    L_initial=m*r_0*v*sin(\u0398)->m*r_0*v*(R_capture/r_0)->m*v*R_capture\n\n    L_i=m*v*R_capture\n\n(3)The energy of the projectile at closest approach will be its kinetic energy\n   at closest approach plus gravitational potential energy(-(GMm)/R)|\n    E_p=K_p+U_p->E_p=0.5*m*(v_p**2)-(G*Mt*m)/r_p\n\n    E_p=0.0.5*m*(v_p**2)-(G*Mt*m)/r_p\n\n(4)The angular momentum of the projectile relative to the target at closest\n   approach will be L_p=m*r_p*v_p*sin(\u0398), however relative to the target \u0398=90\u00b0\n   sin(90\u00b0)=1|\n\n    L_p=m*r_p*v_p\n(5)Using conservation of angular momentum and energy, we can write a quadratic\n   equation that solves for r_p|\n\n   (a)\n    Ei=Ep-> 0.5*m*(v**2)=0.5*m*(v_p**2)-(G*Mt*m)/r_p-> v**2=v_p**2-(2*G*Mt)/r_p\n\n   (b)\n    Li=Lp-> m*v*R_capture=m*r_p*v_p-> v*R_capture=r_p*v_p-> v_p=(v*R_capture)/r_p\n\n   (c) b plugs int a|\n    v**2=((v*R_capture)/r_p)**2-(2*G*Mt)/r_p->\n\n    v**2-(v**2)*(R_c**2)/(r_p**2)+(2*G*Mt)/r_p=0->\n\n    (v**2)*(r_p**2)+2*G*Mt*r_p-(v**2)*(R_c**2)=0\n\n   (d) Using the quadratic formula, we'll solve for r_p then rearrange to solve to\n       R_capture\n\n    r_p=(-2*G*Mt \u00b1 sqrt(4*G^2*Mt^2+ 4(v^4*R_c^2)))/(2*v^2)->\n\n    r_p=(-G*Mt \u00b1 sqrt(G^2*Mt+v^4*R_c^2))/v^2->\n\n    r_p<0 is something we can ignore, as it has no physical meaning for our purposes.->\n\n    r_p=(-G*Mt)/v^2 + sqrt(G^2*Mt^2/v^4 + R_c^2)\n\n   (e)We are trying to solve for R_c. We are looking for impact, so we want r_p=Rt\n\n    Rt + G*Mt/v^2 = sqrt(G^2*Mt^2/v^4 + R_c^2)->\n\n    (Rt + G*Mt/v^2)^2 = G^2*Mt^2/v^4 + R_c^2->\n\n    Rt^2 + 2*G*Mt*Rt/v^2 + G^2*Mt^2/v^4 = G^2*Mt^2/v^4 + R_c^2->\n\n    Rt**2 + 2*G*Mt*Rt/v**2 = R_c**2->\n\n    Rt**2 * (1 + 2*G*Mt/Rt *1/v**2) = R_c**2->\n\n    escape velocity = sqrt(2GM/R)= v_escape**2=2GM/R->\n\n    Rt**2 * (1 + v_esc**2/v**2) = R_c**2->\n\n(6)\n    R_capture = Rt * sqrt(1 + v_esc**2/v**2)\n\nSource: Problem Set 3 #8 c.Fall_2017|Honors Astronomy|Professor Rachel Bezanson\n\nSource #2: http://www.nssc.ac.cn/wxzygx/weixin/201607/P020160718380095698873.pdf\n           8.8 Planetary Rendezvous: Pg.368\n\"\"\"\n", "physics/rms_speed_of_molecule.py": "\"\"\"\nThe root-mean-square speed is essential in measuring the average speed of particles\ncontained in a gas, defined as,\n -----------------\n | Vrms = \u221a3RT/M |\n -----------------\n\nIn Kinetic Molecular Theory, gasified particles are in a condition of constant random\nmotion; each particle moves at a completely different pace, perpetually clashing and\nchanging directions consistently velocity is used to describe the movement of gas\nparticles, thereby taking into account both speed and direction. Although the velocity\nof gaseous particles is constantly changing, the distribution of velocities does not\nchange.\nWe cannot gauge the velocity of every individual particle, thus we frequently reason\nin terms of the particles average behavior. Particles moving in opposite directions\nhave velocities of opposite signs. Since gas particles are in random motion, it's\nplausible that there'll be about as several moving in one direction as within the other\nway, which means that the average velocity for a collection of gas particles equals\nzero; as this value is unhelpful, the average of velocities can be determined using an\nalternative method.\n\"\"\"\n\nUNIVERSAL_GAS_CONSTANT = 8.3144598\n\n\ndef rms_speed_of_molecule(temperature: float, molar_mass: float) -> float:\n    \"\"\"\n    >>> rms_speed_of_molecule(100, 2)\n    35.315279554323226\n    >>> rms_speed_of_molecule(273, 12)\n    23.821458421977443\n    \"\"\"\n    if temperature < 0:\n        raise Exception(\"Temperature cannot be less than 0 K\")\n    if molar_mass <= 0:\n        raise Exception(\"Molar mass cannot be less than or equal to 0 kg/mol\")\n    else:\n        return (3 * UNIVERSAL_GAS_CONSTANT * temperature / molar_mass) ** 0.5\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    # run doctest\n    doctest.testmod()\n\n    # example\n    temperature = 300\n    molar_mass = 28\n    vrms = rms_speed_of_molecule(temperature, molar_mass)\n    print(f\"Vrms of Nitrogen gas at 300 K is {vrms} m/s\")\n", "physics/altitude_pressure.py": "\"\"\"\nTitle : Calculate altitude using Pressure\n\nDescription :\n    The below algorithm approximates the altitude using Barometric formula\n\n\n\"\"\"\n\n\ndef get_altitude_at_pressure(pressure: float) -> float:\n    \"\"\"\n    This method calculates the altitude from Pressure wrt to\n    Sea level pressure as reference .Pressure is in Pascals\n    https://en.wikipedia.org/wiki/Pressure_altitude\n    https://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702\n\n    H = 44330 * [1 - (P/p0)^(1/5.255) ]\n\n    Where :\n    H = altitude (m)\n    P = measured pressure\n    p0 = reference pressure at sea level 101325 Pa\n\n    Examples:\n    >>> get_altitude_at_pressure(pressure=100_000)\n    105.47836610778828\n    >>> get_altitude_at_pressure(pressure=101_325)\n    0.0\n    >>> get_altitude_at_pressure(pressure=80_000)\n    1855.873388064995\n    >>> get_altitude_at_pressure(pressure=201_325)\n    Traceback (most recent call last):\n      ...\n    ValueError: Value Higher than Pressure at Sea Level !\n    >>> get_altitude_at_pressure(pressure=-80_000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Atmospheric Pressure can not be negative !\n    \"\"\"\n\n    if pressure > 101325:\n        raise ValueError(\"Value Higher than Pressure at Sea Level !\")\n    if pressure < 0:\n        raise ValueError(\"Atmospheric Pressure can not be negative !\")\n    return 44_330 * (1 - (pressure / 101_325) ** (1 / 5.5255))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/__init__.py": "", "physics/shear_stress.py": "from __future__ import annotations\n\n\"\"\"\nShear stress is a component of stress that is coplanar to the material cross-section.\nIt arises due to a shear force, the component of the force vector parallel to the\nmaterial cross-section.\n\nhttps://en.wikipedia.org/wiki/Shear_stress\n\"\"\"\n\n\ndef shear_stress(\n    stress: float,\n    tangential_force: float,\n    area: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Shear Stress\n    2. Tangential Force\n    3. Cross-sectional Area\n    This is calculated from the other two provided values\n    Examples -\n    >>> shear_stress(stress=25, tangential_force=100, area=0)\n    ('area', 4.0)\n    >>> shear_stress(stress=0, tangential_force=1600, area=200)\n    ('stress', 8.0)\n    >>> shear_stress(stress=1000, tangential_force=0, area=1200)\n    ('tangential_force', 1200000)\n    \"\"\"\n    if (stress, tangential_force, area).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif stress < 0:\n        raise ValueError(\"Stress cannot be negative\")\n    elif tangential_force < 0:\n        raise ValueError(\"Tangential Force cannot be negative\")\n    elif area < 0:\n        raise ValueError(\"Area cannot be negative\")\n    elif stress == 0:\n        return (\n            \"stress\",\n            tangential_force / area,\n        )\n    elif tangential_force == 0:\n        return (\n            \"tangential_force\",\n            stress * area,\n        )\n    else:\n        return (\n            \"area\",\n            tangential_force / stress,\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "physics/mirror_formulae.py": "\"\"\"\nThis module contains the functions to calculate the focal length, object distance\nand image distance of a mirror.\n\nThe mirror formula is an equation that relates the object distance (u),\nimage distance (v), and focal length (f) of a spherical mirror.\nIt is commonly used in optics to determine the position and characteristics\nof an image formed by a mirror. It is expressed using the formulae :\n\n-------------------\n| 1/f = 1/v + 1/u |\n-------------------\n\nWhere,\nf = Focal length of the spherical mirror (metre)\nv = Image distance from the mirror (metre)\nu = Object distance from the mirror (metre)\n\n\nThe signs of the distances are taken with respect to the sign convention.\nThe sign convention is as follows:\n    1) Object is always placed to the left of mirror\n    2) Distances measured in the direction of the incident ray are positive\n    and the distances measured in the direction opposite to that of the incident\n    rays are negative.\n    3) All distances are measured from the pole of the mirror.\n\n\nThere are a few assumptions that are made while using the mirror formulae.\nThey are as follows:\n    1) Thin Mirror: The mirror is assumed to be thin, meaning its thickness is\n    negligible compared to its radius of curvature. This assumption allows\n    us to treat the mirror as a two-dimensional surface.\n    2) Spherical Mirror: The mirror is assumed to have a spherical shape. While this\n    assumption may not hold exactly for all mirrors, it is a reasonable approximation\n    for most practical purposes.\n    3) Small Angles: The angles involved in the derivation are assumed to be small.\n    This assumption allows us to use the small-angle approximation, where the tangent\n    of a small angle is approximately equal to the angle itself. It simplifies the\n    calculations and makes the derivation more manageable.\n    4) Paraxial Rays: The mirror formula is derived using paraxial rays, which are\n    rays that are close to the principal axis and make small angles with it. This\n    assumption ensures that the rays are close enough to the principal axis, making the\n    calculations more accurate.\n    5) Reflection and Refraction Laws: The derivation assumes that the laws of\n    reflection and refraction hold.\n    These laws state that the angle of incidence is equal to the angle of reflection\n    for reflection, and the incident and refracted rays lie in the same plane and\n    obey Snell's law for refraction.\n\n(Description and Assumptions adapted from\nhttps://www.collegesearch.in/articles/mirror-formula-derivation)\n\n(Sign Convention adapted from\nhttps://www.toppr.com/ask/content/concept/sign-convention-for-mirrors-210189/)\n\n\n\"\"\"\n\n\ndef focal_length(distance_of_object: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(focal_length(10, 20), 6.66666666666666)\n    True\n    >>> from math import isclose\n    >>> isclose(focal_length(9.5, 6.7), 3.929012346)\n    True\n    >>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_object == 0 or distance_of_image == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    focal_length = 1 / ((1 / distance_of_object) + (1 / distance_of_image))\n    return focal_length\n\n\ndef object_distance(focal_length: float, distance_of_image: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(object_distance(30, 20), -60.0)\n    True\n    >>> from math import isclose\n    >>> isclose(object_distance(10.5, 11.7), 102.375)\n    True\n    >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_image == 0 or focal_length == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    object_distance = 1 / ((1 / focal_length) - (1 / distance_of_image))\n    return object_distance\n\n\ndef image_distance(focal_length: float, distance_of_object: float) -> float:\n    \"\"\"\n    >>> from math import isclose\n    >>> isclose(image_distance(10, 40), 13.33333333)\n    True\n    >>> from math import isclose\n    >>> isclose(image_distance(1.5, 6.7), 1.932692308)\n    True\n    >>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid inputs. Enter non zero values with respect\n    to the sign convention.\n    \"\"\"\n\n    if distance_of_object == 0 or focal_length == 0:\n        raise ValueError(\n            \"Invalid inputs. Enter non zero values with respect to the sign convention.\"\n        )\n    image_distance = 1 / ((1 / focal_length) - (1 / distance_of_object))\n    return image_distance\n", "physics/hubble_parameter.py": "\"\"\"\nTitle : Calculating the Hubble Parameter\n\nDescription : The Hubble parameter H is the Universe expansion rate\nin any time. In cosmology is customary to use the redshift redshift\nin place of time, becausethe redshift is directily mensure\nin the light of galaxies moving away from us.\n\nSo, the general relation that we obtain is\n\nH = hubble_constant*(radiation_density*(redshift+1)**4\n                     + matter_density*(redshift+1)**3\n                     + curvature*(redshift+1)**2 + dark_energy)**(1/2)\n\nwhere radiation_density, matter_density, dark_energy are the relativity\n(the percentage) energy densities that exist\nin the Universe today. Here, matter_density is the\nsum of the barion density and the\ndark matter. Curvature is the curvature parameter and can be written in term\nof the densities by the completeness\n\n\ncurvature = 1 - (matter_density + radiation_density + dark_energy)\n\nSource :\nhttps://www.sciencedirect.com/topics/mathematics/hubble-parameter\n\"\"\"\n\n\ndef hubble_parameter(\n    hubble_constant: float,\n    radiation_density: float,\n    matter_density: float,\n    dark_energy: float,\n    redshift: float,\n) -> float:\n    \"\"\"\n    Input Parameters\n    ----------------\n    hubble_constant: Hubble constante is the expansion rate today usually\n    given in km/(s*Mpc)\n\n    radiation_density: relative radiation density today\n\n    matter_density: relative mass density today\n\n    dark_energy: relative dark energy density today\n\n    redshift: the light redshift\n\n    Returns\n    -------\n    result : Hubble parameter in and the unit km/s/Mpc (the unit can be\n    changed if you want, just need to change the unit of the Hubble constant)\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density=-0.3, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: All input parameters must be positive\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 1.2, dark_energy=0.7, redshift=1)\n    Traceback (most recent call last):\n    ...\n    ValueError: Relative densities cannot be greater than one\n\n    >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,\n    ... matter_density= 0.3, dark_energy=0.7, redshift=0)\n    68.3\n    \"\"\"\n    parameters = [redshift, radiation_density, matter_density, dark_energy]\n    if any(p < 0 for p in parameters):\n        raise ValueError(\"All input parameters must be positive\")\n\n    if any(p > 1 for p in parameters[1:4]):\n        raise ValueError(\"Relative densities cannot be greater than one\")\n    else:\n        curvature = 1 - (matter_density + radiation_density + dark_energy)\n\n        e_2 = (\n            radiation_density * (redshift + 1) ** 4\n            + matter_density * (redshift + 1) ** 3\n            + curvature * (redshift + 1) ** 2\n            + dark_energy\n        )\n\n        hubble = hubble_constant * e_2 ** (1 / 2)\n        return hubble\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    # run doctest\n    doctest.testmod()\n\n    # demo LCDM approximation\n    matter_density = 0.3\n\n    print(\n        hubble_parameter(\n            hubble_constant=68.3,\n            radiation_density=1e-4,\n            matter_density=matter_density,\n            dark_energy=1 - matter_density,\n            redshift=0,\n        )\n    )\n", "physics/speed_of_sound.py": "\"\"\"\nTitle : Calculating the speed of sound\n\nDescription :\n    The speed of sound (c) is the speed that a sound wave travels per unit time (m/s).\n    During propagation, the sound wave propagates through an elastic medium.\n\n    Sound propagates as longitudinal waves in liquids and gases and as transverse waves\n    in solids. This file calculates the speed of sound in a fluid based on its bulk\n    module and density.\n\n    Equation for the speed of sound in a fluid:\n    c_fluid = sqrt(K_s / p)\n\n    c_fluid: speed of sound in fluid\n    K_s: isentropic bulk modulus\n    p: density of fluid\n\nSource : https://en.wikipedia.org/wiki/Speed_of_sound\n\"\"\"\n\n\ndef speed_of_sound_in_a_fluid(density: float, bulk_modulus: float) -> float:\n    \"\"\"\n    Calculates the speed of sound in a fluid from its density and bulk modulus\n\n    Examples:\n    Example 1 --> Water 20\u00b0C: bulk_modulus= 2.15MPa, density=998kg/m\u00b3\n    Example 2 --> Mercury 20\u00b0C: bulk_modulus= 28.5MPa, density=13600kg/m\u00b3\n\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)\n    1467.7563207952705\n    >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)\n    1447.614670861731\n    \"\"\"\n\n    if density <= 0:\n        raise ValueError(\"Impossible fluid density\")\n    if bulk_modulus <= 0:\n        raise ValueError(\"Impossible bulk modulus\")\n\n    return (bulk_modulus / density) ** 0.5\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "linear_algebra/gaussian_elimination.py": "\"\"\"\nGaussian elimination method for solving a system of linear equations.\nGaussian elimination - https://en.wikipedia.org/wiki/Gaussian_elimination\n\"\"\"\n\nimport numpy as np\nfrom numpy import float64\nfrom numpy.typing import NDArray\n\n\ndef retroactive_resolution(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    \"\"\"\n    This function performs a retroactive linear system resolution\n        for triangular matrix\n\n    Examples:\n        2x1 + 2x2 - 1x3 = 5         2x1 + 2x2 = -1\n        0x1 - 2x2 - 1x3 = -7        0x1 - 2x2 = -1\n        0x1 + 0x2 + 5x3 = 15\n    >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])\n    array([[2.],\n           [2.],\n           [3.]])\n    >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])\n    array([[-1. ],\n           [ 0.5]])\n    \"\"\"\n\n    rows, columns = np.shape(coefficients)\n\n    x: NDArray[float64] = np.zeros((rows, 1), dtype=float)\n    for row in reversed(range(rows)):\n        total = np.dot(coefficients[row, row + 1 :], x[row + 1 :])\n        x[row, 0] = (vector[row][0] - total[0]) / coefficients[row, row]\n\n    return x\n\n\ndef gaussian_elimination(\n    coefficients: NDArray[float64], vector: NDArray[float64]\n) -> NDArray[float64]:\n    \"\"\"\n    This function performs Gaussian elimination method\n\n    Examples:\n        1x1 - 4x2 - 2x3 = -2        1x1 + 2x2 = 5\n        5x1 + 2x2 - 2x3 = -3        5x1 + 2x2 = 5\n        1x1 - 1x2 + 0x3 = 4\n    >>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])\n    array([[ 2.3 ],\n           [-1.7 ],\n           [ 5.55]])\n    >>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])\n    array([[0. ],\n           [2.5]])\n    \"\"\"\n    # coefficients must to be a square matrix so we need to check first\n    rows, columns = np.shape(coefficients)\n    if rows != columns:\n        return np.array((), dtype=float)\n\n    # augmented matrix\n    augmented_mat: NDArray[float64] = np.concatenate((coefficients, vector), axis=1)\n    augmented_mat = augmented_mat.astype(\"float64\")\n\n    # scale the matrix leaving it triangular\n    for row in range(rows - 1):\n        pivot = augmented_mat[row, row]\n        for col in range(row + 1, columns):\n            factor = augmented_mat[col, row] / pivot\n            augmented_mat[col, :] -= factor * augmented_mat[row, :]\n\n    x = retroactive_resolution(\n        augmented_mat[:, 0:columns], augmented_mat[:, columns : columns + 1]\n    )\n\n    return x\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "linear_algebra/lu_decomposition.py": "\"\"\"\nLower-upper (LU) decomposition factors a matrix as a product of a lower\ntriangular matrix and an upper triangular matrix. A square matrix has an LU\ndecomposition under the following conditions:\n    - If the matrix is invertible, then it has an LU decomposition if and only\n    if all of its leading principal minors are non-zero (see\n    https://en.wikipedia.org/wiki/Minor_(linear_algebra) for an explanation of\n    leading principal minors of a matrix).\n    - If the matrix is singular (i.e., not invertible) and it has a rank of k\n    (i.e., it has k linearly independent columns), then it has an LU\n    decomposition if its first k leading principal minors are non-zero.\n\nThis algorithm will simply attempt to perform LU decomposition on any square\nmatrix and raise an error if no such decomposition exists.\n\nReference: https://en.wikipedia.org/wiki/LU_decomposition\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\n\ndef lower_upper_decomposition(table: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Perform LU decomposition on a given matrix and raises an error if the matrix\n    isn't square or if no such decomposition exists\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. , 0. ],\n           [0. , 1. , 0. ],\n           [2.5, 8. , 1. ]])\n    >>> upper_mat\n    array([[  2. ,  -2. ,   1. ],\n           [  0. ,   1. ,   2. ],\n           [  0. ,   0. , -17.5]])\n\n    >>> matrix = np.array([[4, 3], [6, 3]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1. , 0. ],\n           [1.5, 1. ]])\n    >>> upper_mat\n    array([[ 4. ,  3. ],\n           [ 0. , -1.5]])\n\n    # Matrix is not square\n    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n        ...\n    ValueError: 'table' has to be of square shaped array but got a 2x3 array:\n    [[ 2 -2  1]\n     [ 0  1  2]]\n\n    # Matrix is invertible, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n\n    # Matrix is singular, but its first leading principal minor is 1\n    >>> matrix = np.array([[1, 0], [1, 0]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    >>> lower_mat\n    array([[1., 0.],\n           [1., 1.]])\n    >>> upper_mat\n    array([[1., 0.],\n           [0., 0.]])\n\n    # Matrix is singular, but its first leading principal minor is 0\n    >>> matrix = np.array([[0, 1], [0, 1]])\n    >>> lower_mat, upper_mat = lower_upper_decomposition(matrix)\n    Traceback (most recent call last):\n    ...\n    ArithmeticError: No LU decomposition exists\n    \"\"\"\n    # Ensure that table is a square array\n    rows, columns = np.shape(table)\n    if rows != columns:\n        msg = (\n            \"'table' has to be of square shaped array but got a \"\n            f\"{rows}x{columns} array:\\n{table}\"\n        )\n        raise ValueError(msg)\n\n    lower = np.zeros((rows, columns))\n    upper = np.zeros((rows, columns))\n\n    # in 'total', the necessary data is extracted through slices\n    # and the sum of the products is obtained.\n\n    for i in range(columns):\n        for j in range(i):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            if upper[j][j] == 0:\n                raise ArithmeticError(\"No LU decomposition exists\")\n            lower[i][j] = (table[i][j] - total) / upper[j][j]\n        lower[i][i] = 1\n        for j in range(i, columns):\n            total = np.sum(lower[i, :i] * upper[:i, j])\n            upper[i][j] = table[i][j] - total\n    return lower, upper\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "linear_algebra/__init__.py": "", "linear_algebra/jacobi_iteration_method.py": "\"\"\"\nJacobi Iteration Method - https://en.wikipedia.org/wiki/Jacobi_method\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom numpy import float64\nfrom numpy.typing import NDArray\n\n\n# Method to find solution of system of linear equations\ndef jacobi_iteration_method(\n    coefficient_matrix: NDArray[float64],\n    constant_matrix: NDArray[float64],\n    init_val: list[float],\n    iterations: int,\n) -> list[float]:\n    \"\"\"\n    Jacobi Iteration Method:\n    An iterative algorithm to determine the solutions of strictly diagonally dominant\n    system of linear equations\n\n    4x1 +  x2 +  x3 =  2\n     x1 + 5x2 + 2x3 = -6\n     x1 + 2x2 + 4x3 = -4\n\n    x_init = [0.5, -0.5 , -0.5]\n\n    Examples:\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    [0.909375, -1.14375, -0.7484375]\n\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient matrix dimensions must be nxn but received 2x3\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(\n    ...     coefficient, constant, init_val, iterations\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but\n                received 3x3 and 2x1\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5]\n    >>> iterations = 3\n    >>> jacobi_iteration_method(\n    ...     coefficient, constant, init_val, iterations\n    ... )  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    ValueError: Number of initial values must be equal to number of rows in coefficient\n                matrix but received 2 and 3\n\n    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])\n    >>> constant = np.array([[2], [-6], [-4]])\n    >>> init_val = [0.5, -0.5, -0.5]\n    >>> iterations = 0\n    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)\n    Traceback (most recent call last):\n        ...\n    ValueError: Iterations must be at least 1\n    \"\"\"\n\n    rows1, cols1 = coefficient_matrix.shape\n    rows2, cols2 = constant_matrix.shape\n\n    if rows1 != cols1:\n        msg = f\"Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}\"\n        raise ValueError(msg)\n\n    if cols2 != 1:\n        msg = f\"Constant matrix must be nx1 but received {rows2}x{cols2}\"\n        raise ValueError(msg)\n\n    if rows1 != rows2:\n        msg = (\n            \"Coefficient and constant matrices dimensions must be nxn and nx1 but \"\n            f\"received {rows1}x{cols1} and {rows2}x{cols2}\"\n        )\n        raise ValueError(msg)\n\n    if len(init_val) != rows1:\n        msg = (\n            \"Number of initial values must be equal to number of rows in coefficient \"\n            f\"matrix but received {len(init_val)} and {rows1}\"\n        )\n        raise ValueError(msg)\n\n    if iterations <= 0:\n        raise ValueError(\"Iterations must be at least 1\")\n\n    table: NDArray[float64] = np.concatenate(\n        (coefficient_matrix, constant_matrix), axis=1\n    )\n\n    rows, cols = table.shape\n\n    strictly_diagonally_dominant(table)\n\n    \"\"\"\n    # Iterates the whole matrix for given number of times\n    for _ in range(iterations):\n        new_val = []\n        for row in range(rows):\n            temp = 0\n            for col in range(cols):\n                if col == row:\n                    denom = table[row][col]\n                elif col == cols - 1:\n                    val = table[row][col]\n                else:\n                    temp += (-1) * table[row][col] * init_val[col]\n            temp = (temp + val) / denom\n            new_val.append(temp)\n        init_val = new_val\n    \"\"\"\n\n    # denominator - a list of values along the diagonal\n    denominator = np.diag(coefficient_matrix)\n\n    # val_last - values of the last column of the table array\n    val_last = table[:, -1]\n\n    # masks - boolean mask of all strings without diagonal\n    # elements array coefficient_matrix\n    masks = ~np.eye(coefficient_matrix.shape[0], dtype=bool)\n\n    # no_diagonals - coefficient_matrix array values without diagonal elements\n    no_diagonals = coefficient_matrix[masks].reshape(-1, rows - 1)\n\n    # Here we get 'i_col' - these are the column numbers, for each row\n    # without diagonal elements, except for the last column.\n    i_row, i_col = np.where(masks)\n    ind = i_col.reshape(-1, rows - 1)\n\n    #'i_col' is converted to a two-dimensional list 'ind', which will be\n    # used to make selections from 'init_val' ('arr' array see below).\n\n    # Iterates the whole matrix for given number of times\n    for _ in range(iterations):\n        arr = np.take(init_val, ind)\n        sum_product_rows = np.sum((-1) * no_diagonals * arr, axis=1)\n        new_val = (sum_product_rows + val_last) / denominator\n        init_val = new_val\n\n    return new_val.tolist()\n\n\n# Checks if the given matrix is strictly diagonally dominant\ndef strictly_diagonally_dominant(table: NDArray[float64]) -> bool:\n    \"\"\"\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])\n    >>> strictly_diagonally_dominant(table)\n    True\n\n    >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])\n    >>> strictly_diagonally_dominant(table)\n    Traceback (most recent call last):\n        ...\n    ValueError: Coefficient matrix is not strictly diagonally dominant\n    \"\"\"\n\n    rows, cols = table.shape\n\n    is_diagonally_dominant = True\n\n    for i in range(rows):\n        total = 0\n        for j in range(cols - 1):\n            if i == j:\n                continue\n            else:\n                total += table[i][j]\n\n        if table[i][i] <= total:\n            raise ValueError(\"Coefficient matrix is not strictly diagonally dominant\")\n\n    return is_diagonally_dominant\n\n\n# Test Cases\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "linear_algebra/src/polynom_for_points.py": "def points_to_polynomial(coordinates: list[list[int]]) -> str:\n    \"\"\"\n    coordinates is a two dimensional matrix: [[x, y], [x, y], ...]\n    number of points you want to use\n\n    >>> print(points_to_polynomial([]))\n    Traceback (most recent call last):\n        ...\n    ValueError: The program cannot work out a fitting polynomial.\n    >>> print(points_to_polynomial([[]]))\n    Traceback (most recent call last):\n        ...\n    ValueError: The program cannot work out a fitting polynomial.\n    >>> print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))\n    f(x)=x^2*0.0+x^1*-0.0+x^0*0.0\n    >>> print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))\n    f(x)=x^2*0.0+x^1*-0.0+x^0*1.0\n    >>> print(points_to_polynomial([[1, 3], [2, 3], [3, 3]]))\n    f(x)=x^2*0.0+x^1*-0.0+x^0*3.0\n    >>> print(points_to_polynomial([[1, 1], [2, 2], [3, 3]]))\n    f(x)=x^2*0.0+x^1*1.0+x^0*0.0\n    >>> print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))\n    f(x)=x^2*1.0+x^1*-0.0+x^0*0.0\n    >>> print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))\n    f(x)=x^2*1.0+x^1*-0.0+x^0*2.0\n    >>> print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))\n    f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0\n    >>> print(points_to_polynomial([[1, 5], [2, 2], [3, 9]]))\n    f(x)=x^2*5.0+x^1*-18.0+x^0*18.0\n    \"\"\"\n    if len(coordinates) == 0 or not all(len(pair) == 2 for pair in coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    if len({tuple(pair) for pair in coordinates}) != len(coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    set_x = {x for x, _ in coordinates}\n    if len(set_x) == 1:\n        return f\"x={coordinates[0][0]}\"\n\n    if len(set_x) != len(coordinates):\n        raise ValueError(\"The program cannot work out a fitting polynomial.\")\n\n    x = len(coordinates)\n\n    # put the x and x to the power values in a matrix\n    matrix: list[list[float]] = [\n        [\n            coordinates[count_of_line][0] ** (x - (count_in_line + 1))\n            for count_in_line in range(x)\n        ]\n        for count_of_line in range(x)\n    ]\n\n    # put the y values into a vector\n    vector: list[float] = [coordinates[count_of_line][1] for count_of_line in range(x)]\n\n    for count in range(x):\n        for number in range(x):\n            if count == number:\n                continue\n            fraction = matrix[number][count] / matrix[count][count]\n            for counting_columns, item in enumerate(matrix[count]):\n                # manipulating all the values in the matrix\n                matrix[number][counting_columns] -= item * fraction\n            # manipulating the values in the vector\n            vector[number] -= vector[count] * fraction\n\n    # make solutions\n    solution: list[str] = [\n        str(vector[count] / matrix[count][count]) for count in range(x)\n    ]\n\n    solved = \"f(x)=\"\n\n    for count in range(x):\n        remove_e: list[str] = solution[count].split(\"E\")\n        if len(remove_e) > 1:\n            solution[count] = f\"{remove_e[0]}*10^{remove_e[1]}\"\n        solved += f\"x^{x - (count + 1)}*{solution[count]}\"\n        if count + 1 != x:\n            solved += \"+\"\n\n    return solved\n\n\nif __name__ == \"__main__\":\n    print(points_to_polynomial([]))\n    print(points_to_polynomial([[]]))\n    print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))\n    print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))\n    print(points_to_polynomial([[1, 3], [2, 3], [3, 3]]))\n    print(points_to_polynomial([[1, 1], [2, 2], [3, 3]]))\n    print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))\n    print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))\n    print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))\n    print(points_to_polynomial([[1, 5], [2, 2], [3, 9]]))\n", "linear_algebra/src/conjugate_gradient.py": "\"\"\"\nResources:\n- https://en.wikipedia.org/wiki/Conjugate_gradient_method\n- https://en.wikipedia.org/wiki/Definite_symmetric_matrix\n\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\n\n\ndef _is_matrix_spd(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if input matrix is symmetric positive definite.\n    Returns False otherwise.\n\n    For a matrix to be SPD, all eigenvalues must be positive.\n\n    >>> import numpy as np\n    >>> matrix = np.array([\n    ... [4.12401784, -5.01453636, -0.63865857],\n    ... [-5.01453636, 12.33347422, -3.40493586],\n    ... [-0.63865857, -3.40493586,  5.78591885]])\n    >>> _is_matrix_spd(matrix)\n    True\n    >>> matrix = np.array([\n    ... [0.34634879,  1.96165514,  2.18277744],\n    ... [0.74074469, -1.19648894, -1.34223498],\n    ... [-0.7687067 ,  0.06018373, -1.16315631]])\n    >>> _is_matrix_spd(matrix)\n    False\n    \"\"\"\n    # Ensure matrix is square.\n    assert np.shape(matrix)[0] == np.shape(matrix)[1]\n\n    # If matrix not symmetric, exit right away.\n    if np.allclose(matrix, matrix.T) is False:\n        return False\n\n    # Get eigenvalues and eignevectors for a symmetric matrix.\n    eigen_values, _ = np.linalg.eigh(matrix)\n\n    # Check sign of all eigenvalues.\n    # np.all returns a value of type np.bool_\n    return bool(np.all(eigen_values > 0))\n\n\ndef _create_spd_matrix(dimension: int) -> Any:\n    \"\"\"\n    Returns a symmetric positive definite matrix given a dimension.\n\n    Input:\n    dimension gives the square matrix dimension.\n\n    Output:\n    spd_matrix is an diminesion x dimensions symmetric positive definite (SPD) matrix.\n\n    >>> import numpy as np\n    >>> dimension = 3\n    >>> spd_matrix = _create_spd_matrix(dimension)\n    >>> _is_matrix_spd(spd_matrix)\n    True\n    \"\"\"\n    rng = np.random.default_rng()\n    random_matrix = rng.normal(size=(dimension, dimension))\n    spd_matrix = np.dot(random_matrix, random_matrix.T)\n    assert _is_matrix_spd(spd_matrix)\n    return spd_matrix\n\n\ndef conjugate_gradient(\n    spd_matrix: np.ndarray,\n    load_vector: np.ndarray,\n    max_iterations: int = 1000,\n    tol: float = 1e-8,\n) -> Any:\n    \"\"\"\n    Returns solution to the linear system np.dot(spd_matrix, x) = b.\n\n    Input:\n    spd_matrix is an NxN Symmetric Positive Definite (SPD) matrix.\n    load_vector is an Nx1 vector.\n\n    Output:\n    x is an Nx1 vector that is the solution vector.\n\n    >>> import numpy as np\n    >>> spd_matrix = np.array([\n    ... [8.73256573, -5.02034289, -2.68709226],\n    ... [-5.02034289,  3.78188322,  0.91980451],\n    ... [-2.68709226,  0.91980451,  1.94746467]])\n    >>> b = np.array([\n    ... [-5.80872761],\n    ... [ 3.23807431],\n    ... [ 1.95381422]])\n    >>> conjugate_gradient(spd_matrix, b)\n    array([[-0.63114139],\n           [-0.01561498],\n           [ 0.13979294]])\n    \"\"\"\n    # Ensure proper dimensionality.\n    assert np.shape(spd_matrix)[0] == np.shape(spd_matrix)[1]\n    assert np.shape(load_vector)[0] == np.shape(spd_matrix)[0]\n    assert _is_matrix_spd(spd_matrix)\n\n    # Initialize solution guess, residual, search direction.\n    x0 = np.zeros((np.shape(load_vector)[0], 1))\n    r0 = np.copy(load_vector)\n    p0 = np.copy(r0)\n\n    # Set initial errors in solution guess and residual.\n    error_residual = 1e9\n    error_x_solution = 1e9\n    error = 1e9\n\n    # Set iteration counter to threshold number of iterations.\n    iterations = 0\n\n    while error > tol:\n        # Save this value so we only calculate the matrix-vector product once.\n        w = np.dot(spd_matrix, p0)\n\n        # The main algorithm.\n\n        # Update search direction magnitude.\n        alpha = np.dot(r0.T, r0) / np.dot(p0.T, w)\n        # Update solution guess.\n        x = x0 + alpha * p0\n        # Calculate new residual.\n        r = r0 - alpha * w\n        # Calculate new Krylov subspace scale.\n        beta = np.dot(r.T, r) / np.dot(r0.T, r0)\n        # Calculate new A conjuage search direction.\n        p = r + beta * p0\n\n        # Calculate errors.\n        error_residual = np.linalg.norm(r - r0)\n        error_x_solution = np.linalg.norm(x - x0)\n        error = np.maximum(error_residual, error_x_solution)\n\n        # Update variables.\n        x0 = np.copy(x)\n        r0 = np.copy(r)\n        p0 = np.copy(p)\n\n        # Update number of iterations.\n        iterations += 1\n        if iterations > max_iterations:\n            break\n\n    return x\n\n\ndef test_conjugate_gradient() -> None:\n    \"\"\"\n    >>> test_conjugate_gradient()  # self running tests\n    \"\"\"\n    # Create linear system with SPD matrix and known solution x_true.\n    dimension = 3\n    spd_matrix = _create_spd_matrix(dimension)\n    rng = np.random.default_rng()\n    x_true = rng.normal(size=(dimension, 1))\n    b = np.dot(spd_matrix, x_true)\n\n    # Numpy solution.\n    x_numpy = np.linalg.solve(spd_matrix, b)\n\n    # Our implementation.\n    x_conjugate_gradient = conjugate_gradient(spd_matrix, b)\n\n    # Ensure both solutions are close to x_true (and therefore one another).\n    assert np.linalg.norm(x_numpy - x_true) <= 1e-6\n    assert np.linalg.norm(x_conjugate_gradient - x_true) <= 1e-6\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    test_conjugate_gradient()\n", "linear_algebra/src/power_iteration.py": "import numpy as np\n\n\ndef power_iteration(\n    input_matrix: np.ndarray,\n    vector: np.ndarray,\n    error_tol: float = 1e-12,\n    max_iterations: int = 100,\n) -> tuple[float, np.ndarray]:\n    \"\"\"\n    Power Iteration.\n    Find the largest eigenvalue and corresponding eigenvector\n    of matrix input_matrix given a random vector in the same space.\n    Will work so long as vector has component of largest eigenvector.\n    input_matrix must be either real or Hermitian.\n\n    Input\n    input_matrix: input matrix whose largest eigenvalue we will find.\n    Numpy array. np.shape(input_matrix) == (N,N).\n    vector: random initial vector in same space as matrix.\n    Numpy array. np.shape(vector) == (N,) or (N,1)\n\n    Output\n    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.\n    Float. Scalar.\n    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.\n    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\n\n    >>> import numpy as np\n    >>> input_matrix = np.array([\n    ... [41,  4, 20],\n    ... [ 4, 26, 30],\n    ... [20, 30, 50]\n    ... ])\n    >>> vector = np.array([41,4,20])\n    >>> power_iteration(input_matrix,vector)\n    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))\n    \"\"\"\n\n    # Ensure matrix is square.\n    assert np.shape(input_matrix)[0] == np.shape(input_matrix)[1]\n    # Ensure proper dimensionality.\n    assert np.shape(input_matrix)[0] == np.shape(vector)[0]\n    # Ensure inputs are either both complex or both real\n    assert np.iscomplexobj(input_matrix) == np.iscomplexobj(vector)\n    is_complex = np.iscomplexobj(input_matrix)\n    if is_complex:\n        # Ensure complex input_matrix is Hermitian\n        assert np.array_equal(input_matrix, input_matrix.conj().T)\n\n    # Set convergence to False. Will define convergence when we exceed max_iterations\n    # or when we have small changes from one iteration to next.\n\n    convergence = False\n    lambda_previous = 0\n    iterations = 0\n    error = 1e12\n\n    while not convergence:\n        # Multiple matrix by the vector.\n        w = np.dot(input_matrix, vector)\n        # Normalize the resulting output vector.\n        vector = w / np.linalg.norm(w)\n        # Find rayleigh quotient\n        # (faster than usual b/c we know vector is normalized already)\n        vector_h = vector.conj().T if is_complex else vector.T\n        lambda_ = np.dot(vector_h, np.dot(input_matrix, vector))\n\n        # Check convergence.\n        error = np.abs(lambda_ - lambda_previous) / lambda_\n        iterations += 1\n\n        if error <= error_tol or iterations >= max_iterations:\n            convergence = True\n\n        lambda_previous = lambda_\n\n    if is_complex:\n        lambda_ = np.real(lambda_)\n\n    return lambda_, vector\n\n\ndef test_power_iteration() -> None:\n    \"\"\"\n    >>> test_power_iteration()  # self running tests\n    \"\"\"\n    real_input_matrix = np.array([[41, 4, 20], [4, 26, 30], [20, 30, 50]])\n    real_vector = np.array([41, 4, 20])\n    complex_input_matrix = real_input_matrix.astype(np.complex128)\n    imag_matrix = np.triu(1j * complex_input_matrix, 1)\n    complex_input_matrix += imag_matrix\n    complex_input_matrix += -1 * imag_matrix.T\n    complex_vector = np.array([41, 4, 20]).astype(np.complex128)\n\n    for problem_type in [\"real\", \"complex\"]:\n        if problem_type == \"real\":\n            input_matrix = real_input_matrix\n            vector = real_vector\n        elif problem_type == \"complex\":\n            input_matrix = complex_input_matrix\n            vector = complex_vector\n\n        # Our implementation.\n        eigen_value, eigen_vector = power_iteration(input_matrix, vector)\n\n        # Numpy implementation.\n\n        # Get eigenvalues and eigenvectors using built-in numpy\n        # eigh (eigh used for symmetric or hermetian matrices).\n        eigen_values, eigen_vectors = np.linalg.eigh(input_matrix)\n        # Last eigenvalue is the maximum one.\n        eigen_value_max = eigen_values[-1]\n        # Last column in this matrix is eigenvector corresponding to largest eigenvalue.\n        eigen_vector_max = eigen_vectors[:, -1]\n\n        # Check our implementation and numpy gives close answers.\n        assert np.abs(eigen_value - eigen_value_max) <= 1e-6\n        # Take absolute values element wise of each eigenvector.\n        # as they are only unique to a minus sign.\n        assert np.linalg.norm(np.abs(eigen_vector) - np.abs(eigen_vector_max)) <= 1e-6\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    test_power_iteration()\n", "linear_algebra/src/lib.py": "\"\"\"\nCreated on Mon Feb 26 14:29:11 2018\n\n@author: Christian Bender\n@license: MIT-license\n\nThis module contains some useful classes and functions for dealing\nwith linear algebra in python.\n\nOverview:\n\n- class Vector\n- function zero_vector(dimension)\n- function unit_basis_vector(dimension, pos)\n- function axpy(scalar, vector1, vector2)\n- function random_vector(N, a, b)\n- class Matrix\n- function square_zero_matrix(N)\n- function random_matrix(W, H, a, b)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom collections.abc import Collection\nfrom typing import overload\n\n\nclass Vector:\n    \"\"\"\n    This class represents a vector of arbitrary size.\n    You need to give the vector components.\n\n    Overview of the methods:\n\n        __init__(components: Collection[float] | None): init the vector\n        __len__(): gets the size of the vector (number of components)\n        __str__(): returns a string representation\n        __add__(other: Vector): vector addition\n        __sub__(other: Vector): vector subtraction\n        __mul__(other: float): scalar multiplication\n        __mul__(other: Vector): dot product\n        copy(): copies this vector and returns it\n        component(i): gets the i-th component (0-indexed)\n        change_component(pos: int, value: float): changes specified component\n        euclidean_length(): returns the euclidean length of the vector\n        angle(other: Vector, deg: bool): returns the angle between two vectors\n        TODO: compare-operator\n    \"\"\"\n\n    def __init__(self, components: Collection[float] | None = None) -> None:\n        \"\"\"\n        input: components or nothing\n        simple constructor for init the vector\n        \"\"\"\n        if components is None:\n            components = []\n        self.__components = list(components)\n\n    def __len__(self) -> int:\n        \"\"\"\n        returns the size of the vector\n        \"\"\"\n        return len(self.__components)\n\n    def __str__(self) -> str:\n        \"\"\"\n        returns a string representation of the vector\n        \"\"\"\n        return \"(\" + \",\".join(map(str, self.__components)) + \")\"\n\n    def __add__(self, other: Vector) -> Vector:\n        \"\"\"\n        input: other vector\n        assumes: other vector has the same size\n        returns a new vector that represents the sum.\n        \"\"\"\n        size = len(self)\n        if size == len(other):\n            result = [self.__components[i] + other.component(i) for i in range(size)]\n            return Vector(result)\n        else:\n            raise Exception(\"must have the same size\")\n\n    def __sub__(self, other: Vector) -> Vector:\n        \"\"\"\n        input: other vector\n        assumes: other vector has the same size\n        returns a new vector that represents the difference.\n        \"\"\"\n        size = len(self)\n        if size == len(other):\n            result = [self.__components[i] - other.component(i) for i in range(size)]\n            return Vector(result)\n        else:  # error case\n            raise Exception(\"must have the same size\")\n\n    @overload\n    def __mul__(self, other: float) -> Vector: ...\n\n    @overload\n    def __mul__(self, other: Vector) -> float: ...\n\n    def __mul__(self, other: float | Vector) -> float | Vector:\n        \"\"\"\n        mul implements the scalar multiplication\n        and the dot-product\n        \"\"\"\n        if isinstance(other, (float, int)):\n            ans = [c * other for c in self.__components]\n            return Vector(ans)\n        elif isinstance(other, Vector) and len(self) == len(other):\n            size = len(self)\n            prods = [self.__components[i] * other.component(i) for i in range(size)]\n            return sum(prods)\n        else:  # error case\n            raise Exception(\"invalid operand!\")\n\n    def copy(self) -> Vector:\n        \"\"\"\n        copies this vector and returns it.\n        \"\"\"\n        return Vector(self.__components)\n\n    def component(self, i: int) -> float:\n        \"\"\"\n        input: index (0-indexed)\n        output: the i-th component of the vector.\n        \"\"\"\n        if isinstance(i, int) and -len(self.__components) <= i < len(self.__components):\n            return self.__components[i]\n        else:\n            raise Exception(\"index out of range\")\n\n    def change_component(self, pos: int, value: float) -> None:\n        \"\"\"\n        input: an index (pos) and a value\n        changes the specified component (pos) with the\n        'value'\n        \"\"\"\n        # precondition\n        assert -len(self.__components) <= pos < len(self.__components)\n        self.__components[pos] = value\n\n    def euclidean_length(self) -> float:\n        \"\"\"\n        returns the euclidean length of the vector\n\n        >>> Vector([2, 3, 4]).euclidean_length()\n        5.385164807134504\n        >>> Vector([1]).euclidean_length()\n        1.0\n        >>> Vector([0, -1, -2, -3, 4, 5, 6]).euclidean_length()\n        9.539392014169456\n        >>> Vector([]).euclidean_length()\n        Traceback (most recent call last):\n            ...\n        Exception: Vector is empty\n        \"\"\"\n        if len(self.__components) == 0:\n            raise Exception(\"Vector is empty\")\n        squares = [c**2 for c in self.__components]\n        return math.sqrt(sum(squares))\n\n    def angle(self, other: Vector, deg: bool = False) -> float:\n        \"\"\"\n        find angle between two Vector (self, Vector)\n\n        >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]))\n        1.4906464636572374\n        >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]), deg = True)\n        85.40775111366095\n        >>> Vector([3, 4, -1]).angle(Vector([2, -1]))\n        Traceback (most recent call last):\n            ...\n        Exception: invalid operand!\n        \"\"\"\n        num = self * other\n        den = self.euclidean_length() * other.euclidean_length()\n        if deg:\n            return math.degrees(math.acos(num / den))\n        else:\n            return math.acos(num / den)\n\n\ndef zero_vector(dimension: int) -> Vector:\n    \"\"\"\n    returns a zero-vector of size 'dimension'\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    return Vector([0] * dimension)\n\n\ndef unit_basis_vector(dimension: int, pos: int) -> Vector:\n    \"\"\"\n    returns a unit basis vector with a One\n    at index 'pos' (indexing at 0)\n    \"\"\"\n    # precondition\n    assert isinstance(dimension, int)\n    assert isinstance(pos, int)\n    ans = [0] * dimension\n    ans[pos] = 1\n    return Vector(ans)\n\n\ndef axpy(scalar: float, x: Vector, y: Vector) -> Vector:\n    \"\"\"\n    input: a 'scalar' and two vectors 'x' and 'y'\n    output: a vector\n    computes the axpy operation\n    \"\"\"\n    # precondition\n    assert isinstance(x, Vector)\n    assert isinstance(y, Vector)\n    assert isinstance(scalar, (int, float))\n    return x * scalar + y\n\n\ndef random_vector(n: int, a: int, b: int) -> Vector:\n    \"\"\"\n    input: size (N) of the vector.\n           random range (a,b)\n    output: returns a random vector of size N, with\n            random integer components between 'a' and 'b'.\n    \"\"\"\n    random.seed(None)\n    ans = [random.randint(a, b) for _ in range(n)]\n    return Vector(ans)\n\n\nclass Matrix:\n    \"\"\"\n    class: Matrix\n    This class represents an arbitrary matrix.\n\n    Overview of the methods:\n\n        __init__():\n        __str__(): returns a string representation\n        __add__(other: Matrix): matrix addition\n        __sub__(other: Matrix): matrix subtraction\n        __mul__(other: float): scalar multiplication\n        __mul__(other: Vector): vector multiplication\n        height() : returns height\n        width() : returns width\n        component(x: int, y: int): returns specified component\n        change_component(x: int, y: int, value: float): changes specified component\n        minor(x: int, y: int): returns minor along (x, y)\n        cofactor(x: int, y: int): returns cofactor along (x, y)\n        determinant() : returns determinant\n    \"\"\"\n\n    def __init__(self, matrix: list[list[float]], w: int, h: int) -> None:\n        \"\"\"\n        simple constructor for initializing the matrix with components.\n        \"\"\"\n        self.__matrix = matrix\n        self.__width = w\n        self.__height = h\n\n    def __str__(self) -> str:\n        \"\"\"\n        returns a string representation of this matrix.\n        \"\"\"\n        ans = \"\"\n        for i in range(self.__height):\n            ans += \"|\"\n            for j in range(self.__width):\n                if j < self.__width - 1:\n                    ans += str(self.__matrix[i][j]) + \",\"\n                else:\n                    ans += str(self.__matrix[i][j]) + \"|\\n\"\n        return ans\n\n    def __add__(self, other: Matrix) -> Matrix:\n        \"\"\"\n        implements matrix addition.\n        \"\"\"\n        if self.__width == other.width() and self.__height == other.height():\n            matrix = []\n            for i in range(self.__height):\n                row = [\n                    self.__matrix[i][j] + other.component(i, j)\n                    for j in range(self.__width)\n                ]\n                matrix.append(row)\n            return Matrix(matrix, self.__width, self.__height)\n        else:\n            raise Exception(\"matrix must have the same dimension!\")\n\n    def __sub__(self, other: Matrix) -> Matrix:\n        \"\"\"\n        implements matrix subtraction.\n        \"\"\"\n        if self.__width == other.width() and self.__height == other.height():\n            matrix = []\n            for i in range(self.__height):\n                row = [\n                    self.__matrix[i][j] - other.component(i, j)\n                    for j in range(self.__width)\n                ]\n                matrix.append(row)\n            return Matrix(matrix, self.__width, self.__height)\n        else:\n            raise Exception(\"matrices must have the same dimension!\")\n\n    @overload\n    def __mul__(self, other: float) -> Matrix: ...\n\n    @overload\n    def __mul__(self, other: Vector) -> Vector: ...\n\n    def __mul__(self, other: float | Vector) -> Vector | Matrix:\n        \"\"\"\n        implements the matrix-vector multiplication.\n        implements the matrix-scalar multiplication\n        \"\"\"\n        if isinstance(other, Vector):  # matrix-vector\n            if len(other) == self.__width:\n                ans = zero_vector(self.__height)\n                for i in range(self.__height):\n                    prods = [\n                        self.__matrix[i][j] * other.component(j)\n                        for j in range(self.__width)\n                    ]\n                    ans.change_component(i, sum(prods))\n                return ans\n            else:\n                raise Exception(\n                    \"vector must have the same size as the \"\n                    \"number of columns of the matrix!\"\n                )\n        elif isinstance(other, (int, float)):  # matrix-scalar\n            matrix = [\n                [self.__matrix[i][j] * other for j in range(self.__width)]\n                for i in range(self.__height)\n            ]\n            return Matrix(matrix, self.__width, self.__height)\n        return None\n\n    def height(self) -> int:\n        \"\"\"\n        getter for the height\n        \"\"\"\n        return self.__height\n\n    def width(self) -> int:\n        \"\"\"\n        getter for the width\n        \"\"\"\n        return self.__width\n\n    def component(self, x: int, y: int) -> float:\n        \"\"\"\n        returns the specified (x,y) component\n        \"\"\"\n        if 0 <= x < self.__height and 0 <= y < self.__width:\n            return self.__matrix[x][y]\n        else:\n            raise Exception(\"change_component: indices out of bounds\")\n\n    def change_component(self, x: int, y: int, value: float) -> None:\n        \"\"\"\n        changes the x-y component of this matrix\n        \"\"\"\n        if 0 <= x < self.__height and 0 <= y < self.__width:\n            self.__matrix[x][y] = value\n        else:\n            raise Exception(\"change_component: indices out of bounds\")\n\n    def minor(self, x: int, y: int) -> float:\n        \"\"\"\n        returns the minor along (x, y)\n        \"\"\"\n        if self.__height != self.__width:\n            raise Exception(\"Matrix is not square\")\n        minor = self.__matrix[:x] + self.__matrix[x + 1 :]\n        for i in range(len(minor)):\n            minor[i] = minor[i][:y] + minor[i][y + 1 :]\n        return Matrix(minor, self.__width - 1, self.__height - 1).determinant()\n\n    def cofactor(self, x: int, y: int) -> float:\n        \"\"\"\n        returns the cofactor (signed minor) along (x, y)\n        \"\"\"\n        if self.__height != self.__width:\n            raise Exception(\"Matrix is not square\")\n        if 0 <= x < self.__height and 0 <= y < self.__width:\n            return (-1) ** (x + y) * self.minor(x, y)\n        else:\n            raise Exception(\"Indices out of bounds\")\n\n    def determinant(self) -> float:\n        \"\"\"\n        returns the determinant of an nxn matrix using Laplace expansion\n        \"\"\"\n        if self.__height != self.__width:\n            raise Exception(\"Matrix is not square\")\n        if self.__height < 1:\n            raise Exception(\"Matrix has no element\")\n        elif self.__height == 1:\n            return self.__matrix[0][0]\n        elif self.__height == 2:\n            return (\n                self.__matrix[0][0] * self.__matrix[1][1]\n                - self.__matrix[0][1] * self.__matrix[1][0]\n            )\n        else:\n            cofactor_prods = [\n                self.__matrix[0][y] * self.cofactor(0, y) for y in range(self.__width)\n            ]\n            return sum(cofactor_prods)\n\n\ndef square_zero_matrix(n: int) -> Matrix:\n    \"\"\"\n    returns a square zero-matrix of dimension NxN\n    \"\"\"\n    ans: list[list[float]] = [[0] * n for _ in range(n)]\n    return Matrix(ans, n, n)\n\n\ndef random_matrix(width: int, height: int, a: int, b: int) -> Matrix:\n    \"\"\"\n    returns a random matrix WxH with integer components\n    between 'a' and 'b'\n    \"\"\"\n    random.seed(None)\n    matrix: list[list[float]] = [\n        [random.randint(a, b) for _ in range(width)] for _ in range(height)\n    ]\n    return Matrix(matrix, width, height)\n", "linear_algebra/src/rank_of_matrix.py": "\"\"\"\nCalculate the rank of a matrix.\n\nSee: https://en.wikipedia.org/wiki/Rank_(linear_algebra)\n\"\"\"\n\n\ndef rank_of_matrix(matrix: list[list[int | float]]) -> int:\n    \"\"\"\n    Finds the rank of a matrix.\n    Args:\n        matrix: The matrix as a list of lists.\n    Returns:\n        The rank of the matrix.\n    Example:\n    >>> matrix1 = [[1, 2, 3],\n    ...            [4, 5, 6],\n    ...            [7, 8, 9]]\n    >>> rank_of_matrix(matrix1)\n    2\n    >>> matrix2 = [[1, 0, 0],\n    ...            [0, 1, 0],\n    ...            [0, 0, 0]]\n    >>> rank_of_matrix(matrix2)\n    2\n    >>> matrix3 = [[1, 2, 3, 4],\n    ...            [5, 6, 7, 8],\n    ...            [9, 10, 11, 12]]\n    >>> rank_of_matrix(matrix3)\n    2\n    >>> rank_of_matrix([[2,3,-1,-1],\n    ...                [1,-1,-2,4],\n    ...                [3,1,3,-2],\n    ...                [6,3,0,-7]])\n    4\n    >>> rank_of_matrix([[2,1,-3,-6],\n    ...                [3,-3,1,2],\n    ...                [1,1,1,2]])\n    3\n    >>> rank_of_matrix([[2,-1,0],\n    ...                [1,3,4],\n    ...                [4,1,-3]])\n    3\n    >>> rank_of_matrix([[3,2,1],\n    ...                [-6,-4,-2]])\n    1\n    >>> rank_of_matrix([[],[]])\n    0\n    >>> rank_of_matrix([[1]])\n    1\n    >>> rank_of_matrix([[]])\n    0\n    \"\"\"\n\n    rows = len(matrix)\n    columns = len(matrix[0])\n    rank = min(rows, columns)\n\n    for row in range(rank):\n        # Check if diagonal element is not zero\n        if matrix[row][row] != 0:\n            # Eliminate all the elements below the diagonal\n            for col in range(row + 1, rows):\n                multiplier = matrix[col][row] / matrix[row][row]\n                for i in range(row, columns):\n                    matrix[col][i] -= multiplier * matrix[row][i]\n        else:\n            # Find a non-zero diagonal element to swap rows\n            reduce = True\n            for i in range(row + 1, rows):\n                if matrix[i][row] != 0:\n                    matrix[row], matrix[i] = matrix[i], matrix[row]\n                    reduce = False\n                    break\n            if reduce:\n                rank -= 1\n                for i in range(rows):\n                    matrix[i][row] = matrix[i][rank]\n\n            # Reduce the row pointer by one to stay on the same row\n            row -= 1\n\n    return rank\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "linear_algebra/src/schur_complement.py": "import unittest\n\nimport numpy as np\nimport pytest\n\n\ndef schur_complement(\n    mat_a: np.ndarray,\n    mat_b: np.ndarray,\n    mat_c: np.ndarray,\n    pseudo_inv: np.ndarray | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Schur complement of a symmetric matrix X given as a 2x2 block matrix\n    consisting of matrices A, B and C.\n    Matrix A must be quadratic and non-singular.\n    In case A is singular, a pseudo-inverse may be provided using\n    the pseudo_inv argument.\n\n    Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement\n    See also Convex Optimization - Boyd and Vandenberghe, A.5.5\n    >>> import numpy as np\n    >>> a = np.array([[1, 2], [2, 1]])\n    >>> b = np.array([[0, 3], [3, 0]])\n    >>> c = np.array([[2, 1], [6, 3]])\n    >>> schur_complement(a, b, c)\n    array([[ 5., -5.],\n           [ 0.,  6.]])\n    \"\"\"\n    shape_a = np.shape(mat_a)\n    shape_b = np.shape(mat_b)\n    shape_c = np.shape(mat_c)\n\n    if shape_a[0] != shape_b[0]:\n        msg = (\n            \"Expected the same number of rows for A and B. \"\n            f\"Instead found A of size {shape_a} and B of size {shape_b}\"\n        )\n        raise ValueError(msg)\n\n    if shape_b[1] != shape_c[1]:\n        msg = (\n            \"Expected the same number of columns for B and C. \"\n            f\"Instead found B of size {shape_b} and C of size {shape_c}\"\n        )\n        raise ValueError(msg)\n\n    a_inv = pseudo_inv\n    if a_inv is None:\n        try:\n            a_inv = np.linalg.inv(mat_a)\n        except np.linalg.LinAlgError:\n            raise ValueError(\n                \"Input matrix A is not invertible. Cannot compute Schur complement.\"\n            )\n\n    return mat_c - mat_b.T @ a_inv @ mat_b\n\n\nclass TestSchurComplement(unittest.TestCase):\n    def test_schur_complement(self) -> None:\n        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])\n        b = np.array([[0, 3], [3, 0], [2, 3]])\n        c = np.array([[2, 1], [6, 3]])\n\n        s = schur_complement(a, b, c)\n\n        input_matrix = np.block([[a, b], [b.T, c]])\n\n        det_x = np.linalg.det(input_matrix)\n        det_a = np.linalg.det(a)\n        det_s = np.linalg.det(s)\n\n        assert np.is_close(det_x, det_a * det_s)\n\n    def test_improper_a_b_dimensions(self) -> None:\n        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])\n        b = np.array([[0, 3], [3, 0], [2, 3]])\n        c = np.array([[2, 1], [6, 3]])\n\n        with pytest.raises(ValueError):\n            schur_complement(a, b, c)\n\n    def test_improper_b_c_dimensions(self) -> None:\n        a = np.array([[1, 2, 1], [2, 1, 2], [3, 2, 4]])\n        b = np.array([[0, 3], [3, 0], [2, 3]])\n        c = np.array([[2, 1, 3], [6, 3, 5]])\n\n        with pytest.raises(ValueError):\n            schur_complement(a, b, c)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    unittest.main()\n", "linear_algebra/src/rayleigh_quotient.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Rayleigh_quotient\n\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\n\n\ndef is_hermitian(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a matrix is Hermitian.\n    >>> import numpy as np\n    >>> A = np.array([\n    ... [2,    2+1j, 4],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    True\n    >>> A = np.array([\n    ... [2,    2+1j, 4+1j],\n    ... [2-1j,  3,  1j],\n    ... [4,    -1j,  1]])\n    >>> is_hermitian(A)\n    False\n    \"\"\"\n    return np.array_equal(matrix, matrix.conjugate().T)\n\n\ndef rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:\n    \"\"\"\n    Returns the Rayleigh quotient of a Hermitian matrix A and\n    vector v.\n    >>> import numpy as np\n    >>> A = np.array([\n    ... [1,  2, 4],\n    ... [2,  3,  -1],\n    ... [4, -1,  1]\n    ... ])\n    >>> v = np.array([\n    ... [1],\n    ... [2],\n    ... [3]\n    ... ])\n    >>> rayleigh_quotient(A, v)\n    array([[3.]])\n    \"\"\"\n    v_star = v.conjugate().T\n    v_star_dot = v_star.dot(a)\n    assert isinstance(v_star_dot, np.ndarray)\n    return (v_star_dot.dot(v)) / (v_star.dot(v))\n\n\ndef tests() -> None:\n    a = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])\n    v = np.array([[1], [2], [3]])\n    assert is_hermitian(a), f\"{a} is not hermitian.\"\n    print(rayleigh_quotient(a, v))\n\n    a = np.array([[1, 2, 4], [2, 3, -1], [4, -1, 1]])\n    assert is_hermitian(a), f\"{a} is not hermitian.\"\n    assert rayleigh_quotient(a, v) == float(3)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    tests()\n", "linear_algebra/src/__init__.py": "", "linear_algebra/src/transformations_2d.py": "\"\"\"\n2D Transformations are regularly used in Linear Algebra.\n\nI have added the codes for reflection, projection, scaling and rotation 2D matrices.\n\n    scaling(5) = [[5.0, 0.0], [0.0, 5.0]]\n  rotation(45) = [[0.5253219888177297, -0.8509035245341184],\n                  [0.8509035245341184, 0.5253219888177297]]\nprojection(45) = [[0.27596319193541496, 0.446998331800279],\n                  [0.446998331800279, 0.7240368080645851]]\nreflection(45) = [[0.05064397763545947, 0.893996663600558],\n                  [0.893996663600558, 0.7018070490682369]]\n\"\"\"\n\nfrom math import cos, sin\n\n\ndef scaling(scaling_factor: float) -> list[list[float]]:\n    \"\"\"\n    >>> scaling(5)\n    [[5.0, 0.0], [0.0, 5.0]]\n    \"\"\"\n    scaling_factor = float(scaling_factor)\n    return [[scaling_factor * int(x == y) for x in range(2)] for y in range(2)]\n\n\ndef rotation(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.5253219888177297, -0.8509035245341184],\n     [0.8509035245341184, 0.5253219888177297]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    return [[c, -s], [s, c]]\n\n\ndef projection(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> projection(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.27596319193541496, 0.446998331800279],\n     [0.446998331800279, 0.7240368080645851]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    cs = c * s\n    return [[c * c, cs], [cs, s * s]]\n\n\ndef reflection(angle: float) -> list[list[float]]:\n    \"\"\"\n    >>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE\n    [[0.05064397763545947, 0.893996663600558],\n     [0.893996663600558, 0.7018070490682369]]\n    \"\"\"\n    c, s = cos(angle), sin(angle)\n    cs = c * s\n    return [[2 * c - 1, 2 * cs], [2 * cs, 2 * s - 1]]\n\n\nprint(f\"    {scaling(5) = }\")\nprint(f\"  {rotation(45) = }\")\nprint(f\"{projection(45) = }\")\nprint(f\"{reflection(45) = }\")\n", "linear_algebra/src/gaussian_elimination_pivoting/gaussian_elimination_pivoting.py": "import numpy as np\n\nmatrix = np.array(\n    [\n        [5.0, -5.0, -3.0, 4.0, -11.0],\n        [1.0, -4.0, 6.0, -4.0, -10.0],\n        [-2.0, -5.0, 4.0, -5.0, -12.0],\n        [-3.0, -3.0, 5.0, -5.0, 8.0],\n    ],\n    dtype=float,\n)\n\n\ndef solve_linear_system(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Solve a linear system of equations using Gaussian elimination with partial pivoting\n\n    Args:\n    - matrix: Coefficient matrix with the last column representing the constants.\n\n    Returns:\n    - Solution vector.\n\n    Raises:\n    - ValueError: If the matrix is not correct (i.e., singular).\n\n    https://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7\n\n    Example:\n    >>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float)\n    >>> B = np.array([8, -11, -3], dtype=float)\n    >>> solution = solve_linear_system(np.column_stack((A, B)))\n    >>> np.allclose(solution, np.array([2., 3., -1.]))\n    True\n    >>> solve_linear_system(np.array([[0, 0], [0, 0]],  dtype=float))\n    array([nan, nan])\n    \"\"\"\n    ab = np.copy(matrix)\n    num_of_rows = ab.shape[0]\n    num_of_columns = ab.shape[1] - 1\n    x_lst: list[float] = []\n\n    # Lead element search\n    for column_num in range(num_of_rows):\n        for i in range(column_num, num_of_columns):\n            if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):\n                ab[[column_num, i]] = ab[[i, column_num]]\n                if ab[column_num, column_num] == 0.0:\n                    raise ValueError(\"Matrix is not correct\")\n            else:\n                pass\n        if column_num != 0:\n            for i in range(column_num, num_of_rows):\n                ab[i, :] -= (\n                    ab[i, column_num - 1]\n                    / ab[column_num - 1, column_num - 1]\n                    * ab[column_num - 1, :]\n                )\n\n    # Upper triangular matrix\n    for column_num in range(num_of_rows):\n        for i in range(column_num, num_of_columns):\n            if abs(ab[i][column_num]) > abs(ab[column_num][column_num]):\n                ab[[column_num, i]] = ab[[i, column_num]]\n                if ab[column_num, column_num] == 0.0:\n                    raise ValueError(\"Matrix is not correct\")\n            else:\n                pass\n        if column_num != 0:\n            for i in range(column_num, num_of_rows):\n                ab[i, :] -= (\n                    ab[i, column_num - 1]\n                    / ab[column_num - 1, column_num - 1]\n                    * ab[column_num - 1, :]\n                )\n\n    # Find x vector (Back Substitution)\n    for column_num in range(num_of_rows - 1, -1, -1):\n        x = ab[column_num, -1] / ab[column_num, column_num]\n        x_lst.insert(0, x)\n        for i in range(column_num - 1, -1, -1):\n            ab[i, -1] -= ab[i, column_num] * x\n\n    # Return the solution vector\n    return np.asarray(x_lst)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n    from pathlib import Path\n\n    testmod()\n    file_path = Path(__file__).parent / \"matrix.txt\"\n    try:\n        matrix = np.loadtxt(file_path)\n    except FileNotFoundError:\n        print(f\"Error: {file_path} not found.  Using default matrix instead.\")\n\n    # Example usage:\n    print(f\"Matrix:\\n{matrix}\")\n    print(f\"{solve_linear_system(matrix) = }\")\n", "linear_algebra/src/gaussian_elimination_pivoting/__init__.py": "", "conversions/prefix_conversions_string.py": "\"\"\"\n* Author: Manuel Di Lullo (https://github.com/manueldilullo)\n* Description: Convert a number to use the correct SI or Binary unit prefix.\n\nInspired by prefix_conversion.py file in this repository by lance-pyles\n\nURL: https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes\nURL: https://en.wikipedia.org/wiki/Binary_prefix\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum, unique\nfrom typing import TypeVar\n\n# Create a generic variable that can be 'Enum', or any subclass.\nT = TypeVar(\"T\", bound=\"Enum\")\n\n\n@unique\nclass BinaryUnit(Enum):\n    yotta = 80\n    zetta = 70\n    exa = 60\n    peta = 50\n    tera = 40\n    giga = 30\n    mega = 20\n    kilo = 10\n\n\n@unique\nclass SIUnit(Enum):\n    yotta = 24\n    zetta = 21\n    exa = 18\n    peta = 15\n    tera = 12\n    giga = 9\n    mega = 6\n    kilo = 3\n    hecto = 2\n    deca = 1\n    deci = -1\n    centi = -2\n    milli = -3\n    micro = -6\n    nano = -9\n    pico = -12\n    femto = -15\n    atto = -18\n    zepto = -21\n    yocto = -24\n\n    @classmethod\n    def get_positive(cls: type[T]) -> dict:\n        \"\"\"\n        Returns a dictionary with only the elements of this enum\n        that has a positive value\n        >>> from itertools import islice\n        >>> positive = SIUnit.get_positive()\n        >>> inc = iter(positive.items())\n        >>> dict(islice(inc, len(positive) // 2))\n        {'yotta': 24, 'zetta': 21, 'exa': 18, 'peta': 15, 'tera': 12}\n        >>> dict(inc)\n        {'giga': 9, 'mega': 6, 'kilo': 3, 'hecto': 2, 'deca': 1}\n        \"\"\"\n        return {unit.name: unit.value for unit in cls if unit.value > 0}\n\n    @classmethod\n    def get_negative(cls: type[T]) -> dict:\n        \"\"\"\n        Returns a dictionary with only the elements of this enum\n        that has a negative value\n        @example\n        >>> from itertools import islice\n        >>> negative = SIUnit.get_negative()\n        >>> inc = iter(negative.items())\n        >>> dict(islice(inc, len(negative) // 2))\n        {'deci': -1, 'centi': -2, 'milli': -3, 'micro': -6, 'nano': -9}\n        >>> dict(inc)\n        {'pico': -12, 'femto': -15, 'atto': -18, 'zepto': -21, 'yocto': -24}\n        \"\"\"\n        return {unit.name: unit.value for unit in cls if unit.value < 0}\n\n\ndef add_si_prefix(value: float) -> str:\n    \"\"\"\n    Function that converts a number to his version with SI prefix\n    @input value (an integer)\n    @example:\n    >>> add_si_prefix(10000)\n    '10.0 kilo'\n    \"\"\"\n    prefixes = SIUnit.get_positive() if value > 0 else SIUnit.get_negative()\n    for name_prefix, value_prefix in prefixes.items():\n        numerical_part = value / (10**value_prefix)\n        if numerical_part > 1:\n            return f\"{numerical_part!s} {name_prefix}\"\n    return str(value)\n\n\ndef add_binary_prefix(value: float) -> str:\n    \"\"\"\n    Function that converts a number to his version with Binary prefix\n    @input value (an integer)\n    @example:\n    >>> add_binary_prefix(65536)\n    '64.0 kilo'\n    \"\"\"\n    for prefix in BinaryUnit:\n        numerical_part = value / (2**prefix.value)\n        if numerical_part > 1:\n            return f\"{numerical_part!s} {prefix.name}\"\n    return str(value)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/pressure_conversions.py": "\"\"\"\nConversion of pressure units.\nAvailable Units:- Pascal,Bar,Kilopascal,Megapascal,psi(pound per square inch),\ninHg(in mercury column),torr,atm\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function pressure_conversion() for conversion of pressure units.\n-> Parameters :\n    -> value : The number of from units you want to convert\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\nREFERENCES :\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pascal_(unit)\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pound_per_square_inch\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Inch_of_mercury\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Torr\n-> https://en.wikipedia.org/wiki/Standard_atmosphere_(unit)\n-> https://msestudent.com/what-are-the-units-of-pressure/\n-> https://www.unitconverters.net/pressure-converter.html\n\"\"\"\n\nfrom typing import NamedTuple\n\n\nclass FromTo(NamedTuple):\n    from_factor: float\n    to_factor: float\n\n\nPRESSURE_CONVERSION = {\n    \"atm\": FromTo(1, 1),\n    \"pascal\": FromTo(0.0000098, 101325),\n    \"bar\": FromTo(0.986923, 1.01325),\n    \"kilopascal\": FromTo(0.00986923, 101.325),\n    \"megapascal\": FromTo(9.86923, 0.101325),\n    \"psi\": FromTo(0.068046, 14.6959),\n    \"inHg\": FromTo(0.0334211, 29.9213),\n    \"torr\": FromTo(0.00131579, 760),\n}\n\n\ndef pressure_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between pressure units.\n    >>> pressure_conversion(4, \"atm\", \"pascal\")\n    405300\n    >>> pressure_conversion(1, \"pascal\", \"psi\")\n    0.00014401981999999998\n    >>> pressure_conversion(1, \"bar\", \"atm\")\n    0.986923\n    >>> pressure_conversion(3, \"kilopascal\", \"bar\")\n    0.029999991892499998\n    >>> pressure_conversion(2, \"megapascal\", \"psi\")\n    290.074434314\n    >>> pressure_conversion(4, \"psi\", \"torr\")\n    206.85984\n    >>> pressure_conversion(1, \"inHg\", \"atm\")\n    0.0334211\n    >>> pressure_conversion(1, \"torr\", \"psi\")\n    0.019336718261000002\n    >>> pressure_conversion(4, \"wrongUnit\", \"atm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr\n    \"\"\"\n    if from_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    if to_type not in PRESSURE_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(PRESSURE_CONVERSION)\n        )\n    return (\n        value\n        * PRESSURE_CONVERSION[from_type].from_factor\n        * PRESSURE_CONVERSION[to_type].to_factor\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/volume_conversions.py": "\"\"\"\nConversion of volume units.\nAvailable Units:- Cubic metre,Litre,KiloLitre,Gallon,Cubic yard,Cubic foot,cup\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function length_conversion() for conversion of volume units.\n-> Parameters :\n    -> value : The number of from units you want to convert\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\nREFERENCES :\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_metre\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Litre\n-> Wikipedia reference: https://en.wiktionary.org/wiki/kilolitre\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Gallon\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_yard\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cubic_foot\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Cup_(unit)\n\"\"\"\n\nfrom typing import NamedTuple\n\n\nclass FromTo(NamedTuple):\n    from_factor: float\n    to_factor: float\n\n\nMETRIC_CONVERSION = {\n    \"cubic meter\": FromTo(1, 1),\n    \"litre\": FromTo(0.001, 1000),\n    \"kilolitre\": FromTo(1, 1),\n    \"gallon\": FromTo(0.00454, 264.172),\n    \"cubic yard\": FromTo(0.76455, 1.30795),\n    \"cubic foot\": FromTo(0.028, 35.3147),\n    \"cup\": FromTo(0.000236588, 4226.75),\n}\n\n\ndef volume_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between volume units.\n    >>> volume_conversion(4, \"cubic meter\", \"litre\")\n    4000\n    >>> volume_conversion(1, \"litre\", \"gallon\")\n    0.264172\n    >>> volume_conversion(1, \"kilolitre\", \"cubic meter\")\n    1\n    >>> volume_conversion(3, \"gallon\", \"cubic yard\")\n    0.017814279\n    >>> volume_conversion(2, \"cubic yard\", \"litre\")\n    1529.1\n    >>> volume_conversion(4, \"cubic foot\", \"cup\")\n    473.396\n    >>> volume_conversion(1, \"cup\", \"kilolitre\")\n    0.000236588\n    >>> volume_conversion(4, \"wrongUnit\", \"litre\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:\n    cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup\n    \"\"\"\n    if from_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'from_type' value: {from_type!r}  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    if to_type not in METRIC_CONVERSION:\n        raise ValueError(\n            f\"Invalid 'to_type' value: {to_type!r}.  Supported values are:\\n\"\n            + \", \".join(METRIC_CONVERSION)\n        )\n    return (\n        value\n        * METRIC_CONVERSION[from_type].from_factor\n        * METRIC_CONVERSION[to_type].to_factor\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/ipv4_conversion.py": "# https://www.geeksforgeeks.org/convert-ip-address-to-integer-and-vice-versa/\n\n\ndef ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    Convert an IPv4 address to its decimal representation.\n\n    Args:\n        ip_address: A string representing an IPv4 address (e.g., \"192.168.0.1\").\n\n    Returns:\n        int: The decimal representation of the IP address.\n\n    >>> ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    >>> ipv4_to_decimal(\"10.0.255\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid IPv4 address format\n    >>> ipv4_to_decimal(\"10.0.0.256\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid IPv4 octet 256\n    \"\"\"\n\n    octets = [int(octet) for octet in ipv4_address.split(\".\")]\n    if len(octets) != 4:\n        raise ValueError(\"Invalid IPv4 address format\")\n\n    decimal_ipv4 = 0\n    for octet in octets:\n        if not 0 <= octet <= 255:\n            raise ValueError(f\"Invalid IPv4 octet {octet}\")  # noqa: EM102\n        decimal_ipv4 = (decimal_ipv4 << 8) + int(octet)\n\n    return decimal_ipv4\n\n\ndef alt_ipv4_to_decimal(ipv4_address: str) -> int:\n    \"\"\"\n    >>> alt_ipv4_to_decimal(\"192.168.0.1\")\n    3232235521\n    >>> alt_ipv4_to_decimal(\"10.0.0.255\")\n    167772415\n    \"\"\"\n    return int(\"0x\" + \"\".join(f\"{int(i):02x}\" for i in ipv4_address.split(\".\")), 16)\n\n\ndef decimal_to_ipv4(decimal_ipv4: int) -> str:\n    \"\"\"\n    Convert a decimal representation of an IP address to its IPv4 format.\n\n    Args:\n        decimal_ipv4: An integer representing the decimal IP address.\n\n    Returns:\n        The IPv4 representation of the decimal IP address.\n\n    >>> decimal_to_ipv4(3232235521)\n    '192.168.0.1'\n    >>> decimal_to_ipv4(167772415)\n    '10.0.0.255'\n    >>> decimal_to_ipv4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid decimal IPv4 address\n    \"\"\"\n\n    if not (0 <= decimal_ipv4 <= 4294967295):\n        raise ValueError(\"Invalid decimal IPv4 address\")\n\n    ip_parts = []\n    for _ in range(4):\n        ip_parts.append(str(decimal_ipv4 & 255))\n        decimal_ipv4 >>= 8\n\n    return \".\".join(reversed(ip_parts))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/decimal_to_hexadecimal.py": "\"\"\"Convert Base 10 (Decimal) Values to Hexadecimal Representations\"\"\"\n\n# set decimal value for each hexadecimal digit\nvalues = {\n    0: \"0\",\n    1: \"1\",\n    2: \"2\",\n    3: \"3\",\n    4: \"4\",\n    5: \"5\",\n    6: \"6\",\n    7: \"7\",\n    8: \"8\",\n    9: \"9\",\n    10: \"a\",\n    11: \"b\",\n    12: \"c\",\n    13: \"d\",\n    14: \"e\",\n    15: \"f\",\n}\n\n\ndef decimal_to_hexadecimal(decimal: float) -> str:\n    \"\"\"\n    take integer decimal value, return hexadecimal representation as str beginning\n    with 0x\n    >>> decimal_to_hexadecimal(5)\n    '0x5'\n    >>> decimal_to_hexadecimal(15)\n    '0xf'\n    >>> decimal_to_hexadecimal(37)\n    '0x25'\n    >>> decimal_to_hexadecimal(255)\n    '0xff'\n    >>> decimal_to_hexadecimal(4096)\n    '0x1000'\n    >>> decimal_to_hexadecimal(999098)\n    '0xf3eba'\n    >>> # negatives work too\n    >>> decimal_to_hexadecimal(-256)\n    '-0x100'\n    >>> # floats are acceptable if equivalent to an int\n    >>> decimal_to_hexadecimal(17.0)\n    '0x11'\n    >>> # other floats will error\n    >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # strings will error as well\n    >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    AssertionError\n    >>> # results are the same when compared to Python's default hex function\n    >>> decimal_to_hexadecimal(-256) == hex(-256)\n    True\n    \"\"\"\n    assert isinstance(decimal, (int, float))\n    assert decimal == int(decimal)\n    decimal = int(decimal)\n    hexadecimal = \"\"\n    negative = False\n    if decimal < 0:\n        negative = True\n        decimal *= -1\n    while decimal > 0:\n        decimal, remainder = divmod(decimal, 16)\n        hexadecimal = values[remainder] + hexadecimal\n    hexadecimal = \"0x\" + hexadecimal\n    if negative:\n        hexadecimal = \"-\" + hexadecimal\n    return hexadecimal\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/decimal_to_any.py": "\"\"\"Convert a positive Decimal Number to Any Other Representation\"\"\"\n\nfrom string import ascii_uppercase\n\nALPHABET_VALUES = {str(ord(c) - 55): c for c in ascii_uppercase}\n\n\ndef decimal_to_any(num: int, base: int) -> str:\n    \"\"\"\n    Convert a positive integer to another base as str.\n    >>> decimal_to_any(0, 2)\n    '0'\n    >>> decimal_to_any(5, 4)\n    '11'\n    >>> decimal_to_any(20, 3)\n    '202'\n    >>> decimal_to_any(58, 16)\n    '3A'\n    >>> decimal_to_any(243, 17)\n    'E5'\n    >>> decimal_to_any(34923, 36)\n    'QY3'\n    >>> decimal_to_any(10, 11)\n    'A'\n    >>> decimal_to_any(16, 16)\n    '10'\n    >>> decimal_to_any(36, 36)\n    '10'\n    >>> # negatives will error\n    >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: parameter must be positive int\n    >>> # floats will error\n    >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: int() can't convert non-string with explicit base\n    >>> # a float base will error\n    >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # a str base will error\n    >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    >>> # a base less than 2 will error\n    >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be >= 2\n    >>> # a base greater than 36 will error\n    >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: base must be <= 36\n    \"\"\"\n    if isinstance(num, float):\n        raise TypeError(\"int() can't convert non-string with explicit base\")\n    if num < 0:\n        raise ValueError(\"parameter must be positive int\")\n    if isinstance(base, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n    if isinstance(base, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if base in (0, 1):\n        raise ValueError(\"base must be >= 2\")\n    if base > 36:\n        raise ValueError(\"base must be <= 36\")\n    new_value = \"\"\n    mod = 0\n    div = 0\n    while div != 1:\n        div, mod = divmod(num, base)\n        if base >= 11 and 9 < mod < 36:\n            actual_value = ALPHABET_VALUES[str(mod)]\n        else:\n            actual_value = str(mod)\n        new_value += actual_value\n        div = num // base\n        num = div\n        if div == 0:\n            return str(new_value[::-1])\n        elif div == 1:\n            new_value += str(div)\n            return str(new_value[::-1])\n\n    return new_value[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    for base in range(2, 37):\n        for num in range(1000):\n            assert int(decimal_to_any(num, base), base) == num, (\n                num,\n                base,\n                decimal_to_any(num, base),\n                int(decimal_to_any(num, base), base),\n            )\n", "conversions/weight_conversion.py": "\"\"\"\nConversion of weight units.\n\n__author__ = \"Anubhav Solanki\"\n__license__ = \"MIT\"\n__version__ = \"1.1.0\"\n__maintainer__ = \"Anubhav Solanki\"\n__email__ = \"anubhavsolanki0@gmail.com\"\n\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function weight_conversion() for conversion of weight units.\n-> Parameters :\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\n    -> value : the value which you want to convert\n\nREFERENCES :\n\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilogram\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Gram\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Millimetre\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Tonne\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Long_ton\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Short_ton\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Pound\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Ounce\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Fineness#Karat\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Dalton_(unit)\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Stone_(unit)\n\"\"\"\n\nKILOGRAM_CHART: dict[str, float] = {\n    \"kilogram\": 1,\n    \"gram\": pow(10, 3),\n    \"milligram\": pow(10, 6),\n    \"metric-ton\": pow(10, -3),\n    \"long-ton\": 0.0009842073,\n    \"short-ton\": 0.0011023122,\n    \"pound\": 2.2046244202,\n    \"stone\": 0.1574731728,\n    \"ounce\": 35.273990723,\n    \"carrat\": 5000,\n    \"atomic-mass-unit\": 6.022136652e26,\n}\n\nWEIGHT_TYPE_CHART: dict[str, float] = {\n    \"kilogram\": 1,\n    \"gram\": pow(10, -3),\n    \"milligram\": pow(10, -6),\n    \"metric-ton\": pow(10, 3),\n    \"long-ton\": 1016.04608,\n    \"short-ton\": 907.184,\n    \"pound\": 0.453592,\n    \"stone\": 6.35029,\n    \"ounce\": 0.0283495,\n    \"carrat\": 0.0002,\n    \"atomic-mass-unit\": 1.660540199e-27,\n}\n\n\ndef weight_conversion(from_type: str, to_type: str, value: float) -> float:\n    \"\"\"\n    Conversion of weight unit with the help of KILOGRAM_CHART\n\n    \"kilogram\" : 1,\n    \"gram\" : pow(10, 3),\n    \"milligram\" : pow(10, 6),\n    \"metric-ton\" : pow(10, -3),\n    \"long-ton\" : 0.0009842073,\n    \"short-ton\" : 0.0011023122,\n    \"pound\" : 2.2046244202,\n    \"stone\": 0.1574731728,\n    \"ounce\" : 35.273990723,\n    \"carrat\" : 5000,\n    \"atomic-mass-unit\" : 6.022136652E+26\n\n    >>> weight_conversion(\"kilogram\",\"kilogram\",4)\n    4\n    >>> weight_conversion(\"kilogram\",\"gram\",1)\n    1000\n    >>> weight_conversion(\"kilogram\",\"milligram\",4)\n    4000000\n    >>> weight_conversion(\"kilogram\",\"metric-ton\",4)\n    0.004\n    >>> weight_conversion(\"kilogram\",\"long-ton\",3)\n    0.0029526219\n    >>> weight_conversion(\"kilogram\",\"short-ton\",1)\n    0.0011023122\n    >>> weight_conversion(\"kilogram\",\"pound\",4)\n    8.8184976808\n    >>> weight_conversion(\"kilogram\",\"stone\",5)\n    0.7873658640000001\n    >>> weight_conversion(\"kilogram\",\"ounce\",4)\n    141.095962892\n    >>> weight_conversion(\"kilogram\",\"carrat\",3)\n    15000\n    >>> weight_conversion(\"kilogram\",\"atomic-mass-unit\",1)\n    6.022136652e+26\n    >>> weight_conversion(\"gram\",\"kilogram\",1)\n    0.001\n    >>> weight_conversion(\"gram\",\"gram\",3)\n    3.0\n    >>> weight_conversion(\"gram\",\"milligram\",2)\n    2000.0\n    >>> weight_conversion(\"gram\",\"metric-ton\",4)\n    4e-06\n    >>> weight_conversion(\"gram\",\"long-ton\",3)\n    2.9526219e-06\n    >>> weight_conversion(\"gram\",\"short-ton\",3)\n    3.3069366000000003e-06\n    >>> weight_conversion(\"gram\",\"pound\",3)\n    0.0066138732606\n    >>> weight_conversion(\"gram\",\"stone\",4)\n    0.0006298926912000001\n    >>> weight_conversion(\"gram\",\"ounce\",1)\n    0.035273990723\n    >>> weight_conversion(\"gram\",\"carrat\",2)\n    10.0\n    >>> weight_conversion(\"gram\",\"atomic-mass-unit\",1)\n    6.022136652e+23\n    >>> weight_conversion(\"milligram\",\"kilogram\",1)\n    1e-06\n    >>> weight_conversion(\"milligram\",\"gram\",2)\n    0.002\n    >>> weight_conversion(\"milligram\",\"milligram\",3)\n    3.0\n    >>> weight_conversion(\"milligram\",\"metric-ton\",3)\n    3e-09\n    >>> weight_conversion(\"milligram\",\"long-ton\",3)\n    2.9526219e-09\n    >>> weight_conversion(\"milligram\",\"short-ton\",1)\n    1.1023122e-09\n    >>> weight_conversion(\"milligram\",\"pound\",3)\n    6.6138732605999995e-06\n    >>> weight_conversion(\"milligram\",\"ounce\",2)\n    7.054798144599999e-05\n    >>> weight_conversion(\"milligram\",\"carrat\",1)\n    0.005\n    >>> weight_conversion(\"milligram\",\"atomic-mass-unit\",1)\n    6.022136652e+20\n    >>> weight_conversion(\"metric-ton\",\"kilogram\",2)\n    2000\n    >>> weight_conversion(\"metric-ton\",\"gram\",2)\n    2000000\n    >>> weight_conversion(\"metric-ton\",\"milligram\",3)\n    3000000000\n    >>> weight_conversion(\"metric-ton\",\"metric-ton\",2)\n    2.0\n    >>> weight_conversion(\"metric-ton\",\"long-ton\",3)\n    2.9526219\n    >>> weight_conversion(\"metric-ton\",\"short-ton\",2)\n    2.2046244\n    >>> weight_conversion(\"metric-ton\",\"pound\",3)\n    6613.8732606\n    >>> weight_conversion(\"metric-ton\",\"ounce\",4)\n    141095.96289199998\n    >>> weight_conversion(\"metric-ton\",\"carrat\",4)\n    20000000\n    >>> weight_conversion(\"metric-ton\",\"atomic-mass-unit\",1)\n    6.022136652e+29\n    >>> weight_conversion(\"long-ton\",\"kilogram\",4)\n    4064.18432\n    >>> weight_conversion(\"long-ton\",\"gram\",4)\n    4064184.32\n    >>> weight_conversion(\"long-ton\",\"milligram\",3)\n    3048138240.0\n    >>> weight_conversion(\"long-ton\",\"metric-ton\",4)\n    4.06418432\n    >>> weight_conversion(\"long-ton\",\"long-ton\",3)\n    2.999999907217152\n    >>> weight_conversion(\"long-ton\",\"short-ton\",1)\n    1.119999989746176\n    >>> weight_conversion(\"long-ton\",\"pound\",3)\n    6720.000000049448\n    >>> weight_conversion(\"long-ton\",\"ounce\",1)\n    35840.000000060514\n    >>> weight_conversion(\"long-ton\",\"carrat\",4)\n    20320921.599999998\n    >>> weight_conversion(\"long-ton\",\"atomic-mass-unit\",4)\n    2.4475073353955697e+30\n    >>> weight_conversion(\"short-ton\",\"kilogram\",3)\n    2721.5519999999997\n    >>> weight_conversion(\"short-ton\",\"gram\",3)\n    2721552.0\n    >>> weight_conversion(\"short-ton\",\"milligram\",1)\n    907184000.0\n    >>> weight_conversion(\"short-ton\",\"metric-ton\",4)\n    3.628736\n    >>> weight_conversion(\"short-ton\",\"long-ton\",3)\n    2.6785713457296\n    >>> weight_conversion(\"short-ton\",\"short-ton\",3)\n    2.9999999725344\n    >>> weight_conversion(\"short-ton\",\"pound\",2)\n    4000.0000000294335\n    >>> weight_conversion(\"short-ton\",\"ounce\",4)\n    128000.00000021611\n    >>> weight_conversion(\"short-ton\",\"carrat\",4)\n    18143680.0\n    >>> weight_conversion(\"short-ton\",\"atomic-mass-unit\",1)\n    5.463186016507968e+29\n    >>> weight_conversion(\"pound\",\"kilogram\",4)\n    1.814368\n    >>> weight_conversion(\"pound\",\"gram\",2)\n    907.184\n    >>> weight_conversion(\"pound\",\"milligram\",3)\n    1360776.0\n    >>> weight_conversion(\"pound\",\"metric-ton\",3)\n    0.001360776\n    >>> weight_conversion(\"pound\",\"long-ton\",2)\n    0.0008928571152432\n    >>> weight_conversion(\"pound\",\"short-ton\",1)\n    0.0004999999954224\n    >>> weight_conversion(\"pound\",\"pound\",3)\n    3.0000000000220752\n    >>> weight_conversion(\"pound\",\"ounce\",1)\n    16.000000000027015\n    >>> weight_conversion(\"pound\",\"carrat\",1)\n    2267.96\n    >>> weight_conversion(\"pound\",\"atomic-mass-unit\",4)\n    1.0926372033015936e+27\n    >>> weight_conversion(\"stone\",\"kilogram\",5)\n    31.751450000000002\n    >>> weight_conversion(\"stone\",\"gram\",2)\n    12700.58\n    >>> weight_conversion(\"stone\",\"milligram\",3)\n    19050870.0\n    >>> weight_conversion(\"stone\",\"metric-ton\",3)\n    0.01905087\n    >>> weight_conversion(\"stone\",\"long-ton\",3)\n    0.018750005325351003\n    >>> weight_conversion(\"stone\",\"short-ton\",3)\n    0.021000006421614002\n    >>> weight_conversion(\"stone\",\"pound\",2)\n    28.00000881870372\n    >>> weight_conversion(\"stone\",\"ounce\",1)\n    224.00007054835967\n    >>> weight_conversion(\"stone\",\"carrat\",2)\n    63502.9\n    >>> weight_conversion(\"ounce\",\"kilogram\",3)\n    0.0850485\n    >>> weight_conversion(\"ounce\",\"gram\",3)\n    85.0485\n    >>> weight_conversion(\"ounce\",\"milligram\",4)\n    113398.0\n    >>> weight_conversion(\"ounce\",\"metric-ton\",4)\n    0.000113398\n    >>> weight_conversion(\"ounce\",\"long-ton\",4)\n    0.0001116071394054\n    >>> weight_conversion(\"ounce\",\"short-ton\",4)\n    0.0001249999988556\n    >>> weight_conversion(\"ounce\",\"pound\",1)\n    0.0625000000004599\n    >>> weight_conversion(\"ounce\",\"ounce\",2)\n    2.000000000003377\n    >>> weight_conversion(\"ounce\",\"carrat\",1)\n    141.7475\n    >>> weight_conversion(\"ounce\",\"atomic-mass-unit\",1)\n    1.70724563015874e+25\n    >>> weight_conversion(\"carrat\",\"kilogram\",1)\n    0.0002\n    >>> weight_conversion(\"carrat\",\"gram\",4)\n    0.8\n    >>> weight_conversion(\"carrat\",\"milligram\",2)\n    400.0\n    >>> weight_conversion(\"carrat\",\"metric-ton\",2)\n    4.0000000000000003e-07\n    >>> weight_conversion(\"carrat\",\"long-ton\",3)\n    5.9052438e-07\n    >>> weight_conversion(\"carrat\",\"short-ton\",4)\n    8.818497600000002e-07\n    >>> weight_conversion(\"carrat\",\"pound\",1)\n    0.00044092488404000004\n    >>> weight_conversion(\"carrat\",\"ounce\",2)\n    0.0141095962892\n    >>> weight_conversion(\"carrat\",\"carrat\",4)\n    4.0\n    >>> weight_conversion(\"carrat\",\"atomic-mass-unit\",4)\n    4.8177093216e+23\n    >>> weight_conversion(\"atomic-mass-unit\",\"kilogram\",4)\n    6.642160796e-27\n    >>> weight_conversion(\"atomic-mass-unit\",\"gram\",2)\n    3.321080398e-24\n    >>> weight_conversion(\"atomic-mass-unit\",\"milligram\",2)\n    3.3210803980000002e-21\n    >>> weight_conversion(\"atomic-mass-unit\",\"metric-ton\",3)\n    4.9816205970000004e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"long-ton\",3)\n    4.9029473573977584e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"short-ton\",1)\n    1.830433719948128e-30\n    >>> weight_conversion(\"atomic-mass-unit\",\"pound\",3)\n    1.0982602420317504e-26\n    >>> weight_conversion(\"atomic-mass-unit\",\"ounce\",2)\n    1.1714775914938915e-25\n    >>> weight_conversion(\"atomic-mass-unit\",\"carrat\",2)\n    1.660540199e-23\n    >>> weight_conversion(\"atomic-mass-unit\",\"atomic-mass-unit\",2)\n    1.999999998903455\n    \"\"\"\n    if to_type not in KILOGRAM_CHART or from_type not in WEIGHT_TYPE_CHART:\n        msg = (\n            f\"Invalid 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\\n\"\n            f\"Supported values are: {', '.join(WEIGHT_TYPE_CHART)}\"\n        )\n        raise ValueError(msg)\n    return value * KILOGRAM_CHART[to_type] * WEIGHT_TYPE_CHART[from_type]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/octal_to_decimal.py": "def oct_to_decimal(oct_string: str) -> int:\n    \"\"\"\n    Convert a octal value to its decimal equivalent\n\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-e\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"-8\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"1\")\n    1\n    >>> oct_to_decimal(\"-1\")\n    -1\n    >>> oct_to_decimal(\"12\")\n    10\n    >>> oct_to_decimal(\" 12   \")\n    10\n    >>> oct_to_decimal(\"-45\")\n    -37\n    >>> oct_to_decimal(\"-\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"0\")\n    0\n    >>> oct_to_decimal(\"-4055\")\n    -2093\n    >>> oct_to_decimal(\"2-0Fm\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> oct_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> oct_to_decimal(\"19\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    \"\"\"\n    oct_string = str(oct_string).strip()\n    if not oct_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = oct_string[0] == \"-\"\n    if is_negative:\n        oct_string = oct_string[1:]\n    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):\n        raise ValueError(\"Non-octal value was passed to the function\")\n    decimal_number = 0\n    for char in oct_string:\n        decimal_number = 8 * decimal_number + int(char)\n    if is_negative:\n        decimal_number = -decimal_number\n    return decimal_number\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/astronomical_length_scale_conversion.py": "\"\"\"\nConversion of length units.\nAvailable Units:\nMetre, Kilometre, Megametre, Gigametre,\nTerametre, Petametre, Exametre, Zettametre, Yottametre\n\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function length_conversion() for conversion of length units.\n-> Parameters :\n    -> value : The number of from units you want to convert\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\n\nREFERENCES :\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Meter\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilometer\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Orders_of_magnitude_(length)\n\"\"\"\n\nUNIT_SYMBOL = {\n    \"meter\": \"m\",\n    \"kilometer\": \"km\",\n    \"megametre\": \"Mm\",\n    \"gigametre\": \"Gm\",\n    \"terametre\": \"Tm\",\n    \"petametre\": \"Pm\",\n    \"exametre\": \"Em\",\n    \"zettametre\": \"Zm\",\n    \"yottametre\": \"Ym\",\n}\n# Exponent of the factor(meter)\nMETRIC_CONVERSION = {\n    \"m\": 0,\n    \"km\": 3,\n    \"Mm\": 6,\n    \"Gm\": 9,\n    \"Tm\": 12,\n    \"Pm\": 15,\n    \"Em\": 18,\n    \"Zm\": 21,\n    \"Ym\": 24,\n}\n\n\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between astronomical length units.\n\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"meter\", \"megametre\")\n    1e-06\n    >>> length_conversion(1, \"gigametre\", \"meter\")\n    1000000000\n    >>> length_conversion(1, \"gigametre\", \"terametre\")\n    0.001\n    >>> length_conversion(1, \"petametre\", \"terametre\")\n    1000\n    >>> length_conversion(1, \"petametre\", \"exametre\")\n    0.001\n    >>> length_conversion(1, \"terametre\", \"zettametre\")\n    1e-09\n    >>> length_conversion(1, \"yottametre\", \"zettametre\")\n    1000\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym\n    \"\"\"\n\n    from_sanitized = from_type.lower().strip(\"s\")\n    to_sanitized = to_type.lower().strip(\"s\")\n\n    from_sanitized = UNIT_SYMBOL.get(from_sanitized, from_sanitized)\n    to_sanitized = UNIT_SYMBOL.get(to_sanitized, to_sanitized)\n\n    if from_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if to_sanitized not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    from_exponent = METRIC_CONVERSION[from_sanitized]\n    to_exponent = METRIC_CONVERSION[to_sanitized]\n    exponent = 1\n\n    if from_exponent > to_exponent:\n        exponent = from_exponent - to_exponent\n    else:\n        exponent = -(to_exponent - from_exponent)\n\n    return value * pow(10, exponent)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/length_conversion.py": "\"\"\"\nConversion of length units.\nAvailable Units:- Metre,Kilometre,Feet,Inch,Centimeter,Yard,Foot,Mile,Millimeter\n\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function length_conversion() for conversion of length units.\n-> Parameters :\n    -> value : The number of from units you want to convert\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\n\nREFERENCES :\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Meter\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilometer\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Feet\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Inch\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Centimeter\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Yard\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Foot\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Mile\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Millimeter\n\"\"\"\n\nfrom typing import NamedTuple\n\n\nclass FromTo(NamedTuple):\n    from_factor: float\n    to_factor: float\n\n\nTYPE_CONVERSION = {\n    \"millimeter\": \"mm\",\n    \"centimeter\": \"cm\",\n    \"meter\": \"m\",\n    \"kilometer\": \"km\",\n    \"inch\": \"in\",\n    \"inche\": \"in\",  # Trailing 's' has been stripped off\n    \"feet\": \"ft\",\n    \"foot\": \"ft\",\n    \"yard\": \"yd\",\n    \"mile\": \"mi\",\n}\n\nMETRIC_CONVERSION = {\n    \"mm\": FromTo(0.001, 1000),\n    \"cm\": FromTo(0.01, 100),\n    \"m\": FromTo(1, 1),\n    \"km\": FromTo(1000, 0.001),\n    \"in\": FromTo(0.0254, 39.3701),\n    \"ft\": FromTo(0.3048, 3.28084),\n    \"yd\": FromTo(0.9144, 1.09361),\n    \"mi\": FromTo(1609.34, 0.000621371),\n}\n\n\ndef length_conversion(value: float, from_type: str, to_type: str) -> float:\n    \"\"\"\n    Conversion between length units.\n\n    >>> length_conversion(4, \"METER\", \"FEET\")\n    13.12336\n    >>> length_conversion(4, \"M\", \"FT\")\n    13.12336\n    >>> length_conversion(1, \"meter\", \"kilometer\")\n    0.001\n    >>> length_conversion(1, \"kilometer\", \"inch\")\n    39370.1\n    >>> length_conversion(3, \"kilometer\", \"mile\")\n    1.8641130000000001\n    >>> length_conversion(2, \"feet\", \"meter\")\n    0.6096\n    >>> length_conversion(4, \"feet\", \"yard\")\n    1.333329312\n    >>> length_conversion(1, \"inch\", \"meter\")\n    0.0254\n    >>> length_conversion(2, \"inch\", \"mile\")\n    3.15656468e-05\n    >>> length_conversion(2, \"centimeter\", \"millimeter\")\n    20.0\n    >>> length_conversion(2, \"centimeter\", \"yard\")\n    0.0218722\n    >>> length_conversion(4, \"yard\", \"meter\")\n    3.6576\n    >>> length_conversion(4, \"yard\", \"kilometer\")\n    0.0036576\n    >>> length_conversion(3, \"foot\", \"meter\")\n    0.9144000000000001\n    >>> length_conversion(3, \"foot\", \"inch\")\n    36.00001944\n    >>> length_conversion(4, \"mile\", \"kilometer\")\n    6.43736\n    >>> length_conversion(2, \"miles\", \"InChEs\")\n    126719.753468\n    >>> length_conversion(3, \"millimeter\", \"centimeter\")\n    0.3\n    >>> length_conversion(3, \"mm\", \"in\")\n    0.1181103\n    >>> length_conversion(4, \"wrongUnit\", \"inch\")\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid 'from_type' value: 'wrongUnit'.\n    Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi\n    \"\"\"\n    new_from = from_type.lower().rstrip(\"s\")\n    new_from = TYPE_CONVERSION.get(new_from, new_from)\n    new_to = to_type.lower().rstrip(\"s\")\n    new_to = TYPE_CONVERSION.get(new_to, new_to)\n    if new_from not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'from_type' value: {from_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    if new_to not in METRIC_CONVERSION:\n        msg = (\n            f\"Invalid 'to_type' value: {to_type!r}.\\n\"\n            f\"Conversion abbreviations are: {', '.join(METRIC_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return (\n        value\n        * METRIC_CONVERSION[new_from].from_factor\n        * METRIC_CONVERSION[new_to].to_factor\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/decimal_to_binary.py": "\"\"\"Convert a Decimal Number to a Binary Number.\"\"\"\n\n\ndef decimal_to_binary_iterative(num: int) -> str:\n    \"\"\"\n    Convert an Integer Decimal Number to a Binary Number as str.\n    >>> decimal_to_binary_iterative(0)\n    '0b0'\n    >>> decimal_to_binary_iterative(2)\n    '0b10'\n    >>> decimal_to_binary_iterative(7)\n    '0b111'\n    >>> decimal_to_binary_iterative(35)\n    '0b100011'\n    >>> # negatives work too\n    >>> decimal_to_binary_iterative(-2)\n    '-0b10'\n    >>> # other floats will error\n    >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'float' object cannot be interpreted as an integer\n    >>> # strings will error as well\n    >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: 'str' object cannot be interpreted as an integer\n    \"\"\"\n\n    if isinstance(num, float):\n        raise TypeError(\"'float' object cannot be interpreted as an integer\")\n    if isinstance(num, str):\n        raise TypeError(\"'str' object cannot be interpreted as an integer\")\n\n    if num == 0:\n        return \"0b0\"\n\n    negative = False\n\n    if num < 0:\n        negative = True\n        num = -num\n\n    binary: list[int] = []\n    while num > 0:\n        binary.insert(0, num % 2)\n        num >>= 1\n\n    if negative:\n        return \"-0b\" + \"\".join(str(e) for e in binary)\n\n    return \"0b\" + \"\".join(str(e) for e in binary)\n\n\ndef decimal_to_binary_recursive_helper(decimal: int) -> str:\n    \"\"\"\n    Take a positive integer value and return its binary equivalent.\n    >>> decimal_to_binary_recursive_helper(1000)\n    '1111101000'\n    >>> decimal_to_binary_recursive_helper(\"72\")\n    '1001000'\n    >>> decimal_to_binary_recursive_helper(\"number\")\n    Traceback (most recent call last):\n        ...\n    ValueError: invalid literal for int() with base 10: 'number'\n    \"\"\"\n    decimal = int(decimal)\n    if decimal in (0, 1):  # Exit cases for the recursion\n        return str(decimal)\n    div, mod = divmod(decimal, 2)\n    return decimal_to_binary_recursive_helper(div) + str(mod)\n\n\ndef decimal_to_binary_recursive(number: str) -> str:\n    \"\"\"\n    Take an integer value and raise ValueError for wrong inputs,\n    call the function above and return the output with prefix \"0b\" & \"-0b\"\n    for positive and negative integers respectively.\n    >>> decimal_to_binary_recursive(0)\n    '0b0'\n    >>> decimal_to_binary_recursive(40)\n    '0b101000'\n    >>> decimal_to_binary_recursive(-40)\n    '-0b101000'\n    >>> decimal_to_binary_recursive(40.8)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value is not an integer\n    >>> decimal_to_binary_recursive(\"forty\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input value is not an integer\n    \"\"\"\n    number = str(number).strip()\n    if not number:\n        raise ValueError(\"No input value was provided\")\n    negative = \"-\" if number.startswith(\"-\") else \"\"\n    number = number.lstrip(\"-\")\n    if not number.isnumeric():\n        raise ValueError(\"Input value is not an integer\")\n    return f\"{negative}0b{decimal_to_binary_recursive_helper(int(number))}\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(decimal_to_binary_recursive(input(\"Input a decimal number: \")))\n", "conversions/speed_conversions.py": "\"\"\"\nConvert speed units\n\nhttps://en.wikipedia.org/wiki/Kilometres_per_hour\nhttps://en.wikipedia.org/wiki/Miles_per_hour\nhttps://en.wikipedia.org/wiki/Knot_(unit)\nhttps://en.wikipedia.org/wiki/Metre_per_second\n\"\"\"\n\nspeed_chart: dict[str, float] = {\n    \"km/h\": 1.0,\n    \"m/s\": 3.6,\n    \"mph\": 1.609344,\n    \"knot\": 1.852,\n}\n\nspeed_chart_inverse: dict[str, float] = {\n    \"km/h\": 1.0,\n    \"m/s\": 0.277777778,\n    \"mph\": 0.621371192,\n    \"knot\": 0.539956803,\n}\n\n\ndef convert_speed(speed: float, unit_from: str, unit_to: str) -> float:\n    \"\"\"\n    Convert speed from one unit to another using the speed_chart above.\n\n    \"km/h\": 1.0,\n    \"m/s\": 3.6,\n    \"mph\": 1.609344,\n    \"knot\": 1.852,\n\n    >>> convert_speed(100, \"km/h\", \"m/s\")\n    27.778\n    >>> convert_speed(100, \"km/h\", \"mph\")\n    62.137\n    >>> convert_speed(100, \"km/h\", \"knot\")\n    53.996\n    >>> convert_speed(100, \"m/s\", \"km/h\")\n    360.0\n    >>> convert_speed(100, \"m/s\", \"mph\")\n    223.694\n    >>> convert_speed(100, \"m/s\", \"knot\")\n    194.384\n    >>> convert_speed(100, \"mph\", \"km/h\")\n    160.934\n    >>> convert_speed(100, \"mph\", \"m/s\")\n    44.704\n    >>> convert_speed(100, \"mph\", \"knot\")\n    86.898\n    >>> convert_speed(100, \"knot\", \"km/h\")\n    185.2\n    >>> convert_speed(100, \"knot\", \"m/s\")\n    51.444\n    >>> convert_speed(100, \"knot\", \"mph\")\n    115.078\n    \"\"\"\n    if unit_to not in speed_chart or unit_from not in speed_chart_inverse:\n        msg = (\n            f\"Incorrect 'from_type' or 'to_type' value: {unit_from!r}, {unit_to!r}\\n\"\n            f\"Valid values are: {', '.join(speed_chart_inverse)}\"\n        )\n        raise ValueError(msg)\n    return round(speed * speed_chart[unit_from] * speed_chart_inverse[unit_to], 3)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/hex_to_bin.py": "def hex_to_bin(hex_num: str) -> int:\n    \"\"\"\n    Convert a hexadecimal value to its binary equivalent\n    #https://stackoverflow.com/questions/1425493/convert-hex-to-binary\n    Here, we have used the bitwise right shift operator: >>\n    Shifts the bits of the number to the right and fills 0 on voids left as a result.\n    Similar effect as of dividing the number with some power of two.\n    Example:\n    a = 10\n    a >> 1 = 5\n\n    >>> hex_to_bin(\"AC\")\n    10101100\n    >>> hex_to_bin(\"9A4\")\n    100110100100\n    >>> hex_to_bin(\"   12f   \")\n    100101111\n    >>> hex_to_bin(\"FfFf\")\n    1111111111111111\n    >>> hex_to_bin(\"-fFfF\")\n    -1111111111111111\n    >>> hex_to_bin(\"F-f\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid value was passed to the function\n    >>> hex_to_bin(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: No value was passed to the function\n    \"\"\"\n\n    hex_num = hex_num.strip()\n    if not hex_num:\n        raise ValueError(\"No value was passed to the function\")\n\n    is_negative = hex_num[0] == \"-\"\n    if is_negative:\n        hex_num = hex_num[1:]\n\n    try:\n        int_num = int(hex_num, 16)\n    except ValueError:\n        raise ValueError(\"Invalid value was passed to the function\")\n\n    bin_str = \"\"\n    while int_num > 0:\n        bin_str = str(int_num % 2) + bin_str\n        int_num >>= 1\n\n    return int((\"-\" + bin_str) if is_negative else bin_str)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/energy_conversions.py": "\"\"\"\nConversion of energy units.\n\nAvailable units: joule, kilojoule, megajoule, gigajoule,\\\n      wattsecond, watthour, kilowatthour, newtonmeter, calorie_nutr,\\\n          kilocalorie_nutr, electronvolt, britishthermalunit_it, footpound\n\nUSAGE :\n-> Import this file into their respective project.\n-> Use the function energy_conversion() for conversion of energy units.\n-> Parameters :\n    -> from_type : From which type you want to convert\n    -> to_type : To which type you want to convert\n    -> value : the value which you want to convert\n\nREFERENCES :\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Units_of_energy\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Joule\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Kilowatt-hour\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Newton-metre\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Calorie\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Electronvolt\n-> Wikipedia reference: https://en.wikipedia.org/wiki/British_thermal_unit\n-> Wikipedia reference: https://en.wikipedia.org/wiki/Foot-pound_(energy)\n-> Unit converter reference: https://www.unitconverters.net/energy-converter.html\n\"\"\"\n\nENERGY_CONVERSION: dict[str, float] = {\n    \"joule\": 1.0,\n    \"kilojoule\": 1_000,\n    \"megajoule\": 1_000_000,\n    \"gigajoule\": 1_000_000_000,\n    \"wattsecond\": 1.0,\n    \"watthour\": 3_600,\n    \"kilowatthour\": 3_600_000,\n    \"newtonmeter\": 1.0,\n    \"calorie_nutr\": 4_186.8,\n    \"kilocalorie_nutr\": 4_186_800.00,\n    \"electronvolt\": 1.602_176_634e-19,\n    \"britishthermalunit_it\": 1_055.055_85,\n    \"footpound\": 1.355_818,\n}\n\n\ndef energy_conversion(from_type: str, to_type: str, value: float) -> float:\n    \"\"\"\n    Conversion of energy units.\n    >>> energy_conversion(\"joule\", \"joule\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"kilojoule\", 1)\n    0.001\n    >>> energy_conversion(\"joule\", \"megajoule\", 1)\n    1e-06\n    >>> energy_conversion(\"joule\", \"gigajoule\", 1)\n    1e-09\n    >>> energy_conversion(\"joule\", \"wattsecond\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"watthour\", 1)\n    0.0002777777777777778\n    >>> energy_conversion(\"joule\", \"kilowatthour\", 1)\n    2.7777777777777776e-07\n    >>> energy_conversion(\"joule\", \"newtonmeter\", 1)\n    1.0\n    >>> energy_conversion(\"joule\", \"calorie_nutr\", 1)\n    0.00023884589662749592\n    >>> energy_conversion(\"joule\", \"kilocalorie_nutr\", 1)\n    2.388458966274959e-07\n    >>> energy_conversion(\"joule\", \"electronvolt\", 1)\n    6.241509074460763e+18\n    >>> energy_conversion(\"joule\", \"britishthermalunit_it\", 1)\n    0.0009478171226670134\n    >>> energy_conversion(\"joule\", \"footpound\", 1)\n    0.7375621211696556\n    >>> energy_conversion(\"joule\", \"megajoule\", 1000)\n    0.001\n    >>> energy_conversion(\"calorie_nutr\", \"kilocalorie_nutr\", 1000)\n    1.0\n    >>> energy_conversion(\"kilowatthour\", \"joule\", 10)\n    36000000.0\n    >>> energy_conversion(\"britishthermalunit_it\", \"footpound\", 1)\n    778.1692306784539\n    >>> energy_conversion(\"watthour\", \"joule\", \"a\") # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    TypeError: unsupported operand type(s) for /: 'str' and 'float'\n    >>> energy_conversion(\"wrongunit\", \"joule\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule'\n    Valid values are: joule, ... footpound\n    >>> energy_conversion(\"joule\", \"wrongunit\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit'\n    Valid values are: joule, ... footpound\n    >>> energy_conversion(\"123\", \"abc\", 1) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    ValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc'\n    Valid values are: joule, ... footpound\n    \"\"\"\n    if to_type not in ENERGY_CONVERSION or from_type not in ENERGY_CONVERSION:\n        msg = (\n            f\"Incorrect 'from_type' or 'to_type' value: {from_type!r}, {to_type!r}\\n\"\n            f\"Valid values are: {', '.join(ENERGY_CONVERSION)}\"\n        )\n        raise ValueError(msg)\n    return value * ENERGY_CONVERSION[from_type] / ENERGY_CONVERSION[to_type]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/octal_to_binary.py": "\"\"\"\n* Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n* Description: Convert a Octal number to Binary.\n\nReferences for better understanding:\nhttps://en.wikipedia.org/wiki/Binary_number\nhttps://en.wikipedia.org/wiki/Octal\n\"\"\"\n\n\ndef octal_to_binary(octal_number: str) -> str:\n    \"\"\"\n    Convert an Octal number to Binary.\n\n    >>> octal_to_binary(\"17\")\n    '001111'\n    >>> octal_to_binary(\"7\")\n    '111'\n    >>> octal_to_binary(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"@#\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-octal value was passed to the function\n    >>> octal_to_binary(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    if not octal_number:\n        raise ValueError(\"Empty string was passed to the function\")\n\n    binary_number = \"\"\n    octal_digits = \"01234567\"\n    for digit in octal_number:\n        if digit not in octal_digits:\n            raise ValueError(\"Non-octal value was passed to the function\")\n\n        binary_digit = \"\"\n        value = int(digit)\n        for _ in range(3):\n            binary_digit = str(value % 2) + binary_digit\n            value //= 2\n        binary_number += binary_digit\n\n    return binary_number\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/prefix_conversions.py": "\"\"\"\nConvert International System of Units (SI) and Binary prefixes\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass SIUnit(Enum):\n    yotta = 24\n    zetta = 21\n    exa = 18\n    peta = 15\n    tera = 12\n    giga = 9\n    mega = 6\n    kilo = 3\n    hecto = 2\n    deca = 1\n    deci = -1\n    centi = -2\n    milli = -3\n    micro = -6\n    nano = -9\n    pico = -12\n    femto = -15\n    atto = -18\n    zepto = -21\n    yocto = -24\n\n\nclass BinaryUnit(Enum):\n    yotta = 8\n    zetta = 7\n    exa = 6\n    peta = 5\n    tera = 4\n    giga = 3\n    mega = 2\n    kilo = 1\n\n\ndef convert_si_prefix(\n    known_amount: float,\n    known_prefix: str | SIUnit,\n    unknown_prefix: str | SIUnit,\n) -> float:\n    \"\"\"\n    Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix\n    Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units\n    >>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega)\n    1000\n    >>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga)\n    0.001\n    >>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo)\n    1\n    >>> convert_si_prefix(1, 'giga', 'mega')\n    1000\n    >>> convert_si_prefix(1, 'gIGa', 'mEGa')\n    1000\n    \"\"\"\n    if isinstance(known_prefix, str):\n        known_prefix = SIUnit[known_prefix.lower()]\n    if isinstance(unknown_prefix, str):\n        unknown_prefix = SIUnit[unknown_prefix.lower()]\n    unknown_amount: float = known_amount * (\n        10 ** (known_prefix.value - unknown_prefix.value)\n    )\n    return unknown_amount\n\n\ndef convert_binary_prefix(\n    known_amount: float,\n    known_prefix: str | BinaryUnit,\n    unknown_prefix: str | BinaryUnit,\n) -> float:\n    \"\"\"\n    Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix\n    >>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega)\n    1024\n    >>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga)\n    0.0009765625\n    >>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo)\n    1\n    >>> convert_binary_prefix(1, 'giga', 'mega')\n    1024\n    >>> convert_binary_prefix(1, 'gIGa', 'mEGa')\n    1024\n    \"\"\"\n    if isinstance(known_prefix, str):\n        known_prefix = BinaryUnit[known_prefix.lower()]\n    if isinstance(unknown_prefix, str):\n        unknown_prefix = BinaryUnit[unknown_prefix.lower()]\n    unknown_amount: float = known_amount * (\n        2 ** ((known_prefix.value - unknown_prefix.value) * 10)\n    )\n    return unknown_amount\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/molecular_chemistry.py": "\"\"\"\nFunctions useful for doing molecular chemistry:\n* molarity_to_normality\n* moles_to_pressure\n* moles_to_volume\n* pressure_and_volume_to_temperature\n\"\"\"\n\n\ndef molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:\n    \"\"\"\n    Convert molarity to normality.\n      Volume is taken in litres.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration\n      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration\n\n      >>> molarity_to_normality(2, 3.1, 0.31)\n      20\n      >>> molarity_to_normality(4, 11.4, 5.7)\n      8\n    \"\"\"\n    return round(float(moles / volume) * nfactor)\n\n\ndef moles_to_pressure(volume: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to pressure.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_pressure(0.82, 3, 300)\n      90\n      >>> moles_to_pressure(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (volume)))\n\n\ndef moles_to_volume(pressure: float, moles: float, temperature: float) -> float:\n    \"\"\"\n    Convert moles to volume.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> moles_to_volume(0.82, 3, 300)\n      90\n      >>> moles_to_volume(8.2, 5, 200)\n      10\n    \"\"\"\n    return round(float((moles * 0.0821 * temperature) / (pressure)))\n\n\ndef pressure_and_volume_to_temperature(\n    pressure: float, moles: float, volume: float\n) -> float:\n    \"\"\"\n    Convert pressure and volume to temperature.\n      Ideal gas laws are used.\n      Temperature is taken in kelvin.\n      Volume is taken in litres.\n      Pressure has atm as SI unit.\n\n      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws\n      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure\n      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature\n\n      >>> pressure_and_volume_to_temperature(0.82, 1, 2)\n      20\n      >>> pressure_and_volume_to_temperature(8.2, 5, 3)\n      60\n    \"\"\"\n    return round(float((pressure * volume) / (0.0821 * moles)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/excel_title_to_column.py": "def excel_title_to_column(column_title: str) -> int:\n    \"\"\"\n    Given a string column_title that represents\n    the column title in an Excel sheet, return\n    its corresponding column number.\n\n    >>> excel_title_to_column(\"A\")\n    1\n    >>> excel_title_to_column(\"B\")\n    2\n    >>> excel_title_to_column(\"AB\")\n    28\n    >>> excel_title_to_column(\"Z\")\n    26\n    \"\"\"\n    assert column_title.isupper()\n    answer = 0\n    index = len(column_title) - 1\n    power = 0\n\n    while index >= 0:\n        value = (ord(column_title[index]) - 64) * pow(26, power)\n        answer += value\n        power += 1\n        index -= 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/binary_to_decimal.py": "def bin_to_decimal(bin_string: str) -> int:\n    \"\"\"\n    Convert a binary value to its decimal equivalent\n\n    >>> bin_to_decimal(\"101\")\n    5\n    >>> bin_to_decimal(\" 1010   \")\n    10\n    >>> bin_to_decimal(\"-11101\")\n    -29\n    >>> bin_to_decimal(\"0\")\n    0\n    >>> bin_to_decimal(\"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> bin_to_decimal(\"39\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    \"\"\"\n    bin_string = str(bin_string).strip()\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = bin_string[0] == \"-\"\n    if is_negative:\n        bin_string = bin_string[1:]\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    decimal_number = 0\n    for char in bin_string:\n        decimal_number = 2 * decimal_number + int(char)\n    return -decimal_number if is_negative else decimal_number\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/convert_number_to_words.py": "from enum import Enum\nfrom typing import ClassVar, Literal\n\n\nclass NumberingSystem(Enum):\n    SHORT = (\n        (15, \"quadrillion\"),\n        (12, \"trillion\"),\n        (9, \"billion\"),\n        (6, \"million\"),\n        (3, \"thousand\"),\n        (2, \"hundred\"),\n    )\n\n    LONG = (\n        (15, \"billiard\"),\n        (9, \"milliard\"),\n        (6, \"million\"),\n        (3, \"thousand\"),\n        (2, \"hundred\"),\n    )\n\n    INDIAN = (\n        (14, \"crore crore\"),\n        (12, \"lakh crore\"),\n        (7, \"crore\"),\n        (5, \"lakh\"),\n        (3, \"thousand\"),\n        (2, \"hundred\"),\n    )\n\n    @classmethod\n    def max_value(cls, system: str) -> int:\n        \"\"\"\n        Gets the max value supported by the given number system.\n\n        >>> NumberingSystem.max_value(\"short\") == 10**18 - 1\n        True\n        >>> NumberingSystem.max_value(\"long\") == 10**21 - 1\n        True\n        >>> NumberingSystem.max_value(\"indian\") == 10**19 - 1\n        True\n        \"\"\"\n        match system_enum := cls[system.upper()]:\n            case cls.SHORT:\n                max_exp = system_enum.value[0][0] + 3\n            case cls.LONG:\n                max_exp = system_enum.value[0][0] + 6\n            case cls.INDIAN:\n                max_exp = 19\n            case _:\n                raise ValueError(\"Invalid numbering system\")\n        return 10**max_exp - 1\n\n\nclass NumberWords(Enum):\n    ONES: ClassVar[dict[int, str]] = {\n        0: \"\",\n        1: \"one\",\n        2: \"two\",\n        3: \"three\",\n        4: \"four\",\n        5: \"five\",\n        6: \"six\",\n        7: \"seven\",\n        8: \"eight\",\n        9: \"nine\",\n    }\n\n    TEENS: ClassVar[dict[int, str]] = {\n        0: \"ten\",\n        1: \"eleven\",\n        2: \"twelve\",\n        3: \"thirteen\",\n        4: \"fourteen\",\n        5: \"fifteen\",\n        6: \"sixteen\",\n        7: \"seventeen\",\n        8: \"eighteen\",\n        9: \"nineteen\",\n    }\n\n    TENS: ClassVar[dict[int, str]] = {\n        2: \"twenty\",\n        3: \"thirty\",\n        4: \"forty\",\n        5: \"fifty\",\n        6: \"sixty\",\n        7: \"seventy\",\n        8: \"eighty\",\n        9: \"ninety\",\n    }\n\n\ndef convert_small_number(num: int) -> str:\n    \"\"\"\n    Converts small, non-negative integers with irregular constructions in English (i.e.,\n    numbers under 100) into words.\n\n    >>> convert_small_number(0)\n    'zero'\n    >>> convert_small_number(5)\n    'five'\n    >>> convert_small_number(10)\n    'ten'\n    >>> convert_small_number(15)\n    'fifteen'\n    >>> convert_small_number(20)\n    'twenty'\n    >>> convert_small_number(25)\n    'twenty-five'\n    >>> convert_small_number(-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only accepts non-negative integers\n    >>> convert_small_number(123)\n    Traceback (most recent call last):\n    ...\n    ValueError: This function only converts numbers less than 100\n    \"\"\"\n    if num < 0:\n        raise ValueError(\"This function only accepts non-negative integers\")\n    if num >= 100:\n        raise ValueError(\"This function only converts numbers less than 100\")\n    tens, ones = divmod(num, 10)\n    if tens == 0:\n        return NumberWords.ONES.value[ones] or \"zero\"\n    if tens == 1:\n        return NumberWords.TEENS.value[ones]\n    return (\n        NumberWords.TENS.value[tens]\n        + (\"-\" if NumberWords.ONES.value[ones] else \"\")\n        + NumberWords.ONES.value[ones]\n    )\n\n\ndef convert_number(\n    num: int, system: Literal[\"short\", \"long\", \"indian\"] = \"short\"\n) -> str:\n    \"\"\"\n    Converts an integer to English words.\n\n    :param num: The integer to be converted\n    :param system: The numbering system (short, long, or Indian)\n\n    >>> convert_number(0)\n    'zero'\n    >>> convert_number(1)\n    'one'\n    >>> convert_number(100)\n    'one hundred'\n    >>> convert_number(-100)\n    'negative one hundred'\n    >>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE\n    'one hundred twenty-three trillion four hundred fifty-six billion\n    seven hundred eighty-nine million twelve thousand three hundred forty-five'\n    >>> convert_number(123_456_789_012_345, \"long\") # doctest: +NORMALIZE_WHITESPACE\n    'one hundred twenty-three thousand four hundred fifty-six milliard\n    seven hundred eighty-nine million twelve thousand three hundred forty-five'\n    >>> convert_number(12_34_56_78_90_12_345, \"indian\") # doctest: +NORMALIZE_WHITESPACE\n    'one crore crore twenty-three lakh crore\n    forty-five thousand six hundred seventy-eight crore\n    ninety lakh twelve thousand three hundred forty-five'\n    >>> convert_number(10**18)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    >>> convert_number(10**21, \"long\")\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    >>> convert_number(10**19, \"indian\")\n    Traceback (most recent call last):\n    ...\n    ValueError: Input number is too large\n    \"\"\"\n    word_groups = []\n\n    if num < 0:\n        word_groups.append(\"negative\")\n        num *= -1\n\n    if num > NumberingSystem.max_value(system):\n        raise ValueError(\"Input number is too large\")\n\n    for power, unit in NumberingSystem[system.upper()].value:\n        digit_group, num = divmod(num, 10**power)\n        if digit_group > 0:\n            word_group = (\n                convert_number(digit_group, system)\n                if digit_group >= 100\n                else convert_small_number(digit_group)\n            )\n            word_groups.append(f\"{word_group} {unit}\")\n    if num > 0 or not word_groups:  # word_groups is only empty if input num was 0\n        word_groups.append(convert_small_number(num))\n    return \" \".join(word_groups)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    print(f\"{convert_number(123456789) = }\")\n", "conversions/rgb_cmyk_conversion.py": "def rgb_to_cmyk(r_input: int, g_input: int, b_input: int) -> tuple[int, int, int, int]:\n    \"\"\"\n    Simple RGB to CMYK conversion. Returns percentages of CMYK paint.\n    https://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/\n\n    Note: this is a very popular algorithm that converts colors linearly and gives\n    only approximate results. Actual preparation for printing requires advanced color\n    conversion considering the color profiles and parameters of the target device.\n\n    >>> rgb_to_cmyk(255, 200, \"a\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)\n\n    >>> rgb_to_cmyk(255, 255, 999)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected int of the range 0..255\n\n    >>> rgb_to_cmyk(255, 255, 255)  # white\n    (0, 0, 0, 0)\n\n    >>> rgb_to_cmyk(128, 128, 128)  # gray\n    (0, 0, 0, 50)\n\n    >>> rgb_to_cmyk(0, 0, 0)    # black\n    (0, 0, 0, 100)\n\n    >>> rgb_to_cmyk(255, 0, 0)  # red\n    (0, 100, 100, 0)\n\n    >>> rgb_to_cmyk(0, 255, 0)  # green\n    (100, 0, 100, 0)\n\n    >>> rgb_to_cmyk(0, 0, 255)    # blue\n    (100, 100, 0, 0)\n    \"\"\"\n\n    if (\n        not isinstance(r_input, int)\n        or not isinstance(g_input, int)\n        or not isinstance(b_input, int)\n    ):\n        msg = f\"Expected int, found {type(r_input), type(g_input), type(b_input)}\"\n        raise ValueError(msg)\n\n    if not 0 <= r_input < 256 or not 0 <= g_input < 256 or not 0 <= b_input < 256:\n        raise ValueError(\"Expected int of the range 0..255\")\n\n    # changing range from 0..255 to 0..1\n    r = r_input / 255\n    g = g_input / 255\n    b = b_input / 255\n\n    k = 1 - max(r, g, b)\n\n    if k == 1:  # pure black\n        return 0, 0, 0, 100\n\n    c = round(100 * (1 - r - k) / (1 - k))\n    m = round(100 * (1 - g - k) / (1 - k))\n    y = round(100 * (1 - b - k) / (1 - k))\n    k = round(100 * k)\n\n    return c, m, y, k\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/octal_to_hexadecimal.py": "def octal_to_hex(octal: str) -> str:\n    \"\"\"\n    Convert an Octal number to Hexadecimal number.\n    For more information: https://en.wikipedia.org/wiki/Octal\n\n    >>> octal_to_hex(\"100\")\n    '0x40'\n    >>> octal_to_hex(\"235\")\n    '0x9D'\n    >>> octal_to_hex(17)\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected a string as input\n    >>> octal_to_hex(\"Av\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Not a Valid Octal Number\n    >>> octal_to_hex(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n\n    if not isinstance(octal, str):\n        raise TypeError(\"Expected a string as input\")\n    if octal.startswith(\"0o\"):\n        octal = octal[2:]\n    if octal == \"\":\n        raise ValueError(\"Empty string was passed to the function\")\n    if any(char not in \"01234567\" for char in octal):\n        raise ValueError(\"Not a Valid Octal Number\")\n\n    decimal = 0\n    for char in octal:\n        decimal <<= 3\n        decimal |= int(char)\n\n    hex_char = \"0123456789ABCDEF\"\n\n    revhex = \"\"\n    while decimal:\n        revhex += hex_char[decimal & 15]\n        decimal >>= 4\n\n    return \"0x\" + revhex[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    nums = [\"030\", \"100\", \"247\", \"235\", \"007\"]\n\n    ## Main Tests\n\n    for num in nums:\n        hexadecimal = octal_to_hex(num)\n        expected = \"0x\" + hex(int(num, 8))[2:].upper()\n\n        assert hexadecimal == expected\n\n        print(f\"Hex of '0o{num}' is: {hexadecimal}\")\n        print(f\"Expected was: {expected}\")\n        print(\"---\")\n", "conversions/rgb_hsv_conversion.py": "\"\"\"\nThe RGB color model is an additive color model in which red, green, and blue light\nare added together in various ways to reproduce a broad array of colors. The name\nof the model comes from the initials of the three additive primary colors, red,\ngreen, and blue. Meanwhile, the HSV representation models how colors appear under\nlight. In it, colors are represented using three components: hue, saturation and\n(brightness-)value. This file provides functions for converting colors from one\nrepresentation to the other.\n\n(description adapted from https://en.wikipedia.org/wiki/RGB_color_model and\nhttps://en.wikipedia.org/wiki/HSL_and_HSV).\n\"\"\"\n\n\ndef hsv_to_rgb(hue: float, saturation: float, value: float) -> list[int]:\n    \"\"\"\n    Conversion from the HSV-representation to the RGB-representation.\n    Expected RGB-values taken from\n    https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n\n    >>> hsv_to_rgb(0, 0, 0)\n    [0, 0, 0]\n    >>> hsv_to_rgb(0, 0, 1)\n    [255, 255, 255]\n    >>> hsv_to_rgb(0, 1, 1)\n    [255, 0, 0]\n    >>> hsv_to_rgb(60, 1, 1)\n    [255, 255, 0]\n    >>> hsv_to_rgb(120, 1, 1)\n    [0, 255, 0]\n    >>> hsv_to_rgb(240, 1, 1)\n    [0, 0, 255]\n    >>> hsv_to_rgb(300, 1, 1)\n    [255, 0, 255]\n    >>> hsv_to_rgb(180, 0.5, 0.5)\n    [64, 128, 128]\n    >>> hsv_to_rgb(234, 0.14, 0.88)\n    [193, 196, 224]\n    >>> hsv_to_rgb(330, 0.75, 0.5)\n    [128, 32, 80]\n    \"\"\"\n    if hue < 0 or hue > 360:\n        raise Exception(\"hue should be between 0 and 360\")\n\n    if saturation < 0 or saturation > 1:\n        raise Exception(\"saturation should be between 0 and 1\")\n\n    if value < 0 or value > 1:\n        raise Exception(\"value should be between 0 and 1\")\n\n    chroma = value * saturation\n    hue_section = hue / 60\n    second_largest_component = chroma * (1 - abs(hue_section % 2 - 1))\n    match_value = value - chroma\n\n    if hue_section >= 0 and hue_section <= 1:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 1 and hue_section <= 2:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (match_value))\n    elif hue_section > 2 and hue_section <= 3:\n        red = round(255 * (match_value))\n        green = round(255 * (chroma + match_value))\n        blue = round(255 * (second_largest_component + match_value))\n    elif hue_section > 3 and hue_section <= 4:\n        red = round(255 * (match_value))\n        green = round(255 * (second_largest_component + match_value))\n        blue = round(255 * (chroma + match_value))\n    elif hue_section > 4 and hue_section <= 5:\n        red = round(255 * (second_largest_component + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (chroma + match_value))\n    else:\n        red = round(255 * (chroma + match_value))\n        green = round(255 * (match_value))\n        blue = round(255 * (second_largest_component + match_value))\n\n    return [red, green, blue]\n\n\ndef rgb_to_hsv(red: int, green: int, blue: int) -> list[float]:\n    \"\"\"\n    Conversion from the RGB-representation to the HSV-representation.\n    The tested values are the reverse values from the hsv_to_rgb-doctests.\n    Function \"approximately_equal_hsv\" is needed because of small deviations due to\n    rounding for the RGB-values.\n\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])\n    True\n    >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])\n    True\n    \"\"\"\n    if red < 0 or red > 255:\n        raise Exception(\"red should be between 0 and 255\")\n\n    if green < 0 or green > 255:\n        raise Exception(\"green should be between 0 and 255\")\n\n    if blue < 0 or blue > 255:\n        raise Exception(\"blue should be between 0 and 255\")\n\n    float_red = red / 255\n    float_green = green / 255\n    float_blue = blue / 255\n    value = max(float_red, float_green, float_blue)\n    chroma = value - min(float_red, float_green, float_blue)\n    saturation = 0 if value == 0 else chroma / value\n\n    if chroma == 0:\n        hue = 0.0\n    elif value == float_red:\n        hue = 60 * (0 + (float_green - float_blue) / chroma)\n    elif value == float_green:\n        hue = 60 * (2 + (float_blue - float_red) / chroma)\n    else:\n        hue = 60 * (4 + (float_red - float_green) / chroma)\n\n    hue = (hue + 360) % 360\n\n    return [hue, saturation, value]\n\n\ndef approximately_equal_hsv(hsv_1: list[float], hsv_2: list[float]) -> bool:\n    \"\"\"\n    Utility-function to check that two hsv-colors are approximately equal\n\n    >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])\n    True\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])\n    True\n    >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])\n    False\n    >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])\n    False\n    \"\"\"\n    check_hue = abs(hsv_1[0] - hsv_2[0]) < 0.2\n    check_saturation = abs(hsv_1[1] - hsv_2[1]) < 0.002\n    check_value = abs(hsv_1[2] - hsv_2[2]) < 0.002\n\n    return check_hue and check_saturation and check_value\n", "conversions/roman_numerals.py": "ROMAN = [\n    (1000, \"M\"),\n    (900, \"CM\"),\n    (500, \"D\"),\n    (400, \"CD\"),\n    (100, \"C\"),\n    (90, \"XC\"),\n    (50, \"L\"),\n    (40, \"XL\"),\n    (10, \"X\"),\n    (9, \"IX\"),\n    (5, \"V\"),\n    (4, \"IV\"),\n    (1, \"I\"),\n]\n\n\ndef roman_to_int(roman: str) -> int:\n    \"\"\"\n    LeetCode No. 13 Roman to Integer\n    Given a roman numeral, convert it to an integer.\n    Input is guaranteed to be within the range from 1 to 3999.\n    https://en.wikipedia.org/wiki/Roman_numerals\n    >>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n    >>> all(roman_to_int(key) == value for key, value in tests.items())\n    True\n    \"\"\"\n    vals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    total = 0\n    place = 0\n    while place < len(roman):\n        if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):\n            total += vals[roman[place + 1]] - vals[roman[place]]\n            place += 2\n        else:\n            total += vals[roman[place]]\n            place += 1\n    return total\n\n\ndef int_to_roman(number: int) -> str:\n    \"\"\"\n    Given a integer, convert it to an roman numeral.\n    https://en.wikipedia.org/wiki/Roman_numerals\n    >>> tests = {\"III\": 3, \"CLIV\": 154, \"MIX\": 1009, \"MMD\": 2500, \"MMMCMXCIX\": 3999}\n    >>> all(int_to_roman(value) == key for key, value in tests.items())\n    True\n    \"\"\"\n    result = []\n    for arabic, roman in ROMAN:\n        (factor, number) = divmod(number, arabic)\n        result.append(roman * factor)\n        if number == 0:\n            break\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/decimal_to_octal.py": "\"\"\"Convert a Decimal Number to an Octal Number.\"\"\"\n\nimport math\n\n# Modified from:\n# https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToOctal.js\n\n\ndef decimal_to_octal(num: int) -> str:\n    \"\"\"Convert a Decimal Number to an Octal Number.\n\n    >>> all(decimal_to_octal(i) == oct(i) for i\n    ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))\n    True\n    \"\"\"\n    octal = 0\n    counter = 0\n    while num > 0:\n        remainder = num % 8\n        octal = octal + (remainder * math.floor(math.pow(10, counter)))\n        counter += 1\n        num = math.floor(num / 8)  # basically /= 8 without remainder if any\n        # This formatting removes trailing '.0' from `octal`.\n    return f\"0o{int(octal)}\"\n\n\ndef main() -> None:\n    \"\"\"Print octal equivalents of decimal numbers.\"\"\"\n    print(\"\\n2 in octal is:\")\n    print(decimal_to_octal(2))  # = 2\n    print(\"\\n8 in octal is:\")\n    print(decimal_to_octal(8))  # = 10\n    print(\"\\n65 in octal is:\")\n    print(decimal_to_octal(65))  # = 101\n    print(\"\\n216 in octal is:\")\n    print(decimal_to_octal(216))  # = 330\n    print(\"\\n512 in octal is:\")\n    print(decimal_to_octal(512))  # = 1000\n    print(\"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "conversions/time_conversions.py": "\"\"\"\nA unit of time is any particular time interval, used as a standard way of measuring or\nexpressing duration.  The base unit of time in the International System of Units (SI),\nand by extension most of the Western world, is the second, defined as about 9 billion\noscillations of the caesium atom.\n\nhttps://en.wikipedia.org/wiki/Unit_of_time\n\"\"\"\n\ntime_chart: dict[str, float] = {\n    \"seconds\": 1.0,\n    \"minutes\": 60.0,  # 1 minute = 60 sec\n    \"hours\": 3600.0,  # 1 hour = 60 minutes = 3600 seconds\n    \"days\": 86400.0,  # 1 day = 24 hours = 1440 min = 86400 sec\n    \"weeks\": 604800.0,  # 1 week=7d=168hr=10080min = 604800 sec\n    \"months\": 2629800.0,  # Approximate value for a month in seconds\n    \"years\": 31557600.0,  # Approximate value for a year in seconds\n}\n\ntime_chart_inverse: dict[str, float] = {\n    key: 1 / value for key, value in time_chart.items()\n}\n\n\ndef convert_time(time_value: float, unit_from: str, unit_to: str) -> float:\n    \"\"\"\n    Convert time from one unit to another using the time_chart above.\n\n    >>> convert_time(3600, \"seconds\", \"hours\")\n    1.0\n    >>> convert_time(3500, \"Seconds\", \"Hours\")\n    0.972\n    >>> convert_time(1, \"DaYs\", \"hours\")\n    24.0\n    >>> convert_time(120, \"minutes\", \"SeCoNdS\")\n    7200.0\n    >>> convert_time(2, \"WEEKS\", \"days\")\n    14.0\n    >>> convert_time(0.5, \"hours\", \"MINUTES\")\n    30.0\n    >>> convert_time(-3600, \"seconds\", \"hours\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time(\"Hello\", \"hours\", \"minutes\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time([0, 1, 2], \"weeks\", \"days\")\n    Traceback (most recent call last):\n        ...\n    ValueError: 'time_value' must be a non-negative number.\n    >>> convert_time(1, \"cool\", \"century\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ...\n    >>> convert_time(1, \"seconds\", \"hot\")  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ...\n    \"\"\"\n    if not isinstance(time_value, (int, float)) or time_value < 0:\n        msg = \"'time_value' must be a non-negative number.\"\n        raise ValueError(msg)\n\n    unit_from = unit_from.lower()\n    unit_to = unit_to.lower()\n    if unit_from not in time_chart or unit_to not in time_chart:\n        invalid_unit = unit_from if unit_from not in time_chart else unit_to\n        msg = f\"Invalid unit {invalid_unit} is not in {', '.join(time_chart)}.\"\n        raise ValueError(msg)\n\n    return round(\n        time_value * time_chart[unit_from] * time_chart_inverse[unit_to],\n        3,\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(f\"{convert_time(3600,'seconds', 'hours') = :,}\")\n    print(f\"{convert_time(360, 'days', 'months') = :,}\")\n    print(f\"{convert_time(360, 'months', 'years') = :,}\")\n    print(f\"{convert_time(1, 'years', 'seconds') = :,}\")\n", "conversions/__init__.py": "", "conversions/binary_to_hexadecimal.py": "BITS_TO_HEX = {\n    \"0000\": \"0\",\n    \"0001\": \"1\",\n    \"0010\": \"2\",\n    \"0011\": \"3\",\n    \"0100\": \"4\",\n    \"0101\": \"5\",\n    \"0110\": \"6\",\n    \"0111\": \"7\",\n    \"1000\": \"8\",\n    \"1001\": \"9\",\n    \"1010\": \"a\",\n    \"1011\": \"b\",\n    \"1100\": \"c\",\n    \"1101\": \"d\",\n    \"1110\": \"e\",\n    \"1111\": \"f\",\n}\n\n\ndef bin_to_hexadecimal(binary_str: str) -> str:\n    \"\"\"\n    Converting a binary string into hexadecimal using Grouping Method\n\n    >>> bin_to_hexadecimal('101011111')\n    '0x15f'\n    >>> bin_to_hexadecimal(' 1010   ')\n    '0x0a'\n    >>> bin_to_hexadecimal('-11101')\n    '-0x1d'\n    >>> bin_to_hexadecimal('a')\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-binary value was passed to the function\n    >>> bin_to_hexadecimal('')\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    \"\"\"\n    # Sanitising parameter\n    binary_str = str(binary_str).strip()\n\n    # Exceptions\n    if not binary_str:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = binary_str[0] == \"-\"\n    binary_str = binary_str[1:] if is_negative else binary_str\n    if not all(char in \"01\" for char in binary_str):\n        raise ValueError(\"Non-binary value was passed to the function\")\n\n    binary_str = (\n        \"0\" * (4 * (divmod(len(binary_str), 4)[0] + 1) - len(binary_str)) + binary_str\n    )\n\n    hexadecimal = []\n    for x in range(0, len(binary_str), 4):\n        hexadecimal.append(BITS_TO_HEX[binary_str[x : x + 4]])\n    hexadecimal_str = \"0x\" + \"\".join(hexadecimal)\n\n    return \"-\" + hexadecimal_str if is_negative else hexadecimal_str\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/temperature_conversions.py": "\"\"\"Convert between different units of temperature\"\"\"\n\n\ndef celsius_to_fahrenheit(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> celsius_to_fahrenheit(273.354, 3)\n    524.037\n    >>> celsius_to_fahrenheit(273.354, 0)\n    524.0\n    >>> celsius_to_fahrenheit(-40.0)\n    -40.0\n    >>> celsius_to_fahrenheit(-20.0)\n    -4.0\n    >>> celsius_to_fahrenheit(0)\n    32.0\n    >>> celsius_to_fahrenheit(20)\n    68.0\n    >>> celsius_to_fahrenheit(\"40\")\n    104.0\n    >>> celsius_to_fahrenheit(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round((float(celsius) * 9 / 5) + 32, ndigits)\n\n\ndef celsius_to_kelvin(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> celsius_to_kelvin(273.354, 3)\n    546.504\n    >>> celsius_to_kelvin(273.354, 0)\n    547.0\n    >>> celsius_to_kelvin(0)\n    273.15\n    >>> celsius_to_kelvin(20.0)\n    293.15\n    >>> celsius_to_kelvin(\"40\")\n    313.15\n    >>> celsius_to_kelvin(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round(float(celsius) + 273.15, ndigits)\n\n\ndef celsius_to_rankine(celsius: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Celsius to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> celsius_to_rankine(273.354, 3)\n    983.707\n    >>> celsius_to_rankine(273.354, 0)\n    984.0\n    >>> celsius_to_rankine(0)\n    491.67\n    >>> celsius_to_rankine(20.0)\n    527.67\n    >>> celsius_to_rankine(\"40\")\n    563.67\n    >>> celsius_to_rankine(\"celsius\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'celsius'\n    \"\"\"\n    return round((float(celsius) * 9 / 5) + 491.67, ndigits)\n\n\ndef fahrenheit_to_celsius(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> fahrenheit_to_celsius(273.354, 3)\n    134.086\n    >>> fahrenheit_to_celsius(273.354, 0)\n    134.0\n    >>> fahrenheit_to_celsius(0)\n    -17.78\n    >>> fahrenheit_to_celsius(20.0)\n    -6.67\n    >>> fahrenheit_to_celsius(40.0)\n    4.44\n    >>> fahrenheit_to_celsius(60)\n    15.56\n    >>> fahrenheit_to_celsius(80)\n    26.67\n    >>> fahrenheit_to_celsius(\"100\")\n    37.78\n    >>> fahrenheit_to_celsius(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round((float(fahrenheit) - 32) * 5 / 9, ndigits)\n\n\ndef fahrenheit_to_kelvin(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> fahrenheit_to_kelvin(273.354, 3)\n    407.236\n    >>> fahrenheit_to_kelvin(273.354, 0)\n    407.0\n    >>> fahrenheit_to_kelvin(0)\n    255.37\n    >>> fahrenheit_to_kelvin(20.0)\n    266.48\n    >>> fahrenheit_to_kelvin(40.0)\n    277.59\n    >>> fahrenheit_to_kelvin(60)\n    288.71\n    >>> fahrenheit_to_kelvin(80)\n    299.82\n    >>> fahrenheit_to_kelvin(\"100\")\n    310.93\n    >>> fahrenheit_to_kelvin(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round(((float(fahrenheit) - 32) * 5 / 9) + 273.15, ndigits)\n\n\ndef fahrenheit_to_rankine(fahrenheit: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> fahrenheit_to_rankine(273.354, 3)\n    733.024\n    >>> fahrenheit_to_rankine(273.354, 0)\n    733.0\n    >>> fahrenheit_to_rankine(0)\n    459.67\n    >>> fahrenheit_to_rankine(20.0)\n    479.67\n    >>> fahrenheit_to_rankine(40.0)\n    499.67\n    >>> fahrenheit_to_rankine(60)\n    519.67\n    >>> fahrenheit_to_rankine(80)\n    539.67\n    >>> fahrenheit_to_rankine(\"100\")\n    559.67\n    >>> fahrenheit_to_rankine(\"fahrenheit\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'fahrenheit'\n    \"\"\"\n    return round(float(fahrenheit) + 459.67, ndigits)\n\n\ndef kelvin_to_celsius(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> kelvin_to_celsius(273.354, 3)\n    0.204\n    >>> kelvin_to_celsius(273.354, 0)\n    0.0\n    >>> kelvin_to_celsius(273.15)\n    0.0\n    >>> kelvin_to_celsius(300)\n    26.85\n    >>> kelvin_to_celsius(\"315.5\")\n    42.35\n    >>> kelvin_to_celsius(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round(float(kelvin) - 273.15, ndigits)\n\n\ndef kelvin_to_fahrenheit(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> kelvin_to_fahrenheit(273.354, 3)\n    32.367\n    >>> kelvin_to_fahrenheit(273.354, 0)\n    32.0\n    >>> kelvin_to_fahrenheit(273.15)\n    32.0\n    >>> kelvin_to_fahrenheit(300)\n    80.33\n    >>> kelvin_to_fahrenheit(\"315.5\")\n    108.23\n    >>> kelvin_to_fahrenheit(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round(((float(kelvin) - 273.15) * 9 / 5) + 32, ndigits)\n\n\ndef kelvin_to_rankine(kelvin: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Kelvin to Rankine and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n\n    >>> kelvin_to_rankine(273.354, 3)\n    492.037\n    >>> kelvin_to_rankine(273.354, 0)\n    492.0\n    >>> kelvin_to_rankine(0)\n    0.0\n    >>> kelvin_to_rankine(20.0)\n    36.0\n    >>> kelvin_to_rankine(\"40\")\n    72.0\n    >>> kelvin_to_rankine(\"kelvin\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'kelvin'\n    \"\"\"\n    return round((float(kelvin) * 9 / 5), ndigits)\n\n\ndef rankine_to_celsius(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Celsius and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Celsius\n\n    >>> rankine_to_celsius(273.354, 3)\n    -121.287\n    >>> rankine_to_celsius(273.354, 0)\n    -121.0\n    >>> rankine_to_celsius(273.15)\n    -121.4\n    >>> rankine_to_celsius(300)\n    -106.48\n    >>> rankine_to_celsius(\"315.5\")\n    -97.87\n    >>> rankine_to_celsius(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round((float(rankine) - 491.67) * 5 / 9, ndigits)\n\n\ndef rankine_to_fahrenheit(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit\n\n    >>> rankine_to_fahrenheit(273.15)\n    -186.52\n    >>> rankine_to_fahrenheit(300)\n    -159.67\n    >>> rankine_to_fahrenheit(\"315.5\")\n    -144.17\n    >>> rankine_to_fahrenheit(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round(float(rankine) - 459.67, ndigits)\n\n\ndef rankine_to_kelvin(rankine: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from Rankine to Kelvin and round it to 2 decimal places.\n    Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale\n    Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin\n\n    >>> rankine_to_kelvin(0)\n    0.0\n    >>> rankine_to_kelvin(20.0)\n    11.11\n    >>> rankine_to_kelvin(\"40\")\n    22.22\n    >>> rankine_to_kelvin(\"rankine\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'rankine'\n    \"\"\"\n    return round((float(rankine) * 5 / 9), ndigits)\n\n\ndef reaumur_to_kelvin(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to Kelvin and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_kelvin(0)\n    273.15\n    >>> reaumur_to_kelvin(20.0)\n    298.15\n    >>> reaumur_to_kelvin(40)\n    323.15\n    >>> reaumur_to_kelvin(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 1.25 + 273.15), ndigits)\n\n\ndef reaumur_to_fahrenheit(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_fahrenheit(0)\n    32.0\n    >>> reaumur_to_fahrenheit(20.0)\n    77.0\n    >>> reaumur_to_fahrenheit(40)\n    122.0\n    >>> reaumur_to_fahrenheit(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 2.25 + 32), ndigits)\n\n\ndef reaumur_to_celsius(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to celsius and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_celsius(0)\n    0.0\n    >>> reaumur_to_celsius(20.0)\n    25.0\n    >>> reaumur_to_celsius(40)\n    50.0\n    >>> reaumur_to_celsius(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 1.25), ndigits)\n\n\ndef reaumur_to_rankine(reaumur: float, ndigits: int = 2) -> float:\n    \"\"\"\n    Convert a given value from reaumur to rankine and round it to 2 decimal places.\n    Reference:- http://www.csgnetwork.com/temp2conv.html\n\n    >>> reaumur_to_rankine(0)\n    491.67\n    >>> reaumur_to_rankine(20.0)\n    536.67\n    >>> reaumur_to_rankine(40)\n    581.67\n    >>> reaumur_to_rankine(\"reaumur\")\n    Traceback (most recent call last):\n        ...\n    ValueError: could not convert string to float: 'reaumur'\n    \"\"\"\n    return round((float(reaumur) * 2.25 + 32 + 459.67), ndigits)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "conversions/hexadecimal_to_decimal.py": "hex_table = {hex(i)[2:]: i for i in range(16)}  # Use [:2] to strip off the leading '0x'\n\n\ndef hex_to_decimal(hex_string: str) -> int:\n    \"\"\"\n    Convert a hexadecimal value to its decimal equivalent\n    #https://www.programiz.com/python-programming/methods/built-in/hex\n\n    >>> hex_to_decimal(\"a\")\n    10\n    >>> hex_to_decimal(\"12f\")\n    303\n    >>> hex_to_decimal(\"   12f   \")\n    303\n    >>> hex_to_decimal(\"FfFf\")\n    65535\n    >>> hex_to_decimal(\"-Ff\")\n    -255\n    >>> hex_to_decimal(\"F-f\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-hexadecimal value was passed to the function\n    >>> hex_to_decimal(\"\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Empty string was passed to the function\n    >>> hex_to_decimal(\"12m\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Non-hexadecimal value was passed to the function\n    \"\"\"\n    hex_string = hex_string.strip().lower()\n    if not hex_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    is_negative = hex_string[0] == \"-\"\n    if is_negative:\n        hex_string = hex_string[1:]\n    if not all(char in hex_table for char in hex_string):\n        raise ValueError(\"Non-hexadecimal value was passed to the function\")\n    decimal_number = 0\n    for char in hex_string:\n        decimal_number = 16 * decimal_number + hex_table[char]\n    return -decimal_number if is_negative else decimal_number\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "conversions/binary_to_octal.py": "\"\"\"\nThe function below will convert any binary string to the octal equivalent.\n\n>>> bin_to_octal(\"1111\")\n'17'\n\n>>> bin_to_octal(\"101010101010011\")\n'52523'\n\n>>> bin_to_octal(\"\")\nTraceback (most recent call last):\n    ...\nValueError: Empty string was passed to the function\n>>> bin_to_octal(\"a-1\")\nTraceback (most recent call last):\n    ...\nValueError: Non-binary value was passed to the function\n\"\"\"\n\n\ndef bin_to_octal(bin_string: str) -> str:\n    if not all(char in \"01\" for char in bin_string):\n        raise ValueError(\"Non-binary value was passed to the function\")\n    if not bin_string:\n        raise ValueError(\"Empty string was passed to the function\")\n    oct_string = \"\"\n    while len(bin_string) % 3 != 0:\n        bin_string = \"0\" + bin_string\n    bin_string_in_3_list = [\n        bin_string[index : index + 3]\n        for index in range(len(bin_string))\n        if index % 3 == 0\n    ]\n    for bin_group in bin_string_in_3_list:\n        oct_val = 0\n        for index, val in enumerate(bin_group):\n            oct_val += int(2 ** (2 - index) * int(val))\n        oct_string += str(oct_val)\n    return oct_string\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "machine_learning/k_nearest_neighbours.py": "\"\"\"\nk-Nearest Neighbours (kNN) is a simple non-parametric supervised learning\nalgorithm used for classification. Given some labelled training data, a given\npoint is classified using its k nearest neighbours according to some distance\nmetric. The most commonly occurring label among the neighbours becomes the label\nof the given point. In effect, the label of the given point is decided by a\nmajority vote.\n\nThis implementation uses the commonly used Euclidean distance metric, but other\ndistance metrics can also be used.\n\nReference: https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm\n\"\"\"\n\nfrom collections import Counter\nfrom heapq import nsmallest\n\nimport numpy as np\nfrom sklearn import datasets\nfrom sklearn.model_selection import train_test_split\n\n\nclass KNN:\n    def __init__(\n        self,\n        train_data: np.ndarray[float],\n        train_target: np.ndarray[int],\n        class_labels: list[str],\n    ) -> None:\n        \"\"\"\n        Create a kNN classifier using the given training data and class labels\n        \"\"\"\n        self.data = zip(train_data, train_target)\n        self.labels = class_labels\n\n    @staticmethod\n    def _euclidean_distance(a: np.ndarray[float], b: np.ndarray[float]) -> float:\n        \"\"\"\n        Calculate the Euclidean distance between two points\n        >>> KNN._euclidean_distance(np.array([0, 0]), np.array([3, 4]))\n        5.0\n        >>> KNN._euclidean_distance(np.array([1, 2, 3]), np.array([1, 8, 11]))\n        10.0\n        \"\"\"\n        return np.linalg.norm(a - b)\n\n    def classify(self, pred_point: np.ndarray[float], k: int = 5) -> str:\n        \"\"\"\n        Classify a given point using the kNN algorithm\n        >>> train_X = np.array(\n        ...     [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]]\n        ... )\n        >>> train_y = np.array([0, 0, 0, 0, 1, 1, 1])\n        >>> classes = ['A', 'B']\n        >>> knn = KNN(train_X, train_y, classes)\n        >>> point = np.array([1.2, 1.2])\n        >>> knn.classify(point)\n        'A'\n        \"\"\"\n        # Distances of all points from the point to be classified\n        distances = (\n            (self._euclidean_distance(data_point[0], pred_point), data_point[1])\n            for data_point in self.data\n        )\n\n        # Choosing k points with the shortest distances\n        votes = (i[1] for i in nsmallest(k, distances))\n\n        # Most commonly occurring class is the one into which the point is classified\n        result = Counter(votes).most_common(1)[0][0]\n        return self.labels[result]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    iris = datasets.load_iris()\n\n    X = np.array(iris[\"data\"])\n    y = np.array(iris[\"target\"])\n    iris_classes = iris[\"target_names\"]\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)\n    iris_point = np.array([4.4, 3.1, 1.3, 1.4])\n    classifier = KNN(X_train, y_train, iris_classes)\n    print(classifier.classify(iris_point, k=3))\n", "machine_learning/astar.py": "\"\"\"\nThe A* algorithm combines features of uniform-cost search and pure heuristic search to\nefficiently compute optimal solutions.\n\nThe A* algorithm is a best-first search algorithm in which the cost associated with a\nnode is f(n) = g(n) + h(n), where g(n) is the cost of the path from the initial state to\nnode n and h(n) is the heuristic estimate or the cost or a path from node n to a goal.\n\nThe A* algorithm introduces a heuristic into a regular graph-searching algorithm,\nessentially planning ahead at each step so a more optimal decision is made. For this\nreason, A* is known as an algorithm with brains.\n\nhttps://en.wikipedia.org/wiki/A*_search_algorithm\n\"\"\"\n\nimport numpy as np\n\n\nclass Cell:\n    \"\"\"\n    Class cell represents a cell in the world which have the properties:\n    position: represented by tuple of x and y coordinates initially set to (0,0).\n    parent: Contains the parent cell object visited before we arrived at this cell.\n    g, h, f: Parameters used when calling our heuristic function.\n    \"\"\"\n\n    def __init__(self):\n        self.position = (0, 0)\n        self.parent = None\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    \"\"\"\n    Overrides equals method because otherwise cell assign will give\n    wrong results.\n    \"\"\"\n\n    def __eq__(self, cell):\n        return self.position == cell.position\n\n    def showcell(self):\n        print(self.position)\n\n\nclass Gridworld:\n    \"\"\"\n    Gridworld class represents the  external world here a grid M*M\n    matrix.\n    world_size: create a numpy array with the given world_size default is 5.\n    \"\"\"\n\n    def __init__(self, world_size=(5, 5)):\n        self.w = np.zeros(world_size)\n        self.world_x_limit = world_size[0]\n        self.world_y_limit = world_size[1]\n\n    def show(self):\n        print(self.w)\n\n    def get_neighbours(self, cell):\n        \"\"\"\n        Return the neighbours of cell\n        \"\"\"\n        neughbour_cord = [\n            (-1, -1),\n            (-1, 0),\n            (-1, 1),\n            (0, -1),\n            (0, 1),\n            (1, -1),\n            (1, 0),\n            (1, 1),\n        ]\n        current_x = cell.position[0]\n        current_y = cell.position[1]\n        neighbours = []\n        for n in neughbour_cord:\n            x = current_x + n[0]\n            y = current_y + n[1]\n            if 0 <= x < self.world_x_limit and 0 <= y < self.world_y_limit:\n                c = Cell()\n                c.position = (x, y)\n                c.parent = cell\n                neighbours.append(c)\n        return neighbours\n\n\ndef astar(world, start, goal):\n    \"\"\"\n    Implementation of a start algorithm.\n    world : Object of the world object.\n    start : Object of the cell as  start position.\n    stop  : Object of the cell as goal position.\n\n    >>> p = Gridworld()\n    >>> start = Cell()\n    >>> start.position = (0,0)\n    >>> goal = Cell()\n    >>> goal.position = (4,4)\n    >>> astar(p, start, goal)\n    [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n    \"\"\"\n    _open = []\n    _closed = []\n    _open.append(start)\n\n    while _open:\n        min_f = np.argmin([n.f for n in _open])\n        current = _open[min_f]\n        _closed.append(_open.pop(min_f))\n        if current == goal:\n            break\n        for n in world.get_neighbours(current):\n            for c in _closed:\n                if c == n:\n                    continue\n            n.g = current.g + 1\n            x1, y1 = n.position\n            x2, y2 = goal.position\n            n.h = (y2 - y1) ** 2 + (x2 - x1) ** 2\n            n.f = n.h + n.g\n\n            for c in _open:\n                if c == n and c.f < n.f:\n                    continue\n            _open.append(n)\n    path = []\n    while current.parent is not None:\n        path.append(current.position)\n        current = current.parent\n    path.append(current.position)\n    return path[::-1]\n\n\nif __name__ == \"__main__\":\n    world = Gridworld()\n    # Start position and goal\n    start = Cell()\n    start.position = (0, 0)\n    goal = Cell()\n    goal.position = (4, 4)\n    print(f\"path from {start.position} to {goal.position}\")\n    s = astar(world, start, goal)\n    #   Just for visual reasons.\n    for i in s:\n        world.w[i] = 1\n    print(world.w)\n", "machine_learning/xgboost_regressor.py": "# XGBoost Regressor Example\nimport numpy as np\nfrom sklearn.datasets import fetch_california_housing\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\nfrom sklearn.model_selection import train_test_split\nfrom xgboost import XGBRegressor\n\n\ndef data_handling(data: dict) -> tuple:\n    # Split dataset into features and target.  Data is features.\n    \"\"\"\n    >>> data_handling((\n    ...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]'\n    ...  ,'target':([4.526])}))\n    ('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])\n    \"\"\"\n    return (data[\"data\"], data[\"target\"])\n\n\ndef xgboost(\n    features: np.ndarray, target: np.ndarray, test_features: np.ndarray\n) -> np.ndarray:\n    \"\"\"\n    >>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068,\n    ...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]),\n    ... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00,\n    ...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]]))\n    array([[1.1139996]], dtype=float32)\n    \"\"\"\n    xgb = XGBRegressor(\n        verbosity=0, random_state=42, tree_method=\"exact\", base_score=0.5\n    )\n    xgb.fit(features, target)\n    # Predict target for test data\n    predictions = xgb.predict(test_features)\n    predictions = predictions.reshape(len(predictions), 1)\n    return predictions\n\n\ndef main() -> None:\n    \"\"\"\n    The URL for this algorithm\n    https://xgboost.readthedocs.io/en/stable/\n    California house price dataset is used to demonstrate the algorithm.\n\n    Expected error values:\n    Mean Absolute Error: 0.30957163379906033\n    Mean Square Error: 0.22611560196662744\n    \"\"\"\n    # Load California house price dataset\n    california = fetch_california_housing()\n    data, target = data_handling(california)\n    x_train, x_test, y_train, y_test = train_test_split(\n        data, target, test_size=0.25, random_state=1\n    )\n    predictions = xgboost(x_train, y_train, x_test)\n    # Error printing\n    print(f\"Mean Absolute Error: {mean_absolute_error(y_test, predictions)}\")\n    print(f\"Mean Square Error: {mean_squared_error(y_test, predictions)}\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n    main()\n", "machine_learning/gradient_boosting_classifier.py": "import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeRegressor\n\n\nclass GradientBoostingClassifier:\n    def __init__(self, n_estimators: int = 100, learning_rate: float = 0.1) -> None:\n        \"\"\"\n        Initialize a GradientBoostingClassifier.\n\n        Parameters:\n        - n_estimators (int): The number of weak learners to train.\n        - learning_rate (float): The learning rate for updating the model.\n\n        Attributes:\n        - n_estimators (int): The number of weak learners.\n        - learning_rate (float): The learning rate.\n        - models (list): A list to store the trained weak learners.\n        \"\"\"\n        self.n_estimators = n_estimators\n        self.learning_rate = learning_rate\n        self.models: list[tuple[DecisionTreeRegressor, float]] = []\n\n    def fit(self, features: np.ndarray, target: np.ndarray) -> None:\n        \"\"\"\n        Fit the GradientBoostingClassifier to the training data.\n\n        Parameters:\n        - features (np.ndarray): The training features.\n        - target (np.ndarray): The target values.\n\n        Returns:\n        None\n\n        >>> import numpy as np\n        >>> from sklearn.datasets import load_iris\n        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)\n        >>> iris = load_iris()\n        >>> X, y = iris.data, iris.target\n        >>> clf.fit(X, y)\n        >>> # Check if the model is trained\n        >>> len(clf.models) == 100\n        True\n        \"\"\"\n        for _ in range(self.n_estimators):\n            # Calculate the pseudo-residuals\n            residuals = -self.gradient(target, self.predict(features))\n            # Fit a weak learner (e.g., decision tree) to the residuals\n            model = DecisionTreeRegressor(max_depth=1)\n            model.fit(features, residuals)\n            # Update the model by adding the weak learner with a learning rate\n            self.models.append((model, self.learning_rate))\n\n    def predict(self, features: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Make predictions on input data.\n\n        Parameters:\n        - features (np.ndarray): The input data for making predictions.\n\n        Returns:\n        - np.ndarray: An array of binary predictions (-1 or 1).\n\n        >>> import numpy as np\n        >>> from sklearn.datasets import load_iris\n        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)\n        >>> iris = load_iris()\n        >>> X, y = iris.data, iris.target\n        >>> clf.fit(X, y)\n        >>> y_pred = clf.predict(X)\n        >>> # Check if the predictions have the correct shape\n        >>> y_pred.shape == y.shape\n        True\n        \"\"\"\n        # Initialize predictions with zeros\n        predictions = np.zeros(features.shape[0])\n        for model, learning_rate in self.models:\n            predictions += learning_rate * model.predict(features)\n        return np.sign(predictions)  # Convert to binary predictions (-1 or 1)\n\n    def gradient(self, target: np.ndarray, y_pred: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculate the negative gradient (pseudo-residuals) for logistic loss.\n\n        Parameters:\n        - target (np.ndarray): The target values.\n        - y_pred (np.ndarray): The predicted values.\n\n        Returns:\n        - np.ndarray: An array of pseudo-residuals.\n\n        >>> import numpy as np\n        >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)\n        >>> target = np.array([0, 1, 0, 1])\n        >>> y_pred = np.array([0.2, 0.8, 0.3, 0.7])\n        >>> residuals = clf.gradient(target, y_pred)\n        >>> # Check if residuals have the correct shape\n        >>> residuals.shape == target.shape\n        True\n        \"\"\"\n        return -target / (1 + np.exp(target * y_pred))\n\n\nif __name__ == \"__main__\":\n    iris = load_iris()\n    X, y = iris.data, iris.target\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42\n    )\n\n    clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)\n    clf.fit(X_train, y_train)\n\n    y_pred = clf.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n    print(f\"Accuracy: {accuracy:.2f}\")\n", "machine_learning/linear_discriminant_analysis.py": "\"\"\"\nLinear Discriminant Analysis\n\n\n\nAssumptions About Data :\n    1. The input variables has a gaussian distribution.\n    2. The variance calculated for each input variables by class grouping is the\n       same.\n    3. The mix of classes in your training set is representative of the problem.\n\n\nLearning The Model :\n    The LDA model requires the estimation of statistics from the training data :\n        1. Mean of each input value for each class.\n        2. Probability of an instance belong to each class.\n        3. Covariance for the input data for each class\n\n    Calculate the class means :\n        mean(x) = 1/n ( for i = 1 to i = n --> sum(xi))\n\n    Calculate the class probabilities :\n        P(y = 0) = count(y = 0) / (count(y = 0) + count(y = 1))\n        P(y = 1) = count(y = 1) / (count(y = 0) + count(y = 1))\n\n    Calculate the variance :\n        We can calculate the variance for dataset in two steps :\n            1. Calculate the squared difference for each input variable from the\n               group mean.\n            2. Calculate the mean of the squared difference.\n            ------------------------------------------------\n            Squared_Difference = (x - mean(k)) ** 2\n            Variance = (1 / (count(x) - count(classes))) *\n                (for i = 1 to i = n --> sum(Squared_Difference(xi)))\n\nMaking Predictions :\n    discriminant(x) = x * (mean / variance) -\n        ((mean ** 2) / (2 * variance)) + Ln(probability)\n    ---------------------------------------------------------------------------\n    After calculating the discriminant value for each class, the class with the\n    largest discriminant value is taken as the prediction.\n\nAuthor: @EverLookNeverSee\n\"\"\"\n\nfrom collections.abc import Callable\nfrom math import log\nfrom os import name, system\nfrom random import gauss, seed\nfrom typing import TypeVar\n\n\n# Make a training dataset drawn from a gaussian distribution\ndef gaussian_distribution(mean: float, std_dev: float, instance_count: int) -> list:\n    \"\"\"\n    Generate gaussian distribution instances based-on given mean and standard deviation\n    :param mean: mean value of class\n    :param std_dev: value of standard deviation entered by usr or default value of it\n    :param instance_count: instance number of class\n    :return: a list containing generated values based-on given mean, std_dev and\n        instance_count\n\n    >>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE\n    [6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,\n     3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,\n      5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,\n       5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,\n        5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]\n    \"\"\"\n    seed(1)\n    return [gauss(mean, std_dev) for _ in range(instance_count)]\n\n\n# Make corresponding Y flags to detecting classes\ndef y_generator(class_count: int, instance_count: list) -> list:\n    \"\"\"\n    Generate y values for corresponding classes\n    :param class_count: Number of classes(data groupings) in dataset\n    :param instance_count: number of instances in class\n    :return: corresponding values for data groupings in dataset\n\n    >>> y_generator(1, [10])\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> y_generator(2, [5, 10])\n    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    \"\"\"\n\n    return [k for k in range(class_count) for _ in range(instance_count[k])]\n\n\n# Calculate the class means\ndef calculate_mean(instance_count: int, items: list) -> float:\n    \"\"\"\n    Calculate given class mean\n    :param instance_count: Number of instances in class\n    :param items: items that related to specific class(data grouping)\n    :return: calculated actual mean of considered class\n\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\n    >>> calculate_mean(len(items), items)\n    5.011267842911003\n    \"\"\"\n    # the sum of all items divided by number of instances\n    return sum(items) / instance_count\n\n\n# Calculate the class probabilities\ndef calculate_probabilities(instance_count: int, total_count: int) -> float:\n    \"\"\"\n    Calculate the probability that a given instance will belong to which class\n    :param instance_count: number of instances in class\n    :param total_count: the number of all instances\n    :return: value of probability for considered class\n\n    >>> calculate_probabilities(20, 60)\n    0.3333333333333333\n    >>> calculate_probabilities(30, 100)\n    0.3\n    \"\"\"\n    # number of instances in specific class divided by number of all instances\n    return instance_count / total_count\n\n\n# Calculate the variance\ndef calculate_variance(items: list, means: list, total_count: int) -> float:\n    \"\"\"\n    Calculate the variance\n    :param items: a list containing all items(gaussian distribution of all classes)\n    :param means: a list containing real mean values of each class\n    :param total_count: the number of all instances\n    :return: calculated variance for considered dataset\n\n    >>> items = gaussian_distribution(5.0, 1.0, 20)\n    >>> means = [5.011267842911003]\n    >>> total_count = 20\n    >>> calculate_variance([items], means, total_count)\n    0.9618530973487491\n    \"\"\"\n    squared_diff = []  # An empty list to store all squared differences\n    # iterate over number of elements in items\n    for i in range(len(items)):\n        # for loop iterates over number of elements in inner layer of items\n        for j in range(len(items[i])):\n            # appending squared differences to 'squared_diff' list\n            squared_diff.append((items[i][j] - means[i]) ** 2)\n\n    # one divided by (the number of all instances - number of classes) multiplied by\n    # sum of all squared differences\n    n_classes = len(means)  # Number of classes in dataset\n    return 1 / (total_count - n_classes) * sum(squared_diff)\n\n\n# Making predictions\ndef predict_y_values(\n    x_items: list, means: list, variance: float, probabilities: list\n) -> list:\n    \"\"\"This function predicts new indexes(groups for our data)\n    :param x_items: a list containing all items(gaussian distribution of all classes)\n    :param means: a list containing real mean values of each class\n    :param variance: calculated value of variance by calculate_variance function\n    :param probabilities: a list containing all probabilities of classes\n    :return: a list containing predicted Y values\n\n    >>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,\n    ...                4.235456349028368, 3.9078267848958586, 5.031334516831717,\n    ...                3.977896829989127, 3.56317055489747, 5.199311976483754,\n    ...                5.133374604658605, 5.546468300338232, 4.086029056264687,\n    ...                5.005005283626573, 4.935258239627312, 3.494170998739258,\n    ...                5.537997178661033, 5.320711100998849, 7.3891120432406865,\n    ...                5.202969177309964, 4.855297691835079], [11.288184753155463,\n    ...                11.44944560869977, 10.066335808938263, 9.235456349028368,\n    ...                8.907826784895859, 10.031334516831716, 8.977896829989128,\n    ...                8.56317055489747, 10.199311976483754, 10.133374604658606,\n    ...                10.546468300338232, 9.086029056264687, 10.005005283626572,\n    ...                9.935258239627313, 8.494170998739259, 10.537997178661033,\n    ...                10.320711100998848, 12.389112043240686, 10.202969177309964,\n    ...                9.85529769183508], [16.288184753155463, 16.449445608699772,\n    ...                15.066335808938263, 14.235456349028368, 13.907826784895859,\n    ...                15.031334516831716, 13.977896829989128, 13.56317055489747,\n    ...                15.199311976483754, 15.133374604658606, 15.546468300338232,\n    ...                14.086029056264687, 15.005005283626572, 14.935258239627313,\n    ...                13.494170998739259, 15.537997178661033, 15.320711100998848,\n    ...                17.389112043240686, 15.202969177309964, 14.85529769183508]]\n\n    >>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]\n    >>> variance = 0.9618530973487494\n    >>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]\n    >>> predict_y_values(x_items, means, variance,\n    ...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2]\n\n    \"\"\"\n    # An empty list to store generated discriminant values of all items in dataset for\n    # each class\n    results = []\n    # for loop iterates over number of elements in list\n    for i in range(len(x_items)):\n        # for loop iterates over number of inner items of each element\n        for j in range(len(x_items[i])):\n            temp = []  # to store all discriminant values of each item as a list\n            # for loop iterates over number of classes we have in our dataset\n            for k in range(len(x_items)):\n                # appending values of discriminants for each class to 'temp' list\n                temp.append(\n                    x_items[i][j] * (means[k] / variance)\n                    - (means[k] ** 2 / (2 * variance))\n                    + log(probabilities[k])\n                )\n            # appending discriminant values of each item to 'results' list\n            results.append(temp)\n\n    return [result.index(max(result)) for result in results]\n\n\n# Calculating Accuracy\ndef accuracy(actual_y: list, predicted_y: list) -> float:\n    \"\"\"\n    Calculate the value of accuracy based-on predictions\n    :param actual_y:a list containing initial Y values generated by 'y_generator'\n        function\n    :param predicted_y: a list containing predicted Y values generated by\n        'predict_y_values' function\n    :return: percentage of accuracy\n\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n    ... 1, 1 ,1 ,1 ,1 ,1 ,1]\n    >>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,\n    ... 0, 0, 1, 1, 1, 0, 1, 1, 1]\n    >>> accuracy(actual_y, predicted_y)\n    50.0\n\n    >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n    ... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n    >>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,\n    ... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n    >>> accuracy(actual_y, predicted_y)\n    100.0\n    \"\"\"\n    # iterate over one element of each list at a time (zip mode)\n    # prediction is correct if actual Y value equals to predicted Y value\n    correct = sum(1 for i, j in zip(actual_y, predicted_y) if i == j)\n    # percentage of accuracy equals to number of correct predictions divided by number\n    # of all data and multiplied by 100\n    return (correct / len(actual_y)) * 100\n\n\nnum = TypeVar(\"num\")\n\n\ndef valid_input(\n    input_type: Callable[[object], num],  # Usually float or int\n    input_msg: str,\n    err_msg: str,\n    condition: Callable[[num], bool] = lambda _: True,\n    default: str | None = None,\n) -> num:\n    \"\"\"\n    Ask for user value and validate that it fulfill a condition.\n\n    :input_type: user input expected type of value\n    :input_msg: message to show user in the screen\n    :err_msg: message to show in the screen in case of error\n    :condition: function that represents the condition that user input is valid.\n    :default: Default value in case the user does not type anything\n    :return: user's input\n    \"\"\"\n    while True:\n        try:\n            user_input = input_type(input(input_msg).strip() or default)\n            if condition(user_input):\n                return user_input\n            else:\n                print(f\"{user_input}: {err_msg}\")\n                continue\n        except ValueError:\n            print(\n                f\"{user_input}: Incorrect input type, expected {input_type.__name__!r}\"\n            )\n\n\n# Main Function\ndef main():\n    \"\"\"This function starts execution phase\"\"\"\n    while True:\n        print(\" Linear Discriminant Analysis \".center(50, \"*\"))\n        print(\"*\" * 50, \"\\n\")\n        print(\"First of all we should specify the number of classes that\")\n        print(\"we want to generate as training dataset\")\n        # Trying to get number of classes\n        n_classes = valid_input(\n            input_type=int,\n            condition=lambda x: x > 0,\n            input_msg=\"Enter the number of classes (Data Groupings): \",\n            err_msg=\"Number of classes should be positive!\",\n        )\n\n        print(\"-\" * 100)\n\n        # Trying to get the value of standard deviation\n        std_dev = valid_input(\n            input_type=float,\n            condition=lambda x: x >= 0,\n            input_msg=(\n                \"Enter the value of standard deviation\"\n                \"(Default value is 1.0 for all classes): \"\n            ),\n            err_msg=\"Standard deviation should not be negative!\",\n            default=\"1.0\",\n        )\n\n        print(\"-\" * 100)\n\n        # Trying to get number of instances in classes and theirs means to generate\n        # dataset\n        counts = []  # An empty list to store instance counts of classes in dataset\n        for i in range(n_classes):\n            user_count = valid_input(\n                input_type=int,\n                condition=lambda x: x > 0,\n                input_msg=(f\"Enter The number of instances for class_{i+1}: \"),\n                err_msg=\"Number of instances should be positive!\",\n            )\n            counts.append(user_count)\n        print(\"-\" * 100)\n\n        # An empty list to store values of user-entered means of classes\n        user_means = []\n        for a in range(n_classes):\n            user_mean = valid_input(\n                input_type=float,\n                input_msg=(f\"Enter the value of mean for class_{a+1}: \"),\n                err_msg=\"This is an invalid value.\",\n            )\n            user_means.append(user_mean)\n        print(\"-\" * 100)\n\n        print(\"Standard deviation: \", std_dev)\n        # print out the number of instances in classes in separated line\n        for i, count in enumerate(counts, 1):\n            print(f\"Number of instances in class_{i} is: {count}\")\n        print(\"-\" * 100)\n\n        # print out mean values of classes separated line\n        for i, user_mean in enumerate(user_means, 1):\n            print(f\"Mean of class_{i} is: {user_mean}\")\n        print(\"-\" * 100)\n\n        # Generating training dataset drawn from gaussian distribution\n        x = [\n            gaussian_distribution(user_means[j], std_dev, counts[j])\n            for j in range(n_classes)\n        ]\n        print(\"Generated Normal Distribution: \\n\", x)\n        print(\"-\" * 100)\n\n        # Generating Ys to detecting corresponding classes\n        y = y_generator(n_classes, counts)\n        print(\"Generated Corresponding Ys: \\n\", y)\n        print(\"-\" * 100)\n\n        # Calculating the value of actual mean for each class\n        actual_means = [calculate_mean(counts[k], x[k]) for k in range(n_classes)]\n        # for loop iterates over number of elements in 'actual_means' list and print\n        # out them in separated line\n        for i, actual_mean in enumerate(actual_means, 1):\n            print(f\"Actual(Real) mean of class_{i} is: {actual_mean}\")\n        print(\"-\" * 100)\n\n        # Calculating the value of probabilities for each class\n        probabilities = [\n            calculate_probabilities(counts[i], sum(counts)) for i in range(n_classes)\n        ]\n\n        # for loop iterates over number of elements in 'probabilities' list and print\n        # out them in separated line\n        for i, probability in enumerate(probabilities, 1):\n            print(f\"Probability of class_{i} is: {probability}\")\n        print(\"-\" * 100)\n\n        # Calculating the values of variance for each class\n        variance = calculate_variance(x, actual_means, sum(counts))\n        print(\"Variance: \", variance)\n        print(\"-\" * 100)\n\n        # Predicting Y values\n        # storing predicted Y values in 'pre_indexes' variable\n        pre_indexes = predict_y_values(x, actual_means, variance, probabilities)\n        print(\"-\" * 100)\n\n        # Calculating Accuracy of the model\n        print(f\"Accuracy: {accuracy(y, pre_indexes)}\")\n        print(\"-\" * 100)\n        print(\" DONE \".center(100, \"+\"))\n\n        if input(\"Press any key to restart or 'q' for quit: \").strip().lower() == \"q\":\n            print(\"\\n\" + \"GoodBye!\".center(100, \"-\") + \"\\n\")\n            break\n        system(\"cls\" if name == \"nt\" else \"clear\")  # noqa: S605\n\n\nif __name__ == \"__main__\":\n    main()\n", "machine_learning/dimensionality_reduction.py": "#  Copyright (c) 2023 Diego Gasco (diego.gasco99@gmail.com), Diegomangasco on GitHub\n\n\"\"\"\nRequirements:\n  - numpy version 1.21\n  - scipy version 1.3.3\nNotes:\n  - Each column of the features matrix corresponds to a class item\n\"\"\"\n\nimport logging\n\nimport numpy as np\nimport pytest\nfrom scipy.linalg import eigh\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n\n\ndef column_reshape(input_array: np.ndarray) -> np.ndarray:\n    \"\"\"Function to reshape a row Numpy array into a column Numpy array\n    >>> input_array = np.array([1, 2, 3])\n    >>> column_reshape(input_array)\n    array([[1],\n           [2],\n           [3]])\n    \"\"\"\n\n    return input_array.reshape((input_array.size, 1))\n\n\ndef covariance_within_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n    \"\"\"Function to compute the covariance matrix inside each class.\n    >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> labels = np.array([0, 1, 0])\n    >>> covariance_within_classes(features, labels, 2)\n    array([[0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667],\n           [0.66666667, 0.66666667, 0.66666667]])\n    \"\"\"\n\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        data_mean = data.mean(1)\n        # Centralize the data of class i\n        centered_data = data - column_reshape(data_mean)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += np.dot(centered_data, centered_data.T)\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = np.dot(centered_data, centered_data.T)\n\n    return covariance_sum / features.shape[1]\n\n\ndef covariance_between_classes(\n    features: np.ndarray, labels: np.ndarray, classes: int\n) -> np.ndarray:\n    \"\"\"Function to compute the covariance matrix between multiple classes\n    >>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]])\n    >>> labels = np.array([0, 1, 0])\n    >>> covariance_between_classes(features, labels, 2)\n    array([[ 3.55555556,  1.77777778, -2.66666667],\n           [ 1.77777778,  0.88888889, -1.33333333],\n           [-2.66666667, -1.33333333,  2.        ]])\n    \"\"\"\n\n    general_data_mean = features.mean(1)\n    covariance_sum = np.nan\n    for i in range(classes):\n        data = features[:, labels == i]\n        device_data = data.shape[1]\n        data_mean = data.mean(1)\n        if i > 0:\n            # If covariance_sum is not None\n            covariance_sum += device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n        else:\n            # If covariance_sum is np.nan (i.e. first loop)\n            covariance_sum = device_data * np.dot(\n                column_reshape(data_mean) - column_reshape(general_data_mean),\n                (column_reshape(data_mean) - column_reshape(general_data_mean)).T,\n            )\n\n    return covariance_sum / features.shape[1]\n\n\ndef principal_component_analysis(features: np.ndarray, dimensions: int) -> np.ndarray:\n    \"\"\"\n    Principal Component Analysis.\n\n    For more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis.\n    Parameters:\n        * features: the features extracted from the dataset\n        * dimensions: to filter the projected data for the desired dimension\n\n    >>> test_principal_component_analysis()\n    \"\"\"\n\n    # Check if the features have been loaded\n    if features.any():\n        data_mean = features.mean(1)\n        # Center the dataset\n        centered_data = features - np.reshape(data_mean, (data_mean.size, 1))\n        covariance_matrix = np.dot(centered_data, centered_data.T) / features.shape[1]\n        _, eigenvectors = np.linalg.eigh(covariance_matrix)\n        # Take all the columns in the reverse order (-1), and then takes only the first\n        filtered_eigenvectors = eigenvectors[:, ::-1][:, 0:dimensions]\n        # Project the database on the new space\n        projected_data = np.dot(filtered_eigenvectors.T, features)\n        logging.info(\"Principal Component Analysis computed\")\n\n        return projected_data\n    else:\n        logging.basicConfig(level=logging.ERROR, format=\"%(message)s\", force=True)\n        logging.error(\"Dataset empty\")\n        raise AssertionError\n\n\ndef linear_discriminant_analysis(\n    features: np.ndarray, labels: np.ndarray, classes: int, dimensions: int\n) -> np.ndarray:\n    \"\"\"\n    Linear Discriminant Analysis.\n\n    For more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis.\n    Parameters:\n        * features: the features extracted from the dataset\n        * labels: the class labels of the features\n        * classes: the number of classes present in the dataset\n        * dimensions: to filter the projected data for the desired dimension\n\n    >>> test_linear_discriminant_analysis()\n    \"\"\"\n\n    # Check if the dimension desired is less than the number of classes\n    assert classes > dimensions\n\n    # Check if features have been already loaded\n    if features.any:\n        _, eigenvectors = eigh(\n            covariance_between_classes(features, labels, classes),\n            covariance_within_classes(features, labels, classes),\n        )\n        filtered_eigenvectors = eigenvectors[:, ::-1][:, :dimensions]\n        svd_matrix, _, _ = np.linalg.svd(filtered_eigenvectors)\n        filtered_svd_matrix = svd_matrix[:, 0:dimensions]\n        projected_data = np.dot(filtered_svd_matrix.T, features)\n        logging.info(\"Linear Discriminant Analysis computed\")\n\n        return projected_data\n    else:\n        logging.basicConfig(level=logging.ERROR, format=\"%(message)s\", force=True)\n        logging.error(\"Dataset empty\")\n        raise AssertionError\n\n\ndef test_linear_discriminant_analysis() -> None:\n    # Create dummy dataset with 2 classes and 3 features\n    features = np.array([[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]])\n    labels = np.array([0, 0, 0, 1, 1])\n    classes = 2\n    dimensions = 2\n\n    # Assert that the function raises an AssertionError if dimensions > classes\n    with pytest.raises(AssertionError) as error_info:  # noqa: PT012\n        projected_data = linear_discriminant_analysis(\n            features, labels, classes, dimensions\n        )\n        if isinstance(projected_data, np.ndarray):\n            raise AssertionError(\n                \"Did not raise AssertionError for dimensions > classes\"\n            )\n        assert error_info.type is AssertionError\n\n\ndef test_principal_component_analysis() -> None:\n    features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    dimensions = 2\n    expected_output = np.array([[6.92820323, 8.66025404, 10.39230485], [3.0, 3.0, 3.0]])\n\n    with pytest.raises(AssertionError) as error_info:  # noqa: PT012\n        output = principal_component_analysis(features, dimensions)\n        if not np.allclose(expected_output, output):\n            raise AssertionError\n        assert error_info.type is AssertionError\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/support_vector_machines.py": "import numpy as np\nfrom numpy import ndarray\nfrom scipy.optimize import Bounds, LinearConstraint, minimize\n\n\ndef norm_squared(vector: ndarray) -> float:\n    \"\"\"\n    Return the squared second norm of vector\n    norm_squared(v) = sum(x * x for x in v)\n\n    Args:\n        vector (ndarray): input vector\n\n    Returns:\n        float: squared second norm of vector\n\n    >>> norm_squared([1, 2])\n    5\n    >>> norm_squared(np.asarray([1, 2]))\n    5\n    >>> norm_squared([0, 0])\n    0\n    \"\"\"\n    return np.dot(vector, vector)\n\n\nclass SVC:\n    \"\"\"\n    Support Vector Classifier\n\n    Args:\n        kernel (str): kernel to use. Default: linear\n            Possible choices:\n                - linear\n        regularization: constraint for soft margin (data not linearly separable)\n            Default: unbound\n\n    >>> SVC(kernel=\"asdf\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Unknown kernel: asdf\n\n    >>> SVC(kernel=\"rbf\")\n    Traceback (most recent call last):\n        ...\n    ValueError: rbf kernel requires gamma\n\n    >>> SVC(kernel=\"rbf\", gamma=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: gamma must be > 0\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        regularization: float = np.inf,\n        kernel: str = \"linear\",\n        gamma: float = 0.0,\n    ) -> None:\n        self.regularization = regularization\n        self.gamma = gamma\n        if kernel == \"linear\":\n            self.kernel = self.__linear\n        elif kernel == \"rbf\":\n            if self.gamma == 0:\n                raise ValueError(\"rbf kernel requires gamma\")\n            if not isinstance(self.gamma, (float, int)):\n                raise ValueError(\"gamma must be float or int\")\n            if not self.gamma > 0:\n                raise ValueError(\"gamma must be > 0\")\n            self.kernel = self.__rbf\n            # in the future, there could be a default value like in sklearn\n            # sklear: def_gamma = 1/(n_features * X.var()) (wiki)\n            # previously it was 1/(n_features)\n        else:\n            msg = f\"Unknown kernel: {kernel}\"\n            raise ValueError(msg)\n\n    # kernels\n    def __linear(self, vector1: ndarray, vector2: ndarray) -> float:\n        \"\"\"Linear kernel (as if no kernel used at all)\"\"\"\n        return np.dot(vector1, vector2)\n\n    def __rbf(self, vector1: ndarray, vector2: ndarray) -> float:\n        \"\"\"\n        RBF: Radial Basis Function Kernel\n\n        Note: for more information see:\n            https://en.wikipedia.org/wiki/Radial_basis_function_kernel\n\n        Args:\n            vector1 (ndarray): first vector\n            vector2 (ndarray): second vector)\n\n        Returns:\n            float: exp(-(gamma * norm_squared(vector1 - vector2)))\n        \"\"\"\n        return np.exp(-(self.gamma * norm_squared(vector1 - vector2)))\n\n    def fit(self, observations: list[ndarray], classes: ndarray) -> None:\n        \"\"\"\n        Fits the SVC with a set of observations.\n\n        Args:\n            observations (list[ndarray]): list of observations\n            classes (ndarray): classification of each observation (in {1, -1})\n        \"\"\"\n\n        self.observations = observations\n        self.classes = classes\n\n        # using Wolfe's Dual to calculate w.\n        # Primal problem: minimize 1/2*norm_squared(w)\n        #   constraint: yn(w . xn + b) >= 1\n        #\n        # With l a vector\n        # Dual problem: maximize sum_n(ln) -\n        #       1/2 * sum_n(sum_m(ln*lm*yn*ym*xn . xm))\n        #   constraint: self.C >= ln >= 0\n        #           and sum_n(ln*yn) = 0\n        # Then we get w using w = sum_n(ln*yn*xn)\n        # At the end we can get b ~= mean(yn - w . xn)\n        #\n        # Since we use kernels, we only need l_star to calculate b\n        # and to classify observations\n\n        (n,) = np.shape(classes)\n\n        def to_minimize(candidate: ndarray) -> float:\n            \"\"\"\n            Opposite of the function to maximize\n\n            Args:\n                candidate (ndarray): candidate array to test\n\n            Return:\n                float: Wolfe's Dual result to minimize\n            \"\"\"\n            s = 0\n            (n,) = np.shape(candidate)\n            for i in range(n):\n                for j in range(n):\n                    s += (\n                        candidate[i]\n                        * candidate[j]\n                        * classes[i]\n                        * classes[j]\n                        * self.kernel(observations[i], observations[j])\n                    )\n            return 1 / 2 * s - sum(candidate)\n\n        ly_contraint = LinearConstraint(classes, 0, 0)\n        l_bounds = Bounds(0, self.regularization)\n\n        l_star = minimize(\n            to_minimize, np.ones(n), bounds=l_bounds, constraints=[ly_contraint]\n        ).x\n        self.optimum = l_star\n\n        # calculating mean offset of separation plane to points\n        s = 0\n        for i in range(n):\n            for j in range(n):\n                s += classes[i] - classes[i] * self.optimum[i] * self.kernel(\n                    observations[i], observations[j]\n                )\n        self.offset = s / n\n\n    def predict(self, observation: ndarray) -> int:\n        \"\"\"\n        Get the expected class of an observation\n\n        Args:\n            observation (Vector): observation\n\n        Returns:\n            int {1, -1}: expected class\n\n        >>> xs = [\n        ...     np.asarray([0, 1]), np.asarray([0, 2]),\n        ...     np.asarray([1, 1]), np.asarray([1, 2])\n        ... ]\n        >>> y = np.asarray([1, 1, -1, -1])\n        >>> s = SVC()\n        >>> s.fit(xs, y)\n        >>> s.predict(np.asarray([0, 1]))\n        1\n        >>> s.predict(np.asarray([1, 1]))\n        -1\n        >>> s.predict(np.asarray([2, 2]))\n        -1\n        \"\"\"\n        s = sum(\n            self.optimum[n]\n            * self.classes[n]\n            * self.kernel(self.observations[n], observation)\n            for n in range(len(self.classes))\n        )\n        return 1 if s + self.offset >= 0 else -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/xgboost_classifier.py": "# XGBoost Classifier Example\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.metrics import ConfusionMatrixDisplay\nfrom sklearn.model_selection import train_test_split\nfrom xgboost import XGBClassifier\n\n\ndef data_handling(data: dict) -> tuple:\n    # Split dataset into features and target\n    # data is features\n    \"\"\"\n    >>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])}))\n    ('[5.1, 3.5, 1.4, 0.2]', [0])\n    >>> data_handling(\n    ...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])}\n    ... )\n    ('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])\n    \"\"\"\n    return (data[\"data\"], data[\"target\"])\n\n\ndef xgboost(features: np.ndarray, target: np.ndarray) -> XGBClassifier:\n    \"\"\"\n    # THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0]))\n    XGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,\n                  colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,\n                  early_stopping_rounds=None, enable_categorical=False,\n                  eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',\n                  importance_type=None, interaction_constraints='',\n                  learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,\n                  max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,\n                  missing=nan, monotone_constraints='()', n_estimators=100,\n                  n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,\n                  reg_alpha=0, reg_lambda=1, ...)\n    \"\"\"\n    classifier = XGBClassifier()\n    classifier.fit(features, target)\n    return classifier\n\n\ndef main() -> None:\n    \"\"\"\n    >>> main()\n\n    Url for the algorithm:\n    https://xgboost.readthedocs.io/en/stable/\n    Iris type dataset is used to demonstrate algorithm.\n    \"\"\"\n\n    # Load Iris dataset\n    iris = load_iris()\n    features, targets = data_handling(iris)\n    x_train, x_test, y_train, y_test = train_test_split(\n        features, targets, test_size=0.25\n    )\n\n    names = iris[\"target_names\"]\n\n    # Create an XGBoost Classifier from the training data\n    xgboost_classifier = xgboost(x_train, y_train)\n\n    # Display the confusion matrix of the classifier with both training and test sets\n    ConfusionMatrixDisplay.from_estimator(\n        xgboost_classifier,\n        x_test,\n        y_test,\n        display_labels=names,\n        cmap=\"Blues\",\n        normalize=\"true\",\n    )\n    plt.title(\"Normalized Confusion Matrix - IRIS Dataset\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod(verbose=True)\n    main()\n", "machine_learning/logistic_regression.py": "#!/usr/bin/python\n\n# Logistic Regression from scratch\n\n# In[62]:\n\n# In[63]:\n\n# importing all the required libraries\n\n\"\"\"\nImplementing logistic regression for classification problem\nHelpful resources:\nCoursera ML course\nhttps://medium.com/@martinpella/logistic-regression-from-scratch-in-python-124c5636b8ac\n\"\"\"\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom sklearn import datasets\n\n# get_ipython().run_line_magic('matplotlib', 'inline')\n\n\n# In[67]:\n\n# sigmoid function or logistic function is used as a hypothesis function in\n# classification problems\n\n\ndef sigmoid_function(z: float | np.ndarray) -> float | np.ndarray:\n    \"\"\"\n    Also known as Logistic Function.\n\n                1\n    f(x) =   -------\n              1 + e\u207b\u02e3\n\n    The sigmoid function approaches a value of 1 as its input 'x' becomes\n    increasing positive. Opposite for negative values.\n\n    Reference: https://en.wikipedia.org/wiki/Sigmoid_function\n\n    @param z:  input to the function\n    @returns: returns value in the range 0 to 1\n\n    Examples:\n    >>> sigmoid_function(4)\n    0.9820137900379085\n    >>> sigmoid_function(np.array([-3, 3]))\n    array([0.04742587, 0.95257413])\n    >>> sigmoid_function(np.array([-3, 3, 1]))\n    array([0.04742587, 0.95257413, 0.73105858])\n    >>> sigmoid_function(np.array([-0.01, -2, -1.9]))\n    array([0.49750002, 0.11920292, 0.13010847])\n    >>> sigmoid_function(np.array([-1.3, 5.3, 12]))\n    array([0.21416502, 0.9950332 , 0.99999386])\n    >>> sigmoid_function(np.array([0.01, 0.02, 4.1]))\n    array([0.50249998, 0.50499983, 0.9836975 ])\n    >>> sigmoid_function(np.array([0.8]))\n    array([0.68997448])\n    \"\"\"\n    return 1 / (1 + np.exp(-z))\n\n\ndef cost_function(h: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"\n    Cost function quantifies the error between predicted and expected values.\n    The cost function used in Logistic Regression is called Log Loss\n    or Cross Entropy Function.\n\n    J(\u03b8) = (1/m) * \u03a3 [ -y * log(h\u03b8(x)) - (1 - y) * log(1 - h\u03b8(x)) ]\n\n    Where:\n       - J(\u03b8) is the cost that we want to minimize during training\n       - m is the number of training examples\n       - \u03a3 represents the summation over all training examples\n       - y is the actual binary label (0 or 1) for a given example\n       - h\u03b8(x) is the predicted probability that x belongs to the positive class\n\n    @param h: the output of sigmoid function. It is the estimated probability\n    that the input example 'x' belongs to the positive class\n\n    @param y: the actual binary label associated with input example 'x'\n\n    Examples:\n    >>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 1]))\n    0.18937868932131605\n    >>> estimations = sigmoid_function(np.array([4, 3, 1]))\n    >>> cost_function(h=estimations,y=np.array([1, 0, 0]))\n    1.459999655669926\n    >>> estimations = sigmoid_function(np.array([4, -3, -1]))\n    >>> cost_function(h=estimations,y=np.array([1,0,0]))\n    0.1266663223365915\n    >>> estimations = sigmoid_function(0)\n    >>> cost_function(h=estimations,y=np.array([1]))\n    0.6931471805599453\n\n    References:\n       - https://en.wikipedia.org/wiki/Logistic_regression\n    \"\"\"\n    return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()\n\n\ndef log_likelihood(x, y, weights):\n    scores = np.dot(x, weights)\n    return np.sum(y * scores - np.log(1 + np.exp(scores)))\n\n\n# here alpha is the learning rate, X is the feature matrix,y is the target matrix\ndef logistic_reg(alpha, x, y, max_iterations=70000):\n    theta = np.zeros(x.shape[1])\n\n    for iterations in range(max_iterations):\n        z = np.dot(x, theta)\n        h = sigmoid_function(z)\n        gradient = np.dot(x.T, h - y) / y.size\n        theta = theta - alpha * gradient  # updating the weights\n        z = np.dot(x, theta)\n        h = sigmoid_function(z)\n        j = cost_function(h, y)\n        if iterations % 100 == 0:\n            print(f\"loss: {j} \\t\")  # printing the loss after every 100 iterations\n    return theta\n\n\n# In[68]:\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    iris = datasets.load_iris()\n    x = iris.data[:, :2]\n    y = (iris.target != 0) * 1\n\n    alpha = 0.1\n    theta = logistic_reg(alpha, x, y, max_iterations=70000)\n    print(\"theta: \", theta)  # printing the theta i.e our weights vector\n\n    def predict_prob(x):\n        return sigmoid_function(\n            np.dot(x, theta)\n        )  # predicting the value of probability from the logistic regression algorithm\n\n    plt.figure(figsize=(10, 6))\n    plt.scatter(x[y == 0][:, 0], x[y == 0][:, 1], color=\"b\", label=\"0\")\n    plt.scatter(x[y == 1][:, 0], x[y == 1][:, 1], color=\"r\", label=\"1\")\n    (x1_min, x1_max) = (x[:, 0].min(), x[:, 0].max())\n    (x2_min, x2_max) = (x[:, 1].min(), x[:, 1].max())\n    (xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))\n    grid = np.c_[xx1.ravel(), xx2.ravel()]\n    probs = predict_prob(grid).reshape(xx1.shape)\n    plt.contour(xx1, xx2, probs, [0.5], linewidths=1, colors=\"black\")\n\n    plt.legend()\n    plt.show()\n", "machine_learning/mfcc.py": "\"\"\"\nMel Frequency Cepstral Coefficients (MFCC) Calculation\n\nMFCC is an algorithm widely used in audio and speech processing to represent the\nshort-term power spectrum of a sound signal in a more compact and\ndiscriminative way. It is particularly popular in speech and audio processing\ntasks such as speech recognition and speaker identification.\n\nHow Mel Frequency Cepstral Coefficients are Calculated:\n1. Preprocessing:\n   - Load an audio signal and normalize it to ensure that the values fall\n     within a specific range (e.g., between -1 and 1).\n   - Frame the audio signal into overlapping, fixed-length segments, typically\n     using a technique like windowing to reduce spectral leakage.\n\n2. Fourier Transform:\n   - Apply a Fast Fourier Transform (FFT) to each audio frame to convert it\n     from the time domain to the frequency domain. This results in a\n     representation of the audio frame as a sequence of frequency components.\n\n3. Power Spectrum:\n   - Calculate the power spectrum by taking the squared magnitude of each\n     frequency component obtained from the FFT. This step measures the energy\n     distribution across different frequency bands.\n\n4. Mel Filterbank:\n   - Apply a set of triangular filterbanks spaced in the Mel frequency scale\n     to the power spectrum. These filters mimic the human auditory system's\n     frequency response. Each filterbank sums the power spectrum values within\n     its band.\n\n5. Logarithmic Compression:\n   - Take the logarithm (typically base 10) of the filterbank values to\n     compress the dynamic range. This step mimics the logarithmic response of\n     the human ear to sound intensity.\n\n6. Discrete Cosine Transform (DCT):\n   - Apply the Discrete Cosine Transform to the log filterbank energies to\n     obtain the MFCC coefficients. This transformation helps decorrelate the\n     filterbank energies and captures the most important features of the audio\n     signal.\n\n7. Feature Extraction:\n   - Select a subset of the DCT coefficients to form the feature vector.\n     Often, the first few coefficients (e.g., 12-13) are used for most\n     applications.\n\nReferences:\n- Mel-Frequency Cepstral Coefficients (MFCCs):\n  https://en.wikipedia.org/wiki/Mel-frequency_cepstrum\n- Speech and Language Processing by Daniel Jurafsky & James H. Martin:\n  https://web.stanford.edu/~jurafsky/slp3/\n- Mel Frequency Cepstral Coefficient (MFCC) tutorial\n  http://practicalcryptography.com/miscellaneous/machine-learning\n  /guide-mel-frequency-cepstral-coefficients-mfccs/\n\nAuthor: Amir Lavasani\n\"\"\"\n\nimport logging\n\nimport numpy as np\nimport scipy.fftpack as fft\nfrom scipy.signal import get_window\n\nlogging.basicConfig(filename=f\"{__file__}.log\", level=logging.INFO)\n\n\ndef mfcc(\n    audio: np.ndarray,\n    sample_rate: int,\n    ftt_size: int = 1024,\n    hop_length: int = 20,\n    mel_filter_num: int = 10,\n    dct_filter_num: int = 40,\n) -> np.ndarray:\n    \"\"\"\n    Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.\n\n    Args:\n        audio: The input audio signal.\n        sample_rate: The sample rate of the audio signal (in Hz).\n        ftt_size: The size of the FFT window (default is 1024).\n        hop_length: The hop length for frame creation (default is 20ms).\n        mel_filter_num: The number of Mel filters (default is 10).\n        dct_filter_num: The number of DCT filters (default is 40).\n\n    Returns:\n        A matrix of MFCCs for the input audio.\n\n    Raises:\n        ValueError: If the input audio is empty.\n\n    Example:\n    >>> sample_rate = 44100  # Sample rate of 44.1 kHz\n    >>> duration = 2.0  # Duration of 1 second\n    >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)\n    >>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave\n    >>> mfccs = mfcc(audio, sample_rate)\n    >>> mfccs.shape\n    (40, 101)\n    \"\"\"\n    logging.info(f\"Sample rate: {sample_rate}Hz\")\n    logging.info(f\"Audio duration: {len(audio) / sample_rate}s\")\n    logging.info(f\"Audio min: {np.min(audio)}\")\n    logging.info(f\"Audio max: {np.max(audio)}\")\n\n    # normalize audio\n    audio_normalized = normalize(audio)\n\n    logging.info(f\"Normalized audio min: {np.min(audio_normalized)}\")\n    logging.info(f\"Normalized audio max: {np.max(audio_normalized)}\")\n\n    # frame audio into\n    audio_framed = audio_frames(\n        audio_normalized, sample_rate, ftt_size=ftt_size, hop_length=hop_length\n    )\n\n    logging.info(f\"Framed audio shape: {audio_framed.shape}\")\n    logging.info(f\"First frame: {audio_framed[0]}\")\n\n    # convert to frequency domain\n    # For simplicity we will choose the Hanning window.\n    window = get_window(\"hann\", ftt_size, fftbins=True)\n    audio_windowed = audio_framed * window\n\n    logging.info(f\"Windowed audio shape: {audio_windowed.shape}\")\n    logging.info(f\"First frame: {audio_windowed[0]}\")\n\n    audio_fft = calculate_fft(audio_windowed, ftt_size)\n    logging.info(f\"fft audio shape: {audio_fft.shape}\")\n    logging.info(f\"First frame: {audio_fft[0]}\")\n\n    audio_power = calculate_signal_power(audio_fft)\n    logging.info(f\"power audio shape: {audio_power.shape}\")\n    logging.info(f\"First frame: {audio_power[0]}\")\n\n    filters = mel_spaced_filterbank(sample_rate, mel_filter_num, ftt_size)\n    logging.info(f\"filters shape: {filters.shape}\")\n\n    audio_filtered = np.dot(filters, np.transpose(audio_power))\n    audio_log = 10.0 * np.log10(audio_filtered)\n    logging.info(f\"audio_log shape: {audio_log.shape}\")\n\n    dct_filters = discrete_cosine_transform(dct_filter_num, mel_filter_num)\n    cepstral_coefficents = np.dot(dct_filters, audio_log)\n\n    logging.info(f\"cepstral_coefficents shape: {cepstral_coefficents.shape}\")\n    return cepstral_coefficents\n\n\ndef normalize(audio: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize an audio signal by scaling it to have values between -1 and 1.\n\n    Args:\n        audio: The input audio signal.\n\n    Returns:\n        The normalized audio signal.\n\n    Examples:\n    >>> audio = np.array([1, 2, 3, 4, 5])\n    >>> normalized_audio = normalize(audio)\n    >>> np.max(normalized_audio)\n    1.0\n    >>> np.min(normalized_audio)\n    0.2\n    \"\"\"\n    # Divide the entire audio signal by the maximum absolute value\n    return audio / np.max(np.abs(audio))\n\n\ndef audio_frames(\n    audio: np.ndarray,\n    sample_rate: int,\n    hop_length: int = 20,\n    ftt_size: int = 1024,\n) -> np.ndarray:\n    \"\"\"\n    Split an audio signal into overlapping frames.\n\n    Args:\n        audio: The input audio signal.\n        sample_rate: The sample rate of the audio signal.\n        hop_length: The length of the hopping (default is 20ms).\n        ftt_size: The size of the FFT window (default is 1024).\n\n    Returns:\n        An array of overlapping frames.\n\n    Examples:\n    >>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000)\n    >>> sample_rate = 8000\n    >>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512)\n    >>> frames.shape\n    (126, 512)\n    \"\"\"\n\n    hop_size = np.round(sample_rate * hop_length / 1000).astype(int)\n\n    # Pad the audio signal to handle edge cases\n    audio = np.pad(audio, int(ftt_size / 2), mode=\"reflect\")\n\n    # Calculate the number of frames\n    frame_count = int((len(audio) - ftt_size) / hop_size) + 1\n\n    # Initialize an array to store the frames\n    frames = np.zeros((frame_count, ftt_size))\n\n    # Split the audio signal into frames\n    for n in range(frame_count):\n        frames[n] = audio[n * hop_size : n * hop_size + ftt_size]\n\n    return frames\n\n\ndef calculate_fft(audio_windowed: np.ndarray, ftt_size: int = 1024) -> np.ndarray:\n    \"\"\"\n    Calculate the Fast Fourier Transform (FFT) of windowed audio data.\n\n    Args:\n        audio_windowed: The windowed audio signal.\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        The FFT of the audio data.\n\n    Examples:\n    >>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n    >>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)\n    >>> np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j, -1.5-0.8660254j]))\n    True\n    \"\"\"\n    # Transpose the audio data to have time in rows and channels in columns\n    audio_transposed = np.transpose(audio_windowed)\n\n    # Initialize an array to store the FFT results\n    audio_fft = np.empty(\n        (int(1 + ftt_size // 2), audio_transposed.shape[1]),\n        dtype=np.complex64,\n        order=\"F\",\n    )\n\n    # Compute FFT for each channel\n    for n in range(audio_fft.shape[1]):\n        audio_fft[:, n] = fft.fft(audio_transposed[:, n], axis=0)[: audio_fft.shape[0]]\n\n    # Transpose the FFT results back to the original shape\n    return np.transpose(audio_fft)\n\n\ndef calculate_signal_power(audio_fft: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculate the power of the audio signal from its FFT.\n\n    Args:\n        audio_fft: The FFT of the audio signal.\n\n    Returns:\n        The power of the audio signal.\n\n    Examples:\n    >>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])\n    >>> power = calculate_signal_power(audio_fft)\n    >>> np.allclose(power, np.array([5, 13, 25, 41]))\n    True\n    \"\"\"\n    # Calculate the power by squaring the absolute values of the FFT coefficients\n    return np.square(np.abs(audio_fft))\n\n\ndef freq_to_mel(freq: float) -> float:\n    \"\"\"\n    Convert a frequency in Hertz to the mel scale.\n\n    Args:\n        freq: The frequency in Hertz.\n\n    Returns:\n        The frequency in mel scale.\n\n    Examples:\n    >>> round(freq_to_mel(1000), 2)\n    999.99\n    \"\"\"\n    # Use the formula to convert frequency to the mel scale\n    return 2595.0 * np.log10(1.0 + freq / 700.0)\n\n\ndef mel_to_freq(mels: float) -> float:\n    \"\"\"\n    Convert a frequency in the mel scale to Hertz.\n\n    Args:\n        mels: The frequency in mel scale.\n\n    Returns:\n        The frequency in Hertz.\n\n    Examples:\n    >>> round(mel_to_freq(999.99), 2)\n    1000.01\n    \"\"\"\n    # Use the formula to convert mel scale to frequency\n    return 700.0 * (10.0 ** (mels / 2595.0) - 1.0)\n\n\ndef mel_spaced_filterbank(\n    sample_rate: int, mel_filter_num: int = 10, ftt_size: int = 1024\n) -> np.ndarray:\n    \"\"\"\n    Create a Mel-spaced filter bank for audio processing.\n\n    Args:\n        sample_rate: The sample rate of the audio.\n        mel_filter_num: The number of mel filters (default is 10).\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        Mel-spaced filter bank.\n\n    Examples:\n    >>> round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10)\n    0.0004603981\n    \"\"\"\n    freq_min = 0\n    freq_high = sample_rate // 2\n\n    logging.info(f\"Minimum frequency: {freq_min}\")\n    logging.info(f\"Maximum frequency: {freq_high}\")\n\n    # Calculate filter points and mel frequencies\n    filter_points, mel_freqs = get_filter_points(\n        sample_rate,\n        freq_min,\n        freq_high,\n        mel_filter_num,\n        ftt_size,\n    )\n\n    filters = get_filters(filter_points, ftt_size)\n\n    # normalize filters\n    # taken from the librosa library\n    enorm = 2.0 / (mel_freqs[2 : mel_filter_num + 2] - mel_freqs[:mel_filter_num])\n    return filters * enorm[:, np.newaxis]\n\n\ndef get_filters(filter_points: np.ndarray, ftt_size: int) -> np.ndarray:\n    \"\"\"\n    Generate filters for audio processing.\n\n    Args:\n        filter_points: A list of filter points.\n        ftt_size: The size of the FFT.\n\n    Returns:\n        A matrix of filters.\n\n    Examples:\n    >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape\n    (4, 257)\n    \"\"\"\n    num_filters = len(filter_points) - 2\n    filters = np.zeros((num_filters, int(ftt_size / 2) + 1))\n\n    for n in range(num_filters):\n        start = filter_points[n]\n        mid = filter_points[n + 1]\n        end = filter_points[n + 2]\n\n        # Linearly increase values from 0 to 1\n        filters[n, start:mid] = np.linspace(0, 1, mid - start)\n\n        # Linearly decrease values from 1 to 0\n        filters[n, mid:end] = np.linspace(1, 0, end - mid)\n\n    return filters\n\n\ndef get_filter_points(\n    sample_rate: int,\n    freq_min: int,\n    freq_high: int,\n    mel_filter_num: int = 10,\n    ftt_size: int = 1024,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculate the filter points and frequencies for mel frequency filters.\n\n    Args:\n        sample_rate: The sample rate of the audio.\n        freq_min: The minimum frequency in Hertz.\n        freq_high: The maximum frequency in Hertz.\n        mel_filter_num: The number of mel filters (default is 10).\n        ftt_size: The size of the FFT (default is 1024).\n\n    Returns:\n        Filter points and corresponding frequencies.\n\n    Examples:\n    >>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)\n    >>> filter_points[0]\n    array([  0,  20,  51,  95, 161, 256])\n    >>> filter_points[1]\n    array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,\n           2511.42581671, 4000.        ])\n    \"\"\"\n    # Convert minimum and maximum frequencies to mel scale\n    fmin_mel = freq_to_mel(freq_min)\n    fmax_mel = freq_to_mel(freq_high)\n\n    logging.info(f\"MEL min: {fmin_mel}\")\n    logging.info(f\"MEL max: {fmax_mel}\")\n\n    # Generate equally spaced mel frequencies\n    mels = np.linspace(fmin_mel, fmax_mel, num=mel_filter_num + 2)\n\n    # Convert mel frequencies back to Hertz\n    freqs = mel_to_freq(mels)\n\n    # Calculate filter points as integer values\n    filter_points = np.floor((ftt_size + 1) / sample_rate * freqs).astype(int)\n\n    return filter_points, freqs\n\n\ndef discrete_cosine_transform(dct_filter_num: int, filter_num: int) -> np.ndarray:\n    \"\"\"\n    Compute the Discrete Cosine Transform (DCT) basis matrix.\n\n    Args:\n        dct_filter_num: The number of DCT filters to generate.\n        filter_num: The number of the fbank filters.\n\n    Returns:\n        The DCT basis matrix.\n\n    Examples:\n    >>> round(discrete_cosine_transform(3, 5)[0][0], 5)\n    0.44721\n    \"\"\"\n    basis = np.empty((dct_filter_num, filter_num))\n    basis[0, :] = 1.0 / np.sqrt(filter_num)\n\n    samples = np.arange(1, 2 * filter_num, 2) * np.pi / (2.0 * filter_num)\n\n    for i in range(1, dct_filter_num):\n        basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / filter_num)\n\n    return basis\n\n\ndef example(wav_file_path: str = \"./path-to-file/sample.wav\") -> np.ndarray:\n    \"\"\"\n    Example function to calculate Mel Frequency Cepstral Coefficients\n    (MFCCs) from an audio file.\n\n    Args:\n        wav_file_path: The path to the WAV audio file.\n\n    Returns:\n        np.ndarray: The computed MFCCs for the audio.\n    \"\"\"\n    from scipy.io import wavfile\n\n    # Load the audio from the WAV file\n    sample_rate, audio = wavfile.read(wav_file_path)\n\n    # Calculate MFCCs\n    return mfcc(audio, sample_rate)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/scoring_functions.py": "import numpy as np\n\n\"\"\" Here I implemented the scoring functions.\n    MAE, MSE, RMSE, RMSLE are included.\n\n    Those are used for calculating differences between\n    predicted values and actual values.\n\n    Metrics are slightly differentiated. Sometimes squared, rooted,\n    even log is used.\n\n    Using log and roots can be perceived as tools for penalizing big\n    errors. However, using appropriate metrics depends on the situations,\n    and types of data\n\"\"\"\n\n\n# Mean Absolute Error\ndef mae(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> np.around(mae(predict,actual),decimals = 2)\n    0.67\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> mae(predict,actual)\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = abs(predict - actual)\n    score = difference.mean()\n\n    return score\n\n\n# Mean Squared Error\ndef mse(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> np.around(mse(predict,actual),decimals = 2)\n    1.33\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> mse(predict,actual)\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n\n    score = square_diff.mean()\n    return score\n\n\n# Root Mean Squared Error\ndef rmse(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [1,2,3];predict = [1,4,3]\n    >>> np.around(rmse(predict,actual),decimals = 2)\n    1.15\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> rmse(predict,actual)\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n    score = np.sqrt(mean_square_diff)\n    return score\n\n\n# Root Mean Square Logarithmic Error\ndef rmsle(predict, actual):\n    \"\"\"\n    Examples(rounded for precision):\n    >>> actual = [10,10,30];predict = [10,2,30]\n    >>> np.around(rmsle(predict,actual),decimals = 2)\n    0.75\n\n    >>> actual = [1,1,1];predict = [1,1,1]\n    >>> rmsle(predict,actual)\n    0.0\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    log_predict = np.log(predict + 1)\n    log_actual = np.log(actual + 1)\n\n    difference = log_predict - log_actual\n    square_diff = np.square(difference)\n    mean_square_diff = square_diff.mean()\n\n    score = np.sqrt(mean_square_diff)\n\n    return score\n\n\n# Mean Bias Deviation\ndef mbd(predict, actual):\n    \"\"\"\n    This value is Negative, if the model underpredicts,\n    positive, if it overpredicts.\n\n    Example(rounded for precision):\n\n    Here the model overpredicts\n    >>> actual = [1,2,3];predict = [2,3,4]\n    >>> np.around(mbd(predict,actual),decimals = 2)\n    50.0\n\n    Here the model underpredicts\n    >>> actual = [1,2,3];predict = [0,1,1]\n    >>> np.around(mbd(predict,actual),decimals = 2)\n    -66.67\n    \"\"\"\n    predict = np.array(predict)\n    actual = np.array(actual)\n\n    difference = predict - actual\n    numerator = np.sum(difference) / len(predict)\n    denumerator = np.sum(actual) / len(predict)\n    # print(numerator, denumerator)\n    score = float(numerator) / denumerator * 100\n\n    return score\n\n\ndef manual_accuracy(predict, actual):\n    return np.mean(np.array(actual) == np.array(predict))\n", "machine_learning/linear_regression.py": "\"\"\"\nLinear regression is the most basic type of regression commonly used for\npredictive analysis. The idea is pretty simple: we have a dataset and we have\nfeatures associated with it. Features should be chosen very cautiously\nas they determine how much our model will be able to make future predictions.\nWe try to set the weight of these features, over many iterations, so that they best\nfit our dataset. In this particular code, I had used a CSGO dataset (ADR vs\nRating). We try to best fit a line through dataset and estimate the parameters.\n\"\"\"\n\nimport numpy as np\nimport requests\n\n\ndef collect_dataset():\n    \"\"\"Collect dataset of CSGO\n    The dataset contains ADR vs Rating of a Player\n    :return : dataset obtained from the link, as matrix\n    \"\"\"\n    response = requests.get(\n        \"https://raw.githubusercontent.com/yashLadha/The_Math_of_Intelligence/\"\n        \"master/Week1/ADRvsRating.csv\",\n        timeout=10,\n    )\n    lines = response.text.splitlines()\n    data = []\n    for item in lines:\n        item = item.split(\",\")\n        data.append(item)\n    data.pop(0)  # This is for removing the labels from the list\n    dataset = np.matrix(data)\n    return dataset\n\n\ndef run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta):\n    \"\"\"Run steep gradient descent and updates the Feature vector accordingly_\n    :param data_x   : contains the dataset\n    :param data_y   : contains the output associated with each data-entry\n    :param len_data : length of the data_\n    :param alpha    : Learning rate of the model\n    :param theta    : Feature vector (weight's for our model)\n    ;param return    : Updated Feature's, using\n                       curr_features - alpha_ * gradient(w.r.t. feature)\n    \"\"\"\n    n = len_data\n\n    prod = np.dot(theta, data_x.transpose())\n    prod -= data_y.transpose()\n    sum_grad = np.dot(prod, data_x)\n    theta = theta - (alpha / n) * sum_grad\n    return theta\n\n\ndef sum_of_square_error(data_x, data_y, len_data, theta):\n    \"\"\"Return sum of square error for error calculation\n    :param data_x    : contains our dataset\n    :param data_y    : contains the output (result vector)\n    :param len_data  : len of the dataset\n    :param theta     : contains the feature vector\n    :return          : sum of square error computed from given feature's\n    \"\"\"\n    prod = np.dot(theta, data_x.transpose())\n    prod -= data_y.transpose()\n    sum_elem = np.sum(np.square(prod))\n    error = sum_elem / (2 * len_data)\n    return error\n\n\ndef run_linear_regression(data_x, data_y):\n    \"\"\"Implement Linear regression over the dataset\n    :param data_x  : contains our dataset\n    :param data_y  : contains the output (result vector)\n    :return        : feature for line of best fit (Feature vector)\n    \"\"\"\n    iterations = 100000\n    alpha = 0.0001550\n\n    no_features = data_x.shape[1]\n    len_data = data_x.shape[0] - 1\n\n    theta = np.zeros((1, no_features))\n\n    for i in range(iterations):\n        theta = run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta)\n        error = sum_of_square_error(data_x, data_y, len_data, theta)\n        print(f\"At Iteration {i + 1} - Error is {error:.5f}\")\n\n    return theta\n\n\ndef mean_absolute_error(predicted_y, original_y):\n    \"\"\"Return sum of square error for error calculation\n    :param predicted_y   : contains the output of prediction (result vector)\n    :param original_y    : contains values of expected outcome\n    :return          : mean absolute error computed from given feature's\n    \"\"\"\n    total = sum(abs(y - predicted_y[i]) for i, y in enumerate(original_y))\n    return total / len(original_y)\n\n\ndef main():\n    \"\"\"Driver function\"\"\"\n    data = collect_dataset()\n\n    len_data = data.shape[0]\n    data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float)\n    data_y = data[:, -1].astype(float)\n\n    theta = run_linear_regression(data_x, data_y)\n    len_result = theta.shape[1]\n    print(\"Resultant Feature vector : \")\n    for i in range(len_result):\n        print(f\"{theta[0, i]:.5f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "machine_learning/multilayer_perceptron_classifier.py": "from sklearn.neural_network import MLPClassifier\n\nX = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]\ny = [0, 1, 0, 0]\n\n\nclf = MLPClassifier(\n    solver=\"lbfgs\", alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=1\n)\n\nclf.fit(X, y)\n\n\ntest = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]\nY = clf.predict(test)\n\n\ndef wrapper(y):\n    \"\"\"\n    >>> wrapper(Y)\n    [0, 0, 1]\n    \"\"\"\n    return list(y)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/k_means_clust.py": "\"\"\"README, Author - Anurag Kumar(mailto:anuragkumarak95@gmail.com)\nRequirements:\n  - sklearn\n  - numpy\n  - matplotlib\nPython:\n  - 3.5\nInputs:\n  - X , a 2D numpy array of features.\n  - k , number of clusters to create.\n  - initial_centroids , initial centroid values generated by utility function(mentioned\n    in usage).\n  - maxiter , maximum number of iterations to process.\n  - heterogeneity , empty list that will be filled with heterogeneity values if passed\n    to kmeans func.\nUsage:\n  1. define 'k' value, 'X' features array and 'heterogeneity' empty list\n  2. create initial_centroids,\n        initial_centroids = get_initial_centroids(\n            X,\n            k,\n            seed=0 # seed value for initial centroid generation,\n                   # None for randomness(default=None)\n            )\n  3. find centroids and clusters using kmeans function.\n        centroids, cluster_assignment = kmeans(\n            X,\n            k,\n            initial_centroids,\n            maxiter=400,\n            record_heterogeneity=heterogeneity,\n            verbose=True # whether to print logs in console or not.(default=False)\n            )\n  4. Plot the loss function and heterogeneity values for every iteration saved in\n     heterogeneity list.\n        plot_heterogeneity(\n            heterogeneity,\n            k\n        )\n  5. Transfers Dataframe into excel format it must have feature called\n      'Clust' with k means clustering numbers in it.\n\"\"\"\n\nimport warnings\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.metrics import pairwise_distances\n\nwarnings.filterwarnings(\"ignore\")\n\nTAG = \"K-MEANS-CLUST/ \"\n\n\ndef get_initial_centroids(data, k, seed=None):\n    \"\"\"Randomly choose k data points as initial centroids\"\"\"\n    # useful for obtaining consistent results\n    rng = np.random.default_rng(seed)\n    n = data.shape[0]  # number of data points\n\n    # Pick K indices from range [0, N).\n    rand_indices = rng.integers(0, n, k)\n\n    # Keep centroids as dense format, as many entries will be nonzero due to averaging.\n    # As long as at least one document in a cluster contains a word,\n    # it will carry a nonzero weight in the TF-IDF vector of the centroid.\n    centroids = data[rand_indices, :]\n\n    return centroids\n\n\ndef centroid_pairwise_dist(x, centroids):\n    return pairwise_distances(x, centroids, metric=\"euclidean\")\n\n\ndef assign_clusters(data, centroids):\n    # Compute distances between each data point and the set of centroids:\n    # Fill in the blank (RHS only)\n    distances_from_centroids = centroid_pairwise_dist(data, centroids)\n\n    # Compute cluster assignments for each data point:\n    # Fill in the blank (RHS only)\n    cluster_assignment = np.argmin(distances_from_centroids, axis=1)\n\n    return cluster_assignment\n\n\ndef revise_centroids(data, k, cluster_assignment):\n    new_centroids = []\n    for i in range(k):\n        # Select all data points that belong to cluster i. Fill in the blank (RHS only)\n        member_data_points = data[cluster_assignment == i]\n        # Compute the mean of the data points. Fill in the blank (RHS only)\n        centroid = member_data_points.mean(axis=0)\n        new_centroids.append(centroid)\n    new_centroids = np.array(new_centroids)\n\n    return new_centroids\n\n\ndef compute_heterogeneity(data, k, centroids, cluster_assignment):\n    heterogeneity = 0.0\n    for i in range(k):\n        # Select all data points that belong to cluster i. Fill in the blank (RHS only)\n        member_data_points = data[cluster_assignment == i, :]\n\n        if member_data_points.shape[0] > 0:  # check if i-th cluster is non-empty\n            # Compute distances from centroid to data points (RHS only)\n            distances = pairwise_distances(\n                member_data_points, [centroids[i]], metric=\"euclidean\"\n            )\n            squared_distances = distances**2\n            heterogeneity += np.sum(squared_distances)\n\n    return heterogeneity\n\n\ndef plot_heterogeneity(heterogeneity, k):\n    plt.figure(figsize=(7, 4))\n    plt.plot(heterogeneity, linewidth=4)\n    plt.xlabel(\"# Iterations\")\n    plt.ylabel(\"Heterogeneity\")\n    plt.title(f\"Heterogeneity of clustering over time, K={k:d}\")\n    plt.rcParams.update({\"font.size\": 16})\n    plt.show()\n\n\ndef kmeans(\n    data, k, initial_centroids, maxiter=500, record_heterogeneity=None, verbose=False\n):\n    \"\"\"Runs k-means on given data and initial set of centroids.\n    maxiter: maximum number of iterations to run.(default=500)\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\n                          as function of iterations\n                          if None, do not store the history.\n    verbose: if True, print how many data points changed their cluster labels in\n                          each iteration\"\"\"\n    centroids = initial_centroids[:]\n    prev_cluster_assignment = None\n\n    for itr in range(maxiter):\n        if verbose:\n            print(itr, end=\"\")\n\n        # 1. Make cluster assignments using nearest centroids\n        cluster_assignment = assign_clusters(data, centroids)\n\n        # 2. Compute a new centroid for each of the k clusters, averaging all data\n        #    points assigned to that cluster.\n        centroids = revise_centroids(data, k, cluster_assignment)\n\n        # Check for convergence: if none of the assignments changed, stop\n        if (\n            prev_cluster_assignment is not None\n            and (prev_cluster_assignment == cluster_assignment).all()\n        ):\n            break\n\n        # Print number of new assignments\n        if prev_cluster_assignment is not None:\n            num_changed = np.sum(prev_cluster_assignment != cluster_assignment)\n            if verbose:\n                print(\n                    f\"    {num_changed:5d} elements changed their cluster assignment.\"\n                )\n\n        # Record heterogeneity convergence metric\n        if record_heterogeneity is not None:\n            # YOUR CODE HERE\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\n            record_heterogeneity.append(score)\n\n        prev_cluster_assignment = cluster_assignment[:]\n\n    return centroids, cluster_assignment\n\n\n# Mock test below\nif False:  # change to true to run this test case.\n    from sklearn import datasets as ds\n\n    dataset = ds.load_iris()\n    k = 3\n    heterogeneity = []\n    initial_centroids = get_initial_centroids(dataset[\"data\"], k, seed=0)\n    centroids, cluster_assignment = kmeans(\n        dataset[\"data\"],\n        k,\n        initial_centroids,\n        maxiter=400,\n        record_heterogeneity=heterogeneity,\n        verbose=True,\n    )\n    plot_heterogeneity(heterogeneity, k)\n\n\ndef report_generator(\n    predicted: pd.DataFrame, clustering_variables: np.ndarray, fill_missing_report=None\n) -> pd.DataFrame:\n    \"\"\"\n    Generate a clustering report given these two arguments:\n        predicted - dataframe with predicted cluster column\n        fill_missing_report - dictionary of rules on how we are going to fill in missing\n        values for final generated report (not included in modelling);\n    >>> predicted = pd.DataFrame()\n    >>> predicted['numbers'] = [1, 2, 3]\n    >>> predicted['col1'] = [0.5, 2.5, 4.5]\n    >>> predicted['col2'] = [100, 200, 300]\n    >>> predicted['col3'] = [10, 20, 30]\n    >>> predicted['Cluster'] = [1, 1, 2]\n    >>> report_generator(predicted, ['col1', 'col2'], 0)\n               Features               Type   Mark           1           2\n    0    # of Customers        ClusterSize  False    2.000000    1.000000\n    1    % of Customers  ClusterProportion  False    0.666667    0.333333\n    2              col1    mean_with_zeros   True    1.500000    4.500000\n    3              col2    mean_with_zeros   True  150.000000  300.000000\n    4           numbers    mean_with_zeros  False    1.500000    3.000000\n    ..              ...                ...    ...         ...         ...\n    99            dummy                 5%  False    1.000000    1.000000\n    100           dummy                95%  False    1.000000    1.000000\n    101           dummy              stdev  False    0.000000         NaN\n    102           dummy               mode  False    1.000000    1.000000\n    103           dummy             median  False    1.000000    1.000000\n    <BLANKLINE>\n    [104 rows x 5 columns]\n    \"\"\"\n    # Fill missing values with given rules\n    if fill_missing_report:\n        predicted = predicted.fillna(value=fill_missing_report)\n    predicted[\"dummy\"] = 1\n    numeric_cols = predicted.select_dtypes(np.number).columns\n    report = (\n        predicted.groupby([\"Cluster\"])[  # construct report dataframe\n            numeric_cols\n        ]  # group by cluster number\n        .agg(\n            [\n                (\"sum\", \"sum\"),\n                (\"mean_with_zeros\", lambda x: np.mean(np.nan_to_num(x))),\n                (\"mean_without_zeros\", lambda x: x.replace(0, np.nan).mean()),\n                (\n                    \"mean_25-75\",\n                    lambda x: np.mean(\n                        np.nan_to_num(\n                            sorted(x)[\n                                round(len(x) * 25 / 100) : round(len(x) * 75 / 100)\n                            ]\n                        )\n                    ),\n                ),\n                (\"mean_with_na\", \"mean\"),\n                (\"min\", lambda x: x.min()),\n                (\"5%\", lambda x: x.quantile(0.05)),\n                (\"25%\", lambda x: x.quantile(0.25)),\n                (\"50%\", lambda x: x.quantile(0.50)),\n                (\"75%\", lambda x: x.quantile(0.75)),\n                (\"95%\", lambda x: x.quantile(0.95)),\n                (\"max\", lambda x: x.max()),\n                (\"count\", lambda x: x.count()),\n                (\"stdev\", lambda x: x.std()),\n                (\"mode\", lambda x: x.mode()[0]),\n                (\"median\", lambda x: x.median()),\n                (\"# > 0\", lambda x: (x > 0).sum()),\n            ]\n        )\n        .T.reset_index()\n        .rename(index=str, columns={\"level_0\": \"Features\", \"level_1\": \"Type\"})\n    )  # rename columns\n    # calculate the size of cluster(count of clientID's)\n    # avoid SettingWithCopyWarning\n    clustersize = report[\n        (report[\"Features\"] == \"dummy\") & (report[\"Type\"] == \"count\")\n    ].copy()\n    # rename created predicted cluster to match report column names\n    clustersize.Type = \"ClusterSize\"\n    clustersize.Features = \"# of Customers\"\n    # calculating the proportion of cluster\n    clusterproportion = pd.DataFrame(\n        clustersize.iloc[:, 2:].to_numpy() / clustersize.iloc[:, 2:].to_numpy().sum()\n    )\n    # rename created predicted cluster to match report column names\n    clusterproportion[\"Type\"] = \"% of Customers\"\n    clusterproportion[\"Features\"] = \"ClusterProportion\"\n    cols = clusterproportion.columns.tolist()\n    cols = cols[-2:] + cols[:-2]\n    clusterproportion = clusterproportion[cols]  # rearrange columns to match report\n    clusterproportion.columns = report.columns\n    # generating dataframe with count of nan values\n    a = pd.DataFrame(\n        abs(\n            report[report[\"Type\"] == \"count\"].iloc[:, 2:].to_numpy()\n            - clustersize.iloc[:, 2:].to_numpy()\n        )\n    )\n    a[\"Features\"] = 0\n    a[\"Type\"] = \"# of nan\"\n    # filling values in order to match report\n    a.Features = report[report[\"Type\"] == \"count\"].Features.tolist()\n    cols = a.columns.tolist()\n    cols = cols[-2:] + cols[:-2]\n    a = a[cols]  # rearrange columns to match report\n    a.columns = report.columns  # rename columns to match report\n    # drop count values except for cluster size\n    report = report.drop(report[report.Type == \"count\"].index)\n    # concat report with cluster size and nan values\n    report = pd.concat([report, a, clustersize, clusterproportion], axis=0)\n    report[\"Mark\"] = report[\"Features\"].isin(clustering_variables)\n    cols = report.columns.tolist()\n    cols = cols[0:2] + cols[-1:] + cols[2:-1]\n    report = report[cols]\n    sorter1 = {\n        \"ClusterSize\": 9,\n        \"ClusterProportion\": 8,\n        \"mean_with_zeros\": 7,\n        \"mean_with_na\": 6,\n        \"max\": 5,\n        \"50%\": 4,\n        \"min\": 3,\n        \"25%\": 2,\n        \"75%\": 1,\n        \"# of nan\": 0,\n        \"# > 0\": -1,\n        \"sum_with_na\": -2,\n    }\n    report = (\n        report.assign(\n            Sorter1=lambda x: x.Type.map(sorter1),\n            Sorter2=lambda x: list(reversed(range(len(x)))),\n        )\n        .sort_values([\"Sorter1\", \"Mark\", \"Sorter2\"], ascending=False)\n        .drop([\"Sorter1\", \"Sorter2\"], axis=1)\n    )\n    report.columns.name = \"\"\n    report = report.reset_index()\n    report = report.drop(columns=[\"index\"])\n    return report\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/word_frequency_functions.py": "import string\nfrom math import log10\n\n\"\"\"\n    tf-idf Wikipedia: https://en.wikipedia.org/wiki/Tf%E2%80%93idf\n    tf-idf and other word frequency algorithms are often used\n    as a weighting factor in information retrieval and text\n    mining. 83% of text-based recommender systems use\n    tf-idf for term weighting. In Layman's terms, tf-idf\n    is a statistic intended to reflect how important a word\n    is to a document in a corpus (a collection of documents)\n\n\n    Here I've implemented several word frequency algorithms\n    that are commonly used in information retrieval: Term Frequency,\n    Document Frequency, and TF-IDF (Term-Frequency*Inverse-Document-Frequency)\n    are included.\n\n    Term Frequency is a statistical function that\n    returns a number representing how frequently\n    an expression occurs in a document. This\n    indicates how significant a particular term is in\n    a given document.\n\n    Document Frequency is a statistical function that returns\n    an integer representing the number of documents in a\n    corpus that a term occurs in (where the max number returned\n    would be the number of documents in the corpus).\n\n    Inverse Document Frequency is mathematically written as\n    log10(N/df), where N is the number of documents in your\n    corpus and df is the Document Frequency. If df is 0, a\n    ZeroDivisionError will be thrown.\n\n    Term-Frequency*Inverse-Document-Frequency is a measure\n    of the originality of a term. It is mathematically written\n    as tf*log10(N/df). It compares the number of times\n    a term appears in a document with the number of documents\n    the term appears in. If df is 0, a ZeroDivisionError will be thrown.\n\"\"\"\n\n\ndef term_frequency(term: str, document: str) -> int:\n    \"\"\"\n    Return the number of times a term occurs within\n    a given document.\n    @params: term, the term to search a document for, and document,\n            the document to search within\n    @returns: an integer representing the number of times a term is\n            found within the document\n\n    @examples:\n    >>> term_frequency(\"to\", \"To be, or not to be\")\n    2\n    \"\"\"\n    # strip all punctuation and newlines and replace it with ''\n    document_without_punctuation = document.translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    ).replace(\"\\n\", \"\")\n    tokenize_document = document_without_punctuation.split(\" \")  # word tokenization\n    return len([word for word in tokenize_document if word.lower() == term.lower()])\n\n\ndef document_frequency(term: str, corpus: str) -> tuple[int, int]:\n    \"\"\"\n    Calculate the number of documents in a corpus that contain a\n    given term\n    @params : term, the term to search each document for, and corpus, a collection of\n             documents. Each document should be separated by a newline.\n    @returns : the number of documents in the corpus that contain the term you are\n               searching for and the number of documents in the corpus\n    @examples :\n    >>> document_frequency(\"first\", \"This is the first document in the corpus.\\\\nThIs\\\nis the second document in the corpus.\\\\nTHIS is \\\nthe third document in the corpus.\")\n    (1, 3)\n    \"\"\"\n    corpus_without_punctuation = corpus.lower().translate(\n        str.maketrans(\"\", \"\", string.punctuation)\n    )  # strip all punctuation and replace it with ''\n    docs = corpus_without_punctuation.split(\"\\n\")\n    term = term.lower()\n    return (len([doc for doc in docs if term in doc]), len(docs))\n\n\ndef inverse_document_frequency(df: int, n: int, smoothing=False) -> float:\n    \"\"\"\n    Return an integer denoting the importance\n    of a word. This measure of importance is\n    calculated by log10(N/df), where N is the\n    number of documents and df is\n    the Document Frequency.\n    @params : df, the Document Frequency, N,\n    the number of documents in the corpus and\n    smoothing, if True return the idf-smooth\n    @returns : log10(N/df) or 1+log10(N/1+df)\n    @examples :\n    >>> inverse_document_frequency(3, 0)\n    Traceback (most recent call last):\n     ...\n    ValueError: log10(0) is undefined.\n    >>> inverse_document_frequency(1, 3)\n    0.477\n    >>> inverse_document_frequency(0, 3)\n    Traceback (most recent call last):\n     ...\n    ZeroDivisionError: df must be > 0\n    >>> inverse_document_frequency(0, 3,True)\n    1.477\n    \"\"\"\n    if smoothing:\n        if n == 0:\n            raise ValueError(\"log10(0) is undefined.\")\n        return round(1 + log10(n / (1 + df)), 3)\n\n    if df == 0:\n        raise ZeroDivisionError(\"df must be > 0\")\n    elif n == 0:\n        raise ValueError(\"log10(0) is undefined.\")\n    return round(log10(n / df), 3)\n\n\ndef tf_idf(tf: int, idf: int) -> float:\n    \"\"\"\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    'originality' is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    >>> tf_idf(2, 0.477)\n    0.954\n    \"\"\"\n    return round(tf * idf, 3)\n", "machine_learning/self_organizing_map.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Self-organizing_map\n\"\"\"\n\nimport math\n\n\nclass SelfOrganizingMap:\n    def get_winner(self, weights: list[list[float]], sample: list[int]) -> int:\n        \"\"\"\n        Compute the winning vector by Euclidean distance\n\n        >>> SelfOrganizingMap().get_winner([[1, 2, 3], [4, 5, 6]], [1, 2, 3])\n        1\n        \"\"\"\n        d0 = 0.0\n        d1 = 0.0\n        for i in range(len(sample)):\n            d0 += math.pow((sample[i] - weights[0][i]), 2)\n            d1 += math.pow((sample[i] - weights[1][i]), 2)\n            return 0 if d0 > d1 else 1\n        return 0\n\n    def update(\n        self, weights: list[list[int | float]], sample: list[int], j: int, alpha: float\n    ) -> list[list[int | float]]:\n        \"\"\"\n        Update the winning vector.\n\n        >>> SelfOrganizingMap().update([[1, 2, 3], [4, 5, 6]], [1, 2, 3], 1, 0.1)\n        [[1, 2, 3], [3.7, 4.7, 6]]\n        \"\"\"\n        for i in range(len(weights)):\n            weights[j][i] += alpha * (sample[i] - weights[j][i])\n        return weights\n\n\n# Driver code\ndef main() -> None:\n    # Training Examples ( m, n )\n    training_samples = [[1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1]]\n\n    # weight initialization ( n, C )\n    weights = [[0.2, 0.6, 0.5, 0.9], [0.8, 0.4, 0.7, 0.3]]\n\n    # training\n    self_organizing_map = SelfOrganizingMap()\n    epochs = 3\n    alpha = 0.5\n\n    for _ in range(epochs):\n        for j in range(len(training_samples)):\n            # training sample\n            sample = training_samples[j]\n\n            # Compute the winning vector\n            winner = self_organizing_map.get_winner(weights, sample)\n\n            # Update the winning vector\n            weights = self_organizing_map.update(weights, sample, winner, alpha)\n\n    # classify test sample\n    sample = [0, 0, 0, 1]\n    winner = self_organizing_map.get_winner(weights, sample)\n\n    # results\n    print(f\"Clusters that the test sample belongs to : {winner}\")\n    print(f\"Weights that have been trained : {weights}\")\n\n\n# running the main() function\nif __name__ == \"__main__\":\n    main()\n", "machine_learning/decision_tree.py": "\"\"\"\nImplementation of a basic regression decision tree.\nInput data set: The input data set must be 1-dimensional with continuous labels.\nOutput: The decision tree maps a real number input to a real number output.\n\"\"\"\n\nimport numpy as np\n\n\nclass DecisionTree:\n    def __init__(self, depth=5, min_leaf_size=5):\n        self.depth = depth\n        self.decision_boundary = 0\n        self.left = None\n        self.right = None\n        self.min_leaf_size = min_leaf_size\n        self.prediction = None\n\n    def mean_squared_error(self, labels, prediction):\n        \"\"\"\n        mean_squared_error:\n        @param labels: a one-dimensional numpy array\n        @param prediction: a floating point value\n        return value: mean_squared_error calculates the error if prediction is used to\n            estimate the labels\n        >>> tester = DecisionTree()\n        >>> test_labels = np.array([1,2,3,4,5,6,7,8,9,10])\n        >>> test_prediction = float(6)\n        >>> tester.mean_squared_error(test_labels, test_prediction) == (\n        ...     TestDecisionTree.helper_mean_squared_error_test(test_labels,\n        ...         test_prediction))\n        True\n        >>> test_labels = np.array([1,2,3])\n        >>> test_prediction = float(2)\n        >>> tester.mean_squared_error(test_labels, test_prediction) == (\n        ...     TestDecisionTree.helper_mean_squared_error_test(test_labels,\n        ...         test_prediction))\n        True\n        \"\"\"\n        if labels.ndim != 1:\n            print(\"Error: Input labels must be one dimensional\")\n\n        return np.mean((labels - prediction) ** 2)\n\n    def train(self, x, y):\n        \"\"\"\n        train:\n        @param x: a one-dimensional numpy array\n        @param y: a one-dimensional numpy array.\n        The contents of y are the labels for the corresponding X values\n\n        train() does not have a return value\n\n        Examples:\n        1. Try to train when x & y are of same length & 1 dimensions (No errors)\n        >>> dt = DecisionTree()\n        >>> dt.train(np.array([10,20,30,40,50]),np.array([0,0,0,1,1]))\n\n        2. Try to train when x is 2 dimensions\n        >>> dt = DecisionTree()\n        >>> dt.train(np.array([[1,2,3,4,5],[1,2,3,4,5]]),np.array([0,0,0,1,1]))\n        Traceback (most recent call last):\n            ...\n        ValueError: Input data set must be one-dimensional\n\n        3. Try to train when x and y are not of the same length\n        >>> dt = DecisionTree()\n        >>> dt.train(np.array([1,2,3,4,5]),np.array([[0,0,0,1,1],[0,0,0,1,1]]))\n        Traceback (most recent call last):\n            ...\n        ValueError: x and y have different lengths\n\n        4. Try to train when x & y are of the same length but different dimensions\n        >>> dt = DecisionTree()\n        >>> dt.train(np.array([1,2,3,4,5]),np.array([[1],[2],[3],[4],[5]]))\n        Traceback (most recent call last):\n            ...\n        ValueError: Data set labels must be one-dimensional\n\n        This section is to check that the inputs conform to our dimensionality\n        constraints\n        \"\"\"\n        if x.ndim != 1:\n            raise ValueError(\"Input data set must be one-dimensional\")\n        if len(x) != len(y):\n            raise ValueError(\"x and y have different lengths\")\n        if y.ndim != 1:\n            raise ValueError(\"Data set labels must be one-dimensional\")\n\n        if len(x) < 2 * self.min_leaf_size:\n            self.prediction = np.mean(y)\n            return\n\n        if self.depth == 1:\n            self.prediction = np.mean(y)\n            return\n\n        best_split = 0\n        min_error = self.mean_squared_error(x, np.mean(y)) * 2\n\n        \"\"\"\n        loop over all possible splits for the decision tree. find the best split.\n        if no split exists that is less than 2 * error for the entire array\n        then the data set is not split and the average for the entire array is used as\n        the predictor\n        \"\"\"\n        for i in range(len(x)):\n            if len(x[:i]) < self.min_leaf_size:  # noqa: SIM114\n                continue\n            elif len(x[i:]) < self.min_leaf_size:\n                continue\n            else:\n                error_left = self.mean_squared_error(x[:i], np.mean(y[:i]))\n                error_right = self.mean_squared_error(x[i:], np.mean(y[i:]))\n                error = error_left + error_right\n                if error < min_error:\n                    best_split = i\n                    min_error = error\n\n        if best_split != 0:\n            left_x = x[:best_split]\n            left_y = y[:best_split]\n            right_x = x[best_split:]\n            right_y = y[best_split:]\n\n            self.decision_boundary = x[best_split]\n            self.left = DecisionTree(\n                depth=self.depth - 1, min_leaf_size=self.min_leaf_size\n            )\n            self.right = DecisionTree(\n                depth=self.depth - 1, min_leaf_size=self.min_leaf_size\n            )\n            self.left.train(left_x, left_y)\n            self.right.train(right_x, right_y)\n        else:\n            self.prediction = np.mean(y)\n\n        return\n\n    def predict(self, x):\n        \"\"\"\n        predict:\n        @param x: a floating point value to predict the label of\n        the prediction function works by recursively calling the predict function\n        of the appropriate subtrees based on the tree's decision boundary\n        \"\"\"\n        if self.prediction is not None:\n            return self.prediction\n        elif self.left or self.right is not None:\n            if x >= self.decision_boundary:\n                return self.right.predict(x)\n            else:\n                return self.left.predict(x)\n        else:\n            print(\"Error: Decision tree not yet trained\")\n            return None\n\n\nclass TestDecisionTree:\n    \"\"\"Decision Tres test class\"\"\"\n\n    @staticmethod\n    def helper_mean_squared_error_test(labels, prediction):\n        \"\"\"\n        helper_mean_squared_error_test:\n        @param labels: a one dimensional numpy array\n        @param prediction: a floating point value\n        return value: helper_mean_squared_error_test calculates the mean squared error\n        \"\"\"\n        squared_error_sum = float(0)\n        for label in labels:\n            squared_error_sum += (label - prediction) ** 2\n\n        return float(squared_error_sum / labels.size)\n\n\ndef main():\n    \"\"\"\n    In this demonstration we're generating a sample data set from the sin function in\n    numpy.  We then train a decision tree on the data set and use the decision tree to\n    predict the label of 10 different test values. Then the mean squared error over\n    this test is displayed.\n    \"\"\"\n    x = np.arange(-1.0, 1.0, 0.005)\n    y = np.sin(x)\n\n    tree = DecisionTree(depth=10, min_leaf_size=10)\n    tree.train(x, y)\n\n    rng = np.random.default_rng()\n    test_cases = (rng.random(10) * 2) - 1\n    predictions = np.array([tree.predict(x) for x in test_cases])\n    avg_error = np.mean((predictions - test_cases) ** 2)\n\n    print(\"Test values: \" + str(test_cases))\n    print(\"Predictions: \" + str(predictions))\n    print(\"Average error: \" + str(avg_error))\n\n\nif __name__ == \"__main__\":\n    main()\n    import doctest\n\n    doctest.testmod(name=\"mean_squarred_error\", verbose=True)\n", "machine_learning/frequent_pattern_growth.py": "\"\"\"\nThe Frequent Pattern Growth algorithm (FP-Growth) is a widely used data mining\ntechnique for discovering frequent itemsets in large transaction databases.\n\nIt overcomes some of the limitations of traditional methods such as Apriori by\nefficiently constructing the FP-Tree\n\nWIKI: https://athena.ecs.csus.edu/~mei/associationcw/FpGrowth.html\n\nExamples: https://www.javatpoint.com/fp-growth-algorithm-in-data-mining\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass TreeNode:\n    \"\"\"\n    A node in a Frequent Pattern tree.\n\n    Args:\n        name: The name of this node.\n        num_occur: The number of occurrences of the node.\n        parent_node: The parent node.\n\n    Example:\n    >>> parent = TreeNode(\"Parent\", 1, None)\n    >>> child = TreeNode(\"Child\", 2, parent)\n    >>> child.name\n    'Child'\n    >>> child.count\n    2\n    \"\"\"\n\n    name: str\n    count: int\n    parent: TreeNode | None = None\n    children: dict[str, TreeNode] = field(default_factory=dict)\n    node_link: TreeNode | None = None\n\n    def __repr__(self) -> str:\n        return f\"TreeNode({self.name!r}, {self.count!r}, {self.parent!r})\"\n\n    def inc(self, num_occur: int) -> None:\n        self.count += num_occur\n\n    def disp(self, ind: int = 1) -> None:\n        print(f\"{'  ' * ind} {self.name}  {self.count}\")\n        for child in self.children.values():\n            child.disp(ind + 1)\n\n\ndef create_tree(data_set: list, min_sup: int = 1) -> tuple[TreeNode, dict]:\n    \"\"\"\n    Create Frequent Pattern tree\n\n    Args:\n        data_set: A list of transactions, where each transaction is a list of items.\n        min_sup: The minimum support threshold.\n        Items with support less than this will be pruned. Default is 1.\n\n    Returns:\n        The root of the FP-Tree.\n        header_table: The header table dictionary with item information.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> len(header_table)\n    4\n    >>> header_table[\"A\"]\n    [[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))]\n    >>> header_table[\"E\"][1]  # doctest: +NORMALIZE_WHITESPACE\n    TreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None))))\n    >>> sorted(header_table)\n    ['A', 'B', 'C', 'E']\n    >>> fp_tree.name\n    'Null Set'\n    >>> sorted(fp_tree.children)\n    ['A', 'B']\n    >>> fp_tree.children['A'].name\n    'A'\n    >>> sorted(fp_tree.children['A'].children)\n    ['B', 'C']\n    \"\"\"\n    header_table: dict = {}\n    for trans in data_set:\n        for item in trans:\n            header_table[item] = header_table.get(item, [0, None])\n            header_table[item][0] += 1\n\n    for k in list(header_table):\n        if header_table[k][0] < min_sup:\n            del header_table[k]\n\n    if not (freq_item_set := set(header_table)):\n        return TreeNode(\"Null Set\", 1, None), {}\n\n    for k in header_table:\n        header_table[k] = [header_table[k], None]\n\n    fp_tree = TreeNode(\"Null Set\", 1, None)  # Parent is None for the root node\n    for tran_set in data_set:\n        local_d = {\n            item: header_table[item][0] for item in tran_set if item in freq_item_set\n        }\n        if local_d:\n            sorted_items = sorted(\n                local_d.items(), key=lambda item_info: item_info[1], reverse=True\n            )\n            ordered_items = [item[0] for item in sorted_items]\n            update_tree(ordered_items, fp_tree, header_table, 1)\n\n    return fp_tree, header_table\n\n\ndef update_tree(items: list, in_tree: TreeNode, header_table: dict, count: int) -> None:\n    \"\"\"\n    Update the FP-Tree with a transaction.\n\n    Args:\n        items: List of items in the transaction.\n        in_tree: The current node in the FP-Tree.\n        header_table: The header table dictionary with item information.\n        count: The count of the transaction.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> transaction = ['A', 'B', 'E']\n    >>> update_tree(transaction, fp_tree, header_table, 1)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> fp_tree.children['A'].children['B'].children['E'].children\n    {}\n    >>> fp_tree.children['A'].children['B'].children['E'].count\n    2\n    >>> header_table['E'][1].name\n    'E'\n    \"\"\"\n    if items[0] in in_tree.children:\n        in_tree.children[items[0]].inc(count)\n    else:\n        in_tree.children[items[0]] = TreeNode(items[0], count, in_tree)\n        if header_table[items[0]][1] is None:\n            header_table[items[0]][1] = in_tree.children[items[0]]\n        else:\n            update_header(header_table[items[0]][1], in_tree.children[items[0]])\n    if len(items) > 1:\n        update_tree(items[1:], in_tree.children[items[0]], header_table, count)\n\n\ndef update_header(node_to_test: TreeNode, target_node: TreeNode) -> TreeNode:\n    \"\"\"\n    Update the header table with a node link.\n\n    Args:\n        node_to_test: The node to be updated in the header table.\n        target_node: The node to link to.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> node1 = TreeNode(\"A\", 3, None)\n    >>> node2 = TreeNode(\"B\", 4, None)\n    >>> node1\n    TreeNode('A', 3, None)\n    >>> node1 = update_header(node1, node2)\n    >>> node1\n    TreeNode('A', 3, None)\n    >>> node1.node_link\n    TreeNode('B', 4, None)\n    >>> node2.node_link is None\n    True\n    \"\"\"\n    while node_to_test.node_link is not None:\n        node_to_test = node_to_test.node_link\n    if node_to_test.node_link is None:\n        node_to_test.node_link = target_node\n    # Return the updated node\n    return node_to_test\n\n\ndef ascend_tree(leaf_node: TreeNode, prefix_path: list[str]) -> None:\n    \"\"\"\n    Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix\n    path.\n\n    Args:\n        leaf_node: The leaf node to start ascending from.\n        prefix_path: A list to store the item as they are ascended.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n\n    >>> path = []\n    >>> ascend_tree(fp_tree.children['A'], path)\n    >>> path # ascending from a leaf node 'A'\n    ['A']\n    \"\"\"\n    if leaf_node.parent is not None:\n        prefix_path.append(leaf_node.name)\n        ascend_tree(leaf_node.parent, prefix_path)\n\n\ndef find_prefix_path(base_pat: frozenset, tree_node: TreeNode | None) -> dict:  # noqa: ARG001\n    \"\"\"\n    Find the conditional pattern base for a given base pattern.\n\n    Args:\n        base_pat: The base pattern for which to find the conditional pattern base.\n        tree_node: The node in the FP-Tree.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> len(header_table)\n    4\n    >>> base_pattern = frozenset(['A'])\n    >>> sorted(find_prefix_path(base_pattern, fp_tree.children['A']))\n    []\n    \"\"\"\n    cond_pats: dict = {}\n    while tree_node is not None:\n        prefix_path: list = []\n        ascend_tree(tree_node, prefix_path)\n        if len(prefix_path) > 1:\n            cond_pats[frozenset(prefix_path[1:])] = tree_node.count\n        tree_node = tree_node.node_link\n    return cond_pats\n\n\ndef mine_tree(\n    in_tree: TreeNode,  # noqa: ARG001\n    header_table: dict,\n    min_sup: int,\n    pre_fix: set,\n    freq_item_list: list,\n) -> None:\n    \"\"\"\n    Mine the FP-Tree recursively to discover frequent itemsets.\n\n    Args:\n        in_tree: The FP-Tree to mine.\n        header_table: The header table dictionary with item information.\n        min_sup: The minimum support threshold.\n        pre_fix: A set of items as a prefix for the itemsets being mined.\n        freq_item_list: A list to store the frequent itemsets.\n\n    Example:\n    >>> data_set = [\n    ...    ['A', 'B', 'C'],\n    ...    ['A', 'C'],\n    ...    ['A', 'B', 'E'],\n    ...    ['A', 'B', 'C', 'E'],\n    ...    ['B', 'E']\n    ... ]\n    >>> min_sup = 2\n    >>> fp_tree, header_table = create_tree(data_set, min_sup)\n    >>> fp_tree\n    TreeNode('Null Set', 1, None)\n    >>> frequent_itemsets = []\n    >>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets)\n    >>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}]\n    >>> all(expected in frequent_itemsets for expected in expe_itm)\n    True\n    \"\"\"\n    sorted_items = sorted(header_table.items(), key=lambda item_info: item_info[1][0])\n    big_l = [item[0] for item in sorted_items]\n    for base_pat in big_l:\n        new_freq_set = pre_fix.copy()\n        new_freq_set.add(base_pat)\n        freq_item_list.append(new_freq_set)\n        cond_patt_bases = find_prefix_path(base_pat, header_table[base_pat][1])\n        my_cond_tree, my_head = create_tree(list(cond_patt_bases), min_sup)\n        if my_head is not None:\n            # Pass header_table[base_pat][1] as node_to_test to update_header\n            header_table[base_pat][1] = update_header(\n                header_table[base_pat][1], my_cond_tree\n            )\n            mine_tree(my_cond_tree, my_head, min_sup, new_freq_set, freq_item_list)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    data_set: list[frozenset] = [\n        frozenset([\"bread\", \"milk\", \"cheese\"]),\n        frozenset([\"bread\", \"milk\"]),\n        frozenset([\"bread\", \"diapers\"]),\n        frozenset([\"bread\", \"milk\", \"diapers\"]),\n        frozenset([\"milk\", \"diapers\"]),\n        frozenset([\"milk\", \"cheese\"]),\n        frozenset([\"diapers\", \"cheese\"]),\n        frozenset([\"bread\", \"milk\", \"cheese\", \"diapers\"]),\n    ]\n    print(f\"{len(data_set) = }\")\n    fp_tree, header_table = create_tree(data_set, min_sup=3)\n    print(f\"{fp_tree = }\")\n    print(f\"{len(header_table) = }\")\n    freq_items: list = []\n    mine_tree(fp_tree, header_table, 3, set(), freq_items)\n    print(f\"{freq_items = }\")\n", "machine_learning/sequential_minimum_optimization.py": "\"\"\"\nSequential minimal optimization (SMO) for support vector machines (SVM)\n\nSequential minimal optimization (SMO) is an algorithm for solving the quadratic\nprogramming (QP) problem that arises during the training of SVMs. It was invented by\nJohn Platt in 1998.\n\nInput:\n    0: type: numpy.ndarray.\n    1: first column of ndarray must be tags of samples, must be 1 or -1.\n    2: rows of ndarray represent samples.\n\nUsage:\n    Command:\n        python3 sequential_minimum_optimization.py\n    Code:\n        from sequential_minimum_optimization import SmoSVM, Kernel\n\n        kernel = Kernel(kernel='poly', degree=3., coef0=1., gamma=0.5)\n        init_alphas = np.zeros(train.shape[0])\n        SVM = SmoSVM(train=train, alpha_list=init_alphas, kernel_func=kernel, cost=0.4,\n                     b=0.0, tolerance=0.001)\n        SVM.fit()\n        predict = SVM.predict(test_samples)\n\nReference:\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/smo-book.pdf\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-98-14.pdf\n\"\"\"\n\nimport os\nimport sys\nimport urllib.request\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs, make_circles\nfrom sklearn.preprocessing import StandardScaler\n\nCANCER_DATASET_URL = (\n    \"https://archive.ics.uci.edu/ml/machine-learning-databases/\"\n    \"breast-cancer-wisconsin/wdbc.data\"\n)\n\n\nclass SmoSVM:\n    def __init__(\n        self,\n        train,\n        kernel_func,\n        alpha_list=None,\n        cost=0.4,\n        b=0.0,\n        tolerance=0.001,\n        auto_norm=True,\n    ):\n        self._init = True\n        self._auto_norm = auto_norm\n        self._c = np.float64(cost)\n        self._b = np.float64(b)\n        self._tol = np.float64(tolerance) if tolerance > 0.0001 else np.float64(0.001)\n\n        self.tags = train[:, 0]\n        self.samples = self._norm(train[:, 1:]) if self._auto_norm else train[:, 1:]\n        self.alphas = alpha_list if alpha_list is not None else np.zeros(train.shape[0])\n        self.Kernel = kernel_func\n\n        self._eps = 0.001\n        self._all_samples = list(range(self.length))\n        self._K_matrix = self._calculate_k_matrix()\n        self._error = np.zeros(self.length)\n        self._unbound = []\n\n        self.choose_alpha = self._choose_alphas()\n\n    # Calculate alphas using SMO algorithm\n    def fit(self):\n        k = self._k\n        state = None\n        while True:\n            # 1: Find alpha1, alpha2\n            try:\n                i1, i2 = self.choose_alpha.send(state)\n                state = None\n            except StopIteration:\n                print(\"Optimization done!\\nEvery sample satisfy the KKT condition!\")\n                break\n\n            # 2: calculate new alpha2 and new alpha1\n            y1, y2 = self.tags[i1], self.tags[i2]\n            a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()\n            e1, e2 = self._e(i1), self._e(i2)\n            args = (i1, i2, a1, a2, e1, e2, y1, y2)\n            a1_new, a2_new = self._get_new_alpha(*args)\n            if not a1_new and not a2_new:\n                state = False\n                continue\n            self.alphas[i1], self.alphas[i2] = a1_new, a2_new\n\n            # 3: update threshold(b)\n            b1_new = np.float64(\n                -e1\n                - y1 * k(i1, i1) * (a1_new - a1)\n                - y2 * k(i2, i1) * (a2_new - a2)\n                + self._b\n            )\n            b2_new = np.float64(\n                -e2\n                - y2 * k(i2, i2) * (a2_new - a2)\n                - y1 * k(i1, i2) * (a1_new - a1)\n                + self._b\n            )\n            if 0.0 < a1_new < self._c:\n                b = b1_new\n            if 0.0 < a2_new < self._c:\n                b = b2_new\n            if not (np.float64(0) < a2_new < self._c) and not (\n                np.float64(0) < a1_new < self._c\n            ):\n                b = (b1_new + b2_new) / 2.0\n            b_old = self._b\n            self._b = b\n\n            # 4: update error, here we only calculate the error for non-bound samples\n            self._unbound = [i for i in self._all_samples if self._is_unbound(i)]\n            for s in self.unbound:\n                if s in (i1, i2):\n                    continue\n                self._error[s] += (\n                    y1 * (a1_new - a1) * k(i1, s)\n                    + y2 * (a2_new - a2) * k(i2, s)\n                    + (self._b - b_old)\n                )\n\n            # if i1 or i2 is non-bound, update their error value to zero\n            if self._is_unbound(i1):\n                self._error[i1] = 0\n            if self._is_unbound(i2):\n                self._error[i2] = 0\n\n    # Predict test samples\n    def predict(self, test_samples, classify=True):\n        if test_samples.shape[1] > self.samples.shape[1]:\n            raise ValueError(\n                \"Test samples' feature length does not equal to that of train samples\"\n            )\n\n        if self._auto_norm:\n            test_samples = self._norm(test_samples)\n\n        results = []\n        for test_sample in test_samples:\n            result = self._predict(test_sample)\n            if classify:\n                results.append(1 if result > 0 else -1)\n            else:\n                results.append(result)\n        return np.array(results)\n\n    # Check if alpha violates the KKT condition\n    def _check_obey_kkt(self, index):\n        alphas = self.alphas\n        tol = self._tol\n        r = self._e(index) * self.tags[index]\n        c = self._c\n\n        return (r < -tol and alphas[index] < c) or (r > tol and alphas[index] > 0.0)\n\n    # Get value calculated from kernel function\n    def _k(self, i1, i2):\n        # for test samples, use kernel function\n        if isinstance(i2, np.ndarray):\n            return self.Kernel(self.samples[i1], i2)\n        # for training samples, kernel values have been saved in matrix\n        else:\n            return self._K_matrix[i1, i2]\n\n    # Get error for sample\n    def _e(self, index):\n        \"\"\"\n        Two cases:\n            1: Sample[index] is non-bound, fetch error from list: _error\n            2: sample[index] is bound, use predicted value minus true value: g(xi) - yi\n        \"\"\"\n        # get from error data\n        if self._is_unbound(index):\n            return self._error[index]\n        # get by g(xi) - yi\n        else:\n            gx = np.dot(self.alphas * self.tags, self._K_matrix[:, index]) + self._b\n            yi = self.tags[index]\n            return gx - yi\n\n    # Calculate kernel matrix of all possible i1, i2, saving time\n    def _calculate_k_matrix(self):\n        k_matrix = np.zeros([self.length, self.length])\n        for i in self._all_samples:\n            for j in self._all_samples:\n                k_matrix[i, j] = np.float64(\n                    self.Kernel(self.samples[i, :], self.samples[j, :])\n                )\n        return k_matrix\n\n    # Predict tag for test sample\n    def _predict(self, sample):\n        k = self._k\n        predicted_value = (\n            np.sum(\n                [\n                    self.alphas[i1] * self.tags[i1] * k(i1, sample)\n                    for i1 in self._all_samples\n                ]\n            )\n            + self._b\n        )\n        return predicted_value\n\n    # Choose alpha1 and alpha2\n    def _choose_alphas(self):\n        loci = yield from self._choose_a1()\n        if not loci:\n            return None\n        return loci\n\n    def _choose_a1(self):\n        \"\"\"\n        Choose first alpha\n        Steps:\n            1: First loop over all samples\n            2: Second loop over all non-bound samples until no non-bound samples violate\n               the KKT condition.\n            3: Repeat these two processes until no samples violate the KKT condition\n               after the first loop.\n        \"\"\"\n        while True:\n            all_not_obey = True\n            # all sample\n            print(\"Scanning all samples!\")\n            for i1 in [i for i in self._all_samples if self._check_obey_kkt(i)]:\n                all_not_obey = False\n                yield from self._choose_a2(i1)\n\n            # non-bound sample\n            print(\"Scanning non-bound samples!\")\n            while True:\n                not_obey = True\n                for i1 in [\n                    i\n                    for i in self._all_samples\n                    if self._check_obey_kkt(i) and self._is_unbound(i)\n                ]:\n                    not_obey = False\n                    yield from self._choose_a2(i1)\n                if not_obey:\n                    print(\"All non-bound samples satisfy the KKT condition!\")\n                    break\n            if all_not_obey:\n                print(\"All samples satisfy the KKT condition!\")\n                break\n        return False\n\n    def _choose_a2(self, i1):\n        \"\"\"\n        Choose the second alpha using a heuristic algorithm\n        Steps:\n            1: Choose alpha2 that maximizes the step size (|E1 - E2|).\n            2: Start in a random point, loop over all non-bound samples till alpha1 and\n               alpha2 are optimized.\n            3: Start in a random point, loop over all samples till alpha1 and alpha2 are\n               optimized.\n        \"\"\"\n        self._unbound = [i for i in self._all_samples if self._is_unbound(i)]\n\n        if len(self.unbound) > 0:\n            tmp_error = self._error.copy().tolist()\n            tmp_error_dict = {\n                index: value\n                for index, value in enumerate(tmp_error)\n                if self._is_unbound(index)\n            }\n            if self._e(i1) >= 0:\n                i2 = min(tmp_error_dict, key=lambda index: tmp_error_dict[index])\n            else:\n                i2 = max(tmp_error_dict, key=lambda index: tmp_error_dict[index])\n            cmd = yield i1, i2\n            if cmd is None:\n                return\n\n        rng = np.random.default_rng()\n        for i2 in np.roll(self.unbound, rng.choice(self.length)):\n            cmd = yield i1, i2\n            if cmd is None:\n                return\n\n        for i2 in np.roll(self._all_samples, rng.choice(self.length)):\n            cmd = yield i1, i2\n            if cmd is None:\n                return\n\n    # Get the new alpha2 and new alpha1\n    def _get_new_alpha(self, i1, i2, a1, a2, e1, e2, y1, y2):\n        k = self._k\n        if i1 == i2:\n            return None, None\n\n        # calculate L and H which bound the new alpha2\n        s = y1 * y2\n        if s == -1:\n            l, h = max(0.0, a2 - a1), min(self._c, self._c + a2 - a1)  # noqa: E741\n        else:\n            l, h = max(0.0, a2 + a1 - self._c), min(self._c, a2 + a1)  # noqa: E741\n        if l == h:\n            return None, None\n\n        # calculate eta\n        k11 = k(i1, i1)\n        k22 = k(i2, i2)\n        k12 = k(i1, i2)\n\n        # select the new alpha2 which could achieve the minimal objectives\n        if (eta := k11 + k22 - 2.0 * k12) > 0.0:\n            a2_new_unc = a2 + (y2 * (e1 - e2)) / eta\n            # a2_new has a boundary\n            if a2_new_unc >= h:\n                a2_new = h\n            elif a2_new_unc <= l:\n                a2_new = l\n            else:\n                a2_new = a2_new_unc\n        else:\n            b = self._b\n            l1 = a1 + s * (a2 - l)\n            h1 = a1 + s * (a2 - h)\n\n            # Method 1\n            f1 = y1 * (e1 + b) - a1 * k(i1, i1) - s * a2 * k(i1, i2)\n            f2 = y2 * (e2 + b) - a2 * k(i2, i2) - s * a1 * k(i1, i2)\n            ol = (\n                l1 * f1\n                + l * f2\n                + 1 / 2 * l1**2 * k(i1, i1)\n                + 1 / 2 * l**2 * k(i2, i2)\n                + s * l * l1 * k(i1, i2)\n            )\n            oh = (\n                h1 * f1\n                + h * f2\n                + 1 / 2 * h1**2 * k(i1, i1)\n                + 1 / 2 * h**2 * k(i2, i2)\n                + s * h * h1 * k(i1, i2)\n            )\n            \"\"\"\n            Method 2: Use objective function to check which alpha2_new could achieve the\n            minimal objectives\n            \"\"\"\n            if ol < (oh - self._eps):\n                a2_new = l\n            elif ol > oh + self._eps:\n                a2_new = h\n            else:\n                a2_new = a2\n\n        # a1_new has a boundary too\n        a1_new = a1 + s * (a2 - a2_new)\n        if a1_new < 0:\n            a2_new += s * a1_new\n            a1_new = 0\n        if a1_new > self._c:\n            a2_new += s * (a1_new - self._c)\n            a1_new = self._c\n\n        return a1_new, a2_new\n\n    # Normalize data using min-max method\n    def _norm(self, data):\n        if self._init:\n            self._min = np.min(data, axis=0)\n            self._max = np.max(data, axis=0)\n            self._init = False\n            return (data - self._min) / (self._max - self._min)\n        else:\n            return (data - self._min) / (self._max - self._min)\n\n    def _is_unbound(self, index):\n        return bool(0.0 < self.alphas[index] < self._c)\n\n    def _is_support(self, index):\n        return bool(self.alphas[index] > 0)\n\n    @property\n    def unbound(self):\n        return self._unbound\n\n    @property\n    def support(self):\n        return [i for i in range(self.length) if self._is_support(i)]\n\n    @property\n    def length(self):\n        return self.samples.shape[0]\n\n\nclass Kernel:\n    def __init__(self, kernel, degree=1.0, coef0=0.0, gamma=1.0):\n        self.degree = np.float64(degree)\n        self.coef0 = np.float64(coef0)\n        self.gamma = np.float64(gamma)\n        self._kernel_name = kernel\n        self._kernel = self._get_kernel(kernel_name=kernel)\n        self._check()\n\n    def _polynomial(self, v1, v2):\n        return (self.gamma * np.inner(v1, v2) + self.coef0) ** self.degree\n\n    def _linear(self, v1, v2):\n        return np.inner(v1, v2) + self.coef0\n\n    def _rbf(self, v1, v2):\n        return np.exp(-1 * (self.gamma * np.linalg.norm(v1 - v2) ** 2))\n\n    def _check(self):\n        if self._kernel == self._rbf and self.gamma < 0:\n            raise ValueError(\"gamma value must be non-negative\")\n\n    def _get_kernel(self, kernel_name):\n        maps = {\"linear\": self._linear, \"poly\": self._polynomial, \"rbf\": self._rbf}\n        return maps[kernel_name]\n\n    def __call__(self, v1, v2):\n        return self._kernel(v1, v2)\n\n    def __repr__(self):\n        return self._kernel_name\n\n\ndef count_time(func):\n    def call_func(*args, **kwargs):\n        import time\n\n        start_time = time.time()\n        func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"SMO algorithm cost {end_time - start_time} seconds\")\n\n    return call_func\n\n\n@count_time\ndef test_cancer_data():\n    print(\"Hello!\\nStart test SVM using the SMO algorithm!\")\n    # 0: download dataset and load into pandas' dataframe\n    if not os.path.exists(r\"cancer_data.csv\"):\n        request = urllib.request.Request(  # noqa: S310\n            CANCER_DATASET_URL,\n            headers={\"User-Agent\": \"Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\"},\n        )\n        response = urllib.request.urlopen(request)  # noqa: S310\n        content = response.read().decode(\"utf-8\")\n        with open(r\"cancer_data.csv\", \"w\") as f:\n            f.write(content)\n\n    data = pd.read_csv(\n        \"cancer_data.csv\",\n        header=None,\n        dtype={0: str},  # Assuming the first column contains string data\n    )\n\n    # 1: pre-processing data\n    del data[data.columns.tolist()[0]]\n    data = data.dropna(axis=0)\n    data = data.replace({\"M\": np.float64(1), \"B\": np.float64(-1)})\n    samples = np.array(data)[:, :]\n\n    # 2: dividing data into train_data data and test_data data\n    train_data, test_data = samples[:328, :], samples[328:, :]\n    test_tags, test_samples = test_data[:, 0], test_data[:, 1:]\n\n    # 3: choose kernel function, and set initial alphas to zero (optional)\n    my_kernel = Kernel(kernel=\"rbf\", degree=5, coef0=1, gamma=0.5)\n    al = np.zeros(train_data.shape[0])\n\n    # 4: calculating best alphas using SMO algorithm and predict test_data samples\n    mysvm = SmoSVM(\n        train=train_data,\n        kernel_func=my_kernel,\n        alpha_list=al,\n        cost=0.4,\n        b=0.0,\n        tolerance=0.001,\n    )\n    mysvm.fit()\n    predict = mysvm.predict(test_samples)\n\n    # 5: check accuracy\n    score = 0\n    test_num = test_tags.shape[0]\n    for i in range(test_tags.shape[0]):\n        if test_tags[i] == predict[i]:\n            score += 1\n    print(f\"\\nAll: {test_num}\\nCorrect: {score}\\nIncorrect: {test_num - score}\")\n    print(f\"Rough Accuracy: {score / test_tags.shape[0]}\")\n\n\ndef test_demonstration():\n    # change stdout\n    print(\"\\nStarting plot, please wait!\")\n    sys.stdout = open(os.devnull, \"w\")\n\n    ax1 = plt.subplot2grid((2, 2), (0, 0))\n    ax2 = plt.subplot2grid((2, 2), (0, 1))\n    ax3 = plt.subplot2grid((2, 2), (1, 0))\n    ax4 = plt.subplot2grid((2, 2), (1, 1))\n    ax1.set_title(\"Linear SVM, cost = 0.1\")\n    test_linear_kernel(ax1, cost=0.1)\n    ax2.set_title(\"Linear SVM, cost = 500\")\n    test_linear_kernel(ax2, cost=500)\n    ax3.set_title(\"RBF kernel SVM, cost = 0.1\")\n    test_rbf_kernel(ax3, cost=0.1)\n    ax4.set_title(\"RBF kernel SVM, cost = 500\")\n    test_rbf_kernel(ax4, cost=500)\n\n    sys.stdout = sys.__stdout__\n    print(\"Plot done!\")\n\n\ndef test_linear_kernel(ax, cost):\n    train_x, train_y = make_blobs(\n        n_samples=500, centers=2, n_features=2, random_state=1\n    )\n    train_y[train_y == 0] = -1\n    scaler = StandardScaler()\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\n    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))\n    my_kernel = Kernel(kernel=\"linear\", degree=5, coef0=1, gamma=0.5)\n    mysvm = SmoSVM(\n        train=train_data,\n        kernel_func=my_kernel,\n        cost=cost,\n        tolerance=0.001,\n        auto_norm=False,\n    )\n    mysvm.fit()\n    plot_partition_boundary(mysvm, train_data, ax=ax)\n\n\ndef test_rbf_kernel(ax, cost):\n    train_x, train_y = make_circles(\n        n_samples=500, noise=0.1, factor=0.1, random_state=1\n    )\n    train_y[train_y == 0] = -1\n    scaler = StandardScaler()\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\n    train_data = np.hstack((train_y.reshape(500, 1), train_x_scaled))\n    my_kernel = Kernel(kernel=\"rbf\", degree=5, coef0=1, gamma=0.5)\n    mysvm = SmoSVM(\n        train=train_data,\n        kernel_func=my_kernel,\n        cost=cost,\n        tolerance=0.001,\n        auto_norm=False,\n    )\n    mysvm.fit()\n    plot_partition_boundary(mysvm, train_data, ax=ax)\n\n\ndef plot_partition_boundary(\n    model, train_data, ax, resolution=100, colors=(\"b\", \"k\", \"r\")\n):\n    \"\"\"\n    We cannot get the optimal w of our kernel SVM model, which is different from a\n    linear SVM.  For this reason, we generate randomly distributed points with high\n    density, and predicted values of these points are calculated using our trained\n    model. Then we could use this predicted values to draw contour map, and this contour\n    map represents the SVM's partition boundary.\n    \"\"\"\n    train_data_x = train_data[:, 1]\n    train_data_y = train_data[:, 2]\n    train_data_tags = train_data[:, 0]\n    xrange = np.linspace(train_data_x.min(), train_data_x.max(), resolution)\n    yrange = np.linspace(train_data_y.min(), train_data_y.max(), resolution)\n    test_samples = np.array([(x, y) for x in xrange for y in yrange]).reshape(\n        resolution * resolution, 2\n    )\n\n    test_tags = model.predict(test_samples, classify=False)\n    grid = test_tags.reshape((len(xrange), len(yrange)))\n\n    # Plot contour map which represents the partition boundary\n    ax.contour(\n        xrange,\n        yrange,\n        np.asmatrix(grid).T,\n        levels=(-1, 0, 1),\n        linestyles=(\"--\", \"-\", \"--\"),\n        linewidths=(1, 1, 1),\n        colors=colors,\n    )\n    # Plot all train samples\n    ax.scatter(\n        train_data_x,\n        train_data_y,\n        c=train_data_tags,\n        cmap=plt.cm.Dark2,\n        lw=0,\n        alpha=0.5,\n    )\n\n    # Plot support vectors\n    support = model.support\n    ax.scatter(\n        train_data_x[support],\n        train_data_y[support],\n        c=train_data_tags[support],\n        cmap=plt.cm.Dark2,\n    )\n\n\nif __name__ == \"__main__\":\n    test_cancer_data()\n    test_demonstration()\n    plt.show()\n", "machine_learning/polynomial_regression.py": "\"\"\"\nPolynomial regression is a type of regression analysis that models the relationship\nbetween a predictor x and the response y as an mth-degree polynomial:\n\ny = \u03b2\u2080 + \u03b2\u2081x + \u03b2\u2082x\u00b2 + ... + \u03b2\u2098x\u1d50 + \u03b5\n\nBy treating x, x\u00b2, ..., x\u1d50 as distinct variables, we see that polynomial regression is a\nspecial case of multiple linear regression. Therefore, we can use ordinary least squares\n(OLS) estimation to estimate the vector of model parameters \u03b2 = (\u03b2\u2080, \u03b2\u2081, \u03b2\u2082, ..., \u03b2\u2098)\nfor polynomial regression:\n\n\u03b2 = (X\u1d40X)\u207b\u00b9X\u1d40y = X\u207ay\n\nwhere X is the design matrix, y is the response vector, and X\u207a denotes the Moore-Penrose\npseudoinverse of X. In the case of polynomial regression, the design matrix is\n\n    |1  x\u2081  x\u2081\u00b2 \u22ef x\u2081\u1d50|\nX = |1  x\u2082  x\u2082\u00b2 \u22ef x\u2082\u1d50|\n    |\u22ee  \u22ee   \u22ee   \u22f1 \u22ee  |\n    |1  x\u2099  x\u2099\u00b2 \u22ef  x\u2099\u1d50|\n\nIn OLS estimation, inverting X\u1d40X to compute X\u207a can be very numerically unstable. This\nimplementation sidesteps this need to invert X\u1d40X by computing X\u207a using singular value\ndecomposition (SVD):\n\n\u03b2 = V\u03a3\u207aU\u1d40y\n\nwhere U\u03a3V\u1d40 is an SVD of X.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Polynomial_regression\n    - https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse\n    - https://en.wikipedia.org/wiki/Numerical_methods_for_linear_least_squares\n    - https://en.wikipedia.org/wiki/Singular_value_decomposition\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass PolynomialRegression:\n    __slots__ = \"degree\", \"params\"\n\n    def __init__(self, degree: int) -> None:\n        \"\"\"\n        @raises ValueError: if the polynomial degree is negative\n        \"\"\"\n        if degree < 0:\n            raise ValueError(\"Polynomial degree must be non-negative\")\n\n        self.degree = degree\n        self.params = None\n\n    @staticmethod\n    def _design_matrix(data: np.ndarray, degree: int) -> np.ndarray:\n        \"\"\"\n        Constructs a polynomial regression design matrix for the given input data. For\n        input data x = (x\u2081, x\u2082, ..., x\u2099) and polynomial degree m, the design matrix is\n        the Vandermonde matrix\n\n            |1  x\u2081  x\u2081\u00b2 \u22ef x\u2081\u1d50|\n        X = |1  x\u2082  x\u2082\u00b2 \u22ef x\u2082\u1d50|\n            |\u22ee  \u22ee   \u22ee   \u22f1 \u22ee  |\n            |1  x\u2099  x\u2099\u00b2 \u22ef  x\u2099\u1d50|\n\n        Reference: https://en.wikipedia.org/wiki/Vandermonde_matrix\n\n        @param data:    the input predictor values x, either for model fitting or for\n                        prediction\n        @param degree:  the polynomial degree m\n        @returns:       the Vandermonde matrix X (see above)\n        @raises ValueError: if input data is not N x 1\n\n        >>> x = np.array([0, 1, 2])\n        >>> PolynomialRegression._design_matrix(x, degree=0)\n        array([[1],\n               [1],\n               [1]])\n        >>> PolynomialRegression._design_matrix(x, degree=1)\n        array([[1, 0],\n               [1, 1],\n               [1, 2]])\n        >>> PolynomialRegression._design_matrix(x, degree=2)\n        array([[1, 0, 0],\n               [1, 1, 1],\n               [1, 2, 4]])\n        >>> PolynomialRegression._design_matrix(x, degree=3)\n        array([[1, 0, 0, 0],\n               [1, 1, 1, 1],\n               [1, 2, 4, 8]])\n        >>> PolynomialRegression._design_matrix(np.array([[0, 0], [0 , 0]]), degree=3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Data must have dimensions N x 1\n        \"\"\"\n        rows, *remaining = data.shape\n        if remaining:\n            raise ValueError(\"Data must have dimensions N x 1\")\n\n        return np.vander(data, N=degree + 1, increasing=True)\n\n    def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None:\n        \"\"\"\n        Computes the polynomial regression model parameters using ordinary least squares\n        (OLS) estimation:\n\n        \u03b2 = (X\u1d40X)\u207b\u00b9X\u1d40y = X\u207ay\n\n        where X\u207a denotes the Moore-Penrose pseudoinverse of the design matrix X. This\n        function computes X\u207a using singular value decomposition (SVD).\n\n        References:\n            - https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse\n            - https://en.wikipedia.org/wiki/Singular_value_decomposition\n            - https://en.wikipedia.org/wiki/Multicollinearity\n\n        @param x_train: the predictor values x for model fitting\n        @param y_train: the response values y for model fitting\n        @raises ArithmeticError:    if X isn't full rank, then X\u1d40X is singular and \u03b2\n                                    doesn't exist\n\n        >>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        >>> y = x**3 - 2 * x**2 + 3 * x - 5\n        >>> poly_reg = PolynomialRegression(degree=3)\n        >>> poly_reg.fit(x, y)\n        >>> poly_reg.params\n        array([-5.,  3., -2.,  1.])\n        >>> poly_reg = PolynomialRegression(degree=20)\n        >>> poly_reg.fit(x, y)\n        Traceback (most recent call last):\n        ...\n        ArithmeticError: Design matrix is not full rank, can't compute coefficients\n\n        Make sure errors don't grow too large:\n        >>> coefs = np.array([-250, 50, -2, 36, 20, -12, 10, 2, -1, -15, 1])\n        >>> y = PolynomialRegression._design_matrix(x, len(coefs) - 1) @ coefs\n        >>> poly_reg = PolynomialRegression(degree=len(coefs) - 1)\n        >>> poly_reg.fit(x, y)\n        >>> np.allclose(poly_reg.params, coefs, atol=10e-3)\n        True\n        \"\"\"\n        X = PolynomialRegression._design_matrix(x_train, self.degree)  # noqa: N806\n        _, cols = X.shape\n        if np.linalg.matrix_rank(X) < cols:\n            raise ArithmeticError(\n                \"Design matrix is not full rank, can't compute coefficients\"\n            )\n\n        # np.linalg.pinv() computes the Moore-Penrose pseudoinverse using SVD\n        self.params = np.linalg.pinv(X) @ y_train\n\n    def predict(self, data: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the predicted response values y for the given input data by\n        constructing the design matrix X and evaluating y = X\u03b2.\n\n        @param data:    the predictor values x for prediction\n        @returns:       the predicted response values y = X\u03b2\n        @raises ArithmeticError:    if this function is called before the model\n                                    parameters are fit\n\n        >>> x = np.array([0, 1, 2, 3, 4])\n        >>> y = x**3 - 2 * x**2 + 3 * x - 5\n        >>> poly_reg = PolynomialRegression(degree=3)\n        >>> poly_reg.fit(x, y)\n        >>> poly_reg.predict(np.array([-1]))\n        array([-11.])\n        >>> poly_reg.predict(np.array([-2]))\n        array([-27.])\n        >>> poly_reg.predict(np.array([6]))\n        array([157.])\n        >>> PolynomialRegression(degree=3).predict(x)\n        Traceback (most recent call last):\n        ...\n        ArithmeticError: Predictor hasn't been fit yet\n        \"\"\"\n        if self.params is None:\n            raise ArithmeticError(\"Predictor hasn't been fit yet\")\n\n        return PolynomialRegression._design_matrix(data, self.degree) @ self.params\n\n\ndef main() -> None:\n    \"\"\"\n    Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg\n    dataset\n\n    >>> pass    # Placeholder, function is only for demo purposes\n    \"\"\"\n    import seaborn as sns\n\n    mpg_data = sns.load_dataset(\"mpg\")\n\n    poly_reg = PolynomialRegression(degree=2)\n    poly_reg.fit(mpg_data.weight, mpg_data.mpg)\n\n    weight_sorted = np.sort(mpg_data.weight)\n    predictions = poly_reg.predict(weight_sorted)\n\n    plt.scatter(mpg_data.weight, mpg_data.mpg, color=\"gray\", alpha=0.5)\n    plt.plot(weight_sorted, predictions, color=\"red\", linewidth=3)\n    plt.title(\"Predicting Fuel Efficiency Using Polynomial Regression\")\n    plt.xlabel(\"Weight (lbs)\")\n    plt.ylabel(\"Fuel Efficiency (mpg)\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    main()\n", "machine_learning/__init__.py": "", "machine_learning/loss_functions.py": "import numpy as np\n\n\ndef binary_cross_entropy(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted\n    probabilities.\n\n    BCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\n    probabilities. It's widely used in binary classification tasks.\n\n    BCE = -\u03a3(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Cross_entropy\n\n    Parameters:\n    - y_true: True binary labels (0 or 1)\n    - y_pred: Predicted probabilities for class 1\n    - epsilon: Small constant to avoid numerical instability\n\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n    >>> binary_cross_entropy(true_labels, predicted_probs)\n    0.2529995012327421\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> binary_cross_entropy(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)  # Clip predictions to avoid log(0)\n    bce_loss = -(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))\n    return np.mean(bce_loss)\n\n\ndef binary_focal_cross_entropy(\n    y_true: np.ndarray,\n    y_pred: np.ndarray,\n    gamma: float = 2.0,\n    alpha: float = 0.25,\n    epsilon: float = 1e-15,\n) -> float:\n    \"\"\"\n    Calculate the mean binary focal cross-entropy (BFCE) loss between true labels\n    and predicted probabilities.\n\n    BFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted\n    probabilities. It's a variation of binary cross-entropy that addresses class\n    imbalance by focusing on hard examples.\n\n    BCFE = -\u03a3(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n                + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))\n\n    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\n    Parameters:\n    - y_true: True binary labels (0 or 1).\n    - y_pred: Predicted probabilities for class 1.\n    - gamma: Focusing parameter for modulating the loss (default: 2.0).\n    - alpha: Weighting factor for class 1 (default: 0.25).\n    - epsilon: Small constant to avoid numerical instability.\n\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])\n    >>> binary_focal_cross_entropy(true_labels, predicted_probs)\n    0.008257977659239775\n    >>> true_labels = np.array([0, 1, 1, 0, 1])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> binary_focal_cross_entropy(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n    # Clip predicted probabilities to avoid log(0)\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)\n\n    bcfe_loss = -(\n        alpha * (1 - y_pred) ** gamma * y_true * np.log(y_pred)\n        + (1 - alpha) * y_pred**gamma * (1 - y_true) * np.log(1 - y_pred)\n    )\n\n    return np.mean(bcfe_loss)\n\n\ndef categorical_cross_entropy(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate categorical cross-entropy (CCE) loss between true class labels and\n    predicted class probabilities.\n\n    CCE = -\u03a3(y_true * ln(y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Cross_entropy\n\n    Parameters:\n    - y_true: True class labels (one-hot encoded)\n    - y_pred: Predicted class probabilities\n    - epsilon: Small constant to avoid numerical instability\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    0.567395975254385\n    >>> true_labels = np.array([[1, 0], [0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same shape.\n    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Predicted probabilities must sum to approximately 1.\n    \"\"\"\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Input arrays must have the same shape.\")\n\n    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):\n        raise ValueError(\"y_true must be one-hot encoded.\")\n\n    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):\n        raise ValueError(\"Predicted probabilities must sum to approximately 1.\")\n\n    y_pred = np.clip(y_pred, epsilon, 1)  # Clip predictions to avoid log(0)\n    return -np.sum(y_true * np.log(y_pred))\n\n\ndef categorical_focal_cross_entropy(\n    y_true: np.ndarray,\n    y_pred: np.ndarray,\n    alpha: np.ndarray = None,\n    gamma: float = 2.0,\n    epsilon: float = 1e-15,\n) -> float:\n    \"\"\"\n    Calculate the mean categorical focal cross-entropy (CFCE) loss between true\n    labels and predicted probabilities for multi-class classification.\n\n    CFCE loss is a generalization of binary focal cross-entropy for multi-class\n    classification. It addresses class imbalance by focusing on hard examples.\n\n    CFCE = -\u03a3 alpha * (1 - y_pred)**gamma * y_true * log(y_pred)\n\n    Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)\n\n    Parameters:\n    - y_true: True labels in one-hot encoded form.\n    - y_pred: Predicted probabilities for each class.\n    - alpha: Array of weighting factors for each class.\n    - gamma: Focusing parameter for modulating the loss (default: 2.0).\n    - epsilon: Small constant to avoid numerical instability.\n\n    Returns:\n    - The mean categorical focal cross-entropy loss.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> alpha = np.array([0.6, 0.2, 0.7])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)\n    0.0025966118981496423\n\n    >>> true_labels = np.array([[0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]])\n    >>> alpha = np.array([0.25, 0.25, 0.25])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)\n    0.23315276982014324\n\n    >>> true_labels = np.array([[1, 0], [0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same shape.\n\n    >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n\n    >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: y_true must be one-hot encoded.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Predicted probabilities must sum to approximately 1.\n\n    >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])\n    >>> alpha = np.array([0.6, 0.2])\n    >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)\n    Traceback (most recent call last):\n        ...\n    ValueError: Length of alpha must match the number of classes.\n    \"\"\"\n    if y_true.shape != y_pred.shape:\n        raise ValueError(\"Shape of y_true and y_pred must be the same.\")\n\n    if alpha is None:\n        alpha = np.ones(y_true.shape[1])\n\n    if np.any((y_true != 0) & (y_true != 1)) or np.any(y_true.sum(axis=1) != 1):\n        raise ValueError(\"y_true must be one-hot encoded.\")\n\n    if len(alpha) != y_true.shape[1]:\n        raise ValueError(\"Length of alpha must match the number of classes.\")\n\n    if not np.all(np.isclose(np.sum(y_pred, axis=1), 1, rtol=epsilon, atol=epsilon)):\n        raise ValueError(\"Predicted probabilities must sum to approximately 1.\")\n\n    # Clip predicted probabilities to avoid log(0)\n    y_pred = np.clip(y_pred, epsilon, 1 - epsilon)\n\n    # Calculate loss for each class and sum across classes\n    cfce_loss = -np.sum(\n        alpha * np.power(1 - y_pred, gamma) * y_true * np.log(y_pred), axis=1\n    )\n\n    return np.mean(cfce_loss)\n\n\ndef hinge_loss(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean hinge loss for between true labels and predicted probabilities\n    for training support vector machines (SVMs).\n\n    Hinge loss = max(0, 1 - true * pred)\n\n    Reference: https://en.wikipedia.org/wiki/Hinge_loss\n\n    Args:\n    - y_true: actual values (ground truth) encoded as -1 or 1\n    - y_pred: predicted values\n\n    >>> true_labels = np.array([-1, 1, 1, -1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> hinge_loss(true_labels, pred)\n    1.52\n    >>> true_labels = np.array([-1, 1, 1, -1, 1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> hinge_loss(true_labels, pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Length of predicted and actual array must be same.\n    >>> true_labels = np.array([-1, 1, 10, -1, 1])\n    >>> pred = np.array([-4, -0.3, 0.7, 5, 10])\n    >>> hinge_loss(true_labels, pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: y_true can have values -1 or 1 only.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Length of predicted and actual array must be same.\")\n\n    if np.any((y_true != -1) & (y_true != 1)):\n        raise ValueError(\"y_true can have values -1 or 1 only.\")\n\n    hinge_losses = np.maximum(0, 1.0 - (y_true * y_pred))\n    return np.mean(hinge_losses)\n\n\ndef huber_loss(y_true: np.ndarray, y_pred: np.ndarray, delta: float) -> float:\n    \"\"\"\n    Calculate the mean Huber loss between the given ground truth and predicted values.\n\n    The Huber loss describes the penalty incurred by an estimation procedure, and it\n    serves as a measure of accuracy for regression models.\n\n    Huber loss =\n        0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta\n        delta * |y_true - y_pred| - 0.5 * delta^2   otherwise\n\n    Reference: https://en.wikipedia.org/wiki/Huber_loss\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102)\n    True\n    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0])\n    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n    >>> np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164)\n    True\n    >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0])\n    >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])\n    >>> huber_loss(true_labels, predicted_probs, 1.0)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    huber_mse = 0.5 * (y_true - y_pred) ** 2\n    huber_mae = delta * (np.abs(y_true - y_pred) - 0.5 * delta)\n    return np.where(np.abs(y_true - y_pred) <= delta, huber_mse, huber_mae).mean()\n\n\ndef mean_squared_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between ground truth and predicted values.\n\n    MSE measures the squared difference between true values and predicted values, and it\n    serves as a measure of accuracy for regression models.\n\n    MSE = (1/n) * \u03a3(y_true - y_pred)^2\n\n    Reference: https://en.wikipedia.org/wiki/Mean_squared_error\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> np.isclose(mean_squared_error(true_values, predicted_values), 0.028)\n    True\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> mean_squared_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    squared_errors = (y_true - y_pred) ** 2\n    return np.mean(squared_errors)\n\n\ndef mean_absolute_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculates the Mean Absolute Error (MAE) between ground truth (observed)\n        and predicted values.\n\n    MAE measures the absolute difference between true values and predicted values.\n\n    Equation:\n    MAE = (1/n) * \u03a3(abs(y_true - y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Mean_absolute_error\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> np.isclose(mean_absolute_error(true_values, predicted_values), 0.16)\n    True\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> np.isclose(mean_absolute_error(true_values, predicted_values), 2.16)\n    False\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2])\n    >>> mean_absolute_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    return np.mean(abs(y_true - y_pred))\n\n\ndef mean_squared_logarithmic_error(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the mean squared logarithmic error (MSLE) between ground truth and\n    predicted values.\n\n    MSLE measures the squared logarithmic difference between true values and predicted\n    values for regression models. It's particularly useful for dealing with skewed or\n    large-value data, and it's often used when the relative differences between\n    predicted and true values are more important than absolute differences.\n\n    MSLE = (1/n) * \u03a3(log(1 + y_true) - log(1 + y_pred))^2\n\n    Reference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035\n\n    Parameters:\n    - y_true: The true values (ground truth)\n    - y_pred: The predicted values\n\n    >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])\n    >>> mean_squared_logarithmic_error(true_values, predicted_values)\n    0.0030860877925181344\n    >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])\n    >>> mean_squared_logarithmic_error(true_labels, predicted_probs)\n    Traceback (most recent call last):\n    ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    squared_logarithmic_errors = (np.log1p(y_true) - np.log1p(y_pred)) ** 2\n    return np.mean(squared_logarithmic_errors)\n\n\ndef mean_absolute_percentage_error(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-15\n) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Percentage Error between y_true and y_pred.\n\n    Mean Absolute Percentage Error calculates the average of the absolute\n    percentage differences between the predicted and true values.\n\n    Formula = (\u03a3|y_true[i]-Y_pred[i]/y_true[i]|)/n\n\n    Source: https://stephenallwright.com/good-mape-score/\n\n    Parameters:\n    y_true (np.ndarray): Numpy array containing true/target values.\n    y_pred (np.ndarray): Numpy array containing predicted values.\n\n    Returns:\n    float: The Mean Absolute Percentage error between y_true and y_pred.\n\n    Examples:\n    >>> y_true = np.array([10, 20, 30, 40])\n    >>> y_pred = np.array([12, 18, 33, 45])\n    >>> mean_absolute_percentage_error(y_true, y_pred)\n    0.13125\n\n    >>> y_true = np.array([1, 2, 3, 4])\n    >>> y_pred = np.array([2, 3, 4, 5])\n    >>> mean_absolute_percentage_error(y_true, y_pred)\n    0.5208333333333333\n\n    >>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24])\n    >>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23])\n    >>> mean_absolute_percentage_error(y_true, y_pred)\n    0.064671076436071\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"The length of the two arrays should be the same.\")\n\n    y_true = np.where(y_true == 0, epsilon, y_true)\n    absolute_percentage_diff = np.abs((y_true - y_pred) / y_true)\n\n    return np.mean(absolute_percentage_diff)\n\n\ndef perplexity_loss(\n    y_true: np.ndarray, y_pred: np.ndarray, epsilon: float = 1e-7\n) -> float:\n    \"\"\"\n    Calculate the perplexity for the y_true and y_pred.\n\n    Compute the Perplexity which useful in predicting language model\n    accuracy in Natural Language Processing (NLP.)\n    Perplexity is measure of how certain the model in its predictions.\n\n    Perplexity Loss = exp(-1/N (\u03a3 ln(p(x)))\n\n    Reference:\n    https://en.wikipedia.org/wiki/Perplexity\n\n    Args:\n        y_true: Actual label encoded sentences of shape (batch_size, sentence_length)\n        y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)\n        epsilon: Small floating point number to avoid getting inf for log(0)\n\n    Returns:\n        Perplexity loss between y_true and y_pred.\n\n    >>> y_true = np.array([[1, 4], [2, 3]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    5.0247347775367945\n    >>> y_true = np.array([[1, 4], [2, 3]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27],\n    ...      [0.30, 0.10, 0.20, 0.15, 0.25]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12],\n    ...       [0.30, 0.10, 0.20, 0.15, 0.25]],]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Sentence length of y_true and y_pred must be equal.\n    >>> y_true = np.array([[1, 4], [2, 11]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Label value must not be greater than vocabulary size.\n    >>> y_true = np.array([[1, 4]])\n    >>> y_pred = np.array(\n    ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],\n    ...      [0.24, 0.19, 0.09, 0.18, 0.27]],\n    ...      [[0.03, 0.26, 0.21, 0.18, 0.30],\n    ...       [0.28, 0.10, 0.33, 0.15, 0.12]]]\n    ... )\n    >>> perplexity_loss(y_true, y_pred)\n    Traceback (most recent call last):\n    ...\n    ValueError: Batch size of y_true and y_pred must be equal.\n    \"\"\"\n\n    vocab_size = y_pred.shape[2]\n\n    if y_true.shape[0] != y_pred.shape[0]:\n        raise ValueError(\"Batch size of y_true and y_pred must be equal.\")\n    if y_true.shape[1] != y_pred.shape[1]:\n        raise ValueError(\"Sentence length of y_true and y_pred must be equal.\")\n    if np.max(y_true) > vocab_size:\n        raise ValueError(\"Label value must not be greater than vocabulary size.\")\n\n    # Matrix to select prediction value only for true class\n    filter_matrix = np.array(\n        [[list(np.eye(vocab_size)[word]) for word in sentence] for sentence in y_true]\n    )\n\n    # Getting the matrix containing prediction for only true class\n    true_class_pred = np.sum(y_pred * filter_matrix, axis=2).clip(epsilon, 1)\n\n    # Calculating perplexity for each sentence\n    perp_losses = np.exp(np.negative(np.mean(np.log(true_class_pred), axis=1)))\n\n    return np.mean(perp_losses)\n\n\ndef smooth_l1_loss(y_true: np.ndarray, y_pred: np.ndarray, beta: float = 1.0) -> float:\n    \"\"\"\n    Calculate the Smooth L1 Loss between y_true and y_pred.\n\n    The Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used\n    in regression problems, such as object detection.\n\n    Smooth L1 Loss =\n        0.5 * (x - y)^2 / beta, if |x - y| < beta\n        |x - y| - 0.5 * beta, otherwise\n\n    Reference:\n    https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html\n\n    Args:\n        y_true: Array of true values.\n        y_pred: Array of predicted values.\n        beta: Specifies the threshold at which to change between L1 and L2 loss.\n\n    Returns:\n        The calculated Smooth L1 Loss between y_true and y_pred.\n\n    Raises:\n        ValueError: If the length of the two arrays is not the same.\n\n    >>> y_true = np.array([3, 5, 2, 7])\n    >>> y_pred = np.array([2.9, 4.8, 2.1, 7.2])\n    >>> smooth_l1_loss(y_true, y_pred, 1.0)\n    0.012500000000000022\n\n    >>> y_true = np.array([2, 4, 6])\n    >>> y_pred = np.array([1, 5, 7])\n    >>> smooth_l1_loss(y_true, y_pred, 1.0)\n    0.5\n\n    >>> y_true = np.array([1, 3, 5, 7])\n    >>> y_pred = np.array([1, 3, 5, 7])\n    >>> smooth_l1_loss(y_true, y_pred, 1.0)\n    0.0\n\n    >>> y_true = np.array([1, 3, 5])\n    >>> y_pred = np.array([1, 3, 5, 7])\n    >>> smooth_l1_loss(y_true, y_pred, 1.0)\n    Traceback (most recent call last):\n    ...\n    ValueError: The length of the two arrays should be the same.\n    \"\"\"\n\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"The length of the two arrays should be the same.\")\n\n    diff = np.abs(y_true - y_pred)\n    loss = np.where(diff < beta, 0.5 * diff**2 / beta, diff - 0.5 * beta)\n    return np.mean(loss)\n\n\ndef kullback_leibler_divergence(y_true: np.ndarray, y_pred: np.ndarray) -> float:\n    \"\"\"\n    Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels\n    and predicted probabilities.\n\n    KL divergence loss quantifies dissimilarity between true labels and predicted\n    probabilities. It's often used in training generative models.\n\n    KL = \u03a3(y_true * ln(y_true / y_pred))\n\n    Reference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence\n\n    Parameters:\n    - y_true: True class probabilities\n    - y_pred: Predicted class probabilities\n\n    >>> true_labels = np.array([0.2, 0.3, 0.5])\n    >>> predicted_probs = np.array([0.3, 0.3, 0.4])\n    >>> kullback_leibler_divergence(true_labels, predicted_probs)\n    0.030478754035472025\n    >>> true_labels = np.array([0.2, 0.3, 0.5])\n    >>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5])\n    >>> kullback_leibler_divergence(true_labels, predicted_probs)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input arrays must have the same length.\n    \"\"\"\n    if len(y_true) != len(y_pred):\n        raise ValueError(\"Input arrays must have the same length.\")\n\n    kl_loss = y_true * np.log(y_true / y_pred)\n    return np.sum(kl_loss)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/similarity_search.py": "\"\"\"\nSimilarity Search : https://en.wikipedia.org/wiki/Similarity_search\nSimilarity search is a search algorithm for finding the nearest vector from\nvectors, used in natural language processing.\nIn this algorithm, it calculates distance with euclidean distance and\nreturns a list containing two data for each vector:\n    1. the nearest vector\n    2. distance between the vector and the nearest vector (float)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\n\nimport numpy as np\nfrom numpy.linalg import norm\n\n\ndef euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    \"\"\"\n    Calculates euclidean distance between two data.\n    :param input_a: ndarray of first vector.\n    :param input_b: ndarray of second vector.\n    :return: Euclidean distance of input_a and input_b. By using math.sqrt(),\n             result will be float.\n\n    >>> euclidean(np.array([0]), np.array([1]))\n    1.0\n    >>> euclidean(np.array([0, 1]), np.array([1, 1]))\n    1.0\n    >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))\n    1.0\n    \"\"\"\n    return math.sqrt(sum(pow(a - b, 2) for a, b in zip(input_a, input_b)))\n\n\ndef similarity_search(\n    dataset: np.ndarray, value_array: np.ndarray\n) -> list[list[list[float] | float]]:\n    \"\"\"\n    :param dataset: Set containing the vectors. Should be ndarray.\n    :param value_array: vector/vectors we want to know the nearest vector from dataset.\n    :return: Result will be a list containing\n            1. the nearest vector\n            2. distance from the vector\n\n    >>> dataset = np.array([[0], [1], [2]])\n    >>> value_array = np.array([[0]])\n    >>> similarity_search(dataset, value_array)\n    [[[0], 0.0]]\n\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 1.0]]\n\n    >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]\n\n    These are the errors that might occur:\n\n    1. If dimensions are different.\n    For example, dataset has 2d array and value_array has 1d array:\n    >>> dataset = np.array([[1]])\n    >>> value_array = np.array([1])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1\n\n    2. If data's shapes are different.\n    For example, dataset has shape of (3, 2) and value_array has (2, 3).\n    We are expecting same shapes of two arrays, so it is wrong.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]])\n    >>> value_array = np.array([[0, 0, 0], [0, 0, 1]])\n    >>> similarity_search(dataset, value_array)\n    Traceback (most recent call last):\n        ...\n    ValueError: Wrong input data's shape... dataset : 2, value_array : 3\n\n    3. If data types are different.\n    When trying to compare, we are expecting same types so they should be same.\n    If not, it'll come up with errors.\n    >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)\n    >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)\n    >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n        ...\n    TypeError: Input data have different datatype...\n    dataset : float32, value_array : int32\n    \"\"\"\n\n    if dataset.ndim != value_array.ndim:\n        msg = (\n            \"Wrong input data's dimensions... \"\n            f\"dataset : {dataset.ndim}, value_array : {value_array.ndim}\"\n        )\n        raise ValueError(msg)\n\n    try:\n        if dataset.shape[1] != value_array.shape[1]:\n            msg = (\n                \"Wrong input data's shape... \"\n                f\"dataset : {dataset.shape[1]}, value_array : {value_array.shape[1]}\"\n            )\n            raise ValueError(msg)\n    except IndexError:\n        if dataset.ndim != value_array.ndim:\n            raise TypeError(\"Wrong shape\")\n\n    if dataset.dtype != value_array.dtype:\n        msg = (\n            \"Input data have different datatype... \"\n            f\"dataset : {dataset.dtype}, value_array : {value_array.dtype}\"\n        )\n        raise TypeError(msg)\n\n    answer = []\n\n    for value in value_array:\n        dist = euclidean(value, dataset[0])\n        vector = dataset[0].tolist()\n\n        for dataset_value in dataset[1:]:\n            temp_dist = euclidean(value, dataset_value)\n\n            if dist > temp_dist:\n                dist = temp_dist\n                vector = dataset_value.tolist()\n\n        answer.append([vector, dist])\n\n    return answer\n\n\ndef cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:\n    \"\"\"\n    Calculates cosine similarity between two data.\n    :param input_a: ndarray of first vector.\n    :param input_b: ndarray of second vector.\n    :return: Cosine similarity of input_a and input_b. By using math.sqrt(),\n             result will be float.\n\n    >>> cosine_similarity(np.array([1]), np.array([1]))\n    1.0\n    >>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))\n    0.9615239476408232\n    \"\"\"\n    return np.dot(input_a, input_b) / (norm(input_a) * norm(input_b))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/automatic_differentiation.py": "\"\"\"\nDemonstration of the Automatic Differentiation (Reverse mode).\n\nReference: https://en.wikipedia.org/wiki/Automatic_differentiation\n\nAuthor: Poojan Smart\nEmail: smrtpoojan@gmail.com\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import defaultdict\nfrom enum import Enum\nfrom types import TracebackType\nfrom typing import Any\n\nimport numpy as np\nfrom typing_extensions import Self  # noqa: UP035\n\n\nclass OpType(Enum):\n    \"\"\"\n    Class represents list of supported operations on Variable for gradient calculation.\n    \"\"\"\n\n    ADD = 0\n    SUB = 1\n    MUL = 2\n    DIV = 3\n    MATMUL = 4\n    POWER = 5\n    NOOP = 6\n\n\nclass Variable:\n    \"\"\"\n    Class represents n-dimensional object which is used to wrap numpy array on which\n    operations will be performed and the gradient will be calculated.\n\n    Examples:\n    >>> Variable(5.0)\n    Variable(5.0)\n    >>> Variable([5.0, 2.9])\n    Variable([5.  2.9])\n    >>> Variable([5.0, 2.9]) + Variable([1.0, 5.5])\n    Variable([6.  8.4])\n    >>> Variable([[8.0, 10.0]])\n    Variable([[ 8. 10.]])\n    \"\"\"\n\n    def __init__(self, value: Any) -> None:\n        self.value = np.array(value)\n\n        # pointers to the operations to which the Variable is input\n        self.param_to: list[Operation] = []\n        # pointer to the operation of which the Variable is output of\n        self.result_of: Operation = Operation(OpType.NOOP)\n\n    def __repr__(self) -> str:\n        return f\"Variable({self.value})\"\n\n    def to_ndarray(self) -> np.ndarray:\n        return self.value\n\n    def __add__(self, other: Variable) -> Variable:\n        result = Variable(self.value + other.value)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(OpType.ADD, params=[self, other], output=result)\n        return result\n\n    def __sub__(self, other: Variable) -> Variable:\n        result = Variable(self.value - other.value)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(OpType.SUB, params=[self, other], output=result)\n        return result\n\n    def __mul__(self, other: Variable) -> Variable:\n        result = Variable(self.value * other.value)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(OpType.MUL, params=[self, other], output=result)\n        return result\n\n    def __truediv__(self, other: Variable) -> Variable:\n        result = Variable(self.value / other.value)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(OpType.DIV, params=[self, other], output=result)\n        return result\n\n    def __matmul__(self, other: Variable) -> Variable:\n        result = Variable(self.value @ other.value)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(OpType.MATMUL, params=[self, other], output=result)\n        return result\n\n    def __pow__(self, power: int) -> Variable:\n        result = Variable(self.value**power)\n\n        with GradientTracker() as tracker:\n            # if tracker is enabled, computation graph will be updated\n            if tracker.enabled:\n                tracker.append(\n                    OpType.POWER,\n                    params=[self],\n                    output=result,\n                    other_params={\"power\": power},\n                )\n        return result\n\n    def add_param_to(self, param_to: Operation) -> None:\n        self.param_to.append(param_to)\n\n    def add_result_of(self, result_of: Operation) -> None:\n        self.result_of = result_of\n\n\nclass Operation:\n    \"\"\"\n    Class represents operation between single or two Variable objects.\n    Operation objects contains type of operation, pointers to input Variable\n    objects and pointer to resulting Variable from the operation.\n    \"\"\"\n\n    def __init__(\n        self,\n        op_type: OpType,\n        other_params: dict | None = None,\n    ) -> None:\n        self.op_type = op_type\n        self.other_params = {} if other_params is None else other_params\n\n    def add_params(self, params: list[Variable]) -> None:\n        self.params = params\n\n    def add_output(self, output: Variable) -> None:\n        self.output = output\n\n    def __eq__(self, value) -> bool:\n        return self.op_type == value if isinstance(value, OpType) else False\n\n\nclass GradientTracker:\n    \"\"\"\n    Class contains methods to compute partial derivatives of Variable\n    based on the computation graph.\n\n    Examples:\n\n    >>> with GradientTracker() as tracker:\n    ...     a = Variable([2.0, 5.0])\n    ...     b = Variable([1.0, 2.0])\n    ...     m = Variable([1.0, 2.0])\n    ...     c = a + b\n    ...     d = a * b\n    ...     e = c / d\n    >>> tracker.gradient(e, a)\n    array([-0.25, -0.04])\n    >>> tracker.gradient(e, b)\n    array([-1.  , -0.25])\n    >>> tracker.gradient(e, m) is None\n    True\n\n    >>> with GradientTracker() as tracker:\n    ...     a = Variable([[2.0, 5.0]])\n    ...     b = Variable([[1.0], [2.0]])\n    ...     c = a @ b\n    >>> tracker.gradient(c, a)\n    array([[1., 2.]])\n    >>> tracker.gradient(c, b)\n    array([[2.],\n           [5.]])\n\n    >>> with GradientTracker() as tracker:\n    ...     a = Variable([[2.0, 5.0]])\n    ...     b = a ** 3\n    >>> tracker.gradient(b, a)\n    array([[12., 75.]])\n    \"\"\"\n\n    instance = None\n\n    def __new__(cls) -> Self:\n        \"\"\"\n        Executes at the creation of class object and returns if\n        object is already created. This class follows singleton\n        design pattern.\n        \"\"\"\n        if cls.instance is None:\n            cls.instance = super().__new__(cls)\n        return cls.instance\n\n    def __init__(self) -> None:\n        self.enabled = False\n\n    def __enter__(self) -> Self:\n        self.enabled = True\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> None:\n        self.enabled = False\n\n    def append(\n        self,\n        op_type: OpType,\n        params: list[Variable],\n        output: Variable,\n        other_params: dict | None = None,\n    ) -> None:\n        \"\"\"\n        Adds Operation object to the related Variable objects for\n        creating computational graph for calculating gradients.\n\n        Args:\n            op_type: Operation type\n            params: Input parameters to the operation\n            output: Output variable of the operation\n        \"\"\"\n        operation = Operation(op_type, other_params=other_params)\n        param_nodes = []\n        for param in params:\n            param.add_param_to(operation)\n            param_nodes.append(param)\n        output.add_result_of(operation)\n\n        operation.add_params(param_nodes)\n        operation.add_output(output)\n\n    def gradient(self, target: Variable, source: Variable) -> np.ndarray | None:\n        \"\"\"\n        Reverse accumulation of partial derivatives to calculate gradients\n        of target variable with respect to source variable.\n\n        Args:\n            target: target variable for which gradients are calculated.\n            source: source variable with respect to which the gradients are\n            calculated.\n\n        Returns:\n            Gradient of the source variable with respect to the target variable\n        \"\"\"\n\n        # partial derivatives with respect to target\n        partial_deriv = defaultdict(lambda: 0)\n        partial_deriv[target] = np.ones_like(target.to_ndarray())\n\n        # iterating through each operations in the computation graph\n        operation_queue = [target.result_of]\n        while len(operation_queue) > 0:\n            operation = operation_queue.pop()\n            for param in operation.params:\n                # as per the chain rule, multiplying partial derivatives\n                # of variables with respect to the target\n                dparam_doutput = self.derivative(param, operation)\n                dparam_dtarget = dparam_doutput * partial_deriv[operation.output]\n                partial_deriv[param] += dparam_dtarget\n\n                if param.result_of and param.result_of != OpType.NOOP:\n                    operation_queue.append(param.result_of)\n\n        return partial_deriv.get(source)\n\n    def derivative(self, param: Variable, operation: Operation) -> np.ndarray:\n        \"\"\"\n        Compute the derivative of given operation/function\n\n        Args:\n            param: variable to be differentiated\n            operation: function performed on the input variable\n\n        Returns:\n            Derivative of input variable with respect to the output of\n            the operation\n        \"\"\"\n        params = operation.params\n\n        if operation == OpType.ADD:\n            return np.ones_like(params[0].to_ndarray(), dtype=np.float64)\n        if operation == OpType.SUB:\n            if params[0] == param:\n                return np.ones_like(params[0].to_ndarray(), dtype=np.float64)\n            return -np.ones_like(params[1].to_ndarray(), dtype=np.float64)\n        if operation == OpType.MUL:\n            return (\n                params[1].to_ndarray().T\n                if params[0] == param\n                else params[0].to_ndarray().T\n            )\n        if operation == OpType.DIV:\n            if params[0] == param:\n                return 1 / params[1].to_ndarray()\n            return -params[0].to_ndarray() / (params[1].to_ndarray() ** 2)\n        if operation == OpType.MATMUL:\n            return (\n                params[1].to_ndarray().T\n                if params[0] == param\n                else params[0].to_ndarray().T\n            )\n        if operation == OpType.POWER:\n            power = operation.other_params[\"power\"]\n            return power * (params[0].to_ndarray() ** (power - 1))\n\n        err_msg = f\"invalid operation type: {operation.op_type}\"\n        raise ValueError(err_msg)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "machine_learning/apriori_algorithm.py": "\"\"\"\nApriori Algorithm is a Association rule mining technique, also known as market basket\nanalysis, aims to discover interesting relationships or associations among a set of\nitems in a transactional or relational database.\n\nFor example, Apriori Algorithm states: \"If a customer buys item A and item B, then they\nare likely to buy item C.\"  This rule suggests a relationship between items A, B, and C,\nindicating that customers who purchased A and B are more likely to also purchase item C.\n\nWIKI: https://en.wikipedia.org/wiki/Apriori_algorithm\nExamples: https://www.kaggle.com/code/earthian/apriori-association-rules-mining\n\"\"\"\n\nfrom itertools import combinations\n\n\ndef load_data() -> list[list[str]]:\n    \"\"\"\n    Returns a sample transaction dataset.\n\n    >>> load_data()\n    [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]\n    \"\"\"\n    return [[\"milk\"], [\"milk\", \"butter\"], [\"milk\", \"bread\"], [\"milk\", \"bread\", \"chips\"]]\n\n\ndef prune(itemset: list, candidates: list, length: int) -> list:\n    \"\"\"\n    Prune candidate itemsets that are not frequent.\n    The goal of pruning is to filter out candidate itemsets that are not frequent.  This\n    is done by checking if all the (k-1) subsets of a candidate itemset are present in\n    the frequent itemsets of the previous iteration (valid subsequences of the frequent\n    itemsets from the previous iteration).\n\n    Prunes candidate itemsets that are not frequent.\n\n    >>> itemset = ['X', 'Y', 'Z']\n    >>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n    >>> prune(itemset, candidates, 2)\n    [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]\n\n    >>> itemset = ['1', '2', '3', '4']\n    >>> candidates = ['1', '2', '4']\n    >>> prune(itemset, candidates, 3)\n    []\n    \"\"\"\n    pruned = []\n    for candidate in candidates:\n        is_subsequence = True\n        for item in candidate:\n            if item not in itemset or itemset.count(item) < length - 1:\n                is_subsequence = False\n                break\n        if is_subsequence:\n            pruned.append(candidate)\n    return pruned\n\n\ndef apriori(data: list[list[str]], min_support: int) -> list[tuple[list[str], int]]:\n    \"\"\"\n    Returns a list of frequent itemsets and their support counts.\n\n    >>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]\n    >>> apriori(data, 2)\n    [(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]\n\n    >>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]\n    >>> apriori(data, 3)\n    []\n    \"\"\"\n    itemset = [list(transaction) for transaction in data]\n    frequent_itemsets = []\n    length = 1\n\n    while itemset:\n        # Count itemset support\n        counts = [0] * len(itemset)\n        for transaction in data:\n            for j, candidate in enumerate(itemset):\n                if all(item in transaction for item in candidate):\n                    counts[j] += 1\n\n        # Prune infrequent itemsets\n        itemset = [item for i, item in enumerate(itemset) if counts[i] >= min_support]\n\n        # Append frequent itemsets (as a list to maintain order)\n        for i, item in enumerate(itemset):\n            frequent_itemsets.append((sorted(item), counts[i]))\n\n        length += 1\n        itemset = prune(itemset, list(combinations(itemset, length)), length)\n\n    return frequent_itemsets\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Apriori algorithm for finding frequent itemsets.\n\n    Args:\n        data: A list of transactions, where each transaction is a list of items.\n        min_support: The minimum support threshold for frequent itemsets.\n\n    Returns:\n        A list of frequent itemsets along with their support counts.\n    \"\"\"\n    import doctest\n\n    doctest.testmod()\n\n    # user-defined threshold or minimum support level\n    frequent_itemsets = apriori(data=load_data(), min_support=2)\n    print(\"\\n\".join(f\"{itemset}: {support}\" for itemset, support in frequent_itemsets))\n", "machine_learning/gradient_descent.py": "\"\"\"\nImplementation of gradient descent algorithm for minimizing cost of a linear hypothesis\nfunction.\n\"\"\"\n\nimport numpy as np\n\n# List of input, output pairs\ntrain_data = (\n    ((5, 2, 3), 15),\n    ((6, 5, 9), 25),\n    ((11, 12, 13), 41),\n    ((1, 1, 1), 8),\n    ((11, 12, 13), 41),\n)\ntest_data = (((515, 22, 13), 555), ((61, 35, 49), 150))\nparameter_vector = [2, 4, 1, 5]\nm = len(train_data)\nLEARNING_RATE = 0.009\n\n\ndef _error(example_no, data_set=\"train\"):\n    \"\"\"\n    :param data_set: train data or test data\n    :param example_no: example number whose error has to be checked\n    :return: error in example pointed by example number.\n    \"\"\"\n    return calculate_hypothesis_value(example_no, data_set) - output(\n        example_no, data_set\n    )\n\n\ndef _hypothesis_value(data_input_tuple):\n    \"\"\"\n    Calculates hypothesis function value for a given input\n    :param data_input_tuple: Input tuple of a particular example\n    :return: Value of hypothesis function at that point.\n    Note that there is an 'biased input' whose value is fixed as 1.\n    It is not explicitly mentioned in input data.. But, ML hypothesis functions use it.\n    So, we have to take care of it separately. Line 36 takes care of it.\n    \"\"\"\n    hyp_val = 0\n    for i in range(len(parameter_vector) - 1):\n        hyp_val += data_input_tuple[i] * parameter_vector[i + 1]\n    hyp_val += parameter_vector[0]\n    return hyp_val\n\n\ndef output(example_no, data_set):\n    \"\"\"\n    :param data_set: test data or train data\n    :param example_no: example whose output is to be fetched\n    :return: output for that example\n    \"\"\"\n    if data_set == \"train\":\n        return train_data[example_no][1]\n    elif data_set == \"test\":\n        return test_data[example_no][1]\n    return None\n\n\ndef calculate_hypothesis_value(example_no, data_set):\n    \"\"\"\n    Calculates hypothesis value for a given example\n    :param data_set: test data or train_data\n    :param example_no: example whose hypothesis value is to be calculated\n    :return: hypothesis value for that example\n    \"\"\"\n    if data_set == \"train\":\n        return _hypothesis_value(train_data[example_no][0])\n    elif data_set == \"test\":\n        return _hypothesis_value(test_data[example_no][0])\n    return None\n\n\ndef summation_of_cost_derivative(index, end=m):\n    \"\"\"\n    Calculates the sum of cost function derivative\n    :param index: index wrt derivative is being calculated\n    :param end: value where summation ends, default is m, number of examples\n    :return: Returns the summation of cost derivative\n    Note: If index is -1, this means we are calculating summation wrt to biased\n        parameter.\n    \"\"\"\n    summation_value = 0\n    for i in range(end):\n        if index == -1:\n            summation_value += _error(i)\n        else:\n            summation_value += _error(i) * train_data[i][0][index]\n    return summation_value\n\n\ndef get_cost_derivative(index):\n    \"\"\"\n    :param index: index of the parameter vector wrt to derivative is to be calculated\n    :return: derivative wrt to that index\n    Note: If index is -1, this means we are calculating summation wrt to biased\n        parameter.\n    \"\"\"\n    cost_derivative_value = summation_of_cost_derivative(index, m) / m\n    return cost_derivative_value\n\n\ndef run_gradient_descent():\n    global parameter_vector\n    # Tune these values to set a tolerance value for predicted output\n    absolute_error_limit = 0.000002\n    relative_error_limit = 0\n    j = 0\n    while True:\n        j += 1\n        temp_parameter_vector = [0, 0, 0, 0]\n        for i in range(len(parameter_vector)):\n            cost_derivative = get_cost_derivative(i - 1)\n            temp_parameter_vector[i] = (\n                parameter_vector[i] - LEARNING_RATE * cost_derivative\n            )\n        if np.allclose(\n            parameter_vector,\n            temp_parameter_vector,\n            atol=absolute_error_limit,\n            rtol=relative_error_limit,\n        ):\n            break\n        parameter_vector = temp_parameter_vector\n    print((\"Number of iterations:\", j))\n\n\ndef test_gradient_descent():\n    for i in range(len(test_data)):\n        print((\"Actual output value:\", output(i, \"test\")))\n        print((\"Hypothesis output:\", calculate_hypothesis_value(i, \"test\")))\n\n\nif __name__ == \"__main__\":\n    run_gradient_descent()\n    print(\"\\nTesting gradient descent for a linear hypothesis function.\\n\")\n    test_gradient_descent()\n", "machine_learning/lstm/__init__.py": "", "machine_learning/lstm/lstm_prediction.py": "\"\"\"\nCreate a Long Short Term Memory (LSTM) network model\nAn LSTM is a type of Recurrent Neural Network (RNN) as discussed at:\n* https://colah.github.io/posts/2015-08-Understanding-LSTMs\n* https://en.wikipedia.org/wiki/Long_short-term_memory\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom keras.layers import LSTM, Dense\nfrom keras.models import Sequential\nfrom sklearn.preprocessing import MinMaxScaler\n\nif __name__ == \"__main__\":\n    \"\"\"\n    First part of building a model is to get the data and prepare\n    it for our model. You can use any dataset for stock prediction\n    make sure you set the price column on line number 21.  Here we\n    use a dataset which have the price on 3rd column.\n    \"\"\"\n    sample_data = pd.read_csv(\"sample_data.csv\", header=None)\n    len_data = sample_data.shape[:1][0]\n    # If you're using some other dataset input the target column\n    actual_data = sample_data.iloc[:, 1:2]\n    actual_data = actual_data.to_numpy().reshape(len_data, 1)\n    actual_data = MinMaxScaler().fit_transform(actual_data)\n    look_back = 10\n    forward_days = 5\n    periods = 20\n    division = len_data - periods * look_back\n    train_data = actual_data[:division]\n    test_data = actual_data[division - look_back :]\n    train_x, train_y = [], []\n    test_x, test_y = [], []\n\n    for i in range(len(train_data) - forward_days - look_back + 1):\n        train_x.append(train_data[i : i + look_back])\n        train_y.append(train_data[i + look_back : i + look_back + forward_days])\n    for i in range(len(test_data) - forward_days - look_back + 1):\n        test_x.append(test_data[i : i + look_back])\n        test_y.append(test_data[i + look_back : i + look_back + forward_days])\n    x_train = np.array(train_x)\n    x_test = np.array(test_x)\n    y_train = np.array([list(i.ravel()) for i in train_y])\n    y_test = np.array([list(i.ravel()) for i in test_y])\n\n    model = Sequential()\n    model.add(LSTM(128, input_shape=(look_back, 1), return_sequences=True))\n    model.add(LSTM(64, input_shape=(128, 1)))\n    model.add(Dense(forward_days))\n    model.compile(loss=\"mean_squared_error\", optimizer=\"adam\")\n    history = model.fit(\n        x_train, y_train, epochs=150, verbose=1, shuffle=True, batch_size=4\n    )\n    pred = model.predict(x_test)\n", "machine_learning/local_weighted_learning/local_weighted_learning.py": "\"\"\"\nLocally weighted linear regression, also called local regression, is a type of\nnon-parametric linear regression that prioritizes data closest to a given\nprediction point. The algorithm estimates the vector of model coefficients \u03b2\nusing weighted least squares regression:\n\n\u03b2 = (X\u1d40WX)\u207b\u00b9(X\u1d40Wy),\n\nwhere X is the design matrix, y is the response vector, and W is the diagonal\nweight matrix.\n\nThis implementation calculates w\u1d62, the weight of the ith training sample, using\nthe Gaussian weight:\n\nw\u1d62 = exp(-\u2016x\u1d62 - x\u2016\u00b2/(2\u03c4\u00b2)),\n\nwhere x\u1d62 is the ith training sample, x is the prediction point, \u03c4 is the\n\"bandwidth\", and \u2016x\u2016 is the Euclidean norm (also called the 2-norm or the L\u00b2\nnorm). The bandwidth \u03c4 controls how quickly the weight of a training sample\ndecreases as its distance from the prediction point increases. One can think of\nthe Gaussian weight as a bell curve centered around the prediction point: a\ntraining sample is weighted lower if it's farther from the center, and \u03c4\ncontrols the spread of the bell curve.\n\nOther types of locally weighted regression such as locally estimated scatterplot\nsmoothing (LOESS) typically use different weight functions.\n\nReferences:\n    - https://en.wikipedia.org/wiki/Local_regression\n    - https://en.wikipedia.org/wiki/Weighted_least_squares\n    - https://cs229.stanford.edu/notes2022fall/main_notes.pdf\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef weight_matrix(point: np.ndarray, x_train: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Calculate the weight of every point in the training data around a given\n    prediction point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n\n    Returns:\n        m x m weight matrix around the prediction point, where m is the size of\n        the training set\n    >>> weight_matrix(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     0.6\n    ... )\n    array([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],\n           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],\n           [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])\n    \"\"\"\n    m = len(x_train)  # Number of training samples\n    weights = np.eye(m)  # Initialize weights as identity matrix\n    for j in range(m):\n        diff = point - x_train[j]\n        weights[j, j] = np.exp(diff @ diff.T / (-2.0 * tau**2))\n\n    return weights\n\n\ndef local_weight(\n    point: np.ndarray, x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate the local weights at a given prediction point using the weight\n    matrix for that point\n\n    Args:\n        point: x-value at which the prediction is being made\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n    Returns:\n        ndarray of local weights\n    >>> local_weight(\n    ...     np.array([1., 1.]),\n    ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([[0.00873174],\n           [0.08272556]])\n    \"\"\"\n    weight_mat = weight_matrix(point, x_train, tau)\n    weight = np.linalg.inv(x_train.T @ weight_mat @ x_train) @ (\n        x_train.T @ weight_mat @ y_train.T\n    )\n\n    return weight\n\n\ndef local_weight_regression(\n    x_train: np.ndarray, y_train: np.ndarray, tau: float\n) -> np.ndarray:\n    \"\"\"\n    Calculate predictions for each point in the training data\n\n    Args:\n        x_train: ndarray of x-values for training\n        y_train: ndarray of y-values for training\n        tau: bandwidth value, controls how quickly the weight of training values\n            decreases as the distance from the prediction point increases\n\n    Returns:\n        ndarray of predictions\n    >>> local_weight_regression(\n    ...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),\n    ...     np.array([[1.01, 1.66, 3.5]]),\n    ...     0.6\n    ... )\n    array([1.07173261, 1.65970737, 3.50160179])\n    \"\"\"\n    y_pred = np.zeros(len(x_train))  # Initialize array of predictions\n    for i, item in enumerate(x_train):\n        y_pred[i] = np.dot(item, local_weight(item, x_train, y_train, tau)).item()\n\n    return y_pred\n\n\ndef load_data(\n    dataset_name: str, x_name: str, y_name: str\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Load data from seaborn and split it into x and y points\n    >>> pass    # No doctests, function is for demo purposes only\n    \"\"\"\n    import seaborn as sns\n\n    data = sns.load_dataset(dataset_name)\n    x_data = np.array(data[x_name])\n    y_data = np.array(data[y_name])\n\n    one = np.ones(len(y_data))\n\n    # pairing elements of one and x_data\n    x_train = np.column_stack((one, x_data))\n\n    return x_train, x_data, y_data\n\n\ndef plot_preds(\n    x_train: np.ndarray,\n    preds: np.ndarray,\n    x_data: np.ndarray,\n    y_data: np.ndarray,\n    x_name: str,\n    y_name: str,\n) -> None:\n    \"\"\"\n    Plot predictions and display the graph\n    >>> pass    # No doctests, function is for demo purposes only\n    \"\"\"\n    x_train_sorted = np.sort(x_train, axis=0)\n    plt.scatter(x_data, y_data, color=\"blue\")\n    plt.plot(\n        x_train_sorted[:, 1],\n        preds[x_train[:, 1].argsort(0)],\n        color=\"yellow\",\n        linewidth=5,\n    )\n    plt.title(\"Local Weighted Regression\")\n    plt.xlabel(x_name)\n    plt.ylabel(y_name)\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Demo with a dataset from the seaborn module\n    training_data_x, total_bill, tip = load_data(\"tips\", \"total_bill\", \"tip\")\n    predictions = local_weight_regression(training_data_x, tip, 5)\n    plot_preds(training_data_x, predictions, total_bill, tip, \"total_bill\", \"tip\")\n", "machine_learning/local_weighted_learning/__init__.py": "", "machine_learning/forecasting/run.py": "\"\"\"\nthis is code for forecasting\nbut I modified it and used it for safety checker of data\nfor ex: you have an online shop and for some reason some data are\nmissing (the amount of data that u expected are not supposed to be)\n        then we can use it\n*ps : 1. ofc we can use normal statistic method but in this case\n         the data is quite absurd and only a little^^\n      2. ofc u can use this and modified it for forecasting purpose\n         for the next 3 months sales or something,\n         u can just adjust it for ur own purpose\n\"\"\"\n\nfrom warnings import simplefilter\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.svm import SVR\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\n\n\ndef linear_regression_prediction(\n    train_dt: list, train_usr: list, train_mtch: list, test_dt: list, test_mtch: list\n) -> float:\n    \"\"\"\n    First method: linear regression\n    input : training data (date, total_user, total_event) in list of float\n    output : list of total user prediction in float\n    >>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2])\n    >>> abs(n - 5.0) < 1e-6  # Checking precision because of floating point errors\n    True\n    \"\"\"\n    x = np.array([[1, item, train_mtch[i]] for i, item in enumerate(train_dt)])\n    y = np.array(train_usr)\n    beta = np.dot(np.dot(np.linalg.inv(np.dot(x.transpose(), x)), x.transpose()), y)\n    return abs(beta[0] + test_dt[0] * beta[1] + test_mtch[0] + beta[2])\n\n\ndef sarimax_predictor(train_user: list, train_match: list, test_match: list) -> float:\n    \"\"\"\n    second method: Sarimax\n    sarimax is a statistic method which using previous input\n    and learn its pattern to predict future data\n    input : training data (total_user, with exog data = total_event) in list of float\n    output : list of total user prediction in float\n    >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])\n    6.6666671111109626\n    \"\"\"\n    # Suppress the User Warning raised by SARIMAX due to insufficient observations\n    simplefilter(\"ignore\", UserWarning)\n    order = (1, 2, 1)\n    seasonal_order = (1, 1, 1, 7)\n    model = SARIMAX(\n        train_user, exog=train_match, order=order, seasonal_order=seasonal_order\n    )\n    model_fit = model.fit(disp=False, maxiter=600, method=\"nm\")\n    result = model_fit.predict(1, len(test_match), exog=[test_match])\n    return result[0]\n\n\ndef support_vector_regressor(x_train: list, x_test: list, train_user: list) -> float:\n    \"\"\"\n    Third method: Support vector regressor\n    svr is quite the same with svm(support vector machine)\n    it uses the same principles as the SVM for classification,\n    with only a few minor differences and the only different is that\n    it suits better for regression purpose\n    input : training data (date, total_user, total_event) in list of float\n    where x = list of set (date and total event)\n    output : list of total user prediction in float\n    >>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4])\n    1.634932078116079\n    \"\"\"\n    regressor = SVR(kernel=\"rbf\", C=1, gamma=0.1, epsilon=0.1)\n    regressor.fit(x_train, train_user)\n    y_pred = regressor.predict(x_test)\n    return y_pred[0]\n\n\ndef interquartile_range_checker(train_user: list) -> float:\n    \"\"\"\n    Optional method: interquatile range\n    input : list of total user in float\n    output : low limit of input in float\n    this method can be used to check whether some data is outlier or not\n    >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])\n    2.8\n    \"\"\"\n    train_user.sort()\n    q1 = np.percentile(train_user, 25)\n    q3 = np.percentile(train_user, 75)\n    iqr = q3 - q1\n    low_lim = q1 - (iqr * 0.1)\n    return low_lim\n\n\ndef data_safety_checker(list_vote: list, actual_result: float) -> bool:\n    \"\"\"\n    Used to review all the votes (list result prediction)\n    and compare it to the actual result.\n    input : list of predictions\n    output : print whether it's safe or not\n    >>> data_safety_checker([2, 3, 4], 5.0)\n    False\n    \"\"\"\n    safe = 0\n    not_safe = 0\n\n    if not isinstance(actual_result, float):\n        raise TypeError(\"Actual result should be float. Value passed is a list\")\n\n    for i in list_vote:\n        if i > actual_result:\n            safe = not_safe + 1\n        elif abs(abs(i) - abs(actual_result)) <= 0.1:\n            safe += 1\n        else:\n            not_safe += 1\n    return safe > not_safe\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    data column = total user in a day, how much online event held in one day,\n    what day is that(sunday-saturday)\n    \"\"\"\n    data_input_df = pd.read_csv(\"ex_data.csv\")\n\n    # start normalization\n    normalize_df = Normalizer().fit_transform(data_input_df.values)\n    # split data\n    total_date = normalize_df[:, 2].tolist()\n    total_user = normalize_df[:, 0].tolist()\n    total_match = normalize_df[:, 1].tolist()\n\n    # for svr (input variable = total date and total match)\n    x = normalize_df[:, [1, 2]].tolist()\n    x_train = x[: len(x) - 1]\n    x_test = x[len(x) - 1 :]\n\n    # for linear regression & sarimax\n    train_date = total_date[: len(total_date) - 1]\n    train_user = total_user[: len(total_user) - 1]\n    train_match = total_match[: len(total_match) - 1]\n\n    test_date = total_date[len(total_date) - 1 :]\n    test_user = total_user[len(total_user) - 1 :]\n    test_match = total_match[len(total_match) - 1 :]\n\n    # voting system with forecasting\n    res_vote = [\n        linear_regression_prediction(\n            train_date, train_user, train_match, test_date, test_match\n        ),\n        sarimax_predictor(train_user, train_match, test_match),\n        support_vector_regressor(x_train, x_test, train_user),\n    ]\n\n    # check the safety of today's data\n    not_str = \"\" if data_safety_checker(res_vote, test_user[0]) else \"not \"\n    print(f\"Today's data is {not_str}safe.\")\n", "machine_learning/forecasting/__init__.py": "", "networking_flow/ford_fulkerson.py": "\"\"\"\nFord-Fulkerson Algorithm for Maximum Flow Problem\n* https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\n\nDescription:\n    (1) Start with initial flow as 0\n    (2) Choose the augmenting path from source to sink and add the path to flow\n\"\"\"\n\ngraph = [\n    [0, 16, 13, 0, 0, 0],\n    [0, 0, 10, 12, 0, 0],\n    [0, 4, 0, 0, 14, 0],\n    [0, 0, 9, 0, 0, 20],\n    [0, 0, 0, 7, 0, 4],\n    [0, 0, 0, 0, 0, 0],\n]\n\n\ndef breadth_first_search(graph: list, source: int, sink: int, parents: list) -> bool:\n    \"\"\"\n    This function returns True if there is a node that has not iterated.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n        parents: Parent list\n\n    Returns:\n        True if there is a node that has not iterated.\n\n    >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])\n    True\n    >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])\n    Traceback (most recent call last):\n        ...\n    IndexError: list index out of range\n    \"\"\"\n    visited = [False] * len(graph)  # Mark all nodes as not visited\n    queue = []  # breadth-first search queue\n\n    # Source node\n    queue.append(source)\n    visited[source] = True\n\n    while queue:\n        u = queue.pop(0)  # Pop the front node\n        # Traverse all adjacent nodes of u\n        for ind, node in enumerate(graph[u]):\n            if visited[ind] is False and node > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parents[ind] = u\n    return visited[sink]\n\n\ndef ford_fulkerson(graph: list, source: int, sink: int) -> int:\n    \"\"\"\n    This function returns the maximum flow from source to sink in the given graph.\n\n    CAUTION: This function changes the given graph.\n\n    Args:\n        graph: Adjacency matrix of graph\n        source: Source\n        sink: Sink\n\n    Returns:\n        Maximum flow\n\n    >>> test_graph = [\n    ...     [0, 16, 13, 0, 0, 0],\n    ...     [0, 0, 10, 12, 0, 0],\n    ...     [0, 4, 0, 0, 14, 0],\n    ...     [0, 0, 9, 0, 0, 20],\n    ...     [0, 0, 0, 7, 0, 4],\n    ...     [0, 0, 0, 0, 0, 0],\n    ... ]\n    >>> ford_fulkerson(test_graph, 0, 5)\n    23\n    \"\"\"\n    # This array is filled by breadth-first search and to store path\n    parent = [-1] * (len(graph))\n    max_flow = 0\n\n    # While there is a path from source to sink\n    while breadth_first_search(graph, source, sink, parent):\n        path_flow = int(1e9)  # Infinite value\n        s = sink\n\n        while s != source:\n            # Find the minimum value in the selected path\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n        v = sink\n\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    return max_flow\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    print(f\"{ford_fulkerson(graph, source=0, sink=5) = }\")\n", "networking_flow/minimum_cut.py": "# Minimum cut on Ford_Fulkerson algorithm.\n\ntest_graph = [\n    [0, 16, 13, 0, 0, 0],\n    [0, 0, 10, 12, 0, 0],\n    [0, 4, 0, 0, 14, 0],\n    [0, 0, 9, 0, 0, 20],\n    [0, 0, 0, 7, 0, 4],\n    [0, 0, 0, 0, 0, 0],\n]\n\n\ndef bfs(graph, s, t, parent):\n    # Return True if there is node that has not iterated.\n    visited = [False] * len(graph)\n    queue = [s]\n    visited[s] = True\n\n    while queue:\n        u = queue.pop(0)\n        for ind in range(len(graph[u])):\n            if visited[ind] is False and graph[u][ind] > 0:\n                queue.append(ind)\n                visited[ind] = True\n                parent[ind] = u\n\n    return visited[t]\n\n\ndef mincut(graph, source, sink):\n    \"\"\"This array is filled by BFS and to store path\n    >>> mincut(test_graph, source=0, sink=5)\n    [(1, 3), (4, 3), (4, 5)]\n    \"\"\"\n    parent = [-1] * (len(graph))\n    max_flow = 0\n    res = []\n    temp = [i[:] for i in graph]  # Record original cut, copy.\n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"Inf\")\n        s = sink\n\n        while s != source:\n            # Find the minimum value in select path\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n\n        max_flow += path_flow\n        v = sink\n\n        while v != source:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n\n    for i in range(len(graph)):\n        for j in range(len(graph[0])):\n            if graph[i][j] == 0 and temp[i][j] > 0:\n                res.append((i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(mincut(test_graph, source=0, sink=5))\n", "networking_flow/__init__.py": "", "searches/interpolation_search.py": "\"\"\"\nThis is pure Python implementation of interpolation search algorithm\n\"\"\"\n\n\ndef interpolation_search(sorted_collection, item):\n    \"\"\"Pure implementation of interpolation search algorithm in Python\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n    \"\"\"\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        # avoid divided by 0 during interpolation\n        if sorted_collection[left] == sorted_collection[right]:\n            if sorted_collection[left] == item:\n                return left\n            else:\n                return None\n\n        point = left + ((item - sorted_collection[left]) * (right - left)) // (\n            sorted_collection[right] - sorted_collection[left]\n        )\n\n        # out of range check\n        if point < 0 or point >= len(sorted_collection):\n            return None\n\n        current_item = sorted_collection[point]\n        if current_item == item:\n            return point\n        elif point < left:\n            right = left\n            left = point\n        elif point > right:\n            left = right\n            right = point\n        elif item < current_item:\n            right = point - 1\n        else:\n            left = point + 1\n    return None\n\n\ndef interpolation_search_by_recursion(sorted_collection, item, left, right):\n    \"\"\"Pure implementation of interpolation search algorithm in Python by recursion\n    Be careful collection must be ascending sorted, otherwise result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of found item or None if item is not found\n    \"\"\"\n\n    # avoid divided by 0 during interpolation\n    if sorted_collection[left] == sorted_collection[right]:\n        if sorted_collection[left] == item:\n            return left\n        else:\n            return None\n\n    point = left + ((item - sorted_collection[left]) * (right - left)) // (\n        sorted_collection[right] - sorted_collection[left]\n    )\n\n    # out of range check\n    if point < 0 or point >= len(sorted_collection):\n        return None\n\n    if sorted_collection[point] == item:\n        return point\n    elif point < left:\n        return interpolation_search_by_recursion(sorted_collection, item, point, left)\n    elif point > right:\n        return interpolation_search_by_recursion(sorted_collection, item, right, left)\n    elif sorted_collection[point] > item:\n        return interpolation_search_by_recursion(\n            sorted_collection, item, left, point - 1\n        )\n    else:\n        return interpolation_search_by_recursion(\n            sorted_collection, item, point + 1, right\n        )\n\n\ndef __assert_sorted(collection):\n    \"\"\"Check if collection is ascending sorted, if not - raises :py:class:`ValueError`\n    :param collection: collection\n    :return: True if collection is ascending sorted\n    :raise: :py:class:`ValueError` if collection is not ascending sorted\n    Examples:\n    >>> __assert_sorted([0, 1, 2, 4])\n    True\n    >>> __assert_sorted([10, -1, 5])\n    Traceback (most recent call last):\n        ...\n    ValueError: Collection must be ascending sorted\n    \"\"\"\n    if collection != sorted(collection):\n        raise ValueError(\"Collection must be ascending sorted\")\n    return True\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    \"\"\"\n        user_input = input('Enter numbers separated by comma:\\n').strip()\n    collection = [int(item) for item in user_input.split(',')]\n    try:\n        __assert_sorted(collection)\n    except ValueError:\n        sys.exit('Sequence must be ascending sorted to apply interpolation search')\n\n    target_input = input('Enter a single number to be found in the list:\\n')\n    target = int(target_input)\n        \"\"\"\n\n    debug = 0\n    if debug == 1:\n        collection = [10, 30, 40, 45, 50, 66, 77, 93]\n        try:\n            __assert_sorted(collection)\n        except ValueError:\n            sys.exit(\"Sequence must be ascending sorted to apply interpolation search\")\n        target = 67\n\n    result = interpolation_search(collection, target)\n    if result is not None:\n        print(f\"{target} found at positions: {result}\")\n    else:\n        print(\"Not found\")\n", "searches/double_linear_search_recursion.py": "def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:\n    \"\"\"\n    Iterate through the array to find the index of key using recursion.\n    :param list_data: the list to be searched\n    :param key: the key to be searched\n    :param left: the index of first element\n    :param right: the index of last element\n    :return: the index of key value if found, -1 otherwise.\n\n    >>> search(list(range(0, 11)), 5)\n    5\n    >>> search([1, 2, 4, 5, 3], 4)\n    2\n    >>> search([1, 2, 4, 5, 3], 6)\n    -1\n    >>> search([5], 5)\n    0\n    >>> search([], 1)\n    -1\n    \"\"\"\n    right = right or len(list_data) - 1\n    if left > right:\n        return -1\n    elif list_data[left] == key:\n        return left\n    elif list_data[right] == key:\n        return right\n    else:\n        return search(list_data, key, left + 1, right - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "searches/tabu_search.py": "\"\"\"\nThis is pure Python implementation of Tabu search algorithm for a Travelling Salesman\nProblem, that the distances between the cities are symmetric (the distance between city\n'a' and city 'b' is the same between city 'b' and city 'a').\nThe TSP can be represented into a graph. The cities are represented by nodes and the\ndistance between them is represented by the weight of the ark between the nodes.\n\nThe .txt file with the graph has the form:\n\nnode1 node2 distance_between_node1_and_node2\nnode1 node3 distance_between_node1_and_node3\n...\n\nBe careful node1, node2 and the distance between them, must exist only once. This means\nin the .txt file should not exist:\nnode1 node2 distance_between_node1_and_node2\nnode2 node1 distance_between_node2_and_node1\n\nFor pytests run following command:\npytest\n\nFor manual testing run:\npython tabu_search.py -f your_file_name.txt -number_of_iterations_of_tabu_search \\\n    -s size_of_tabu_search\ne.g. python tabu_search.py -f tabudata2.txt -i 4 -s 3\n\"\"\"\n\nimport argparse\nimport copy\n\n\ndef generate_neighbours(path):\n    \"\"\"\n    Pure implementation of generating a dictionary of neighbors and the cost with each\n    neighbor, given a path file that includes a graph.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :return dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n\n    Example of dict_of_neighbours:\n    >>) dict_of_neighbours[a]\n    [[b,20],[c,18],[d,22],[e,26]]\n\n    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'\n    with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and\n    the node 'e' with distance 26.\n    \"\"\"\n\n    dict_of_neighbours = {}\n\n    with open(path) as f:\n        for line in f:\n            if line.split()[0] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[1], line.split()[2]])\n                dict_of_neighbours[line.split()[0]] = _list\n            else:\n                dict_of_neighbours[line.split()[0]].append(\n                    [line.split()[1], line.split()[2]]\n                )\n            if line.split()[1] not in dict_of_neighbours:\n                _list = []\n                _list.append([line.split()[0], line.split()[2]])\n                dict_of_neighbours[line.split()[1]] = _list\n            else:\n                dict_of_neighbours[line.split()[1]].append(\n                    [line.split()[0], line.split()[2]]\n                )\n\n    return dict_of_neighbours\n\n\ndef generate_first_solution(path, dict_of_neighbours):\n    \"\"\"\n    Pure implementation of generating the first solution for the Tabu search to start,\n    with the redundant resolution strategy. That means that we start from the starting\n    node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node\n    (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.\n    till we have visited all cities and return to the starting node.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :return distance_of_first_solution: The total distance that Travelling Salesman\n        will travel, if he follows the path in first_solution.\n    \"\"\"\n\n    with open(path) as f:\n        start_node = f.read(1)\n    end_node = start_node\n\n    first_solution = []\n\n    visiting = start_node\n\n    distance_of_first_solution = 0\n    while visiting not in first_solution:\n        minim = 10000\n        for k in dict_of_neighbours[visiting]:\n            if int(k[1]) < int(minim) and k[0] not in first_solution:\n                minim = k[1]\n                best_node = k[0]\n\n        first_solution.append(visiting)\n        distance_of_first_solution = distance_of_first_solution + int(minim)\n        visiting = best_node\n\n    first_solution.append(end_node)\n\n    position = 0\n    for k in dict_of_neighbours[first_solution[-2]]:\n        if k[0] == start_node:\n            break\n        position += 1\n\n    distance_of_first_solution = (\n        distance_of_first_solution\n        + int(dict_of_neighbours[first_solution[-2]][position][1])\n        - 10000\n    )\n    return first_solution, distance_of_first_solution\n\n\ndef find_neighborhood(solution, dict_of_neighbours):\n    \"\"\"\n    Pure implementation of generating the neighborhood (sorted by total distance of\n    each solution from lowest to highest) of a solution with 1-1 exchange method, that\n    means we exchange each node in a solution with each other node and generating a\n    number of solution named neighborhood.\n\n    :param solution: The solution in which we want to find the neighborhood.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return neighborhood_of_solution: A list that includes the solutions and the total\n        distance of each solution (in form of list) that are produced with 1-1 exchange\n        from the solution that the method took as an input\n\n    Example:\n    >>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],\n    ...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],\n    ...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],\n    ...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],\n    ...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],\n    ...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}\n    ...                   )  # doctest: +NORMALIZE_WHITESPACE\n    [['a', 'e', 'b', 'd', 'c', 'a', 90],\n     ['a', 'c', 'd', 'b', 'e', 'a', 90],\n     ['a', 'd', 'b', 'c', 'e', 'a', 93],\n     ['a', 'c', 'b', 'e', 'd', 'a', 102],\n     ['a', 'c', 'e', 'd', 'b', 'a', 113],\n     ['a', 'b', 'c', 'd', 'e', 'a', 119]]\n    \"\"\"\n\n    neighborhood_of_solution = []\n\n    for n in solution[1:-1]:\n        idx1 = solution.index(n)\n        for kn in solution[1:-1]:\n            idx2 = solution.index(kn)\n            if n == kn:\n                continue\n\n            _tmp = copy.deepcopy(solution)\n            _tmp[idx1] = kn\n            _tmp[idx2] = n\n\n            distance = 0\n\n            for k in _tmp[:-1]:\n                next_node = _tmp[_tmp.index(k) + 1]\n                for i in dict_of_neighbours[k]:\n                    if i[0] == next_node:\n                        distance = distance + int(i[1])\n            _tmp.append(distance)\n\n            if _tmp not in neighborhood_of_solution:\n                neighborhood_of_solution.append(_tmp)\n\n    index_of_last_item_in_the_list = len(neighborhood_of_solution[0]) - 1\n\n    neighborhood_of_solution.sort(key=lambda x: x[index_of_last_item_in_the_list])\n    return neighborhood_of_solution\n\n\ndef tabu_search(\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n):\n    \"\"\"\n    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\n    Python.\n\n    :param first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :param distance_of_first_solution: The total distance that Travelling Salesman will\n        travel, if he follows the path in first_solution.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :param iters: The number of iterations that Tabu search will execute.\n    :param size: The size of Tabu List.\n    :return best_solution_ever: The solution with the lowest distance that occurred\n        during the execution of Tabu search.\n    :return best_cost: The total distance that Travelling Salesman will travel, if he\n        follows the path in best_solution ever.\n    \"\"\"\n    count = 1\n    solution = first_solution\n    tabu_list = []\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    while count <= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = 0\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = len(best_solution) - 1\n\n        found = False\n        while not found:\n            i = 0\n            while i < len(best_solution):\n                if best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    break\n                i = i + 1\n\n            if [first_exchange_node, second_exchange_node] not in tabu_list and [\n                second_exchange_node,\n                first_exchange_node,\n            ] not in tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = True\n                solution = best_solution[:-1]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            else:\n                index_of_best_solution = index_of_best_solution + 1\n                best_solution = neighborhood[index_of_best_solution]\n\n        if len(tabu_list) >= size:\n            tabu_list.pop(0)\n\n        count = count + 1\n\n    return best_solution_ever, best_cost\n\n\ndef main(args=None):\n    dict_of_neighbours = generate_neighbours(args.File)\n\n    first_solution, distance_of_first_solution = generate_first_solution(\n        args.File, dict_of_neighbours\n    )\n\n    best_sol, best_cost = tabu_search(\n        first_solution,\n        distance_of_first_solution,\n        dict_of_neighbours,\n        args.Iterations,\n        args.Size,\n    )\n\n    print(f\"Best solution: {best_sol}, with total distance: {best_cost}.\")\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Tabu Search\")\n    parser.add_argument(\n        \"-f\",\n        \"--File\",\n        type=str,\n        help=\"Path to the file containing the data\",\n        required=True,\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--Iterations\",\n        type=int,\n        help=\"How many iterations the algorithm should perform\",\n        required=True,\n    )\n    parser.add_argument(\n        \"-s\", \"--Size\", type=int, help=\"Size of the tabu list\", required=True\n    )\n\n    # Pass the arguments to main method\n    main(parser.parse_args())\n", "searches/jump_search.py": "\"\"\"\nPure Python implementation of the jump search algorithm.\nThis algorithm iterates through a sorted collection with a step of n^(1/2),\nuntil the element compared is bigger than the one searched.\nIt will then perform a linear search until it matches the wanted number.\nIf not found, it returns -1.\n\nhttps://en.wikipedia.org/wiki/Jump_search\n\"\"\"\n\nimport math\nfrom collections.abc import Sequence\nfrom typing import Any, Protocol, TypeVar\n\n\nclass Comparable(Protocol):\n    def __lt__(self, other: Any, /) -> bool: ...\n\n\nT = TypeVar(\"T\", bound=Comparable)\n\n\ndef jump_search(arr: Sequence[T], item: T) -> int:\n    \"\"\"\n    Python implementation of the jump search algorithm.\n    Return the index if the `item` is found, otherwise return -1.\n\n    Examples:\n    >>> jump_search([0, 1, 2, 3, 4, 5], 3)\n    3\n    >>> jump_search([-5, -2, -1], -1)\n    2\n    >>> jump_search([0, 5, 10, 20], 8)\n    -1\n    >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)\n    10\n    >>> jump_search([\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"], \"ee\")\n    4\n    \"\"\"\n\n    arr_size = len(arr)\n    block_size = int(math.sqrt(arr_size))\n\n    prev = 0\n    step = block_size\n    while arr[min(step, arr_size) - 1] < item:\n        prev = step\n        step += block_size\n        if prev >= arr_size:\n            return -1\n\n    while arr[prev] < item:\n        prev += 1\n        if prev == min(step, arr_size):\n            return -1\n    if arr[prev] == item:\n        return prev\n    return -1\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by a comma:\\n\").strip()\n    array = [int(item) for item in user_input.split(\",\")]\n    x = int(input(\"Enter the number to be searched:\\n\"))\n\n    res = jump_search(array, x)\n    if res == -1:\n        print(\"Number not found!\")\n    else:\n        print(f\"Number {x} is at index {res}\")\n", "searches/sentinel_linear_search.py": "\"\"\"\nThis is pure Python implementation of sentinel linear search algorithm\n\nFor doctests run following command:\npython -m doctest -v sentinel_linear_search.py\nor\npython3 -m doctest -v sentinel_linear_search.py\n\nFor manual testing run:\npython sentinel_linear_search.py\n\"\"\"\n\n\ndef sentinel_linear_search(sequence, target):\n    \"\"\"Pure implementation of sentinel linear search algorithm in Python\n\n    :param sequence: some sequence with comparable items\n    :param target: item value to search\n    :return: index of found item or None if item is not found\n\n    Examples:\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)\n    0\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)\n    4\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)\n    1\n\n    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)\n\n    \"\"\"\n    sequence.append(target)\n\n    index = 0\n    while sequence[index] != target:\n        index += 1\n\n    sequence.pop()\n\n    if index == len(sequence):\n        return None\n\n    return index\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by comma:\\n\").strip()\n    sequence = [int(item) for item in user_input.split(\",\")]\n\n    target_input = input(\"Enter a single number to be found in the list:\\n\")\n    target = int(target_input)\n    result = sentinel_linear_search(sequence, target)\n    if result is not None:\n        print(f\"{target} found at positions: {result}\")\n    else:\n        print(\"Not found\")\n", "searches/simple_binary_search.py": "\"\"\"\nPure Python implementation of a binary search algorithm.\n\nFor doctests run following command:\npython3 -m doctest -v simple_binary_search.py\n\nFor manual testing run:\npython3 simple_binary_search.py\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef binary_search(a_list: list[int], item: int) -> bool:\n    \"\"\"\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> binary_search(test_list, 3)\n    False\n    >>> binary_search(test_list, 13)\n    True\n    >>> binary_search([4, 4, 5, 6, 7], 4)\n    True\n    >>> binary_search([4, 4, 5, 6, 7], -10)\n    False\n    >>> binary_search([-18, 2], -18)\n    True\n    >>> binary_search([5], 5)\n    True\n    >>> binary_search(['a', 'c', 'd'], 'c')\n    True\n    >>> binary_search(['a', 'c', 'd'], 'f')\n    False\n    >>> binary_search([], 1)\n    False\n    >>> binary_search([-.1, .1 , .8], .1)\n    True\n    >>> binary_search(range(-5000, 5000, 10), 80)\n    True\n    >>> binary_search(range(-5000, 5000, 10), 1255)\n    False\n    >>> binary_search(range(0, 10000, 5), 2)\n    False\n    \"\"\"\n    if len(a_list) == 0:\n        return False\n    midpoint = len(a_list) // 2\n    if a_list[midpoint] == item:\n        return True\n    if item < a_list[midpoint]:\n        return binary_search(a_list[:midpoint], item)\n    else:\n        return binary_search(a_list[midpoint + 1 :], item)\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by comma:\\n\").strip()\n    sequence = [int(item.strip()) for item in user_input.split(\",\")]\n    target = int(input(\"Enter the number to be found in the list:\\n\").strip())\n    not_str = \"\" if binary_search(sequence, target) else \"not \"\n    print(f\"{target} was {not_str}found in {sequence}\")\n", "searches/linear_search.py": "\"\"\"\nThis is pure Python implementation of linear search algorithm\n\nFor doctests run following command:\npython3 -m doctest -v linear_search.py\n\nFor manual testing run:\npython3 linear_search.py\n\"\"\"\n\n\ndef linear_search(sequence: list, target: int) -> int:\n    \"\"\"A pure Python implementation of a linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param target: item value to search\n    :return: index of found item or -1 if item is not found\n\n    Examples:\n    >>> linear_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> linear_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> linear_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> linear_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    for index, item in enumerate(sequence):\n        if item == target:\n            return index\n    return -1\n\n\ndef rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:\n    \"\"\"\n    A pure Python implementation of a recursive linear search algorithm\n\n    :param sequence: a collection with comparable items (as sorted items not required\n        in Linear Search)\n    :param low: Lower bound of the array\n    :param high: Higher bound of the array\n    :param target: The element to be found\n    :return: Index of the key or -1 if key not found\n\n    Examples:\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)\n    0\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)\n    4\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)\n    1\n    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)\n    -1\n    \"\"\"\n    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):\n        raise Exception(\"Invalid upper or lower bound!\")\n    if high < low:\n        return -1\n    if sequence[low] == target:\n        return low\n    if sequence[high] == target:\n        return high\n    return rec_linear_search(sequence, low + 1, high - 1, target)\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter numbers separated by comma:\\n\").strip()\n    sequence = [int(item.strip()) for item in user_input.split(\",\")]\n\n    target = int(input(\"Enter a single number to be found in the list:\\n\").strip())\n    result = linear_search(sequence, target)\n    if result != -1:\n        print(f\"linear_search({sequence}, {target}) = {result}\")\n    else:\n        print(f\"{target} was not found in {sequence}\")\n", "searches/ternary_search.py": "\"\"\"\nThis is a type of divide and conquer algorithm which divides the search space into\n3 parts and finds the target value based on the property of the array or list\n(usually monotonic property).\n\nTime Complexity  : O(log3 N)\nSpace Complexity : O(1)\n\"\"\"\n\nfrom __future__ import annotations\n\n# This is the precision for this function which can be altered.\n# It is recommended for users to keep this number greater than or equal to 10.\nprecision = 10\n\n\n# This is the linear search that will occur after the search space has become smaller.\n\n\ndef lin_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Perform linear search in list. Returns -1 if element is not found.\n\n    Parameters\n    ----------\n    left : int\n        left index bound.\n    right : int\n        right index bound.\n    array : List[int]\n        List of elements to be searched on\n    target : int\n        Element that is searched\n\n    Returns\n    -------\n    int\n        index of element that is looked for.\n\n    Examples\n    --------\n    >>> lin_search(0, 4, [4, 5, 6, 7], 7)\n    3\n    >>> lin_search(0, 3, [4, 5, 6, 7], 7)\n    -1\n    >>> lin_search(0, 2, [-18, 2], -18)\n    0\n    >>> lin_search(0, 1, [5], 5)\n    0\n    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')\n    1\n    >>> lin_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)\n    2\n    \"\"\"\n    for i in range(left, right):\n        if array[i] == target:\n            return i\n    return -1\n\n\ndef ite_ternary_search(array: list[int], target: int) -> int:\n    \"\"\"Iterative method of the ternary search algorithm.\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> ite_ternary_search(test_list, 3)\n    -1\n    >>> ite_ternary_search(test_list, 13)\n    4\n    >>> ite_ternary_search([4, 5, 6, 7], 4)\n    0\n    >>> ite_ternary_search([4, 5, 6, 7], -10)\n    -1\n    >>> ite_ternary_search([-18, 2], -18)\n    0\n    >>> ite_ternary_search([5], 5)\n    0\n    >>> ite_ternary_search(['a', 'c', 'd'], 'c')\n    1\n    >>> ite_ternary_search(['a', 'c', 'd'], 'f')\n    -1\n    >>> ite_ternary_search([], 1)\n    -1\n    >>> ite_ternary_search([.1, .4 , -.1], .1)\n    0\n    \"\"\"\n\n    left = 0\n    right = len(array)\n    while left <= right:\n        if right - left < precision:\n            return lin_search(left, right, array, target)\n\n        one_third = (left + right) // 3 + 1\n        two_third = 2 * (left + right) // 3 + 1\n\n        if array[one_third] == target:\n            return one_third\n        elif array[two_third] == target:\n            return two_third\n\n        elif target < array[one_third]:\n            right = one_third - 1\n        elif array[two_third] < target:\n            left = two_third + 1\n\n        else:\n            left = one_third + 1\n            right = two_third - 1\n    return -1\n\n\ndef rec_ternary_search(left: int, right: int, array: list[int], target: int) -> int:\n    \"\"\"Recursive method of the ternary search algorithm.\n\n    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n    >>> rec_ternary_search(0, len(test_list), test_list, 3)\n    -1\n    >>> rec_ternary_search(4, len(test_list), test_list, 42)\n    8\n    >>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)\n    0\n    >>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)\n    -1\n    >>> rec_ternary_search(0, 1, [-18, 2], -18)\n    0\n    >>> rec_ternary_search(0, 1, [5], 5)\n    0\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')\n    1\n    >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')\n    -1\n    >>> rec_ternary_search(0, 0, [], 1)\n    -1\n    >>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)\n    0\n    \"\"\"\n    if left < right:\n        if right - left < precision:\n            return lin_search(left, right, array, target)\n        one_third = (left + right) // 3 + 1\n        two_third = 2 * (left + right) // 3 + 1\n\n        if array[one_third] == target:\n            return one_third\n        elif array[two_third] == target:\n            return two_third\n\n        elif target < array[one_third]:\n            return rec_ternary_search(left, one_third - 1, array, target)\n        elif array[two_third] < target:\n            return rec_ternary_search(two_third + 1, right, array, target)\n        else:\n            return rec_ternary_search(one_third + 1, two_third - 1, array, target)\n    else:\n        return -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    user_input = input(\"Enter numbers separated by comma:\\n\").strip()\n    collection = [int(item.strip()) for item in user_input.split(\",\")]\n    assert collection == sorted(collection), f\"List must be ordered.\\n{collection}.\"\n    target = int(input(\"Enter the number to be found in the list:\\n\").strip())\n    result1 = ite_ternary_search(collection, target)\n    result2 = rec_ternary_search(0, len(collection) - 1, collection, target)\n    if result2 != -1:\n        print(f\"Iterative search: {target} found at positions: {result1}\")\n        print(f\"Recursive search: {target} found at positions: {result2}\")\n    else:\n        print(\"Not found\")\n", "searches/quick_select.py": "\"\"\"\nA Python implementation of the quick select algorithm, which is efficient for\ncalculating the value that would appear in the index of a list if it would be\nsorted, even if it is not already sorted\nhttps://en.wikipedia.org/wiki/Quickselect\n\"\"\"\n\nimport random\n\n\ndef _partition(data: list, pivot) -> tuple:\n    \"\"\"\n    Three way partition the data into smaller, equal and greater lists,\n    in relationship to the pivot\n    :param data: The data to be sorted (a list)\n    :param pivot: The value to partition the data on\n    :return: Three list: smaller, equal and greater\n    \"\"\"\n    less, equal, greater = [], [], []\n    for element in data:\n        if element < pivot:\n            less.append(element)\n        elif element > pivot:\n            greater.append(element)\n        else:\n            equal.append(element)\n    return less, equal, greater\n\n\ndef quick_select(items: list, index: int):\n    \"\"\"\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n    54\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n    4\n    >>> quick_select([5, 4, 3, 2], 2)\n    4\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\n    7\n    \"\"\"\n    # index = len(items) // 2 when trying to find the median\n    #   (value of index when items is sorted)\n\n    # invalid input\n    if index >= len(items) or index < 0:\n        return None\n\n    pivot = items[random.randint(0, len(items) - 1)]\n    count = 0\n    smaller, equal, larger = _partition(items, pivot)\n    count = len(equal)\n    m = len(smaller)\n\n    # index is the pivot\n    if m <= index < m + count:\n        return pivot\n    # must be in smaller\n    elif m > index:\n        return quick_select(smaller, index)\n    # must be in larger\n    else:\n        return quick_select(larger, index - (m + count))\n", "searches/binary_tree_traversal.py": "\"\"\"\nThis is pure Python implementation of tree traversal algorithms\n\"\"\"\n\nfrom __future__ import annotations\n\nimport queue\n\n\nclass TreeNode:\n    def __init__(self, data):\n        self.data = data\n        self.right = None\n        self.left = None\n\n\ndef build_tree() -> TreeNode:\n    print(\"\\n********Press N to stop entering at any point of time********\\n\")\n    check = input(\"Enter the value of the root node: \").strip().lower()\n    q: queue.Queue = queue.Queue()\n    tree_node = TreeNode(int(check))\n    q.put(tree_node)\n    while not q.empty():\n        node_found = q.get()\n        msg = f\"Enter the left node of {node_found.data}: \"\n        check = input(msg).strip().lower() or \"n\"\n        if check == \"n\":\n            return tree_node\n        left_node = TreeNode(int(check))\n        node_found.left = left_node\n        q.put(left_node)\n        msg = f\"Enter the right node of {node_found.data}: \"\n        check = input(msg).strip().lower() or \"n\"\n        if check == \"n\":\n            return tree_node\n        right_node = TreeNode(int(check))\n        node_found.right = right_node\n        q.put(right_node)\n    raise\n\n\ndef pre_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    print(node.data, end=\",\")\n    pre_order(node.left)\n    pre_order(node.right)\n\n\ndef in_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    in_order(node.left)\n    print(node.data, end=\",\")\n    in_order(node.right)\n\n\ndef post_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    post_order(node.left)\n    post_order(node.right)\n    print(node.data, end=\",\")\n\n\ndef level_order(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order(root)\n    1,2,3,4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        node_dequeued = q.get()\n        print(node_dequeued.data, end=\",\")\n        if node_dequeued.left:\n            q.put(node_dequeued.left)\n        if node_dequeued.right:\n            q.put(node_dequeued.right)\n\n\ndef level_order_actual(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> level_order_actual(root)\n    1,\n    2,3,\n    4,5,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    q: queue.Queue = queue.Queue()\n    q.put(node)\n    while not q.empty():\n        list_ = []\n        while not q.empty():\n            node_dequeued = q.get()\n            print(node_dequeued.data, end=\",\")\n            if node_dequeued.left:\n                list_.append(node_dequeued.left)\n            if node_dequeued.right:\n                list_.append(node_dequeued.right)\n        print()\n        for node in list_:\n            q.put(node)\n\n\n# iteration version\ndef pre_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> pre_order_iter(root)\n    1,2,4,5,3,6,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:  # start from root node, find its left child\n            print(n.data, end=\",\")\n            stack.append(n)\n            n = n.left\n        # end of while means current node doesn't have left child\n        n = stack.pop()\n        # start to traverse its right child\n        n = n.right\n\n\ndef in_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> in_order_iter(root)\n    4,2,5,1,6,3,7,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack: list[TreeNode] = []\n    n = node\n    while n or stack:\n        while n:\n            stack.append(n)\n            n = n.left\n        n = stack.pop()\n        print(n.data, end=\",\")\n        n = n.right\n\n\ndef post_order_iter(node: TreeNode) -> None:\n    \"\"\"\n    >>> root = TreeNode(1)\n    >>> tree_node2 = TreeNode(2)\n    >>> tree_node3 = TreeNode(3)\n    >>> tree_node4 = TreeNode(4)\n    >>> tree_node5 = TreeNode(5)\n    >>> tree_node6 = TreeNode(6)\n    >>> tree_node7 = TreeNode(7)\n    >>> root.left, root.right = tree_node2, tree_node3\n    >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5\n    >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7\n    >>> post_order_iter(root)\n    4,5,2,6,7,3,1,\n    \"\"\"\n    if not isinstance(node, TreeNode) or not node:\n        return\n    stack1, stack2 = [], []\n    n = node\n    stack1.append(n)\n    while stack1:  # to find the reversed order of post order, store it in stack2\n        n = stack1.pop()\n        if n.left:\n            stack1.append(n.left)\n        if n.right:\n            stack1.append(n.right)\n        stack2.append(n)\n    while stack2:  # pop up from stack2 will be the post order\n        print(stack2.pop().data, end=\",\")\n\n\ndef prompt(s: str = \"\", width=50, char=\"*\") -> str:\n    if not s:\n        return \"\\n\" + width * char\n    left, extra = divmod(width - len(s) - 2, 2)\n    return f\"{left * char} {s} {(left + extra) * char}\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(prompt(\"Binary Tree Traversals\"))\n\n    node: TreeNode = build_tree()\n    print(prompt(\"Pre Order Traversal\"))\n    pre_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"In Order Traversal\"))\n    in_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Post Order Traversal\"))\n    post_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Level Order Traversal\"))\n    level_order(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Actual Level Order Traversal\"))\n    level_order_actual(node)\n    print(\"*\" * 50 + \"\\n\")\n\n    print(prompt(\"Pre Order Traversal - Iteration Version\"))\n    pre_order_iter(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"In Order Traversal - Iteration Version\"))\n    in_order_iter(node)\n    print(prompt() + \"\\n\")\n\n    print(prompt(\"Post Order Traversal - Iteration Version\"))\n    post_order_iter(node)\n    print(prompt())\n", "searches/median_of_medians.py": "\"\"\"\nA Python implementation of the Median of Medians algorithm\nto select pivots for quick_select, which is efficient for\ncalculating the value that would appear in the index of a\nlist if it would be sorted, even if it is not already\nsorted. Search in time complexity O(n) at any rank\ndeterministically\nhttps://en.wikipedia.org/wiki/Median_of_medians\n\"\"\"\n\n\ndef median_of_five(arr: list) -> int:\n    \"\"\"\n    Return the median of the input list\n    :param arr: Array to find median of\n    :return: median of arr\n\n    >>> median_of_five([2, 4, 5, 7, 899])\n    5\n    >>> median_of_five([5, 7, 899, 54, 32])\n    32\n    >>> median_of_five([5, 4, 3, 2])\n    4\n    >>> median_of_five([3, 5, 7, 10, 2])\n    5\n    \"\"\"\n    arr = sorted(arr)\n    return arr[len(arr) // 2]\n\n\ndef median_of_medians(arr: list) -> int:\n    \"\"\"\n    Return a pivot to partition data on by calculating\n    Median of medians of input data\n    :param arr: The data to be checked (a list)\n    :return: median of medians of input array\n\n    >>> median_of_medians([2, 4, 5, 7, 899, 54, 32])\n    54\n    >>> median_of_medians([5, 7, 899, 54, 32])\n    32\n    >>> median_of_medians([5, 4, 3, 2])\n    4\n    >>> median_of_medians([3, 5, 7, 10, 2, 12])\n    12\n    \"\"\"\n\n    if len(arr) <= 5:\n        return median_of_five(arr)\n    medians = []\n    i = 0\n    while i < len(arr):\n        if (i + 4) <= len(arr):\n            medians.append(median_of_five(arr[i:].copy()))\n        else:\n            medians.append(median_of_five(arr[i : i + 5].copy()))\n        i += 5\n    return median_of_medians(medians)\n\n\ndef quick_select(arr: list, target: int) -> int:\n    \"\"\"\n    Two way partition the data into smaller and greater lists,\n    in relationship to the pivot\n    :param arr: The data to be searched (a list)\n    :param target: The rank to be searched\n    :return: element at rank target\n\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)\n    32\n    >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)\n    2\n    >>> quick_select([5, 4, 3, 2], 2)\n    3\n    >>> quick_select([3, 5, 7, 10, 2, 12], 3)\n    5\n    \"\"\"\n\n    # Invalid Input\n    if target > len(arr):\n        return -1\n\n    # x is the estimated pivot by median of medians algorithm\n    x = median_of_medians(arr)\n    left = []\n    right = []\n    check = False\n    for i in range(len(arr)):\n        if arr[i] < x:\n            left.append(arr[i])\n        elif arr[i] > x:\n            right.append(arr[i])\n        elif arr[i] == x and not check:\n            check = True\n        else:\n            right.append(arr[i])\n    rank_x = len(left) + 1\n    if rank_x == target:\n        answer = x\n    elif rank_x > target:\n        answer = quick_select(left, target)\n    elif rank_x < target:\n        answer = quick_select(right, target - rank_x)\n    return answer\n\n\nprint(median_of_five([5, 4, 3, 2]))\n", "searches/double_linear_search.py": "from __future__ import annotations\n\n\ndef double_linear_search(array: list[int], search_item: int) -> int:\n    \"\"\"\n    Iterate through the array from both sides to find the index of search_item.\n\n    :param array: the array to be searched\n    :param search_item: the item to be searched\n    :return the index of search_item, if search_item is in array, else -1\n\n    Examples:\n    >>> double_linear_search([1, 5, 5, 10], 1)\n    0\n    >>> double_linear_search([1, 5, 5, 10], 5)\n    1\n    >>> double_linear_search([1, 5, 5, 10], 100)\n    -1\n    >>> double_linear_search([1, 5, 5, 10], 10)\n    3\n    \"\"\"\n    # define the start and end index of the given array\n    start_ind, end_ind = 0, len(array) - 1\n    while start_ind <= end_ind:\n        if array[start_ind] == search_item:\n            return start_ind\n        elif array[end_ind] == search_item:\n            return end_ind\n        else:\n            start_ind += 1\n            end_ind -= 1\n    # returns -1 if search_item is not found in array\n    return -1\n\n\nif __name__ == \"__main__\":\n    print(double_linear_search(list(range(100)), 40))\n", "searches/binary_search.py": "#!/usr/bin/env python3\n\n\"\"\"\nPure Python implementations of binary search algorithms\n\nFor doctests run the following command:\npython3 -m doctest -v binary_search.py\n\nFor manual testing run:\npython3 binary_search.py\n\"\"\"\n\nfrom __future__ import annotations\n\nimport bisect\n\n\ndef bisect_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger or equal to a given\n    value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are < item and all\n        values in sorted_collection[i:hi] are >= item.\n\n    Examples:\n    >>> bisect_left([0, 5, 7, 10, 15], 0)\n    0\n    >>> bisect_left([0, 5, 7, 10, 15], 6)\n    2\n    >>> bisect_left([0, 5, 7, 10, 15], 20)\n    5\n    >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n    >>> bisect_left([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] < item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo\n\n\ndef bisect_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> int:\n    \"\"\"\n    Locates the first element in a sorted array that is larger than a given value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.bisect_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to bisect\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n    :return: index i such that all values in sorted_collection[lo:i] are <= item and\n        all values in sorted_collection[i:hi] are > item.\n\n    Examples:\n    >>> bisect_right([0, 5, 7, 10, 15], 0)\n    1\n    >>> bisect_right([0, 5, 7, 10, 15], 15)\n    5\n    >>> bisect_right([0, 5, 7, 10, 15], 6)\n    2\n    >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)\n    3\n    >>> bisect_right([0, 5, 7, 10, 15], 6, 2)\n    2\n    \"\"\"\n    if hi < 0:\n        hi = len(sorted_collection)\n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if sorted_collection[mid] <= item:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo\n\n\ndef insort_left(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array before other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_left .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_left(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    True\n    >>> item is sorted_collection[2]\n    False\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_left(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_left(sorted_collection, item, lo, hi), item)\n\n\ndef insort_right(\n    sorted_collection: list[int], item: int, lo: int = 0, hi: int = -1\n) -> None:\n    \"\"\"\n    Inserts a given value into a sorted array after other values with the same value.\n\n    It has the same interface as\n    https://docs.python.org/3/library/bisect.html#bisect.insort_right .\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item to insert\n    :param lo: lowest index to consider (as in sorted_collection[lo:hi])\n    :param hi: past the highest index to consider (as in sorted_collection[lo:hi])\n\n    Examples:\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 6)\n    >>> sorted_collection\n    [0, 5, 6, 7, 10, 15]\n    >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item = (5, 5)\n    >>> insort_right(sorted_collection, item)\n    >>> sorted_collection\n    [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]\n    >>> item is sorted_collection[1]\n    False\n    >>> item is sorted_collection[2]\n    True\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 20)\n    >>> sorted_collection\n    [0, 5, 7, 10, 15, 20]\n    >>> sorted_collection = [0, 5, 7, 10, 15]\n    >>> insort_right(sorted_collection, 15, 1, 3)\n    >>> sorted_collection\n    [0, 5, 7, 15, 10, 15]\n    \"\"\"\n    sorted_collection.insert(bisect_right(sorted_collection, item, lo, hi), item)\n\n\ndef binary_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    left = 0\n    right = len(sorted_collection) - 1\n\n    while left <= right:\n        midpoint = left + (right - left) // 2\n        current_item = sorted_collection[midpoint]\n        if current_item == item:\n            return midpoint\n        elif item < current_item:\n            right = midpoint - 1\n        else:\n            left = midpoint + 1\n    return -1\n\n\ndef binary_search_std_lib(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python using stdlib\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)\n    0\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)\n    4\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)\n    1\n    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    index = bisect.bisect_left(sorted_collection, item)\n    if index != len(sorted_collection) and sorted_collection[index] == item:\n        return index\n    return -1\n\n\ndef binary_search_by_recursion(\n    sorted_collection: list[int], item: int, left: int = 0, right: int = -1\n) -> int:\n    \"\"\"Pure implementation of a binary search algorithm in Python by recursion\n\n    Be careful collection must be ascending sorted otherwise, the result will be\n    unpredictable\n    First recursion should be started with left=0 and right=(len(sorted_collection)-1)\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    Examples:\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)\n    0\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)\n    4\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)\n    1\n    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)\n    -1\n    \"\"\"\n    if right < 0:\n        right = len(sorted_collection) - 1\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    if right < left:\n        return -1\n\n    midpoint = left + (right - left) // 2\n\n    if sorted_collection[midpoint] == item:\n        return midpoint\n    elif sorted_collection[midpoint] > item:\n        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)\n    else:\n        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)\n\n\ndef exponential_search(sorted_collection: list[int], item: int) -> int:\n    \"\"\"Pure implementation of an exponential search algorithm in Python\n    Resources used:\n    https://en.wikipedia.org/wiki/Exponential_search\n\n    Be careful collection must be ascending sorted otherwise, result will be\n    unpredictable\n\n    :param sorted_collection: some ascending sorted collection with comparable items\n    :param item: item value to search\n    :return: index of the found item or -1 if the item is not found\n\n    the order of this algorithm is O(lg I) where I is index position of item if exist\n\n    Examples:\n    >>> exponential_search([0, 5, 7, 10, 15], 0)\n    0\n    >>> exponential_search([0, 5, 7, 10, 15], 15)\n    4\n    >>> exponential_search([0, 5, 7, 10, 15], 5)\n    1\n    >>> exponential_search([0, 5, 7, 10, 15], 6)\n    -1\n    \"\"\"\n    if list(sorted_collection) != sorted(sorted_collection):\n        raise ValueError(\"sorted_collection must be sorted in ascending order\")\n    bound = 1\n    while bound < len(sorted_collection) and sorted_collection[bound] < item:\n        bound *= 2\n    left = bound // 2\n    right = min(bound, len(sorted_collection) - 1)\n    last_result = binary_search_by_recursion(\n        sorted_collection=sorted_collection, item=item, left=left, right=right\n    )\n    if last_result is None:\n        return -1\n    return last_result\n\n\nsearches = (  # Fastest to slowest...\n    binary_search_std_lib,\n    binary_search,\n    exponential_search,\n    binary_search_by_recursion,\n)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    import timeit\n\n    doctest.testmod()\n    for search in searches:\n        name = f\"{search.__name__:>26}\"\n        print(f\"{name}: {search([0, 5, 7, 10, 15], 10) = }\")  # type: ignore[operator]\n\n    print(\"\\nBenchmarks...\")\n    setup = \"collection = range(1000)\"\n    for search in searches:\n        name = search.__name__\n        print(\n            f\"{name:>26}:\",\n            timeit.timeit(\n                f\"{name}(collection, 500)\", setup=setup, number=5_000, globals=globals()\n            ),\n        )\n\n    user_input = input(\"\\nEnter numbers separated by comma: \").strip()\n    collection = sorted(int(item) for item in user_input.split(\",\"))\n    target = int(input(\"Enter a single number to be found in the list: \"))\n    result = binary_search(sorted_collection=collection, item=target)\n    if result == -1:\n        print(f\"{target} was not found in {collection}.\")\n    else:\n        print(f\"{target} was found at position {result} of {collection}.\")\n", "searches/simulated_annealing.py": "# https://en.wikipedia.org/wiki/Simulated_annealing\nimport math\nimport random\nfrom typing import Any\n\nfrom .hill_climbing import SearchProblem\n\n\ndef simulated_annealing(\n    search_prob,\n    find_max: bool = True,\n    max_x: float = math.inf,\n    min_x: float = -math.inf,\n    max_y: float = math.inf,\n    min_y: float = -math.inf,\n    visualization: bool = False,\n    start_temperate: float = 100,\n    rate_of_decrease: float = 0.01,\n    threshold_temp: float = 1,\n) -> Any:\n    \"\"\"\n    Implementation of the simulated annealing algorithm. We start with a given state,\n    find all its neighbors. Pick a random neighbor, if that neighbor improves the\n    solution, we move in that direction, if that neighbor does not improve the solution,\n    we generate a random real number between 0 and 1, if the number is within a certain\n    range (calculated using temperature) we move in that direction, else we pick\n    another neighbor randomly and repeat the process.\n\n    Args:\n        search_prob: The search state at the start.\n        find_max: If True, the algorithm should find the minimum else the minimum.\n        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n        visualization: If True, a matplotlib graph is displayed.\n        start_temperate: the initial temperate of the system when the program starts.\n        rate_of_decrease: the rate at which the temperate decreases in each iteration.\n        threshold_temp: the threshold temperature below which we end the search\n    Returns a search state having the maximum (or minimum) score.\n    \"\"\"\n    search_end = False\n    current_state = search_prob\n    current_temp = start_temperate\n    scores = []\n    iterations = 0\n    best_state = None\n\n    while not search_end:\n        current_score = current_state.score()\n        if best_state is None or current_score > best_state.score():\n            best_state = current_state\n        scores.append(current_score)\n        iterations += 1\n        next_state = None\n        neighbors = current_state.get_neighbors()\n        while (\n            next_state is None and neighbors\n        ):  # till we do not find a neighbor that we can move to\n            index = random.randint(0, len(neighbors) - 1)  # picking a random neighbor\n            picked_neighbor = neighbors.pop(index)\n            change = picked_neighbor.score() - current_score\n\n            if (\n                picked_neighbor.x > max_x\n                or picked_neighbor.x < min_x\n                or picked_neighbor.y > max_y\n                or picked_neighbor.y < min_y\n            ):\n                continue  # neighbor outside our bounds\n\n            if not find_max:\n                change = change * -1  # in case we are finding minimum\n            if change > 0:  # improves the solution\n                next_state = picked_neighbor\n            else:\n                probability = (math.e) ** (\n                    change / current_temp\n                )  # probability generation function\n                if random.random() < probability:  # random number within probability\n                    next_state = picked_neighbor\n        current_temp = current_temp - (current_temp * rate_of_decrease)\n\n        if current_temp < threshold_temp or next_state is None:\n            # temperature below threshold, or could not find a suitable neighbor\n            search_end = True\n        else:\n            current_state = next_state\n\n    if visualization:\n        from matplotlib import pyplot as plt\n\n        plt.plot(range(iterations), scores)\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Function values\")\n        plt.show()\n    return best_state\n\n\nif __name__ == \"__main__\":\n\n    def test_f1(x, y):\n        return (x**2) + (y**2)\n\n    # starting the problem with initial coordinates (12, 47)\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\n    local_min = simulated_annealing(\n        prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\n    )\n    print(\n        \"The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \"\n        f\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\"\n    )\n\n    # starting the problem with initial coordinates (12, 47)\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\n    local_min = simulated_annealing(\n        prob, find_max=True, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\n    )\n    print(\n        \"The maximum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \"\n        f\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\"\n    )\n\n    def test_f2(x, y):\n        return (3 * x**2) - (6 * y)\n\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\n    local_min = simulated_annealing(prob, find_max=False, visualization=True)\n    print(\n        \"The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: \"\n        f\"{local_min.score()}\"\n    )\n\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\n    local_min = simulated_annealing(prob, find_max=True, visualization=True)\n    print(\n        \"The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: \"\n        f\"{local_min.score()}\"\n    )\n", "searches/hill_climbing.py": "# https://en.wikipedia.org/wiki/Hill_climbing\nimport math\n\n\nclass SearchProblem:\n    \"\"\"\n    An interface to define search problems.\n    The interface will be illustrated using the example of mathematical function.\n    \"\"\"\n\n    def __init__(self, x: int, y: int, step_size: int, function_to_optimize):\n        \"\"\"\n        The constructor of the search problem.\n\n        x: the x coordinate of the current search state.\n        y: the y coordinate of the current search state.\n        step_size: size of the step to take when looking for neighbors.\n        function_to_optimize: a function to optimize having the signature f(x, y).\n        \"\"\"\n        self.x = x\n        self.y = y\n        self.step_size = step_size\n        self.function = function_to_optimize\n\n    def score(self) -> int:\n        \"\"\"\n        Returns the output of the function called with current x and y coordinates.\n        >>> def test_function(x, y):\n        ...     return x + y\n        >>> SearchProblem(0, 0, 1, test_function).score()  # 0 + 0 = 0\n        0\n        >>> SearchProblem(5, 7, 1, test_function).score()  # 5 + 7 = 12\n        12\n        \"\"\"\n        return self.function(self.x, self.y)\n\n    def get_neighbors(self):\n        \"\"\"\n        Returns a list of coordinates of neighbors adjacent to the current coordinates.\n\n        Neighbors:\n        | 0 | 1 | 2 |\n        | 3 | _ | 4 |\n        | 5 | 6 | 7 |\n        \"\"\"\n        step_size = self.step_size\n        return [\n            SearchProblem(x, y, step_size, self.function)\n            for x, y in (\n                (self.x - step_size, self.y - step_size),\n                (self.x - step_size, self.y),\n                (self.x - step_size, self.y + step_size),\n                (self.x, self.y - step_size),\n                (self.x, self.y + step_size),\n                (self.x + step_size, self.y - step_size),\n                (self.x + step_size, self.y),\n                (self.x + step_size, self.y + step_size),\n            )\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        hash the string representation of the current search state.\n        \"\"\"\n        return hash(str(self))\n\n    def __eq__(self, obj):\n        \"\"\"\n        Check if the 2 objects are equal.\n        \"\"\"\n        if isinstance(obj, SearchProblem):\n            return hash(str(self)) == hash(str(obj))\n        return False\n\n    def __str__(self):\n        \"\"\"\n        string representation of the current search state.\n        >>> str(SearchProblem(0, 0, 1, None))\n        'x: 0 y: 0'\n        >>> str(SearchProblem(2, 5, 1, None))\n        'x: 2 y: 5'\n        \"\"\"\n        return f\"x: {self.x} y: {self.y}\"\n\n\ndef hill_climbing(\n    search_prob,\n    find_max: bool = True,\n    max_x: float = math.inf,\n    min_x: float = -math.inf,\n    max_y: float = math.inf,\n    min_y: float = -math.inf,\n    visualization: bool = False,\n    max_iter: int = 10000,\n) -> SearchProblem:\n    \"\"\"\n    Implementation of the hill climbling algorithm.\n    We start with a given state, find all its neighbors,\n    move towards the neighbor which provides the maximum (or minimum) change.\n    We keep doing this until we are at a state where we do not have any\n    neighbors which can improve the solution.\n        Args:\n            search_prob: The search state at the start.\n            find_max: If True, the algorithm should find the maximum else the minimum.\n            max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n            visualization: If True, a matplotlib graph is displayed.\n            max_iter: number of times to run the iteration.\n        Returns a search state having the maximum (or minimum) score.\n    \"\"\"\n    current_state = search_prob\n    scores = []  # list to store the current score at each iteration\n    iterations = 0\n    solution_found = False\n    visited = set()\n    while not solution_found and iterations < max_iter:\n        visited.add(current_state)\n        iterations += 1\n        current_score = current_state.score()\n        scores.append(current_score)\n        neighbors = current_state.get_neighbors()\n        max_change = -math.inf\n        min_change = math.inf\n        next_state = None  # to hold the next best neighbor\n        for neighbor in neighbors:\n            if neighbor in visited:\n                continue  # do not want to visit the same state again\n            if (\n                neighbor.x > max_x\n                or neighbor.x < min_x\n                or neighbor.y > max_y\n                or neighbor.y < min_y\n            ):\n                continue  # neighbor outside our bounds\n            change = neighbor.score() - current_score\n            if find_max:  # finding max\n                # going to direction with greatest ascent\n                if change > max_change and change > 0:\n                    max_change = change\n                    next_state = neighbor\n            elif change < min_change and change < 0:  # finding min\n                # to direction with greatest descent\n                min_change = change\n                next_state = neighbor\n        if next_state is not None:\n            # we found at least one neighbor which improved the current state\n            current_state = next_state\n        else:\n            # since we have no neighbor that improves the solution we stop the search\n            solution_found = True\n\n    if visualization:\n        from matplotlib import pyplot as plt\n\n        plt.plot(range(iterations), scores)\n        plt.xlabel(\"Iterations\")\n        plt.ylabel(\"Function values\")\n        plt.show()\n\n    return current_state\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    def test_f1(x, y):\n        return (x**2) + (y**2)\n\n    # starting the problem with initial coordinates (3, 4)\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\n    local_min = hill_climbing(prob, find_max=False)\n    print(\n        \"The minimum score for f(x, y) = x^2 + y^2 found via hill climbing: \"\n        f\"{local_min.score()}\"\n    )\n\n    # starting the problem with initial coordinates (12, 47)\n    prob = SearchProblem(x=12, y=47, step_size=1, function_to_optimize=test_f1)\n    local_min = hill_climbing(\n        prob, find_max=False, max_x=100, min_x=5, max_y=50, min_y=-5, visualization=True\n    )\n    print(\n        \"The minimum score for f(x, y) = x^2 + y^2 with the domain 100 > x > 5 \"\n        f\"and 50 > y > - 5 found via hill climbing: {local_min.score()}\"\n    )\n\n    def test_f2(x, y):\n        return (3 * x**2) - (6 * y)\n\n    prob = SearchProblem(x=3, y=4, step_size=1, function_to_optimize=test_f1)\n    local_min = hill_climbing(prob, find_max=True)\n    print(\n        \"The maximum score for f(x, y) = x^2 + y^2 found via hill climbing: \"\n        f\"{local_min.score()}\"\n    )\n", "searches/fibonacci_search.py": "\"\"\"\nThis is pure Python implementation of fibonacci search.\n\nResources used:\nhttps://en.wikipedia.org/wiki/Fibonacci_search_technique\n\nFor doctests run following command:\npython3 -m doctest -v fibonacci_search.py\n\nFor manual testing run:\npython3 fibonacci_search.py\n\"\"\"\n\nfrom functools import lru_cache\n\n\n@lru_cache\ndef fibonacci(k: int) -> int:\n    \"\"\"Finds fibonacci number in index k.\n\n    Parameters\n    ----------\n    k :\n        Index of fibonacci.\n\n    Returns\n    -------\n    int\n        Fibonacci number in position k.\n\n    >>> fibonacci(0)\n    0\n    >>> fibonacci(2)\n    1\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(15)\n    610\n    >>> fibonacci('a')\n    Traceback (most recent call last):\n    TypeError: k must be an integer.\n    >>> fibonacci(-5)\n    Traceback (most recent call last):\n    ValueError: k integer must be greater or equal to zero.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer.\")\n    if k < 0:\n        raise ValueError(\"k integer must be greater or equal to zero.\")\n    if k == 0:\n        return 0\n    elif k == 1:\n        return 1\n    else:\n        return fibonacci(k - 1) + fibonacci(k - 2)\n\n\ndef fibonacci_search(arr: list, val: int) -> int:\n    \"\"\"A pure Python implementation of a fibonacci search algorithm.\n\n    Parameters\n    ----------\n    arr\n        List of sorted elements.\n    val\n        Element to search in list.\n\n    Returns\n    -------\n    int\n        The index of the element in the array.\n        -1 if the element is not found.\n\n    >>> fibonacci_search([4, 5, 6, 7], 4)\n    0\n    >>> fibonacci_search([4, 5, 6, 7], -10)\n    -1\n    >>> fibonacci_search([-18, 2], -18)\n    0\n    >>> fibonacci_search([5], 5)\n    0\n    >>> fibonacci_search(['a', 'c', 'd'], 'c')\n    1\n    >>> fibonacci_search(['a', 'c', 'd'], 'f')\n    -1\n    >>> fibonacci_search([], 1)\n    -1\n    >>> fibonacci_search([.1, .4 , 7], .4)\n    1\n    >>> fibonacci_search([], 9)\n    -1\n    >>> fibonacci_search(list(range(100)), 63)\n    63\n    >>> fibonacci_search(list(range(100)), 99)\n    99\n    >>> fibonacci_search(list(range(-100, 100, 3)), -97)\n    1\n    >>> fibonacci_search(list(range(-100, 100, 3)), 0)\n    -1\n    >>> fibonacci_search(list(range(-100, 100, 5)), 0)\n    20\n    >>> fibonacci_search(list(range(-100, 100, 5)), 95)\n    39\n    \"\"\"\n    len_list = len(arr)\n    # Find m such that F_m >= n where F_i is the i_th fibonacci number.\n    i = 0\n    while True:\n        if fibonacci(i) >= len_list:\n            fibb_k = i\n            break\n        i += 1\n    offset = 0\n    while fibb_k > 0:\n        index_k = min(\n            offset + fibonacci(fibb_k - 1), len_list - 1\n        )  # Prevent out of range\n        item_k_1 = arr[index_k]\n        if item_k_1 == val:\n            return index_k\n        elif val < item_k_1:\n            fibb_k -= 1\n        elif val > item_k_1:\n            offset += fibonacci(fibb_k - 1)\n            fibb_k -= 2\n    return -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "searches/__init__.py": "", "audio_filters/show_response.py": "from __future__ import annotations\n\nfrom abc import abstractmethod\nfrom math import pi\nfrom typing import Protocol\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass FilterType(Protocol):\n    @abstractmethod\n    def process(self, sample: float) -> float:\n        \"\"\"\n        Calculate y[n]\n\n        >>> issubclass(FilterType, Protocol)\n        True\n        \"\"\"\n\n\ndef get_bounds(\n    fft_results: np.ndarray, samplerate: int\n) -> tuple[int | float, int | float]:\n    \"\"\"\n    Get bounds for printing fft results\n\n    >>> import numpy\n    >>> array = numpy.linspace(-20.0, 20.0, 1000)\n    >>> get_bounds(array, 1000)\n    (-20, 20)\n    \"\"\"\n    lowest = min([-20, np.min(fft_results[1 : samplerate // 2 - 1])])\n    highest = max([20, np.max(fft_results[1 : samplerate // 2 - 1])])\n    return lowest, highest\n\n\ndef show_frequency_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show frequency response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_frequency_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.abs(np.fft.fft(outputs))\n    fft_db = 20 * np.log10(fft_out)\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    # Display within reasonable bounds\n    bounds = get_bounds(fft_db, samplerate)\n    plt.ylim(max([-80, bounds[0]]), min([80, bounds[1]]))\n    plt.ylabel(\"Gain (dB)\")\n\n    plt.plot(fft_db)\n    plt.show()\n\n\ndef show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n    \"\"\"\n    Show phase response of a filter\n\n    >>> from audio_filters.iir_filter import IIRFilter\n    >>> filt = IIRFilter(4)\n    >>> show_phase_response(filt, 48000)\n    \"\"\"\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  # zero-padding\n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    # Frequencies on log scale from 24 to nyquist frequency\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()\n", "audio_filters/butterworth_filter.py": "from math import cos, sin, sqrt, tau\n\nfrom audio_filters.iir_filter import IIRFilter\n\n\"\"\"\nCreate 2nd-order IIR filters with Butterworth design.\n\nCode based on https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html\nAlternatively you can use scipy.signal.butter, which should yield the same results.\n\"\"\"\n\n\ndef make_lowpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a low-pass filter\n\n    >>> filter = make_lowpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,\n     0.008555138626189618, 0.004277569313094809]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = (1 - _cos) / 2\n    b1 = 1 - _cos\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\n    return filt\n\n\ndef make_highpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a high-pass filter\n\n    >>> filter = make_highpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,\n     -1.9914448613738105, 0.9957224306869052]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = (1 + _cos) / 2\n    b1 = -1 - _cos\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b0])\n    return filt\n\n\ndef make_bandpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a band-pass filter\n\n    >>> filter = make_bandpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,\n     0, -0.06526309611002579]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = _sin / 2\n    b1 = 0\n    b2 = -b0\n\n    a0 = 1 + alpha\n    a1 = -2 * _cos\n    a2 = 1 - alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt\n\n\ndef make_allpass(\n    frequency: int,\n    samplerate: int,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates an all-pass filter\n\n    >>> filter = make_allpass(1000, 48000)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,\n     -1.9828897227476208, 1.0922959556412573]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n\n    b0 = 1 - alpha\n    b1 = -2 * _cos\n    b2 = 1 + alpha\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([b2, b1, b0], [b0, b1, b2])\n    return filt\n\n\ndef make_peak(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a peak filter\n\n    >>> filter = make_peak(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,\n     -1.9828897227476208, 0.8696284974398878]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n\n    b0 = 1 + alpha * big_a\n    b1 = -2 * _cos\n    b2 = 1 - alpha * big_a\n    a0 = 1 + alpha / big_a\n    a1 = -2 * _cos\n    a2 = 1 - alpha / big_a\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt\n\n\ndef make_lowshelf(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a low-shelf filter\n\n    >>> filter = make_lowshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,\n     -5.591841778072785, 2.5201667380627257]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n    pmc = (big_a + 1) - (big_a - 1) * _cos\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\n    mpc = (big_a - 1) - (big_a + 1) * _cos\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\n    aa2 = 2 * sqrt(big_a) * alpha\n\n    b0 = big_a * (pmc + aa2)\n    b1 = 2 * big_a * mpc\n    b2 = big_a * (pmc - aa2)\n    a0 = ppmc + aa2\n    a1 = -2 * pmpc\n    a2 = ppmc - aa2\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt\n\n\ndef make_highshelf(\n    frequency: int,\n    samplerate: int,\n    gain_db: float,\n    q_factor: float = 1 / sqrt(2),\n) -> IIRFilter:\n    \"\"\"\n    Creates a high-shelf filter\n\n    >>> filter = make_highshelf(1000, 48000, 6)\n    >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE\n    [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,\n     -7.922740859457287, 3.6756456963725253]\n    \"\"\"\n    w0 = tau * frequency / samplerate\n    _sin = sin(w0)\n    _cos = cos(w0)\n    alpha = _sin / (2 * q_factor)\n    big_a = 10 ** (gain_db / 40)\n    pmc = (big_a + 1) - (big_a - 1) * _cos\n    ppmc = (big_a + 1) + (big_a - 1) * _cos\n    mpc = (big_a - 1) - (big_a + 1) * _cos\n    pmpc = (big_a - 1) + (big_a + 1) * _cos\n    aa2 = 2 * sqrt(big_a) * alpha\n\n    b0 = big_a * (ppmc + aa2)\n    b1 = -2 * big_a * pmpc\n    b2 = big_a * (ppmc - aa2)\n    a0 = pmc + aa2\n    a1 = 2 * mpc\n    a2 = pmc - aa2\n\n    filt = IIRFilter(2)\n    filt.set_coefficients([a0, a1, a2], [b0, b1, b2])\n    return filt\n", "audio_filters/iir_filter.py": "from __future__ import annotations\n\n\nclass IIRFilter:\n    r\"\"\"\n    N-Order IIR filter\n    Assumes working with float samples normalized on [-1, 1]\n\n    ---\n\n    Implementation details:\n    Based on the 2nd-order function from\n     https://en.wikipedia.org/wiki/Digital_biquad_filter,\n    this generalized N-order function was made.\n\n    Using the following transfer function\n    H(z)=\\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}{a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}\n    we can rewrite this to\n    y[n]={\\frac{1}{a_{0}}}\\left(\\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\\right)-\\left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\\right)\\right)\n    \"\"\"\n\n    def __init__(self, order: int) -> None:\n        self.order = order\n\n        # a_{0} ... a_{k}\n        self.a_coeffs = [1.0] + [0.0] * order\n        # b_{0} ... b_{k}\n        self.b_coeffs = [1.0] + [0.0] * order\n\n        # x[n-1] ... x[n-k]\n        self.input_history = [0.0] * self.order\n        # y[n-1] ... y[n-k]\n        self.output_history = [0.0] * self.order\n\n    def set_coefficients(self, a_coeffs: list[float], b_coeffs: list[float]) -> None:\n        \"\"\"\n        Set the coefficients for the IIR filter. These should both be of size order + 1.\n        a_0 may be left out, and it will use 1.0 as default value.\n\n        This method works well with scipy's filter design functions\n            >>> # Make a 2nd-order 1000Hz butterworth lowpass filter\n            >>> import scipy.signal\n            >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,\n            ...                                          btype='lowpass',\n            ...                                          fs=48000)\n            >>> filt = IIRFilter(2)\n            >>> filt.set_coefficients(a_coeffs, b_coeffs)\n        \"\"\"\n        if len(a_coeffs) < self.order:\n            a_coeffs = [1.0, *a_coeffs]\n\n        if len(a_coeffs) != self.order + 1:\n            msg = (\n                f\"Expected a_coeffs to have {self.order + 1} elements \"\n                f\"for {self.order}-order filter, got {len(a_coeffs)}\"\n            )\n            raise ValueError(msg)\n\n        if len(b_coeffs) != self.order + 1:\n            msg = (\n                f\"Expected b_coeffs to have {self.order + 1} elements \"\n                f\"for {self.order}-order filter, got {len(a_coeffs)}\"\n            )\n            raise ValueError(msg)\n\n        self.a_coeffs = a_coeffs\n        self.b_coeffs = b_coeffs\n\n    def process(self, sample: float) -> float:\n        \"\"\"\n        Calculate y[n]\n\n        >>> filt = IIRFilter(2)\n        >>> filt.process(0)\n        0.0\n        \"\"\"\n        result = 0.0\n\n        # Start at index 1 and do index 0 at the end.\n        for i in range(1, self.order + 1):\n            result += (\n                self.b_coeffs[i] * self.input_history[i - 1]\n                - self.a_coeffs[i] * self.output_history[i - 1]\n            )\n\n        result = (result + self.b_coeffs[0] * sample) / self.a_coeffs[0]\n\n        self.input_history[1:] = self.input_history[:-1]\n        self.output_history[1:] = self.output_history[:-1]\n\n        self.input_history[0] = sample\n        self.output_history[0] = result\n\n        return result\n", "audio_filters/__init__.py": "", "matrix/count_paths.py": "\"\"\"\nGiven a grid, where you start from the top left position [0, 0],\nyou want to find how many paths you can take to get to the bottom right position.\n\nstart here  ->   0  0  0  0\n                 1  1  0  0\n                 0  0  0  1\n                 0  1  0  0  <- finish here\nhow many 'distinct' paths can you take to get to the finish?\nUsing a recursive depth-first search algorithm below, you are able to\nfind the number of distinct unique paths (count).\n\n'*' will demonstrate a path\nIn the example above, there are two distinct paths:\n1.                2.\n    *  *  *  0      *  *  *  *\n    1  1  *  0      1  1  *  *\n    0  0  *  1      0  0  *  1\n    0  1  *  *      0  1  *  *\n\"\"\"\n\n\ndef depth_first_search(grid: list[list[int]], row: int, col: int, visit: set) -> int:\n    \"\"\"\n    Recursive Backtracking Depth First Search Algorithm\n\n    Starting from top left of a matrix, count the number of\n    paths that can reach the bottom right of a matrix.\n    1 represents a block (inaccessible)\n    0 represents a valid space (accessible)\n\n    0  0  0  0\n    1  1  0  0\n    0  0  0  1\n    0  1  0  0\n    >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n\n    0  0  0  0  0\n    0  1  1  1  0\n    0  1  1  1  0\n    0  0  0  0  0\n    >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\n    >>> depth_first_search(grid, 0, 0, set())\n    2\n    \"\"\"\n    row_length, col_length = len(grid), len(grid[0])\n    if (\n        min(row, col) < 0\n        or row == row_length\n        or col == col_length\n        or (row, col) in visit\n        or grid[row][col] == 1\n    ):\n        return 0\n    if row == row_length - 1 and col == col_length - 1:\n        return 1\n\n    visit.add((row, col))\n\n    count = 0\n    count += depth_first_search(grid, row + 1, col, visit)\n    count += depth_first_search(grid, row - 1, col, visit)\n    count += depth_first_search(grid, row, col + 1, visit)\n    count += depth_first_search(grid, row, col - 1, visit)\n\n    visit.remove((row, col))\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "matrix/cramers_rule_2x2.py": "# https://www.chilimath.com/lessons/advanced-algebra/cramers-rule-with-two-variables\n# https://en.wikipedia.org/wiki/Cramer%27s_rule\n\n\ndef cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:\n    \"\"\"\n    Solves the system of linear equation in 2 variables.\n    :param: equation1: list of 3 numbers\n    :param: equation2: list of 3 numbers\n    :return: String of result\n    input format : [a1, b1, d1], [a2, b2, d2]\n    determinant = [[a1, b1], [a2, b2]]\n    determinant_x = [[d1, b1], [d2, b2]]\n    determinant_y = [[a1, d1], [a2, d2]]\n\n    >>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])\n    (0.0, 0.0)\n    >>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])\n    (13.0, 12.5)\n    >>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])\n    (4.0, -7.0)\n    >>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])\n    (2.0, -1.0)\n\n    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])\n    Traceback (most recent call last):\n        ...\n    ValueError: Infinite solutions. (Consistent system)\n    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    >>> cramers_rule_2x2([1, 2, 3], [11, 22])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please enter a valid equation.\n    >>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    >>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Both a & b of two equations can't be zero.\n    >>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Infinite solutions. (Consistent system)\n    >>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])\n    Traceback (most recent call last):\n        ...\n    ValueError: No solution. (Inconsistent system)\n    \"\"\"\n\n    # Check if the input is valid\n    if not len(equation1) == len(equation2) == 3:\n        raise ValueError(\"Please enter a valid equation.\")\n    if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:\n        raise ValueError(\"Both a & b of two equations can't be zero.\")\n\n    # Extract the coefficients\n    a1, b1, c1 = equation1\n    a2, b2, c2 = equation2\n\n    # Calculate the determinants of the matrices\n    determinant = a1 * b2 - a2 * b1\n    determinant_x = c1 * b2 - c2 * b1\n    determinant_y = a1 * c2 - a2 * c1\n\n    # Check if the system of linear equations has a solution (using Cramer's rule)\n    if determinant == 0:\n        if determinant_x == determinant_y == 0:\n            raise ValueError(\"Infinite solutions. (Consistent system)\")\n        else:\n            raise ValueError(\"No solution. (Inconsistent system)\")\n    elif determinant_x == determinant_y == 0:\n        # Trivial solution (Inconsistent system)\n        return (0.0, 0.0)\n    else:\n        x = determinant_x / determinant\n        y = determinant_y / determinant\n        # Non-Trivial Solution (Consistent system)\n        return (x, y)\n", "matrix/count_negative_numbers_in_sorted_matrix.py": "\"\"\"\nGiven an matrix of numbers in which all rows and all columns are sorted in decreasing\norder, return the number of negative numbers in grid.\n\nReference: https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix\n\"\"\"\n\n\ndef generate_large_matrix() -> list[list[int]]:\n    \"\"\"\n    >>> generate_large_matrix() # doctest: +ELLIPSIS\n    [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]\n    \"\"\"\n    return [list(range(1000 - i, -1000 - i, -1)) for i in range(1000)]\n\n\ngrid = generate_large_matrix()\ntest_grids = (\n    [[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]],\n    [[3, 2], [1, 0]],\n    [[7, 7, 6]],\n    [[7, 7, 6], [-1, -2, -3]],\n    grid,\n)\n\n\ndef validate_grid(grid: list[list[int]]) -> None:\n    \"\"\"\n    Validate that the rows and columns of the grid is sorted in decreasing order.\n    >>> for grid in test_grids:\n    ...     validate_grid(grid)\n    \"\"\"\n    assert all(row == sorted(row, reverse=True) for row in grid)\n    assert all(list(col) == sorted(col, reverse=True) for col in zip(*grid))\n\n\ndef find_negative_index(array: list[int]) -> int:\n    \"\"\"\n    Find the smallest negative index\n\n    >>> find_negative_index([0,0,0,0])\n    4\n    >>> find_negative_index([4,3,2,-1])\n    3\n    >>> find_negative_index([1,0,-1,-10])\n    2\n    >>> find_negative_index([0,0,0,-1])\n    3\n    >>> find_negative_index([11,8,7,-3,-5,-9])\n    3\n    >>> find_negative_index([-1,-1,-2,-3])\n    0\n    >>> find_negative_index([5,1,0])\n    3\n    >>> find_negative_index([-5,-5,-5])\n    0\n    >>> find_negative_index([0])\n    1\n    >>> find_negative_index([])\n    0\n    \"\"\"\n    left = 0\n    right = len(array) - 1\n\n    # Edge cases such as no values or all numbers are negative.\n    if not array or array[0] < 0:\n        return 0\n\n    while right + 1 > left:\n        mid = (left + right) // 2\n        num = array[mid]\n\n        # Num must be negative and the index must be greater than or equal to 0.\n        if num < 0 and array[mid - 1] >= 0:\n            return mid\n\n        if num >= 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # No negative numbers so return the last index of the array + 1 which is the length.\n    return len(array)\n\n\ndef count_negatives_binary_search(grid: list[list[int]]) -> int:\n    \"\"\"\n    An O(m logn) solution that uses binary search in order to find the boundary between\n    positive and negative numbers\n\n    >>> [count_negatives_binary_search(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    total = 0\n    bound = len(grid[0])\n\n    for i in range(len(grid)):\n        bound = find_negative_index(grid[i][:bound])\n        total += bound\n    return (len(grid) * len(grid[0])) - total\n\n\ndef count_negatives_brute_force(grid: list[list[int]]) -> int:\n    \"\"\"\n    This solution is O(n^2) because it iterates through every column and row.\n\n    >>> [count_negatives_brute_force(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    return len([number for row in grid for number in row if number < 0])\n\n\ndef count_negatives_brute_force_with_break(grid: list[list[int]]) -> int:\n    \"\"\"\n    Similar to the brute force solution above but uses break in order to reduce the\n    number of iterations.\n\n    >>> [count_negatives_brute_force_with_break(grid) for grid in test_grids]\n    [8, 0, 0, 3, 1498500]\n    \"\"\"\n    total = 0\n    for row in grid:\n        for i, number in enumerate(row):\n            if number < 0:\n                total += len(row) - i\n                break\n    return total\n\n\ndef benchmark() -> None:\n    \"\"\"Benchmark our functions next to each other\"\"\"\n    from timeit import timeit\n\n    print(\"Running benchmarks\")\n    setup = (\n        \"from __main__ import count_negatives_binary_search, \"\n        \"count_negatives_brute_force, count_negatives_brute_force_with_break, grid\"\n    )\n    for func in (\n        \"count_negatives_binary_search\",  # took 0.7727 seconds\n        \"count_negatives_brute_force_with_break\",  # took 4.6505 seconds\n        \"count_negatives_brute_force\",  # took 12.8160 seconds\n    ):\n        time = timeit(f\"{func}(grid=grid)\", setup=setup, number=500)\n        print(f\"{func}() took {time:0.4f} seconds\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "matrix/matrix_operation.py": "\"\"\"\nFunctions for 2D matrix operations\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n\ndef add(*matrix_s: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> add([[1,2],[3,4]],[[2,3],[4,5]])\n    [[3, 5], [7, 9]]\n    >>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])\n    [[3.2, 5.4], [7, 9]]\n    >>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])\n    [[7, 14], [12, 16]]\n    >>> add([3], [4, 5])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if all(_check_not_integer(m) for m in matrix_s):\n        for i in matrix_s[1:]:\n            _verify_matrix_sizes(matrix_s[0], i)\n        return [[sum(t) for t in zip(*m)] for m in zip(*matrix_s)]\n    raise TypeError(\"Expected a matrix, got int/list instead\")\n\n\ndef subtract(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> subtract([[1,2],[3,4]],[[2,3],[4,5]])\n    [[-1, -1], [-1, -1]]\n    >>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])\n    [[-1, -0.5], [-1, -1.5]]\n    >>> subtract([3], [4, 5])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if (\n        _check_not_integer(matrix_a)\n        and _check_not_integer(matrix_b)\n        and _verify_matrix_sizes(matrix_a, matrix_b)\n    ):\n        return [[i - j for i, j in zip(*m)] for m in zip(matrix_a, matrix_b)]\n    raise TypeError(\"Expected a matrix, got int/list instead\")\n\n\ndef scalar_multiply(matrix: list[list[int]], n: float) -> list[list[float]]:\n    \"\"\"\n    >>> scalar_multiply([[1,2],[3,4]],5)\n    [[5, 10], [15, 20]]\n    >>> scalar_multiply([[1.4,2.3],[3,4]],5)\n    [[7.0, 11.5], [15, 20]]\n    \"\"\"\n    return [[x * n for x in row] for row in matrix]\n\n\ndef multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> multiply([[1,2],[3,4]],[[5,5],[7,5]])\n    [[19, 15], [43, 35]]\n    >>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])\n    [[22.5, 17.5], [46.5, 37.5]]\n    >>> multiply([[1, 2, 3]], [[2], [3], [4]])\n    [[20]]\n    \"\"\"\n    if _check_not_integer(matrix_a) and _check_not_integer(matrix_b):\n        rows, cols = _verify_matrix_sizes(matrix_a, matrix_b)\n\n    if cols[0] != rows[1]:\n        msg = (\n            \"Cannot multiply matrix of dimensions \"\n            f\"({rows[0]},{cols[0]}) and ({rows[1]},{cols[1]})\"\n        )\n        raise ValueError(msg)\n    return [\n        [sum(m * n for m, n in zip(i, j)) for j in zip(*matrix_b)] for i in matrix_a\n    ]\n\n\ndef identity(n: int) -> list[list[int]]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]\n\n\ndef transpose(\n    matrix: list[list[int]], return_map: bool = True\n) -> list[list[int]] | map[list[int]]:\n    \"\"\"\n    >>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS\n    <map object at ...\n    >>> transpose([[1,2],[3,4]], return_map=False)\n    [[1, 3], [2, 4]]\n    >>> transpose([1, [2, 3]])\n    Traceback (most recent call last):\n      ...\n    TypeError: Expected a matrix, got int/list instead\n    \"\"\"\n    if _check_not_integer(matrix):\n        if return_map:\n            return map(list, zip(*matrix))\n        else:\n            return list(map(list, zip(*matrix)))\n    raise TypeError(\"Expected a matrix, got int/list instead\")\n\n\ndef minor(matrix: list[list[int]], row: int, column: int) -> list[list[int]]:\n    \"\"\"\n    >>> minor([[1, 2], [3, 4]], 1, 1)\n    [[1]]\n    \"\"\"\n    minor = matrix[:row] + matrix[row + 1 :]\n    return [row[:column] + row[column + 1 :] for row in minor]\n\n\ndef determinant(matrix: list[list[int]]) -> Any:\n    \"\"\"\n    >>> determinant([[1, 2], [3, 4]])\n    -2\n    >>> determinant([[1.5, 2.5], [3, 4]])\n    -1.5\n    \"\"\"\n    if len(matrix) == 1:\n        return matrix[0][0]\n\n    return sum(\n        x * determinant(minor(matrix, 0, i)) * (-1) ** i\n        for i, x in enumerate(matrix[0])\n    )\n\n\ndef inverse(matrix: list[list[int]]) -> list[list[float]] | None:\n    \"\"\"\n    >>> inverse([[1, 2], [3, 4]])\n    [[-2.0, 1.0], [1.5, -0.5]]\n    >>> inverse([[1, 1], [1, 1]])\n    \"\"\"\n    # https://stackoverflow.com/questions/20047519/python-doctests-test-for-none\n    det = determinant(matrix)\n    if det == 0:\n        return None\n\n    matrix_minor = [\n        [determinant(minor(matrix, i, j)) for j in range(len(matrix))]\n        for i in range(len(matrix))\n    ]\n\n    cofactors = [\n        [x * (-1) ** (row + col) for col, x in enumerate(matrix_minor[row])]\n        for row in range(len(matrix))\n    ]\n    adjugate = list(transpose(cofactors))\n    return scalar_multiply(adjugate, 1 / det)\n\n\ndef _check_not_integer(matrix: list[list[int]]) -> bool:\n    return not isinstance(matrix, int) and not isinstance(matrix[0], int)\n\n\ndef _shape(matrix: list[list[int]]) -> tuple[int, int]:\n    return len(matrix), len(matrix[0])\n\n\ndef _verify_matrix_sizes(\n    matrix_a: list[list[int]], matrix_b: list[list[int]]\n) -> tuple[tuple[int, int], tuple[int, int]]:\n    shape = _shape(matrix_a) + _shape(matrix_b)\n    if shape[0] != shape[3] or shape[1] != shape[2]:\n        msg = (\n            \"operands could not be broadcast together with shape \"\n            f\"({shape[0], shape[1]}), ({shape[2], shape[3]})\"\n        )\n        raise ValueError(msg)\n    return (shape[0], shape[2]), (shape[1], shape[3])\n\n\ndef main() -> None:\n    matrix_a = [[12, 10], [3, 9]]\n    matrix_b = [[3, 4], [7, 4]]\n    matrix_c = [[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]\n    matrix_d = [[3, 0, 2], [2, 0, -2], [0, 1, 1]]\n    print(f\"Add Operation, {add(matrix_a, matrix_b) = } \\n\")\n    print(f\"Multiply Operation, {multiply(matrix_a, matrix_b) = } \\n\")\n    print(f\"Identity: {identity(5)}\\n\")\n    print(f\"Minor of {matrix_c} = {minor(matrix_c, 1, 2)} \\n\")\n    print(f\"Determinant of {matrix_b} = {determinant(matrix_b)} \\n\")\n    print(f\"Inverse of {matrix_d} = {inverse(matrix_d)}\\n\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "matrix/matrix_equalization.py": "from sys import maxsize\n\n\ndef array_equalization(vector: list[int], step_size: int) -> int:\n    \"\"\"\n    This algorithm equalizes all elements of the input vector\n    to a common value, by making the minimal number of\n    \"updates\" under the constraint of a step size (step_size).\n\n    >>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)\n    4\n    >>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)\n    5\n    >>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)\n    0\n    >>> array_equalization([22, 22, 22, 33, 33, 33], 2)\n    2\n    >>> array_equalization([1, 2, 3], 0)\n    Traceback (most recent call last):\n    ValueError: Step size must be positive and non-zero.\n    >>> array_equalization([1, 2, 3], -1)\n    Traceback (most recent call last):\n    ValueError: Step size must be positive and non-zero.\n    >>> array_equalization([1, 2, 3], 0.5)\n    Traceback (most recent call last):\n    ValueError: Step size must be an integer.\n    >>> array_equalization([1, 2, 3], maxsize)\n    1\n    \"\"\"\n    if step_size <= 0:\n        raise ValueError(\"Step size must be positive and non-zero.\")\n    if not isinstance(step_size, int):\n        raise ValueError(\"Step size must be an integer.\")\n\n    unique_elements = set(vector)\n    min_updates = maxsize\n\n    for element in unique_elements:\n        elem_index = 0\n        updates = 0\n        while elem_index < len(vector):\n            if vector[elem_index] != element:\n                updates += 1\n                elem_index += step_size\n            else:\n                elem_index += 1\n        min_updates = min(min_updates, updates)\n\n    return min_updates\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "matrix/binary_search_matrix.py": "def binary_search(array: list, lower_bound: int, upper_bound: int, value: int) -> int:\n    \"\"\"\n    This function carries out Binary search on a 1d array and\n    return -1 if it do not exist\n    array: A 1d sorted array\n    value : the value meant to be searched\n    >>> matrix = [1, 4, 7, 11, 15]\n    >>> binary_search(matrix, 0, len(matrix) - 1, 1)\n    0\n    >>> binary_search(matrix, 0, len(matrix) - 1, 23)\n    -1\n    \"\"\"\n\n    r = int((lower_bound + upper_bound) // 2)\n    if array[r] == value:\n        return r\n    if lower_bound >= upper_bound:\n        return -1\n    if array[r] < value:\n        return binary_search(array, r + 1, upper_bound, value)\n    else:\n        return binary_search(array, lower_bound, r - 1, value)\n\n\ndef mat_bin_search(value: int, matrix: list) -> list:\n    \"\"\"\n    This function loops over a 2d matrix and calls binarySearch on\n    the selected 1d array and returns [-1, -1] is it do not exist\n    value : value meant to be searched\n    matrix = a sorted 2d matrix\n    >>> matrix = [[1, 4, 7, 11, 15],\n    ...           [2, 5, 8, 12, 19],\n    ...           [3, 6, 9, 16, 22],\n    ...           [10, 13, 14, 17, 24],\n    ...           [18, 21, 23, 26, 30]]\n    >>> target = 1\n    >>> mat_bin_search(target, matrix)\n    [0, 0]\n    >>> target = 34\n    >>> mat_bin_search(target, matrix)\n    [-1, -1]\n    \"\"\"\n    index = 0\n    if matrix[index][0] == value:\n        return [index, 0]\n    while index < len(matrix) and matrix[index][0] < value:\n        r = binary_search(matrix[index], 0, len(matrix[index]) - 1, value)\n        if r != -1:\n            return [index, r]\n        index += 1\n    return [-1, -1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "matrix/rotate_matrix.py": "\"\"\"\nIn this problem, we want to rotate the matrix elements by 90, 180, 270\n(counterclockwise)\nDiscussion in stackoverflow:\nhttps://stackoverflow.com/questions/42519/how-do-you-rotate-a-two-dimensional-array\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef make_matrix(row_size: int = 4) -> list[list[int]]:\n    \"\"\"\n    >>> make_matrix()\n    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    >>> make_matrix(1)\n    [[1]]\n    >>> make_matrix(-2)\n    [[1, 2], [3, 4]]\n    >>> make_matrix(3)\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> make_matrix() == make_matrix(4)\n    True\n    \"\"\"\n    row_size = abs(row_size) or 4\n    return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]\n\n\ndef rotate_90(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_90(make_matrix())\n    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]\n    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_row(transpose(matrix))\n    # OR.. transpose(reverse_column(matrix))\n\n\ndef rotate_180(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_180(make_matrix())\n    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]\n    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_row(reverse_column(matrix))\n    # OR.. reverse_column(reverse_row(matrix))\n\n\ndef rotate_270(matrix: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    >>> rotate_270(make_matrix())\n    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]\n    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))\n    True\n    \"\"\"\n\n    return reverse_column(transpose(matrix))\n    # OR.. transpose(reverse_row(matrix))\n\n\ndef transpose(matrix: list[list[int]]) -> list[list[int]]:\n    matrix[:] = [list(x) for x in zip(*matrix)]\n    return matrix\n\n\ndef reverse_row(matrix: list[list[int]]) -> list[list[int]]:\n    matrix[:] = matrix[::-1]\n    return matrix\n\n\ndef reverse_column(matrix: list[list[int]]) -> list[list[int]]:\n    matrix[:] = [x[::-1] for x in matrix]\n    return matrix\n\n\ndef print_matrix(matrix: list[list[int]]) -> None:\n    for i in matrix:\n        print(*i)\n\n\nif __name__ == \"__main__\":\n    matrix = make_matrix()\n    print(\"\\norigin:\\n\")\n    print_matrix(matrix)\n    print(\"\\nrotate 90 counterclockwise:\\n\")\n    print_matrix(rotate_90(matrix))\n\n    matrix = make_matrix()\n    print(\"\\norigin:\\n\")\n    print_matrix(matrix)\n    print(\"\\nrotate 180:\\n\")\n    print_matrix(rotate_180(matrix))\n\n    matrix = make_matrix()\n    print(\"\\norigin:\\n\")\n    print_matrix(matrix)\n    print(\"\\nrotate 270 counterclockwise:\\n\")\n    print_matrix(rotate_270(matrix))\n", "matrix/sherman_morrison.py": "from __future__ import annotations\n\nfrom typing import Any\n\n\nclass Matrix:\n    \"\"\"\n    <class Matrix>\n    Matrix structure.\n    \"\"\"\n\n    def __init__(self, row: int, column: int, default_value: float = 0) -> None:\n        \"\"\"\n        <method Matrix.__init__>\n        Initialize matrix with given size and default value.\n        Example:\n        >>> a = Matrix(2, 3, 1)\n        >>> a\n        Matrix consist of 2 rows and 3 columns\n        [1, 1, 1]\n        [1, 1, 1]\n        \"\"\"\n\n        self.row, self.column = row, column\n        self.array = [[default_value for _ in range(column)] for _ in range(row)]\n\n    def __str__(self) -> str:\n        \"\"\"\n        <method Matrix.__str__>\n        Return string representation of this matrix.\n        \"\"\"\n\n        # Prefix\n        s = f\"Matrix consist of {self.row} rows and {self.column} columns\\n\"\n\n        # Make string identifier\n        max_element_length = 0\n        for row_vector in self.array:\n            for obj in row_vector:\n                max_element_length = max(max_element_length, len(str(obj)))\n        string_format_identifier = f\"%{max_element_length}s\"\n\n        # Make string and return\n        def single_line(row_vector: list[float]) -> str:\n            nonlocal string_format_identifier\n            line = \"[\"\n            line += \", \".join(string_format_identifier % (obj,) for obj in row_vector)\n            line += \"]\"\n            return line\n\n        s += \"\\n\".join(single_line(row_vector) for row_vector in self.array)\n        return s\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    def validate_indices(self, loc: tuple[int, int]) -> bool:\n        \"\"\"\n        <method Matrix.validate_indicies>\n        Check if given indices are valid to pick element from matrix.\n        Example:\n        >>> a = Matrix(2, 6, 0)\n        >>> a.validate_indices((2, 7))\n        False\n        >>> a.validate_indices((0, 0))\n        True\n        \"\"\"\n        if not (isinstance(loc, (list, tuple)) and len(loc) == 2):  # noqa: SIM114\n            return False\n        elif not (0 <= loc[0] < self.row and 0 <= loc[1] < self.column):\n            return False\n        else:\n            return True\n\n    def __getitem__(self, loc: tuple[int, int]) -> Any:\n        \"\"\"\n        <method Matrix.__getitem__>\n        Return array[row][column] where loc = (row, column).\n        Example:\n        >>> a = Matrix(3, 2, 7)\n        >>> a[1, 0]\n        7\n        \"\"\"\n        assert self.validate_indices(loc)\n        return self.array[loc[0]][loc[1]]\n\n    def __setitem__(self, loc: tuple[int, int], value: float) -> None:\n        \"\"\"\n        <method Matrix.__setitem__>\n        Set array[row][column] = value where loc = (row, column).\n        Example:\n        >>> a = Matrix(2, 3, 1)\n        >>> a[1, 2] = 51\n        >>> a\n        Matrix consist of 2 rows and 3 columns\n        [ 1,  1,  1]\n        [ 1,  1, 51]\n        \"\"\"\n        assert self.validate_indices(loc)\n        self.array[loc[0]][loc[1]] = value\n\n    def __add__(self, another: Matrix) -> Matrix:\n        \"\"\"\n        <method Matrix.__add__>\n        Return self + another.\n        Example:\n        >>> a = Matrix(2, 1, -4)\n        >>> b = Matrix(2, 1, 3)\n        >>> a+b\n        Matrix consist of 2 rows and 1 columns\n        [-1]\n        [-1]\n        \"\"\"\n\n        # Validation\n        assert isinstance(another, Matrix)\n        assert self.row == another.row\n        assert self.column == another.column\n\n        # Add\n        result = Matrix(self.row, self.column)\n        for r in range(self.row):\n            for c in range(self.column):\n                result[r, c] = self[r, c] + another[r, c]\n        return result\n\n    def __neg__(self) -> Matrix:\n        \"\"\"\n        <method Matrix.__neg__>\n        Return -self.\n        Example:\n        >>> a = Matrix(2, 2, 3)\n        >>> a[0, 1] = a[1, 0] = -2\n        >>> -a\n        Matrix consist of 2 rows and 2 columns\n        [-3,  2]\n        [ 2, -3]\n        \"\"\"\n\n        result = Matrix(self.row, self.column)\n        for r in range(self.row):\n            for c in range(self.column):\n                result[r, c] = -self[r, c]\n        return result\n\n    def __sub__(self, another: Matrix) -> Matrix:\n        return self + (-another)\n\n    def __mul__(self, another: float | Matrix) -> Matrix:\n        \"\"\"\n        <method Matrix.__mul__>\n        Return self * another.\n        Example:\n        >>> a = Matrix(2, 3, 1)\n        >>> a[0,2] = a[1,2] = 3\n        >>> a * -2\n        Matrix consist of 2 rows and 3 columns\n        [-2, -2, -6]\n        [-2, -2, -6]\n        \"\"\"\n\n        if isinstance(another, (int, float)):  # Scalar multiplication\n            result = Matrix(self.row, self.column)\n            for r in range(self.row):\n                for c in range(self.column):\n                    result[r, c] = self[r, c] * another\n            return result\n        elif isinstance(another, Matrix):  # Matrix multiplication\n            assert self.column == another.row\n            result = Matrix(self.row, another.column)\n            for r in range(self.row):\n                for c in range(another.column):\n                    for i in range(self.column):\n                        result[r, c] += self[r, i] * another[i, c]\n            return result\n        else:\n            msg = f\"Unsupported type given for another ({type(another)})\"\n            raise TypeError(msg)\n\n    def transpose(self) -> Matrix:\n        \"\"\"\n        <method Matrix.transpose>\n        Return self^T.\n        Example:\n        >>> a = Matrix(2, 3)\n        >>> for r in range(2):\n        ...     for c in range(3):\n        ...             a[r,c] = r*c\n        ...\n        >>> a.transpose()\n        Matrix consist of 3 rows and 2 columns\n        [0, 0]\n        [0, 1]\n        [0, 2]\n        \"\"\"\n\n        result = Matrix(self.column, self.row)\n        for r in range(self.row):\n            for c in range(self.column):\n                result[c, r] = self[r, c]\n        return result\n\n    def sherman_morrison(self, u: Matrix, v: Matrix) -> Any:\n        \"\"\"\n        <method Matrix.sherman_morrison>\n        Apply Sherman-Morrison formula in O(n^2).\n        To learn this formula, please look this:\n        https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula\n        This method returns (A + uv^T)^(-1) where A^(-1) is self. Returns None if it's\n        impossible to calculate.\n        Warning: This method doesn't check if self is invertible.\n            Make sure self is invertible before execute this method.\n        Example:\n        >>> ainv = Matrix(3, 3, 0)\n        >>> for i in range(3): ainv[i,i] = 1\n        ...\n        >>> u = Matrix(3, 1, 0)\n        >>> u[0,0], u[1,0], u[2,0] = 1, 2, -3\n        >>> v = Matrix(3, 1, 0)\n        >>> v[0,0], v[1,0], v[2,0] = 4, -2, 5\n        >>> ainv.sherman_morrison(u, v)\n        Matrix consist of 3 rows and 3 columns\n        [  1.2857142857142856, -0.14285714285714285,   0.3571428571428571]\n        [  0.5714285714285714,   0.7142857142857143,   0.7142857142857142]\n        [ -0.8571428571428571,  0.42857142857142855,  -0.0714285714285714]\n        \"\"\"\n\n        # Size validation\n        assert isinstance(u, Matrix)\n        assert isinstance(v, Matrix)\n        assert self.row == self.column == u.row == v.row  # u, v should be column vector\n        assert u.column == v.column == 1  # u, v should be column vector\n\n        # Calculate\n        v_t = v.transpose()\n        numerator_factor = (v_t * self * u)[0, 0] + 1\n        if numerator_factor == 0:\n            return None  # It's not invertible\n        return self - ((self * u) * (v_t * self) * (1.0 / numerator_factor))\n\n\n# Testing\nif __name__ == \"__main__\":\n\n    def test1() -> None:\n        # a^(-1)\n        ainv = Matrix(3, 3, 0)\n        for i in range(3):\n            ainv[i, i] = 1\n        print(f\"a^(-1) is {ainv}\")\n        # u, v\n        u = Matrix(3, 1, 0)\n        u[0, 0], u[1, 0], u[2, 0] = 1, 2, -3\n        v = Matrix(3, 1, 0)\n        v[0, 0], v[1, 0], v[2, 0] = 4, -2, 5\n        print(f\"u is {u}\")\n        print(f\"v is {v}\")\n        print(f\"uv^T is {u * v.transpose()}\")\n        # Sherman Morrison\n        print(f\"(a + uv^T)^(-1) is {ainv.sherman_morrison(u, v)}\")\n\n    def test2() -> None:\n        import doctest\n\n        doctest.testmod()\n\n    test2()\n", "matrix/searching_in_sorted_matrix.py": "from __future__ import annotations\n\n\ndef search_in_a_sorted_matrix(mat: list[list[int]], m: int, n: int, key: float) -> None:\n    \"\"\"\n    >>> search_in_a_sorted_matrix(\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)\n    Key 5 found at row- 1 column- 2\n    >>> search_in_a_sorted_matrix(\n    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)\n    Key 21 not found\n    >>> search_in_a_sorted_matrix(\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)\n    Key 2.1 found at row- 1 column- 1\n    >>> search_in_a_sorted_matrix(\n    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)\n    Key 2.2 not found\n    \"\"\"\n    i, j = m - 1, 0\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print(f\"Key {key} found at row- {i + 1} column- {j + 1}\")\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1\n    print(f\"Key {key} not found\")\n\n\ndef main() -> None:\n    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]\n    x = int(input(\"Enter the element to be searched:\"))\n    print(mat)\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), x)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "matrix/pascal_triangle.py": "\"\"\"\nThis implementation demonstrates how to generate the elements of a Pascal's triangle.\nThe element havingva row index of r and column index of c can be derivedvas follows:\ntriangle[r][c] = triangle[r-1][c-1]+triangle[r-1][c]\n\nA Pascal's triangle is a triangular array containing binomial coefficients.\nhttps://en.wikipedia.org/wiki/Pascal%27s_triangle\n\"\"\"\n\n\ndef print_pascal_triangle(num_rows: int) -> None:\n    \"\"\"\n    Print Pascal's triangle for different number of rows\n    >>> print_pascal_triangle(5)\n        1\n       1 1\n      1 2 1\n     1 3 3 1\n    1 4 6 4 1\n    \"\"\"\n    triangle = generate_pascal_triangle(num_rows)\n    for row_idx in range(num_rows):\n        # Print left spaces\n        for _ in range(num_rows - row_idx - 1):\n            print(end=\" \")\n        # Print row values\n        for col_idx in range(row_idx + 1):\n            if col_idx != row_idx:\n                print(triangle[row_idx][col_idx], end=\" \")\n            else:\n                print(triangle[row_idx][col_idx], end=\"\")\n        print()\n\n\ndef generate_pascal_triangle(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    Create Pascal's triangle for different number of rows\n    >>> generate_pascal_triangle(0)\n    []\n    >>> generate_pascal_triangle(1)\n    [[1]]\n    >>> generate_pascal_triangle(2)\n    [[1], [1, 1]]\n    >>> generate_pascal_triangle(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle(4)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n    >>> generate_pascal_triangle(5)\n    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    >>> generate_pascal_triangle(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    triangle: list[list[int]] = []\n    for current_row_idx in range(num_rows):\n        current_row = populate_current_row(triangle, current_row_idx)\n        triangle.append(current_row)\n    return triangle\n\n\ndef populate_current_row(triangle: list[list[int]], current_row_idx: int) -> list[int]:\n    \"\"\"\n    >>> triangle = [[1]]\n    >>> populate_current_row(triangle, 1)\n    [1, 1]\n    \"\"\"\n    current_row = [-1] * (current_row_idx + 1)\n    # first and last elements of current row are equal to 1\n    current_row[0], current_row[-1] = 1, 1\n    for current_col_idx in range(1, current_row_idx):\n        calculate_current_element(\n            triangle, current_row, current_row_idx, current_col_idx\n        )\n    return current_row\n\n\ndef calculate_current_element(\n    triangle: list[list[int]],\n    current_row: list[int],\n    current_row_idx: int,\n    current_col_idx: int,\n) -> None:\n    \"\"\"\n    >>> triangle = [[1], [1, 1]]\n    >>> current_row = [1, -1, 1]\n    >>> calculate_current_element(triangle, current_row, 2, 1)\n    >>> current_row\n    [1, 2, 1]\n    \"\"\"\n    above_to_left_elt = triangle[current_row_idx - 1][current_col_idx - 1]\n    above_to_right_elt = triangle[current_row_idx - 1][current_col_idx]\n    current_row[current_col_idx] = above_to_left_elt + above_to_right_elt\n\n\ndef generate_pascal_triangle_optimized(num_rows: int) -> list[list[int]]:\n    \"\"\"\n    This function returns a matrix representing the corresponding pascal's triangle\n    according to the given input of number of rows of Pascal's triangle to be generated.\n    It reduces the operations done to generate a row by half\n    by eliminating redundant calculations.\n\n    :param num_rows: Integer specifying the number of rows in the Pascal's triangle\n    :return: 2-D List (matrix) representing the Pascal's triangle\n\n    Return the Pascal's triangle of given rows\n    >>> generate_pascal_triangle_optimized(3)\n    [[1], [1, 1], [1, 2, 1]]\n    >>> generate_pascal_triangle_optimized(1)\n    [[1]]\n    >>> generate_pascal_triangle_optimized(0)\n    []\n    >>> generate_pascal_triangle_optimized(-5)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value of 'num_rows' should be greater than or equal to 0\n    >>> generate_pascal_triangle_optimized(7.89)\n    Traceback (most recent call last):\n        ...\n    TypeError: The input value of 'num_rows' should be 'int'\n    \"\"\"\n\n    if not isinstance(num_rows, int):\n        raise TypeError(\"The input value of 'num_rows' should be 'int'\")\n\n    if num_rows == 0:\n        return []\n    elif num_rows < 0:\n        raise ValueError(\n            \"The input value of 'num_rows' should be greater than or equal to 0\"\n        )\n\n    result: list[list[int]] = [[1]]\n\n    for row_index in range(1, num_rows):\n        temp_row = [0] + result[-1] + [0]\n        row_length = row_index + 1\n        # Calculate the number of distinct elements in a row\n        distinct_elements = sum(divmod(row_length, 2))\n        row_first_half = [\n            temp_row[i - 1] + temp_row[i] for i in range(1, distinct_elements + 1)\n        ]\n        row_second_half = row_first_half[: (row_index + 1) // 2]\n        row_second_half.reverse()\n        row = row_first_half + row_second_half\n        result.append(row)\n\n    return result\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark multiple functions, with three different length int values.\n    \"\"\"\n    from collections.abc import Callable\n    from timeit import timeit\n\n    def benchmark_a_function(func: Callable, value: int) -> None:\n        call = f\"{func.__name__}({value})\"\n        timing = timeit(f\"__main__.{call}\", setup=\"import __main__\")\n        # print(f\"{call:38} = {func(value)} -- {timing:.4f} seconds\")\n        print(f\"{call:38} -- {timing:.4f} seconds\")\n\n    for value in range(15):  # (1, 7, 14):\n        for func in (generate_pascal_triangle, generate_pascal_triangle_optimized):\n            benchmark_a_function(func, value)\n        print()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "matrix/matrix_multiplication_recursion.py": "# @Author  : ojas-wani\n# @File    : matrix_multiplication_recursion.py\n# @Date    : 10/06/2023\n\n\n\"\"\"\nPerform matrix multiplication using a recursive algorithm.\nhttps://en.wikipedia.org/wiki/Matrix_multiplication\n\"\"\"\n\n# type Matrix = list[list[int]]  # psf/black currenttly fails on this line\nMatrix = list[list[int]]\n\nmatrix_1_to_4 = [\n    [1, 2],\n    [3, 4],\n]\n\nmatrix_5_to_8 = [\n    [5, 6],\n    [7, 8],\n]\n\nmatrix_5_to_9_high = [\n    [5, 6],\n    [7, 8],\n    [9],\n]\n\nmatrix_5_to_9_wide = [\n    [5, 6],\n    [7, 8, 9],\n]\n\nmatrix_count_up = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16],\n]\n\nmatrix_unordered = [\n    [5, 8, 1, 2],\n    [6, 7, 3, 0],\n    [4, 5, 9, 1],\n    [2, 6, 10, 14],\n]\nmatrices = (\n    matrix_1_to_4,\n    matrix_5_to_8,\n    matrix_5_to_9_high,\n    matrix_5_to_9_wide,\n    matrix_count_up,\n    matrix_unordered,\n)\n\n\ndef is_square(matrix: Matrix) -> bool:\n    \"\"\"\n    >>> is_square([])\n    True\n    >>> is_square(matrix_1_to_4)\n    True\n    >>> is_square(matrix_5_to_9_high)\n    False\n    \"\"\"\n    len_matrix = len(matrix)\n    return all(len(row) == len_matrix for row in matrix)\n\n\ndef matrix_multiply(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    \"\"\"\n    >>> matrix_multiply(matrix_1_to_4, matrix_5_to_8)\n    [[19, 22], [43, 50]]\n    \"\"\"\n    return [\n        [sum(a * b for a, b in zip(row, col)) for col in zip(*matrix_b)]\n        for row in matrix_a\n    ]\n\n\ndef matrix_multiply_recursive(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    \"\"\"\n    :param matrix_a: A square Matrix.\n    :param matrix_b: Another square Matrix with the same dimensions as matrix_a.\n    :return: Result of matrix_a * matrix_b.\n    :raises ValueError: If the matrices cannot be multiplied.\n\n    >>> matrix_multiply_recursive([], [])\n    []\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8)\n    [[19, 22], [43, 50]]\n    >>> matrix_multiply_recursive(matrix_count_up, matrix_unordered)\n    [[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]]\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    >>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid matrix dimensions\n    \"\"\"\n    if not matrix_a or not matrix_b:\n        return []\n    if not all(\n        (len(matrix_a) == len(matrix_b), is_square(matrix_a), is_square(matrix_b))\n    ):\n        raise ValueError(\"Invalid matrix dimensions\")\n\n    # Initialize the result matrix with zeros\n    result = [[0] * len(matrix_b[0]) for _ in range(len(matrix_a))]\n\n    # Recursive multiplication of matrices\n    def multiply(\n        i_loop: int,\n        j_loop: int,\n        k_loop: int,\n        matrix_a: Matrix,\n        matrix_b: Matrix,\n        result: Matrix,\n    ) -> None:\n        \"\"\"\n        :param matrix_a: A square Matrix.\n        :param matrix_b: Another square Matrix with the same dimensions as matrix_a.\n        :param result: Result matrix\n        :param i: Index used for iteration during multiplication.\n        :param j: Index used for iteration during multiplication.\n        :param k: Index used for iteration during multiplication.\n        >>> 0 > 1  # Doctests in inner functions are never run\n        True\n        \"\"\"\n        if i_loop >= len(matrix_a):\n            return\n        if j_loop >= len(matrix_b[0]):\n            return multiply(i_loop + 1, 0, 0, matrix_a, matrix_b, result)\n        if k_loop >= len(matrix_b):\n            return multiply(i_loop, j_loop + 1, 0, matrix_a, matrix_b, result)\n        result[i_loop][j_loop] += matrix_a[i_loop][k_loop] * matrix_b[k_loop][j_loop]\n        return multiply(i_loop, j_loop, k_loop + 1, matrix_a, matrix_b, result)\n\n    # Perform the recursive matrix multiplication\n    multiply(0, 0, 0, matrix_a, matrix_b, result)\n    return result\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    failure_count, test_count = testmod()\n    if not failure_count:\n        matrix_a = matrices[0]\n        for matrix_b in matrices[1:]:\n            print(\"Multiplying:\")\n            for row in matrix_a:\n                print(row)\n            print(\"By:\")\n            for row in matrix_b:\n                print(row)\n            print(\"Result:\")\n            try:\n                result = matrix_multiply_recursive(matrix_a, matrix_b)\n                for row in result:\n                    print(row)\n                assert result == matrix_multiply(matrix_a, matrix_b)\n            except ValueError as e:\n                print(f\"{e!r}\")\n            print()\n            matrix_a = matrix_b\n\n    print(\"Benchmark:\")\n    from functools import partial\n    from timeit import timeit\n\n    mytimeit = partial(timeit, globals=globals(), number=100_000)\n    for func in (\"matrix_multiply\", \"matrix_multiply_recursive\"):\n        print(f\"{func:>25}(): {mytimeit(f'{func}(matrix_count_up, matrix_unordered)')}\")\n", "matrix/count_islands_in_matrix.py": "# An island in matrix is a group of linked areas, all having the same value.\n# This code counts number of islands in a given matrix, with including diagonal\n# connections.\n\n\nclass Matrix:  # Public class to implement a graph\n    def __init__(self, row: int, col: int, graph: list[list[bool]]) -> None:\n        self.ROW = row\n        self.COL = col\n        self.graph = graph\n\n    def is_safe(self, i: int, j: int, visited: list[list[bool]]) -> bool:\n        return (\n            0 <= i < self.ROW\n            and 0 <= j < self.COL\n            and not visited[i][j]\n            and self.graph[i][j]\n        )\n\n    def diffs(self, i: int, j: int, visited: list[list[bool]]) -> None:\n        # Checking all 8 elements surrounding nth element\n        row_nbr = [-1, -1, -1, 0, 0, 1, 1, 1]  # Coordinate order\n        col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]\n        visited[i][j] = True  # Make those cells visited\n        for k in range(8):\n            if self.is_safe(i + row_nbr[k], j + col_nbr[k], visited):\n                self.diffs(i + row_nbr[k], j + col_nbr[k], visited)\n\n    def count_islands(self) -> int:  # And finally, count all islands.\n        visited = [[False for j in range(self.COL)] for i in range(self.ROW)]\n        count = 0\n        for i in range(self.ROW):\n            for j in range(self.COL):\n                if visited[i][j] is False and self.graph[i][j] == 1:\n                    self.diffs(i, j, visited)\n                    count += 1\n        return count\n", "matrix/validate_sudoku_board.py": "\"\"\"\nLeetCode 36. Valid Sudoku\nhttps://leetcode.com/problems/valid-sudoku/\nhttps://en.wikipedia.org/wiki/Sudoku\n\nDetermine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be\nvalidated according to the following rules:\n\n- Each row must contain the digits 1-9 without repetition.\n- Each column must contain the digits 1-9 without repetition.\n- Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9\n  without repetition.\n\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily\nsolvable.\n\nOnly the filled cells need to be validated according to the mentioned rules.\n\"\"\"\n\nfrom collections import defaultdict\n\nNUM_SQUARES = 9\nEMPTY_CELL = \".\"\n\n\ndef is_valid_sudoku_board(sudoku_board: list[list[str]]) -> bool:\n    \"\"\"\n    This function validates (but does not solve) a sudoku board.\n    The board may be valid but unsolvable.\n\n    >>> is_valid_sudoku_board([\n    ...  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ... ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ... ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ... ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ... ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ... ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ... ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ... ])\n    False\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n    ... ,[\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\",\"3\"]\n    ... ,[\"7\",\"8\",\"9\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n    ... ,[\".\",\".\",\".\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\".\",\".\",\".\",\"5\",\"6\",\"4\"]\n    ... ,[\"4\",\"5\",\"6\",\".\",\".\",\".\",\"8\",\"9\",\"7\"]\n    ... ,[\"7\",\"8\",\"9\",\".\",\".\",\".\",\"2\",\"3\",\"1\"]\n    ... ,[\".\",\".\",\".\",\"4\",\"5\",\"6\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"7\",\"8\",\"9\",\".\",\".\",\".\"]\n    ... ,[\".\",\".\",\".\",\"1\",\"2\",\"3\",\".\",\".\",\".\"]\n    ... ,[\"3\",\"1\",\"2\",\".\",\".\",\".\",\"7\",\"8\",\"9\"]\n    ... ,[\"6\",\"4\",\"5\",\".\",\".\",\".\",\"1\",\"2\",\"3\"]\n    ... ,[\"9\",\"7\",\"8\",\".\",\".\",\".\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n    ... ,[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"]\n    ... ,[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"]\n    ... ,[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"]\n    ... ,[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]\n    ... ,[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"]\n    ... ,[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"]\n    ... ,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"]\n    ... ,[\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"]\n    ... ])\n    False\n    >>> is_valid_sudoku_board([\n    ...  [\"1\",\"2\",\"3\",\"8\",\"9\",\"7\",\"5\",\"6\",\"4\"]\n    ... ,[\"4\",\"5\",\"6\",\"2\",\"3\",\"1\",\"8\",\"9\",\"7\"]\n    ... ,[\"7\",\"8\",\"9\",\"5\",\"6\",\"4\",\"2\",\"3\",\"1\"]\n    ... ,[\"2\",\"3\",\"1\",\"4\",\"5\",\"6\",\"9\",\"7\",\"8\"]\n    ... ,[\"5\",\"6\",\"4\",\"7\",\"8\",\"9\",\"3\",\"1\",\"2\"]\n    ... ,[\"8\",\"9\",\"7\",\"1\",\"2\",\"3\",\"6\",\"4\",\"5\"]\n    ... ,[\"3\",\"1\",\"2\",\"6\",\"4\",\"5\",\"7\",\"8\",\"9\"]\n    ... ,[\"6\",\"4\",\"5\",\"9\",\"7\",\"8\",\"1\",\"2\",\"3\"]\n    ... ,[\"9\",\"7\",\"8\",\"3\",\"1\",\"2\",\"4\",\"5\",\"6\"]\n    ... ])\n    True\n    >>> is_valid_sudoku_board([[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Sudoku boards must be 9x9 squares.\n    >>> is_valid_sudoku_board(\n    ...        [[\"1\"], [\"2\"], [\"3\"], [\"4\"], [\"5\"], [\"6\"], [\"7\"], [\"8\"], [\"9\"]]\n    ...  )\n    Traceback (most recent call last):\n        ...\n    ValueError: Sudoku boards must be 9x9 squares.\n    \"\"\"\n    if len(sudoku_board) != NUM_SQUARES or (\n        any(len(row) != NUM_SQUARES for row in sudoku_board)\n    ):\n        error_message = f\"Sudoku boards must be {NUM_SQUARES}x{NUM_SQUARES} squares.\"\n        raise ValueError(error_message)\n\n    row_values: defaultdict[int, set[str]] = defaultdict(set)\n    col_values: defaultdict[int, set[str]] = defaultdict(set)\n    box_values: defaultdict[tuple[int, int], set[str]] = defaultdict(set)\n\n    for row in range(NUM_SQUARES):\n        for col in range(NUM_SQUARES):\n            value = sudoku_board[row][col]\n\n            if value == EMPTY_CELL:\n                continue\n\n            box = (row // 3, col // 3)\n\n            if (\n                value in row_values[row]\n                or value in col_values[col]\n                or value in box_values[box]\n            ):\n                return False\n\n            row_values[row].add(value)\n            col_values[col].add(value)\n            box_values[box].add(value)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n    from timeit import timeit\n\n    testmod()\n    print(timeit(\"is_valid_sudoku_board(valid_board)\", globals=globals()))\n    print(timeit(\"is_valid_sudoku_board(invalid_board)\", globals=globals()))\n", "matrix/largest_square_area_in_matrix.py": "\"\"\"\nQuestion:\nGiven a binary matrix mat of size n * m, find out the maximum size square\nsub-matrix with all 1s.\n\n---\nExample 1:\n\nInput:\nn = 2, m = 2\nmat = [[1, 1],\n       [1, 1]]\n\nOutput:\n2\n\nExplanation: The maximum size of the square\nsub-matrix is 2. The matrix itself is the\nmaximum sized sub-matrix in this case.\n---\nExample 2\n\nInput:\nn = 2, m = 2\nmat = [[0, 0],\n       [0, 0]]\nOutput: 0\n\nExplanation: There is no 1 in the matrix.\n\n\nApproach:\nWe initialize another matrix (dp) with the same dimensions\nas the original one initialized with all 0's.\n\ndp_array(i,j) represents the side length of the maximum square whose\nbottom right corner is the cell with index (i,j) in the original matrix.\n\nStarting from index (0,0), for every 1 found in the original matrix,\nwe update the value of the current element as\n\ndp_array(i,j)=dp_array(dp(i-1,j),dp_array(i-1,j-1),dp_array(i,j-1)) + 1.\n\"\"\"\n\n\ndef largest_square_area_in_matrix_top_down_approch(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We aren't using dp_array here, so the time complexity would be exponential.\n\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square(row: int, col: int) -> int:\n        # BASE CASE\n        if row >= rows or col >= cols:\n            return 0\n\n        right = update_area_of_max_square(row, col + 1)\n        diagonal = update_area_of_max_square(row + 1, col + 1)\n        down = update_area_of_max_square(row + 1, col)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    update_area_of_max_square(0, 0)\n    return largest_square_area[0]\n\n\ndef largest_square_area_in_matrix_top_down_approch_with_dp(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area[0], if recursive call found\n    square with maximum area.\n\n    We are using dp_array here, so the time complexity would be O(N^2).\n\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n\n    def update_area_of_max_square_using_dp_array(\n        row: int, col: int, dp_array: list[list[int]]\n    ) -> int:\n        if row >= rows or col >= cols:\n            return 0\n        if dp_array[row][col] != -1:\n            return dp_array[row][col]\n\n        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)\n        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)\n        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)\n\n        if mat[row][col]:\n            sub_problem_sol = 1 + min([right, diagonal, down])\n            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)\n            dp_array[row][col] = sub_problem_sol\n            return sub_problem_sol\n        else:\n            return 0\n\n    largest_square_area = [0]\n    dp_array = [[-1] * cols for _ in range(rows)]\n    update_area_of_max_square_using_dp_array(0, 0, dp_array)\n\n    return largest_square_area[0]\n\n\ndef largest_square_area_in_matrix_bottom_up(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up approach.\n\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])\n    0\n\n    \"\"\"\n    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = dp_array[row][col + 1]\n            diagonal = dp_array[row + 1][col + 1]\n            bottom = dp_array[row + 1][col]\n\n            if mat[row][col] == 1:\n                dp_array[row][col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(dp_array[row][col], largest_square_area)\n            else:\n                dp_array[row][col] = 0\n\n    return largest_square_area\n\n\ndef largest_square_area_in_matrix_bottom_up_space_optimization(\n    rows: int, cols: int, mat: list[list[int]]\n) -> int:\n    \"\"\"\n    Function updates the largest_square_area, using bottom up\n    approach. with space optimization.\n\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])\n    2\n    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])\n    0\n    \"\"\"\n    current_row = [0] * (cols + 1)\n    next_row = [0] * (cols + 1)\n    largest_square_area = 0\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            right = current_row[col + 1]\n            diagonal = next_row[col + 1]\n            bottom = next_row[col]\n\n            if mat[row][col] == 1:\n                current_row[col] = 1 + min(right, diagonal, bottom)\n                largest_square_area = max(current_row[col], largest_square_area)\n            else:\n                current_row[col] = 0\n        next_row = current_row\n\n    return largest_square_area\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(largest_square_area_in_matrix_bottom_up(2, 2, [[1, 1], [1, 1]]))\n", "matrix/spiral_print.py": "\"\"\"\nThis program print the matrix in spiral form.\nThis problem has been solved through recursive way.\n      Matrix must satisfy below conditions\n        i) matrix should be only one or two dimensional\n        ii) number of column of all rows should be equal\n\"\"\"\n\n\ndef check_matrix(matrix: list[list[int]]) -> bool:\n    # must be\n    matrix = [list(row) for row in matrix]\n    if matrix and isinstance(matrix, list):\n        if isinstance(matrix[0], list):\n            prev_len = 0\n            for row in matrix:\n                if prev_len == 0:\n                    prev_len = len(row)\n                    result = True\n                else:\n                    result = prev_len == len(row)\n        else:\n            result = True\n    else:\n        result = False\n\n    return result\n\n\ndef spiral_print_clockwise(a: list[list[int]]) -> None:\n    \"\"\"\n    >>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    1\n    2\n    3\n    4\n    8\n    12\n    11\n    10\n    9\n    5\n    6\n    7\n    \"\"\"\n    if check_matrix(a) and len(a) > 0:\n        a = [list(row) for row in a]\n        mat_row = len(a)\n        if isinstance(a[0], list):\n            mat_col = len(a[0])\n        else:\n            for dat in a:\n                print(dat)\n            return\n\n        # horizotal printing increasing\n        for i in range(mat_col):\n            print(a[0][i])\n        # vertical printing down\n        for i in range(1, mat_row):\n            print(a[i][mat_col - 1])\n        # horizotal printing decreasing\n        if mat_row > 1:\n            for i in range(mat_col - 2, -1, -1):\n                print(a[mat_row - 1][i])\n        # vertical printing up\n        for i in range(mat_row - 2, 0, -1):\n            print(a[i][0])\n        remain_mat = [row[1 : mat_col - 1] for row in a[1 : mat_row - 1]]\n        if len(remain_mat) > 0:\n            spiral_print_clockwise(remain_mat)\n        else:\n            return\n    else:\n        print(\"Not a valid matrix\")\n        return\n\n\n# Other Easy to understand Approach\n\n\ndef spiral_traversal(matrix: list[list]) -> list[int]:\n    \"\"\"\n    >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n    Example:\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    Algorithm:\n        Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the\n                output of [step 2])\n        Step 2. Now perform matrix's Transpose operation (Change rows to column\n                and vice versa) and reverse the resultant matrix.\n        Step 3. Pass the output of [2nd step], to same recursive function till\n                base case hits.\n    Dry Run:\n    Stage 1.\n    [1, 2, 3, 4] +   spiral_traversal([\n        [8, 12], [7, 11], [6, 10], [5, 9]]\n     ])\n    Stage 2.\n    [1, 2, 3, 4, 8, 12] + spiral_traversal([\n        [11, 10, 9], [7, 6, 5]\n    ])\n    Stage 3.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 4.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([\n        [5], [6], [7]\n    ])\n    Stage 5.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])\n    Stage 6.\n    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])\n    \"\"\"\n    if matrix:\n        return list(matrix.pop(0)) + spiral_traversal(\n            [list(row) for row in zip(*matrix)][::-1]\n        )\n    else:\n        return []\n\n\n# driver code\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    spiral_print_clockwise(a)\n", "matrix/__init__.py": "", "matrix/median_matrix.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Median\n\"\"\"\n\n\ndef median(matrix: list[list[int]]) -> int:\n    \"\"\"\n    Calculate the median of a sorted matrix.\n\n    Args:\n        matrix: A 2D matrix of integers.\n\n    Returns:\n        The median value of the matrix.\n\n    Examples:\n        >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]\n        >>> median(matrix)\n        5\n\n        >>> matrix = [[1, 2, 3], [4, 5, 6]]\n        >>> median(matrix)\n        3\n    \"\"\"\n    # Flatten the matrix into a sorted 1D list\n    linear = sorted(num for row in matrix for num in row)\n\n    # Calculate the middle index\n    mid = (len(linear) - 1) // 2\n\n    # Return the median\n    return linear[mid]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "matrix/nth_fibonacci_using_matrix_exponentiation.py": "\"\"\"\nImplementation of finding nth fibonacci number using matrix exponentiation.\nTime Complexity is about O(log(n)*8), where 8 is the complexity of matrix\nmultiplication of size 2 by 2.\nAnd on the other hand complexity of bruteforce solution is O(n).\nAs we know\n    f[n] = f[n-1] + f[n-1]\nConverting to matrix,\n    [f(n),f(n-1)] = [[1,1],[1,0]] * [f(n-1),f(n-2)]\n->  [f(n),f(n-1)] = [[1,1],[1,0]]^2 * [f(n-2),f(n-3)]\n    ...\n    ...\n->  [f(n),f(n-1)] = [[1,1],[1,0]]^(n-1) * [f(1),f(0)]\nSo we just need the n times multiplication of the matrix [1,1],[1,0]].\nWe can decrease the n times multiplication by following the divide and conquer approach.\n\"\"\"\n\n\ndef multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]:\n    matrix_c = []\n    n = len(matrix_a)\n    for i in range(n):\n        list_1 = []\n        for j in range(n):\n            val = 0\n            for k in range(n):\n                val = val + matrix_a[i][k] * matrix_b[k][j]\n            list_1.append(val)\n        matrix_c.append(list_1)\n    return matrix_c\n\n\ndef identity(n: int) -> list[list[int]]:\n    return [[int(row == column) for column in range(n)] for row in range(n)]\n\n\ndef nth_fibonacci_matrix(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_matrix(100)\n    354224848179261915075\n    >>> nth_fibonacci_matrix(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    res_matrix = identity(2)\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    n = n - 1\n    while n > 0:\n        if n % 2 == 1:\n            res_matrix = multiply(res_matrix, fibonacci_matrix)\n        fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)\n        n = int(n / 2)\n    return res_matrix[0][0]\n\n\ndef nth_fibonacci_bruteforce(n: int) -> int:\n    \"\"\"\n    >>> nth_fibonacci_bruteforce(100)\n    354224848179261915075\n    >>> nth_fibonacci_bruteforce(-100)\n    -100\n    \"\"\"\n    if n <= 1:\n        return n\n    fib0 = 0\n    fib1 = 1\n    for _ in range(2, n + 1):\n        fib0, fib1 = fib1, fib0 + fib1\n    return fib1\n\n\ndef main() -> None:\n    for ordinal in \"0th 1st 2nd 3rd 10th 100th 1000th\".split():\n        n = int(\"\".join(c for c in ordinal if c in \"0123456789\"))  # 1000th --> 1000\n        print(\n            f\"{ordinal} fibonacci number using matrix exponentiation is \"\n            f\"{nth_fibonacci_matrix(n)} and using bruteforce is \"\n            f\"{nth_fibonacci_bruteforce(n)}\\n\"\n        )\n    # from timeit import timeit\n    # print(timeit(\"nth_fibonacci_matrix(1000000)\",\n    #              \"from main import nth_fibonacci_matrix\", number=5))\n    # print(timeit(\"nth_fibonacci_bruteforce(1000000)\",\n    #              \"from main import nth_fibonacci_bruteforce\", number=5))\n    # 2.3342058970001744\n    # 57.256506615000035\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "matrix/max_area_of_island.py": "\"\"\"\nGiven an two dimensional binary matrix grid. An island is a group of 1's (representing\nland) connected 4-directionally (horizontal or vertical.) You may assume all four edges\nof the grid are surrounded by water.  The area of an island is the number of cells with\na value 1 in the island. Return the maximum area of an island in a grid. If there is no\nisland, return 0.\n\"\"\"\n\nmatrix = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\n\n\ndef is_safe(row: int, col: int, rows: int, cols: int) -> bool:\n    \"\"\"\n    Checking whether coordinate (row, col) is valid or not.\n\n    >>> is_safe(0, 0, 5, 5)\n    True\n    >>> is_safe(-1,-1, 5, 5)\n    False\n    \"\"\"\n    return 0 <= row < rows and 0 <= col < cols\n\n\ndef depth_first_search(row: int, col: int, seen: set, mat: list[list[int]]) -> int:\n    \"\"\"\n    Returns the current area of the island\n\n    >>> depth_first_search(0, 0, set(), matrix)\n    0\n    \"\"\"\n    rows = len(mat)\n    cols = len(mat[0])\n    if is_safe(row, col, rows, cols) and (row, col) not in seen and mat[row][col] == 1:\n        seen.add((row, col))\n        return (\n            1\n            + depth_first_search(row + 1, col, seen, mat)\n            + depth_first_search(row - 1, col, seen, mat)\n            + depth_first_search(row, col + 1, seen, mat)\n            + depth_first_search(row, col - 1, seen, mat)\n        )\n    else:\n        return 0\n\n\ndef find_max_area(mat: list[list[int]]) -> int:\n    \"\"\"\n    Finds the area of all islands and returns the maximum area.\n\n    >>> find_max_area(matrix)\n    6\n    \"\"\"\n    seen: set = set()\n\n    max_area = 0\n    for row, line in enumerate(mat):\n        for col, item in enumerate(line):\n            if item == 1 and (row, col) not in seen:\n                # Maximizing the area\n                max_area = max(max_area, depth_first_search(row, col, seen, mat))\n    return max_area\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    print(find_max_area(matrix))  # Output -> 6\n\n    \"\"\"\n    Explanation:\n    We are allowed to move in four directions (horizontal or vertical) so the possible\n    in a matrix if we are at x and y position the possible moving are\n\n    Directions are [(x, y+1), (x, y-1), (x+1, y), (x-1, y)] but we need to take care of\n    boundary cases as well which are x and y can not be smaller than 0 and greater than\n    the number of rows and columns respectively.\n\n    Visualization\n    mat = [\n        [0,0,A,0,0,0,0,B,0,0,0,0,0],\n        [0,0,0,0,0,0,0,B,B,B,0,0,0],\n        [0,C,C,0,D,0,0,0,0,0,0,0,0],\n        [0,C,0,0,D,D,0,0,E,0,E,0,0],\n        [0,C,0,0,D,D,0,0,E,E,E,0,0],\n        [0,0,0,0,0,0,0,0,0,0,E,0,0],\n        [0,0,0,0,0,0,0,F,F,F,0,0,0],\n        [0,0,0,0,0,0,0,F,F,0,0,0,0]\n    ]\n\n    For visualization, I have defined the connected island with letters\n    by observation, we can see that\n        A island is of area 1\n        B island is of area 4\n        C island is of area 4\n        D island is of area 5\n        E island is of area 6 and\n        F island is of area 5\n\n    it has 6 unique islands of mentioned areas\n    and the maximum of all of them is 6 so we return 6.\n    \"\"\"\n\n    doctest.testmod()\n", "matrix/inverse_of_matrix.py": "from __future__ import annotations\n\nfrom decimal import Decimal\n\nfrom numpy import array\n\n\ndef inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    A matrix multiplied with its inverse gives the identity matrix.\n    This function finds the inverse of a 2x2 and 3x3 matrix.\n    If the determinant of a matrix is 0, its inverse does not exist.\n\n    Sources for fixing inaccurate float arithmetic:\n    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python\n    https://docs.python.org/3/library/decimal.html\n\n    Doctests for 2x2\n    >>> inverse_of_matrix([[2, 5], [2, 0]])\n    [[0.0, 0.5], [0.2, -0.2]]\n    >>> inverse_of_matrix([[2.5, 5], [1, 2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n    >>> inverse_of_matrix([[12, -16], [-9, 0]])\n    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]\n    >>> inverse_of_matrix([[12, 3], [16, 8]])\n    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]\n    >>> inverse_of_matrix([[10, 5], [3, 2.5]])\n    [[0.25, -0.5], [-0.3, 1.0]]\n\n    Doctests for 3x3\n    >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])\n    [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]\n    >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[],[]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Please provide a matrix of size 2x2 or 3x3.\n\n    >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])\n    Traceback (most recent call last):\n        ...\n    ValueError: This matrix has no inverse.\n\n    >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n    \"\"\"\n\n    d = Decimal\n\n    # Check if the provided matrix has 2 rows and 2 columns\n    # since this implementation only works for 2x2 matrices\n    if len(matrix) == 2 and len(matrix[0]) == 2 and len(matrix[1]) == 2:\n        # Calculate the determinant of the matrix\n        determinant = float(\n            d(matrix[0][0]) * d(matrix[1][1]) - d(matrix[1][0]) * d(matrix[0][1])\n        )\n        if determinant == 0:\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creates a copy of the matrix with swapped positions of the elements\n        swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]\n        swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]\n        swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]\n\n        # Calculate the inverse of the matrix\n        return [\n            [(float(d(n)) / determinant) or 0.0 for n in row] for row in swapped_matrix\n        ]\n    elif (\n        len(matrix) == 3\n        and len(matrix[0]) == 3\n        and len(matrix[1]) == 3\n        and len(matrix[2]) == 3\n    ):\n        # Calculate the determinant of the matrix using Sarrus rule\n        determinant = float(\n            (\n                (d(matrix[0][0]) * d(matrix[1][1]) * d(matrix[2][2]))\n                + (d(matrix[0][1]) * d(matrix[1][2]) * d(matrix[2][0]))\n                + (d(matrix[0][2]) * d(matrix[1][0]) * d(matrix[2][1]))\n            )\n            - (\n                (d(matrix[0][2]) * d(matrix[1][1]) * d(matrix[2][0]))\n                + (d(matrix[0][1]) * d(matrix[1][0]) * d(matrix[2][2]))\n                + (d(matrix[0][0]) * d(matrix[1][2]) * d(matrix[2][1]))\n            )\n        )\n        if determinant == 0:\n            raise ValueError(\"This matrix has no inverse.\")\n\n        # Creating cofactor matrix\n        cofactor_matrix = [\n            [d(0.0), d(0.0), d(0.0)],\n            [d(0.0), d(0.0), d(0.0)],\n            [d(0.0), d(0.0), d(0.0)],\n        ]\n        cofactor_matrix[0][0] = (d(matrix[1][1]) * d(matrix[2][2])) - (\n            d(matrix[1][2]) * d(matrix[2][1])\n        )\n        cofactor_matrix[0][1] = -(\n            (d(matrix[1][0]) * d(matrix[2][2])) - (d(matrix[1][2]) * d(matrix[2][0]))\n        )\n        cofactor_matrix[0][2] = (d(matrix[1][0]) * d(matrix[2][1])) - (\n            d(matrix[1][1]) * d(matrix[2][0])\n        )\n        cofactor_matrix[1][0] = -(\n            (d(matrix[0][1]) * d(matrix[2][2])) - (d(matrix[0][2]) * d(matrix[2][1]))\n        )\n        cofactor_matrix[1][1] = (d(matrix[0][0]) * d(matrix[2][2])) - (\n            d(matrix[0][2]) * d(matrix[2][0])\n        )\n        cofactor_matrix[1][2] = -(\n            (d(matrix[0][0]) * d(matrix[2][1])) - (d(matrix[0][1]) * d(matrix[2][0]))\n        )\n        cofactor_matrix[2][0] = (d(matrix[0][1]) * d(matrix[1][2])) - (\n            d(matrix[0][2]) * d(matrix[1][1])\n        )\n        cofactor_matrix[2][1] = -(\n            (d(matrix[0][0]) * d(matrix[1][2])) - (d(matrix[0][2]) * d(matrix[1][0]))\n        )\n        cofactor_matrix[2][2] = (d(matrix[0][0]) * d(matrix[1][1])) - (\n            d(matrix[0][1]) * d(matrix[1][0])\n        )\n\n        # Transpose the cofactor matrix (Adjoint matrix)\n        adjoint_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                adjoint_matrix[i][j] = cofactor_matrix[j][i]\n\n        # Inverse of the matrix using the formula (1/determinant) * adjoint matrix\n        inverse_matrix = array(cofactor_matrix)\n        for i in range(3):\n            for j in range(3):\n                inverse_matrix[i][j] /= d(determinant)\n\n        # Calculate the inverse of the matrix\n        return [[float(d(n)) or 0.0 for n in row] for row in inverse_matrix]\n    raise ValueError(\"Please provide a matrix of size 2x2 or 3x3.\")\n", "matrix/matrix_class.py": "# An OOP approach to representing and manipulating matrices\n\nfrom __future__ import annotations\n\n\nclass Matrix:\n    \"\"\"\n    Matrix object generated from a 2D array where each element is an array representing\n    a row.\n    Rows can contain type int or float.\n    Common operations and information available.\n    >>> rows = [\n    ...     [1, 2, 3],\n    ...     [4, 5, 6],\n    ...     [7, 8, 9]\n    ... ]\n    >>> matrix = Matrix(rows)\n    >>> print(matrix)\n    [[1. 2. 3.]\n     [4. 5. 6.]\n     [7. 8. 9.]]\n\n    Matrix rows and columns are available as 2D arrays\n    >>> matrix.rows\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> matrix.columns()\n    [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n\n    Order is returned as a tuple\n    >>> matrix.order\n    (3, 3)\n\n    Squareness and invertability are represented as bool\n    >>> matrix.is_square\n    True\n    >>> matrix.is_invertable()\n    False\n\n    Identity, Minors, Cofactors and Adjugate are returned as Matrices.  Inverse can be\n    a Matrix or Nonetype\n    >>> print(matrix.identity())\n    [[1. 0. 0.]\n     [0. 1. 0.]\n     [0. 0. 1.]]\n    >>> print(matrix.minors())\n    [[-3. -6. -3.]\n     [-6. -12. -6.]\n     [-3. -6. -3.]]\n    >>> print(matrix.cofactors())\n    [[-3. 6. -3.]\n     [6. -12. 6.]\n     [-3. 6. -3.]]\n    >>>  # won't be apparent due to the nature of the cofactor matrix\n    >>> print(matrix.adjugate())\n    [[-3. 6. -3.]\n     [6. -12. 6.]\n     [-3. 6. -3.]]\n    >>> matrix.inverse()\n    Traceback (most recent call last):\n        ...\n    TypeError: Only matrices with a non-zero determinant have an inverse\n\n    Determinant is an int, float, or Nonetype\n    >>> matrix.determinant()\n    0\n\n    Negation, scalar multiplication, addition, subtraction, multiplication and\n    exponentiation are available and all return a Matrix\n    >>> print(-matrix)\n    [[-1. -2. -3.]\n     [-4. -5. -6.]\n     [-7. -8. -9.]]\n    >>> matrix2 = matrix * 3\n    >>> print(matrix2)\n    [[3. 6. 9.]\n     [12. 15. 18.]\n     [21. 24. 27.]]\n    >>> print(matrix + matrix2)\n    [[4. 8. 12.]\n     [16. 20. 24.]\n     [28. 32. 36.]]\n    >>> print(matrix - matrix2)\n    [[-2. -4. -6.]\n     [-8. -10. -12.]\n     [-14. -16. -18.]]\n    >>> print(matrix ** 3)\n    [[468. 576. 684.]\n     [1062. 1305. 1548.]\n     [1656. 2034. 2412.]]\n\n    Matrices can also be modified\n    >>> matrix.add_row([10, 11, 12])\n    >>> print(matrix)\n    [[1. 2. 3.]\n     [4. 5. 6.]\n     [7. 8. 9.]\n     [10. 11. 12.]]\n    >>> matrix2.add_column([8, 16, 32])\n    >>> print(matrix2)\n    [[3. 6. 9. 8.]\n     [12. 15. 18. 16.]\n     [21. 24. 27. 32.]]\n    >>> print(matrix *  matrix2)\n    [[90. 108. 126. 136.]\n     [198. 243. 288. 304.]\n     [306. 378. 450. 472.]\n     [414. 513. 612. 640.]]\n    \"\"\"\n\n    def __init__(self, rows: list[list[int]]):\n        error = TypeError(\n            \"Matrices must be formed from a list of zero or more lists containing at \"\n            \"least one and the same number of values, each of which must be of type \"\n            \"int or float.\"\n        )\n        if len(rows) != 0:\n            cols = len(rows[0])\n            if cols == 0:\n                raise error\n            for row in rows:\n                if len(row) != cols:\n                    raise error\n                for value in row:\n                    if not isinstance(value, (int, float)):\n                        raise error\n            self.rows = rows\n        else:\n            self.rows = []\n\n    # MATRIX INFORMATION\n    def columns(self) -> list[list[int]]:\n        return [[row[i] for row in self.rows] for i in range(len(self.rows[0]))]\n\n    @property\n    def num_rows(self) -> int:\n        return len(self.rows)\n\n    @property\n    def num_columns(self) -> int:\n        return len(self.rows[0])\n\n    @property\n    def order(self) -> tuple[int, int]:\n        return self.num_rows, self.num_columns\n\n    @property\n    def is_square(self) -> bool:\n        return self.order[0] == self.order[1]\n\n    def identity(self) -> Matrix:\n        values = [\n            [0 if column_num != row_num else 1 for column_num in range(self.num_rows)]\n            for row_num in range(self.num_rows)\n        ]\n        return Matrix(values)\n\n    def determinant(self) -> int:\n        if not self.is_square:\n            return 0\n        if self.order == (0, 0):\n            return 1\n        if self.order == (1, 1):\n            return int(self.rows[0][0])\n        if self.order == (2, 2):\n            return int(\n                (self.rows[0][0] * self.rows[1][1])\n                - (self.rows[0][1] * self.rows[1][0])\n            )\n        else:\n            return sum(\n                self.rows[0][column] * self.cofactors().rows[0][column]\n                for column in range(self.num_columns)\n            )\n\n    def is_invertable(self) -> bool:\n        return bool(self.determinant())\n\n    def get_minor(self, row: int, column: int) -> int:\n        values = [\n            [\n                self.rows[other_row][other_column]\n                for other_column in range(self.num_columns)\n                if other_column != column\n            ]\n            for other_row in range(self.num_rows)\n            if other_row != row\n        ]\n        return Matrix(values).determinant()\n\n    def get_cofactor(self, row: int, column: int) -> int:\n        if (row + column) % 2 == 0:\n            return self.get_minor(row, column)\n        return -1 * self.get_minor(row, column)\n\n    def minors(self) -> Matrix:\n        return Matrix(\n            [\n                [self.get_minor(row, column) for column in range(self.num_columns)]\n                for row in range(self.num_rows)\n            ]\n        )\n\n    def cofactors(self) -> Matrix:\n        return Matrix(\n            [\n                [\n                    self.minors().rows[row][column]\n                    if (row + column) % 2 == 0\n                    else self.minors().rows[row][column] * -1\n                    for column in range(self.minors().num_columns)\n                ]\n                for row in range(self.minors().num_rows)\n            ]\n        )\n\n    def adjugate(self) -> Matrix:\n        values = [\n            [self.cofactors().rows[column][row] for column in range(self.num_columns)]\n            for row in range(self.num_rows)\n        ]\n        return Matrix(values)\n\n    def inverse(self) -> Matrix:\n        determinant = self.determinant()\n        if not determinant:\n            raise TypeError(\"Only matrices with a non-zero determinant have an inverse\")\n        return self.adjugate() * (1 / determinant)\n\n    def __repr__(self) -> str:\n        return str(self.rows)\n\n    def __str__(self) -> str:\n        if self.num_rows == 0:\n            return \"[]\"\n        if self.num_rows == 1:\n            return \"[[\" + \". \".join(str(self.rows[0])) + \"]]\"\n        return (\n            \"[\"\n            + \"\\n \".join(\n                [\n                    \"[\" + \". \".join([str(value) for value in row]) + \".]\"\n                    for row in self.rows\n                ]\n            )\n            + \"]\"\n        )\n\n    # MATRIX MANIPULATION\n    def add_row(self, row: list[int], position: int | None = None) -> None:\n        type_error = TypeError(\"Row must be a list containing all ints and/or floats\")\n        if not isinstance(row, list):\n            raise type_error\n        for value in row:\n            if not isinstance(value, (int, float)):\n                raise type_error\n        if len(row) != self.num_columns:\n            raise ValueError(\n                \"Row must be equal in length to the other rows in the matrix\"\n            )\n        if position is None:\n            self.rows.append(row)\n        else:\n            self.rows = self.rows[0:position] + [row] + self.rows[position:]\n\n    def add_column(self, column: list[int], position: int | None = None) -> None:\n        type_error = TypeError(\n            \"Column must be a list containing all ints and/or floats\"\n        )\n        if not isinstance(column, list):\n            raise type_error\n        for value in column:\n            if not isinstance(value, (int, float)):\n                raise type_error\n        if len(column) != self.num_rows:\n            raise ValueError(\n                \"Column must be equal in length to the other columns in the matrix\"\n            )\n        if position is None:\n            self.rows = [self.rows[i] + [column[i]] for i in range(self.num_rows)]\n        else:\n            self.rows = [\n                self.rows[i][0:position] + [column[i]] + self.rows[i][position:]\n                for i in range(self.num_rows)\n            ]\n\n    # MATRIX OPERATIONS\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Matrix):\n            return NotImplemented\n        return self.rows == other.rows\n\n    def __ne__(self, other: object) -> bool:\n        return not self == other\n\n    def __neg__(self) -> Matrix:\n        return self * -1\n\n    def __add__(self, other: Matrix) -> Matrix:\n        if self.order != other.order:\n            raise ValueError(\"Addition requires matrices of the same order\")\n        return Matrix(\n            [\n                [self.rows[i][j] + other.rows[i][j] for j in range(self.num_columns)]\n                for i in range(self.num_rows)\n            ]\n        )\n\n    def __sub__(self, other: Matrix) -> Matrix:\n        if self.order != other.order:\n            raise ValueError(\"Subtraction requires matrices of the same order\")\n        return Matrix(\n            [\n                [self.rows[i][j] - other.rows[i][j] for j in range(self.num_columns)]\n                for i in range(self.num_rows)\n            ]\n        )\n\n    def __mul__(self, other: Matrix | float) -> Matrix:\n        if isinstance(other, (int, float)):\n            return Matrix(\n                [[int(element * other) for element in row] for row in self.rows]\n            )\n        elif isinstance(other, Matrix):\n            if self.num_columns != other.num_rows:\n                raise ValueError(\n                    \"The number of columns in the first matrix must \"\n                    \"be equal to the number of rows in the second\"\n                )\n            return Matrix(\n                [\n                    [Matrix.dot_product(row, column) for column in other.columns()]\n                    for row in self.rows\n                ]\n            )\n        else:\n            raise TypeError(\n                \"A Matrix can only be multiplied by an int, float, or another matrix\"\n            )\n\n    def __pow__(self, other: int) -> Matrix:\n        if not isinstance(other, int):\n            raise TypeError(\"A Matrix can only be raised to the power of an int\")\n        if not self.is_square:\n            raise ValueError(\"Only square matrices can be raised to a power\")\n        if other == 0:\n            return self.identity()\n        if other < 0:\n            if self.is_invertable():\n                return self.inverse() ** (-other)\n            raise ValueError(\n                \"Only invertable matrices can be raised to a negative power\"\n            )\n        result = self\n        for _ in range(other - 1):\n            result *= self\n        return result\n\n    @classmethod\n    def dot_product(cls, row: list[int], column: list[int]) -> int:\n        return sum(row[i] * column[i] for i in range(len(row)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/split.py": "def split(string: str, separator: str = \" \") -> list:\n    \"\"\"\n    Will split the string up into all the values separated by the separator\n    (defaults to spaces)\n\n    >>> split(\"apple#banana#cherry#orange\",separator='#')\n    ['apple', 'banana', 'cherry', 'orange']\n\n    >>> split(\"Hello there\")\n    ['Hello', 'there']\n\n    >>> split(\"11/22/63\",separator = '/')\n    ['11', '22', '63']\n\n    >>> split(\"12:43:39\",separator = \":\")\n    ['12', '43', '39']\n    \"\"\"\n\n    split_words = []\n\n    last_index = 0\n    for index, char in enumerate(string):\n        if char == separator:\n            split_words.append(string[last_index:index])\n            last_index = index + 1\n        elif index + 1 == len(string):\n            split_words.append(string[last_index : index + 1])\n    return split_words\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/wave.py": "def wave(txt: str) -> list:\n    \"\"\"\n    Returns a so called 'wave' of a given string\n    >>> wave('cat')\n    ['Cat', 'cAt', 'caT']\n    >>> wave('one')\n    ['One', 'oNe', 'onE']\n    >>> wave('book')\n    ['Book', 'bOok', 'boOk', 'booK']\n    \"\"\"\n\n    return [\n        txt[:a] + txt[a].upper() + txt[a + 1 :]\n        for a in range(len(txt))\n        if txt[a].isalpha()\n    ]\n\n\nif __name__ == \"__main__\":\n    __import__(\"doctest\").testmod()\n", "strings/hamming_distance.py": "def hamming_distance(string1: str, string2: str) -> int:\n    \"\"\"Calculate the Hamming distance between two equal length strings\n    In information theory, the Hamming distance between two strings of equal\n    length is the number of positions at which the corresponding symbols are\n    different. https://en.wikipedia.org/wiki/Hamming_distance\n\n    Args:\n        string1 (str): Sequence 1\n        string2 (str): Sequence 2\n\n    Returns:\n        int: Hamming distance\n\n    >>> hamming_distance(\"python\", \"python\")\n    0\n    >>> hamming_distance(\"karolin\", \"kathrin\")\n    3\n    >>> hamming_distance(\"00000\", \"11111\")\n    5\n    >>> hamming_distance(\"karolin\", \"kath\")\n    Traceback (most recent call last):\n      ...\n    ValueError: String lengths must match!\n    \"\"\"\n    if len(string1) != len(string2):\n        raise ValueError(\"String lengths must match!\")\n\n    count = 0\n\n    for char1, char2 in zip(string1, string2):\n        if char1 != char2:\n            count += 1\n\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/upper.py": "def upper(word: str) -> str:\n    \"\"\"\n    Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII\n    letters and subtracting 32 from their integer representation to get the uppercase\n    letter.\n\n    >>> upper(\"wow\")\n    'WOW'\n    >>> upper(\"Hello\")\n    'HELLO'\n    >>> upper(\"WHAT\")\n    'WHAT'\n    >>> upper(\"wh[]32\")\n    'WH[]32'\n    \"\"\"\n    return \"\".join(chr(ord(char) - 32) if \"a\" <= char <= \"z\" else char for char in word)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/naive_string_search.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/String-searching_algorithm#Na%C3%AFve_string_search\nthis algorithm tries to find the pattern from every position of\nthe mainString if pattern is found from position i it add it to\nthe answer and does the same for position i+1\nComplexity : O(n*m)\n    n=length of main string\n    m=length of pattern string\n\"\"\"\n\n\ndef naive_pattern_search(s: str, pattern: str) -> list:\n    \"\"\"\n    >>> naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\")\n    [4, 10, 18]\n    >>> naive_pattern_search(\"ABC\", \"ABAAABCDBBABCDDEBCABC\")\n    []\n    >>> naive_pattern_search(\"\", \"ABC\")\n    []\n    >>> naive_pattern_search(\"TEST\", \"TEST\")\n    [0]\n    >>> naive_pattern_search(\"ABCDEGFTEST\", \"TEST\")\n    [7]\n    \"\"\"\n    pat_len = len(pattern)\n    position = []\n    for i in range(len(s) - pat_len + 1):\n        match_found = True\n        for j in range(pat_len):\n            if s[i + j] != pattern[j]:\n                match_found = False\n                break\n        if match_found:\n            position.append(i)\n    return position\n\n\nif __name__ == \"__main__\":\n    assert naive_pattern_search(\"ABCDEFG\", \"DE\") == [3]\n    print(naive_pattern_search(\"ABAAABCDBBABCDDEBCABC\", \"ABC\"))\n", "strings/rabin_karp.py": "# Numbers of alphabet which we call base\nalphabet_size = 256\n# Modulus to hash a string\nmodulus = 1000003\n\n\ndef rabin_karp(pattern: str, text: str) -> bool:\n    \"\"\"\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\n    with complexity O(nm), most efficient when it is used with multiple patterns\n    as it is able to check if any of a set of patterns match a section of text in o(1)\n    given the precomputed hashes.\n\n    This will be the simple version which only assumes one pattern is being searched\n    for but it's not hard to modify\n\n    1) Calculate pattern hash\n\n    2) Step through the text one character at a time passing a window with the same\n        length as the pattern\n        calculating the hash of the text within the window compare it with the hash\n        of the pattern. Only testing equality if the hashes match\n    \"\"\"\n    p_len = len(pattern)\n    t_len = len(text)\n    if p_len > t_len:\n        return False\n\n    p_hash = 0\n    text_hash = 0\n    modulus_power = 1\n\n    # Calculating the hash of pattern and substring of text\n    for i in range(p_len):\n        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus\n        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus\n        if i == p_len - 1:\n            continue\n        modulus_power = (modulus_power * alphabet_size) % modulus\n\n    for i in range(t_len - p_len + 1):\n        if text_hash == p_hash and text[i : i + p_len] == pattern:\n            return True\n        if i == t_len - p_len:\n            continue\n        # Calculate the https://en.wikipedia.org/wiki/Rolling_hash\n        text_hash = (\n            (text_hash - ord(text[i]) * modulus_power) * alphabet_size\n            + ord(text[i + p_len])\n        ) % modulus\n    return False\n\n\ndef test_rabin_karp() -> None:\n    \"\"\"\n    >>> test_rabin_karp()\n    Success.\n    \"\"\"\n    # Test 1)\n    pattern = \"abc1abc12\"\n    text1 = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\n    text2 = \"alskfjaldsk23adsfabcabc\"\n    assert rabin_karp(pattern, text1)\n    assert not rabin_karp(pattern, text2)\n\n    # Test 2)\n    pattern = \"ABABX\"\n    text = \"ABABZABABYABABX\"\n    assert rabin_karp(pattern, text)\n\n    # Test 3)\n    pattern = \"AAAB\"\n    text = \"ABAAAAAB\"\n    assert rabin_karp(pattern, text)\n\n    # Test 4)\n    pattern = \"abcdabcy\"\n    text = \"abcxabcdabxabcdabcdabcy\"\n    assert rabin_karp(pattern, text)\n\n    # Test 5)\n    pattern = \"L\u00fc\"\n    text = \"L\u00fcsai\"\n    assert rabin_karp(pattern, text)\n    pattern = \"Lue\"\n    assert not rabin_karp(pattern, text)\n    print(\"Success.\")\n\n\nif __name__ == \"__main__\":\n    test_rabin_karp()\n", "strings/knuth_morris_pratt.py": "from __future__ import annotations\n\n\ndef knuth_morris_pratt(text: str, pattern: str) -> int:\n    \"\"\"\n    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text\n    with complexity O(n + m)\n\n    1) Preprocess pattern to identify any suffixes that are identical to prefixes\n\n        This tells us where to continue from if we get a mismatch between a character\n        in our pattern and the text.\n\n    2) Step through the text one character at a time and compare it to a character in\n        the pattern updating our location within the pattern if necessary\n\n    >>> kmp = \"knuth_morris_pratt\"\n    >>> all(\n    ...    knuth_morris_pratt(kmp, s) == kmp.find(s)\n    ...    for s in (\"kn\", \"h_m\", \"rr\", \"tt\", \"not there\")\n    ... )\n    True\n    \"\"\"\n\n    # 1) Construct the failure array\n    failure = get_failure_array(pattern)\n\n    # 2) Step through text searching for pattern\n    i, j = 0, 0  # index into text, pattern\n    while i < len(text):\n        if pattern[j] == text[i]:\n            if j == (len(pattern) - 1):\n                return i - j\n            j += 1\n\n        # if this is a prefix in our pattern\n        # just go back far enough to continue\n        elif j > 0:\n            j = failure[j - 1]\n            continue\n        i += 1\n    return -1\n\n\ndef get_failure_array(pattern: str) -> list[int]:\n    \"\"\"\n    Calculates the new index we should go to if we fail a comparison\n    :param pattern:\n    :return:\n    \"\"\"\n    failure = [0]\n    i = 0\n    j = 1\n    while j < len(pattern):\n        if pattern[i] == pattern[j]:\n            i += 1\n        elif i > 0:\n            i = failure[i - 1]\n            continue\n        j += 1\n        failure.append(i)\n    return failure\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Test 1)\n    pattern = \"abc1abc12\"\n    text1 = \"alskfjaldsabc1abc1abc12k23adsfabcabc\"\n    text2 = \"alskfjaldsk23adsfabcabc\"\n    assert knuth_morris_pratt(text1, pattern)\n    assert knuth_morris_pratt(text2, pattern)\n\n    # Test 2)\n    pattern = \"ABABX\"\n    text = \"ABABZABABYABABX\"\n    assert knuth_morris_pratt(text, pattern)\n\n    # Test 3)\n    pattern = \"AAAB\"\n    text = \"ABAAAAAB\"\n    assert knuth_morris_pratt(text, pattern)\n\n    # Test 4)\n    pattern = \"abcdabcy\"\n    text = \"abcxabcdabxabcdabcdabcy\"\n    assert knuth_morris_pratt(text, pattern)\n\n    # Test 5) -> Doctests\n    kmp = \"knuth_morris_pratt\"\n    assert all(\n        knuth_morris_pratt(kmp, s) == kmp.find(s)\n        for s in (\"kn\", \"h_m\", \"rr\", \"tt\", \"not there\")\n    )\n\n    # Test 6)\n    pattern = \"aabaabaaa\"\n    assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]\n", "strings/is_polish_national_id.py": "def is_polish_national_id(input_str: str) -> bool:\n    \"\"\"\n    Verification of the correctness of the PESEL number.\n    www-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en\n\n    PESEL can start with 0, that's why we take str as input,\n    but convert it to int for some calculations.\n\n\n    >>> is_polish_national_id(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected str as input, found <class 'int'>\n\n    >>> is_polish_national_id(\"abc\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected number as input\n\n    >>> is_polish_national_id(\"02070803628\") # correct PESEL\n    True\n\n    >>> is_polish_national_id(\"02150803629\") # wrong month\n    False\n\n    >>> is_polish_national_id(\"02075503622\") # wrong day\n    False\n\n    >>> is_polish_national_id(\"-99012212349\") # wrong range\n    False\n\n    >>> is_polish_national_id(\"990122123499999\") # wrong range\n    False\n\n    >>> is_polish_national_id(\"02070803621\") # wrong checksum\n    False\n    \"\"\"\n\n    # check for invalid input type\n    if not isinstance(input_str, str):\n        msg = f\"Expected str as input, found {type(input_str)}\"\n        raise ValueError(msg)\n\n    # check if input can be converted to int\n    try:\n        input_int = int(input_str)\n    except ValueError:\n        msg = \"Expected number as input\"\n        raise ValueError(msg)\n\n    # check number range\n    if not 10100000 <= input_int <= 99923199999:\n        return False\n\n    # check month correctness\n    month = int(input_str[2:4])\n\n    if (\n        month not in range(1, 13)  # year 1900-1999\n        and month not in range(21, 33)  # 2000-2099\n        and month not in range(41, 53)  # 2100-2199\n        and month not in range(61, 73)  # 2200-2299\n        and month not in range(81, 93)  # 1800-1899\n    ):\n        return False\n\n    # check day correctness\n    day = int(input_str[4:6])\n\n    if day not in range(1, 32):\n        return False\n\n    # check the checksum\n    multipliers = [1, 3, 7, 9, 1, 3, 7, 9, 1, 3]\n    subtotal = 0\n\n    digits_to_check = str(input_str)[:-1]  # cut off the checksum\n\n    for index, digit in enumerate(digits_to_check):\n        # Multiply corresponding digits and multipliers.\n        # In case of a double-digit result, add only the last digit.\n        subtotal += (int(digit) * multipliers[index]) % 10\n\n    checksum = 10 - subtotal % 10\n\n    return checksum == input_int % 10\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/palindrome.py": "# Algorithms to determine if a string is palindrome\n\nfrom timeit import timeit\n\ntest_data = {\n    \"MALAYALAM\": True,\n    \"String\": False,\n    \"rotor\": True,\n    \"level\": True,\n    \"A\": True,\n    \"BB\": True,\n    \"ABC\": False,\n    \"amanaplanacanalpanama\": True,  # \"a man a plan a canal panama\"\n}\n# Ensure our test data is valid\nassert all((key == key[::-1]) is value for key, value in test_data.items())\n\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n\n    start_i = 0\n    end_i = len(s) - 1\n    while start_i < end_i:\n        if s[start_i] == s[end_i]:\n            start_i += 1\n            end_i -= 1\n        else:\n            return False\n    return True\n\n\ndef is_palindrome_traversal(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_traversal(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    end = len(s) // 2\n    n = len(s)\n\n    # We need to traverse till half of the length of string\n    # as we can get access of the i'th last element from\n    # i'th index.\n    # eg: [0,1,2,3,4,5] => 4th index can be accessed\n    # with the help of 1st index (i==n-i-1)\n    # where n is length of string\n    return all(s[i] == s[n - i - 1] for i in range(end))\n\n\ndef is_palindrome_recursive(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    if len(s) <= 2:\n        return True\n    if s[0] == s[len(s) - 1]:\n        return is_palindrome_recursive(s[1:-1])\n    else:\n        return False\n\n\ndef is_palindrome_slice(s: str) -> bool:\n    \"\"\"\n    Return True if s is a palindrome otherwise return False.\n\n    >>> all(is_palindrome_slice(key) is value for key, value in test_data.items())\n    True\n    \"\"\"\n    return s == s[::-1]\n\n\ndef benchmark_function(name: str) -> None:\n    stmt = f\"all({name}(key) is value for key, value in test_data.items())\"\n    setup = f\"from __main__ import test_data, {name}\"\n    number = 500000\n    result = timeit(stmt=stmt, setup=setup, number=number)\n    print(f\"{name:<35} finished {number:,} runs in {result:.5f} seconds\")\n\n\nif __name__ == \"__main__\":\n    for key, value in test_data.items():\n        assert is_palindrome(key) is is_palindrome_recursive(key)\n        assert is_palindrome(key) is is_palindrome_slice(key)\n        print(f\"{key:21} {value}\")\n    print(\"a man a plan a canal panama\")\n\n    # finished 500,000 runs in 0.46793 seconds\n    benchmark_function(\"is_palindrome_slice\")\n    # finished 500,000 runs in 0.85234 seconds\n    benchmark_function(\"is_palindrome\")\n    # finished 500,000 runs in 1.32028 seconds\n    benchmark_function(\"is_palindrome_recursive\")\n    # finished 500,000 runs in 2.08679 seconds\n    benchmark_function(\"is_palindrome_traversal\")\n", "strings/word_patterns.py": "def get_word_pattern(word: str) -> str:\n    \"\"\"\n    Returns numerical pattern of character appearances in given word\n    >>> get_word_pattern(\"\")\n    ''\n    >>> get_word_pattern(\" \")\n    '0'\n    >>> get_word_pattern(\"pattern\")\n    '0.1.2.2.3.4.5'\n    >>> get_word_pattern(\"word pattern\")\n    '0.1.2.3.4.5.6.7.7.8.2.9'\n    >>> get_word_pattern(\"get word pattern\")\n    '0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'\n    >>> get_word_pattern()\n    Traceback (most recent call last):\n    ...\n    TypeError: get_word_pattern() missing 1 required positional argument: 'word'\n    >>> get_word_pattern(1)\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'int' object has no attribute 'upper'\n    >>> get_word_pattern(1.1)\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'float' object has no attribute 'upper'\n    >>> get_word_pattern([])\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'list' object has no attribute 'upper'\n    \"\"\"\n    word = word.upper()\n    next_num = 0\n    letter_nums = {}\n    word_pattern = []\n\n    for letter in word:\n        if letter not in letter_nums:\n            letter_nums[letter] = str(next_num)\n            next_num += 1\n        word_pattern.append(letter_nums[letter])\n    return \".\".join(word_pattern)\n\n\nif __name__ == \"__main__\":\n    import pprint\n    import time\n\n    start_time = time.time()\n    with open(\"dictionary.txt\") as in_file:\n        word_list = in_file.read().splitlines()\n\n    all_patterns: dict = {}\n    for word in word_list:\n        pattern = get_word_pattern(word)\n        if pattern in all_patterns:\n            all_patterns[pattern].append(word)\n        else:\n            all_patterns[pattern] = [word]\n\n    with open(\"word_patterns.txt\", \"w\") as out_file:\n        out_file.write(pprint.pformat(all_patterns))\n\n    total_time = round(time.time() - start_time, 2)\n    print(f\"Done!  {len(all_patterns):,} word patterns found in {total_time} seconds.\")\n    # Done!  9,581 word patterns found in 0.58 seconds.\n", "strings/levenshtein_distance.py": "from collections.abc import Callable\n\n\ndef levenshtein_distance(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Implementation of the Levenshtein distance in Python.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance(\"\", \"test\")\n    4\n    >>> levenshtein_distance(\"book\", \"back\")\n    2\n    >>> levenshtein_distance(\"book\", \"book\")\n    0\n    >>> levenshtein_distance(\"test\", \"\")\n    4\n    >>> levenshtein_distance(\"\", \"\")\n    0\n    >>> levenshtein_distance(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    # The longer word should come first\n    if len(first_word) < len(second_word):\n        return levenshtein_distance(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1]\n\n        for j, c2 in enumerate(second_word):\n            # Calculate insertions, deletions, and substitutions\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n\n            # Get the minimum to append to the current row\n            current_row.append(min(insertions, deletions, substitutions))\n\n        # Store the previous row\n        previous_row = current_row\n\n    # Returns the last element (distance)\n    return previous_row[-1]\n\n\ndef levenshtein_distance_optimized(first_word: str, second_word: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between two words (strings).\n    The function is optimized for efficiency by modifying rows in place.\n    :param first_word: the first word to measure the difference.\n    :param second_word: the second word to measure the difference.\n    :return: the Levenshtein distance between the two words.\n    Examples:\n    >>> levenshtein_distance_optimized(\"planet\", \"planetary\")\n    3\n    >>> levenshtein_distance_optimized(\"\", \"test\")\n    4\n    >>> levenshtein_distance_optimized(\"book\", \"back\")\n    2\n    >>> levenshtein_distance_optimized(\"book\", \"book\")\n    0\n    >>> levenshtein_distance_optimized(\"test\", \"\")\n    4\n    >>> levenshtein_distance_optimized(\"\", \"\")\n    0\n    >>> levenshtein_distance_optimized(\"orchestration\", \"container\")\n    10\n    \"\"\"\n    if len(first_word) < len(second_word):\n        return levenshtein_distance_optimized(second_word, first_word)\n\n    if len(second_word) == 0:\n        return len(first_word)\n\n    previous_row = list(range(len(second_word) + 1))\n\n    for i, c1 in enumerate(first_word):\n        current_row = [i + 1] + [0] * len(second_word)\n\n        for j, c2 in enumerate(second_word):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row[j + 1] = min(insertions, deletions, substitutions)\n\n        previous_row = current_row\n\n    return previous_row[-1]\n\n\ndef benchmark_levenshtein_distance(func: Callable) -> None:\n    \"\"\"\n    Benchmark the Levenshtein distance function.\n    :param str: The name of the function being benchmarked.\n    :param func: The function to be benchmarked.\n    \"\"\"\n    from timeit import timeit\n\n    stmt = f\"{func.__name__}('sitting', 'kitten')\"\n    setup = f\"from __main__ import {func.__name__}\"\n    number = 25_000\n    result = timeit(stmt=stmt, setup=setup, number=number)\n    print(f\"{func.__name__:<30} finished {number:,} runs in {result:.5f} seconds\")\n\n\nif __name__ == \"__main__\":\n    # Get user input for words\n    first_word = input(\"Enter the first word for Levenshtein distance:\\n\").strip()\n    second_word = input(\"Enter the second word for Levenshtein distance:\\n\").strip()\n\n    # Calculate and print Levenshtein distances\n    print(f\"{levenshtein_distance(first_word, second_word) = }\")\n    print(f\"{levenshtein_distance_optimized(first_word, second_word) = }\")\n\n    # Benchmark the Levenshtein distance functions\n    benchmark_levenshtein_distance(levenshtein_distance)\n    benchmark_levenshtein_distance(levenshtein_distance_optimized)\n", "strings/word_occurrence.py": "# Created by sarathkaul on 17/11/19\n# Modified by Arkadip Bhattacharya(@darkmatter18) on 20/04/2020\nfrom collections import defaultdict\n\n\ndef word_occurrence(sentence: str) -> dict:\n    \"\"\"\n    >>> from collections import Counter\n    >>> SENTENCE = \"a b A b c b d b d e f e g e h e i e j e 0\"\n    >>> occurence_dict = word_occurrence(SENTENCE)\n    >>> all(occurence_dict[word] == count for word, count\n    ...     in Counter(SENTENCE.split()).items())\n    True\n    >>> dict(word_occurrence(\"Two  spaces\"))\n    {'Two': 1, 'spaces': 1}\n    \"\"\"\n    occurrence: defaultdict[str, int] = defaultdict(int)\n    # Creating a dictionary containing count of each word\n    for word in sentence.split():\n        occurrence[word] += 1\n    return occurrence\n\n\nif __name__ == \"__main__\":\n    for word, count in word_occurrence(\"INPUT STRING\").items():\n        print(f\"{word}: {count}\")\n", "strings/dna.py": "import re\n\n\ndef dna(dna: str) -> str:\n    \"\"\"\n    https://en.wikipedia.org/wiki/DNA\n    Returns the second side of a DNA strand\n\n    >>> dna(\"GCTA\")\n    'CGAT'\n    >>> dna(\"ATGC\")\n    'TACG'\n    >>> dna(\"CTGA\")\n    'GACT'\n    >>> dna(\"GFGG\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid Strand\n    \"\"\"\n\n    if len(re.findall(\"[ATCG]\", dna)) != len(dna):\n        raise ValueError(\"Invalid Strand\")\n\n    return dna.translate(dna.maketrans(\"ATCG\", \"TAGC\"))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/strip.py": "def strip(user_string: str, characters: str = \" \\t\\n\\r\") -> str:\n    \"\"\"\n    Remove leading and trailing characters (whitespace by default) from a string.\n\n    Args:\n        user_string (str): The input string to be stripped.\n        characters (str, optional): Optional characters to be removed\n                (default is whitespace).\n\n    Returns:\n        str: The stripped string.\n\n    Examples:\n        >>> strip(\"   hello   \")\n        'hello'\n        >>> strip(\"...world...\", \".\")\n        'world'\n        >>> strip(\"123hello123\", \"123\")\n        'hello'\n        >>> strip(\"\")\n        ''\n    \"\"\"\n\n    start = 0\n    end = len(user_string)\n\n    while start < end and user_string[start] in characters:\n        start += 1\n\n    while end > start and user_string[end - 1] in characters:\n        end -= 1\n\n    return user_string[start:end]\n", "strings/is_contains_unique_chars.py": "def is_contains_unique_chars(input_str: str) -> bool:\n    \"\"\"\n    Check if all characters in the string is unique or not.\n    >>> is_contains_unique_chars(\"I_love.py\")\n    True\n    >>> is_contains_unique_chars(\"I don't love Python\")\n    False\n\n    Time complexity: O(n)\n    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode\n    \"\"\"\n\n    # Each bit will represent each unicode character\n    # For example 65th bit representing 'A'\n    # https://stackoverflow.com/a/12811293\n    bitmap = 0\n    for ch in input_str:\n        ch_unicode = ord(ch)\n        ch_bit_index_on = pow(2, ch_unicode)\n\n        # If we already turned on bit for current character's unicode\n        if bitmap >> ch_unicode & 1 == 1:\n            return False\n        bitmap |= ch_bit_index_on\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/reverse_letters.py": "def reverse_letters(sentence: str, length: int = 0) -> str:\n    \"\"\"\n    Reverse all words that are longer than the given length of characters in a sentence.\n    If unspecified, length is taken as 0\n\n    >>> reverse_letters(\"Hey wollef sroirraw\", 3)\n    'Hey fellow warriors'\n    >>> reverse_letters(\"nohtyP is nohtyP\", 2)\n    'Python is Python'\n    >>> reverse_letters(\"1 12 123 1234 54321 654321\", 0)\n    '1 21 321 4321 12345 123456'\n    >>> reverse_letters(\"racecar\")\n    'racecar'\n    \"\"\"\n    return \" \".join(\n        \"\".join(word[::-1]) if len(word) > length else word for word in sentence.split()\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(reverse_letters(\"Hey wollef sroirraw\"))\n", "strings/wildcard_pattern_matching.py": "\"\"\"\nImplementation of regular expression matching with support for '.' and '*'.\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\n\"\"\"\n\n\ndef match_pattern(input_string: str, pattern: str) -> bool:\n    \"\"\"\n    uses bottom-up dynamic programming solution for matching the input\n    string with a given pattern.\n\n    Runtime: O(len(input_string)*len(pattern))\n\n    Arguments\n    --------\n    input_string: str, any string which should be compared with the pattern\n    pattern: str, the string that represents a pattern and may contain\n    '.' for single character matches and '*' for zero or more of preceding character\n    matches\n\n    Note\n    ----\n    the pattern cannot start with a '*',\n    because there should be at least one character before *\n\n    Returns\n    -------\n    A Boolean denoting whether the given string follows the pattern\n\n    Examples\n    -------\n    >>> match_pattern(\"aab\", \"c*a*b\")\n    True\n    >>> match_pattern(\"dabc\", \"*abc\")\n    False\n    >>> match_pattern(\"aaa\", \"aa\")\n    False\n    >>> match_pattern(\"aaa\", \"a.a\")\n    True\n    >>> match_pattern(\"aaab\", \"aa*\")\n    False\n    >>> match_pattern(\"aaab\", \".*\")\n    True\n    >>> match_pattern(\"a\", \"bbbb\")\n    False\n    >>> match_pattern(\"\", \"bbbb\")\n    False\n    >>> match_pattern(\"a\", \"\")\n    False\n    >>> match_pattern(\"\", \"\")\n    True\n    \"\"\"\n\n    len_string = len(input_string) + 1\n    len_pattern = len(pattern) + 1\n\n    # dp is a 2d matrix where dp[i][j] denotes whether prefix string of\n    # length i of input_string matches with prefix string of length j of\n    # given pattern.\n    # \"dp\" stands for dynamic programming.\n    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]\n\n    # since string of zero length match pattern of zero length\n    dp[0][0] = 1\n\n    # since pattern of zero length will never match with string of non-zero length\n    for i in range(1, len_string):\n        dp[i][0] = 0\n\n    # since string of zero length will match with pattern where there\n    # is at least one * alternatively\n    for j in range(1, len_pattern):\n        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == \"*\" else 0\n\n    # now using bottom-up approach to find for all remaining lengths\n    for i in range(1, len_string):\n        for j in range(1, len_pattern):\n            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == \".\":\n                dp[i][j] = dp[i - 1][j - 1]\n\n            elif pattern[j - 1] == \"*\":\n                if dp[i][j - 2] == 1:\n                    dp[i][j] = 1\n                elif pattern[j - 2] in (input_string[i - 1], \".\"):\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n\n    return bool(dp[-1][-1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    # inputing the strings\n    # input_string = input(\"input a string :\")\n    # pattern = input(\"input a pattern :\")\n\n    input_string = \"aab\"\n    pattern = \"c*a*b\"\n\n    # using function to check whether given string matches the given pattern\n    if match_pattern(input_string, pattern):\n        print(f\"{input_string} matches the given pattern {pattern}\")\n    else:\n        print(f\"{input_string} does not match with the given pattern {pattern}\")\n", "strings/detecting_english_programmatically.py": "import os\nfrom string import ascii_letters\n\nLETTERS_AND_SPACE = ascii_letters + \" \\t\\n\"\n\n\ndef load_dictionary() -> dict[str, None]:\n    path = os.path.split(os.path.realpath(__file__))\n    english_words: dict[str, None] = {}\n    with open(path[0] + \"/dictionary.txt\") as dictionary_file:\n        for word in dictionary_file.read().split(\"\\n\"):\n            english_words[word] = None\n    return english_words\n\n\nENGLISH_WORDS = load_dictionary()\n\n\ndef get_english_count(message: str) -> float:\n    message = message.upper()\n    message = remove_non_letters(message)\n    possible_words = message.split()\n    matches = len([word for word in possible_words if word in ENGLISH_WORDS])\n    return float(matches) / len(possible_words)\n\n\ndef remove_non_letters(message: str) -> str:\n    \"\"\"\n    >>> remove_non_letters(\"Hi! how are you?\")\n    'Hi how are you'\n    >>> remove_non_letters(\"P^y%t)h@o*n\")\n    'Python'\n    >>> remove_non_letters(\"1+1=2\")\n    ''\n    >>> remove_non_letters(\"www.google.com/\")\n    'wwwgooglecom'\n    >>> remove_non_letters(\"\")\n    ''\n    \"\"\"\n    return \"\".join(symbol for symbol in message if symbol in LETTERS_AND_SPACE)\n\n\ndef is_english(\n    message: str, word_percentage: int = 20, letter_percentage: int = 85\n) -> bool:\n    \"\"\"\n    >>> is_english('Hello World')\n    True\n    >>> is_english('llold HorWd')\n    False\n    \"\"\"\n    words_match = get_english_count(message) * 100 >= word_percentage\n    num_letters = len(remove_non_letters(message))\n    message_letters_percentage = (float(num_letters) / len(message)) * 100\n    letters_match = message_letters_percentage >= letter_percentage\n    return words_match and letters_match\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/manacher.py": "def palindromic_string(input_string: str) -> str:\n    \"\"\"\n    >>> palindromic_string('abbbaba')\n    'abbba'\n    >>> palindromic_string('ababa')\n    'ababa'\n\n    Manacher's algorithm which finds Longest palindromic Substring in linear time.\n\n    1. first this convert input_string(\"xyx\") into new_string(\"x|y|x\") where odd\n        positions are actual input characters.\n    2. for each character in new_string it find corresponding length and\n        store the length and left,right to store previously calculated info.\n        (please look the explanation for details)\n\n    3. return corresponding output_string by removing all \"|\"\n    \"\"\"\n    max_length = 0\n\n    # if input_string is \"aba\" than new_input_string become \"a|b|a\"\n    new_input_string = \"\"\n    output_string = \"\"\n\n    # append each character + \"|\" in new_string for range(0, length-1)\n    for i in input_string[: len(input_string) - 1]:\n        new_input_string += i + \"|\"\n    # append last character\n    new_input_string += input_string[-1]\n\n    # we will store the starting and ending of previous furthest ending palindromic\n    # substring\n    left, right = 0, 0\n\n    # length[i] shows the length of palindromic substring with center i\n    length = [1 for i in range(len(new_input_string))]\n\n    # for each character in new_string find corresponding palindromic string\n    start = 0\n    for j in range(len(new_input_string)):\n        k = 1 if j > right else min(length[left + right - j] // 2, right - j + 1)\n        while (\n            j - k >= 0\n            and j + k < len(new_input_string)\n            and new_input_string[k + j] == new_input_string[j - k]\n        ):\n            k += 1\n\n        length[j] = 2 * k - 1\n\n        # does this string is ending after the previously explored end (that is right) ?\n        # if yes the update the new right to the last index of this\n        if j + k - 1 > right:\n            left = j - k + 1\n            right = j + k - 1\n\n        # update max_length and start position\n        if max_length < length[j]:\n            max_length = length[j]\n            start = j\n\n    # create that string\n    s = new_input_string[start - max_length // 2 : start + max_length // 2 + 1]\n    for i in s:\n        if i != \"|\":\n            output_string += i\n\n    return output_string\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n\"\"\"\n...a0...a1...a2.....a3......a4...a5...a6....\n\nconsider the string for which we are calculating the longest palindromic substring is\nshown above where ... are some characters in between and right now we are calculating\nthe length of palindromic substring with center at a5 with following conditions :\ni) we have stored the length of palindromic substring which has center at a3\n    (starts at left ends at right) and it is the furthest ending till now,\n    and it has ending after a6\nii) a2 and a4 are equally distant from a3 so char(a2) == char(a4)\niii) a0 and a6 are equally distant from a3 so char(a0) == char(a6)\niv) a1 is corresponding equal character of a5 in palindrome with center a3 (remember\n    that in below derivation of a4==a6)\n\nnow for a5 we will calculate the length of palindromic substring with center as a5 but\ncan we use previously calculated information in some way?\nYes, look the above string we know that a5 is inside the palindrome with center a3 and\npreviously we have calculated that\na0==a2 (palindrome of center a1)\na2==a4 (palindrome of center a3)\na0==a6 (palindrome of center a3)\nso a4==a6\n\nso we can say that palindrome at center a5 is at least as long as palindrome at center\na1 but this only holds if a0 and a6 are inside the limits of palindrome centered at a3\nso finally ..\n\nlen_of_palindrome__at(a5) = min(len_of_palindrome_at(a1), right-a5)\nwhere a3 lies from left to right and we have to keep updating that\n\nand if the a5 lies outside of left,right boundary we calculate length of palindrome with\nbruteforce and update left,right.\n\nit gives the linear time complexity just like z-function\n\"\"\"\n", "strings/ngram.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/N-gram\n\"\"\"\n\n\ndef create_ngram(sentence: str, ngram_size: int) -> list[str]:\n    \"\"\"\n    Create ngrams from a sentence\n\n    >>> create_ngram(\"I am a sentence\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']\n    >>> create_ngram(\"I am an NLPer\", 2)\n    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']\n    >>> create_ngram(\"This is short\", 50)\n    []\n    \"\"\"\n    return [sentence[i : i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/alternative_string_arrange.py": "def alternative_string_arrange(first_str: str, second_str: str) -> str:\n    \"\"\"\n    Return the alternative arrangements of the two strings.\n    :param first_str:\n    :param second_str:\n    :return: String\n    >>> alternative_string_arrange(\"ABCD\", \"XY\")\n    'AXBYCD'\n    >>> alternative_string_arrange(\"XY\", \"ABCD\")\n    'XAYBCD'\n    >>> alternative_string_arrange(\"AB\", \"XYZ\")\n    'AXBYZ'\n    >>> alternative_string_arrange(\"ABC\", \"\")\n    'ABC'\n    \"\"\"\n    first_str_length: int = len(first_str)\n    second_str_length: int = len(second_str)\n    abs_length: int = (\n        first_str_length if first_str_length > second_str_length else second_str_length\n    )\n    output_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_str_length:\n            output_list.append(first_str[char_count])\n        if char_count < second_str_length:\n            output_list.append(second_str[char_count])\n    return \"\".join(output_list)\n\n\nif __name__ == \"__main__\":\n    print(alternative_string_arrange(\"AB\", \"XYZ\"), end=\" \")\n", "strings/top_k_frequent_words.py": "\"\"\"\nFinds the top K most frequent words from the provided word list.\n\nThis implementation aims to show how to solve the problem using the Heap class\nalready present in this repository.\nComputing order statistics is, in fact, a typical usage of heaps.\n\nThis is mostly shown for educational purposes, since the problem can be solved\nin a few lines using collections.Counter from the Python standard library:\n\nfrom collections import Counter\ndef top_k_frequent_words(words, k_value):\n    return [x[0] for x in Counter(words).most_common(k_value)]\n\"\"\"\n\nfrom collections import Counter\nfrom functools import total_ordering\n\nfrom data_structures.heap.heap import Heap\n\n\n@total_ordering\nclass WordCount:\n    def __init__(self, word: str, count: int) -> None:\n        self.word = word\n        self.count = count\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        >>> WordCount('a', 1).__eq__(WordCount('b', 1))\n        True\n        >>> WordCount('a', 1).__eq__(WordCount('a', 1))\n        True\n        >>> WordCount('a', 1).__eq__(WordCount('a', 2))\n        False\n        >>> WordCount('a', 1).__eq__(WordCount('b', 2))\n        False\n        >>> WordCount('a', 1).__eq__(1)\n        NotImplemented\n        \"\"\"\n        if not isinstance(other, WordCount):\n            return NotImplemented\n        return self.count == other.count\n\n    def __lt__(self, other: object) -> bool:\n        \"\"\"\n        >>> WordCount('a', 1).__lt__(WordCount('b', 1))\n        False\n        >>> WordCount('a', 1).__lt__(WordCount('a', 1))\n        False\n        >>> WordCount('a', 1).__lt__(WordCount('a', 2))\n        True\n        >>> WordCount('a', 1).__lt__(WordCount('b', 2))\n        True\n        >>> WordCount('a', 2).__lt__(WordCount('a', 1))\n        False\n        >>> WordCount('a', 2).__lt__(WordCount('b', 1))\n        False\n        >>> WordCount('a', 1).__lt__(1)\n        NotImplemented\n        \"\"\"\n        if not isinstance(other, WordCount):\n            return NotImplemented\n        return self.count < other.count\n\n\ndef top_k_frequent_words(words: list[str], k_value: int) -> list[str]:\n    \"\"\"\n    Returns the `k_value` most frequently occurring words,\n    in non-increasing order of occurrence.\n    In this context, a word is defined as an element in the provided list.\n\n    In case `k_value` is greater than the number of distinct words, a value of k equal\n    to the number of distinct words will be considered, instead.\n\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)\n    ['c', 'a', 'b']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)\n    ['c', 'a']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)\n    ['c']\n    >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)\n    []\n    >>> top_k_frequent_words([], 1)\n    []\n    >>> top_k_frequent_words(['a', 'a'], 2)\n    ['a']\n    \"\"\"\n    heap: Heap[WordCount] = Heap()\n    count_by_word = Counter(words)\n    heap.build_max_heap(\n        [WordCount(word, count) for word, count in count_by_word.items()]\n    )\n    return [heap.extract_max().word for _ in range(min(k_value, len(count_by_word)))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/frequency_finder.py": "# Frequency Finder\n\nimport string\n\n# frequency taken from https://en.wikipedia.org/wiki/Letter_frequency\nenglish_letter_freq = {\n    \"E\": 12.70,\n    \"T\": 9.06,\n    \"A\": 8.17,\n    \"O\": 7.51,\n    \"I\": 6.97,\n    \"N\": 6.75,\n    \"S\": 6.33,\n    \"H\": 6.09,\n    \"R\": 5.99,\n    \"D\": 4.25,\n    \"L\": 4.03,\n    \"C\": 2.78,\n    \"U\": 2.76,\n    \"M\": 2.41,\n    \"W\": 2.36,\n    \"F\": 2.23,\n    \"G\": 2.02,\n    \"Y\": 1.97,\n    \"P\": 1.93,\n    \"B\": 1.29,\n    \"V\": 0.98,\n    \"K\": 0.77,\n    \"J\": 0.15,\n    \"X\": 0.15,\n    \"Q\": 0.10,\n    \"Z\": 0.07,\n}\nETAOIN = \"ETAOINSHRDLCUMWFGYPBVKJXQZ\"\nLETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef get_letter_count(message: str) -> dict[str, int]:\n    letter_count = {letter: 0 for letter in string.ascii_uppercase}\n    for letter in message.upper():\n        if letter in LETTERS:\n            letter_count[letter] += 1\n\n    return letter_count\n\n\ndef get_item_at_index_zero(x: tuple) -> str:\n    return x[0]\n\n\ndef get_frequency_order(message: str) -> str:\n    \"\"\"\n    Get the frequency order of the letters in the given string\n    >>> get_frequency_order('Hello World')\n    'LOWDRHEZQXJKVBPYGFMUCSNIAT'\n    >>> get_frequency_order('Hello@')\n    'LHOEZQXJKVBPYGFWMUCDRSNIAT'\n    >>> get_frequency_order('h')\n    'HZQXJKVBPYGFWMUCLDRSNIOATE'\n    \"\"\"\n    letter_to_freq = get_letter_count(message)\n    freq_to_letter: dict[int, list[str]] = {\n        freq: [] for letter, freq in letter_to_freq.items()\n    }\n    for letter in LETTERS:\n        freq_to_letter[letter_to_freq[letter]].append(letter)\n\n    freq_to_letter_str: dict[int, str] = {}\n\n    for freq in freq_to_letter:\n        freq_to_letter[freq].sort(key=ETAOIN.find, reverse=True)\n        freq_to_letter_str[freq] = \"\".join(freq_to_letter[freq])\n\n    freq_pairs = list(freq_to_letter_str.items())\n    freq_pairs.sort(key=get_item_at_index_zero, reverse=True)\n\n    freq_order: list[str] = [freq_pair[1] for freq_pair in freq_pairs]\n\n    return \"\".join(freq_order)\n\n\ndef english_freq_match_score(message: str) -> int:\n    \"\"\"\n    >>> english_freq_match_score('Hello World')\n    1\n    \"\"\"\n    freq_order = get_frequency_order(message)\n    match_score = 0\n    for common_letter in ETAOIN[:6]:\n        if common_letter in freq_order[:6]:\n            match_score += 1\n\n    for uncommon_letter in ETAOIN[-6:]:\n        if uncommon_letter in freq_order[-6:]:\n            match_score += 1\n\n    return match_score\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/reverse_words.py": "def reverse_words(input_str: str) -> str:\n    \"\"\"\n    Reverses words in a given string\n    >>> reverse_words(\"I love Python\")\n    'Python love I'\n    >>> reverse_words(\"I     Love          Python\")\n    'Python Love I'\n    \"\"\"\n    return \" \".join(input_str.split()[::-1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/join.py": "\"\"\"\nProgram to join a list of strings with a separator\n\"\"\"\n\n\ndef join(separator: str, separated: list[str]) -> str:\n    \"\"\"\n    Joins a list of strings using a separator\n    and returns the result.\n\n    :param separator: Separator to be used\n                for joining the strings.\n    :param separated: List of strings to be joined.\n\n    :return: Joined string with the specified separator.\n\n    Examples:\n\n    >>> join(\"\", [\"a\", \"b\", \"c\", \"d\"])\n    'abcd'\n    >>> join(\"#\", [\"a\", \"b\", \"c\", \"d\"])\n    'a#b#c#d'\n    >>> join(\"#\", \"a\")\n    'a'\n    >>> join(\" \", [\"You\", \"are\", \"amazing!\"])\n    'You are amazing!'\n\n    This example should raise an\n    exception for non-string elements:\n    >>> join(\"#\", [\"a\", \"b\", \"c\", 1])\n    Traceback (most recent call last):\n        ...\n    Exception: join() accepts only strings\n\n    Additional test case with a different separator:\n    >>> join(\"-\", [\"apple\", \"banana\", \"cherry\"])\n    'apple-banana-cherry'\n    \"\"\"\n\n    joined = \"\"\n    for word_or_phrase in separated:\n        if not isinstance(word_or_phrase, str):\n            raise Exception(\"join() accepts only strings\")\n        joined += word_or_phrase + separator\n\n    # Remove the trailing separator\n    # by stripping it from the result\n    return joined.strip(separator)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/bitap_string_match.py": "\"\"\"\nBitap exact string matching\nhttps://en.wikipedia.org/wiki/Bitap_algorithm\n\nSearches for a pattern inside text, and returns the index of the first occurrence\nof the pattern. Both text and pattern consist of lowercase alphabetical characters only.\n\nComplexity: O(m*n)\n    n = length of text\n    m = length of pattern\n\nPython doctests can be run using this command:\npython3 -m doctest -v bitap_string_match.py\n\"\"\"\n\n\ndef bitap_string_match(text: str, pattern: str) -> int:\n    \"\"\"\n    Retrieves the index of the first occurrence of pattern in text.\n\n    Args:\n        text: A string consisting only of lowercase alphabetical characters.\n        pattern: A string consisting only of lowercase alphabetical characters.\n\n    Returns:\n        int: The index where pattern first occurs. Return -1  if not found.\n\n    >>> bitap_string_match('abdabababc', 'ababc')\n    5\n    >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')\n    0\n    >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')\n    0\n    >>> bitap_string_match('abdabababc', '')\n    0\n    >>> bitap_string_match('abdabababc', 'c')\n    9\n    >>> bitap_string_match('abdabababc', 'fofosdfo')\n    -1\n    >>> bitap_string_match('abdab', 'fofosdfo')\n    -1\n    \"\"\"\n    if not pattern:\n        return 0\n    m = len(pattern)\n    if m > len(text):\n        return -1\n\n    # Initial state of bit string 1110\n    state = ~1\n    # Bit = 0 if character appears at index, and 1 otherwise\n    pattern_mask: list[int] = [~0] * 27  # 1111\n\n    for i, char in enumerate(pattern):\n        # For the pattern mask for this character, set the bit to 0 for each i\n        # the character appears.\n        pattern_index: int = ord(char) - ord(\"a\")\n        pattern_mask[pattern_index] &= ~(1 << i)\n\n    for i, char in enumerate(text):\n        text_index = ord(char) - ord(\"a\")\n        # If this character does not appear in pattern, it's pattern mask is 1111.\n        # Performing a bitwise OR between state and 1111 will reset the state to 1111\n        # and start searching the start of pattern again.\n        state |= pattern_mask[text_index]\n        state <<= 1\n\n        # If the mth bit (counting right to left) of the state is 0, then we have\n        # found pattern in text\n        if (state & (1 << m)) == 0:\n            return i - m + 1\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/credit_card_validator.py": "\"\"\"\nFunctions for testing the validity of credit card numbers.\n\nhttps://en.wikipedia.org/wiki/Luhn_algorithm\n\"\"\"\n\n\ndef validate_initial_digits(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate initial digits of a given credit card number.\n    >>> valid = \"4111111111111111 41111111111111 34 35 37 412345 523456 634567\"\n    >>> all(validate_initial_digits(cc) for cc in valid.split())\n    True\n    >>> invalid = \"14 25 76 32323 36111111111111\"\n    >>> all(validate_initial_digits(cc) is False for cc in invalid.split())\n    True\n    \"\"\"\n    return credit_card_number.startswith((\"34\", \"35\", \"37\", \"4\", \"5\", \"6\"))\n\n\ndef luhn_validation(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to luhn algorithm validation for a given credit card number.\n    >>> luhn_validation('4111111111111111')\n    True\n    >>> luhn_validation('36111111111111')\n    True\n    >>> luhn_validation('41111111111111')\n    False\n    \"\"\"\n    cc_number = credit_card_number\n    total = 0\n    half_len = len(cc_number) - 2\n    for i in range(half_len, -1, -2):\n        #  double the value of every second digit\n        digit = int(cc_number[i])\n        digit *= 2\n        # If doubling of a number results in a two digit number\n        # i.e greater than 9(e.g., 6 x 2 = 12),\n        # then add the digits of the product (e.g., 12: 1 + 2 = 3, 15: 1 + 5 = 6),\n        # to get a single digit number.\n        if digit > 9:\n            digit %= 10\n            digit += 1\n        cc_number = cc_number[:i] + str(digit) + cc_number[i + 1 :]\n        total += digit\n\n    # Sum up the remaining digits\n    for i in range(len(cc_number) - 1, -1, -2):\n        total += int(cc_number[i])\n\n    return total % 10 == 0\n\n\ndef validate_credit_card_number(credit_card_number: str) -> bool:\n    \"\"\"\n    Function to validate the given credit card number.\n    >>> validate_credit_card_number('4111111111111111')\n    4111111111111111 is a valid credit card number.\n    True\n    >>> validate_credit_card_number('helloworld$')\n    helloworld$ is an invalid credit card number because it has nonnumerical characters.\n    False\n    >>> validate_credit_card_number('32323')\n    32323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('32323323233232332323')\n    32323323233232332323 is an invalid credit card number because of its length.\n    False\n    >>> validate_credit_card_number('36111111111111')\n    36111111111111 is an invalid credit card number because of its first two digits.\n    False\n    >>> validate_credit_card_number('41111111111111')\n    41111111111111 is an invalid credit card number because it fails the Luhn check.\n    False\n    \"\"\"\n    error_message = f\"{credit_card_number} is an invalid credit card number because\"\n    if not credit_card_number.isdigit():\n        print(f\"{error_message} it has nonnumerical characters.\")\n        return False\n\n    if not 13 <= len(credit_card_number) <= 16:\n        print(f\"{error_message} of its length.\")\n        return False\n\n    if not validate_initial_digits(credit_card_number):\n        print(f\"{error_message} of its first two digits.\")\n        return False\n\n    if not luhn_validation(credit_card_number):\n        print(f\"{error_message} it fails the Luhn check.\")\n        return False\n\n    print(f\"{credit_card_number} is a valid credit card number.\")\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    validate_credit_card_number(\"4111111111111111\")\n    validate_credit_card_number(\"32323\")\n", "strings/snake_case_to_camel_pascal_case.py": "def snake_to_camel_case(input_str: str, use_pascal: bool = False) -> str:\n    \"\"\"\n    Transforms a snake_case given string to camelCase (or PascalCase if indicated)\n    (defaults to not use Pascal)\n\n    >>> snake_to_camel_case(\"some_random_string\")\n    'someRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string\", use_pascal=True)\n    'SomeRandomString'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\")\n    'someRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(\"some_random_string_with_numbers_123\", use_pascal=True)\n    'SomeRandomStringWithNumbers123'\n\n    >>> snake_to_camel_case(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected string as input, found <class 'int'>\n\n    >>> snake_to_camel_case(\"some_string\", use_pascal=\"True\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected boolean as use_pascal parameter, found <class 'str'>\n    \"\"\"\n\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n    if not isinstance(use_pascal, bool):\n        msg = f\"Expected boolean as use_pascal parameter, found {type(use_pascal)}\"\n        raise ValueError(msg)\n\n    words = input_str.split(\"_\")\n\n    start_index = 0 if use_pascal else 1\n\n    words_to_capitalize = words[start_index:]\n\n    capitalized_words = [word[0].upper() + word[1:] for word in words_to_capitalize]\n\n    initial_word = \"\" if use_pascal else words[0]\n\n    return \"\".join([initial_word, *capitalized_words])\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/barcode_validator.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Check_digit#Algorithms\n\"\"\"\n\n\ndef get_check_digit(barcode: int) -> int:\n    \"\"\"\n    Returns the last digit of barcode by excluding the last digit first\n    and then computing to reach the actual last digit from the remaining\n    12 digits.\n\n    >>> get_check_digit(8718452538119)\n    9\n    >>> get_check_digit(87184523)\n    5\n    >>> get_check_digit(87193425381086)\n    9\n    >>> [get_check_digit(x) for x in range(0, 100, 10)]\n    [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]\n    \"\"\"\n    barcode //= 10  # exclude the last digit\n    checker = False\n    s = 0\n\n    # extract and check each digit\n    while barcode != 0:\n        mult = 1 if checker else 3\n        s += mult * (barcode % 10)\n        barcode //= 10\n        checker = not checker\n\n    return (10 - (s % 10)) % 10\n\n\ndef is_valid(barcode: int) -> bool:\n    \"\"\"\n    Checks for length of barcode and last-digit\n    Returns boolean value of validity of barcode\n\n    >>> is_valid(8718452538119)\n    True\n    >>> is_valid(87184525)\n    False\n    >>> is_valid(87193425381089)\n    False\n    >>> is_valid(0)\n    False\n    >>> is_valid(dwefgiweuf)\n    Traceback (most recent call last):\n        ...\n    NameError: name 'dwefgiweuf' is not defined\n    \"\"\"\n    return len(str(barcode)) == 13 and get_check_digit(barcode) == barcode % 10\n\n\ndef get_barcode(barcode: str) -> int:\n    \"\"\"\n    Returns the barcode as an integer\n\n    >>> get_barcode(\"8718452538119\")\n    8718452538119\n    >>> get_barcode(\"dwefgiweuf\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Barcode 'dwefgiweuf' has alphabetic characters.\n    \"\"\"\n    if str(barcode).isalpha():\n        msg = f\"Barcode '{barcode}' has alphabetic characters.\"\n        raise ValueError(msg)\n    elif int(barcode) < 0:\n        raise ValueError(\"The entered barcode has a negative value. Try again.\")\n    else:\n        return int(barcode)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    \"\"\"\n    Enter a barcode.\n\n    \"\"\"\n    barcode = get_barcode(input(\"Barcode: \").strip())\n\n    if is_valid(barcode):\n        print(f\"'{barcode}' is a valid barcode.\")\n    else:\n        print(f\"'{barcode}' is NOT a valid barcode.\")\n", "strings/is_isogram.py": "\"\"\"\nwiki: https://en.wikipedia.org/wiki/Heterogram_(literature)#Isograms\n\"\"\"\n\n\ndef is_isogram(string: str) -> bool:\n    \"\"\"\n    An isogram is a word in which no letter is repeated.\n    Examples of isograms are uncopyrightable and ambidextrously.\n    >>> is_isogram('Uncopyrightable')\n    True\n    >>> is_isogram('allowance')\n    False\n    >>> is_isogram('copy1')\n    Traceback (most recent call last):\n     ...\n    ValueError: String must only contain alphabetic characters.\n    \"\"\"\n    if not all(x.isalpha() for x in string):\n        raise ValueError(\"String must only contain alphabetic characters.\")\n\n    letters = sorted(string.lower())\n    return len(letters) == len(set(letters))\n\n\nif __name__ == \"__main__\":\n    input_str = input(\"Enter a string \").strip()\n\n    isogram = is_isogram(input_str)\n    print(f\"{input_str} is {'an' if isogram else 'not an'} isogram.\")\n", "strings/autocomplete_using_trie.py": "from __future__ import annotations\n\nEND = \"#\"\n\n\nclass Trie:\n    def __init__(self) -> None:\n        self._trie: dict = {}\n\n    def insert_word(self, text: str) -> None:\n        trie = self._trie\n        for char in text:\n            if char not in trie:\n                trie[char] = {}\n            trie = trie[char]\n        trie[END] = True\n\n    def find_word(self, prefix: str) -> tuple | list:\n        trie = self._trie\n        for char in prefix:\n            if char in trie:\n                trie = trie[char]\n            else:\n                return []\n        return self._elements(trie)\n\n    def _elements(self, d: dict) -> tuple:\n        result = []\n        for c, v in d.items():\n            sub_result = [\" \"] if c == END else [(c + s) for s in self._elements(v)]\n            result.extend(sub_result)\n        return tuple(result)\n\n\ntrie = Trie()\nwords = (\"depart\", \"detergent\", \"daring\", \"dog\", \"deer\", \"deal\")\nfor word in words:\n    trie.insert_word(word)\n\n\ndef autocomplete_using_trie(string: str) -> tuple:\n    \"\"\"\n    >>> trie = Trie()\n    >>> for word in words:\n    ...     trie.insert_word(word)\n    ...\n    >>> matches = autocomplete_using_trie(\"de\")\n    >>> \"detergent \" in matches\n    True\n    >>> \"dog \" in matches\n    False\n    \"\"\"\n    suffixes = trie.find_word(string)\n    return tuple(string + word for word in suffixes)\n\n\ndef main() -> None:\n    print(autocomplete_using_trie(\"de\"))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()\n", "strings/z_function.py": "\"\"\"\nhttps://cp-algorithms.com/string/z-function.html\n\nZ-function or Z algorithm\n\nEfficient algorithm for pattern occurrence in a string\n\nTime Complexity: O(n) - where n is the length of the string\n\n\"\"\"\n\n\ndef z_function(input_str: str) -> list[int]:\n    \"\"\"\n    For the given string this function computes value for each index,\n    which represents the maximal length substring starting from the index\n    and is the same as the prefix of the same size\n\n    e.x.  for string 'abab' for second index value would be 2\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> z_function(\"abracadabra\")\n    [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]\n    >>> z_function(\"aaaa\")\n    [0, 3, 2, 1]\n    >>> z_function(\"zxxzxxz\")\n    [0, 0, 0, 4, 0, 0, 1]\n    \"\"\"\n    z_result = [0 for i in range(len(input_str))]\n\n    # initialize interval's left pointer and right pointer\n    left_pointer, right_pointer = 0, 0\n\n    for i in range(1, len(input_str)):\n        # case when current index is inside the interval\n        if i <= right_pointer:\n            min_edge = min(right_pointer - i + 1, z_result[i - left_pointer])\n            z_result[i] = min_edge\n\n        while go_next(i, z_result, input_str):\n            z_result[i] += 1\n\n        # if new index's result gives us more right interval,\n        # we've to update left_pointer and right_pointer\n        if i + z_result[i] - 1 > right_pointer:\n            left_pointer, right_pointer = i, i + z_result[i] - 1\n\n    return z_result\n\n\ndef go_next(i: int, z_result: list[int], s: str) -> bool:\n    \"\"\"\n    Check if we have to move forward to the next characters or not\n    \"\"\"\n    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]\n\n\ndef find_pattern(pattern: str, input_str: str) -> int:\n    \"\"\"\n    Example of using z-function for pattern occurrence\n    Given function returns the number of times 'pattern'\n    appears in 'input_str' as a substring\n\n    >>> find_pattern(\"abr\", \"abracadabra\")\n    2\n    >>> find_pattern(\"a\", \"aaaa\")\n    4\n    >>> find_pattern(\"xz\", \"zxxzxxz\")\n    2\n    \"\"\"\n    answer = 0\n    # concatenate 'pattern' and 'input_str' and call z_function\n    # with concatenated string\n    z_result = z_function(pattern + input_str)\n\n    for val in z_result:\n        # if value is greater then length of the pattern string\n        # that means this index is starting position of substring\n        # which is equal to pattern string\n        if val >= len(pattern):\n            answer += 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/min_cost_string_conversion.py": "\"\"\"\nAlgorithm for calculating the most cost-efficient sequence for converting one string\ninto another.\nThe only allowed operations are\n--- Cost to copy a character is copy_cost\n--- Cost to replace a character is replace_cost\n--- Cost to delete a character is delete_cost\n--- Cost to insert a character is insert_cost\n\"\"\"\n\n\ndef compute_transform_tables(\n    source_string: str,\n    destination_string: str,\n    copy_cost: int,\n    replace_cost: int,\n    delete_cost: int,\n    insert_cost: int,\n) -> tuple[list[list[int]], list[list[str]]]:\n    source_seq = list(source_string)\n    destination_seq = list(destination_string)\n    len_source_seq = len(source_seq)\n    len_destination_seq = len(destination_seq)\n\n    costs = [\n        [0 for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n    ops = [\n        [\"0\" for _ in range(len_destination_seq + 1)] for _ in range(len_source_seq + 1)\n    ]\n\n    for i in range(1, len_source_seq + 1):\n        costs[i][0] = i * delete_cost\n        ops[i][0] = f\"D{source_seq[i - 1]:c}\"\n\n    for i in range(1, len_destination_seq + 1):\n        costs[0][i] = i * insert_cost\n        ops[0][i] = f\"I{destination_seq[i - 1]:c}\"\n\n    for i in range(1, len_source_seq + 1):\n        for j in range(1, len_destination_seq + 1):\n            if source_seq[i - 1] == destination_seq[j - 1]:\n                costs[i][j] = costs[i - 1][j - 1] + copy_cost\n                ops[i][j] = f\"C{source_seq[i - 1]:c}\"\n            else:\n                costs[i][j] = costs[i - 1][j - 1] + replace_cost\n                ops[i][j] = f\"R{source_seq[i - 1]:c}\" + str(destination_seq[j - 1])\n\n            if costs[i - 1][j] + delete_cost < costs[i][j]:\n                costs[i][j] = costs[i - 1][j] + delete_cost\n                ops[i][j] = f\"D{source_seq[i - 1]:c}\"\n\n            if costs[i][j - 1] + insert_cost < costs[i][j]:\n                costs[i][j] = costs[i][j - 1] + insert_cost\n                ops[i][j] = f\"I{destination_seq[j - 1]:c}\"\n\n    return costs, ops\n\n\ndef assemble_transformation(ops: list[list[str]], i: int, j: int) -> list[str]:\n    if i == 0 and j == 0:\n        return []\n    elif ops[i][j][0] in {\"C\", \"R\"}:\n        seq = assemble_transformation(ops, i - 1, j - 1)\n        seq.append(ops[i][j])\n        return seq\n    elif ops[i][j][0] == \"D\":\n        seq = assemble_transformation(ops, i - 1, j)\n        seq.append(ops[i][j])\n        return seq\n    else:\n        seq = assemble_transformation(ops, i, j - 1)\n        seq.append(ops[i][j])\n        return seq\n\n\nif __name__ == \"__main__\":\n    _, operations = compute_transform_tables(\"Python\", \"Algorithms\", -1, 1, 2, 2)\n\n    m = len(operations)\n    n = len(operations[0])\n    sequence = assemble_transformation(operations, m - 1, n - 1)\n\n    string = list(\"Python\")\n    i = 0\n    cost = 0\n\n    with open(\"min_cost.txt\", \"w\") as file:\n        for op in sequence:\n            print(\"\".join(string))\n\n            if op[0] == \"C\":\n                file.write(\"%-16s\" % \"Copy %c\" % op[1])\n                file.write(\"\\t\\t\\t\" + \"\".join(string))\n                file.write(\"\\r\\n\")\n\n                cost -= 1\n            elif op[0] == \"R\":\n                string[i] = op[2]\n\n                file.write(\"%-16s\" % (\"Replace %c\" % op[1] + \" with \" + str(op[2])))\n                file.write(\"\\t\\t\" + \"\".join(string))\n                file.write(\"\\r\\n\")\n\n                cost += 1\n            elif op[0] == \"D\":\n                string.pop(i)\n\n                file.write(\"%-16s\" % \"Delete %c\" % op[1])\n                file.write(\"\\t\\t\\t\" + \"\".join(string))\n                file.write(\"\\r\\n\")\n\n                cost += 2\n            else:\n                string.insert(i, op[1])\n\n                file.write(\"%-16s\" % \"Insert %c\" % op[1])\n                file.write(\"\\t\\t\\t\" + \"\".join(string))\n                file.write(\"\\r\\n\")\n\n                cost += 2\n\n            i += 1\n\n        print(\"\".join(string))\n        print(\"Cost: \", cost)\n\n        file.write(\"\\r\\nMinimum cost: \" + str(cost))\n", "strings/check_anagrams.py": "\"\"\"\nwiki: https://en.wikipedia.org/wiki/Anagram\n\"\"\"\n\nfrom collections import defaultdict\n\n\ndef check_anagrams(first_str: str, second_str: str) -> bool:\n    \"\"\"\n    Two strings are anagrams if they are made up of the same letters but are\n    arranged differently (ignoring the case).\n    >>> check_anagrams('Silent', 'Listen')\n    True\n    >>> check_anagrams('This is a string', 'Is this a string')\n    True\n    >>> check_anagrams('This is    a      string', 'Is     this a string')\n    True\n    >>> check_anagrams('There', 'Their')\n    False\n    \"\"\"\n    first_str = first_str.lower().strip()\n    second_str = second_str.lower().strip()\n\n    # Remove whitespace\n    first_str = first_str.replace(\" \", \"\")\n    second_str = second_str.replace(\" \", \"\")\n\n    # Strings of different lengths are not anagrams\n    if len(first_str) != len(second_str):\n        return False\n\n    # Default values for count should be 0\n    count: defaultdict[str, int] = defaultdict(int)\n\n    # For each character in input strings,\n    # increment count in the corresponding\n    for i in range(len(first_str)):\n        count[first_str[i]] += 1\n        count[second_str[i]] -= 1\n\n    return all(_count == 0 for _count in count.values())\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    input_a = input(\"Enter the first string \").strip()\n    input_b = input(\"Enter the second string \").strip()\n\n    status = check_anagrams(input_a, input_b)\n    print(f\"{input_a} and {input_b} are {'' if status else 'not '}anagrams.\")\n", "strings/title.py": "def to_title_case(word: str) -> str:\n    \"\"\"\n    Converts a string to capitalized case, preserving the input as is\n\n    >>> to_title_case(\"Aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"aakash\")\n    'Aakash'\n\n    >>> to_title_case(\"AAKASH\")\n    'Aakash'\n\n    >>> to_title_case(\"aAkAsH\")\n    'Aakash'\n    \"\"\"\n\n    \"\"\"\n    Convert the first character to uppercase if it's lowercase\n    \"\"\"\n    if \"a\" <= word[0] <= \"z\":\n        word = chr(ord(word[0]) - 32) + word[1:]\n\n    \"\"\"\n    Convert the remaining characters to lowercase if they are uppercase\n    \"\"\"\n    for i in range(1, len(word)):\n        if \"A\" <= word[i] <= \"Z\":\n            word = word[:i] + chr(ord(word[i]) + 32) + word[i + 1 :]\n\n    return word\n\n\ndef sentence_to_title_case(input_str: str) -> str:\n    \"\"\"\n    Converts a string to title case, preserving the input as is\n\n    >>> sentence_to_title_case(\"Aakash Giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aakash giri\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"AAKASH GIRI\")\n    'Aakash Giri'\n\n    >>> sentence_to_title_case(\"aAkAsH gIrI\")\n    'Aakash Giri'\n    \"\"\"\n\n    return \" \".join(to_title_case(word) for word in input_str.split())\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/prefix_function.py": "\"\"\"\nhttps://cp-algorithms.com/string/prefix-function.html\n\nPrefix function Knuth-Morris-Pratt algorithm\n\nDifferent algorithm than Knuth-Morris-Pratt pattern finding\n\nE.x. Finding longest prefix which is also suffix\n\nTime Complexity: O(n) - where n is the length of the string\n\"\"\"\n\n\ndef prefix_function(input_string: str) -> list:\n    \"\"\"\n    For the given string this function computes value for each index(i),\n    which represents the longest coincidence of prefix and suffix\n    for given substring (input_str[0...i])\n\n    For the value of the first element the algorithm always returns 0\n\n    >>> prefix_function(\"aabcdaabc\")\n    [0, 1, 0, 0, 0, 1, 2, 3, 4]\n    >>> prefix_function(\"asdasdad\")\n    [0, 0, 0, 1, 2, 3, 4, 0]\n    \"\"\"\n\n    # list for the result values\n    prefix_result = [0] * len(input_string)\n\n    for i in range(1, len(input_string)):\n        # use last results for better performance - dynamic programming\n        j = prefix_result[i - 1]\n        while j > 0 and input_string[i] != input_string[j]:\n            j = prefix_result[j - 1]\n\n        if input_string[i] == input_string[j]:\n            j += 1\n        prefix_result[i] = j\n\n    return prefix_result\n\n\ndef longest_prefix(input_str: str) -> int:\n    \"\"\"\n    Prefix-function use case\n    Finding longest prefix which is suffix as well\n\n    >>> longest_prefix(\"aabcdaabc\")\n    4\n    >>> longest_prefix(\"asdasdad\")\n    4\n    >>> longest_prefix(\"abcab\")\n    2\n    \"\"\"\n\n    # just returning maximum value of the array gives us answer\n    return max(prefix_function(input_str))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/is_srilankan_phone_number.py": "import re\n\n\ndef is_sri_lankan_phone_number(phone: str) -> bool:\n    \"\"\"\n    Determine whether the string is a valid sri lankan mobile phone number or not\n    References: https://aye.sh/blog/sri-lankan-phone-number-regex\n\n    >>> is_sri_lankan_phone_number(\"+94773283048\")\n    True\n    >>> is_sri_lankan_phone_number(\"+9477-3283048\")\n    True\n    >>> is_sri_lankan_phone_number(\"0718382399\")\n    True\n    >>> is_sri_lankan_phone_number(\"0094702343221\")\n    True\n    >>> is_sri_lankan_phone_number(\"075 3201568\")\n    True\n    >>> is_sri_lankan_phone_number(\"07779209245\")\n    False\n    >>> is_sri_lankan_phone_number(\"0957651234\")\n    False\n    \"\"\"\n\n    pattern = re.compile(r\"^(?:0|94|\\+94|0{2}94)7(0|1|2|4|5|6|7|8)(-| |)\\d{7}$\")\n\n    return bool(re.search(pattern, phone))\n\n\nif __name__ == \"__main__\":\n    phone = \"0094702343221\"\n\n    print(is_sri_lankan_phone_number(phone))\n", "strings/boyer_moore_search.py": "\"\"\"\nThe algorithm finds the pattern in given text using following rule.\n\nThe bad-character rule considers the mismatched character in Text.\nThe next occurrence of that character to the left in Pattern is found,\n\nIf the mismatched character occurs to the left in Pattern,\na shift is proposed that aligns text block and pattern.\n\nIf the mismatched character does not occur to the left in Pattern,\na shift is proposed that moves the entirety of Pattern past\nthe point of mismatch in the text.\n\nIf there no mismatch then the pattern matches with text block.\n\nTime Complexity : O(n/m)\n    n=length of main string\n    m=length of pattern string\n\"\"\"\n\nfrom __future__ import annotations\n\n\nclass BoyerMooreSearch:\n    def __init__(self, text: str, pattern: str):\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char: str) -> int:\n        \"\"\"finds the index of char in pattern in reverse order\n\n        Parameters :\n            char (chr): character to be searched\n\n        Returns :\n            i (int): index of char from last in pattern\n            -1 (int): if char is not found in pattern\n        \"\"\"\n\n        for i in range(self.patLen - 1, -1, -1):\n            if char == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, current_pos: int) -> int:\n        \"\"\"\n        find the index of mis-matched character in text when compared with pattern\n        from last\n\n        Parameters :\n            current_pos (int): current index position of text\n\n        Returns :\n            i (int): index of mismatched char from last in text\n            -1 (int): if there is no mismatch between pattern and text block\n        \"\"\"\n\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] != self.text[current_pos + i]:\n                return current_pos + i\n        return -1\n\n    def bad_character_heuristic(self) -> list[int]:\n        # searches pattern in text and returns index positions\n        positions = []\n        for i in range(self.textLen - self.patLen + 1):\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i = (\n                    mismatch_index - match_index\n                )  # shifting index lgtm [py/multiple-definition]\n        return positions\n\n\ntext = \"ABAABA\"\npattern = \"AB\"\nbms = BoyerMooreSearch(text, pattern)\npositions = bms.bad_character_heuristic()\n\nif len(positions) == 0:\n    print(\"No match found\")\nelse:\n    print(\"Pattern found in following positions: \")\n    print(positions)\n", "strings/jaro_winkler.py": "\"\"\"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance\"\"\"\n\n\ndef jaro_winkler(str1: str, str2: str) -> float:\n    \"\"\"\n    Jaro-Winkler distance is a string metric measuring an edit distance between two\n    sequences.\n    Output value is between 0.0 and 1.0.\n\n    >>> jaro_winkler(\"martha\", \"marhta\")\n    0.9611111111111111\n    >>> jaro_winkler(\"CRATE\", \"TRACE\")\n    0.7333333333333334\n    >>> jaro_winkler(\"test\", \"dbdbdbdb\")\n    0.0\n    >>> jaro_winkler(\"test\", \"test\")\n    1.0\n    >>> jaro_winkler(\"hello world\", \"HeLLo W0rlD\")\n    0.6363636363636364\n    >>> jaro_winkler(\"test\", \"\")\n    0.0\n    >>> jaro_winkler(\"hello\", \"world\")\n    0.4666666666666666\n    >>> jaro_winkler(\"hell**o\", \"*world\")\n    0.4365079365079365\n    \"\"\"\n\n    def get_matched_characters(_str1: str, _str2: str) -> str:\n        matched = []\n        limit = min(len(_str1), len(_str2)) // 2\n        for i, char in enumerate(_str1):\n            left = int(max(0, i - limit))\n            right = int(min(i + limit + 1, len(_str2)))\n            if char in _str2[left:right]:\n                matched.append(char)\n                _str2 = f\"{_str2[0:_str2.index(char)]} {_str2[_str2.index(char) + 1:]}\"\n\n        return \"\".join(matched)\n\n    # matching characters\n    matching_1 = get_matched_characters(str1, str2)\n    matching_2 = get_matched_characters(str2, str1)\n    match_count = len(matching_1)\n\n    # transposition\n    transpositions = (\n        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2\n    )\n\n    if not match_count:\n        jaro = 0.0\n    else:\n        jaro = (\n            1\n            / 3\n            * (\n                match_count / len(str1)\n                + match_count / len(str2)\n                + (match_count - transpositions) / match_count\n            )\n        )\n\n    # common prefix up to 4 characters\n    prefix_len = 0\n    for c1, c2 in zip(str1[:4], str2[:4]):\n        if c1 == c2:\n            prefix_len += 1\n        else:\n            break\n\n    return jaro + 0.1 * prefix_len * (1 - jaro)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    print(jaro_winkler(\"hello\", \"world\"))\n", "strings/capitalize.py": "from string import ascii_lowercase, ascii_uppercase\n\n\ndef capitalize(sentence: str) -> str:\n    \"\"\"\n    Capitalizes the first letter of a sentence or word.\n\n    >>> capitalize(\"hello world\")\n    'Hello world'\n    >>> capitalize(\"123 hello world\")\n    '123 hello world'\n    >>> capitalize(\" hello world\")\n    ' hello world'\n    >>> capitalize(\"a\")\n    'A'\n    >>> capitalize(\"\")\n    ''\n    \"\"\"\n    if not sentence:\n        return \"\"\n\n    # Create a dictionary that maps lowercase letters to uppercase letters\n    # Capitalize the first character if it's a lowercase letter\n    # Concatenate the capitalized character with the rest of the string\n    lower_to_upper = dict(zip(ascii_lowercase, ascii_uppercase))\n    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/aho_corasick.py": "from __future__ import annotations\n\nfrom collections import deque\n\n\nclass Automaton:\n    def __init__(self, keywords: list[str]):\n        self.adlist: list[dict] = []\n        self.adlist.append(\n            {\"value\": \"\", \"next_states\": [], \"fail_state\": 0, \"output\": []}\n        )\n\n        for keyword in keywords:\n            self.add_keyword(keyword)\n        self.set_fail_transitions()\n\n    def find_next_state(self, current_state: int, char: str) -> int | None:\n        for state in self.adlist[current_state][\"next_states\"]:\n            if char == self.adlist[state][\"value\"]:\n                return state\n        return None\n\n    def add_keyword(self, keyword: str) -> None:\n        current_state = 0\n        for character in keyword:\n            next_state = self.find_next_state(current_state, character)\n            if next_state is None:\n                self.adlist.append(\n                    {\n                        \"value\": character,\n                        \"next_states\": [],\n                        \"fail_state\": 0,\n                        \"output\": [],\n                    }\n                )\n                self.adlist[current_state][\"next_states\"].append(len(self.adlist) - 1)\n                current_state = len(self.adlist) - 1\n            else:\n                current_state = next_state\n        self.adlist[current_state][\"output\"].append(keyword)\n\n    def set_fail_transitions(self) -> None:\n        q: deque = deque()\n        for node in self.adlist[0][\"next_states\"]:\n            q.append(node)\n            self.adlist[node][\"fail_state\"] = 0\n        while q:\n            r = q.popleft()\n            for child in self.adlist[r][\"next_states\"]:\n                q.append(child)\n                state = self.adlist[r][\"fail_state\"]\n                while (\n                    self.find_next_state(state, self.adlist[child][\"value\"]) is None\n                    and state != 0\n                ):\n                    state = self.adlist[state][\"fail_state\"]\n                self.adlist[child][\"fail_state\"] = self.find_next_state(\n                    state, self.adlist[child][\"value\"]\n                )\n                if self.adlist[child][\"fail_state\"] is None:\n                    self.adlist[child][\"fail_state\"] = 0\n                self.adlist[child][\"output\"] = (\n                    self.adlist[child][\"output\"]\n                    + self.adlist[self.adlist[child][\"fail_state\"]][\"output\"]\n                )\n\n    def search_in(self, string: str) -> dict[str, list[int]]:\n        \"\"\"\n        >>> A = Automaton([\"what\", \"hat\", \"ver\", \"er\"])\n        >>> A.search_in(\"whatever, err ... , wherever\")\n        {'what': [0], 'hat': [1], 'ver': [5, 25], 'er': [6, 10, 22, 26]}\n        \"\"\"\n        result: dict = {}  # returns a dict with keywords and list of its occurrences\n        current_state = 0\n        for i in range(len(string)):\n            while (\n                self.find_next_state(current_state, string[i]) is None\n                and current_state != 0\n            ):\n                current_state = self.adlist[current_state][\"fail_state\"]\n            next_state = self.find_next_state(current_state, string[i])\n            if next_state is None:\n                current_state = 0\n            else:\n                current_state = next_state\n                for key in self.adlist[current_state][\"output\"]:\n                    if key not in result:\n                        result[key] = []\n                    result[key].append(i - len(key) + 1)\n        return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/is_pangram.py": "\"\"\"\nwiki: https://en.wikipedia.org/wiki/Pangram\n\"\"\"\n\n\ndef is_pangram(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    A Pangram String contains all the alphabets at least once.\n    >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram(\"My name is Unknown\")\n    False\n    >>> is_pangram(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram()\n    True\n    \"\"\"\n    # Declare frequency as a set to have unique occurrences of letters\n    frequency = set()\n\n    # Replace all the whitespace in our sentence\n    input_str = input_str.replace(\" \", \"\")\n    for alpha in input_str:\n        if \"a\" <= alpha.lower() <= \"z\":\n            frequency.add(alpha.lower())\n    return len(frequency) == 26\n\n\ndef is_pangram_faster(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_faster(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_faster(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_faster(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_faster(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_faster()\n    True\n    \"\"\"\n    flag = [False] * 26\n    for char in input_str:\n        if char.islower():\n            flag[ord(char) - 97] = True\n        elif char.isupper():\n            flag[ord(char) - 65] = True\n    return all(flag)\n\n\ndef is_pangram_fastest(\n    input_str: str = \"The quick brown fox jumps over the lazy dog\",\n) -> bool:\n    \"\"\"\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the lazy dog\")\n    True\n    >>> is_pangram_fastest(\"Waltz, bad nymph, for quick jigs vex.\")\n    True\n    >>> is_pangram_fastest(\"Jived fox nymph grabs quick waltz.\")\n    True\n    >>> is_pangram_fastest(\"The quick brown fox jumps over the la_y dog\")\n    False\n    >>> is_pangram_fastest()\n    True\n    \"\"\"\n    return len({char for char in input_str.lower() if char.isalpha()}) == 26\n\n\ndef benchmark() -> None:\n    \"\"\"\n    Benchmark code comparing different version.\n    \"\"\"\n    from timeit import timeit\n\n    setup = \"from __main__ import is_pangram, is_pangram_faster, is_pangram_fastest\"\n    print(timeit(\"is_pangram()\", setup=setup))\n    print(timeit(\"is_pangram_faster()\", setup=setup))\n    print(timeit(\"is_pangram_fastest()\", setup=setup))\n    # 5.348480500048026, 2.6477354579837993, 1.8470395830227062\n    # 5.036091582966037, 2.644472333951853,  1.8869528750656173\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    benchmark()\n", "strings/camel_case_to_snake_case.py": "def camel_to_snake_case(input_str: str) -> str:\n    \"\"\"\n    Transforms a camelCase (or PascalCase) string to snake_case\n\n    >>> camel_to_snake_case(\"someRandomString\")\n    'some_random_string'\n\n    >>> camel_to_snake_case(\"SomeRandomStr#ng\")\n    'some_random_str_ng'\n\n    >>> camel_to_snake_case(\"123someRandom123String123\")\n    '123_some_random_123_string_123'\n\n    >>> camel_to_snake_case(\"123SomeRandom123String123\")\n    '123_some_random_123_string_123'\n\n    >>> camel_to_snake_case(123)\n    Traceback (most recent call last):\n        ...\n    ValueError: Expected string as input, found <class 'int'>\n\n    \"\"\"\n\n    # check for invalid input type\n    if not isinstance(input_str, str):\n        msg = f\"Expected string as input, found {type(input_str)}\"\n        raise ValueError(msg)\n\n    snake_str = \"\"\n\n    for index, char in enumerate(input_str):\n        if char.isupper():\n            snake_str += \"_\" + char.lower()\n\n        # if char is lowercase but proceeded by a digit:\n        elif input_str[index - 1].isdigit() and char.islower():\n            snake_str += \"_\" + char\n\n        # if char is a digit proceeded by a letter:\n        elif input_str[index - 1].isalpha() and char.isnumeric():\n            snake_str += \"_\" + char.lower()\n\n        # if char is not alphanumeric:\n        elif not char.isalnum():\n            snake_str += \"_\"\n\n        else:\n            snake_str += char\n\n    # remove leading underscore\n    if snake_str[0] == \"_\":\n        snake_str = snake_str[1:]\n\n    return snake_str\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/__init__.py": "", "strings/is_spain_national_id.py": "NUMBERS_PLUS_LETTER = \"Input must be a string of 8 numbers plus letter\"\nLOOKUP_LETTERS = \"TRWAGMYFPDXBNJZSQVHLCKE\"\n\n\ndef is_spain_national_id(spanish_id: str) -> bool:\n    \"\"\"\n    Spain National Id is a string composed by 8 numbers plus a letter\n    The letter in fact is not part of the ID, it acts as a validator,\n    checking you didn't do a mistake when entering it on a system or\n    are giving a fake one.\n\n    https://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number\n\n    >>> is_spain_national_id(\"12345678Z\")\n    True\n    >>> is_spain_national_id(\"12345678z\")  # It is case-insensitive\n    True\n    >>> is_spain_national_id(\"12345678x\")\n    False\n    >>> is_spain_national_id(\"12345678I\")\n    False\n    >>> is_spain_national_id(\"12345678-Z\")  # Some systems add a dash\n    True\n    >>> is_spain_national_id(\"12345678\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"123456709\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234567--Z\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234Z\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(\"1234ZzZZ\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a string of 8 numbers plus letter\n    >>> is_spain_national_id(12345678)\n    Traceback (most recent call last):\n        ...\n    TypeError: Expected string as input, found int\n    \"\"\"\n\n    if not isinstance(spanish_id, str):\n        msg = f\"Expected string as input, found {type(spanish_id).__name__}\"\n        raise TypeError(msg)\n\n    spanish_id_clean = spanish_id.replace(\"-\", \"\").upper()\n    if len(spanish_id_clean) != 9:\n        raise ValueError(NUMBERS_PLUS_LETTER)\n\n    try:\n        number = int(spanish_id_clean[0:8])\n        letter = spanish_id_clean[8]\n    except ValueError as ex:\n        raise ValueError(NUMBERS_PLUS_LETTER) from ex\n\n    if letter.isdigit():\n        raise ValueError(NUMBERS_PLUS_LETTER)\n\n    return letter == LOOKUP_LETTERS[number % 23]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/anagrams.py": "from __future__ import annotations\n\nimport collections\nimport pprint\nfrom pathlib import Path\n\n\ndef signature(word: str) -> str:\n    \"\"\"Return a word sorted\n    >>> signature(\"test\")\n    'estt'\n    >>> signature(\"this is a test\")\n    '   aehiisssttt'\n    >>> signature(\"finaltest\")\n    'aefilnstt'\n    \"\"\"\n    return \"\".join(sorted(word))\n\n\ndef anagram(my_word: str) -> list[str]:\n    \"\"\"Return every anagram of the given word\n    >>> anagram('test')\n    ['sett', 'stet', 'test']\n    >>> anagram('this is a test')\n    []\n    >>> anagram('final')\n    ['final']\n    \"\"\"\n    return word_by_signature[signature(my_word)]\n\n\ndata: str = Path(__file__).parent.joinpath(\"words.txt\").read_text(encoding=\"utf-8\")\nword_list = sorted({word.strip().lower() for word in data.splitlines()})\n\nword_by_signature = collections.defaultdict(list)\nfor word in word_list:\n    word_by_signature[signature(word)].append(word)\n\nif __name__ == \"__main__\":\n    all_anagrams = {word: anagram(word) for word in word_list if len(anagram(word)) > 1}\n\n    with open(\"anagrams.txt\", \"w\") as file:\n        file.write(\"all_anagrams = \\n \")\n        file.write(pprint.pformat(all_anagrams))\n", "strings/indian_phone_validator.py": "import re\n\n\ndef indian_phone_validator(phone: str) -> bool:\n    \"\"\"\n    Determine whether the string is a valid phone number or not\n    :param phone:\n    :return: Boolean\n    >>> indian_phone_validator(\"+91123456789\")\n    False\n    >>> indian_phone_validator(\"+919876543210\")\n    True\n    >>> indian_phone_validator(\"01234567896\")\n    False\n    >>> indian_phone_validator(\"919876543218\")\n    True\n    >>> indian_phone_validator(\"+91-1234567899\")\n    False\n    >>> indian_phone_validator(\"+91-9876543218\")\n    True\n    \"\"\"\n    pat = re.compile(r\"^(\\+91[\\-\\s]?)?[0]?(91)?[789]\\d{9}$\")\n    if match := re.search(pat, phone):\n        return match.string == phone\n    return False\n\n\nif __name__ == \"__main__\":\n    print(indian_phone_validator(\"+918827897895\"))\n", "strings/lower.py": "def lower(word: str) -> str:\n    \"\"\"\n    Will convert the entire string to lowercase letters\n\n    >>> lower(\"wow\")\n    'wow'\n    >>> lower(\"HellZo\")\n    'hellzo'\n    >>> lower(\"WHAT\")\n    'what'\n    >>> lower(\"wh[]32\")\n    'wh[]32'\n    >>> lower(\"whAT\")\n    'what'\n    \"\"\"\n\n    # Converting to ASCII value, obtaining the integer representation\n    # and checking to see if the character is a capital letter.\n    # If it is a capital letter, it is shifted by 32, making it a lowercase letter.\n    return \"\".join(chr(ord(char) + 32) if \"A\" <= char <= \"Z\" else char for char in word)\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/edit_distance.py": "def edit_distance(source: str, target: str) -> int:\n    \"\"\"\n    Edit distance algorithm is a string metric, i.e., it is a way of quantifying how\n    dissimilar two strings are to one another. It is measured by counting the minimum\n    number of operations required to transform one string into another.\n\n    This implementation assumes that the cost of operations (insertion, deletion and\n    substitution) is always 1\n\n    Args:\n    source: the initial string with respect to which we are calculating the edit\n        distance for the target\n    target: the target string, formed after performing n operations on the source string\n\n    >>> edit_distance(\"GATTIC\", \"GALTIC\")\n    1\n    \"\"\"\n    if len(source) == 0:\n        return len(target)\n    elif len(target) == 0:\n        return len(source)\n\n    delta = int(source[-1] != target[-1])  # Substitution\n    return min(\n        edit_distance(source[:-1], target[:-1]) + delta,\n        edit_distance(source, target[:-1]) + 1,\n        edit_distance(source[:-1], target) + 1,\n    )\n\n\nif __name__ == \"__main__\":\n    print(edit_distance(\"ATCGCTG\", \"TAGCTAA\"))  # Answer is 4\n", "strings/can_string_be_rearranged_as_palindrome.py": "# Created by susmith98\n\nfrom collections import Counter\nfrom timeit import timeit\n\n# Problem Description:\n# Check if characters of the given string can be rearranged to form a palindrome.\n# Counter is faster for long strings and non-Counter is faster for short strings.\n\n\ndef can_string_be_rearranged_as_palindrome_counter(\n    input_str: str = \"\",\n) -> bool:\n    \"\"\"\n    A Palindrome is a String that reads the same forward as it does backwards.\n    Examples of Palindromes mom, dad, malayalam\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Momo\")\n    True\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Mother\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"Father\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\n    True\n    \"\"\"\n    return sum(c % 2 for c in Counter(input_str.replace(\" \", \"\").lower()).values()) < 2\n\n\ndef can_string_be_rearranged_as_palindrome(input_str: str = \"\") -> bool:\n    \"\"\"\n    A Palindrome is a String that reads the same forward as it does backwards.\n    Examples of Palindromes mom, dad, malayalam\n    >>> can_string_be_rearranged_as_palindrome(\"Momo\")\n    True\n    >>> can_string_be_rearranged_as_palindrome(\"Mother\")\n    False\n    >>> can_string_be_rearranged_as_palindrome(\"Father\")\n    False\n    >>> can_string_be_rearranged_as_palindrome_counter(\"A man a plan a canal Panama\")\n    True\n    \"\"\"\n    if len(input_str) == 0:\n        return True\n    lower_case_input_str = input_str.replace(\" \", \"\").lower()\n    # character_freq_dict: Stores the frequency of every character in the input string\n    character_freq_dict: dict[str, int] = {}\n\n    for character in lower_case_input_str:\n        character_freq_dict[character] = character_freq_dict.get(character, 0) + 1\n    \"\"\"\n    Above line of code is equivalent to:\n    1) Getting the frequency of current character till previous index\n    >>> character_freq =  character_freq_dict.get(character, 0)\n    2) Incrementing the frequency of current character by 1\n    >>> character_freq = character_freq + 1\n    3) Updating the frequency of current character\n    >>> character_freq_dict[character] = character_freq\n    \"\"\"\n    \"\"\"\n    OBSERVATIONS:\n    Even length palindrome\n    -> Every character appears even no.of times.\n    Odd length palindrome\n    -> Every character appears even no.of times except for one character.\n    LOGIC:\n    Step 1: We'll count number of characters that appear odd number of times i.e oddChar\n    Step 2:If we find more than 1 character that appears odd number of times,\n    It is not possible to rearrange as a palindrome\n    \"\"\"\n    odd_char = 0\n\n    for character_count in character_freq_dict.values():\n        if character_count % 2:\n            odd_char += 1\n    if odd_char > 1:\n        return False\n    return True\n\n\ndef benchmark(input_str: str = \"\") -> None:\n    \"\"\"\n    Benchmark code for comparing above 2 functions\n    \"\"\"\n    print(\"\\nFor string = \", input_str, \":\")\n    print(\n        \"> can_string_be_rearranged_as_palindrome_counter()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome_counter(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome_counter(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )\n    print(\n        \"> can_string_be_rearranged_as_palindrome()\",\n        \"\\tans =\",\n        can_string_be_rearranged_as_palindrome(input_str),\n        \"\\ttime =\",\n        timeit(\n            \"z.can_string_be_rearranged_as_palindrome(z.check_str)\",\n            setup=\"import __main__ as z\",\n        ),\n        \"seconds\",\n    )\n\n\nif __name__ == \"__main__\":\n    check_str = input(\n        \"Enter string to determine if it can be rearranged as a palindrome or not: \"\n    ).strip()\n    benchmark(check_str)\n    status = can_string_be_rearranged_as_palindrome_counter(check_str)\n    print(f\"{check_str} can {'' if status else 'not '}be rearranged as a palindrome\")\n", "strings/remove_duplicate.py": "def remove_duplicates(sentence: str) -> str:\n    \"\"\"\n    Remove duplicates from sentence\n    >>> remove_duplicates(\"Python is great and Java is also great\")\n    'Java Python also and great is'\n    >>> remove_duplicates(\"Python   is      great and Java is also great\")\n    'Java Python also and great is'\n    \"\"\"\n    return \" \".join(sorted(set(sentence.split())))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/is_valid_email_address.py": "\"\"\"\nImplements an is valid email address algorithm\n\n@ https://en.wikipedia.org/wiki/Email_address\n\"\"\"\n\nimport string\n\nemail_tests: tuple[tuple[str, bool], ...] = (\n    (\"simple@example.com\", True),\n    (\"very.common@example.com\", True),\n    (\"disposable.style.email.with+symbol@example.com\", True),\n    (\"other-email-with-hyphen@and.subdomains.example.com\", True),\n    (\"fully-qualified-domain@example.com\", True),\n    (\"user.name+tag+sorting@example.com\", True),\n    (\"x@example.com\", True),\n    (\"example-indeed@strange-example.com\", True),\n    (\"test/test@test.com\", True),\n    (\n        \"123456789012345678901234567890123456789012345678901234567890123@example.com\",\n        True,\n    ),\n    (\"admin@mailserver1\", True),\n    (\"example@s.example\", True),\n    (\"Abc.example.com\", False),\n    (\"A@b@c@example.com\", False),\n    (\"abc@example..com\", False),\n    (\"a(c)d,e:f;g<h>i[j\\\\k]l@example.com\", False),\n    (\n        \"12345678901234567890123456789012345678901234567890123456789012345@example.com\",\n        False,\n    ),\n    (\"i.like.underscores@but_its_not_allowed_in_this_part\", False),\n    (\"\", False),\n)\n\n# The maximum octets (one character as a standard unicode character is one byte)\n# that the local part and the domain part can have\nMAX_LOCAL_PART_OCTETS = 64\nMAX_DOMAIN_OCTETS = 255\n\n\ndef is_valid_email_address(email: str) -> bool:\n    \"\"\"\n    Returns True if the passed email address is valid.\n\n    The local part of the email precedes the singular @ symbol and\n    is associated with a display-name. For example, \"john.smith\"\n    The domain is stricter than the local part and follows the @ symbol.\n\n    Global email checks:\n     1. There can only be one @ symbol in the email address. Technically if the\n        @ symbol is quoted in the local-part, then it is valid, however this\n        implementation ignores \"\" for now.\n        (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)\n     2. The local-part and the domain are limited to a certain number of octets. With\n        unicode storing a single character in one byte, each octet is equivalent to\n        a character. Hence, we can just check the length of the string.\n    Checks for the local-part:\n     3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,\n        and printable characters (!#$%&'*+-/=?^_`{|}~)\n     4. The local-part may also contain a \".\" in any place that is not the first or\n        last character, and may not have more than one \".\" consecutively.\n\n    Checks for the domain:\n     5. The domain may contain: upper and lowercase latin letters and digits 0 to 9\n     6. Hyphen \"-\", provided that it is not the first or last character\n     7. The domain may also contain a \".\" in any place that is not the first or\n        last character, and may not have more than one \".\" consecutively.\n\n    >>> for email, valid in email_tests:\n    ...     assert is_valid_email_address(email) == valid\n    \"\"\"\n\n    # (1.) Make sure that there is only one @ symbol in the email address\n    if email.count(\"@\") != 1:\n        return False\n\n    local_part, domain = email.split(\"@\")\n    # (2.) Check octet length of the local part and domain\n    if len(local_part) > MAX_LOCAL_PART_OCTETS or len(domain) > MAX_DOMAIN_OCTETS:\n        return False\n\n    # (3.) Validate the characters in the local-part\n    if any(\n        char not in string.ascii_letters + string.digits + \".(!#$%&'*+-/=?^_`{|}~)\"\n        for char in local_part\n    ):\n        return False\n\n    # (4.) Validate the placement of \".\" characters in the local-part\n    if local_part.startswith(\".\") or local_part.endswith(\".\") or \"..\" in local_part:\n        return False\n\n    # (5.) Validate the characters in the domain\n    if any(char not in string.ascii_letters + string.digits + \".-\" for char in domain):\n        return False\n\n    # (6.) Validate the placement of \"-\" characters\n    if domain.startswith(\"-\") or domain.endswith(\".\"):\n        return False\n\n    # (7.) Validate the placement of \".\" characters\n    if domain.startswith(\".\") or domain.endswith(\".\") or \"..\" in domain:\n        return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    for email, valid in email_tests:\n        is_valid = is_valid_email_address(email)\n        assert is_valid == valid, f\"{email} is {is_valid}\"\n        print(f\"Email address {email} is {'not ' if not is_valid else ''}valid\")\n", "strings/pig_latin.py": "def pig_latin(word: str) -> str:\n    \"\"\"Compute the piglatin of a given string.\n\n    https://en.wikipedia.org/wiki/Pig_Latin\n\n    Usage examples:\n    >>> pig_latin(\"pig\")\n    'igpay'\n    >>> pig_latin(\"latin\")\n    'atinlay'\n    >>> pig_latin(\"banana\")\n    'ananabay'\n    >>> pig_latin(\"friends\")\n    'iendsfray'\n    >>> pig_latin(\"smile\")\n    'ilesmay'\n    >>> pig_latin(\"string\")\n    'ingstray'\n    >>> pig_latin(\"eat\")\n    'eatway'\n    >>> pig_latin(\"omelet\")\n    'omeletway'\n    >>> pig_latin(\"are\")\n    'areway'\n    >>> pig_latin(\" \")\n    ''\n    >>> pig_latin(None)\n    ''\n    \"\"\"\n    if not (word or \"\").strip():\n        return \"\"\n    word = word.lower()\n    if word[0] in \"aeiou\":\n        return f\"{word}way\"\n    for i, char in enumerate(word):  # noqa: B007\n        if char in \"aeiou\":\n            break\n    return f\"{word[i:]}{word[:i]}ay\"\n\n\nif __name__ == \"__main__\":\n    print(f\"{pig_latin('friends') = }\")\n    word = input(\"Enter a word: \")\n    print(f\"{pig_latin(word) = }\")\n", "strings/damerau_levenshtein_distance.py": "\"\"\"\nThis script is a implementation of the Damerau-Levenshtein distance algorithm.\n\nIt's an algorithm that measures the edit distance between two string sequences\n\nMore information about this algorithm can be found in this wikipedia article:\nhttps://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\n\"\"\"\n\n\ndef damerau_levenshtein_distance(first_string: str, second_string: str) -> int:\n    \"\"\"\n    Implements the Damerau-Levenshtein distance algorithm that measures\n    the edit distance between two strings.\n\n    Parameters:\n        first_string: The first string to compare\n        second_string: The second string to compare\n\n    Returns:\n        distance: The edit distance between the first and second strings\n\n    >>> damerau_levenshtein_distance(\"cat\", \"cut\")\n    1\n    >>> damerau_levenshtein_distance(\"kitten\", \"sitting\")\n    3\n    >>> damerau_levenshtein_distance(\"hello\", \"world\")\n    4\n    >>> damerau_levenshtein_distance(\"book\", \"back\")\n    2\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    >>> damerau_levenshtein_distance(\"container\", \"containment\")\n    3\n    \"\"\"\n    # Create a dynamic programming matrix to store the distances\n    dp_matrix = [[0] * (len(second_string) + 1) for _ in range(len(first_string) + 1)]\n\n    # Initialize the matrix\n    for i in range(len(first_string) + 1):\n        dp_matrix[i][0] = i\n    for j in range(len(second_string) + 1):\n        dp_matrix[0][j] = j\n\n    # Fill the matrix\n    for i, first_char in enumerate(first_string, start=1):\n        for j, second_char in enumerate(second_string, start=1):\n            cost = int(first_char != second_char)\n\n            dp_matrix[i][j] = min(\n                dp_matrix[i - 1][j] + 1,  # Deletion\n                dp_matrix[i][j - 1] + 1,  # Insertion\n                dp_matrix[i - 1][j - 1] + cost,  # Substitution\n            )\n\n            if (\n                i > 1\n                and j > 1\n                and first_string[i - 1] == second_string[j - 2]\n                and first_string[i - 2] == second_string[j - 1]\n            ):\n                # Transposition\n                dp_matrix[i][j] = min(dp_matrix[i][j], dp_matrix[i - 2][j - 2] + cost)\n\n    return dp_matrix[-1][-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "strings/text_justification.py": "def text_justification(word: str, max_width: int) -> list:\n    \"\"\"\n    Will format the string such that each line has exactly\n    (max_width) characters and is fully (left and right) justified,\n    and return the list of justified text.\n\n    example 1:\n    string = \"This is an example of text justification.\"\n    max_width = 16\n\n    output = ['This    is    an',\n              'example  of text',\n              'justification.  ']\n\n    >>> text_justification(\"This is an example of text justification.\", 16)\n    ['This    is    an', 'example  of text', 'justification.  ']\n\n    example 2:\n    string = \"Two roads diverged in a yellow wood\"\n    max_width = 16\n    output = ['Two        roads',\n              'diverged   in  a',\n              'yellow wood     ']\n\n    >>> text_justification(\"Two roads diverged in a yellow wood\", 16)\n    ['Two        roads', 'diverged   in  a', 'yellow wood     ']\n\n    Time complexity: O(m*n)\n    Space complexity: O(m*n)\n    \"\"\"\n\n    # Converting string into list of strings split by a space\n    words = word.split()\n\n    def justify(line: list, width: int, max_width: int) -> str:\n        overall_spaces_count = max_width - width\n        words_count = len(line)\n        if len(line) == 1:\n            # if there is only word in line\n            # just insert overall_spaces_count for the remainder of line\n            return line[0] + \" \" * overall_spaces_count\n        else:\n            spaces_to_insert_between_words = words_count - 1\n            # num_spaces_between_words_list[i] : tells you to insert\n            # num_spaces_between_words_list[i] spaces\n            # after word on line[i]\n            num_spaces_between_words_list = spaces_to_insert_between_words * [\n                overall_spaces_count // spaces_to_insert_between_words\n            ]\n            spaces_count_in_locations = (\n                overall_spaces_count % spaces_to_insert_between_words\n            )\n            # distribute spaces via round robin to the left words\n            for i in range(spaces_count_in_locations):\n                num_spaces_between_words_list[i] += 1\n            aligned_words_list = []\n            for i in range(spaces_to_insert_between_words):\n                # add the word\n                aligned_words_list.append(line[i])\n                # add the spaces to insert\n                aligned_words_list.append(num_spaces_between_words_list[i] * \" \")\n            # just add the last word to the sentence\n            aligned_words_list.append(line[-1])\n            # join the aligned words list to form a justified line\n            return \"\".join(aligned_words_list)\n\n    answer = []\n    line: list[str] = []\n    width = 0\n    for word in words:\n        if width + len(word) + len(line) <= max_width:\n            # keep adding words until we can fill out max_width\n            # width = sum of length of all words (without overall_spaces_count)\n            # len(word) = length of current word\n            # len(line) = number of overall_spaces_count to insert between words\n            line.append(word)\n            width += len(word)\n        else:\n            # justify the line and add it to result\n            answer.append(justify(line, width, max_width))\n            # reset new line and new width\n            line, width = [word], len(word)\n    remaining_spaces = max_width - width - len(line)\n    answer.append(\" \".join(line) + (remaining_spaces + 1) * \" \")\n    return answer\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n", "strings/string_switch_case.py": "import re\n\n\"\"\"\ngeneral info:\nhttps://en.wikipedia.org/wiki/Naming_convention_(programming)#Python_and_Ruby\n\npascal case [ an upper Camel Case ]: https://en.wikipedia.org/wiki/Camel_case\n\ncamel case: https://en.wikipedia.org/wiki/Camel_case\n\nkebab case [ can be found in general info ]:\nhttps://en.wikipedia.org/wiki/Naming_convention_(programming)#Python_and_Ruby\n\nsnake case: https://en.wikipedia.org/wiki/Snake_case\n\"\"\"\n\n\n# assistant functions\ndef split_input(str_: str) -> list:\n    \"\"\"\n    >>> split_input(\"one two 31235three4four\")\n    [['one', 'two', '31235three4four']]\n    \"\"\"\n    return [char.split() for char in re.split(r\"[^ a-z A-Z 0-9 \\s]\", str_)]\n\n\ndef to_simple_case(str_: str) -> str:\n    \"\"\"\n    >>> to_simple_case(\"one two 31235three4four\")\n    'OneTwo31235three4four'\n    >>> to_simple_case(\"This should be combined\")\n    'ThisShouldBeCombined'\n    >>> to_simple_case(\"The first letters are capitalized, then string is merged\")\n    'TheFirstLettersAreCapitalizedThenStringIsMerged'\n    >>> to_simple_case(\"special characters :, ', %, ^, $, are ignored\")\n    'SpecialCharactersAreIgnored'\n    \"\"\"\n    string_split = split_input(str_)\n    return \"\".join(\n        [\"\".join([char.capitalize() for char in sub_str]) for sub_str in string_split]\n    )\n\n\ndef to_complex_case(text: str, upper: bool, separator: str) -> str:\n    \"\"\"\n    Returns the string concatenated with the delimiter we provide.\n\n    Parameters:\n    @text: The string on which we want to perform operation\n    @upper: Boolean value to determine whether we want capitalized result or not\n    @separator: The delimiter with which we want to concatenate words\n\n    Examples:\n    >>> to_complex_case(\"one two 31235three4four\", True, \"_\")\n    'ONE_TWO_31235THREE4FOUR'\n    >>> to_complex_case(\"one two 31235three4four\", False, \"-\")\n    'one-two-31235three4four'\n    \"\"\"\n    try:\n        string_split = split_input(text)\n        if upper:\n            res_str = \"\".join(\n                [\n                    separator.join([char.upper() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        else:\n            res_str = \"\".join(\n                [\n                    separator.join([char.lower() for char in sub_str])\n                    for sub_str in string_split\n                ]\n            )\n        return res_str\n    except IndexError:\n        return \"not valid string\"\n\n\n# main content\ndef to_pascal_case(text: str) -> str:\n    \"\"\"\n    >>> to_pascal_case(\"one two 31235three4four\")\n    'OneTwo31235three4four'\n    \"\"\"\n    return to_simple_case(text)\n\n\ndef to_camel_case(text: str) -> str:\n    \"\"\"\n    >>> to_camel_case(\"one two 31235three4four\")\n    'oneTwo31235three4four'\n    \"\"\"\n    try:\n        res_str = to_simple_case(text)\n        return res_str[0].lower() + res_str[1:]\n    except IndexError:\n        return \"not valid string\"\n\n\ndef to_snake_case(text: str, upper: bool) -> str:\n    \"\"\"\n    >>> to_snake_case(\"one two 31235three4four\", True)\n    'ONE_TWO_31235THREE4FOUR'\n    >>> to_snake_case(\"one two 31235three4four\", False)\n    'one_two_31235three4four'\n    \"\"\"\n    return to_complex_case(text, upper, \"_\")\n\n\ndef to_kebab_case(text: str, upper: bool) -> str:\n    \"\"\"\n    >>> to_kebab_case(\"one two 31235three4four\", True)\n    'ONE-TWO-31235THREE4FOUR'\n    >>> to_kebab_case(\"one two 31235three4four\", False)\n    'one-two-31235three4four'\n    \"\"\"\n    return to_complex_case(text, upper, \"-\")\n\n\nif __name__ == \"__main__\":\n    __import__(\"doctest\").testmod()\n", "other/scoring_algorithm.py": "\"\"\"\ndeveloped by: markmelnic\noriginal repo: https://github.com/markmelnic/Scoring-Algorithm\n\nAnalyse data using a range based percentual proximity algorithm\nand calculate the linear maximum likelihood estimation.\nThe basic principle is that all values supplied will be broken\ndown to a range from 0 to 1 and each column's score will be added\nup to get the total score.\n\n==========\nExample for data of vehicles\nprice|mileage|registration_year\n20k  |60k    |2012\n22k  |50k    |2011\n23k  |90k    |2015\n16k  |210k   |2010\n\nWe want the vehicle with the lowest price,\nlowest mileage but newest registration year.\nThus the weights for each column are as follows:\n[0, 0, 1]\n\"\"\"\n\n\ndef get_data(source_data: list[list[float]]) -> list[list[float]]:\n    \"\"\"\n    >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])\n    [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]\n    \"\"\"\n    data_lists: list[list[float]] = []\n    for data in source_data:\n        for i, el in enumerate(data):\n            if len(data_lists) < i + 1:\n                data_lists.append([])\n            data_lists[i].append(float(el))\n    return data_lists\n\n\ndef calculate_each_score(\n    data_lists: list[list[float]], weights: list[int]\n) -> list[list[float]]:\n    \"\"\"\n    >>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]],\n    ...                      [0, 0, 1])\n    [[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]\n    \"\"\"\n    score_lists: list[list[float]] = []\n    for dlist, weight in zip(data_lists, weights):\n        mind = min(dlist)\n        maxd = max(dlist)\n\n        score: list[float] = []\n        # for weight 0 score is 1 - actual score\n        if weight == 0:\n            for item in dlist:\n                try:\n                    score.append(1 - ((item - mind) / (maxd - mind)))\n                except ZeroDivisionError:\n                    score.append(1)\n\n        elif weight == 1:\n            for item in dlist:\n                try:\n                    score.append((item - mind) / (maxd - mind))\n                except ZeroDivisionError:\n                    score.append(0)\n\n        # weight not 0 or 1\n        else:\n            msg = f\"Invalid weight of {weight:f} provided\"\n            raise ValueError(msg)\n\n        score_lists.append(score)\n\n    return score_lists\n\n\ndef generate_final_scores(score_lists: list[list[float]]) -> list[float]:\n    \"\"\"\n    >>> generate_final_scores([[1.0, 0.0, 0.33333333333333337],\n    ...                        [0.75, 0.0, 1.0],\n    ...                        [0.25, 1.0, 0.0]])\n    [2.0, 1.0, 1.3333333333333335]\n    \"\"\"\n    # initialize final scores\n    final_scores: list[float] = [0 for i in range(len(score_lists[0]))]\n\n    for slist in score_lists:\n        for j, ele in enumerate(slist):\n            final_scores[j] = final_scores[j] + ele\n\n    return final_scores\n\n\ndef procentual_proximity(\n    source_data: list[list[float]], weights: list[int]\n) -> list[list[float]]:\n    \"\"\"\n    weights - int list\n    possible values - 0 / 1\n    0 if lower values have higher weight in the data set\n    1 if higher values have higher weight in the data set\n\n    >>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])\n    [[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]\n    \"\"\"\n\n    data_lists = get_data(source_data)\n    score_lists = calculate_each_score(data_lists, weights)\n    final_scores = generate_final_scores(score_lists)\n\n    # append scores to source data\n    for i, ele in enumerate(final_scores):\n        source_data[i].append(ele)\n\n    return source_data\n", "other/sdes.py": "def apply_table(inp, table):\n    \"\"\"\n    >>> apply_table(\"0123456789\", list(range(10)))\n    '9012345678'\n    >>> apply_table(\"0123456789\", list(range(9, -1, -1)))\n    '8765432109'\n    \"\"\"\n    res = \"\"\n    for i in table:\n        res += inp[i - 1]\n    return res\n\n\ndef left_shift(data):\n    \"\"\"\n    >>> left_shift(\"0123456789\")\n    '1234567890'\n    \"\"\"\n    return data[1:] + data[0]\n\n\ndef xor(a, b):\n    \"\"\"\n    >>> xor(\"01010101\", \"00001111\")\n    '01011010'\n    \"\"\"\n    res = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res += \"0\"\n        else:\n            res += \"1\"\n    return res\n\n\ndef apply_sbox(s, data):\n    row = int(\"0b\" + data[0] + data[-1], 2)\n    col = int(\"0b\" + data[1:3], 2)\n    return bin(s[row][col])[2:]\n\n\ndef function(expansion, s0, s1, key, message):\n    left = message[:4]\n    right = message[4:]\n    temp = apply_table(right, expansion)\n    temp = xor(temp, key)\n    left_bin_str = apply_sbox(s0, temp[:4])\n    right_bin_str = apply_sbox(s1, temp[4:])\n    left_bin_str = \"0\" * (2 - len(left_bin_str)) + left_bin_str\n    right_bin_str = \"0\" * (2 - len(right_bin_str)) + right_bin_str\n    temp = apply_table(left_bin_str + right_bin_str, p4_table)\n    temp = xor(left, temp)\n    return temp + right\n\n\nif __name__ == \"__main__\":\n    key = input(\"Enter 10 bit key: \")\n    message = input(\"Enter 8 bit message: \")\n\n    p8_table = [6, 3, 7, 4, 8, 5, 10, 9]\n    p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]\n    p4_table = [2, 4, 3, 1]\n    IP = [2, 6, 3, 1, 4, 8, 5, 7]\n    IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]\n    expansion = [4, 1, 2, 3, 2, 3, 4, 1]\n    s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]\n    s1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]\n\n    # key generation\n    temp = apply_table(key, p10_table)\n    left = temp[:5]\n    right = temp[5:]\n    left = left_shift(left)\n    right = left_shift(right)\n    key1 = apply_table(left + right, p8_table)\n    left = left_shift(left)\n    right = left_shift(right)\n    left = left_shift(left)\n    right = left_shift(right)\n    key2 = apply_table(left + right, p8_table)\n\n    # encryption\n    temp = apply_table(message, IP)\n    temp = function(expansion, s0, s1, key1, temp)\n    temp = temp[4:] + temp[:4]\n    temp = function(expansion, s0, s1, key2, temp)\n    CT = apply_table(temp, IP_inv)\n    print(\"Cipher text is:\", CT)\n\n    # decryption\n    temp = apply_table(CT, IP)\n    temp = function(expansion, s0, s1, key2, temp)\n    temp = temp[4:] + temp[:4]\n    temp = function(expansion, s0, s1, key1, temp)\n    PT = apply_table(temp, IP_inv)\n    print(\"Plain text after decypting is:\", PT)\n", "other/maximum_subsequence.py": "from collections.abc import Sequence\n\n\ndef max_subsequence_sum(nums: Sequence[int] | None = None) -> int:\n    \"\"\"Return the maximum possible sum amongst all non - empty subsequences.\n\n    Raises:\n      ValueError: when nums is empty.\n\n    >>> max_subsequence_sum([1,2,3,4,-2])\n    10\n    >>> max_subsequence_sum([-2, -3, -1, -4, -6])\n    -1\n    >>> max_subsequence_sum([])\n    Traceback (most recent call last):\n        . . .\n    ValueError: Input sequence should not be empty\n    >>> max_subsequence_sum()\n    Traceback (most recent call last):\n        . . .\n    ValueError: Input sequence should not be empty\n    \"\"\"\n    if nums is None or not nums:\n        raise ValueError(\"Input sequence should not be empty\")\n\n    ans = nums[0]\n    for i in range(1, len(nums)):\n        num = nums[i]\n        ans = max(ans, ans + num, num)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    # Try on a sample input from the user\n    n = int(input(\"Enter number of elements : \").strip())\n    array = list(map(int, input(\"\\nEnter the numbers : \").strip().split()))[:n]\n    print(max_subsequence_sum(array))\n", "other/number_container_system.py": "\"\"\"\nA number container system that uses binary search to delete and insert values into\narrays with O(log n) write times and O(1) read times.\n\nThis container system holds integers at indexes.\n\nFurther explained in this leetcode problem\n> https://leetcode.com/problems/minimum-cost-tree-from-leaf-values\n\"\"\"\n\n\nclass NumberContainer:\n    def __init__(self) -> None:\n        # numbermap keys are the number and its values are lists of indexes sorted\n        # in ascending order\n        self.numbermap: dict[int, list[int]] = {}\n        # indexmap keys are an index and it's values are the number at that index\n        self.indexmap: dict[int, int] = {}\n\n    def binary_search_delete(self, array: list | str | range, item: int) -> list[int]:\n        \"\"\"\n        Removes the item from the sorted array and returns\n        the new array.\n\n        >>> NumberContainer().binary_search_delete([1,2,3], 2)\n        [1, 3]\n        >>> NumberContainer().binary_search_delete([0, 0, 0], 0)\n        [0, 0]\n        >>> NumberContainer().binary_search_delete([-1, -1, -1], -1)\n        [-1, -1]\n        >>> NumberContainer().binary_search_delete([-1, 0], 0)\n        [-1]\n        >>> NumberContainer().binary_search_delete([-1, 0], -1)\n        [0]\n        >>> NumberContainer().binary_search_delete(range(7), 3)\n        [0, 1, 2, 4, 5, 6]\n        >>> NumberContainer().binary_search_delete([1.1, 2.2, 3.3], 2.2)\n        [1.1, 3.3]\n        >>> NumberContainer().binary_search_delete(\"abcde\", \"c\")\n        ['a', 'b', 'd', 'e']\n        >>> NumberContainer().binary_search_delete([0, -1, 2, 4], 0)\n        Traceback (most recent call last):\n            ...\n        ValueError: Either the item is not in the array or the array was unsorted\n        >>> NumberContainer().binary_search_delete([2, 0, 4, -1, 11], -1)\n        Traceback (most recent call last):\n            ...\n        ValueError: Either the item is not in the array or the array was unsorted\n        >>> NumberContainer().binary_search_delete(125, 1)\n        Traceback (most recent call last):\n            ...\n        TypeError: binary_search_delete() only accepts either a list, range or str\n        \"\"\"\n        if isinstance(array, (range, str)):\n            array = list(array)\n        elif not isinstance(array, list):\n            raise TypeError(\n                \"binary_search_delete() only accepts either a list, range or str\"\n            )\n\n        low = 0\n        high = len(array) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if array[mid] == item:\n                array.pop(mid)\n                return array\n            elif array[mid] < item:\n                low = mid + 1\n            else:\n                high = mid - 1\n        raise ValueError(\n            \"Either the item is not in the array or the array was unsorted\"\n        )\n\n    def binary_search_insert(self, array: list | str | range, index: int) -> list[int]:\n        \"\"\"\n        Inserts the index into the sorted array\n        at the correct position.\n\n        >>> NumberContainer().binary_search_insert([1,2,3], 2)\n        [1, 2, 2, 3]\n        >>> NumberContainer().binary_search_insert([0,1,3], 2)\n        [0, 1, 2, 3]\n        >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 103], 51)\n        [-5, -3, 0, 0, 11, 51, 103]\n        >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 100, 103], 101)\n        [-5, -3, 0, 0, 11, 100, 101, 103]\n        >>> NumberContainer().binary_search_insert(range(10), 4)\n        [0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9]\n        >>> NumberContainer().binary_search_insert(\"abd\", \"c\")\n        ['a', 'b', 'c', 'd']\n        >>> NumberContainer().binary_search_insert(131, 23)\n        Traceback (most recent call last):\n            ...\n        TypeError: binary_search_insert() only accepts either a list, range or str\n        \"\"\"\n        if isinstance(array, (range, str)):\n            array = list(array)\n        elif not isinstance(array, list):\n            raise TypeError(\n                \"binary_search_insert() only accepts either a list, range or str\"\n            )\n\n        low = 0\n        high = len(array) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if array[mid] == index:\n                # If the item already exists in the array,\n                # insert it after the existing item\n                array.insert(mid + 1, index)\n                return array\n            elif array[mid] < index:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        # If the item doesn't exist in the array, insert it at the appropriate position\n        array.insert(low, index)\n        return array\n\n    def change(self, index: int, number: int) -> None:\n        \"\"\"\n        Changes (sets) the index as number\n\n        >>> cont = NumberContainer()\n        >>> cont.change(0, 10)\n        >>> cont.change(0, 20)\n        >>> cont.change(-13, 20)\n        >>> cont.change(-100030, 20032903290)\n        \"\"\"\n        # Remove previous index\n        if index in self.indexmap:\n            n = self.indexmap[index]\n            if len(self.numbermap[n]) == 1:\n                del self.numbermap[n]\n            else:\n                self.numbermap[n] = self.binary_search_delete(self.numbermap[n], index)\n\n        # Set new index\n        self.indexmap[index] = number\n\n        # Number not seen before or empty so insert number value\n        if number not in self.numbermap:\n            self.numbermap[number] = [index]\n\n        # Here we need to perform a binary search insertion in order to insert\n        # The item in the correct place\n        else:\n            self.numbermap[number] = self.binary_search_insert(\n                self.numbermap[number], index\n            )\n\n    def find(self, number: int) -> int:\n        \"\"\"\n        Returns the smallest index where the number is.\n\n        >>> cont = NumberContainer()\n        >>> cont.find(10)\n        -1\n        >>> cont.change(0, 10)\n        >>> cont.find(10)\n        0\n        >>> cont.change(0, 20)\n        >>> cont.find(10)\n        -1\n        >>> cont.find(20)\n        0\n        \"\"\"\n        # Simply return the 0th index (smallest) of the indexes found (or -1)\n        return self.numbermap.get(number, [-1])[0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/quine.py": "#!/bin/python3\n# ruff: noqa\n\"\"\"\nQuine:\n\nA quine is a computer program which takes no input and produces a copy of its\nown source code as its only output (disregarding this docstring and the shebang).\n\nMore info on: https://en.wikipedia.org/wiki/Quine_(computing)\n\"\"\"\n\nprint((lambda quine: quine % quine)(\"print((lambda quine: quine %% quine)(%r))\"))\n", "other/davis_putnam_logemann_loveland.py": "#!/usr/bin/env python3\n\n\"\"\"\nDavis-Putnam-Logemann-Loveland (DPLL) algorithm is a complete, backtracking-based\nsearch algorithm for deciding the satisfiability of propositional logic formulae in\nconjunctive normal form, i.e, for solving the Conjunctive Normal Form SATisfiability\n(CNF-SAT) problem.\n\nFor more information about the algorithm: https://en.wikipedia.org/wiki/DPLL_algorithm\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\nfrom collections.abc import Iterable\n\n\nclass Clause:\n    \"\"\"\n    A clause represented in Conjunctive Normal Form.\n    A clause is a set of literals, either complemented or otherwise.\n    For example:\n        {A1, A2, A3'} is the clause (A1 v A2 v A3')\n        {A5', A2', A1} is the clause (A5' v A2' v A1)\n\n    Create model\n    >>> clause = Clause([\"A1\", \"A2'\", \"A3\"])\n    >>> clause.evaluate({\"A1\": True})\n    True\n    \"\"\"\n\n    def __init__(self, literals: list[str]) -> None:\n        \"\"\"\n        Represent the literals and an assignment in a clause.\"\n        \"\"\"\n        # Assign all literals to None initially\n        self.literals: dict[str, bool | None] = {literal: None for literal in literals}\n\n    def __str__(self) -> str:\n        \"\"\"\n        To print a clause as in Conjunctive Normal Form.\n        >>> str(Clause([\"A1\", \"A2'\", \"A3\"]))\n        \"{A1 , A2' , A3}\"\n        \"\"\"\n        return \"{\" + \" , \".join(self.literals) + \"}\"\n\n    def __len__(self) -> int:\n        \"\"\"\n        To print a clause as in Conjunctive Normal Form.\n        >>> len(Clause([]))\n        0\n        >>> len(Clause([\"A1\", \"A2'\", \"A3\"]))\n        3\n        \"\"\"\n        return len(self.literals)\n\n    def assign(self, model: dict[str, bool | None]) -> None:\n        \"\"\"\n        Assign values to literals of the clause as given by model.\n        \"\"\"\n        for literal in self.literals:\n            symbol = literal[:2]\n            if symbol in model:\n                value = model[symbol]\n            else:\n                continue\n            # Complement assignment if literal is in complemented form\n            if value is not None and literal.endswith(\"'\"):\n                value = not value\n            self.literals[literal] = value\n\n    def evaluate(self, model: dict[str, bool | None]) -> bool | None:\n        \"\"\"\n        Evaluates the clause with the assignments in model.\n        This has the following steps:\n        1. Return True if both a literal and its complement exist in the clause.\n        2. Return True if a single literal has the assignment True.\n        3. Return None(unable to complete evaluation) if a literal has no assignment.\n        4. Compute disjunction of all values assigned in clause.\n        \"\"\"\n        for literal in self.literals:\n            symbol = literal.rstrip(\"'\") if literal.endswith(\"'\") else literal + \"'\"\n            if symbol in self.literals:\n                return True\n\n        self.assign(model)\n        for value in self.literals.values():\n            if value in (True, None):\n                return value\n        return any(self.literals.values())\n\n\nclass Formula:\n    \"\"\"\n    A formula represented in Conjunctive Normal Form.\n    A formula is a set of clauses.\n    For example,\n        {{A1, A2, A3'}, {A5', A2', A1}} is ((A1 v A2 v A3') and (A5' v A2' v A1))\n    \"\"\"\n\n    def __init__(self, clauses: Iterable[Clause]) -> None:\n        \"\"\"\n        Represent the number of clauses and the clauses themselves.\n        \"\"\"\n        self.clauses = list(clauses)\n\n    def __str__(self) -> str:\n        \"\"\"\n        To print a formula as in Conjunctive Normal Form.\n        str(Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])]))\n        \"{{A1 , A2' , A3} , {A5' , A2' , A1}}\"\n        \"\"\"\n        return \"{\" + \" , \".join(str(clause) for clause in self.clauses) + \"}\"\n\n\ndef generate_clause() -> Clause:\n    \"\"\"\n    Randomly generate a clause.\n    All literals have the name Ax, where x is an integer from 1 to 5.\n    \"\"\"\n    literals = []\n    no_of_literals = random.randint(1, 5)\n    base_var = \"A\"\n    i = 0\n    while i < no_of_literals:\n        var_no = random.randint(1, 5)\n        var_name = base_var + str(var_no)\n        var_complement = random.randint(0, 1)\n        if var_complement == 1:\n            var_name += \"'\"\n        if var_name in literals:\n            i -= 1\n        else:\n            literals.append(var_name)\n        i += 1\n    return Clause(literals)\n\n\ndef generate_formula() -> Formula:\n    \"\"\"\n    Randomly generate a formula.\n    \"\"\"\n    clauses: set[Clause] = set()\n    no_of_clauses = random.randint(1, 10)\n    while len(clauses) < no_of_clauses:\n        clauses.add(generate_clause())\n    return Formula(clauses)\n\n\ndef generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:\n    \"\"\"\n    Return the clauses and symbols from a formula.\n    A symbol is the uncomplemented form of a literal.\n    For example,\n        Symbol of A3 is A3.\n        Symbol of A5' is A5.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n    >>> clauses_list = [str(i) for i in clauses]\n    >>> clauses_list\n    [\"{A1 , A2' , A3}\", \"{A5' , A2' , A1}\"]\n    >>> symbols\n    ['A1', 'A2', 'A3', 'A5']\n    \"\"\"\n    clauses = formula.clauses\n    symbols_set = []\n    for clause in formula.clauses:\n        for literal in clause.literals:\n            symbol = literal[:2]\n            if symbol not in symbols_set:\n                symbols_set.append(symbol)\n    return clauses, symbols_set\n\n\ndef find_pure_symbols(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    Return pure symbols and their values to satisfy clause.\n    Pure symbols are symbols in a formula that exist only\n    in one form, either complemented or otherwise.\n    For example,\n        { { A4 , A3 , A5' , A1 , A3' } , { A4 } , { A3 } } has\n        pure symbols A4, A5' and A1.\n    This has the following steps:\n    1. Ignore clauses that have already evaluated to be True.\n    2. Find symbols that occur only in one form in the rest of the clauses.\n    3. Assign value True or False depending on whether the symbols occurs\n    in normal or complemented form respectively.\n\n    >>> formula = Formula([Clause([\"A1\", \"A2'\", \"A3\"]), Clause([\"A5'\", \"A2'\", \"A1\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n\n    >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})\n    >>> pure_symbols\n    ['A1', 'A2', 'A3', 'A5']\n    >>> values\n    {'A1': True, 'A2': False, 'A3': True, 'A5': False}\n    \"\"\"\n    pure_symbols = []\n    assignment: dict[str, bool | None] = {}\n    literals = []\n\n    for clause in clauses:\n        if clause.evaluate(model):\n            continue\n        for literal in clause.literals:\n            literals.append(literal)\n\n    for s in symbols:\n        sym = s + \"'\"\n        if (s in literals and sym not in literals) or (\n            s not in literals and sym in literals\n        ):\n            pure_symbols.append(s)\n    for p in pure_symbols:\n        assignment[p] = None\n    for s in pure_symbols:\n        sym = s + \"'\"\n        if s in literals:\n            assignment[s] = True\n        elif sym in literals:\n            assignment[s] = False\n    return pure_symbols, assignment\n\n\ndef find_unit_clauses(\n    clauses: list[Clause],\n    model: dict[str, bool | None],  # noqa: ARG001\n) -> tuple[list[str], dict[str, bool | None]]:\n    \"\"\"\n    Returns the unit symbols and their values to satisfy clause.\n    Unit symbols are symbols in a formula that are:\n    - Either the only symbol in a clause\n    - Or all other literals in that clause have been assigned False\n    This has the following steps:\n    1. Find symbols that are the only occurrences in a clause.\n    2. Find symbols in a clause where all other literals are assigned False.\n    3. Assign True or False depending on whether the symbols occurs in\n    normal or complemented form respectively.\n\n    >>> clause1 = Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"])\n    >>> clause2 = Clause([\"A4\"])\n    >>> clause3 = Clause([\"A3\"])\n    >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))\n\n    >>> unit_clauses, values = find_unit_clauses(clauses, {})\n    >>> unit_clauses\n    ['A4', 'A3']\n    >>> values\n    {'A4': True, 'A3': True}\n    \"\"\"\n    unit_symbols = []\n    for clause in clauses:\n        if len(clause) == 1:\n            unit_symbols.append(next(iter(clause.literals.keys())))\n        else:\n            f_count, n_count = 0, 0\n            for literal, value in clause.literals.items():\n                if value is False:\n                    f_count += 1\n                elif value is None:\n                    sym = literal\n                    n_count += 1\n            if f_count == len(clause) - 1 and n_count == 1:\n                unit_symbols.append(sym)\n    assignment: dict[str, bool | None] = {}\n    for i in unit_symbols:\n        symbol = i[:2]\n        assignment[symbol] = len(i) == 2\n    unit_symbols = [i[:2] for i in unit_symbols]\n\n    return unit_symbols, assignment\n\n\ndef dpll_algorithm(\n    clauses: list[Clause], symbols: list[str], model: dict[str, bool | None]\n) -> tuple[bool | None, dict[str, bool | None] | None]:\n    \"\"\"\n    Returns the model if the formula is satisfiable, else None\n    This has the following steps:\n    1. If every clause in clauses is True, return True.\n    2. If some clause in clauses is False, return False.\n    3. Find pure symbols.\n    4. Find unit symbols.\n\n    >>> formula = Formula([Clause([\"A4\", \"A3\", \"A5'\", \"A1\", \"A3'\"]), Clause([\"A4\"])])\n    >>> clauses, symbols = generate_parameters(formula)\n\n    >>> soln, model = dpll_algorithm(clauses, symbols, {})\n    >>> soln\n    True\n    >>> model\n    {'A4': True}\n    \"\"\"\n    check_clause_all_true = True\n    for clause in clauses:\n        clause_check = clause.evaluate(model)\n        if clause_check is False:\n            return False, None\n        elif clause_check is None:\n            check_clause_all_true = False\n            continue\n\n    if check_clause_all_true:\n        return True, model\n\n    try:\n        pure_symbols, assignment = find_pure_symbols(clauses, symbols, model)\n    except RecursionError:\n        print(\"raises a RecursionError and is\")\n        return None, {}\n    p = None\n    if len(pure_symbols) > 0:\n        p, value = pure_symbols[0], assignment[pure_symbols[0]]\n\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n\n    unit_symbols, assignment = find_unit_clauses(clauses, model)\n    p = None\n    if len(unit_symbols) > 0:\n        p, value = unit_symbols[0], assignment[unit_symbols[0]]\n    if p:\n        tmp_model = model\n        tmp_model[p] = value\n        tmp_symbols = list(symbols)\n        if p in tmp_symbols:\n            tmp_symbols.remove(p)\n        return dpll_algorithm(clauses, tmp_symbols, tmp_model)\n    p = symbols[0]\n    rest = symbols[1:]\n    tmp1, tmp2 = model, model\n    tmp1[p], tmp2[p] = True, False\n\n    return dpll_algorithm(clauses, rest, tmp1) or dpll_algorithm(clauses, rest, tmp2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    formula = generate_formula()\n    print(f\"The formula {formula} is\", end=\" \")\n\n    clauses, symbols = generate_parameters(formula)\n    solution, model = dpll_algorithm(clauses, symbols, {})\n\n    if solution:\n        print(f\"satisfiable with the assignment {model}.\")\n    else:\n        print(\"not satisfiable.\")\n", "other/password.py": "import secrets\nfrom random import shuffle\nfrom string import ascii_letters, ascii_lowercase, ascii_uppercase, digits, punctuation\n\n\ndef password_generator(length: int = 8) -> str:\n    \"\"\"\n    Password Generator allows you to generate a random password of length N.\n\n    >>> len(password_generator())\n    8\n    >>> len(password_generator(length=16))\n    16\n    >>> len(password_generator(257))\n    257\n    >>> len(password_generator(length=0))\n    0\n    >>> len(password_generator(-1))\n    0\n    \"\"\"\n    chars = ascii_letters + digits + punctuation\n    return \"\".join(secrets.choice(chars) for _ in range(length))\n\n\n# ALTERNATIVE METHODS\n# chars_incl= characters that must be in password\n# i= how many letters or characters the password length will be\ndef alternative_password_generator(chars_incl: str, i: int) -> str:\n    # Password Generator = full boot with random_number, random_letters, and\n    # random_character FUNCTIONS\n    # Put your code here...\n    i -= len(chars_incl)\n    quotient = i // 3\n    remainder = i % 3\n    # chars = chars_incl + random_letters(ascii_letters, i / 3 + remainder) +\n    #     random_number(digits, i / 3) + random_characters(punctuation, i / 3)\n    chars = (\n        chars_incl\n        + random(ascii_letters, quotient + remainder)\n        + random(digits, quotient)\n        + random(punctuation, quotient)\n    )\n    list_of_chars = list(chars)\n    shuffle(list_of_chars)\n    return \"\".join(list_of_chars)\n\n    # random is a generalised function for letters, characters and numbers\n\n\ndef random(chars_incl: str, i: int) -> str:\n    return \"\".join(secrets.choice(chars_incl) for _ in range(i))\n\n\ndef is_strong_password(password: str, min_length: int = 8) -> bool:\n    \"\"\"\n    This will check whether a given password is strong or not. The password must be at\n    least as long as the provided minimum length, and it must contain at least 1\n    lowercase letter, 1 uppercase letter, 1 number and 1 special character.\n\n    >>> is_strong_password('Hwea7$2!')\n    True\n    >>> is_strong_password('Sh0r1')\n    False\n    >>> is_strong_password('Hello123')\n    False\n    >>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')\n    True\n    >>> is_strong_password('0')\n    False\n    \"\"\"\n\n    if len(password) < min_length:\n        return False\n\n    upper = any(char in ascii_uppercase for char in password)\n    lower = any(char in ascii_lowercase for char in password)\n    num = any(char in digits for char in password)\n    spec_char = any(char in punctuation for char in password)\n\n    return upper and lower and num and spec_char\n\n\ndef main():\n    length = int(input(\"Please indicate the max length of your password: \").strip())\n    chars_incl = input(\n        \"Please indicate the characters that must be in your password: \"\n    ).strip()\n    print(\"Password generated:\", password_generator(length))\n    print(\n        \"Alternative Password generated:\",\n        alternative_password_generator(chars_incl, length),\n    )\n    print(\"[If you are thinking of using this password, You better save it.]\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "other/nested_brackets.py": "\"\"\"\nThe nested brackets problem is a problem that determines if a sequence of\nbrackets are properly nested.  A sequence of brackets s is considered properly nested\nif any of the following conditions are true:\n\n    - s is empty\n    - s has the form (U) or [U] or {U} where U is a properly nested string\n    - s has the form VW where V and W are properly nested strings\n\nFor example, the string \"()()[()]\" is properly nested but \"[(()]\" is not.\n\nThe function called is_balanced takes as input a string S which is a sequence of\nbrackets and returns true if S is nested and false otherwise.\n\"\"\"\n\n\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    >>> is_balanced(\"\")\n    True\n    >>> is_balanced(\"()\")\n    True\n    >>> is_balanced(\"[]\")\n    True\n    >>> is_balanced(\"{}\")\n    True\n    >>> is_balanced(\"()[]{}\")\n    True\n    >>> is_balanced(\"(())\")\n    True\n    >>> is_balanced(\"[[\")\n    False\n    >>> is_balanced(\"([{}])\")\n    True\n    >>> is_balanced(\"(()[)]\")\n    False\n    >>> is_balanced(\"([)]\")\n    False\n    >>> is_balanced(\"[[()]]\")\n    True\n    >>> is_balanced(\"(()(()))\")\n    True\n    >>> is_balanced(\"]\")\n    False\n    >>> is_balanced(\"Life is a bowl of cherries.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che{}ies.\")\n    True\n    >>> is_balanced(\"Life is a bowl of che}{ies.\")\n    False\n    \"\"\"\n    open_to_closed = {\"{\": \"}\", \"[\": \"]\", \"(\": \")\"}\n    stack = []\n    for symbol in s:\n        if symbol in open_to_closed:\n            stack.append(symbol)\n        elif symbol in open_to_closed.values() and (\n            not stack or open_to_closed[stack.pop()] != symbol\n        ):\n            return False\n    return not stack  # stack should be empty\n\n\ndef main():\n    s = input(\"Enter sequence of brackets: \")\n    print(f\"'{s}' is {'' if is_balanced(s) else 'not '}balanced.\")\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()\n    main()\n", "other/lfu_cache.py": "from __future__ import annotations\n\nfrom collections.abc import Callable\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\nU = TypeVar(\"U\")\n\n\nclass DoubleLinkedListNode(Generic[T, U]):\n    \"\"\"\n    Double Linked List Node built specifically for LFU Cache\n\n    >>> node = DoubleLinkedListNode(1,1)\n    >>> node\n    Node: key: 1, val: 1, freq: 0, has next: False, has prev: False\n    \"\"\"\n\n    def __init__(self, key: T | None, val: U | None):\n        self.key = key\n        self.val = val\n        self.freq: int = 0\n        self.next: DoubleLinkedListNode[T, U] | None = None\n        self.prev: DoubleLinkedListNode[T, U] | None = None\n\n    def __repr__(self) -> str:\n        return (\n            f\"Node: key: {self.key}, val: {self.val}, freq: {self.freq}, \"\n            f\"has next: {self.next is not None}, has prev: {self.prev is not None}\"\n        )\n\n\nclass DoubleLinkedList(Generic[T, U]):\n    \"\"\"\n    Double Linked List built specifically for LFU Cache\n\n    >>> dll: DoubleLinkedList = DoubleLinkedList()\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\n\n    >>> first_node = DoubleLinkedListNode(1,10)\n    >>> first_node\n    Node: key: 1, val: 10, freq: 0, has next: False, has prev: False\n\n\n    >>> dll.add(first_node)\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\n        Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\n\n    >>> # node is mutated\n    >>> first_node\n    Node: key: 1, val: 10, freq: 1, has next: True, has prev: True\n\n    >>> second_node = DoubleLinkedListNode(2,20)\n    >>> second_node\n    Node: key: 2, val: 20, freq: 0, has next: False, has prev: False\n\n    >>> dll.add(second_node)\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\n        Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,\n        Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\n\n    >>> removed_node = dll.remove(first_node)\n    >>> assert removed_node == first_node\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, freq: 0, has next: True, has prev: False,\n        Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,\n        Node: key: None, val: None, freq: 0, has next: False, has prev: True\n\n\n    >>> # Attempt to remove node not on list\n    >>> removed_node = dll.remove(first_node)\n    >>> removed_node is None\n    True\n\n    >>> # Attempt to remove head or rear\n    >>> dll.head\n    Node: key: None, val: None, freq: 0, has next: True, has prev: False\n    >>> dll.remove(dll.head) is None\n    True\n\n    >>> # Attempt to remove head or rear\n    >>> dll.rear\n    Node: key: None, val: None, freq: 0, has next: False, has prev: True\n    >>> dll.remove(dll.rear) is None\n    True\n\n\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\n        self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\n        self.head.next, self.rear.prev = self.rear, self.head\n\n    def __repr__(self) -> str:\n        rep = [\"DoubleLinkedList\"]\n        node = self.head\n        while node.next is not None:\n            rep.append(str(node))\n            node = node.next\n        rep.append(str(self.rear))\n        return \",\\n    \".join(rep)\n\n    def add(self, node: DoubleLinkedListNode[T, U]) -> None:\n        \"\"\"\n        Adds the given node at the tail of the list and shifting it to proper position\n        \"\"\"\n\n        previous = self.rear.prev\n\n        # All nodes other than self.head are guaranteed to have non-None previous\n        assert previous is not None\n\n        previous.next = node\n        node.prev = previous\n        self.rear.prev = node\n        node.next = self.rear\n        node.freq += 1\n        self._position_node(node)\n\n    def _position_node(self, node: DoubleLinkedListNode[T, U]) -> None:\n        \"\"\"\n        Moves node forward to maintain invariant of sort by freq value\n        \"\"\"\n\n        while node.prev is not None and node.prev.freq > node.freq:\n            # swap node with previous node\n            previous_node = node.prev\n\n            node.prev = previous_node.prev\n            previous_node.next = node.prev\n            node.next = previous_node\n            previous_node.prev = node\n\n    def remove(\n        self, node: DoubleLinkedListNode[T, U]\n    ) -> DoubleLinkedListNode[T, U] | None:\n        \"\"\"\n        Removes and returns the given node from the list\n\n        Returns None if node.prev or node.next is None\n        \"\"\"\n\n        if node.prev is None or node.next is None:\n            return None\n\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n        return node\n\n\nclass LFUCache(Generic[T, U]):\n    \"\"\"\n    LFU Cache to store a given capacity of data. Can be used as a stand-alone object\n    or as a function decorator.\n\n    >>> cache = LFUCache(2)\n    >>> cache.put(1, 1)\n    >>> cache.put(2, 2)\n    >>> cache.get(1)\n    1\n    >>> cache.put(3, 3)\n    >>> cache.get(2) is None\n    True\n    >>> cache.put(4, 4)\n    >>> cache.get(1) is None\n    True\n    >>> cache.get(3)\n    3\n    >>> cache.get(4)\n    4\n    >>> cache\n    CacheInfo(hits=3, misses=2, capacity=2, current_size=2)\n    >>> @LFUCache.decorator(100)\n    ... def fib(num):\n    ...     if num in (1, 2):\n    ...         return 1\n    ...     return fib(num - 1) + fib(num - 2)\n\n    >>> for i in range(1, 101):\n    ...     res = fib(i)\n\n    >>> fib.cache_info()\n    CacheInfo(hits=196, misses=100, capacity=100, current_size=100)\n    \"\"\"\n\n    # class variable to map the decorator functions to their respective instance\n    decorator_function_to_instance_map: dict[Callable[[T], U], LFUCache[T, U]] = {}\n\n    def __init__(self, capacity: int):\n        self.list: DoubleLinkedList[T, U] = DoubleLinkedList()\n        self.capacity = capacity\n        self.num_keys = 0\n        self.hits = 0\n        self.miss = 0\n        self.cache: dict[T, DoubleLinkedListNode[T, U]] = {}\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return the details for the cache instance\n        [hits, misses, capacity, current_size]\n        \"\"\"\n\n        return (\n            f\"CacheInfo(hits={self.hits}, misses={self.miss}, \"\n            f\"capacity={self.capacity}, current_size={self.num_keys})\"\n        )\n\n    def __contains__(self, key: T) -> bool:\n        \"\"\"\n        >>> cache = LFUCache(1)\n\n        >>> 1 in cache\n        False\n\n        >>> cache.put(1, 1)\n        >>> 1 in cache\n        True\n        \"\"\"\n\n        return key in self.cache\n\n    def get(self, key: T) -> U | None:\n        \"\"\"\n        Returns the value for the input key and updates the Double Linked List. Returns\n        Returns None if key is not present in cache\n        \"\"\"\n\n        if key in self.cache:\n            self.hits += 1\n            value_node: DoubleLinkedListNode[T, U] = self.cache[key]\n            node = self.list.remove(self.cache[key])\n            assert node == value_node\n\n            # node is guaranteed not None because it is in self.cache\n            assert node is not None\n            self.list.add(node)\n            return node.val\n        self.miss += 1\n        return None\n\n    def put(self, key: T, value: U) -> None:\n        \"\"\"\n        Sets the value for the input key and updates the Double Linked List\n        \"\"\"\n\n        if key not in self.cache:\n            if self.num_keys >= self.capacity:\n                # delete first node when over capacity\n                first_node = self.list.head.next\n\n                # guaranteed to have a non-None first node when num_keys > 0\n                # explain to type checker via assertions\n                assert first_node is not None\n                assert first_node.key is not None\n                assert self.list.remove(first_node) is not None\n                # first_node guaranteed to be in list\n\n                del self.cache[first_node.key]\n                self.num_keys -= 1\n            self.cache[key] = DoubleLinkedListNode(key, value)\n            self.list.add(self.cache[key])\n            self.num_keys += 1\n\n        else:\n            node = self.list.remove(self.cache[key])\n            assert node is not None  # node guaranteed to be in list\n            node.val = value\n            self.list.add(node)\n\n    @classmethod\n    def decorator(\n        cls: type[LFUCache[T, U]], size: int = 128\n    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:\n        \"\"\"\n        Decorator version of LFU Cache\n\n        Decorated function must be function of T -> U\n        \"\"\"\n\n        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:\n            def cache_decorator_wrapper(*args: T) -> U:\n                if func not in cls.decorator_function_to_instance_map:\n                    cls.decorator_function_to_instance_map[func] = LFUCache(size)\n\n                result = cls.decorator_function_to_instance_map[func].get(args[0])\n                if result is None:\n                    result = func(*args)\n                    cls.decorator_function_to_instance_map[func].put(args[0], result)\n                return result\n\n            def cache_info() -> LFUCache[T, U]:\n                return cls.decorator_function_to_instance_map[func]\n\n            setattr(cache_decorator_wrapper, \"cache_info\", cache_info)  # noqa: B010\n\n            return cache_decorator_wrapper\n\n        return cache_decorator_inner\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/tower_of_hanoi.py": "def move_tower(height, from_pole, to_pole, with_pole):\n    \"\"\"\n    >>> move_tower(3, 'A', 'B', 'C')\n    moving disk from A to B\n    moving disk from A to C\n    moving disk from B to C\n    moving disk from A to B\n    moving disk from C to A\n    moving disk from C to B\n    moving disk from A to B\n    \"\"\"\n    if height >= 1:\n        move_tower(height - 1, from_pole, with_pole, to_pole)\n        move_disk(from_pole, to_pole)\n        move_tower(height - 1, with_pole, to_pole, from_pole)\n\n\ndef move_disk(fp, tp):\n    print(\"moving disk from\", fp, \"to\", tp)\n\n\ndef main():\n    height = int(input(\"Height of hanoi: \").strip())\n    move_tower(height, \"A\", \"B\", \"C\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "other/magicdiamondpattern.py": "# Python program for generating diamond pattern in Python 3.7+\n\n\n# Function to print upper half of diamond (pyramid)\ndef floyd(n):\n    \"\"\"\n    Print the upper half of a diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> floyd(3)\n        '  * \\\\n * * \\\\n* * * \\\\n'\n\n        >>> floyd(5)\n        '    * \\\\n   * * \\\\n  * * * \\\\n * * * * \\\\n* * * * * \\\\n'\n    \"\"\"\n    result = \"\"\n    for i in range(n):\n        for _ in range(n - i - 1):  # printing spaces\n            result += \" \"\n        for _ in range(i + 1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n    return result\n\n\n# Function to print lower half of diamond (pyramid)\ndef reverse_floyd(n):\n    \"\"\"\n    Print the lower half of a diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> reverse_floyd(3)\n        '* * * \\\\n * * \\\\n  * \\\\n   '\n\n        >>> reverse_floyd(5)\n        '* * * * * \\\\n * * * * \\\\n  * * * \\\\n   * * \\\\n    * \\\\n     '\n    \"\"\"\n    result = \"\"\n    for i in range(n, 0, -1):\n        for _ in range(i, 0, -1):  # printing stars\n            result += \"* \"\n        result += \"\\n\"\n        for _ in range(n - i + 1, 0, -1):  # printing spaces\n            result += \" \"\n    return result\n\n\n# Function to print complete diamond pattern of \"*\"\ndef pretty_print(n):\n    \"\"\"\n    Print a complete diamond pattern with '*' characters.\n\n    Args:\n        n (int): Size of the pattern.\n\n    Examples:\n        >>> pretty_print(0)\n        '       ...       ....        nothing printing :('\n\n        >>> pretty_print(3)\n        '  * \\\\n * * \\\\n* * * \\\\n* * * \\\\n * * \\\\n  * \\\\n   '\n    \"\"\"\n    if n <= 0:\n        return \"       ...       ....        nothing printing :(\"\n    upper_half = floyd(n)  # upper half\n    lower_half = reverse_floyd(n)  # lower half\n    return upper_half + lower_half\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/fischer_yates_shuffle.py": "#!/usr/bin/python\n\"\"\"\nThe Fisher-Yates shuffle is an algorithm for generating a random permutation of a\nfinite sequence.\nFor more details visit\nwikipedia/Fischer-Yates-Shuffle.\n\"\"\"\n\nimport random\nfrom typing import Any\n\n\ndef fisher_yates_shuffle(data: list) -> list[Any]:\n    for _ in range(len(data)):\n        a = random.randint(0, len(data) - 1)\n        b = random.randint(0, len(data) - 1)\n        data[a], data[b] = data[b], data[a]\n    return data\n\n\nif __name__ == \"__main__\":\n    integers = [0, 1, 2, 3, 4, 5, 6, 7]\n    strings = [\"python\", \"says\", \"hello\", \"!\"]\n    print(\"Fisher-Yates Shuffle:\")\n    print(\"List\", integers, strings)\n    print(\"FY Shuffle\", fisher_yates_shuffle(integers), fisher_yates_shuffle(strings))\n", "other/linear_congruential_generator.py": "__author__ = \"Tobias Carryer\"\n\nfrom time import time\n\n\nclass LinearCongruentialGenerator:\n    \"\"\"\n    A pseudorandom number generator.\n    \"\"\"\n\n    # The default value for **seed** is the result of a function call, which is not\n    # normally recommended and causes ruff to raise a B008 error. However, in this case,\n    # it is acceptable because `LinearCongruentialGenerator.__init__()` will only be\n    # called once per instance and it ensures that each instance will generate a unique\n    # sequence of numbers.\n\n    def __init__(self, multiplier, increment, modulo, seed=int(time())):  # noqa: B008\n        \"\"\"\n        These parameters are saved and used when nextNumber() is called.\n\n        modulo is the largest number that can be generated (exclusive). The most\n        efficient values are powers of 2. 2^32 is a common value.\n        \"\"\"\n        self.multiplier = multiplier\n        self.increment = increment\n        self.modulo = modulo\n        self.seed = seed\n\n    def next_number(self):\n        \"\"\"\n        The smallest number that can be generated is zero.\n        The largest number that can be generated is modulo-1. modulo is set in the\n        constructor.\n        \"\"\"\n        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo\n        return self.seed\n\n\nif __name__ == \"__main__\":\n    # Show the LCG in action.\n    lcg = LinearCongruentialGenerator(1664525, 1013904223, 2 << 31)\n    while True:\n        print(lcg.next_number())\n", "other/graham_scan.py": "\"\"\"\nThis is a pure Python implementation of the Graham scan algorithm\nSource: https://en.wikipedia.org/wiki/Graham_scan\n\nFor doctests run following command:\npython3 -m doctest -v graham_scan.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import deque\nfrom enum import Enum\nfrom math import atan2, degrees\nfrom sys import maxsize\n\n\n# traversal from the lowest and the most left point in anti-clockwise direction\n# if direction gets right, the previous point is not the convex hull.\nclass Direction(Enum):\n    left = 1\n    straight = 2\n    right = 3\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}.{self.name}\"\n\n\ndef angle_comparer(point: tuple[int, int], minx: int, miny: int) -> float:\n    \"\"\"Return the angle toward to point from (minx, miny)\n\n    :param point: The target point\n           minx: The starting point's x\n           miny: The starting point's y\n    :return: the angle\n\n    Examples:\n    >>> angle_comparer((1,1), 0, 0)\n    45.0\n\n    >>> angle_comparer((100,1), 10, 10)\n    -5.710593137499642\n\n    >>> angle_comparer((5,5), 2, 3)\n    33.690067525979785\n    \"\"\"\n    # sort the points accorgind to the angle from the lowest and the most left point\n    x, y = point\n    return degrees(atan2(y - miny, x - minx))\n\n\ndef check_direction(\n    starting: tuple[int, int], via: tuple[int, int], target: tuple[int, int]\n) -> Direction:\n    \"\"\"Return the direction toward to the line from via to target from starting\n\n    :param starting: The starting point\n           via: The via point\n           target: The target point\n    :return: the Direction\n\n    Examples:\n    >>> check_direction((1,1), (2,2), (3,3))\n    Direction.straight\n\n    >>> check_direction((60,1), (-50,199), (30,2))\n    Direction.left\n\n    >>> check_direction((0,0), (5,5), (10,0))\n    Direction.right\n    \"\"\"\n    x0, y0 = starting\n    x1, y1 = via\n    x2, y2 = target\n    via_angle = degrees(atan2(y1 - y0, x1 - x0))\n    via_angle %= 360\n    target_angle = degrees(atan2(y2 - y0, x2 - x0))\n    target_angle %= 360\n    # t-\n    #  \\ \\\n    #   \\ v\n    #    \\|\n    #     s\n    # via_angle is always lower than target_angle, if direction is left.\n    # If they are same, it means they are on a same line of convex hull.\n    if target_angle > via_angle:\n        return Direction.left\n    elif target_angle == via_angle:\n        return Direction.straight\n    else:\n        return Direction.right\n\n\ndef graham_scan(points: list[tuple[int, int]]) -> list[tuple[int, int]]:\n    \"\"\"Pure implementation of graham scan algorithm in Python\n\n    :param points: The unique points on coordinates.\n    :return: The points on convex hell.\n\n    Examples:\n    >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])\n    [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]\n\n    >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])\n    [(0, 0), (1, 0), (1, 1), (0, 1)]\n\n    >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])\n    [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]\n\n    >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])\n    [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]\n    \"\"\"\n\n    if len(points) <= 2:\n        # There is no convex hull\n        raise ValueError(\"graham_scan: argument must contain more than 3 points.\")\n    if len(points) == 3:\n        return points\n    # find the lowest and the most left point\n    minidx = 0\n    miny, minx = maxsize, maxsize\n    for i, point in enumerate(points):\n        x = point[0]\n        y = point[1]\n        if y < miny:\n            miny = y\n            minx = x\n            minidx = i\n        if y == miny and x < minx:\n            minx = x\n            minidx = i\n\n    # remove the lowest and the most left point from points for preparing for sort\n    points.pop(minidx)\n\n    sorted_points = sorted(points, key=lambda point: angle_comparer(point, minx, miny))\n    # This insert actually costs complexity,\n    # and you should instead add (minx, miny) into stack later.\n    # I'm using insert just for easy understanding.\n    sorted_points.insert(0, (minx, miny))\n\n    stack: deque[tuple[int, int]] = deque()\n    stack.append(sorted_points[0])\n    stack.append(sorted_points[1])\n    stack.append(sorted_points[2])\n    # The first 3 points lines are towards the left because we sort them by their angle\n    # from minx, miny.\n    current_direction = Direction.left\n\n    for i in range(3, len(sorted_points)):\n        while True:\n            starting = stack[-2]\n            via = stack[-1]\n            target = sorted_points[i]\n            next_direction = check_direction(starting, via, target)\n\n            if next_direction == Direction.left:\n                current_direction = Direction.left\n                break\n            if next_direction == Direction.straight:\n                if current_direction == Direction.left:\n                    # We keep current_direction as left.\n                    # Because if the straight line keeps as straight,\n                    # we want to know if this straight line is towards left.\n                    break\n                elif current_direction == Direction.right:\n                    # If the straight line is towards right,\n                    # every previous points on that straight line is not convex hull.\n                    stack.pop()\n            if next_direction == Direction.right:\n                stack.pop()\n        stack.append(sorted_points[i])\n    return list(stack)\n", "other/bankers_algorithm.py": "# A Python implementation of the Banker's Algorithm in Operating Systems using\n# Processes and Resources\n# {\n# \"Author: \"Biney Kingsley (bluedistro@github.io), bineykingsley36@gmail.com\",\n# \"Date\": 28-10-2018\n# }\n\"\"\"\nThe Banker's algorithm is a resource allocation and deadlock avoidance algorithm\ndeveloped by Edsger Dijkstra that tests for safety by simulating the allocation of\npredetermined maximum possible amounts of all resources, and then makes a \"s-state\"\ncheck to test for possible deadlock conditions for all other pending activities,\nbefore deciding whether allocation should be allowed to continue.\n[Source] Wikipedia\n[Credit] Rosetta Code C implementation helped very much.\n (https://rosettacode.org/wiki/Banker%27s_algorithm)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\n\ntest_claim_vector = [8, 5, 9, 7]\ntest_allocated_res_table = [\n    [2, 0, 1, 1],\n    [0, 1, 2, 1],\n    [4, 0, 0, 3],\n    [0, 2, 1, 0],\n    [1, 0, 3, 0],\n]\ntest_maximum_claim_table = [\n    [3, 2, 1, 4],\n    [0, 2, 5, 2],\n    [5, 1, 0, 5],\n    [1, 5, 3, 0],\n    [3, 0, 3, 3],\n]\n\n\nclass BankersAlgorithm:\n    def __init__(\n        self,\n        claim_vector: list[int],\n        allocated_resources_table: list[list[int]],\n        maximum_claim_table: list[list[int]],\n    ) -> None:\n        \"\"\"\n        :param claim_vector: A nxn/nxm list depicting the amount of each resources\n         (eg. memory, interface, semaphores, etc.) available.\n        :param allocated_resources_table: A nxn/nxm list depicting the amount of each\n         resource each process is currently holding\n        :param maximum_claim_table: A nxn/nxm list depicting how much of each resource\n         the system currently has available\n        \"\"\"\n        self.__claim_vector = claim_vector\n        self.__allocated_resources_table = allocated_resources_table\n        self.__maximum_claim_table = maximum_claim_table\n\n    def __processes_resource_summation(self) -> list[int]:\n        \"\"\"\n        Check for allocated resources in line with each resource in the claim vector\n        \"\"\"\n        return [\n            sum(p_item[i] for p_item in self.__allocated_resources_table)\n            for i in range(len(self.__allocated_resources_table[0]))\n        ]\n\n    def __available_resources(self) -> list[int]:\n        \"\"\"\n        Check for available resources in line with each resource in the claim vector\n        \"\"\"\n        return np.array(self.__claim_vector) - np.array(\n            self.__processes_resource_summation()\n        )\n\n    def __need(self) -> list[list[int]]:\n        \"\"\"\n        Implement safety checker that calculates the needs by ensuring that\n        max_claim[i][j] - alloc_table[i][j] <= avail[j]\n        \"\"\"\n        return [\n            list(np.array(self.__maximum_claim_table[i]) - np.array(allocated_resource))\n            for i, allocated_resource in enumerate(self.__allocated_resources_table)\n        ]\n\n    def __need_index_manager(self) -> dict[int, list[int]]:\n        \"\"\"\n        This function builds an index control dictionary to track original ids/indices\n        of processes when altered during execution of method \"main\"\n            Return: {0: [a: int, b: int], 1: [c: int, d: int]}\n        >>> (BankersAlgorithm(test_claim_vector, test_allocated_res_table,\n        ...     test_maximum_claim_table)._BankersAlgorithm__need_index_manager()\n        ...     )  # doctest: +NORMALIZE_WHITESPACE\n        {0: [1, 2, 0, 3], 1: [0, 1, 3, 1], 2: [1, 1, 0, 2], 3: [1, 3, 2, 0],\n         4: [2, 0, 0, 3]}\n        \"\"\"\n        return {self.__need().index(i): i for i in self.__need()}\n\n    def main(self, **kwargs) -> None:\n        \"\"\"\n        Utilize various methods in this class to simulate the Banker's algorithm\n        Return: None\n        >>> BankersAlgorithm(test_claim_vector, test_allocated_res_table,\n        ...    test_maximum_claim_table).main(describe=True)\n                 Allocated Resource Table\n        P1       2        0        1        1\n        <BLANKLINE>\n        P2       0        1        2        1\n        <BLANKLINE>\n        P3       4        0        0        3\n        <BLANKLINE>\n        P4       0        2        1        0\n        <BLANKLINE>\n        P5       1        0        3        0\n        <BLANKLINE>\n                 System Resource Table\n        P1       3        2        1        4\n        <BLANKLINE>\n        P2       0        2        5        2\n        <BLANKLINE>\n        P3       5        1        0        5\n        <BLANKLINE>\n        P4       1        5        3        0\n        <BLANKLINE>\n        P5       3        0        3        3\n        <BLANKLINE>\n        Current Usage by Active Processes: 8 5 9 7\n        Initial Available Resources:       1 2 2 2\n        __________________________________________________\n        <BLANKLINE>\n        Process 3 is executing.\n        Updated available resource stack for processes: 5 2 2 5\n        The process is in a safe state.\n        <BLANKLINE>\n        Process 1 is executing.\n        Updated available resource stack for processes: 7 2 3 6\n        The process is in a safe state.\n        <BLANKLINE>\n        Process 2 is executing.\n        Updated available resource stack for processes: 7 3 5 7\n        The process is in a safe state.\n        <BLANKLINE>\n        Process 4 is executing.\n        Updated available resource stack for processes: 7 5 6 7\n        The process is in a safe state.\n        <BLANKLINE>\n        Process 5 is executing.\n        Updated available resource stack for processes: 8 5 9 7\n        The process is in a safe state.\n        <BLANKLINE>\n        \"\"\"\n        need_list = self.__need()\n        alloc_resources_table = self.__allocated_resources_table\n        available_resources = self.__available_resources()\n        need_index_manager = self.__need_index_manager()\n        for kw, val in kwargs.items():\n            if kw and val is True:\n                self.__pretty_data()\n        print(\"_\" * 50 + \"\\n\")\n        while need_list:\n            safe = False\n            for each_need in need_list:\n                execution = True\n                for index, need in enumerate(each_need):\n                    if need > available_resources[index]:\n                        execution = False\n                        break\n                if execution:\n                    safe = True\n                    # get the original index of the process from ind_ctrl db\n                    for original_need_index, need_clone in need_index_manager.items():\n                        if each_need == need_clone:\n                            process_number = original_need_index\n                    print(f\"Process {process_number + 1} is executing.\")\n                    # remove the process run from stack\n                    need_list.remove(each_need)\n                    # update available/freed resources stack\n                    available_resources = np.array(available_resources) + np.array(\n                        alloc_resources_table[process_number]\n                    )\n                    print(\n                        \"Updated available resource stack for processes: \"\n                        + \" \".join([str(x) for x in available_resources])\n                    )\n                    break\n            if safe:\n                print(\"The process is in a safe state.\\n\")\n            else:\n                print(\"System in unsafe state. Aborting...\\n\")\n                break\n\n    def __pretty_data(self):\n        \"\"\"\n        Properly align display of the algorithm's solution\n        \"\"\"\n        print(\" \" * 9 + \"Allocated Resource Table\")\n        for item in self.__allocated_resources_table:\n            print(\n                f\"P{self.__allocated_resources_table.index(item) + 1}\"\n                + \" \".join(f\"{it:>8}\" for it in item)\n                + \"\\n\"\n            )\n        print(\" \" * 9 + \"System Resource Table\")\n        for item in self.__maximum_claim_table:\n            print(\n                f\"P{self.__maximum_claim_table.index(item) + 1}\"\n                + \" \".join(f\"{it:>8}\" for it in item)\n                + \"\\n\"\n            )\n        print(\n            \"Current Usage by Active Processes: \"\n            + \" \".join(str(x) for x in self.__claim_vector)\n        )\n        print(\n            \"Initial Available Resources:       \"\n            + \" \".join(str(x) for x in self.__available_resources())\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/majority_vote_algorithm.py": "\"\"\"\nThis is Booyer-Moore Majority Vote Algorithm. The problem statement goes like this:\nGiven an integer array of size n, find all elements that appear more than \u230a n/k \u230b times.\nWe have to solve in O(n) time and O(1) Space.\nURL : https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n\"\"\"\n\nfrom collections import Counter\n\n\ndef majority_vote(votes: list[int], votes_needed_to_win: int) -> list[int]:\n    \"\"\"\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3)\n    [2]\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2)\n    []\n    >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4)\n    [1, 2, 3]\n    \"\"\"\n    majority_candidate_counter: Counter[int] = Counter()\n    for vote in votes:\n        majority_candidate_counter[vote] += 1\n        if len(majority_candidate_counter) == votes_needed_to_win:\n            majority_candidate_counter -= Counter(set(majority_candidate_counter))\n    majority_candidate_counter = Counter(\n        vote for vote in votes if vote in majority_candidate_counter\n    )\n    return [\n        vote\n        for vote in majority_candidate_counter\n        if majority_candidate_counter[vote] > len(votes) / votes_needed_to_win\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/greedy.py": "class Things:\n    def __init__(self, name, value, weight):\n        self.name = name\n        self.value = value\n        self.weight = weight\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self.name}, {self.value}, {self.weight})\"\n\n    def get_value(self):\n        return self.value\n\n    def get_name(self):\n        return self.name\n\n    def get_weight(self):\n        return self.weight\n\n    def value_weight(self):\n        return self.value / self.weight\n\n\ndef build_menu(name, value, weight):\n    menu = []\n    for i in range(len(value)):\n        menu.append(Things(name[i], value[i], weight[i]))\n    return menu\n\n\ndef greedy(item, max_cost, key_func):\n    items_copy = sorted(item, key=key_func, reverse=True)\n    result = []\n    total_value, total_cost = 0.0, 0.0\n    for i in range(len(items_copy)):\n        if (total_cost + items_copy[i].get_weight()) <= max_cost:\n            result.append(items_copy[i])\n            total_cost += items_copy[i].get_weight()\n            total_value += items_copy[i].get_value()\n    return (result, total_value)\n\n\ndef test_greedy():\n    \"\"\"\n    >>> food = [\"Burger\", \"Pizza\", \"Coca Cola\", \"Rice\",\n    ...         \"Sambhar\", \"Chicken\", \"Fries\", \"Milk\"]\n    >>> value = [80, 100, 60, 70, 50, 110, 90, 60]\n    >>> weight = [40, 60, 40, 70, 100, 85, 55, 70]\n    >>> foods = build_menu(food, value, weight)\n    >>> foods  # doctest: +NORMALIZE_WHITESPACE\n    [Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),\n     Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),\n     Things(Fries, 90, 55), Things(Milk, 60, 70)]\n    >>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE\n    ([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),\n      Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),\n      Things(Milk, 60, 70)], 570.0)\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/alternative_list_arrange.py": "def alternative_list_arrange(first_input_list: list, second_input_list: list) -> list:\n    \"\"\"\n    The method arranges two lists as one list in alternative forms of the list elements.\n    :param first_input_list:\n    :param second_input_list:\n    :return: List\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [\"A\", \"B\", \"C\"])\n    [1, 'A', 2, 'B', 3, 'C', 4, 5]\n    >>> alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5])\n    ['A', 1, 'B', 2, 'C', 3, 4, 5]\n    >>> alternative_list_arrange([\"X\", \"Y\", \"Z\"], [9, 8, 7, 6])\n    ['X', 9, 'Y', 8, 'Z', 7, 6]\n    >>> alternative_list_arrange([1, 2, 3, 4, 5], [])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    first_input_list_length: int = len(first_input_list)\n    second_input_list_length: int = len(second_input_list)\n    abs_length: int = (\n        first_input_list_length\n        if first_input_list_length > second_input_list_length\n        else second_input_list_length\n    )\n    output_result_list: list = []\n    for char_count in range(abs_length):\n        if char_count < first_input_list_length:\n            output_result_list.append(first_input_list[char_count])\n        if char_count < second_input_list_length:\n            output_result_list.append(second_input_list[char_count])\n\n    return output_result_list\n\n\nif __name__ == \"__main__\":\n    print(alternative_list_arrange([\"A\", \"B\", \"C\"], [1, 2, 3, 4, 5]), end=\" \")\n", "other/activity_selection.py": "\"\"\"The following implementation assumes that the activities\nare already sorted according to their finish time\"\"\"\n\n\"\"\"Prints a maximum set of activities that can be done by a\nsingle person, one at a time\"\"\"\n# n --> Total number of activities\n# start[]--> An array that contains start time of all activities\n# finish[] --> An array that contains finish time of all activities\n\n\ndef print_max_activities(start: list[int], finish: list[int]) -> None:\n    \"\"\"\n    >>> start = [1, 3, 0, 5, 8, 5]\n    >>> finish = [2, 4, 6, 7, 9, 9]\n    >>> print_max_activities(start, finish)\n    The following activities are selected:\n    0,1,3,4,\n    \"\"\"\n    n = len(finish)\n    print(\"The following activities are selected:\")\n\n    # The first activity is always selected\n    i = 0\n    print(i, end=\",\")\n\n    # Consider rest of the activities\n    for j in range(n):\n        # If this activity has start time greater than\n        # or equal to the finish time of previously\n        # selected activity, then select it\n        if start[j] >= finish[i]:\n            print(j, end=\",\")\n            i = j\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    start = [1, 3, 0, 5, 8, 5]\n    finish = [2, 4, 6, 7, 9, 9]\n    print_max_activities(start, finish)\n", "other/__init__.py": "", "other/word_search.py": "\"\"\"\nCreates a random wordsearch with eight different directions\nthat are best described as compass locations.\n\n@ https://en.wikipedia.org/wiki/Word_search\n\"\"\"\n\nfrom random import choice, randint, shuffle\n\n# The words to display on the word search -\n# can be made dynamic by randonly selecting a certain number of\n# words from a predefined word file, while ensuring the character\n# count fits within the matrix size (n x m)\nWORDS = [\"cat\", \"dog\", \"snake\", \"fish\"]\n\nWIDTH = 10\nHEIGHT = 10\n\n\nclass WordSearch:\n    \"\"\"\n    >>> ws = WordSearch(WORDS, WIDTH, HEIGHT)\n    >>> ws.board  # doctest: +ELLIPSIS\n    [[None, ..., None], ..., [None, ..., None]]\n    >>> ws.generate_board()\n    \"\"\"\n\n    def __init__(self, words: list[str], width: int, height: int) -> None:\n        self.words = words\n        self.width = width\n        self.height = height\n\n        # Board matrix holding each letter\n        self.board: list[list[str | None]] = [[None] * width for _ in range(height)]\n\n    def insert_north(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_north(\"cat\", [2], [2])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, 't'],\n        [None, None, 'a'],\n        [None, None, 'c']]\n        >>> ws.insert_north(\"at\", [0, 1, 2], [2, 1])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, 't', 't'],\n        [None, 'a', 'a'],\n        [None, None, 'c']]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space above the row to fit in the word\n            if word_length > row + 1:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Only check to be made here is if there are existing letters\n                # above the column that will be overwritten\n                letters_above = [self.board[row - i][col] for i in range(word_length)]\n                if all(letter is None for letter in letters_above):\n                    # Successful, insert the word north\n                    for i in range(word_length):\n                        self.board[row - i][col] = word[i]\n                    return\n\n    def insert_northeast(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_northeast(\"cat\", [2], [0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, 't'],\n        [None, 'a', None],\n        ['c', None, None]]\n        >>> ws.insert_northeast(\"at\", [0, 1], [2, 1, 0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, 't', 't'],\n        ['a', 'a', None],\n        ['c', None, None]]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space for the word above the row\n            if word_length > row + 1:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the right of the word as well as above\n                if word_length + col > self.width:\n                    continue\n\n                # Check if there are existing letters\n                # to the right of the column that will be overwritten\n                letters_diagonal_left = [\n                    self.board[row - i][col + i] for i in range(word_length)\n                ]\n                if all(letter is None for letter in letters_diagonal_left):\n                    # Successful, insert the word northeast\n                    for i in range(word_length):\n                        self.board[row - i][col + i] = word[i]\n                    return\n\n    def insert_east(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_east(\"cat\", [1], [0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, None],\n        ['c', 'a', 't'],\n        [None, None, None]]\n        >>> ws.insert_east(\"at\", [1, 0], [2, 1, 0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, 'a', 't'],\n        ['c', 'a', 't'],\n        [None, None, None]]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the right of the word\n                if word_length + col > self.width:\n                    continue\n\n                # Check if there are existing letters\n                # to the right of the column that will be overwritten\n                letters_left = [self.board[row][col + i] for i in range(word_length)]\n                if all(letter is None for letter in letters_left):\n                    # Successful, insert the word east\n                    for i in range(word_length):\n                        self.board[row][col + i] = word[i]\n                    return\n\n    def insert_southeast(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_southeast(\"cat\", [0], [0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['c', None, None],\n        [None, 'a', None],\n        [None, None, 't']]\n        >>> ws.insert_southeast(\"at\", [1, 0], [2, 1, 0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['c', None, None],\n        ['a', 'a', None],\n        [None, 't', 't']]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space for the word below the row\n            if word_length + row > self.height:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the right of the word as well as below\n                if word_length + col > self.width:\n                    continue\n\n                # Check if there are existing letters\n                # to the right of the column that will be overwritten\n                letters_diagonal_left = [\n                    self.board[row + i][col + i] for i in range(word_length)\n                ]\n                if all(letter is None for letter in letters_diagonal_left):\n                    # Successful, insert the word southeast\n                    for i in range(word_length):\n                        self.board[row + i][col + i] = word[i]\n                    return\n\n    def insert_south(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_south(\"cat\", [0], [0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['c', None, None],\n        ['a', None, None],\n        ['t', None, None]]\n        >>> ws.insert_south(\"at\", [2, 1, 0], [0, 1, 2])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['c', None, None],\n        ['a', 'a', None],\n        ['t', 't', None]]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space below the row to fit in the word\n            if word_length + row > self.height:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Only check to be made here is if there are existing letters\n                # below the column that will be overwritten\n                letters_below = [self.board[row + i][col] for i in range(word_length)]\n                if all(letter is None for letter in letters_below):\n                    # Successful, insert the word south\n                    for i in range(word_length):\n                        self.board[row + i][col] = word[i]\n                    return\n\n    def insert_southwest(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_southwest(\"cat\", [0], [2])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, 'c'],\n        [None, 'a', None],\n        ['t', None, None]]\n        >>> ws.insert_southwest(\"at\", [1, 2], [2, 1, 0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, 'c'],\n        [None, 'a', 'a'],\n        ['t', 't', None]]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space for the word below the row\n            if word_length + row > self.height:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the left of the word as well as below\n                if word_length > col + 1:\n                    continue\n\n                # Check if there are existing letters\n                # to the right of the column that will be overwritten\n                letters_diagonal_left = [\n                    self.board[row + i][col - i] for i in range(word_length)\n                ]\n                if all(letter is None for letter in letters_diagonal_left):\n                    # Successful, insert the word southwest\n                    for i in range(word_length):\n                        self.board[row + i][col - i] = word[i]\n                    return\n\n    def insert_west(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_west(\"cat\", [1], [2])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [[None, None, None],\n        ['t', 'a', 'c'],\n        [None, None, None]]\n        >>> ws.insert_west(\"at\", [1, 0], [1, 2, 0])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['t', 'a', None],\n        ['t', 'a', 'c'],\n        [None, None, None]]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the left of the word\n                if word_length > col + 1:\n                    continue\n\n                # Check if there are existing letters\n                # to the left of the column that will be overwritten\n                letters_left = [self.board[row][col - i] for i in range(word_length)]\n                if all(letter is None for letter in letters_left):\n                    # Successful, insert the word west\n                    for i in range(word_length):\n                        self.board[row][col - i] = word[i]\n                    return\n\n    def insert_northwest(self, word: str, rows: list[int], cols: list[int]) -> None:\n        \"\"\"\n        >>> ws = WordSearch(WORDS, 3, 3)\n        >>> ws.insert_northwest(\"cat\", [2], [2])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['t', None, None],\n        [None, 'a', None],\n        [None, None, 'c']]\n        >>> ws.insert_northwest(\"at\", [1, 2], [0, 1])\n        >>> ws.board  # doctest: +NORMALIZE_WHITESPACE\n        [['t', None, None],\n        ['t', 'a', None],\n        [None, 'a', 'c']]\n        \"\"\"\n        word_length = len(word)\n        # Attempt to insert the word into each row and when successful, exit\n        for row in rows:\n            # Check if there is space for the word above the row\n            if word_length > row + 1:\n                continue\n\n            # Attempt to insert the word into each column\n            for col in cols:\n                # Check if there is space to the left of the word as well as above\n                if word_length > col + 1:\n                    continue\n\n                # Check if there are existing letters\n                # to the right of the column that will be overwritten\n                letters_diagonal_left = [\n                    self.board[row - i][col - i] for i in range(word_length)\n                ]\n                if all(letter is None for letter in letters_diagonal_left):\n                    # Successful, insert the word northwest\n                    for i in range(word_length):\n                        self.board[row - i][col - i] = word[i]\n                    return\n\n    def generate_board(self) -> None:\n        \"\"\"\n        Generates a board with a random direction for each word.\n\n        >>> wt = WordSearch(WORDS, WIDTH, HEIGHT)\n        >>> wt.generate_board()\n        >>> len(list(filter(lambda word: word is not None, sum(wt.board, start=[])))\n        ... ) == sum(map(lambda word: len(word), WORDS))\n        True\n        \"\"\"\n        directions = (\n            self.insert_north,\n            self.insert_northeast,\n            self.insert_east,\n            self.insert_southeast,\n            self.insert_south,\n            self.insert_southwest,\n            self.insert_west,\n            self.insert_northwest,\n        )\n        for word in self.words:\n            # Shuffle the row order and column order that is used when brute forcing\n            # the insertion of the word\n            rows, cols = list(range(self.height)), list(range(self.width))\n            shuffle(rows)\n            shuffle(cols)\n\n            # Insert the word via the direction\n            choice(directions)(word, rows, cols)\n\n\ndef visualise_word_search(\n    board: list[list[str | None]] | None = None, *, add_fake_chars: bool = True\n) -> None:\n    \"\"\"\n    Graphically displays the word search in the terminal.\n\n    >>> ws = WordSearch(WORDS, 5, 5)\n    >>> ws.insert_north(\"cat\", [4], [4])\n    >>> visualise_word_search(\n    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n    # # # # #\n    # # # # #\n    # # # # t\n    # # # # a\n    # # # # c\n    >>> ws.insert_northeast(\"snake\", [4], [4, 3, 2, 1, 0])\n    >>> visualise_word_search(\n    ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE\n    # # # # e\n    # # # k #\n    # # a # t\n    # n # # a\n    s # # # c\n    \"\"\"\n    if board is None:\n        word_search = WordSearch(WORDS, WIDTH, HEIGHT)\n        word_search.generate_board()\n        board = word_search.board\n\n    result = \"\"\n    for row in range(len(board)):\n        for col in range(len(board[0])):\n            character = \"#\"\n            if (letter := board[row][col]) is not None:\n                character = letter\n            # Empty char, so add a fake char\n            elif add_fake_chars:\n                character = chr(randint(97, 122))\n            result += f\"{character} \"\n        result += \"\\n\"\n    print(result, end=\"\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    visualise_word_search()\n", "other/gauss_easter.py": "\"\"\"\nhttps://en.wikipedia.org/wiki/Computus#Gauss'_Easter_algorithm\n\"\"\"\n\nimport math\nfrom datetime import UTC, datetime, timedelta\n\n\ndef gauss_easter(year: int) -> datetime:\n    \"\"\"\n    Calculation Gregorian easter date for given year\n\n    >>> gauss_easter(2007)\n    datetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2008)\n    datetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2020)\n    datetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)\n\n    >>> gauss_easter(2021)\n    datetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)\n    \"\"\"\n    metonic_cycle = year % 19\n    julian_leap_year = year % 4\n    non_leap_year = year % 7\n    leap_day_inhibits = math.floor(year / 100)\n    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)\n    leap_day_reinstall_number = leap_day_inhibits / 4\n    secular_moon_shift = (\n        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number\n    ) % 30\n    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7\n\n    # days to be added to March 21\n    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30\n\n    # PHM -> Paschal Full Moon\n    days_from_phm_to_sunday = (\n        2 * julian_leap_year\n        + 4 * non_leap_year\n        + 6 * days_to_add\n        + century_starting_point\n    ) % 7\n\n    if days_to_add == 29 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 19, tzinfo=UTC)\n    elif days_to_add == 28 and days_from_phm_to_sunday == 6:\n        return datetime(year, 4, 18, tzinfo=UTC)\n    else:\n        return datetime(year, 3, 22, tzinfo=UTC) + timedelta(\n            days=int(days_to_add + days_from_phm_to_sunday)\n        )\n\n\nif __name__ == \"__main__\":\n    for year in (1994, 2000, 2010, 2021, 2023, 2032, 2100):\n        tense = \"will be\" if year > datetime.now(tz=UTC).year else \"was\"\n        print(f\"Easter in {year} {tense} {gauss_easter(year)}\")\n", "other/guess_the_number_search.py": "\"\"\"\nguess the number using lower,higher and the value to find or guess\n\nsolution works by dividing lower and higher of number guessed\n\nsuppose lower is 0, higher is 1000 and the number to guess is 355\n\n>>> guess_the_number(10, 1000, 17)\nstarted...\nguess the number : 17\ndetails : [505, 257, 133, 71, 40, 25, 17]\n\n\"\"\"\n\n\ndef temp_input_value(\n    min_val: int = 10, max_val: int = 1000, option: bool = True\n) -> int:\n    \"\"\"\n    Temporary input values for tests\n\n    >>> temp_input_value(option=True)\n    10\n\n    >>> temp_input_value(option=False)\n    1000\n\n    >>> temp_input_value(min_val=100, option=True)\n    100\n\n    >>> temp_input_value(min_val=100, max_val=50)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid value for min_val or max_val (min_value < max_value)\n\n    >>> temp_input_value(\"ten\",\"fifty\",1)\n    Traceback (most recent call last):\n        ...\n    AssertionError: Invalid type of value(s) specified to function!\n\n    >>> temp_input_value(min_val=-100, max_val=500)\n    -100\n\n    >>> temp_input_value(min_val=-5100, max_val=-100)\n    -5100\n    \"\"\"\n    assert (\n        isinstance(min_val, int)\n        and isinstance(max_val, int)\n        and isinstance(option, bool)\n    ), \"Invalid type of value(s) specified to function!\"\n\n    if min_val > max_val:\n        raise ValueError(\"Invalid value for min_val or max_val (min_value < max_value)\")\n    return min_val if option else max_val\n\n\ndef get_avg(number_1: int, number_2: int) -> int:\n    \"\"\"\n    Return the mid-number(whole) of two integers a and b\n\n    >>> get_avg(10, 15)\n    12\n\n    >>> get_avg(20, 300)\n    160\n\n    >>> get_avg(\"abcd\", 300)\n    Traceback (most recent call last):\n        ...\n    TypeError: can only concatenate str (not \"int\") to str\n\n    >>> get_avg(10.5,50.25)\n    30\n    \"\"\"\n    return int((number_1 + number_2) / 2)\n\n\ndef guess_the_number(lower: int, higher: int, to_guess: int) -> None:\n    \"\"\"\n    The `guess_the_number` function that guess the number by some operations\n    and using inner functions\n\n    >>> guess_the_number(10, 1000, 17)\n    started...\n    guess the number : 17\n    details : [505, 257, 133, 71, 40, 25, 17]\n\n    >>> guess_the_number(-10000, 10000, 7)\n    started...\n    guess the number : 7\n    details : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]\n\n    >>> guess_the_number(10, 1000, \"a\")\n    Traceback (most recent call last):\n        ...\n    AssertionError: argument values must be type of \"int\"\n\n    >>> guess_the_number(10, 1000, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: guess value must be within the range of lower and higher value\n\n    >>> guess_the_number(10000, 100, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: argument value for lower and higher must be(lower > higher)\n    \"\"\"\n    assert (\n        isinstance(lower, int) and isinstance(higher, int) and isinstance(to_guess, int)\n    ), 'argument values must be type of \"int\"'\n\n    if lower > higher:\n        raise ValueError(\"argument value for lower and higher must be(lower > higher)\")\n\n    if not lower < to_guess < higher:\n        raise ValueError(\n            \"guess value must be within the range of lower and higher value\"\n        )\n\n    def answer(number: int) -> str:\n        \"\"\"\n        Returns value by comparing with entered `to_guess` number\n        \"\"\"\n        if number > to_guess:\n            return \"high\"\n        elif number < to_guess:\n            return \"low\"\n        else:\n            return \"same\"\n\n    print(\"started...\")\n\n    last_lowest = lower\n    last_highest = higher\n\n    last_numbers = []\n\n    while True:\n        number = get_avg(last_lowest, last_highest)\n        last_numbers.append(number)\n\n        if answer(number) == \"low\":\n            last_lowest = number\n        elif answer(number) == \"high\":\n            last_highest = number\n        else:\n            break\n\n    print(f\"guess the number : {last_numbers[-1]}\")\n    print(f\"details : {last_numbers!s}\")\n\n\ndef main() -> None:\n    \"\"\"\n    starting point or function of script\n    \"\"\"\n    lower = int(input(\"Enter lower value : \").strip())\n    higher = int(input(\"Enter high value : \").strip())\n    guess = int(input(\"Enter value to guess : \").strip())\n    guess_the_number(lower, higher, guess)\n\n\nif __name__ == \"__main__\":\n    main()\n", "other/least_recently_used.py": "from __future__ import annotations\n\nimport sys\nfrom collections import deque\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass LRUCache(Generic[T]):\n    \"\"\"\n    Page Replacement Algorithm, Least Recently Used (LRU) Caching.\n\n    >>> lru_cache: LRUCache[str | int] = LRUCache(4)\n    >>> lru_cache.refer(\"A\")\n    >>> lru_cache.refer(2)\n    >>> lru_cache.refer(3)\n\n    >>> lru_cache\n    LRUCache(4) => [3, 2, 'A']\n\n    >>> lru_cache.refer(\"A\")\n    >>> lru_cache\n    LRUCache(4) => ['A', 3, 2]\n\n    >>> lru_cache.refer(4)\n    >>> lru_cache.refer(5)\n    >>> lru_cache\n    LRUCache(4) => [5, 4, 'A', 3]\n\n    \"\"\"\n\n    dq_store: deque[T]  # Cache store of keys\n    key_reference: set[T]  # References of the keys in cache\n    _MAX_CAPACITY: int = 10  # Maximum capacity of cache\n\n    def __init__(self, n: int) -> None:\n        \"\"\"Creates an empty store and map for the keys.\n        The LRUCache is set the size n.\n        \"\"\"\n        self.dq_store = deque()\n        self.key_reference = set()\n        if not n:\n            LRUCache._MAX_CAPACITY = sys.maxsize\n        elif n < 0:\n            raise ValueError(\"n should be an integer greater than 0.\")\n        else:\n            LRUCache._MAX_CAPACITY = n\n\n    def refer(self, x: T) -> None:\n        \"\"\"\n        Looks for a page in the cache store and adds reference to the set.\n        Remove the least recently used key if the store is full.\n        Update store to reflect recent access.\n        \"\"\"\n        if x not in self.key_reference:\n            if len(self.dq_store) == LRUCache._MAX_CAPACITY:\n                last_element = self.dq_store.pop()\n                self.key_reference.remove(last_element)\n        else:\n            self.dq_store.remove(x)\n\n        self.dq_store.appendleft(x)\n        self.key_reference.add(x)\n\n    def display(self) -> None:\n        \"\"\"\n        Prints all the elements in the store.\n        \"\"\"\n        for k in self.dq_store:\n            print(k)\n\n    def __repr__(self) -> str:\n        return f\"LRUCache({self._MAX_CAPACITY}) => {list(self.dq_store)}\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n\n    lru_cache: LRUCache[str | int] = LRUCache(4)\n    lru_cache.refer(\"A\")\n    lru_cache.refer(2)\n    lru_cache.refer(3)\n    lru_cache.refer(\"A\")\n    lru_cache.refer(4)\n    lru_cache.refer(5)\n    lru_cache.display()\n\n    print(lru_cache)\n    assert str(lru_cache) == \"LRUCache(4) => [5, 4, 'A', 3]\"\n", "other/h_index.py": "\"\"\"\nTask:\nGiven an array of integers citations where citations[i] is the number of\ncitations a researcher received for their ith paper, return compute the\nresearcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: A scientist has an\nindex h if h of their n papers have at least h citations each, and the other\nn - h papers have no more than h citations each.\n\nIf there are several possible values for h, the maximum one is taken as the\nh-index.\n\nH-Index link: https://en.wikipedia.org/wiki/H-index\n\nImplementation notes:\nUse sorting of array\n\nLeetcode link: https://leetcode.com/problems/h-index/description/\n\nn = len(citations)\nRuntime Complexity: O(n * log(n))\nSpace  Complexity: O(1)\n\n\"\"\"\n\n\ndef h_index(citations: list[int]) -> int:\n    \"\"\"\n    Return H-index of citations\n\n    >>> h_index([3, 0, 6, 1, 5])\n    3\n    >>> h_index([1, 3, 1])\n    1\n    >>> h_index([1, 2, 3])\n    2\n    >>> h_index('test')\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    >>> h_index([1,2,'3'])\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    >>> h_index([1,2,-3])\n    Traceback (most recent call last):\n        ...\n    ValueError: The citations should be a list of non negative integers.\n    \"\"\"\n\n    # validate:\n    if not isinstance(citations, list) or not all(\n        isinstance(item, int) and item >= 0 for item in citations\n    ):\n        raise ValueError(\"The citations should be a list of non negative integers.\")\n\n    citations.sort()\n    len_citations = len(citations)\n\n    for i in range(len_citations):\n        if citations[len_citations - 1 - i] <= i:\n            return i\n\n    return len_citations\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/lru_cache.py": "from __future__ import annotations\n\nfrom collections.abc import Callable\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\nU = TypeVar(\"U\")\n\n\nclass DoubleLinkedListNode(Generic[T, U]):\n    \"\"\"\n    Double Linked List Node built specifically for LRU Cache\n\n    >>> DoubleLinkedListNode(1,1)\n    Node: key: 1, val: 1, has next: False, has prev: False\n    \"\"\"\n\n    def __init__(self, key: T | None, val: U | None):\n        self.key = key\n        self.val = val\n        self.next: DoubleLinkedListNode[T, U] | None = None\n        self.prev: DoubleLinkedListNode[T, U] | None = None\n\n    def __repr__(self) -> str:\n        return (\n            f\"Node: key: {self.key}, val: {self.val}, \"\n            f\"has next: {bool(self.next)}, has prev: {bool(self.prev)}\"\n        )\n\n\nclass DoubleLinkedList(Generic[T, U]):\n    \"\"\"\n    Double Linked List built specifically for LRU Cache\n\n    >>> dll: DoubleLinkedList = DoubleLinkedList()\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: None, val: None, has next: False, has prev: True\n\n    >>> first_node = DoubleLinkedListNode(1,10)\n    >>> first_node\n    Node: key: 1, val: 10, has next: False, has prev: False\n\n\n    >>> dll.add(first_node)\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: 1, val: 10, has next: True, has prev: True,\n        Node: key: None, val: None, has next: False, has prev: True\n\n    >>> # node is mutated\n    >>> first_node\n    Node: key: 1, val: 10, has next: True, has prev: True\n\n    >>> second_node = DoubleLinkedListNode(2,20)\n    >>> second_node\n    Node: key: 2, val: 20, has next: False, has prev: False\n\n    >>> dll.add(second_node)\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: 1, val: 10, has next: True, has prev: True,\n        Node: key: 2, val: 20, has next: True, has prev: True,\n        Node: key: None, val: None, has next: False, has prev: True\n\n    >>> removed_node = dll.remove(first_node)\n    >>> assert removed_node == first_node\n    >>> dll\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: 2, val: 20, has next: True, has prev: True,\n        Node: key: None, val: None, has next: False, has prev: True\n\n\n    >>> # Attempt to remove node not on list\n    >>> removed_node = dll.remove(first_node)\n    >>> removed_node is None\n    True\n\n    >>> # Attempt to remove head or rear\n    >>> dll.head\n    Node: key: None, val: None, has next: True, has prev: False\n    >>> dll.remove(dll.head) is None\n    True\n\n    >>> # Attempt to remove head or rear\n    >>> dll.rear\n    Node: key: None, val: None, has next: False, has prev: True\n    >>> dll.remove(dll.rear) is None\n    True\n\n\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.head: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\n        self.rear: DoubleLinkedListNode[T, U] = DoubleLinkedListNode(None, None)\n        self.head.next, self.rear.prev = self.rear, self.head\n\n    def __repr__(self) -> str:\n        rep = [\"DoubleLinkedList\"]\n        node = self.head\n        while node.next is not None:\n            rep.append(str(node))\n            node = node.next\n        rep.append(str(self.rear))\n        return \",\\n    \".join(rep)\n\n    def add(self, node: DoubleLinkedListNode[T, U]) -> None:\n        \"\"\"\n        Adds the given node to the end of the list (before rear)\n        \"\"\"\n\n        previous = self.rear.prev\n\n        # All nodes other than self.head are guaranteed to have non-None previous\n        assert previous is not None\n\n        previous.next = node\n        node.prev = previous\n        self.rear.prev = node\n        node.next = self.rear\n\n    def remove(\n        self, node: DoubleLinkedListNode[T, U]\n    ) -> DoubleLinkedListNode[T, U] | None:\n        \"\"\"\n        Removes and returns the given node from the list\n\n        Returns None if node.prev or node.next is None\n        \"\"\"\n\n        if node.prev is None or node.next is None:\n            return None\n\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n        return node\n\n\nclass LRUCache(Generic[T, U]):\n    \"\"\"\n    LRU Cache to store a given capacity of data. Can be used as a stand-alone object\n    or as a function decorator.\n\n    >>> cache = LRUCache(2)\n\n    >>> cache.put(1, 1)\n    >>> cache.put(2, 2)\n    >>> cache.get(1)\n    1\n\n    >>> cache.list\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: 2, val: 2, has next: True, has prev: True,\n        Node: key: 1, val: 1, has next: True, has prev: True,\n        Node: key: None, val: None, has next: False, has prev: True\n\n    >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE\n    {1: Node: key: 1, val: 1, has next: True, has prev: True, \\\n     2: Node: key: 2, val: 2, has next: True, has prev: True}\n\n    >>> cache.put(3, 3)\n\n    >>> cache.list\n    DoubleLinkedList,\n        Node: key: None, val: None, has next: True, has prev: False,\n        Node: key: 1, val: 1, has next: True, has prev: True,\n        Node: key: 3, val: 3, has next: True, has prev: True,\n        Node: key: None, val: None, has next: False, has prev: True\n\n    >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE\n    {1: Node: key: 1, val: 1, has next: True, has prev: True, \\\n     3: Node: key: 3, val: 3, has next: True, has prev: True}\n\n    >>> cache.get(2) is None\n    True\n\n    >>> cache.put(4, 4)\n\n    >>> cache.get(1) is None\n    True\n\n    >>> cache.get(3)\n    3\n\n    >>> cache.get(4)\n    4\n\n    >>> cache\n    CacheInfo(hits=3, misses=2, capacity=2, current size=2)\n\n    >>> @LRUCache.decorator(100)\n    ... def fib(num):\n    ...     if num in (1, 2):\n    ...         return 1\n    ...     return fib(num - 1) + fib(num - 2)\n\n    >>> for i in range(1, 100):\n    ...     res = fib(i)\n\n    >>> fib.cache_info()\n    CacheInfo(hits=194, misses=99, capacity=100, current size=99)\n    \"\"\"\n\n    # class variable to map the decorator functions to their respective instance\n    decorator_function_to_instance_map: dict[Callable[[T], U], LRUCache[T, U]] = {}\n\n    def __init__(self, capacity: int):\n        self.list: DoubleLinkedList[T, U] = DoubleLinkedList()\n        self.capacity = capacity\n        self.num_keys = 0\n        self.hits = 0\n        self.miss = 0\n        self.cache: dict[T, DoubleLinkedListNode[T, U]] = {}\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return the details for the cache instance\n        [hits, misses, capacity, current_size]\n        \"\"\"\n\n        return (\n            f\"CacheInfo(hits={self.hits}, misses={self.miss}, \"\n            f\"capacity={self.capacity}, current size={self.num_keys})\"\n        )\n\n    def __contains__(self, key: T) -> bool:\n        \"\"\"\n        >>> cache = LRUCache(1)\n\n        >>> 1 in cache\n        False\n\n        >>> cache.put(1, 1)\n\n        >>> 1 in cache\n        True\n        \"\"\"\n\n        return key in self.cache\n\n    def get(self, key: T) -> U | None:\n        \"\"\"\n        Returns the value for the input key and updates the Double Linked List.\n        Returns None if key is not present in cache\n        \"\"\"\n        # Note: pythonic interface would throw KeyError rather than return None\n\n        if key in self.cache:\n            self.hits += 1\n            value_node: DoubleLinkedListNode[T, U] = self.cache[key]\n            node = self.list.remove(self.cache[key])\n            assert node == value_node\n\n            # node is guaranteed not None because it is in self.cache\n            assert node is not None\n            self.list.add(node)\n            return node.val\n        self.miss += 1\n        return None\n\n    def put(self, key: T, value: U) -> None:\n        \"\"\"\n        Sets the value for the input key and updates the Double Linked List\n        \"\"\"\n\n        if key not in self.cache:\n            if self.num_keys >= self.capacity:\n                # delete first node (oldest) when over capacity\n                first_node = self.list.head.next\n\n                # guaranteed to have a non-None first node when num_keys > 0\n                # explain to type checker via assertions\n                assert first_node is not None\n                assert first_node.key is not None\n                assert (\n                    self.list.remove(first_node) is not None\n                )  # node guaranteed to be in list assert node.key is not None\n\n                del self.cache[first_node.key]\n                self.num_keys -= 1\n            self.cache[key] = DoubleLinkedListNode(key, value)\n            self.list.add(self.cache[key])\n            self.num_keys += 1\n\n        else:\n            # bump node to the end of the list, update value\n            node = self.list.remove(self.cache[key])\n            assert node is not None  # node guaranteed to be in list\n            node.val = value\n            self.list.add(node)\n\n    @classmethod\n    def decorator(\n        cls, size: int = 128\n    ) -> Callable[[Callable[[T], U]], Callable[..., U]]:\n        \"\"\"\n        Decorator version of LRU Cache\n\n        Decorated function must be function of T -> U\n        \"\"\"\n\n        def cache_decorator_inner(func: Callable[[T], U]) -> Callable[..., U]:\n            def cache_decorator_wrapper(*args: T) -> U:\n                if func not in cls.decorator_function_to_instance_map:\n                    cls.decorator_function_to_instance_map[func] = LRUCache(size)\n\n                result = cls.decorator_function_to_instance_map[func].get(args[0])\n                if result is None:\n                    result = func(*args)\n                    cls.decorator_function_to_instance_map[func].put(args[0], result)\n                return result\n\n            def cache_info() -> LRUCache[T, U]:\n                return cls.decorator_function_to_instance_map[func]\n\n            setattr(cache_decorator_wrapper, \"cache_info\", cache_info)  # noqa: B010\n\n            return cache_decorator_wrapper\n\n        return cache_decorator_inner\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "other/doomsday.py": "#!/bin/python3\n# Doomsday algorithm info: https://en.wikipedia.org/wiki/Doomsday_rule\n\nDOOMSDAY_LEAP = [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\nDOOMSDAY_NOT_LEAP = [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\nWEEK_DAY_NAMES = {\n    0: \"Sunday\",\n    1: \"Monday\",\n    2: \"Tuesday\",\n    3: \"Wednesday\",\n    4: \"Thursday\",\n    5: \"Friday\",\n    6: \"Saturday\",\n}\n\n\ndef get_week_day(year: int, month: int, day: int) -> str:\n    \"\"\"Returns the week-day name out of a given date.\n\n    >>> get_week_day(2020, 10, 24)\n    'Saturday'\n    >>> get_week_day(2017, 10, 24)\n    'Tuesday'\n    >>> get_week_day(2019, 5, 3)\n    'Friday'\n    >>> get_week_day(1970, 9, 16)\n    'Wednesday'\n    >>> get_week_day(1870, 8, 13)\n    'Saturday'\n    >>> get_week_day(2040, 3, 14)\n    'Wednesday'\n\n    \"\"\"\n    # minimal input check:\n    assert len(str(year)) > 2, \"year should be in YYYY format\"\n    assert 1 <= month <= 12, \"month should be between 1 to 12\"\n    assert 1 <= day <= 31, \"day should be between 1 to 31\"\n\n    # Doomsday algorithm:\n    century = year // 100\n    century_anchor = (5 * (century % 4) + 2) % 7\n    centurian = year % 100\n    centurian_m = centurian % 12\n    dooms_day = (\n        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor\n    ) % 7\n    day_anchor = (\n        DOOMSDAY_NOT_LEAP[month - 1]\n        if (year % 4 != 0) or (centurian == 0 and (year % 400) == 0)\n        else DOOMSDAY_LEAP[month - 1]\n    )\n    week_day = (dooms_day + day - day_anchor) % 7\n    return WEEK_DAY_NAMES[week_day]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/charging_inductor.py": "# source - The ARRL Handbook for Radio Communications\n# https://en.wikipedia.org/wiki/RL_circuit\n\n\"\"\"\nDescription\n-----------\nInductor is a passive electronic device which stores energy but unlike capacitor, it\nstores energy in its 'magnetic field' or 'magnetostatic field'.\n\nWhen inductor is connected to 'DC' current source nothing happens it just works like a\nwire because it's real effect cannot be seen while 'DC' is connected, its not even\ngoing to store energy. Inductor stores energy only when it is working on 'AC' current.\n\nConnecting a inductor in series with a resistor(when R = 0) to a 'AC' potential source,\nfrom zero to a finite value causes a sudden voltage to induced in inductor which\nopposes the current. which results in initially slowly current rise. However it would\ncease if there is no further changes in current. With resistance zero current will never\nstop rising.\n\n'Resistance(ohms) / Inductance(henrys)' is known as RL-timeconstant. It also represents\nas \u03c4 (tau). While the charging of a inductor with a resistor results in\na exponential function.\n\nwhen inductor is connected across 'AC' potential source. It starts to store the energy\nin its 'magnetic field'.with the help 'RL-time-constant' we can find current at any time\nin inductor while it is charging.\n\"\"\"\n\nfrom math import exp  # value of exp = 2.718281828459\u2026\n\n\ndef charging_inductor(\n    source_voltage: float,  # source_voltage should be in volts.\n    resistance: float,  # resistance should be in ohms.\n    inductance: float,  # inductance should be in henrys.\n    time: float,  # time should in seconds.\n) -> float:\n    \"\"\"\n    Find inductor current at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)\n    2.817\n\n    >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)\n    1.543\n\n    >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)\n    0.016\n\n    >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n\n    >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if inductance <= 0:\n        raise ValueError(\"Inductance must be positive.\")\n    return round(\n        source_voltage / resistance * (1 - exp((-time * resistance) / inductance)), 3\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/resistor_color_code.py": "\"\"\"\nTitle : Calculating the resistance of a n band resistor using the color codes\n\nDescription :\n    Resistors resist the flow of electrical current.Each one has a value that tells how\n    strongly it resists current flow.This value's unit is the ohm, often noted with the\n    Greek letter omega: \u2126.\n\n    The colored bands on a resistor can tell you everything you need to know about its\n    value and tolerance, as long as you understand how to read them. The order in which\n    the colors are arranged is very important, and each value of resistor has its own\n    unique combination.\n\n    The color coding for resistors is an international standard that is defined in IEC\n    60062.\n\n    The number of bands present in a resistor varies from three to six. These represent\n    significant figures, multiplier, tolerance, reliability, and temperature coefficient\n    Each color used for a type of band has a value assigned to it. It is read from left\n    to right.\n    All resistors will have significant figures and multiplier bands. In a three band\n    resistor first two bands from the left represent significant figures and the third\n    represents the multiplier band.\n\n    Significant figures - The number of significant figures band in a resistor can vary\n    from two to three.\n    Colors and values associated with significant figure bands -\n    (Black = 0, Brown = 1, Red = 2, Orange = 3, Yellow = 4, Green = 5, Blue = 6,\n    Violet = 7, Grey = 8, White = 9)\n\n    Multiplier - There will be one multiplier band in a resistor. It is multiplied with\n    the significant figures obtained from previous bands.\n    Colors and values associated with multiplier band -\n    (Black = 100, Brown = 10^1, Red = 10^2, Orange = 10^3, Yellow = 10^4, Green = 10^5,\n    Blue = 10^6, Violet = 10^7, Grey = 10^8, White = 10^9, Gold = 10^-1, Silver = 10^-2)\n    Note that multiplier bands use Gold and Silver which are not used for significant\n    figure bands.\n\n    Tolerance - The tolerance band is not always present. It can be seen in four band\n    resistors and above. This is a percentage by which the resistor value can vary.\n    Colors and values associated with tolerance band -\n    (Brown = 1%, Red = 2%, Orange = 0.05%, Yellow = 0.02%, Green = 0.5%,Blue = 0.25%,\n    Violet = 0.1%, Grey = 0.01%, Gold = 5%, Silver = 10%)\n    If no color is mentioned then by default tolerance is 20%\n    Note that tolerance band does not use Black and White colors.\n\n    Temperature Coeffecient - Indicates the change in resistance of the component as\n    a function of ambient temperature in terms of ppm/K.\n    It is present in six band resistors.\n    Colors and values associated with Temperature coeffecient -\n    (Black = 250 ppm/K, Brown = 100 ppm/K, Red = 50 ppm/K, Orange = 15 ppm/K,\n    Yellow = 25 ppm/K, Green = 20 ppm/K, Blue = 10 ppm/K, Violet = 5 ppm/K,\n    Grey = 1 ppm/K)\n    Note that temperature coeffecient band does not use White, Gold, Silver colors.\n\nSources :\n    https://www.calculator.net/resistor-calculator.html\n    https://learn.parallax.com/support/reference/resistor-color-codes\n    https://byjus.com/physics/resistor-colour-codes/\n\"\"\"\n\nvalid_colors: list = [\n    \"Black\",\n    \"Brown\",\n    \"Red\",\n    \"Orange\",\n    \"Yellow\",\n    \"Green\",\n    \"Blue\",\n    \"Violet\",\n    \"Grey\",\n    \"White\",\n    \"Gold\",\n    \"Silver\",\n]\n\nsignificant_figures_color_values: dict[str, int] = {\n    \"Black\": 0,\n    \"Brown\": 1,\n    \"Red\": 2,\n    \"Orange\": 3,\n    \"Yellow\": 4,\n    \"Green\": 5,\n    \"Blue\": 6,\n    \"Violet\": 7,\n    \"Grey\": 8,\n    \"White\": 9,\n}\n\nmultiplier_color_values: dict[str, float] = {\n    \"Black\": 10**0,\n    \"Brown\": 10**1,\n    \"Red\": 10**2,\n    \"Orange\": 10**3,\n    \"Yellow\": 10**4,\n    \"Green\": 10**5,\n    \"Blue\": 10**6,\n    \"Violet\": 10**7,\n    \"Grey\": 10**8,\n    \"White\": 10**9,\n    \"Gold\": 10**-1,\n    \"Silver\": 10**-2,\n}\n\ntolerance_color_values: dict[str, float] = {\n    \"Brown\": 1,\n    \"Red\": 2,\n    \"Orange\": 0.05,\n    \"Yellow\": 0.02,\n    \"Green\": 0.5,\n    \"Blue\": 0.25,\n    \"Violet\": 0.1,\n    \"Grey\": 0.01,\n    \"Gold\": 5,\n    \"Silver\": 10,\n}\n\ntemperature_coeffecient_color_values: dict[str, int] = {\n    \"Black\": 250,\n    \"Brown\": 100,\n    \"Red\": 50,\n    \"Orange\": 15,\n    \"Yellow\": 25,\n    \"Green\": 20,\n    \"Blue\": 10,\n    \"Violet\": 5,\n    \"Grey\": 1,\n}\n\nband_types: dict[int, dict[str, int]] = {\n    3: {\"significant\": 2, \"multiplier\": 1},\n    4: {\"significant\": 2, \"multiplier\": 1, \"tolerance\": 1},\n    5: {\"significant\": 3, \"multiplier\": 1, \"tolerance\": 1},\n    6: {\"significant\": 3, \"multiplier\": 1, \"tolerance\": 1, \"temp_coeffecient\": 1},\n}\n\n\ndef get_significant_digits(colors: list) -> str:\n    \"\"\"\n    Function returns the digit associated with the color. Function takes a\n    list containing colors as input and returns digits as string\n\n    >>> get_significant_digits(['Black','Blue'])\n    '06'\n\n    >>> get_significant_digits(['Aqua','Blue'])\n    Traceback (most recent call last):\n      ...\n    ValueError: Aqua is not a valid color for significant figure bands\n\n    \"\"\"\n    digit = \"\"\n    for color in colors:\n        if color not in significant_figures_color_values:\n            msg = f\"{color} is not a valid color for significant figure bands\"\n            raise ValueError(msg)\n        digit = digit + str(significant_figures_color_values[color])\n    return str(digit)\n\n\ndef get_multiplier(color: str) -> float:\n    \"\"\"\n    Function returns the multiplier value associated with the color.\n    Function takes color as input and returns multiplier value\n\n    >>> get_multiplier('Gold')\n    0.1\n\n    >>> get_multiplier('Ivory')\n    Traceback (most recent call last):\n      ...\n    ValueError: Ivory is not a valid color for multiplier band\n\n    \"\"\"\n    if color not in multiplier_color_values:\n        msg = f\"{color} is not a valid color for multiplier band\"\n        raise ValueError(msg)\n    return multiplier_color_values[color]\n\n\ndef get_tolerance(color: str) -> float:\n    \"\"\"\n    Function returns the tolerance value associated with the color.\n    Function takes color as input and returns tolerance value.\n\n    >>> get_tolerance('Green')\n    0.5\n\n    >>> get_tolerance('Indigo')\n    Traceback (most recent call last):\n      ...\n    ValueError: Indigo is not a valid color for tolerance band\n\n    \"\"\"\n    if color not in tolerance_color_values:\n        msg = f\"{color} is not a valid color for tolerance band\"\n        raise ValueError(msg)\n    return tolerance_color_values[color]\n\n\ndef get_temperature_coeffecient(color: str) -> int:\n    \"\"\"\n    Function returns the temperature coeffecient value associated with the color.\n    Function takes color as input and returns temperature coeffecient value.\n\n    >>> get_temperature_coeffecient('Yellow')\n    25\n\n    >>> get_temperature_coeffecient('Cyan')\n    Traceback (most recent call last):\n      ...\n    ValueError: Cyan is not a valid color for temperature coeffecient band\n\n    \"\"\"\n    if color not in temperature_coeffecient_color_values:\n        msg = f\"{color} is not a valid color for temperature coeffecient band\"\n        raise ValueError(msg)\n    return temperature_coeffecient_color_values[color]\n\n\ndef get_band_type_count(total_number_of_bands: int, type_of_band: str) -> int:\n    \"\"\"\n    Function returns the number of bands of a given type in a resistor with n bands\n    Function takes total_number_of_bands and type_of_band as input and returns\n    number of bands belonging to that type in the given resistor\n\n    >>> get_band_type_count(3,'significant')\n    2\n\n    >>> get_band_type_count(2,'significant')\n    Traceback (most recent call last):\n      ...\n    ValueError: 2 is not a valid number of bands\n\n    >>> get_band_type_count(3,'sign')\n    Traceback (most recent call last):\n      ...\n    ValueError: sign is not valid for a 3 band resistor\n\n    >>> get_band_type_count(3,'tolerance')\n    Traceback (most recent call last):\n      ...\n    ValueError: tolerance is not valid for a 3 band resistor\n\n    >>> get_band_type_count(5,'temp_coeffecient')\n    Traceback (most recent call last):\n      ...\n    ValueError: temp_coeffecient is not valid for a 5 band resistor\n\n    \"\"\"\n    if total_number_of_bands not in band_types:\n        msg = f\"{total_number_of_bands} is not a valid number of bands\"\n        raise ValueError(msg)\n    if type_of_band not in band_types[total_number_of_bands]:\n        msg = f\"{type_of_band} is not valid for a {total_number_of_bands} band resistor\"\n        raise ValueError(msg)\n    return band_types[total_number_of_bands][type_of_band]\n\n\ndef check_validity(number_of_bands: int, colors: list) -> bool:\n    \"\"\"\n    Function checks if the input provided is valid or not.\n    Function takes number_of_bands and colors as input and returns\n    True if it is valid\n\n    >>> check_validity(3, [\"Black\",\"Blue\",\"Orange\"])\n    True\n\n    >>> check_validity(4, [\"Black\",\"Blue\",\"Orange\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Expecting 4 colors, provided 3 colors\n\n    >>> check_validity(3, [\"Cyan\",\"Red\",\"Yellow\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Cyan is not a valid color\n\n    \"\"\"\n    if number_of_bands >= 3 and number_of_bands <= 6:\n        if number_of_bands == len(colors):\n            for color in colors:\n                if color not in valid_colors:\n                    msg = f\"{color} is not a valid color\"\n                    raise ValueError(msg)\n            return True\n        else:\n            msg = f\"Expecting {number_of_bands} colors, provided {len(colors)} colors\"\n            raise ValueError(msg)\n    else:\n        msg = \"Invalid number of bands. Resistor bands must be 3 to 6\"\n        raise ValueError(msg)\n\n\ndef calculate_resistance(number_of_bands: int, color_code_list: list) -> dict:\n    \"\"\"\n    Function calculates the total resistance of the resistor using the color codes.\n    Function takes number_of_bands, color_code_list as input and returns\n    resistance\n\n    >>> calculate_resistance(3, [\"Black\",\"Blue\",\"Orange\"])\n    {'resistance': '6000\u03a9 \u00b120% '}\n\n    >>> calculate_resistance(4, [\"Orange\",\"Green\",\"Blue\",\"Gold\"])\n    {'resistance': '35000000\u03a9 \u00b15% '}\n\n    >>> calculate_resistance(5, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    {'resistance': '7.18\u03a9 \u00b10.5% '}\n\n    >>> calculate_resistance(6, [\"Red\",\"Green\",\"Blue\",\"Yellow\",\"Orange\",\"Grey\"])\n    {'resistance': '2560000\u03a9 \u00b10.05% 1 ppm/K'}\n\n    >>> calculate_resistance(0, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Invalid number of bands. Resistor bands must be 3 to 6\n\n    >>> calculate_resistance(4, [\"Violet\",\"Brown\",\"Grey\",\"Silver\",\"Green\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Expecting 4 colors, provided 5 colors\n\n    >>> calculate_resistance(4, [\"Violet\",\"Silver\",\"Brown\",\"Grey\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Silver is not a valid color for significant figure bands\n\n    >>> calculate_resistance(4, [\"Violet\",\"Blue\",\"Lime\",\"Grey\"])\n    Traceback (most recent call last):\n      ...\n    ValueError: Lime is not a valid color\n\n    \"\"\"\n    is_valid = check_validity(number_of_bands, color_code_list)\n    if is_valid:\n        number_of_significant_bands = get_band_type_count(\n            number_of_bands, \"significant\"\n        )\n        significant_colors = color_code_list[:number_of_significant_bands]\n        significant_digits = int(get_significant_digits(significant_colors))\n        multiplier_color = color_code_list[number_of_significant_bands]\n        multiplier = get_multiplier(multiplier_color)\n        if number_of_bands == 3:\n            tolerance_color = None\n        else:\n            tolerance_color = color_code_list[number_of_significant_bands + 1]\n        tolerance = (\n            20 if tolerance_color is None else get_tolerance(str(tolerance_color))\n        )\n        if number_of_bands != 6:\n            temperature_coeffecient_color = None\n        else:\n            temperature_coeffecient_color = color_code_list[\n                number_of_significant_bands + 2\n            ]\n        temperature_coeffecient = (\n            0\n            if temperature_coeffecient_color is None\n            else get_temperature_coeffecient(str(temperature_coeffecient_color))\n        )\n        resisitance = significant_digits * multiplier\n        if temperature_coeffecient == 0:\n            answer = f\"{resisitance}\u03a9 \u00b1{tolerance}% \"\n        else:\n            answer = f\"{resisitance}\u03a9 \u00b1{tolerance}% {temperature_coeffecient} ppm/K\"\n        return {\"resistance\": answer}\n    else:\n        raise ValueError(\"Input is invalid\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/apparent_power.py": "import cmath\nimport math\n\n\ndef apparent_power(\n    voltage: float, current: float, voltage_angle: float, current_angle: float\n) -> complex:\n    \"\"\"\n    Calculate the apparent power in a single-phase AC circuit.\n\n    Reference: https://en.wikipedia.org/wiki/AC_power#Apparent_power\n\n    >>> apparent_power(100, 5, 0, 0)\n    (500+0j)\n    >>> apparent_power(100, 5, 90, 0)\n    (3.061616997868383e-14+500j)\n    >>> apparent_power(100, 5, -45, -60)\n    (-129.40952255126027-482.9629131445341j)\n    >>> apparent_power(200, 10, -30, -90)\n    (-999.9999999999998-1732.0508075688776j)\n    \"\"\"\n    # Convert angles from degrees to radians\n    voltage_angle_rad = math.radians(voltage_angle)\n    current_angle_rad = math.radians(current_angle)\n\n    # Convert voltage and current to rectangular form\n    voltage_rect = cmath.rect(voltage, voltage_angle_rad)\n    current_rect = cmath.rect(current, current_angle_rad)\n\n    # Calculate apparent power\n    return voltage_rect * current_rect\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/carrier_concentration.py": "# https://en.wikipedia.org/wiki/Charge_carrier_density\n# https://www.pveducation.org/pvcdrom/pn-junctions/equilibrium-carrier-concentration\n# http://www.ece.utep.edu/courses/ee3329/ee3329/Studyguide/ToC/Fundamentals/Carriers/concentrations.html\n\nfrom __future__ import annotations\n\n\ndef carrier_concentration(\n    electron_conc: float,\n    hole_conc: float,\n    intrinsic_conc: float,\n) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Electron Concentration\n    2, Hole Concentration\n    3. Intrinsic Concentration\n    given the other two.\n    Examples -\n    >>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)\n    ('intrinsic_conc', 50.0)\n    >>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)\n    ('electron_conc', 25.0)\n    >>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)\n    ('hole_conc', 1440.0)\n    >>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: You cannot supply more or less than 2 values\n    >>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Electron concentration cannot be negative in a semiconductor\n    >>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Hole concentration cannot be negative in a semiconductor\n    >>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)\n    Traceback (most recent call last):\n        ...\n    ValueError: Intrinsic concentration cannot be negative in a semiconductor\n    \"\"\"\n    if (electron_conc, hole_conc, intrinsic_conc).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative in a semiconductor\")\n    elif hole_conc < 0:\n        raise ValueError(\"Hole concentration cannot be negative in a semiconductor\")\n    elif intrinsic_conc < 0:\n        raise ValueError(\n            \"Intrinsic concentration cannot be negative in a semiconductor\"\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            intrinsic_conc**2 / hole_conc,\n        )\n    elif hole_conc == 0:\n        return (\n            \"hole_conc\",\n            intrinsic_conc**2 / electron_conc,\n        )\n    elif intrinsic_conc == 0:\n        return (\n            \"intrinsic_conc\",\n            (electron_conc * hole_conc) ** 0.5,\n        )\n    else:\n        return (-1, -1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/charging_capacitor.py": "# source - The ARRL Handbook for Radio Communications\n# https://en.wikipedia.org/wiki/RC_time_constant\n\n\"\"\"\nDescription\n-----------\nWhen a capacitor is connected with a potential source (AC or DC). It starts to charge\nat a general speed but when a resistor is connected in the  circuit with in series to\na capacitor then the capacitor charges slowly means it will take more time than usual.\nwhile the capacitor is being charged, the voltage is in exponential function with time.\n\n'resistance(ohms) * capacitance(farads)' is called RC-timeconstant which may also be\nrepresented as \u03c4 (tau).  By using this RC-timeconstant we can find the voltage at any\ntime 't' from the initiation of charging a capacitor with the help of the exponential\nfunction containing RC.  Both at charging and discharging of a capacitor.\n\"\"\"\n\nfrom math import exp  # value of exp = 2.718281828459\u2026\n\n\ndef charging_capacitor(\n    source_voltage: float,  # voltage in volts.\n    resistance: float,  # resistance in ohms.\n    capacitance: float,  # capacitance in farads.\n    time_sec: float,  # time in seconds after charging initiation of capacitor.\n) -> float:\n    \"\"\"\n    Find capacitor voltage at any nth second after initiating its charging.\n\n    Examples\n    --------\n    >>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5)\n    0.013\n\n    >>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9)\n    1.446\n\n    >>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2)\n    0.007\n\n    >>> charging_capacitor(20, 2000, 30*pow(10,-5), 4)\n    19.975\n\n    >>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3)\n    Traceback (most recent call last):\n        ...\n    ValueError: Source voltage must be positive.\n\n    >>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistance must be positive.\n\n    >>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitance must be positive.\n    \"\"\"\n\n    if source_voltage <= 0:\n        raise ValueError(\"Source voltage must be positive.\")\n    if resistance <= 0:\n        raise ValueError(\"Resistance must be positive.\")\n    if capacitance <= 0:\n        raise ValueError(\"Capacitance must be positive.\")\n    return round(source_voltage * (1 - exp(-time_sec / (resistance * capacitance))), 3)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/resonant_frequency.py": "# https://en.wikipedia.org/wiki/LC_circuit\n\n\"\"\"An LC circuit, also called a resonant circuit, tank circuit, or tuned circuit,\nis an electric circuit consisting of an inductor, represented by the letter L,\nand a capacitor, represented by the letter C, connected together.\nThe circuit can act as an electrical resonator, an electrical analogue of a\ntuning fork, storing energy oscillating at the circuit's resonant frequency.\nSource: https://en.wikipedia.org/wiki/LC_circuit\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom math import pi, sqrt\n\n\ndef resonant_frequency(inductance: float, capacitance: float) -> tuple:\n    \"\"\"\n    This function can calculate the resonant frequency of LC circuit,\n    for the given value of inductance and capacitnace.\n\n    Examples are given below:\n    >>> resonant_frequency(inductance=10, capacitance=5)\n    ('Resonant frequency', 0.022507907903927652)\n    >>> resonant_frequency(inductance=0, capacitance=5)\n    Traceback (most recent call last):\n      ...\n    ValueError: Inductance cannot be 0 or negative\n    >>> resonant_frequency(inductance=10, capacitance=0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Capacitance cannot be 0 or negative\n    \"\"\"\n\n    if inductance <= 0:\n        raise ValueError(\"Inductance cannot be 0 or negative\")\n\n    elif capacitance <= 0:\n        raise ValueError(\"Capacitance cannot be 0 or negative\")\n\n    else:\n        return (\n            \"Resonant frequency\",\n            float(1 / (2 * pi * (sqrt(inductance * capacitance)))),\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/electric_conductivity.py": "from __future__ import annotations\n\nELECTRON_CHARGE = 1.6021e-19  # units = C\n\n\ndef electric_conductivity(\n    conductivity: float,\n    electron_conc: float,\n    mobility: float,\n) -> tuple[str, float]:\n    \"\"\"\n    This function can calculate any one of the three -\n    1. Conductivity\n    2. Electron Concentration\n    3. Electron Mobility\n    This is calculated from the other two provided values\n    Examples -\n    >>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0)\n    ('mobility', 1.5604519068722301e+18)\n    >>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200)\n    ('conductivity', 5.12672e-14)\n    >>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200)\n    ('electron_conc', 5.201506356240767e+18)\n    \"\"\"\n    if (conductivity, electron_conc, mobility).count(0) != 1:\n        raise ValueError(\"You cannot supply more or less than 2 values\")\n    elif conductivity < 0:\n        raise ValueError(\"Conductivity cannot be negative\")\n    elif electron_conc < 0:\n        raise ValueError(\"Electron concentration cannot be negative\")\n    elif mobility < 0:\n        raise ValueError(\"mobility cannot be negative\")\n    elif conductivity == 0:\n        return (\n            \"conductivity\",\n            mobility * electron_conc * ELECTRON_CHARGE,\n        )\n    elif electron_conc == 0:\n        return (\n            \"electron_conc\",\n            conductivity / (mobility * ELECTRON_CHARGE),\n        )\n    else:\n        return (\n            \"mobility\",\n            conductivity / (electron_conc * ELECTRON_CHARGE),\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/resistor_equivalence.py": "# https://byjus.com/equivalent-resistance-formula/\n\nfrom __future__ import annotations\n\n\ndef resistor_parallel(resistors: list[float]) -> float:\n    \"\"\"\n    Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)\n\n    >>> resistor_parallel([3.21389, 2, 3])\n    0.8737571620498019\n    >>> resistor_parallel([3.21389, 2, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative or zero value!\n    >>> resistor_parallel([3.21389, 2, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.00\n    for index, resistor in enumerate(resistors):\n        if resistor <= 0:\n            msg = f\"Resistor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / float(resistor)\n    return 1 / first_sum\n\n\ndef resistor_series(resistors: list[float]) -> float:\n    \"\"\"\n    Req = R1 + R2 + ... + Rn\n\n    Calculate the equivalent resistance for any number of resistors in parallel.\n\n    >>> resistor_series([3.21389, 2, 3])\n    8.21389\n    >>> resistor_series([3.21389, 2, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Resistor at index 2 has a negative value!\n    \"\"\"\n    sum_r = 0.00\n    for index, resistor in enumerate(resistors):\n        sum_r += resistor\n        if resistor < 0:\n            msg = f\"Resistor at index {index} has a negative value!\"\n            raise ValueError(msg)\n    return sum_r\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/coulombs_law.py": "# https://en.wikipedia.org/wiki/Coulomb%27s_law\n\nfrom __future__ import annotations\n\nCOULOMBS_CONSTANT = 8.988e9  # units = N * m^s * C^-2\n\n\ndef couloumbs_law(\n    force: float, charge1: float, charge2: float, distance: float\n) -> dict[str, float]:\n    \"\"\"\n    Apply Coulomb's Law on any three given values. These can be force, charge1,\n    charge2, or distance, and then in a Python dict return name/value pair of\n    the zero value.\n\n    Coulomb's Law states that the magnitude of the electrostatic force of\n    attraction or repulsion between two point charges is directly proportional\n    to the product of the magnitudes of charges and inversely proportional to\n    the square of the distance between them.\n\n    Reference\n    ----------\n    Coulomb (1785) \"Premier m\u00e9moire sur l'\u00e9lectricit\u00e9 et le magn\u00e9tisme,\"\n    Histoire de l'Acad\u00e9mie Royale des Sciences, pp. 569-577.\n\n    Parameters\n    ----------\n    force : float with units in Newtons\n\n    charge1 : float with units in Coulombs\n\n    charge2 : float with units in Coulombs\n\n    distance : float with units in meters\n\n    Returns\n    -------\n    result : dict name/value pair of the zero value\n\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000)\n    {'force': 33705.0}\n\n    >>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0)\n    {'distance': 116112.01488218177}\n\n    >>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000)\n    {'charge1': 0.0008900756564307966}\n\n    >>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n\n    >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Distance cannot be negative\n\n    \"\"\"\n\n    charge_product = abs(charge1 * charge2)\n\n    if (force, charge1, charge2, distance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if distance < 0:\n        raise ValueError(\"Distance cannot be negative\")\n    if force == 0:\n        force = COULOMBS_CONSTANT * charge_product / (distance**2)\n        return {\"force\": force}\n    elif charge1 == 0:\n        charge1 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge2)\n        return {\"charge1\": charge1}\n    elif charge2 == 0:\n        charge2 = abs(force) * (distance**2) / (COULOMBS_CONSTANT * charge1)\n        return {\"charge2\": charge2}\n    elif distance == 0:\n        distance = (COULOMBS_CONSTANT * charge_product / abs(force)) ** 0.5\n        return {\"distance\": distance}\n    raise ValueError(\"Exactly one argument must be 0\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/circular_convolution.py": "# https://en.wikipedia.org/wiki/Circular_convolution\n\n\"\"\"\nCircular convolution, also known as cyclic convolution,\nis a special case of periodic convolution, which is the convolution of two\nperiodic functions that have the same period. Periodic convolution arises,\nfor example, in the context of the discrete-time Fourier transform (DTFT).\nIn particular, the DTFT of the product of two discrete sequences is the periodic\nconvolution of the DTFTs of the individual sequences. And each DTFT is a periodic\nsummation of a continuous Fourier transform function.\n\nSource: https://en.wikipedia.org/wiki/Circular_convolution\n\"\"\"\n\nimport doctest\nfrom collections import deque\n\nimport numpy as np\n\n\nclass CircularConvolution:\n    \"\"\"\n    This class stores the first and second signal and performs the circular convolution\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        First signal and second signal are stored as 1-D array\n        \"\"\"\n\n        self.first_signal = [2, 1, 2, -1]\n        self.second_signal = [1, 2, 3, 4]\n\n    def circular_convolution(self) -> list[float]:\n        \"\"\"\n        This function performs the circular convolution of the first and second signal\n        using matrix method\n\n        Usage:\n        >>> convolution = CircularConvolution()\n        >>> convolution.circular_convolution()\n        [10, 10, 6, 14]\n\n        >>> convolution.first_signal = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]\n        >>> convolution.second_signal = [0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5]\n        >>> convolution.circular_convolution()\n        [5.2, 6.0, 6.48, 6.64, 6.48, 6.0, 5.2, 4.08]\n\n        >>> convolution.first_signal = [-1, 1, 2, -2]\n        >>> convolution.second_signal = [0.5, 1, -1, 2, 0.75]\n        >>> convolution.circular_convolution()\n        [6.25, -3.0, 1.5, -2.0, -2.75]\n\n        >>> convolution.first_signal = [1, -1, 2, 3, -1]\n        >>> convolution.second_signal = [1, 2, 3]\n        >>> convolution.circular_convolution()\n        [8, -2, 3, 4, 11]\n\n        \"\"\"\n\n        length_first_signal = len(self.first_signal)\n        length_second_signal = len(self.second_signal)\n\n        max_length = max(length_first_signal, length_second_signal)\n\n        # create a zero matrix of max_length x max_length\n        matrix = [[0] * max_length for i in range(max_length)]\n\n        # fills the smaller signal with zeros to make both signals of same length\n        if length_first_signal < length_second_signal:\n            self.first_signal += [0] * (max_length - length_first_signal)\n        elif length_first_signal > length_second_signal:\n            self.second_signal += [0] * (max_length - length_second_signal)\n\n        \"\"\"\n        Fills the matrix in the following way assuming 'x' is the signal of length 4\n        [\n            [x[0], x[3], x[2], x[1]],\n            [x[1], x[0], x[3], x[2]],\n            [x[2], x[1], x[0], x[3]],\n            [x[3], x[2], x[1], x[0]]\n        ]\n        \"\"\"\n        for i in range(max_length):\n            rotated_signal = deque(self.second_signal)\n            rotated_signal.rotate(i)\n            for j, item in enumerate(rotated_signal):\n                matrix[i][j] += item\n\n        # multiply the matrix with the first signal\n        final_signal = np.matmul(np.transpose(matrix), np.transpose(self.first_signal))\n\n        # rounding-off to two decimal places\n        return [round(i, 2) for i in final_signal]\n\n\nif __name__ == \"__main__\":\n    doctest.testmod()\n", "electronics/real_and_reactive_power.py": "import math\n\n\ndef real_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate real power from apparent power and power factor.\n\n    Examples:\n    >>> real_power(100, 0.9)\n    90.0\n    >>> real_power(0, 0.8)\n    0.0\n    >>> real_power(100, -0.9)\n    -90.0\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * power_factor\n\n\ndef reactive_power(apparent_power: float, power_factor: float) -> float:\n    \"\"\"\n    Calculate reactive power from apparent power and power factor.\n\n    Examples:\n    >>> reactive_power(100, 0.9)\n    43.58898943540673\n    >>> reactive_power(0, 0.8)\n    0.0\n    >>> reactive_power(100, -0.9)\n    43.58898943540673\n    \"\"\"\n    if (\n        not isinstance(power_factor, (int, float))\n        or power_factor < -1\n        or power_factor > 1\n    ):\n        raise ValueError(\"power_factor must be a valid float value between -1 and 1.\")\n    return apparent_power * math.sqrt(1 - power_factor**2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/builtin_voltage.py": "from math import log\n\nfrom scipy.constants import Boltzmann, physical_constants\n\nT = 300  # TEMPERATURE (unit = K)\n\n\ndef builtin_voltage(\n    donor_conc: float,  # donor concentration\n    acceptor_conc: float,  # acceptor concentration\n    intrinsic_conc: float,  # intrinsic concentration\n) -> float:\n    \"\"\"\n    This function can calculate the Builtin Voltage of a pn junction diode.\n    This is calculated from the given three values.\n    Examples -\n    >>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10)\n    0.833370010652644\n    >>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200)\n    Traceback (most recent call last):\n      ...\n    ValueError: Donor concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200)\n    Traceback (most recent call last):\n      ...\n    ValueError: Acceptor concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Intrinsic concentration should be positive\n    >>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Donor concentration should be greater than intrinsic concentration\n    >>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000)\n    Traceback (most recent call last):\n      ...\n    ValueError: Acceptor concentration should be greater than intrinsic concentration\n    \"\"\"\n\n    if donor_conc <= 0:\n        raise ValueError(\"Donor concentration should be positive\")\n    elif acceptor_conc <= 0:\n        raise ValueError(\"Acceptor concentration should be positive\")\n    elif intrinsic_conc <= 0:\n        raise ValueError(\"Intrinsic concentration should be positive\")\n    elif donor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Donor concentration should be greater than intrinsic concentration\"\n        )\n    elif acceptor_conc <= intrinsic_conc:\n        raise ValueError(\n            \"Acceptor concentration should be greater than intrinsic concentration\"\n        )\n    else:\n        return (\n            Boltzmann\n            * T\n            * log((donor_conc * acceptor_conc) / intrinsic_conc**2)\n            / physical_constants[\"electron volt\"][0]\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/electrical_impedance.py": "\"\"\"Electrical impedance is the measure of the opposition that a\ncircuit presents to a current when a voltage is applied.\nImpedance extends the concept of resistance to alternating current (AC) circuits.\nSource: https://en.wikipedia.org/wiki/Electrical_impedance\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom math import pow, sqrt\n\n\ndef electrical_impedance(\n    resistance: float, reactance: float, impedance: float\n) -> dict[str, float]:\n    \"\"\"\n    Apply Electrical Impedance formula, on any two given electrical values,\n    which can be resistance, reactance, and impedance, and then in a Python dict\n    return name/value pair of the zero value.\n\n    >>> electrical_impedance(3,4,0)\n    {'impedance': 5.0}\n    >>> electrical_impedance(0,4,5)\n    {'resistance': 3.0}\n    >>> electrical_impedance(3,0,5)\n    {'reactance': 4.0}\n    >>> electrical_impedance(3,4,5)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n    \"\"\"\n    if (resistance, reactance, impedance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance == 0:\n        return {\"resistance\": sqrt(pow(impedance, 2) - pow(reactance, 2))}\n    elif reactance == 0:\n        return {\"reactance\": sqrt(pow(impedance, 2) - pow(resistance, 2))}\n    elif impedance == 0:\n        return {\"impedance\": sqrt(pow(resistance, 2) + pow(reactance, 2))}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/__init__.py": "", "electronics/wheatstone_bridge.py": "# https://en.wikipedia.org/wiki/Wheatstone_bridge\nfrom __future__ import annotations\n\n\ndef wheatstone_solver(\n    resistance_1: float, resistance_2: float, resistance_3: float\n) -> float:\n    \"\"\"\n    This function can calculate the unknown resistance in an wheatstone network,\n    given that the three other resistances in the network are known.\n    The formula to calculate the same is:\n\n    ---------------\n    |Rx=(R2/R1)*R3|\n    ---------------\n\n    Usage examples:\n    >>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)\n    10.0\n    >>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)\n    641.5280898876405\n    >>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    >>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All resistance values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0:\n        raise ValueError(\"All resistance values must be positive\")\n    else:\n        return float((resistance_2 / resistance_1) * resistance_3)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/ind_reactance.py": "# https://en.wikipedia.org/wiki/Electrical_reactance#Inductive_reactance\nfrom __future__ import annotations\n\nfrom math import pi\n\n\ndef ind_reactance(\n    inductance: float, frequency: float, reactance: float\n) -> dict[str, float]:\n    \"\"\"\n    Calculate inductive reactance, frequency or inductance from two given electrical\n    properties then return name/value pair of the zero value in a Python dict.\n\n    Parameters\n    ----------\n    inductance : float with units in Henries\n\n    frequency : float with units in Hertz\n\n    reactance : float with units in Ohms\n\n    >>> ind_reactance(-35e-6, 1e3, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductance cannot be negative\n\n    >>> ind_reactance(35e-6, -1e3, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: Frequency cannot be negative\n\n    >>> ind_reactance(35e-6, 0, -1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Inductive reactance cannot be negative\n\n    >>> ind_reactance(0, 10e3, 50)\n    {'inductance': 0.0007957747154594767}\n\n    >>> ind_reactance(35e-3, 0, 50)\n    {'frequency': 227.36420441699332}\n\n    >>> ind_reactance(35e-6, 1e3, 0)\n    {'reactance': 0.2199114857512855}\n\n    \"\"\"\n\n    if (inductance, frequency, reactance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if inductance < 0:\n        raise ValueError(\"Inductance cannot be negative\")\n    if frequency < 0:\n        raise ValueError(\"Frequency cannot be negative\")\n    if reactance < 0:\n        raise ValueError(\"Inductive reactance cannot be negative\")\n    if inductance == 0:\n        return {\"inductance\": reactance / (2 * pi * frequency)}\n    elif frequency == 0:\n        return {\"frequency\": reactance / (2 * pi * inductance)}\n    elif reactance == 0:\n        return {\"reactance\": 2 * pi * frequency * inductance}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/electric_power.py": "# https://en.m.wikipedia.org/wiki/Electric_power\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n\nclass Result(NamedTuple):\n    name: str\n    value: float\n\n\ndef electric_power(voltage: float, current: float, power: float) -> tuple:\n    \"\"\"\n    This function can calculate any one of the three (voltage, current, power),\n    fundamental value of electrical system.\n    examples are below:\n    >>> electric_power(voltage=0, current=2, power=5)\n    Result(name='voltage', value=2.5)\n    >>> electric_power(voltage=2, current=2, power=0)\n    Result(name='power', value=4.0)\n    >>> electric_power(voltage=-2, current=3, power=0)\n    Result(name='power', value=6.0)\n    >>> electric_power(voltage=2, current=4, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only one argument must be 0\n    >>> electric_power(voltage=0, current=0, power=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: Only one argument must be 0\n    >>> electric_power(voltage=0, current=2, power=-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: Power cannot be negative in any electrical/electronics system\n    >>> electric_power(voltage=2.2, current=2.2, power=0)\n    Result(name='power', value=4.84)\n    \"\"\"\n    if (voltage, current, power).count(0) != 1:\n        raise ValueError(\"Only one argument must be 0\")\n    elif power < 0:\n        raise ValueError(\n            \"Power cannot be negative in any electrical/electronics system\"\n        )\n    elif voltage == 0:\n        return Result(\"voltage\", power / current)\n    elif current == 0:\n        return Result(\"current\", power / voltage)\n    elif power == 0:\n        return Result(\"power\", float(round(abs(voltage * current), 2)))\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/capacitor_equivalence.py": "# https://farside.ph.utexas.edu/teaching/316/lectures/node46.html\n\nfrom __future__ import annotations\n\n\ndef capacitor_parallel(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = C1 + C2 + ... + Cn\n    Calculate the equivalent resistance for any number of capacitors in parallel.\n    >>> capacitor_parallel([5.71389, 12, 3])\n    20.71389\n    >>> capacitor_parallel([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative value!\n    \"\"\"\n    sum_c = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor < 0:\n            msg = f\"Capacitor at index {index} has a negative value!\"\n            raise ValueError(msg)\n        sum_c += capacitor\n    return sum_c\n\n\ndef capacitor_series(capacitors: list[float]) -> float:\n    \"\"\"\n    Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)\n    >>> capacitor_series([5.71389, 12, 3])\n    1.6901062252507735\n    >>> capacitor_series([5.71389, 12, -3])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    >>> capacitor_series([5.71389, 12, 0.000])\n    Traceback (most recent call last):\n        ...\n    ValueError: Capacitor at index 2 has a negative or zero value!\n    \"\"\"\n\n    first_sum = 0.0\n    for index, capacitor in enumerate(capacitors):\n        if capacitor <= 0:\n            msg = f\"Capacitor at index {index} has a negative or zero value!\"\n            raise ValueError(msg)\n        first_sum += 1 / capacitor\n    return 1 / first_sum\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/ic_555_timer.py": "from __future__ import annotations\n\n\"\"\"\n    Calculate the frequency and/or duty cycle of an astable 555 timer.\n    * https://en.wikipedia.org/wiki/555_timer_IC#Astable\n\n    These functions take in the value of the external resistances (in ohms)\n    and capacitance (in Microfarad), and calculates the following:\n\n    -------------------------------------\n    | Freq = 1.44 /[( R1+ 2 x R2) x C1] |               ... in Hz\n    -------------------------------------\n    where Freq is the frequency,\n          R1 is the first resistance in ohms,\n          R2 is the second resistance in ohms,\n          C1 is the capacitance in Microfarads.\n\n    ------------------------------------------------\n    | Duty Cycle = (R1 + R2) / (R1 + 2 x R2) x 100 |    ... in %\n    ------------------------------------------------\n    where R1 is the first resistance in ohms,\n          R2 is the second resistance in ohms.\n\"\"\"\n\n\ndef astable_frequency(\n    resistance_1: float, resistance_2: float, capacitance: float\n) -> float:\n    \"\"\"\n    Usage examples:\n    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7)\n    1523.8095238095239\n    >>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976)\n    1.7905459175553078\n    >>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0 or capacitance <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (1.44 / ((resistance_1 + 2 * resistance_2) * capacitance)) * 10**6\n\n\ndef astable_duty_cycle(resistance_1: float, resistance_2: float) -> float:\n    \"\"\"\n    Usage examples:\n    >>> astable_duty_cycle(resistance_1=45, resistance_2=45)\n    66.66666666666666\n    >>> astable_duty_cycle(resistance_1=356, resistance_2=234)\n    71.60194174757282\n    >>> astable_duty_cycle(resistance_1=2, resistance_2=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    >>> astable_duty_cycle(resistance_1=0, resistance_2=0)\n    Traceback (most recent call last):\n        ...\n    ValueError: All values must be positive\n    \"\"\"\n\n    if resistance_1 <= 0 or resistance_2 <= 0:\n        raise ValueError(\"All values must be positive\")\n    return (resistance_1 + resistance_2) / (resistance_1 + 2 * resistance_2) * 100\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n", "electronics/ohms_law.py": "# https://en.wikipedia.org/wiki/Ohm%27s_law\nfrom __future__ import annotations\n\n\ndef ohms_law(voltage: float, current: float, resistance: float) -> dict[str, float]:\n    \"\"\"\n    Apply Ohm's Law, on any two given electrical values, which can be voltage, current,\n    and resistance, and then in a Python dict return name/value pair of the zero value.\n\n    >>> ohms_law(voltage=10, resistance=5, current=0)\n    {'current': 2.0}\n    >>> ohms_law(voltage=0, current=0, resistance=10)\n    Traceback (most recent call last):\n      ...\n    ValueError: One and only one argument must be 0\n    >>> ohms_law(voltage=0, current=1, resistance=-2)\n    Traceback (most recent call last):\n      ...\n    ValueError: Resistance cannot be negative\n    >>> ohms_law(resistance=0, voltage=-10, current=1)\n    {'resistance': -10.0}\n    >>> ohms_law(voltage=0, current=-1.5, resistance=2)\n    {'voltage': -3.0}\n    \"\"\"\n    if (voltage, current, resistance).count(0) != 1:\n        raise ValueError(\"One and only one argument must be 0\")\n    if resistance < 0:\n        raise ValueError(\"Resistance cannot be negative\")\n    if voltage == 0:\n        return {\"voltage\": float(current * resistance)}\n    elif current == 0:\n        return {\"current\": voltage / resistance}\n    elif resistance == 0:\n        return {\"resistance\": voltage / current}\n    else:\n        raise ValueError(\"Exactly one argument must be 0\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n"}