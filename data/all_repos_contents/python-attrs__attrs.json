{"conftest.py": "# SPDX-License-Identifier: MIT\n\nfrom datetime import timedelta\n\nimport pytest\n\nfrom hypothesis import HealthCheck, settings\n\nfrom attr._compat import PY_3_10_PLUS\n\n\n@pytest.fixture(name=\"slots\", params=(True, False))\ndef _slots(request):\n    return request.param\n\n\n@pytest.fixture(name=\"frozen\", params=(True, False))\ndef _frozen(request):\n    return request.param\n\n\ndef pytest_configure(config):\n    # HealthCheck.too_slow causes more trouble than good -- especially in CIs.\n    settings.register_profile(\n        \"patience\",\n        settings(\n            suppress_health_check=[HealthCheck.too_slow],\n            deadline=timedelta(milliseconds=400),\n        ),\n    )\n    settings.load_profile(\"patience\")\n\n\ncollect_ignore = []\nif not PY_3_10_PLUS:\n    collect_ignore.extend([\"tests/test_pattern_matching.py\"])\n", "docs/conf.py": "# SPDX-License-Identifier: MIT\n\nfrom importlib import metadata\nfrom pathlib import Path\n\n\n# -- Path setup -----------------------------------------------------------\n\nPROJECT_ROOT_DIR = Path(__file__).parents[1].resolve()\n\n\n# -- General configuration ------------------------------------------------\n\ndoctest_global_setup = \"\"\"\nfrom attr import define, frozen, field, validators, Factory\n\"\"\"\n\nlinkcheck_ignore = [\n    # We run into GitHub's rate limits.\n    r\"https://github.com/.*/(issues|pull)/\\d+\",\n    # Rate limits and the latest tag is missing anyways on release.\n    \"https://github.com/python-attrs/attrs/tree/.*\",\n]\n\n# In nitpick mode (-n), still ignore any of the following \"broken\" references\n# to non-types.\nnitpick_ignore = [\n    (\"py:class\", \"Any value\"),\n    (\"py:class\", \"callable\"),\n    (\"py:class\", \"callables\"),\n    (\"py:class\", \"tuple of types\"),\n]\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"myst_parser\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.todo\",\n    \"notfound.extension\",\n    \"sphinxcontrib.towncrier\",\n]\n\nmyst_enable_extensions = [\n    \"colon_fence\",\n    \"smartquotes\",\n    \"deflist\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"attrs\"\nauthor = \"Hynek Schlawack\"\ncopyright = f\"2015, {author}\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n\n# The full version, including alpha/beta/rc tags.\nrelease = metadata.version(\"attrs\")\nif \"dev\" in release:\n    release = version = \"UNRELEASED\"\nelse:\n    # The short X.Y version.\n    version = release.rsplit(\".\", 1)[0]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = \"any\"\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\nadd_function_parentheses = True\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nhtml_theme = \"furo\"\nhtml_theme_options = {\n    \"sidebar_hide_name\": True,\n    \"light_logo\": \"attrs_logo.svg\",\n    \"dark_logo\": \"attrs_logo_white.svg\",\n    \"top_of_page_buttons\": [],\n    \"light_css_variables\": {\n        \"font-stack\": \"Inter,sans-serif\",\n        \"font-stack--monospace\": \"BerkeleyMono, MonoLisa, ui-monospace, \"\n        \"SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace\",\n    },\n}\nhtml_css_files = [\"custom.css\"]\n\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# If false, no module index is generated.\nhtml_domain_indices = True\n\n# If false, no index is generated.\nhtml_use_index = True\n\n# If true, the index is split into individual pages for each letter.\nhtml_split_index = False\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = False\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\nhtml_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\nhtml_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"attrsdoc\"\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", \"attrs\", \"attrs Documentation\", [\"Hynek Schlawack\"], 1)]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        \"attrs\",\n        \"attrs Documentation\",\n        \"Hynek Schlawack\",\n        \"attrs\",\n        \"Python Classes Without Boilerplate\",\n        \"Miscellaneous\",\n    )\n]\n\nepub_description = \"Python Classes Without Boilerplate\"\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\n\n# Allow non-local URIs so we can have images in CHANGELOG etc.\nsuppress_warnings = [\"image.nonlocal_uri\"]\n\n\n# -- Options for sphinxcontrib.towncrier extension ------------------------\n\ntowncrier_draft_autoversion_mode = \"draft\"\ntowncrier_draft_include_empty = True\ntowncrier_draft_working_directory = PROJECT_ROOT_DIR\ntowncrier_draft_config_path = \"pyproject.toml\"\n", "tests/test_validators.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr.validators`.\n\"\"\"\n\n\nimport re\n\nimport pytest\n\nimport attr\n\nfrom attr import _config, fields, has\nfrom attr import validators as validator_module\nfrom attr.validators import (\n    _subclass_of,\n    and_,\n    deep_iterable,\n    deep_mapping,\n    ge,\n    gt,\n    in_,\n    instance_of,\n    is_callable,\n    le,\n    lt,\n    matches_re,\n    max_len,\n    min_len,\n    not_,\n    optional,\n)\n\nfrom .utils import simple_attr\n\n\nclass TestDisableValidators:\n    @pytest.fixture(autouse=True)\n    def _reset_default(self):\n        \"\"\"\n        Make sure validators are always enabled after a test.\n        \"\"\"\n        yield\n        _config._run_validators = True\n\n    def test_default(self):\n        \"\"\"\n        Run validators by default.\n        \"\"\"\n        assert _config._run_validators is True\n\n    @pytest.mark.parametrize(\n        (\"value\", \"expected\"), [(True, False), (False, True)]\n    )\n    def test_set_validators_disabled(self, value, expected):\n        \"\"\"\n        Sets `_run_validators`.\n        \"\"\"\n        validator_module.set_disabled(value)\n\n        assert _config._run_validators is expected\n\n    @pytest.mark.parametrize(\n        (\"value\", \"expected\"), [(True, False), (False, True)]\n    )\n    def test_disabled(self, value, expected):\n        \"\"\"\n        Returns `_run_validators`.\n        \"\"\"\n        _config._run_validators = value\n\n        assert validator_module.get_disabled() is expected\n\n    def test_disabled_ctx(self):\n        \"\"\"\n        The `disabled` context manager disables running validators,\n        but only within its context.\n        \"\"\"\n        assert _config._run_validators is True\n\n        with validator_module.disabled():\n            assert _config._run_validators is False\n\n        assert _config._run_validators is True\n\n    def test_disabled_ctx_with_errors(self):\n        \"\"\"\n        Running validators is re-enabled even if an error is raised.\n        \"\"\"\n        assert _config._run_validators is True\n\n        with pytest.raises(ValueError), validator_module.disabled():\n            assert _config._run_validators is False\n\n            raise ValueError(\"haha!\")\n\n        assert _config._run_validators is True\n\n\nclass TestInstanceOf:\n    \"\"\"\n    Tests for `instance_of`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert instance_of.__name__ in validator_module.__all__\n\n    def test_success(self):\n        \"\"\"\n        Nothing happens if types match.\n        \"\"\"\n        v = instance_of(int)\n        v(None, simple_attr(\"test\"), 42)\n\n    def test_subclass(self):\n        \"\"\"\n        Subclasses are accepted too.\n        \"\"\"\n        v = instance_of(int)\n        # yep, bools are a subclass of int :(\n        v(None, simple_attr(\"test\"), True)\n\n    def test_fail(self):\n        \"\"\"\n        Raises `TypeError` on wrong types.\n        \"\"\"\n        v = instance_of(int)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError) as e:\n            v(None, a, \"42\")\n        assert (\n            \"'test' must be <class 'int'> (got '42' that is a <class 'str'>).\",\n            a,\n            int,\n            \"42\",\n        ) == e.value.args\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        v = instance_of(int)\n        assert (\"<instance_of validator for type <class 'int'>>\") == repr(v)\n\n\nclass TestMatchesRe:\n    \"\"\"\n    Tests for `matches_re`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        validator is in ``__all__``.\n        \"\"\"\n        assert matches_re.__name__ in validator_module.__all__\n\n    def test_match(self):\n        \"\"\"\n        Silent on matches, raises ValueError on mismatches.\n        \"\"\"\n\n        @attr.s\n        class ReTester:\n            str_match = attr.ib(validator=matches_re(\"a|ab\"))\n\n        ReTester(\"ab\")  # shouldn't raise exceptions\n        with pytest.raises(TypeError):\n            ReTester(1)\n        with pytest.raises(ValueError):\n            ReTester(\"1\")\n        with pytest.raises(ValueError):\n            ReTester(\"a1\")\n\n    def test_flags(self):\n        \"\"\"\n        Flags are propagated to the match function.\n        \"\"\"\n\n        @attr.s\n        class MatchTester:\n            val = attr.ib(validator=matches_re(\"a\", re.IGNORECASE, re.match))\n\n        MatchTester(\"A1\")  # test flags and using re.match\n\n    def test_precompiled_pattern(self):\n        \"\"\"\n        Pre-compiled patterns are accepted.\n        \"\"\"\n        pattern = re.compile(\"a\")\n\n        @attr.s\n        class RePatternTester:\n            val = attr.ib(validator=matches_re(pattern))\n\n        RePatternTester(\"a\")\n\n    def test_precompiled_pattern_no_flags(self):\n        \"\"\"\n        A pre-compiled pattern cannot be combined with a 'flags' argument.\n        \"\"\"\n        pattern = re.compile(\"\")\n\n        with pytest.raises(\n            TypeError, match=\"can only be used with a string pattern\"\n        ):\n            matches_re(pattern, flags=re.IGNORECASE)\n\n    def test_different_func(self):\n        \"\"\"\n        Changing the match functions works.\n        \"\"\"\n\n        @attr.s\n        class SearchTester:\n            val = attr.ib(validator=matches_re(\"a\", 0, re.search))\n\n        SearchTester(\"bab\")  # re.search will match\n\n    def test_catches_invalid_func(self):\n        \"\"\"\n        Invalid match functions are caught.\n        \"\"\"\n        with pytest.raises(ValueError) as ei:\n            matches_re(\"a\", 0, lambda: None)\n\n        assert (\n            \"'func' must be one of None, fullmatch, match, search.\"\n            == ei.value.args[0]\n        )\n\n    @pytest.mark.parametrize(\n        \"func\", [None, getattr(re, \"fullmatch\", None), re.match, re.search]\n    )\n    def test_accepts_all_valid_func(self, func):\n        \"\"\"\n        Every valid match function is accepted.\n        \"\"\"\n        matches_re(\"a\", func=func)\n\n    def test_repr(self):\n        \"\"\"\n        __repr__ is meaningful.\n        \"\"\"\n        assert repr(matches_re(\"a\")).startswith(\n            \"<matches_re validator for pattern\"\n        )\n\n\ndef always_pass(_, __, ___):\n    \"\"\"\n    Toy validator that always passes.\n    \"\"\"\n\n\ndef always_fail(_, __, ___):\n    \"\"\"\n    Toy validator that always fails.\n    \"\"\"\n    0 / 0\n\n\nclass TestAnd:\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert and_.__name__ in validator_module.__all__\n\n    def test_success(self):\n        \"\"\"\n        Succeeds if all wrapped validators succeed.\n        \"\"\"\n        v = and_(instance_of(int), always_pass)\n\n        v(None, simple_attr(\"test\"), 42)\n\n    def test_fail(self):\n        \"\"\"\n        Fails if any wrapped validator fails.\n        \"\"\"\n        v = and_(instance_of(int), always_fail)\n\n        with pytest.raises(ZeroDivisionError):\n            v(None, simple_attr(\"test\"), 42)\n\n    def test_sugar(self):\n        \"\"\"\n        `and_(v1, v2, v3)` and `[v1, v2, v3]` are equivalent.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a1 = attr.ib(\"a1\", validator=and_(instance_of(int)))\n            a2 = attr.ib(\"a2\", validator=[instance_of(int)])\n\n        assert C.__attrs_attrs__[0].validator == C.__attrs_attrs__[1].validator\n\n\n@pytest.mark.parametrize(\n    \"validator\",\n    [\n        instance_of(int),\n        [always_pass, instance_of(int)],\n        (always_pass, instance_of(int)),\n    ],\n)\nclass TestOptional:\n    \"\"\"\n    Tests for `optional`.\n    \"\"\"\n\n    def test_in_all(self, validator):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert optional.__name__ in validator_module.__all__\n\n    def test_success(self, validator):\n        \"\"\"\n        Nothing happens if validator succeeds.\n        \"\"\"\n        v = optional(validator)\n        v(None, simple_attr(\"test\"), 42)\n\n    def test_success_with_none(self, validator):\n        \"\"\"\n        Nothing happens if None.\n        \"\"\"\n        v = optional(validator)\n        v(None, simple_attr(\"test\"), None)\n\n    def test_fail(self, validator):\n        \"\"\"\n        Raises `TypeError` on wrong types.\n        \"\"\"\n        v = optional(validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError) as e:\n            v(None, a, \"42\")\n        assert (\n            \"'test' must be <class 'int'> (got '42' that is a <class 'str'>).\",\n            a,\n            int,\n            \"42\",\n        ) == e.value.args\n\n    def test_repr(self, validator):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        v = optional(validator)\n\n        if isinstance(validator, list):\n            repr_s = (\n                f\"<optional validator for _AndValidator(_validators=[{always_pass!r}, \"\n                \"<instance_of validator for type <class 'int'>>]) or None>\"\n            )\n        elif isinstance(validator, tuple):\n            repr_s = (\n                f\"<optional validator for _AndValidator(_validators=({always_pass!r}, \"\n                \"<instance_of validator for type <class 'int'>>)) or None>\"\n            )\n        else:\n            repr_s = (\n                \"<optional validator for <instance_of validator for type \"\n                \"<class 'int'>> or None>\"\n            )\n\n        assert repr_s == repr(v)\n\n\nclass TestIn_:\n    \"\"\"\n    Tests for `in_`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert in_.__name__ in validator_module.__all__\n\n    def test_success_with_value(self):\n        \"\"\"\n        If the value is in our options, nothing happens.\n        \"\"\"\n        v = in_([1, 2, 3])\n        a = simple_attr(\"test\")\n        v(1, a, 3)\n\n    def test_fail(self):\n        \"\"\"\n        Raise ValueError if the value is outside our options.\n        \"\"\"\n        v = in_([1, 2, 3])\n        a = simple_attr(\"test\")\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, None)\n\n        assert (\n            \"'test' must be in [1, 2, 3] (got None)\",\n            a,\n            [1, 2, 3],\n            None,\n        ) == e.value.args\n\n    def test_fail_with_string(self):\n        \"\"\"\n        Raise ValueError if the value is outside our options when the\n        options are specified as a string and the value is not a string.\n        \"\"\"\n        v = in_(\"abc\")\n        a = simple_attr(\"test\")\n        with pytest.raises(ValueError) as e:\n            v(None, a, None)\n        assert (\n            \"'test' must be in 'abc' (got None)\",\n            a,\n            \"abc\",\n            None,\n        ) == e.value.args\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        v = in_([3, 4, 5])\n        assert (\"<in_ validator with options [3, 4, 5]>\") == repr(v)\n\n\n@pytest.fixture(\n    name=\"member_validator\",\n    params=(\n        instance_of(int),\n        [always_pass, instance_of(int)],\n        (always_pass, instance_of(int)),\n    ),\n    scope=\"module\",\n)\ndef _member_validator(request):\n    \"\"\"\n    Provides sample `member_validator`s for some tests in `TestDeepIterable`\n    \"\"\"\n    return request.param\n\n\nclass TestDeepIterable:\n    \"\"\"\n    Tests for `deep_iterable`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert deep_iterable.__name__ in validator_module.__all__\n\n    def test_success_member_only(self, member_validator):\n        \"\"\"\n        If the member validator succeeds and the iterable validator is not set,\n        nothing happens.\n        \"\"\"\n        v = deep_iterable(member_validator)\n        a = simple_attr(\"test\")\n        v(None, a, [42])\n\n    def test_success_member_and_iterable(self, member_validator):\n        \"\"\"\n        If both the member and iterable validators succeed, nothing happens.\n        \"\"\"\n        iterable_validator = instance_of(list)\n        v = deep_iterable(member_validator, iterable_validator)\n        a = simple_attr(\"test\")\n        v(None, a, [42])\n\n    @pytest.mark.parametrize(\n        (\"member_validator\", \"iterable_validator\"),\n        [\n            (instance_of(int), 42),\n            (42, instance_of(list)),\n            (42, 42),\n            (42, None),\n            ([instance_of(int), 42], 42),\n            ([42, instance_of(int)], 42),\n        ],\n    )\n    def test_noncallable_validators(\n        self, member_validator, iterable_validator\n    ):\n        \"\"\"\n        Raise `TypeError` if any validators are not callable.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            deep_iterable(member_validator, iterable_validator)\n        value = 42\n        message = (\n            f\"must be callable (got {value} that is a {value.__class__}).\"\n        )\n\n        assert message in e.value.args[0]\n        assert value == e.value.args[1]\n        assert message in e.value.msg\n        assert value == e.value.value\n\n    def test_fail_invalid_member(self, member_validator):\n        \"\"\"\n        Raise member validator error if an invalid member is found.\n        \"\"\"\n        v = deep_iterable(member_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, [42, \"42\"])\n\n    def test_fail_invalid_iterable(self, member_validator):\n        \"\"\"\n        Raise iterable validator error if an invalid iterable is found.\n        \"\"\"\n        member_validator = instance_of(int)\n        iterable_validator = instance_of(tuple)\n        v = deep_iterable(member_validator, iterable_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, [42])\n\n    def test_fail_invalid_member_and_iterable(self, member_validator):\n        \"\"\"\n        Raise iterable validator error if both the iterable\n        and a member are invalid.\n        \"\"\"\n        iterable_validator = instance_of(tuple)\n        v = deep_iterable(member_validator, iterable_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, [42, \"42\"])\n\n    def test_repr_member_only(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`\n        when only member validator is set.\n        \"\"\"\n        member_validator = instance_of(int)\n        member_repr = \"<instance_of validator for type <class 'int'>>\"\n        v = deep_iterable(member_validator)\n        expected_repr = (\n            f\"<deep_iterable validator for iterables of {member_repr}>\"\n        )\n        assert expected_repr == repr(v)\n\n    def test_repr_member_only_sequence(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`\n        when only member validator is set and the member validator is a list of\n        validators\n        \"\"\"\n        member_validator = [always_pass, instance_of(int)]\n        member_repr = (\n            f\"_AndValidator(_validators=({always_pass!r}, \"\n            \"<instance_of validator for type <class 'int'>>))\"\n        )\n        v = deep_iterable(member_validator)\n        expected_repr = (\n            f\"<deep_iterable validator for iterables of {member_repr}>\"\n        )\n        assert expected_repr == repr(v)\n\n    def test_repr_member_and_iterable(self):\n        \"\"\"\n        Returned validator has a useful `__repr__` when both member\n        and iterable validators are set.\n        \"\"\"\n        member_validator = instance_of(int)\n        member_repr = \"<instance_of validator for type <class 'int'>>\"\n        iterable_validator = instance_of(list)\n        iterable_repr = \"<instance_of validator for type <class 'list'>>\"\n        v = deep_iterable(member_validator, iterable_validator)\n        expected_repr = (\n            \"<deep_iterable validator for\"\n            f\" {iterable_repr} iterables of {member_repr}>\"\n        )\n        assert expected_repr == repr(v)\n\n    def test_repr_sequence_member_and_iterable(self):\n        \"\"\"\n        Returned validator has a useful `__repr__` when both member\n        and iterable validators are set and the member validator is a list of\n        validators\n        \"\"\"\n        member_validator = [always_pass, instance_of(int)]\n        member_repr = (\n            f\"_AndValidator(_validators=({always_pass!r}, \"\n            \"<instance_of validator for type <class 'int'>>))\"\n        )\n        iterable_validator = instance_of(list)\n        iterable_repr = \"<instance_of validator for type <class 'list'>>\"\n        v = deep_iterable(member_validator, iterable_validator)\n        expected_repr = (\n            \"<deep_iterable validator for\"\n            f\" {iterable_repr} iterables of {member_repr}>\"\n        )\n\n        assert expected_repr == repr(v)\n\n\nclass TestDeepMapping:\n    \"\"\"\n    Tests for `deep_mapping`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert deep_mapping.__name__ in validator_module.__all__\n\n    def test_success(self):\n        \"\"\"\n        If both the key and value validators succeed, nothing happens.\n        \"\"\"\n        key_validator = instance_of(str)\n        value_validator = instance_of(int)\n        v = deep_mapping(key_validator, value_validator)\n        a = simple_attr(\"test\")\n        v(None, a, {\"a\": 6, \"b\": 7})\n\n    @pytest.mark.parametrize(\n        (\"key_validator\", \"value_validator\", \"mapping_validator\"),\n        [\n            (42, instance_of(int), None),\n            (instance_of(str), 42, None),\n            (instance_of(str), instance_of(int), 42),\n            (42, 42, None),\n            (42, 42, 42),\n        ],\n    )\n    def test_noncallable_validators(\n        self, key_validator, value_validator, mapping_validator\n    ):\n        \"\"\"\n        Raise `TypeError` if any validators are not callable.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            deep_mapping(key_validator, value_validator, mapping_validator)\n\n        value = 42\n        message = (\n            f\"must be callable (got {value} that is a {value.__class__}).\"\n        )\n\n        assert message in e.value.args[0]\n        assert value == e.value.args[1]\n        assert message in e.value.msg\n        assert value == e.value.value\n\n    def test_fail_invalid_mapping(self):\n        \"\"\"\n        Raise `TypeError` if mapping validator fails.\n        \"\"\"\n        key_validator = instance_of(str)\n        value_validator = instance_of(int)\n        mapping_validator = instance_of(dict)\n        v = deep_mapping(key_validator, value_validator, mapping_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, None)\n\n    def test_fail_invalid_key(self):\n        \"\"\"\n        Raise key validator error if an invalid key is found.\n        \"\"\"\n        key_validator = instance_of(str)\n        value_validator = instance_of(int)\n        v = deep_mapping(key_validator, value_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, {\"a\": 6, 42: 7})\n\n    def test_fail_invalid_member(self):\n        \"\"\"\n        Raise key validator error if an invalid member value is found.\n        \"\"\"\n        key_validator = instance_of(str)\n        value_validator = instance_of(int)\n        v = deep_mapping(key_validator, value_validator)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError):\n            v(None, a, {\"a\": \"6\", \"b\": 7})\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        key_validator = instance_of(str)\n        key_repr = \"<instance_of validator for type <class 'str'>>\"\n        value_validator = instance_of(int)\n        value_repr = \"<instance_of validator for type <class 'int'>>\"\n        v = deep_mapping(key_validator, value_validator)\n        expected_repr = (\n            \"<deep_mapping validator for objects mapping \"\n            f\"{key_repr} to {value_repr}>\"\n        )\n        assert expected_repr == repr(v)\n\n\nclass TestIsCallable:\n    \"\"\"\n    Tests for `is_callable`.\n    \"\"\"\n\n    def test_in_all(self):\n        \"\"\"\n        Verify that this validator is in ``__all__``.\n        \"\"\"\n        assert is_callable.__name__ in validator_module.__all__\n\n    def test_success(self):\n        \"\"\"\n        If the value is callable, nothing happens.\n        \"\"\"\n        v = is_callable()\n        a = simple_attr(\"test\")\n        v(None, a, isinstance)\n\n    def test_fail(self):\n        \"\"\"\n        Raise TypeError if the value is not callable.\n        \"\"\"\n        v = is_callable()\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError) as e:\n            v(None, a, None)\n\n        value = None\n        message = \"'test' must be callable (got {value} that is a {type_}).\"\n        expected_message = message.format(value=value, type_=value.__class__)\n\n        assert expected_message == e.value.args[0]\n        assert value == e.value.args[1]\n        assert expected_message == e.value.msg\n        assert value == e.value.value\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        v = is_callable()\n        assert \"<is_callable validator>\" == repr(v)\n\n    def test_exception_repr(self):\n        \"\"\"\n        Verify that NotCallableError exception has a useful `__str__`.\n        \"\"\"\n        from attr.exceptions import NotCallableError\n\n        instance = NotCallableError(msg=\"Some Message\", value=42)\n        assert \"Some Message\" == str(instance)\n\n\ndef test_hashability():\n    \"\"\"\n    Validator classes are hashable.\n    \"\"\"\n    for obj_name in dir(validator_module):\n        obj = getattr(validator_module, obj_name)\n        if not has(obj):\n            continue\n        hash_func = getattr(obj, \"__hash__\", None)\n        assert hash_func is not None\n        assert hash_func is not object.__hash__\n\n\nclass TestLtLeGeGt:\n    \"\"\"\n    Tests for `Lt, Le, Ge, Gt`.\n    \"\"\"\n\n    BOUND = 4\n\n    def test_in_all(self):\n        \"\"\"\n        validator is in ``__all__``.\n        \"\"\"\n        assert all(\n            f.__name__ in validator_module.__all__ for f in [lt, le, ge, gt]\n        )\n\n    @pytest.mark.parametrize(\"v\", [lt, le, ge, gt])\n    def test_retrieve_bound(self, v):\n        \"\"\"\n        The configured bound for the comparison can be extracted from the\n        Attribute.\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=v(self.BOUND))\n\n        assert fields(Tester).value.validator.bound == self.BOUND\n\n    @pytest.mark.parametrize(\n        (\"v\", \"value\"),\n        [\n            (lt, 3),\n            (le, 3),\n            (le, 4),\n            (ge, 4),\n            (ge, 5),\n            (gt, 5),\n        ],\n    )\n    def test_check_valid(self, v, value):\n        \"\"\"Silent if value {op} bound.\"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=v(self.BOUND))\n\n        Tester(value)  # shouldn't raise exceptions\n\n    @pytest.mark.parametrize(\n        (\"v\", \"value\"),\n        [\n            (lt, 4),\n            (le, 5),\n            (ge, 3),\n            (gt, 4),\n        ],\n    )\n    def test_check_invalid(self, v, value):\n        \"\"\"Raise ValueError if value {op} bound.\"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=v(self.BOUND))\n\n        with pytest.raises(ValueError):\n            Tester(value)\n\n    @pytest.mark.parametrize(\"v\", [lt, le, ge, gt])\n    def test_repr(self, v):\n        \"\"\"\n        __repr__ is meaningful.\n        \"\"\"\n        nv = v(23)\n        assert repr(nv) == f\"<Validator for x {nv.compare_op} {23}>\"\n\n\nclass TestMaxLen:\n    \"\"\"\n    Tests for `max_len`.\n    \"\"\"\n\n    MAX_LENGTH = 4\n\n    def test_in_all(self):\n        \"\"\"\n        validator is in ``__all__``.\n        \"\"\"\n        assert max_len.__name__ in validator_module.__all__\n\n    def test_retrieve_max_len(self):\n        \"\"\"\n        The configured max. length can be extracted from the Attribute\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=max_len(self.MAX_LENGTH))\n\n        assert fields(Tester).value.validator.max_length == self.MAX_LENGTH\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [\n            \"\",\n            \"foo\",\n            \"spam\",\n            [],\n            list(range(MAX_LENGTH)),\n            {\"spam\": 3, \"eggs\": 4},\n        ],\n    )\n    def test_check_valid(self, value):\n        \"\"\"\n        Silent if len(value) <= max_len.\n        Values can be strings and other iterables.\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=max_len(self.MAX_LENGTH))\n\n        Tester(value)  # shouldn't raise exceptions\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [\n            \"bacon\",\n            list(range(6)),\n        ],\n    )\n    def test_check_invalid(self, value):\n        \"\"\"\n        Raise ValueError if len(value) > max_len.\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=max_len(self.MAX_LENGTH))\n\n        with pytest.raises(ValueError):\n            Tester(value)\n\n    def test_repr(self):\n        \"\"\"\n        __repr__ is meaningful.\n        \"\"\"\n        assert repr(max_len(23)) == \"<max_len validator for 23>\"\n\n\nclass TestMinLen:\n    \"\"\"\n    Tests for `min_len`.\n    \"\"\"\n\n    MIN_LENGTH = 2\n\n    def test_in_all(self):\n        \"\"\"\n        validator is in ``__all__``.\n        \"\"\"\n        assert min_len.__name__ in validator_module.__all__\n\n    def test_retrieve_min_len(self):\n        \"\"\"\n        The configured min. length can be extracted from the Attribute\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=min_len(self.MIN_LENGTH))\n\n        assert fields(Tester).value.validator.min_length == self.MIN_LENGTH\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [\n            \"foo\",\n            \"spam\",\n            list(range(MIN_LENGTH)),\n            {\"spam\": 3, \"eggs\": 4},\n        ],\n    )\n    def test_check_valid(self, value):\n        \"\"\"\n        Silent if len(value) => min_len.\n        Values can be strings and other iterables.\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=min_len(self.MIN_LENGTH))\n\n        Tester(value)  # shouldn't raise exceptions\n\n    @pytest.mark.parametrize(\n        \"value\",\n        [\n            \"\",\n            list(range(1)),\n        ],\n    )\n    def test_check_invalid(self, value):\n        \"\"\"\n        Raise ValueError if len(value) < min_len.\n        \"\"\"\n\n        @attr.s\n        class Tester:\n            value = attr.ib(validator=min_len(self.MIN_LENGTH))\n\n        with pytest.raises(ValueError):\n            Tester(value)\n\n    def test_repr(self):\n        \"\"\"\n        __repr__ is meaningful.\n        \"\"\"\n        assert repr(min_len(23)) == \"<min_len validator for 23>\"\n\n\nclass TestSubclassOf:\n    \"\"\"\n    Tests for `_subclass_of`.\n    \"\"\"\n\n    def test_success(self):\n        \"\"\"\n        Nothing happens if classes match.\n        \"\"\"\n        v = _subclass_of(int)\n        v(None, simple_attr(\"test\"), int)\n\n    def test_subclass(self):\n        \"\"\"\n        Subclasses are accepted too.\n        \"\"\"\n        v = _subclass_of(int)\n        # yep, bools are a subclass of int :(\n        v(None, simple_attr(\"test\"), bool)\n\n    def test_fail(self):\n        \"\"\"\n        Raises `TypeError` on wrong types.\n        \"\"\"\n        v = _subclass_of(int)\n        a = simple_attr(\"test\")\n        with pytest.raises(TypeError) as e:\n            v(None, a, str)\n        assert (\n            \"'test' must be a subclass of <class 'int'> (got <class 'str'>).\",\n            a,\n            int,\n            str,\n        ) == e.value.args\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        v = _subclass_of(int)\n        assert (\"<subclass_of validator for type <class 'int'>>\") == repr(v)\n\n\nclass TestNot_:\n    \"\"\"\n    Tests for `not_`.\n    \"\"\"\n\n    DEFAULT_EXC_TYPES = (ValueError, TypeError)\n\n    def test_not_all(self):\n        \"\"\"\n        The validator is in ``__all__``.\n        \"\"\"\n        assert not_.__name__ in validator_module.__all__\n\n    def test_repr(self):\n        \"\"\"\n        Returned validator has a useful `__repr__`.\n        \"\"\"\n        wrapped = in_([3, 4, 5])\n\n        v = not_(wrapped)\n\n        assert (\n            f\"<not_ validator wrapping {wrapped!r}, \"\n            f\"capturing {v.exc_types!r}>\"\n        ) == repr(v)\n\n    def test_success_because_fails(self):\n        \"\"\"\n        If the wrapped validator fails, we're happy.\n        \"\"\"\n\n        def always_fails(inst, attr, value):\n            raise ValueError(\"always fails\")\n\n        v = not_(always_fails)\n        a = simple_attr(\"test\")\n        input_value = 3\n\n        v(1, a, input_value)\n\n    def test_fails_because_success(self):\n        \"\"\"\n        If the wrapped validator doesn't fail, not_ should fail.\n        \"\"\"\n\n        def always_passes(inst, attr, value):\n            pass\n\n        v = not_(always_passes)\n        a = simple_attr(\"test\")\n        input_value = 3\n\n        with pytest.raises(ValueError) as e:\n            v(1, a, input_value)\n\n        assert (\n            (\n                f\"not_ validator child '{always_passes!r}' did not raise a captured error\"\n            ),\n            a,\n            always_passes,\n            input_value,\n            self.DEFAULT_EXC_TYPES,\n        ) == e.value.args\n\n    def test_composable_with_in_pass(self):\n        \"\"\"\n        Check something is ``not in`` something else.\n        \"\"\"\n        v = not_(in_(\"abc\"))\n        a = simple_attr(\"test\")\n        input_value = \"d\"\n\n        v(None, a, input_value)\n\n    def test_composable_with_in_fail(self):\n        \"\"\"\n        Check something is ``not in`` something else, but it is, so fail.\n        \"\"\"\n        wrapped = in_(\"abc\")\n        v = not_(wrapped)\n        a = simple_attr(\"test\")\n        input_value = \"b\"\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, input_value)\n\n        assert (\n            (\n                \"not_ validator child '{!r}' did not raise a captured error\"\n            ).format(in_(\"abc\")),\n            a,\n            wrapped,\n            input_value,\n            self.DEFAULT_EXC_TYPES,\n        ) == e.value.args\n\n    def test_composable_with_matches_re_pass(self):\n        \"\"\"\n        Check something does not match a regex.\n        \"\"\"\n        v = not_(matches_re(\"[a-z]{3}\"))\n        a = simple_attr(\"test\")\n        input_value = \"spam\"\n\n        v(None, a, input_value)\n\n    def test_composable_with_matches_re_fail(self):\n        \"\"\"\n        Check something does not match a regex, but it does, so fail.\n        \"\"\"\n        wrapped = matches_re(\"[a-z]{3}\")\n        v = not_(wrapped)\n        a = simple_attr(\"test\")\n        input_value = \"egg\"\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, input_value)\n\n        assert (\n            (\n                f\"not_ validator child '{wrapped!r}' did not raise a captured error\"\n            ),\n            a,\n            wrapped,\n            input_value,\n            self.DEFAULT_EXC_TYPES,\n        ) == e.value.args\n\n    def test_composable_with_instance_of_pass(self):\n        \"\"\"\n        Check something is not a type. This validator raises a TypeError,\n        rather than a ValueError like the others.\n        \"\"\"\n        v = not_(instance_of((int, float)))\n        a = simple_attr(\"test\")\n\n        v(None, a, \"spam\")\n\n    def test_composable_with_instance_of_fail(self):\n        \"\"\"\n        Check something is not a type, but it is, so fail.\n        \"\"\"\n        wrapped = instance_of((int, float))\n        v = not_(wrapped)\n        a = simple_attr(\"test\")\n        input_value = 2.718281828\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, input_value)\n\n        assert (\n            (\n                f\"not_ validator child '{instance_of((int, float))!r}' did not raise a captured error\"\n            ),\n            a,\n            wrapped,\n            input_value,\n            self.DEFAULT_EXC_TYPES,\n        ) == e.value.args\n\n    def test_custom_capture_match(self):\n        \"\"\"\n        Match a custom exception provided to `not_`\n        \"\"\"\n        v = not_(in_(\"abc\"), exc_types=ValueError)\n        a = simple_attr(\"test\")\n\n        v(None, a, \"d\")\n\n    def test_custom_capture_miss(self):\n        \"\"\"\n        If the exception doesn't match, the underlying raise comes through\n        \"\"\"\n\n        class MyError(Exception):\n            \"\"\":(\"\"\"\n\n        wrapped = in_(\"abc\")\n        v = not_(wrapped, exc_types=MyError)\n        a = simple_attr(\"test\")\n        input_value = \"d\"\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, input_value)\n\n        # get the underlying exception to compare\n        with pytest.raises(Exception) as e_from_wrapped:\n            wrapped(None, a, input_value)\n        assert e_from_wrapped.value.args == e.value.args\n\n    def test_custom_msg(self):\n        \"\"\"\n        If provided, use the custom message in the raised error\n        \"\"\"\n        custom_msg = \"custom message!\"\n        wrapped = in_(\"abc\")\n        v = not_(wrapped, msg=custom_msg)\n        a = simple_attr(\"test\")\n        input_value = \"a\"\n\n        with pytest.raises(ValueError) as e:\n            v(None, a, input_value)\n\n        assert (\n            custom_msg,\n            a,\n            wrapped,\n            input_value,\n            self.DEFAULT_EXC_TYPES,\n        ) == e.value.args\n\n    def test_bad_exception_args(self):\n        \"\"\"\n        Malformed exception arguments\n        \"\"\"\n        wrapped = in_(\"abc\")\n\n        with pytest.raises(TypeError) as e:\n            not_(wrapped, exc_types=(str, int))\n\n        assert (\n            \"'exc_types' must be a subclass of <class 'Exception'> \"\n            \"(got <class 'str'>).\"\n        ) == e.value.args[0]\n", "tests/test_funcs.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr._funcs`.\n\"\"\"\n\nimport re\n\nfrom collections import OrderedDict\nfrom typing import Generic, NamedTuple, TypeVar\n\nimport pytest\n\nfrom hypothesis import assume, given\nfrom hypothesis import strategies as st\n\nimport attr\n\nfrom attr import asdict, assoc, astuple, evolve, fields, has\nfrom attr._compat import Mapping, Sequence\nfrom attr.exceptions import AttrsAttributeNotFoundError\nfrom attr.validators import instance_of\n\nfrom .strategies import nested_classes, simple_classes\n\n\nMAPPING_TYPES = (dict, OrderedDict)\nSEQUENCE_TYPES = (list, tuple)\n\n\n@pytest.fixture(scope=\"session\", name=\"C\")\ndef _C():\n    \"\"\"\n    Return a simple but fully featured attrs class with an x and a y attribute.\n    \"\"\"\n    import attr\n\n    @attr.s\n    class C:\n        x = attr.ib()\n        y = attr.ib()\n\n    return C\n\n\nclass TestAsDict:\n    \"\"\"\n    Tests for `asdict`.\n    \"\"\"\n\n    @given(st.sampled_from(MAPPING_TYPES))\n    def test_shallow(self, C, dict_factory):\n        \"\"\"\n        Shallow asdict returns correct dict.\n        \"\"\"\n        assert {\"x\": 1, \"y\": 2} == asdict(\n            C(x=1, y=2), False, dict_factory=dict_factory\n        )\n\n    @given(st.sampled_from(MAPPING_TYPES))\n    def test_recurse(self, C, dict_class):\n        \"\"\"\n        Deep asdict returns correct dict.\n        \"\"\"\n        assert {\"x\": {\"x\": 1, \"y\": 2}, \"y\": {\"x\": 3, \"y\": 4}} == asdict(\n            C(C(1, 2), C(3, 4)), dict_factory=dict_class\n        )\n\n    def test_nested_lists(self, C):\n        \"\"\"\n        Test unstructuring deeply nested lists.\n        \"\"\"\n        inner = C(1, 2)\n        outer = C([[inner]], None)\n\n        assert {\"x\": [[{\"x\": 1, \"y\": 2}]], \"y\": None} == asdict(outer)\n\n    def test_nested_dicts(self, C):\n        \"\"\"\n        Test unstructuring deeply nested dictionaries.\n        \"\"\"\n        inner = C(1, 2)\n        outer = C({1: {2: inner}}, None)\n\n        assert {\"x\": {1: {2: {\"x\": 1, \"y\": 2}}}, \"y\": None} == asdict(outer)\n\n    @given(nested_classes, st.sampled_from(MAPPING_TYPES))\n    def test_recurse_property(self, cls, dict_class):\n        \"\"\"\n        Property tests for recursive asdict.\n        \"\"\"\n        obj = cls()\n        obj_dict = asdict(obj, dict_factory=dict_class)\n\n        def assert_proper_dict_class(obj, obj_dict):\n            assert isinstance(obj_dict, dict_class)\n\n            for field in fields(obj.__class__):\n                field_val = getattr(obj, field.name)\n                if has(field_val.__class__):\n                    # This field holds a class, recurse the assertions.\n                    assert_proper_dict_class(field_val, obj_dict[field.name])\n                elif isinstance(field_val, Sequence):\n                    dict_val = obj_dict[field.name]\n                    for item, item_dict in zip(field_val, dict_val):\n                        if has(item.__class__):\n                            assert_proper_dict_class(item, item_dict)\n                elif isinstance(field_val, Mapping):\n                    # This field holds a dictionary.\n                    assert isinstance(obj_dict[field.name], dict_class)\n\n                    for key, val in field_val.items():\n                        if has(val.__class__):\n                            assert_proper_dict_class(\n                                val, obj_dict[field.name][key]\n                            )\n\n        assert_proper_dict_class(obj, obj_dict)\n\n    @given(st.sampled_from(MAPPING_TYPES))\n    def test_filter(self, C, dict_factory):\n        \"\"\"\n        Attributes that are supposed to be skipped are skipped.\n        \"\"\"\n        assert {\"x\": {\"x\": 1}} == asdict(\n            C(C(1, 2), C(3, 4)),\n            filter=lambda a, v: a.name != \"y\",\n            dict_factory=dict_factory,\n        )\n\n    @given(container=st.sampled_from(SEQUENCE_TYPES))\n    def test_lists_tuples(self, container, C):\n        \"\"\"\n        If recurse is True, also recurse into lists.\n        \"\"\"\n        assert {\n            \"x\": 1,\n            \"y\": [{\"x\": 2, \"y\": 3}, {\"x\": 4, \"y\": 5}, \"a\"],\n        } == asdict(C(1, container([C(2, 3), C(4, 5), \"a\"])))\n\n    @given(container=st.sampled_from(SEQUENCE_TYPES))\n    def test_lists_tuples_retain_type(self, container, C):\n        \"\"\"\n        If recurse and retain_collection_types are True, also recurse\n        into lists and do not convert them into list.\n        \"\"\"\n        assert {\n            \"x\": 1,\n            \"y\": container([{\"x\": 2, \"y\": 3}, {\"x\": 4, \"y\": 5}, \"a\"]),\n        } == asdict(\n            C(1, container([C(2, 3), C(4, 5), \"a\"])),\n            retain_collection_types=True,\n        )\n\n    @given(set_type=st.sampled_from((set, frozenset)))\n    def test_sets_no_retain(self, C, set_type):\n        \"\"\"\n        Set types are converted to lists if retain_collection_types=False.\n        \"\"\"\n        d = asdict(\n            C(1, set_type((1, 2, 3))),\n            retain_collection_types=False,\n            recurse=True,\n        )\n\n        assert {\"x\": 1, \"y\": [1, 2, 3]} == d\n\n    @given(st.sampled_from(MAPPING_TYPES))\n    def test_dicts(self, C, dict_factory):\n        \"\"\"\n        If recurse is True, also recurse into dicts.\n        \"\"\"\n        res = asdict(C(1, {\"a\": C(4, 5)}), dict_factory=dict_factory)\n\n        assert {\"x\": 1, \"y\": {\"a\": {\"x\": 4, \"y\": 5}}} == res\n        assert isinstance(res, dict_factory)\n\n    @given(simple_classes(private_attrs=False), st.sampled_from(MAPPING_TYPES))\n    def test_roundtrip(self, cls, dict_class):\n        \"\"\"\n        Test dumping to dicts and back for Hypothesis-generated classes.\n\n        Private attributes don't round-trip (the attribute name is different\n        than the initializer argument).\n        \"\"\"\n        instance = cls()\n        dict_instance = asdict(instance, dict_factory=dict_class)\n\n        assert isinstance(dict_instance, dict_class)\n\n        roundtrip_instance = cls(**dict_instance)\n\n        assert instance == roundtrip_instance\n\n    @given(simple_classes())\n    def test_asdict_preserve_order(self, cls):\n        \"\"\"\n        Field order should be preserved when dumping to an ordered_dict.\n        \"\"\"\n        instance = cls()\n        dict_instance = asdict(instance, dict_factory=dict)\n\n        assert [a.name for a in fields(cls)] == list(dict_instance.keys())\n\n    def test_retain_keys_are_tuples(self):\n        \"\"\"\n        retain_collect_types also retains keys.\n        \"\"\"\n\n        @attr.s\n        class A:\n            a = attr.ib()\n\n        instance = A({(1,): 1})\n\n        assert {\"a\": {(1,): 1}} == attr.asdict(\n            instance, retain_collection_types=True\n        )\n\n    def test_tuple_keys(self):\n        \"\"\"\n        If a key is collection type, retain_collection_types is False,\n         the key is serialized as a tuple.\n\n        See #646\n        \"\"\"\n\n        @attr.s\n        class A:\n            a = attr.ib()\n\n        instance = A({(1,): 1})\n\n        assert {\"a\": {(1,): 1}} == attr.asdict(instance)\n\n    def test_named_tuple_retain_type(self):\n        \"\"\"\n        Namedtuples can be serialized if retain_collection_types is True.\n\n        See #1164\n        \"\"\"\n\n        class Coordinates(NamedTuple):\n            lat: float\n            lon: float\n\n        @attr.s\n        class A:\n            coords: Coordinates = attr.ib()\n\n        instance = A(Coordinates(50.419019, 30.516225))\n\n        assert {\"coords\": Coordinates(50.419019, 30.516225)} == attr.asdict(\n            instance, retain_collection_types=True\n        )\n\n    def test_type_error_with_retain_type(self):\n        \"\"\"\n        Serialization that fails with TypeError leaves the error through if\n        they're not tuples.\n\n        See #1164\n        \"\"\"\n\n        message = \"__new__() missing 1 required positional argument (asdict)\"\n\n        class Coordinates(list):\n            def __init__(self, first, *rest):\n                if isinstance(first, list):\n                    raise TypeError(message)\n                super().__init__([first, *rest])\n\n        @attr.s\n        class A:\n            coords: Coordinates = attr.ib()\n\n        instance = A(Coordinates(50.419019, 30.516225))\n\n        with pytest.raises(TypeError, match=re.escape(message)):\n            attr.asdict(instance, retain_collection_types=True)\n\n\nclass TestAsTuple:\n    \"\"\"\n    Tests for `astuple`.\n    \"\"\"\n\n    @given(st.sampled_from(SEQUENCE_TYPES))\n    def test_shallow(self, C, tuple_factory):\n        \"\"\"\n        Shallow astuple returns correct dict.\n        \"\"\"\n        assert tuple_factory([1, 2]) == astuple(\n            C(x=1, y=2), False, tuple_factory=tuple_factory\n        )\n\n    @given(st.sampled_from(SEQUENCE_TYPES))\n    def test_recurse(self, C, tuple_factory):\n        \"\"\"\n        Deep astuple returns correct tuple.\n        \"\"\"\n        assert tuple_factory(\n            [tuple_factory([1, 2]), tuple_factory([3, 4])]\n        ) == astuple(C(C(1, 2), C(3, 4)), tuple_factory=tuple_factory)\n\n    @given(nested_classes, st.sampled_from(SEQUENCE_TYPES))\n    def test_recurse_property(self, cls, tuple_class):\n        \"\"\"\n        Property tests for recursive astuple.\n        \"\"\"\n        obj = cls()\n        obj_tuple = astuple(obj, tuple_factory=tuple_class)\n\n        def assert_proper_tuple_class(obj, obj_tuple):\n            assert isinstance(obj_tuple, tuple_class)\n            for index, field in enumerate(fields(obj.__class__)):\n                field_val = getattr(obj, field.name)\n                if has(field_val.__class__):\n                    # This field holds a class, recurse the assertions.\n                    assert_proper_tuple_class(field_val, obj_tuple[index])\n\n        assert_proper_tuple_class(obj, obj_tuple)\n\n    @given(nested_classes, st.sampled_from(SEQUENCE_TYPES))\n    def test_recurse_retain(self, cls, tuple_class):\n        \"\"\"\n        Property tests for asserting collection types are retained.\n        \"\"\"\n        obj = cls()\n        obj_tuple = astuple(\n            obj, tuple_factory=tuple_class, retain_collection_types=True\n        )\n\n        def assert_proper_col_class(obj, obj_tuple):\n            # Iterate over all attributes, and if they are lists or mappings\n            # in the original, assert they are the same class in the dumped.\n            for index, field in enumerate(fields(obj.__class__)):\n                field_val = getattr(obj, field.name)\n                if has(field_val.__class__):\n                    # This field holds a class, recurse the assertions.\n                    assert_proper_col_class(field_val, obj_tuple[index])\n                elif isinstance(field_val, (list, tuple)):\n                    # This field holds a sequence of something.\n                    expected_type = type(obj_tuple[index])\n                    assert type(field_val) is expected_type\n                    for obj_e, obj_tuple_e in zip(field_val, obj_tuple[index]):\n                        if has(obj_e.__class__):\n                            assert_proper_col_class(obj_e, obj_tuple_e)\n                elif isinstance(field_val, dict):\n                    orig = field_val\n                    tupled = obj_tuple[index]\n                    assert type(orig) is type(tupled)\n                    for obj_e, obj_tuple_e in zip(\n                        orig.items(), tupled.items()\n                    ):\n                        if has(obj_e[0].__class__):  # Dict key\n                            assert_proper_col_class(obj_e[0], obj_tuple_e[0])\n                        if has(obj_e[1].__class__):  # Dict value\n                            assert_proper_col_class(obj_e[1], obj_tuple_e[1])\n\n        assert_proper_col_class(obj, obj_tuple)\n\n    @given(st.sampled_from(SEQUENCE_TYPES))\n    def test_filter(self, C, tuple_factory):\n        \"\"\"\n        Attributes that are supposed to be skipped are skipped.\n        \"\"\"\n        assert tuple_factory([tuple_factory([1])]) == astuple(\n            C(C(1, 2), C(3, 4)),\n            filter=lambda a, v: a.name != \"y\",\n            tuple_factory=tuple_factory,\n        )\n\n    @given(container=st.sampled_from(SEQUENCE_TYPES))\n    def test_lists_tuples(self, container, C):\n        \"\"\"\n        If recurse is True, also recurse into lists.\n        \"\"\"\n        assert (1, [(2, 3), (4, 5), \"a\"]) == astuple(\n            C(1, container([C(2, 3), C(4, 5), \"a\"]))\n        )\n\n    @given(st.sampled_from(SEQUENCE_TYPES))\n    def test_dicts(self, C, tuple_factory):\n        \"\"\"\n        If recurse is True, also recurse into dicts.\n        \"\"\"\n        res = astuple(C(1, {\"a\": C(4, 5)}), tuple_factory=tuple_factory)\n        assert tuple_factory([1, {\"a\": tuple_factory([4, 5])}]) == res\n        assert isinstance(res, tuple_factory)\n\n    @given(container=st.sampled_from(SEQUENCE_TYPES))\n    def test_lists_tuples_retain_type(self, container, C):\n        \"\"\"\n        If recurse and retain_collection_types are True, also recurse\n        into lists and do not convert them into list.\n        \"\"\"\n        assert (1, container([(2, 3), (4, 5), \"a\"])) == astuple(\n            C(1, container([C(2, 3), C(4, 5), \"a\"])),\n            retain_collection_types=True,\n        )\n\n    @given(container=st.sampled_from(MAPPING_TYPES))\n    def test_dicts_retain_type(self, container, C):\n        \"\"\"\n        If recurse and retain_collection_types are True, also recurse\n        into lists and do not convert them into list.\n        \"\"\"\n        assert (1, container({\"a\": (4, 5)})) == astuple(\n            C(1, container({\"a\": C(4, 5)})), retain_collection_types=True\n        )\n\n    @given(simple_classes(), st.sampled_from(SEQUENCE_TYPES))\n    def test_roundtrip(self, cls, tuple_class):\n        \"\"\"\n        Test dumping to tuple and back for Hypothesis-generated classes.\n        \"\"\"\n        instance = cls()\n        tuple_instance = astuple(instance, tuple_factory=tuple_class)\n\n        assert isinstance(tuple_instance, tuple_class)\n\n        roundtrip_instance = cls(*tuple_instance)\n\n        assert instance == roundtrip_instance\n\n    @given(set_type=st.sampled_from((set, frozenset)))\n    def test_sets_no_retain(self, C, set_type):\n        \"\"\"\n        Set types are converted to lists if retain_collection_types=False.\n        \"\"\"\n        d = astuple(\n            C(1, set_type((1, 2, 3))),\n            retain_collection_types=False,\n            recurse=True,\n        )\n\n        assert (1, [1, 2, 3]) == d\n\n    def test_named_tuple_retain_type(self):\n        \"\"\"\n        Namedtuples can be serialized if retain_collection_types is True.\n\n        See #1164\n        \"\"\"\n\n        class Coordinates(NamedTuple):\n            lat: float\n            lon: float\n\n        @attr.s\n        class A:\n            coords: Coordinates = attr.ib()\n\n        instance = A(Coordinates(50.419019, 30.516225))\n\n        assert (Coordinates(50.419019, 30.516225),) == attr.astuple(\n            instance, retain_collection_types=True\n        )\n\n    def test_type_error_with_retain_type(self):\n        \"\"\"\n        Serialization that fails with TypeError leaves the error through if\n        they're not tuples.\n\n        See #1164\n        \"\"\"\n\n        message = \"__new__() missing 1 required positional argument (astuple)\"\n\n        class Coordinates(list):\n            def __init__(self, first, *rest):\n                if isinstance(first, list):\n                    raise TypeError(message)\n                super().__init__([first, *rest])\n\n        @attr.s\n        class A:\n            coords: Coordinates = attr.ib()\n\n        instance = A(Coordinates(50.419019, 30.516225))\n\n        with pytest.raises(TypeError, match=re.escape(message)):\n            attr.astuple(instance, retain_collection_types=True)\n\n\nclass TestHas:\n    \"\"\"\n    Tests for `has`.\n    \"\"\"\n\n    def test_positive(self, C):\n        \"\"\"\n        Returns `True` on decorated classes.\n        \"\"\"\n        assert has(C)\n\n    def test_positive_empty(self):\n        \"\"\"\n        Returns `True` on decorated classes even if there are no attributes.\n        \"\"\"\n\n        @attr.s\n        class D:\n            pass\n\n        assert has(D)\n\n    def test_negative(self):\n        \"\"\"\n        Returns `False` on non-decorated classes.\n        \"\"\"\n        assert not has(object)\n\n    def test_generics(self):\n        \"\"\"\n        Works with generic classes.\n        \"\"\"\n        T = TypeVar(\"T\")\n\n        @attr.define\n        class A(Generic[T]):\n            a: T\n\n        assert has(A)\n\n        assert has(A[str])\n        # Verify twice, since there's caching going on.\n        assert has(A[str])\n\n    def test_generics_negative(self):\n        \"\"\"\n        Returns `False` on non-decorated generic classes.\n        \"\"\"\n        T = TypeVar(\"T\")\n\n        class A(Generic[T]):\n            a: T\n\n        assert not has(A)\n\n        assert not has(A[str])\n        # Verify twice, since there's caching going on.\n        assert not has(A[str])\n\n\nclass TestAssoc:\n    \"\"\"\n    Tests for `assoc`.\n    \"\"\"\n\n    @given(slots=st.booleans(), frozen=st.booleans())\n    def test_empty(self, slots, frozen):\n        \"\"\"\n        Empty classes without changes get copied.\n        \"\"\"\n\n        @attr.s(slots=slots, frozen=frozen)\n        class C:\n            pass\n\n        i1 = C()\n        i2 = assoc(i1)\n\n        assert i1 is not i2\n        assert i1 == i2\n\n    @given(simple_classes())\n    def test_no_changes(self, C):\n        \"\"\"\n        No changes means a verbatim copy.\n        \"\"\"\n        i1 = C()\n        i2 = assoc(i1)\n\n        assert i1 is not i2\n        assert i1 == i2\n\n    @given(simple_classes(), st.data())\n    def test_change(self, C, data):\n        \"\"\"\n        Changes work.\n        \"\"\"\n        # Take the first attribute, and change it.\n        assume(fields(C))  # Skip classes with no attributes.\n        field_names = [a.name for a in fields(C)]\n        original = C()\n        chosen_names = data.draw(st.sets(st.sampled_from(field_names)))\n        change_dict = {name: data.draw(st.integers()) for name in chosen_names}\n\n        changed = assoc(original, **change_dict)\n\n        for k, v in change_dict.items():\n            assert getattr(changed, k) == v\n\n    @given(simple_classes())\n    def test_unknown(self, C):\n        \"\"\"\n        Wanting to change an unknown attribute raises an\n        AttrsAttributeNotFoundError.\n        \"\"\"\n        # No generated class will have a four letter attribute.\n        with pytest.raises(AttrsAttributeNotFoundError) as e:\n            assoc(C(), aaaa=2)\n\n        assert (f\"aaaa is not an attrs attribute on {C!r}.\",) == e.value.args\n\n    def test_frozen(self):\n        \"\"\"\n        Works on frozen classes.\n        \"\"\"\n\n        @attr.s(frozen=True)\n        class C:\n            x = attr.ib()\n            y = attr.ib()\n\n        assert C(3, 2) == assoc(C(1, 2), x=3)\n\n\nclass TestEvolve:\n    \"\"\"\n    Tests for `evolve`.\n    \"\"\"\n\n    @given(slots=st.booleans(), frozen=st.booleans())\n    def test_empty(self, slots, frozen):\n        \"\"\"\n        Empty classes without changes get copied.\n        \"\"\"\n\n        @attr.s(slots=slots, frozen=frozen)\n        class C:\n            pass\n\n        i1 = C()\n        i2 = evolve(i1)\n\n        assert i1 is not i2\n        assert i1 == i2\n\n    @given(simple_classes())\n    def test_no_changes(self, C):\n        \"\"\"\n        No changes means a verbatim copy.\n        \"\"\"\n        i1 = C()\n        i2 = evolve(i1)\n\n        assert i1 is not i2\n        assert i1 == i2\n\n    @given(simple_classes(), st.data())\n    def test_change(self, C, data):\n        \"\"\"\n        Changes work.\n        \"\"\"\n        # Take the first attribute, and change it.\n        assume(fields(C))  # Skip classes with no attributes.\n        field_names = [a.name for a in fields(C)]\n        original = C()\n        chosen_names = data.draw(st.sets(st.sampled_from(field_names)))\n        # We pay special attention to private attributes, they should behave\n        # like in `__init__`.\n        change_dict = {\n            name.replace(\"_\", \"\"): data.draw(st.integers())\n            for name in chosen_names\n        }\n        changed = evolve(original, **change_dict)\n        for name in chosen_names:\n            assert getattr(changed, name) == change_dict[name.replace(\"_\", \"\")]\n\n    @given(simple_classes())\n    def test_unknown(self, C):\n        \"\"\"\n        Wanting to change an unknown attribute raises an\n        AttrsAttributeNotFoundError.\n        \"\"\"\n        # No generated class will have a four letter attribute.\n        with pytest.raises(TypeError) as e:\n            evolve(C(), aaaa=2)\n\n        if hasattr(C, \"__attrs_init__\"):\n            expected = (\n                \"__attrs_init__() got an unexpected keyword argument 'aaaa'\"\n            )\n        else:\n            expected = \"__init__() got an unexpected keyword argument 'aaaa'\"\n\n        assert e.value.args[0].endswith(expected)\n\n    def test_validator_failure(self):\n        \"\"\"\n        TypeError isn't swallowed when validation fails within evolve.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a = attr.ib(validator=instance_of(int))\n\n        with pytest.raises(TypeError) as e:\n            evolve(C(a=1), a=\"some string\")\n        m = e.value.args[0]\n\n        assert m.startswith(\"'a' must be <class 'int'>\")\n\n    def test_private(self):\n        \"\"\"\n        evolve() acts as `__init__` with regards to private attributes.\n        \"\"\"\n\n        @attr.s\n        class C:\n            _a = attr.ib()\n\n        assert evolve(C(1), a=2)._a == 2\n\n        with pytest.raises(TypeError):\n            evolve(C(1), _a=2)\n\n        with pytest.raises(TypeError):\n            evolve(C(1), a=3, _a=2)\n\n    def test_non_init_attrs(self):\n        \"\"\"\n        evolve() handles `init=False` attributes.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a = attr.ib()\n            b = attr.ib(init=False, default=0)\n\n        assert evolve(C(1), a=2).a == 2\n\n    def test_regression_attrs_classes(self):\n        \"\"\"\n        evolve() can evolve fields that are instances of attrs classes.\n\n        Regression test for #804\n        \"\"\"\n\n        @attr.s\n        class Cls1:\n            param1 = attr.ib()\n\n        @attr.s\n        class Cls2:\n            param2 = attr.ib()\n\n        obj2a = Cls2(param2=\"a\")\n        obj2b = Cls2(param2=\"b\")\n\n        obj1a = Cls1(param1=obj2a)\n\n        assert Cls1(param1=Cls2(param2=\"b\")) == attr.evolve(\n            obj1a, param1=obj2b\n        )\n\n    def test_dicts(self):\n        \"\"\"\n        evolve() can replace an attrs class instance with a dict.\n\n        See #806\n        \"\"\"\n\n        @attr.s\n        class Cls1:\n            param1 = attr.ib()\n\n        @attr.s\n        class Cls2:\n            param2 = attr.ib()\n\n        obj2a = Cls2(param2=\"a\")\n        obj2b = {\"foo\": 42, \"param2\": 42}\n\n        obj1a = Cls1(param1=obj2a)\n\n        assert Cls1({\"foo\": 42, \"param2\": 42}) == attr.evolve(\n            obj1a, param1=obj2b\n        )\n\n    def test_no_inst(self):\n        \"\"\"\n        Missing inst argument raises a TypeError like Python would.\n        \"\"\"\n        with pytest.raises(\n            TypeError, match=r\"evolve\\(\\) takes 1 positional argument\"\n        ):\n            evolve(x=1)\n\n    def test_too_many_pos_args(self):\n        \"\"\"\n        More than one positional argument raises a TypeError like Python would.\n        \"\"\"\n        with pytest.raises(\n            TypeError,\n            match=r\"evolve\\(\\) takes 1 positional argument, but 2 were given\",\n        ):\n            evolve(1, 2)\n\n    def test_can_change_inst(self):\n        \"\"\"\n        If the instance is passed by positional argument, a field named `inst`\n        can be changed.\n        \"\"\"\n\n        @attr.define\n        class C:\n            inst: int\n\n        assert C(42) == evolve(C(23), inst=42)\n", "tests/strategies.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTesting strategies for Hypothesis-based tests.\n\"\"\"\nimport functools\nimport keyword\nimport string\n\nfrom collections import OrderedDict\n\nfrom hypothesis import strategies as st\n\nimport attr\n\nfrom attr._compat import PY_3_8_PLUS\n\nfrom .utils import make_class\n\n\noptional_bool = st.one_of(st.none(), st.booleans())\n\n\ndef gen_attr_names():\n    \"\"\"\n    Generate names for attributes, 'a'...'z', then 'aa'...'zz'.\n\n    ~702 different attribute names should be enough in practice.\n\n    Some short strings (such as 'as') are keywords, so we skip them.\n    \"\"\"\n    lc = string.ascii_lowercase\n    yield from lc\n    for outer in lc:\n        for inner in lc:\n            res = outer + inner\n            if keyword.iskeyword(res):\n                continue\n            yield outer + inner\n\n\ndef maybe_underscore_prefix(source):\n    \"\"\"\n    A generator to sometimes prepend an underscore.\n    \"\"\"\n    to_underscore = False\n    for val in source:\n        yield val if not to_underscore else \"_\" + val\n        to_underscore = not to_underscore\n\n\n@st.composite\ndef _create_hyp_nested_strategy(draw, simple_class_strategy):\n    \"\"\"\n    Create a recursive attrs class.\n\n    Given a strategy for building (simpler) classes, create and return\n    a strategy for building classes that have as an attribute: either just\n    the simpler class, a list of simpler classes, a tuple of simpler classes,\n    an ordered dict or a dict mapping the string \"cls\" to a simpler class.\n    \"\"\"\n    cls = draw(simple_class_strategy)\n    factories = [\n        cls,\n        lambda: [cls()],\n        lambda: (cls(),),\n        lambda: {\"cls\": cls()},\n        lambda: OrderedDict([(\"cls\", cls())]),\n    ]\n    factory = draw(st.sampled_from(factories))\n    attrs = [*draw(list_of_attrs), attr.ib(default=attr.Factory(factory))]\n    return make_class(\"HypClass\", dict(zip(gen_attr_names(), attrs)))\n\n\nbare_attrs = st.builds(attr.ib, default=st.none())\nint_attrs = st.integers().map(lambda i: attr.ib(default=i))\nstr_attrs = st.text().map(lambda s: attr.ib(default=s))\nfloat_attrs = st.floats().map(lambda f: attr.ib(default=f))\ndict_attrs = st.dictionaries(keys=st.text(), values=st.integers()).map(\n    lambda d: attr.ib(default=d)\n)\n\nsimple_attrs_without_metadata = (\n    bare_attrs | int_attrs | str_attrs | float_attrs | dict_attrs\n)\n\n\n@st.composite\ndef simple_attrs_with_metadata(draw):\n    \"\"\"\n    Create a simple attribute with arbitrary metadata.\n    \"\"\"\n    c_attr = draw(simple_attrs)\n    keys = st.booleans() | st.binary() | st.integers() | st.text()\n    vals = st.booleans() | st.binary() | st.integers() | st.text()\n    metadata = draw(\n        st.dictionaries(keys=keys, values=vals, min_size=1, max_size=3)\n    )\n\n    return attr.ib(\n        default=c_attr._default,\n        validator=c_attr._validator,\n        repr=c_attr.repr,\n        eq=c_attr.eq,\n        order=c_attr.order,\n        hash=c_attr.hash,\n        init=c_attr.init,\n        metadata=metadata,\n        type=None,\n        converter=c_attr.converter,\n    )\n\n\nsimple_attrs = simple_attrs_without_metadata | simple_attrs_with_metadata()\n\n\n# Python functions support up to 255 arguments.\nlist_of_attrs = st.lists(simple_attrs, max_size=3)\n\n\n@st.composite\ndef simple_classes(\n    draw,\n    slots=None,\n    frozen=None,\n    weakref_slot=None,\n    private_attrs=None,\n    cached_property=None,\n):\n    \"\"\"\n    A strategy that generates classes with default non-attr attributes.\n\n    For example, this strategy might generate a class such as:\n\n    @attr.s(slots=True, frozen=True, weakref_slot=True)\n    class HypClass:\n        a = attr.ib(default=1)\n        _b = attr.ib(default=None)\n        c = attr.ib(default='text')\n        _d = attr.ib(default=1.0)\n        c = attr.ib(default={'t': 1})\n\n    By default, all combinations of slots, frozen, and weakref_slot classes\n    will be generated.  If `slots=True` is passed in, only slotted classes will\n    be generated, and if `slots=False` is passed in, no slotted classes will be\n    generated. The same applies to `frozen` and `weakref_slot`.\n\n    By default, some attributes will be private (those prefixed with an\n    underscore). If `private_attrs=True` is passed in, all attributes will be\n    private, and if `private_attrs=False`, no attributes will be private.\n    \"\"\"\n    attrs = draw(list_of_attrs)\n    frozen_flag = draw(st.booleans())\n    slots_flag = draw(st.booleans())\n    weakref_flag = draw(st.booleans())\n\n    if private_attrs is None:\n        attr_names = maybe_underscore_prefix(gen_attr_names())\n    elif private_attrs is True:\n        attr_names = (\"_\" + n for n in gen_attr_names())\n    elif private_attrs is False:\n        attr_names = gen_attr_names()\n\n    cls_dict = dict(zip(attr_names, attrs))\n    pre_init_flag = draw(st.booleans())\n    post_init_flag = draw(st.booleans())\n    init_flag = draw(st.booleans())\n    cached_property_flag = draw(st.booleans())\n\n    if pre_init_flag:\n\n        def pre_init(self):\n            pass\n\n        cls_dict[\"__attrs_pre_init__\"] = pre_init\n\n    if post_init_flag:\n\n        def post_init(self):\n            pass\n\n        cls_dict[\"__attrs_post_init__\"] = post_init\n\n    if not init_flag:\n\n        def init(self, *args, **kwargs):\n            self.__attrs_init__(*args, **kwargs)\n\n        cls_dict[\"__init__\"] = init\n\n    bases = (object,)\n    if cached_property or (\n        PY_3_8_PLUS and cached_property is None and cached_property_flag\n    ):\n\n        class BaseWithCachedProperty:\n            @functools.cached_property\n            def _cached_property(self) -> int:\n                return 1\n\n        bases = (BaseWithCachedProperty,)\n\n    return make_class(\n        \"HypClass\",\n        cls_dict,\n        bases=bases,\n        slots=slots_flag if slots is None else slots,\n        frozen=frozen_flag if frozen is None else frozen,\n        weakref_slot=weakref_flag if weakref_slot is None else weakref_slot,\n        init=init_flag,\n    )\n\n\n# st.recursive works by taking a base strategy (in this case, simple_classes)\n# and a special function.  This function receives a strategy, and returns\n# another strategy (building on top of the base strategy).\nnested_classes = st.recursive(\n    simple_classes(), _create_hyp_nested_strategy, max_leaves=3\n)\n", "tests/test_pyright.py": "# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nimport json\nimport shutil\nimport subprocess\n\nfrom pathlib import Path\n\nimport pytest\n\nimport attrs\n\n\npytestmark = [\n    pytest.mark.skipif(\n        shutil.which(\"pyright\") is None, reason=\"Requires pyright.\"\n    ),\n]\n\n\n@attrs.frozen\nclass PyrightDiagnostic:\n    severity: str\n    message: str\n\n\ndef parse_pyright_output(test_file: Path) -> set[PyrightDiagnostic]:\n    pyright = subprocess.run(  # noqa: PLW1510\n        [\"pyright\", \"--outputjson\", str(test_file)], capture_output=True\n    )\n\n    pyright_result = json.loads(pyright.stdout)\n\n    return {\n        PyrightDiagnostic(d[\"severity\"], d[\"message\"])\n        for d in pyright_result[\"generalDiagnostics\"]\n    }\n\n\ndef test_pyright_baseline():\n    \"\"\"\n    The typing.dataclass_transform decorator allows pyright to determine\n    attrs decorated class types.\n    \"\"\"\n\n    test_file = Path(__file__).parent / \"dataclass_transform_example.py\"\n\n    diagnostics = parse_pyright_output(test_file)\n\n    # Expected diagnostics as per pyright 1.1.311\n    expected_diagnostics = {\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"Define.__init__\" is'\n            ' \"(self: Define, a: str, b: int) -> None\"',\n        ),\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"DefineConverter.__init__\" is '\n            '\"(self: DefineConverter, with_converter: str | Buffer | '\n            'SupportsInt | SupportsIndex | SupportsTrunc) -> None\"',\n        ),\n        PyrightDiagnostic(\n            severity=\"error\",\n            message='Cannot assign member \"a\" for type '\n            '\"Frozen\"\\n\\xa0\\xa0\"Frozen\" is frozen\\n\\xa0\\xa0\\xa0\\xa0Member \"__set__\" is unknown',\n        ),\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"d.a\" is \"Literal[\\'new\\']\"',\n        ),\n        PyrightDiagnostic(\n            severity=\"error\",\n            message='Cannot assign member \"a\" for type '\n            '\"FrozenDefine\"\\n\\xa0\\xa0\"FrozenDefine\" is frozen\\n\\xa0\\xa0\\xa0\\xa0'\n            'Member \"__set__\" is unknown',\n        ),\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"d2.a\" is \"Literal[\\'new\\']\"',\n        ),\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"af.__init__\" is \"(_a: int) -> None\"',\n        ),\n    }\n\n    assert expected_diagnostics == diagnostics\n\n\ndef test_pyright_attrsinstance_compat(tmp_path):\n    \"\"\"\n    Test that `AttrsInstance` is compatible with Pyright.\n    \"\"\"\n    test_pyright_attrsinstance_compat_path = (\n        tmp_path / \"test_pyright_attrsinstance_compat.py\"\n    )\n    test_pyright_attrsinstance_compat_path.write_text(\n        \"\"\"\\\nimport attrs\n\n# We can assign any old object to `AttrsInstance`.\nfoo: attrs.AttrsInstance = object()\n\nreveal_type(attrs.AttrsInstance)\n\"\"\"\n    )\n\n    diagnostics = parse_pyright_output(test_pyright_attrsinstance_compat_path)\n    expected_diagnostics = {\n        PyrightDiagnostic(\n            severity=\"information\",\n            message='Type of \"attrs.AttrsInstance\" is \"type[AttrsInstance]\"',\n        ),\n    }\n    assert diagnostics == expected_diagnostics\n", "tests/test_setattr.py": "# SPDX-License-Identifier: MIT\n\n\nimport pickle\n\nimport pytest\n\nimport attr\n\nfrom attr import setters\nfrom attr.exceptions import FrozenAttributeError\nfrom attr.validators import instance_of, matches_re\n\n\n@attr.s(frozen=True)\nclass Frozen:\n    x = attr.ib()\n\n\n@attr.s\nclass WithOnSetAttrHook:\n    x = attr.ib(on_setattr=lambda *args: None)\n\n\nclass TestSetAttr:\n    def test_change(self):\n        \"\"\"\n        The return value of a hook overwrites the value. But they are not run\n        on __init__.\n        \"\"\"\n\n        def hook(*a, **kw):\n            return \"hooked!\"\n\n        @attr.s\n        class Hooked:\n            x = attr.ib(on_setattr=hook)\n            y = attr.ib()\n\n        h = Hooked(\"x\", \"y\")\n\n        assert \"x\" == h.x\n        assert \"y\" == h.y\n\n        h.x = \"xxx\"\n        h.y = \"yyy\"\n\n        assert \"yyy\" == h.y\n        assert \"hooked!\" == h.x\n\n    def test_frozen_attribute(self):\n        \"\"\"\n        Frozen attributes raise FrozenAttributeError, others are not affected.\n        \"\"\"\n\n        @attr.s\n        class PartiallyFrozen:\n            x = attr.ib(on_setattr=setters.frozen)\n            y = attr.ib()\n\n        pf = PartiallyFrozen(\"x\", \"y\")\n\n        pf.y = \"yyy\"\n\n        assert \"yyy\" == pf.y\n\n        with pytest.raises(FrozenAttributeError):\n            pf.x = \"xxx\"\n\n        assert \"x\" == pf.x\n\n    @pytest.mark.parametrize(\n        \"on_setattr\",\n        [setters.validate, [setters.validate], setters.pipe(setters.validate)],\n    )\n    def test_validator(self, on_setattr):\n        \"\"\"\n        Validators are run and they don't alter the value.\n        \"\"\"\n\n        @attr.s(on_setattr=on_setattr)\n        class ValidatedAttribute:\n            x = attr.ib()\n            y = attr.ib(validator=[instance_of(str), matches_re(\"foo.*qux\")])\n\n        va = ValidatedAttribute(42, \"foobarqux\")\n\n        with pytest.raises(TypeError) as ei:\n            va.y = 42\n\n        assert \"foobarqux\" == va.y\n\n        assert ei.value.args[0].startswith(\"'y' must be <\")\n\n        with pytest.raises(ValueError) as ei:\n            va.y = \"quxbarfoo\"\n\n        assert ei.value.args[0].startswith(\"'y' must match regex '\")\n\n        assert \"foobarqux\" == va.y\n\n        va.y = \"foobazqux\"\n\n        assert \"foobazqux\" == va.y\n\n    def test_pipe(self):\n        \"\"\"\n        Multiple hooks are possible, in that case the last return value is\n        used. They can be supplied using the pipe functions or by passing a\n        list to on_setattr.\n        \"\"\"\n\n        s = [setters.convert, lambda _, __, nv: nv + 1]\n\n        @attr.s\n        class Piped:\n            x1 = attr.ib(converter=int, on_setattr=setters.pipe(*s))\n            x2 = attr.ib(converter=int, on_setattr=s)\n\n        p = Piped(\"41\", \"22\")\n\n        assert 41 == p.x1\n        assert 22 == p.x2\n\n        p.x1 = \"41\"\n        p.x2 = \"22\"\n\n        assert 42 == p.x1\n        assert 23 == p.x2\n\n    def test_make_class(self):\n        \"\"\"\n        on_setattr of make_class gets forwarded.\n        \"\"\"\n        C = attr.make_class(\"C\", {\"x\": attr.ib()}, on_setattr=setters.frozen)\n\n        c = C(1)\n\n        with pytest.raises(FrozenAttributeError):\n            c.x = 2\n\n    def test_no_validator_no_converter(self):\n        \"\"\"\n        validate and convert tolerate missing validators and converters.\n        \"\"\"\n\n        @attr.s(on_setattr=[setters.convert, setters.validate])\n        class C:\n            x = attr.ib()\n\n        c = C(1)\n\n        c.x = 2\n\n        assert 2 == c.x\n\n    def test_validate_respects_run_validators_config(self):\n        \"\"\"\n        If run validators is off, validate doesn't run them.\n        \"\"\"\n\n        @attr.s(on_setattr=setters.validate)\n        class C:\n            x = attr.ib(validator=attr.validators.instance_of(int))\n\n        c = C(1)\n\n        attr.set_run_validators(False)\n\n        c.x = \"1\"\n\n        assert \"1\" == c.x\n\n        attr.set_run_validators(True)\n\n        with pytest.raises(TypeError) as ei:\n            c.x = \"1\"\n\n        assert ei.value.args[0].startswith(\"'x' must be <\")\n\n    def test_frozen_on_setattr_class_is_caught(self):\n        \"\"\"\n        @attr.s(on_setattr=X, frozen=True) raises an ValueError.\n        \"\"\"\n        with pytest.raises(ValueError) as ei:\n\n            @attr.s(frozen=True, on_setattr=setters.validate)\n            class C:\n                x = attr.ib()\n\n        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n\n    def test_frozen_on_setattr_attribute_is_caught(self):\n        \"\"\"\n        attr.ib(on_setattr=X) on a frozen class raises an ValueError.\n        \"\"\"\n\n        with pytest.raises(ValueError) as ei:\n\n            @attr.s(frozen=True)\n            class C:\n                x = attr.ib(on_setattr=setters.validate)\n\n        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n\n    def test_setattr_reset_if_no_custom_setattr(self, slots):\n        \"\"\"\n        If a class with an active setattr is subclassed and no new setattr\n        is generated, the __setattr__ is set to object.__setattr__.\n\n        We do the double test because of Python 2.\n        \"\"\"\n\n        def boom(*args):\n            pytest.fail(\"Must not be called.\")\n\n        @attr.s\n        class Hooked:\n            x = attr.ib(on_setattr=boom)\n\n        @attr.s(slots=slots)\n        class NoHook(WithOnSetAttrHook):\n            x = attr.ib()\n\n        assert NoHook.__setattr__ == object.__setattr__\n        assert 1 == NoHook(1).x\n        assert Hooked.__attrs_own_setattr__\n        assert not NoHook.__attrs_own_setattr__\n        assert WithOnSetAttrHook.__attrs_own_setattr__\n\n    def test_setattr_inherited_do_not_reset(self, slots):\n        \"\"\"\n        If we inherit a __setattr__ that has been written by the user, we must\n        not reset it unless necessary.\n        \"\"\"\n\n        class A:\n            \"\"\"\n            Not an attrs class on purpose to prevent accidental resets that\n            would render the asserts meaningless.\n            \"\"\"\n\n            def __setattr__(self, *args):\n                pass\n\n        @attr.s(slots=slots)\n        class B(A):\n            pass\n\n        assert B.__setattr__ == A.__setattr__\n\n        @attr.s(slots=slots)\n        class C(B):\n            pass\n\n        assert C.__setattr__ == A.__setattr__\n\n    def test_pickling_retains_attrs_own(self, slots):\n        \"\"\"\n        Pickling/Unpickling does not lose ownership information about\n        __setattr__.\n        \"\"\"\n        i = WithOnSetAttrHook(1)\n\n        assert True is i.__attrs_own_setattr__\n\n        i2 = pickle.loads(pickle.dumps(i))\n\n        assert True is i2.__attrs_own_setattr__\n\n        WOSAH = pickle.loads(pickle.dumps(WithOnSetAttrHook))\n\n        assert True is WOSAH.__attrs_own_setattr__\n\n    def test_slotted_class_can_have_custom_setattr(self):\n        \"\"\"\n        A slotted class can define a custom setattr and it doesn't get\n        overwritten.\n\n        Regression test for #680.\n        \"\"\"\n\n        @attr.s(slots=True)\n        class A:\n            def __setattr__(self, key, value):\n                raise SystemError\n\n        with pytest.raises(SystemError):\n            A().x = 1\n\n    @pytest.mark.xfail(raises=attr.exceptions.FrozenAttributeError)\n    def test_slotted_confused(self):\n        \"\"\"\n        If we have a in-between non-attrs class, setattr reset detection\n        should still work, but currently doesn't.\n\n        It works with dict classes because we can look the finished class and\n        patch it.  With slotted classes we have to deduce it ourselves.\n        \"\"\"\n\n        @attr.s(slots=True)\n        class A:\n            x = attr.ib(on_setattr=setters.frozen)\n\n        class B(A):\n            pass\n\n        @attr.s(slots=True)\n        class C(B):\n            x = attr.ib()\n\n        C(1).x = 2\n\n    def test_setattr_auto_detect_if_no_custom_setattr(self, slots):\n        \"\"\"\n        It's possible to remove the on_setattr hook from an attribute and\n        therefore write a custom __setattr__.\n        \"\"\"\n        assert 1 == WithOnSetAttrHook(1).x\n\n        @attr.s(auto_detect=True, slots=slots)\n        class RemoveNeedForOurSetAttr(WithOnSetAttrHook):\n            x = attr.ib()\n\n            def __setattr__(self, name, val):\n                object.__setattr__(self, name, val * 2)\n\n        i = RemoveNeedForOurSetAttr(1)\n\n        assert not RemoveNeedForOurSetAttr.__attrs_own_setattr__\n        assert 2 == i.x\n\n    def test_setattr_restore_respects_auto_detect(self, slots):\n        \"\"\"\n        If __setattr__ should be restored but the user supplied its own and\n        set auto_detect, leave is alone.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots)\n        class CustomSetAttr:\n            def __setattr__(self, _, __):\n                pass\n\n        assert CustomSetAttr.__setattr__ != object.__setattr__\n\n    def test_setattr_auto_detect_frozen(self, slots):\n        \"\"\"\n        frozen=True together with a detected custom __setattr__ are rejected.\n        \"\"\"\n        with pytest.raises(\n            ValueError, match=\"Can't freeze a class with a custom __setattr__.\"\n        ):\n\n            @attr.s(auto_detect=True, slots=slots, frozen=True)\n            class CustomSetAttr(Frozen):\n                def __setattr__(self, _, __):\n                    pass\n\n    def test_setattr_auto_detect_on_setattr(self, slots):\n        \"\"\"\n        on_setattr attributes together with a detected custom __setattr__ are\n        rejected.\n        \"\"\"\n        with pytest.raises(\n            ValueError,\n            match=\"Can't combine custom __setattr__ with on_setattr hooks.\",\n        ):\n\n            @attr.s(auto_detect=True, slots=slots)\n            class HookAndCustomSetAttr:\n                x = attr.ib(on_setattr=lambda *args: None)\n\n                def __setattr__(self, _, __):\n                    pass\n\n    @pytest.mark.parametrize(\"a_slots\", [True, False])\n    @pytest.mark.parametrize(\"b_slots\", [True, False])\n    @pytest.mark.parametrize(\"c_slots\", [True, False])\n    def test_setattr_inherited_do_not_reset_intermediate(\n        self, a_slots, b_slots, c_slots\n    ):\n        \"\"\"\n        A user-provided intermediate __setattr__ is not reset to\n        object.__setattr__.\n\n        This only can work with auto_detect activated, such that attrs can know\n        that there is a user-provided __setattr__.\n        \"\"\"\n\n        @attr.s(slots=a_slots)\n        class A:\n            x = attr.ib(on_setattr=setters.frozen)\n\n        @attr.s(slots=b_slots, auto_detect=True)\n        class B(A):\n            x = attr.ib(on_setattr=setters.NO_OP)\n\n            def __setattr__(self, key, value):\n                raise SystemError\n\n        @attr.s(slots=c_slots)\n        class C(B):\n            pass\n\n        assert getattr(A, \"__attrs_own_setattr__\", False) is True\n        assert getattr(B, \"__attrs_own_setattr__\", False) is False\n        assert getattr(C, \"__attrs_own_setattr__\", False) is False\n\n        with pytest.raises(SystemError):\n            C(1).x = 3\n\n    def test_docstring(self):\n        \"\"\"\n        Generated __setattr__ has a useful docstring.\n        \"\"\"\n        assert (\n            \"Method generated by attrs for class WithOnSetAttrHook.\"\n            == WithOnSetAttrHook.__setattr__.__doc__\n        )\n", "tests/dataclass_transform_example.py": "# SPDX-License-Identifier: MIT\n\nimport attr\nimport attrs\n\n\n@attr.define()\nclass Define:\n    a: str\n    b: int\n\n\nreveal_type(Define.__init__)  # noqa: F821\n\n\n@attr.define()\nclass DefineConverter:\n    # mypy plugin adapts the \"int\" method signature, pyright does not\n    with_converter: int = attr.field(converter=int)\n\n\nreveal_type(DefineConverter.__init__)  # noqa: F821\n\nDefineConverter(with_converter=b\"42\")\n\n\n@attr.frozen()\nclass Frozen:\n    a: str\n\n\nd = Frozen(\"a\")\nd.a = \"new\"\n\nreveal_type(d.a)  # noqa: F821\n\n\n@attr.define(frozen=True)\nclass FrozenDefine:\n    a: str\n\n\nd2 = FrozenDefine(\"a\")\nd2.a = \"new\"\n\nreveal_type(d2.a)  # noqa: F821\n\n\n# Field-aliasing works\n@attrs.define\nclass AliasedField:\n    _a: int = attrs.field(alias=\"_a\")\n\n\naf = AliasedField(42)\n\nreveal_type(af.__init__)  # noqa: F821\n\n\n# unsafe_hash is accepted\n@attrs.define(unsafe_hash=True)\nclass Hashable:\n    pass\n", "tests/test_config.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr._config`.\n\"\"\"\n\n\nimport pytest\n\nfrom attr import _config\n\n\nclass TestConfig:\n    def test_default(self):\n        \"\"\"\n        Run validators by default.\n        \"\"\"\n        assert True is _config._run_validators\n\n    def test_set_run_validators(self):\n        \"\"\"\n        Sets `_run_validators`.\n        \"\"\"\n        _config.set_run_validators(False)\n        assert False is _config._run_validators\n        _config.set_run_validators(True)\n        assert True is _config._run_validators\n\n    def test_get_run_validators(self):\n        \"\"\"\n        Returns `_run_validators`.\n        \"\"\"\n        _config._run_validators = False\n        assert _config._run_validators is _config.get_run_validators()\n        _config._run_validators = True\n        assert _config._run_validators is _config.get_run_validators()\n\n    def test_wrong_type(self):\n        \"\"\"\n        Passing anything else than a boolean raises TypeError.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            _config.set_run_validators(\"False\")\n        assert \"'run' must be bool.\" == e.value.args[0]\n", "tests/test_functional.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nEnd-to-end tests.\n\"\"\"\n\n\nimport inspect\nimport pickle\n\nfrom copy import deepcopy\n\nimport pytest\n\nfrom hypothesis import given\nfrom hypothesis.strategies import booleans\n\nimport attr\n\nfrom attr._make import NOTHING, Attribute\nfrom attr.exceptions import FrozenInstanceError\n\n\n@attr.s\nclass C1:\n    x = attr.ib(validator=attr.validators.instance_of(int))\n    y = attr.ib()\n\n\n@attr.s(slots=True)\nclass C1Slots:\n    x = attr.ib(validator=attr.validators.instance_of(int))\n    y = attr.ib()\n\n\nfoo = None\n\n\n@attr.s()\nclass C2:\n    x = attr.ib(default=foo)\n    y = attr.ib(default=attr.Factory(list))\n\n\n@attr.s(slots=True)\nclass C2Slots:\n    x = attr.ib(default=foo)\n    y = attr.ib(default=attr.Factory(list))\n\n\n@attr.s\nclass Base:\n    x = attr.ib()\n\n    def meth(self):\n        return self.x\n\n\n@attr.s(slots=True)\nclass BaseSlots:\n    x = attr.ib()\n\n    def meth(self):\n        return self.x\n\n\n@attr.s\nclass Sub(Base):\n    y = attr.ib()\n\n\n@attr.s(slots=True)\nclass SubSlots(BaseSlots):\n    y = attr.ib()\n\n\n@attr.s(frozen=True, slots=True)\nclass Frozen:\n    x = attr.ib()\n\n\n@attr.s\nclass SubFrozen(Frozen):\n    y = attr.ib()\n\n\n@attr.s(frozen=True, slots=False)\nclass FrozenNoSlots:\n    x = attr.ib()\n\n\nclass Meta(type):\n    pass\n\n\n@attr.s\nclass WithMeta(metaclass=Meta):\n    pass\n\n\n@attr.s(slots=True)\nclass WithMetaSlots(metaclass=Meta):\n    pass\n\n\nFromMakeClass = attr.make_class(\"FromMakeClass\", [\"x\"])\n\n\nclass TestFunctional:\n    \"\"\"\n    Functional tests.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"cls\", [C2, C2Slots])\n    def test_fields(self, cls):\n        \"\"\"\n        `attr.fields` works.\n        \"\"\"\n        assert (\n            Attribute(\n                name=\"x\",\n                alias=\"x\",\n                default=foo,\n                validator=None,\n                repr=True,\n                cmp=None,\n                eq=True,\n                order=True,\n                hash=None,\n                init=True,\n                inherited=False,\n            ),\n            Attribute(\n                name=\"y\",\n                alias=\"y\",\n                default=attr.Factory(list),\n                validator=None,\n                repr=True,\n                cmp=None,\n                eq=True,\n                order=True,\n                hash=None,\n                init=True,\n                inherited=False,\n            ),\n        ) == attr.fields(cls)\n\n    @pytest.mark.parametrize(\"cls\", [C1, C1Slots])\n    def test_asdict(self, cls):\n        \"\"\"\n        `attr.asdict` works.\n        \"\"\"\n        assert {\"x\": 1, \"y\": 2} == attr.asdict(cls(x=1, y=2))\n\n    @pytest.mark.parametrize(\"cls\", [C1, C1Slots])\n    def test_validator(self, cls):\n        \"\"\"\n        `instance_of` raises `TypeError` on type mismatch.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            cls(\"1\", 2)\n\n        # Using C1 explicitly, since slotted classes don't support this.\n        assert (\n            \"'x' must be <class 'int'> (got '1' that is a <class 'str'>).\",\n            attr.fields(C1).x,\n            int,\n            \"1\",\n        ) == e.value.args\n\n    @given(booleans())\n    def test_renaming(self, slots):\n        \"\"\"\n        Private members are renamed but only in `__init__`.\n        \"\"\"\n\n        @attr.s(slots=slots)\n        class C3:\n            _x = attr.ib()\n\n        assert \"C3(_x=1)\" == repr(C3(x=1))\n\n    @given(booleans(), booleans())\n    def test_programmatic(self, slots, frozen):\n        \"\"\"\n        `attr.make_class` works.\n        \"\"\"\n        PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots, frozen=frozen)\n\n        assert (\n            Attribute(\n                name=\"a\",\n                alias=\"a\",\n                default=NOTHING,\n                validator=None,\n                repr=True,\n                cmp=None,\n                eq=True,\n                order=True,\n                hash=None,\n                init=True,\n                inherited=False,\n            ),\n            Attribute(\n                name=\"b\",\n                alias=\"b\",\n                default=NOTHING,\n                validator=None,\n                repr=True,\n                cmp=None,\n                eq=True,\n                order=True,\n                hash=None,\n                init=True,\n                inherited=False,\n            ),\n        ) == attr.fields(PC)\n\n    @pytest.mark.parametrize(\"cls\", [Sub, SubSlots])\n    def test_subclassing_with_extra_attrs(self, cls):\n        \"\"\"\n        Subclassing (where the subclass has extra attrs) does what you'd hope\n        for.\n        \"\"\"\n        obj = object()\n        i = cls(x=obj, y=2)\n        assert i.x is i.meth() is obj\n        assert i.y == 2\n        if cls is Sub:\n            assert f\"Sub(x={obj}, y=2)\" == repr(i)\n        else:\n            assert f\"SubSlots(x={obj}, y=2)\" == repr(i)\n\n    @pytest.mark.parametrize(\"base\", [Base, BaseSlots])\n    def test_subclass_without_extra_attrs(self, base):\n        \"\"\"\n        Subclassing (where the subclass does not have extra attrs) still\n        behaves the same as a subclass with extra attrs.\n        \"\"\"\n\n        class Sub2(base):\n            pass\n\n        obj = object()\n        i = Sub2(x=obj)\n        assert i.x is i.meth() is obj\n        assert f\"Sub2(x={obj})\" == repr(i)\n\n    @pytest.mark.parametrize(\n        \"frozen_class\",\n        [\n            Frozen,  # has slots=True\n            attr.make_class(\"FrozenToo\", [\"x\"], slots=False, frozen=True),\n        ],\n    )\n    def test_frozen_instance(self, frozen_class):\n        \"\"\"\n        Frozen instances can't be modified (easily).\n        \"\"\"\n        frozen = frozen_class(1)\n\n        with pytest.raises(FrozenInstanceError) as e:\n            frozen.x = 2\n\n        with pytest.raises(FrozenInstanceError) as e:\n            del frozen.x\n\n        assert e.value.args[0] == \"can't set attribute\"\n        assert 1 == frozen.x\n\n    @pytest.mark.parametrize(\n        \"cls\",\n        [\n            C1,\n            C1Slots,\n            C2,\n            C2Slots,\n            Base,\n            BaseSlots,\n            Sub,\n            SubSlots,\n            Frozen,\n            FrozenNoSlots,\n            FromMakeClass,\n        ],\n    )\n    @pytest.mark.parametrize(\"protocol\", range(2, pickle.HIGHEST_PROTOCOL + 1))\n    def test_pickle_attributes(self, cls, protocol):\n        \"\"\"\n        Pickling/un-pickling of Attribute instances works.\n        \"\"\"\n        for attribute in attr.fields(cls):\n            assert attribute == pickle.loads(pickle.dumps(attribute, protocol))\n\n    @pytest.mark.parametrize(\n        \"cls\",\n        [\n            C1,\n            C1Slots,\n            C2,\n            C2Slots,\n            Base,\n            BaseSlots,\n            Sub,\n            SubSlots,\n            Frozen,\n            FrozenNoSlots,\n            FromMakeClass,\n        ],\n    )\n    @pytest.mark.parametrize(\"protocol\", range(2, pickle.HIGHEST_PROTOCOL + 1))\n    def test_pickle_object(self, cls, protocol):\n        \"\"\"\n        Pickle object serialization works on all kinds of attrs classes.\n        \"\"\"\n        obj = cls(123, 456) if len(attr.fields(cls)) == 2 else cls(123)\n\n        assert repr(obj) == repr(pickle.loads(pickle.dumps(obj, protocol)))\n\n    def test_subclassing_frozen_gives_frozen(self):\n        \"\"\"\n        The frozen-ness of classes is inherited.  Subclasses of frozen classes\n        are also frozen and can be instantiated.\n        \"\"\"\n        i = SubFrozen(\"foo\", \"bar\")\n\n        assert i.x == \"foo\"\n        assert i.y == \"bar\"\n\n        with pytest.raises(FrozenInstanceError):\n            i.x = \"baz\"\n\n    @pytest.mark.parametrize(\"cls\", [WithMeta, WithMetaSlots])\n    def test_metaclass_preserved(self, cls):\n        \"\"\"\n        Metaclass data is preserved.\n        \"\"\"\n        assert Meta == type(cls)\n\n    def test_default_decorator(self):\n        \"\"\"\n        Default decorator sets the default and the respective method gets\n        called.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(default=1)\n            y = attr.ib()\n\n            @y.default\n            def compute(self):\n                return self.x + 1\n\n        assert C(1, 2) == C()\n\n    @pytest.mark.parametrize(\"weakref_slot\", [True, False])\n    def test_attrib_overwrite(self, slots, frozen, weakref_slot):\n        \"\"\"\n        Subclasses can overwrite attributes of their base class.\n        \"\"\"\n\n        @attr.s(slots=slots, frozen=frozen, weakref_slot=weakref_slot)\n        class SubOverwrite(Base):\n            x = attr.ib(default=attr.Factory(list))\n\n        assert SubOverwrite([]) == SubOverwrite()\n\n    def test_dict_patch_class(self):\n        \"\"\"\n        dict-classes are never replaced.\n        \"\"\"\n\n        class C:\n            x = attr.ib()\n\n        C_new = attr.s(C)\n\n        assert C_new is C\n\n    def test_hash_by_id(self):\n        \"\"\"\n        With dict classes, hashing by ID is active for hash=False even on\n        Python 3.  This is incorrect behavior but we have to retain it for\n        backward compatibility.\n        \"\"\"\n\n        @attr.s(hash=False)\n        class HashByIDBackwardCompat:\n            x = attr.ib()\n\n        assert hash(HashByIDBackwardCompat(1)) != hash(\n            HashByIDBackwardCompat(1)\n        )\n\n        @attr.s(hash=False, eq=False)\n        class HashByID:\n            x = attr.ib()\n\n        assert hash(HashByID(1)) != hash(HashByID(1))\n\n        @attr.s(hash=True)\n        class HashByValues:\n            x = attr.ib()\n\n        assert hash(HashByValues(1)) == hash(HashByValues(1))\n\n    def test_handles_different_defaults(self):\n        \"\"\"\n        Unhashable defaults + subclassing values work.\n        \"\"\"\n\n        @attr.s\n        class Unhashable:\n            pass\n\n        @attr.s\n        class C:\n            x = attr.ib(default=Unhashable())\n\n        @attr.s\n        class D(C):\n            pass\n\n    def test_hash_false_eq_false(self, slots):\n        \"\"\"\n        hash=False and eq=False make a class hashable by ID.\n        \"\"\"\n\n        @attr.s(hash=False, eq=False, slots=slots)\n        class C:\n            pass\n\n        assert hash(C()) != hash(C())\n\n    def test_eq_false(self, slots):\n        \"\"\"\n        eq=False makes a class hashable by ID.\n        \"\"\"\n\n        @attr.s(eq=False, slots=slots)\n        class C:\n            pass\n\n        # Ensure both objects live long enough such that their ids/hashes\n        # can't be recycled. Thanks to Ask Hjorth Larsen for pointing that\n        # out.\n        c1 = C()\n        c2 = C()\n\n        assert hash(c1) != hash(c2)\n\n    def test_overwrite_base(self):\n        \"\"\"\n        Base classes can overwrite each other and the attributes are added\n        in the order they are defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            c = attr.ib(default=100)\n            x = attr.ib(default=1)\n            b = attr.ib(default=23)\n\n        @attr.s\n        class D(C):\n            a = attr.ib(default=42)\n            x = attr.ib(default=2)\n            d = attr.ib(default=3.14)\n\n        @attr.s\n        class E(D):\n            y = attr.ib(default=3)\n            z = attr.ib(default=4)\n\n        assert \"E(c=100, b=23, a=42, x=2, d=3.14, y=3, z=4)\" == repr(E())\n\n    @pytest.mark.parametrize(\"base_slots\", [True, False])\n    @pytest.mark.parametrize(\"sub_slots\", [True, False])\n    @pytest.mark.parametrize(\"base_frozen\", [True, False])\n    @pytest.mark.parametrize(\"sub_frozen\", [True, False])\n    @pytest.mark.parametrize(\"base_weakref_slot\", [True, False])\n    @pytest.mark.parametrize(\"sub_weakref_slot\", [True, False])\n    @pytest.mark.parametrize(\"base_converter\", [True, False])\n    @pytest.mark.parametrize(\"sub_converter\", [True, False])\n    def test_frozen_slots_combo(\n        self,\n        base_slots,\n        sub_slots,\n        base_frozen,\n        sub_frozen,\n        base_weakref_slot,\n        sub_weakref_slot,\n        base_converter,\n        sub_converter,\n    ):\n        \"\"\"\n        A class with a single attribute, inheriting from another class\n        with a single attribute.\n        \"\"\"\n\n        @attr.s(\n            frozen=base_frozen,\n            slots=base_slots,\n            weakref_slot=base_weakref_slot,\n        )\n        class Base:\n            a = attr.ib(converter=int if base_converter else None)\n\n        @attr.s(\n            frozen=sub_frozen, slots=sub_slots, weakref_slot=sub_weakref_slot\n        )\n        class Sub(Base):\n            b = attr.ib(converter=int if sub_converter else None)\n\n        i = Sub(\"1\", \"2\")\n\n        assert i.a == (1 if base_converter else \"1\")\n        assert i.b == (2 if sub_converter else \"2\")\n\n        if base_frozen or sub_frozen:\n            with pytest.raises(FrozenInstanceError):\n                i.a = \"2\"\n\n            with pytest.raises(FrozenInstanceError):\n                i.b = \"3\"\n\n    def test_tuple_class_aliasing(self):\n        \"\"\"\n        itemgetter and property are legal attribute names.\n        \"\"\"\n\n        @attr.s\n        class C:\n            property = attr.ib()\n            itemgetter = attr.ib()\n            x = attr.ib()\n\n        assert \"property\" == attr.fields(C).property.name\n        assert \"itemgetter\" == attr.fields(C).itemgetter.name\n        assert \"x\" == attr.fields(C).x.name\n\n    def test_auto_exc(self, slots, frozen):\n        \"\"\"\n        Classes with auto_exc=True have a Exception-style __str__, compare and\n        hash by id, and store the fields additionally in self.args.\n        \"\"\"\n\n        @attr.s(auto_exc=True, slots=slots, frozen=frozen)\n        class FooError(Exception):\n            x = attr.ib()\n            y = attr.ib(init=False, default=42)\n            z = attr.ib(init=False)\n            a = attr.ib()\n\n        FooErrorMade = attr.make_class(\n            \"FooErrorMade\",\n            bases=(Exception,),\n            attrs={\n                \"x\": attr.ib(),\n                \"y\": attr.ib(init=False, default=42),\n                \"z\": attr.ib(init=False),\n                \"a\": attr.ib(),\n            },\n            auto_exc=True,\n            slots=slots,\n            frozen=frozen,\n        )\n\n        assert FooError(1, \"foo\") != FooError(1, \"foo\")\n        assert FooErrorMade(1, \"foo\") != FooErrorMade(1, \"foo\")\n\n        for cls in (FooError, FooErrorMade):\n            with pytest.raises(cls) as ei1:\n                raise cls(1, \"foo\")\n\n            with pytest.raises(cls) as ei2:\n                raise cls(1, \"foo\")\n\n            e1 = ei1.value\n            e2 = ei2.value\n\n            assert e1 is e1\n            assert e1 == e1\n            assert e2 == e2\n            assert e1 != e2\n            assert \"(1, 'foo')\" == str(e1) == str(e2)\n            assert (1, \"foo\") == e1.args == e2.args\n\n            hash(e1) == hash(e1)\n            hash(e2) == hash(e2)\n\n            if not frozen:\n                deepcopy(e1)\n                deepcopy(e2)\n\n    def test_auto_exc_one_attrib(self, slots, frozen):\n        \"\"\"\n        Having one attribute works with auto_exc=True.\n\n        Easy to get wrong with tuple literals.\n        \"\"\"\n\n        @attr.s(auto_exc=True, slots=slots, frozen=frozen)\n        class FooError(Exception):\n            x = attr.ib()\n\n        FooError(1)\n\n    def test_eq_only(self, slots, frozen):\n        \"\"\"\n        Classes with order=False cannot be ordered.\n        \"\"\"\n\n        @attr.s(eq=True, order=False, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n        possible_errors = (\n            \"unorderable types: C() < C()\",\n            \"'<' not supported between instances of 'C' and 'C'\",\n            \"unorderable types: C < C\",  # old PyPy 3\n        )\n\n        with pytest.raises(TypeError) as ei:\n            C(5) < C(6)\n\n        assert ei.value.args[0] in possible_errors\n\n    @pytest.mark.parametrize(\"cmp\", [True, False])\n    def test_attrib_cmp_shortcut(self, slots, cmp):\n        \"\"\"\n        Setting cmp on `attr.ib`s sets both eq and order.\n        \"\"\"\n\n        @attr.s(slots=slots)\n        class C:\n            x = attr.ib(cmp=cmp)\n\n        assert cmp is attr.fields(C).x.eq\n        assert cmp is attr.fields(C).x.order\n\n    def test_no_setattr_if_validate_without_validators(self, slots):\n        \"\"\"\n        If a class has on_setattr=attr.setters.validate (former default in NG\n        APIs) but sets no validators, don't use the (slower) setattr in\n        __init__.\n\n        Regression test for #816.\n        \"\"\"\n\n        @attr.s(on_setattr=attr.setters.validate, slots=slots)\n        class C:\n            x = attr.ib()\n\n        @attr.s(on_setattr=attr.setters.validate, slots=slots)\n        class D(C):\n            y = attr.ib()\n\n        src = inspect.getsource(D.__init__)\n\n        assert \"setattr\" not in src\n        assert \"self.x = x\" in src\n        assert \"self.y = y\" in src\n        assert object.__setattr__ == D.__setattr__\n\n    def test_no_setattr_if_convert_without_converters(self, slots):\n        \"\"\"\n        If a class has on_setattr=attr.setters.convert but sets no validators,\n        don't use the (slower) setattr in __init__.\n        \"\"\"\n\n        @attr.s(on_setattr=attr.setters.convert, slots=slots)\n        class C:\n            x = attr.ib()\n\n        @attr.s(on_setattr=attr.setters.convert, slots=slots)\n        class D(C):\n            y = attr.ib()\n\n        src = inspect.getsource(D.__init__)\n\n        assert \"setattr\" not in src\n        assert \"self.x = x\" in src\n        assert \"self.y = y\" in src\n        assert object.__setattr__ == D.__setattr__\n\n    def test_no_setattr_with_ng_defaults(self, slots):\n        \"\"\"\n        If a class has the NG default on_setattr=[convert, validate] but sets\n        no validators or converters, don't use the (slower) setattr in\n        __init__.\n        \"\"\"\n\n        @attr.define(slots=slots)\n        class C:\n            x = attr.ib()\n\n        src = inspect.getsource(C.__init__)\n\n        assert \"setattr\" not in src\n        assert \"self.x = x\" in src\n        assert object.__setattr__ == C.__setattr__\n\n        @attr.define(slots=slots)\n        class D(C):\n            y = attr.ib()\n\n        src = inspect.getsource(D.__init__)\n\n        assert \"setattr\" not in src\n        assert \"self.x = x\" in src\n        assert \"self.y = y\" in src\n        assert object.__setattr__ == D.__setattr__\n\n    def test_on_setattr_detect_inherited_validators(self):\n        \"\"\"\n        _make_init detects the presence of a validator even if the field is\n        inherited.\n        \"\"\"\n\n        @attr.s(on_setattr=attr.setters.validate)\n        class C:\n            x = attr.ib(validator=42)\n\n        @attr.s(on_setattr=attr.setters.validate)\n        class D(C):\n            y = attr.ib()\n\n        src = inspect.getsource(D.__init__)\n\n        assert \"_setattr = _cached_setattr_get(self)\" in src\n        assert \"_setattr('x', x)\" in src\n        assert \"_setattr('y', y)\" in src\n        assert object.__setattr__ != D.__setattr__\n\n    def test_unsafe_hash(self, slots):\n        \"\"\"\n        attr.s(unsafe_hash=True) makes a class hashable.\n        \"\"\"\n\n        @attr.s(slots=slots, unsafe_hash=True)\n        class Hashable:\n            pass\n\n        assert hash(Hashable())\n", "tests/test_converters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr.converters`.\n\"\"\"\n\n\nimport pytest\n\nimport attr\n\nfrom attr import Factory, attrib\nfrom attr.converters import default_if_none, optional, pipe, to_bool\n\n\nclass TestOptional:\n    \"\"\"\n    Tests for `optional`.\n    \"\"\"\n\n    def test_success_with_type(self):\n        \"\"\"\n        Wrapped converter is used as usual if value is not None.\n        \"\"\"\n        c = optional(int)\n\n        assert c(\"42\") == 42\n\n    def test_success_with_none(self):\n        \"\"\"\n        Nothing happens if None.\n        \"\"\"\n        c = optional(int)\n\n        assert c(None) is None\n\n    def test_fail(self):\n        \"\"\"\n        Propagates the underlying conversion error when conversion fails.\n        \"\"\"\n        c = optional(int)\n\n        with pytest.raises(ValueError):\n            c(\"not_an_int\")\n\n\nclass TestDefaultIfNone:\n    def test_missing_default(self):\n        \"\"\"\n        Raises TypeError if neither default nor factory have been passed.\n        \"\"\"\n        with pytest.raises(TypeError, match=\"Must pass either\"):\n            default_if_none()\n\n    def test_too_many_defaults(self):\n        \"\"\"\n        Raises TypeError if both default and factory are passed.\n        \"\"\"\n        with pytest.raises(TypeError, match=\"but not both\"):\n            default_if_none(True, lambda: 42)\n\n    def test_factory_takes_self(self):\n        \"\"\"\n        Raises ValueError if passed Factory has takes_self=True.\n        \"\"\"\n        with pytest.raises(ValueError, match=\"takes_self\"):\n            default_if_none(Factory(list, takes_self=True))\n\n    @pytest.mark.parametrize(\"val\", [1, 0, True, False, \"foo\", \"\", object()])\n    def test_not_none(self, val):\n        \"\"\"\n        If a non-None value is passed, it's handed down.\n        \"\"\"\n        c = default_if_none(\"nope\")\n\n        assert val == c(val)\n\n        c = default_if_none(factory=list)\n\n        assert val == c(val)\n\n    def test_none_value(self):\n        \"\"\"\n        Default values are returned when a None is passed.\n        \"\"\"\n        c = default_if_none(42)\n\n        assert 42 == c(None)\n\n    def test_none_factory(self):\n        \"\"\"\n        Factories are used if None is passed.\n        \"\"\"\n        c = default_if_none(factory=list)\n\n        assert [] == c(None)\n\n        c = default_if_none(default=Factory(list))\n\n        assert [] == c(None)\n\n\nclass TestPipe:\n    def test_success(self):\n        \"\"\"\n        Succeeds if all wrapped converters succeed.\n        \"\"\"\n        c = pipe(str, to_bool, bool)\n\n        assert True is c(\"True\") is c(True)\n\n    def test_fail(self):\n        \"\"\"\n        Fails if any wrapped converter fails.\n        \"\"\"\n        c = pipe(str, to_bool)\n\n        # First wrapped converter fails:\n        with pytest.raises(ValueError):\n            c(33)\n\n        # Last wrapped converter fails:\n        with pytest.raises(ValueError):\n            c(\"33\")\n\n    def test_sugar(self):\n        \"\"\"\n        `pipe(c1, c2, c3)` and `[c1, c2, c3]` are equivalent.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a1 = attrib(default=\"True\", converter=pipe(str, to_bool, bool))\n            a2 = attrib(default=True, converter=[str, to_bool, bool])\n\n        c = C()\n        assert True is c.a1 is c.a2\n\n    def test_empty(self):\n        \"\"\"\n        Empty pipe returns same value.\n        \"\"\"\n        o = object()\n\n        assert o is pipe()(o)\n\n\nclass TestToBool:\n    def test_unhashable(self):\n        \"\"\"\n        Fails if value is unhashable.\n        \"\"\"\n        with pytest.raises(ValueError, match=\"Cannot convert value to bool\"):\n            to_bool([])\n\n    def test_truthy(self):\n        \"\"\"\n        Fails if truthy values are incorrectly converted.\n        \"\"\"\n        assert to_bool(\"t\")\n        assert to_bool(\"yes\")\n        assert to_bool(\"on\")\n\n    def test_falsy(self):\n        \"\"\"\n        Fails if falsy values are incorrectly converted.\n        \"\"\"\n        assert not to_bool(\"f\")\n        assert not to_bool(\"no\")\n        assert not to_bool(\"off\")\n", "tests/test_3rd_party.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for compatibility against other Python modules.\n\"\"\"\n\nimport pytest\n\nfrom hypothesis import given\n\nfrom .strategies import simple_classes\n\n\ncloudpickle = pytest.importorskip(\"cloudpickle\")\n\n\nclass TestCloudpickleCompat:\n    \"\"\"\n    Tests for compatibility with ``cloudpickle``.\n    \"\"\"\n\n    @given(simple_classes(cached_property=False))\n    def test_repr(self, cls):\n        \"\"\"\n        attrs instances can be pickled and un-pickled with cloudpickle.\n        \"\"\"\n        inst = cls()\n        # Exact values aren't a concern so long as neither direction\n        # raises an exception.\n        pkl = cloudpickle.dumps(inst)\n        cloudpickle.loads(pkl)\n", "tests/test_annotations.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for PEP-526 type annotations.\n\"\"\"\n\nimport sys\nimport types\nimport typing\n\nimport pytest\n\nimport attr\n\nfrom attr._make import _is_class_var\nfrom attr.exceptions import UnannotatedAttributeError\n\n\ndef assert_init_annotations(cls, **annotations):\n    \"\"\"\n    Assert cls.__init__ has the correct annotations.\n    \"\"\"\n    __tracebackhide__ = True\n\n    annotations[\"return\"] = type(None)\n\n    assert annotations == typing.get_type_hints(cls.__init__)\n\n\nclass TestAnnotations:\n    \"\"\"\n    Tests for types derived from variable annotations (PEP-526).\n    \"\"\"\n\n    def test_basic_annotations(self):\n        \"\"\"\n        Sets the `Attribute.type` attr from basic type annotations.\n        \"\"\"\n\n        @attr.resolve_types\n        @attr.s\n        class C:\n            x: int = attr.ib()\n            y = attr.ib(type=str)\n            z = attr.ib()\n\n        assert int is attr.fields(C).x.type\n        assert str is attr.fields(C).y.type\n        assert None is attr.fields(C).z.type\n        assert_init_annotations(C, x=int, y=str)\n\n    def test_catches_basic_type_conflict(self):\n        \"\"\"\n        Raises ValueError if type is specified both ways.\n        \"\"\"\n        with pytest.raises(ValueError) as e:\n\n            @attr.s\n            class C:\n                x: int = attr.ib(type=int)\n\n        assert (\n            \"Type annotation and type argument cannot both be present\",\n        ) == e.value.args\n\n    def test_typing_annotations(self):\n        \"\"\"\n        Sets the `Attribute.type` attr from typing annotations.\n        \"\"\"\n\n        @attr.resolve_types\n        @attr.s\n        class C:\n            x: typing.List[int] = attr.ib()\n            y = attr.ib(type=typing.Optional[str])\n\n        assert typing.List[int] is attr.fields(C).x.type\n        assert typing.Optional[str] is attr.fields(C).y.type\n        assert_init_annotations(C, x=typing.List[int], y=typing.Optional[str])\n\n    def test_only_attrs_annotations_collected(self):\n        \"\"\"\n        Annotations that aren't set to an attr.ib are ignored.\n        \"\"\"\n\n        @attr.resolve_types\n        @attr.s\n        class C:\n            x: typing.List[int] = attr.ib()\n            y: int\n\n        assert 1 == len(attr.fields(C))\n        assert_init_annotations(C, x=typing.List[int])\n\n    @pytest.mark.skipif(\n        sys.version_info[:2] < (3, 11),\n        reason=\"Incompatible behavior on older Pythons\",\n    )\n    def test_auto_attribs(self, slots):\n        \"\"\"\n        If *auto_attribs* is True, bare annotations are collected too.\n        Defaults work and class variables are ignored.\n        \"\"\"\n\n        @attr.s(auto_attribs=True, slots=slots)\n        class C:\n            cls_var: typing.ClassVar[int] = 23\n            a: int\n            x: typing.List[int] = attr.Factory(list)\n            y: int = 2\n            z: int = attr.ib(default=3)\n            foo: typing.Any = None\n\n        i = C(42)\n        assert \"C(a=42, x=[], y=2, z=3, foo=None)\" == repr(i)\n\n        attr_names = {a.name for a in C.__attrs_attrs__}\n        assert \"a\" in attr_names  # just double check that the set works\n        assert \"cls_var\" not in attr_names\n\n        attr.resolve_types(C)\n\n        assert int == attr.fields(C).a.type\n\n        assert attr.Factory(list) == attr.fields(C).x.default\n        assert typing.List[int] == attr.fields(C).x.type\n\n        assert int == attr.fields(C).y.type\n        assert 2 == attr.fields(C).y.default\n\n        assert int == attr.fields(C).z.type\n\n        assert typing.Any == attr.fields(C).foo.type\n\n        # Class body is clean.\n        if slots is False:\n            with pytest.raises(AttributeError):\n                C.y\n\n            assert 2 == i.y\n        else:\n            assert isinstance(C.y, types.MemberDescriptorType)\n\n            i.y = 23\n            assert 23 == i.y\n\n        assert_init_annotations(\n            C,\n            a=int,\n            x=typing.List[int],\n            y=int,\n            z=int,\n            foo=typing.Any,\n        )\n\n    def test_auto_attribs_unannotated(self, slots):\n        \"\"\"\n        Unannotated `attr.ib`s raise an error.\n        \"\"\"\n        with pytest.raises(UnannotatedAttributeError) as e:\n\n            @attr.s(slots=slots, auto_attribs=True)\n            class C:\n                v = attr.ib()\n                x: int\n                y = attr.ib()\n                z: str\n\n        assert (\n            \"The following `attr.ib`s lack a type annotation: v, y.\",\n        ) == e.value.args\n\n    def test_auto_attribs_subclassing(self, slots):\n        \"\"\"\n        Attributes from base classes are inherited, it doesn't matter if the\n        subclass has annotations or not.\n\n        Ref #291\n        \"\"\"\n\n        @attr.resolve_types\n        @attr.s(slots=slots, auto_attribs=True)\n        class A:\n            a: int = 1\n\n        @attr.resolve_types\n        @attr.s(slots=slots, auto_attribs=True)\n        class B(A):\n            b: int = 2\n\n        @attr.resolve_types\n        @attr.s(slots=slots, auto_attribs=True)\n        class C(A):\n            pass\n\n        assert \"B(a=1, b=2)\" == repr(B())\n        assert \"C(a=1)\" == repr(C())\n        assert_init_annotations(A, a=int)\n        assert_init_annotations(B, a=int, b=int)\n        assert_init_annotations(C, a=int)\n\n    def test_converter_annotations(self):\n        \"\"\"\n        An unannotated attribute with an annotated converter gets its\n        annotation from the converter.\n        \"\"\"\n\n        def int2str(x: int) -> str:\n            return str(x)\n\n        @attr.s\n        class A:\n            a = attr.ib(converter=int2str)\n\n        assert_init_annotations(A, a=int)\n\n        def int2str_(x: int, y: str = \"\"):\n            return str(x)\n\n        @attr.s\n        class A:\n            a = attr.ib(converter=int2str_)\n\n        assert_init_annotations(A, a=int)\n\n    def test_converter_attrib_annotations(self):\n        \"\"\"\n        If a converter is provided, an explicit type annotation has no\n        effect on an attribute's type annotation.\n        \"\"\"\n\n        def int2str(x: int) -> str:\n            return str(x)\n\n        @attr.s\n        class A:\n            a: str = attr.ib(converter=int2str)\n            b = attr.ib(converter=int2str, type=str)\n\n        assert_init_annotations(A, a=int, b=int)\n\n    def test_non_introspectable_converter(self):\n        \"\"\"\n        A non-introspectable converter doesn't cause a crash.\n        \"\"\"\n\n        @attr.s\n        class A:\n            a = attr.ib(converter=print)\n\n    def test_nullary_converter(self):\n        \"\"\"\n        A converter with no arguments doesn't cause a crash.\n        \"\"\"\n\n        def noop():\n            pass\n\n        @attr.s\n        class A:\n            a = attr.ib(converter=noop)\n\n        assert A.__init__.__annotations__ == {\"return\": None}\n\n    def test_pipe(self):\n        \"\"\"\n        pipe() uses the input annotation of its first argument and the\n        output annotation of its last argument.\n        \"\"\"\n\n        def int2str(x: int) -> str:\n            return str(x)\n\n        def strlen(y: str) -> int:\n            return len(y)\n\n        def identity(z):\n            return z\n\n        assert attr.converters.pipe(int2str).__annotations__ == {\n            \"val\": int,\n            \"return\": str,\n        }\n        assert attr.converters.pipe(int2str, strlen).__annotations__ == {\n            \"val\": int,\n            \"return\": int,\n        }\n        assert attr.converters.pipe(identity, strlen).__annotations__ == {\n            \"return\": int\n        }\n        assert attr.converters.pipe(int2str, identity).__annotations__ == {\n            \"val\": int\n        }\n\n        def int2str_(x: int, y: int = 0) -> str:\n            return str(x)\n\n        assert attr.converters.pipe(int2str_).__annotations__ == {\n            \"val\": int,\n            \"return\": str,\n        }\n\n    def test_pipe_empty(self):\n        \"\"\"\n        pipe() with no converters is annotated like the identity.\n        \"\"\"\n\n        p = attr.converters.pipe()\n        assert \"val\" in p.__annotations__\n        t = p.__annotations__[\"val\"]\n        assert isinstance(t, typing.TypeVar)\n        assert p.__annotations__ == {\"val\": t, \"return\": t}\n\n    def test_pipe_non_introspectable(self):\n        \"\"\"\n        pipe() doesn't crash when passed a non-introspectable converter.\n        \"\"\"\n\n        assert attr.converters.pipe(print).__annotations__ == {}\n\n    def test_pipe_nullary(self):\n        \"\"\"\n        pipe() doesn't crash when passed a nullary converter.\n        \"\"\"\n\n        def noop():\n            pass\n\n        assert attr.converters.pipe(noop).__annotations__ == {}\n\n    def test_optional(self):\n        \"\"\"\n        optional() uses the annotations of the converter it wraps.\n        \"\"\"\n\n        def int2str(x: int) -> str:\n            return str(x)\n\n        def int_identity(x: int):\n            return x\n\n        def strify(x) -> str:\n            return str(x)\n\n        def identity(x):\n            return x\n\n        assert attr.converters.optional(int2str).__annotations__ == {\n            \"val\": typing.Optional[int],\n            \"return\": typing.Optional[str],\n        }\n        assert attr.converters.optional(int_identity).__annotations__ == {\n            \"val\": typing.Optional[int]\n        }\n        assert attr.converters.optional(strify).__annotations__ == {\n            \"return\": typing.Optional[str]\n        }\n        assert attr.converters.optional(identity).__annotations__ == {}\n\n        def int2str_(x: int, y: int = 0) -> str:\n            return str(x)\n\n        assert attr.converters.optional(int2str_).__annotations__ == {\n            \"val\": typing.Optional[int],\n            \"return\": typing.Optional[str],\n        }\n\n    def test_optional_non_introspectable(self):\n        \"\"\"\n        optional() doesn't crash when passed a non-introspectable\n        converter.\n        \"\"\"\n\n        assert attr.converters.optional(print).__annotations__ == {}\n\n    def test_optional_nullary(self):\n        \"\"\"\n        optional() doesn't crash when passed a nullary converter.\n        \"\"\"\n\n        def noop():\n            pass\n\n        assert attr.converters.optional(noop).__annotations__ == {}\n\n    @pytest.mark.skipif(\n        sys.version_info[:2] < (3, 11),\n        reason=\"Incompatible behavior on older Pythons\",\n    )\n    def test_annotations_strings(self, slots):\n        \"\"\"\n        String annotations are passed into __init__ as is.\n\n        The strings keep changing between releases.\n        \"\"\"\n        import typing as t\n\n        from typing import ClassVar\n\n        @attr.s(auto_attribs=True, slots=slots)\n        class C:\n            cls_var1: \"typing.ClassVar[int]\" = 23\n            cls_var2: \"ClassVar[int]\" = 23\n            cls_var3: \"t.ClassVar[int]\" = 23\n            a: \"int\"\n            x: \"typing.List[int]\" = attr.Factory(list)\n            y: \"int\" = 2\n            z: \"int\" = attr.ib(default=3)\n            foo: \"typing.Any\" = None\n\n        attr.resolve_types(C, locals(), globals())\n\n        assert_init_annotations(\n            C,\n            a=int,\n            x=typing.List[int],\n            y=int,\n            z=int,\n            foo=typing.Any,\n        )\n\n    def test_typing_extensions_classvar(self, slots):\n        \"\"\"\n        If ClassVar is coming from typing_extensions, it is recognized too.\n        \"\"\"\n\n        @attr.s(auto_attribs=True, slots=slots)\n        class C:\n            cls_var: \"typing_extensions.ClassVar\" = 23  # noqa: F821\n\n        assert_init_annotations(C)\n\n    def test_keyword_only_auto_attribs(self):\n        \"\"\"\n        `kw_only` propagates to attributes defined via `auto_attribs`.\n        \"\"\"\n\n        @attr.s(auto_attribs=True, kw_only=True)\n        class C:\n            x: int\n            y: int\n\n        with pytest.raises(TypeError):\n            C(0, 1)\n\n        with pytest.raises(TypeError):\n            C(x=0)\n\n        c = C(x=0, y=1)\n\n        assert c.x == 0\n        assert c.y == 1\n\n    def test_base_class_variable(self):\n        \"\"\"\n        Base class' class variables can be overridden with an attribute\n        without resorting to using an explicit `attr.ib()`.\n        \"\"\"\n\n        class Base:\n            x: int = 42\n\n        @attr.s(auto_attribs=True)\n        class C(Base):\n            x: int\n\n        assert 1 == C(1).x\n\n    def test_removes_none_too(self):\n        \"\"\"\n        Regression test for #523: make sure defaults that are set to None are\n        removed too.\n        \"\"\"\n\n        @attr.s(auto_attribs=True)\n        class C:\n            x: int = 42\n            y: typing.Any = None\n\n        with pytest.raises(AttributeError):\n            C.x\n\n        with pytest.raises(AttributeError):\n            C.y\n\n    def test_non_comparable_defaults(self):\n        \"\"\"\n        Regression test for #585: objects that are not directly comparable\n        (for example numpy arrays) would cause a crash when used as\n        default values of an attrs auto-attrib class.\n        \"\"\"\n\n        class NonComparable:\n            def __eq__(self, other):\n                raise ValueError\n\n        @attr.s(auto_attribs=True)\n        class C:\n            x: typing.Any = NonComparable()\n\n    def test_basic_resolve(self):\n        \"\"\"\n        Resolve the `Attribute.type` attr from basic type annotations.\n        Unannotated types are ignored.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x: \"int\" = attr.ib()\n            y = attr.ib(type=str)\n            z = attr.ib()\n\n        attr.resolve_types(C)\n\n        assert int is attr.fields(C).x.type\n        assert str is attr.fields(C).y.type\n        assert None is attr.fields(C).z.type\n\n    @pytest.mark.skipif(\n        sys.version_info[:2] < (3, 9),\n        reason=\"Incompatible behavior on older Pythons\",\n    )\n    def test_extra_resolve(self):\n        \"\"\"\n        `get_type_hints` returns extra type hints.\n        \"\"\"\n        from typing import Annotated\n\n        globals = {\"Annotated\": Annotated}\n\n        @attr.define\n        class C:\n            x: 'Annotated[float, \"test\"]'\n\n        attr.resolve_types(C, globals)\n\n        assert attr.fields(C).x.type == Annotated[float, \"test\"]\n\n        @attr.define\n        class D:\n            x: 'Annotated[float, \"test\"]'\n\n        attr.resolve_types(D, globals, include_extras=False)\n\n        assert attr.fields(D).x.type == float\n\n    def test_resolve_types_auto_attrib(self, slots):\n        \"\"\"\n        Types can be resolved even when strings are involved.\n        \"\"\"\n\n        @attr.s(slots=slots, auto_attribs=True)\n        class A:\n            a: typing.List[int]\n            b: typing.List[\"int\"]\n            c: \"typing.List[int]\"\n\n        # Note: I don't have to pass globals and locals here because\n        # int is a builtin and will be available in any scope.\n        attr.resolve_types(A)\n\n        assert typing.List[int] == attr.fields(A).a.type\n        assert typing.List[int] == attr.fields(A).b.type\n        assert typing.List[int] == attr.fields(A).c.type\n\n    def test_resolve_types_decorator(self, slots):\n        \"\"\"\n        Types can be resolved using it as a decorator.\n        \"\"\"\n\n        @attr.resolve_types\n        @attr.s(slots=slots, auto_attribs=True)\n        class A:\n            a: typing.List[int]\n            b: typing.List[\"int\"]\n            c: \"typing.List[int]\"\n\n        assert typing.List[int] == attr.fields(A).a.type\n        assert typing.List[int] == attr.fields(A).b.type\n        assert typing.List[int] == attr.fields(A).c.type\n\n    def test_self_reference(self, slots):\n        \"\"\"\n        References to self class using quotes can be resolved.\n        \"\"\"\n\n        @attr.s(slots=slots, auto_attribs=True)\n        class A:\n            a: \"A\"\n            b: typing.Optional[\"A\"]  # will resolve below -- noqa: F821\n\n        attr.resolve_types(A, globals(), locals())\n\n        assert A == attr.fields(A).a.type\n        assert typing.Optional[A] == attr.fields(A).b.type\n\n    def test_forward_reference(self, slots):\n        \"\"\"\n        Forward references can be resolved.\n        \"\"\"\n\n        @attr.s(slots=slots, auto_attribs=True)\n        class A:\n            a: typing.List[\"B\"]  # will resolve below -- noqa: F821\n\n        @attr.s(slots=slots, auto_attribs=True)\n        class B:\n            a: A\n\n        attr.resolve_types(A, globals(), locals())\n        attr.resolve_types(B, globals(), locals())\n\n        assert typing.List[B] == attr.fields(A).a.type\n        assert A == attr.fields(B).a.type\n\n        assert typing.List[B] == attr.fields(A).a.type\n        assert A == attr.fields(B).a.type\n\n    def test_init_type_hints(self):\n        \"\"\"\n        Forward references in __init__ can be automatically resolved.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(type=\"typing.List[int]\")\n\n        assert_init_annotations(C, x=typing.List[int])\n\n    def test_init_type_hints_fake_module(self):\n        \"\"\"\n        If you somehow set the __module__ to something that doesn't exist\n        you'll lose __init__ resolution.\n        \"\"\"\n\n        class C:\n            x = attr.ib(type=\"typing.List[int]\")\n\n        C.__module__ = \"totally fake\"\n        C = attr.s(C)\n\n        with pytest.raises(NameError):\n            typing.get_type_hints(C.__init__)\n\n    def test_inheritance(self):\n        \"\"\"\n        Subclasses can be resolved after the parent is resolved.\n        \"\"\"\n\n        @attr.define()\n        class A:\n            n: \"int\"\n\n        @attr.define()\n        class B(A):\n            pass\n\n        attr.resolve_types(A)\n        attr.resolve_types(B)\n\n        assert int == attr.fields(A).n.type\n        assert int == attr.fields(B).n.type\n\n    def test_resolve_twice(self):\n        \"\"\"\n        You can call resolve_types as many times as you like.\n        This test is here mostly for coverage.\n        \"\"\"\n\n        @attr.define()\n        class A:\n            n: \"int\"\n\n        attr.resolve_types(A)\n        assert int == attr.fields(A).n.type\n        attr.resolve_types(A)\n        assert int == attr.fields(A).n.type\n\n\n@pytest.mark.parametrize(\n    \"annot\",\n    [\n        typing.ClassVar,\n        \"typing.ClassVar\",\n        \"'typing.ClassVar[dict]'\",\n        \"t.ClassVar[int]\",\n    ],\n)\ndef test_is_class_var(annot):\n    \"\"\"\n    ClassVars are detected, even if they're a string or quoted.\n    \"\"\"\n    assert _is_class_var(annot)\n", "tests/test_abc.py": "# SPDX-License-Identifier: MIT\n\nimport abc\nimport inspect\n\nimport pytest\n\nimport attrs\n\nfrom attr._compat import PY_3_10_PLUS, PY_3_12_PLUS\n\n\n@pytest.mark.skipif(\n    not PY_3_10_PLUS, reason=\"abc.update_abstractmethods is 3.10+\"\n)\nclass TestUpdateAbstractMethods:\n    def test_abc_implementation(self, slots):\n        \"\"\"\n        If an attrs class implements an abstract method, it stops being\n        abstract.\n        \"\"\"\n\n        class Ordered(abc.ABC):\n            @abc.abstractmethod\n            def __lt__(self, other):\n                pass\n\n            @abc.abstractmethod\n            def __le__(self, other):\n                pass\n\n        @attrs.define(order=True, slots=slots)\n        class Concrete(Ordered):\n            x: int\n\n        assert not inspect.isabstract(Concrete)\n        assert Concrete(2) > Concrete(1)\n\n    def test_remain_abstract(self, slots):\n        \"\"\"\n        If an attrs class inherits from an abstract class but doesn't implement\n        abstract methods, it remains abstract.\n        \"\"\"\n\n        class A(abc.ABC):\n            @abc.abstractmethod\n            def foo(self):\n                pass\n\n        @attrs.define(slots=slots)\n        class StillAbstract(A):\n            pass\n\n        assert inspect.isabstract(StillAbstract)\n        expected_exception_message = (\n            \"^Can't instantiate abstract class StillAbstract without an \"\n            \"implementation for abstract method 'foo'$\"\n            if PY_3_12_PLUS\n            else \"class StillAbstract with abstract method foo\"\n        )\n        with pytest.raises(TypeError, match=expected_exception_message):\n            StillAbstract()\n", "tests/utils.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommon helper functions for tests.\n\"\"\"\n\n\nfrom attr import Attribute\nfrom attr._make import NOTHING, _default_init_alias_for, make_class\n\n\ndef simple_class(\n    eq=False,\n    order=False,\n    repr=False,\n    hash=False,\n    str=False,\n    slots=False,\n    frozen=False,\n    cache_hash=False,\n):\n    \"\"\"\n    Return a new simple class.\n    \"\"\"\n    return make_class(\n        \"C\",\n        [\"a\", \"b\"],\n        eq=eq or order,\n        order=order,\n        repr=repr,\n        hash=hash,\n        init=True,\n        slots=slots,\n        str=str,\n        frozen=frozen,\n        cache_hash=cache_hash,\n    )\n\n\ndef simple_attr(\n    name,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    eq=True,\n    hash=None,\n    init=True,\n    converter=None,\n    kw_only=False,\n    inherited=False,\n):\n    \"\"\"\n    Return an attribute with a name and no other bells and whistles.\n    \"\"\"\n    return Attribute(\n        name=name,\n        default=default,\n        validator=validator,\n        repr=repr,\n        cmp=None,\n        eq=eq,\n        hash=hash,\n        init=init,\n        converter=converter,\n        kw_only=kw_only,\n        inherited=inherited,\n        alias=_default_init_alias_for(name),\n    )\n", "tests/test_filters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr.filters`.\n\"\"\"\n\n\nimport pytest\n\nimport attr\n\nfrom attr import fields\nfrom attr.filters import _split_what, exclude, include\n\n\n@attr.s\nclass C:\n    a = attr.ib()\n    b = attr.ib()\n\n\nclass TestSplitWhat:\n    \"\"\"\n    Tests for `_split_what`.\n    \"\"\"\n\n    def test_splits(self):\n        \"\"\"\n        Splits correctly.\n        \"\"\"\n        assert (\n            frozenset((int, str)),\n            frozenset((\"abcd\", \"123\")),\n            frozenset((fields(C).a,)),\n        ) == _split_what((str, \"123\", fields(C).a, int, \"abcd\"))\n\n\nclass TestInclude:\n    \"\"\"\n    Tests for `include`.\n    \"\"\"\n\n    @pytest.mark.parametrize(\n        (\"incl\", \"value\"),\n        [\n            ((int,), 42),\n            ((str,), \"hello\"),\n            ((str, fields(C).a), 42),\n            ((str, fields(C).b), \"hello\"),\n            ((\"a\",), 42),\n            ((\"a\",), \"hello\"),\n            ((\"a\", str), 42),\n            ((\"a\", fields(C).b), \"hello\"),\n        ],\n    )\n    def test_allow(self, incl, value):\n        \"\"\"\n        Return True if a class or attribute is included.\n        \"\"\"\n        i = include(*incl)\n        assert i(fields(C).a, value) is True\n\n    @pytest.mark.parametrize(\n        (\"incl\", \"value\"),\n        [\n            ((str,), 42),\n            ((int,), \"hello\"),\n            ((str, fields(C).b), 42),\n            ((int, fields(C).b), \"hello\"),\n            ((\"b\",), 42),\n            ((\"b\",), \"hello\"),\n            ((\"b\", str), 42),\n            ((\"b\", fields(C).b), \"hello\"),\n        ],\n    )\n    def test_drop_class(self, incl, value):\n        \"\"\"\n        Return False on non-included classes and attributes.\n        \"\"\"\n        i = include(*incl)\n        assert i(fields(C).a, value) is False\n\n\nclass TestExclude:\n    \"\"\"\n    Tests for `exclude`.\n    \"\"\"\n\n    @pytest.mark.parametrize(\n        (\"excl\", \"value\"),\n        [\n            ((str,), 42),\n            ((int,), \"hello\"),\n            ((str, fields(C).b), 42),\n            ((int, fields(C).b), \"hello\"),\n            ((\"b\",), 42),\n            ((\"b\",), \"hello\"),\n            ((\"b\", str), 42),\n            ((\"b\", fields(C).b), \"hello\"),\n        ],\n    )\n    def test_allow(self, excl, value):\n        \"\"\"\n        Return True if class or attribute is not excluded.\n        \"\"\"\n        e = exclude(*excl)\n        assert e(fields(C).a, value) is True\n\n    @pytest.mark.parametrize(\n        (\"excl\", \"value\"),\n        [\n            ((int,), 42),\n            ((str,), \"hello\"),\n            ((str, fields(C).a), 42),\n            ((str, fields(C).b), \"hello\"),\n            ((\"a\",), 42),\n            ((\"a\",), \"hello\"),\n            ((\"a\", str), 42),\n            ((\"a\", fields(C).b), \"hello\"),\n        ],\n    )\n    def test_drop_class(self, excl, value):\n        \"\"\"\n        Return True on non-excluded classes and attributes.\n        \"\"\"\n        e = exclude(*excl)\n        assert e(fields(C).a, value) is False\n", "tests/test_import.py": "# SPDX-License-Identifier: MIT\n\n\nclass TestImportStar:\n    def test_from_attr_import_star(self):\n        \"\"\"\n        import * from attr\n        \"\"\"\n        # attr_import_star contains `from attr import *`, which cannot\n        # be done here because *-imports are only allowed on module level.\n        from . import attr_import_star  # noqa: F401\n", "tests/test_compat.py": "# SPDX-License-Identifier: MIT\n\nimport types\n\nimport pytest\n\nimport attr\n\n\n@pytest.fixture(name=\"mp\")\ndef _mp():\n    return types.MappingProxyType({\"x\": 42, \"y\": \"foo\"})\n\n\nclass TestMetadataProxy:\n    \"\"\"\n    Ensure properties of metadata proxy independently of hypothesis strategies.\n    \"\"\"\n\n    def test_repr(self, mp):\n        \"\"\"\n        repr makes sense and is consistent across Python versions.\n        \"\"\"\n        assert any(\n            [\n                \"mappingproxy({'x': 42, 'y': 'foo'})\" == repr(mp),\n                \"mappingproxy({'y': 'foo', 'x': 42})\" == repr(mp),\n            ]\n        )\n\n    def test_immutable(self, mp):\n        \"\"\"\n        All mutating methods raise errors.\n        \"\"\"\n        with pytest.raises(TypeError, match=\"not support item assignment\"):\n            mp[\"z\"] = 23\n\n        with pytest.raises(TypeError, match=\"not support item deletion\"):\n            del mp[\"x\"]\n\n        with pytest.raises(AttributeError, match=\"no attribute 'update'\"):\n            mp.update({})\n\n        with pytest.raises(AttributeError, match=\"no attribute 'clear'\"):\n            mp.clear()\n\n        with pytest.raises(AttributeError, match=\"no attribute 'pop'\"):\n            mp.pop(\"x\")\n\n        with pytest.raises(AttributeError, match=\"no attribute 'popitem'\"):\n            mp.popitem()\n\n        with pytest.raises(AttributeError, match=\"no attribute 'setdefault'\"):\n            mp.setdefault(\"x\")\n\n\ndef test_attrsinstance_subclass_protocol():\n    \"\"\"\n    It's possible to subclass AttrsInstance and Protocol at once.\n    \"\"\"\n\n    class Foo(attr.AttrsInstance, attr._compat.Protocol):\n        def attribute(self) -> int: ...\n", "tests/test_packaging.py": "# SPDX-License-Identifier: MIT\n\nimport sys\n\nimport pytest\n\nimport attr\nimport attrs\n\n\nif sys.version_info < (3, 8):\n    import importlib_metadata as metadata\nelse:\n    from importlib import metadata\n\n\n@pytest.fixture(name=\"mod\", params=(attr, attrs))\ndef _mod(request):\n    return request.param\n\n\nclass TestLegacyMetadataHack:\n    def test_version(self, mod, recwarn):\n        \"\"\"\n        __version__ returns the correct version and doesn't warn.\n        \"\"\"\n        assert metadata.version(\"attrs\") == mod.__version__\n\n        assert [] == recwarn.list\n\n    def test_does_not_exist(self, mod):\n        \"\"\"\n        Asking for unsupported dunders raises an AttributeError.\n        \"\"\"\n        with pytest.raises(\n            AttributeError,\n            match=f\"module {mod.__name__} has no attribute __yolo__\",\n        ):\n            mod.__yolo__\n\n    def test_version_info(self, recwarn, mod):\n        \"\"\"\n        ___version_info__ is not deprecated, therefore doesn't raise a warning\n        and parses correctly.\n        \"\"\"\n        assert isinstance(mod.__version_info__, attr.VersionInfo)\n        assert [] == recwarn.list\n", "tests/test_dunders.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for dunder methods from `attrib._make`.\n\"\"\"\n\n\nimport copy\nimport inspect\nimport pickle\n\nimport pytest\n\nfrom hypothesis import given\nfrom hypothesis.strategies import booleans\n\nimport attr\n\nfrom attr._make import (\n    NOTHING,\n    Factory,\n    _add_repr,\n    _make_init,\n    fields,\n    make_class,\n)\nfrom attr.validators import instance_of\n\nfrom .utils import simple_attr, simple_class\n\n\nEqC = simple_class(eq=True)\nEqCSlots = simple_class(eq=True, slots=True)\nOrderC = simple_class(order=True)\nOrderCSlots = simple_class(order=True, slots=True)\nReprC = simple_class(repr=True)\nReprCSlots = simple_class(repr=True, slots=True)\n\n\n@attr.s(eq=True)\nclass EqCallableC:\n    a = attr.ib(eq=str.lower, order=False)\n    b = attr.ib(eq=True)\n\n\n@attr.s(eq=True, slots=True)\nclass EqCallableCSlots:\n    a = attr.ib(eq=str.lower, order=False)\n    b = attr.ib(eq=True)\n\n\n@attr.s(order=True)\nclass OrderCallableC:\n    a = attr.ib(eq=True, order=str.lower)\n    b = attr.ib(order=True)\n\n\n@attr.s(order=True, slots=True)\nclass OrderCallableCSlots:\n    a = attr.ib(eq=True, order=str.lower)\n    b = attr.ib(order=True)\n\n\n# HashC is hashable by explicit definition while HashCSlots is hashable\n# implicitly.  The \"Cached\" versions are the same, except with hash code\n# caching enabled\nHashC = simple_class(hash=True)\nHashCSlots = simple_class(hash=None, eq=True, frozen=True, slots=True)\nHashCCached = simple_class(hash=True, cache_hash=True)\nHashCSlotsCached = simple_class(\n    hash=None, eq=True, frozen=True, slots=True, cache_hash=True\n)\n# the cached hash code is stored slightly differently in this case\n# so it needs to be tested separately\nHashCFrozenNotSlotsCached = simple_class(\n    frozen=True, slots=False, hash=True, cache_hash=True\n)\n\n\ndef _add_init(cls, frozen):\n    \"\"\"\n    Add a __init__ method to *cls*.  If *frozen* is True, make it immutable.\n\n    This function used to be part of _make.  It wasn't used anymore however\n    the tests for it are still useful to test the behavior of _make_init.\n    \"\"\"\n    has_pre_init = bool(getattr(cls, \"__attrs_pre_init__\", False))\n\n    cls.__init__ = _make_init(\n        cls,\n        cls.__attrs_attrs__,\n        has_pre_init,\n        (\n            len(inspect.signature(cls.__attrs_pre_init__).parameters) > 1\n            if has_pre_init\n            else False\n        ),\n        getattr(cls, \"__attrs_post_init__\", False),\n        frozen,\n        \"__slots__\" in cls.__dict__,\n        cache_hash=False,\n        base_attr_map={},\n        is_exc=False,\n        cls_on_setattr=None,\n        attrs_init=False,\n    )\n    return cls\n\n\nclass InitC:\n    __attrs_attrs__ = [simple_attr(\"a\"), simple_attr(\"b\")]\n\n\nInitC = _add_init(InitC, False)\n\n\nclass TestEqOrder:\n    \"\"\"\n    Tests for eq and order related methods.\n    \"\"\"\n\n    @given(booleans())\n    def test_eq_ignore_attrib(self, slots):\n        \"\"\"\n        If `eq` is False for an attribute, ignore that attribute.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"a\": attr.ib(eq=False), \"b\": attr.ib()}, slots=slots\n        )\n\n        assert C(1, 2) == C(2, 2)\n\n    @pytest.mark.parametrize(\"cls\", [EqC, EqCSlots])\n    def test_equal(self, cls):\n        \"\"\"\n        Equal objects are detected as equal.\n        \"\"\"\n        assert cls(1, 2) == cls(1, 2)\n        assert not (cls(1, 2) != cls(1, 2))\n\n    @pytest.mark.parametrize(\"cls\", [EqCallableC, EqCallableCSlots])\n    def test_equal_callable(self, cls):\n        \"\"\"\n        Equal objects are detected as equal.\n        \"\"\"\n        assert cls(\"Test\", 1) == cls(\"test\", 1)\n        assert cls(\"Test\", 1) != cls(\"test\", 2)\n        assert not (cls(\"Test\", 1) != cls(\"test\", 1))\n        assert not (cls(\"Test\", 1) == cls(\"test\", 2))\n\n    @pytest.mark.parametrize(\"cls\", [EqC, EqCSlots])\n    def test_unequal_same_class(self, cls):\n        \"\"\"\n        Unequal objects of correct type are detected as unequal.\n        \"\"\"\n        assert cls(1, 2) != cls(2, 1)\n        assert not (cls(1, 2) == cls(2, 1))\n\n    @pytest.mark.parametrize(\"cls\", [EqCallableC, EqCallableCSlots])\n    def test_unequal_same_class_callable(self, cls):\n        \"\"\"\n        Unequal objects of correct type are detected as unequal.\n        \"\"\"\n        assert cls(\"Test\", 1) != cls(\"foo\", 2)\n        assert not (cls(\"Test\", 1) == cls(\"foo\", 2))\n\n    @pytest.mark.parametrize(\n        \"cls\", [EqC, EqCSlots, EqCallableC, EqCallableCSlots]\n    )\n    def test_unequal_different_class(self, cls):\n        \"\"\"\n        Unequal objects of different type are detected even if their attributes\n        match.\n        \"\"\"\n\n        class NotEqC:\n            a = 1\n            b = 2\n\n        assert cls(1, 2) != NotEqC()\n        assert not (cls(1, 2) == NotEqC())\n\n    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n    def test_lt(self, cls):\n        \"\"\"\n        __lt__ compares objects as tuples of attribute values.\n        \"\"\"\n        for a, b in [\n            ((1, 2), (2, 1)),\n            ((1, 2), (1, 3)),\n            ((\"a\", \"b\"), (\"b\", \"a\")),\n        ]:\n            assert cls(*a) < cls(*b)\n\n    @pytest.mark.parametrize(\"cls\", [OrderCallableC, OrderCallableCSlots])\n    def test_lt_callable(self, cls):\n        \"\"\"\n        __lt__ compares objects as tuples of attribute values.\n        \"\"\"\n        # Note: \"A\" < \"a\"\n        for a, b in [\n            ((\"test1\", 1), (\"Test1\", 2)),\n            ((\"test0\", 1), (\"Test1\", 1)),\n        ]:\n            assert cls(*a) < cls(*b)\n\n    @pytest.mark.parametrize(\n        \"cls\", [OrderC, OrderCSlots, OrderCallableC, OrderCallableCSlots]\n    )\n    def test_lt_unordable(self, cls):\n        \"\"\"\n        __lt__ returns NotImplemented if classes differ.\n        \"\"\"\n        assert NotImplemented == (cls(1, 2).__lt__(42))\n\n    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n    def test_le(self, cls):\n        \"\"\"\n        __le__ compares objects as tuples of attribute values.\n        \"\"\"\n        for a, b in [\n            ((1, 2), (2, 1)),\n            ((1, 2), (1, 3)),\n            ((1, 1), (1, 1)),\n            ((\"a\", \"b\"), (\"b\", \"a\")),\n            ((\"a\", \"b\"), (\"a\", \"b\")),\n        ]:\n            assert cls(*a) <= cls(*b)\n\n    @pytest.mark.parametrize(\"cls\", [OrderCallableC, OrderCallableCSlots])\n    def test_le_callable(self, cls):\n        \"\"\"\n        __le__ compares objects as tuples of attribute values.\n        \"\"\"\n        # Note: \"A\" < \"a\"\n        for a, b in [\n            ((\"test1\", 1), (\"Test1\", 1)),\n            ((\"test1\", 1), (\"Test1\", 2)),\n            ((\"test0\", 1), (\"Test1\", 1)),\n            ((\"test0\", 2), (\"Test1\", 1)),\n        ]:\n            assert cls(*a) <= cls(*b)\n\n    @pytest.mark.parametrize(\n        \"cls\", [OrderC, OrderCSlots, OrderCallableC, OrderCallableCSlots]\n    )\n    def test_le_unordable(self, cls):\n        \"\"\"\n        __le__ returns NotImplemented if classes differ.\n        \"\"\"\n        assert NotImplemented == (cls(1, 2).__le__(42))\n\n    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n    def test_gt(self, cls):\n        \"\"\"\n        __gt__ compares objects as tuples of attribute values.\n        \"\"\"\n        for a, b in [\n            ((2, 1), (1, 2)),\n            ((1, 3), (1, 2)),\n            ((\"b\", \"a\"), (\"a\", \"b\")),\n        ]:\n            assert cls(*a) > cls(*b)\n\n    @pytest.mark.parametrize(\"cls\", [OrderCallableC, OrderCallableCSlots])\n    def test_gt_callable(self, cls):\n        \"\"\"\n        __gt__ compares objects as tuples of attribute values.\n        \"\"\"\n        # Note: \"A\" < \"a\"\n        for a, b in [\n            ((\"Test1\", 2), (\"test1\", 1)),\n            ((\"Test1\", 1), (\"test0\", 1)),\n        ]:\n            assert cls(*a) > cls(*b)\n\n    @pytest.mark.parametrize(\n        \"cls\", [OrderC, OrderCSlots, OrderCallableC, OrderCallableCSlots]\n    )\n    def test_gt_unordable(self, cls):\n        \"\"\"\n        __gt__ returns NotImplemented if classes differ.\n        \"\"\"\n        assert NotImplemented == (cls(1, 2).__gt__(42))\n\n    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n    def test_ge(self, cls):\n        \"\"\"\n        __ge__ compares objects as tuples of attribute values.\n        \"\"\"\n        for a, b in [\n            ((2, 1), (1, 2)),\n            ((1, 3), (1, 2)),\n            ((1, 1), (1, 1)),\n            ((\"b\", \"a\"), (\"a\", \"b\")),\n            ((\"a\", \"b\"), (\"a\", \"b\")),\n        ]:\n            assert cls(*a) >= cls(*b)\n\n    @pytest.mark.parametrize(\"cls\", [OrderCallableC, OrderCallableCSlots])\n    def test_ge_callable(self, cls):\n        \"\"\"\n        __ge__ compares objects as tuples of attribute values.\n        \"\"\"\n        # Note: \"A\" < \"a\"\n        for a, b in [\n            ((\"Test1\", 1), (\"test1\", 1)),\n            ((\"Test1\", 2), (\"test1\", 1)),\n            ((\"Test1\", 1), (\"test0\", 1)),\n            ((\"Test1\", 1), (\"test0\", 2)),\n        ]:\n            assert cls(*a) >= cls(*b)\n\n    @pytest.mark.parametrize(\n        \"cls\", [OrderC, OrderCSlots, OrderCallableC, OrderCallableCSlots]\n    )\n    def test_ge_unordable(self, cls):\n        \"\"\"\n        __ge__ returns NotImplemented if classes differ.\n        \"\"\"\n        assert NotImplemented == (cls(1, 2).__ge__(42))\n\n\nclass TestAddRepr:\n    \"\"\"\n    Tests for `_add_repr`.\n    \"\"\"\n\n    def test_repr(self, slots):\n        \"\"\"\n        If `repr` is False, ignore that attribute.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"a\": attr.ib(repr=False), \"b\": attr.ib()}, slots=slots\n        )\n\n        assert \"C(b=2)\" == repr(C(1, 2))\n\n    @pytest.mark.parametrize(\"cls\", [ReprC, ReprCSlots])\n    def test_repr_works(self, cls):\n        \"\"\"\n        repr returns a sensible value.\n        \"\"\"\n        assert \"C(a=1, b=2)\" == repr(cls(1, 2))\n\n    def test_custom_repr_works(self):\n        \"\"\"\n        repr returns a sensible value for attributes with a custom repr\n        callable.\n        \"\"\"\n\n        def custom_repr(value):\n            return \"foo:\" + str(value)\n\n        @attr.s\n        class C:\n            a = attr.ib(repr=custom_repr)\n\n        assert \"C(a=foo:1)\" == repr(C(1))\n\n    def test_infinite_recursion(self):\n        \"\"\"\n        In the presence of a cyclic graph, repr will emit an ellipsis and not\n        raise an exception.\n        \"\"\"\n\n        @attr.s\n        class Cycle:\n            value = attr.ib(default=7)\n            cycle = attr.ib(default=None)\n\n        cycle = Cycle()\n        cycle.cycle = cycle\n        assert \"Cycle(value=7, cycle=...)\" == repr(cycle)\n\n    def test_infinite_recursion_long_cycle(self):\n        \"\"\"\n        A cyclic graph can pass through other non-attrs objects, and repr will\n        still emit an ellipsis and not raise an exception.\n        \"\"\"\n\n        @attr.s\n        class LongCycle:\n            value = attr.ib(default=14)\n            cycle = attr.ib(default=None)\n\n        cycle = LongCycle()\n        # Ensure that the reference cycle passes through a non-attrs object.\n        # This demonstrates the need for a thread-local \"global\" ID tracker.\n        cycle.cycle = {\"cycle\": [cycle]}\n        assert \"LongCycle(value=14, cycle={'cycle': [...]})\" == repr(cycle)\n\n    def test_underscores(self):\n        \"\"\"\n        repr does not strip underscores.\n        \"\"\"\n\n        class C:\n            __attrs_attrs__ = [simple_attr(\"_x\")]\n\n        C = _add_repr(C)\n        i = C()\n        i._x = 42\n\n        assert \"C(_x=42)\" == repr(i)\n\n    def test_repr_uninitialized_member(self):\n        \"\"\"\n        repr signals unset attributes\n        \"\"\"\n        C = make_class(\"C\", {\"a\": attr.ib(init=False)})\n\n        assert \"C(a=NOTHING)\" == repr(C())\n\n    @given(add_str=booleans(), slots=booleans())\n    def test_str(self, add_str, slots):\n        \"\"\"\n        If str is True, it returns the same as repr.\n\n        This only makes sense when subclassing a class with an poor __str__\n        (like Exceptions).\n        \"\"\"\n\n        @attr.s(str=add_str, slots=slots)\n        class Error(Exception):\n            x = attr.ib()\n\n        e = Error(42)\n\n        assert (str(e) == repr(e)) is add_str\n\n    def test_str_no_repr(self):\n        \"\"\"\n        Raises a ValueError if repr=False and str=True.\n        \"\"\"\n        with pytest.raises(ValueError) as e:\n            simple_class(repr=False, str=True)\n\n        assert (\n            \"__str__ can only be generated if a __repr__ exists.\"\n        ) == e.value.args[0]\n\n\n# these are for use in TestAddHash.test_cache_hash_serialization\n# they need to be out here so they can be un-pickled\n@attr.attrs(hash=True, cache_hash=False)\nclass HashCacheSerializationTestUncached:\n    foo_value = attr.ib()\n\n\n@attr.attrs(hash=True, cache_hash=True)\nclass HashCacheSerializationTestCached:\n    foo_value = attr.ib()\n\n\n@attr.attrs(slots=True, hash=True, cache_hash=True)\nclass HashCacheSerializationTestCachedSlots:\n    foo_value = attr.ib()\n\n\nclass IncrementingHasher:\n    def __init__(self):\n        self.hash_value = 100\n\n    def __hash__(self):\n        rv = self.hash_value\n        self.hash_value += 1\n        return rv\n\n\nclass TestAddHash:\n    \"\"\"\n    Tests for `_add_hash`.\n    \"\"\"\n\n    def test_enforces_type(self):\n        \"\"\"\n        The `hash` argument to both attrs and attrib must be None, True, or\n        False.\n        \"\"\"\n        exc_args = (\"Invalid value for hash.  Must be True, False, or None.\",)\n\n        with pytest.raises(TypeError) as e:\n            make_class(\"C\", {}, hash=1),\n\n        assert exc_args == e.value.args\n\n        with pytest.raises(TypeError) as e:\n            make_class(\"C\", {\"a\": attr.ib(hash=1)}),\n\n        assert exc_args == e.value.args\n\n    def test_enforce_no_cache_hash_without_hash(self):\n        \"\"\"\n        Ensure exception is thrown if caching the hash code is requested\n        but attrs is not requested to generate `__hash__`.\n        \"\"\"\n        exc_args = (\n            \"Invalid value for cache_hash.  To use hash caching,\"\n            \" hashing must be either explicitly or implicitly \"\n            \"enabled.\",\n        )\n        with pytest.raises(TypeError) as e:\n            make_class(\"C\", {}, hash=False, cache_hash=True)\n        assert exc_args == e.value.args\n\n        # unhashable case\n        with pytest.raises(TypeError) as e:\n            make_class(\n                \"C\", {}, hash=None, eq=True, frozen=False, cache_hash=True\n            )\n        assert exc_args == e.value.args\n\n    def test_enforce_no_cached_hash_without_init(self):\n        \"\"\"\n        Ensure exception is thrown if caching the hash code is requested\n        but attrs is not requested to generate `__init__`.\n        \"\"\"\n        exc_args = (\n            \"Invalid value for cache_hash.  To use hash caching,\"\n            \" init must be True.\",\n        )\n        with pytest.raises(TypeError) as e:\n            make_class(\"C\", {}, init=False, hash=True, cache_hash=True)\n        assert exc_args == e.value.args\n\n    @given(booleans(), booleans())\n    def test_hash_attribute(self, slots, cache_hash):\n        \"\"\"\n        If `hash` is False on an attribute, ignore that attribute.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\"a\": attr.ib(hash=False), \"b\": attr.ib()},\n            slots=slots,\n            hash=True,\n            cache_hash=cache_hash,\n        )\n\n        assert hash(C(1, 2)) == hash(C(2, 2))\n\n    @given(booleans())\n    def test_hash_attribute_mirrors_eq(self, eq):\n        \"\"\"\n        If `hash` is None, the hash generation mirrors `eq`.\n        \"\"\"\n        C = make_class(\"C\", {\"a\": attr.ib(eq=eq)}, eq=True, frozen=True)\n\n        if eq:\n            assert C(1) != C(2)\n            assert hash(C(1)) != hash(C(2))\n            assert hash(C(1)) == hash(C(1))\n        else:\n            assert C(1) == C(2)\n            assert hash(C(1)) == hash(C(2))\n\n    @given(booleans())\n    def test_hash_mirrors_eq(self, eq):\n        \"\"\"\n        If `hash` is None, the hash generation mirrors `eq`.\n        \"\"\"\n        C = make_class(\"C\", {\"a\": attr.ib()}, eq=eq, frozen=True)\n\n        i = C(1)\n\n        assert i == i\n        assert hash(i) == hash(i)\n\n        if eq:\n            assert C(1) == C(1)\n            assert hash(C(1)) == hash(C(1))\n        else:\n            assert C(1) != C(1)\n            assert hash(C(1)) != hash(C(1))\n\n    @pytest.mark.parametrize(\n        \"cls\",\n        [\n            HashC,\n            HashCSlots,\n            HashCCached,\n            HashCSlotsCached,\n            HashCFrozenNotSlotsCached,\n        ],\n    )\n    def test_hash_works(self, cls):\n        \"\"\"\n        __hash__ returns different hashes for different values.\n        \"\"\"\n        a = cls(1, 2)\n        b = cls(1, 1)\n        assert hash(a) != hash(b)\n        # perform the test again to test the pre-cached path through\n        # __hash__ for the cached-hash versions\n        assert hash(a) != hash(b)\n\n    def test_hash_default(self):\n        \"\"\"\n        Classes are not hashable by default.\n        \"\"\"\n        C = make_class(\"C\", {})\n\n        with pytest.raises(TypeError) as e:\n            hash(C())\n\n        assert e.value.args[0] in (\n            \"'C' objects are unhashable\",  # PyPy\n            \"unhashable type: 'C'\",  # CPython\n        )\n\n    def test_cache_hashing(self):\n        \"\"\"\n        Ensure that hash computation if cached if and only if requested\n        \"\"\"\n\n        class HashCounter:\n            \"\"\"\n            A class for testing which counts how many times its hash\n            has been requested\n            \"\"\"\n\n            def __init__(self):\n                self.times_hash_called = 0\n\n            def __hash__(self):\n                self.times_hash_called += 1\n                return 12345\n\n        Uncached = make_class(\n            \"Uncached\",\n            {\"hash_counter\": attr.ib(factory=HashCounter)},\n            hash=True,\n            cache_hash=False,\n        )\n        Cached = make_class(\n            \"Cached\",\n            {\"hash_counter\": attr.ib(factory=HashCounter)},\n            hash=True,\n            cache_hash=True,\n        )\n\n        uncached_instance = Uncached()\n        cached_instance = Cached()\n\n        hash(uncached_instance)\n        hash(uncached_instance)\n        hash(cached_instance)\n        hash(cached_instance)\n\n        assert 2 == uncached_instance.hash_counter.times_hash_called\n        assert 1 == cached_instance.hash_counter.times_hash_called\n\n    @pytest.mark.parametrize(\"cache_hash\", [True, False])\n    def test_copy_hash_cleared(self, cache_hash, frozen, slots):\n        \"\"\"\n        Test that the default hash is recalculated after a copy operation.\n        \"\"\"\n\n        kwargs = {\"frozen\": frozen, \"slots\": slots, \"cache_hash\": cache_hash}\n\n        # Give it an explicit hash if we don't have an implicit one\n        if not frozen:\n            kwargs[\"hash\"] = True\n\n        @attr.s(**kwargs)\n        class C:\n            x = attr.ib()\n\n        a = C(IncrementingHasher())\n        # Ensure that any hash cache would be calculated before copy\n        orig_hash = hash(a)\n        b = copy.deepcopy(a)\n\n        if kwargs[\"cache_hash\"]:\n            # For cache_hash classes, this call is cached\n            assert orig_hash == hash(a)\n\n        assert orig_hash != hash(b)\n\n    @pytest.mark.parametrize(\n        (\"klass\", \"cached\"),\n        [\n            (HashCacheSerializationTestUncached, False),\n            (HashCacheSerializationTestCached, True),\n            (HashCacheSerializationTestCachedSlots, True),\n        ],\n    )\n    def test_cache_hash_serialization_hash_cleared(self, klass, cached):\n        \"\"\"\n        Tests that the hash cache is cleared on deserialization to fix\n        https://github.com/python-attrs/attrs/issues/482 .\n\n        This test is intended to guard against a stale hash code surviving\n        across serialization (which may cause problems when the hash value\n        is different in different interpreters).\n        \"\"\"\n\n        obj = klass(IncrementingHasher())\n        original_hash = hash(obj)\n        obj_rt = self._roundtrip_pickle(obj)\n\n        if cached:\n            assert original_hash == hash(obj)\n\n        assert original_hash != hash(obj_rt)\n\n    def test_copy_two_arg_reduce(self, frozen):\n        \"\"\"\n        If __getstate__ returns None, the tuple returned by object.__reduce__\n        won't contain the state dictionary; this test ensures that the custom\n        __reduce__ generated when cache_hash=True works in that case.\n        \"\"\"\n\n        @attr.s(frozen=frozen, cache_hash=True, hash=True)\n        class C:\n            x = attr.ib()\n\n            def __getstate__(self):\n                return None\n\n        # By the nature of this test it doesn't really create an object that's\n        # in a valid state - it basically does the equivalent of\n        # `object.__new__(C)`, so it doesn't make much sense to assert anything\n        # about the result of the copy. This test will just check that it\n        # doesn't raise an *error*.\n        copy.deepcopy(C(1))\n\n    def _roundtrip_pickle(self, obj):\n        pickle_str = pickle.dumps(obj)\n        return pickle.loads(pickle_str)\n\n\nclass TestAddInit:\n    \"\"\"\n    Tests for `_add_init`.\n    \"\"\"\n\n    @given(booleans(), booleans())\n    def test_init(self, slots, frozen):\n        \"\"\"\n        If `init` is False, ignore that attribute.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\"a\": attr.ib(init=False), \"b\": attr.ib()},\n            slots=slots,\n            frozen=frozen,\n        )\n        with pytest.raises(TypeError) as e:\n            C(a=1, b=2)\n\n        assert e.value.args[0].endswith(\n            \"__init__() got an unexpected keyword argument 'a'\"\n        )\n\n    @given(booleans(), booleans())\n    def test_no_init_default(self, slots, frozen):\n        \"\"\"\n        If `init` is False but a Factory is specified, don't allow passing that\n        argument but initialize it anyway.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\n                \"_a\": attr.ib(init=False, default=42),\n                \"_b\": attr.ib(init=False, default=Factory(list)),\n                \"c\": attr.ib(),\n            },\n            slots=slots,\n            frozen=frozen,\n        )\n        with pytest.raises(TypeError):\n            C(a=1, c=2)\n        with pytest.raises(TypeError):\n            C(b=1, c=2)\n\n        i = C(23)\n        assert (42, [], 23) == (i._a, i._b, i.c)\n\n    @given(booleans(), booleans())\n    def test_no_init_order(self, slots, frozen):\n        \"\"\"\n        If an attribute is `init=False`, it's legal to come after a mandatory\n        attribute.\n        \"\"\"\n        make_class(\n            \"C\",\n            {\"a\": attr.ib(default=Factory(list)), \"b\": attr.ib(init=False)},\n            slots=slots,\n            frozen=frozen,\n        )\n\n    def test_sets_attributes(self):\n        \"\"\"\n        The attributes are initialized using the passed keywords.\n        \"\"\"\n        obj = InitC(a=1, b=2)\n        assert 1 == obj.a\n        assert 2 == obj.b\n\n    def test_default(self):\n        \"\"\"\n        If a default value is present, it's used as fallback.\n        \"\"\"\n\n        class C:\n            __attrs_attrs__ = [\n                simple_attr(name=\"a\", default=2),\n                simple_attr(name=\"b\", default=\"hallo\"),\n                simple_attr(name=\"c\", default=None),\n            ]\n\n        C = _add_init(C, False)\n        i = C()\n        assert 2 == i.a\n        assert \"hallo\" == i.b\n        assert None is i.c\n\n    def test_factory(self):\n        \"\"\"\n        If a default factory is present, it's used as fallback.\n        \"\"\"\n\n        class D:\n            pass\n\n        class C:\n            __attrs_attrs__ = [\n                simple_attr(name=\"a\", default=Factory(list)),\n                simple_attr(name=\"b\", default=Factory(D)),\n            ]\n\n        C = _add_init(C, False)\n        i = C()\n\n        assert [] == i.a\n        assert isinstance(i.b, D)\n\n    def test_factory_takes_self(self):\n        \"\"\"\n        If takes_self on factories is True, self is passed.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\n                \"x\": attr.ib(\n                    default=Factory((lambda self: self), takes_self=True)\n                )\n            },\n        )\n\n        i = C()\n\n        assert i is i.x\n\n    def test_factory_hashable(self):\n        \"\"\"\n        Factory is hashable.\n        \"\"\"\n        assert hash(Factory(None, False)) == hash(Factory(None, False))\n\n    def test_validator(self):\n        \"\"\"\n        If a validator is passed, call it with the preliminary instance, the\n        Attribute, and the argument.\n        \"\"\"\n\n        class VException(Exception):\n            pass\n\n        def raiser(*args):\n            raise VException(*args)\n\n        C = make_class(\"C\", {\"a\": attr.ib(\"a\", validator=raiser)})\n        with pytest.raises(VException) as e:\n            C(42)\n\n        assert (fields(C).a, 42) == e.value.args[1:]\n        assert isinstance(e.value.args[0], C)\n\n    def test_validator_slots(self):\n        \"\"\"\n        If a validator is passed, call it with the preliminary instance, the\n        Attribute, and the argument.\n        \"\"\"\n\n        class VException(Exception):\n            pass\n\n        def raiser(*args):\n            raise VException(*args)\n\n        C = make_class(\"C\", {\"a\": attr.ib(\"a\", validator=raiser)}, slots=True)\n        with pytest.raises(VException) as e:\n            C(42)\n\n        assert (fields(C)[0], 42) == e.value.args[1:]\n        assert isinstance(e.value.args[0], C)\n\n    @given(booleans())\n    def test_validator_others(self, slots):\n        \"\"\"\n        Does not interfere when setting non-attrs attributes.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"a\": attr.ib(\"a\", validator=instance_of(int))}, slots=slots\n        )\n        i = C(1)\n\n        assert 1 == i.a\n\n        if not slots:\n            i.b = \"foo\"\n            assert \"foo\" == i.b\n        else:\n            with pytest.raises(AttributeError):\n                i.b = \"foo\"\n\n    def test_underscores(self):\n        \"\"\"\n        The argument names in `__init__` are without leading and trailing\n        underscores.\n        \"\"\"\n\n        class C:\n            __attrs_attrs__ = [simple_attr(\"_private\")]\n\n        C = _add_init(C, False)\n        i = C(private=42)\n        assert 42 == i._private\n\n\nclass TestNothing:\n    \"\"\"\n    Tests for `NOTHING`.\n    \"\"\"\n\n    def test_copy(self):\n        \"\"\"\n        __copy__ returns the same object.\n        \"\"\"\n        n = NOTHING\n        assert n is copy.copy(n)\n\n    def test_deepcopy(self):\n        \"\"\"\n        __deepcopy__ returns the same object.\n        \"\"\"\n        n = NOTHING\n        assert n is copy.deepcopy(n)\n\n    def test_eq(self):\n        \"\"\"\n        All instances are equal.\n        \"\"\"\n        assert NOTHING == NOTHING == NOTHING\n        assert not (NOTHING != NOTHING)\n        assert 1 != NOTHING\n\n    def test_false(self):\n        \"\"\"\n        NOTHING evaluates as falsey.\n        \"\"\"\n        assert not NOTHING\n        assert False is bool(NOTHING)\n\n\n@attr.s(hash=True, order=True)\nclass C:\n    pass\n\n\n# Store this class so that we recreate it.\nOriginalC = C\n\n\n@attr.s(hash=True, order=True)\nclass C:\n    pass\n\n\nCopyC = C\n\n\n@attr.s(hash=True, order=True)\nclass C:\n    \"\"\"A different class, to generate different methods.\"\"\"\n\n    a = attr.ib()\n\n\nclass TestFilenames:\n    def test_filenames(self):\n        \"\"\"\n        The created dunder methods have a \"consistent\" filename.\n        \"\"\"\n        assert (\n            OriginalC.__init__.__code__.co_filename\n            == \"<attrs generated init tests.test_dunders.C>\"\n        )\n        assert (\n            OriginalC.__eq__.__code__.co_filename\n            == \"<attrs generated eq tests.test_dunders.C>\"\n        )\n        assert (\n            OriginalC.__hash__.__code__.co_filename\n            == \"<attrs generated hash tests.test_dunders.C>\"\n        )\n        assert (\n            CopyC.__init__.__code__.co_filename\n            == \"<attrs generated init tests.test_dunders.C>\"\n        )\n        assert (\n            CopyC.__eq__.__code__.co_filename\n            == \"<attrs generated eq tests.test_dunders.C>\"\n        )\n        assert (\n            CopyC.__hash__.__code__.co_filename\n            == \"<attrs generated hash tests.test_dunders.C>\"\n        )\n        assert (\n            C.__init__.__code__.co_filename\n            == \"<attrs generated init tests.test_dunders.C-1>\"\n        )\n        assert (\n            C.__eq__.__code__.co_filename\n            == \"<attrs generated eq tests.test_dunders.C-1>\"\n        )\n        assert (\n            C.__hash__.__code__.co_filename\n            == \"<attrs generated hash tests.test_dunders.C-1>\"\n        )\n", "tests/test_hooks.py": "# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\n\nimport attr\n\n\nclass TestTransformHook:\n    \"\"\"\n    Tests for `attrs(tranform_value_serializer=func)`\n    \"\"\"\n\n    def test_hook_applied(self):\n        \"\"\"\n        The transform hook is applied to all attributes.  Types can be missing,\n        explicitly set, or annotated.\n        \"\"\"\n        results = []\n\n        def hook(cls, attribs):\n            attr.resolve_types(cls, attribs=attribs)\n            results[:] = [(a.name, a.type) for a in attribs]\n            return attribs\n\n        @attr.s(field_transformer=hook)\n        class C:\n            x = attr.ib()\n            y = attr.ib(type=int)\n            z: float = attr.ib()\n\n        assert results == [(\"x\", None), (\"y\", int), (\"z\", float)]\n\n    def test_hook_applied_auto_attrib(self):\n        \"\"\"\n        The transform hook is applied to all attributes and type annotations\n        are detected.\n        \"\"\"\n        results = []\n\n        def hook(cls, attribs):\n            attr.resolve_types(cls, attribs=attribs)\n            results[:] = [(a.name, a.type) for a in attribs]\n            return attribs\n\n        @attr.s(auto_attribs=True, field_transformer=hook)\n        class C:\n            x: int\n            y: str = attr.ib()\n\n        assert results == [(\"x\", int), (\"y\", str)]\n\n    def test_hook_applied_modify_attrib(self):\n        \"\"\"\n        The transform hook can modify attributes.\n        \"\"\"\n\n        def hook(cls, attribs):\n            attr.resolve_types(cls, attribs=attribs)\n            return [a.evolve(converter=a.type) for a in attribs]\n\n        @attr.s(auto_attribs=True, field_transformer=hook)\n        class C:\n            x: int = attr.ib(converter=int)\n            y: float\n\n        c = C(x=\"3\", y=\"3.14\")\n        assert c == C(x=3, y=3.14)\n\n    def test_hook_remove_field(self):\n        \"\"\"\n        It is possible to remove fields via the hook.\n        \"\"\"\n\n        def hook(cls, attribs):\n            attr.resolve_types(cls, attribs=attribs)\n            return [a for a in attribs if a.type is not int]\n\n        @attr.s(auto_attribs=True, field_transformer=hook)\n        class C:\n            x: int\n            y: float\n\n        assert attr.asdict(C(2.7)) == {\"y\": 2.7}\n\n    def test_hook_add_field(self):\n        \"\"\"\n        It is possible to add fields via the hook.\n        \"\"\"\n\n        def hook(cls, attribs):\n            a1 = attribs[0]\n            a2 = a1.evolve(name=\"new\")\n            return [a1, a2]\n\n        @attr.s(auto_attribs=True, field_transformer=hook)\n        class C:\n            x: int\n\n        assert attr.asdict(C(1, 2)) == {\"x\": 1, \"new\": 2}\n\n    def test_hook_override_alias(self):\n        \"\"\"\n        It is possible to set field alias via hook\n        \"\"\"\n\n        def use_dataclass_names(cls, attribs):\n            return [a.evolve(alias=a.name) for a in attribs]\n\n        @attr.s(auto_attribs=True, field_transformer=use_dataclass_names)\n        class NameCase:\n            public: int\n            _private: int\n            __dunder__: int\n\n        assert NameCase(public=1, _private=2, __dunder__=3) == NameCase(\n            1, 2, 3\n        )\n\n    def test_hook_with_inheritance(self):\n        \"\"\"\n        The hook receives all fields from base classes.\n        \"\"\"\n\n        def hook(cls, attribs):\n            assert [a.name for a in attribs] == [\"x\", \"y\"]\n            # Remove Base' \"x\"\n            return attribs[1:]\n\n        @attr.s(auto_attribs=True)\n        class Base:\n            x: int\n\n        @attr.s(auto_attribs=True, field_transformer=hook)\n        class Sub(Base):\n            y: int\n\n        assert attr.asdict(Sub(2)) == {\"y\": 2}\n\n    def test_attrs_attrclass(self):\n        \"\"\"\n        The list of attrs returned by a field_transformer is converted to\n        \"AttrsClass\" again.\n\n        Regression test for #821.\n        \"\"\"\n\n        @attr.s(auto_attribs=True, field_transformer=lambda c, a: list(a))\n        class C:\n            x: int\n\n        fields_type = type(attr.fields(C))\n        assert fields_type.__name__ == \"CAttributes\"\n        assert issubclass(fields_type, tuple)\n\n\nclass TestAsDictHook:\n    def test_asdict(self):\n        \"\"\"\n        asdict() calls the hooks in attrs classes and in other datastructures\n        like lists or dicts.\n        \"\"\"\n\n        def hook(inst, a, v):\n            if isinstance(v, datetime):\n                return v.isoformat()\n            return v\n\n        @attr.dataclass\n        class Child:\n            x: datetime\n            y: list[datetime]\n\n        @attr.dataclass\n        class Parent:\n            a: Child\n            b: list[Child]\n            c: dict[str, Child]\n            d: dict[str, datetime]\n\n        inst = Parent(\n            a=Child(1, [datetime(2020, 7, 1)]),\n            b=[Child(2, [datetime(2020, 7, 2)])],\n            c={\"spam\": Child(3, [datetime(2020, 7, 3)])},\n            d={\"eggs\": datetime(2020, 7, 4)},\n        )\n\n        result = attr.asdict(inst, value_serializer=hook)\n        assert result == {\n            \"a\": {\"x\": 1, \"y\": [\"2020-07-01T00:00:00\"]},\n            \"b\": [{\"x\": 2, \"y\": [\"2020-07-02T00:00:00\"]}],\n            \"c\": {\"spam\": {\"x\": 3, \"y\": [\"2020-07-03T00:00:00\"]}},\n            \"d\": {\"eggs\": \"2020-07-04T00:00:00\"},\n        }\n\n    def test_asdict_calls(self):\n        \"\"\"\n        The correct instances and attribute names are passed to the hook.\n        \"\"\"\n        calls = []\n\n        def hook(inst, a, v):\n            calls.append((inst, a.name if a else a, v))\n            return v\n\n        @attr.dataclass\n        class Child:\n            x: int\n\n        @attr.dataclass\n        class Parent:\n            a: Child\n            b: list[Child]\n            c: dict[str, Child]\n\n        inst = Parent(a=Child(1), b=[Child(2)], c={\"spam\": Child(3)})\n\n        attr.asdict(inst, value_serializer=hook)\n        assert calls == [\n            (inst, \"a\", inst.a),\n            (inst.a, \"x\", inst.a.x),\n            (inst, \"b\", inst.b),\n            (inst.b[0], \"x\", inst.b[0].x),\n            (inst, \"c\", inst.c),\n            (None, None, \"spam\"),\n            (inst.c[\"spam\"], \"x\", inst.c[\"spam\"].x),\n        ]\n", "tests/test_pattern_matching.py": "# SPDX-License-Identifier: MIT\n\n# Keep this file SHORT, until Black can handle it.\nimport pytest\n\nimport attr\n\n\nclass TestPatternMatching:\n    \"\"\"\n    Pattern matching syntax test cases.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"dec\", [attr.s, attr.define, attr.frozen])\n    def test_simple_match_case(self, dec):\n        \"\"\"\n        Simple match case statement works as expected with all class\n        decorators.\n        \"\"\"\n\n        @dec\n        class C:\n            a = attr.ib()\n\n        assert (\"a\",) == C.__match_args__\n\n        matched = False\n        c = C(a=1)\n        match c:\n            case C(a):\n                matched = True\n\n        assert matched\n        assert 1 == a\n\n    def test_explicit_match_args(self):\n        \"\"\"\n        Does not overwrite a manually set empty __match_args__.\n        \"\"\"\n\n        ma = ()\n\n        @attr.define\n        class C:\n            a = attr.field()\n            __match_args__ = ma\n\n        c = C(a=1)\n\n        msg = r\"C\\(\\) accepts 0 positional sub-patterns \\(1 given\\)\"\n        with pytest.raises(TypeError, match=msg):\n            match c:\n                case C(_):\n                    pass\n\n    def test_match_args_kw_only(self):\n        \"\"\"\n        kw_only classes don't generate __match_args__.\n        kw_only fields are not included in __match_args__.\n        \"\"\"\n\n        @attr.define\n        class C:\n            a = attr.field(kw_only=True)\n            b = attr.field()\n\n        assert (\"b\",) == C.__match_args__\n\n        c = C(a=1, b=1)\n        msg = r\"C\\(\\) accepts 1 positional sub-pattern \\(2 given\\)\"\n        with pytest.raises(TypeError, match=msg):\n            match c:\n                case C(a, b):\n                    pass\n\n        found = False\n        match c:\n            case C(b, a=a):\n                found = True\n\n        assert found\n\n        @attr.define(kw_only=True)\n        class C:\n            a = attr.field()\n            b = attr.field()\n\n        c = C(a=1, b=1)\n        msg = r\"C\\(\\) accepts 0 positional sub-patterns \\(2 given\\)\"\n        with pytest.raises(TypeError, match=msg):\n            match c:\n                case C(a, b):\n                    pass\n\n        found = False\n        match c:\n            case C(a=a, b=b):\n                found = True\n\n        assert found\n        assert (1, 1) == (a, b)\n", "tests/test_init_subclass.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `__init_subclass__` related functionality.\n\"\"\"\n\nimport attr\n\n\ndef test_init_subclass_vanilla(slots):\n    \"\"\"\n    `super().__init_subclass__` can be used if the subclass is not an attrs\n    class both with dict and slotted classes.\n    \"\"\"\n\n    @attr.s(slots=slots)\n    class Base:\n        def __init_subclass__(cls, param, **kw):\n            super().__init_subclass__(**kw)\n            cls.param = param\n\n    class Vanilla(Base, param=\"foo\"):\n        pass\n\n    assert \"foo\" == Vanilla().param\n\n\ndef test_init_subclass_attrs():\n    \"\"\"\n    `__init_subclass__` works with attrs classes as long as slots=False.\n    \"\"\"\n\n    @attr.s(slots=False)\n    class Base:\n        def __init_subclass__(cls, param, **kw):\n            super().__init_subclass__(**kw)\n            cls.param = param\n\n    @attr.s\n    class Attrs(Base, param=\"foo\"):\n        pass\n\n    assert \"foo\" == Attrs().param\n\n\ndef test_init_subclass_slots_workaround():\n    \"\"\"\n    `__init_subclass__` works with modern APIs if care is taken around classes\n    existing twice.\n    \"\"\"\n    subs = {}\n\n    @attr.define\n    class Base:\n        def __init_subclass__(cls):\n            subs[cls.__qualname__] = cls\n\n    @attr.define\n    class Sub1(Base):\n        x: int\n\n    @attr.define\n    class Sub2(Base):\n        y: int\n\n    assert (Sub1, Sub2) == tuple(subs.values())\n", "tests/test_slots.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nUnit tests for slots-related functionality.\n\"\"\"\nimport functools\nimport pickle\nimport weakref\n\nfrom unittest import mock\n\nimport pytest\n\nimport attr\nimport attrs\n\nfrom attr._compat import PY_3_8_PLUS, PYPY\n\n\n# Pympler doesn't work on PyPy.\ntry:\n    from pympler.asizeof import asizeof\n\n    has_pympler = True\nexcept BaseException:  # Won't be an import error.  # noqa: BLE001\n    has_pympler = False\n\n\n@attr.s\nclass C1:\n    x = attr.ib(validator=attr.validators.instance_of(int))\n    y = attr.ib()\n\n    def method(self):\n        return self.x\n\n    @classmethod\n    def classmethod(cls):\n        return \"clsmethod\"\n\n    @staticmethod\n    def staticmethod():\n        return \"staticmethod\"\n\n    def my_class(self):\n        return __class__\n\n    def my_super(self):\n        \"\"\"Just to test out the no-arg super.\"\"\"\n        return super().__repr__()\n\n\n@attr.s(slots=True, hash=True)\nclass C1Slots:\n    x = attr.ib(validator=attr.validators.instance_of(int))\n    y = attr.ib()\n\n    def method(self):\n        return self.x\n\n    @classmethod\n    def classmethod(cls):\n        return \"clsmethod\"\n\n    @staticmethod\n    def staticmethod():\n        return \"staticmethod\"\n\n    def my_class(self):\n        return __class__\n\n    def my_super(self):\n        \"\"\"Just to test out the no-arg super.\"\"\"\n        return super().__repr__()\n\n\ndef test_slots_being_used():\n    \"\"\"\n    The class is really using __slots__.\n    \"\"\"\n    non_slot_instance = C1(x=1, y=\"test\")\n    slot_instance = C1Slots(x=1, y=\"test\")\n\n    assert \"__dict__\" not in dir(slot_instance)\n    assert \"__slots__\" in dir(slot_instance)\n\n    assert \"__dict__\" in dir(non_slot_instance)\n    assert \"__slots__\" not in dir(non_slot_instance)\n\n    assert {\"__weakref__\", \"x\", \"y\"} == set(slot_instance.__slots__)\n\n    if has_pympler:\n        assert asizeof(slot_instance) < asizeof(non_slot_instance)\n\n    non_slot_instance.t = \"test\"\n    with pytest.raises(AttributeError):\n        slot_instance.t = \"test\"\n\n    assert 1 == non_slot_instance.method()\n    assert 1 == slot_instance.method()\n\n    assert attr.fields(C1Slots) == attr.fields(C1)\n    assert attr.asdict(slot_instance) == attr.asdict(non_slot_instance)\n\n\ndef test_basic_attr_funcs():\n    \"\"\"\n    Comparison, `__eq__`, `__hash__`, `__repr__`, `attrs.asdict` work.\n    \"\"\"\n    a = C1Slots(x=1, y=2)\n    b = C1Slots(x=1, y=3)\n    a_ = C1Slots(x=1, y=2)\n\n    # Comparison.\n    assert b > a\n\n    assert a_ == a\n\n    # Hashing.\n    hash(b)  # Just to assert it doesn't raise.\n\n    # Repr.\n    assert \"C1Slots(x=1, y=2)\" == repr(a)\n\n    assert {\"x\": 1, \"y\": 2} == attr.asdict(a)\n\n\ndef test_inheritance_from_nonslots():\n    \"\"\"\n    Inheritance from a non-slotted class works.\n\n    Note that a slotted class inheriting from an ordinary class loses most of\n    the benefits of slotted classes, but it should still work.\n    \"\"\"\n\n    @attr.s(slots=True, hash=True)\n    class C2Slots(C1):\n        z = attr.ib()\n\n    c2 = C2Slots(x=1, y=2, z=\"test\")\n\n    assert 1 == c2.x\n    assert 2 == c2.y\n    assert \"test\" == c2.z\n\n    c2.t = \"test\"  # This will work, using the base class.\n\n    assert \"test\" == c2.t\n\n    assert 1 == c2.method()\n    assert \"clsmethod\" == c2.classmethod()\n    assert \"staticmethod\" == c2.staticmethod()\n\n    assert {\"z\"} == set(C2Slots.__slots__)\n\n    c3 = C2Slots(x=1, y=3, z=\"test\")\n\n    assert c3 > c2\n\n    c2_ = C2Slots(x=1, y=2, z=\"test\")\n\n    assert c2 == c2_\n\n    assert \"C2Slots(x=1, y=2, z='test')\" == repr(c2)\n\n    hash(c2)  # Just to assert it doesn't raise.\n\n    assert {\"x\": 1, \"y\": 2, \"z\": \"test\"} == attr.asdict(c2)\n\n\ndef test_nonslots_these():\n    \"\"\"\n    Enhancing a dict class using 'these' works.\n\n    This will actually *replace* the class with another one, using slots.\n    \"\"\"\n\n    class SimpleOrdinaryClass:\n        def __init__(self, x, y, z):\n            self.x = x\n            self.y = y\n            self.z = z\n\n        def method(self):\n            return self.x\n\n        @classmethod\n        def classmethod(cls):\n            return \"clsmethod\"\n\n        @staticmethod\n        def staticmethod():\n            return \"staticmethod\"\n\n    C2Slots = attr.s(\n        these={\"x\": attr.ib(), \"y\": attr.ib(), \"z\": attr.ib()},\n        init=False,\n        slots=True,\n        hash=True,\n    )(SimpleOrdinaryClass)\n\n    c2 = C2Slots(x=1, y=2, z=\"test\")\n    assert 1 == c2.x\n    assert 2 == c2.y\n    assert \"test\" == c2.z\n    with pytest.raises(AttributeError):\n        c2.t = \"test\"  # We have slots now.\n\n    assert 1 == c2.method()\n    assert \"clsmethod\" == c2.classmethod()\n    assert \"staticmethod\" == c2.staticmethod()\n\n    assert {\"__weakref__\", \"x\", \"y\", \"z\"} == set(C2Slots.__slots__)\n\n    c3 = C2Slots(x=1, y=3, z=\"test\")\n    assert c3 > c2\n    c2_ = C2Slots(x=1, y=2, z=\"test\")\n    assert c2 == c2_\n\n    assert \"SimpleOrdinaryClass(x=1, y=2, z='test')\" == repr(c2)\n\n    hash(c2)  # Just to assert it doesn't raise.\n\n    assert {\"x\": 1, \"y\": 2, \"z\": \"test\"} == attr.asdict(c2)\n\n\ndef test_inheritance_from_slots():\n    \"\"\"\n    Inheriting from an attrs slotted class works.\n    \"\"\"\n\n    @attr.s(slots=True, hash=True)\n    class C2Slots(C1Slots):\n        z = attr.ib()\n\n    @attr.s(slots=True, hash=True)\n    class C2(C1):\n        z = attr.ib()\n\n    c2 = C2Slots(x=1, y=2, z=\"test\")\n    assert 1 == c2.x\n    assert 2 == c2.y\n    assert \"test\" == c2.z\n\n    assert {\"z\"} == set(C2Slots.__slots__)\n\n    assert 1 == c2.method()\n    assert \"clsmethod\" == c2.classmethod()\n    assert \"staticmethod\" == c2.staticmethod()\n\n    with pytest.raises(AttributeError):\n        c2.t = \"test\"\n\n    non_slot_instance = C2(x=1, y=2, z=\"test\")\n    if has_pympler:\n        assert asizeof(c2) < asizeof(non_slot_instance)\n\n    c3 = C2Slots(x=1, y=3, z=\"test\")\n    assert c3 > c2\n    c2_ = C2Slots(x=1, y=2, z=\"test\")\n    assert c2 == c2_\n\n    assert \"C2Slots(x=1, y=2, z='test')\" == repr(c2)\n\n    hash(c2)  # Just to assert it doesn't raise.\n\n    assert {\"x\": 1, \"y\": 2, \"z\": \"test\"} == attr.asdict(c2)\n\n\ndef test_inheritance_from_slots_with_attribute_override():\n    \"\"\"\n    Inheriting from a slotted class doesn't re-create existing slots\n    \"\"\"\n\n    class HasXSlot:\n        __slots__ = (\"x\",)\n\n    @attr.s(slots=True, hash=True)\n    class C2Slots(C1Slots):\n        # y re-defined here but it shouldn't get a slot\n        y = attr.ib()\n        z = attr.ib()\n\n    @attr.s(slots=True, hash=True)\n    class NonAttrsChild(HasXSlot):\n        # Parent class has slot for \"x\" already, so we skip it\n        x = attr.ib()\n        y = attr.ib()\n        z = attr.ib()\n\n    c2 = C2Slots(1, 2, \"test\")\n    assert 1 == c2.x\n    assert 2 == c2.y\n    assert \"test\" == c2.z\n\n    assert {\"z\"} == set(C2Slots.__slots__)\n\n    na = NonAttrsChild(1, 2, \"test\")\n    assert 1 == na.x\n    assert 2 == na.y\n    assert \"test\" == na.z\n\n    assert {\"__weakref__\", \"y\", \"z\"} == set(NonAttrsChild.__slots__)\n\n\ndef test_inherited_slot_reuses_slot_descriptor():\n    \"\"\"\n    We reuse slot descriptor for an attr.ib defined in a slotted attr.s\n    \"\"\"\n\n    class HasXSlot:\n        __slots__ = (\"x\",)\n\n    class OverridesX(HasXSlot):\n        @property\n        def x(self):\n            return None\n\n    @attr.s(slots=True)\n    class Child(OverridesX):\n        x = attr.ib()\n\n    assert Child.x is not OverridesX.x\n    assert Child.x is HasXSlot.x\n\n    c = Child(1)\n    assert 1 == c.x\n    assert set() == set(Child.__slots__)\n\n    ox = OverridesX()\n    assert ox.x is None\n\n\ndef test_bare_inheritance_from_slots():\n    \"\"\"\n    Inheriting from a bare attrs slotted class works.\n    \"\"\"\n\n    @attr.s(\n        init=False, eq=False, order=False, hash=False, repr=False, slots=True\n    )\n    class C1BareSlots:\n        x = attr.ib(validator=attr.validators.instance_of(int))\n        y = attr.ib()\n\n        def method(self):\n            return self.x\n\n        @classmethod\n        def classmethod(cls):\n            return \"clsmethod\"\n\n        @staticmethod\n        def staticmethod():\n            return \"staticmethod\"\n\n    @attr.s(init=False, eq=False, order=False, hash=False, repr=False)\n    class C1Bare:\n        x = attr.ib(validator=attr.validators.instance_of(int))\n        y = attr.ib()\n\n        def method(self):\n            return self.x\n\n        @classmethod\n        def classmethod(cls):\n            return \"clsmethod\"\n\n        @staticmethod\n        def staticmethod():\n            return \"staticmethod\"\n\n    @attr.s(slots=True, hash=True)\n    class C2Slots(C1BareSlots):\n        z = attr.ib()\n\n    @attr.s(slots=True, hash=True)\n    class C2(C1Bare):\n        z = attr.ib()\n\n    c2 = C2Slots(x=1, y=2, z=\"test\")\n    assert 1 == c2.x\n    assert 2 == c2.y\n    assert \"test\" == c2.z\n\n    assert 1 == c2.method()\n    assert \"clsmethod\" == c2.classmethod()\n    assert \"staticmethod\" == c2.staticmethod()\n\n    with pytest.raises(AttributeError):\n        c2.t = \"test\"\n\n    non_slot_instance = C2(x=1, y=2, z=\"test\")\n    if has_pympler:\n        assert asizeof(c2) < asizeof(non_slot_instance)\n\n    c3 = C2Slots(x=1, y=3, z=\"test\")\n    assert c3 > c2\n    c2_ = C2Slots(x=1, y=2, z=\"test\")\n    assert c2 == c2_\n\n    assert \"C2Slots(x=1, y=2, z='test')\" == repr(c2)\n\n    hash(c2)  # Just to assert it doesn't raise.\n\n    assert {\"x\": 1, \"y\": 2, \"z\": \"test\"} == attr.asdict(c2)\n\n\nclass TestClosureCellRewriting:\n    def test_closure_cell_rewriting(self):\n        \"\"\"\n        Slotted classes support proper closure cell rewriting.\n\n        This affects features like `__class__` and the no-arg super().\n        \"\"\"\n        non_slot_instance = C1(x=1, y=\"test\")\n        slot_instance = C1Slots(x=1, y=\"test\")\n\n        assert non_slot_instance.my_class() is C1\n        assert slot_instance.my_class() is C1Slots\n\n        # Just assert they return something, and not an exception.\n        assert non_slot_instance.my_super()\n        assert slot_instance.my_super()\n\n    def test_inheritance(self):\n        \"\"\"\n        Slotted classes support proper closure cell rewriting when inheriting.\n\n        This affects features like `__class__` and the no-arg super().\n        \"\"\"\n\n        @attr.s\n        class C2(C1):\n            def my_subclass(self):\n                return __class__\n\n        @attr.s\n        class C2Slots(C1Slots):\n            def my_subclass(self):\n                return __class__\n\n        non_slot_instance = C2(x=1, y=\"test\")\n        slot_instance = C2Slots(x=1, y=\"test\")\n\n        assert non_slot_instance.my_class() is C1\n        assert slot_instance.my_class() is C1Slots\n\n        # Just assert they return something, and not an exception.\n        assert non_slot_instance.my_super()\n        assert slot_instance.my_super()\n\n        assert non_slot_instance.my_subclass() is C2\n        assert slot_instance.my_subclass() is C2Slots\n\n    def test_cls_static(self, slots):\n        \"\"\"\n        Slotted classes support proper closure cell rewriting for class- and\n        static methods.\n        \"\"\"\n        # Python can reuse closure cells, so we create new classes just for\n        # this test.\n\n        @attr.s(slots=slots)\n        class C:\n            @classmethod\n            def clsmethod(cls):\n                return __class__\n\n        assert C.clsmethod() is C\n\n        @attr.s(slots=slots)\n        class D:\n            @staticmethod\n            def statmethod():\n                return __class__\n\n        assert D.statmethod() is D\n\n\n@pytest.mark.skipif(PYPY, reason=\"__slots__ only block weakref on CPython\")\ndef test_not_weakrefable():\n    \"\"\"\n    Instance is not weak-referenceable when `weakref_slot=False` in CPython.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=False)\n    class C:\n        pass\n\n    c = C()\n\n    with pytest.raises(TypeError):\n        weakref.ref(c)\n\n\n@pytest.mark.skipif(\n    not PYPY, reason=\"slots without weakref_slot should only work on PyPy\"\n)\ndef test_implicitly_weakrefable():\n    \"\"\"\n    Instance is weak-referenceable even when `weakref_slot=False` in PyPy.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=False)\n    class C:\n        pass\n\n    c = C()\n    w = weakref.ref(c)\n\n    assert c is w()\n\n\ndef test_weakrefable():\n    \"\"\"\n    Instance is weak-referenceable when `weakref_slot=True`.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=True)\n    class C:\n        pass\n\n    c = C()\n    w = weakref.ref(c)\n\n    assert c is w()\n\n\ndef test_weakref_does_not_add_a_field():\n    \"\"\"\n    `weakref_slot=True` does not add a field to the class.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=True)\n    class C:\n        field = attr.ib()\n\n    assert [f.name for f in attr.fields(C)] == [\"field\"]\n\n\ndef tests_weakref_does_not_add_when_inheriting_with_weakref():\n    \"\"\"\n    `weakref_slot=True` does not add a new __weakref__ slot when inheriting\n    one.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=True)\n    class C:\n        pass\n\n    @attr.s(slots=True, weakref_slot=True)\n    class D(C):\n        pass\n\n    d = D()\n    w = weakref.ref(d)\n\n    assert d is w()\n\n\ndef tests_weakref_does_not_add_with_weakref_attribute():\n    \"\"\"\n    `weakref_slot=True` does not add a new __weakref__ slot when an attribute\n    of that name exists.\n    \"\"\"\n\n    @attr.s(slots=True, weakref_slot=True)\n    class C:\n        __weakref__ = attr.ib(\n            init=False, hash=False, repr=False, eq=False, order=False\n        )\n\n    c = C()\n    w = weakref.ref(c)\n\n    assert c is w()\n\n\ndef test_slots_empty_cell():\n    \"\"\"\n    Tests that no `ValueError: Cell is empty` exception is raised when\n    closure cells are present with no contents in a `slots=True` class.\n    (issue https://github.com/python-attrs/attrs/issues/589)\n\n    If a method mentions `__class__` or uses the no-arg `super()`, the compiler\n    will bake a reference to the class in the method itself as\n    `method.__closure__`. Since `attrs` replaces the class with a clone,\n    `_ClassBuilder._create_slots_class(self)` will rewrite these references so\n    it keeps working. This method was not properly covering the edge case where\n    the closure cell was empty, we fixed it and this is the non-regression\n    test.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class C:\n        field = attr.ib()\n\n        def f(self, a):\n            super(C, self).__init__()  # noqa: UP008\n\n    C(field=1)\n\n\n@attr.s(getstate_setstate=True)\nclass C2:\n    x = attr.ib()\n\n\n@attr.s(slots=True, getstate_setstate=True)\nclass C2Slots:\n    x = attr.ib()\n\n\nclass TestPickle:\n    @pytest.mark.parametrize(\"protocol\", range(pickle.HIGHEST_PROTOCOL))\n    def test_pickleable_by_default(self, protocol):\n        \"\"\"\n        If nothing else is passed, slotted classes can be pickled and\n        unpickled with all supported protocols.\n        \"\"\"\n        i1 = C1Slots(1, 2)\n        i2 = pickle.loads(pickle.dumps(i1, protocol))\n\n        assert i1 == i2\n        assert i1 is not i2\n\n    def test_no_getstate_setstate_for_dict_classes(self):\n        \"\"\"\n        As long as getstate_setstate is None, nothing is done to dict\n        classes.\n        \"\"\"\n        assert getattr(object, \"__getstate__\", None) is getattr(\n            C1, \"__getstate__\", None\n        )\n        assert getattr(object, \"__setstate__\", None) is getattr(\n            C1, \"__setstate__\", None\n        )\n\n    def test_no_getstate_setstate_if_option_false(self):\n        \"\"\"\n        Don't add getstate/setstate if getstate_setstate is False.\n        \"\"\"\n\n        @attr.s(slots=True, getstate_setstate=False)\n        class C:\n            x = attr.ib()\n\n        assert getattr(object, \"__getstate__\", None) is getattr(\n            C, \"__getstate__\", None\n        )\n        assert getattr(object, \"__setstate__\", None) is getattr(\n            C, \"__setstate__\", None\n        )\n\n    @pytest.mark.parametrize(\"cls\", [C2(1), C2Slots(1)])\n    def test_getstate_set_state_force_true(self, cls):\n        \"\"\"\n        If getstate_setstate is True, add them unconditionally.\n        \"\"\"\n        assert None is not getattr(cls, \"__getstate__\", None)\n        assert None is not getattr(cls, \"__setstate__\", None)\n\n\ndef test_slots_super_property_get():\n    \"\"\"\n    Both `super()` and `super(self.__class__, self)` work.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=True)\n    class B(A):\n        @property\n        def f(self):\n            return super().f ** 2\n\n    @attr.s(slots=True)\n    class C(A):\n        @property\n        def f(self):\n            return super(C, self).f ** 2  # noqa: UP008\n\n    assert B(11).f == 121\n    assert B(17).f == 289\n    assert C(11).f == 121\n    assert C(17).f == 289\n\n\ndef test_slots_super_property_get_shortcut():\n    \"\"\"\n    The `super()` shortcut is allowed.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=True)\n    class B(A):\n        @property\n        def f(self):\n            return super().f ** 2\n\n    assert B(11).f == 121\n    assert B(17).f == 289\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_allows_call():\n    \"\"\"\n    cached_property in slotted class allows call.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    assert A(11).f == 11\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_class_does_not_have__dict__():\n    \"\"\"\n    slotted class with cached property has no __dict__ attribute.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    assert set(A.__slots__) == {\"x\", \"f\", \"__weakref__\"}\n    assert \"__dict__\" not in dir(A)\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_works_on_frozen_isntances():\n    \"\"\"\n    Infers type of cached property.\n    \"\"\"\n\n    @attrs.frozen(slots=True)\n    class A:\n        x: int\n\n        @functools.cached_property\n        def f(self) -> int:\n            return self.x\n\n    assert A(x=1).f == 1\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_infers_type():\n    \"\"\"\n    Infers type of cached property.\n    \"\"\"\n\n    @attrs.frozen(slots=True)\n    class A:\n        x: int\n\n        @functools.cached_property\n        def f(self) -> int:\n            return self.x\n\n    assert A.__annotations__ == {\"x\": int, \"f\": int}\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_with_empty_getattr_raises_attribute_error_of_requested():\n    \"\"\"\n    Ensures error information is not lost.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    a = A(1)\n    with pytest.raises(\n        AttributeError, match=\"'A' object has no attribute 'z'\"\n    ):\n        a.z\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_raising_attributeerror():\n    \"\"\"\n    Ensures AttributeError raised by a property is preserved by __getattr__()\n    implementation.\n\n    Regression test for issue https://github.com/python-attrs/attrs/issues/1230\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.p\n\n        @property\n        def p(self):\n            raise AttributeError(\"I am a property\")\n\n        @functools.cached_property\n        def g(self):\n            return self.q\n\n        @property\n        def q(self):\n            return 2\n\n    a = A(1)\n    with pytest.raises(AttributeError, match=r\"^I am a property$\"):\n        a.p\n    with pytest.raises(AttributeError, match=r\"^I am a property$\"):\n        a.f\n\n    assert a.g == 2\n    assert a.q == 2\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_with_getattr_calls_getattr_for_missing_attributes():\n    \"\"\"\n    Ensure __getattr__ implementation is maintained for non cached_properties.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n        def __getattr__(self, item):\n            return item\n\n    a = A(1)\n    assert a.f == 1\n    assert a.z == \"z\"\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_getattr_in_superclass__is_called_for_missing_attributes_when_cached_property_present():\n    \"\"\"\n    Ensure __getattr__ implementation is maintained in subclass.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        def __getattr__(self, item):\n            return item\n\n    @attr.s(slots=True)\n    class B(A):\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    b = B(1)\n    assert b.f == 1\n    assert b.z == \"z\"\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_getattr_in_subclass_gets_superclass_cached_property():\n    \"\"\"\n    Ensure super() in __getattr__ is not broken through cached_property re-write.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n        def __getattr__(self, item):\n            return item\n\n    @attr.s(slots=True)\n    class B(A):\n        @functools.cached_property\n        def g(self):\n            return self.x\n\n        def __getattr__(self, item):\n            return super().__getattr__(item)\n\n    b = B(1)\n    assert b.f == 1\n    assert b.z == \"z\"\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_sub_class_with_independent_cached_properties_both_work():\n    \"\"\"\n    Subclassing shouldn't break cached properties.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=True)\n    class B(A):\n        @functools.cached_property\n        def g(self):\n            return self.x * 2\n\n    assert B(1).f == 1\n    assert B(1).g == 2\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_with_multiple_cached_property_subclasses_works():\n    \"\"\"\n    Multiple sub-classes shouldn't break cached properties.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib(kw_only=True)\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=False)\n    class B:\n        @functools.cached_property\n        def g(self):\n            return self.x * 2\n\n        def __getattr__(self, item):\n            if hasattr(super(), \"__getattr__\"):\n                return super().__getattr__(item)\n            return item\n\n    @attr.s(slots=True)\n    class AB(A, B):\n        pass\n\n    ab = AB(x=1)\n\n    assert ab.f == 1\n    assert ab.g == 2\n    assert ab.h == \"h\"\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slotted_cached_property_can_access_super():\n    \"\"\"\n    Multiple sub-classes shouldn't break cached properties.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib(kw_only=True)\n\n    @attr.s(slots=True)\n    class B(A):\n        @functools.cached_property\n        def f(self):\n            return super().x * 2\n\n    assert B(x=1).f == 2\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_sub_class_avoids_duplicated_slots():\n    \"\"\"\n    Duplicating the slots is a waste of memory.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=True)\n    class B(A):\n        @functools.cached_property\n        def f(self):\n            return self.x * 2\n\n    assert B(1).f == 2\n    assert B.__slots__ == ()\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_sub_class_with_actual_slot():\n    \"\"\"\n    A sub-class can have an explicit attrs field that replaces a cached property.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:  # slots : (x, f)\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    @attr.s(slots=True)\n    class B(A):\n        f: int = attr.ib()\n\n    assert B(1, 2).f == 2\n    assert B.__slots__ == ()\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_is_not_called_at_construction():\n    \"\"\"\n    A cached property function should only be called at property access point.\n    \"\"\"\n    call_count = 0\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            nonlocal call_count\n            call_count += 1\n            return self.x\n\n    A(1)\n    assert call_count == 0\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_repeat_call_only_once():\n    \"\"\"\n    A cached property function should be called only once, on repeated attribute access.\n    \"\"\"\n    call_count = 0\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            nonlocal call_count\n            call_count += 1\n            return self.x\n\n    obj = A(1)\n    obj.f\n    obj.f\n    assert call_count == 1\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_property_called_independent_across_instances():\n    \"\"\"\n    A cached property value should be specific to the given instance.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f(self):\n            return self.x\n\n    obj_1 = A(1)\n    obj_2 = A(2)\n\n    assert obj_1.f == 1\n    assert obj_2.f == 2\n\n\n@pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\ndef test_slots_cached_properties_work_independently():\n    \"\"\"\n    Multiple cached properties should work independently.\n    \"\"\"\n\n    @attr.s(slots=True)\n    class A:\n        x = attr.ib()\n\n        @functools.cached_property\n        def f_1(self):\n            return self.x\n\n        @functools.cached_property\n        def f_2(self):\n            return self.x * 2\n\n    obj = A(1)\n\n    assert obj.f_1 == 1\n    assert obj.f_2 == 2\n\n\n@attr.s(slots=True)\nclass A:\n    x = attr.ib()\n    b = attr.ib()\n    c = attr.ib()\n\n\ndef test_slots_unpickle_after_attr_removed():\n    \"\"\"\n    We don't assign attributes we don't have anymore if the class has\n    removed it.\n    \"\"\"\n    a = A(1, 2, 3)\n    a_pickled = pickle.dumps(a)\n    a_unpickled = pickle.loads(a_pickled)\n    assert a_unpickled == a\n\n    @attr.s(slots=True)\n    class NEW_A:\n        x = attr.ib()\n        c = attr.ib()\n\n    with mock.patch(f\"{__name__}.A\", NEW_A):\n        new_a = pickle.loads(a_pickled)\n\n        assert new_a.x == 1\n        assert new_a.c == 3\n        assert not hasattr(new_a, \"b\")\n\n\ndef test_slots_unpickle_after_attr_added(frozen):\n    \"\"\"\n    We don't assign attribute we haven't had before if the class has one added.\n    \"\"\"\n    a = A(1, 2, 3)\n    a_pickled = pickle.dumps(a)\n    a_unpickled = pickle.loads(a_pickled)\n\n    assert a_unpickled == a\n\n    @attr.s(slots=True, frozen=frozen)\n    class NEW_A:\n        x = attr.ib()\n        b = attr.ib()\n        d = attr.ib()\n        c = attr.ib()\n\n    with mock.patch(f\"{__name__}.A\", NEW_A):\n        new_a = pickle.loads(a_pickled)\n\n        assert new_a.x == 1\n        assert new_a.b == 2\n        assert new_a.c == 3\n        assert not hasattr(new_a, \"d\")\n\n\ndef test_slots_unpickle_is_backward_compatible(frozen):\n    \"\"\"\n    Ensure object pickled before v22.2.0 can still be unpickled.\n    \"\"\"\n    a = A(1, 2, 3)\n\n    a_pickled = (\n        b\"\\x80\\x04\\x95&\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x10\"\n        + a.__module__.encode()\n        + b\"\\x94\\x8c\\x01A\\x94\\x93\\x94)\\x81\\x94K\\x01K\\x02K\\x03\\x87\\x94b.\"\n    )\n\n    a_unpickled = pickle.loads(a_pickled)\n\n    assert a_unpickled == a\n", "tests/test_cmp.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for methods from `attrib._cmp`.\n\"\"\"\n\nimport pytest\n\nfrom attr._cmp import cmp_using\nfrom attr._compat import PY_3_13_PLUS\n\n\n# Test parameters.\nEqCSameType = cmp_using(eq=lambda a, b: a == b, class_name=\"EqCSameType\")\nPartialOrderCSameType = cmp_using(\n    eq=lambda a, b: a == b,\n    lt=lambda a, b: a < b,\n    class_name=\"PartialOrderCSameType\",\n)\nFullOrderCSameType = cmp_using(\n    eq=lambda a, b: a == b,\n    lt=lambda a, b: a < b,\n    le=lambda a, b: a <= b,\n    gt=lambda a, b: a > b,\n    ge=lambda a, b: a >= b,\n    class_name=\"FullOrderCSameType\",\n)\n\nEqCAnyType = cmp_using(\n    eq=lambda a, b: a == b, require_same_type=False, class_name=\"EqCAnyType\"\n)\nPartialOrderCAnyType = cmp_using(\n    eq=lambda a, b: a == b,\n    lt=lambda a, b: a < b,\n    require_same_type=False,\n    class_name=\"PartialOrderCAnyType\",\n)\n\n\neq_data = [\n    (EqCSameType, True),\n    (EqCAnyType, False),\n]\n\norder_data = [\n    (PartialOrderCSameType, True),\n    (PartialOrderCAnyType, False),\n    (FullOrderCSameType, True),\n]\n\neq_ids = [c[0].__name__ for c in eq_data]\norder_ids = [c[0].__name__ for c in order_data]\n\ncmp_data = eq_data + order_data\ncmp_ids = eq_ids + order_ids\n\n# Compiler strips indents from docstrings in Python 3.13+\nindent = \"\" if PY_3_13_PLUS else \" \" * 8\n\n\nclass TestEqOrder:\n    \"\"\"\n    Tests for eq and order related methods.\n    \"\"\"\n\n    #########\n    # eq\n    #########\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), cmp_data, ids=cmp_ids\n    )\n    def test_equal_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Equal objects are detected as equal.\n        \"\"\"\n        assert cls(1) == cls(1)\n        assert not (cls(1) != cls(1))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), cmp_data, ids=cmp_ids\n    )\n    def test_unequal_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Unequal objects of correct type are detected as unequal.\n        \"\"\"\n        assert cls(1) != cls(2)\n        assert not (cls(1) == cls(2))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), cmp_data, ids=cmp_ids\n    )\n    def test_equal_different_type(self, cls, requires_same_type):\n        \"\"\"\n        Equal values of different types are detected appropriately.\n        \"\"\"\n        assert (cls(1) == cls(1.0)) == (not requires_same_type)\n        assert not (cls(1) != cls(1.0)) == (not requires_same_type)\n\n    #########\n    # lt\n    #########\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), eq_data, ids=eq_ids\n    )\n    def test_lt_unorderable(self, cls, requires_same_type):\n        \"\"\"\n        TypeError is raised if class does not implement __lt__.\n        \"\"\"\n        with pytest.raises(TypeError):\n            cls(1) < cls(2)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_lt_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Less-than objects are detected appropriately.\n        \"\"\"\n        assert cls(1) < cls(2)\n        assert not (cls(2) < cls(1))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_not_lt_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Not less-than objects are detected appropriately.\n        \"\"\"\n        assert cls(2) >= cls(1)\n        assert not (cls(1) >= cls(2))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_lt_different_type(self, cls, requires_same_type):\n        \"\"\"\n        Less-than values of different types are detected appropriately.\n        \"\"\"\n        if requires_same_type:\n            # Unlike __eq__, NotImplemented will cause an exception to be\n            # raised from __lt__.\n            with pytest.raises(TypeError):\n                cls(1) < cls(2.0)\n        else:\n            assert cls(1) < cls(2.0)\n            assert not (cls(2) < cls(1.0))\n\n    #########\n    # le\n    #########\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), eq_data, ids=eq_ids\n    )\n    def test_le_unorderable(self, cls, requires_same_type):\n        \"\"\"\n        TypeError is raised if class does not implement __le__.\n        \"\"\"\n        with pytest.raises(TypeError):\n            cls(1) <= cls(2)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_le_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Less-than-or-equal objects are detected appropriately.\n        \"\"\"\n        assert cls(1) <= cls(1)\n        assert cls(1) <= cls(2)\n        assert not (cls(2) <= cls(1))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_not_le_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Not less-than-or-equal objects are detected appropriately.\n        \"\"\"\n        assert cls(2) > cls(1)\n        assert not (cls(1) > cls(1))\n        assert not (cls(1) > cls(2))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_le_different_type(self, cls, requires_same_type):\n        \"\"\"\n        Less-than-or-equal values of diff. types are detected appropriately.\n        \"\"\"\n        if requires_same_type:\n            # Unlike __eq__, NotImplemented will cause an exception to be\n            # raised from __le__.\n            with pytest.raises(TypeError):\n                cls(1) <= cls(2.0)\n        else:\n            assert cls(1) <= cls(2.0)\n            assert cls(1) <= cls(1.0)\n            assert not (cls(2) <= cls(1.0))\n\n    #########\n    # gt\n    #########\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), eq_data, ids=eq_ids\n    )\n    def test_gt_unorderable(self, cls, requires_same_type):\n        \"\"\"\n        TypeError is raised if class does not implement __gt__.\n        \"\"\"\n        with pytest.raises(TypeError):\n            cls(2) > cls(1)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_gt_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Greater-than objects are detected appropriately.\n        \"\"\"\n        assert cls(2) > cls(1)\n        assert not (cls(1) > cls(2))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_not_gt_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Not greater-than objects are detected appropriately.\n        \"\"\"\n        assert cls(1) <= cls(2)\n        assert not (cls(2) <= cls(1))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_gt_different_type(self, cls, requires_same_type):\n        \"\"\"\n        Greater-than values of different types are detected appropriately.\n        \"\"\"\n        if requires_same_type:\n            # Unlike __eq__, NotImplemented will cause an exception to be\n            # raised from __gt__.\n            with pytest.raises(TypeError):\n                cls(2) > cls(1.0)\n        else:\n            assert cls(2) > cls(1.0)\n            assert not (cls(1) > cls(2.0))\n\n    #########\n    # ge\n    #########\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), eq_data, ids=eq_ids\n    )\n    def test_ge_unorderable(self, cls, requires_same_type):\n        \"\"\"\n        TypeError is raised if class does not implement __ge__.\n        \"\"\"\n        with pytest.raises(TypeError):\n            cls(2) >= cls(1)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_ge_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Greater-than-or-equal objects are detected appropriately.\n        \"\"\"\n        assert cls(1) >= cls(1)\n        assert cls(2) >= cls(1)\n        assert not (cls(1) >= cls(2))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_not_ge_same_type(self, cls, requires_same_type):\n        \"\"\"\n        Not greater-than-or-equal objects are detected appropriately.\n        \"\"\"\n        assert cls(1) < cls(2)\n        assert not (cls(1) < cls(1))\n        assert not (cls(2) < cls(1))\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"requires_same_type\"), order_data, ids=order_ids\n    )\n    def test_ge_different_type(self, cls, requires_same_type):\n        \"\"\"\n        Greater-than-or-equal values of diff. types are detected appropriately.\n        \"\"\"\n        if requires_same_type:\n            # Unlike __eq__, NotImplemented will cause an exception to be\n            # raised from __ge__.\n            with pytest.raises(TypeError):\n                cls(2) >= cls(1.0)\n        else:\n            assert cls(2) >= cls(2.0)\n            assert cls(2) >= cls(1.0)\n            assert not (cls(1) >= cls(2.0))\n\n\nclass TestDundersUnnamedClass:\n    \"\"\"\n    Tests for dunder attributes of unnamed classes.\n    \"\"\"\n\n    cls = cmp_using(eq=lambda a, b: a == b)\n\n    def test_class(self):\n        \"\"\"\n        Class name and qualified name should be well behaved.\n        \"\"\"\n        assert self.cls.__name__ == \"Comparable\"\n        assert self.cls.__qualname__ == \"Comparable\"\n\n    def test_eq(self):\n        \"\"\"\n        __eq__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__eq__\n        assert method.__doc__.strip() == \"Return a == b.  Computed by attrs.\"\n        assert method.__name__ == \"__eq__\"\n\n    def test_ne(self):\n        \"\"\"\n        __ne__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__ne__\n        assert method.__doc__.strip() == (\n            \"Check equality and either forward a NotImplemented or\\n\"\n            f\"{indent}return the result negated.\"\n        )\n        assert method.__name__ == \"__ne__\"\n\n\nclass TestTotalOrderingException:\n    \"\"\"\n    Test for exceptions related to total ordering.\n    \"\"\"\n\n    def test_eq_must_specified(self):\n        \"\"\"\n        `total_ordering` requires `__eq__` to be specified.\n        \"\"\"\n        with pytest.raises(ValueError) as ei:\n            cmp_using(lt=lambda a, b: a < b)\n\n        assert ei.value.args[0] == (\n            \"eq must be define is order to complete ordering from \"\n            \"lt, le, gt, ge.\"\n        )\n\n\nclass TestNotImplementedIsPropagated:\n    \"\"\"\n    Test related to functions that return NotImplemented.\n    \"\"\"\n\n    def test_not_implemented_is_propagated(self):\n        \"\"\"\n        If the comparison function returns NotImplemented,\n        the dunder method should too.\n        \"\"\"\n        C = cmp_using(eq=lambda a, b: NotImplemented if a == 1 else a == b)\n\n        assert C(2) == C(2)\n        assert C(1) != C(1)\n\n\nclass TestDundersPartialOrdering:\n    \"\"\"\n    Tests for dunder attributes of classes with partial ordering.\n    \"\"\"\n\n    cls = PartialOrderCSameType\n\n    def test_class(self):\n        \"\"\"\n        Class name and qualified name should be well behaved.\n        \"\"\"\n        assert self.cls.__name__ == \"PartialOrderCSameType\"\n        assert self.cls.__qualname__ == \"PartialOrderCSameType\"\n\n    def test_eq(self):\n        \"\"\"\n        __eq__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__eq__\n        assert method.__doc__.strip() == \"Return a == b.  Computed by attrs.\"\n        assert method.__name__ == \"__eq__\"\n\n    def test_ne(self):\n        \"\"\"\n        __ne__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__ne__\n        assert method.__doc__.strip() == (\n            \"Check equality and either forward a NotImplemented or\\n\"\n            f\"{indent}return the result negated.\"\n        )\n        assert method.__name__ == \"__ne__\"\n\n    def test_lt(self):\n        \"\"\"\n        __lt__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__lt__\n        assert method.__doc__.strip() == \"Return a < b.  Computed by attrs.\"\n        assert method.__name__ == \"__lt__\"\n\n    def test_le(self):\n        \"\"\"\n        __le__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__le__\n        assert method.__doc__.strip().startswith(\n            \"Return a <= b.  Computed by @total_ordering from\"\n        )\n        assert method.__name__ == \"__le__\"\n\n    def test_gt(self):\n        \"\"\"\n        __gt__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__gt__\n        assert method.__doc__.strip().startswith(\n            \"Return a > b.  Computed by @total_ordering from\"\n        )\n        assert method.__name__ == \"__gt__\"\n\n    def test_ge(self):\n        \"\"\"\n        __ge__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__ge__\n        assert method.__doc__.strip().startswith(\n            \"Return a >= b.  Computed by @total_ordering from\"\n        )\n        assert method.__name__ == \"__ge__\"\n\n\nclass TestDundersFullOrdering:\n    \"\"\"\n    Tests for dunder attributes of classes with full ordering.\n    \"\"\"\n\n    cls = FullOrderCSameType\n\n    def test_class(self):\n        \"\"\"\n        Class name and qualified name should be well behaved.\n        \"\"\"\n        assert self.cls.__name__ == \"FullOrderCSameType\"\n        assert self.cls.__qualname__ == \"FullOrderCSameType\"\n\n    def test_eq(self):\n        \"\"\"\n        __eq__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__eq__\n        assert method.__doc__.strip() == \"Return a == b.  Computed by attrs.\"\n        assert method.__name__ == \"__eq__\"\n\n    def test_ne(self):\n        \"\"\"\n        __ne__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__ne__\n        assert method.__doc__.strip() == (\n            \"Check equality and either forward a NotImplemented or\\n\"\n            f\"{indent}return the result negated.\"\n        )\n        assert method.__name__ == \"__ne__\"\n\n    def test_lt(self):\n        \"\"\"\n        __lt__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__lt__\n        assert method.__doc__.strip() == \"Return a < b.  Computed by attrs.\"\n        assert method.__name__ == \"__lt__\"\n\n    def test_le(self):\n        \"\"\"\n        __le__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__le__\n        assert method.__doc__.strip() == \"Return a <= b.  Computed by attrs.\"\n        assert method.__name__ == \"__le__\"\n\n    def test_gt(self):\n        \"\"\"\n        __gt__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__gt__\n        assert method.__doc__.strip() == \"Return a > b.  Computed by attrs.\"\n        assert method.__name__ == \"__gt__\"\n\n    def test_ge(self):\n        \"\"\"\n        __ge__ docstring and qualified name should be well behaved.\n        \"\"\"\n        method = self.cls.__ge__\n        assert method.__doc__.strip() == \"Return a >= b.  Computed by attrs.\"\n        assert method.__name__ == \"__ge__\"\n", "tests/test_version_info.py": "# SPDX-License-Identifier: MIT\n\n\nimport pytest\n\nfrom attr import VersionInfo\n\n\n@pytest.fixture(name=\"vi\")\ndef fixture_vi():\n    return VersionInfo(19, 2, 0, \"final\")\n\n\nclass TestVersionInfo:\n    def test_from_string_no_releaselevel(self, vi):\n        \"\"\"\n        If there is no suffix, the releaselevel becomes \"final\" by default.\n        \"\"\"\n        assert vi == VersionInfo._from_version_string(\"19.2.0\")\n\n    def test_suffix_is_preserved(self):\n        \"\"\"\n        If there is a suffix, it's preserved.\n        \"\"\"\n        assert (\n            \"dev0\"\n            == VersionInfo._from_version_string(\"19.2.0.dev0\").releaselevel\n        )\n\n    @pytest.mark.parametrize(\"other\", [(), (19, 2, 0, \"final\", \"garbage\")])\n    def test_wrong_len(self, vi, other):\n        \"\"\"\n        Comparing with a tuple that has the wrong length raises an error.\n        \"\"\"\n        assert vi != other\n\n        with pytest.raises(TypeError):\n            vi < other\n\n    @pytest.mark.parametrize(\"other\", [[19, 2, 0, \"final\"]])\n    def test_wrong_type(self, vi, other):\n        \"\"\"\n        Only compare to other VersionInfos or tuples.\n        \"\"\"\n        assert vi != other\n\n    def test_order(self, vi):\n        \"\"\"\n        Ordering works as expected.\n        \"\"\"\n        assert vi < (20,)\n        assert vi < (19, 2, 1)\n        assert vi > (0,)\n        assert vi <= (19, 2)\n        assert vi >= (19, 2)\n        assert vi > (19, 2, 0, \"dev0\")\n        assert vi < (19, 2, 0, \"post1\")\n", "tests/__init__.py": "# SPDX-License-Identifier: MIT\n", "tests/attr_import_star.py": "# SPDX-License-Identifier: MIT\n\n\nfrom attr import *  # noqa: F403\n\n\n# This is imported by test_import::test_from_attr_import_star; this must\n# be done indirectly because importing * is only allowed on module level,\n# so can't be done inside a test.\n", "tests/typing_example.py": "# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nimport re\n\nfrom typing import Any, Dict, List, Tuple\n\nimport attr\nimport attrs\n\n\n# Typing via \"type\" Argument ---\n\n\n@attr.s\nclass C:\n    a = attr.ib(type=int)\n\n\nc = C(1)\nC(a=1)\n\n\n@attr.s\nclass D:\n    x = attr.ib(type=List[int])\n\n\n@attr.s\nclass E:\n    y = attr.ib(type=\"List[int]\")\n\n\n@attr.s\nclass F:\n    z = attr.ib(type=Any)\n\n\n# Typing via Annotations ---\n\n\n@attr.s\nclass CC:\n    a: int = attr.ib()\n\n\ncc = CC(1)\nCC(a=1)\n\n\n@attr.s\nclass DD:\n    x: list[int] = attr.ib()\n\n\n@attr.s\nclass EE:\n    y: \"list[int]\" = attr.ib()\n\n\n@attr.s\nclass FF:\n    z: Any = attr.ib()\n\n\n@attrs.define\nclass FFF:\n    z: int\n\n\nFFF(1)\n\n\n# Inheritance --\n\n\n@attr.s\nclass GG(DD):\n    y: str = attr.ib()\n\n\nGG(x=[1], y=\"foo\")\n\n\n@attr.s\nclass HH(DD, EE):\n    z: float = attr.ib()\n\n\nHH(x=[1], y=[], z=1.1)\n\n\n# same class\nc == cc\n\n\n# Exceptions\n@attr.s(auto_exc=True)\nclass Error(Exception):\n    x: int = attr.ib()\n\n\ntry:\n    raise Error(1)\nexcept Error as e:\n    e.x\n    e.args\n    str(e)\n\n\n@attrs.define\nclass Error2(Exception):\n    x: int\n\n\ntry:\n    raise Error2(1)\nexcept Error as e:\n    e.x\n    e.args\n    str(e)\n\n# Field aliases\n\n\n@attrs.define\nclass AliasExample:\n    without_alias: int\n    _with_alias: int = attr.ib(alias=\"_with_alias\")\n\n\nattr.fields(AliasExample).without_alias.alias\nattr.fields(AliasExample)._with_alias.alias\n\n# Converters\n# XXX: Currently converters can only be functions so none of this works\n# although the stubs should be correct.\n\n# @attr.s\n# class ConvCOptional:\n#     x: Optional[int] = attr.ib(converter=attr.converters.optional(int))\n\n\n# ConvCOptional(1)\n# ConvCOptional(None)\n\n\n# @attr.s\n# class ConvCDefaultIfNone:\n#     x: int = attr.ib(converter=attr.converters.default_if_none(42))\n\n\n# ConvCDefaultIfNone(1)\n# ConvCDefaultIfNone(None)\n\n\n# @attr.s\n# class ConvCToBool:\n#     x: int = attr.ib(converter=attr.converters.to_bool)\n\n\n# ConvCToBool(1)\n# ConvCToBool(True)\n# ConvCToBool(\"on\")\n# ConvCToBool(\"yes\")\n# ConvCToBool(0)\n# ConvCToBool(False)\n# ConvCToBool(\"n\")\n\n\n# Validators\n@attr.s\nclass Validated:\n    a = attr.ib(\n        type=List[C],\n        validator=attr.validators.deep_iterable(\n            attr.validators.instance_of(C), attr.validators.instance_of(list)\n        ),\n    )\n    aa = attr.ib(\n        type=Tuple[C],\n        validator=attr.validators.deep_iterable(\n            attr.validators.instance_of(C), attr.validators.instance_of(tuple)\n        ),\n    )\n    b = attr.ib(\n        type=List[C],\n        validator=attr.validators.deep_iterable(\n            attr.validators.instance_of(C)\n        ),\n    )\n    c = attr.ib(\n        type=Dict[C, D],\n        validator=attr.validators.deep_mapping(\n            attr.validators.instance_of(C),\n            attr.validators.instance_of(D),\n            attr.validators.instance_of(dict),\n        ),\n    )\n    d = attr.ib(\n        type=Dict[C, D],\n        validator=attr.validators.deep_mapping(\n            attr.validators.instance_of(C), attr.validators.instance_of(D)\n        ),\n    )\n    e: str = attr.ib(validator=attr.validators.matches_re(re.compile(r\"foo\")))\n    f: str = attr.ib(\n        validator=attr.validators.matches_re(r\"foo\", flags=42, func=re.search)\n    )\n\n    # Test different forms of instance_of\n    g: int = attr.ib(validator=attr.validators.instance_of(int))\n    h: int = attr.ib(validator=attr.validators.instance_of((int,)))\n    j: int | str = attr.ib(validator=attr.validators.instance_of((int, str)))\n    k: int | str | C = attr.ib(\n        validator=attrs.validators.instance_of((int, C, str))\n    )\n\n    l: Any = attr.ib(\n        validator=attr.validators.not_(attr.validators.in_(\"abc\"))\n    )\n    m: Any = attr.ib(\n        validator=attr.validators.not_(\n            attr.validators.in_(\"abc\"), exc_types=ValueError\n        )\n    )\n    n: Any = attr.ib(\n        validator=attr.validators.not_(\n            attr.validators.in_(\"abc\"), exc_types=(ValueError,)\n        )\n    )\n    o: Any = attr.ib(\n        validator=attr.validators.not_(attr.validators.in_(\"abc\"), msg=\"spam\")\n    )\n    p: Any = attr.ib(\n        validator=attr.validators.not_(attr.validators.in_(\"abc\"), msg=None)\n    )\n    q: Any = attr.ib(\n        validator=attrs.validators.optional(attrs.validators.instance_of(C))\n    )\n    r: Any = attr.ib(\n        validator=attrs.validators.optional([attrs.validators.instance_of(C)])\n    )\n    s: Any = attr.ib(\n        validator=attrs.validators.optional((attrs.validators.instance_of(C),))\n    )\n\n\n@attr.define\nclass Validated2:\n    num: int = attr.field(validator=attr.validators.ge(0))\n\n\n@attrs.define\nclass Validated3:\n    num: int = attr.field(validator=attr.validators.ge(0))\n\n\nwith attr.validators.disabled():\n    Validated2(num=-1)\n\nwith attrs.validators.disabled():\n    Validated3(num=-1)\n\ntry:\n    attr.validators.set_disabled(True)\n    Validated2(num=-1)\nfinally:\n    attr.validators.set_disabled(False)\n\n\n# Custom repr()\n@attr.s\nclass WithCustomRepr:\n    a: int = attr.ib(repr=True)\n    b: str = attr.ib(repr=False)\n    c: str = attr.ib(repr=lambda value: \"c is for cookie\")\n    d: bool = attr.ib(repr=str)\n\n\n@attrs.define\nclass WithCustomRepr2:\n    a: int = attrs.field(repr=True)\n    b: str = attrs.field(repr=False)\n    c: str = attrs.field(repr=lambda value: \"c is for cookie\")\n    d: bool = attrs.field(repr=str)\n\n\n# Check some of our own types\n@attr.s(eq=True, order=False)\nclass OrderFlags:\n    a: int = attr.ib(eq=False, order=False)\n    b: int = attr.ib(eq=True, order=True)\n\n\n# on_setattr hooks\n@attr.s(on_setattr=attr.setters.validate)\nclass ValidatedSetter:\n    a: int\n    b: str = attr.ib(on_setattr=attr.setters.NO_OP)\n    c: bool = attr.ib(on_setattr=attr.setters.frozen)\n    d: int = attr.ib(on_setattr=[attr.setters.convert, attr.setters.validate])\n    e: bool = attr.ib(\n        on_setattr=attr.setters.pipe(\n            attr.setters.convert, attr.setters.validate\n        )\n    )\n\n\n@attrs.define(on_setattr=attr.setters.validate)\nclass ValidatedSetter2:\n    a: int\n    b: str = attrs.field(on_setattr=attrs.setters.NO_OP)\n    c: bool = attrs.field(on_setattr=attrs.setters.frozen)\n    d: int = attrs.field(\n        on_setattr=[attrs.setters.convert, attrs.setters.validate]\n    )\n    e: bool = attrs.field(\n        on_setattr=attrs.setters.pipe(\n            attrs.setters.convert, attrs.setters.validate\n        )\n    )\n\n\n# field_transformer\ndef ft_hook(cls: type, attribs: list[attr.Attribute]) -> list[attr.Attribute]:\n    return attribs\n\n\n# field_transformer\ndef ft_hook2(\n    cls: type, attribs: list[attrs.Attribute]\n) -> list[attrs.Attribute]:\n    return attribs\n\n\n@attr.s(field_transformer=ft_hook)\nclass TransformedAttrs:\n    x: int\n\n\n@attrs.define(field_transformer=ft_hook2)\nclass TransformedAttrs2:\n    x: int\n\n\n# Auto-detect\n@attr.s(auto_detect=True)\nclass AutoDetect:\n    x: int\n\n    def __init__(self, x: int):\n        self.x = x\n\n\n# Provisional APIs\n@attr.define(order=True)\nclass NGClass:\n    x: int = attr.field(default=42)\n\n\nngc = NGClass(1)\n\n\n@attr.mutable(slots=False)\nclass NGClass2:\n    x: int\n\n\nngc2 = NGClass2(1)\n\n\n@attr.frozen(str=True)\nclass NGFrozen:\n    x: int\n\n\nngf = NGFrozen(1)\n\nattr.fields(NGFrozen).x.evolve(eq=False)\na = attr.fields(NGFrozen).x\na.evolve(repr=False)\n\n\nattrs.fields(NGFrozen).x.evolve(eq=False)\na = attrs.fields(NGFrozen).x\na.evolve(repr=False)\n\n\n@attr.s(collect_by_mro=True)\nclass MRO:\n    pass\n\n\n@attr.s\nclass FactoryTest:\n    a: list[int] = attr.ib(default=attr.Factory(list))\n    b: list[Any] = attr.ib(default=attr.Factory(list, False))\n    c: list[int] = attr.ib(default=attr.Factory((lambda s: s.a), True))\n\n\n@attrs.define\nclass FactoryTest2:\n    a: list[int] = attrs.field(default=attrs.Factory(list))\n    b: list[Any] = attrs.field(default=attrs.Factory(list, False))\n    c: list[int] = attrs.field(default=attrs.Factory((lambda s: s.a), True))\n\n\nattrs.asdict(FactoryTest2())\nattr.asdict(FactoryTest(), tuple_keys=True)\n\n\n# Check match_args stub\n@attr.s(match_args=False)\nclass MatchArgs:\n    a: int = attr.ib()\n    b: int = attr.ib()\n\n\nattr.asdict(FactoryTest())\nattr.asdict(FactoryTest(), retain_collection_types=False)\n\n\n# Check match_args stub\n@attrs.define(match_args=False)\nclass MatchArgs2:\n    a: int\n    b: int\n\n\n# NG versions of asdict/astuple\nattrs.asdict(MatchArgs2(1, 2))\nattrs.astuple(MatchArgs2(1, 2))\n\n\ndef accessing_from_attr() -> None:\n    \"\"\"\n    Use a function to keep the ns clean.\n    \"\"\"\n    attr.converters.optional\n    attr.exceptions.FrozenError\n    attr.filters.include\n    attr.filters.exclude\n    attr.setters.frozen\n    attr.validators.and_\n    attr.cmp_using\n\n\ndef accessing_from_attrs() -> None:\n    \"\"\"\n    Use a function to keep the ns clean.\n    \"\"\"\n    attrs.converters.optional\n    attrs.exceptions.FrozenError\n    attrs.filters.include\n    attrs.filters.exclude\n    attrs.setters.frozen\n    attrs.validators.and_\n    attrs.cmp_using\n\n\nfoo = object\nif attrs.has(foo) or attr.has(foo):\n    foo.__attrs_attrs__\n\n\n@attrs.define(unsafe_hash=True)\nclass Hashable:\n    pass\n\n\ndef test(cls: type) -> None:\n    if attr.has(cls):\n        attr.resolve_types(cls)\n", "tests/test_next_gen.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nIntegration tests for next-generation APIs.\n\"\"\"\n\nimport re\n\nfrom contextlib import contextmanager\nfrom functools import partial\n\nimport pytest\n\nimport attr as _attr  # don't use it by accident\nimport attrs\n\n\n@attrs.define\nclass C:\n    x: str\n    y: int\n\n\nclass TestNextGen:\n    def test_simple(self):\n        \"\"\"\n        Instantiation works.\n        \"\"\"\n        C(\"1\", 2)\n\n    def test_field_type(self):\n        \"\"\"\n        Make class with attrs.field and type parameter.\n        \"\"\"\n        classFields = {\"testint\": attrs.field(type=int)}\n\n        A = attrs.make_class(\"A\", classFields)\n\n        assert int == attrs.fields(A).testint.type\n\n    def test_no_slots(self):\n        \"\"\"\n        slots can be deactivated.\n        \"\"\"\n\n        @attrs.define(slots=False)\n        class NoSlots:\n            x: int\n\n        ns = NoSlots(1)\n\n        assert {\"x\": 1} == ns.__dict__\n\n    def test_validates(self):\n        \"\"\"\n        Validators at __init__ and __setattr__ work.\n        \"\"\"\n\n        @attrs.define\n        class Validated:\n            x: int = attrs.field(validator=attrs.validators.instance_of(int))\n\n        v = Validated(1)\n\n        with pytest.raises(TypeError):\n            Validated(None)\n\n        with pytest.raises(TypeError):\n            v.x = \"1\"\n\n    def test_no_order(self):\n        \"\"\"\n        Order is off by default but can be added.\n        \"\"\"\n        with pytest.raises(TypeError):\n            C(\"1\", 2) < C(\"2\", 3)\n\n        @attrs.define(order=True)\n        class Ordered:\n            x: int\n\n        assert Ordered(1) < Ordered(2)\n\n    def test_override_auto_attribs_true(self):\n        \"\"\"\n        Don't guess if auto_attrib is set explicitly.\n\n        Having an unannotated attrs.ib/attrs.field fails.\n        \"\"\"\n        with pytest.raises(attrs.exceptions.UnannotatedAttributeError):\n\n            @attrs.define(auto_attribs=True)\n            class ThisFails:\n                x = attrs.field()\n                y: int\n\n    def test_override_auto_attribs_false(self):\n        \"\"\"\n        Don't guess if auto_attrib is set explicitly.\n\n        Annotated fields that don't carry an attrs.ib are ignored.\n        \"\"\"\n\n        @attrs.define(auto_attribs=False)\n        class NoFields:\n            x: int\n            y: int\n\n        assert NoFields() == NoFields()\n\n    def test_auto_attribs_detect(self):\n        \"\"\"\n        define correctly detects if a class lacks type annotations.\n        \"\"\"\n\n        @attrs.define\n        class OldSchool:\n            x = attrs.field()\n\n        assert OldSchool(1) == OldSchool(1)\n\n        # Test with maybe_cls = None\n        @attrs.define()\n        class OldSchool2:\n            x = attrs.field()\n\n        assert OldSchool2(1) == OldSchool2(1)\n\n    def test_auto_attribs_detect_fields_and_annotations(self):\n        \"\"\"\n        define infers auto_attribs=True if fields have type annotations\n        \"\"\"\n\n        @attrs.define\n        class NewSchool:\n            x: int\n            y: list = attrs.field()\n\n            @y.validator\n            def _validate_y(self, attribute, value):\n                if value < 0:\n                    raise ValueError(\"y must be positive\")\n\n        assert NewSchool(1, 1) == NewSchool(1, 1)\n        with pytest.raises(ValueError):\n            NewSchool(1, -1)\n        assert list(attrs.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n\n    def test_auto_attribs_partially_annotated(self):\n        \"\"\"\n        define infers auto_attribs=True if any type annotations are found\n        \"\"\"\n\n        @attrs.define\n        class NewSchool:\n            x: int\n            y: list\n            z = 10\n\n        # fields are defined for any annotated attributes\n        assert NewSchool(1, []) == NewSchool(1, [])\n        assert list(attrs.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n\n        # while the unannotated attributes are left as class vars\n        assert NewSchool.z == 10\n        assert \"z\" in NewSchool.__dict__\n\n    def test_auto_attribs_detect_annotations(self):\n        \"\"\"\n        define correctly detects if a class has type annotations.\n        \"\"\"\n\n        @attrs.define\n        class NewSchool:\n            x: int\n\n        assert NewSchool(1) == NewSchool(1)\n\n        # Test with maybe_cls = None\n        @attrs.define()\n        class NewSchool2:\n            x: int\n\n        assert NewSchool2(1) == NewSchool2(1)\n\n    def test_exception(self):\n        \"\"\"\n        Exceptions are detected and correctly handled.\n        \"\"\"\n\n        @attrs.define\n        class E(Exception):\n            msg: str\n            other: int\n\n        with pytest.raises(E) as ei:\n            raise E(\"yolo\", 42)\n\n        e = ei.value\n\n        assert (\"yolo\", 42) == e.args\n        assert \"yolo\" == e.msg\n        assert 42 == e.other\n\n    def test_frozen(self):\n        \"\"\"\n        attrs.frozen freezes classes.\n        \"\"\"\n\n        @attrs.frozen\n        class F:\n            x: str\n\n        f = F(1)\n\n        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n            f.x = 2\n\n    def test_auto_detect_eq(self):\n        \"\"\"\n        auto_detect=True works for eq.\n\n        Regression test for #670.\n        \"\"\"\n\n        @attrs.define\n        class C:\n            def __eq__(self, o):\n                raise ValueError()\n\n        with pytest.raises(ValueError):\n            C() == C()\n\n    def test_subclass_frozen(self):\n        \"\"\"\n        It's possible to subclass an `attrs.frozen` class and the frozen-ness\n        is inherited.\n        \"\"\"\n\n        @attrs.frozen\n        class A:\n            a: int\n\n        @attrs.frozen\n        class B(A):\n            b: int\n\n        @attrs.define(on_setattr=attrs.setters.NO_OP)\n        class C(B):\n            c: int\n\n        assert B(1, 2) == B(1, 2)\n        assert C(1, 2, 3) == C(1, 2, 3)\n\n        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n            A(1).a = 1\n\n        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n            B(1, 2).a = 1\n\n        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n            B(1, 2).b = 2\n\n        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n            C(1, 2, 3).c = 3\n\n    def test_catches_frozen_on_setattr(self):\n        \"\"\"\n        Passing frozen=True and on_setattr hooks is caught, even if the\n        immutability is inherited.\n        \"\"\"\n\n        @attrs.define(frozen=True)\n        class A:\n            pass\n\n        with pytest.raises(\n            ValueError, match=\"Frozen classes can't use on_setattr.\"\n        ):\n\n            @attrs.define(frozen=True, on_setattr=attrs.setters.validate)\n            class B:\n                pass\n\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\n                \"Frozen classes can't use on_setattr \"\n                \"(frozen-ness was inherited).\"\n            ),\n        ):\n\n            @attrs.define(on_setattr=attrs.setters.validate)\n            class C(A):\n                pass\n\n    @pytest.mark.parametrize(\n        \"decorator\",\n        [\n            partial(_attr.s, frozen=True, slots=True, auto_exc=True),\n            attrs.frozen,\n            attrs.define,\n            attrs.mutable,\n        ],\n    )\n    def test_discard_context(self, decorator):\n        \"\"\"\n        raise from None works.\n\n        Regression test for #703.\n        \"\"\"\n\n        @decorator\n        class MyException(Exception):\n            x: str = attrs.field()\n\n        with pytest.raises(MyException) as ei:\n            try:\n                raise ValueError()\n            except ValueError:\n                raise MyException(\"foo\") from None\n\n        assert \"foo\" == ei.value.x\n        assert ei.value.__cause__ is None\n\n    @pytest.mark.parametrize(\n        \"decorator\",\n        [\n            partial(_attr.s, frozen=True, slots=True, auto_exc=True),\n            attrs.frozen,\n            attrs.define,\n            attrs.mutable,\n        ],\n    )\n    def test_setting_traceback_on_exception(self, decorator):\n        \"\"\"\n        contextlib.contextlib (re-)sets __traceback__ on raised exceptions.\n\n        Ensure that works, as well as if done explicitly\n        \"\"\"\n\n        @decorator\n        class MyException(Exception):\n            pass\n\n        @contextmanager\n        def do_nothing():\n            yield\n\n        with do_nothing(), pytest.raises(MyException) as ei:\n            raise MyException()\n\n        assert isinstance(ei.value, MyException)\n\n        # this should not raise an exception either\n        ei.value.__traceback__ = ei.value.__traceback__\n\n    def test_converts_and_validates_by_default(self):\n        \"\"\"\n        If no on_setattr is set, assume setters.convert, setters.validate.\n        \"\"\"\n\n        @attrs.define\n        class C:\n            x: int = attrs.field(converter=int)\n\n            @x.validator\n            def _v(self, _, value):\n                if value < 10:\n                    raise ValueError(\"must be >=10\")\n\n        inst = C(10)\n\n        # Converts\n        inst.x = \"11\"\n\n        assert 11 == inst.x\n\n        # Validates\n        with pytest.raises(ValueError, match=\"must be >=10\"):\n            inst.x = \"9\"\n\n    def test_mro_ng(self):\n        \"\"\"\n        Attributes and methods are looked up the same way in NG by default.\n\n        See #428\n        \"\"\"\n\n        @attrs.define\n        class A:\n            x: int = 10\n\n            def xx(self):\n                return 10\n\n        @attrs.define\n        class B(A):\n            y: int = 20\n\n        @attrs.define\n        class C(A):\n            x: int = 50\n\n            def xx(self):\n                return 50\n\n        @attrs.define\n        class D(B, C):\n            pass\n\n        d = D()\n\n        assert d.x == d.xx()\n\n\nclass TestAsTuple:\n    def test_smoke(self):\n        \"\"\"\n        `attrs.astuple` only changes defaults, so we just call it and compare.\n        \"\"\"\n        inst = C(\"foo\", 42)\n\n        assert attrs.astuple(inst) == _attr.astuple(inst)\n\n\nclass TestAsDict:\n    def test_smoke(self):\n        \"\"\"\n        `attrs.asdict` only changes defaults, so we just call it and compare.\n        \"\"\"\n        inst = C(\"foo\", {(1,): 42})\n\n        assert attrs.asdict(inst) == _attr.asdict(\n            inst, retain_collection_types=True\n        )\n\n\nclass TestImports:\n    \"\"\"\n    Verify our re-imports and mirroring works.\n    \"\"\"\n\n    def test_converters(self):\n        \"\"\"\n        Importing from attrs.converters works.\n        \"\"\"\n        from attrs.converters import optional\n\n        assert optional is _attr.converters.optional\n\n    def test_exceptions(self):\n        \"\"\"\n        Importing from attrs.exceptions works.\n        \"\"\"\n        from attrs.exceptions import FrozenError\n\n        assert FrozenError is _attr.exceptions.FrozenError\n\n    def test_filters(self):\n        \"\"\"\n        Importing from attrs.filters works.\n        \"\"\"\n        from attrs.filters import include\n\n        assert include is _attr.filters.include\n\n    def test_setters(self):\n        \"\"\"\n        Importing from attrs.setters works.\n        \"\"\"\n        from attrs.setters import pipe\n\n        assert pipe is _attr.setters.pipe\n\n    def test_validators(self):\n        \"\"\"\n        Importing from attrs.validators works.\n        \"\"\"\n        from attrs.validators import and_\n\n        assert and_ is _attr.validators.and_\n", "tests/test_make.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nTests for `attr._make`.\n\"\"\"\nimport copy\nimport functools\nimport gc\nimport inspect\nimport itertools\nimport sys\n\nfrom operator import attrgetter\nfrom typing import Generic, TypeVar\n\nimport pytest\n\nfrom hypothesis import assume, given\nfrom hypothesis.strategies import booleans, integers, lists, sampled_from, text\n\nimport attr\n\nfrom attr import _config\nfrom attr._compat import PY_3_8_PLUS, PY_3_10_PLUS\nfrom attr._make import (\n    Attribute,\n    Factory,\n    _AndValidator,\n    _Attributes,\n    _ClassBuilder,\n    _CountingAttr,\n    _determine_attrib_eq_order,\n    _determine_attrs_eq_order,\n    _determine_whether_to_implement,\n    _transform_attrs,\n    and_,\n    fields,\n    fields_dict,\n    make_class,\n    validate,\n)\nfrom attr.exceptions import DefaultAlreadySetError, NotAnAttrsClassError\n\nfrom .strategies import (\n    gen_attr_names,\n    list_of_attrs,\n    optional_bool,\n    simple_attrs,\n    simple_attrs_with_metadata,\n    simple_attrs_without_metadata,\n    simple_classes,\n)\nfrom .utils import simple_attr\n\n\nattrs_st = simple_attrs.map(lambda c: Attribute.from_counting_attr(\"name\", c))\n\n\n@pytest.fixture(name=\"with_and_without_validation\", params=[True, False])\ndef _with_and_without_validation(request):\n    \"\"\"\n    Run tests with and without validation enabled.\n    \"\"\"\n    attr.validators.set_disabled(request.param)\n\n    try:\n        yield\n    finally:\n        attr.validators.set_disabled(False)\n\n\nclass TestCountingAttr:\n    \"\"\"\n    Tests for `attr`.\n    \"\"\"\n\n    def test_returns_Attr(self):\n        \"\"\"\n        Returns an instance of _CountingAttr.\n        \"\"\"\n        a = attr.ib()\n\n        assert isinstance(a, _CountingAttr)\n\n    def test_validators_lists_to_wrapped_tuples(self):\n        \"\"\"\n        If a list is passed as validator, it's just converted to a tuple.\n        \"\"\"\n\n        def v1(_, __):\n            pass\n\n        def v2(_, __):\n            pass\n\n        a = attr.ib(validator=[v1, v2])\n\n        assert _AndValidator((v1, v2)) == a._validator\n\n    def test_validator_decorator_single(self):\n        \"\"\"\n        If _CountingAttr.validator is used as a decorator and there is no\n        decorator set, the decorated method is used as the validator.\n        \"\"\"\n        a = attr.ib()\n\n        @a.validator\n        def v():\n            pass\n\n        assert v == a._validator\n\n    @pytest.mark.parametrize(\n        \"wrap\", [lambda v: v, lambda v: [v], lambda v: and_(v)]\n    )\n    def test_validator_decorator(self, wrap):\n        \"\"\"\n        If _CountingAttr.validator is used as a decorator and there is already\n        a decorator set, the decorators are composed using `and_`.\n        \"\"\"\n\n        def v(_, __):\n            pass\n\n        a = attr.ib(validator=wrap(v))\n\n        @a.validator\n        def v2(self, _, __):\n            pass\n\n        assert _AndValidator((v, v2)) == a._validator\n\n    def test_default_decorator_already_set(self):\n        \"\"\"\n        Raise DefaultAlreadySetError if the decorator is used after a default\n        has been set.\n        \"\"\"\n        a = attr.ib(default=42)\n\n        with pytest.raises(DefaultAlreadySetError):\n\n            @a.default\n            def f(self):\n                pass\n\n    def test_default_decorator_sets(self):\n        \"\"\"\n        Decorator wraps the method in a Factory with pass_self=True and sets\n        the default.\n        \"\"\"\n        a = attr.ib()\n\n        @a.default\n        def f(self):\n            pass\n\n        assert Factory(f, True) == a._default\n\n\ndef make_tc():\n    class TransformC:\n        z = attr.ib()\n        y = attr.ib()\n        x = attr.ib()\n        a = 42\n\n    return TransformC\n\n\nclass TestTransformAttrs:\n    \"\"\"\n    Tests for `_transform_attrs`.\n    \"\"\"\n\n    def test_no_modifications(self):\n        \"\"\"\n        Does not attach __attrs_attrs__ to the class.\n        \"\"\"\n        C = make_tc()\n        _transform_attrs(C, None, False, False, True, None)\n\n        assert None is getattr(C, \"__attrs_attrs__\", None)\n\n    def test_normal(self):\n        \"\"\"\n        Transforms every `_CountingAttr` and leaves others (a) be.\n        \"\"\"\n        C = make_tc()\n        attrs, _, _ = _transform_attrs(C, None, False, False, True, None)\n\n        assert [\"z\", \"y\", \"x\"] == [a.name for a in attrs]\n\n    def test_empty(self):\n        \"\"\"\n        No attributes works as expected.\n        \"\"\"\n\n        @attr.s\n        class C:\n            pass\n\n        assert _Attributes(((), [], {})) == _transform_attrs(\n            C, None, False, False, True, None\n        )\n\n    def test_transforms_to_attribute(self):\n        \"\"\"\n        All `_CountingAttr`s are transformed into `Attribute`s.\n        \"\"\"\n        C = make_tc()\n        attrs, base_attrs, _ = _transform_attrs(\n            C, None, False, False, True, None\n        )\n\n        assert [] == base_attrs\n        assert 3 == len(attrs)\n        assert all(isinstance(a, Attribute) for a in attrs)\n\n    def test_conflicting_defaults(self):\n        \"\"\"\n        Raises `ValueError` if attributes with defaults are followed by\n        mandatory attributes.\n        \"\"\"\n\n        class C:\n            x = attr.ib(default=None)\n            y = attr.ib()\n\n        with pytest.raises(ValueError) as e:\n            _transform_attrs(C, None, False, False, True, None)\n        assert (\n            \"No mandatory attributes allowed after an attribute with a \"\n            \"default value or factory.  Attribute in question: Attribute\"\n            \"(name='y', default=NOTHING, validator=None, repr=True, \"\n            \"eq=True, eq_key=None, order=True, order_key=None, \"\n            \"hash=None, init=True, \"\n            \"metadata=mappingproxy({}), type=None, converter=None, \"\n            \"kw_only=False, inherited=False, on_setattr=None, alias=None)\",\n        ) == e.value.args\n\n    def test_kw_only(self):\n        \"\"\"\n        Converts all attributes, including base class' attributes, if `kw_only`\n        is provided. Therefore, `kw_only` allows attributes with defaults to\n        precede mandatory attributes.\n\n        Updates in the subclass *don't* affect the base class attributes.\n        \"\"\"\n\n        @attr.s\n        class B:\n            b = attr.ib()\n\n        for b_a in B.__attrs_attrs__:\n            assert b_a.kw_only is False\n\n        class C(B):\n            x = attr.ib(default=None)\n            y = attr.ib()\n\n        attrs, base_attrs, _ = _transform_attrs(\n            C, None, False, True, True, None\n        )\n\n        assert len(attrs) == 3\n        assert len(base_attrs) == 1\n\n        for a in attrs:\n            assert a.kw_only is True\n\n        for b_a in B.__attrs_attrs__:\n            assert b_a.kw_only is False\n\n    def test_these(self):\n        \"\"\"\n        If these is passed, use it and ignore body and base classes.\n        \"\"\"\n\n        class Base:\n            z = attr.ib()\n\n        class C(Base):\n            y = attr.ib()\n\n        attrs, base_attrs, _ = _transform_attrs(\n            C, {\"x\": attr.ib()}, False, False, True, None\n        )\n\n        assert [] == base_attrs\n        assert (simple_attr(\"x\"),) == attrs\n\n    def test_these_leave_body(self):\n        \"\"\"\n        If these is passed, no attributes are removed from the body.\n        \"\"\"\n\n        @attr.s(init=False, these={\"x\": attr.ib()})\n        class C:\n            x = 5\n\n        assert 5 == C().x\n        assert \"C(x=5)\" == repr(C())\n\n    def test_these_ordered(self):\n        \"\"\"\n        If these is passed ordered attrs, their order respect instead of the\n        counter.\n        \"\"\"\n        b = attr.ib(default=2)\n        a = attr.ib(default=1)\n\n        @attr.s(these={\"a\": a, \"b\": b})\n        class C:\n            pass\n\n        assert \"C(a=1, b=2)\" == repr(C())\n\n    def test_multiple_inheritance_old(self):\n        \"\"\"\n        Old multiple inheritance attribute collection behavior is retained.\n\n        See #285\n        \"\"\"\n\n        @attr.s\n        class A:\n            a1 = attr.ib(default=\"a1\")\n            a2 = attr.ib(default=\"a2\")\n\n        @attr.s\n        class B(A):\n            b1 = attr.ib(default=\"b1\")\n            b2 = attr.ib(default=\"b2\")\n\n        @attr.s\n        class C(B, A):\n            c1 = attr.ib(default=\"c1\")\n            c2 = attr.ib(default=\"c2\")\n\n        @attr.s\n        class D(A):\n            d1 = attr.ib(default=\"d1\")\n            d2 = attr.ib(default=\"d2\")\n\n        @attr.s\n        class E(C, D):\n            e1 = attr.ib(default=\"e1\")\n            e2 = attr.ib(default=\"e2\")\n\n        assert (\n            \"E(a1='a1', a2='a2', b1='b1', b2='b2', c1='c1', c2='c2', d1='d1', \"\n            \"d2='d2', e1='e1', e2='e2')\"\n        ) == repr(E())\n\n    def test_overwrite_proper_mro(self):\n        \"\"\"\n        The proper MRO path works single overwrites too.\n        \"\"\"\n\n        @attr.s(collect_by_mro=True)\n        class C:\n            x = attr.ib(default=1)\n\n        @attr.s(collect_by_mro=True)\n        class D(C):\n            x = attr.ib(default=2)\n\n        assert \"D(x=2)\" == repr(D())\n\n    def test_multiple_inheritance_proper_mro(self):\n        \"\"\"\n        Attributes are collected according to the MRO.\n\n        See #428\n        \"\"\"\n\n        @attr.s\n        class A:\n            a1 = attr.ib(default=\"a1\")\n            a2 = attr.ib(default=\"a2\")\n\n        @attr.s\n        class B(A):\n            b1 = attr.ib(default=\"b1\")\n            b2 = attr.ib(default=\"b2\")\n\n        @attr.s\n        class C(B, A):\n            c1 = attr.ib(default=\"c1\")\n            c2 = attr.ib(default=\"c2\")\n\n        @attr.s\n        class D(A):\n            d1 = attr.ib(default=\"d1\")\n            d2 = attr.ib(default=\"d2\")\n\n        @attr.s(collect_by_mro=True)\n        class E(C, D):\n            e1 = attr.ib(default=\"e1\")\n            e2 = attr.ib(default=\"e2\")\n\n        assert (\n            \"E(a1='a1', a2='a2', d1='d1', d2='d2', b1='b1', b2='b2', c1='c1', \"\n            \"c2='c2', e1='e1', e2='e2')\"\n        ) == repr(E())\n\n    def test_mro(self):\n        \"\"\"\n        Attributes and methods are looked up the same way.\n\n        See #428\n        \"\"\"\n\n        @attr.s(collect_by_mro=True)\n        class A:\n            x = attr.ib(10)\n\n            def xx(self):\n                return 10\n\n        @attr.s(collect_by_mro=True)\n        class B(A):\n            y = attr.ib(20)\n\n        @attr.s(collect_by_mro=True)\n        class C(A):\n            x = attr.ib(50)\n\n            def xx(self):\n                return 50\n\n        @attr.s(collect_by_mro=True)\n        class D(B, C):\n            pass\n\n        d = D()\n\n        assert d.x == d.xx()\n\n    def test_inherited(self):\n        \"\"\"\n        Inherited Attributes have `.inherited` True, otherwise False.\n        \"\"\"\n\n        @attr.s\n        class A:\n            a = attr.ib()\n\n        @attr.s\n        class B(A):\n            b = attr.ib()\n\n        @attr.s\n        class C(B):\n            a = attr.ib()\n            c = attr.ib()\n\n        f = attr.fields\n\n        assert False is f(A).a.inherited\n\n        assert True is f(B).a.inherited\n        assert False is f(B).b.inherited\n\n        assert False is f(C).a.inherited\n        assert True is f(C).b.inherited\n        assert False is f(C).c.inherited\n\n\nclass TestAttributes:\n    \"\"\"\n    Tests for the `attrs`/`attr.s` class decorator.\n    \"\"\"\n\n    def test_sets_attrs(self):\n        \"\"\"\n        Sets the `__attrs_attrs__` class attribute with a list of `Attribute`s.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib()\n\n        assert \"x\" == C.__attrs_attrs__[0].name\n        assert all(isinstance(a, Attribute) for a in C.__attrs_attrs__)\n\n    def test_empty(self):\n        \"\"\"\n        No attributes, no problems.\n        \"\"\"\n\n        @attr.s\n        class C3:\n            pass\n\n        assert \"C3()\" == repr(C3())\n        assert C3() == C3()\n\n    @given(attr=attrs_st, attr_name=sampled_from(Attribute.__slots__))\n    def test_immutable(self, attr, attr_name):\n        \"\"\"\n        Attribute instances are immutable.\n        \"\"\"\n        with pytest.raises(AttributeError):\n            setattr(attr, attr_name, 1)\n\n    @pytest.mark.parametrize(\n        \"method_name\", [\"__repr__\", \"__eq__\", \"__hash__\", \"__init__\"]\n    )\n    def test_adds_all_by_default(self, method_name):\n        \"\"\"\n        If no further arguments are supplied, all add_XXX functions except\n        add_hash are applied.  __hash__ is set to None.\n        \"\"\"\n        # Set the method name to a sentinel and check whether it has been\n        # overwritten afterwards.\n        sentinel = object()\n\n        class C:\n            x = attr.ib()\n\n        setattr(C, method_name, sentinel)\n\n        C = attr.s(C)\n        meth = getattr(C, method_name)\n\n        assert sentinel != meth\n        if method_name == \"__hash__\":\n            assert meth is None\n\n    @pytest.mark.parametrize(\n        (\"arg_name\", \"method_name\"),\n        [\n            (\"repr\", \"__repr__\"),\n            (\"eq\", \"__eq__\"),\n            (\"order\", \"__le__\"),\n            (\"hash\", \"__hash__\"),\n            (\"init\", \"__init__\"),\n        ],\n    )\n    def test_respects_add_arguments(self, arg_name, method_name):\n        \"\"\"\n        If a certain `XXX` is `False`, `__XXX__` is not added to the class.\n        \"\"\"\n        # Set the method name to a sentinel and check whether it has been\n        # overwritten afterwards.\n        sentinel = object()\n\n        am_args = {\n            \"repr\": True,\n            \"eq\": True,\n            \"order\": True,\n            \"hash\": True,\n            \"init\": True,\n        }\n        am_args[arg_name] = False\n        if arg_name == \"eq\":\n            am_args[\"order\"] = False\n\n        class C:\n            x = attr.ib()\n\n        setattr(C, method_name, sentinel)\n\n        C = attr.s(**am_args)(C)\n\n        assert sentinel == getattr(C, method_name)\n\n    @pytest.mark.parametrize(\"init\", [True, False])\n    def test_respects_init_attrs_init(self, init):\n        \"\"\"\n        If init=False, adds __attrs_init__ to the class.\n        Otherwise, it does not.\n        \"\"\"\n\n        class C:\n            x = attr.ib()\n\n        C = attr.s(init=init)(C)\n        assert hasattr(C, \"__attrs_init__\") != init\n\n    @given(slots_outer=booleans(), slots_inner=booleans())\n    def test_repr_qualname(self, slots_outer, slots_inner):\n        \"\"\"\n        The name in repr is the __qualname__.\n        \"\"\"\n\n        @attr.s(slots=slots_outer)\n        class C:\n            @attr.s(slots=slots_inner)\n            class D:\n                pass\n\n        assert \"C.D()\" == repr(C.D())\n        assert \"GC.D()\" == repr(GC.D())\n\n    @given(slots_outer=booleans(), slots_inner=booleans())\n    def test_repr_fake_qualname(self, slots_outer, slots_inner):\n        \"\"\"\n        Setting repr_ns overrides a potentially guessed namespace.\n        \"\"\"\n\n        with pytest.deprecated_call(match=\"The `repr_ns` argument\"):\n\n            @attr.s(slots=slots_outer)\n            class C:\n                @attr.s(repr_ns=\"C\", slots=slots_inner)\n                class D:\n                    pass\n\n        assert \"C.D()\" == repr(C.D())\n\n    @given(slots_outer=booleans(), slots_inner=booleans())\n    def test_name_not_overridden(self, slots_outer, slots_inner):\n        \"\"\"\n        __name__ is different from __qualname__.\n        \"\"\"\n\n        @attr.s(slots=slots_outer)\n        class C:\n            @attr.s(slots=slots_inner)\n            class D:\n                pass\n\n        assert C.D.__name__ == \"D\"\n        assert C.D.__qualname__ == C.__qualname__ + \".D\"\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_pre_init(self):\n        \"\"\"\n        Verify that __attrs_pre_init__ gets called if defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            def __attrs_pre_init__(self2):\n                self2.z = 30\n\n        c = C()\n\n        assert 30 == getattr(c, \"z\", None)\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_pre_init_args(self):\n        \"\"\"\n        Verify that __attrs_pre_init__ gets called with extra args if defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib()\n\n            def __attrs_pre_init__(self2, x):\n                self2.z = x + 1\n\n        c = C(x=10)\n\n        assert 11 == getattr(c, \"z\", None)\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_pre_init_kwargs(self):\n        \"\"\"\n        Verify that __attrs_pre_init__ gets called with extra args and kwargs\n        if defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib()\n            y = attr.field(kw_only=True)\n\n            def __attrs_pre_init__(self2, x, y):\n                self2.z = x + y + 1\n\n        c = C(10, y=11)\n\n        assert 22 == getattr(c, \"z\", None)\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_pre_init_kwargs_only(self):\n        \"\"\"\n        Verify that __attrs_pre_init__ gets called with extra kwargs only if\n        defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            y = attr.field(kw_only=True)\n\n            def __attrs_pre_init__(self2, y):\n                self2.z = y + 1\n\n        c = C(y=11)\n\n        assert 12 == getattr(c, \"z\", None)\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_post_init(self):\n        \"\"\"\n        Verify that __attrs_post_init__ gets called if defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib()\n            y = attr.ib()\n\n            def __attrs_post_init__(self2):\n                self2.z = self2.x + self2.y\n\n        c = C(x=10, y=20)\n\n        assert 30 == getattr(c, \"z\", None)\n\n    @pytest.mark.usefixtures(\"with_and_without_validation\")\n    def test_pre_post_init_order(self):\n        \"\"\"\n        Verify that __attrs_post_init__ gets called if defined.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib()\n\n            def __attrs_pre_init__(self2):\n                self2.z = 30\n\n            def __attrs_post_init__(self2):\n                self2.z += self2.x\n\n        c = C(x=10)\n\n        assert 40 == getattr(c, \"z\", None)\n\n    def test_types(self):\n        \"\"\"\n        Sets the `Attribute.type` attr from type argument.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(type=int)\n            y = attr.ib(type=str)\n            z = attr.ib()\n\n        assert int is fields(C).x.type\n        assert str is fields(C).y.type\n        assert None is fields(C).z.type\n\n    def test_clean_class(self, slots):\n        \"\"\"\n        Attribute definitions do not appear on the class body after @attr.s.\n        \"\"\"\n\n        @attr.s(slots=slots)\n        class C:\n            x = attr.ib()\n\n        x = getattr(C, \"x\", None)\n\n        assert not isinstance(x, _CountingAttr)\n\n    def test_factory_sugar(self):\n        \"\"\"\n        Passing factory=f is syntactic sugar for passing default=Factory(f).\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(factory=list)\n\n        assert Factory(list) == attr.fields(C).x.default\n\n    def test_sugar_factory_mutex(self):\n        \"\"\"\n        Passing both default and factory raises ValueError.\n        \"\"\"\n        with pytest.raises(ValueError, match=\"mutually exclusive\"):\n\n            @attr.s\n            class C:\n                x = attr.ib(factory=list, default=Factory(list))\n\n    def test_sugar_callable(self):\n        \"\"\"\n        Factory has to be a callable to prevent people from passing Factory\n        into it.\n        \"\"\"\n        with pytest.raises(ValueError, match=\"must be a callable\"):\n\n            @attr.s\n            class C:\n                x = attr.ib(factory=Factory(list))\n\n    def test_inherited_does_not_affect_hashing_and_equality(self):\n        \"\"\"\n        Whether or not an Attribute has been inherited doesn't affect how it's\n        hashed and compared.\n        \"\"\"\n\n        @attr.s\n        class BaseClass:\n            x = attr.ib()\n\n        @attr.s\n        class SubClass(BaseClass):\n            pass\n\n        ba = attr.fields(BaseClass)[0]\n        sa = attr.fields(SubClass)[0]\n\n        assert ba == sa\n        assert hash(ba) == hash(sa)\n\n\nclass TestKeywordOnlyAttributes:\n    \"\"\"\n    Tests for keyword-only attributes.\n    \"\"\"\n\n    def test_adds_keyword_only_arguments(self):\n        \"\"\"\n        Attributes can be added as keyword-only.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a = attr.ib()\n            b = attr.ib(default=2, kw_only=True)\n            c = attr.ib(kw_only=True)\n            d = attr.ib(default=attr.Factory(lambda: 4), kw_only=True)\n\n        c = C(1, c=3)\n\n        assert c.a == 1\n        assert c.b == 2\n        assert c.c == 3\n        assert c.d == 4\n\n    def test_ignores_kw_only_when_init_is_false(self):\n        \"\"\"\n        Specifying ``kw_only=True`` when ``init=False`` is essentially a no-op.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(init=False, default=0, kw_only=True)\n            y = attr.ib()\n\n        c = C(1)\n\n        assert c.x == 0\n        assert c.y == 1\n\n    def test_keyword_only_attributes_presence(self):\n        \"\"\"\n        Raises `TypeError` when keyword-only arguments are\n        not specified.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(kw_only=True)\n\n        with pytest.raises(TypeError) as e:\n            C()\n\n        assert (\n            \"missing 1 required keyword-only argument: 'x'\"\n        ) in e.value.args[0]\n\n    def test_keyword_only_attributes_unexpected(self):\n        \"\"\"\n        Raises `TypeError` when unexpected keyword argument passed.\n        \"\"\"\n\n        @attr.s\n        class C:\n            x = attr.ib(kw_only=True)\n\n        with pytest.raises(TypeError) as e:\n            C(x=5, y=10)\n\n        assert \"got an unexpected keyword argument 'y'\" in e.value.args[0]\n\n    def test_keyword_only_attributes_can_come_in_any_order(self):\n        \"\"\"\n        Mandatory vs non-mandatory attr order only matters when they are part\n        of the __init__ signature and when they aren't kw_only (which are\n        moved to the end and can be mandatory or non-mandatory in any order,\n        as they will be specified as keyword args anyway).\n        \"\"\"\n\n        @attr.s\n        class C:\n            a = attr.ib(kw_only=True)\n            b = attr.ib(kw_only=True, default=\"b\")\n            c = attr.ib(kw_only=True)\n            d = attr.ib()\n            e = attr.ib(default=\"e\")\n            f = attr.ib(kw_only=True)\n            g = attr.ib(kw_only=True, default=\"g\")\n            h = attr.ib(kw_only=True)\n            i = attr.ib(init=False)\n\n        c = C(\"d\", a=\"a\", c=\"c\", f=\"f\", h=\"h\")\n\n        assert c.a == \"a\"\n        assert c.b == \"b\"\n        assert c.c == \"c\"\n        assert c.d == \"d\"\n        assert c.e == \"e\"\n        assert c.f == \"f\"\n        assert c.g == \"g\"\n        assert c.h == \"h\"\n\n    def test_keyword_only_attributes_allow_subclassing(self):\n        \"\"\"\n        Subclass can define keyword-only attributed without defaults,\n        when the base class has attributes with defaults.\n        \"\"\"\n\n        @attr.s\n        class Base:\n            x = attr.ib(default=0)\n\n        @attr.s\n        class C(Base):\n            y = attr.ib(kw_only=True)\n\n        c = C(y=1)\n\n        assert c.x == 0\n        assert c.y == 1\n\n    def test_keyword_only_class_level(self):\n        \"\"\"\n        `kw_only` can be provided at the attr.s level, converting all\n        attributes to `kw_only.`\n        \"\"\"\n\n        @attr.s(kw_only=True)\n        class C:\n            x = attr.ib()\n            y = attr.ib(kw_only=True)\n\n        with pytest.raises(TypeError):\n            C(0, y=1)\n\n        c = C(x=0, y=1)\n\n        assert c.x == 0\n        assert c.y == 1\n\n    def test_keyword_only_class_level_subclassing(self):\n        \"\"\"\n        Subclass `kw_only` propagates to attrs inherited from the base,\n        allowing non-default following default.\n        \"\"\"\n\n        @attr.s\n        class Base:\n            x = attr.ib(default=0)\n\n        @attr.s(kw_only=True)\n        class C(Base):\n            y = attr.ib()\n\n        with pytest.raises(TypeError):\n            C(1)\n\n        c = C(x=0, y=1)\n\n        assert c.x == 0\n        assert c.y == 1\n\n    def test_init_false_attribute_after_keyword_attribute(self):\n        \"\"\"\n        A positional attribute cannot follow a `kw_only` attribute,\n        but an `init=False` attribute can because it won't appear\n        in `__init__`\n        \"\"\"\n\n        @attr.s\n        class KwArgBeforeInitFalse:\n            kwarg = attr.ib(kw_only=True)\n            non_init_function_default = attr.ib(init=False)\n            non_init_keyword_default = attr.ib(\n                init=False, default=\"default-by-keyword\"\n            )\n\n            @non_init_function_default.default\n            def _init_to_init(self):\n                return self.kwarg + \"b\"\n\n        c = KwArgBeforeInitFalse(kwarg=\"a\")\n\n        assert c.kwarg == \"a\"\n        assert c.non_init_function_default == \"ab\"\n        assert c.non_init_keyword_default == \"default-by-keyword\"\n\n    def test_init_false_attribute_after_keyword_attribute_with_inheritance(\n        self,\n    ):\n        \"\"\"\n        A positional attribute cannot follow a `kw_only` attribute,\n        but an `init=False` attribute can because it won't appear\n        in `__init__`. This test checks that we allow this\n        even when the `kw_only` attribute appears in a parent class\n        \"\"\"\n\n        @attr.s\n        class KwArgBeforeInitFalseParent:\n            kwarg = attr.ib(kw_only=True)\n\n        @attr.s\n        class KwArgBeforeInitFalseChild(KwArgBeforeInitFalseParent):\n            non_init_function_default = attr.ib(init=False)\n            non_init_keyword_default = attr.ib(\n                init=False, default=\"default-by-keyword\"\n            )\n\n            @non_init_function_default.default\n            def _init_to_init(self):\n                return self.kwarg + \"b\"\n\n        c = KwArgBeforeInitFalseChild(kwarg=\"a\")\n\n        assert c.kwarg == \"a\"\n        assert c.non_init_function_default == \"ab\"\n        assert c.non_init_keyword_default == \"default-by-keyword\"\n\n\n@attr.s\nclass GC:\n    @attr.s\n    class D:\n        pass\n\n\nclass TestMakeClass:\n    \"\"\"\n    Tests for `make_class`.\n    \"\"\"\n\n    @pytest.mark.parametrize(\"ls\", [list, tuple])\n    def test_simple(self, ls):\n        \"\"\"\n        Passing a list of strings creates attributes with default args.\n        \"\"\"\n        C1 = make_class(\"C1\", ls([\"a\", \"b\"]))\n\n        @attr.s\n        class C2:\n            a = attr.ib()\n            b = attr.ib()\n\n        assert C1.__attrs_attrs__ == C2.__attrs_attrs__\n\n    def test_dict(self):\n        \"\"\"\n        Passing a dict of name: _CountingAttr creates an equivalent class.\n        \"\"\"\n        C1 = make_class(\n            \"C1\", {\"a\": attr.ib(default=42), \"b\": attr.ib(default=None)}\n        )\n\n        @attr.s\n        class C2:\n            a = attr.ib(default=42)\n            b = attr.ib(default=None)\n\n        assert C1.__attrs_attrs__ == C2.__attrs_attrs__\n\n    def test_attr_args(self):\n        \"\"\"\n        attributes_arguments are passed to attributes\n        \"\"\"\n        C = make_class(\"C\", [\"x\"], repr=False)\n\n        assert repr(C(1)).startswith(\"<tests.test_make.C object at 0x\")\n\n    def test_catches_wrong_attrs_type(self):\n        \"\"\"\n        Raise `TypeError` if an invalid type for attrs is passed.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            make_class(\"C\", object())\n\n        assert (\"attrs argument must be a dict or a list.\",) == e.value.args\n\n    def test_bases(self):\n        \"\"\"\n        Parameter bases default to (object,) and subclasses correctly\n        \"\"\"\n\n        class D:\n            pass\n\n        cls = make_class(\"C\", {})\n\n        assert cls.__mro__[-1] == object\n\n        cls = make_class(\"C\", {}, bases=(D,))\n\n        assert D in cls.__mro__\n        assert isinstance(cls(), D)\n\n    def test_additional_class_body(self):\n        \"\"\"\n        Additional class_body is added to newly created class.\n        \"\"\"\n\n        def echo_func(cls, *args):\n            return args\n\n        cls = make_class(\"C\", {}, class_body={\"echo\": classmethod(echo_func)})\n\n        assert (\"a\", \"b\") == cls.echo(\"a\", \"b\")\n\n    def test_clean_class(self, slots):\n        \"\"\"\n        Attribute definitions do not appear on the class body.\n        \"\"\"\n        C = make_class(\"C\", [\"x\"], slots=slots)\n\n        x = getattr(C, \"x\", None)\n\n        assert not isinstance(x, _CountingAttr)\n\n    def test_missing_sys_getframe(self, monkeypatch):\n        \"\"\"\n        `make_class()` does not fail when `sys._getframe()` is not available.\n        \"\"\"\n        monkeypatch.delattr(sys, \"_getframe\")\n        C = make_class(\"C\", [\"x\"])\n\n        assert 1 == len(C.__attrs_attrs__)\n\n    def test_make_class_ordered(self):\n        \"\"\"\n        If `make_class()` is passed ordered attrs, their order is respected\n        instead of the counter.\n        \"\"\"\n        b = attr.ib(default=2)\n        a = attr.ib(default=1)\n\n        C = attr.make_class(\"C\", {\"a\": a, \"b\": b})\n\n        assert \"C(a=1, b=2)\" == repr(C())\n\n    def test_generic_dynamic_class(self):\n        \"\"\"\n        make_class can create generic dynamic classes.\n\n        https://github.com/python-attrs/attrs/issues/756\n        https://bugs.python.org/issue33188\n        \"\"\"\n        from types import new_class\n        from typing import Generic, TypeVar\n\n        MyTypeVar = TypeVar(\"MyTypeVar\")\n        MyParent = new_class(\"MyParent\", (Generic[MyTypeVar],), {})\n\n        attr.make_class(\"test\", {\"id\": attr.ib(type=str)}, (MyParent[int],))\n\n\nclass TestFields:\n    \"\"\"\n    Tests for `fields`.\n    \"\"\"\n\n    @given(simple_classes())\n    def test_instance(self, C):\n        \"\"\"\n        Raises `TypeError` on non-classes.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            fields(C())\n\n        assert \"Passed object must be a class.\" == e.value.args[0]\n\n    def test_handler_non_attrs_class(self):\n        \"\"\"\n        Raises `ValueError` if passed a non-*attrs* instance.\n        \"\"\"\n        with pytest.raises(NotAnAttrsClassError) as e:\n            fields(object)\n\n        assert (\n            f\"{object!r} is not an attrs-decorated class.\"\n        ) == e.value.args[0]\n\n    def test_handler_non_attrs_generic_class(self):\n        \"\"\"\n        Raises `ValueError` if passed a non-*attrs* generic class.\n        \"\"\"\n        T = TypeVar(\"T\")\n\n        class B(Generic[T]):\n            pass\n\n        with pytest.raises(NotAnAttrsClassError) as e:\n            fields(B[str])\n\n        assert (\n            f\"{B[str]!r} is not an attrs-decorated class.\"\n        ) == e.value.args[0]\n\n    @given(simple_classes())\n    def test_fields(self, C):\n        \"\"\"\n        Returns a list of `Attribute`a.\n        \"\"\"\n        assert all(isinstance(a, Attribute) for a in fields(C))\n\n    @given(simple_classes())\n    def test_fields_properties(self, C):\n        \"\"\"\n        Fields returns a tuple with properties.\n        \"\"\"\n        for attribute in fields(C):\n            assert getattr(fields(C), attribute.name) is attribute\n\n    def test_generics(self):\n        \"\"\"\n        Fields work with generic classes.\n        \"\"\"\n        T = TypeVar(\"T\")\n\n        @attr.define\n        class A(Generic[T]):\n            a: T\n\n        assert len(fields(A)) == 1\n        assert fields(A).a.name == \"a\"\n        assert fields(A).a.default is attr.NOTHING\n\n        assert len(fields(A[str])) == 1\n        assert fields(A[str]).a.name == \"a\"\n        assert fields(A[str]).a.default is attr.NOTHING\n\n\nclass TestFieldsDict:\n    \"\"\"\n    Tests for `fields_dict`.\n    \"\"\"\n\n    @given(simple_classes())\n    def test_instance(self, C):\n        \"\"\"\n        Raises `TypeError` on non-classes.\n        \"\"\"\n        with pytest.raises(TypeError) as e:\n            fields_dict(C())\n\n        assert \"Passed object must be a class.\" == e.value.args[0]\n\n    def test_handler_non_attrs_class(self):\n        \"\"\"\n        Raises `ValueError` if passed a non-*attrs* instance.\n        \"\"\"\n        with pytest.raises(NotAnAttrsClassError) as e:\n            fields_dict(object)\n\n        assert (\n            f\"{object!r} is not an attrs-decorated class.\"\n        ) == e.value.args[0]\n\n    @given(simple_classes())\n    def test_fields_dict(self, C):\n        \"\"\"\n        Returns an ordered dict of ``{attribute_name: Attribute}``.\n        \"\"\"\n        d = fields_dict(C)\n\n        assert isinstance(d, dict)\n        assert list(fields(C)) == list(d.values())\n        assert [a.name for a in fields(C)] == list(d)\n\n\nclass TestConverter:\n    \"\"\"\n    Tests for attribute conversion.\n    \"\"\"\n\n    def test_convert(self):\n        \"\"\"\n        Return value of converter is used as the attribute's value.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"x\": attr.ib(converter=lambda v: v + 1), \"y\": attr.ib()}\n        )\n        c = C(1, 2)\n\n        assert c.x == 2\n        assert c.y == 2\n\n    @given(integers(), booleans())\n    def test_convert_property(self, val, init):\n        \"\"\"\n        Property tests for attributes using converter.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\n                \"y\": attr.ib(),\n                \"x\": attr.ib(\n                    init=init, default=val, converter=lambda v: v + 1\n                ),\n            },\n        )\n        c = C(2)\n\n        assert c.x == val + 1\n        assert c.y == 2\n\n    @given(integers(), booleans())\n    def test_converter_factory_property(self, val, init):\n        \"\"\"\n        Property tests for attributes with converter, and a factory default.\n        \"\"\"\n        C = make_class(\n            \"C\",\n            {\n                \"y\": attr.ib(),\n                \"x\": attr.ib(\n                    init=init,\n                    default=Factory(lambda: val),\n                    converter=lambda v: v + 1,\n                ),\n            },\n        )\n        c = C(2)\n\n        assert c.x == val + 1\n        assert c.y == 2\n\n    def test_convert_before_validate(self):\n        \"\"\"\n        Validation happens after conversion.\n        \"\"\"\n\n        def validator(inst, attr, val):\n            raise RuntimeError(\"foo\")\n\n        C = make_class(\n            \"C\",\n            {\n                \"x\": attr.ib(validator=validator, converter=lambda v: 1 / 0),\n                \"y\": attr.ib(),\n            },\n        )\n        with pytest.raises(ZeroDivisionError):\n            C(1, 2)\n\n    def test_frozen(self):\n        \"\"\"\n        Converters circumvent immutability.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"x\": attr.ib(converter=lambda v: int(v))}, frozen=True\n        )\n        C(\"1\")\n\n\nclass TestValidate:\n    \"\"\"\n    Tests for `validate`.\n    \"\"\"\n\n    def test_success(self):\n        \"\"\"\n        If the validator succeeds, nothing gets raised.\n        \"\"\"\n        C = make_class(\n            \"C\", {\"x\": attr.ib(validator=lambda *a: None), \"y\": attr.ib()}\n        )\n        validate(C(1, 2))\n\n    def test_propagates(self):\n        \"\"\"\n        The exception of the validator is handed through.\n        \"\"\"\n\n        def raiser(_, __, value):\n            if value == 42:\n                raise FloatingPointError\n\n        C = make_class(\"C\", {\"x\": attr.ib(validator=raiser)})\n        i = C(1)\n        i.x = 42\n\n        with pytest.raises(FloatingPointError):\n            validate(i)\n\n    def test_run_validators(self):\n        \"\"\"\n        Setting `_run_validators` to False prevents validators from running.\n        \"\"\"\n        _config._run_validators = False\n        obj = object()\n\n        def raiser(_, __, ___):\n            raise Exception(obj)\n\n        C = make_class(\"C\", {\"x\": attr.ib(validator=raiser)})\n        c = C(1)\n        validate(c)\n        assert 1 == c.x\n        _config._run_validators = True\n\n        with pytest.raises(Exception):\n            validate(c)\n\n        with pytest.raises(Exception) as e:\n            C(1)\n        assert (obj,) == e.value.args\n\n    def test_multiple_validators(self):\n        \"\"\"\n        If a list is passed as a validator, all of its items are treated as one\n        and must pass.\n        \"\"\"\n\n        def v1(_, __, value):\n            if value == 23:\n                raise TypeError(\"omg\")\n\n        def v2(_, __, value):\n            if value == 42:\n                raise ValueError(\"omg\")\n\n        C = make_class(\"C\", {\"x\": attr.ib(validator=[v1, v2])})\n\n        validate(C(1))\n\n        with pytest.raises(TypeError) as e:\n            C(23)\n\n        assert \"omg\" == e.value.args[0]\n\n        with pytest.raises(ValueError) as e:\n            C(42)\n\n        assert \"omg\" == e.value.args[0]\n\n    def test_multiple_empty(self):\n        \"\"\"\n        Empty list/tuple for validator is the same as None.\n        \"\"\"\n        C1 = make_class(\"C\", {\"x\": attr.ib(validator=[])})\n        C2 = make_class(\"C\", {\"x\": attr.ib(validator=None)})\n\n        assert inspect.getsource(C1.__init__) == inspect.getsource(C2.__init__)\n\n\n# Hypothesis seems to cache values, so the lists of attributes come out\n# unsorted.\nsorted_lists_of_attrs = list_of_attrs.map(\n    lambda ln: sorted(ln, key=attrgetter(\"counter\"))\n)\n\n\nclass TestMetadata:\n    \"\"\"\n    Tests for metadata handling.\n    \"\"\"\n\n    @given(sorted_lists_of_attrs)\n    def test_metadata_present(self, list_of_attrs):\n        \"\"\"\n        Assert dictionaries are copied and present.\n        \"\"\"\n        C = make_class(\"C\", dict(zip(gen_attr_names(), list_of_attrs)))\n\n        for hyp_attr, class_attr in zip(list_of_attrs, fields(C)):\n            if hyp_attr.metadata is None:\n                # The default is a singleton empty dict.\n                assert class_attr.metadata is not None\n                assert len(class_attr.metadata) == 0\n            else:\n                assert hyp_attr.metadata == class_attr.metadata\n\n                # Once more, just to assert getting items and iteration.\n                for k in class_attr.metadata:\n                    assert hyp_attr.metadata[k] == class_attr.metadata[k]\n                    assert hyp_attr.metadata.get(k) == class_attr.metadata.get(\n                        k\n                    )\n\n    @given(simple_classes(), text())\n    def test_metadata_immutability(self, C, string):\n        \"\"\"\n        The metadata dict should be best-effort immutable.\n        \"\"\"\n        for a in fields(C):\n            with pytest.raises(TypeError):\n                a.metadata[string] = string\n            with pytest.raises(AttributeError):\n                a.metadata.update({string: string})\n            with pytest.raises(AttributeError):\n                a.metadata.clear()\n            with pytest.raises(AttributeError):\n                a.metadata.setdefault(string, string)\n\n            for k in a.metadata:\n                # For some reason, MappingProxyType throws an IndexError for\n                # deletes on a large integer key.\n                with pytest.raises((TypeError, IndexError)):\n                    del a.metadata[k]\n                with pytest.raises(AttributeError):\n                    a.metadata.pop(k)\n            with pytest.raises(AttributeError):\n                a.metadata.popitem()\n\n    @given(lists(simple_attrs_without_metadata, min_size=2, max_size=5))\n    def test_empty_metadata_singleton(self, list_of_attrs):\n        \"\"\"\n        All empty metadata attributes share the same empty metadata dict.\n        \"\"\"\n        C = make_class(\"C\", dict(zip(gen_attr_names(), list_of_attrs)))\n        for a in fields(C)[1:]:\n            assert a.metadata is fields(C)[0].metadata\n\n    @given(lists(simple_attrs_without_metadata, min_size=2, max_size=5))\n    def test_empty_countingattr_metadata_independent(self, list_of_attrs):\n        \"\"\"\n        All empty metadata attributes are independent before ``@attr.s``.\n        \"\"\"\n        for x, y in itertools.combinations(list_of_attrs, 2):\n            assert x.metadata is not y.metadata\n\n    @given(lists(simple_attrs_with_metadata(), min_size=2, max_size=5))\n    def test_not_none_metadata(self, list_of_attrs):\n        \"\"\"\n        Non-empty metadata attributes exist as fields after ``@attr.s``.\n        \"\"\"\n        C = make_class(\"C\", dict(zip(gen_attr_names(), list_of_attrs)))\n\n        assert len(fields(C)) > 0\n\n        for cls_a, raw_a in zip(fields(C), list_of_attrs):\n            assert cls_a.metadata != {}\n            assert cls_a.metadata == raw_a.metadata\n\n    def test_metadata(self):\n        \"\"\"\n        If metadata that is not None is passed, it is used.\n\n        This is necessary for coverage because the previous test is\n        hypothesis-based.\n        \"\"\"\n        md = {}\n        a = attr.ib(metadata=md)\n\n        assert md is a.metadata\n\n\nclass TestClassBuilder:\n    \"\"\"\n    Tests for `_ClassBuilder`.\n    \"\"\"\n\n    def test_repr_str(self):\n        \"\"\"\n        Trying to add a `__str__` without having a `__repr__` raises a\n        ValueError.\n        \"\"\"\n        with pytest.raises(ValueError) as ei:\n            make_class(\"C\", {}, repr=False, str=True)\n\n        assert (\n            \"__str__ can only be generated if a __repr__ exists.\",\n        ) == ei.value.args\n\n    def test_repr(self):\n        \"\"\"\n        repr of builder itself makes sense.\n        \"\"\"\n\n        class C:\n            pass\n\n        b = _ClassBuilder(\n            C,\n            None,\n            True,\n            True,\n            False,\n            False,\n            False,\n            False,\n            False,\n            False,\n            True,\n            None,\n            False,\n            None,\n        )\n\n        assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n\n    def test_returns_self(self):\n        \"\"\"\n        All methods return the builder for chaining.\n        \"\"\"\n\n        class C:\n            x = attr.ib()\n\n        b = _ClassBuilder(\n            C,\n            None,\n            True,\n            True,\n            False,\n            False,\n            False,\n            False,\n            False,\n            False,\n            True,\n            None,\n            False,\n            None,\n        )\n\n        cls = (\n            b.add_eq()\n            .add_order()\n            .add_hash()\n            .add_init()\n            .add_attrs_init()\n            .add_repr(\"ns\")\n            .add_str()\n            .build_class()\n        )\n\n        assert \"ns.C(x=1)\" == repr(cls(1))\n\n    @pytest.mark.parametrize(\n        \"meth_name\",\n        [\n            \"__init__\",\n            \"__hash__\",\n            \"__repr__\",\n            \"__str__\",\n            \"__eq__\",\n            \"__ne__\",\n            \"__lt__\",\n            \"__le__\",\n            \"__gt__\",\n            \"__ge__\",\n        ],\n    )\n    def test_attaches_meta_dunders(self, meth_name):\n        \"\"\"\n        Generated methods have correct __module__, __name__, and __qualname__\n        attributes.\n        \"\"\"\n\n        @attr.s(hash=True, str=True)\n        class C:\n            def organic(self):\n                pass\n\n        @attr.s(hash=True, str=True)\n        class D:\n            pass\n\n        meth_C = getattr(C, meth_name)\n        meth_D = getattr(D, meth_name)\n\n        assert meth_name == meth_C.__name__ == meth_D.__name__\n        assert C.organic.__module__ == meth_C.__module__ == meth_D.__module__\n        # This is assertion that would fail if a single __ne__ instance\n        # was reused across multiple _make_eq calls.\n        organic_prefix = C.organic.__qualname__.rsplit(\".\", 1)[0]\n        assert organic_prefix + \".\" + meth_name == meth_C.__qualname__\n\n    def test_handles_missing_meta_on_class(self):\n        \"\"\"\n        If the class hasn't a __module__ or __qualname__, the method hasn't\n        either.\n        \"\"\"\n\n        class C:\n            pass\n\n        b = _ClassBuilder(\n            C,\n            these=None,\n            slots=False,\n            frozen=False,\n            weakref_slot=True,\n            getstate_setstate=False,\n            auto_attribs=False,\n            is_exc=False,\n            kw_only=False,\n            cache_hash=False,\n            collect_by_mro=True,\n            on_setattr=None,\n            has_custom_setattr=False,\n            field_transformer=None,\n        )\n        b._cls = {}  # no __module__; no __qualname__\n\n        def fake_meth(self):\n            pass\n\n        fake_meth.__module__ = \"42\"\n        fake_meth.__qualname__ = \"23\"\n\n        rv = b._add_method_dunders(fake_meth)\n\n        assert \"42\" == rv.__module__ == fake_meth.__module__\n        assert \"23\" == rv.__qualname__ == fake_meth.__qualname__\n\n    def test_weakref_setstate(self):\n        \"\"\"\n        __weakref__ is not set on in setstate because it's not writable in\n        slotted classes.\n        \"\"\"\n\n        @attr.s(slots=True)\n        class C:\n            __weakref__ = attr.ib(\n                init=False, hash=False, repr=False, eq=False, order=False\n            )\n\n        assert C() == copy.deepcopy(C())\n\n    def test_no_references_to_original(self):\n        \"\"\"\n        When subclassing a slotted class, there are no stray references to the\n        original class.\n        \"\"\"\n\n        @attr.s(slots=True)\n        class C:\n            pass\n\n        @attr.s(slots=True)\n        class C2(C):\n            pass\n\n        # The original C2 is in a reference cycle, so force a collect:\n        gc.collect()\n\n        assert [C2] == C.__subclasses__()\n\n    @pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\n    def test_no_references_to_original_when_using_cached_property(self):\n        \"\"\"\n        When subclassing a slotted class and using cached property, there are no stray references to the original class.\n        \"\"\"\n\n        @attr.s(slots=True)\n        class C:\n            pass\n\n        @attr.s(slots=True)\n        class C2(C):\n            @functools.cached_property\n            def value(self) -> int:\n                return 0\n\n        # The original C2 is in a reference cycle, so force a collect:\n        gc.collect()\n\n        assert [C2] == C.__subclasses__()\n\n    def _get_copy_kwargs(include_slots=True):\n        \"\"\"\n        Generate a list of compatible attr.s arguments for the `copy` tests.\n        \"\"\"\n        options = [\"frozen\", \"hash\", \"cache_hash\"]\n\n        if include_slots:\n            options.extend([\"slots\", \"weakref_slot\"])\n\n        out_kwargs = []\n        for args in itertools.product([True, False], repeat=len(options)):\n            kwargs = dict(zip(options, args))\n\n            kwargs[\"hash\"] = kwargs[\"hash\"] or None\n\n            if kwargs[\"cache_hash\"] and not (\n                kwargs[\"frozen\"] or kwargs[\"hash\"]\n            ):\n                continue\n\n            out_kwargs.append(kwargs)\n\n        return out_kwargs\n\n    @pytest.mark.parametrize(\"kwargs\", _get_copy_kwargs())\n    def test_copy(self, kwargs):\n        \"\"\"\n        Ensure that an attrs class can be copied successfully.\n        \"\"\"\n\n        @attr.s(eq=True, **kwargs)\n        class C:\n            x = attr.ib()\n\n        a = C(1)\n        b = copy.deepcopy(a)\n\n        assert a == b\n\n    @pytest.mark.parametrize(\"kwargs\", _get_copy_kwargs(include_slots=False))\n    def test_copy_custom_setstate(self, kwargs):\n        \"\"\"\n        Ensure that non-slots classes respect a custom __setstate__.\n        \"\"\"\n\n        @attr.s(eq=True, **kwargs)\n        class C:\n            x = attr.ib()\n\n            def __getstate__(self):\n                return self.__dict__\n\n            def __setstate__(self, state):\n                state[\"x\"] *= 5\n                self.__dict__.update(state)\n\n        expected = C(25)\n        actual = copy.copy(C(5))\n\n        assert actual == expected\n\n\nclass TestInitAlias:\n    \"\"\"\n    Tests for Attribute alias handling.\n    \"\"\"\n\n    def test_default_and_specify(self):\n        \"\"\"\n        alias is present on the Attributes returned from attr.fields.\n\n        If left unspecified, it defaults to standard private-attribute\n        handling.  If specified, it passes through the explicit alias.\n        \"\"\"\n\n        # alias is None by default on _CountingAttr\n        default_counting = attr.ib()\n        assert default_counting.alias is None\n\n        override_counting = attr.ib(alias=\"specified\")\n        assert override_counting.alias == \"specified\"\n\n        @attr.s\n        class Cases:\n            public_default = attr.ib()\n            _private_default = attr.ib()\n            __dunder_default__ = attr.ib()\n\n            public_override = attr.ib(alias=\"public\")\n            _private_override = attr.ib(alias=\"_private\")\n            __dunder_override__ = attr.ib(alias=\"__dunder__\")\n\n        cases = attr.fields_dict(Cases)\n\n        # Default applies private-name mangling logic\n        assert cases[\"public_default\"].name == \"public_default\"\n        assert cases[\"public_default\"].alias == \"public_default\"\n\n        assert cases[\"_private_default\"].name == \"_private_default\"\n        assert cases[\"_private_default\"].alias == \"private_default\"\n\n        assert cases[\"__dunder_default__\"].name == \"__dunder_default__\"\n        assert cases[\"__dunder_default__\"].alias == \"dunder_default__\"\n\n        # Override is passed through\n        assert cases[\"public_override\"].name == \"public_override\"\n        assert cases[\"public_override\"].alias == \"public\"\n\n        assert cases[\"_private_override\"].name == \"_private_override\"\n        assert cases[\"_private_override\"].alias == \"_private\"\n\n        assert cases[\"__dunder_override__\"].name == \"__dunder_override__\"\n        assert cases[\"__dunder_override__\"].alias == \"__dunder__\"\n\n        # And aliases are applied to the __init__ signature\n        example = Cases(\n            public_default=1,\n            private_default=2,\n            dunder_default__=3,\n            public=4,\n            _private=5,\n            __dunder__=6,\n        )\n\n        assert example.public_default == 1\n        assert example._private_default == 2\n        assert example.__dunder_default__ == 3\n        assert example.public_override == 4\n        assert example._private_override == 5\n        assert example.__dunder_override__ == 6\n\n    def test_evolve(self):\n        \"\"\"\n        attr.evolve uses Attribute.alias to determine parameter names.\n        \"\"\"\n\n        @attr.s\n        class EvolveCase:\n            _override = attr.ib(alias=\"_override\")\n            __mangled = attr.ib()\n            __dunder__ = attr.ib()\n\n        org = EvolveCase(1, 2, 3)\n\n        # Previous behavior of evolve as broken for double-underscore\n        # passthrough, and would raise here due to mis-mapping the __dunder__\n        # alias\n        assert attr.evolve(org) == org\n\n        # evolve uses the alias to match __init__ signature\n        assert attr.evolve(\n            org,\n            _override=0,\n        ) == EvolveCase(0, 2, 3)\n\n        # and properly passes through dunders and mangles\n        assert attr.evolve(\n            org,\n            EvolveCase__mangled=4,\n            dunder__=5,\n        ) == EvolveCase(1, 4, 5)\n\n\nclass TestMakeOrder:\n    \"\"\"\n    Tests for _make_order().\n    \"\"\"\n\n    def test_subclasses_cannot_be_compared(self):\n        \"\"\"\n        Calling comparison methods on subclasses raises a TypeError.\n\n        We use the actual operation so we get an error raised.\n        \"\"\"\n\n        @attr.s\n        class A:\n            a = attr.ib()\n\n        @attr.s\n        class B(A):\n            pass\n\n        a = A(42)\n        b = B(42)\n\n        assert a <= a\n        assert a >= a\n        assert not a < a\n        assert not a > a\n\n        assert (\n            NotImplemented\n            == a.__lt__(b)\n            == a.__le__(b)\n            == a.__gt__(b)\n            == a.__ge__(b)\n        )\n\n        with pytest.raises(TypeError):\n            a <= b\n\n        with pytest.raises(TypeError):\n            a >= b\n\n        with pytest.raises(TypeError):\n            a < b\n\n        with pytest.raises(TypeError):\n            a > b\n\n\nclass TestDetermineAttrsEqOrder:\n    def test_default(self):\n        \"\"\"\n        If all are set to None, set both eq and order to the passed default.\n        \"\"\"\n        assert (42, 42) == _determine_attrs_eq_order(None, None, None, 42)\n\n    @pytest.mark.parametrize(\"eq\", [True, False])\n    def test_order_mirrors_eq_by_default(self, eq):\n        \"\"\"\n        If order is None, it mirrors eq.\n        \"\"\"\n        assert (eq, eq) == _determine_attrs_eq_order(None, eq, None, True)\n\n    def test_order_without_eq(self):\n        \"\"\"\n        eq=False, order=True raises a meaningful ValueError.\n        \"\"\"\n        with pytest.raises(\n            ValueError, match=\"`order` can only be True if `eq` is True too.\"\n        ):\n            _determine_attrs_eq_order(None, False, True, True)\n\n    @given(cmp=booleans(), eq=optional_bool, order=optional_bool)\n    def test_mix(self, cmp, eq, order):\n        \"\"\"\n        If cmp is not None, eq and order must be None and vice versa.\n        \"\"\"\n        assume(eq is not None or order is not None)\n\n        with pytest.raises(\n            ValueError, match=\"Don't mix `cmp` with `eq' and `order`.\"\n        ):\n            _determine_attrs_eq_order(cmp, eq, order, True)\n\n\nclass TestDetermineAttribEqOrder:\n    def test_default(self):\n        \"\"\"\n        If all are set to None, set both eq and order to the passed default.\n        \"\"\"\n        assert (42, None, 42, None) == _determine_attrib_eq_order(\n            None, None, None, 42\n        )\n\n    def test_eq_callable_order_boolean(self):\n        \"\"\"\n        eq=callable or order=callable need to transformed into eq/eq_key\n        or order/order_key.\n        \"\"\"\n        assert (True, str.lower, False, None) == _determine_attrib_eq_order(\n            None, str.lower, False, True\n        )\n\n    def test_eq_callable_order_callable(self):\n        \"\"\"\n        eq=callable or order=callable need to transformed into eq/eq_key\n        or order/order_key.\n        \"\"\"\n        assert (True, str.lower, True, abs) == _determine_attrib_eq_order(\n            None, str.lower, abs, True\n        )\n\n    def test_eq_boolean_order_callable(self):\n        \"\"\"\n        eq=callable or order=callable need to transformed into eq/eq_key\n        or order/order_key.\n        \"\"\"\n        assert (True, None, True, str.lower) == _determine_attrib_eq_order(\n            None, True, str.lower, True\n        )\n\n    @pytest.mark.parametrize(\"eq\", [True, False])\n    def test_order_mirrors_eq_by_default(self, eq):\n        \"\"\"\n        If order is None, it mirrors eq.\n        \"\"\"\n        assert (eq, None, eq, None) == _determine_attrib_eq_order(\n            None, eq, None, True\n        )\n\n    def test_order_without_eq(self):\n        \"\"\"\n        eq=False, order=True raises a meaningful ValueError.\n        \"\"\"\n        with pytest.raises(\n            ValueError, match=\"`order` can only be True if `eq` is True too.\"\n        ):\n            _determine_attrib_eq_order(None, False, True, True)\n\n    @given(cmp=booleans(), eq=optional_bool, order=optional_bool)\n    def test_mix(self, cmp, eq, order):\n        \"\"\"\n        If cmp is not None, eq and order must be None and vice versa.\n        \"\"\"\n        assume(eq is not None or order is not None)\n\n        with pytest.raises(\n            ValueError, match=\"Don't mix `cmp` with `eq' and `order`.\"\n        ):\n            _determine_attrib_eq_order(cmp, eq, order, True)\n\n\nclass TestDocs:\n    @pytest.mark.parametrize(\n        \"meth_name\",\n        [\n            \"__init__\",\n            \"__repr__\",\n            \"__eq__\",\n            \"__ne__\",\n            \"__lt__\",\n            \"__le__\",\n            \"__gt__\",\n            \"__ge__\",\n        ],\n    )\n    def test_docs(self, meth_name):\n        \"\"\"\n        Tests the presence and correctness of the documentation\n        for the generated methods\n        \"\"\"\n\n        @attr.s\n        class A:\n            pass\n\n        if hasattr(A, \"__qualname__\"):\n            method = getattr(A, meth_name)\n            expected = f\"Method generated by attrs for class {A.__qualname__}.\"\n            assert expected == method.__doc__\n\n\nclass BareC:\n    pass\n\n\nclass BareSlottedC:\n    __slots__ = ()\n\n\nclass TestAutoDetect:\n    @pytest.mark.parametrize(\"C\", [BareC, BareSlottedC])\n    def test_determine_detects_non_presence_correctly(self, C):\n        \"\"\"\n        On an empty class, nothing should be detected.\n        \"\"\"\n        assert True is _determine_whether_to_implement(\n            C, None, True, (\"__init__\",)\n        )\n        assert True is _determine_whether_to_implement(\n            C, None, True, (\"__repr__\",)\n        )\n        assert True is _determine_whether_to_implement(\n            C, None, True, (\"__eq__\", \"__ne__\")\n        )\n        assert True is _determine_whether_to_implement(\n            C, None, True, (\"__le__\", \"__lt__\", \"__ge__\", \"__gt__\")\n        )\n\n    def test_make_all_by_default(self, slots, frozen):\n        \"\"\"\n        If nothing is there to be detected, imply init=True, repr=True,\n        hash=None, eq=True, order=True.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n        i = C(1)\n        o = object()\n\n        assert i.__init__ is not o.__init__\n        assert i.__repr__ is not o.__repr__\n        assert i.__eq__ is not o.__eq__\n        assert i.__ne__ is not o.__ne__\n        assert i.__le__ is not o.__le__\n        assert i.__lt__ is not o.__lt__\n        assert i.__ge__ is not o.__ge__\n        assert i.__gt__ is not o.__gt__\n\n    def test_detect_auto_init(self, slots, frozen):\n        \"\"\"\n        If auto_detect=True and an __init__ exists, don't write one.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class CI:\n            x = attr.ib()\n\n            def __init__(self):\n                object.__setattr__(self, \"x\", 42)\n\n        assert 42 == CI().x\n\n    def test_detect_auto_repr(self, slots, frozen):\n        \"\"\"\n        If auto_detect=True and an __repr__ exists, don't write one.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __repr__(self):\n                return \"hi\"\n\n        assert \"hi\" == repr(C(42))\n\n    def test_hash_uses_eq(self, slots, frozen):\n        \"\"\"\n        If eq is passed in, then __hash__ should use the eq callable\n        to generate the hash code.\n        \"\"\"\n\n        @attr.s(slots=slots, frozen=frozen, hash=True)\n        class C:\n            x = attr.ib(eq=str)\n\n        @attr.s(slots=slots, frozen=frozen, hash=True)\n        class D:\n            x = attr.ib()\n\n        # These hashes should be the same because 1 is turned into\n        # string before hashing.\n        assert hash(C(\"1\")) == hash(C(1))\n        assert hash(D(\"1\")) != hash(D(1))\n\n    def test_detect_auto_hash(self, slots, frozen):\n        \"\"\"\n        If auto_detect=True and an __hash__ exists, don't write one.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __hash__(self):\n                return 0xC0FFEE\n\n        assert 0xC0FFEE == hash(C(42))\n\n    def test_detect_auto_eq(self, slots, frozen):\n        \"\"\"\n        If auto_detect=True and an __eq__ or an __ne__, exist, don't write one.\n        \"\"\"\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __eq__(self, o):\n                raise ValueError(\"worked\")\n\n        with pytest.raises(ValueError, match=\"worked\"):\n            C(1) == C(1)\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class D:\n            x = attr.ib()\n\n            def __ne__(self, o):\n                raise ValueError(\"worked\")\n\n        with pytest.raises(ValueError, match=\"worked\"):\n            D(1) != D(1)\n\n    def test_detect_auto_order(self, slots, frozen):\n        \"\"\"\n        If auto_detect=True and an __ge__, __gt__, __le__, or and __lt__ exist,\n        don't write one.\n\n        It's surprisingly difficult to test this programmatically, so we do it\n        by hand.\n        \"\"\"\n\n        def assert_not_set(cls, ex, meth_name):\n            __tracebackhide__ = True\n\n            a = getattr(cls, meth_name)\n            if meth_name == ex:\n                assert a == 42\n            else:\n                assert a is getattr(object, meth_name)\n\n        def assert_none_set(cls, ex):\n            __tracebackhide__ = True\n\n            for m in (\"le\", \"lt\", \"ge\", \"gt\"):\n                assert_not_set(cls, ex, \"__\" + m + \"__\")\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class LE:\n            __le__ = 42\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class LT:\n            __lt__ = 42\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class GE:\n            __ge__ = 42\n\n        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n        class GT:\n            __gt__ = 42\n\n        assert_none_set(LE, \"__le__\")\n        assert_none_set(LT, \"__lt__\")\n        assert_none_set(GE, \"__ge__\")\n        assert_none_set(GT, \"__gt__\")\n\n    def test_override_init(self, slots, frozen):\n        \"\"\"\n        If init=True is passed, ignore __init__.\n        \"\"\"\n\n        @attr.s(init=True, auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __init__(self):\n                pytest.fail(\"should not be called\")\n\n        assert C(1) == C(1)\n\n    def test_override_repr(self, slots, frozen):\n        \"\"\"\n        If repr=True is passed, ignore __repr__.\n        \"\"\"\n\n        @attr.s(repr=True, auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __repr__(self):\n                pytest.fail(\"should not be called\")\n\n        assert \"C(x=1)\" == repr(C(1))\n\n    def test_override_hash(self, slots, frozen):\n        \"\"\"\n        If hash=True is passed, ignore __hash__.\n        \"\"\"\n\n        @attr.s(hash=True, auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __hash__(self):\n                pytest.fail(\"should not be called\")\n\n        assert hash(C(1))\n\n    def test_override_eq(self, slots, frozen):\n        \"\"\"\n        If eq=True is passed, ignore __eq__ and __ne__.\n        \"\"\"\n\n        @attr.s(eq=True, auto_detect=True, slots=slots, frozen=frozen)\n        class C:\n            x = attr.ib()\n\n            def __eq__(self, o):\n                pytest.fail(\"should not be called\")\n\n            def __ne__(self, o):\n                pytest.fail(\"should not be called\")\n\n        assert C(1) == C(1)\n\n    @pytest.mark.parametrize(\n        (\"eq\", \"order\", \"cmp\"),\n        [\n            (True, None, None),\n            (True, True, None),\n            (None, True, None),\n            (None, None, True),\n        ],\n    )\n    def test_override_order(self, slots, frozen, eq, order, cmp):\n        \"\"\"\n        If order=True is passed, ignore __le__, __lt__, __gt__, __ge__.\n\n        eq=True and cmp=True both imply order=True so test it too.\n        \"\"\"\n\n        def meth(self, o):\n            pytest.fail(\"should not be called\")\n\n        @attr.s(\n            cmp=cmp,\n            order=order,\n            eq=eq,\n            auto_detect=True,\n            slots=slots,\n            frozen=frozen,\n        )\n        class C:\n            x = attr.ib()\n            __le__ = __lt__ = __gt__ = __ge__ = meth\n\n        assert C(1) < C(2)\n        assert C(1) <= C(2)\n        assert C(2) > C(1)\n        assert C(2) >= C(1)\n\n    @pytest.mark.parametrize(\"first\", [True, False])\n    def test_total_ordering(self, slots, first):\n        \"\"\"\n        functools.total_ordering works as expected if an order method and an eq\n        method are detected.\n\n        Ensure the order doesn't matter.\n        \"\"\"\n\n        class C:\n            x = attr.ib()\n            own_eq_called = attr.ib(default=False)\n            own_le_called = attr.ib(default=False)\n\n            def __eq__(self, o):\n                self.own_eq_called = True\n                return self.x == o.x\n\n            def __le__(self, o):\n                self.own_le_called = True\n                return self.x <= o.x\n\n        if first:\n            C = functools.total_ordering(\n                attr.s(auto_detect=True, slots=slots)(C)\n            )\n        else:\n            C = attr.s(auto_detect=True, slots=slots)(\n                functools.total_ordering(C)\n            )\n\n        c1, c2 = C(1), C(2)\n\n        assert c1 < c2\n        assert c1.own_le_called\n\n        c1, c2 = C(1), C(2)\n\n        assert c2 > c1\n        assert c2.own_le_called\n\n        c1, c2 = C(1), C(2)\n\n        assert c2 != c1\n        assert c1 == c1\n\n        assert c1.own_eq_called\n\n    def test_detects_setstate_getstate(self, slots):\n        \"\"\"\n        __getstate__ and __setstate__ are not overwritten if either is present.\n        \"\"\"\n\n        @attr.s(slots=slots, auto_detect=True)\n        class C:\n            def __getstate__(self):\n                return (\"hi\",)\n\n        assert getattr(object, \"__setstate__\", None) is getattr(\n            C, \"__setstate__\", None\n        )\n\n        @attr.s(slots=slots, auto_detect=True)\n        class C:\n            called = attr.ib(False)\n\n            def __setstate__(self, state):\n                self.called = True\n\n        i = C()\n\n        assert False is i.called\n\n        i.__setstate__(())\n\n        assert True is i.called\n        assert getattr(object, \"__getstate__\", None) is getattr(\n            C, \"__getstate__\", None\n        )\n\n    @pytest.mark.skipif(PY_3_10_PLUS, reason=\"Pre-3.10 only.\")\n    def test_match_args_pre_310(self):\n        \"\"\"\n        __match_args__ is not created on Python versions older than 3.10.\n        \"\"\"\n\n        @attr.s\n        class C:\n            a = attr.ib()\n\n        assert None is getattr(C, \"__match_args__\", None)\n\n\n@pytest.mark.skipif(\n    not PY_3_10_PLUS, reason=\"Structural pattern matching is 3.10+\"\n)\nclass TestMatchArgs:\n    \"\"\"\n    Tests for match_args and __match_args__ generation.\n    \"\"\"\n\n    def test_match_args(self):\n        \"\"\"\n        __match_args__ is created by default on Python 3.10.\n        \"\"\"\n\n        @attr.define\n        class C:\n            a = attr.field()\n\n        assert (\"a\",) == C.__match_args__\n\n    def test_explicit_match_args(self):\n        \"\"\"\n        A custom __match_args__ set is not overwritten.\n        \"\"\"\n\n        ma = ()\n\n        @attr.define\n        class C:\n            a = attr.field()\n            __match_args__ = ma\n\n        assert C(42).__match_args__ is ma\n\n    @pytest.mark.parametrize(\"match_args\", [True, False])\n    def test_match_args_attr_set(self, match_args):\n        \"\"\"\n        __match_args__ is set depending on match_args.\n        \"\"\"\n\n        @attr.define(match_args=match_args)\n        class C:\n            a = attr.field()\n\n        if match_args:\n            assert hasattr(C, \"__match_args__\")\n        else:\n            assert not hasattr(C, \"__match_args__\")\n\n    def test_match_args_kw_only(self):\n        \"\"\"\n        kw_only classes don't generate __match_args__.\n        kw_only fields are not included in __match_args__.\n        \"\"\"\n\n        @attr.define\n        class C:\n            a = attr.field(kw_only=True)\n            b = attr.field()\n\n        assert C.__match_args__ == (\"b\",)\n\n        @attr.define(kw_only=True)\n        class C:\n            a = attr.field()\n            b = attr.field()\n\n        assert C.__match_args__ == ()\n\n    def test_match_args_argument(self):\n        \"\"\"\n        match_args being False with inheritance.\n        \"\"\"\n\n        @attr.define(match_args=False)\n        class X:\n            a = attr.field()\n\n        assert \"__match_args__\" not in X.__dict__\n\n        @attr.define(match_args=False)\n        class Y:\n            a = attr.field()\n            __match_args__ = (\"b\",)\n\n        assert Y.__match_args__ == (\"b\",)\n\n        @attr.define(match_args=False)\n        class Z(Y):\n            z = attr.field()\n\n        assert Z.__match_args__ == (\"b\",)\n\n        @attr.define\n        class A:\n            a = attr.field()\n            z = attr.field()\n\n        @attr.define(match_args=False)\n        class B(A):\n            b = attr.field()\n\n        assert B.__match_args__ == (\"a\", \"z\")\n\n    def test_make_class(self):\n        \"\"\"\n        match_args generation with make_class.\n        \"\"\"\n\n        C1 = make_class(\"C1\", [\"a\", \"b\"])\n        assert (\"a\", \"b\") == C1.__match_args__\n\n        C1 = make_class(\"C1\", [\"a\", \"b\"], match_args=False)\n        assert not hasattr(C1, \"__match_args__\")\n\n        C1 = make_class(\"C1\", [\"a\", \"b\"], kw_only=True)\n        assert () == C1.__match_args__\n\n        C1 = make_class(\"C1\", {\"a\": attr.ib(kw_only=True), \"b\": attr.ib()})\n        assert (\"b\",) == C1.__match_args__\n", "tests/test_utils.py": "from .utils import simple_class\n\n\nclass TestSimpleClass:\n    \"\"\"\n    Tests for the testing helper function `make_class`.\n    \"\"\"\n\n    def test_returns_class(self):\n        \"\"\"\n        Returns a class object.\n        \"\"\"\n        assert type is simple_class().__class__\n\n    def test_returns_distinct_classes(self):\n        \"\"\"\n        Each call returns a completely new class.\n        \"\"\"\n        assert simple_class() is not simple_class()\n", "src/attr/filters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful filters for `attr.asdict`.\n\"\"\"\n\nfrom ._make import Attribute\n\n\ndef _split_what(what):\n    \"\"\"\n    Returns a tuple of `frozenset`s of classes and attributes.\n    \"\"\"\n    return (\n        frozenset(cls for cls in what if isinstance(cls, type)),\n        frozenset(cls for cls in what if isinstance(cls, str)),\n        frozenset(cls for cls in what if isinstance(cls, Attribute)),\n    )\n\n\ndef include(*what):\n    \"\"\"\n    Include *what*.\n\n    :param what: What to include.\n    :type what: `list` of classes `type`, field names `str` or\n        `attrs.Attribute`\\\\ s\n\n    :rtype: `callable`\n\n    .. versionchanged:: 23.1.0 Accept strings with field names.\n    \"\"\"\n    cls, names, attrs = _split_what(what)\n\n    def include_(attribute, value):\n        return (\n            value.__class__ in cls\n            or attribute.name in names\n            or attribute in attrs\n        )\n\n    return include_\n\n\ndef exclude(*what):\n    \"\"\"\n    Exclude *what*.\n\n    :param what: What to exclude.\n    :type what: `list` of classes `type`, field names `str` or\n        `attrs.Attribute`\\\\ s.\n\n    :rtype: `callable`\n\n    .. versionchanged:: 23.3.0 Accept field name string as input argument\n    \"\"\"\n    cls, names, attrs = _split_what(what)\n\n    def exclude_(attribute, value):\n        return not (\n            value.__class__ in cls\n            or attribute.name in names\n            or attribute in attrs\n        )\n\n    return exclude_\n", "src/attr/exceptions.py": "# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar\n\n\nclass FrozenError(AttributeError):\n    \"\"\"\n    A frozen/immutable instance or attribute have been attempted to be\n    modified.\n\n    It mirrors the behavior of ``namedtuples`` by using the same error message\n    and subclassing `AttributeError`.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    msg = \"can't set attribute\"\n    args: ClassVar[tuple[str]] = [msg]\n\n\nclass FrozenInstanceError(FrozenError):\n    \"\"\"\n    A frozen instance has been attempted to be modified.\n\n    .. versionadded:: 16.1.0\n    \"\"\"\n\n\nclass FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n\nclass AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An *attrs* function couldn't find an attribute that the user asked for.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n\n\nclass NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-*attrs* class has been passed into an *attrs* function.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n\n\nclass DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set when defining the field and is attempted to be reset\n    using the decorator.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n\n\nclass UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has a field without a type annotation.\n\n    .. versionadded:: 17.3.0\n    \"\"\"\n\n\nclass PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an *attrs* feature that requires a newer Python\n    version.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n\n\nclass NotCallableError(TypeError):\n    \"\"\"\n    A field requiring a callable has been set with a value that is not\n    callable.\n\n    .. versionadded:: 19.2.0\n    \"\"\"\n\n    def __init__(self, msg, value):\n        super(TypeError, self).__init__(msg, value)\n        self.msg = msg\n        self.value = value\n\n    def __str__(self):\n        return str(self.msg)\n", "src/attr/_make.py": "# SPDX-License-Identifier: MIT\n\nimport contextlib\nimport copy\nimport enum\nimport functools\nimport inspect\nimport itertools\nimport linecache\nimport sys\nimport types\nimport typing\n\nfrom operator import itemgetter\n\n# We need to import _compat itself in addition to the _compat members to avoid\n# having the thread-local in the globals here.\nfrom . import _compat, _config, setters\nfrom ._compat import (\n    PY_3_8_PLUS,\n    PY_3_10_PLUS,\n    _AnnotationExtractor,\n    get_generic_base,\n)\nfrom .exceptions import (\n    DefaultAlreadySetError,\n    FrozenInstanceError,\n    NotAnAttrsClassError,\n    UnannotatedAttributeError,\n)\n\n\n# This is used at least twice, so cache it here.\n_OBJ_SETATTR = object.__setattr__\n_INIT_CONVERTER_PAT = \"__attr_converter_%s\"\n_INIT_FACTORY_PAT = \"__attr_factory_%s\"\n_CLASSVAR_PREFIXES = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)\n_HASH_CACHE_FIELD = \"_attrs_cached_hash\"\n\n_EMPTY_METADATA_SINGLETON = types.MappingProxyType({})\n\n# Unique object for unequivocal getattr() defaults.\n_SENTINEL = object()\n\n_DEFAULT_ON_SETATTR = setters.pipe(setters.convert, setters.validate)\n\n\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when `None` is ambiguous.\n\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n\n    NOTHING = enum.auto()\n\n    def __repr__(self):\n        return \"NOTHING\"\n\n    def __bool__(self):\n        return False\n\n\nNOTHING = _Nothing.NOTHING\n\"\"\"\nSentinel to indicate the lack of a value when `None` is ambiguous.\n\"\"\"\n\n\nclass _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since `None`\n    is the default value for uncalculated hashes, whenever this is copied,\n    the copy's value for the hash should automatically reset.\n\n    See GH #613 for more details.\n    \"\"\"\n\n    def __reduce__(self, _none_constructor=type(None), _args=()):  # noqa: B008\n        return _none_constructor, _args\n\n\ndef attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n    alias=None,\n):\n    \"\"\"\n    Create a new attribute on a class.\n\n    ..  warning::\n\n        Does *not* do anything unless the class is also decorated with `attr.s`\n        / `attrs.define` / and so on!\n\n    Please consider using `attrs.field` in new code (``attr.ib`` will *never*\n    go away, though).\n\n    :param default: A value that is used if an *attrs*-generated ``__init__``\n        is used and no value is passed while instantiating or the attribute is\n        excluded using ``init=False``.\n\n        If the value is an instance of `attrs.Factory`, its callable will be\n        used to construct a new value (useful for mutable data types like lists\n        or dicts).\n\n        If a default is not set (or set manually to `attrs.NOTHING`), a value\n        *must* be supplied when instantiating; otherwise a `TypeError` will be\n        raised.\n\n        The default can also be set using decorator notation as shown below.\n\n        .. seealso:: `defaults`\n\n    :param ~typing.Callable factory: Syntactic sugar for\n        ``default=attr.Factory(factory)``.\n\n    :param ~typing.Callable | list[~typing.Callable] validator: Callable that\n        is called by *attrs*-generated ``__init__`` methods after the instance\n        has been initialized.  They receive the initialized instance, the\n        :func:`~attrs.Attribute`, and the passed value.\n\n        The return value is *not* inspected so the validator has to throw an\n        exception itself.\n\n        If a `list` is passed, its items are treated as validators and must all\n        pass.\n\n        Validators can be globally disabled and re-enabled using\n        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.\n\n        The validator can also be set using decorator notation as shown below.\n\n        .. seealso:: :ref:`validators`\n\n    :param bool | ~typing.Callable repr: Include this attribute in the\n        generated ``__repr__`` method. If `True`, include the attribute; if\n        `False`, omit it. By default, the built-in ``repr()`` function is used.\n        To override how the attribute value is formatted, pass a ``callable``\n        that takes a single value and returns a string. Note that the resulting\n        string is used as-is, which means it will be used directly *instead* of\n        calling ``repr()`` (the default).\n\n    :param bool | ~typing.Callable eq: If `True` (default), include this\n        attribute in the generated ``__eq__`` and ``__ne__`` methods that check\n        two instances for equality. To override how the attribute value is\n        compared, pass a callable that takes a single value and returns the\n        value to be compared.\n\n        .. seealso:: `comparison`\n\n    :param bool | ~typing.Callable order: If `True` (default), include this\n        attributes in the generated ``__lt__``, ``__le__``, ``__gt__`` and\n        ``__ge__`` methods. To override how the attribute value is ordered,\n        pass a callable that takes a single value and returns the value to be\n        ordered.\n\n        .. seealso:: `comparison`\n\n    :param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the\n        same value. Must not be mixed with *eq* or *order*.\n\n        .. seealso:: `comparison`\n    :type cmp: a `bool` or a `callable`.\n\n    :param bool | None hash: Include this attribute in the generated\n        ``__hash__`` method.  If `None` (default), mirror *eq*'s value.  This\n        is the correct behavior according the Python spec.  Setting this value\n        to anything else than `None` is *discouraged*.\n\n        .. seealso:: `hashing`\n    :param bool init: Include this attribute in the generated ``__init__``\n        method.  It is possible to set this to `False` and set a default value.\n        In that case this attributed is unconditionally initialized with the\n        specified default value or factory.\n\n        .. seealso:: `init`\n    :param typing.Callable converter: `callable` that is called by\n        *attrs*-generated ``__init__`` methods to convert attribute's value to\n        the desired format.  It is given the passed-in value, and the returned\n        value will be used as the new value of the attribute.  The value is\n        converted before being passed to the validator, if any.\n\n        .. seealso:: :ref:`converters`\n    :param dict | None metadata: An arbitrary mapping, to be used by\n        third-party components.  See `extending-metadata`.\n\n    :param type: The type of the attribute. Nowadays, the preferred method to\n        specify the type is using a variable annotation (see :pep:`526`). This\n        argument is provided for backward compatibility. Regardless of the\n        approach used, the type will be stored on ``Attribute.type``.\n\n        Please note that *attrs* doesn't do anything with this metadata by\n        itself. You can use it as part of your own code or for `static type\n        checking <types>`.\n    :param bool kw_only: Make this attribute keyword-only in the generated\n        ``__init__`` (if ``init`` is `False`, this parameter is ignored).\n    :param on_setattr: Allows to overwrite the *on_setattr* setting from\n        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n        Set to `attrs.setters.NO_OP` to run **no** `setattr` hooks for this\n        attribute -- regardless of the setting in `attr.s`.\n    :type on_setattr: ~typing.Callable | list[~typing.Callable] | None |\n        typing.Literal[attrs.setters.NO_OP]\n    :param str | None alias: Override this attribute's parameter name in the\n        generated ``__init__`` method. If left `None`, default to ``name``\n        stripped of leading underscores. See `private-attributes`.\n\n    .. versionadded:: 15.2.0 *convert*\n    .. versionadded:: 16.3.0 *metadata*\n    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n    .. versionchanged:: 17.1.0\n       *hash* is `None` and therefore mirrors *eq* by default.\n    .. versionadded:: 17.3.0 *type*\n    .. deprecated:: 17.4.0 *convert*\n    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n       *convert* to achieve consistency with other noun-based arguments.\n    .. versionadded:: 18.1.0\n       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionchanged:: 19.2.0 *convert* keyword argument removed.\n    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2\n    .. versionchanged:: 21.1.0\n       *eq*, *order*, and *cmp* also accept a custom callable\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    .. versionadded:: 22.2.0 *alias*\n    \"\"\"\n    eq, eq_key, order, order_key = _determine_attrib_eq_order(\n        cmp, eq, order, True\n    )\n\n    if hash is not None and hash is not True and hash is not False:\n        msg = \"Invalid value for hash.  Must be True, False, or None.\"\n        raise TypeError(msg)\n\n    if factory is not None:\n        if default is not NOTHING:\n            msg = (\n                \"The `default` and `factory` arguments are mutually exclusive.\"\n            )\n            raise ValueError(msg)\n        if not callable(factory):\n            msg = \"The `factory` argument must be a callable.\"\n            raise ValueError(msg)\n        default = Factory(factory)\n\n    if metadata is None:\n        metadata = {}\n\n    # Apply syntactic sugar by auto-wrapping.\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    if validator and isinstance(validator, (list, tuple)):\n        validator = and_(*validator)\n\n    if converter and isinstance(converter, (list, tuple)):\n        converter = pipe(*converter)\n\n    return _CountingAttr(\n        default=default,\n        validator=validator,\n        repr=repr,\n        cmp=None,\n        hash=hash,\n        init=init,\n        converter=converter,\n        metadata=metadata,\n        type=type,\n        kw_only=kw_only,\n        eq=eq,\n        eq_key=eq_key,\n        order=order,\n        order_key=order_key,\n        on_setattr=on_setattr,\n        alias=alias,\n    )\n\n\ndef _compile_and_eval(script, globs, locs=None, filename=\"\"):\n    \"\"\"\n    Evaluate the script with the given global (globs) and local (locs)\n    variables.\n    \"\"\"\n    bytecode = compile(script, filename, \"exec\")\n    eval(bytecode, globs, locs)\n\n\ndef _make_method(name, script, filename, globs, locals=None):\n    \"\"\"\n    Create the method with the script given and return the method object.\n    \"\"\"\n    locs = {} if locals is None else locals\n\n    # In order of debuggers like PDB being able to step through the code,\n    # we add a fake linecache entry.\n    count = 1\n    base_filename = filename\n    while True:\n        linecache_tuple = (\n            len(script),\n            None,\n            script.splitlines(True),\n            filename,\n        )\n        old_val = linecache.cache.setdefault(filename, linecache_tuple)\n        if old_val == linecache_tuple:\n            break\n\n        filename = f\"{base_filename[:-1]}-{count}>\"\n        count += 1\n\n    _compile_and_eval(script, globs, locs, filename)\n\n    return locs[name]\n\n\ndef _make_attr_tuple_class(cls_name, attr_names):\n    \"\"\"\n    Create a tuple subclass to hold `Attribute`s for an `attrs` class.\n\n    The subclass is a bare tuple with properties for names.\n\n    class MyClassAttributes(tuple):\n        __slots__ = ()\n        x = property(itemgetter(0))\n    \"\"\"\n    attr_class_name = f\"{cls_name}Attributes\"\n    attr_class_template = [\n        f\"class {attr_class_name}(tuple):\",\n        \"    __slots__ = ()\",\n    ]\n    if attr_names:\n        for i, attr_name in enumerate(attr_names):\n            attr_class_template.append(\n                f\"    {attr_name} = _attrs_property(_attrs_itemgetter({i}))\"\n            )\n    else:\n        attr_class_template.append(\"    pass\")\n    globs = {\"_attrs_itemgetter\": itemgetter, \"_attrs_property\": property}\n    _compile_and_eval(\"\\n\".join(attr_class_template), globs)\n    return globs[attr_class_name]\n\n\n# Tuple class for extracted attributes from a class definition.\n# `base_attrs` is a subset of `attrs`.\n_Attributes = _make_attr_tuple_class(\n    \"_Attributes\",\n    [\n        # all attributes to build dunder methods for\n        \"attrs\",\n        # attributes that have been inherited\n        \"base_attrs\",\n        # map inherited attributes to their originating classes\n        \"base_attrs_map\",\n    ],\n)\n\n\ndef _is_class_var(annot):\n    \"\"\"\n    Check whether *annot* is a typing.ClassVar.\n\n    The string comparison hack is used to avoid evaluating all string\n    annotations which would put attrs-based classes at a performance\n    disadvantage compared to plain old classes.\n    \"\"\"\n    annot = str(annot)\n\n    # Annotation can be quoted.\n    if annot.startswith((\"'\", '\"')) and annot.endswith((\"'\", '\"')):\n        annot = annot[1:-1]\n\n    return annot.startswith(_CLASSVAR_PREFIXES)\n\n\ndef _has_own_attribute(cls, attrib_name):\n    \"\"\"\n    Check whether *cls* defines *attrib_name* (and doesn't just inherit it).\n    \"\"\"\n    attr = getattr(cls, attrib_name, _SENTINEL)\n    if attr is _SENTINEL:\n        return False\n\n    for base_cls in cls.__mro__[1:]:\n        a = getattr(base_cls, attrib_name, None)\n        if attr is a:\n            return False\n\n    return True\n\n\ndef _get_annotations(cls):\n    \"\"\"\n    Get annotations for *cls*.\n    \"\"\"\n    if _has_own_attribute(cls, \"__annotations__\"):\n        return cls.__annotations__\n\n    return {}\n\n\ndef _collect_base_attrs(cls, taken_attr_names):\n    \"\"\"\n    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n    \"\"\"\n    base_attrs = []\n    base_attr_map = {}  # A dictionary of base attrs to their classes.\n\n    # Traverse the MRO and collect attributes.\n    for base_cls in reversed(cls.__mro__[1:-1]):\n        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n            if a.inherited or a.name in taken_attr_names:\n                continue\n\n            a = a.evolve(inherited=True)  # noqa: PLW2901\n            base_attrs.append(a)\n            base_attr_map[a.name] = base_cls\n\n    # For each name, only keep the freshest definition i.e. the furthest at the\n    # back.  base_attr_map is fine because it gets overwritten with every new\n    # instance.\n    filtered = []\n    seen = set()\n    for a in reversed(base_attrs):\n        if a.name in seen:\n            continue\n        filtered.insert(0, a)\n        seen.add(a.name)\n\n    return filtered, base_attr_map\n\n\ndef _collect_base_attrs_broken(cls, taken_attr_names):\n    \"\"\"\n    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n\n    N.B. *taken_attr_names* will be mutated.\n\n    Adhere to the old incorrect behavior.\n\n    Notably it collects from the front and considers inherited attributes which\n    leads to the buggy behavior reported in #428.\n    \"\"\"\n    base_attrs = []\n    base_attr_map = {}  # A dictionary of base attrs to their classes.\n\n    # Traverse the MRO and collect attributes.\n    for base_cls in cls.__mro__[1:-1]:\n        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n            if a.name in taken_attr_names:\n                continue\n\n            a = a.evolve(inherited=True)  # noqa: PLW2901\n            taken_attr_names.add(a.name)\n            base_attrs.append(a)\n            base_attr_map[a.name] = base_cls\n\n    return base_attrs, base_attr_map\n\n\ndef _transform_attrs(\n    cls, these, auto_attribs, kw_only, collect_by_mro, field_transformer\n):\n    \"\"\"\n    Transform all `_CountingAttr`s on a class into `Attribute`s.\n\n    If *these* is passed, use that and don't look for them on the class.\n\n    If *collect_by_mro* is True, collect them in the correct MRO order,\n    otherwise use the old -- incorrect -- order.  See #428.\n\n    Return an `_Attributes`.\n    \"\"\"\n    cd = cls.__dict__\n    anns = _get_annotations(cls)\n\n    if these is not None:\n        ca_list = list(these.items())\n    elif auto_attribs is True:\n        ca_names = {\n            name\n            for name, attr in cd.items()\n            if isinstance(attr, _CountingAttr)\n        }\n        ca_list = []\n        annot_names = set()\n        for attr_name, type in anns.items():\n            if _is_class_var(type):\n                continue\n            annot_names.add(attr_name)\n            a = cd.get(attr_name, NOTHING)\n\n            if not isinstance(a, _CountingAttr):\n                a = attrib() if a is NOTHING else attrib(default=a)\n            ca_list.append((attr_name, a))\n\n        unannotated = ca_names - annot_names\n        if len(unannotated) > 0:\n            raise UnannotatedAttributeError(\n                \"The following `attr.ib`s lack a type annotation: \"\n                + \", \".join(\n                    sorted(unannotated, key=lambda n: cd.get(n).counter)\n                )\n                + \".\"\n            )\n    else:\n        ca_list = sorted(\n            (\n                (name, attr)\n                for name, attr in cd.items()\n                if isinstance(attr, _CountingAttr)\n            ),\n            key=lambda e: e[1].counter,\n        )\n\n    own_attrs = [\n        Attribute.from_counting_attr(\n            name=attr_name, ca=ca, type=anns.get(attr_name)\n        )\n        for attr_name, ca in ca_list\n    ]\n\n    if collect_by_mro:\n        base_attrs, base_attr_map = _collect_base_attrs(\n            cls, {a.name for a in own_attrs}\n        )\n    else:\n        base_attrs, base_attr_map = _collect_base_attrs_broken(\n            cls, {a.name for a in own_attrs}\n        )\n\n    if kw_only:\n        own_attrs = [a.evolve(kw_only=True) for a in own_attrs]\n        base_attrs = [a.evolve(kw_only=True) for a in base_attrs]\n\n    attrs = base_attrs + own_attrs\n\n    # Mandatory vs non-mandatory attr order only matters when they are part of\n    # the __init__ signature and when they aren't kw_only (which are moved to\n    # the end and can be mandatory or non-mandatory in any order, as they will\n    # be specified as keyword args anyway). Check the order of those attrs:\n    had_default = False\n    for a in (a for a in attrs if a.init is not False and a.kw_only is False):\n        if had_default is True and a.default is NOTHING:\n            msg = f\"No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: {a!r}\"\n            raise ValueError(msg)\n\n        if had_default is False and a.default is not NOTHING:\n            had_default = True\n\n    if field_transformer is not None:\n        attrs = field_transformer(cls, attrs)\n\n    # Resolve default field alias after executing field_transformer.\n    # This allows field_transformer to differentiate between explicit vs\n    # default aliases and supply their own defaults.\n    attrs = [\n        a.evolve(alias=_default_init_alias_for(a.name)) if not a.alias else a\n        for a in attrs\n    ]\n\n    # Create AttrsClass *after* applying the field_transformer since it may\n    # add or remove attributes!\n    attr_names = [a.name for a in attrs]\n    AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)\n\n    return _Attributes((AttrsClass(attrs), base_attrs, base_attr_map))\n\n\ndef _make_cached_property_getattr(cached_properties, original_getattr, cls):\n    lines = [\n        # Wrapped to get `__class__` into closure cell for super()\n        # (It will be replaced with the newly constructed class after construction).\n        \"def wrapper(_cls):\",\n        \"    __class__ = _cls\",\n        \"    def __getattr__(self, item, cached_properties=cached_properties, original_getattr=original_getattr, _cached_setattr_get=_cached_setattr_get):\",\n        \"         func = cached_properties.get(item)\",\n        \"         if func is not None:\",\n        \"              result = func(self)\",\n        \"              _setter = _cached_setattr_get(self)\",\n        \"              _setter(item, result)\",\n        \"              return result\",\n    ]\n    if original_getattr is not None:\n        lines.append(\n            \"         return original_getattr(self, item)\",\n        )\n    else:\n        lines.extend(\n            [\n                \"         try:\",\n                \"             return super().__getattribute__(item)\",\n                \"         except AttributeError:\",\n                \"             if not hasattr(super(), '__getattr__'):\",\n                \"                 raise\",\n                \"             return super().__getattr__(item)\",\n                \"         original_error = f\\\"'{self.__class__.__name__}' object has no attribute '{item}'\\\"\",\n                \"         raise AttributeError(original_error)\",\n            ]\n        )\n\n    lines.extend(\n        [\n            \"    return __getattr__\",\n            \"__getattr__ = wrapper(_cls)\",\n        ]\n    )\n\n    unique_filename = _generate_unique_filename(cls, \"getattr\")\n\n    glob = {\n        \"cached_properties\": cached_properties,\n        \"_cached_setattr_get\": _OBJ_SETATTR.__get__,\n        \"original_getattr\": original_getattr,\n    }\n\n    return _make_method(\n        \"__getattr__\",\n        \"\\n\".join(lines),\n        unique_filename,\n        glob,\n        locals={\n            \"_cls\": cls,\n        },\n    )\n\n\ndef _frozen_setattrs(self, name, value):\n    \"\"\"\n    Attached to frozen classes as __setattr__.\n    \"\"\"\n    if isinstance(self, BaseException) and name in (\n        \"__cause__\",\n        \"__context__\",\n        \"__traceback__\",\n    ):\n        BaseException.__setattr__(self, name, value)\n        return\n\n    raise FrozenInstanceError()\n\n\ndef _frozen_delattrs(self, name):\n    \"\"\"\n    Attached to frozen classes as __delattr__.\n    \"\"\"\n    raise FrozenInstanceError()\n\n\nclass _ClassBuilder:\n    \"\"\"\n    Iteratively build *one* class.\n    \"\"\"\n\n    __slots__ = (\n        \"_attr_names\",\n        \"_attrs\",\n        \"_base_attr_map\",\n        \"_base_names\",\n        \"_cache_hash\",\n        \"_cls\",\n        \"_cls_dict\",\n        \"_delete_attribs\",\n        \"_frozen\",\n        \"_has_pre_init\",\n        \"_pre_init_has_args\",\n        \"_has_post_init\",\n        \"_is_exc\",\n        \"_on_setattr\",\n        \"_slots\",\n        \"_weakref_slot\",\n        \"_wrote_own_setattr\",\n        \"_has_custom_setattr\",\n    )\n\n    def __init__(\n        self,\n        cls,\n        these,\n        slots,\n        frozen,\n        weakref_slot,\n        getstate_setstate,\n        auto_attribs,\n        kw_only,\n        cache_hash,\n        is_exc,\n        collect_by_mro,\n        on_setattr,\n        has_custom_setattr,\n        field_transformer,\n    ):\n        attrs, base_attrs, base_map = _transform_attrs(\n            cls,\n            these,\n            auto_attribs,\n            kw_only,\n            collect_by_mro,\n            field_transformer,\n        )\n\n        self._cls = cls\n        self._cls_dict = dict(cls.__dict__) if slots else {}\n        self._attrs = attrs\n        self._base_names = {a.name for a in base_attrs}\n        self._base_attr_map = base_map\n        self._attr_names = tuple(a.name for a in attrs)\n        self._slots = slots\n        self._frozen = frozen\n        self._weakref_slot = weakref_slot\n        self._cache_hash = cache_hash\n        self._has_pre_init = bool(getattr(cls, \"__attrs_pre_init__\", False))\n        self._pre_init_has_args = False\n        if self._has_pre_init:\n            # Check if the pre init method has more arguments than just `self`\n            # We want to pass arguments if pre init expects arguments\n            pre_init_func = cls.__attrs_pre_init__\n            pre_init_signature = inspect.signature(pre_init_func)\n            self._pre_init_has_args = len(pre_init_signature.parameters) > 1\n        self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n        self._delete_attribs = not bool(these)\n        self._is_exc = is_exc\n        self._on_setattr = on_setattr\n\n        self._has_custom_setattr = has_custom_setattr\n        self._wrote_own_setattr = False\n\n        self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n\n        if frozen:\n            self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n            self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n\n            self._wrote_own_setattr = True\n        elif on_setattr in (\n            _DEFAULT_ON_SETATTR,\n            setters.validate,\n            setters.convert,\n        ):\n            has_validator = has_converter = False\n            for a in attrs:\n                if a.validator is not None:\n                    has_validator = True\n                if a.converter is not None:\n                    has_converter = True\n\n                if has_validator and has_converter:\n                    break\n            if (\n                (\n                    on_setattr == _DEFAULT_ON_SETATTR\n                    and not (has_validator or has_converter)\n                )\n                or (on_setattr == setters.validate and not has_validator)\n                or (on_setattr == setters.convert and not has_converter)\n            ):\n                # If class-level on_setattr is set to convert + validate, but\n                # there's no field to convert or validate, pretend like there's\n                # no on_setattr.\n                self._on_setattr = None\n\n        if getstate_setstate:\n            (\n                self._cls_dict[\"__getstate__\"],\n                self._cls_dict[\"__setstate__\"],\n            ) = self._make_getstate_setstate()\n\n    def __repr__(self):\n        return f\"<_ClassBuilder(cls={self._cls.__name__})>\"\n\n    if PY_3_10_PLUS:\n        import abc\n\n        def build_class(self):\n            \"\"\"\n            Finalize class based on the accumulated configuration.\n\n            Builder cannot be used after calling this method.\n            \"\"\"\n            if self._slots is True:\n                return self._create_slots_class()\n\n            return self.abc.update_abstractmethods(\n                self._patch_original_class()\n            )\n\n    else:\n\n        def build_class(self):\n            \"\"\"\n            Finalize class based on the accumulated configuration.\n\n            Builder cannot be used after calling this method.\n            \"\"\"\n            if self._slots is True:\n                return self._create_slots_class()\n\n            return self._patch_original_class()\n\n    def _patch_original_class(self):\n        \"\"\"\n        Apply accumulated methods and return the class.\n        \"\"\"\n        cls = self._cls\n        base_names = self._base_names\n\n        # Clean class of attribute definitions (`attr.ib()`s).\n        if self._delete_attribs:\n            for name in self._attr_names:\n                if (\n                    name not in base_names\n                    and getattr(cls, name, _SENTINEL) is not _SENTINEL\n                ):\n                    # An AttributeError can happen if a base class defines a\n                    # class variable and we want to set an attribute with the\n                    # same name by using only a type annotation.\n                    with contextlib.suppress(AttributeError):\n                        delattr(cls, name)\n\n        # Attach our dunder methods.\n        for name, value in self._cls_dict.items():\n            setattr(cls, name, value)\n\n        # If we've inherited an attrs __setattr__ and don't write our own,\n        # reset it to object's.\n        if not self._wrote_own_setattr and getattr(\n            cls, \"__attrs_own_setattr__\", False\n        ):\n            cls.__attrs_own_setattr__ = False\n\n            if not self._has_custom_setattr:\n                cls.__setattr__ = _OBJ_SETATTR\n\n        return cls\n\n    def _create_slots_class(self):\n        \"\"\"\n        Build and return a new class with a `__slots__` attribute.\n        \"\"\"\n        cd = {\n            k: v\n            for k, v in self._cls_dict.items()\n            if k not in (*tuple(self._attr_names), \"__dict__\", \"__weakref__\")\n        }\n\n        # If our class doesn't have its own implementation of __setattr__\n        # (either from the user or by us), check the bases, if one of them has\n        # an attrs-made __setattr__, that needs to be reset. We don't walk the\n        # MRO because we only care about our immediate base classes.\n        # XXX: This can be confused by subclassing a slotted attrs class with\n        # XXX: a non-attrs class and subclass the resulting class with an attrs\n        # XXX: class.  See `test_slotted_confused` for details.  For now that's\n        # XXX: OK with us.\n        if not self._wrote_own_setattr:\n            cd[\"__attrs_own_setattr__\"] = False\n\n            if not self._has_custom_setattr:\n                for base_cls in self._cls.__bases__:\n                    if base_cls.__dict__.get(\"__attrs_own_setattr__\", False):\n                        cd[\"__setattr__\"] = _OBJ_SETATTR\n                        break\n\n        # Traverse the MRO to collect existing slots\n        # and check for an existing __weakref__.\n        existing_slots = {}\n        weakref_inherited = False\n        for base_cls in self._cls.__mro__[1:-1]:\n            if base_cls.__dict__.get(\"__weakref__\", None) is not None:\n                weakref_inherited = True\n            existing_slots.update(\n                {\n                    name: getattr(base_cls, name)\n                    for name in getattr(base_cls, \"__slots__\", [])\n                }\n            )\n\n        base_names = set(self._base_names)\n\n        names = self._attr_names\n        if (\n            self._weakref_slot\n            and \"__weakref__\" not in getattr(self._cls, \"__slots__\", ())\n            and \"__weakref__\" not in names\n            and not weakref_inherited\n        ):\n            names += (\"__weakref__\",)\n\n        if PY_3_8_PLUS:\n            cached_properties = {\n                name: cached_property.func\n                for name, cached_property in cd.items()\n                if isinstance(cached_property, functools.cached_property)\n            }\n        else:\n            # `functools.cached_property` was introduced in 3.8.\n            # So can't be used before this.\n            cached_properties = {}\n\n        # Collect methods with a `__class__` reference that are shadowed in the new class.\n        # To know to update them.\n        additional_closure_functions_to_update = []\n        if cached_properties:\n            # Add cached properties to names for slotting.\n            names += tuple(cached_properties.keys())\n\n            for name in cached_properties:\n                # Clear out function from class to avoid clashing.\n                del cd[name]\n\n            additional_closure_functions_to_update.extend(\n                cached_properties.values()\n            )\n\n            class_annotations = _get_annotations(self._cls)\n            for name, func in cached_properties.items():\n                annotation = inspect.signature(func).return_annotation\n                if annotation is not inspect.Parameter.empty:\n                    class_annotations[name] = annotation\n\n            original_getattr = cd.get(\"__getattr__\")\n            if original_getattr is not None:\n                additional_closure_functions_to_update.append(original_getattr)\n\n            cd[\"__getattr__\"] = _make_cached_property_getattr(\n                cached_properties, original_getattr, self._cls\n            )\n\n        # We only add the names of attributes that aren't inherited.\n        # Setting __slots__ to inherited attributes wastes memory.\n        slot_names = [name for name in names if name not in base_names]\n\n        # There are slots for attributes from current class\n        # that are defined in parent classes.\n        # As their descriptors may be overridden by a child class,\n        # we collect them here and update the class dict\n        reused_slots = {\n            slot: slot_descriptor\n            for slot, slot_descriptor in existing_slots.items()\n            if slot in slot_names\n        }\n        slot_names = [name for name in slot_names if name not in reused_slots]\n        cd.update(reused_slots)\n        if self._cache_hash:\n            slot_names.append(_HASH_CACHE_FIELD)\n\n        cd[\"__slots__\"] = tuple(slot_names)\n\n        cd[\"__qualname__\"] = self._cls.__qualname__\n\n        # Create new class based on old class and our methods.\n        cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)\n\n        # The following is a fix for\n        # <https://github.com/python-attrs/attrs/issues/102>.\n        # If a method mentions `__class__` or uses the no-arg super(), the\n        # compiler will bake a reference to the class in the method itself\n        # as `method.__closure__`.  Since we replace the class with a\n        # clone, we rewrite these references so it keeps working.\n        for item in itertools.chain(\n            cls.__dict__.values(), additional_closure_functions_to_update\n        ):\n            if isinstance(item, (classmethod, staticmethod)):\n                # Class- and staticmethods hide their functions inside.\n                # These might need to be rewritten as well.\n                closure_cells = getattr(item.__func__, \"__closure__\", None)\n            elif isinstance(item, property):\n                # Workaround for property `super()` shortcut (PY3-only).\n                # There is no universal way for other descriptors.\n                closure_cells = getattr(item.fget, \"__closure__\", None)\n            else:\n                closure_cells = getattr(item, \"__closure__\", None)\n\n            if not closure_cells:  # Catch None or the empty list.\n                continue\n            for cell in closure_cells:\n                try:\n                    match = cell.cell_contents is self._cls\n                except ValueError:  # noqa: PERF203\n                    # ValueError: Cell is empty\n                    pass\n                else:\n                    if match:\n                        cell.cell_contents = cls\n        return cls\n\n    def add_repr(self, ns):\n        self._cls_dict[\"__repr__\"] = self._add_method_dunders(\n            _make_repr(self._attrs, ns, self._cls)\n        )\n        return self\n\n    def add_str(self):\n        repr = self._cls_dict.get(\"__repr__\")\n        if repr is None:\n            msg = \"__str__ can only be generated if a __repr__ exists.\"\n            raise ValueError(msg)\n\n        def __str__(self):\n            return self.__repr__()\n\n        self._cls_dict[\"__str__\"] = self._add_method_dunders(__str__)\n        return self\n\n    def _make_getstate_setstate(self):\n        \"\"\"\n        Create custom __setstate__ and __getstate__ methods.\n        \"\"\"\n        # __weakref__ is not writable.\n        state_attr_names = tuple(\n            an for an in self._attr_names if an != \"__weakref__\"\n        )\n\n        def slots_getstate(self):\n            \"\"\"\n            Automatically created by attrs.\n            \"\"\"\n            return {name: getattr(self, name) for name in state_attr_names}\n\n        hash_caching_enabled = self._cache_hash\n\n        def slots_setstate(self, state):\n            \"\"\"\n            Automatically created by attrs.\n            \"\"\"\n            __bound_setattr = _OBJ_SETATTR.__get__(self)\n            if isinstance(state, tuple):\n                # Backward compatibility with attrs instances pickled with\n                # attrs versions before v22.2.0 which stored tuples.\n                for name, value in zip(state_attr_names, state):\n                    __bound_setattr(name, value)\n            else:\n                for name in state_attr_names:\n                    if name in state:\n                        __bound_setattr(name, state[name])\n\n            # The hash code cache is not included when the object is\n            # serialized, but it still needs to be initialized to None to\n            # indicate that the first call to __hash__ should be a cache\n            # miss.\n            if hash_caching_enabled:\n                __bound_setattr(_HASH_CACHE_FIELD, None)\n\n        return slots_getstate, slots_setstate\n\n    def make_unhashable(self):\n        self._cls_dict[\"__hash__\"] = None\n        return self\n\n    def add_hash(self):\n        self._cls_dict[\"__hash__\"] = self._add_method_dunders(\n            _make_hash(\n                self._cls,\n                self._attrs,\n                frozen=self._frozen,\n                cache_hash=self._cache_hash,\n            )\n        )\n\n        return self\n\n    def add_init(self):\n        self._cls_dict[\"__init__\"] = self._add_method_dunders(\n            _make_init(\n                self._cls,\n                self._attrs,\n                self._has_pre_init,\n                self._pre_init_has_args,\n                self._has_post_init,\n                self._frozen,\n                self._slots,\n                self._cache_hash,\n                self._base_attr_map,\n                self._is_exc,\n                self._on_setattr,\n                attrs_init=False,\n            )\n        )\n\n        return self\n\n    def add_match_args(self):\n        self._cls_dict[\"__match_args__\"] = tuple(\n            field.name\n            for field in self._attrs\n            if field.init and not field.kw_only\n        )\n\n    def add_attrs_init(self):\n        self._cls_dict[\"__attrs_init__\"] = self._add_method_dunders(\n            _make_init(\n                self._cls,\n                self._attrs,\n                self._has_pre_init,\n                self._pre_init_has_args,\n                self._has_post_init,\n                self._frozen,\n                self._slots,\n                self._cache_hash,\n                self._base_attr_map,\n                self._is_exc,\n                self._on_setattr,\n                attrs_init=True,\n            )\n        )\n\n        return self\n\n    def add_eq(self):\n        cd = self._cls_dict\n\n        cd[\"__eq__\"] = self._add_method_dunders(\n            _make_eq(self._cls, self._attrs)\n        )\n        cd[\"__ne__\"] = self._add_method_dunders(_make_ne())\n\n        return self\n\n    def add_order(self):\n        cd = self._cls_dict\n\n        cd[\"__lt__\"], cd[\"__le__\"], cd[\"__gt__\"], cd[\"__ge__\"] = (\n            self._add_method_dunders(meth)\n            for meth in _make_order(self._cls, self._attrs)\n        )\n\n        return self\n\n    def add_setattr(self):\n        if self._frozen:\n            return self\n\n        sa_attrs = {}\n        for a in self._attrs:\n            on_setattr = a.on_setattr or self._on_setattr\n            if on_setattr and on_setattr is not setters.NO_OP:\n                sa_attrs[a.name] = a, on_setattr\n\n        if not sa_attrs:\n            return self\n\n        if self._has_custom_setattr:\n            # We need to write a __setattr__ but there already is one!\n            msg = \"Can't combine custom __setattr__ with on_setattr hooks.\"\n            raise ValueError(msg)\n\n        # docstring comes from _add_method_dunders\n        def __setattr__(self, name, val):\n            try:\n                a, hook = sa_attrs[name]\n            except KeyError:\n                nval = val\n            else:\n                nval = hook(self, a, val)\n\n            _OBJ_SETATTR(self, name, nval)\n\n        self._cls_dict[\"__attrs_own_setattr__\"] = True\n        self._cls_dict[\"__setattr__\"] = self._add_method_dunders(__setattr__)\n        self._wrote_own_setattr = True\n\n        return self\n\n    def _add_method_dunders(self, method):\n        \"\"\"\n        Add __module__ and __qualname__ to a *method* if possible.\n        \"\"\"\n        with contextlib.suppress(AttributeError):\n            method.__module__ = self._cls.__module__\n\n        with contextlib.suppress(AttributeError):\n            method.__qualname__ = f\"{self._cls.__qualname__}.{method.__name__}\"\n\n        with contextlib.suppress(AttributeError):\n            method.__doc__ = (\n                \"Method generated by attrs for class \"\n                f\"{self._cls.__qualname__}.\"\n            )\n\n        return method\n\n\ndef _determine_attrs_eq_order(cmp, eq, order, default_eq):\n    \"\"\"\n    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n    values of eq and order.  If *eq* is None, set it to *default_eq*.\n    \"\"\"\n    if cmp is not None and any((eq is not None, order is not None)):\n        msg = \"Don't mix `cmp` with `eq' and `order`.\"\n        raise ValueError(msg)\n\n    # cmp takes precedence due to bw-compatibility.\n    if cmp is not None:\n        return cmp, cmp\n\n    # If left None, equality is set to the specified default and ordering\n    # mirrors equality.\n    if eq is None:\n        eq = default_eq\n\n    if order is None:\n        order = eq\n\n    if eq is False and order is True:\n        msg = \"`order` can only be True if `eq` is True too.\"\n        raise ValueError(msg)\n\n    return eq, order\n\n\ndef _determine_attrib_eq_order(cmp, eq, order, default_eq):\n    \"\"\"\n    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n    values of eq and order.  If *eq* is None, set it to *default_eq*.\n    \"\"\"\n    if cmp is not None and any((eq is not None, order is not None)):\n        msg = \"Don't mix `cmp` with `eq' and `order`.\"\n        raise ValueError(msg)\n\n    def decide_callable_or_boolean(value):\n        \"\"\"\n        Decide whether a key function is used.\n        \"\"\"\n        if callable(value):\n            value, key = True, value\n        else:\n            key = None\n        return value, key\n\n    # cmp takes precedence due to bw-compatibility.\n    if cmp is not None:\n        cmp, cmp_key = decide_callable_or_boolean(cmp)\n        return cmp, cmp_key, cmp, cmp_key\n\n    # If left None, equality is set to the specified default and ordering\n    # mirrors equality.\n    if eq is None:\n        eq, eq_key = default_eq, None\n    else:\n        eq, eq_key = decide_callable_or_boolean(eq)\n\n    if order is None:\n        order, order_key = eq, eq_key\n    else:\n        order, order_key = decide_callable_or_boolean(order)\n\n    if eq is False and order is True:\n        msg = \"`order` can only be True if `eq` is True too.\"\n        raise ValueError(msg)\n\n    return eq, eq_key, order, order_key\n\n\ndef _determine_whether_to_implement(\n    cls, flag, auto_detect, dunders, default=True\n):\n    \"\"\"\n    Check whether we should implement a set of methods for *cls*.\n\n    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the\n    same as passed into @attr.s and *dunders* is a tuple of attribute names\n    whose presence signal that the user has implemented it themselves.\n\n    Return *default* if no reason for either for or against is found.\n    \"\"\"\n    if flag is True or flag is False:\n        return flag\n\n    if flag is None and auto_detect is False:\n        return default\n\n    # Logically, flag is None and auto_detect is True here.\n    for dunder in dunders:\n        if _has_own_attribute(cls, dunder):\n            return False\n\n    return default\n\n\ndef attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=False,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=False,\n    eq=None,\n    order=None,\n    auto_detect=False,\n    collect_by_mro=False,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n    match_args=True,\n    unsafe_hash=None,\n):\n    r\"\"\"\n    A class decorator that adds :term:`dunder methods` according to the\n    specified attributes using `attr.ib` or the *these* argument.\n\n    Consider using `attrs.define` / `attrs.frozen` in new code (``attr.s`` will\n    *never* go away, though).\n\n    :param these: A dictionary of name to `attr.ib` mappings.  This is useful\n        to avoid the definition of your attributes within the class body\n        because you can't (for example, if you want to add ``__repr__`` methods\n        to Django models) or don't want to.\n\n        If *these* is not `None`, *attrs* will *not* search the class body\n        for attributes and will *not* remove any attributes from it.\n\n        The order is deduced from the order of the attributes inside *these*.\n\n    :type these: `dict` of `str` to `attr.ib`\n\n    :param str repr_ns: When using nested classes, there was no way in Python 2\n        to automatically detect that.  This argument allows to set a custom\n        name for a more meaningful ``repr`` output.  This argument\n        is pointless in Python 3 and is therefore deprecated.\n    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,\n        *order*, and *hash* arguments explicitly, assume they are set to\n        `True` **unless any** of the involved methods for one of the\n        arguments is implemented in the *current* class (meaning, it is *not*\n        inherited from some base class).\n\n        So, for example by implementing ``__eq__`` on a class yourself, *attrs*\n        will deduce ``eq=False`` and will create *neither* ``__eq__`` *nor*\n        ``__ne__`` (but Python classes come with a sensible ``__ne__`` by\n        default, so it *should* be enough to only implement ``__eq__`` in most\n        cases).\n\n        .. warning::\n\n           If you prevent *attrs* from creating the ordering methods for you\n           (``order=False``, for example, by implementing ``__le__``), it\n           becomes *your* responsibility to make sure its ordering is sound.\n           The best way is to use the `functools.total_ordering` decorator.\n\n        Passing `True` or `False` to *init*, *repr*, *eq*, *order*, *cmp*,\n        or *hash* overrides whatever *auto_detect* would determine.\n\n    :param bool repr: Create a ``__repr__`` method with a human readable\n        representation of *attrs* attributes..\n    :param bool str: Create a ``__str__`` method that is identical to\n        ``__repr__``.  This is usually not necessary except for `Exception`\\ s.\n    :param bool | None eq: If `True` or `None` (default), add ``__eq__``\n        and ``__ne__`` methods that check two instances for equality.\n\n        They compare the instances as if they were tuples of their *attrs*\n        attributes if and only if the types of both classes are *identical*!\n\n        .. seealso:: `comparison`\n    :param bool | None order: If `True`, add ``__lt__``, ``__le__``,\n        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n        allow instances to be ordered. If `None` (default) mirror value of\n        *eq*.\n\n        .. seealso:: `comparison`\n    :param bool | None cmp: Setting *cmp* is equivalent to setting *eq* and\n        *order* to the same value. Must not be mixed with *eq* or *order*.\n\n        .. seealso:: `comparison`\n    :param bool | None unsafe_hash: If `None` (default), the ``__hash__``\n        method is generated according how *eq* and *frozen* are set.\n\n        1. If *both* are True, *attrs* will generate a ``__hash__`` for you.\n        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n           None, marking it unhashable (which it is).\n        3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n           ``__hash__`` method of the base class will be used (if base class is\n           ``object``, this means it will fall back to id-based hashing.).\n\n        Although not recommended, you can decide for yourself and force *attrs*\n        to create one (for example, if the class is immutable even though you\n        didn't freeze it programmatically) by passing `True` or not.  Both of\n        these cases are rather special and should be used carefully.\n\n        .. seealso::\n\n           - Our documentation on `hashing`,\n           - Python's documentation on `object.__hash__`,\n           - and the `GitHub issue that led to the default \\ behavior\n             <https://github.com/python-attrs/attrs/issues/136>`_ for more\n             details.\n\n    :param bool | None hash: Alias for *unsafe_hash*. *unsafe_hash* takes\n        precedence.\n    :param bool init: Create a ``__init__`` method that initializes the *attrs*\n        attributes. Leading underscores are stripped for the argument name\n        (unless an alias is set on the attribute). If a ``__attrs_pre_init__``\n        method exists on the class, it will be called before the class is\n        initialized. If a ``__attrs_post_init__`` method exists on the class,\n        it will be called after the class is fully initialized.\n\n        If ``init`` is `False`, an ``__attrs_init__`` method will be injected\n        instead. This allows you to define a custom ``__init__`` method that\n        can do pre-init work such as ``super().__init__()``, and then call\n        ``__attrs_init__()`` and ``__attrs_post_init__()``.\n\n        .. seealso:: `init`\n    :param bool slots: Create a :term:`slotted class <slotted classes>` that's\n        more memory-efficient. Slotted classes are generally superior to the\n        default dict classes, but have some gotchas you should know about, so\n        we encourage you to read the :term:`glossary entry <slotted classes>`.\n    :param bool frozen: Make instances immutable after initialization.  If\n        someone attempts to modify a frozen instance,\n        `attrs.exceptions.FrozenInstanceError` is raised.\n\n        .. note::\n\n            1. This is achieved by installing a custom ``__setattr__`` method\n               on your class, so you can't implement your own.\n\n            2. True immutability is impossible in Python.\n\n            3. This *does* have a minor a runtime performance `impact\n               <how-frozen>` when initializing new instances.  In other words:\n               ``__init__`` is slightly slower with ``frozen=True``.\n\n            4. If a class is frozen, you cannot modify ``self`` in\n               ``__attrs_post_init__`` or a self-written ``__init__``. You can\n               circumvent that limitation by using ``object.__setattr__(self,\n               \"attribute_name\", value)``.\n\n            5. Subclasses of a frozen class are frozen too.\n\n    :param bool weakref_slot: Make instances weak-referenceable.  This has no\n        effect unless ``slots`` is also enabled.\n    :param bool auto_attribs: If `True`, collect :pep:`526`-annotated\n        attributes from the class body.\n\n        In this case, you **must** annotate every field.  If *attrs* encounters\n        a field that is set to an `attr.ib` but lacks a type annotation, an\n        `attrs.exceptions.UnannotatedAttributeError` is raised.  Use\n        ``field_name: typing.Any = attr.ib(...)`` if you don't want to set a\n        type.\n\n        If you assign a value to those attributes (for example, ``x: int =\n        42``), that value becomes the default value like if it were passed\n        using ``attr.ib(default=42)``.  Passing an instance of `attrs.Factory`\n        also works as expected in most cases (see warning below).\n\n        Attributes annotated as `typing.ClassVar`, and attributes that are\n        neither annotated nor set to an `attr.ib` are **ignored**.\n\n        .. warning::\n\n           For features that use the attribute name to create decorators (for\n           example, :ref:`validators <validators>`), you still *must* assign\n           `attr.ib` to them. Otherwise Python will either not find the name or\n           try to use the default value to call, for example, ``validator`` on\n           it.\n\n    :param bool kw_only: Make all attributes keyword-only in the generated\n        ``__init__`` (if *init* is `False`, this parameter is ignored).\n    :param bool cache_hash: Ensure that the object's hash code is computed only\n        once and stored on the object.  If this is set to `True`, hashing\n        must be either explicitly or implicitly enabled for this class.  If the\n        hash code is cached, avoid any reassignments of fields involved in hash\n        code computation or mutations of the objects those fields point to\n        after object creation.  If such changes occur, the behavior of the\n        object's hash code is undefined.\n    :param bool auto_exc: If the class subclasses `BaseException` (which\n        implicitly includes any subclass of any exception), the following\n        happens to behave like a well-behaved Python exceptions class:\n\n        - the values for *eq*, *order*, and *hash* are ignored and the\n          instances compare and hash by the instance's ids (N.B. *attrs* will\n          *not* remove existing implementations of ``__hash__`` or the equality\n          methods. It just won't add own ones.),\n        - all attributes that are either passed into ``__init__`` or have a\n          default value are additionally available as a tuple in the ``args``\n          attribute,\n        - the value of *str* is ignored leaving ``__str__`` to base classes.\n    :param bool collect_by_mro: Setting this to `True` fixes the way *attrs*\n       collects attributes from base classes.  The default behavior is\n       incorrect in certain cases of multiple inheritance.  It should be on by\n       default, but is kept off for backwards-compatibility.\n\n       .. seealso::\n          Issue `#428 <https://github.com/python-attrs/attrs/issues/428>`_\n\n    :param bool | None getstate_setstate:\n       .. note::\n          This is usually only interesting for slotted classes and you should\n          probably just set *auto_detect* to `True`.\n\n       If `True`, ``__getstate__`` and ``__setstate__`` are generated and\n       attached to the class. This is necessary for slotted classes to be\n       pickleable. If left `None`, it's `True` by default for slotted classes\n       and `False` for dict classes.\n\n       If *auto_detect* is `True`, and *getstate_setstate* is left `None`, and\n       **either** ``__getstate__`` or ``__setstate__`` is detected directly on\n       the class (meaning: not inherited), it is set to `False` (this is\n       usually what you want).\n\n    :param on_setattr: A callable that is run whenever the user attempts to set\n        an attribute (either by assignment like ``i.x = 42`` or by using\n        `setattr` like ``setattr(i, \"x\", 42)``). It receives the same arguments\n        as validators: the instance, the attribute that is being modified, and\n        the new value.\n\n        If no exception is raised, the attribute is set to the return value of\n        the callable.\n\n        If a list of callables is passed, they're automatically wrapped in an\n        `attrs.setters.pipe`.\n    :type on_setattr: ~typing.Callable | list[~typing.Callable] | None |\n        typing.Literal[attrs.setters.NO_OP]\n\n    :param ~typing.Callable | None field_transformer:\n        A function that is called with the original class object and all fields\n        right before *attrs* finalizes the class.  You can use this, for\n        example, to automatically add converters or validators to fields based\n        on their types.\n\n        .. seealso:: `transform-fields`\n\n    :param bool match_args:\n        If `True` (default), set ``__match_args__`` on the class to support\n        :pep:`634` (*Structural Pattern Matching*). It is a tuple of all\n        non-keyword-only ``__init__`` parameter names on Python 3.10 and later.\n        Ignored on older Python versions.\n\n    .. versionadded:: 16.0.0 *slots*\n    .. versionadded:: 16.1.0 *frozen*\n    .. versionadded:: 16.3.0 *str*\n    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.\n    .. versionchanged:: 17.1.0\n       *hash* supports `None` as value which is also the default now.\n    .. versionadded:: 17.3.0 *auto_attribs*\n    .. versionchanged:: 18.1.0\n       If *these* is passed, no attributes are deleted from the class body.\n    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n    .. versionadded:: 18.2.0 *weakref_slot*\n    .. deprecated:: 18.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a\n       `DeprecationWarning` if the classes compared are subclasses of\n       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n       to each other.\n    .. versionchanged:: 19.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider\n       subclasses comparable anymore.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionadded:: 18.2.0 *cache_hash*\n    .. versionadded:: 19.1.0 *auto_exc*\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *auto_detect*\n    .. versionadded:: 20.1.0 *collect_by_mro*\n    .. versionadded:: 20.1.0 *getstate_setstate*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionadded:: 20.3.0 *field_transformer*\n    .. versionchanged:: 21.1.0\n       ``init=False`` injects ``__attrs_init__``\n    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    .. versionadded:: 21.3.0 *match_args*\n    .. versionadded:: 22.2.0\n       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).\n    .. deprecated:: 24.1.0 *repr_ns*\n    \"\"\"\n    if repr_ns is not None:\n        import warnings\n\n        warnings.warn(\n            DeprecationWarning(\n                \"The `repr_ns` argument is deprecated and will be removed in or after April 2025.\"\n            ),\n            stacklevel=2,\n        )\n\n    eq_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)\n\n    # unsafe_hash takes precedence due to PEP 681.\n    if unsafe_hash is not None:\n        hash = unsafe_hash\n\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    def wrap(cls):\n        is_frozen = frozen or _has_frozen_base_class(cls)\n        is_exc = auto_exc is True and issubclass(cls, BaseException)\n        has_own_setattr = auto_detect and _has_own_attribute(\n            cls, \"__setattr__\"\n        )\n\n        if has_own_setattr and is_frozen:\n            msg = \"Can't freeze a class with a custom __setattr__.\"\n            raise ValueError(msg)\n\n        builder = _ClassBuilder(\n            cls,\n            these,\n            slots,\n            is_frozen,\n            weakref_slot,\n            _determine_whether_to_implement(\n                cls,\n                getstate_setstate,\n                auto_detect,\n                (\"__getstate__\", \"__setstate__\"),\n                default=slots,\n            ),\n            auto_attribs,\n            kw_only,\n            cache_hash,\n            is_exc,\n            collect_by_mro,\n            on_setattr,\n            has_own_setattr,\n            field_transformer,\n        )\n        if _determine_whether_to_implement(\n            cls, repr, auto_detect, (\"__repr__\",)\n        ):\n            builder.add_repr(repr_ns)\n        if str is True:\n            builder.add_str()\n\n        eq = _determine_whether_to_implement(\n            cls, eq_, auto_detect, (\"__eq__\", \"__ne__\")\n        )\n        if not is_exc and eq is True:\n            builder.add_eq()\n        if not is_exc and _determine_whether_to_implement(\n            cls, order_, auto_detect, (\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\")\n        ):\n            builder.add_order()\n\n        builder.add_setattr()\n\n        nonlocal hash\n        if (\n            hash is None\n            and auto_detect is True\n            and _has_own_attribute(cls, \"__hash__\")\n        ):\n            hash = False\n\n        if hash is not True and hash is not False and hash is not None:\n            # Can't use `hash in` because 1 == True for example.\n            msg = \"Invalid value for hash.  Must be True, False, or None.\"\n            raise TypeError(msg)\n\n        if hash is False or (hash is None and eq is False) or is_exc:\n            # Don't do anything. Should fall back to __object__'s __hash__\n            # which is by id.\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.\"\n                raise TypeError(msg)\n        elif hash is True or (\n            hash is None and eq is True and is_frozen is True\n        ):\n            # Build a __hash__ if told so, or if it's safe.\n            builder.add_hash()\n        else:\n            # Raise TypeError on attempts to hash.\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.\"\n                raise TypeError(msg)\n            builder.make_unhashable()\n\n        if _determine_whether_to_implement(\n            cls, init, auto_detect, (\"__init__\",)\n        ):\n            builder.add_init()\n        else:\n            builder.add_attrs_init()\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, init must be True.\"\n                raise TypeError(msg)\n\n        if (\n            PY_3_10_PLUS\n            and match_args\n            and not _has_own_attribute(cls, \"__match_args__\")\n        ):\n            builder.add_match_args()\n\n        return builder.build_class()\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but `None` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n\n    return wrap(maybe_cls)\n\n\n_attrs = attrs\n\"\"\"\nInternal alias so we can use it in functions that take an argument called\n*attrs*.\n\"\"\"\n\n\ndef _has_frozen_base_class(cls):\n    \"\"\"\n    Check whether *cls* has a frozen ancestor by looking at its\n    __setattr__.\n    \"\"\"\n    return cls.__setattr__ is _frozen_setattrs\n\n\ndef _generate_unique_filename(cls, func_name):\n    \"\"\"\n    Create a \"filename\" suitable for a function being generated.\n    \"\"\"\n    return (\n        f\"<attrs generated {func_name} {cls.__module__}.\"\n        f\"{getattr(cls, '__qualname__', cls.__name__)}>\"\n    )\n\n\ndef _make_hash(cls, attrs, frozen, cache_hash):\n    attrs = tuple(\n        a for a in attrs if a.hash is True or (a.hash is None and a.eq is True)\n    )\n\n    tab = \"        \"\n\n    unique_filename = _generate_unique_filename(cls, \"hash\")\n    type_hash = hash(unique_filename)\n    # If eq is custom generated, we need to include the functions in globs\n    globs = {}\n\n    hash_def = \"def __hash__(self\"\n    hash_func = \"hash((\"\n    closing_braces = \"))\"\n    if not cache_hash:\n        hash_def += \"):\"\n    else:\n        hash_def += \", *\"\n\n        hash_def += \", _cache_wrapper=__import__('attr._make')._make._CacheHashWrapper):\"\n        hash_func = \"_cache_wrapper(\" + hash_func\n        closing_braces += \")\"\n\n    method_lines = [hash_def]\n\n    def append_hash_computation_lines(prefix, indent):\n        \"\"\"\n        Generate the code for actually computing the hash code.\n        Below this will either be returned directly or used to compute\n        a value which is then cached, depending on the value of cache_hash\n        \"\"\"\n\n        method_lines.extend(\n            [\n                indent + prefix + hash_func,\n                indent + f\"        {type_hash},\",\n            ]\n        )\n\n        for a in attrs:\n            if a.eq_key:\n                cmp_name = f\"_{a.name}_key\"\n                globs[cmp_name] = a.eq_key\n                method_lines.append(\n                    indent + f\"        {cmp_name}(self.{a.name}),\"\n                )\n            else:\n                method_lines.append(indent + f\"        self.{a.name},\")\n\n        method_lines.append(indent + \"    \" + closing_braces)\n\n    if cache_hash:\n        method_lines.append(tab + f\"if self.{_HASH_CACHE_FIELD} is None:\")\n        if frozen:\n            append_hash_computation_lines(\n                f\"object.__setattr__(self, '{_HASH_CACHE_FIELD}', \", tab * 2\n            )\n            method_lines.append(tab * 2 + \")\")  # close __setattr__\n        else:\n            append_hash_computation_lines(\n                f\"self.{_HASH_CACHE_FIELD} = \", tab * 2\n            )\n        method_lines.append(tab + f\"return self.{_HASH_CACHE_FIELD}\")\n    else:\n        append_hash_computation_lines(\"return \", tab)\n\n    script = \"\\n\".join(method_lines)\n    return _make_method(\"__hash__\", script, unique_filename, globs)\n\n\ndef _add_hash(cls, attrs):\n    \"\"\"\n    Add a hash method to *cls*.\n    \"\"\"\n    cls.__hash__ = _make_hash(cls, attrs, frozen=False, cache_hash=False)\n    return cls\n\n\ndef _make_ne():\n    \"\"\"\n    Create __ne__ method.\n    \"\"\"\n\n    def __ne__(self, other):\n        \"\"\"\n        Check equality and either forward a NotImplemented or\n        return the result negated.\n        \"\"\"\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return NotImplemented\n\n        return not result\n\n    return __ne__\n\n\ndef _make_eq(cls, attrs):\n    \"\"\"\n    Create __eq__ method for *cls* with *attrs*.\n    \"\"\"\n    attrs = [a for a in attrs if a.eq]\n\n    unique_filename = _generate_unique_filename(cls, \"eq\")\n    lines = [\n        \"def __eq__(self, other):\",\n        \"    if other.__class__ is not self.__class__:\",\n        \"        return NotImplemented\",\n    ]\n\n    # We can't just do a big self.x = other.x and... clause due to\n    # irregularities like nan == nan is false but (nan,) == (nan,) is true.\n    globs = {}\n    if attrs:\n        lines.append(\"    return  (\")\n        others = [\"    ) == (\"]\n        for a in attrs:\n            if a.eq_key:\n                cmp_name = f\"_{a.name}_key\"\n                # Add the key function to the global namespace\n                # of the evaluated function.\n                globs[cmp_name] = a.eq_key\n                lines.append(f\"        {cmp_name}(self.{a.name}),\")\n                others.append(f\"        {cmp_name}(other.{a.name}),\")\n            else:\n                lines.append(f\"        self.{a.name},\")\n                others.append(f\"        other.{a.name},\")\n\n        lines += [*others, \"    )\"]\n    else:\n        lines.append(\"    return True\")\n\n    script = \"\\n\".join(lines)\n\n    return _make_method(\"__eq__\", script, unique_filename, globs)\n\n\ndef _make_order(cls, attrs):\n    \"\"\"\n    Create ordering methods for *cls* with *attrs*.\n    \"\"\"\n    attrs = [a for a in attrs if a.order]\n\n    def attrs_to_tuple(obj):\n        \"\"\"\n        Save us some typing.\n        \"\"\"\n        return tuple(\n            key(value) if key else value\n            for value, key in (\n                (getattr(obj, a.name), a.order_key) for a in attrs\n            )\n        )\n\n    def __lt__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) < attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __le__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) <= attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __gt__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) > attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __ge__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) >= attrs_to_tuple(other)\n\n        return NotImplemented\n\n    return __lt__, __le__, __gt__, __ge__\n\n\ndef _add_eq(cls, attrs=None):\n    \"\"\"\n    Add equality methods to *cls* with *attrs*.\n    \"\"\"\n    if attrs is None:\n        attrs = cls.__attrs_attrs__\n\n    cls.__eq__ = _make_eq(cls, attrs)\n    cls.__ne__ = _make_ne()\n\n    return cls\n\n\ndef _make_repr(attrs, ns, cls):\n    unique_filename = _generate_unique_filename(cls, \"repr\")\n    # Figure out which attributes to include, and which function to use to\n    # format them. The a.repr value can be either bool or a custom\n    # callable.\n    attr_names_with_reprs = tuple(\n        (a.name, (repr if a.repr is True else a.repr), a.init)\n        for a in attrs\n        if a.repr is not False\n    )\n    globs = {\n        name + \"_repr\": r for name, r, _ in attr_names_with_reprs if r != repr\n    }\n    globs[\"_compat\"] = _compat\n    globs[\"AttributeError\"] = AttributeError\n    globs[\"NOTHING\"] = NOTHING\n    attribute_fragments = []\n    for name, r, i in attr_names_with_reprs:\n        accessor = (\n            \"self.\" + name if i else 'getattr(self, \"' + name + '\", NOTHING)'\n        )\n        fragment = (\n            \"%s={%s!r}\" % (name, accessor)\n            if r == repr\n            else \"%s={%s_repr(%s)}\" % (name, name, accessor)\n        )\n        attribute_fragments.append(fragment)\n    repr_fragment = \", \".join(attribute_fragments)\n\n    if ns is None:\n        cls_name_fragment = '{self.__class__.__qualname__.rsplit(\">.\", 1)[-1]}'\n    else:\n        cls_name_fragment = ns + \".{self.__class__.__name__}\"\n\n    lines = [\n        \"def __repr__(self):\",\n        \"  try:\",\n        \"    already_repring = _compat.repr_context.already_repring\",\n        \"  except AttributeError:\",\n        \"    already_repring = {id(self),}\",\n        \"    _compat.repr_context.already_repring = already_repring\",\n        \"  else:\",\n        \"    if id(self) in already_repring:\",\n        \"      return '...'\",\n        \"    else:\",\n        \"      already_repring.add(id(self))\",\n        \"  try:\",\n        f\"    return f'{cls_name_fragment}({repr_fragment})'\",\n        \"  finally:\",\n        \"    already_repring.remove(id(self))\",\n    ]\n\n    return _make_method(\n        \"__repr__\", \"\\n\".join(lines), unique_filename, globs=globs\n    )\n\n\ndef _add_repr(cls, ns=None, attrs=None):\n    \"\"\"\n    Add a repr method to *cls*.\n    \"\"\"\n    if attrs is None:\n        attrs = cls.__attrs_attrs__\n\n    cls.__repr__ = _make_repr(attrs, ns, cls)\n    return cls\n\n\ndef fields(cls):\n    \"\"\"\n    Return the tuple of *attrs* attributes for a class.\n\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    :rtype: tuple (with name accessors) of `attrs.Attribute`\n\n    .. versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n       by name.\n    .. versionchanged:: 23.1.0 Add support for generic classes.\n    \"\"\"\n    generic_base = get_generic_base(cls)\n\n    if generic_base is None and not isinstance(cls, type):\n        msg = \"Passed object must be a class.\"\n        raise TypeError(msg)\n\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n\n    if attrs is None:\n        if generic_base is not None:\n            attrs = getattr(generic_base, \"__attrs_attrs__\", None)\n            if attrs is not None:\n                # Even though this is global state, stick it on here to speed\n                # it up. We rely on `cls` being cached for this to be\n                # efficient.\n                cls.__attrs_attrs__ = attrs\n                return attrs\n        msg = f\"{cls!r} is not an attrs-decorated class.\"\n        raise NotAnAttrsClassError(msg)\n\n    return attrs\n\n\ndef fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of *attrs* attributes for a class, whose\n    keys are the attribute names.\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    :rtype: dict\n\n    .. versionadded:: 18.1.0\n    \"\"\"\n    if not isinstance(cls, type):\n        msg = \"Passed object must be a class.\"\n        raise TypeError(msg)\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        msg = f\"{cls!r} is not an attrs-decorated class.\"\n        raise NotAnAttrsClassError(msg)\n    return {a.name: a for a in attrs}\n\n\ndef validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n\n    Leaves all exceptions through.\n\n    :param inst: Instance of a class with *attrs* attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n\n    for a in fields(inst.__class__):\n        v = a.validator\n        if v is not None:\n            v(inst, a, getattr(inst, a.name))\n\n\ndef _is_slot_attr(a_name, base_attr_map):\n    \"\"\"\n    Check if the attribute name comes from a slot class.\n    \"\"\"\n    cls = base_attr_map.get(a_name)\n    return cls and \"__slots__\" in cls.__dict__\n\n\ndef _make_init(\n    cls,\n    attrs,\n    pre_init,\n    pre_init_has_args,\n    post_init,\n    frozen,\n    slots,\n    cache_hash,\n    base_attr_map,\n    is_exc,\n    cls_on_setattr,\n    attrs_init,\n):\n    has_cls_on_setattr = (\n        cls_on_setattr is not None and cls_on_setattr is not setters.NO_OP\n    )\n\n    if frozen and has_cls_on_setattr:\n        msg = \"Frozen classes can't use on_setattr.\"\n        raise ValueError(msg)\n\n    needs_cached_setattr = cache_hash or frozen\n    filtered_attrs = []\n    attr_dict = {}\n    for a in attrs:\n        if not a.init and a.default is NOTHING:\n            continue\n\n        filtered_attrs.append(a)\n        attr_dict[a.name] = a\n\n        if a.on_setattr is not None:\n            if frozen is True:\n                msg = \"Frozen classes can't use on_setattr.\"\n                raise ValueError(msg)\n\n            needs_cached_setattr = True\n        elif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:\n            needs_cached_setattr = True\n\n    unique_filename = _generate_unique_filename(cls, \"init\")\n\n    script, globs, annotations = _attrs_to_init_script(\n        filtered_attrs,\n        frozen,\n        slots,\n        pre_init,\n        pre_init_has_args,\n        post_init,\n        cache_hash,\n        base_attr_map,\n        is_exc,\n        needs_cached_setattr,\n        has_cls_on_setattr,\n        attrs_init,\n    )\n    if cls.__module__ in sys.modules:\n        # This makes typing.get_type_hints(CLS.__init__) resolve string types.\n        globs.update(sys.modules[cls.__module__].__dict__)\n\n    globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n\n    if needs_cached_setattr:\n        # Save the lookup overhead in __init__ if we need to circumvent\n        # setattr hooks.\n        globs[\"_cached_setattr_get\"] = _OBJ_SETATTR.__get__\n\n    init = _make_method(\n        \"__attrs_init__\" if attrs_init else \"__init__\",\n        script,\n        unique_filename,\n        globs,\n    )\n    init.__annotations__ = annotations\n\n    return init\n\n\ndef _setattr(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Use the cached object.setattr to set *attr_name* to *value_var*.\n    \"\"\"\n    return f\"_setattr('{attr_name}', {value_var})\"\n\n\ndef _setattr_with_converter(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Use the cached object.setattr to set *attr_name* to *value_var*, but run\n    its converter first.\n    \"\"\"\n    return \"_setattr('%s', %s(%s))\" % (\n        attr_name,\n        _INIT_CONVERTER_PAT % (attr_name,),\n        value_var,\n    )\n\n\ndef _assign(attr_name, value, has_on_setattr):\n    \"\"\"\n    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise\n    relegate to _setattr.\n    \"\"\"\n    if has_on_setattr:\n        return _setattr(attr_name, value, True)\n\n    return f\"self.{attr_name} = {value}\"\n\n\ndef _assign_with_converter(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Unless *attr_name* has an on_setattr hook, use normal assignment after\n    conversion. Otherwise relegate to _setattr_with_converter.\n    \"\"\"\n    if has_on_setattr:\n        return _setattr_with_converter(attr_name, value_var, True)\n\n    return \"self.%s = %s(%s)\" % (\n        attr_name,\n        _INIT_CONVERTER_PAT % (attr_name,),\n        value_var,\n    )\n\n\ndef _determine_setters(frozen, slots, base_attr_map):\n    \"\"\"\n    Determine the correct setter functions based on whether a class is frozen\n    and/or slotted.\n    \"\"\"\n    if frozen is True:\n        if slots is True:\n            return (), _setattr, _setattr_with_converter\n\n        # Dict frozen classes assign directly to __dict__.\n        # But only if the attribute doesn't come from an ancestor slot\n        # class.\n        # Note _inst_dict will be used again below if cache_hash is True\n\n        def fmt_setter(attr_name, value_var, has_on_setattr):\n            if _is_slot_attr(attr_name, base_attr_map):\n                return _setattr(attr_name, value_var, has_on_setattr)\n\n            return f\"_inst_dict['{attr_name}'] = {value_var}\"\n\n        def fmt_setter_with_converter(attr_name, value_var, has_on_setattr):\n            if has_on_setattr or _is_slot_attr(attr_name, base_attr_map):\n                return _setattr_with_converter(\n                    attr_name, value_var, has_on_setattr\n                )\n\n            return \"_inst_dict['%s'] = %s(%s)\" % (\n                attr_name,\n                _INIT_CONVERTER_PAT % (attr_name,),\n                value_var,\n            )\n\n        return (\n            (\"_inst_dict = self.__dict__\",),\n            fmt_setter,\n            fmt_setter_with_converter,\n        )\n\n    # Not frozen -- we can just assign directly.\n    return (), _assign, _assign_with_converter\n\n\ndef _attrs_to_init_script(\n    attrs,\n    frozen,\n    slots,\n    pre_init,\n    pre_init_has_args,\n    post_init,\n    cache_hash,\n    base_attr_map,\n    is_exc,\n    needs_cached_setattr,\n    has_cls_on_setattr,\n    attrs_init,\n):\n    \"\"\"\n    Return a script of an initializer for *attrs* and a dict of globals.\n\n    The globals are expected by the generated script.\n\n    If *frozen* is True, we cannot set the attributes directly so we use\n    a cached ``object.__setattr__``.\n    \"\"\"\n    lines = [\"self.__attrs_pre_init__()\"] if pre_init else []\n\n    if needs_cached_setattr:\n        lines.append(\n            # Circumvent the __setattr__ descriptor to save one lookup per\n            # assignment.\n            # Note _setattr will be used again below if cache_hash is True\n            \"_setattr = _cached_setattr_get(self)\"\n        )\n\n    extra_lines, fmt_setter, fmt_setter_with_converter = _determine_setters(\n        frozen, slots, base_attr_map\n    )\n    lines.extend(extra_lines)\n\n    args = []\n    kw_only_args = []\n    attrs_to_validate = []\n\n    # This is a dictionary of names to validator and converter callables.\n    # Injecting this into __init__ globals lets us avoid lookups.\n    names_for_globals = {}\n    annotations = {\"return\": None}\n\n    for a in attrs:\n        if a.validator:\n            attrs_to_validate.append(a)\n\n        attr_name = a.name\n        has_on_setattr = a.on_setattr is not None or (\n            a.on_setattr is not setters.NO_OP and has_cls_on_setattr\n        )\n        # a.alias is set to maybe-mangled attr_name in _ClassBuilder if not\n        # explicitly provided\n        arg_name = a.alias\n\n        has_factory = isinstance(a.default, Factory)\n        maybe_self = \"self\" if has_factory and a.default.takes_self else \"\"\n\n        if a.init is False:\n            if has_factory:\n                init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n                if a.converter is not None:\n                    lines.append(\n                        fmt_setter_with_converter(\n                            attr_name,\n                            init_factory_name + f\"({maybe_self})\",\n                            has_on_setattr,\n                        )\n                    )\n                    names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                        a.converter\n                    )\n                else:\n                    lines.append(\n                        fmt_setter(\n                            attr_name,\n                            init_factory_name + f\"({maybe_self})\",\n                            has_on_setattr,\n                        )\n                    )\n                names_for_globals[init_factory_name] = a.default.factory\n            elif a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name,\n                        f\"attr_dict['{attr_name}'].default\",\n                        has_on_setattr,\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(\n                    fmt_setter(\n                        attr_name,\n                        f\"attr_dict['{attr_name}'].default\",\n                        has_on_setattr,\n                    )\n                )\n        elif a.default is not NOTHING and not has_factory:\n            arg = f\"{arg_name}=attr_dict['{attr_name}'].default\"\n            if a.kw_only:\n                kw_only_args.append(arg)\n            else:\n                args.append(arg)\n\n            if a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n\n        elif has_factory:\n            arg = f\"{arg_name}=NOTHING\"\n            if a.kw_only:\n                kw_only_args.append(arg)\n            else:\n                args.append(arg)\n            lines.append(f\"if {arg_name} is not NOTHING:\")\n\n            init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n            if a.converter is not None:\n                lines.append(\n                    \"    \"\n                    + fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                lines.append(\"else:\")\n                lines.append(\n                    \"    \"\n                    + fmt_setter_with_converter(\n                        attr_name,\n                        init_factory_name + \"(\" + maybe_self + \")\",\n                        has_on_setattr,\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(\n                    \"    \" + fmt_setter(attr_name, arg_name, has_on_setattr)\n                )\n                lines.append(\"else:\")\n                lines.append(\n                    \"    \"\n                    + fmt_setter(\n                        attr_name,\n                        init_factory_name + \"(\" + maybe_self + \")\",\n                        has_on_setattr,\n                    )\n                )\n            names_for_globals[init_factory_name] = a.default.factory\n        else:\n            if a.kw_only:\n                kw_only_args.append(arg_name)\n            else:\n                args.append(arg_name)\n\n            if a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n\n        if a.init is True:\n            if a.type is not None and a.converter is None:\n                annotations[arg_name] = a.type\n            elif a.converter is not None:\n                # Try to get the type from the converter.\n                t = _AnnotationExtractor(a.converter).get_first_param_type()\n                if t:\n                    annotations[arg_name] = t\n\n    if attrs_to_validate:  # we can skip this if there are no validators.\n        names_for_globals[\"_config\"] = _config\n        lines.append(\"if _config._run_validators is True:\")\n        for a in attrs_to_validate:\n            val_name = \"__attr_validator_\" + a.name\n            attr_name = \"__attr_\" + a.name\n            lines.append(f\"    {val_name}(self, {attr_name}, self.{a.name})\")\n            names_for_globals[val_name] = a.validator\n            names_for_globals[attr_name] = a\n\n    if post_init:\n        lines.append(\"self.__attrs_post_init__()\")\n\n    # because this is set only after __attrs_post_init__ is called, a crash\n    # will result if post-init tries to access the hash code.  This seemed\n    # preferable to setting this beforehand, in which case alteration to\n    # field values during post-init combined with post-init accessing the\n    # hash code would result in silent bugs.\n    if cache_hash:\n        if frozen:\n            if slots:  # noqa: SIM108\n                # if frozen and slots, then _setattr defined above\n                init_hash_cache = \"_setattr('%s', %s)\"\n            else:\n                # if frozen and not slots, then _inst_dict defined above\n                init_hash_cache = \"_inst_dict['%s'] = %s\"\n        else:\n            init_hash_cache = \"self.%s = %s\"\n        lines.append(init_hash_cache % (_HASH_CACHE_FIELD, \"None\"))\n\n    # For exceptions we rely on BaseException.__init__ for proper\n    # initialization.\n    if is_exc:\n        vals = \",\".join(f\"self.{a.name}\" for a in attrs if a.init)\n\n        lines.append(f\"BaseException.__init__(self, {vals})\")\n\n    args = \", \".join(args)\n    pre_init_args = args\n    if kw_only_args:\n        args += \"%s*, %s\" % (\n            \", \" if args else \"\",  # leading comma\n            \", \".join(kw_only_args),  # kw_only args\n        )\n        pre_init_kw_only_args = \", \".join(\n            [\"%s=%s\" % (kw_arg, kw_arg) for kw_arg in kw_only_args]\n        )\n        pre_init_args += (\n            \", \" if pre_init_args else \"\"\n        )  # handle only kwargs and no regular args\n        pre_init_args += pre_init_kw_only_args\n\n    if pre_init and pre_init_has_args:\n        # If pre init method has arguments, pass same arguments as `__init__`\n        lines[0] = \"self.__attrs_pre_init__(%s)\" % pre_init_args\n\n    return (\n        \"def %s(self, %s):\\n    %s\\n\"\n        % (\n            (\"__attrs_init__\" if attrs_init else \"__init__\"),\n            args,\n            \"\\n    \".join(lines) if lines else \"pass\",\n        ),\n        names_for_globals,\n        annotations,\n    )\n\n\ndef _default_init_alias_for(name: str) -> str:\n    \"\"\"\n    The default __init__ parameter name for a field.\n\n    This performs private-name adjustment via leading-unscore stripping,\n    and is the default value of Attribute.alias if not provided.\n    \"\"\"\n\n    return name.lstrip(\"_\")\n\n\nclass Attribute:\n    \"\"\"\n    *Read-only* representation of an attribute.\n\n    .. warning::\n\n       You should never instantiate this class yourself.\n\n    The class has *all* arguments of `attr.ib` (except for ``factory`` which is\n    only syntactic sugar for ``default=Factory(...)`` plus the following:\n\n    - ``name`` (`str`): The name of the attribute.\n    - ``alias`` (`str`): The __init__ parameter name of the attribute, after\n      any explicit overrides and default private-attribute-name handling.\n    - ``inherited`` (`bool`): Whether or not that attribute has been inherited\n      from a base class.\n    - ``eq_key`` and ``order_key`` (`typing.Callable` or `None`): The\n      callables that are used for comparing and ordering objects by this\n      attribute, respectively. These are set by passing a callable to\n      `attr.ib`'s ``eq``, ``order``, or ``cmp`` arguments. See also\n      :ref:`comparison customization <custom-comparison>`.\n\n    Instances of this class are frequently used for introspection purposes\n    like:\n\n    - `fields` returns a tuple of them.\n    - Validators get them passed as the first argument.\n    - The :ref:`field transformer <transform-fields>` hook receives a list of\n      them.\n    - The ``alias`` property exposes the __init__ parameter name of the field,\n      with any overrides and default private-attribute handling applied.\n\n\n    .. versionadded:: 20.1.0 *inherited*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.2.0 *inherited* is not taken into account for\n        equality checks and hashing anymore.\n    .. versionadded:: 21.1.0 *eq_key* and *order_key*\n    .. versionadded:: 22.2.0 *alias*\n\n    For the full version history of the fields, see `attr.ib`.\n    \"\"\"\n\n    __slots__ = (\n        \"name\",\n        \"default\",\n        \"validator\",\n        \"repr\",\n        \"eq\",\n        \"eq_key\",\n        \"order\",\n        \"order_key\",\n        \"hash\",\n        \"init\",\n        \"metadata\",\n        \"type\",\n        \"converter\",\n        \"kw_only\",\n        \"inherited\",\n        \"on_setattr\",\n        \"alias\",\n    )\n\n    def __init__(\n        self,\n        name,\n        default,\n        validator,\n        repr,\n        cmp,  # XXX: unused, remove along with other cmp code.\n        hash,\n        init,\n        inherited,\n        metadata=None,\n        type=None,\n        converter=None,\n        kw_only=False,\n        eq=None,\n        eq_key=None,\n        order=None,\n        order_key=None,\n        on_setattr=None,\n        alias=None,\n    ):\n        eq, eq_key, order, order_key = _determine_attrib_eq_order(\n            cmp, eq_key or eq, order_key or order, True\n        )\n\n        # Cache this descriptor here to speed things up later.\n        bound_setattr = _OBJ_SETATTR.__get__(self)\n\n        # Despite the big red warning, people *do* instantiate `Attribute`\n        # themselves.\n        bound_setattr(\"name\", name)\n        bound_setattr(\"default\", default)\n        bound_setattr(\"validator\", validator)\n        bound_setattr(\"repr\", repr)\n        bound_setattr(\"eq\", eq)\n        bound_setattr(\"eq_key\", eq_key)\n        bound_setattr(\"order\", order)\n        bound_setattr(\"order_key\", order_key)\n        bound_setattr(\"hash\", hash)\n        bound_setattr(\"init\", init)\n        bound_setattr(\"converter\", converter)\n        bound_setattr(\n            \"metadata\",\n            (\n                types.MappingProxyType(dict(metadata))  # Shallow copy\n                if metadata\n                else _EMPTY_METADATA_SINGLETON\n            ),\n        )\n        bound_setattr(\"type\", type)\n        bound_setattr(\"kw_only\", kw_only)\n        bound_setattr(\"inherited\", inherited)\n        bound_setattr(\"on_setattr\", on_setattr)\n        bound_setattr(\"alias\", alias)\n\n    def __setattr__(self, name, value):\n        raise FrozenInstanceError()\n\n    @classmethod\n    def from_counting_attr(cls, name, ca, type=None):\n        # type holds the annotated value. deal with conflicts:\n        if type is None:\n            type = ca.type\n        elif ca.type is not None:\n            msg = \"Type annotation and type argument cannot both be present\"\n            raise ValueError(msg)\n        inst_dict = {\n            k: getattr(ca, k)\n            for k in Attribute.__slots__\n            if k\n            not in (\n                \"name\",\n                \"validator\",\n                \"default\",\n                \"type\",\n                \"inherited\",\n            )  # exclude methods and deprecated alias\n        }\n        return cls(\n            name=name,\n            validator=ca._validator,\n            default=ca._default,\n            type=type,\n            cmp=None,\n            inherited=False,\n            **inst_dict,\n        )\n\n    # Don't use attrs.evolve since fields(Attribute) doesn't work\n    def evolve(self, **changes):\n        \"\"\"\n        Copy *self* and apply *changes*.\n\n        This works similarly to `attrs.evolve` but that function does not work\n        with `Attribute`.\n\n        It is mainly meant to be used for `transform-fields`.\n\n        .. versionadded:: 20.3.0\n        \"\"\"\n        new = copy.copy(self)\n\n        new._setattrs(changes.items())\n\n        return new\n\n    # Don't use _add_pickle since fields(Attribute) doesn't work\n    def __getstate__(self):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        return tuple(\n            getattr(self, name) if name != \"metadata\" else dict(self.metadata)\n            for name in self.__slots__\n        )\n\n    def __setstate__(self, state):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        self._setattrs(zip(self.__slots__, state))\n\n    def _setattrs(self, name_values_pairs):\n        bound_setattr = _OBJ_SETATTR.__get__(self)\n        for name, value in name_values_pairs:\n            if name != \"metadata\":\n                bound_setattr(name, value)\n            else:\n                bound_setattr(\n                    name,\n                    (\n                        types.MappingProxyType(dict(value))\n                        if value\n                        else _EMPTY_METADATA_SINGLETON\n                    ),\n                )\n\n\n_a = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=(name != \"metadata\"),\n        init=True,\n        inherited=False,\n        alias=_default_init_alias_for(name),\n    )\n    for name in Attribute.__slots__\n]\n\nAttribute = _add_hash(\n    _add_eq(\n        _add_repr(Attribute, attrs=_a),\n        attrs=[a for a in _a if a.name != \"inherited\"],\n    ),\n    attrs=[a for a in _a if a.hash and a.name != \"inherited\"],\n)\n\n\nclass _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve\n    the order in which the attributes have been defined.\n\n    *Internal* data structure of the attrs library.  Running into is most\n    likely the result of a bug like a forgotten `@attr.s` decorator.\n    \"\"\"\n\n    __slots__ = (\n        \"counter\",\n        \"_default\",\n        \"repr\",\n        \"eq\",\n        \"eq_key\",\n        \"order\",\n        \"order_key\",\n        \"hash\",\n        \"init\",\n        \"metadata\",\n        \"_validator\",\n        \"converter\",\n        \"type\",\n        \"kw_only\",\n        \"on_setattr\",\n        \"alias\",\n    )\n    __attrs_attrs__ = (\n        *tuple(\n            Attribute(\n                name=name,\n                alias=_default_init_alias_for(name),\n                default=NOTHING,\n                validator=None,\n                repr=True,\n                cmp=None,\n                hash=True,\n                init=True,\n                kw_only=False,\n                eq=True,\n                eq_key=None,\n                order=False,\n                order_key=None,\n                inherited=False,\n                on_setattr=None,\n            )\n            for name in (\n                \"counter\",\n                \"_default\",\n                \"repr\",\n                \"eq\",\n                \"order\",\n                \"hash\",\n                \"init\",\n                \"on_setattr\",\n                \"alias\",\n            )\n        ),\n        Attribute(\n            name=\"metadata\",\n            alias=\"metadata\",\n            default=None,\n            validator=None,\n            repr=True,\n            cmp=None,\n            hash=False,\n            init=True,\n            kw_only=False,\n            eq=True,\n            eq_key=None,\n            order=False,\n            order_key=None,\n            inherited=False,\n            on_setattr=None,\n        ),\n    )\n    cls_counter = 0\n\n    def __init__(\n        self,\n        default,\n        validator,\n        repr,\n        cmp,\n        hash,\n        init,\n        converter,\n        metadata,\n        type,\n        kw_only,\n        eq,\n        eq_key,\n        order,\n        order_key,\n        on_setattr,\n        alias,\n    ):\n        _CountingAttr.cls_counter += 1\n        self.counter = _CountingAttr.cls_counter\n        self._default = default\n        self._validator = validator\n        self.converter = converter\n        self.repr = repr\n        self.eq = eq\n        self.eq_key = eq_key\n        self.order = order\n        self.order_key = order_key\n        self.hash = hash\n        self.init = init\n        self.metadata = metadata\n        self.type = type\n        self.kw_only = kw_only\n        self.on_setattr = on_setattr\n        self.alias = alias\n\n    def validator(self, meth):\n        \"\"\"\n        Decorator that adds *meth* to the list of validators.\n\n        Returns *meth* unchanged.\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if self._validator is None:\n            self._validator = meth\n        else:\n            self._validator = and_(self._validator, meth)\n        return meth\n\n    def default(self, meth):\n        \"\"\"\n        Decorator that allows to set the default for an attribute.\n\n        Returns *meth* unchanged.\n\n        :raises DefaultAlreadySetError: If default has been set before.\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if self._default is not NOTHING:\n            raise DefaultAlreadySetError()\n\n        self._default = Factory(meth, takes_self=True)\n\n        return meth\n\n\n_CountingAttr = _add_eq(_add_repr(_CountingAttr))\n\n\nclass Factory:\n    \"\"\"\n    Stores a factory callable.\n\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n\n    :param typing.Callable factory: A callable that takes either none or\n        exactly one mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.\n\n    .. versionadded:: 17.1.0  *takes_self*\n    \"\"\"\n\n    __slots__ = (\"factory\", \"takes_self\")\n\n    def __init__(self, factory, takes_self=False):\n        self.factory = factory\n        self.takes_self = takes_self\n\n    def __getstate__(self):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        return tuple(getattr(self, name) for name in self.__slots__)\n\n    def __setstate__(self, state):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        for name, value in zip(self.__slots__, state):\n            setattr(self, name, value)\n\n\n_f = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=True,\n        init=True,\n        inherited=False,\n    )\n    for name in Factory.__slots__\n]\n\nFactory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)\n\n\ndef make_class(\n    name, attrs, bases=(object,), class_body=None, **attributes_arguments\n):\n    r\"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n\n    :param str name: The name for the new class.\n\n    :param list | dict attrs: A list of names or a dictionary of mappings of\n        names to `attr.ib`\\ s / `attrs.field`\\ s.\n\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.\n\n    :param tuple bases: Classes that the new class will subclass.\n\n    :param dict class_body: An optional dictionary of class attributes for the\n        new class.\n\n    :param attributes_arguments: Passed unmodified to `attr.s`.\n\n    :return: A new class with *attrs*.\n    :rtype: type\n\n    .. versionadded:: 17.1.0 *bases*\n    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.\n    .. versionchanged:: 23.2.0 *class_body*\n    \"\"\"\n    if isinstance(attrs, dict):\n        cls_dict = attrs\n    elif isinstance(attrs, (list, tuple)):\n        cls_dict = {a: attrib() for a in attrs}\n    else:\n        msg = \"attrs argument must be a dict or a list.\"\n        raise TypeError(msg)\n\n    pre_init = cls_dict.pop(\"__attrs_pre_init__\", None)\n    post_init = cls_dict.pop(\"__attrs_post_init__\", None)\n    user_init = cls_dict.pop(\"__init__\", None)\n\n    body = {}\n    if class_body is not None:\n        body.update(class_body)\n    if pre_init is not None:\n        body[\"__attrs_pre_init__\"] = pre_init\n    if post_init is not None:\n        body[\"__attrs_post_init__\"] = post_init\n    if user_init is not None:\n        body[\"__init__\"] = user_init\n\n    type_ = types.new_class(name, bases, {}, lambda ns: ns.update(body))\n\n    # For pickling to work, the __module__ variable needs to be set to the\n    # frame where the class is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    with contextlib.suppress(AttributeError, ValueError):\n        type_.__module__ = sys._getframe(1).f_globals.get(\n            \"__name__\", \"__main__\"\n        )\n\n    # We do it here for proper warnings with meaningful stacklevel.\n    cmp = attributes_arguments.pop(\"cmp\", None)\n    (\n        attributes_arguments[\"eq\"],\n        attributes_arguments[\"order\"],\n    ) = _determine_attrs_eq_order(\n        cmp,\n        attributes_arguments.get(\"eq\"),\n        attributes_arguments.get(\"order\"),\n        True,\n    )\n\n    return _attrs(these=cls_dict, **attributes_arguments)(type_)\n\n\n# These are required by within this module so we define them here and merely\n# import into .validators / .converters.\n\n\n@attrs(slots=True, hash=True)\nclass _AndValidator:\n    \"\"\"\n    Compose many validators to a single one.\n    \"\"\"\n\n    _validators = attrib()\n\n    def __call__(self, inst, attr, value):\n        for v in self._validators:\n            v(inst, attr, value)\n\n\ndef and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n\n    When called on a value, it runs all wrapped validators.\n\n    :param ~collections.abc.Iterable[typing.Callable] validators: Arbitrary\n        number of validators.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(\n            validator._validators\n            if isinstance(validator, _AndValidator)\n            else [validator]\n        )\n\n    return _AndValidator(tuple(vals))\n\n\ndef pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n\n    Type annotations will be inferred from the wrapped converters', if they\n    have any.\n\n    :param ~collections.abc.Iterable[typing.Callable] converters: Arbitrary\n        number of converters.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def pipe_converter(val):\n        for converter in converters:\n            val = converter(val)\n\n        return val\n\n    if not converters:\n        # If the converter list is empty, pipe_converter is the identity.\n        A = typing.TypeVar(\"A\")\n        pipe_converter.__annotations__ = {\"val\": A, \"return\": A}\n    else:\n        # Get parameter type from first converter.\n        t = _AnnotationExtractor(converters[0]).get_first_param_type()\n        if t:\n            pipe_converter.__annotations__[\"val\"] = t\n\n        # Get return type from last converter.\n        rt = _AnnotationExtractor(converters[-1]).get_return_type()\n        if rt:\n            pipe_converter.__annotations__[\"return\"] = rt\n\n    return pipe_converter\n", "src/attr/_funcs.py": "# SPDX-License-Identifier: MIT\n\n\nimport copy\n\nfrom ._compat import PY_3_9_PLUS, get_generic_base\nfrom ._make import _OBJ_SETATTR, NOTHING, fields\nfrom .exceptions import AttrsAttributeNotFoundError\n\n\ndef asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the *attrs* attribute values of *inst* as a dict.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also *attrs*-decorated.\n    :param ~typing.Callable filter: A callable whose return code determines\n        whether an attribute or element is included (`True`) or dropped\n        (`False`).  Is called with the `attrs.Attribute` as the first argument\n        and the value as the second argument.\n    :param ~typing.Callable dict_factory: A callable to produce dictionaries\n        from.  For example, to produce ordered dictionaries instead of normal\n        Python dictionaries, pass in ``collections.OrderedDict``.\n    :param bool retain_collection_types: Do not convert to `list` when\n        encountering an attribute whose type is `tuple` or `set`.  Only\n        meaningful if *recurse* is `True`.\n    :param typing.Callable | None value_serializer: A hook that is called for\n        every attribute or dict key/value.  It receives the current instance,\n        field and value and must return the (updated) value.  The hook is run\n        *after* the optional *filter* has been applied.\n\n    :rtype: return type of *dict_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.0.0 *dict_factory*\n    ..  versionadded:: 16.1.0 *retain_collection_types*\n    ..  versionadded:: 20.3.0 *value_serializer*\n    ..  versionadded:: 21.3.0 If a dict has a collection for a key, it is\n        serialized as a tuple.\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = dict_factory()\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n\n        if value_serializer is not None:\n            v = value_serializer(inst, a, v)\n\n        if recurse is True:\n            if has(v.__class__):\n                rv[a.name] = asdict(\n                    v,\n                    recurse=True,\n                    filter=filter,\n                    dict_factory=dict_factory,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain_collection_types is True else list\n                items = [\n                    _asdict_anything(\n                        i,\n                        is_key=False,\n                        filter=filter,\n                        dict_factory=dict_factory,\n                        retain_collection_types=retain_collection_types,\n                        value_serializer=value_serializer,\n                    )\n                    for i in v\n                ]\n                try:\n                    rv[a.name] = cf(items)\n                except TypeError:\n                    if not issubclass(cf, tuple):\n                        raise\n                    # Workaround for TypeError: cf.__new__() missing 1 required\n                    # positional argument (which appears, for a namedturle)\n                    rv[a.name] = cf(*items)\n            elif isinstance(v, dict):\n                df = dict_factory\n                rv[a.name] = df(\n                    (\n                        _asdict_anything(\n                            kk,\n                            is_key=True,\n                            filter=filter,\n                            dict_factory=df,\n                            retain_collection_types=retain_collection_types,\n                            value_serializer=value_serializer,\n                        ),\n                        _asdict_anything(\n                            vv,\n                            is_key=False,\n                            filter=filter,\n                            dict_factory=df,\n                            retain_collection_types=retain_collection_types,\n                            value_serializer=value_serializer,\n                        ),\n                    )\n                    for kk, vv in v.items()\n                )\n            else:\n                rv[a.name] = v\n        else:\n            rv[a.name] = v\n    return rv\n\n\ndef _asdict_anything(\n    val,\n    is_key,\n    filter,\n    dict_factory,\n    retain_collection_types,\n    value_serializer,\n):\n    \"\"\"\n    ``asdict`` only works on attrs instances, this works on anything.\n    \"\"\"\n    if getattr(val.__class__, \"__attrs_attrs__\", None) is not None:\n        # Attrs class.\n        rv = asdict(\n            val,\n            recurse=True,\n            filter=filter,\n            dict_factory=dict_factory,\n            retain_collection_types=retain_collection_types,\n            value_serializer=value_serializer,\n        )\n    elif isinstance(val, (tuple, list, set, frozenset)):\n        if retain_collection_types is True:\n            cf = val.__class__\n        elif is_key:\n            cf = tuple\n        else:\n            cf = list\n\n        rv = cf(\n            [\n                _asdict_anything(\n                    i,\n                    is_key=False,\n                    filter=filter,\n                    dict_factory=dict_factory,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                )\n                for i in val\n            ]\n        )\n    elif isinstance(val, dict):\n        df = dict_factory\n        rv = df(\n            (\n                _asdict_anything(\n                    kk,\n                    is_key=True,\n                    filter=filter,\n                    dict_factory=df,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                ),\n                _asdict_anything(\n                    vv,\n                    is_key=False,\n                    filter=filter,\n                    dict_factory=df,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                ),\n            )\n            for kk, vv in val.items()\n        )\n    else:\n        rv = val\n        if value_serializer is not None:\n            rv = value_serializer(None, None, rv)\n\n    return rv\n\n\ndef astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the *attrs* attribute values of *inst* as a tuple.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also *attrs*-decorated.\n    :param ~typing.Callable filter: A callable whose return code determines\n        whether an attribute or element is included (`True`) or dropped\n        (`False`).  Is called with the `attrs.Attribute` as the first argument\n        and the value as the second argument.\n    :param ~typing.Callable tuple_factory: A callable to produce tuples from.\n        For example, to produce lists instead of tuples.\n    :param bool retain_collection_types: Do not convert to `list` or `dict`\n        when encountering an attribute which type is `tuple`, `dict` or `set`.\n        Only meaningful if *recurse* is `True`.\n\n    :rtype: return type of *tuple_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.2.0\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = []\n    retain = retain_collection_types  # Very long. :/\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n        if recurse is True:\n            if has(v.__class__):\n                rv.append(\n                    astuple(\n                        v,\n                        recurse=True,\n                        filter=filter,\n                        tuple_factory=tuple_factory,\n                        retain_collection_types=retain,\n                    )\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain is True else list\n                items = [\n                    (\n                        astuple(\n                            j,\n                            recurse=True,\n                            filter=filter,\n                            tuple_factory=tuple_factory,\n                            retain_collection_types=retain,\n                        )\n                        if has(j.__class__)\n                        else j\n                    )\n                    for j in v\n                ]\n                try:\n                    rv.append(cf(items))\n                except TypeError:\n                    if not issubclass(cf, tuple):\n                        raise\n                    # Workaround for TypeError: cf.__new__() missing 1 required\n                    # positional argument (which appears, for a namedturle)\n                    rv.append(cf(*items))\n            elif isinstance(v, dict):\n                df = v.__class__ if retain is True else dict\n                rv.append(\n                    df(\n                        (\n                            (\n                                astuple(\n                                    kk,\n                                    tuple_factory=tuple_factory,\n                                    retain_collection_types=retain,\n                                )\n                                if has(kk.__class__)\n                                else kk\n                            ),\n                            (\n                                astuple(\n                                    vv,\n                                    tuple_factory=tuple_factory,\n                                    retain_collection_types=retain,\n                                )\n                                if has(vv.__class__)\n                                else vv\n                            ),\n                        )\n                        for kk, vv in v.items()\n                    )\n                )\n            else:\n                rv.append(v)\n        else:\n            rv.append(v)\n\n    return rv if tuple_factory is list else tuple_factory(rv)\n\n\ndef has(cls):\n    \"\"\"\n    Check whether *cls* is a class with *attrs* attributes.\n\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n\n    :rtype: bool\n    \"\"\"\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is not None:\n        return True\n\n    # No attrs, maybe it's a specialized generic (A[str])?\n    generic_base = get_generic_base(cls)\n    if generic_base is not None:\n        generic_attrs = getattr(generic_base, \"__attrs_attrs__\", None)\n        if generic_attrs is not None:\n            # Stick it on here for speed next time.\n            cls.__attrs_attrs__ = generic_attrs\n        return generic_attrs is not None\n    return False\n\n\ndef assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n\n    This is different from `evolve` that applies the changes to the arguments\n    that create the new instance.\n\n    `evolve`'s behavior is preferable, but there are `edge cases`_ where it\n    doesn't work. Therefore `assoc` is deprecated, but will not be removed.\n\n    .. _`edge cases`: https://github.com/python-attrs/attrs/issues/251\n\n    :param inst: Instance of a class with *attrs* attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name*\n        couldn't be found on *cls*.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  deprecated:: 17.1.0\n        Use `attrs.evolve` instead if you can.\n        This function will not be removed du to the slightly different approach\n        compared to `attrs.evolve`.\n    \"\"\"\n    new = copy.copy(inst)\n    attrs = fields(inst.__class__)\n    for k, v in changes.items():\n        a = getattr(attrs, k, NOTHING)\n        if a is NOTHING:\n            msg = f\"{k} is not an attrs attribute on {new.__class__}.\"\n            raise AttrsAttributeNotFoundError(msg)\n        _OBJ_SETATTR(new, k, v)\n    return new\n\n\ndef evolve(*args, **changes):\n    \"\"\"\n    Create a new instance, based on the first positional argument with\n    *changes* applied.\n\n    :param inst: Instance of a class with *attrs* attributes. *inst* must be\n        passed as a positional argument.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    .. versionadded:: 17.1.0\n    .. deprecated:: 23.1.0\n       It is now deprecated to pass the instance using the keyword argument\n       *inst*. It will raise a warning until at least April 2024, after which\n       it will become an error. Always pass the instance as a positional\n       argument.\n    .. versionchanged:: 24.1.0\n       *inst* can't be passed as a keyword argument anymore.\n    \"\"\"\n    try:\n        (inst,) = args\n    except ValueError:\n        msg = (\n            f\"evolve() takes 1 positional argument, but {len(args)} were given\"\n        )\n        raise TypeError(msg) from None\n\n    cls = inst.__class__\n    attrs = fields(cls)\n    for a in attrs:\n        if not a.init:\n            continue\n        attr_name = a.name  # To deal with private attributes.\n        init_name = a.alias\n        if init_name not in changes:\n            changes[init_name] = getattr(inst, attr_name)\n\n    return cls(**changes)\n\n\ndef resolve_types(\n    cls, globalns=None, localns=None, attribs=None, include_extras=True\n):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only use\n    them for static type checking.\n\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, for example, if the name only\n    exists inside a method, you may pass *globalns* or *localns* to specify\n    other dictionaries in which to look up these names. See the docs of\n    `typing.get_type_hints` for more details.\n\n    :param type cls: Class to resolve.\n    :param dict | None globalns: Dictionary containing global variables.\n    :param dict | None localns: Dictionary containing local variables.\n    :param list | None attribs: List of attribs for the given class. This is\n        necessary when calling from inside a ``field_transformer`` since *cls*\n        is not an *attrs* class yet.\n    :param bool include_extras: Resolve more accurately, if possible. Pass\n        ``include_extras`` to ``typing.get_hints``, if supported by the typing\n        module. On supported Python versions (3.9+), this resolves the types\n        more accurately.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class and you didn't pass any attribs.\n    :raise NameError: If types cannot be resolved because of missing variables.\n\n    :returns: *cls* so you can use this function also as a class decorator.\n        Please note that you have to apply it **after** `attrs.define`. That\n        means the decorator has to come in the line **before** `attrs.define`.\n\n    ..  versionadded:: 20.1.0\n    ..  versionadded:: 21.1.0 *attribs*\n    ..  versionadded:: 23.1.0 *include_extras*\n    \"\"\"\n    # Since calling get_type_hints is expensive we cache whether we've\n    # done it already.\n    if getattr(cls, \"__attrs_types_resolved__\", None) != cls:\n        import typing\n\n        kwargs = {\"globalns\": globalns, \"localns\": localns}\n\n        if PY_3_9_PLUS:\n            kwargs[\"include_extras\"] = include_extras\n\n        hints = typing.get_type_hints(cls, **kwargs)\n        for field in fields(cls) if attribs is None else attribs:\n            if field.name in hints:\n                # Since fields have been frozen we must work around it.\n                _OBJ_SETATTR(field, \"type\", hints[field.name])\n        # We store the class we resolved so that subclasses know they haven't\n        # been resolved.\n        cls.__attrs_types_resolved__ = cls\n\n    # Return the class so you can use it as a decorator too.\n    return cls\n", "src/attr/_version_info.py": "# SPDX-License-Identifier: MIT\n\n\nfrom functools import total_ordering\n\nfrom ._funcs import astuple\nfrom ._make import attrib, attrs\n\n\n@total_ordering\n@attrs(eq=False, order=False, slots=True, frozen=True)\nclass VersionInfo:\n    \"\"\"\n    A version object that can be compared to tuple of length 1--4:\n\n    >>> attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\n    True\n    >>> attr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)\n    True\n    >>> vi = attr.VersionInfo(19, 2, 0, \"final\")\n    >>> vi < (19, 1, 1)\n    False\n    >>> vi < (19,)\n    False\n    >>> vi == (19, 2,)\n    True\n    >>> vi == (19, 2, 1)\n    False\n\n    .. versionadded:: 19.2\n    \"\"\"\n\n    year = attrib(type=int)\n    minor = attrib(type=int)\n    micro = attrib(type=int)\n    releaselevel = attrib(type=str)\n\n    @classmethod\n    def _from_version_string(cls, s):\n        \"\"\"\n        Parse *s* and return a _VersionInfo.\n        \"\"\"\n        v = s.split(\".\")\n        if len(v) == 3:\n            v.append(\"final\")\n\n        return cls(\n            year=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]\n        )\n\n    def _ensure_tuple(self, other):\n        \"\"\"\n        Ensure *other* is a tuple of a valid length.\n\n        Returns a possibly transformed *other* and ourselves as a tuple of\n        the same length as *other*.\n        \"\"\"\n\n        if self.__class__ is other.__class__:\n            other = astuple(other)\n\n        if not isinstance(other, tuple):\n            raise NotImplementedError\n\n        if not (1 <= len(other) <= 4):\n            raise NotImplementedError\n\n        return astuple(self)[: len(other)], other\n\n    def __eq__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        return us == them\n\n    def __lt__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        # Since alphabetically \"dev0\" < \"final\" < \"post1\" < \"post2\", we don't\n        # have to do anything special with releaselevel for now.\n        return us < them\n", "src/attr/_config.py": "# SPDX-License-Identifier: MIT\n\n__all__ = [\"set_run_validators\", \"get_run_validators\"]\n\n_run_validators = True\n\n\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        msg = \"'run' must be bool.\"\n        raise TypeError(msg)\n    global _run_validators\n    _run_validators = run\n\n\ndef get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`\n        instead.\n    \"\"\"\n    return _run_validators\n", "src/attr/converters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful converters.\n\"\"\"\n\n\nimport typing\n\nfrom ._compat import _AnnotationExtractor\nfrom ._make import NOTHING, Factory, pipe\n\n\n__all__ = [\n    \"default_if_none\",\n    \"optional\",\n    \"pipe\",\n    \"to_bool\",\n]\n\n\ndef optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to `None`.\n\n    Type annotations will be inferred from the wrapped converter's, if it has\n    any.\n\n    :param typing.Callable converter: the converter that is used for non-`None`\n        values.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n\n    def optional_converter(val):\n        if val is None:\n            return None\n        return converter(val)\n\n    xtr = _AnnotationExtractor(converter)\n\n    t = xtr.get_first_param_type()\n    if t:\n        optional_converter.__annotations__[\"val\"] = typing.Optional[t]\n\n    rt = xtr.get_return_type()\n    if rt:\n        optional_converter.__annotations__[\"return\"] = typing.Optional[rt]\n\n    return optional_converter\n\n\ndef default_if_none(default=NOTHING, factory=None):\n    \"\"\"\n    A converter that allows to replace `None` values by *default* or the result\n    of *factory*.\n\n    :param default: Value to be used if `None` is passed. Passing an instance\n       of `attrs.Factory` is supported, however the ``takes_self`` option is\n       *not*.\n    :param typing.Callable factory: A callable that takes no parameters whose\n       result is used if `None` is passed.\n\n    :raises TypeError: If **neither** *default* or *factory* is passed.\n    :raises TypeError: If **both** *default* and *factory* are passed.\n    :raises ValueError: If an instance of `attrs.Factory` is passed with\n       ``takes_self=True``.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n    if default is NOTHING and factory is None:\n        msg = \"Must pass either `default` or `factory`.\"\n        raise TypeError(msg)\n\n    if default is not NOTHING and factory is not None:\n        msg = \"Must pass either `default` or `factory` but not both.\"\n        raise TypeError(msg)\n\n    if factory is not None:\n        default = Factory(factory)\n\n    if isinstance(default, Factory):\n        if default.takes_self:\n            msg = \"`takes_self` is not supported by default_if_none.\"\n            raise ValueError(msg)\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default.factory()\n\n    else:\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default\n\n    return default_if_none_converter\n\n\ndef to_bool(val):\n    \"\"\"\n    Convert \"boolean\" strings (for example, from environment variables) to real\n    booleans.\n\n    Values mapping to `True`:\n\n    - ``True``\n    - ``\"true\"`` / ``\"t\"``\n    - ``\"yes\"`` / ``\"y\"``\n    - ``\"on\"``\n    - ``\"1\"``\n    - ``1``\n\n    Values mapping to `False`:\n\n    - ``False``\n    - ``\"false\"`` / ``\"f\"``\n    - ``\"no\"`` / ``\"n\"``\n    - ``\"off\"``\n    - ``\"0\"``\n    - ``0``\n\n    :raises ValueError: for any other value.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    if val in (True, \"true\", \"t\", \"yes\", \"y\", \"on\", \"1\", 1):\n        return True\n    if val in (False, \"false\", \"f\", \"no\", \"n\", \"off\", \"0\", 0):\n        return False\n\n    msg = f\"Cannot convert value to bool: {val!r}\"\n    raise ValueError(msg)\n", "src/attr/_next_gen.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nThese are keyword-only APIs that call `attr.s` and `attr.ib` with different\ndefault values.\n\"\"\"\n\n\nfrom functools import partial\n\nfrom . import setters\nfrom ._funcs import asdict as _asdict\nfrom ._funcs import astuple as _astuple\nfrom ._make import (\n    _DEFAULT_ON_SETATTR,\n    NOTHING,\n    _frozen_setattrs,\n    attrib,\n    attrs,\n)\nfrom .exceptions import UnannotatedAttributeError\n\n\ndef define(\n    maybe_cls=None,\n    *,\n    these=None,\n    repr=None,\n    unsafe_hash=None,\n    hash=None,\n    init=None,\n    slots=True,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=None,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=True,\n    eq=None,\n    order=False,\n    auto_detect=True,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n    match_args=True,\n):\n    r\"\"\"\n    Define an *attrs* class.\n\n    Differences to the classic `attr.s` that it uses underneath:\n\n    - Automatically detect whether or not *auto_attribs* should be `True` (c.f.\n      *auto_attribs* parameter).\n    - Converters and validators run when attributes are set by default -- if\n      *frozen* is `False`.\n    - *slots=True*\n\n      .. caution::\n\n         Usually this has only upsides and few visible effects in everyday\n         programming. But it *can* lead to some surprising behaviors, so please\n         make sure to read :term:`slotted classes`.\n    - *auto_exc=True*\n    - *auto_detect=True*\n    - *order=False*\n    - Some options that were only relevant on Python 2 or were kept around for\n      backwards-compatibility have been removed.\n\n    Please note that these are all defaults and you can change them as you\n    wish.\n\n    :param bool | None auto_attribs: If set to `True` or `False`, it behaves\n       exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n\n       1. If any attributes are annotated and no unannotated `attrs.fields`\\ s\n          are found, it assumes *auto_attribs=True*.\n       2. Otherwise it assumes *auto_attribs=False* and tries to collect\n          `attrs.fields`\\ s.\n\n    For now, please refer to `attr.s` for the rest of the parameters.\n\n    .. versionadded:: 20.1.0\n    .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.\n    .. versionadded:: 22.2.0\n       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).\n    \"\"\"\n\n    def do_it(cls, auto_attribs):\n        return attrs(\n            maybe_cls=cls,\n            these=these,\n            repr=repr,\n            hash=hash,\n            unsafe_hash=unsafe_hash,\n            init=init,\n            slots=slots,\n            frozen=frozen,\n            weakref_slot=weakref_slot,\n            str=str,\n            auto_attribs=auto_attribs,\n            kw_only=kw_only,\n            cache_hash=cache_hash,\n            auto_exc=auto_exc,\n            eq=eq,\n            order=order,\n            auto_detect=auto_detect,\n            collect_by_mro=True,\n            getstate_setstate=getstate_setstate,\n            on_setattr=on_setattr,\n            field_transformer=field_transformer,\n            match_args=match_args,\n        )\n\n    def wrap(cls):\n        \"\"\"\n        Making this a wrapper ensures this code runs during class creation.\n\n        We also ensure that frozen-ness of classes is inherited.\n        \"\"\"\n        nonlocal frozen, on_setattr\n\n        had_on_setattr = on_setattr not in (None, setters.NO_OP)\n\n        # By default, mutable classes convert & validate on setattr.\n        if frozen is False and on_setattr is None:\n            on_setattr = _DEFAULT_ON_SETATTR\n\n        # However, if we subclass a frozen class, we inherit the immutability\n        # and disable on_setattr.\n        for base_cls in cls.__bases__:\n            if base_cls.__setattr__ is _frozen_setattrs:\n                if had_on_setattr:\n                    msg = \"Frozen classes can't use on_setattr (frozen-ness was inherited).\"\n                    raise ValueError(msg)\n\n                on_setattr = setters.NO_OP\n                break\n\n        if auto_attribs is not None:\n            return do_it(cls, auto_attribs)\n\n        try:\n            return do_it(cls, True)\n        except UnannotatedAttributeError:\n            return do_it(cls, False)\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but `None` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n\n    return wrap(maybe_cls)\n\n\nmutable = define\nfrozen = partial(define, frozen=True, on_setattr=None)\n\n\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n    alias=None,\n):\n    \"\"\"\n    Identical to `attr.ib`, except keyword-only and with some arguments\n    removed.\n\n    .. versionadded:: 23.1.0\n       The *type* parameter has been re-added; mostly for `attrs.make_class`.\n       Please note that type checkers ignore this metadata.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    return attrib(\n        default=default,\n        validator=validator,\n        repr=repr,\n        hash=hash,\n        init=init,\n        metadata=metadata,\n        type=type,\n        converter=converter,\n        factory=factory,\n        kw_only=kw_only,\n        eq=eq,\n        order=order,\n        on_setattr=on_setattr,\n        alias=alias,\n    )\n\n\ndef asdict(inst, *, recurse=True, filter=None, value_serializer=None):\n    \"\"\"\n    Same as `attr.asdict`, except that collections types are always retained\n    and dict is always used as *dict_factory*.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _asdict(\n        inst=inst,\n        recurse=recurse,\n        filter=filter,\n        value_serializer=value_serializer,\n        retain_collection_types=True,\n    )\n\n\ndef astuple(inst, *, recurse=True, filter=None):\n    \"\"\"\n    Same as `attr.astuple`, except that collections types are always retained\n    and `tuple` is always used as the *tuple_factory*.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _astuple(\n        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True\n    )\n", "src/attr/setters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly used hooks for on_setattr.\n\"\"\"\n\n\nfrom . import _config\nfrom .exceptions import FrozenAttributeError\n\n\ndef pipe(*setters):\n    \"\"\"\n    Run all *setters* and return the return value of the last one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def wrapped_pipe(instance, attrib, new_value):\n        rv = new_value\n\n        for setter in setters:\n            rv = setter(instance, attrib, rv)\n\n        return rv\n\n    return wrapped_pipe\n\n\ndef frozen(_, __, ___):\n    \"\"\"\n    Prevent an attribute to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    raise FrozenAttributeError()\n\n\ndef validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    if _config._run_validators is False:\n        return new_value\n\n    v = attrib.validator\n    if not v:\n        return new_value\n\n    v(instance, attrib, new_value)\n\n    return new_value\n\n\ndef convert(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n    result.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    c = attrib.converter\n    if c:\n        return c(new_value)\n\n    return new_value\n\n\n# Sentinel for disabling class-wide *on_setattr* hooks for certain attributes.\n# Sphinx's autodata stopped working, so the docstring is inlined in the API\n# docs.\nNO_OP = object()\n", "src/attr/validators.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful validators.\n\"\"\"\n\n\nimport operator\nimport re\n\nfrom contextlib import contextmanager\nfrom re import Pattern\n\nfrom ._config import get_run_validators, set_run_validators\nfrom ._make import _AndValidator, and_, attrib, attrs\nfrom .converters import default_if_none\nfrom .exceptions import NotCallableError\n\n\n__all__ = [\n    \"and_\",\n    \"deep_iterable\",\n    \"deep_mapping\",\n    \"disabled\",\n    \"ge\",\n    \"get_disabled\",\n    \"gt\",\n    \"in_\",\n    \"instance_of\",\n    \"is_callable\",\n    \"le\",\n    \"lt\",\n    \"matches_re\",\n    \"max_len\",\n    \"min_len\",\n    \"not_\",\n    \"optional\",\n    \"set_disabled\",\n]\n\n\ndef set_disabled(disabled):\n    \"\"\"\n    Globally disable or enable running validators.\n\n    By default, they are run.\n\n    :param disabled: If `True`, disable running all validators.\n    :type disabled: bool\n\n    .. warning::\n\n        This function is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(not disabled)\n\n\ndef get_disabled():\n    \"\"\"\n    Return a bool indicating whether validators are currently disabled or not.\n\n    :return: `True` if validators are currently disabled.\n    :rtype: bool\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return not get_run_validators()\n\n\n@contextmanager\ndef disabled():\n    \"\"\"\n    Context manager that disables running validators within its context.\n\n    .. warning::\n\n        This context manager is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(False)\n    try:\n        yield\n    finally:\n        set_run_validators(True)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _InstanceOfValidator:\n    type = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not isinstance(value, self.type):\n            msg = f\"'{attr.name}' must be {self.type!r} (got {value!r} that is a {value.__class__!r}).\"\n            raise TypeError(\n                msg,\n                attr,\n                self.type,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<instance_of validator for type {self.type!r}>\"\n\n\ndef instance_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called with a\n    wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n\n    :param type | tuple[type] type: The type to check for.\n\n    :raises TypeError: With a human readable error message, the attribute (of\n        type `attrs.Attribute`), the expected type, and the value it got.\n    \"\"\"\n    return _InstanceOfValidator(type)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MatchesReValidator:\n    pattern = attrib()\n    match_func = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.match_func(value):\n            msg = f\"'{attr.name}' must match regex {self.pattern.pattern!r} ({value!r} doesn't)\"\n            raise ValueError(\n                msg,\n                attr,\n                self.pattern,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<matches_re validator for pattern {self.pattern!r}>\"\n\n\ndef matches_re(regex, flags=0, func=None):\n    r\"\"\"\n    A validator that raises `ValueError` if the initializer is called with a\n    string that doesn't match *regex*.\n\n    :param regex: a regex string or precompiled pattern to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param typing.Callable func: which underlying `re` function to call. Valid\n        options are `re.fullmatch`, `re.search`, and `re.match`; the default\n        `None` means `re.fullmatch`. For performance reasons, the pattern is\n        always precompiled using `re.compile`.\n\n    .. versionadded:: 19.2.0\n    .. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.\n    \"\"\"\n    valid_funcs = (re.fullmatch, None, re.search, re.match)\n    if func not in valid_funcs:\n        msg = \"'func' must be one of {}.\".format(\n            \", \".join(\n                sorted(e and e.__name__ or \"None\" for e in set(valid_funcs))\n            )\n        )\n        raise ValueError(msg)\n\n    if isinstance(regex, Pattern):\n        if flags:\n            msg = \"'flags' can only be used with a string pattern; pass flags to re.compile() instead\"\n            raise TypeError(msg)\n        pattern = regex\n    else:\n        pattern = re.compile(regex, flags)\n\n    if func is re.match:\n        match_func = pattern.match\n    elif func is re.search:\n        match_func = pattern.search\n    else:\n        match_func = pattern.fullmatch\n\n    return _MatchesReValidator(pattern, match_func)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _OptionalValidator:\n    validator = attrib()\n\n    def __call__(self, inst, attr, value):\n        if value is None:\n            return\n\n        self.validator(inst, attr, value)\n\n    def __repr__(self):\n        return f\"<optional validator for {self.validator!r} or None>\"\n\n\ndef optional(validator):\n    \"\"\"\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to `None` in addition to satisfying the requirements of\n    the sub-validator.\n\n    :param validator: A validator (or validators) that is used for non-`None`\n        values.\n    :type validator: typing.Callable | tuple[typing.Callable] |\n        list[typing.Callable]\n\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.\n    .. versionchanged:: 23.1.0 *validator* can also be a tuple of validators.\n    \"\"\"\n    if isinstance(validator, (list, tuple)):\n        return _OptionalValidator(_AndValidator(validator))\n\n    return _OptionalValidator(validator)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _InValidator:\n    options = attrib()\n\n    def __call__(self, inst, attr, value):\n        try:\n            in_options = value in self.options\n        except TypeError:  # e.g. `1 in \"abc\"`\n            in_options = False\n\n        if not in_options:\n            msg = f\"'{attr.name}' must be in {self.options!r} (got {value!r})\"\n            raise ValueError(\n                msg,\n                attr,\n                self.options,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<in_ validator with options {self.options!r}>\"\n\n\ndef in_(options):\n    \"\"\"\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attrs.Attribute`), the expected options, and the value it\n       got.\n\n    .. versionadded:: 17.1.0\n    .. versionchanged:: 22.1.0\n       The ValueError was incomplete until now and only contained the human\n       readable error message. Now it contains all the information that has\n       been promised since 17.1.0.\n    \"\"\"\n    return _InValidator(options)\n\n\n@attrs(repr=False, slots=False, hash=True)\nclass _IsCallableValidator:\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not callable(value):\n            message = (\n                \"'{name}' must be callable \"\n                \"(got {value!r} that is a {actual!r}).\"\n            )\n            raise NotCallableError(\n                msg=message.format(\n                    name=attr.name, value=value, actual=value.__class__\n                ),\n                value=value,\n            )\n\n    def __repr__(self):\n        return \"<is_callable validator>\"\n\n\ndef is_callable():\n    \"\"\"\n    A validator that raises a `attrs.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n\n    .. versionadded:: 19.1.0\n\n    :raises attrs.exceptions.NotCallableError: With a human readable error\n        message containing the attribute (`attrs.Attribute`) name,\n        and the value it got.\n    \"\"\"\n    return _IsCallableValidator()\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _DeepIterable:\n    member_validator = attrib(validator=is_callable())\n    iterable_validator = attrib(\n        default=None, validator=optional(is_callable())\n    )\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.iterable_validator is not None:\n            self.iterable_validator(inst, attr, value)\n\n        for member in value:\n            self.member_validator(inst, attr, member)\n\n    def __repr__(self):\n        iterable_identifier = (\n            \"\"\n            if self.iterable_validator is None\n            else f\" {self.iterable_validator!r}\"\n        )\n        return (\n            f\"<deep_iterable validator for{iterable_identifier}\"\n            f\" iterables of {self.member_validator!r}>\"\n        )\n\n\ndef deep_iterable(member_validator, iterable_validator=None):\n    \"\"\"\n    A validator that performs deep validation of an iterable.\n\n    :param member_validator: Validator(s) to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    if isinstance(member_validator, (list, tuple)):\n        member_validator = and_(*member_validator)\n    return _DeepIterable(member_validator, iterable_validator)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _DeepMapping:\n    key_validator = attrib(validator=is_callable())\n    value_validator = attrib(validator=is_callable())\n    mapping_validator = attrib(default=None, validator=optional(is_callable()))\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.mapping_validator is not None:\n            self.mapping_validator(inst, attr, value)\n\n        for key in value:\n            self.key_validator(inst, attr, key)\n            self.value_validator(inst, attr, value[key])\n\n    def __repr__(self):\n        return f\"<deep_mapping validator for objects mapping {self.key_validator!r} to {self.value_validator!r}>\"\n\n\ndef deep_mapping(key_validator, value_validator, mapping_validator=None):\n    \"\"\"\n    A validator that performs deep validation of a dictionary.\n\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    return _DeepMapping(key_validator, value_validator, mapping_validator)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _NumberValidator:\n    bound = attrib()\n    compare_op = attrib()\n    compare_func = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.compare_func(value, self.bound):\n            msg = f\"'{attr.name}' must be {self.compare_op} {self.bound}: {value}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<Validator for x {self.compare_op} {self.bound}>\"\n\n\ndef lt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number larger or equal to *val*.\n\n    :param val: Exclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<\", operator.lt)\n\n\ndef le(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number greater than *val*.\n\n    :param val: Inclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<=\", operator.le)\n\n\ndef ge(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller than *val*.\n\n    :param val: Inclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">=\", operator.ge)\n\n\ndef gt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller or equal to *val*.\n\n    :param val: Exclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">\", operator.gt)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MaxLengthValidator:\n    max_length = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) > self.max_length:\n            msg = f\"Length of '{attr.name}' must be <= {self.max_length}: {len(value)}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<max_len validator for {self.max_length}>\"\n\n\ndef max_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is longer than *length*.\n\n    :param int length: Maximum length of the string or iterable\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _MaxLengthValidator(length)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MinLengthValidator:\n    min_length = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) < self.min_length:\n            msg = f\"Length of '{attr.name}' must be >= {self.min_length}: {len(value)}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<min_len validator for {self.min_length}>\"\n\n\ndef min_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is shorter than *length*.\n\n    :param int length: Minimum length of the string or iterable\n\n    .. versionadded:: 22.1.0\n    \"\"\"\n    return _MinLengthValidator(length)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _SubclassOfValidator:\n    type = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not issubclass(value, self.type):\n            msg = f\"'{attr.name}' must be a subclass of {self.type!r} (got {value!r}).\"\n            raise TypeError(\n                msg,\n                attr,\n                self.type,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<subclass_of validator for type {self.type!r}>\"\n\n\ndef _subclass_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `issubclass` therefore it's also valid to pass a tuple of types).\n\n    :param type: The type to check for.\n    :type type: type or tuple of types\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.\n    \"\"\"\n    return _SubclassOfValidator(type)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _NotValidator:\n    validator = attrib()\n    msg = attrib(\n        converter=default_if_none(\n            \"not_ validator child '{validator!r}' \"\n            \"did not raise a captured error\"\n        )\n    )\n    exc_types = attrib(\n        validator=deep_iterable(\n            member_validator=_subclass_of(Exception),\n            iterable_validator=instance_of(tuple),\n        ),\n    )\n\n    def __call__(self, inst, attr, value):\n        try:\n            self.validator(inst, attr, value)\n        except self.exc_types:\n            pass  # suppress error to invert validity\n        else:\n            raise ValueError(\n                self.msg.format(\n                    validator=self.validator,\n                    exc_types=self.exc_types,\n                ),\n                attr,\n                self.validator,\n                value,\n                self.exc_types,\n            )\n\n    def __repr__(self):\n        return f\"<not_ validator wrapping {self.validator!r}, capturing {self.exc_types!r}>\"\n\n\ndef not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):\n    \"\"\"\n    A validator that wraps and logically 'inverts' the validator passed to it.\n    It will raise a `ValueError` if the provided validator *doesn't* raise a\n    `ValueError` or `TypeError` (by default), and will suppress the exception\n    if the provided validator *does*.\n\n    Intended to be used with existing validators to compose logic without\n    needing to create inverted variants, for example, ``not_(in_(...))``.\n\n    :param validator: A validator to be logically inverted.\n    :param msg: Message to raise if validator fails.\n        Formatted with keys ``exc_types`` and ``validator``.\n    :type msg: str\n    :param exc_types: Exception type(s) to capture.\n        Other types raised by child validators will not be intercepted and\n        pass through.\n\n    :raises ValueError: With a human readable error message,\n        the attribute (of type `attrs.Attribute`),\n        the validator that failed to raise an exception,\n        the value it got,\n        and the expected exception types.\n\n    .. versionadded:: 22.2.0\n    \"\"\"\n    try:\n        exc_types = tuple(exc_types)\n    except TypeError:\n        exc_types = (exc_types,)\n    return _NotValidator(validator, msg, exc_types)\n", "src/attr/_compat.py": "# SPDX-License-Identifier: MIT\n\nimport inspect\nimport platform\nimport sys\nimport threading\n\nfrom collections.abc import Mapping, Sequence  # noqa: F401\nfrom typing import _GenericAlias\n\n\nPYPY = platform.python_implementation() == \"PyPy\"\nPY_3_8_PLUS = sys.version_info[:2] >= (3, 8)\nPY_3_9_PLUS = sys.version_info[:2] >= (3, 9)\nPY_3_10_PLUS = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\nPY_3_13_PLUS = sys.version_info[:2] >= (3, 13)\n\n\nif sys.version_info < (3, 8):\n    try:\n        from typing_extensions import Protocol\n    except ImportError:  # pragma: no cover\n        Protocol = object\nelse:\n    from typing import Protocol  # noqa: F401\n\n\nclass _AnnotationExtractor:\n    \"\"\"\n    Extract type annotations from a callable, returning None whenever there\n    is none.\n    \"\"\"\n\n    __slots__ = [\"sig\"]\n\n    def __init__(self, callable):\n        try:\n            self.sig = inspect.signature(callable)\n        except (ValueError, TypeError):  # inspect failed\n            self.sig = None\n\n    def get_first_param_type(self):\n        \"\"\"\n        Return the type annotation of the first argument if it's not empty.\n        \"\"\"\n        if not self.sig:\n            return None\n\n        params = list(self.sig.parameters.values())\n        if params and params[0].annotation is not inspect.Parameter.empty:\n            return params[0].annotation\n\n        return None\n\n    def get_return_type(self):\n        \"\"\"\n        Return the return type if it's not empty.\n        \"\"\"\n        if (\n            self.sig\n            and self.sig.return_annotation is not inspect.Signature.empty\n        ):\n            return self.sig.return_annotation\n\n        return None\n\n\n# Thread-local global to track attrs instances which are already being repr'd.\n# This is needed because there is no other (thread-safe) way to pass info\n# about the instances that are already being repr'd through the call stack\n# in order to ensure we don't perform infinite recursion.\n#\n# For instance, if an instance contains a dict which contains that instance,\n# we need to know that we're already repr'ing the outside instance from within\n# the dict's repr() call.\n#\n# This lives here rather than in _make.py so that the functions in _make.py\n# don't have a direct reference to the thread-local in their globals dict.\n# If they have such a reference, it breaks cloudpickle.\nrepr_context = threading.local()\n\n\ndef get_generic_base(cl):\n    \"\"\"If this is a generic class (A[str]), return the generic base for it.\"\"\"\n    if cl.__class__ is _GenericAlias:\n        return cl.__origin__\n    return None\n", "src/attr/__init__.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nClasses Without Boilerplate\n\"\"\"\n\nfrom functools import partial\nfrom typing import Callable\n\nfrom . import converters, exceptions, filters, setters, validators\nfrom ._cmp import cmp_using\nfrom ._compat import Protocol\nfrom ._config import get_run_validators, set_run_validators\nfrom ._funcs import asdict, assoc, astuple, evolve, has, resolve_types\nfrom ._make import (\n    NOTHING,\n    Attribute,\n    Factory,\n    attrib,\n    attrs,\n    fields,\n    fields_dict,\n    make_class,\n    validate,\n)\nfrom ._next_gen import define, field, frozen, mutable\nfrom ._version_info import VersionInfo\n\n\ns = attributes = attrs\nib = attr = attrib\ndataclass = partial(attrs, auto_attribs=True)  # happy Easter ;)\n\n\nclass AttrsInstance(Protocol):\n    pass\n\n\n__all__ = [\n    \"Attribute\",\n    \"AttrsInstance\",\n    \"Factory\",\n    \"NOTHING\",\n    \"asdict\",\n    \"assoc\",\n    \"astuple\",\n    \"attr\",\n    \"attrib\",\n    \"attributes\",\n    \"attrs\",\n    \"cmp_using\",\n    \"converters\",\n    \"define\",\n    \"evolve\",\n    \"exceptions\",\n    \"field\",\n    \"fields\",\n    \"fields_dict\",\n    \"filters\",\n    \"frozen\",\n    \"get_run_validators\",\n    \"has\",\n    \"ib\",\n    \"make_class\",\n    \"mutable\",\n    \"resolve_types\",\n    \"s\",\n    \"set_run_validators\",\n    \"setters\",\n    \"validate\",\n    \"validators\",\n]\n\n\ndef _make_getattr(mod_name: str) -> Callable:\n    \"\"\"\n    Create a metadata proxy for packaging information that uses *mod_name* in\n    its warnings and errors.\n    \"\"\"\n\n    def __getattr__(name: str) -> str:\n        if name not in (\"__version__\", \"__version_info__\"):\n            msg = f\"module {mod_name} has no attribute {name}\"\n            raise AttributeError(msg)\n\n        try:\n            from importlib.metadata import metadata\n        except ImportError:\n            from importlib_metadata import metadata\n\n        meta = metadata(\"attrs\")\n\n        if name == \"__version_info__\":\n            return VersionInfo._from_version_string(meta[\"version\"])\n\n        return meta[\"version\"]\n\n    return __getattr__\n\n\n__getattr__ = _make_getattr(__name__)\n", "src/attr/_cmp.py": "# SPDX-License-Identifier: MIT\n\n\nimport functools\nimport types\n\nfrom ._make import _make_ne\n\n\n_operation_names = {\"eq\": \"==\", \"lt\": \"<\", \"le\": \"<=\", \"gt\": \">\", \"ge\": \">=\"}\n\n\ndef cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"\n    Create a class that can be passed into `attrs.field`'s ``eq``, ``order``,\n    and ``cmp`` arguments to customize field comparison.\n\n    The resulting class will have a full set of ordering methods if at least\n    one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n\n    :param typing.Callable | None eq: Callable used to evaluate equality of two\n        objects.\n    :param typing.Callable | None lt: Callable used to evaluate whether one\n        object is less than another object.\n    :param typing.Callable | None le: Callable used to evaluate whether one\n        object is less than or equal to another object.\n    :param typing.Callable | None gt: Callable used to evaluate whether one\n        object is greater than another object.\n    :param typing.Callable | None ge: Callable used to evaluate whether one\n        object is greater than or equal to another object.\n\n    :param bool require_same_type: When `True`, equality and ordering methods\n        will return `NotImplemented` if objects are not of the same type.\n\n    :param str | None class_name: Name of class. Defaults to \"Comparable\".\n\n    See `comparison` for more details.\n\n    .. versionadded:: 21.1.0\n    \"\"\"\n\n    body = {\n        \"__slots__\": [\"value\"],\n        \"__init__\": _make_init(),\n        \"_requirements\": [],\n        \"_is_comparable_to\": _is_comparable_to,\n    }\n\n    # Add operations.\n    num_order_functions = 0\n    has_eq_function = False\n\n    if eq is not None:\n        has_eq_function = True\n        body[\"__eq__\"] = _make_operator(\"eq\", eq)\n        body[\"__ne__\"] = _make_ne()\n\n    if lt is not None:\n        num_order_functions += 1\n        body[\"__lt__\"] = _make_operator(\"lt\", lt)\n\n    if le is not None:\n        num_order_functions += 1\n        body[\"__le__\"] = _make_operator(\"le\", le)\n\n    if gt is not None:\n        num_order_functions += 1\n        body[\"__gt__\"] = _make_operator(\"gt\", gt)\n\n    if ge is not None:\n        num_order_functions += 1\n        body[\"__ge__\"] = _make_operator(\"ge\", ge)\n\n    type_ = types.new_class(\n        class_name, (object,), {}, lambda ns: ns.update(body)\n    )\n\n    # Add same type requirement.\n    if require_same_type:\n        type_._requirements.append(_check_same_type)\n\n    # Add total ordering if at least one operation was defined.\n    if 0 < num_order_functions < 4:\n        if not has_eq_function:\n            # functools.total_ordering requires __eq__ to be defined,\n            # so raise early error here to keep a nice stack.\n            msg = \"eq must be define is order to complete ordering from lt, le, gt, ge.\"\n            raise ValueError(msg)\n        type_ = functools.total_ordering(type_)\n\n    return type_\n\n\ndef _make_init():\n    \"\"\"\n    Create __init__ method.\n    \"\"\"\n\n    def __init__(self, value):\n        \"\"\"\n        Initialize object with *value*.\n        \"\"\"\n        self.value = value\n\n    return __init__\n\n\ndef _make_operator(name, func):\n    \"\"\"\n    Create operator method.\n    \"\"\"\n\n    def method(self, other):\n        if not self._is_comparable_to(other):\n            return NotImplemented\n\n        result = func(self.value, other.value)\n        if result is NotImplemented:\n            return NotImplemented\n\n        return result\n\n    method.__name__ = f\"__{name}__\"\n    method.__doc__ = (\n        f\"Return a {_operation_names[name]} b.  Computed by attrs.\"\n    )\n\n    return method\n\n\ndef _is_comparable_to(self, other):\n    \"\"\"\n    Check whether `other` is comparable to `self`.\n    \"\"\"\n    return all(func(self, other) for func in self._requirements)\n\n\ndef _check_same_type(self, other):\n    \"\"\"\n    Return True if *self* and *other* are of the same type, False otherwise.\n    \"\"\"\n    return other.value.__class__ is self.value.__class__\n", "src/attrs/filters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.filters import *  # noqa: F403\n", "src/attrs/exceptions.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.exceptions import *  # noqa: F403\n", "src/attrs/converters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.converters import *  # noqa: F403\n", "src/attrs/setters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.setters import *  # noqa: F403\n", "src/attrs/validators.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.validators import *  # noqa: F403\n", "src/attrs/__init__.py": "# SPDX-License-Identifier: MIT\n\nfrom attr import (\n    NOTHING,\n    Attribute,\n    AttrsInstance,\n    Factory,\n    _make_getattr,\n    assoc,\n    cmp_using,\n    define,\n    evolve,\n    field,\n    fields,\n    fields_dict,\n    frozen,\n    has,\n    make_class,\n    mutable,\n    resolve_types,\n    validate,\n)\nfrom attr._next_gen import asdict, astuple\n\nfrom . import converters, exceptions, filters, setters, validators\n\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__description__\",\n    \"__doc__\",\n    \"__email__\",\n    \"__license__\",\n    \"__title__\",\n    \"__url__\",\n    \"__version__\",\n    \"__version_info__\",\n    \"asdict\",\n    \"assoc\",\n    \"astuple\",\n    \"Attribute\",\n    \"AttrsInstance\",\n    \"cmp_using\",\n    \"converters\",\n    \"define\",\n    \"evolve\",\n    \"exceptions\",\n    \"Factory\",\n    \"field\",\n    \"fields_dict\",\n    \"fields\",\n    \"filters\",\n    \"frozen\",\n    \"has\",\n    \"make_class\",\n    \"mutable\",\n    \"NOTHING\",\n    \"resolve_types\",\n    \"setters\",\n    \"validate\",\n    \"validators\",\n]\n\n__getattr__ = _make_getattr(__name__)\n"}