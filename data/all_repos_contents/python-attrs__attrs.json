{"src/attr/filters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful filters for `attr.asdict`.\n\"\"\"\n\nfrom ._make import Attribute\n\n\ndef _split_what(what):\n    \"\"\"\n    Returns a tuple of `frozenset`s of classes and attributes.\n    \"\"\"\n    return (\n        frozenset(cls for cls in what if isinstance(cls, type)),\n        frozenset(cls for cls in what if isinstance(cls, str)),\n        frozenset(cls for cls in what if isinstance(cls, Attribute)),\n    )\n\n\ndef include(*what):\n    \"\"\"\n    Include *what*.\n\n    :param what: What to include.\n    :type what: `list` of classes `type`, field names `str` or\n        `attrs.Attribute`\\\\ s\n\n    :rtype: `callable`\n\n    .. versionchanged:: 23.1.0 Accept strings with field names.\n    \"\"\"\n    cls, names, attrs = _split_what(what)\n\n    def include_(attribute, value):\n        return (\n            value.__class__ in cls\n            or attribute.name in names\n            or attribute in attrs\n        )\n\n    return include_\n\n\ndef exclude(*what):\n    \"\"\"\n    Exclude *what*.\n\n    :param what: What to exclude.\n    :type what: `list` of classes `type`, field names `str` or\n        `attrs.Attribute`\\\\ s.\n\n    :rtype: `callable`\n\n    .. versionchanged:: 23.3.0 Accept field name string as input argument\n    \"\"\"\n    cls, names, attrs = _split_what(what)\n\n    def exclude_(attribute, value):\n        return not (\n            value.__class__ in cls\n            or attribute.name in names\n            or attribute in attrs\n        )\n\n    return exclude_\n", "src/attr/exceptions.py": "# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nfrom typing import ClassVar\n\n\nclass FrozenError(AttributeError):\n    \"\"\"\n    A frozen/immutable instance or attribute have been attempted to be\n    modified.\n\n    It mirrors the behavior of ``namedtuples`` by using the same error message\n    and subclassing `AttributeError`.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    msg = \"can't set attribute\"\n    args: ClassVar[tuple[str]] = [msg]\n\n\nclass FrozenInstanceError(FrozenError):\n    \"\"\"\n    A frozen instance has been attempted to be modified.\n\n    .. versionadded:: 16.1.0\n    \"\"\"\n\n\nclass FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n\nclass AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An *attrs* function couldn't find an attribute that the user asked for.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n\n\nclass NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-*attrs* class has been passed into an *attrs* function.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n\n\nclass DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set when defining the field and is attempted to be reset\n    using the decorator.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n\n\nclass UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has a field without a type annotation.\n\n    .. versionadded:: 17.3.0\n    \"\"\"\n\n\nclass PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an *attrs* feature that requires a newer Python\n    version.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n\n\nclass NotCallableError(TypeError):\n    \"\"\"\n    A field requiring a callable has been set with a value that is not\n    callable.\n\n    .. versionadded:: 19.2.0\n    \"\"\"\n\n    def __init__(self, msg, value):\n        super(TypeError, self).__init__(msg, value)\n        self.msg = msg\n        self.value = value\n\n    def __str__(self):\n        return str(self.msg)\n", "src/attr/_make.py": "# SPDX-License-Identifier: MIT\n\nimport contextlib\nimport copy\nimport enum\nimport functools\nimport inspect\nimport itertools\nimport linecache\nimport sys\nimport types\nimport typing\n\nfrom operator import itemgetter\n\n# We need to import _compat itself in addition to the _compat members to avoid\n# having the thread-local in the globals here.\nfrom . import _compat, _config, setters\nfrom ._compat import (\n    PY_3_8_PLUS,\n    PY_3_10_PLUS,\n    _AnnotationExtractor,\n    get_generic_base,\n)\nfrom .exceptions import (\n    DefaultAlreadySetError,\n    FrozenInstanceError,\n    NotAnAttrsClassError,\n    UnannotatedAttributeError,\n)\n\n\n# This is used at least twice, so cache it here.\n_OBJ_SETATTR = object.__setattr__\n_INIT_CONVERTER_PAT = \"__attr_converter_%s\"\n_INIT_FACTORY_PAT = \"__attr_factory_%s\"\n_CLASSVAR_PREFIXES = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)\n_HASH_CACHE_FIELD = \"_attrs_cached_hash\"\n\n_EMPTY_METADATA_SINGLETON = types.MappingProxyType({})\n\n# Unique object for unequivocal getattr() defaults.\n_SENTINEL = object()\n\n_DEFAULT_ON_SETATTR = setters.pipe(setters.convert, setters.validate)\n\n\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when `None` is ambiguous.\n\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n\n    NOTHING = enum.auto()\n\n    def __repr__(self):\n        return \"NOTHING\"\n\n    def __bool__(self):\n        return False\n\n\nNOTHING = _Nothing.NOTHING\n\"\"\"\nSentinel to indicate the lack of a value when `None` is ambiguous.\n\"\"\"\n\n\nclass _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since `None`\n    is the default value for uncalculated hashes, whenever this is copied,\n    the copy's value for the hash should automatically reset.\n\n    See GH #613 for more details.\n    \"\"\"\n\n    def __reduce__(self, _none_constructor=type(None), _args=()):  # noqa: B008\n        return _none_constructor, _args\n\n\ndef attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n    alias=None,\n):\n    \"\"\"\n    Create a new attribute on a class.\n\n    ..  warning::\n\n        Does *not* do anything unless the class is also decorated with `attr.s`\n        / `attrs.define` / and so on!\n\n    Please consider using `attrs.field` in new code (``attr.ib`` will *never*\n    go away, though).\n\n    :param default: A value that is used if an *attrs*-generated ``__init__``\n        is used and no value is passed while instantiating or the attribute is\n        excluded using ``init=False``.\n\n        If the value is an instance of `attrs.Factory`, its callable will be\n        used to construct a new value (useful for mutable data types like lists\n        or dicts).\n\n        If a default is not set (or set manually to `attrs.NOTHING`), a value\n        *must* be supplied when instantiating; otherwise a `TypeError` will be\n        raised.\n\n        The default can also be set using decorator notation as shown below.\n\n        .. seealso:: `defaults`\n\n    :param ~typing.Callable factory: Syntactic sugar for\n        ``default=attr.Factory(factory)``.\n\n    :param ~typing.Callable | list[~typing.Callable] validator: Callable that\n        is called by *attrs*-generated ``__init__`` methods after the instance\n        has been initialized.  They receive the initialized instance, the\n        :func:`~attrs.Attribute`, and the passed value.\n\n        The return value is *not* inspected so the validator has to throw an\n        exception itself.\n\n        If a `list` is passed, its items are treated as validators and must all\n        pass.\n\n        Validators can be globally disabled and re-enabled using\n        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.\n\n        The validator can also be set using decorator notation as shown below.\n\n        .. seealso:: :ref:`validators`\n\n    :param bool | ~typing.Callable repr: Include this attribute in the\n        generated ``__repr__`` method. If `True`, include the attribute; if\n        `False`, omit it. By default, the built-in ``repr()`` function is used.\n        To override how the attribute value is formatted, pass a ``callable``\n        that takes a single value and returns a string. Note that the resulting\n        string is used as-is, which means it will be used directly *instead* of\n        calling ``repr()`` (the default).\n\n    :param bool | ~typing.Callable eq: If `True` (default), include this\n        attribute in the generated ``__eq__`` and ``__ne__`` methods that check\n        two instances for equality. To override how the attribute value is\n        compared, pass a callable that takes a single value and returns the\n        value to be compared.\n\n        .. seealso:: `comparison`\n\n    :param bool | ~typing.Callable order: If `True` (default), include this\n        attributes in the generated ``__lt__``, ``__le__``, ``__gt__`` and\n        ``__ge__`` methods. To override how the attribute value is ordered,\n        pass a callable that takes a single value and returns the value to be\n        ordered.\n\n        .. seealso:: `comparison`\n\n    :param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the\n        same value. Must not be mixed with *eq* or *order*.\n\n        .. seealso:: `comparison`\n    :type cmp: a `bool` or a `callable`.\n\n    :param bool | None hash: Include this attribute in the generated\n        ``__hash__`` method.  If `None` (default), mirror *eq*'s value.  This\n        is the correct behavior according the Python spec.  Setting this value\n        to anything else than `None` is *discouraged*.\n\n        .. seealso:: `hashing`\n    :param bool init: Include this attribute in the generated ``__init__``\n        method.  It is possible to set this to `False` and set a default value.\n        In that case this attributed is unconditionally initialized with the\n        specified default value or factory.\n\n        .. seealso:: `init`\n    :param typing.Callable converter: `callable` that is called by\n        *attrs*-generated ``__init__`` methods to convert attribute's value to\n        the desired format.  It is given the passed-in value, and the returned\n        value will be used as the new value of the attribute.  The value is\n        converted before being passed to the validator, if any.\n\n        .. seealso:: :ref:`converters`\n    :param dict | None metadata: An arbitrary mapping, to be used by\n        third-party components.  See `extending-metadata`.\n\n    :param type: The type of the attribute. Nowadays, the preferred method to\n        specify the type is using a variable annotation (see :pep:`526`). This\n        argument is provided for backward compatibility. Regardless of the\n        approach used, the type will be stored on ``Attribute.type``.\n\n        Please note that *attrs* doesn't do anything with this metadata by\n        itself. You can use it as part of your own code or for `static type\n        checking <types>`.\n    :param bool kw_only: Make this attribute keyword-only in the generated\n        ``__init__`` (if ``init`` is `False`, this parameter is ignored).\n    :param on_setattr: Allows to overwrite the *on_setattr* setting from\n        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n        Set to `attrs.setters.NO_OP` to run **no** `setattr` hooks for this\n        attribute -- regardless of the setting in `attr.s`.\n    :type on_setattr: ~typing.Callable | list[~typing.Callable] | None |\n        typing.Literal[attrs.setters.NO_OP]\n    :param str | None alias: Override this attribute's parameter name in the\n        generated ``__init__`` method. If left `None`, default to ``name``\n        stripped of leading underscores. See `private-attributes`.\n\n    .. versionadded:: 15.2.0 *convert*\n    .. versionadded:: 16.3.0 *metadata*\n    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n    .. versionchanged:: 17.1.0\n       *hash* is `None` and therefore mirrors *eq* by default.\n    .. versionadded:: 17.3.0 *type*\n    .. deprecated:: 17.4.0 *convert*\n    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n       *convert* to achieve consistency with other noun-based arguments.\n    .. versionadded:: 18.1.0\n       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionchanged:: 19.2.0 *convert* keyword argument removed.\n    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2\n    .. versionchanged:: 21.1.0\n       *eq*, *order*, and *cmp* also accept a custom callable\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    .. versionadded:: 22.2.0 *alias*\n    \"\"\"\n    eq, eq_key, order, order_key = _determine_attrib_eq_order(\n        cmp, eq, order, True\n    )\n\n    if hash is not None and hash is not True and hash is not False:\n        msg = \"Invalid value for hash.  Must be True, False, or None.\"\n        raise TypeError(msg)\n\n    if factory is not None:\n        if default is not NOTHING:\n            msg = (\n                \"The `default` and `factory` arguments are mutually exclusive.\"\n            )\n            raise ValueError(msg)\n        if not callable(factory):\n            msg = \"The `factory` argument must be a callable.\"\n            raise ValueError(msg)\n        default = Factory(factory)\n\n    if metadata is None:\n        metadata = {}\n\n    # Apply syntactic sugar by auto-wrapping.\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    if validator and isinstance(validator, (list, tuple)):\n        validator = and_(*validator)\n\n    if converter and isinstance(converter, (list, tuple)):\n        converter = pipe(*converter)\n\n    return _CountingAttr(\n        default=default,\n        validator=validator,\n        repr=repr,\n        cmp=None,\n        hash=hash,\n        init=init,\n        converter=converter,\n        metadata=metadata,\n        type=type,\n        kw_only=kw_only,\n        eq=eq,\n        eq_key=eq_key,\n        order=order,\n        order_key=order_key,\n        on_setattr=on_setattr,\n        alias=alias,\n    )\n\n\ndef _compile_and_eval(script, globs, locs=None, filename=\"\"):\n    \"\"\"\n    Evaluate the script with the given global (globs) and local (locs)\n    variables.\n    \"\"\"\n    bytecode = compile(script, filename, \"exec\")\n    eval(bytecode, globs, locs)\n\n\ndef _make_method(name, script, filename, globs, locals=None):\n    \"\"\"\n    Create the method with the script given and return the method object.\n    \"\"\"\n    locs = {} if locals is None else locals\n\n    # In order of debuggers like PDB being able to step through the code,\n    # we add a fake linecache entry.\n    count = 1\n    base_filename = filename\n    while True:\n        linecache_tuple = (\n            len(script),\n            None,\n            script.splitlines(True),\n            filename,\n        )\n        old_val = linecache.cache.setdefault(filename, linecache_tuple)\n        if old_val == linecache_tuple:\n            break\n\n        filename = f\"{base_filename[:-1]}-{count}>\"\n        count += 1\n\n    _compile_and_eval(script, globs, locs, filename)\n\n    return locs[name]\n\n\ndef _make_attr_tuple_class(cls_name, attr_names):\n    \"\"\"\n    Create a tuple subclass to hold `Attribute`s for an `attrs` class.\n\n    The subclass is a bare tuple with properties for names.\n\n    class MyClassAttributes(tuple):\n        __slots__ = ()\n        x = property(itemgetter(0))\n    \"\"\"\n    attr_class_name = f\"{cls_name}Attributes\"\n    attr_class_template = [\n        f\"class {attr_class_name}(tuple):\",\n        \"    __slots__ = ()\",\n    ]\n    if attr_names:\n        for i, attr_name in enumerate(attr_names):\n            attr_class_template.append(\n                f\"    {attr_name} = _attrs_property(_attrs_itemgetter({i}))\"\n            )\n    else:\n        attr_class_template.append(\"    pass\")\n    globs = {\"_attrs_itemgetter\": itemgetter, \"_attrs_property\": property}\n    _compile_and_eval(\"\\n\".join(attr_class_template), globs)\n    return globs[attr_class_name]\n\n\n# Tuple class for extracted attributes from a class definition.\n# `base_attrs` is a subset of `attrs`.\n_Attributes = _make_attr_tuple_class(\n    \"_Attributes\",\n    [\n        # all attributes to build dunder methods for\n        \"attrs\",\n        # attributes that have been inherited\n        \"base_attrs\",\n        # map inherited attributes to their originating classes\n        \"base_attrs_map\",\n    ],\n)\n\n\ndef _is_class_var(annot):\n    \"\"\"\n    Check whether *annot* is a typing.ClassVar.\n\n    The string comparison hack is used to avoid evaluating all string\n    annotations which would put attrs-based classes at a performance\n    disadvantage compared to plain old classes.\n    \"\"\"\n    annot = str(annot)\n\n    # Annotation can be quoted.\n    if annot.startswith((\"'\", '\"')) and annot.endswith((\"'\", '\"')):\n        annot = annot[1:-1]\n\n    return annot.startswith(_CLASSVAR_PREFIXES)\n\n\ndef _has_own_attribute(cls, attrib_name):\n    \"\"\"\n    Check whether *cls* defines *attrib_name* (and doesn't just inherit it).\n    \"\"\"\n    attr = getattr(cls, attrib_name, _SENTINEL)\n    if attr is _SENTINEL:\n        return False\n\n    for base_cls in cls.__mro__[1:]:\n        a = getattr(base_cls, attrib_name, None)\n        if attr is a:\n            return False\n\n    return True\n\n\ndef _get_annotations(cls):\n    \"\"\"\n    Get annotations for *cls*.\n    \"\"\"\n    if _has_own_attribute(cls, \"__annotations__\"):\n        return cls.__annotations__\n\n    return {}\n\n\ndef _collect_base_attrs(cls, taken_attr_names):\n    \"\"\"\n    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n    \"\"\"\n    base_attrs = []\n    base_attr_map = {}  # A dictionary of base attrs to their classes.\n\n    # Traverse the MRO and collect attributes.\n    for base_cls in reversed(cls.__mro__[1:-1]):\n        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n            if a.inherited or a.name in taken_attr_names:\n                continue\n\n            a = a.evolve(inherited=True)  # noqa: PLW2901\n            base_attrs.append(a)\n            base_attr_map[a.name] = base_cls\n\n    # For each name, only keep the freshest definition i.e. the furthest at the\n    # back.  base_attr_map is fine because it gets overwritten with every new\n    # instance.\n    filtered = []\n    seen = set()\n    for a in reversed(base_attrs):\n        if a.name in seen:\n            continue\n        filtered.insert(0, a)\n        seen.add(a.name)\n\n    return filtered, base_attr_map\n\n\ndef _collect_base_attrs_broken(cls, taken_attr_names):\n    \"\"\"\n    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n\n    N.B. *taken_attr_names* will be mutated.\n\n    Adhere to the old incorrect behavior.\n\n    Notably it collects from the front and considers inherited attributes which\n    leads to the buggy behavior reported in #428.\n    \"\"\"\n    base_attrs = []\n    base_attr_map = {}  # A dictionary of base attrs to their classes.\n\n    # Traverse the MRO and collect attributes.\n    for base_cls in cls.__mro__[1:-1]:\n        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n            if a.name in taken_attr_names:\n                continue\n\n            a = a.evolve(inherited=True)  # noqa: PLW2901\n            taken_attr_names.add(a.name)\n            base_attrs.append(a)\n            base_attr_map[a.name] = base_cls\n\n    return base_attrs, base_attr_map\n\n\ndef _transform_attrs(\n    cls, these, auto_attribs, kw_only, collect_by_mro, field_transformer\n):\n    \"\"\"\n    Transform all `_CountingAttr`s on a class into `Attribute`s.\n\n    If *these* is passed, use that and don't look for them on the class.\n\n    If *collect_by_mro* is True, collect them in the correct MRO order,\n    otherwise use the old -- incorrect -- order.  See #428.\n\n    Return an `_Attributes`.\n    \"\"\"\n    cd = cls.__dict__\n    anns = _get_annotations(cls)\n\n    if these is not None:\n        ca_list = list(these.items())\n    elif auto_attribs is True:\n        ca_names = {\n            name\n            for name, attr in cd.items()\n            if isinstance(attr, _CountingAttr)\n        }\n        ca_list = []\n        annot_names = set()\n        for attr_name, type in anns.items():\n            if _is_class_var(type):\n                continue\n            annot_names.add(attr_name)\n            a = cd.get(attr_name, NOTHING)\n\n            if not isinstance(a, _CountingAttr):\n                a = attrib() if a is NOTHING else attrib(default=a)\n            ca_list.append((attr_name, a))\n\n        unannotated = ca_names - annot_names\n        if len(unannotated) > 0:\n            raise UnannotatedAttributeError(\n                \"The following `attr.ib`s lack a type annotation: \"\n                + \", \".join(\n                    sorted(unannotated, key=lambda n: cd.get(n).counter)\n                )\n                + \".\"\n            )\n    else:\n        ca_list = sorted(\n            (\n                (name, attr)\n                for name, attr in cd.items()\n                if isinstance(attr, _CountingAttr)\n            ),\n            key=lambda e: e[1].counter,\n        )\n\n    own_attrs = [\n        Attribute.from_counting_attr(\n            name=attr_name, ca=ca, type=anns.get(attr_name)\n        )\n        for attr_name, ca in ca_list\n    ]\n\n    if collect_by_mro:\n        base_attrs, base_attr_map = _collect_base_attrs(\n            cls, {a.name for a in own_attrs}\n        )\n    else:\n        base_attrs, base_attr_map = _collect_base_attrs_broken(\n            cls, {a.name for a in own_attrs}\n        )\n\n    if kw_only:\n        own_attrs = [a.evolve(kw_only=True) for a in own_attrs]\n        base_attrs = [a.evolve(kw_only=True) for a in base_attrs]\n\n    attrs = base_attrs + own_attrs\n\n    # Mandatory vs non-mandatory attr order only matters when they are part of\n    # the __init__ signature and when they aren't kw_only (which are moved to\n    # the end and can be mandatory or non-mandatory in any order, as they will\n    # be specified as keyword args anyway). Check the order of those attrs:\n    had_default = False\n    for a in (a for a in attrs if a.init is not False and a.kw_only is False):\n        if had_default is True and a.default is NOTHING:\n            msg = f\"No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: {a!r}\"\n            raise ValueError(msg)\n\n        if had_default is False and a.default is not NOTHING:\n            had_default = True\n\n    if field_transformer is not None:\n        attrs = field_transformer(cls, attrs)\n\n    # Resolve default field alias after executing field_transformer.\n    # This allows field_transformer to differentiate between explicit vs\n    # default aliases and supply their own defaults.\n    attrs = [\n        a.evolve(alias=_default_init_alias_for(a.name)) if not a.alias else a\n        for a in attrs\n    ]\n\n    # Create AttrsClass *after* applying the field_transformer since it may\n    # add or remove attributes!\n    attr_names = [a.name for a in attrs]\n    AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)\n\n    return _Attributes((AttrsClass(attrs), base_attrs, base_attr_map))\n\n\ndef _make_cached_property_getattr(cached_properties, original_getattr, cls):\n    lines = [\n        # Wrapped to get `__class__` into closure cell for super()\n        # (It will be replaced with the newly constructed class after construction).\n        \"def wrapper(_cls):\",\n        \"    __class__ = _cls\",\n        \"    def __getattr__(self, item, cached_properties=cached_properties, original_getattr=original_getattr, _cached_setattr_get=_cached_setattr_get):\",\n        \"         func = cached_properties.get(item)\",\n        \"         if func is not None:\",\n        \"              result = func(self)\",\n        \"              _setter = _cached_setattr_get(self)\",\n        \"              _setter(item, result)\",\n        \"              return result\",\n    ]\n    if original_getattr is not None:\n        lines.append(\n            \"         return original_getattr(self, item)\",\n        )\n    else:\n        lines.extend(\n            [\n                \"         try:\",\n                \"             return super().__getattribute__(item)\",\n                \"         except AttributeError:\",\n                \"             if not hasattr(super(), '__getattr__'):\",\n                \"                 raise\",\n                \"             return super().__getattr__(item)\",\n                \"         original_error = f\\\"'{self.__class__.__name__}' object has no attribute '{item}'\\\"\",\n                \"         raise AttributeError(original_error)\",\n            ]\n        )\n\n    lines.extend(\n        [\n            \"    return __getattr__\",\n            \"__getattr__ = wrapper(_cls)\",\n        ]\n    )\n\n    unique_filename = _generate_unique_filename(cls, \"getattr\")\n\n    glob = {\n        \"cached_properties\": cached_properties,\n        \"_cached_setattr_get\": _OBJ_SETATTR.__get__,\n        \"original_getattr\": original_getattr,\n    }\n\n    return _make_method(\n        \"__getattr__\",\n        \"\\n\".join(lines),\n        unique_filename,\n        glob,\n        locals={\n            \"_cls\": cls,\n        },\n    )\n\n\ndef _frozen_setattrs(self, name, value):\n    \"\"\"\n    Attached to frozen classes as __setattr__.\n    \"\"\"\n    if isinstance(self, BaseException) and name in (\n        \"__cause__\",\n        \"__context__\",\n        \"__traceback__\",\n    ):\n        BaseException.__setattr__(self, name, value)\n        return\n\n    raise FrozenInstanceError()\n\n\ndef _frozen_delattrs(self, name):\n    \"\"\"\n    Attached to frozen classes as __delattr__.\n    \"\"\"\n    raise FrozenInstanceError()\n\n\nclass _ClassBuilder:\n    \"\"\"\n    Iteratively build *one* class.\n    \"\"\"\n\n    __slots__ = (\n        \"_attr_names\",\n        \"_attrs\",\n        \"_base_attr_map\",\n        \"_base_names\",\n        \"_cache_hash\",\n        \"_cls\",\n        \"_cls_dict\",\n        \"_delete_attribs\",\n        \"_frozen\",\n        \"_has_pre_init\",\n        \"_pre_init_has_args\",\n        \"_has_post_init\",\n        \"_is_exc\",\n        \"_on_setattr\",\n        \"_slots\",\n        \"_weakref_slot\",\n        \"_wrote_own_setattr\",\n        \"_has_custom_setattr\",\n    )\n\n    def __init__(\n        self,\n        cls,\n        these,\n        slots,\n        frozen,\n        weakref_slot,\n        getstate_setstate,\n        auto_attribs,\n        kw_only,\n        cache_hash,\n        is_exc,\n        collect_by_mro,\n        on_setattr,\n        has_custom_setattr,\n        field_transformer,\n    ):\n        attrs, base_attrs, base_map = _transform_attrs(\n            cls,\n            these,\n            auto_attribs,\n            kw_only,\n            collect_by_mro,\n            field_transformer,\n        )\n\n        self._cls = cls\n        self._cls_dict = dict(cls.__dict__) if slots else {}\n        self._attrs = attrs\n        self._base_names = {a.name for a in base_attrs}\n        self._base_attr_map = base_map\n        self._attr_names = tuple(a.name for a in attrs)\n        self._slots = slots\n        self._frozen = frozen\n        self._weakref_slot = weakref_slot\n        self._cache_hash = cache_hash\n        self._has_pre_init = bool(getattr(cls, \"__attrs_pre_init__\", False))\n        self._pre_init_has_args = False\n        if self._has_pre_init:\n            # Check if the pre init method has more arguments than just `self`\n            # We want to pass arguments if pre init expects arguments\n            pre_init_func = cls.__attrs_pre_init__\n            pre_init_signature = inspect.signature(pre_init_func)\n            self._pre_init_has_args = len(pre_init_signature.parameters) > 1\n        self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n        self._delete_attribs = not bool(these)\n        self._is_exc = is_exc\n        self._on_setattr = on_setattr\n\n        self._has_custom_setattr = has_custom_setattr\n        self._wrote_own_setattr = False\n\n        self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n\n        if frozen:\n            self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n            self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n\n            self._wrote_own_setattr = True\n        elif on_setattr in (\n            _DEFAULT_ON_SETATTR,\n            setters.validate,\n            setters.convert,\n        ):\n            has_validator = has_converter = False\n            for a in attrs:\n                if a.validator is not None:\n                    has_validator = True\n                if a.converter is not None:\n                    has_converter = True\n\n                if has_validator and has_converter:\n                    break\n            if (\n                (\n                    on_setattr == _DEFAULT_ON_SETATTR\n                    and not (has_validator or has_converter)\n                )\n                or (on_setattr == setters.validate and not has_validator)\n                or (on_setattr == setters.convert and not has_converter)\n            ):\n                # If class-level on_setattr is set to convert + validate, but\n                # there's no field to convert or validate, pretend like there's\n                # no on_setattr.\n                self._on_setattr = None\n\n        if getstate_setstate:\n            (\n                self._cls_dict[\"__getstate__\"],\n                self._cls_dict[\"__setstate__\"],\n            ) = self._make_getstate_setstate()\n\n    def __repr__(self):\n        return f\"<_ClassBuilder(cls={self._cls.__name__})>\"\n\n    if PY_3_10_PLUS:\n        import abc\n\n        def build_class(self):\n            \"\"\"\n            Finalize class based on the accumulated configuration.\n\n            Builder cannot be used after calling this method.\n            \"\"\"\n            if self._slots is True:\n                return self._create_slots_class()\n\n            return self.abc.update_abstractmethods(\n                self._patch_original_class()\n            )\n\n    else:\n\n        def build_class(self):\n            \"\"\"\n            Finalize class based on the accumulated configuration.\n\n            Builder cannot be used after calling this method.\n            \"\"\"\n            if self._slots is True:\n                return self._create_slots_class()\n\n            return self._patch_original_class()\n\n    def _patch_original_class(self):\n        \"\"\"\n        Apply accumulated methods and return the class.\n        \"\"\"\n        cls = self._cls\n        base_names = self._base_names\n\n        # Clean class of attribute definitions (`attr.ib()`s).\n        if self._delete_attribs:\n            for name in self._attr_names:\n                if (\n                    name not in base_names\n                    and getattr(cls, name, _SENTINEL) is not _SENTINEL\n                ):\n                    # An AttributeError can happen if a base class defines a\n                    # class variable and we want to set an attribute with the\n                    # same name by using only a type annotation.\n                    with contextlib.suppress(AttributeError):\n                        delattr(cls, name)\n\n        # Attach our dunder methods.\n        for name, value in self._cls_dict.items():\n            setattr(cls, name, value)\n\n        # If we've inherited an attrs __setattr__ and don't write our own,\n        # reset it to object's.\n        if not self._wrote_own_setattr and getattr(\n            cls, \"__attrs_own_setattr__\", False\n        ):\n            cls.__attrs_own_setattr__ = False\n\n            if not self._has_custom_setattr:\n                cls.__setattr__ = _OBJ_SETATTR\n\n        return cls\n\n    def _create_slots_class(self):\n        \"\"\"\n        Build and return a new class with a `__slots__` attribute.\n        \"\"\"\n        cd = {\n            k: v\n            for k, v in self._cls_dict.items()\n            if k not in (*tuple(self._attr_names), \"__dict__\", \"__weakref__\")\n        }\n\n        # If our class doesn't have its own implementation of __setattr__\n        # (either from the user or by us), check the bases, if one of them has\n        # an attrs-made __setattr__, that needs to be reset. We don't walk the\n        # MRO because we only care about our immediate base classes.\n        # XXX: This can be confused by subclassing a slotted attrs class with\n        # XXX: a non-attrs class and subclass the resulting class with an attrs\n        # XXX: class.  See `test_slotted_confused` for details.  For now that's\n        # XXX: OK with us.\n        if not self._wrote_own_setattr:\n            cd[\"__attrs_own_setattr__\"] = False\n\n            if not self._has_custom_setattr:\n                for base_cls in self._cls.__bases__:\n                    if base_cls.__dict__.get(\"__attrs_own_setattr__\", False):\n                        cd[\"__setattr__\"] = _OBJ_SETATTR\n                        break\n\n        # Traverse the MRO to collect existing slots\n        # and check for an existing __weakref__.\n        existing_slots = {}\n        weakref_inherited = False\n        for base_cls in self._cls.__mro__[1:-1]:\n            if base_cls.__dict__.get(\"__weakref__\", None) is not None:\n                weakref_inherited = True\n            existing_slots.update(\n                {\n                    name: getattr(base_cls, name)\n                    for name in getattr(base_cls, \"__slots__\", [])\n                }\n            )\n\n        base_names = set(self._base_names)\n\n        names = self._attr_names\n        if (\n            self._weakref_slot\n            and \"__weakref__\" not in getattr(self._cls, \"__slots__\", ())\n            and \"__weakref__\" not in names\n            and not weakref_inherited\n        ):\n            names += (\"__weakref__\",)\n\n        if PY_3_8_PLUS:\n            cached_properties = {\n                name: cached_property.func\n                for name, cached_property in cd.items()\n                if isinstance(cached_property, functools.cached_property)\n            }\n        else:\n            # `functools.cached_property` was introduced in 3.8.\n            # So can't be used before this.\n            cached_properties = {}\n\n        # Collect methods with a `__class__` reference that are shadowed in the new class.\n        # To know to update them.\n        additional_closure_functions_to_update = []\n        if cached_properties:\n            # Add cached properties to names for slotting.\n            names += tuple(cached_properties.keys())\n\n            for name in cached_properties:\n                # Clear out function from class to avoid clashing.\n                del cd[name]\n\n            additional_closure_functions_to_update.extend(\n                cached_properties.values()\n            )\n\n            class_annotations = _get_annotations(self._cls)\n            for name, func in cached_properties.items():\n                annotation = inspect.signature(func).return_annotation\n                if annotation is not inspect.Parameter.empty:\n                    class_annotations[name] = annotation\n\n            original_getattr = cd.get(\"__getattr__\")\n            if original_getattr is not None:\n                additional_closure_functions_to_update.append(original_getattr)\n\n            cd[\"__getattr__\"] = _make_cached_property_getattr(\n                cached_properties, original_getattr, self._cls\n            )\n\n        # We only add the names of attributes that aren't inherited.\n        # Setting __slots__ to inherited attributes wastes memory.\n        slot_names = [name for name in names if name not in base_names]\n\n        # There are slots for attributes from current class\n        # that are defined in parent classes.\n        # As their descriptors may be overridden by a child class,\n        # we collect them here and update the class dict\n        reused_slots = {\n            slot: slot_descriptor\n            for slot, slot_descriptor in existing_slots.items()\n            if slot in slot_names\n        }\n        slot_names = [name for name in slot_names if name not in reused_slots]\n        cd.update(reused_slots)\n        if self._cache_hash:\n            slot_names.append(_HASH_CACHE_FIELD)\n\n        cd[\"__slots__\"] = tuple(slot_names)\n\n        cd[\"__qualname__\"] = self._cls.__qualname__\n\n        # Create new class based on old class and our methods.\n        cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)\n\n        # The following is a fix for\n        # <https://github.com/python-attrs/attrs/issues/102>.\n        # If a method mentions `__class__` or uses the no-arg super(), the\n        # compiler will bake a reference to the class in the method itself\n        # as `method.__closure__`.  Since we replace the class with a\n        # clone, we rewrite these references so it keeps working.\n        for item in itertools.chain(\n            cls.__dict__.values(), additional_closure_functions_to_update\n        ):\n            if isinstance(item, (classmethod, staticmethod)):\n                # Class- and staticmethods hide their functions inside.\n                # These might need to be rewritten as well.\n                closure_cells = getattr(item.__func__, \"__closure__\", None)\n            elif isinstance(item, property):\n                # Workaround for property `super()` shortcut (PY3-only).\n                # There is no universal way for other descriptors.\n                closure_cells = getattr(item.fget, \"__closure__\", None)\n            else:\n                closure_cells = getattr(item, \"__closure__\", None)\n\n            if not closure_cells:  # Catch None or the empty list.\n                continue\n            for cell in closure_cells:\n                try:\n                    match = cell.cell_contents is self._cls\n                except ValueError:  # noqa: PERF203\n                    # ValueError: Cell is empty\n                    pass\n                else:\n                    if match:\n                        cell.cell_contents = cls\n        return cls\n\n    def add_repr(self, ns):\n        self._cls_dict[\"__repr__\"] = self._add_method_dunders(\n            _make_repr(self._attrs, ns, self._cls)\n        )\n        return self\n\n    def add_str(self):\n        repr = self._cls_dict.get(\"__repr__\")\n        if repr is None:\n            msg = \"__str__ can only be generated if a __repr__ exists.\"\n            raise ValueError(msg)\n\n        def __str__(self):\n            return self.__repr__()\n\n        self._cls_dict[\"__str__\"] = self._add_method_dunders(__str__)\n        return self\n\n    def _make_getstate_setstate(self):\n        \"\"\"\n        Create custom __setstate__ and __getstate__ methods.\n        \"\"\"\n        # __weakref__ is not writable.\n        state_attr_names = tuple(\n            an for an in self._attr_names if an != \"__weakref__\"\n        )\n\n        def slots_getstate(self):\n            \"\"\"\n            Automatically created by attrs.\n            \"\"\"\n            return {name: getattr(self, name) for name in state_attr_names}\n\n        hash_caching_enabled = self._cache_hash\n\n        def slots_setstate(self, state):\n            \"\"\"\n            Automatically created by attrs.\n            \"\"\"\n            __bound_setattr = _OBJ_SETATTR.__get__(self)\n            if isinstance(state, tuple):\n                # Backward compatibility with attrs instances pickled with\n                # attrs versions before v22.2.0 which stored tuples.\n                for name, value in zip(state_attr_names, state):\n                    __bound_setattr(name, value)\n            else:\n                for name in state_attr_names:\n                    if name in state:\n                        __bound_setattr(name, state[name])\n\n            # The hash code cache is not included when the object is\n            # serialized, but it still needs to be initialized to None to\n            # indicate that the first call to __hash__ should be a cache\n            # miss.\n            if hash_caching_enabled:\n                __bound_setattr(_HASH_CACHE_FIELD, None)\n\n        return slots_getstate, slots_setstate\n\n    def make_unhashable(self):\n        self._cls_dict[\"__hash__\"] = None\n        return self\n\n    def add_hash(self):\n        self._cls_dict[\"__hash__\"] = self._add_method_dunders(\n            _make_hash(\n                self._cls,\n                self._attrs,\n                frozen=self._frozen,\n                cache_hash=self._cache_hash,\n            )\n        )\n\n        return self\n\n    def add_init(self):\n        self._cls_dict[\"__init__\"] = self._add_method_dunders(\n            _make_init(\n                self._cls,\n                self._attrs,\n                self._has_pre_init,\n                self._pre_init_has_args,\n                self._has_post_init,\n                self._frozen,\n                self._slots,\n                self._cache_hash,\n                self._base_attr_map,\n                self._is_exc,\n                self._on_setattr,\n                attrs_init=False,\n            )\n        )\n\n        return self\n\n    def add_match_args(self):\n        self._cls_dict[\"__match_args__\"] = tuple(\n            field.name\n            for field in self._attrs\n            if field.init and not field.kw_only\n        )\n\n    def add_attrs_init(self):\n        self._cls_dict[\"__attrs_init__\"] = self._add_method_dunders(\n            _make_init(\n                self._cls,\n                self._attrs,\n                self._has_pre_init,\n                self._pre_init_has_args,\n                self._has_post_init,\n                self._frozen,\n                self._slots,\n                self._cache_hash,\n                self._base_attr_map,\n                self._is_exc,\n                self._on_setattr,\n                attrs_init=True,\n            )\n        )\n\n        return self\n\n    def add_eq(self):\n        cd = self._cls_dict\n\n        cd[\"__eq__\"] = self._add_method_dunders(\n            _make_eq(self._cls, self._attrs)\n        )\n        cd[\"__ne__\"] = self._add_method_dunders(_make_ne())\n\n        return self\n\n    def add_order(self):\n        cd = self._cls_dict\n\n        cd[\"__lt__\"], cd[\"__le__\"], cd[\"__gt__\"], cd[\"__ge__\"] = (\n            self._add_method_dunders(meth)\n            for meth in _make_order(self._cls, self._attrs)\n        )\n\n        return self\n\n    def add_setattr(self):\n        if self._frozen:\n            return self\n\n        sa_attrs = {}\n        for a in self._attrs:\n            on_setattr = a.on_setattr or self._on_setattr\n            if on_setattr and on_setattr is not setters.NO_OP:\n                sa_attrs[a.name] = a, on_setattr\n\n        if not sa_attrs:\n            return self\n\n        if self._has_custom_setattr:\n            # We need to write a __setattr__ but there already is one!\n            msg = \"Can't combine custom __setattr__ with on_setattr hooks.\"\n            raise ValueError(msg)\n\n        # docstring comes from _add_method_dunders\n        def __setattr__(self, name, val):\n            try:\n                a, hook = sa_attrs[name]\n            except KeyError:\n                nval = val\n            else:\n                nval = hook(self, a, val)\n\n            _OBJ_SETATTR(self, name, nval)\n\n        self._cls_dict[\"__attrs_own_setattr__\"] = True\n        self._cls_dict[\"__setattr__\"] = self._add_method_dunders(__setattr__)\n        self._wrote_own_setattr = True\n\n        return self\n\n    def _add_method_dunders(self, method):\n        \"\"\"\n        Add __module__ and __qualname__ to a *method* if possible.\n        \"\"\"\n        with contextlib.suppress(AttributeError):\n            method.__module__ = self._cls.__module__\n\n        with contextlib.suppress(AttributeError):\n            method.__qualname__ = f\"{self._cls.__qualname__}.{method.__name__}\"\n\n        with contextlib.suppress(AttributeError):\n            method.__doc__ = (\n                \"Method generated by attrs for class \"\n                f\"{self._cls.__qualname__}.\"\n            )\n\n        return method\n\n\ndef _determine_attrs_eq_order(cmp, eq, order, default_eq):\n    \"\"\"\n    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n    values of eq and order.  If *eq* is None, set it to *default_eq*.\n    \"\"\"\n    if cmp is not None and any((eq is not None, order is not None)):\n        msg = \"Don't mix `cmp` with `eq' and `order`.\"\n        raise ValueError(msg)\n\n    # cmp takes precedence due to bw-compatibility.\n    if cmp is not None:\n        return cmp, cmp\n\n    # If left None, equality is set to the specified default and ordering\n    # mirrors equality.\n    if eq is None:\n        eq = default_eq\n\n    if order is None:\n        order = eq\n\n    if eq is False and order is True:\n        msg = \"`order` can only be True if `eq` is True too.\"\n        raise ValueError(msg)\n\n    return eq, order\n\n\ndef _determine_attrib_eq_order(cmp, eq, order, default_eq):\n    \"\"\"\n    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n    values of eq and order.  If *eq* is None, set it to *default_eq*.\n    \"\"\"\n    if cmp is not None and any((eq is not None, order is not None)):\n        msg = \"Don't mix `cmp` with `eq' and `order`.\"\n        raise ValueError(msg)\n\n    def decide_callable_or_boolean(value):\n        \"\"\"\n        Decide whether a key function is used.\n        \"\"\"\n        if callable(value):\n            value, key = True, value\n        else:\n            key = None\n        return value, key\n\n    # cmp takes precedence due to bw-compatibility.\n    if cmp is not None:\n        cmp, cmp_key = decide_callable_or_boolean(cmp)\n        return cmp, cmp_key, cmp, cmp_key\n\n    # If left None, equality is set to the specified default and ordering\n    # mirrors equality.\n    if eq is None:\n        eq, eq_key = default_eq, None\n    else:\n        eq, eq_key = decide_callable_or_boolean(eq)\n\n    if order is None:\n        order, order_key = eq, eq_key\n    else:\n        order, order_key = decide_callable_or_boolean(order)\n\n    if eq is False and order is True:\n        msg = \"`order` can only be True if `eq` is True too.\"\n        raise ValueError(msg)\n\n    return eq, eq_key, order, order_key\n\n\ndef _determine_whether_to_implement(\n    cls, flag, auto_detect, dunders, default=True\n):\n    \"\"\"\n    Check whether we should implement a set of methods for *cls*.\n\n    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the\n    same as passed into @attr.s and *dunders* is a tuple of attribute names\n    whose presence signal that the user has implemented it themselves.\n\n    Return *default* if no reason for either for or against is found.\n    \"\"\"\n    if flag is True or flag is False:\n        return flag\n\n    if flag is None and auto_detect is False:\n        return default\n\n    # Logically, flag is None and auto_detect is True here.\n    for dunder in dunders:\n        if _has_own_attribute(cls, dunder):\n            return False\n\n    return default\n\n\ndef attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=False,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=False,\n    eq=None,\n    order=None,\n    auto_detect=False,\n    collect_by_mro=False,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n    match_args=True,\n    unsafe_hash=None,\n):\n    r\"\"\"\n    A class decorator that adds :term:`dunder methods` according to the\n    specified attributes using `attr.ib` or the *these* argument.\n\n    Consider using `attrs.define` / `attrs.frozen` in new code (``attr.s`` will\n    *never* go away, though).\n\n    :param these: A dictionary of name to `attr.ib` mappings.  This is useful\n        to avoid the definition of your attributes within the class body\n        because you can't (for example, if you want to add ``__repr__`` methods\n        to Django models) or don't want to.\n\n        If *these* is not `None`, *attrs* will *not* search the class body\n        for attributes and will *not* remove any attributes from it.\n\n        The order is deduced from the order of the attributes inside *these*.\n\n    :type these: `dict` of `str` to `attr.ib`\n\n    :param str repr_ns: When using nested classes, there was no way in Python 2\n        to automatically detect that.  This argument allows to set a custom\n        name for a more meaningful ``repr`` output.  This argument\n        is pointless in Python 3 and is therefore deprecated.\n    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,\n        *order*, and *hash* arguments explicitly, assume they are set to\n        `True` **unless any** of the involved methods for one of the\n        arguments is implemented in the *current* class (meaning, it is *not*\n        inherited from some base class).\n\n        So, for example by implementing ``__eq__`` on a class yourself, *attrs*\n        will deduce ``eq=False`` and will create *neither* ``__eq__`` *nor*\n        ``__ne__`` (but Python classes come with a sensible ``__ne__`` by\n        default, so it *should* be enough to only implement ``__eq__`` in most\n        cases).\n\n        .. warning::\n\n           If you prevent *attrs* from creating the ordering methods for you\n           (``order=False``, for example, by implementing ``__le__``), it\n           becomes *your* responsibility to make sure its ordering is sound.\n           The best way is to use the `functools.total_ordering` decorator.\n\n        Passing `True` or `False` to *init*, *repr*, *eq*, *order*, *cmp*,\n        or *hash* overrides whatever *auto_detect* would determine.\n\n    :param bool repr: Create a ``__repr__`` method with a human readable\n        representation of *attrs* attributes..\n    :param bool str: Create a ``__str__`` method that is identical to\n        ``__repr__``.  This is usually not necessary except for `Exception`\\ s.\n    :param bool | None eq: If `True` or `None` (default), add ``__eq__``\n        and ``__ne__`` methods that check two instances for equality.\n\n        They compare the instances as if they were tuples of their *attrs*\n        attributes if and only if the types of both classes are *identical*!\n\n        .. seealso:: `comparison`\n    :param bool | None order: If `True`, add ``__lt__``, ``__le__``,\n        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n        allow instances to be ordered. If `None` (default) mirror value of\n        *eq*.\n\n        .. seealso:: `comparison`\n    :param bool | None cmp: Setting *cmp* is equivalent to setting *eq* and\n        *order* to the same value. Must not be mixed with *eq* or *order*.\n\n        .. seealso:: `comparison`\n    :param bool | None unsafe_hash: If `None` (default), the ``__hash__``\n        method is generated according how *eq* and *frozen* are set.\n\n        1. If *both* are True, *attrs* will generate a ``__hash__`` for you.\n        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n           None, marking it unhashable (which it is).\n        3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n           ``__hash__`` method of the base class will be used (if base class is\n           ``object``, this means it will fall back to id-based hashing.).\n\n        Although not recommended, you can decide for yourself and force *attrs*\n        to create one (for example, if the class is immutable even though you\n        didn't freeze it programmatically) by passing `True` or not.  Both of\n        these cases are rather special and should be used carefully.\n\n        .. seealso::\n\n           - Our documentation on `hashing`,\n           - Python's documentation on `object.__hash__`,\n           - and the `GitHub issue that led to the default \\ behavior\n             <https://github.com/python-attrs/attrs/issues/136>`_ for more\n             details.\n\n    :param bool | None hash: Alias for *unsafe_hash*. *unsafe_hash* takes\n        precedence.\n    :param bool init: Create a ``__init__`` method that initializes the *attrs*\n        attributes. Leading underscores are stripped for the argument name\n        (unless an alias is set on the attribute). If a ``__attrs_pre_init__``\n        method exists on the class, it will be called before the class is\n        initialized. If a ``__attrs_post_init__`` method exists on the class,\n        it will be called after the class is fully initialized.\n\n        If ``init`` is `False`, an ``__attrs_init__`` method will be injected\n        instead. This allows you to define a custom ``__init__`` method that\n        can do pre-init work such as ``super().__init__()``, and then call\n        ``__attrs_init__()`` and ``__attrs_post_init__()``.\n\n        .. seealso:: `init`\n    :param bool slots: Create a :term:`slotted class <slotted classes>` that's\n        more memory-efficient. Slotted classes are generally superior to the\n        default dict classes, but have some gotchas you should know about, so\n        we encourage you to read the :term:`glossary entry <slotted classes>`.\n    :param bool frozen: Make instances immutable after initialization.  If\n        someone attempts to modify a frozen instance,\n        `attrs.exceptions.FrozenInstanceError` is raised.\n\n        .. note::\n\n            1. This is achieved by installing a custom ``__setattr__`` method\n               on your class, so you can't implement your own.\n\n            2. True immutability is impossible in Python.\n\n            3. This *does* have a minor a runtime performance `impact\n               <how-frozen>` when initializing new instances.  In other words:\n               ``__init__`` is slightly slower with ``frozen=True``.\n\n            4. If a class is frozen, you cannot modify ``self`` in\n               ``__attrs_post_init__`` or a self-written ``__init__``. You can\n               circumvent that limitation by using ``object.__setattr__(self,\n               \"attribute_name\", value)``.\n\n            5. Subclasses of a frozen class are frozen too.\n\n    :param bool weakref_slot: Make instances weak-referenceable.  This has no\n        effect unless ``slots`` is also enabled.\n    :param bool auto_attribs: If `True`, collect :pep:`526`-annotated\n        attributes from the class body.\n\n        In this case, you **must** annotate every field.  If *attrs* encounters\n        a field that is set to an `attr.ib` but lacks a type annotation, an\n        `attrs.exceptions.UnannotatedAttributeError` is raised.  Use\n        ``field_name: typing.Any = attr.ib(...)`` if you don't want to set a\n        type.\n\n        If you assign a value to those attributes (for example, ``x: int =\n        42``), that value becomes the default value like if it were passed\n        using ``attr.ib(default=42)``.  Passing an instance of `attrs.Factory`\n        also works as expected in most cases (see warning below).\n\n        Attributes annotated as `typing.ClassVar`, and attributes that are\n        neither annotated nor set to an `attr.ib` are **ignored**.\n\n        .. warning::\n\n           For features that use the attribute name to create decorators (for\n           example, :ref:`validators <validators>`), you still *must* assign\n           `attr.ib` to them. Otherwise Python will either not find the name or\n           try to use the default value to call, for example, ``validator`` on\n           it.\n\n    :param bool kw_only: Make all attributes keyword-only in the generated\n        ``__init__`` (if *init* is `False`, this parameter is ignored).\n    :param bool cache_hash: Ensure that the object's hash code is computed only\n        once and stored on the object.  If this is set to `True`, hashing\n        must be either explicitly or implicitly enabled for this class.  If the\n        hash code is cached, avoid any reassignments of fields involved in hash\n        code computation or mutations of the objects those fields point to\n        after object creation.  If such changes occur, the behavior of the\n        object's hash code is undefined.\n    :param bool auto_exc: If the class subclasses `BaseException` (which\n        implicitly includes any subclass of any exception), the following\n        happens to behave like a well-behaved Python exceptions class:\n\n        - the values for *eq*, *order*, and *hash* are ignored and the\n          instances compare and hash by the instance's ids (N.B. *attrs* will\n          *not* remove existing implementations of ``__hash__`` or the equality\n          methods. It just won't add own ones.),\n        - all attributes that are either passed into ``__init__`` or have a\n          default value are additionally available as a tuple in the ``args``\n          attribute,\n        - the value of *str* is ignored leaving ``__str__`` to base classes.\n    :param bool collect_by_mro: Setting this to `True` fixes the way *attrs*\n       collects attributes from base classes.  The default behavior is\n       incorrect in certain cases of multiple inheritance.  It should be on by\n       default, but is kept off for backwards-compatibility.\n\n       .. seealso::\n          Issue `#428 <https://github.com/python-attrs/attrs/issues/428>`_\n\n    :param bool | None getstate_setstate:\n       .. note::\n          This is usually only interesting for slotted classes and you should\n          probably just set *auto_detect* to `True`.\n\n       If `True`, ``__getstate__`` and ``__setstate__`` are generated and\n       attached to the class. This is necessary for slotted classes to be\n       pickleable. If left `None`, it's `True` by default for slotted classes\n       and `False` for dict classes.\n\n       If *auto_detect* is `True`, and *getstate_setstate* is left `None`, and\n       **either** ``__getstate__`` or ``__setstate__`` is detected directly on\n       the class (meaning: not inherited), it is set to `False` (this is\n       usually what you want).\n\n    :param on_setattr: A callable that is run whenever the user attempts to set\n        an attribute (either by assignment like ``i.x = 42`` or by using\n        `setattr` like ``setattr(i, \"x\", 42)``). It receives the same arguments\n        as validators: the instance, the attribute that is being modified, and\n        the new value.\n\n        If no exception is raised, the attribute is set to the return value of\n        the callable.\n\n        If a list of callables is passed, they're automatically wrapped in an\n        `attrs.setters.pipe`.\n    :type on_setattr: ~typing.Callable | list[~typing.Callable] | None |\n        typing.Literal[attrs.setters.NO_OP]\n\n    :param ~typing.Callable | None field_transformer:\n        A function that is called with the original class object and all fields\n        right before *attrs* finalizes the class.  You can use this, for\n        example, to automatically add converters or validators to fields based\n        on their types.\n\n        .. seealso:: `transform-fields`\n\n    :param bool match_args:\n        If `True` (default), set ``__match_args__`` on the class to support\n        :pep:`634` (*Structural Pattern Matching*). It is a tuple of all\n        non-keyword-only ``__init__`` parameter names on Python 3.10 and later.\n        Ignored on older Python versions.\n\n    .. versionadded:: 16.0.0 *slots*\n    .. versionadded:: 16.1.0 *frozen*\n    .. versionadded:: 16.3.0 *str*\n    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.\n    .. versionchanged:: 17.1.0\n       *hash* supports `None` as value which is also the default now.\n    .. versionadded:: 17.3.0 *auto_attribs*\n    .. versionchanged:: 18.1.0\n       If *these* is passed, no attributes are deleted from the class body.\n    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n    .. versionadded:: 18.2.0 *weakref_slot*\n    .. deprecated:: 18.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a\n       `DeprecationWarning` if the classes compared are subclasses of\n       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n       to each other.\n    .. versionchanged:: 19.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider\n       subclasses comparable anymore.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionadded:: 18.2.0 *cache_hash*\n    .. versionadded:: 19.1.0 *auto_exc*\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *auto_detect*\n    .. versionadded:: 20.1.0 *collect_by_mro*\n    .. versionadded:: 20.1.0 *getstate_setstate*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionadded:: 20.3.0 *field_transformer*\n    .. versionchanged:: 21.1.0\n       ``init=False`` injects ``__attrs_init__``\n    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    .. versionadded:: 21.3.0 *match_args*\n    .. versionadded:: 22.2.0\n       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).\n    .. deprecated:: 24.1.0 *repr_ns*\n    \"\"\"\n    if repr_ns is not None:\n        import warnings\n\n        warnings.warn(\n            DeprecationWarning(\n                \"The `repr_ns` argument is deprecated and will be removed in or after April 2025.\"\n            ),\n            stacklevel=2,\n        )\n\n    eq_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)\n\n    # unsafe_hash takes precedence due to PEP 681.\n    if unsafe_hash is not None:\n        hash = unsafe_hash\n\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    def wrap(cls):\n        is_frozen = frozen or _has_frozen_base_class(cls)\n        is_exc = auto_exc is True and issubclass(cls, BaseException)\n        has_own_setattr = auto_detect and _has_own_attribute(\n            cls, \"__setattr__\"\n        )\n\n        if has_own_setattr and is_frozen:\n            msg = \"Can't freeze a class with a custom __setattr__.\"\n            raise ValueError(msg)\n\n        builder = _ClassBuilder(\n            cls,\n            these,\n            slots,\n            is_frozen,\n            weakref_slot,\n            _determine_whether_to_implement(\n                cls,\n                getstate_setstate,\n                auto_detect,\n                (\"__getstate__\", \"__setstate__\"),\n                default=slots,\n            ),\n            auto_attribs,\n            kw_only,\n            cache_hash,\n            is_exc,\n            collect_by_mro,\n            on_setattr,\n            has_own_setattr,\n            field_transformer,\n        )\n        if _determine_whether_to_implement(\n            cls, repr, auto_detect, (\"__repr__\",)\n        ):\n            builder.add_repr(repr_ns)\n        if str is True:\n            builder.add_str()\n\n        eq = _determine_whether_to_implement(\n            cls, eq_, auto_detect, (\"__eq__\", \"__ne__\")\n        )\n        if not is_exc and eq is True:\n            builder.add_eq()\n        if not is_exc and _determine_whether_to_implement(\n            cls, order_, auto_detect, (\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\")\n        ):\n            builder.add_order()\n\n        builder.add_setattr()\n\n        nonlocal hash\n        if (\n            hash is None\n            and auto_detect is True\n            and _has_own_attribute(cls, \"__hash__\")\n        ):\n            hash = False\n\n        if hash is not True and hash is not False and hash is not None:\n            # Can't use `hash in` because 1 == True for example.\n            msg = \"Invalid value for hash.  Must be True, False, or None.\"\n            raise TypeError(msg)\n\n        if hash is False or (hash is None and eq is False) or is_exc:\n            # Don't do anything. Should fall back to __object__'s __hash__\n            # which is by id.\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.\"\n                raise TypeError(msg)\n        elif hash is True or (\n            hash is None and eq is True and is_frozen is True\n        ):\n            # Build a __hash__ if told so, or if it's safe.\n            builder.add_hash()\n        else:\n            # Raise TypeError on attempts to hash.\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled.\"\n                raise TypeError(msg)\n            builder.make_unhashable()\n\n        if _determine_whether_to_implement(\n            cls, init, auto_detect, (\"__init__\",)\n        ):\n            builder.add_init()\n        else:\n            builder.add_attrs_init()\n            if cache_hash:\n                msg = \"Invalid value for cache_hash.  To use hash caching, init must be True.\"\n                raise TypeError(msg)\n\n        if (\n            PY_3_10_PLUS\n            and match_args\n            and not _has_own_attribute(cls, \"__match_args__\")\n        ):\n            builder.add_match_args()\n\n        return builder.build_class()\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but `None` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n\n    return wrap(maybe_cls)\n\n\n_attrs = attrs\n\"\"\"\nInternal alias so we can use it in functions that take an argument called\n*attrs*.\n\"\"\"\n\n\ndef _has_frozen_base_class(cls):\n    \"\"\"\n    Check whether *cls* has a frozen ancestor by looking at its\n    __setattr__.\n    \"\"\"\n    return cls.__setattr__ is _frozen_setattrs\n\n\ndef _generate_unique_filename(cls, func_name):\n    \"\"\"\n    Create a \"filename\" suitable for a function being generated.\n    \"\"\"\n    return (\n        f\"<attrs generated {func_name} {cls.__module__}.\"\n        f\"{getattr(cls, '__qualname__', cls.__name__)}>\"\n    )\n\n\ndef _make_hash(cls, attrs, frozen, cache_hash):\n    attrs = tuple(\n        a for a in attrs if a.hash is True or (a.hash is None and a.eq is True)\n    )\n\n    tab = \"        \"\n\n    unique_filename = _generate_unique_filename(cls, \"hash\")\n    type_hash = hash(unique_filename)\n    # If eq is custom generated, we need to include the functions in globs\n    globs = {}\n\n    hash_def = \"def __hash__(self\"\n    hash_func = \"hash((\"\n    closing_braces = \"))\"\n    if not cache_hash:\n        hash_def += \"):\"\n    else:\n        hash_def += \", *\"\n\n        hash_def += \", _cache_wrapper=__import__('attr._make')._make._CacheHashWrapper):\"\n        hash_func = \"_cache_wrapper(\" + hash_func\n        closing_braces += \")\"\n\n    method_lines = [hash_def]\n\n    def append_hash_computation_lines(prefix, indent):\n        \"\"\"\n        Generate the code for actually computing the hash code.\n        Below this will either be returned directly or used to compute\n        a value which is then cached, depending on the value of cache_hash\n        \"\"\"\n\n        method_lines.extend(\n            [\n                indent + prefix + hash_func,\n                indent + f\"        {type_hash},\",\n            ]\n        )\n\n        for a in attrs:\n            if a.eq_key:\n                cmp_name = f\"_{a.name}_key\"\n                globs[cmp_name] = a.eq_key\n                method_lines.append(\n                    indent + f\"        {cmp_name}(self.{a.name}),\"\n                )\n            else:\n                method_lines.append(indent + f\"        self.{a.name},\")\n\n        method_lines.append(indent + \"    \" + closing_braces)\n\n    if cache_hash:\n        method_lines.append(tab + f\"if self.{_HASH_CACHE_FIELD} is None:\")\n        if frozen:\n            append_hash_computation_lines(\n                f\"object.__setattr__(self, '{_HASH_CACHE_FIELD}', \", tab * 2\n            )\n            method_lines.append(tab * 2 + \")\")  # close __setattr__\n        else:\n            append_hash_computation_lines(\n                f\"self.{_HASH_CACHE_FIELD} = \", tab * 2\n            )\n        method_lines.append(tab + f\"return self.{_HASH_CACHE_FIELD}\")\n    else:\n        append_hash_computation_lines(\"return \", tab)\n\n    script = \"\\n\".join(method_lines)\n    return _make_method(\"__hash__\", script, unique_filename, globs)\n\n\ndef _add_hash(cls, attrs):\n    \"\"\"\n    Add a hash method to *cls*.\n    \"\"\"\n    cls.__hash__ = _make_hash(cls, attrs, frozen=False, cache_hash=False)\n    return cls\n\n\ndef _make_ne():\n    \"\"\"\n    Create __ne__ method.\n    \"\"\"\n\n    def __ne__(self, other):\n        \"\"\"\n        Check equality and either forward a NotImplemented or\n        return the result negated.\n        \"\"\"\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return NotImplemented\n\n        return not result\n\n    return __ne__\n\n\ndef _make_eq(cls, attrs):\n    \"\"\"\n    Create __eq__ method for *cls* with *attrs*.\n    \"\"\"\n    attrs = [a for a in attrs if a.eq]\n\n    unique_filename = _generate_unique_filename(cls, \"eq\")\n    lines = [\n        \"def __eq__(self, other):\",\n        \"    if other.__class__ is not self.__class__:\",\n        \"        return NotImplemented\",\n    ]\n\n    # We can't just do a big self.x = other.x and... clause due to\n    # irregularities like nan == nan is false but (nan,) == (nan,) is true.\n    globs = {}\n    if attrs:\n        lines.append(\"    return  (\")\n        others = [\"    ) == (\"]\n        for a in attrs:\n            if a.eq_key:\n                cmp_name = f\"_{a.name}_key\"\n                # Add the key function to the global namespace\n                # of the evaluated function.\n                globs[cmp_name] = a.eq_key\n                lines.append(f\"        {cmp_name}(self.{a.name}),\")\n                others.append(f\"        {cmp_name}(other.{a.name}),\")\n            else:\n                lines.append(f\"        self.{a.name},\")\n                others.append(f\"        other.{a.name},\")\n\n        lines += [*others, \"    )\"]\n    else:\n        lines.append(\"    return True\")\n\n    script = \"\\n\".join(lines)\n\n    return _make_method(\"__eq__\", script, unique_filename, globs)\n\n\ndef _make_order(cls, attrs):\n    \"\"\"\n    Create ordering methods for *cls* with *attrs*.\n    \"\"\"\n    attrs = [a for a in attrs if a.order]\n\n    def attrs_to_tuple(obj):\n        \"\"\"\n        Save us some typing.\n        \"\"\"\n        return tuple(\n            key(value) if key else value\n            for value, key in (\n                (getattr(obj, a.name), a.order_key) for a in attrs\n            )\n        )\n\n    def __lt__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) < attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __le__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) <= attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __gt__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) > attrs_to_tuple(other)\n\n        return NotImplemented\n\n    def __ge__(self, other):\n        \"\"\"\n        Automatically created by attrs.\n        \"\"\"\n        if other.__class__ is self.__class__:\n            return attrs_to_tuple(self) >= attrs_to_tuple(other)\n\n        return NotImplemented\n\n    return __lt__, __le__, __gt__, __ge__\n\n\ndef _add_eq(cls, attrs=None):\n    \"\"\"\n    Add equality methods to *cls* with *attrs*.\n    \"\"\"\n    if attrs is None:\n        attrs = cls.__attrs_attrs__\n\n    cls.__eq__ = _make_eq(cls, attrs)\n    cls.__ne__ = _make_ne()\n\n    return cls\n\n\ndef _make_repr(attrs, ns, cls):\n    unique_filename = _generate_unique_filename(cls, \"repr\")\n    # Figure out which attributes to include, and which function to use to\n    # format them. The a.repr value can be either bool or a custom\n    # callable.\n    attr_names_with_reprs = tuple(\n        (a.name, (repr if a.repr is True else a.repr), a.init)\n        for a in attrs\n        if a.repr is not False\n    )\n    globs = {\n        name + \"_repr\": r for name, r, _ in attr_names_with_reprs if r != repr\n    }\n    globs[\"_compat\"] = _compat\n    globs[\"AttributeError\"] = AttributeError\n    globs[\"NOTHING\"] = NOTHING\n    attribute_fragments = []\n    for name, r, i in attr_names_with_reprs:\n        accessor = (\n            \"self.\" + name if i else 'getattr(self, \"' + name + '\", NOTHING)'\n        )\n        fragment = (\n            \"%s={%s!r}\" % (name, accessor)\n            if r == repr\n            else \"%s={%s_repr(%s)}\" % (name, name, accessor)\n        )\n        attribute_fragments.append(fragment)\n    repr_fragment = \", \".join(attribute_fragments)\n\n    if ns is None:\n        cls_name_fragment = '{self.__class__.__qualname__.rsplit(\">.\", 1)[-1]}'\n    else:\n        cls_name_fragment = ns + \".{self.__class__.__name__}\"\n\n    lines = [\n        \"def __repr__(self):\",\n        \"  try:\",\n        \"    already_repring = _compat.repr_context.already_repring\",\n        \"  except AttributeError:\",\n        \"    already_repring = {id(self),}\",\n        \"    _compat.repr_context.already_repring = already_repring\",\n        \"  else:\",\n        \"    if id(self) in already_repring:\",\n        \"      return '...'\",\n        \"    else:\",\n        \"      already_repring.add(id(self))\",\n        \"  try:\",\n        f\"    return f'{cls_name_fragment}({repr_fragment})'\",\n        \"  finally:\",\n        \"    already_repring.remove(id(self))\",\n    ]\n\n    return _make_method(\n        \"__repr__\", \"\\n\".join(lines), unique_filename, globs=globs\n    )\n\n\ndef _add_repr(cls, ns=None, attrs=None):\n    \"\"\"\n    Add a repr method to *cls*.\n    \"\"\"\n    if attrs is None:\n        attrs = cls.__attrs_attrs__\n\n    cls.__repr__ = _make_repr(attrs, ns, cls)\n    return cls\n\n\ndef fields(cls):\n    \"\"\"\n    Return the tuple of *attrs* attributes for a class.\n\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    :rtype: tuple (with name accessors) of `attrs.Attribute`\n\n    .. versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n       by name.\n    .. versionchanged:: 23.1.0 Add support for generic classes.\n    \"\"\"\n    generic_base = get_generic_base(cls)\n\n    if generic_base is None and not isinstance(cls, type):\n        msg = \"Passed object must be a class.\"\n        raise TypeError(msg)\n\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n\n    if attrs is None:\n        if generic_base is not None:\n            attrs = getattr(generic_base, \"__attrs_attrs__\", None)\n            if attrs is not None:\n                # Even though this is global state, stick it on here to speed\n                # it up. We rely on `cls` being cached for this to be\n                # efficient.\n                cls.__attrs_attrs__ = attrs\n                return attrs\n        msg = f\"{cls!r} is not an attrs-decorated class.\"\n        raise NotAnAttrsClassError(msg)\n\n    return attrs\n\n\ndef fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of *attrs* attributes for a class, whose\n    keys are the attribute names.\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    :rtype: dict\n\n    .. versionadded:: 18.1.0\n    \"\"\"\n    if not isinstance(cls, type):\n        msg = \"Passed object must be a class.\"\n        raise TypeError(msg)\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        msg = f\"{cls!r} is not an attrs-decorated class.\"\n        raise NotAnAttrsClassError(msg)\n    return {a.name: a for a in attrs}\n\n\ndef validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n\n    Leaves all exceptions through.\n\n    :param inst: Instance of a class with *attrs* attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n\n    for a in fields(inst.__class__):\n        v = a.validator\n        if v is not None:\n            v(inst, a, getattr(inst, a.name))\n\n\ndef _is_slot_attr(a_name, base_attr_map):\n    \"\"\"\n    Check if the attribute name comes from a slot class.\n    \"\"\"\n    cls = base_attr_map.get(a_name)\n    return cls and \"__slots__\" in cls.__dict__\n\n\ndef _make_init(\n    cls,\n    attrs,\n    pre_init,\n    pre_init_has_args,\n    post_init,\n    frozen,\n    slots,\n    cache_hash,\n    base_attr_map,\n    is_exc,\n    cls_on_setattr,\n    attrs_init,\n):\n    has_cls_on_setattr = (\n        cls_on_setattr is not None and cls_on_setattr is not setters.NO_OP\n    )\n\n    if frozen and has_cls_on_setattr:\n        msg = \"Frozen classes can't use on_setattr.\"\n        raise ValueError(msg)\n\n    needs_cached_setattr = cache_hash or frozen\n    filtered_attrs = []\n    attr_dict = {}\n    for a in attrs:\n        if not a.init and a.default is NOTHING:\n            continue\n\n        filtered_attrs.append(a)\n        attr_dict[a.name] = a\n\n        if a.on_setattr is not None:\n            if frozen is True:\n                msg = \"Frozen classes can't use on_setattr.\"\n                raise ValueError(msg)\n\n            needs_cached_setattr = True\n        elif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:\n            needs_cached_setattr = True\n\n    unique_filename = _generate_unique_filename(cls, \"init\")\n\n    script, globs, annotations = _attrs_to_init_script(\n        filtered_attrs,\n        frozen,\n        slots,\n        pre_init,\n        pre_init_has_args,\n        post_init,\n        cache_hash,\n        base_attr_map,\n        is_exc,\n        needs_cached_setattr,\n        has_cls_on_setattr,\n        attrs_init,\n    )\n    if cls.__module__ in sys.modules:\n        # This makes typing.get_type_hints(CLS.__init__) resolve string types.\n        globs.update(sys.modules[cls.__module__].__dict__)\n\n    globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n\n    if needs_cached_setattr:\n        # Save the lookup overhead in __init__ if we need to circumvent\n        # setattr hooks.\n        globs[\"_cached_setattr_get\"] = _OBJ_SETATTR.__get__\n\n    init = _make_method(\n        \"__attrs_init__\" if attrs_init else \"__init__\",\n        script,\n        unique_filename,\n        globs,\n    )\n    init.__annotations__ = annotations\n\n    return init\n\n\ndef _setattr(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Use the cached object.setattr to set *attr_name* to *value_var*.\n    \"\"\"\n    return f\"_setattr('{attr_name}', {value_var})\"\n\n\ndef _setattr_with_converter(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Use the cached object.setattr to set *attr_name* to *value_var*, but run\n    its converter first.\n    \"\"\"\n    return \"_setattr('%s', %s(%s))\" % (\n        attr_name,\n        _INIT_CONVERTER_PAT % (attr_name,),\n        value_var,\n    )\n\n\ndef _assign(attr_name, value, has_on_setattr):\n    \"\"\"\n    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise\n    relegate to _setattr.\n    \"\"\"\n    if has_on_setattr:\n        return _setattr(attr_name, value, True)\n\n    return f\"self.{attr_name} = {value}\"\n\n\ndef _assign_with_converter(attr_name, value_var, has_on_setattr):\n    \"\"\"\n    Unless *attr_name* has an on_setattr hook, use normal assignment after\n    conversion. Otherwise relegate to _setattr_with_converter.\n    \"\"\"\n    if has_on_setattr:\n        return _setattr_with_converter(attr_name, value_var, True)\n\n    return \"self.%s = %s(%s)\" % (\n        attr_name,\n        _INIT_CONVERTER_PAT % (attr_name,),\n        value_var,\n    )\n\n\ndef _determine_setters(frozen, slots, base_attr_map):\n    \"\"\"\n    Determine the correct setter functions based on whether a class is frozen\n    and/or slotted.\n    \"\"\"\n    if frozen is True:\n        if slots is True:\n            return (), _setattr, _setattr_with_converter\n\n        # Dict frozen classes assign directly to __dict__.\n        # But only if the attribute doesn't come from an ancestor slot\n        # class.\n        # Note _inst_dict will be used again below if cache_hash is True\n\n        def fmt_setter(attr_name, value_var, has_on_setattr):\n            if _is_slot_attr(attr_name, base_attr_map):\n                return _setattr(attr_name, value_var, has_on_setattr)\n\n            return f\"_inst_dict['{attr_name}'] = {value_var}\"\n\n        def fmt_setter_with_converter(attr_name, value_var, has_on_setattr):\n            if has_on_setattr or _is_slot_attr(attr_name, base_attr_map):\n                return _setattr_with_converter(\n                    attr_name, value_var, has_on_setattr\n                )\n\n            return \"_inst_dict['%s'] = %s(%s)\" % (\n                attr_name,\n                _INIT_CONVERTER_PAT % (attr_name,),\n                value_var,\n            )\n\n        return (\n            (\"_inst_dict = self.__dict__\",),\n            fmt_setter,\n            fmt_setter_with_converter,\n        )\n\n    # Not frozen -- we can just assign directly.\n    return (), _assign, _assign_with_converter\n\n\ndef _attrs_to_init_script(\n    attrs,\n    frozen,\n    slots,\n    pre_init,\n    pre_init_has_args,\n    post_init,\n    cache_hash,\n    base_attr_map,\n    is_exc,\n    needs_cached_setattr,\n    has_cls_on_setattr,\n    attrs_init,\n):\n    \"\"\"\n    Return a script of an initializer for *attrs* and a dict of globals.\n\n    The globals are expected by the generated script.\n\n    If *frozen* is True, we cannot set the attributes directly so we use\n    a cached ``object.__setattr__``.\n    \"\"\"\n    lines = [\"self.__attrs_pre_init__()\"] if pre_init else []\n\n    if needs_cached_setattr:\n        lines.append(\n            # Circumvent the __setattr__ descriptor to save one lookup per\n            # assignment.\n            # Note _setattr will be used again below if cache_hash is True\n            \"_setattr = _cached_setattr_get(self)\"\n        )\n\n    extra_lines, fmt_setter, fmt_setter_with_converter = _determine_setters(\n        frozen, slots, base_attr_map\n    )\n    lines.extend(extra_lines)\n\n    args = []\n    kw_only_args = []\n    attrs_to_validate = []\n\n    # This is a dictionary of names to validator and converter callables.\n    # Injecting this into __init__ globals lets us avoid lookups.\n    names_for_globals = {}\n    annotations = {\"return\": None}\n\n    for a in attrs:\n        if a.validator:\n            attrs_to_validate.append(a)\n\n        attr_name = a.name\n        has_on_setattr = a.on_setattr is not None or (\n            a.on_setattr is not setters.NO_OP and has_cls_on_setattr\n        )\n        # a.alias is set to maybe-mangled attr_name in _ClassBuilder if not\n        # explicitly provided\n        arg_name = a.alias\n\n        has_factory = isinstance(a.default, Factory)\n        maybe_self = \"self\" if has_factory and a.default.takes_self else \"\"\n\n        if a.init is False:\n            if has_factory:\n                init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n                if a.converter is not None:\n                    lines.append(\n                        fmt_setter_with_converter(\n                            attr_name,\n                            init_factory_name + f\"({maybe_self})\",\n                            has_on_setattr,\n                        )\n                    )\n                    names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                        a.converter\n                    )\n                else:\n                    lines.append(\n                        fmt_setter(\n                            attr_name,\n                            init_factory_name + f\"({maybe_self})\",\n                            has_on_setattr,\n                        )\n                    )\n                names_for_globals[init_factory_name] = a.default.factory\n            elif a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name,\n                        f\"attr_dict['{attr_name}'].default\",\n                        has_on_setattr,\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(\n                    fmt_setter(\n                        attr_name,\n                        f\"attr_dict['{attr_name}'].default\",\n                        has_on_setattr,\n                    )\n                )\n        elif a.default is not NOTHING and not has_factory:\n            arg = f\"{arg_name}=attr_dict['{attr_name}'].default\"\n            if a.kw_only:\n                kw_only_args.append(arg)\n            else:\n                args.append(arg)\n\n            if a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n\n        elif has_factory:\n            arg = f\"{arg_name}=NOTHING\"\n            if a.kw_only:\n                kw_only_args.append(arg)\n            else:\n                args.append(arg)\n            lines.append(f\"if {arg_name} is not NOTHING:\")\n\n            init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n            if a.converter is not None:\n                lines.append(\n                    \"    \"\n                    + fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                lines.append(\"else:\")\n                lines.append(\n                    \"    \"\n                    + fmt_setter_with_converter(\n                        attr_name,\n                        init_factory_name + \"(\" + maybe_self + \")\",\n                        has_on_setattr,\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(\n                    \"    \" + fmt_setter(attr_name, arg_name, has_on_setattr)\n                )\n                lines.append(\"else:\")\n                lines.append(\n                    \"    \"\n                    + fmt_setter(\n                        attr_name,\n                        init_factory_name + \"(\" + maybe_self + \")\",\n                        has_on_setattr,\n                    )\n                )\n            names_for_globals[init_factory_name] = a.default.factory\n        else:\n            if a.kw_only:\n                kw_only_args.append(arg_name)\n            else:\n                args.append(arg_name)\n\n            if a.converter is not None:\n                lines.append(\n                    fmt_setter_with_converter(\n                        attr_name, arg_name, has_on_setattr\n                    )\n                )\n                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n                    a.converter\n                )\n            else:\n                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n\n        if a.init is True:\n            if a.type is not None and a.converter is None:\n                annotations[arg_name] = a.type\n            elif a.converter is not None:\n                # Try to get the type from the converter.\n                t = _AnnotationExtractor(a.converter).get_first_param_type()\n                if t:\n                    annotations[arg_name] = t\n\n    if attrs_to_validate:  # we can skip this if there are no validators.\n        names_for_globals[\"_config\"] = _config\n        lines.append(\"if _config._run_validators is True:\")\n        for a in attrs_to_validate:\n            val_name = \"__attr_validator_\" + a.name\n            attr_name = \"__attr_\" + a.name\n            lines.append(f\"    {val_name}(self, {attr_name}, self.{a.name})\")\n            names_for_globals[val_name] = a.validator\n            names_for_globals[attr_name] = a\n\n    if post_init:\n        lines.append(\"self.__attrs_post_init__()\")\n\n    # because this is set only after __attrs_post_init__ is called, a crash\n    # will result if post-init tries to access the hash code.  This seemed\n    # preferable to setting this beforehand, in which case alteration to\n    # field values during post-init combined with post-init accessing the\n    # hash code would result in silent bugs.\n    if cache_hash:\n        if frozen:\n            if slots:  # noqa: SIM108\n                # if frozen and slots, then _setattr defined above\n                init_hash_cache = \"_setattr('%s', %s)\"\n            else:\n                # if frozen and not slots, then _inst_dict defined above\n                init_hash_cache = \"_inst_dict['%s'] = %s\"\n        else:\n            init_hash_cache = \"self.%s = %s\"\n        lines.append(init_hash_cache % (_HASH_CACHE_FIELD, \"None\"))\n\n    # For exceptions we rely on BaseException.__init__ for proper\n    # initialization.\n    if is_exc:\n        vals = \",\".join(f\"self.{a.name}\" for a in attrs if a.init)\n\n        lines.append(f\"BaseException.__init__(self, {vals})\")\n\n    args = \", \".join(args)\n    pre_init_args = args\n    if kw_only_args:\n        args += \"%s*, %s\" % (\n            \", \" if args else \"\",  # leading comma\n            \", \".join(kw_only_args),  # kw_only args\n        )\n        pre_init_kw_only_args = \", \".join(\n            [\"%s=%s\" % (kw_arg, kw_arg) for kw_arg in kw_only_args]\n        )\n        pre_init_args += (\n            \", \" if pre_init_args else \"\"\n        )  # handle only kwargs and no regular args\n        pre_init_args += pre_init_kw_only_args\n\n    if pre_init and pre_init_has_args:\n        # If pre init method has arguments, pass same arguments as `__init__`\n        lines[0] = \"self.__attrs_pre_init__(%s)\" % pre_init_args\n\n    return (\n        \"def %s(self, %s):\\n    %s\\n\"\n        % (\n            (\"__attrs_init__\" if attrs_init else \"__init__\"),\n            args,\n            \"\\n    \".join(lines) if lines else \"pass\",\n        ),\n        names_for_globals,\n        annotations,\n    )\n\n\ndef _default_init_alias_for(name: str) -> str:\n    \"\"\"\n    The default __init__ parameter name for a field.\n\n    This performs private-name adjustment via leading-unscore stripping,\n    and is the default value of Attribute.alias if not provided.\n    \"\"\"\n\n    return name.lstrip(\"_\")\n\n\nclass Attribute:\n    \"\"\"\n    *Read-only* representation of an attribute.\n\n    .. warning::\n\n       You should never instantiate this class yourself.\n\n    The class has *all* arguments of `attr.ib` (except for ``factory`` which is\n    only syntactic sugar for ``default=Factory(...)`` plus the following:\n\n    - ``name`` (`str`): The name of the attribute.\n    - ``alias`` (`str`): The __init__ parameter name of the attribute, after\n      any explicit overrides and default private-attribute-name handling.\n    - ``inherited`` (`bool`): Whether or not that attribute has been inherited\n      from a base class.\n    - ``eq_key`` and ``order_key`` (`typing.Callable` or `None`): The\n      callables that are used for comparing and ordering objects by this\n      attribute, respectively. These are set by passing a callable to\n      `attr.ib`'s ``eq``, ``order``, or ``cmp`` arguments. See also\n      :ref:`comparison customization <custom-comparison>`.\n\n    Instances of this class are frequently used for introspection purposes\n    like:\n\n    - `fields` returns a tuple of them.\n    - Validators get them passed as the first argument.\n    - The :ref:`field transformer <transform-fields>` hook receives a list of\n      them.\n    - The ``alias`` property exposes the __init__ parameter name of the field,\n      with any overrides and default private-attribute handling applied.\n\n\n    .. versionadded:: 20.1.0 *inherited*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.2.0 *inherited* is not taken into account for\n        equality checks and hashing anymore.\n    .. versionadded:: 21.1.0 *eq_key* and *order_key*\n    .. versionadded:: 22.2.0 *alias*\n\n    For the full version history of the fields, see `attr.ib`.\n    \"\"\"\n\n    __slots__ = (\n        \"name\",\n        \"default\",\n        \"validator\",\n        \"repr\",\n        \"eq\",\n        \"eq_key\",\n        \"order\",\n        \"order_key\",\n        \"hash\",\n        \"init\",\n        \"metadata\",\n        \"type\",\n        \"converter\",\n        \"kw_only\",\n        \"inherited\",\n        \"on_setattr\",\n        \"alias\",\n    )\n\n    def __init__(\n        self,\n        name,\n        default,\n        validator,\n        repr,\n        cmp,  # XXX: unused, remove along with other cmp code.\n        hash,\n        init,\n        inherited,\n        metadata=None,\n        type=None,\n        converter=None,\n        kw_only=False,\n        eq=None,\n        eq_key=None,\n        order=None,\n        order_key=None,\n        on_setattr=None,\n        alias=None,\n    ):\n        eq, eq_key, order, order_key = _determine_attrib_eq_order(\n            cmp, eq_key or eq, order_key or order, True\n        )\n\n        # Cache this descriptor here to speed things up later.\n        bound_setattr = _OBJ_SETATTR.__get__(self)\n\n        # Despite the big red warning, people *do* instantiate `Attribute`\n        # themselves.\n        bound_setattr(\"name\", name)\n        bound_setattr(\"default\", default)\n        bound_setattr(\"validator\", validator)\n        bound_setattr(\"repr\", repr)\n        bound_setattr(\"eq\", eq)\n        bound_setattr(\"eq_key\", eq_key)\n        bound_setattr(\"order\", order)\n        bound_setattr(\"order_key\", order_key)\n        bound_setattr(\"hash\", hash)\n        bound_setattr(\"init\", init)\n        bound_setattr(\"converter\", converter)\n        bound_setattr(\n            \"metadata\",\n            (\n                types.MappingProxyType(dict(metadata))  # Shallow copy\n                if metadata\n                else _EMPTY_METADATA_SINGLETON\n            ),\n        )\n        bound_setattr(\"type\", type)\n        bound_setattr(\"kw_only\", kw_only)\n        bound_setattr(\"inherited\", inherited)\n        bound_setattr(\"on_setattr\", on_setattr)\n        bound_setattr(\"alias\", alias)\n\n    def __setattr__(self, name, value):\n        raise FrozenInstanceError()\n\n    @classmethod\n    def from_counting_attr(cls, name, ca, type=None):\n        # type holds the annotated value. deal with conflicts:\n        if type is None:\n            type = ca.type\n        elif ca.type is not None:\n            msg = \"Type annotation and type argument cannot both be present\"\n            raise ValueError(msg)\n        inst_dict = {\n            k: getattr(ca, k)\n            for k in Attribute.__slots__\n            if k\n            not in (\n                \"name\",\n                \"validator\",\n                \"default\",\n                \"type\",\n                \"inherited\",\n            )  # exclude methods and deprecated alias\n        }\n        return cls(\n            name=name,\n            validator=ca._validator,\n            default=ca._default,\n            type=type,\n            cmp=None,\n            inherited=False,\n            **inst_dict,\n        )\n\n    # Don't use attrs.evolve since fields(Attribute) doesn't work\n    def evolve(self, **changes):\n        \"\"\"\n        Copy *self* and apply *changes*.\n\n        This works similarly to `attrs.evolve` but that function does not work\n        with `Attribute`.\n\n        It is mainly meant to be used for `transform-fields`.\n\n        .. versionadded:: 20.3.0\n        \"\"\"\n        new = copy.copy(self)\n\n        new._setattrs(changes.items())\n\n        return new\n\n    # Don't use _add_pickle since fields(Attribute) doesn't work\n    def __getstate__(self):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        return tuple(\n            getattr(self, name) if name != \"metadata\" else dict(self.metadata)\n            for name in self.__slots__\n        )\n\n    def __setstate__(self, state):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        self._setattrs(zip(self.__slots__, state))\n\n    def _setattrs(self, name_values_pairs):\n        bound_setattr = _OBJ_SETATTR.__get__(self)\n        for name, value in name_values_pairs:\n            if name != \"metadata\":\n                bound_setattr(name, value)\n            else:\n                bound_setattr(\n                    name,\n                    (\n                        types.MappingProxyType(dict(value))\n                        if value\n                        else _EMPTY_METADATA_SINGLETON\n                    ),\n                )\n\n\n_a = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=(name != \"metadata\"),\n        init=True,\n        inherited=False,\n        alias=_default_init_alias_for(name),\n    )\n    for name in Attribute.__slots__\n]\n\nAttribute = _add_hash(\n    _add_eq(\n        _add_repr(Attribute, attrs=_a),\n        attrs=[a for a in _a if a.name != \"inherited\"],\n    ),\n    attrs=[a for a in _a if a.hash and a.name != \"inherited\"],\n)\n\n\nclass _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve\n    the order in which the attributes have been defined.\n\n    *Internal* data structure of the attrs library.  Running into is most\n    likely the result of a bug like a forgotten `@attr.s` decorator.\n    \"\"\"\n\n    __slots__ = (\n        \"counter\",\n        \"_default\",\n        \"repr\",\n        \"eq\",\n        \"eq_key\",\n        \"order\",\n        \"order_key\",\n        \"hash\",\n        \"init\",\n        \"metadata\",\n        \"_validator\",\n        \"converter\",\n        \"type\",\n        \"kw_only\",\n        \"on_setattr\",\n        \"alias\",\n    )\n    __attrs_attrs__ = (\n        *tuple(\n            Attribute(\n                name=name,\n                alias=_default_init_alias_for(name),\n                default=NOTHING,\n                validator=None,\n                repr=True,\n                cmp=None,\n                hash=True,\n                init=True,\n                kw_only=False,\n                eq=True,\n                eq_key=None,\n                order=False,\n                order_key=None,\n                inherited=False,\n                on_setattr=None,\n            )\n            for name in (\n                \"counter\",\n                \"_default\",\n                \"repr\",\n                \"eq\",\n                \"order\",\n                \"hash\",\n                \"init\",\n                \"on_setattr\",\n                \"alias\",\n            )\n        ),\n        Attribute(\n            name=\"metadata\",\n            alias=\"metadata\",\n            default=None,\n            validator=None,\n            repr=True,\n            cmp=None,\n            hash=False,\n            init=True,\n            kw_only=False,\n            eq=True,\n            eq_key=None,\n            order=False,\n            order_key=None,\n            inherited=False,\n            on_setattr=None,\n        ),\n    )\n    cls_counter = 0\n\n    def __init__(\n        self,\n        default,\n        validator,\n        repr,\n        cmp,\n        hash,\n        init,\n        converter,\n        metadata,\n        type,\n        kw_only,\n        eq,\n        eq_key,\n        order,\n        order_key,\n        on_setattr,\n        alias,\n    ):\n        _CountingAttr.cls_counter += 1\n        self.counter = _CountingAttr.cls_counter\n        self._default = default\n        self._validator = validator\n        self.converter = converter\n        self.repr = repr\n        self.eq = eq\n        self.eq_key = eq_key\n        self.order = order\n        self.order_key = order_key\n        self.hash = hash\n        self.init = init\n        self.metadata = metadata\n        self.type = type\n        self.kw_only = kw_only\n        self.on_setattr = on_setattr\n        self.alias = alias\n\n    def validator(self, meth):\n        \"\"\"\n        Decorator that adds *meth* to the list of validators.\n\n        Returns *meth* unchanged.\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if self._validator is None:\n            self._validator = meth\n        else:\n            self._validator = and_(self._validator, meth)\n        return meth\n\n    def default(self, meth):\n        \"\"\"\n        Decorator that allows to set the default for an attribute.\n\n        Returns *meth* unchanged.\n\n        :raises DefaultAlreadySetError: If default has been set before.\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if self._default is not NOTHING:\n            raise DefaultAlreadySetError()\n\n        self._default = Factory(meth, takes_self=True)\n\n        return meth\n\n\n_CountingAttr = _add_eq(_add_repr(_CountingAttr))\n\n\nclass Factory:\n    \"\"\"\n    Stores a factory callable.\n\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n\n    :param typing.Callable factory: A callable that takes either none or\n        exactly one mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.\n\n    .. versionadded:: 17.1.0  *takes_self*\n    \"\"\"\n\n    __slots__ = (\"factory\", \"takes_self\")\n\n    def __init__(self, factory, takes_self=False):\n        self.factory = factory\n        self.takes_self = takes_self\n\n    def __getstate__(self):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        return tuple(getattr(self, name) for name in self.__slots__)\n\n    def __setstate__(self, state):\n        \"\"\"\n        Play nice with pickle.\n        \"\"\"\n        for name, value in zip(self.__slots__, state):\n            setattr(self, name, value)\n\n\n_f = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=True,\n        init=True,\n        inherited=False,\n    )\n    for name in Factory.__slots__\n]\n\nFactory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)\n\n\ndef make_class(\n    name, attrs, bases=(object,), class_body=None, **attributes_arguments\n):\n    r\"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n\n    :param str name: The name for the new class.\n\n    :param list | dict attrs: A list of names or a dictionary of mappings of\n        names to `attr.ib`\\ s / `attrs.field`\\ s.\n\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.\n\n    :param tuple bases: Classes that the new class will subclass.\n\n    :param dict class_body: An optional dictionary of class attributes for the\n        new class.\n\n    :param attributes_arguments: Passed unmodified to `attr.s`.\n\n    :return: A new class with *attrs*.\n    :rtype: type\n\n    .. versionadded:: 17.1.0 *bases*\n    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.\n    .. versionchanged:: 23.2.0 *class_body*\n    \"\"\"\n    if isinstance(attrs, dict):\n        cls_dict = attrs\n    elif isinstance(attrs, (list, tuple)):\n        cls_dict = {a: attrib() for a in attrs}\n    else:\n        msg = \"attrs argument must be a dict or a list.\"\n        raise TypeError(msg)\n\n    pre_init = cls_dict.pop(\"__attrs_pre_init__\", None)\n    post_init = cls_dict.pop(\"__attrs_post_init__\", None)\n    user_init = cls_dict.pop(\"__init__\", None)\n\n    body = {}\n    if class_body is not None:\n        body.update(class_body)\n    if pre_init is not None:\n        body[\"__attrs_pre_init__\"] = pre_init\n    if post_init is not None:\n        body[\"__attrs_post_init__\"] = post_init\n    if user_init is not None:\n        body[\"__init__\"] = user_init\n\n    type_ = types.new_class(name, bases, {}, lambda ns: ns.update(body))\n\n    # For pickling to work, the __module__ variable needs to be set to the\n    # frame where the class is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    with contextlib.suppress(AttributeError, ValueError):\n        type_.__module__ = sys._getframe(1).f_globals.get(\n            \"__name__\", \"__main__\"\n        )\n\n    # We do it here for proper warnings with meaningful stacklevel.\n    cmp = attributes_arguments.pop(\"cmp\", None)\n    (\n        attributes_arguments[\"eq\"],\n        attributes_arguments[\"order\"],\n    ) = _determine_attrs_eq_order(\n        cmp,\n        attributes_arguments.get(\"eq\"),\n        attributes_arguments.get(\"order\"),\n        True,\n    )\n\n    return _attrs(these=cls_dict, **attributes_arguments)(type_)\n\n\n# These are required by within this module so we define them here and merely\n# import into .validators / .converters.\n\n\n@attrs(slots=True, hash=True)\nclass _AndValidator:\n    \"\"\"\n    Compose many validators to a single one.\n    \"\"\"\n\n    _validators = attrib()\n\n    def __call__(self, inst, attr, value):\n        for v in self._validators:\n            v(inst, attr, value)\n\n\ndef and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n\n    When called on a value, it runs all wrapped validators.\n\n    :param ~collections.abc.Iterable[typing.Callable] validators: Arbitrary\n        number of validators.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(\n            validator._validators\n            if isinstance(validator, _AndValidator)\n            else [validator]\n        )\n\n    return _AndValidator(tuple(vals))\n\n\ndef pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n\n    Type annotations will be inferred from the wrapped converters', if they\n    have any.\n\n    :param ~collections.abc.Iterable[typing.Callable] converters: Arbitrary\n        number of converters.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def pipe_converter(val):\n        for converter in converters:\n            val = converter(val)\n\n        return val\n\n    if not converters:\n        # If the converter list is empty, pipe_converter is the identity.\n        A = typing.TypeVar(\"A\")\n        pipe_converter.__annotations__ = {\"val\": A, \"return\": A}\n    else:\n        # Get parameter type from first converter.\n        t = _AnnotationExtractor(converters[0]).get_first_param_type()\n        if t:\n            pipe_converter.__annotations__[\"val\"] = t\n\n        # Get return type from last converter.\n        rt = _AnnotationExtractor(converters[-1]).get_return_type()\n        if rt:\n            pipe_converter.__annotations__[\"return\"] = rt\n\n    return pipe_converter\n", "src/attr/_funcs.py": "# SPDX-License-Identifier: MIT\n\n\nimport copy\n\nfrom ._compat import PY_3_9_PLUS, get_generic_base\nfrom ._make import _OBJ_SETATTR, NOTHING, fields\nfrom .exceptions import AttrsAttributeNotFoundError\n\n\ndef asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the *attrs* attribute values of *inst* as a dict.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also *attrs*-decorated.\n    :param ~typing.Callable filter: A callable whose return code determines\n        whether an attribute or element is included (`True`) or dropped\n        (`False`).  Is called with the `attrs.Attribute` as the first argument\n        and the value as the second argument.\n    :param ~typing.Callable dict_factory: A callable to produce dictionaries\n        from.  For example, to produce ordered dictionaries instead of normal\n        Python dictionaries, pass in ``collections.OrderedDict``.\n    :param bool retain_collection_types: Do not convert to `list` when\n        encountering an attribute whose type is `tuple` or `set`.  Only\n        meaningful if *recurse* is `True`.\n    :param typing.Callable | None value_serializer: A hook that is called for\n        every attribute or dict key/value.  It receives the current instance,\n        field and value and must return the (updated) value.  The hook is run\n        *after* the optional *filter* has been applied.\n\n    :rtype: return type of *dict_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.0.0 *dict_factory*\n    ..  versionadded:: 16.1.0 *retain_collection_types*\n    ..  versionadded:: 20.3.0 *value_serializer*\n    ..  versionadded:: 21.3.0 If a dict has a collection for a key, it is\n        serialized as a tuple.\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = dict_factory()\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n\n        if value_serializer is not None:\n            v = value_serializer(inst, a, v)\n\n        if recurse is True:\n            if has(v.__class__):\n                rv[a.name] = asdict(\n                    v,\n                    recurse=True,\n                    filter=filter,\n                    dict_factory=dict_factory,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain_collection_types is True else list\n                items = [\n                    _asdict_anything(\n                        i,\n                        is_key=False,\n                        filter=filter,\n                        dict_factory=dict_factory,\n                        retain_collection_types=retain_collection_types,\n                        value_serializer=value_serializer,\n                    )\n                    for i in v\n                ]\n                try:\n                    rv[a.name] = cf(items)\n                except TypeError:\n                    if not issubclass(cf, tuple):\n                        raise\n                    # Workaround for TypeError: cf.__new__() missing 1 required\n                    # positional argument (which appears, for a namedturle)\n                    rv[a.name] = cf(*items)\n            elif isinstance(v, dict):\n                df = dict_factory\n                rv[a.name] = df(\n                    (\n                        _asdict_anything(\n                            kk,\n                            is_key=True,\n                            filter=filter,\n                            dict_factory=df,\n                            retain_collection_types=retain_collection_types,\n                            value_serializer=value_serializer,\n                        ),\n                        _asdict_anything(\n                            vv,\n                            is_key=False,\n                            filter=filter,\n                            dict_factory=df,\n                            retain_collection_types=retain_collection_types,\n                            value_serializer=value_serializer,\n                        ),\n                    )\n                    for kk, vv in v.items()\n                )\n            else:\n                rv[a.name] = v\n        else:\n            rv[a.name] = v\n    return rv\n\n\ndef _asdict_anything(\n    val,\n    is_key,\n    filter,\n    dict_factory,\n    retain_collection_types,\n    value_serializer,\n):\n    \"\"\"\n    ``asdict`` only works on attrs instances, this works on anything.\n    \"\"\"\n    if getattr(val.__class__, \"__attrs_attrs__\", None) is not None:\n        # Attrs class.\n        rv = asdict(\n            val,\n            recurse=True,\n            filter=filter,\n            dict_factory=dict_factory,\n            retain_collection_types=retain_collection_types,\n            value_serializer=value_serializer,\n        )\n    elif isinstance(val, (tuple, list, set, frozenset)):\n        if retain_collection_types is True:\n            cf = val.__class__\n        elif is_key:\n            cf = tuple\n        else:\n            cf = list\n\n        rv = cf(\n            [\n                _asdict_anything(\n                    i,\n                    is_key=False,\n                    filter=filter,\n                    dict_factory=dict_factory,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                )\n                for i in val\n            ]\n        )\n    elif isinstance(val, dict):\n        df = dict_factory\n        rv = df(\n            (\n                _asdict_anything(\n                    kk,\n                    is_key=True,\n                    filter=filter,\n                    dict_factory=df,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                ),\n                _asdict_anything(\n                    vv,\n                    is_key=False,\n                    filter=filter,\n                    dict_factory=df,\n                    retain_collection_types=retain_collection_types,\n                    value_serializer=value_serializer,\n                ),\n            )\n            for kk, vv in val.items()\n        )\n    else:\n        rv = val\n        if value_serializer is not None:\n            rv = value_serializer(None, None, rv)\n\n    return rv\n\n\ndef astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the *attrs* attribute values of *inst* as a tuple.\n\n    Optionally recurse into other *attrs*-decorated classes.\n\n    :param inst: Instance of an *attrs*-decorated class.\n    :param bool recurse: Recurse into classes that are also *attrs*-decorated.\n    :param ~typing.Callable filter: A callable whose return code determines\n        whether an attribute or element is included (`True`) or dropped\n        (`False`).  Is called with the `attrs.Attribute` as the first argument\n        and the value as the second argument.\n    :param ~typing.Callable tuple_factory: A callable to produce tuples from.\n        For example, to produce lists instead of tuples.\n    :param bool retain_collection_types: Do not convert to `list` or `dict`\n        when encountering an attribute which type is `tuple`, `dict` or `set`.\n        Only meaningful if *recurse* is `True`.\n\n    :rtype: return type of *tuple_factory*\n\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  versionadded:: 16.2.0\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = []\n    retain = retain_collection_types  # Very long. :/\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n        if recurse is True:\n            if has(v.__class__):\n                rv.append(\n                    astuple(\n                        v,\n                        recurse=True,\n                        filter=filter,\n                        tuple_factory=tuple_factory,\n                        retain_collection_types=retain,\n                    )\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain is True else list\n                items = [\n                    (\n                        astuple(\n                            j,\n                            recurse=True,\n                            filter=filter,\n                            tuple_factory=tuple_factory,\n                            retain_collection_types=retain,\n                        )\n                        if has(j.__class__)\n                        else j\n                    )\n                    for j in v\n                ]\n                try:\n                    rv.append(cf(items))\n                except TypeError:\n                    if not issubclass(cf, tuple):\n                        raise\n                    # Workaround for TypeError: cf.__new__() missing 1 required\n                    # positional argument (which appears, for a namedturle)\n                    rv.append(cf(*items))\n            elif isinstance(v, dict):\n                df = v.__class__ if retain is True else dict\n                rv.append(\n                    df(\n                        (\n                            (\n                                astuple(\n                                    kk,\n                                    tuple_factory=tuple_factory,\n                                    retain_collection_types=retain,\n                                )\n                                if has(kk.__class__)\n                                else kk\n                            ),\n                            (\n                                astuple(\n                                    vv,\n                                    tuple_factory=tuple_factory,\n                                    retain_collection_types=retain,\n                                )\n                                if has(vv.__class__)\n                                else vv\n                            ),\n                        )\n                        for kk, vv in v.items()\n                    )\n                )\n            else:\n                rv.append(v)\n        else:\n            rv.append(v)\n\n    return rv if tuple_factory is list else tuple_factory(rv)\n\n\ndef has(cls):\n    \"\"\"\n    Check whether *cls* is a class with *attrs* attributes.\n\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n\n    :rtype: bool\n    \"\"\"\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is not None:\n        return True\n\n    # No attrs, maybe it's a specialized generic (A[str])?\n    generic_base = get_generic_base(cls)\n    if generic_base is not None:\n        generic_attrs = getattr(generic_base, \"__attrs_attrs__\", None)\n        if generic_attrs is not None:\n            # Stick it on here for speed next time.\n            cls.__attrs_attrs__ = generic_attrs\n        return generic_attrs is not None\n    return False\n\n\ndef assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n\n    This is different from `evolve` that applies the changes to the arguments\n    that create the new instance.\n\n    `evolve`'s behavior is preferable, but there are `edge cases`_ where it\n    doesn't work. Therefore `assoc` is deprecated, but will not be removed.\n\n    .. _`edge cases`: https://github.com/python-attrs/attrs/issues/251\n\n    :param inst: Instance of a class with *attrs* attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name*\n        couldn't be found on *cls*.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    ..  deprecated:: 17.1.0\n        Use `attrs.evolve` instead if you can.\n        This function will not be removed du to the slightly different approach\n        compared to `attrs.evolve`.\n    \"\"\"\n    new = copy.copy(inst)\n    attrs = fields(inst.__class__)\n    for k, v in changes.items():\n        a = getattr(attrs, k, NOTHING)\n        if a is NOTHING:\n            msg = f\"{k} is not an attrs attribute on {new.__class__}.\"\n            raise AttrsAttributeNotFoundError(msg)\n        _OBJ_SETATTR(new, k, v)\n    return new\n\n\ndef evolve(*args, **changes):\n    \"\"\"\n    Create a new instance, based on the first positional argument with\n    *changes* applied.\n\n    :param inst: Instance of a class with *attrs* attributes. *inst* must be\n        passed as a positional argument.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class.\n\n    .. versionadded:: 17.1.0\n    .. deprecated:: 23.1.0\n       It is now deprecated to pass the instance using the keyword argument\n       *inst*. It will raise a warning until at least April 2024, after which\n       it will become an error. Always pass the instance as a positional\n       argument.\n    .. versionchanged:: 24.1.0\n       *inst* can't be passed as a keyword argument anymore.\n    \"\"\"\n    try:\n        (inst,) = args\n    except ValueError:\n        msg = (\n            f\"evolve() takes 1 positional argument, but {len(args)} were given\"\n        )\n        raise TypeError(msg) from None\n\n    cls = inst.__class__\n    attrs = fields(cls)\n    for a in attrs:\n        if not a.init:\n            continue\n        attr_name = a.name  # To deal with private attributes.\n        init_name = a.alias\n        if init_name not in changes:\n            changes[init_name] = getattr(inst, attr_name)\n\n    return cls(**changes)\n\n\ndef resolve_types(\n    cls, globalns=None, localns=None, attribs=None, include_extras=True\n):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only use\n    them for static type checking.\n\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, for example, if the name only\n    exists inside a method, you may pass *globalns* or *localns* to specify\n    other dictionaries in which to look up these names. See the docs of\n    `typing.get_type_hints` for more details.\n\n    :param type cls: Class to resolve.\n    :param dict | None globalns: Dictionary containing global variables.\n    :param dict | None localns: Dictionary containing local variables.\n    :param list | None attribs: List of attribs for the given class. This is\n        necessary when calling from inside a ``field_transformer`` since *cls*\n        is not an *attrs* class yet.\n    :param bool include_extras: Resolve more accurately, if possible. Pass\n        ``include_extras`` to ``typing.get_hints``, if supported by the typing\n        module. On supported Python versions (3.9+), this resolves the types\n        more accurately.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n        class and you didn't pass any attribs.\n    :raise NameError: If types cannot be resolved because of missing variables.\n\n    :returns: *cls* so you can use this function also as a class decorator.\n        Please note that you have to apply it **after** `attrs.define`. That\n        means the decorator has to come in the line **before** `attrs.define`.\n\n    ..  versionadded:: 20.1.0\n    ..  versionadded:: 21.1.0 *attribs*\n    ..  versionadded:: 23.1.0 *include_extras*\n    \"\"\"\n    # Since calling get_type_hints is expensive we cache whether we've\n    # done it already.\n    if getattr(cls, \"__attrs_types_resolved__\", None) != cls:\n        import typing\n\n        kwargs = {\"globalns\": globalns, \"localns\": localns}\n\n        if PY_3_9_PLUS:\n            kwargs[\"include_extras\"] = include_extras\n\n        hints = typing.get_type_hints(cls, **kwargs)\n        for field in fields(cls) if attribs is None else attribs:\n            if field.name in hints:\n                # Since fields have been frozen we must work around it.\n                _OBJ_SETATTR(field, \"type\", hints[field.name])\n        # We store the class we resolved so that subclasses know they haven't\n        # been resolved.\n        cls.__attrs_types_resolved__ = cls\n\n    # Return the class so you can use it as a decorator too.\n    return cls\n", "src/attr/_version_info.py": "# SPDX-License-Identifier: MIT\n\n\nfrom functools import total_ordering\n\nfrom ._funcs import astuple\nfrom ._make import attrib, attrs\n\n\n@total_ordering\n@attrs(eq=False, order=False, slots=True, frozen=True)\nclass VersionInfo:\n    \"\"\"\n    A version object that can be compared to tuple of length 1--4:\n\n    >>> attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\n    True\n    >>> attr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)\n    True\n    >>> vi = attr.VersionInfo(19, 2, 0, \"final\")\n    >>> vi < (19, 1, 1)\n    False\n    >>> vi < (19,)\n    False\n    >>> vi == (19, 2,)\n    True\n    >>> vi == (19, 2, 1)\n    False\n\n    .. versionadded:: 19.2\n    \"\"\"\n\n    year = attrib(type=int)\n    minor = attrib(type=int)\n    micro = attrib(type=int)\n    releaselevel = attrib(type=str)\n\n    @classmethod\n    def _from_version_string(cls, s):\n        \"\"\"\n        Parse *s* and return a _VersionInfo.\n        \"\"\"\n        v = s.split(\".\")\n        if len(v) == 3:\n            v.append(\"final\")\n\n        return cls(\n            year=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]\n        )\n\n    def _ensure_tuple(self, other):\n        \"\"\"\n        Ensure *other* is a tuple of a valid length.\n\n        Returns a possibly transformed *other* and ourselves as a tuple of\n        the same length as *other*.\n        \"\"\"\n\n        if self.__class__ is other.__class__:\n            other = astuple(other)\n\n        if not isinstance(other, tuple):\n            raise NotImplementedError\n\n        if not (1 <= len(other) <= 4):\n            raise NotImplementedError\n\n        return astuple(self)[: len(other)], other\n\n    def __eq__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        return us == them\n\n    def __lt__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        # Since alphabetically \"dev0\" < \"final\" < \"post1\" < \"post2\", we don't\n        # have to do anything special with releaselevel for now.\n        return us < them\n", "src/attr/_config.py": "# SPDX-License-Identifier: MIT\n\n__all__ = [\"set_run_validators\", \"get_run_validators\"]\n\n_run_validators = True\n\n\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        msg = \"'run' must be bool.\"\n        raise TypeError(msg)\n    global _run_validators\n    _run_validators = run\n\n\ndef get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`\n        instead.\n    \"\"\"\n    return _run_validators\n", "src/attr/converters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful converters.\n\"\"\"\n\n\nimport typing\n\nfrom ._compat import _AnnotationExtractor\nfrom ._make import NOTHING, Factory, pipe\n\n\n__all__ = [\n    \"default_if_none\",\n    \"optional\",\n    \"pipe\",\n    \"to_bool\",\n]\n\n\ndef optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to `None`.\n\n    Type annotations will be inferred from the wrapped converter's, if it has\n    any.\n\n    :param typing.Callable converter: the converter that is used for non-`None`\n        values.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n\n    def optional_converter(val):\n        if val is None:\n            return None\n        return converter(val)\n\n    xtr = _AnnotationExtractor(converter)\n\n    t = xtr.get_first_param_type()\n    if t:\n        optional_converter.__annotations__[\"val\"] = typing.Optional[t]\n\n    rt = xtr.get_return_type()\n    if rt:\n        optional_converter.__annotations__[\"return\"] = typing.Optional[rt]\n\n    return optional_converter\n\n\ndef default_if_none(default=NOTHING, factory=None):\n    \"\"\"\n    A converter that allows to replace `None` values by *default* or the result\n    of *factory*.\n\n    :param default: Value to be used if `None` is passed. Passing an instance\n       of `attrs.Factory` is supported, however the ``takes_self`` option is\n       *not*.\n    :param typing.Callable factory: A callable that takes no parameters whose\n       result is used if `None` is passed.\n\n    :raises TypeError: If **neither** *default* or *factory* is passed.\n    :raises TypeError: If **both** *default* and *factory* are passed.\n    :raises ValueError: If an instance of `attrs.Factory` is passed with\n       ``takes_self=True``.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n    if default is NOTHING and factory is None:\n        msg = \"Must pass either `default` or `factory`.\"\n        raise TypeError(msg)\n\n    if default is not NOTHING and factory is not None:\n        msg = \"Must pass either `default` or `factory` but not both.\"\n        raise TypeError(msg)\n\n    if factory is not None:\n        default = Factory(factory)\n\n    if isinstance(default, Factory):\n        if default.takes_self:\n            msg = \"`takes_self` is not supported by default_if_none.\"\n            raise ValueError(msg)\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default.factory()\n\n    else:\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default\n\n    return default_if_none_converter\n\n\ndef to_bool(val):\n    \"\"\"\n    Convert \"boolean\" strings (for example, from environment variables) to real\n    booleans.\n\n    Values mapping to `True`:\n\n    - ``True``\n    - ``\"true\"`` / ``\"t\"``\n    - ``\"yes\"`` / ``\"y\"``\n    - ``\"on\"``\n    - ``\"1\"``\n    - ``1``\n\n    Values mapping to `False`:\n\n    - ``False``\n    - ``\"false\"`` / ``\"f\"``\n    - ``\"no\"`` / ``\"n\"``\n    - ``\"off\"``\n    - ``\"0\"``\n    - ``0``\n\n    :raises ValueError: for any other value.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    if val in (True, \"true\", \"t\", \"yes\", \"y\", \"on\", \"1\", 1):\n        return True\n    if val in (False, \"false\", \"f\", \"no\", \"n\", \"off\", \"0\", 0):\n        return False\n\n    msg = f\"Cannot convert value to bool: {val!r}\"\n    raise ValueError(msg)\n", "src/attr/_next_gen.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nThese are keyword-only APIs that call `attr.s` and `attr.ib` with different\ndefault values.\n\"\"\"\n\n\nfrom functools import partial\n\nfrom . import setters\nfrom ._funcs import asdict as _asdict\nfrom ._funcs import astuple as _astuple\nfrom ._make import (\n    _DEFAULT_ON_SETATTR,\n    NOTHING,\n    _frozen_setattrs,\n    attrib,\n    attrs,\n)\nfrom .exceptions import UnannotatedAttributeError\n\n\ndef define(\n    maybe_cls=None,\n    *,\n    these=None,\n    repr=None,\n    unsafe_hash=None,\n    hash=None,\n    init=None,\n    slots=True,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=None,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=True,\n    eq=None,\n    order=False,\n    auto_detect=True,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n    match_args=True,\n):\n    r\"\"\"\n    Define an *attrs* class.\n\n    Differences to the classic `attr.s` that it uses underneath:\n\n    - Automatically detect whether or not *auto_attribs* should be `True` (c.f.\n      *auto_attribs* parameter).\n    - Converters and validators run when attributes are set by default -- if\n      *frozen* is `False`.\n    - *slots=True*\n\n      .. caution::\n\n         Usually this has only upsides and few visible effects in everyday\n         programming. But it *can* lead to some surprising behaviors, so please\n         make sure to read :term:`slotted classes`.\n    - *auto_exc=True*\n    - *auto_detect=True*\n    - *order=False*\n    - Some options that were only relevant on Python 2 or were kept around for\n      backwards-compatibility have been removed.\n\n    Please note that these are all defaults and you can change them as you\n    wish.\n\n    :param bool | None auto_attribs: If set to `True` or `False`, it behaves\n       exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n\n       1. If any attributes are annotated and no unannotated `attrs.fields`\\ s\n          are found, it assumes *auto_attribs=True*.\n       2. Otherwise it assumes *auto_attribs=False* and tries to collect\n          `attrs.fields`\\ s.\n\n    For now, please refer to `attr.s` for the rest of the parameters.\n\n    .. versionadded:: 20.1.0\n    .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.\n    .. versionadded:: 22.2.0\n       *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).\n    \"\"\"\n\n    def do_it(cls, auto_attribs):\n        return attrs(\n            maybe_cls=cls,\n            these=these,\n            repr=repr,\n            hash=hash,\n            unsafe_hash=unsafe_hash,\n            init=init,\n            slots=slots,\n            frozen=frozen,\n            weakref_slot=weakref_slot,\n            str=str,\n            auto_attribs=auto_attribs,\n            kw_only=kw_only,\n            cache_hash=cache_hash,\n            auto_exc=auto_exc,\n            eq=eq,\n            order=order,\n            auto_detect=auto_detect,\n            collect_by_mro=True,\n            getstate_setstate=getstate_setstate,\n            on_setattr=on_setattr,\n            field_transformer=field_transformer,\n            match_args=match_args,\n        )\n\n    def wrap(cls):\n        \"\"\"\n        Making this a wrapper ensures this code runs during class creation.\n\n        We also ensure that frozen-ness of classes is inherited.\n        \"\"\"\n        nonlocal frozen, on_setattr\n\n        had_on_setattr = on_setattr not in (None, setters.NO_OP)\n\n        # By default, mutable classes convert & validate on setattr.\n        if frozen is False and on_setattr is None:\n            on_setattr = _DEFAULT_ON_SETATTR\n\n        # However, if we subclass a frozen class, we inherit the immutability\n        # and disable on_setattr.\n        for base_cls in cls.__bases__:\n            if base_cls.__setattr__ is _frozen_setattrs:\n                if had_on_setattr:\n                    msg = \"Frozen classes can't use on_setattr (frozen-ness was inherited).\"\n                    raise ValueError(msg)\n\n                on_setattr = setters.NO_OP\n                break\n\n        if auto_attribs is not None:\n            return do_it(cls, auto_attribs)\n\n        try:\n            return do_it(cls, True)\n        except UnannotatedAttributeError:\n            return do_it(cls, False)\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but `None` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n\n    return wrap(maybe_cls)\n\n\nmutable = define\nfrozen = partial(define, frozen=True, on_setattr=None)\n\n\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n    alias=None,\n):\n    \"\"\"\n    Identical to `attr.ib`, except keyword-only and with some arguments\n    removed.\n\n    .. versionadded:: 23.1.0\n       The *type* parameter has been re-added; mostly for `attrs.make_class`.\n       Please note that type checkers ignore this metadata.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    return attrib(\n        default=default,\n        validator=validator,\n        repr=repr,\n        hash=hash,\n        init=init,\n        metadata=metadata,\n        type=type,\n        converter=converter,\n        factory=factory,\n        kw_only=kw_only,\n        eq=eq,\n        order=order,\n        on_setattr=on_setattr,\n        alias=alias,\n    )\n\n\ndef asdict(inst, *, recurse=True, filter=None, value_serializer=None):\n    \"\"\"\n    Same as `attr.asdict`, except that collections types are always retained\n    and dict is always used as *dict_factory*.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _asdict(\n        inst=inst,\n        recurse=recurse,\n        filter=filter,\n        value_serializer=value_serializer,\n        retain_collection_types=True,\n    )\n\n\ndef astuple(inst, *, recurse=True, filter=None):\n    \"\"\"\n    Same as `attr.astuple`, except that collections types are always retained\n    and `tuple` is always used as the *tuple_factory*.\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _astuple(\n        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True\n    )\n", "src/attr/setters.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly used hooks for on_setattr.\n\"\"\"\n\n\nfrom . import _config\nfrom .exceptions import FrozenAttributeError\n\n\ndef pipe(*setters):\n    \"\"\"\n    Run all *setters* and return the return value of the last one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def wrapped_pipe(instance, attrib, new_value):\n        rv = new_value\n\n        for setter in setters:\n            rv = setter(instance, attrib, rv)\n\n        return rv\n\n    return wrapped_pipe\n\n\ndef frozen(_, __, ___):\n    \"\"\"\n    Prevent an attribute to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    raise FrozenAttributeError()\n\n\ndef validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    if _config._run_validators is False:\n        return new_value\n\n    v = attrib.validator\n    if not v:\n        return new_value\n\n    v(instance, attrib, new_value)\n\n    return new_value\n\n\ndef convert(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n    result.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    c = attrib.converter\n    if c:\n        return c(new_value)\n\n    return new_value\n\n\n# Sentinel for disabling class-wide *on_setattr* hooks for certain attributes.\n# Sphinx's autodata stopped working, so the docstring is inlined in the API\n# docs.\nNO_OP = object()\n", "src/attr/validators.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nCommonly useful validators.\n\"\"\"\n\n\nimport operator\nimport re\n\nfrom contextlib import contextmanager\nfrom re import Pattern\n\nfrom ._config import get_run_validators, set_run_validators\nfrom ._make import _AndValidator, and_, attrib, attrs\nfrom .converters import default_if_none\nfrom .exceptions import NotCallableError\n\n\n__all__ = [\n    \"and_\",\n    \"deep_iterable\",\n    \"deep_mapping\",\n    \"disabled\",\n    \"ge\",\n    \"get_disabled\",\n    \"gt\",\n    \"in_\",\n    \"instance_of\",\n    \"is_callable\",\n    \"le\",\n    \"lt\",\n    \"matches_re\",\n    \"max_len\",\n    \"min_len\",\n    \"not_\",\n    \"optional\",\n    \"set_disabled\",\n]\n\n\ndef set_disabled(disabled):\n    \"\"\"\n    Globally disable or enable running validators.\n\n    By default, they are run.\n\n    :param disabled: If `True`, disable running all validators.\n    :type disabled: bool\n\n    .. warning::\n\n        This function is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(not disabled)\n\n\ndef get_disabled():\n    \"\"\"\n    Return a bool indicating whether validators are currently disabled or not.\n\n    :return: `True` if validators are currently disabled.\n    :rtype: bool\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return not get_run_validators()\n\n\n@contextmanager\ndef disabled():\n    \"\"\"\n    Context manager that disables running validators within its context.\n\n    .. warning::\n\n        This context manager is not thread-safe!\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(False)\n    try:\n        yield\n    finally:\n        set_run_validators(True)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _InstanceOfValidator:\n    type = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not isinstance(value, self.type):\n            msg = f\"'{attr.name}' must be {self.type!r} (got {value!r} that is a {value.__class__!r}).\"\n            raise TypeError(\n                msg,\n                attr,\n                self.type,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<instance_of validator for type {self.type!r}>\"\n\n\ndef instance_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called with a\n    wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n\n    :param type | tuple[type] type: The type to check for.\n\n    :raises TypeError: With a human readable error message, the attribute (of\n        type `attrs.Attribute`), the expected type, and the value it got.\n    \"\"\"\n    return _InstanceOfValidator(type)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MatchesReValidator:\n    pattern = attrib()\n    match_func = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.match_func(value):\n            msg = f\"'{attr.name}' must match regex {self.pattern.pattern!r} ({value!r} doesn't)\"\n            raise ValueError(\n                msg,\n                attr,\n                self.pattern,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<matches_re validator for pattern {self.pattern!r}>\"\n\n\ndef matches_re(regex, flags=0, func=None):\n    r\"\"\"\n    A validator that raises `ValueError` if the initializer is called with a\n    string that doesn't match *regex*.\n\n    :param regex: a regex string or precompiled pattern to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param typing.Callable func: which underlying `re` function to call. Valid\n        options are `re.fullmatch`, `re.search`, and `re.match`; the default\n        `None` means `re.fullmatch`. For performance reasons, the pattern is\n        always precompiled using `re.compile`.\n\n    .. versionadded:: 19.2.0\n    .. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.\n    \"\"\"\n    valid_funcs = (re.fullmatch, None, re.search, re.match)\n    if func not in valid_funcs:\n        msg = \"'func' must be one of {}.\".format(\n            \", \".join(\n                sorted(e and e.__name__ or \"None\" for e in set(valid_funcs))\n            )\n        )\n        raise ValueError(msg)\n\n    if isinstance(regex, Pattern):\n        if flags:\n            msg = \"'flags' can only be used with a string pattern; pass flags to re.compile() instead\"\n            raise TypeError(msg)\n        pattern = regex\n    else:\n        pattern = re.compile(regex, flags)\n\n    if func is re.match:\n        match_func = pattern.match\n    elif func is re.search:\n        match_func = pattern.search\n    else:\n        match_func = pattern.fullmatch\n\n    return _MatchesReValidator(pattern, match_func)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _OptionalValidator:\n    validator = attrib()\n\n    def __call__(self, inst, attr, value):\n        if value is None:\n            return\n\n        self.validator(inst, attr, value)\n\n    def __repr__(self):\n        return f\"<optional validator for {self.validator!r} or None>\"\n\n\ndef optional(validator):\n    \"\"\"\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to `None` in addition to satisfying the requirements of\n    the sub-validator.\n\n    :param validator: A validator (or validators) that is used for non-`None`\n        values.\n    :type validator: typing.Callable | tuple[typing.Callable] |\n        list[typing.Callable]\n\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.\n    .. versionchanged:: 23.1.0 *validator* can also be a tuple of validators.\n    \"\"\"\n    if isinstance(validator, (list, tuple)):\n        return _OptionalValidator(_AndValidator(validator))\n\n    return _OptionalValidator(validator)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _InValidator:\n    options = attrib()\n\n    def __call__(self, inst, attr, value):\n        try:\n            in_options = value in self.options\n        except TypeError:  # e.g. `1 in \"abc\"`\n            in_options = False\n\n        if not in_options:\n            msg = f\"'{attr.name}' must be in {self.options!r} (got {value!r})\"\n            raise ValueError(\n                msg,\n                attr,\n                self.options,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<in_ validator with options {self.options!r}>\"\n\n\ndef in_(options):\n    \"\"\"\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attrs.Attribute`), the expected options, and the value it\n       got.\n\n    .. versionadded:: 17.1.0\n    .. versionchanged:: 22.1.0\n       The ValueError was incomplete until now and only contained the human\n       readable error message. Now it contains all the information that has\n       been promised since 17.1.0.\n    \"\"\"\n    return _InValidator(options)\n\n\n@attrs(repr=False, slots=False, hash=True)\nclass _IsCallableValidator:\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not callable(value):\n            message = (\n                \"'{name}' must be callable \"\n                \"(got {value!r} that is a {actual!r}).\"\n            )\n            raise NotCallableError(\n                msg=message.format(\n                    name=attr.name, value=value, actual=value.__class__\n                ),\n                value=value,\n            )\n\n    def __repr__(self):\n        return \"<is_callable validator>\"\n\n\ndef is_callable():\n    \"\"\"\n    A validator that raises a `attrs.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n\n    .. versionadded:: 19.1.0\n\n    :raises attrs.exceptions.NotCallableError: With a human readable error\n        message containing the attribute (`attrs.Attribute`) name,\n        and the value it got.\n    \"\"\"\n    return _IsCallableValidator()\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _DeepIterable:\n    member_validator = attrib(validator=is_callable())\n    iterable_validator = attrib(\n        default=None, validator=optional(is_callable())\n    )\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.iterable_validator is not None:\n            self.iterable_validator(inst, attr, value)\n\n        for member in value:\n            self.member_validator(inst, attr, member)\n\n    def __repr__(self):\n        iterable_identifier = (\n            \"\"\n            if self.iterable_validator is None\n            else f\" {self.iterable_validator!r}\"\n        )\n        return (\n            f\"<deep_iterable validator for{iterable_identifier}\"\n            f\" iterables of {self.member_validator!r}>\"\n        )\n\n\ndef deep_iterable(member_validator, iterable_validator=None):\n    \"\"\"\n    A validator that performs deep validation of an iterable.\n\n    :param member_validator: Validator(s) to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    if isinstance(member_validator, (list, tuple)):\n        member_validator = and_(*member_validator)\n    return _DeepIterable(member_validator, iterable_validator)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _DeepMapping:\n    key_validator = attrib(validator=is_callable())\n    value_validator = attrib(validator=is_callable())\n    mapping_validator = attrib(default=None, validator=optional(is_callable()))\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.mapping_validator is not None:\n            self.mapping_validator(inst, attr, value)\n\n        for key in value:\n            self.key_validator(inst, attr, key)\n            self.value_validator(inst, attr, value[key])\n\n    def __repr__(self):\n        return f\"<deep_mapping validator for objects mapping {self.key_validator!r} to {self.value_validator!r}>\"\n\n\ndef deep_mapping(key_validator, value_validator, mapping_validator=None):\n    \"\"\"\n    A validator that performs deep validation of a dictionary.\n\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    return _DeepMapping(key_validator, value_validator, mapping_validator)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _NumberValidator:\n    bound = attrib()\n    compare_op = attrib()\n    compare_func = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.compare_func(value, self.bound):\n            msg = f\"'{attr.name}' must be {self.compare_op} {self.bound}: {value}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<Validator for x {self.compare_op} {self.bound}>\"\n\n\ndef lt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number larger or equal to *val*.\n\n    :param val: Exclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<\", operator.lt)\n\n\ndef le(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number greater than *val*.\n\n    :param val: Inclusive upper bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<=\", operator.le)\n\n\ndef ge(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller than *val*.\n\n    :param val: Inclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">=\", operator.ge)\n\n\ndef gt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller or equal to *val*.\n\n    :param val: Exclusive lower bound for values\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">\", operator.gt)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MaxLengthValidator:\n    max_length = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) > self.max_length:\n            msg = f\"Length of '{attr.name}' must be <= {self.max_length}: {len(value)}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<max_len validator for {self.max_length}>\"\n\n\ndef max_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is longer than *length*.\n\n    :param int length: Maximum length of the string or iterable\n\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _MaxLengthValidator(length)\n\n\n@attrs(repr=False, frozen=True, slots=True)\nclass _MinLengthValidator:\n    min_length = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) < self.min_length:\n            msg = f\"Length of '{attr.name}' must be >= {self.min_length}: {len(value)}\"\n            raise ValueError(msg)\n\n    def __repr__(self):\n        return f\"<min_len validator for {self.min_length}>\"\n\n\ndef min_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is shorter than *length*.\n\n    :param int length: Minimum length of the string or iterable\n\n    .. versionadded:: 22.1.0\n    \"\"\"\n    return _MinLengthValidator(length)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _SubclassOfValidator:\n    type = attrib()\n\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not issubclass(value, self.type):\n            msg = f\"'{attr.name}' must be a subclass of {self.type!r} (got {value!r}).\"\n            raise TypeError(\n                msg,\n                attr,\n                self.type,\n                value,\n            )\n\n    def __repr__(self):\n        return f\"<subclass_of validator for type {self.type!r}>\"\n\n\ndef _subclass_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `issubclass` therefore it's also valid to pass a tuple of types).\n\n    :param type: The type to check for.\n    :type type: type or tuple of types\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.\n    \"\"\"\n    return _SubclassOfValidator(type)\n\n\n@attrs(repr=False, slots=True, hash=True)\nclass _NotValidator:\n    validator = attrib()\n    msg = attrib(\n        converter=default_if_none(\n            \"not_ validator child '{validator!r}' \"\n            \"did not raise a captured error\"\n        )\n    )\n    exc_types = attrib(\n        validator=deep_iterable(\n            member_validator=_subclass_of(Exception),\n            iterable_validator=instance_of(tuple),\n        ),\n    )\n\n    def __call__(self, inst, attr, value):\n        try:\n            self.validator(inst, attr, value)\n        except self.exc_types:\n            pass  # suppress error to invert validity\n        else:\n            raise ValueError(\n                self.msg.format(\n                    validator=self.validator,\n                    exc_types=self.exc_types,\n                ),\n                attr,\n                self.validator,\n                value,\n                self.exc_types,\n            )\n\n    def __repr__(self):\n        return f\"<not_ validator wrapping {self.validator!r}, capturing {self.exc_types!r}>\"\n\n\ndef not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):\n    \"\"\"\n    A validator that wraps and logically 'inverts' the validator passed to it.\n    It will raise a `ValueError` if the provided validator *doesn't* raise a\n    `ValueError` or `TypeError` (by default), and will suppress the exception\n    if the provided validator *does*.\n\n    Intended to be used with existing validators to compose logic without\n    needing to create inverted variants, for example, ``not_(in_(...))``.\n\n    :param validator: A validator to be logically inverted.\n    :param msg: Message to raise if validator fails.\n        Formatted with keys ``exc_types`` and ``validator``.\n    :type msg: str\n    :param exc_types: Exception type(s) to capture.\n        Other types raised by child validators will not be intercepted and\n        pass through.\n\n    :raises ValueError: With a human readable error message,\n        the attribute (of type `attrs.Attribute`),\n        the validator that failed to raise an exception,\n        the value it got,\n        and the expected exception types.\n\n    .. versionadded:: 22.2.0\n    \"\"\"\n    try:\n        exc_types = tuple(exc_types)\n    except TypeError:\n        exc_types = (exc_types,)\n    return _NotValidator(validator, msg, exc_types)\n", "src/attr/_compat.py": "# SPDX-License-Identifier: MIT\n\nimport inspect\nimport platform\nimport sys\nimport threading\n\nfrom collections.abc import Mapping, Sequence  # noqa: F401\nfrom typing import _GenericAlias\n\n\nPYPY = platform.python_implementation() == \"PyPy\"\nPY_3_8_PLUS = sys.version_info[:2] >= (3, 8)\nPY_3_9_PLUS = sys.version_info[:2] >= (3, 9)\nPY_3_10_PLUS = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\nPY_3_13_PLUS = sys.version_info[:2] >= (3, 13)\n\n\nif sys.version_info < (3, 8):\n    try:\n        from typing_extensions import Protocol\n    except ImportError:  # pragma: no cover\n        Protocol = object\nelse:\n    from typing import Protocol  # noqa: F401\n\n\nclass _AnnotationExtractor:\n    \"\"\"\n    Extract type annotations from a callable, returning None whenever there\n    is none.\n    \"\"\"\n\n    __slots__ = [\"sig\"]\n\n    def __init__(self, callable):\n        try:\n            self.sig = inspect.signature(callable)\n        except (ValueError, TypeError):  # inspect failed\n            self.sig = None\n\n    def get_first_param_type(self):\n        \"\"\"\n        Return the type annotation of the first argument if it's not empty.\n        \"\"\"\n        if not self.sig:\n            return None\n\n        params = list(self.sig.parameters.values())\n        if params and params[0].annotation is not inspect.Parameter.empty:\n            return params[0].annotation\n\n        return None\n\n    def get_return_type(self):\n        \"\"\"\n        Return the return type if it's not empty.\n        \"\"\"\n        if (\n            self.sig\n            and self.sig.return_annotation is not inspect.Signature.empty\n        ):\n            return self.sig.return_annotation\n\n        return None\n\n\n# Thread-local global to track attrs instances which are already being repr'd.\n# This is needed because there is no other (thread-safe) way to pass info\n# about the instances that are already being repr'd through the call stack\n# in order to ensure we don't perform infinite recursion.\n#\n# For instance, if an instance contains a dict which contains that instance,\n# we need to know that we're already repr'ing the outside instance from within\n# the dict's repr() call.\n#\n# This lives here rather than in _make.py so that the functions in _make.py\n# don't have a direct reference to the thread-local in their globals dict.\n# If they have such a reference, it breaks cloudpickle.\nrepr_context = threading.local()\n\n\ndef get_generic_base(cl):\n    \"\"\"If this is a generic class (A[str]), return the generic base for it.\"\"\"\n    if cl.__class__ is _GenericAlias:\n        return cl.__origin__\n    return None\n", "src/attr/__init__.py": "# SPDX-License-Identifier: MIT\n\n\"\"\"\nClasses Without Boilerplate\n\"\"\"\n\nfrom functools import partial\nfrom typing import Callable\n\nfrom . import converters, exceptions, filters, setters, validators\nfrom ._cmp import cmp_using\nfrom ._compat import Protocol\nfrom ._config import get_run_validators, set_run_validators\nfrom ._funcs import asdict, assoc, astuple, evolve, has, resolve_types\nfrom ._make import (\n    NOTHING,\n    Attribute,\n    Factory,\n    attrib,\n    attrs,\n    fields,\n    fields_dict,\n    make_class,\n    validate,\n)\nfrom ._next_gen import define, field, frozen, mutable\nfrom ._version_info import VersionInfo\n\n\ns = attributes = attrs\nib = attr = attrib\ndataclass = partial(attrs, auto_attribs=True)  # happy Easter ;)\n\n\nclass AttrsInstance(Protocol):\n    pass\n\n\n__all__ = [\n    \"Attribute\",\n    \"AttrsInstance\",\n    \"Factory\",\n    \"NOTHING\",\n    \"asdict\",\n    \"assoc\",\n    \"astuple\",\n    \"attr\",\n    \"attrib\",\n    \"attributes\",\n    \"attrs\",\n    \"cmp_using\",\n    \"converters\",\n    \"define\",\n    \"evolve\",\n    \"exceptions\",\n    \"field\",\n    \"fields\",\n    \"fields_dict\",\n    \"filters\",\n    \"frozen\",\n    \"get_run_validators\",\n    \"has\",\n    \"ib\",\n    \"make_class\",\n    \"mutable\",\n    \"resolve_types\",\n    \"s\",\n    \"set_run_validators\",\n    \"setters\",\n    \"validate\",\n    \"validators\",\n]\n\n\ndef _make_getattr(mod_name: str) -> Callable:\n    \"\"\"\n    Create a metadata proxy for packaging information that uses *mod_name* in\n    its warnings and errors.\n    \"\"\"\n\n    def __getattr__(name: str) -> str:\n        if name not in (\"__version__\", \"__version_info__\"):\n            msg = f\"module {mod_name} has no attribute {name}\"\n            raise AttributeError(msg)\n\n        try:\n            from importlib.metadata import metadata\n        except ImportError:\n            from importlib_metadata import metadata\n\n        meta = metadata(\"attrs\")\n\n        if name == \"__version_info__\":\n            return VersionInfo._from_version_string(meta[\"version\"])\n\n        return meta[\"version\"]\n\n    return __getattr__\n\n\n__getattr__ = _make_getattr(__name__)\n", "src/attr/_cmp.py": "# SPDX-License-Identifier: MIT\n\n\nimport functools\nimport types\n\nfrom ._make import _make_ne\n\n\n_operation_names = {\"eq\": \"==\", \"lt\": \"<\", \"le\": \"<=\", \"gt\": \">\", \"ge\": \">=\"}\n\n\ndef cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"\n    Create a class that can be passed into `attrs.field`'s ``eq``, ``order``,\n    and ``cmp`` arguments to customize field comparison.\n\n    The resulting class will have a full set of ordering methods if at least\n    one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n\n    :param typing.Callable | None eq: Callable used to evaluate equality of two\n        objects.\n    :param typing.Callable | None lt: Callable used to evaluate whether one\n        object is less than another object.\n    :param typing.Callable | None le: Callable used to evaluate whether one\n        object is less than or equal to another object.\n    :param typing.Callable | None gt: Callable used to evaluate whether one\n        object is greater than another object.\n    :param typing.Callable | None ge: Callable used to evaluate whether one\n        object is greater than or equal to another object.\n\n    :param bool require_same_type: When `True`, equality and ordering methods\n        will return `NotImplemented` if objects are not of the same type.\n\n    :param str | None class_name: Name of class. Defaults to \"Comparable\".\n\n    See `comparison` for more details.\n\n    .. versionadded:: 21.1.0\n    \"\"\"\n\n    body = {\n        \"__slots__\": [\"value\"],\n        \"__init__\": _make_init(),\n        \"_requirements\": [],\n        \"_is_comparable_to\": _is_comparable_to,\n    }\n\n    # Add operations.\n    num_order_functions = 0\n    has_eq_function = False\n\n    if eq is not None:\n        has_eq_function = True\n        body[\"__eq__\"] = _make_operator(\"eq\", eq)\n        body[\"__ne__\"] = _make_ne()\n\n    if lt is not None:\n        num_order_functions += 1\n        body[\"__lt__\"] = _make_operator(\"lt\", lt)\n\n    if le is not None:\n        num_order_functions += 1\n        body[\"__le__\"] = _make_operator(\"le\", le)\n\n    if gt is not None:\n        num_order_functions += 1\n        body[\"__gt__\"] = _make_operator(\"gt\", gt)\n\n    if ge is not None:\n        num_order_functions += 1\n        body[\"__ge__\"] = _make_operator(\"ge\", ge)\n\n    type_ = types.new_class(\n        class_name, (object,), {}, lambda ns: ns.update(body)\n    )\n\n    # Add same type requirement.\n    if require_same_type:\n        type_._requirements.append(_check_same_type)\n\n    # Add total ordering if at least one operation was defined.\n    if 0 < num_order_functions < 4:\n        if not has_eq_function:\n            # functools.total_ordering requires __eq__ to be defined,\n            # so raise early error here to keep a nice stack.\n            msg = \"eq must be define is order to complete ordering from lt, le, gt, ge.\"\n            raise ValueError(msg)\n        type_ = functools.total_ordering(type_)\n\n    return type_\n\n\ndef _make_init():\n    \"\"\"\n    Create __init__ method.\n    \"\"\"\n\n    def __init__(self, value):\n        \"\"\"\n        Initialize object with *value*.\n        \"\"\"\n        self.value = value\n\n    return __init__\n\n\ndef _make_operator(name, func):\n    \"\"\"\n    Create operator method.\n    \"\"\"\n\n    def method(self, other):\n        if not self._is_comparable_to(other):\n            return NotImplemented\n\n        result = func(self.value, other.value)\n        if result is NotImplemented:\n            return NotImplemented\n\n        return result\n\n    method.__name__ = f\"__{name}__\"\n    method.__doc__ = (\n        f\"Return a {_operation_names[name]} b.  Computed by attrs.\"\n    )\n\n    return method\n\n\ndef _is_comparable_to(self, other):\n    \"\"\"\n    Check whether `other` is comparable to `self`.\n    \"\"\"\n    return all(func(self, other) for func in self._requirements)\n\n\ndef _check_same_type(self, other):\n    \"\"\"\n    Return True if *self* and *other* are of the same type, False otherwise.\n    \"\"\"\n    return other.value.__class__ is self.value.__class__\n", "src/attrs/filters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.filters import *  # noqa: F403\n", "src/attrs/exceptions.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.exceptions import *  # noqa: F403\n", "src/attrs/converters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.converters import *  # noqa: F403\n", "src/attrs/setters.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.setters import *  # noqa: F403\n", "src/attrs/validators.py": "# SPDX-License-Identifier: MIT\n\nfrom attr.validators import *  # noqa: F403\n", "src/attrs/__init__.py": "# SPDX-License-Identifier: MIT\n\nfrom attr import (\n    NOTHING,\n    Attribute,\n    AttrsInstance,\n    Factory,\n    _make_getattr,\n    assoc,\n    cmp_using,\n    define,\n    evolve,\n    field,\n    fields,\n    fields_dict,\n    frozen,\n    has,\n    make_class,\n    mutable,\n    resolve_types,\n    validate,\n)\nfrom attr._next_gen import asdict, astuple\n\nfrom . import converters, exceptions, filters, setters, validators\n\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__description__\",\n    \"__doc__\",\n    \"__email__\",\n    \"__license__\",\n    \"__title__\",\n    \"__url__\",\n    \"__version__\",\n    \"__version_info__\",\n    \"asdict\",\n    \"assoc\",\n    \"astuple\",\n    \"Attribute\",\n    \"AttrsInstance\",\n    \"cmp_using\",\n    \"converters\",\n    \"define\",\n    \"evolve\",\n    \"exceptions\",\n    \"Factory\",\n    \"field\",\n    \"fields_dict\",\n    \"fields\",\n    \"filters\",\n    \"frozen\",\n    \"has\",\n    \"make_class\",\n    \"mutable\",\n    \"NOTHING\",\n    \"resolve_types\",\n    \"setters\",\n    \"validate\",\n    \"validators\",\n]\n\n__getattr__ = _make_getattr(__name__)\n"}