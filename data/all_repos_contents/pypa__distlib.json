{"docs/conf.py": "# -*- coding: utf-8 -*-\n#\n# Distlib documentation build configuration file, created by\n# sphinx-quickstart on Sat Sep 22 21:05:36 2012.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport datetime, sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath('..'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    'sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage',\n    'sphinx.ext.imgmath', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode', 'sphinxcontrib.spelling'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'Distlib'\ncopyright = u'2012-%s, The Python Software Foundation' % datetime.date.today().year\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The full version, including alpha/beta/rc tags.\nfrom distlib import __version__ as release\n# The short X.Y version.\nversion = release[:3]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\nadd_module_names = False\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\nspelling_lang = 'en_GB'\nspelling_word_list_filename = 'spelling_wordlist.txt'\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = os.environ.get('DOCS_THEME', 'default')\n\nTHEME_OPTIONS = {\n    'pydoc': {\n        'collapsiblesidebar': True\n    },\n    'sizzle': {\n        'globaltoc_depth': 5\n    },\n}\n\nif html_theme == 'sizzle' and os.path.isfile('hover.json'):\n    import json\n\n    with open('hover.json', encoding='utf-8') as f:\n        THEME_OPTIONS['sizzle']['custom_data'] = {'hovers': json.load(f)}\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nif html_theme in THEME_OPTIONS:\n    html_theme_options = THEME_OPTIONS[html_theme]\n\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = ['themes']\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Distlibdoc'\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    ('index', 'Distlib.tex', u'Distlib Documentation', u'Vinay Sajip', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [('index', 'distlib', u'Distlib Documentation', [u'Vinay Sajip'], 1)]\n\n# -- Options for Epub output ---------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = u'Distlib'\nepub_author = u'Vinay Sajip'\nepub_publisher = u'The Python Software Foundation'\nepub_copyright = u'2012, The Python Software Foundation'\n\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = ''\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = ''\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = ''\n\n# A unique identification for the text.\n#epub_uid = ''\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n\n# HTML files that should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n#epub_tocdup = True\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {'python': ('https://docs.python.org/3', None)}\n\n\ndef skip_module_docstring(app, what, name, obj, options, lines):\n    if (what, name) == ('module', 'distlib'):\n        del lines[:]\n\n\ndef setup(app):\n    app.connect('autodoc-process-docstring', skip_module_docstring)\n", "tests/test_manifest.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport logging\nimport logging.handlers\nimport os\nimport re\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib import DistlibException\nfrom distlib.manifest import Manifest\n\nlogger = logging.getLogger(__name__)\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n\nclass ManifestTestCase(DistlibTestCase):\n\n    def setUp(self):\n        self.base = os.path.join(HERE, 'testsrc')\n        self.manifest = Manifest(self.base)\n\n    def get_files(self, files):\n        return set([os.path.relpath(p, self.base) for p in files])\n\n    def test_findall(self):\n        mf = self.manifest\n        mf.findall()\n        actual = self.get_files(mf.allfiles)\n        expected = set([\n            '.hidden',\n            'README.txt',\n            'LICENSE',\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n            os.path.join('subdir', 'subsubdir', 'somedata.bin'),\n            os.path.join('keep', 'keep.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_add(self):\n        mf = self.manifest\n        mf.add('README.txt')\n        actual = self.get_files(mf.files)\n        expected = set(['README.txt'])\n        self.assertEqual(actual, expected)\n\n    def test_add_many(self):\n        mf = self.manifest\n        mf.add_many(['README.txt', 'LICENSE'])\n        actual = self.get_files(mf.files)\n        expected = set(['README.txt', 'LICENSE'])\n        self.assertEqual(actual, expected)\n\n    def test_clear(self):\n        mf = self.manifest\n        mf.findall()\n        mf.add('abc')\n        self.assertTrue(mf.files)\n        mf.clear()\n        self.assertFalse(mf.files)\n        self.assertFalse(mf.allfiles)\n\n    def test_invalid(self):\n        mf = self.manifest\n        self.assertRaises(DistlibException, mf.process_directive, 'random abc')\n        for cmd in ('include', 'exclude', 'global-include', 'global-exclude'):\n            self.assertRaises(DistlibException, mf.process_directive, cmd)\n        for cmd in ('recursive-include', 'recursive-exclude'):\n            s = '%s dir' % cmd\n            self.assertRaises(DistlibException, mf.process_directive, s)\n        for cmd in ('prune', 'graft'):\n            self.assertRaises(DistlibException, mf.process_directive, cmd)\n            s = '%s abc def' % cmd\n            self.assertRaises(DistlibException, mf.process_directive, s)\n\n    def test_default_action(self):\n        mf = self.manifest\n        mf.process_directive('*')\n        actual = self.get_files(mf.files)\n        expected = set(['.hidden', 'README.txt', 'LICENSE'])\n        self.assertEqual(actual, expected)\n\n    def test_include(self):\n        mf = self.manifest\n        mf.process_directive('include README.txt LICENSE')\n        actual = self.get_files(mf.files)\n        expected = set(['README.txt', 'LICENSE'])\n        self.assertEqual(actual, expected)\n\n    def test_exclude(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        mf.process_directive('exclude README.txt')\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_exclude_regex_str(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        mf._exclude_pattern(r'R.*\\.txt', is_regex=True)\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_exclude_regex_re(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        mf._exclude_pattern(re.compile(r'R.*\\.txt'), is_regex=True)\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_global_include(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        actual = self.get_files(mf.files)\n        expected = set([\n            'README.txt',\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_global_exclude(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        mf.process_directive('global-exclude *d*.txt')\n        actual = self.get_files(mf.files)\n        expected = set([\n            'README.txt',\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_recursive_include(self):\n        mf = self.manifest\n        mf.process_directive('recursive-include subdir *.txt')\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_recursive_exclude(self):\n        mf = self.manifest\n        mf.process_directive('global-include *.txt')\n        mf.process_directive('recursive-exclude subdir *d*.txt')\n        actual = self.get_files(mf.files)\n        expected = set([\n            'README.txt',\n            os.path.join('keep', 'keep.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_graft(self):\n        mf = self.manifest\n        mf.process_directive('graft keep')\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('keep', 'keep.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_prune(self):\n        mf = self.manifest\n        mf.process_directive('graft subdir')\n        mf.process_directive('prune subdir/lose')\n        actual = self.get_files(mf.files)\n        expected = set([\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'subsubdir', 'somedata.bin'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_sorting(self):\n        mf = self.manifest\n        mf.process_directive('global-include *')\n        actual = self.get_files(mf.sorted())\n        expected = set([\n            '.hidden',\n            'LICENSE',\n            'README.txt',\n            os.path.join('subdir', 'somedata.txt'),\n            os.path.join('subdir', 'lose', 'lose.txt'),\n            os.path.join('subdir', 'subsubdir', 'somedata.bin'),\n            os.path.join('keep', 'keep.txt'),\n        ])\n        self.assertEqual(actual, expected)\n\n    def test_find_warnings(self):\n        mf = self.manifest\n        lines = (\n            'include nonexistent',\n            'exclude nonexistent',\n            'global-include nonexistent',\n            'global-exclude nonexistent',\n            'recursive-include subdir nonexistent',\n            'recursive-exclude subdir nonexistent',\n            'graft nonexistent',\n            'prune nonexistent',\n        )\n        h = logging.handlers.MemoryHandler(len(lines))\n        dl_logger = logging.getLogger('distlib.manifest')\n        dl_logger.addHandler(h)\n        try:\n            for line in lines:\n                mf.process_directive(line)\n        finally:\n            dl_logger.removeHandler(h)\n        h.close()\n        actual = [r.getMessage() for r in h.buffer]\n        expected = [\n            \"no files found matching 'nonexistent'\",\n            # \"no previously-included files found matching 'nonexistent'\",\n            \"no files found matching 'nonexistent' anywhere in distribution\",\n            # \"no previously-included files matching 'nonexistent' found \"\n            #    \"anywhere in distribution\",\n            \"no files found matching 'nonexistent' under directory 'subdir'\",\n            # \"no previously-included files matching 'nonexistent' found under \"\n            #    \"directory 'subdir'\",\n            \"no directories found matching 'nonexistent'\",\n            \"no previously-included directories found matching 'nonexistent'\",\n        ]\n        self.assertEqual(actual, expected)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/test_locators.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\nimport os\nimport posixpath\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None\nimport sys\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib.compat import url2pathname, urlparse\nfrom distlib.database import (Distribution, DistributionPath, make_graph, make_dist)\nfrom distlib.locators import (SimpleScrapingLocator, PyPIRPCLocator, PyPIJSONLocator, DirectoryLocator, DistPathLocator,\n                              AggregatingLocator, JSONLocator, DependencyFinder, locate, get_all_distribution_names,\n                              default_locator)\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\nPYPI_RPC_HOST = 'http://python.org/pypi'\n\nPYPI_WEB_HOST = os.environ.get('PYPI_WEB_HOST', 'https://pypi.org/simple/')\n\n\nclass LocatorTestCase(DistlibTestCase):\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_xmlrpc(self):\n        locator = PyPIRPCLocator(PYPI_RPC_HOST)\n        try:\n            try:\n                result = locator.get_project('sarge')\n            except Exception:  # pragma: no cover\n                raise unittest.SkipTest('PyPI XML-RPC not available')\n            self.assertIn('0.1', result)\n            dist = result['0.1']\n            self.assertEqual(dist.name, 'sarge')\n            self.assertEqual(dist.version, '0.1')\n            possible = ('https://pypi.org/packages/source/s/sarge/'\n                        'sarge-0.1.tar.gz', 'http://pypi.org/packages/source/s/sarge/'\n                        'sarge-0.1.tar.gz')\n            self.assertIn(dist.source_url, possible)\n            self.assertEqual(dist.digest, ('md5', '961ddd9bc085fdd8b248c6dd96ceb1c8'))\n            try:\n                names = locator.get_distribution_names()\n            except Exception:  # pragma: no cover\n                raise unittest.SkipTest('PyPI XML-RPC not available')\n            self.assertGreater(len(names), 25000)\n        finally:\n            locator.client('close')()\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_json(self):\n        locator = PyPIJSONLocator(PYPI_RPC_HOST)\n        result = locator.get_project('sarge')\n        LATEST_SARGE_VERSION = '0.1.4'\n        LATEST_SARGE_HASHES = (\n            ('md5', '285013875aa908ef1417055d3e74a00a'),\n            ('sha256', '59f93216723ddd9062d17cbbb90ed9e69267b84825cf0bde0b7f8d934c424823'),\n        )\n        self.assertIn(LATEST_SARGE_VERSION, result)\n        dist = result[LATEST_SARGE_VERSION]\n        self.assertEqual(dist.name, 'sarge')\n        self.assertEqual(dist.version, LATEST_SARGE_VERSION)\n        path = '/sarge-%s.tar.gz' % LATEST_SARGE_VERSION\n        for url in dist.download_urls:\n            self.assertTrue(url.endswith(path))\n        self.assertIn(dist.digests[url], LATEST_SARGE_HASHES)\n        self.assertRaises(NotImplementedError, locator.get_distribution_names)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_scraper(self):\n        locator = SimpleScrapingLocator('https://pypi.org/simple/')\n        for name in ('sarge', 'Sarge'):\n            result = locator.get_project(name)\n            self.assertIn('0.1', result)\n            dist = result['0.1']\n            self.assertEqual(dist.name, 'sarge')\n            self.assertEqual(dist.version, '0.1')\n            self.assertTrue(dist.source_url.endswith('/sarge-0.1.tar.gz'))\n            SARGE_HASHES = (\n                ('md5', '961ddd9bc085fdd8b248c6dd96ceb1c8'),\n                ('sha256', 'ec2ec0b1c9ed9a77f9b4322c16e4954c93aa00d974a1af931b18eb751e377dfe'),\n            )\n            self.assertIn(dist.digest, SARGE_HASHES)\n        # Test to check issue #112 fix.\n        locator.wheel_tags = [('cp27', 'cp27m', 'win_amd64'), ('cp35', 'cp35m', 'win32')]\n        result = locator.get_project('simplejson')\n        urls = result['urls'].get('3.16.0')\n        self.assertTrue(urls)\n        self.assertEqual(3, len(urls))\n        expected = set([\n            'simplejson-3.16.0-cp27-cp27m-win_amd64.whl', 'simplejson-3.16.0-cp35-cp35m-win32.whl',\n            'simplejson-3.16.0.tar.gz'\n        ])\n        for u in urls:\n            p = posixpath.split(urlparse(u).path)[-1]\n            self.assertIn(p, expected)\n        return\n        # The following is too slow\n        names = locator.get_distribution_names()\n        self.assertGreater(len(names), 25000)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_unicode_project_name(self):\n        # Just checking to see that no exceptions are raised.\n        NAME = '\\u2603'\n        locator = SimpleScrapingLocator('https://pypi.org/simple/')\n        result = locator.get_project(NAME)\n        expected = {'urls': {}, 'digests': {}}\n        self.assertEqual(result, expected)\n        locator = PyPIJSONLocator('https://pypi.org/pypi/')\n        result = locator.get_project(NAME)\n        self.assertEqual(result, expected)\n\n    def test_dir(self):\n        d = os.path.join(HERE, 'fake_archives')\n        locator = DirectoryLocator(d)\n        expected = os.path.join(HERE, 'fake_archives', 'subdir', 'subsubdir', 'Flask-0.9.tar.gz')\n\n        def get_path(url):\n            t = urlparse(url)\n            return url2pathname(t.path)\n\n        for name in ('flask', 'Flask'):\n            result = locator.get_project(name)\n            self.assertIn('0.9', result)\n            dist = result['0.9']\n            self.assertEqual(dist.name, 'Flask')\n            self.assertEqual(dist.version, '0.9')\n            self.assertEqual(os.path.normcase(get_path(dist.source_url)), os.path.normcase(expected))\n        names = locator.get_distribution_names()\n        expected = set(['Flask', 'python-gnupg', 'coverage', 'Django'])\n        if sys.version_info[:2] == (2, 7):\n            expected.add('config')\n        self.assertEqual(names, expected)\n\n    def test_dir_nonrecursive(self):\n        d = os.path.join(HERE, 'fake_archives')\n        locator = DirectoryLocator(d, recursive=False)\n        expected = os.path.join(HERE, 'fake_archives', 'subdir', 'subsubdir', 'Flask-0.9.tar.gz')\n\n        def get_path(url):\n            t = urlparse(url)\n            return url2pathname(t.path)\n\n        for name in ('flask', 'Flask'):\n            result = locator.get_project(name)\n            self.assertEqual(result, {'urls': {}, 'digests': {}})\n        names = locator.get_distribution_names()\n        expected = set(['coverage'])\n        self.assertEqual(names, expected)\n\n    def test_path(self):\n        fakes = os.path.join(HERE, 'fake_dists')\n        sys.path.insert(0, fakes)\n        try:\n            edp = DistributionPath(include_egg=True)\n            locator = DistPathLocator(edp)\n            cases = ('babar', 'choxie', 'strawberry', 'towel-stuff', 'coconuts-aster', 'bacon', 'grammar', 'truffles',\n                     'banana', 'cheese')\n            for name in cases:\n                d = locator.locate(name, True)\n                self.assertIsNotNone(d)\n                r = locator.get_project(name)\n                expected = {d.version: d, 'urls': {d.version: set([d.source_url])}, 'digests': {d.version: set([None])}}\n                self.assertEqual(r, expected)\n            d = locator.locate('nonexistent')\n            self.assertIsNone(d)\n            r = locator.get_project('nonexistent')\n            self.assertTrue(len(r) == 2)\n\n        finally:\n            sys.path.pop(0)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_aggregation(self):\n        d = os.path.join(HERE, 'fake_archives')\n        loc1 = DirectoryLocator(d)\n        loc2 = SimpleScrapingLocator('https://pypi.org/simple/', timeout=5.0)\n        locator = AggregatingLocator(loc1, loc2)\n        exp1 = os.path.join(HERE, 'fake_archives', 'subdir', 'subsubdir', 'Flask-0.9.tar.gz')\n        exp2 = '/Flask-0.9.tar.gz'\n        result = locator.get_project('flask')\n        self.assertEqual(len(result), 3)\n        self.assertIn('0.9', result)\n        dist = result['0.9']\n        self.assertEqual(dist.name, 'Flask')\n        self.assertEqual(dist.version, '0.9')\n        scheme, _, path, _, _, _ = urlparse(dist.source_url)\n        self.assertEqual(scheme, 'file')\n        self.assertEqual(os.path.normcase(url2pathname(path)), os.path.normcase(exp1))\n        locator.merge = True\n        locator._cache.clear()\n        result = locator.get_project('flask')\n        self.assertGreater(len(result), 3)\n        self.assertIn('0.9', result)\n        dist = result['0.9']\n        self.assertEqual(dist.name, 'Flask')\n        self.assertEqual(dist.version, '0.9')\n        self.assertTrue(dist.source_url.endswith(exp2))\n        return\n        # The following code is slow because it has\n        # to get all the dist names by scraping :-(\n        n1 = loc1.get_distribution_names()\n        n2 = loc2.get_distribution_names()\n        self.assertEqual(locator.get_distribution_names(), n1 | n2)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    @unittest.skipIf(True, 'Optimised metadata is not up-to-date')\n    def test_dependency_finder(self):\n        locator = AggregatingLocator(JSONLocator(),\n                                     SimpleScrapingLocator('https://pypi.org/simple/', timeout=3.0),\n                                     scheme='legacy')\n        finder = DependencyFinder(locator)\n        dists, problems = finder.find('irc (== 5.0.1)')\n        self.assertFalse(problems)\n        actual = sorted([d.name for d in dists])\n        self.assertEqual(actual, ['hgtools', 'irc', 'pytest-runner', 'setuptools_scm'])\n        dists, problems = finder.find('irc (== 5.0.1)', meta_extras=[':test:'])\n        self.assertFalse(problems)\n        actual = sorted([d.name for d in dists])\n        # expected = [\n        # 'atomicwrites',\n        # 'attrs',\n        # 'colorama',\n        # 'hgtools',\n        # 'importlib-metadata',\n        # 'irc',\n        # 'more-itertools',\n        # 'packaging',\n        # 'pathlib2',\n        # 'pluggy',\n        # 'py',\n        # 'pyparsing',\n        # 'pytest',\n        # 'pytest-runner',\n        # 'setuptools',\n        # 'setuptools-scm',\n        # 'setuptools_scm',\n        # 'six',\n        # 'wcwidth'\n        # ]\n        expected = ['hgtools', 'irc', 'pytest', 'pytest-runner', 'setuptools_scm']\n        self.assertEqual(actual, expected)\n        g = make_graph(dists)\n        slist, cycle = g.topological_sort()\n        self.assertFalse(cycle)\n        names = [d.name for d in slist]\n        expected = set([\n            ('atomicwrites', 'six', 'importlib-metadata', 'more-itertools', 'attrs', 'pyparsing', 'setuptools',\n             'setuptools_scm', 'setuptools-scm', 'wcwidth', 'colorama', 'py', 'pathlib2', 'pluggy', 'hgtools',\n             'pytest-runner', 'packaging', 'irc', 'pytest'),\n            ('atomicwrites', 'setuptools', 'importlib-metadata', 'more-itertools', 'attrs', 'wcwidth', 'pyparsing',\n             'colorama', 'six', 'setuptools_scm', 'setuptools-scm', 'pluggy', 'packaging', 'py', 'hgtools',\n             'pytest-runner', 'pathlib2', 'irc', 'pytest'),\n            ('wcwidth', 'setuptools_scm', 'colorama', 'six', 'importlib-metadata', 'setuptools', 'setuptools-scm',\n             'pyparsing', 'more-itertools', 'attrs', 'atomicwrites', 'pathlib2', 'packaging', 'pytest-runner',\n             'hgtools', 'py', 'pluggy', 'irc', 'pytest'),\n            ('setuptools', 'setuptools-scm', 'wcwidth', 'importlib-metadata', 'colorama', 'six', 'atomicwrites',\n             'more-itertools', 'attrs', 'pyparsing', 'setuptools_scm', 'pluggy', 'pathlib2', 'packaging', 'py',\n             'pytest-runner', 'hgtools', 'irc', 'pytest'),\n            ('atomicwrites', 'setuptools', 'importlib-metadata', 'attrs', 'wcwidth', 'more-itertools', 'pyparsing',\n             'colorama', 'six', 'setuptools_scm', 'setuptools-scm', 'pluggy', 'packaging', 'hgtools', 'pytest-runner',\n             'pathlib2', 'py', 'irc', 'pytest'),\n            ('wcwidth', 'setuptools_scm', 'more-itertools', 'colorama', 'six', 'importlib-metadata', 'setuptools',\n             'setuptools-scm', 'atomicwrites', 'pyparsing', 'attrs', 'pathlib2', 'packaging', 'pytest-runner', 'py',\n             'pluggy', 'hgtools', 'irc', 'pytest'),\n            ('six', 'atomicwrites', 'setuptools', 'setuptools-scm', 'attrs', 'importlib-metadata', 'more-itertools',\n             'wcwidth', 'colorama', 'pyparsing', 'setuptools_scm', 'pluggy', 'packaging', 'hgtools', 'py',\n             'pytest-runner', 'pathlib2', 'irc', 'pytest'),\n            ('wcwidth', 'setuptools_scm', 'more-itertools', 'six', 'setuptools', 'importlib-metadata', 'pyparsing',\n             'setuptools-scm', 'atomicwrites', 'colorama', 'attrs', 'pathlib2', 'packaging', 'pytest-runner', 'hgtools',\n             'py', 'pluggy', 'pytest', 'irc'),\n            ('atomicwrites', 'importlib-metadata', 'attrs', 'pyparsing', 'wcwidth', 'colorama', 'setuptools',\n             'more-itertools', 'six', 'setuptools_scm', 'setuptools-scm', 'pluggy', 'packaging', 'hgtools',\n             'pytest-runner', 'pathlib2', 'py', 'irc', 'pytest'),\n            ('atomicwrites', 'pyparsing', 'six', 'setuptools', 'importlib-metadata', 'more-itertools', 'attrs',\n             'setuptools_scm', 'setuptools-scm', 'wcwidth', 'colorama', 'py', 'pathlib2', 'pluggy', 'hgtools',\n             'pytest-runner', 'packaging', 'irc', 'pytest'),\n            ('atomicwrites', 'setuptools', 'importlib-metadata', 'more-itertools', 'attrs', 'pyparsing', 'wcwidth',\n             'colorama', 'six', 'setuptools_scm', 'setuptools-scm', 'pluggy', 'packaging', 'py', 'hgtools',\n             'pytest-runner', 'pathlib2', 'irc', 'pytest'),\n            ('wcwidth', 'setuptools_scm', 'more-itertools', 'six', 'setuptools', 'importlib-metadata', 'pyparsing',\n             'setuptools-scm', 'atomicwrites', 'attrs', 'colorama', 'pathlib2', 'packaging', 'pytest-runner', 'hgtools',\n             'py', 'pluggy', 'pytest', 'irc'),\n            ('six', 'atomicwrites', 'setuptools', 'setuptools-scm', 'attrs', 'importlib-metadata', 'more-itertools',\n             'wcwidth', 'pyparsing', 'colorama', 'setuptools_scm', 'pluggy', 'packaging', 'hgtools', 'py',\n             'pytest-runner', 'pathlib2', 'irc', 'pytest'),\n            ('pytest', 'setuptools_scm', 'hgtools', 'pytest-runner', 'irc'),\n            ('pytest', 'setuptools_scm', 'pytest-runner', 'hgtools', 'irc'),\n            ('setuptools_scm', 'pytest', 'hgtools', 'pytest-runner', 'irc'),\n        ])\n        self.assertIn(tuple(names), expected)\n\n        # Test with extras\n        dists, problems = finder.find('Jinja2 (== 2.6)')\n        self.assertFalse(problems)\n        actual = sorted([d.name_and_version for d in dists])\n        self.assertEqual(actual, ['Jinja2 (2.6)'])\n        dists, problems = finder.find('Jinja2 [i18n] (== 2.6)')\n        self.assertFalse(problems)\n        actual = sorted([d.name_and_version for d in dists])\n        self.assertEqual(actual[-2], 'Jinja2 (2.6)')\n        self.assertTrue(actual[-1].startswith('pytz ('))\n        self.assertTrue(actual[0].startswith('Babel ('))\n        actual = [d.build_time_dependency for d in dists]\n        self.assertEqual(actual, [False, False, False])\n\n        # Now test with extra in dependency\n        locator.clear_cache()\n        dummy = make_dist('dummy', '0.1')\n        dummy.metadata.run_requires = [{'requires': ['Jinja2 [i18n] (<2.8)']}]\n        dists, problems = finder.find(dummy)\n        self.assertFalse(problems)\n        actual = sorted([d.name_and_version for d in dists])\n        self.assertTrue(actual[0].startswith('Babel ('))\n        locator.clear_cache()\n        dummy.metadata.run_requires = [{'requires': ['Jinja2']}]\n        dists, problems = finder.find(dummy)\n        self.assertFalse(problems)\n        actual = sorted([d.name_and_version for d in dists])\n        self.assertTrue(actual[0].startswith('Jinja2 ('))\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_get_all_dist_names(self):\n        for url in (None, PYPI_RPC_HOST):\n            try:\n                all_dists = get_all_distribution_names(url)\n            except Exception:  # pragma: no cover\n                raise unittest.SkipTest('PyPI XML-RPC not available')\n            self.assertGreater(len(all_dists), 0)\n\n    def test_url_preference(self):\n        cases = (('https://netloc/path', 'http://netloc/path'), ('http://pypi.org/path', 'http://netloc/path'),\n                 ('http://netloc/B', 'http://netloc/A'))\n        for url1, url2 in cases:\n            self.assertEqual(default_locator.prefer_url(url1, url2), url1)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_prereleases(self):\n        locator = AggregatingLocator(JSONLocator(),\n                                     SimpleScrapingLocator('https://pypi.org/simple/', timeout=3.0),\n                                     scheme='legacy')\n        REQT = 'SQLAlchemy (>0.5.8, < 0.6)'\n        finder = DependencyFinder(locator)\n        d = locator.locate(REQT)\n        self.assertIsNone(d)\n        d = locator.locate(REQT, True)\n        self.assertIsNotNone(d)\n        self.assertEqual(d.name_and_version, 'SQLAlchemy (0.6beta3)')\n        dist = make_dist('dummy', '0.1')\n        dist.metadata.run_requires = [{'requires': [REQT]}]\n        dists, problems = finder.find(dist, prereleases=True)\n        self.assertFalse(problems)\n        actual = sorted(dists, key=lambda o: o.name_and_version)\n        self.assertEqual(actual[0].name_and_version, 'SQLAlchemy (0.6beta3)')\n        dists, problems = finder.find(dist)\n        # Test changed since now prereleases as found as a last resort.\n        # self.assertEqual(dists, set([dist]))\n        # self.assertEqual(len(problems), 1)\n        # problem = problems.pop()\n        # self.assertEqual(problem, ('unsatisfied', REQT))\n        self.assertEqual(dists, set([actual[0], dist]))\n        self.assertFalse(problems)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_dist_reqts(self):\n        r = 'config <=0.3.9'\n        dist = default_locator.locate(r)\n        self.assertIsNotNone(dist)\n        self.assertIsNone(dist.extras)\n        self.assertTrue(dist.matches_requirement(r))\n        self.assertFalse(dist.matches_requirement('config == 0.4.0'))\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_dist_reqts_extras(self):\n        r = 'config[doc,test](<=0.3.9)'\n        dist = default_locator.locate(r)\n        self.assertIsNotNone(dist)\n        self.assertTrue(dist.matches_requirement(r))\n        self.assertEqual(dist.extras, ['doc', 'test'])\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_all_versions(self):\n        d = default_locator.get_project('setuptools')\n        self.assertTrue('urls' in d)\n        d = d['urls']\n        expected = set([\n            'setuptools-0.6b1.zip',\n            'setuptools-0.6b2.zip',\n            'setuptools-0.6b3.zip',\n            'setuptools-0.6b4.zip',\n            'setuptools-0.6c10.tar.gz',\n            'setuptools-0.6c11.tar.gz',\n            # 'setuptools-0.6c12dev-r88997.tar.gz',\n            # 'setuptools-0.6c12dev-r88998.tar.gz',\n            # 'setuptools-0.6c12dev-r89000.tar.gz',\n            'setuptools-0.6c1.zip',\n            'setuptools-0.6c2.zip',\n            'setuptools-0.6c3.tar.gz',\n            'setuptools-0.6c4.tar.gz',\n            'setuptools-0.6c5.tar.gz',\n            'setuptools-0.6c6.tar.gz',\n            'setuptools-0.6c7.tar.gz',\n            'setuptools-0.6c8.tar.gz',\n            'setuptools-0.6c9.tar.gz',\n            'setuptools-0.7.2.tar.gz',\n            'setuptools-0.7.3.tar.gz',\n            'setuptools-0.7.4.tar.gz',\n            'setuptools-0.7.5.tar.gz',\n            'setuptools-0.7.6.tar.gz',\n            'setuptools-0.7.7.tar.gz',\n            'setuptools-0.7.8.tar.gz',\n            'setuptools-0.8.tar.gz',\n            'setuptools-0.9.1.tar.gz',\n            'setuptools-0.9.2.tar.gz',\n            'setuptools-0.9.3.tar.gz',\n            'setuptools-0.9.4.tar.gz',\n            'setuptools-0.9.5.tar.gz',\n            'setuptools-0.9.6.tar.gz',\n            'setuptools-0.9.7.tar.gz',\n            'setuptools-0.9.8.tar.gz',\n            'setuptools-0.9.tar.gz',\n            'setuptools-1.0.tar.gz',\n            'setuptools-1.1.1.tar.gz',\n            'setuptools-1.1.2.tar.gz',\n            'setuptools-1.1.3.tar.gz',\n            'setuptools-1.1.4.tar.gz',\n            'setuptools-1.1.5.tar.gz',\n            'setuptools-1.1.6.tar.gz',\n            'setuptools-1.1.7.tar.gz',\n            'setuptools-1.1.tar.gz',\n            'setuptools-1.2.tar.gz',\n            'setuptools-1.3.1.tar.gz',\n            'setuptools-1.3.2.tar.gz',\n            'setuptools-1.3.tar.gz',\n            'setuptools-1.4.1.tar.gz',\n            'setuptools-1.4.2.tar.gz',\n            'setuptools-1.4.tar.gz',\n            'setuptools-2.0.1.tar.gz',\n            'setuptools-2.0.2.tar.gz',\n            'setuptools-2.0.tar.gz',\n            'setuptools-2.1.1.tar.gz',\n            'setuptools-2.1.2.tar.gz',\n            'setuptools-2.1.tar.gz',\n            'setuptools-2.2.tar.gz',\n            'setuptools-3.0.1.tar.gz',\n            'setuptools-3.0.1.zip',\n            'setuptools-3.0.2.tar.gz',\n            'setuptools-3.0.2.zip',\n            'setuptools-3.0.tar.gz',\n            'setuptools-3.0.zip',\n            'setuptools-3.1.tar.gz',\n            'setuptools-3.1.zip',\n            'setuptools-3.2.tar.gz',\n            'setuptools-3.2.zip',\n            'setuptools-3.3.tar.gz',\n            'setuptools-3.3.zip',\n            'setuptools-3.4.1.tar.gz',\n            'setuptools-3.4.1.zip',\n            'setuptools-3.4.2.tar.gz',\n            'setuptools-3.4.2.zip',\n            'setuptools-3.4.3.tar.gz',\n            'setuptools-3.4.3.zip',\n            'setuptools-3.4.4.tar.gz',\n            'setuptools-3.4.4.zip',\n            'setuptools-3.4.tar.gz',\n            'setuptools-3.4.zip',\n            'setuptools-3.5.1.tar.gz',\n            'setuptools-3.5.1.zip',\n            'setuptools-3.5.2.tar.gz',\n            'setuptools-3.5.2.zip',\n            'setuptools-3.5.tar.gz',\n            'setuptools-3.5.zip',\n            'setuptools-3.6.tar.gz',\n            'setuptools-3.6.zip',\n            'setuptools-3.7.1.tar.gz',\n            'setuptools-3.7.1.zip',\n            'setuptools-3.7.tar.gz',\n            'setuptools-3.7.zip',\n            'setuptools-3.8.1.tar.gz',\n            'setuptools-3.8.1.zip',\n            'setuptools-3.8.tar.gz',\n            'setuptools-3.8.zip',\n            'setuptools-4.0.1.tar.gz',\n            'setuptools-4.0.1.zip',\n            'setuptools-4.0.tar.gz',\n            'setuptools-4.0.zip',\n            'setuptools-5.0.1.tar.gz',\n            'setuptools-5.0.1.zip',\n            'setuptools-5.0.2.tar.gz',\n            'setuptools-5.0.2.zip',\n            'setuptools-5.0.tar.gz',\n            'setuptools-5.0.zip',\n            'setuptools-5.1.tar.gz',\n            'setuptools-5.1.zip',\n            'setuptools-5.2.tar.gz',\n            'setuptools-5.2.zip',\n            'setuptools-5.3.tar.gz',\n            'setuptools-5.3.zip',\n            'setuptools-5.4.1.tar.gz',\n            'setuptools-5.4.1.zip',\n            'setuptools-5.4.2.tar.gz',\n            'setuptools-5.4.2.zip',\n            'setuptools-5.4.tar.gz',\n            'setuptools-5.4.zip',\n            'setuptools-5.5.1.tar.gz',\n            'setuptools-5.5.1.zip',\n            'setuptools-5.5.tar.gz',\n            'setuptools-5.5.zip',\n            'setuptools-5.6.tar.gz',\n            'setuptools-5.6.zip',\n            'setuptools-5.7.tar.gz',\n            'setuptools-5.7.zip',\n            'setuptools-5.8.tar.gz',\n            'setuptools-5.8.zip',\n            'setuptools-6.0.1.tar.gz',\n            'setuptools-6.0.1.zip',\n            'setuptools-6.0.2.tar.gz',\n            'setuptools-6.0.2.zip',\n        ])\n        actual = set()\n        for k, v in d.items():\n            for url in v:\n                _, _, path, _, _, _ = urlparse(url)\n                filename = path.rsplit('/', 1)[-1]\n                actual.add(filename)\n        self.assertEqual(actual & expected, expected)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_nonexistent(self):\n        # See Issue #58\n        d = locate('foobarbazbishboshboo')\n        self.assertTrue(d is None or isinstance(d, Distribution))\n\n\nif __name__ == '__main__':  # pragma: no cover\n    import logging\n    logging.basicConfig(level=logging.DEBUG, filename='run/test_locators.log', filemode='w', format='%(message)s')\n    unittest.main()\n", "tests/test_resources.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nfrom operator import attrgetter\nimport os\nimport sys\n\nfrom compat import unittest\nfrom support import DistlibTestCase, in_github_workflow\n\nfrom distlib import DistlibException\nfrom distlib.resources import finder, finder_for_path, ResourceCache\nfrom distlib.util import get_cache_base\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nIN_GITHUB_WORKFLOW = in_github_workflow()\n\n\nclass ZipResourceTestCase(DistlibTestCase):\n\n    def setUp(self):\n        sys.path.insert(0, os.path.join(HERE, 'foo.zip'))\n\n    def tearDown(self):\n        sys.path.pop(0)\n\n    def test_existing_resource(self):\n        f = finder('foo')\n        r = f.find('foo_resource.bin')\n        self.assertTrue(r)\n        self.assertEqual(r.bytes, b'more_data\\n')\n        self.assertEqual(r.size, 10)\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'more_data\\n')\n        stream.close()\n        # can access subpackage bar's resources using subdir path ...\n        r = f.find('bar/bar_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n        self.assertEqual(r.bytes, b'data\\n')\n        self.assertEqual(r.size, 5)\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'data\\n')\n        stream.close()\n\n        r = f.find('bar')\n        self.assertTrue(r)\n        self.assertTrue(r.is_container)\n        self.assertRaises(AttributeError, attrgetter('bytes'), r)\n        self.assertRaises(AttributeError, attrgetter('size'), r)\n        self.assertRaises(AttributeError, attrgetter('file_path'), r)\n        f = finder('foo.bar')\n        r = f.find('bar_resource.bin')\n        self.assertTrue(r)\n        self.assertEqual(r.bytes, b'data\\n')\n        self.assertEqual(r.size, 5)\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'data\\n')\n        stream.close()\n\n    def test_nonexistent_resource(self):\n        f = finder('foo')\n        r = f.find('no_such_resource.bin')\n        self.assertIsNone(r)\n\n    def test_non_package(self):\n        self.assertRaises(DistlibException, finder, 'foo.bar.baz')\n\n    def test_contents(self):\n        f = finder('foo')\n        r = f.find('foo_resource.bin')\n        self.assertTrue(r)\n        self.assertRaises(AttributeError, attrgetter('resources'), r)\n        r = f.find('bar')\n        self.assertTrue(r)\n        expected = set(('bar_resource.bin', 'baz.py', '__init__.py'))\n        self.assertEqual(r.resources, expected)\n\n    def test_root_resources(self):\n        f = finder('foo')\n        r = f.find('')\n        self.assertTrue(r)\n        self.assertTrue(r.is_container)\n        expected = set(('foo_resource.bin', 'bar', '__init__.py'))\n        self.assertEqual(r.resources, expected)\n\n    def test_dir_in_zip(self):\n        sys.path[0] = '%s/lib' % os.path.join(HERE, 'bar.zip')\n        f = finder('barbar')\n        self.assertIsNone(f.find('readme.txt'))\n        r = f.find('bar_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n        f = finder('barbar.baz')\n        r = f.find('baz_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n\n    def test_finder_for_path(self):\n        f = finder_for_path(sys.path[0])\n        r = f.find('')\n        self.assertIsNotNone(r)\n        self.assertTrue(r.is_container)\n        p = os.path.join(sys.path[0], 'foo')\n        f = finder_for_path(p)\n        r = f.find('')\n        self.assertIsNotNone(r)\n        self.assertTrue(r.is_container)\n\n    def test_iterator(self):\n        f = finder('foo')\n        iterator = f.iterator('')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        expected = set([('', True), ('foo_resource.bin', False), ('bar/bar_resource.bin', False), ('bar/baz.py', False),\n                        ('__init__.py', False), ('bar', True), ('bar/__init__.py', False)])\n        self.assertEqual(actual, expected)\n        iterator = f.iterator('bar')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        expected = set([('bar/baz.py', False), ('bar', True), ('bar/bar_resource.bin', False),\n                        ('bar/__init__.py', False)])\n        self.assertEqual(actual, expected)\n        iterator = f.iterator('bar/bar_resource.bin')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        self.assertEqual(actual, set([('bar/bar_resource.bin', False)]))\n\n\nclass FileResourceTestCase(DistlibTestCase):\n\n    def setUp(self):\n        sys.path.insert(0, HERE)\n\n    def tearDown(self):\n        sys.path.pop(0)\n\n    @unittest.skipIf(IN_GITHUB_WORKFLOW, 'This test is end-of-line dependent')\n    def test_existing_resource(self):\n        f = finder('foofoo')\n        r = f.find('foo_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n        self.assertEqual(r.bytes, b'more_data\\n')\n        self.assertEqual(r.size, 10)\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'more_data\\n')\n        stream.close()\n        r = f.find('bar')\n        self.assertTrue(r)\n        self.assertTrue(r.is_container)\n        self.assertRaises(AttributeError, attrgetter('bytes'), r)\n        self.assertRaises(AttributeError, attrgetter('size'), r)\n        f = finder('foofoo.bar')\n        r = f.find('bar_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n        self.assertEqual(r.bytes, b'data\\n')\n        self.assertEqual(r.size, 5)\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'data\\n')\n        stream.close()\n\n    def test_nonexistent_resource(self):\n        f = finder('foofoo')\n        r = f.find('no_such_resource.bin')\n        self.assertIsNone(r)\n\n    def test_contents(self):\n        f = finder('foofoo')\n        r = f.find('foo_resource.bin')\n        self.assertTrue(r)\n        self.assertRaises(AttributeError, attrgetter('resources'), r)\n        r = f.find('bar')\n        self.assertTrue(r)\n        expected = set(('bar_resource.bin', 'baz.py', '__init__.py'))\n        self.assertEqual(r.resources, expected)\n\n    def test_root_resources(self):\n        f = finder('foofoo')\n        r = f.find('')\n        self.assertTrue(r)\n        self.assertTrue(r.is_container)\n        expected = set(('foo_resource.bin', 'bar', '__init__.py', 'nested'))\n        self.assertEqual(r.resources, expected)\n\n    @unittest.skipIf(IN_GITHUB_WORKFLOW, 'This test is end-of-line dependent')\n    def test_nested(self):\n        f = finder('foofoo')\n        r = f.find('nested/nested_resource.bin')\n        self.assertTrue(r)\n        self.assertFalse(r.is_container)\n        self.assertEqual(r.bytes, b'nested data\\n')\n        stream = r.as_stream()\n        self.assertEqual(stream.read(), b'nested data\\n')\n        stream.close()\n        r = f.find('nested')\n        self.assertTrue(r)\n        self.assertTrue(r.is_container)\n        self.assertTrue(r)\n        self.assertEqual(r.resources, set(['nested_resource.bin']))\n\n    @unittest.skipIf(sys.version_info[0] != 2, 'This test on Python 2 only')\n    def test_bytes_path(self):\n        f = finder('foofoo')\n        for path in 'foo/b\\xe7r', b'foo/b\\xe7r':\n            self.assertEqual(type(f._make_path(path)), type(path))\n\n    def test_iterator(self):\n        f = finder('foofoo')\n        iterator = f.iterator('')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        expected = set([\n            ('', True),\n            ('nested/nested_resource.bin', False),\n            ('bar', True),\n            ('__init__.py', False),\n            ('nested', True),\n            ('bar/bar_resource.bin', False),\n            ('bar/__init__.py', False),\n            ('bar/baz.py', False),\n            ('foo_resource.bin', False),\n        ])\n        self.assertEqual(actual, expected)\n        iterator = f.iterator('bar')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        expected = set([('bar/baz.py', False), ('bar', True), ('bar/bar_resource.bin', False),\n                        ('bar/__init__.py', False)])\n        self.assertEqual(actual, expected)\n        iterator = f.iterator('bar/bar_resource.bin')\n        actual = set([(r.name, r.is_container) for r in iterator])\n        self.assertEqual(actual, set([('bar/bar_resource.bin', False)]))\n\n\nclass CacheTestCase(DistlibTestCase):\n\n    def test_base(self):\n        cache = ResourceCache()\n        expected = os.path.join(get_cache_base(), str('resource-cache'))\n        self.assertEqual(expected, cache.base)\n        self.assertTrue(os.path.isdir(expected))\n\n    def test_filepath(self):\n        path = os.path.join(HERE, 'foo.zip')\n        sys.path.insert(0, path)\n        self.addCleanup(sys.path.remove, path)\n        sys.path.insert(0, HERE)\n        self.addCleanup(sys.path.remove, HERE)\n        path = '%s/lib' % os.path.join(HERE, 'bar.zip')\n        sys.path.insert(0, path)\n        self.addCleanup(sys.path.remove, path)\n\n        cases = (('foo', 'foo_resource.bin'), ('foo', 'bar/bar_resource.bin'), ('foofoo', 'bar/bar_resource.bin'),\n                 ('barbar', 'bar_resource.bin'), ('barbar.baz', 'baz_resource.bin'))\n\n        for pkg, path in cases:\n            f = finder(pkg)\n            r = f.find(path)\n            fp = r.file_path\n            with open(fp, 'rb') as df:\n                data = df.read()\n            self.assertEqual(data, r.bytes)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/test_scripts.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\ntry:\n    import venv\nexcept ImportError:\n    venv = None\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib.compat import fsencode, sysconfig\nfrom distlib.scripts import ScriptMaker, enquote_executable\nfrom distlib.util import get_executable\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\nCOPIED_SCRIPT = '''#!python\n# This is a copied script\n'''\n\nMADE_SCRIPT = 'made = dummy.module:main'\n\n\nclass ScriptTestCase(DistlibTestCase):\n\n    def setUp(self):\n        source_dir = os.path.join(HERE, 'scripts')\n        target_dir = tempfile.mkdtemp(prefix='distlib-test-')\n        self.maker = ScriptMaker(source_dir, target_dir, add_launchers=False)\n\n    def tearDown(self):\n        shutil.rmtree(self.maker.target_dir)\n\n    @unittest.skipIf(sysconfig.is_python_build(), 'Test not appropriate for '\n                     'Python source builds')\n    def test_shebangs(self):\n        executable = fsencode(get_executable())\n        for fn in ('foo.py', 'script1.py', 'script2.py', 'script3.py', 'shell.sh'):\n            files = self.maker.make(fn)\n            self.assertEqual(len(files), 1)\n            d, f = os.path.split(files[0])\n            self.assertEqual(f, fn)\n            self.assertEqual(d, self.maker.target_dir)\n            if fn.endswith('.py') and fn != 'foo.py':  # no shebang in foo.py\n                with open(files[0], 'rb') as f:\n                    first_line = f.readline()\n                self.assertIn(executable, first_line)\n\n    def test_shebangs_custom_executable(self):\n        srcdir = tempfile.mkdtemp(prefix='distlib-test-')\n        self.addCleanup(shutil.rmtree, srcdir)\n        dstdir = tempfile.mkdtemp(prefix='distlib-test-')\n        self.addCleanup(shutil.rmtree, dstdir)\n        maker = ScriptMaker(srcdir, dstdir, add_launchers=False)\n        maker.executable = 'this_should_appear_in_the_shebang_line(\u4e2d\u6587)'\n        # let's create the script to be copied. It has a vanilla shebang line,\n        # with some Unicode in it.\n        fn = os.path.join(srcdir, 'copied')\n        with open(fn, 'w') as f:\n            f.write(COPIED_SCRIPT)\n        # Let's ask the maker to copy the script, and see what the shebang is\n        # in the copy.\n        filenames = maker.make('copied')\n        with open(filenames[0], 'rb') as f:\n            actual = f.readline().decode('utf-8')\n        self.assertIn(maker.executable, actual)\n        # Now let's make a script from a callable\n        filenames = maker.make(MADE_SCRIPT)\n        with open(filenames[0], 'rb') as f:\n            actual = f.readline().decode('utf-8')\n        self.assertIn(maker.executable, actual)\n\n    @unittest.skipIf(os.name != 'posix', 'Test only appropriate for '\n                     'POSIX systems')\n    def test_custom_shebang(self):\n        # Construct an executable with a space in it\n        self.maker.executable = 'an executable with spaces'\n        filenames = self.maker.make('script1.py')\n        with open(filenames[0], 'rb') as f:\n            first_line = f.readline()\n            second_line = f.readline()\n            third_line = f.readline()\n        self.assertEqual(first_line, b'#!/bin/sh\\n')\n        self.assertEqual(second_line, b\"'''exec' an executable with \"\n                         b'spaces \"$0\" \"$@\"\\n')\n        self.assertEqual(third_line, b\"' '''\\n\")\n        # Python 3.3 cannot create a venv in an existing directory\n        if venv and sys.version_info[:2] >= (3, 4):\n            if sys.platform == 'darwin':\n                # Supposedly 512, but various symlinks mean that temp folder\n                # names get larger than you'd expect ... might vary on different\n                # OS versions, too\n                dlen = 220\n            else:\n                dlen = 127\n            dstdir = tempfile.mkdtemp(suffix='cataaaaaa' + 'a' * dlen)\n            self.addCleanup(shutil.rmtree, dstdir)\n            bindir = os.path.join(dstdir, 'bin')\n            maker = ScriptMaker(self.maker.source_dir, bindir, add_launchers=False)\n            # See issue #204. Changed to use symlinks on POSIX\n            venv.create(dstdir, symlinks=(os.name != 'nt'))\n            maker.executable = os.path.join(bindir, 'python')\n            filenames = maker.make('script8.py')\n            p = subprocess.Popen(filenames[0], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdout, stderr = p.communicate()\n            self.assertEqual(p.returncode, 0)\n            self.assertEqual(stderr, b'')\n            expected = os.path.realpath(maker.executable)  # symlinks on OS X\n            actual = os.path.realpath(stdout.strip())\n            self.assertEqual(actual, expected.encode('utf-8'))\n\n    def test_multiple(self):\n        specs = ('foo.py', 'script1.py', 'script2.py', 'script3.py', 'shell.sh', 'uwsgi_part')\n        files = self.maker.make_multiple(specs)\n        self.assertEqual(len(specs), len(files))\n        expected = set(specs)\n        self.assertEqual(expected, set([os.path.basename(f) for f in files]))\n        ofiles = os.listdir(self.maker.target_dir)\n        self.assertEqual(expected, set(ofiles))\n\n    def test_generation(self):\n        self.maker.clobber = True\n\n        def do_test(maker, version_info):\n            for name in ('main', 'other_main'):\n                for options in (None, {}, {'gui': False}, {'gui': True}):\n                    gui = options and options.get('gui', False)\n                    spec = 'foo = foo:' + name\n                    files = maker.make(spec, options)\n                    self.assertEqual(len(files), 2)\n                    actual = set()\n                    for f in files:\n                        d, f = os.path.split(f)\n                        actual.add(f)\n                    if os.name == 'nt':  # pragma: no cover\n                        if gui:\n                            ext = 'pyw'\n                        else:\n                            ext = 'py'\n                        expected = set(['foo.%s' % ext, 'foo-%s.%s.%s' % (version_info[0], version_info[1], ext)])\n                    else:\n                        expected = set(['foo', 'foo-%s.%s' % (version_info[0], version_info[1])])\n                    self.assertEqual(actual, expected)\n                    self.assertEqual(d, maker.target_dir)\n                    for fn in files:\n                        with open(fn, 'r') as f:\n                            text = f.read()\n                        # self.assertIn(\"_resolve('foo', '%s')\" % name, text)\n                        if options and options['gui'] and os.name == 'nt':  # pragma: no cover\n                            first_line, rest = text.split('\\n', 1)\n                            self.assertIn('pythonw', first_line)\n\n        do_test(self.maker, sys.version_info)\n        # See issue 134. Test for specifying the target Python version\n        self.maker.version_info = version_info = (4, 4)  # just any other Python version\n        do_test(self.maker, version_info)\n\n    def test_clobber(self):\n        files = self.maker.make('foo = foo:main')\n        saved_files = files\n        self.assertGreaterEqual(len(files), 2)  # foo, foo-X.Y\n        files = self.maker.make('foo = foo:main')\n        self.assertFalse(files)\n        self.maker.clobber = True\n        files = self.maker.make('foo = foo:main')\n        self.assertEqual(files, saved_files)\n\n    @unittest.skipIf(os.name != 'nt', 'Test is Windows-specific')\n    def test_launchers(self):  # pragma: no cover\n        tlauncher = self.maker._get_launcher('t')\n        self.maker.add_launchers = True\n        specs = ('foo.py', 'script1.py', 'script2.py', 'script3.py', 'shell.sh')\n        files = self.maker.make_multiple(specs)\n        self.assertEqual(len(specs), len(files))\n        filenames = set([os.path.basename(f) for f in files])\n        self.assertEqual(filenames, set(('foo.py', 'script1.exe', 'script2.exe', 'script3.exe', 'shell.sh')))\n        for fn in files:\n            if not fn.endswith('.exe'):\n                continue\n            with open(fn, 'rb') as f:\n                data = f.read()\n            self.assertTrue(data.startswith(tlauncher))\n\n    @unittest.skipIf(os.name != 'nt', 'Test is Windows-specific')\n    def test_launcher_run(self):\n        self.maker.add_launchers = True\n        files = self.maker.make('script6.py')\n        self.assertEqual(len(files), 1)\n        p = subprocess.Popen([files[0], 'Test Argument'],\n                             stdout=subprocess.PIPE,\n                             stdin=subprocess.PIPE,\n                             stderr=subprocess.STDOUT)\n        stdout, stderr = p.communicate('input'.encode('ascii'))\n        actual = stdout.decode('ascii').replace('\\r\\n', '\\n')\n        expected = textwrap.dedent(\"\"\"\n            script6.exe\n            ['Test Argument']\n            'input'\n            non-optimized\n            \"\"\").lstrip()\n        self.assertEqual(actual, expected)\n\n    @unittest.skipIf(os.name != 'nt', 'Test is Windows-specific')\n    def test_launcher_run_with_interpreter_args(self):\n        srcdir = tempfile.mkdtemp(prefix='distlib-test-')\n        self.addCleanup(shutil.rmtree, srcdir)\n        dstdir = tempfile.mkdtemp(prefix='distlib-test-')\n        self.addCleanup(shutil.rmtree, dstdir)\n        maker = ScriptMaker(srcdir, dstdir, add_launchers=True)\n\n        # add '-O' option to shebang to run in optimized mode\n        with open(os.path.join(HERE, 'scripts', 'script6.py'), 'r') as src:\n            with open(os.path.join(srcdir, 'script6-optimized.py'), 'w') as dst:\n                shebang = src.readline().rstrip()\n                dst.write(shebang + \" -O\\n\")\n                dst.write(src.read())\n\n        files = maker.make('script6-optimized.py')\n        self.assertEqual(len(files), 1)\n        p = subprocess.Popen([files[0], 'Test Argument'],\n                             stdout=subprocess.PIPE,\n                             stdin=subprocess.PIPE,\n                             stderr=subprocess.STDOUT)\n        stdout, stderr = p.communicate('input'.encode('ascii'))\n        actual = stdout.decode('ascii').replace('\\r\\n', '\\n')\n        expected = textwrap.dedent(\"\"\"\n            script6-optimized.exe\n            ['Test Argument']\n            'input'\n            \"\"\").lstrip()  # 'non-optimized' is not printed this time\n        self.assertEqual(actual, expected)\n\n    @unittest.skipIf(os.name != 'nt', 'Test is Windows-specific')\n    def test_windows(self):  # pragma: no cover\n        wlauncher = self.maker._get_launcher('w')\n        tlauncher = self.maker._get_launcher('t')\n        self.maker.add_launchers = True\n        # executable = os.path.normcase(sys.executable).encode('utf-8')\n        executable = sys.executable.encode('utf-8')\n        if b'python3.' in executable:\n            wexecutable = executable.replace(b'python3.', b'pythonw3.')\n        else:\n            wexecutable = executable.replace(b'python.', b'pythonw.')\n        files = self.maker.make('script4.py')\n        self.assertEqual(len(files), 1)\n        filenames = set([os.path.basename(f) for f in files])\n        self.assertEqual(filenames, set(['script4.exe']))\n        for fn in files:\n            with open(fn, 'rb') as f:\n                data = f.read()\n            self.assertTrue(data.startswith(wlauncher))\n            self.assertIn(executable, data)\n        # Now test making scripts gui and console\n        files = self.maker.make('foo = foo:main', {'gui': True})\n        self.assertEqual(len(files), 2)\n        filenames = set([os.path.basename(f) for f in files])\n        specific = '%s.%s' % sys.version_info[:2]\n        self.assertEqual(filenames, set(('foo.exe', 'foo-%s.exe' % specific)))\n        for fn in files:\n            with open(fn, 'rb') as f:\n                data = f.read()\n            self.assertTrue(data.startswith(wlauncher))\n            self.assertIn(wexecutable, data)\n\n        files = self.maker.make('foo = foo:main')\n        self.assertEqual(len(files), 2)\n        filenames = set([os.path.basename(f) for f in files])\n        self.assertEqual(filenames, set(('foo.exe', 'foo-%s.exe' % specific)))\n        for fn in files:\n            with open(fn, 'rb') as f:\n                data = f.read()\n            self.assertTrue(data.startswith(tlauncher))\n            self.assertIn(executable, data)\n\n    @unittest.skipIf(os.name != 'nt', 'Test is Windows-specific')\n    def test_windows_run(self):\n        self.maker.add_launchers = True\n        files = self.maker.make('script7.pyw')\n        self.assertEqual(len(files), 1)\n\n        test_output = os.path.join(self.maker.target_dir, 'test_output.txt')\n        p = subprocess.Popen([files[0], test_output, 'Test Argument'],\n                             stdout=subprocess.PIPE,\n                             stdin=subprocess.PIPE,\n                             stderr=subprocess.STDOUT)\n        stdout, stderr = p.communicate()\n        self.assertFalse(stdout)\n        self.assertFalse(stderr)\n        with open(test_output, 'rb') as f:\n            actual = f.read().decode('ascii')\n        self.assertEqual(actual, 'Test Argument')\n\n    def test_dry_run(self):\n        self.maker.dry_run = True\n        self.maker.variants = set([''])\n        specs = ('foo.py', 'bar = foo:main')\n        files = self.maker.make_multiple(specs)\n        self.assertEqual(len(specs), len(files))\n        if os.name == 'nt':  # pragma: no cover\n            bar = 'bar.py'\n        else:\n            bar = 'bar'\n        self.assertEqual(set(('foo.py', bar)), set([os.path.basename(f) for f in files]))\n        ofiles = os.listdir(self.maker.target_dir)\n        self.assertFalse(ofiles)\n\n    def test_script_run(self):\n        if sys.version_info[:2] < (3, 13):\n            target = 'cgi:print_directory'\n        else:\n            target = 'test.support.interpreters:list_all'\n        files = self.maker.make('test = %s' % target)\n        self.assertEqual(len(files), 2)\n        p = subprocess.Popen([sys.executable, files[0]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        if sys.version_info[:2] < (3, 13):\n            self.assertIn(b'<H3>Current Working Directory:</H3>', stdout)\n            self.assertIn(os.getcwd().encode('utf-8'), stdout)\n        else:\n            self.assertIn(b'[Interpreter(0)]', stderr)\n            self.assertEqual(p.returncode, 1)\n\n    @unittest.skipUnless(os.name == 'posix', 'Test only valid for POSIX')\n    def test_mode(self):\n        # save test runner's original umask and ensure default 022\n        saved_umask = os.umask(0o022)\n        try:\n            self.maker.set_mode = False\n            files = self.maker.make('foo = foo:main')\n            self.assertEqual(len(files), 2)\n            for f in files:\n                self.assertIn(os.stat(f).st_mode & 0o7777, (0o644, 0o664))\n            self.maker.set_mode = True\n            files = self.maker.make('bar = bar:main')\n            self.assertEqual(len(files), 2)\n            for f in files:\n                self.assertIn(os.stat(f).st_mode & 0o7777, (0o755, 0o775))\n        finally:\n            # restore the test runner's original umask\n            os.umask(saved_umask)\n\n    def test_interpreter_args(self):\n        executable = fsencode(get_executable())\n        options = {'interpreter_args': ['-E', '\"foo bar\"', 'baz frobozz']}\n        self.maker.variants = set([''])\n        files = self.maker.make('foo = bar:baz', options=options)\n        self.assertEqual(len(files), 1)\n        with open(files[0], 'rb') as f:\n            shebang_line = f.readline()\n        if not sysconfig.is_python_build():\n            self.assertIn(executable, shebang_line)\n        self.assertIn(b' -E \"foo bar\" baz frobozz', shebang_line)\n\n    def test_args_on_copy(self):\n        self.maker.variants = set([''])\n        self.maker.executable = 'mypython'\n        files = self.maker.make('script5.py')\n        with open(files[0]) as f:\n            actual = f.readline().strip()\n        self.assertEqual(actual, '#!mypython -mzippy.activate')\n        if not sysconfig.is_python_build():\n            self.maker.executable = None\n            os.remove(files[0])\n            files = self.maker.make('script5.py')\n            with open(files[0]) as f:\n                actual = f.readline().strip()\n            expected = '#!%s -mzippy.activate' % get_executable()\n            self.assertEqual(actual, expected)\n\n    def test_enquote_executable(self):\n        for executable, expected in (('/no/spaces', '/no/spaces'), ('/i have/space', '\"/i have/space\"'),\n                                     ('\"/space prequoted\"', '\"/space prequoted\"'),\n                                     ('/usr/bin/env nospaces', '/usr/bin/env nospaces'), ('/usr/bin/env with spaces',\n                                                                                          '/usr/bin/env \"with spaces\"'),\n                                     ('/usr/bin/env \"pre spaced\"', '/usr/bin/env \"pre spaced\"')):\n            self.assertEqual(enquote_executable(executable), expected)\n\n    def test_variant_configuration(self):\n        spec = 'foo = foo:main'\n        files = self.maker.make(spec)\n        if os.name == 'nt':\n            ext = '.py'\n        else:\n            ext = ''\n        basenames = ('foo%s' % ext, 'foo-%s.%s%s' % (self.maker.version_info[:2] + (ext, )))\n        expected = set([os.path.join(self.maker.target_dir, s) for s in basenames])\n        self.assertEqual(expected, set(files))\n        self.maker.variant_separator = ''\n        self.maker.clobber = True\n        files = self.maker.make(spec)\n        basenames = ('foo%s' % ext, 'foo%s.%s%s' % (self.maker.version_info[:2] + (ext, )))\n        expected = set([os.path.join(self.maker.target_dir, s) for s in basenames])\n        self.assertEqual(expected, set(files))\n\n        class CustomMaker(ScriptMaker):\n\n            def get_script_filenames(self, name):\n                result = super(CustomMaker, self).get_script_filenames(name)\n                if 'X.Y' in self.variants:\n                    result.add('%s%s.%s' % ((name, ) + self.version_info[:2]))\n                return result\n\n        maker = CustomMaker(self.maker.source_dir, self.maker.target_dir, add_launchers=False)\n        maker.clobber = True\n        files = maker.make(spec)\n        basenames = ('foo%s' % ext, 'foo%s.%s%s' % (self.maker.version_info[:2] + (ext, )),\n                     'foo-%s.%s%s' % (self.maker.version_info[:2] + (ext, )))\n        expected = set([os.path.join(self.maker.target_dir, s) for s in basenames])\n        self.assertEqual(expected, set(files))\n        if os.name == 'nt':\n            maker.add_launchers = True\n            files = maker.make(spec)\n            expected = set([e.replace('.py', '.exe') for e in expected])\n            self.assertEqual(expected, set(files))\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/test_util.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom io import BytesIO\nfrom itertools import islice\nimport os\nimport re\nimport shutil\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None\nimport sys\nimport tempfile\nimport textwrap\nimport time\n\nfrom compat import unittest\nfrom support import TempdirManager, DistlibTestCase, in_github_workflow\n\nfrom distlib import DistlibException\nfrom distlib.compat import cache_from_source\nfrom distlib.util import (get_export_entry, ExportEntry, resolve, get_cache_base, path_to_cache_dir, zip_dir,\n                          parse_credentials, ensure_slash, split_filename, EventMixin, Sequencer, unarchive, Progress,\n                          iglob, RICH_GLOB, parse_requirement, get_extras, Configurator, read_exports, write_exports,\n                          FileOperator, is_string_sequence, get_package_data, convert_path)\n\nHERE = os.path.dirname(os.path.abspath(__file__))\nIN_GITHUB_WORKFLOW = in_github_workflow()\n\n\nclass TestContainer(object):\n\n    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\n\nclass UtilTestCase(DistlibTestCase):\n\n    def check_entry(self, entry, name, prefix, suffix, flags):\n        self.assertEqual(entry.name, name)\n        self.assertEqual(entry.prefix, prefix)\n        self.assertEqual(entry.suffix, suffix)\n        self.assertEqual(entry.flags, flags)\n\n    def test_export_entry(self):\n        self.assertIsNone(get_export_entry('foo.py'))\n        self.assertIsNone(get_export_entry('foo.py='))\n        for spec in ('foo=foo:main', 'foo =foo:main', 'foo= foo:main', 'foo = foo:main'):\n            self.check_entry(get_export_entry(spec), 'foo', 'foo', 'main', [])\n        self.check_entry(get_export_entry('foo=foo.bar:main'), 'foo', 'foo.bar', 'main', [])\n        self.check_entry(get_export_entry('foo=foo.bar:main [a]'), 'foo', 'foo.bar', 'main', ['a'])\n        # See issue #127 - allow hyphens\n        self.check_entry(get_export_entry('foo=foo.bar:main [with-foo]'), 'foo', 'foo.bar', 'main', ['with-foo'])\n        self.check_entry(get_export_entry('foo=foo.bar:main [ a ]'), 'foo', 'foo.bar', 'main', ['a'])\n        self.check_entry(get_export_entry('foo=foo.bar:main [a=b, c=d,e, f=g]'), 'foo', 'foo.bar', 'main',\n                         ['a=b', 'c=d', 'e', 'f=g'])\n        self.check_entry(get_export_entry('foo=foo.bar:main [a=9, 9=8,e, f9=g8]'), 'foo', 'foo.bar', 'main',\n                         ['a=9', '9=8', 'e', 'f9=g8'])\n        self.check_entry(get_export_entry('foo=foo.bar:main[x]'), 'foo', 'foo.bar', 'main', ['x'])\n        self.check_entry(get_export_entry('foo=abc'), 'foo', 'abc', None, [])\n        self.check_entry(get_export_entry('smc++ = smcpp.frontend:console'), 'smc++', 'smcpp.frontend', 'console', [])\n        # See issue #203 - correct name parsing to allow non-name-like names like \",\"\n        self.check_entry(get_export_entry(', = comma:main'), ',', 'comma', 'main', [])\n        self.check_entry(get_export_entry(',comma = comma:main'), ',comma', 'comma', 'main', [])\n\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x:y')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x ]')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x []')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [\\\\]')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [a=]')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [a,]')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [a,,b]')\n        self.assertRaises(DistlibException, get_export_entry, 'foo=foo.bar:x [a b]')\n\n    def test_resolve(self):\n        import logging\n        import logging.handlers\n        self.assertIs(resolve('logging', None), logging)\n        self.assertIs(resolve('logging.handlers', None), logging.handlers)\n        self.assertIs(resolve('logging', 'root'), logging.root)\n        self.assertEqual(resolve('logging', 'root.debug'), logging.root.debug)\n\n    def test_cache_base(self):\n        actual = get_cache_base()\n        if os.name == 'nt' and 'LOCALAPPDATA' in os.environ:\n            expected = os.path.expandvars('$localappdata')\n        else:\n            expected = os.path.expanduser('~')\n        expected = os.path.join(expected, '.distlib')\n        self.assertEqual(expected, actual)\n        self.assertTrue(os.path.isdir(expected))\n\n    @unittest.skipIf(os.name != 'posix', 'Test is only valid for POSIX')\n    def test_path_to_cache_dir_posix(self):\n        self.assertEqual(path_to_cache_dir('/home/user/some-file.zip'), '--home--user--some-file.zip.cache')\n\n    @unittest.skipIf(os.name != 'nt', 'Test is only valid for Windows')\n    def test_path_to_cache_dir_nt(self):\n        self.assertEqual(path_to_cache_dir(r'c:\\Users\\User\\Some-File.zip'), 'c-----Users--User--Some-File.zip.cache')\n\n    def test_parse_credentials(self):\n        cases = (\n            ('example.com', (None, None, 'example.com')),\n            ('user@example.com', ('user', None, 'example.com')),\n            ('user:pwd@example.com', ('user', 'pwd', 'example.com')),\n            ('user:@example.com', ('user', '', 'example.com')),\n            ('user:pass@word@example.com', ('user', 'pass@word', 'example.com')),\n            ('user:pass:word@example.com', ('user', 'pass:word', 'example.com')),\n            ('user%3Aname:%23%5E%40@example.com', ('user:name', '#^@', 'example.com')),\n        )\n\n        for s, expected in cases:\n            self.assertEqual(parse_credentials(s), expected)\n\n    def test_ensure_slash(self):\n        self.assertEqual(ensure_slash(''), '/')\n        self.assertEqual(ensure_slash('/'), '/')\n        self.assertEqual(ensure_slash('abc'), 'abc/')\n        self.assertEqual(ensure_slash('def/'), 'def/')\n\n    def test_split_filename(self):\n        self.assertIsNone(split_filename('abl.jquery'))\n        self.assertEqual(split_filename('abl.jquery-1.4.2-2'), ('abl.jquery', '1.4.2-2', None))\n        self.assertEqual(split_filename('python-gnupg-0.1'), ('python-gnupg', '0.1', None))\n        self.assertEqual(split_filename('baklabel-1.0.3-2729-py3.2'), ('baklabel', '1.0.3-2729', '3.2'))\n        self.assertEqual(split_filename('baklabel-1.0.3-2729-py27'), ('baklabel', '1.0.3-2729', '27'))\n        self.assertEqual(split_filename('advpy-0.99b'), ('advpy', '0.99b', None))\n        self.assertEqual(split_filename('asv_files-dev-20120501-01', 'asv_files'),\n                         ('asv_files', 'dev-20120501-01', None))\n        self.assertEqual(split_filename('greenlet-0.4.0-py27-win32'), ('greenlet', '0.4.0', '27'))\n        self.assertEqual(split_filename('greenlet-0.4.0-py27-linux_x86_64'), ('greenlet', '0.4.0', '27'))\n        self.assertEqual(split_filename('django-altuser-v0.6.8'), ('django-altuser', 'v0.6.8', None))\n        self.assertEqual(split_filename('youtube_dl_server-alpha.1'), ('youtube_dl_server', 'alpha.1', None))\n        self.assertEqual(split_filename('pytest-xdist-dev'), ('pytest-xdist', 'dev', None))\n        self.assertEqual(split_filename('pytest_xdist-0.1_myfork', None), ('pytest_xdist', '0.1_myfork', None))\n        self.assertEqual(split_filename('pytest_xdist-0.1_myfork', 'pytest-xdist'),\n                         ('pytest_xdist', '0.1_myfork', None))\n        self.assertEqual(split_filename('pytest_xdist-0.1_myfork', 'pytest_dist'), ('pytest_xdist', '0.1_myfork', None))\n\n    def test_convert_path(self):\n        CP = convert_path\n        if os.sep == '/':\n            d = os.path.dirname(__file__)\n            self.assertEqual(CP(d), d)\n        else:\n            self.assertEqual(CP(''), '')\n            self.assertRaises(ValueError, CP, '/foo')\n            self.assertRaises(ValueError, CP, 'foo/')\n\n    def test_events(self):\n        collected = []\n\n        def handler1(e, *args, **kwargs):\n            collected.append((1, e, args, kwargs))\n\n        def handler2(e, *args, **kwargs):\n            collected.append((2, e, args, kwargs))\n\n        def handler3(e, *args, **kwargs):\n            if not args:\n                raise NotImplementedError('surprise!')\n            collected.append((3, e, args, kwargs))\n            return (args, kwargs)\n\n        e = EventMixin()\n        e.add('A', handler1)\n        self.assertRaises(ValueError, e.remove, 'B', handler1)\n\n        cases = (\n            ((1, 2), {\n                'buckle': 'my shoe'\n            }),\n            ((3, 4), {\n                'shut': 'the door'\n            }),\n        )\n\n        for case in cases:\n            e.publish('A', *case[0], **case[1])\n            e.publish('B', *case[0], **case[1])\n\n        for actual, source in zip(collected, cases):\n            self.assertEqual(actual, (1, 'A') + source[:1] + source[1:])\n\n        collected = []\n        e.add('B', handler2)\n\n        self.assertEqual(tuple(e.get_subscribers('A')), (handler1, ))\n        self.assertEqual(tuple(e.get_subscribers('B')), (handler2, ))\n        self.assertEqual(tuple(e.get_subscribers('C')), ())\n\n        for case in cases:\n            e.publish('A', *case[0], **case[1])\n            e.publish('B', *case[0], **case[1])\n\n        actuals = islice(collected, 0, None, 2)\n        for actual, source in zip(actuals, cases):\n            self.assertEqual(actual, (1, 'A') + source[:1] + source[1:])\n\n        actuals = islice(collected, 1, None, 2)\n        for actual, source in zip(actuals, cases):\n            self.assertEqual(actual, (2, 'B') + source[:1] + source[1:])\n\n        e.remove('B', handler2)\n\n        collected = []\n\n        for case in cases:\n            e.publish('A', *case[0], **case[1])\n            e.publish('B', *case[0], **case[1])\n\n        for actual, source in zip(collected, cases):\n            self.assertEqual(actual, (1, 'A') + source[:1] + source[1:])\n\n        e.add('C', handler3)\n\n        collected = []\n        returned = []\n\n        for case in cases:\n            returned.extend(e.publish('C', *case[0], **case[1]))\n            returned.extend(e.publish('C'))\n\n        for actual, source in zip(collected, cases):\n            self.assertEqual(actual, (3, 'C') + source[:1] + source[1:])\n\n        self.assertEqual(tuple(islice(returned, 1, None, 2)), (None, None))\n        actuals = islice(returned, 0, None, 2)\n        for actual, expected in zip(actuals, cases):\n            self.assertEqual(actual, expected)\n\n    def test_sequencer_basic(self):\n        seq = Sequencer()\n\n        steps = (('check', 'sdist'), ('check', 'register'), ('check', 'sdist'), ('check', 'register'),\n                 ('register', 'upload_sdist'), ('sdist', 'upload_sdist'), ('check', 'build_clibs'),\n                 ('build_clibs', 'build_ext'), ('build_ext', 'build_py'), ('build_py', 'build_scripts'),\n                 ('build_scripts', 'build'), ('build', 'test'), ('register', 'upload_bdist'), ('build', 'upload_bdist'),\n                 ('build', 'install_headers'), ('install_headers', 'install_lib'), ('install_lib', 'install_scripts'),\n                 ('install_scripts', 'install_data'), ('install_data', 'install_distinfo'), ('install_distinfo',\n                                                                                             'install'))\n\n        for pred, succ in steps:\n            seq.add(pred, succ)\n\n        # Note: these tests are sensitive to dictionary ordering\n        # but work under Python 2.6, 2.7, 3.2, 3.3, 3.4 and PyPy 2.5\n        cases = (\n            ('check', ['check']),\n            ('register', ['check', 'register']),\n            ('sdist', ['check', 'sdist']),\n            ('build_clibs', ['check', 'build_clibs']),\n            ('build_ext', ['check', 'build_clibs', 'build_ext']),\n            ('build_py', ['check', 'build_clibs', 'build_ext', 'build_py']),\n            ('build_scripts', ['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts']),\n            ('build', ['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build']),\n            ('test', ['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'test']),\n            ('install_headers',\n             ['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers']),\n            ('install_lib', [\n                'check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers',\n                'install_lib'\n            ]),\n            ('install_scripts', [\n                'check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers',\n                'install_lib', 'install_scripts'\n            ]),\n            ('install_data', [\n                'check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers',\n                'install_lib', 'install_scripts', 'install_data'\n            ]),\n            ('install_distinfo', [\n                'check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers',\n                'install_lib', 'install_scripts', 'install_data', 'install_distinfo'\n            ]),\n            ('install', [\n                'check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'install_headers',\n                'install_lib', 'install_scripts', 'install_data', 'install_distinfo', 'install'\n            ]),\n            ('upload_sdist', (['check', 'register', 'sdist',\n                               'upload_sdist'], ['check', 'sdist', 'register', 'upload_sdist'])),\n            ('upload_bdist',\n             (['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'build', 'register', 'upload_bdist'],\n              ['check', 'build_clibs', 'build_ext', 'build_py', 'build_scripts', 'register', 'build', 'upload_bdist'])),\n        )\n\n        for final, expected in cases:\n            actual = list(seq.get_steps(final))\n            if isinstance(expected, tuple):\n                self.assertIn(actual, expected)\n            else:\n                self.assertEqual(actual, expected)\n\n        dot = seq.dot\n        expected = '''\n        digraph G {\n          check -> build_clibs;\n          install_lib -> install_scripts;\n          register -> upload_bdist;\n          build -> upload_bdist;\n          build_ext -> build_py;\n          install_scripts -> install_data;\n          check -> sdist;\n          check -> register;\n          build -> install_headers;\n          install_data -> install_distinfo;\n          sdist -> upload_sdist;\n          register -> upload_sdist;\n          install_distinfo -> install;\n          build -> test;\n          install_headers -> install_lib;\n          build_py -> build_scripts;\n          build_clibs -> build_ext;\n          build_scripts -> build;\n        }\n        '''\n        expected = textwrap.dedent(expected).strip().splitlines()\n        actual = dot.splitlines()\n        self.assertEqual(expected[0], actual[0])\n        self.assertEqual(expected[-1], actual[-1])\n        self.assertEqual(set(expected[1:-1]), set(actual[1:-1]))\n        actual = seq.strong_connections\n        expected = (\n            [('test', ), ('upload_bdist', ), ('install', ), ('install_distinfo', ), ('install_data', ),\n             ('install_scripts', ), ('install_lib', ), ('install_headers', ), ('build', ), ('build_scripts', ),\n             ('build_py', ), ('build_ext', ), ('build_clibs', ), ('upload_sdist', ), ('sdist', ), ('register', ),\n             ('check', )],\n            [('install', ), ('install_distinfo', ), ('install_data', ), ('install_scripts', ), ('install_lib', ),\n             ('install_headers', ), ('test', ), ('upload_bdist', ), ('build', ), ('build_scripts', ), ('build_py', ),\n             ('build_ext', ), ('build_clibs', ), ('upload_sdist', ), ('sdist', ), ('register', ), ('check', )],\n            [('upload_sdist', ), ('sdist', ), ('install', ), ('install_distinfo', ), ('install_data', ),\n             ('upload_bdist', ), ('register', ), ('install_scripts', ), ('install_lib', ), ('install_headers', ),\n             ('test', ), ('build', ), ('build_scripts', ), ('build_py', ), ('build_ext', ), ('build_clibs', ),\n             ('check', )],\n            # Next case added for PyPy\n            [('upload_sdist', ), ('sdist', ), ('upload_bdist', ), ('register', ), ('test', ), ('install', ),\n             ('install_distinfo', ), ('install_data', ),\n             ('install_scripts', ), ('install_lib', ), ('install_headers', ), ('build', ), ('build_scripts', ),\n             ('build_py', ), ('build_ext', ), ('build_clibs', ), ('check', )],\n            # Next case added for Python 3.6\n            [('upload_sdist', ), ('sdist', ), ('upload_bdist', ), ('register', ), ('install', ), ('install_distinfo', ),\n             ('install_data', ), ('install_scripts', ), ('install_lib', ), ('install_headers', ), ('test', ),\n             ('build', ), ('build_scripts', ), ('build_py', ), ('build_ext', ), ('build_clibs', ), ('check', )],\n            # Next case added for Python 3.11\n            [('upload_sdist', ), ('sdist', ), ('install', ), ('install_distinfo', ), ('install_data', ),\n             ('install_scripts', ), ('install_lib', ), ('install_headers', ), ('test', ), ('upload_bdist', ),\n             ('build', ), ('build_scripts', ), ('build_py', ), ('build_ext', ), ('build_clibs', ), ('register', ),\n             ('check', )])\n        self.assertIn(actual, expected)\n\n    def test_sequencer_cycle(self):\n        seq = Sequencer()\n        seq.add('A', 'B')\n        seq.add('B', 'C')\n        seq.add('C', 'D')\n        self.assertEqual(list(seq.get_steps('D')), ['A', 'B', 'C', 'D'])\n        seq.add('C', 'A')\n        self.assertEqual(list(seq.get_steps('D')), ['C', 'A', 'B', 'D'])\n        self.assertFalse(seq.is_step('E'))\n        self.assertRaises(ValueError, seq.get_steps, 'E')\n        seq.add_node('E')\n        self.assertTrue(seq.is_step('E'))\n        self.assertEqual(list(seq.get_steps('E')), ['E'])\n        seq.remove_node('E')\n        self.assertFalse(seq.is_step('E'))\n        self.assertRaises(ValueError, seq.get_steps, 'E')\n        seq.remove('C', 'A')\n        self.assertEqual(list(seq.get_steps('D')), ['A', 'B', 'C', 'D'])\n\n    def test_sequencer_removal(self):\n        seq = Sequencer()\n        seq.add('A', 'B')\n        seq.add('B', 'C')\n        seq.add('C', 'D')\n        preds = {'B': set(['A']), 'C': set(['B']), 'D': set(['C'])}\n        succs = {'A': set(['B']), 'B': set(['C']), 'C': set(['D'])}\n        self.assertEqual(seq._preds, preds)\n        self.assertEqual(seq._succs, succs)\n        seq.remove_node('C')\n        self.assertEqual(seq._preds, preds)\n        self.assertEqual(seq._succs, succs)\n        seq.remove_node('C', True)\n        self.assertEqual(seq._preds, {'B': set(['A'])})\n        self.assertEqual(seq._succs, {'A': set(['B'])})\n\n    def test_unarchive(self):\n        import zipfile, tarfile\n\n        good_archives = (\n            ('good.zip', zipfile.ZipFile, 'r', 'namelist'),\n            ('good.tar', tarfile.open, 'r', 'getnames'),\n            ('good.tar.gz', tarfile.open, 'r:gz', 'getnames'),\n            ('good.tar.bz2', tarfile.open, 'r:bz2', 'getnames'),\n        )\n        bad_archives = ('bad.zip', 'bad.tar', 'bad.tar.gz', 'bad.tar.bz2')\n\n        # Test \"evil\" tarball on 3.12 *or* on Python with PEP-706 backported\n        if sys.version_info > (3, 12) or hasattr(tarfile, 'data_filter'):\n            bad_archives += ('evil.tar.gz', )\n\n        for name, cls, mode, lister in good_archives:\n            td = tempfile.mkdtemp()\n            archive = None\n            try:\n                name = os.path.join(HERE, name)\n                unarchive(name, td)\n                archive = cls(name, mode)\n                names = getattr(archive, lister)()\n                for name in names:\n                    p = os.path.join(td, name)\n                    self.assertTrue(os.path.exists(p))\n            finally:\n                shutil.rmtree(td)\n                if archive:\n                    archive.close()\n\n        for name in bad_archives:\n            name = os.path.join(HERE, name)\n            td = tempfile.mkdtemp()\n            try:\n                self.assertRaises(ValueError, unarchive, name, td)\n            finally:\n                shutil.rmtree(td)\n\n    def test_string_sequence(self):\n        self.assertTrue(is_string_sequence(['a']))\n        self.assertTrue(is_string_sequence(['a', 'b']))\n        self.assertFalse(is_string_sequence(['a', 'b', None]))\n        self.assertRaises(AssertionError, is_string_sequence, [])\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    def test_package_data(self):\n        data = get_package_data(name='config', version='0.3.6')\n        self.assertTrue(data)\n        self.assertTrue('index-metadata' in data)\n        metadata = data['index-metadata']\n        self.assertEqual(metadata['name'], 'config')\n        self.assertEqual(metadata['version'], '0.3.6')\n        data = get_package_data(name='config', version='0.3.5')\n        self.assertFalse(data)\n\n    def test_zip_dir(self):\n        d = os.path.join(HERE, 'foofoo')\n        data = zip_dir(d)\n        self.assertIsInstance(data, BytesIO)\n\n    def test_configurator(self):\n        d = {\n            'a': 1,\n            'b': 2.0,\n            'c': 'xyz',\n            'd': 'inc://' + os.path.join(HERE, 'included.json'),\n            'e': 'inc://' + 'included.json',\n            'stderr': 'ext://sys.stderr',\n            'list_o_stuff': [\n                'cfg://stderr',\n                'ext://sys.stdout',\n                'ext://logging.NOTSET',\n            ],\n            'dict_o_stuff': {\n                'k1': 'cfg://list_o_stuff[1]',\n                'k2': 'abc',\n                'k3': 'cfg://list_o_stuff',\n            },\n            'another_dict_o_stuff': {\n                'k1': 'cfg://dict_o_stuff[k2]',\n                'k2': 'ext://re.I',\n                'k3': 'cfg://dict_o_stuff[k3][0]',\n            },\n            'custom': {\n                '()': __name__ + '.TestContainer',\n                '[]': [1, 'a', 2.0, ('b', 'c', 'd')],\n                '.': {\n                    'p1': 'a',\n                    'p2': 'b',\n                    'p3': {\n                        '()': __name__ + '.TestContainer',\n                        '[]': [1, 2],\n                        '.': {\n                            'p1': 'c',\n                        },\n                    },\n                },\n                'k1': 'v1',\n                'k2': 'v2',\n            }\n        }\n\n        cfg = Configurator(d, HERE)\n        self.assertEqual(cfg['a'], 1)\n        self.assertEqual(cfg['b'], 2.0)\n        self.assertEqual(cfg['c'], 'xyz')\n        self.assertIs(cfg['stderr'], sys.stderr)\n        self.assertIs(cfg['list_o_stuff'][0], sys.stderr)\n        self.assertIs(cfg['list_o_stuff'][1], sys.stdout)\n        self.assertIs(cfg['list_o_stuff'][-1], 0)  # logging.NOTSET == 0\n        self.assertIs(cfg['dict_o_stuff']['k1'], sys.stdout)\n        self.assertIs(cfg['another_dict_o_stuff']['k1'], 'abc')\n        self.assertIs(cfg['another_dict_o_stuff']['k2'], re.I)\n        self.assertIs(cfg['another_dict_o_stuff']['k3'], sys.stderr)\n        custom = cfg['custom']\n        self.assertIsInstance(custom, TestContainer)\n        self.assertEqual(custom.args, (1, 'a', 2.0, ('b', 'c', 'd')))\n        self.assertEqual(custom.kwargs, {'k1': 'v1', 'k2': 'v2'})\n        self.assertEqual(custom.p1, 'a')\n        self.assertEqual(custom.p2, 'b')\n        self.assertIsInstance(custom.p3, TestContainer)\n        self.assertEqual(custom.p3.args, (1, 2))\n        self.assertEqual(custom.p3.kwargs, {})\n        self.assertEqual(custom.p3.p1, 'c')\n        self.assertEqual(cfg['d'], {'foo': 'bar', 'bar': 'baz'})\n        self.assertEqual(cfg['e'], {'foo': 'bar', 'bar': 'baz'})\n\n\ndef _speed_range(min_speed, max_speed):\n    return tuple(['%d KB/s' % v for v in range(min_speed, max_speed + 1)])\n\n\ndef _eta_range(min_eta, max_eta, prefix='ETA '):\n    msg = prefix + ': 00:00:%02d'\n    return tuple([msg % v for v in range(min_eta, max_eta + 1)])\n\n\nclass ProgressTestCase(DistlibTestCase):\n    # Of late, the speed tests keep failing on AppVeyor and Windows\n    @unittest.skipIf(IN_GITHUB_WORKFLOW or (os.name == 'nt' and os.environ.get('APPVEYOR') == 'True'),\n                     'Test disabled on some environments due to performance')\n    def test_basic(self):\n\n        # These ranges may need tweaking to cater for especially slow\n        # machines\n        if os.name == 'nt':\n            speed1 = _speed_range(18, 20)\n            speed2 = _speed_range(20, 22)\n        else:\n            speed1 = _speed_range(16, 19)\n            speed2 = _speed_range(20, 22)\n        expected = (\n            (' 10 %', _eta_range(4, 7), speed1),\n            (' 20 %', _eta_range(4, 7), speed1),\n            (' 30 %', _eta_range(3, 4), speed1),\n            (' 40 %', _eta_range(3, 3), speed1),\n            (' 50 %', _eta_range(2, 2), speed1),\n            (' 60 %', _eta_range(2, 2), speed1),\n            (' 70 %', _eta_range(1, 1), speed1),\n            (' 80 %', _eta_range(1, 1), speed1),\n            (' 90 %', _eta_range(0, 0), speed1),\n            ('100 %', _eta_range(4, 5, 'Done'), speed2),\n        )\n        bar = Progress(maxval=100000).start()\n        for i, v in enumerate(range(10000, 100000, 10000)):\n            time.sleep(0.5)\n            bar.update(v)\n            p, e, s = expected[i]\n            self.assertEqual(bar.percentage, p)\n            self.assertIn(bar.ETA, e, p)\n            self.assertIn(bar.speed, s)\n        bar.stop()\n        p, e, s = expected[i + 1]\n        self.assertEqual(bar.percentage, p)\n        self.assertIn(bar.ETA, e, p)\n        self.assertIn(bar.speed, s)\n\n    # Of late, the speed tests keep failing on AppVeyor and Windows\n    @unittest.skipIf(IN_GITHUB_WORKFLOW or (os.name == 'nt' and os.environ.get('APPVEYOR') == 'True'),\n                     'Test disabled on some environments due to performance')\n    def test_unknown(self):\n        if os.name == 'nt':\n            speed = _speed_range(17, 20)\n        else:\n            speed = _speed_range(17, 19)\n        expected = (\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            (' ?? %', 'ETA : ??:??:??', speed),\n            ('100 %', 'Done: 00:00:04', speed),\n        )\n        bar = Progress(maxval=None).start()\n        for i, v in enumerate(range(10000, 100000, 10000)):\n            time.sleep(0.5)\n            bar.update(v)\n            p, e, s = expected[i]\n            self.assertEqual(bar.percentage, p)\n            self.assertEqual(bar.ETA, e)\n            self.assertIn(bar.speed, s)\n        bar.stop()\n        p, e, s = expected[i + 1]\n        self.assertEqual(bar.percentage, p)\n        self.assertEqual(bar.ETA, e)\n        self.assertIn(bar.speed, s)\n\n\nclass FileOpsTestCase(DistlibTestCase):\n\n    def setUp(self):\n        self.fileop = FileOperator()\n        self.workdir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        if os.path.isdir(self.workdir):\n            shutil.rmtree(self.workdir)\n\n    def test_ensure_dir(self):\n        td = self.workdir\n        os.rmdir(td)\n        self.fileop.ensure_dir(td)\n        self.assertTrue(os.path.exists(td))\n        self.fileop.dry_run = True\n        os.rmdir(td)\n        self.fileop.ensure_dir(td)\n        self.assertFalse(os.path.exists(td))\n\n    def test_ensure_removed(self):\n        td = self.workdir\n        self.assertTrue(os.path.exists(td))\n        self.fileop.dry_run = True\n        self.fileop.ensure_removed(td)\n        self.assertTrue(os.path.exists(td))\n        self.fileop.dry_run = False\n        self.fileop.ensure_removed(td)\n        self.assertFalse(os.path.exists(td))\n\n    def test_is_writable(self):\n        sd = 'subdir'\n        ssd = 'subsubdir'\n        path = os.path.join(self.workdir, sd, ssd)\n        os.makedirs(path)\n        path = os.path.join(path, 'test')\n        self.assertTrue(self.fileop.is_writable(path))\n        if os.name == 'posix':\n            self.assertFalse(self.fileop.is_writable('/etc'))\n\n    def test_byte_compile(self):\n        path = os.path.join(self.workdir, 'hello.py')\n        dpath = cache_from_source(path, True)\n        self.fileop.write_text_file(path, 'print(\"Hello, world!\")', 'utf-8')\n        self.fileop.byte_compile(path, optimize=False)\n        self.assertTrue(os.path.exists(dpath))\n\n    def write_some_files(self):\n        path = os.path.join(self.workdir, 'file1')\n        written = []\n        self.fileop.write_text_file(path, 'test', 'utf-8')\n        written.append(path)\n        path = os.path.join(self.workdir, 'file2')\n        self.fileop.copy_file(written[0], path)\n        written.append(path)\n        path = os.path.join(self.workdir, 'dir1')\n        self.fileop.ensure_dir(path)\n        return set(written), set([path])\n\n    def test_copy_check(self):\n        srcpath = os.path.join(self.workdir, 'file1')\n        self.fileop.write_text_file(srcpath, 'test', 'utf-8')\n        dstpath = os.path.join(self.workdir, 'file2')\n        os.mkdir(dstpath)\n        self.assertRaises(ValueError, self.fileop.copy_file, srcpath, dstpath)\n        os.rmdir(dstpath)\n        if os.name == 'posix':  # symlinks available\n            linkpath = os.path.join(self.workdir, 'file3')\n            self.fileop.write_text_file(linkpath, 'linkdest', 'utf-8')\n            os.symlink(linkpath, dstpath)\n            self.assertRaises(ValueError, self.fileop.copy_file, srcpath, dstpath)\n\n    def test_commit(self):\n        # will assert if record isn't set\n        self.assertRaises(AssertionError, self.fileop.commit)\n        self.fileop.record = True\n        expected = self.write_some_files()\n        actual = self.fileop.commit()\n        self.assertEqual(actual, expected)\n        self.assertFalse(self.fileop.record)\n\n    def test_rollback(self):\n        # will assert if record isn't set\n        self.assertRaises(AssertionError, self.fileop.commit)\n        self.fileop.record = True\n        self.write_some_files()\n        self.fileop.rollback()\n        self.assertEqual(os.listdir(self.workdir), [])\n        self.assertFalse(self.fileop.record)\n\n\nclass GlobTestCaseBase(TempdirManager, DistlibTestCase):\n\n    def build_files_tree(self, files):\n        tempdir = self.mkdtemp()\n        for filepath in files:\n            is_dir = filepath.endswith('/')\n            filepath = os.path.join(tempdir, *filepath.split('/'))\n            if is_dir:\n                dirname = filepath\n            else:\n                dirname = os.path.dirname(filepath)\n            if dirname and not os.path.exists(dirname):\n                os.makedirs(dirname)\n            if not is_dir:\n                self.write_file(filepath, 'babar')\n        return tempdir\n\n    @staticmethod\n    def os_dependent_path(path):\n        path = path.rstrip('/').split('/')\n        return os.path.join(*path)\n\n    def clean_tree(self, spec):\n        files = []\n        for path, includes in spec.items():\n            if includes:\n                files.append(self.os_dependent_path(path))\n        return sorted(files)\n\n\nclass GlobTestCase(GlobTestCaseBase):\n\n    def assertGlobMatch(self, glob, spec):\n        tempdir = self.build_files_tree(spec)\n        expected = self.clean_tree(spec)\n        os.chdir(tempdir)\n        result = sorted(iglob(glob))\n        self.assertEqual(expected, result)\n\n    def test_regex_rich_glob(self):\n        matches = RICH_GLOB.findall(r\"babar aime les {fraises} est les {huitres}\")\n        self.assertEqual([\"fraises\", \"huitres\"], matches)\n\n    def test_simple_glob(self):\n        glob = '*.tp?'\n        spec = {'coucou.tpl': True, 'coucou.tpj': True, 'Donotwant': False}\n        self.assertGlobMatch(glob, spec)\n\n    def test_simple_glob_in_dir(self):\n        glob = os.path.join('babar', '*.tp?')\n        spec = {'babar/coucou.tpl': True, 'babar/coucou.tpj': True, 'babar/toto.bin': False, 'Donotwant': False}\n        self.assertGlobMatch(glob, spec)\n\n    def test_recursive_glob_head(self):\n        glob = os.path.join('**', 'tip', '*.t?l')\n        spec = {\n            'babar/zaza/zuzu/tip/coucou.tpl': True,\n            'babar/z/tip/coucou.tpl': True,\n            'babar/tip/coucou.tpl': True,\n            'babar/zeop/tip/babar/babar.tpl': False,\n            'babar/z/tip/coucou.bin': False,\n            'babar/toto.bin': False,\n            'zozo/zuzu/tip/babar.tpl': True,\n            'zozo/tip/babar.tpl': True,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_recursive_glob_tail(self):\n        glob = os.path.join('babar', '**')\n        spec = {\n            'babar/zaza/': True,\n            'babar/zaza/zuzu/': True,\n            'babar/zaza/zuzu/babar.xml': True,\n            'babar/zaza/zuzu/toto.xml': True,\n            'babar/zaza/zuzu/toto.csv': True,\n            'babar/zaza/coucou.tpl': True,\n            'babar/bubu.tpl': True,\n            'zozo/zuzu/tip/babar.tpl': False,\n            'zozo/tip/babar.tpl': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_recursive_glob_middle(self):\n        glob = os.path.join('babar', '**', 'tip', '*.t?l')\n        spec = {\n            'babar/zaza/zuzu/tip/coucou.tpl': True,\n            'babar/z/tip/coucou.tpl': True,\n            'babar/tip/coucou.tpl': True,\n            'babar/zeop/tip/babar/babar.tpl': False,\n            'babar/z/tip/coucou.bin': False,\n            'babar/toto.bin': False,\n            'zozo/zuzu/tip/babar.tpl': False,\n            'zozo/tip/babar.tpl': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_glob_set_tail(self):\n        glob = os.path.join('bin', '*.{bin,sh,exe}')\n        spec = {\n            'bin/babar.bin': True,\n            'bin/zephir.sh': True,\n            'bin/celestine.exe': True,\n            'bin/cornelius.bat': False,\n            'bin/cornelius.xml': False,\n            'toto/yurg': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_glob_set_middle(self):\n        glob = os.path.join('xml', '{babar,toto}.xml')\n        spec = {\n            'xml/babar.xml': True,\n            'xml/toto.xml': True,\n            'xml/babar.xslt': False,\n            'xml/cornelius.sgml': False,\n            'xml/zephir.xml': False,\n            'toto/yurg.xml': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_glob_set_head(self):\n        glob = os.path.join('{xml,xslt}', 'babar.*')\n        spec = {\n            'xml/babar.xml': True,\n            'xml/toto.xml': False,\n            'xslt/babar.xslt': True,\n            'xslt/toto.xslt': False,\n            'toto/yurg.xml': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_glob_all(self):\n        dirs = '{%s,%s}' % (os.path.join('xml', '*'), os.path.join('xslt', '**'))\n        glob = os.path.join(dirs, 'babar.xml')\n        spec = {\n            'xml/a/babar.xml': True,\n            'xml/b/babar.xml': True,\n            'xml/a/c/babar.xml': False,\n            'xslt/a/babar.xml': True,\n            'xslt/b/babar.xml': True,\n            'xslt/a/c/babar.xml': True,\n            'toto/yurg.xml': False,\n            'Donotwant': False\n        }\n        self.assertGlobMatch(glob, spec)\n\n    def test_invalid_glob_pattern(self):\n        invalids = [\n            'ppooa**',\n            'azzaeaz4**/',\n            '/**ddsfs',\n            '**##1e\"&e',\n            'DSFb**c009',\n            '{',\n            '{aaQSDFa',\n            '}',\n            'aQSDFSaa}',\n            '{**a,',\n            ',**a}',\n            '{a**,',\n            ',b**}',\n            '{a**a,babar}',\n            '{bob,b**z}',\n        ]\n        for pattern in invalids:\n            self.assertRaises(ValueError, iglob, pattern)\n\n    def test_parse_requirement(self):\n        # Empty requirements\n        for empty in ('', '#this should be ignored'):\n            self.assertIsNone(parse_requirement(empty))\n\n        # Invalid requirements\n        for invalid in ('a (', 'a/', 'a$', 'a [', 'a () [],', 'a 1.2'):\n            self.assertRaises(SyntaxError, parse_requirement, invalid)\n\n        # Valid requirements\n        def validate(r, values):\n            self.assertEqual(r.name, values[0])\n            self.assertEqual(r.constraints, values[1])\n            self.assertEqual(r.extras, values[2])\n            self.assertEqual(r.requirement, values[3])\n            self.assertEqual(r.url, values[4])\n\n        r = parse_requirement('a')\n        validate(r, ('a', None, None, 'a', None))\n        r = parse_requirement('a >= 1.2, <2.0,!=1.7')\n        validate(r, ('a', [('>=', '1.2'), ('<', '2.0'), ('!=', '1.7')], None, 'a >= 1.2, < 2.0, != 1.7', None))\n        r = parse_requirement('a [ab,cd , ef] >= 1.2, <2.0')\n        validate(r, ('a', [('>=', '1.2'), ('<', '2.0')], ['ab', 'cd', 'ef'], 'a >= 1.2, < 2.0', None))\n        r = parse_requirement('a[]')\n        validate(r, ('a', None, None, 'a', None))\n        r = parse_requirement('a (== 1.2.*, != 1.2.1.*)')\n        validate(r, ('a', [('==', '1.2.*'), ('!=', '1.2.1.*')], None, 'a == 1.2.*, != 1.2.1.*', None))\n        r = parse_requirement('a @ http://domain.com/path#abc=def')\n        validate(r, ('a', None, None, 'a', 'http://domain.com/path#abc=def'))\n        # See issue #148\n        r = parse_requirement('a >=3.6')\n        validate(r, ('a', [('>=', '3.6')], None, 'a >= 3.6', None))\n        r = parse_requirement('a >=3.6,')\n        validate(r, ('a', [('>=', '3.6')], None, 'a >= 3.6', None))\n\n        if False:  # TODO re-enable\n            for e in ('*', ':*:', ':meta:', '-', '-abc'):\n                r = parse_requirement('a [%s]' % e)\n                validate(r, ('a', None, [e], 'a', None))\n\n    def test_write_exports(self):\n        exports = {\n            'foo': {\n                'v1': ExportEntry('v1', 'p1', 's1', []),\n                'v2': ExportEntry('v2', 'p2', 's2', ['f2=a', 'g2']),\n            },\n            'bar': {\n                'v3': ExportEntry('v3', 'p3', 's3', ['f3', 'g3=h']),\n                'v4': ExportEntry('v4', 'p4', 's4', ['f4', 'g4']),\n            },\n        }\n\n        fd, fn = tempfile.mkstemp()\n        try:\n            os.close(fd)\n            with open(fn, 'wb') as f:\n                write_exports(exports, f)\n            with open(fn, 'rb') as f:\n                actual = read_exports(f)\n            self.assertEqual(actual, exports)\n        finally:\n            os.remove(fn)\n\n    def test_get_extras(self):\n        cases = (\n            (['*'], ['i18n'], set(['i18n'])),\n            (['*', '-bar'], ['foo', 'bar'], set(['foo'])),\n        )\n        for requested, available, expected in cases:\n            actual = get_extras(requested, available)\n            self.assertEqual(actual, expected)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/support.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport codecs\nimport os\nimport logging\nimport logging.handlers\nimport shutil\nimport socket\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None\nimport sys\nimport tempfile\ntry:\n    import threading\nexcept ImportError:\n    import dummy_threading as threading\nimport weakref\n\nfrom compat import (unittest, HTTPServer as BaseHTTPServer, SimpleHTTPRequestHandler, urlparse)\n\nfrom distlib import logger\n\nHERE = os.path.dirname(__file__)\n\n\nclass _TestHandler(logging.handlers.BufferingHandler, object):\n    # stolen and adapted from test.support\n\n    def __init__(self):\n        super(_TestHandler, self).__init__(0)\n        self.setLevel(logging.DEBUG)\n\n    def shouldFlush(self):\n        return False\n\n    def emit(self, record):\n        self.buffer.append(record)\n\n\nclass LoggingCatcher(object):\n    \"\"\"TestCase-compatible mixin to receive logging calls.\n\n    Upon setUp, instances of this classes get a BufferingHandler that's\n    configured to record all messages logged to the 'distutils2' logger.\n\n    Use get_logs to retrieve messages and self.loghandler.flush to discard\n    them.  get_logs automatically flushes the logs, unless you pass\n    *flush=False*, for example to make multiple calls to the method with\n    different level arguments.  If your test calls some code that generates\n    logging message and then you don't call get_logs, you will need to flush\n    manually before testing other code in the same test_* method, otherwise\n    get_logs in the next lines will see messages from the previous lines.\n    See example in test_command_check.\n    \"\"\"\n\n    def setUp(self):\n        super(LoggingCatcher, self).setUp()\n        self.loghandler = handler = _TestHandler()\n        self._old_level = logger.level\n        logger.addHandler(handler)\n        logger.setLevel(logging.DEBUG)  # we want all messages\n\n    def tearDown(self):\n        handler = self.loghandler\n        # All this is necessary to properly shut down the logging system and\n        # avoid a regrtest complaint.  Thanks to Vinay Sajip for the help.\n        handler.close()\n        logger.removeHandler(handler)\n        for ref in weakref.getweakrefs(handler):\n            logging._removeHandlerRef(ref)\n        del self.loghandler\n        logger.setLevel(self._old_level)\n        super(LoggingCatcher, self).tearDown()\n\n    def get_logs(self, level=logging.WARNING, flush=True):\n        \"\"\"Return all log messages with given level.\n\n        *level* defaults to logging.WARNING.\n\n        For log calls with arguments (i.e.  logger.info('bla bla %r', arg)),\n        the messages will be formatted before being returned (e.g. \"bla bla\n        'thing'\").\n\n        Returns a list.  Automatically flushes the loghandler after being\n        called, unless *flush* is False (this is useful to get e.g. all\n        warnings then all info messages).\n        \"\"\"\n        messages = [log.getMessage() for log in self.loghandler.buffer if log.levelno == level]\n        if flush:\n            self.loghandler.flush()\n        return messages\n\n\nclass TempdirManager(object):\n    \"\"\"TestCase-compatible mixin to create temporary directories and files.\n\n    Directories and files created in a test_* method will be removed after it\n    has run.\n    \"\"\"\n\n    def setUp(self):\n        super(TempdirManager, self).setUp()\n        self._olddir = os.getcwd()\n        self._basetempdir = tempfile.mkdtemp()\n        self._files = []\n\n    def tearDown(self):\n        for handle, name in self._files:\n            if handle is not None:\n                handle.close()\n            os.remove(name)\n\n        os.chdir(self._olddir)\n        shutil.rmtree(self._basetempdir)\n        super(TempdirManager, self).tearDown()\n\n    def temp_filename(self):\n        \"\"\"Create a read-write temporary file name and return it.\"\"\"\n        fd, fn = tempfile.mkstemp(dir=self._basetempdir)\n        os.close(fd)\n        self._files.append((None, fn))\n        return fn\n\n    def mktempfile(self):\n        \"\"\"Create a read-write temporary file and return it.\"\"\"\n        fd, fn = tempfile.mkstemp(dir=self._basetempdir)\n        os.close(fd)\n        fp = open(fn, 'w+')\n        self._files.append((fp, fn))\n        return fp\n\n    def mkdtemp(self):\n        \"\"\"Create a temporary directory and return its path.\"\"\"\n        d = tempfile.mkdtemp(dir=self._basetempdir)\n        return d\n\n    def write_file(self, path, content='xxx', encoding=None):\n        \"\"\"Write a file at the given path.\n\n        path can be a string, a tuple or a list; if it's a tuple or list,\n        os.path.join will be used to produce a path.\n        \"\"\"\n        if isinstance(path, (list, tuple)):\n            path = os.path.join(*path)\n        f = codecs.open(path, 'w', encoding=encoding)\n        try:\n            f.write(content)\n        finally:\n            f.close()\n\n    def assertIsFile(self, *args):\n        path = os.path.join(*args)\n        dirname = os.path.dirname(path)\n        file = os.path.basename(path)\n        if os.path.isdir(dirname):\n            files = os.listdir(dirname)\n            msg = \"%s not found in %s: %s\" % (file, dirname, files)\n            assert os.path.isfile(path), msg\n        else:\n            raise AssertionError('%s not found. %s does not exist' % (file, dirname))\n\n    def assertIsNotFile(self, *args):\n        path = os.path.join(*args)\n        self.assertFalse(os.path.isfile(path), \"%r exists\" % path)\n\n\nclass EnvironRestorer(object):\n    \"\"\"TestCase-compatible mixin to restore or delete environment variables.\n\n    The variables to restore (or delete if they were not originally present)\n    must be explicitly listed in self.restore_environ.  It's better to be\n    aware of what we're modifying instead of saving and restoring the whole\n    environment.\n    \"\"\"\n\n    def setUp(self):\n        super(EnvironRestorer, self).setUp()\n        self._saved = []\n        self._added = []\n        for key in self.restore_environ:\n            if key in os.environ:\n                self._saved.append((key, os.environ[key]))\n            else:\n                self._added.append(key)\n\n    def tearDown(self):\n        for key, value in self._saved:\n            os.environ[key] = value\n        for key in self._added:\n            os.environ.pop(key, None)\n        super(EnvironRestorer, self).tearDown()\n\n\nclass HTTPRequestHandler(SimpleHTTPRequestHandler):\n\n    server_version = \"TestHTTPS/1.0\"\n    # Avoid hanging when a request gets interrupted by the client\n    timeout = 5\n\n    def translate_path(self, path):\n        return os.path.join(HERE, 'testsrc', 'README.txt')\n\n    def log_message(self, format, *args):\n        pass\n\n\nclass HTTPSServer(BaseHTTPServer):\n    # Adapted from the one in Python's test suite.\n    def __init__(self, server_address, handler_class, certfile):\n        BaseHTTPServer.__init__(self, server_address, handler_class)\n        self.certfile = certfile\n\n    def get_request(self):\n        try:\n            sock, addr = self.socket.accept()\n            if hasattr(ssl, 'SSLContext'):\n                context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n                context.load_cert_chain(self.certfile)\n                sock = context.wrap_socket(sock, server_side=True)\n            else:\n                sock = ssl.wrap_socket(sock,\n                                       server_side=True,\n                                       certfile=self.certfile,\n                                       keyfile=self.certfile,\n                                       ssl_version=ssl.PROTOCOL_SSLv23)\n        except socket.error as e:\n            # socket errors are silenced by the caller, print them here\n            sys.stderr.write(\"Got an error:\\n%s\\n\" % e)\n            raise\n        return sock, addr\n\n\nclass HTTPSServerThread(threading.Thread):\n\n    def __init__(self, certfile):\n        self.flag = None\n        self.server = HTTPSServer(('localhost', 0), HTTPRequestHandler, certfile)\n        self.port = self.server.server_port\n        threading.Thread.__init__(self)\n        self.daemon = True\n\n    def start(self, flag=None):\n        self.flag = flag\n        threading.Thread.start(self)\n\n    def run(self):\n        if self.flag:\n            self.flag.set()\n        try:\n            self.server.serve_forever(0.05)\n        finally:\n            self.server.server_close()\n\n    def stop(self):\n        self.server.shutdown()\n\n\ntry:\n    import zlib\nexcept ImportError:\n    zlib = None\n\nrequires_zlib = unittest.skipUnless(zlib, 'requires zlib')\n\n_can_symlink = None\n\n\ndef can_symlink():\n    global _can_symlink\n    if _can_symlink is not None:\n        return _can_symlink\n    fd, TESTFN = tempfile.mkstemp()\n    os.close(fd)\n    os.remove(TESTFN)\n    symlink_path = TESTFN + \"can_symlink\"\n    try:\n        os.symlink(TESTFN, symlink_path)\n        can = True\n    except (OSError, NotImplementedError, AttributeError):\n        can = False\n    else:\n        os.remove(symlink_path)\n    _can_symlink = can\n    return can\n\n\ndef skip_unless_symlink(test):\n    \"\"\"Skip decorator for tests that require functional symlink\"\"\"\n    ok = can_symlink()\n    msg = \"Requires functional symlink implementation\"\n    return test if ok else unittest.skip(msg)(test)\n\n\ndef fake_dec(*args, **kw):\n    \"\"\"Fake decorator\"\"\"\n\n    def _wrap(func):\n\n        def __wrap(*args, **kw):\n            return func(*args, **kw)\n\n        return __wrap\n\n    return _wrap\n\n\ndef in_github_workflow():\n    return 'GITHUB_WORKFLOW' in os.environ\n\n\nSEP = '-' * 80\n\n\nclass DistlibTestCase(unittest.TestCase):\n\n    def setUp(self):\n        logger.debug(SEP)\n        logger.debug(self.id().rsplit('.', 1)[-1])\n        logger.debug(SEP)\n", "tests/test_markers.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"Tests for distlib.markers.\"\"\"\nimport os\nimport sys\nimport platform\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib.compat import python_implementation\nfrom distlib.markers import interpret\nfrom distlib.util import in_venv\n\n\nclass MarkersTestCase(DistlibTestCase):\n\n    def test_interpret(self):\n        sys_platform = sys.platform\n        version = sys.version.split()[0]\n        os_name = os.name\n        platform_version = platform.version()\n        platform_machine = platform.machine()\n        platform_python_implementation = python_implementation()\n\n        self.assertTrue(interpret(\"sys_platform == '%s'\" % sys_platform))\n        self.assertTrue(interpret(\"sys_platform == '%s' and python_full_version == '%s'\" % (sys_platform, version)))\n        self.assertTrue(interpret(\"'%s' == sys_platform\" % sys_platform))\n        self.assertTrue(interpret('os_name == \"%s\"' % os_name))\n        self.assertTrue(\n            interpret('platform_version == \"%s\" and platform_machine == \"%s\"' % (platform_version, platform_machine)))\n        self.assertTrue(interpret('platform_python_implementation == \"%s\"' % platform_python_implementation))\n\n        self.assertTrue(interpret('platform_in_venv == \"%s\"' % in_venv()))\n\n        # stuff that need to raise a syntax error\n        ops = ('os_name == 2', \"'2' == '2'\", 'okpjonon', '', 'os_name ==', 'python_version == 2.4')\n        for op in ops:\n            self.assertRaises(SyntaxError, interpret, op)\n\n        # combined operations\n        OP = 'os_name == \"%s\"' % os_name\n        FALSEOP = 'os_name == \"buuuu\"'\n        AND = ' and '\n        OR = ' or '\n        self.assertTrue(interpret(OP + AND + OP))\n        self.assertTrue(interpret(OP + AND + OP + AND + OP))\n        self.assertTrue(interpret(OP + OR + OP))\n        self.assertTrue(interpret(OP + OR + FALSEOP))\n        self.assertTrue(interpret(OP + OR + OP + OR + FALSEOP))\n        self.assertTrue(interpret(OP + OR + FALSEOP + OR + FALSEOP))\n        self.assertTrue(interpret(FALSEOP + OR + OP))\n        self.assertFalse(interpret(FALSEOP + AND + FALSEOP))\n        self.assertFalse(interpret(FALSEOP + OR + FALSEOP))\n\n        # other operators\n        self.assertTrue(interpret(\"os_name != 'buuuu'\"))\n        self.assertTrue(interpret(\"python_version > '1.0'\"))\n        self.assertTrue(interpret(\"python_version < '5.0'\"))\n        self.assertTrue(interpret(\"python_version <= '5.0'\"))\n        self.assertTrue(interpret(\"python_version >= '1.0'\"))\n        if sys.version_info < (3, 10):\n            self.assertTrue(interpret('python_version < \"3.10\"'))\n            self.assertFalse(interpret('python_version >= \"3.10\"'))\n        if sys.version_info >= (3, 10):\n            self.assertFalse(interpret('python_version < \"3.10\"'))\n            self.assertTrue(interpret('python_version >= \"3.10\"'))\n        self.assertTrue(interpret(\"'%s' in os_name\" % os_name))\n        self.assertTrue(interpret(\"'buuuu' not in os_name\"))\n        self.assertTrue(interpret(\"'buu' in os_name\", {'os_name': 'buuu'}))\n        self.assertTrue(interpret(\"'buuuu' not in os_name and '%s' in os_name\" % os_name))\n\n        # normalized version comparison correctness\n        self.assertTrue(interpret('python_version > \"5.0\"', {'python_version': '10.0'}))\n        self.assertTrue(interpret('python_version == \"5.0\"', {'python_version': '5.0'}))\n        self.assertTrue(interpret('python_version < \"5.0\"', {'python_version': '5.0b0'}))\n        self.assertTrue(interpret('python_full_version > \"5.0\"', {'python_full_version': '10.0'}))\n\n        # execution context\n        self.assertTrue(interpret('python_version == \"0.1\"', {'python_version': '0.1'}))\n\n        # parentheses and extra\n        if sys.platform != 'win32':\n            relop = '!='\n        else:\n            relop = '=='\n        expression = (\"(sys_platform %s 'win32' or python_version == '2.4') \"\n                      \"and extra == 'quux'\" % relop)\n        self.assertTrue(interpret(expression, {'extra': 'quux'}))\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/test_database.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nimport base64\nimport io\nimport os\nimport hashlib\nimport logging\nimport random\nimport re\nimport shutil\nimport sys\nimport tempfile\n\nfrom compat import unittest\n\nfrom distlib import DistlibException\nfrom distlib.compat import text_type, StringIO\nfrom distlib.metadata import Metadata, METADATA_FILENAME, LEGACY_METADATA_FILENAME\nfrom distlib.database import (InstalledDistribution, EggInfoDistribution, BaseInstalledDistribution, EXPORTS_FILENAME,\n                              DistributionPath, make_graph, get_required_dists, get_dependent_dists)\nfrom distlib.util import get_resources_dests, CSVReader, read_exports\n\nfrom test_util import GlobTestCaseBase\nfrom support import LoggingCatcher, requires_zlib, DistlibTestCase\n\nlogger = logging.getLogger(__name__)\n\n# TODO Add a test for getting a distribution provided by another distribution\n# TODO Add a test for absolute path RECORD items (e.g. /etc/myapp/config.ini)\n# TODO Add tests from the former pep376 project (zipped site-packages, etc.)\n\n\nclass FakeDistsMixin(object):\n\n    def setUp(self):\n        super(FakeDistsMixin, self).setUp()\n\n        # make a copy that we can write into for our fake installed\n        # distributions\n        tmpdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, tmpdir)\n        self.fake_dists_path = os.path.realpath(os.path.join(tmpdir, 'fake_dists'))\n        fake_dists_src = os.path.abspath(os.path.join(os.path.dirname(__file__), 'fake_dists'))\n        shutil.copytree(fake_dists_src, self.fake_dists_path)\n        # XXX ugly workaround: revert copystat calls done by shutil behind our\n        # back (to avoid getting a read-only copy of a read-only file).  we\n        # could pass a custom copy_function to change the mode of files, but\n        # shutil gives no control over the mode of directories :(\n        # see http://bugs.python.org/issue1666318\n        for root, dirs, files in os.walk(self.fake_dists_path):\n            os.chmod(root, 0o755)\n            for f in files:\n                os.chmod(os.path.join(root, f), 0o644)\n            for d in dirs:\n                os.chmod(os.path.join(root, d), 0o755)\n\n\nclass CommonDistributionTests(FakeDistsMixin):\n    \"\"\"Mixin used to test the interface common to InstalledDistribution\n    and EggInfoDistribution classes.\n\n    Derived classes define cls, sample_dist, dirs and records.  These\n    attributes are used in test methods.  See source code for details.\n    \"\"\"\n\n    def _get_dist_path(self, distdir):\n        here = os.path.abspath(os.path.dirname(__file__))\n        return os.path.join(here, 'fake_dists', distdir)\n\n    def test_instantiation(self):\n        # check that useful attributes are here\n        name, version, distdir = self.sample_dist\n        dist_path = self._get_dist_path(distdir)\n        dist = self.dist = self.cls(dist_path)\n        self.assertEqual(dist.path, dist_path)\n        self.assertEqual(dist.name, name)\n        self.assertEqual(dist.metadata.name, name)\n        self.assertIsInstance(dist.metadata, Metadata)\n        self.assertEqual(dist.version, version)\n        self.assertEqual(dist.metadata.version, version)\n\n    @requires_zlib\n    def test_repr(self):\n        dist = self.cls(self.dirs[0])\n        # just check that the class name is in the repr\n        self.assertIn(self.cls.__name__, repr(dist))\n\n    @requires_zlib\n    def test_str(self):\n        name, version, distdir = self.sample_dist\n        dist = self.cls(self._get_dist_path(distdir))\n        self.assertEqual(name, dist.name)\n        # Sanity test: dist.name is unicode,\n        # but str output contains no u prefix.\n        self.assertIsInstance(dist.name, text_type)\n        self.assertEqual(version, dist.version)\n        self.assertEqual(str(dist), self.expected_str_output)\n\n    @requires_zlib\n    def test_comparison(self):\n        # tests for __eq__ and __hash__\n        dist = self.cls(self.dirs[0])\n        dist2 = self.cls(self.dirs[0])\n        dist3 = self.cls(self.dirs[1])\n        self.assertIn(dist, {dist: True})\n        self.assertEqual(dist, dist)\n\n        self.assertIsNot(dist, dist2)\n        self.assertEqual(dist, dist2)\n        self.assertNotEqual(dist, dist3)\n        self.assertNotEqual(dist, ())\n\n    def test_list_installed_files(self):\n        for dir_ in self.dirs:\n            dist = self.cls(dir_)\n            for path, hash, size in dist.list_installed_files():\n                record_data = self.records[dist.path]\n                self.assertIn(path, record_data)\n                self.assertEqual(hash, record_data[path][0])\n                self.assertEqual(size, record_data[path][1])\n\n    def test_hash(self):\n        datalen = random.randrange(0, 500)\n        data = os.urandom(datalen)\n        for dir_ in self.dirs:\n            dist = self.cls(dir_)\n            for hasher in ('sha1', 'sha224', 'sha384', 'sha256', 'sha512', None):\n                dist.hasher = hasher\n                actual = dist.get_hash(data)\n                if hasher is None:\n                    digester = hashlib.md5(data)\n                else:\n                    digester = getattr(hashlib, hasher)(data)\n                digest = digester.digest()\n                digest = base64.urlsafe_b64encode(digest).rstrip(b'=')\n                digest = digest.decode('ascii')\n                if hasher is None:\n                    expected = digest\n                else:\n                    expected = '%s=%s' % (hasher, digest)\n                self.assertEqual(actual, expected)\n\n\nclass TestDistribution(CommonDistributionTests, DistlibTestCase):\n\n    cls = InstalledDistribution\n    sample_dist = 'choxie', '2.0.0.9', 'choxie-2.0.0.9.dist-info'\n    expected_str_output = 'choxie 2.0.0.9'\n\n    def setUp(self):\n\n        def get_files(location):\n            for path in ('REQUESTED', 'INSTALLER', LEGACY_METADATA_FILENAME, METADATA_FILENAME, EXPORTS_FILENAME):\n                p = os.path.join(location + '.dist-info', path)\n                if os.path.exists(p):\n                    yield p\n            for path, dirs, files in os.walk(location):\n                for f in files:\n                    yield os.path.join(path, f)\n\n        super(TestDistribution, self).setUp()\n        self.dirs = [\n            os.path.join(self.fake_dists_path, f) for f in os.listdir(self.fake_dists_path) if f.endswith('.dist-info')\n        ]\n\n        self.records = {}\n        for distinfo_dir in self.dirs:\n            dist_location = distinfo_dir.replace('.dist-info', '')\n            record_file = os.path.join(distinfo_dir, 'RECORD')\n\n            # Write the files using write_installed_files.\n            # list_installed_files should read and match.\n            dist = self.cls(distinfo_dir)\n            prefix = os.path.dirname(dist_location)\n            dist.write_installed_files(get_files(dist_location), prefix)\n\n            with CSVReader(path=record_file) as record_reader:\n                record_data = {}\n                for row in record_reader:\n                    if row == []:\n                        continue\n                    path, hash, size = (row[:] + [None for i in range(len(row), 3)])\n                    record_data[path] = hash, size\n            self.records[distinfo_dir] = record_data\n\n    def test_instantiation(self):\n        super(TestDistribution, self).test_instantiation()\n        self.assertIsInstance(self.dist.requested, bool)\n\n    def test_get_distinfo_file(self):\n        # Test the retrieval of dist-info file objects.\n        distinfo_name = 'choxie-2.0.0.9'\n        other_distinfo_name = 'grammar-1.0a4'\n        distinfo_dir = os.path.join(self.fake_dists_path, distinfo_name + '.dist-info')\n        dist = InstalledDistribution(distinfo_dir)\n        # Test for known good file matches\n        distinfo_files = [\n            # Relative paths\n            'INSTALLER',\n            METADATA_FILENAME,\n            # Absolute paths\n            os.path.join(distinfo_dir, 'RECORD'),\n            os.path.join(distinfo_dir, 'REQUESTED'),\n        ]\n\n        for distfile in distinfo_files:\n            value = dist.get_distinfo_file(distfile)\n            self.assertTrue(os.path.isfile(value))\n            self.assertEqual(value, os.path.join(distinfo_dir, distfile))\n\n        # Test an absolute path that is part of another distributions dist-info\n        other_distinfo_file = os.path.join(self.fake_dists_path, other_distinfo_name + '.dist-info', 'REQUESTED')\n        self.assertRaises(DistlibException, dist.get_distinfo_file, other_distinfo_file)\n        # Test for a file that should not exist\n        self.assertRaises(DistlibException, dist.get_distinfo_file, 'MAGICFILE')\n\n    def test_list_distinfo_files(self):\n        distinfo_name = 'towel_stuff-0.1'\n        distinfo_dir = os.path.join(self.fake_dists_path, distinfo_name + '.dist-info')\n        dist = InstalledDistribution(distinfo_dir)\n        # Test for the iteration of the raw path\n        distinfo_files = [os.path.join(distinfo_dir, filename) for filename in os.listdir(distinfo_dir)]\n        found = list(dist.list_distinfo_files())\n        base = self.fake_dists_path\n        for i, p in enumerate(found):\n            if not os.path.isabs(p):\n                found[i] = os.path.join(base, p)\n        self.assertEqual(sorted(found), sorted(distinfo_files))\n        # Test for the iteration of local absolute paths\n        distinfo_files = [os.path.join(sys.prefix, distinfo_dir, path) for path in distinfo_files]\n        found = sorted(dist.list_distinfo_files())\n        if os.sep != '/':\n            self.assertNotIn('/', found[0])\n            self.assertIn(os.sep, found[0])\n        self.assertEqual(found, sorted(distinfo_files))\n\n    def test_get_resources_path(self):\n        distinfo_name = 'babar-0.1'\n        distinfo_dir = os.path.join(self.fake_dists_path, distinfo_name + '.dist-info')\n        dist = InstalledDistribution(distinfo_dir)\n        resource_path = dist.get_resource_path('babar.png')\n        self.assertEqual(resource_path, 'babar.png')\n        self.assertRaises(KeyError, dist.get_resource_path, 'notexist')\n\n    def test_check_installed_files(self):\n        for dir_ in self.dirs:\n            dist = self.cls(dir_)\n            mismatches = dist.check_installed_files()\n            self.assertEqual(mismatches, [])\n            # pick a non-empty file at random and change its contents\n            # but not its size. Check the failure returned,\n            # then restore the file.\n            files = [f for f in dist.list_installed_files() if f[-1] not in ('', '0')]\n            bad_file = random.choice(files)\n            bad_file_name = bad_file[0]\n            if not os.path.isabs(bad_file_name):\n                base = os.path.dirname(dir_)\n                bad_file_name = os.path.join(base, bad_file_name)\n            with open(bad_file_name, 'rb') as f:\n                data = f.read()\n            bad_data = bytes(bytearray(reversed(data)))\n            bad_hash = dist.get_hash(bad_data)\n            with open(bad_file_name, 'wb') as f:\n                f.write(bad_data)\n            mismatches = dist.check_installed_files()\n            self.assertEqual(mismatches, [(bad_file_name, 'hash', bad_file[1], bad_hash)])\n            # now truncate the file by one byte and see what's returned\n            with open(bad_file_name, 'wb') as f:\n                f.write(bad_data[:-1])\n            bad_size = str(len(bad_data) - 1)\n            mismatches = dist.check_installed_files()\n            self.assertEqual(mismatches, [(bad_file_name, 'size', bad_file[2], bad_size)])\n\n            # now remove the file and see what's returned\n            os.remove(bad_file_name)\n            mismatches = dist.check_installed_files()\n            self.assertEqual(mismatches, [(bad_file_name, 'exists', True, False)])\n\n            # restore the file\n            with open(bad_file_name, 'wb') as f:\n                f.write(data)\n\n\nclass TestEggInfoDistribution(CommonDistributionTests, LoggingCatcher, DistlibTestCase):\n\n    cls = EggInfoDistribution\n    sample_dist = 'bacon', '0.1', 'bacon-0.1.egg-info'\n    expected_str_output = 'bacon 0.1'\n\n    def setUp(self):\n        super(TestEggInfoDistribution, self).setUp()\n\n        self.dirs = [\n            os.path.join(self.fake_dists_path, f) for f in os.listdir(self.fake_dists_path)\n            if f.endswith('.egg') or f.endswith('.egg-info')\n        ]\n\n        self.records = {}\n        for egginfo_dir in self.dirs:\n            # dist_location = egginfo_dir.replace('.egg-info', '')\n            record_file = os.path.join(egginfo_dir, 'installed-files.txt')\n\n            # dist = self.cls(egginfo_dir)\n            # prefix = os.path.dirname(dist_location)\n            # dist.write_installed_files(get_files(dist_location), prefix)\n\n            record_data = {}\n            if os.path.exists(record_file):\n                with open(record_file) as fp:\n                    for line in fp:\n                        line = line.strip()\n                        if line == './':\n                            break\n                        record_data[line] = None, None\n            self.records[egginfo_dir] = record_data\n\n    @unittest.skip('not implemented yet')\n    def test_list_installed_files(self):\n        # EggInfoDistribution defines list_installed_files but there is no\n        # test for it yet; someone needs to add a file with the list of\n        # installed files for one of the egg fake dists and write the support\n        # code to populate self.records (and then delete this method)\n        pass\n\n\nclass TestDatabase(LoggingCatcher, FakeDistsMixin, DistlibTestCase):\n\n    def setUp(self):\n        super(TestDatabase, self).setUp()\n        sys.path.insert(0, self.fake_dists_path)\n        self.addCleanup(sys.path.remove, self.fake_dists_path)\n\n    def test_caches(self):\n        # sanity check for internal caches\n        d = DistributionPath()\n        for name in ('_cache', '_cache_egg'):\n            self.assertEqual(getattr(d, name).name, {})\n            self.assertEqual(getattr(d, name).path, {})\n\n    def test_distinfo_dirname(self):\n        # Given a name and a version, we expect the distinfo_dirname function\n        # to return a standard distribution information directory name.\n\n        items = [\n            # (name, version, standard_dirname)\n            # Test for a very simple single word name and decimal version\n            # number\n            ('docutils', '0.5', 'docutils-0.5.dist-info'),\n            # Test for another except this time with a '-' in the name, which\n            # needs to be transformed during the name lookup\n            ('python-ldap', '2.5', 'python_ldap-2.5.dist-info'),\n            # Test for both '-' in the name and a funky version number\n            ('python-ldap', '2.5 a---5', 'python_ldap-2.5 a---5.dist-info'),\n        ]\n\n        # Loop through the items to validate the results\n        for name, version, standard_dirname in items:\n            dirname = DistributionPath.distinfo_dirname(name, version)\n            self.assertEqual(dirname, standard_dirname)\n\n    @requires_zlib\n    def test_get_distributions(self):\n        # Lookup all distributions found in the ``sys.path``.\n        # This test could potentially pick up other installed distributions\n        non_egg_dists = [('grammar', '1.0a4'), ('choxie', '2.0.0.9'), ('towel-stuff', '0.1'), ('babar', '0.1')]\n        egg_dists = [('bacon', '0.1'), ('cheese', '2.0.2'), ('coconuts-aster', '10.3'), ('banana', '0.4'),\n                     ('strawberry', '0.6'), ('truffles', '5.0'), ('nut', 'funkyversion')]\n\n        all_dists = non_egg_dists + egg_dists\n\n        d = DistributionPath()\n        ed = DistributionPath(include_egg=True)\n\n        cases = ((d, non_egg_dists, InstalledDistribution), (ed, all_dists, BaseInstalledDistribution))\n\n        fake_dists_path = self.fake_dists_path\n        for enabled in (True, False):\n            if not enabled:\n                d.cache_enabled = False\n                ed.cache_enabled = False\n                d.clear_cache()\n                ed.clear_cache()\n\n            for distset, fake_dists, allowed_class in cases:\n                found_dists = []\n\n                # Verify the fake dists have been found.\n                dists = list(distset.get_distributions())\n                for dist in dists:\n                    self.assertIsInstance(dist, allowed_class)\n                    if (dist.name in dict(fake_dists) and dist.path.startswith(fake_dists_path)):\n                        found_dists.append((dist.name, dist.version))\n                    else:\n                        # check that it doesn't find anything more than this\n                        self.assertFalse(dist.path.startswith(fake_dists_path))\n                    # otherwise we don't care what other dists are found\n\n                # Finally, test that we found all that we were looking for\n                self.assertEqual(sorted(found_dists), sorted(fake_dists))\n\n    @requires_zlib\n    def test_get_distribution(self):\n        # Test for looking up a distribution by name.\n        # Test the lookup of the towel-stuff distribution\n        name = 'towel-stuff'  # Note: This is different from the directory name\n\n        d = DistributionPath()\n        ed = DistributionPath(include_egg=True)\n\n        # Lookup the distribution\n        dist = d.get_distribution(name)\n        self.assertIsInstance(dist, InstalledDistribution)\n        self.assertEqual(dist.name, name)\n\n        # Verify that an unknown distribution returns None\n        self.assertIsNone(d.get_distribution('bogus'))\n\n        # Verify partial name matching doesn't work\n        self.assertIsNone(d.get_distribution('towel'))\n\n        # Verify that it does not find egg-info distributions, when not\n        # instructed to\n        self.assertIsNone(d.get_distribution('bacon'))\n        self.assertIsNone(d.get_distribution('cheese'))\n        self.assertIsNone(d.get_distribution('strawberry'))\n        self.assertIsNone(d.get_distribution('banana'))\n\n        # Now check that it works well in both situations, when egg-info\n        # is a file and directory respectively.\n\n        for name in ('cheese', 'bacon', 'banana', 'strawberry'):\n            dist = ed.get_distribution(name)\n            self.assertIsInstance(dist, EggInfoDistribution)\n            self.assertEqual(dist.name, name)\n\n    @requires_zlib\n    def test_provides(self):\n        # Test for looking up distributions by what they provide\n        checkLists = lambda x, y: self.assertEqual(sorted(x), sorted(y))\n\n        d = DistributionPath()\n        ed = DistributionPath(include_egg=True)\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles')]\n        checkLists(test_list, ['choxie', 'towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '1.0')]\n        checkLists(test_list, ['choxie', 'towel-stuff'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('truffles', '1.0')]\n        checkLists(test_list, ['choxie', 'cheese', 'towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '1.1.2')]\n        checkLists(test_list, ['towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '1.1')]\n        checkLists(test_list, ['towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '!=1.1,<=2.0')]\n        checkLists(test_list, ['choxie', 'towel-stuff'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('truffles', '!=1.1,<=2.0')]\n        checkLists(test_list, ['choxie', 'bacon', 'cheese', 'towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '>1.0')]\n        checkLists(test_list, ['towel-stuff'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '>1.5')]\n        checkLists(test_list, [])\n\n        test_list = [dist.name for dist in ed.provides_distribution('truffles', '>1.5')]\n        checkLists(test_list, ['bacon', 'truffles'])\n\n        test_list = [dist.name for dist in d.provides_distribution('truffles', '>=1.0')]\n        checkLists(test_list, ['choxie', 'towel-stuff'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('strawberry', '0.6')]\n        checkLists(test_list, ['coconuts-aster', 'strawberry'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('strawberry', '>=0.5')]\n        checkLists(test_list, ['coconuts-aster', 'strawberry'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('strawberry', '>0.6')]\n        checkLists(test_list, [])\n\n        test_list = [dist.name for dist in ed.provides_distribution('banana', '0.4')]\n        checkLists(test_list, ['banana', 'coconuts-aster'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('banana', '>=0.3')]\n        checkLists(test_list, ['banana', 'coconuts-aster'])\n\n        test_list = [dist.name for dist in ed.provides_distribution('banana', '!=0.4')]\n        checkLists(test_list, [])\n\n    @requires_zlib\n    def test_yield_distribution(self):\n        # tests the internal function _yield_distributions\n        checkLists = lambda x, y: self.assertEqual(sorted(x), sorted(y))\n\n        eggs = [('bacon', '0.1'), ('banana', '0.4'), ('strawberry', '0.6'), ('truffles', '5.0'), ('cheese', '2.0.2'),\n                ('coconuts-aster', '10.3'), ('nut', 'funkyversion')]\n        dists = [('choxie', '2.0.0.9'), ('grammar', '1.0a4'), ('towel-stuff', '0.1'), ('babar', '0.1')]\n\n        d = DistributionPath(include_egg=False)\n        d._include_dist = False\n        checkLists([], d._yield_distributions())\n\n        d = DistributionPath(include_egg=True)\n        d._include_dist = False\n        found = [(dist.name, dist.version) for dist in d._yield_distributions()\n                 if dist.path.startswith(self.fake_dists_path)]\n        checkLists(eggs, found)\n\n        d = DistributionPath()\n        found = [(dist.name, dist.version) for dist in d._yield_distributions()\n                 if dist.path.startswith(self.fake_dists_path)]\n        checkLists(dists, found)\n\n        d = DistributionPath(include_egg=True)\n        found = [(dist.name, dist.version) for dist in d._yield_distributions()\n                 if dist.path.startswith(self.fake_dists_path)]\n        checkLists(dists + eggs, found)\n\n    def check_entry(self, entry, name, prefix, suffix, flags):\n        self.assertEqual(entry.name, name)\n        self.assertEqual(entry.prefix, prefix)\n        self.assertEqual(entry.suffix, suffix)\n        self.assertEqual(entry.flags, flags)\n\n    def test_read_exports(self):\n        d = DistributionPath().get_distribution('babar')\n        r = d.exports\n        self.assertIn('foo', r)\n        d = r['foo']\n        self.assertIn('bar', d)\n        self.check_entry(d['bar'], 'bar', 'baz', 'barbaz', ['a=10', 'b'])\n        self.assertIn('bar.baz', r)\n        d = r['bar.baz']\n        self.assertIn('foofoo', d)\n        self.check_entry(d['foofoo'], 'foofoo', 'baz.foo', 'bazbar', [])\n        self.assertIn('real', d)\n        e = d['real']\n        self.check_entry(e, 'real', 'cgi', 'print_directory', [])\n        if sys.version_info[:2] < (3, 12):\n            import cgi\n            self.assertIs(e.value, cgi.print_directory)\n\n        # See issue #78. Test reading an entry_points.txt with leading spaces\n\n        TEST_EXPORTS = b\"\"\"\n        [paste.server_runner]\n        main = waitress:serve_paste\n        [console_scripts]\n        waitress-serve = waitress.runner:run\n        \"\"\"\n        with io.BytesIO(TEST_EXPORTS) as f:\n            exports = read_exports(f)\n        self.assertEqual(set(exports.keys()), set(['paste.server_runner', 'console_scripts']))\n\n    def test_exports_iteration(self):\n        d = DistributionPath()\n        expected = set((\n            ('bar', 'baz', 'barbaz', ('a=10', 'b')),\n            ('bar', 'crunchie', None, ()),\n            ('bar', 'towel', 'towel', ()),\n            ('baz', 'towel', 'beach_towel', ()),\n        ))\n        entries = list(d.get_exported_entries('foo'))\n        for e in entries:\n            t = e.name, e.prefix, e.suffix, tuple(e.flags)\n            self.assertIn(t, expected)\n            expected.remove(t)\n        self.assertFalse(expected)  # nothing left\n        expected = set((\n            ('bar', 'baz', 'barbaz', ('a=10', 'b')),\n            ('bar', 'crunchie', None, ()),\n            ('bar', 'towel', 'towel', ()),\n        ))\n        entries = list(d.get_exported_entries('foo', 'bar'))\n        for e in entries:\n            t = e.name, e.prefix, e.suffix, tuple(e.flags)\n            self.assertIn(t, expected)\n            expected.remove(t)\n        self.assertFalse(expected)  # nothing left\n\n        expected = set((\n            ('foofoo', 'baz.foo', 'bazbar', ()),\n            ('real', 'cgi', 'print_directory', ()),\n            ('foofoo', 'ferrero', 'rocher', ()),\n            ('foobar', 'hoopy', 'frood', ('dent', )),\n        ))\n        entries = list(d.get_exported_entries('bar.baz'))\n        for e in entries:\n            t = e.name, e.prefix, e.suffix, tuple(e.flags)\n            self.assertIn(t, expected)\n            expected.remove(t)\n        self.assertFalse(expected)  # nothing left\n\n    def test_modules(self):\n        dp = DistributionPath(include_egg=True)\n        dist = dp.get_distribution('banana')\n        self.assertIsInstance(dist, EggInfoDistribution)\n        self.assertEqual(dist.modules, ['banana', 'cavendish'])\n\n\nclass DataFilesTestCase(GlobTestCaseBase):\n\n    def assertRulesMatch(self, rules, spec):\n        tempdir = self.build_files_tree(spec)\n        expected = self.clean_tree(spec)\n        result = get_resources_dests(tempdir, rules)\n        self.assertEqual(expected, result)\n\n    def clean_tree(self, spec):\n        files = {}\n        for path, value in spec.items():\n            if value is not None:\n                files[path] = value\n        return files\n\n    def test_simple_glob(self):\n        rules = [('', '*.tpl', '{data}')]\n        spec = {'coucou.tpl': '{data}/coucou.tpl', 'Donotwant': None}\n        self.assertRulesMatch(rules, spec)\n\n    def test_multiple_match(self):\n        rules = [('scripts', '*.bin', '{appdata}'), ('scripts', '*', '{appscript}')]\n        spec = {'scripts/script.bin': '{appscript}/script.bin', 'Babarlikestrawberry': None}\n        self.assertRulesMatch(rules, spec)\n\n    def test_set_match(self):\n        rules = [('scripts', '*.{bin,sh}', '{appscript}')]\n        spec = {\n            'scripts/script.bin': '{appscript}/script.bin',\n            'scripts/babar.sh': '{appscript}/babar.sh',\n            'Babarlikestrawberry': None\n        }\n        self.assertRulesMatch(rules, spec)\n\n    def test_set_match_multiple(self):\n        rules = [('scripts', 'script{s,}.{bin,sh}', '{appscript}')]\n        spec = {\n            'scripts/scripts.bin': '{appscript}/scripts.bin',\n            'scripts/script.sh': '{appscript}/script.sh',\n            'Babarlikestrawberry': None\n        }\n        self.assertRulesMatch(rules, spec)\n\n    def test_set_match_exclude(self):\n        rules = [('scripts', '*', '{appscript}'), ('', os.path.join('**', '*.sh'), None)]\n        spec = {\n            'scripts/scripts.bin': '{appscript}/scripts.bin',\n            'scripts/script.sh': None,\n            'Babarlikestrawberry': None\n        }\n        self.assertRulesMatch(rules, spec)\n\n    def test_glob_in_base(self):\n        rules = [('scrip*', '*.bin', '{appscript}')]\n        spec = {\n            'scripts/scripts.bin': '{appscript}/scripts.bin',\n            'scripouille/babar.bin': '{appscript}/babar.bin',\n            'scriptortu/lotus.bin': '{appscript}/lotus.bin',\n            'Babarlikestrawberry': None\n        }\n        self.assertRulesMatch(rules, spec)\n\n    def test_recursive_glob(self):\n        rules = [('', os.path.join('**', '*.bin'), '{binary}')]\n        spec = {\n            'binary0.bin': '{binary}/binary0.bin',\n            'scripts/binary1.bin': '{binary}/scripts/binary1.bin',\n            'scripts/bin/binary2.bin': '{binary}/scripts/bin/binary2.bin',\n            'you/kill/pandabear.guy': None\n        }\n        self.assertRulesMatch(rules, spec)\n\n    def test_final_example_glob(self):\n        rules = [\n            ('mailman/database/schemas/', '*', '{appdata}/schemas'),\n            ('', os.path.join('**', '*.tpl'), '{appdata}/templates'),\n            ('', os.path.join('developer-docs', '**', '*.txt'), '{doc}'),\n            ('', 'README', '{doc}'),\n            ('mailman/etc/', '*', '{config}'),\n            ('mailman/foo/', os.path.join('**', 'bar', '*.cfg'), '{config}/baz'),\n            ('mailman/foo/', os.path.join('**', '*.cfg'), '{config}/hmm'),\n            ('', 'some-new-semantic.sns', '{funky-crazy-category}'),\n        ]\n        spec = {\n            'README': '{doc}/README',\n            'some.tpl': '{appdata}/templates/some.tpl',\n            'some-new-semantic.sns': '{funky-crazy-category}/some-new-semantic.sns',\n            'mailman/database/mailman.db': None,\n            'mailman/database/schemas/blah.schema': '{appdata}/schemas/blah.schema',\n            'mailman/etc/my.cnf': '{config}/my.cnf',\n            'mailman/foo/some/path/bar/my.cfg': '{config}/hmm/some/path/bar/my.cfg',\n            'mailman/foo/some/path/other.cfg': '{config}/hmm/some/path/other.cfg',\n            'developer-docs/index.txt': '{doc}/developer-docs/index.txt',\n            'developer-docs/api/toc.txt': '{doc}/developer-docs/api/toc.txt',\n        }\n        self.maxDiff = None\n        self.assertRulesMatch(rules, spec)\n\n    def test_get_file(self):\n        # Create a fake dist\n        temp_site_packages = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, temp_site_packages)\n\n        dist_name = 'test'\n        dist_info = os.path.join(temp_site_packages, 'test-0.1.dist-info')\n        os.mkdir(dist_info)\n\n        metadata_path = os.path.join(dist_info, 'pydist.json')\n        resources_path = os.path.join(dist_info, 'RESOURCES')\n        md = Metadata()\n        md.name = 'test'\n        md.version = '0.1'\n        md.summary = 'test'\n        md.write(path=metadata_path)\n        test_path = 'test.cfg'\n\n        fd, test_resource_path = tempfile.mkstemp()\n        os.close(fd)\n        self.addCleanup(os.remove, test_resource_path)\n\n        fp = open(test_resource_path, 'w')\n        try:\n            fp.write('Config')\n        finally:\n            fp.close()\n\n        fp = open(resources_path, 'w')\n        try:\n            fp.write('%s,%s' % (test_path, test_resource_path))\n        finally:\n            fp.close()\n\n        # Add fake site-packages to sys.path to retrieve fake dist\n        self.addCleanup(sys.path.remove, temp_site_packages)\n        sys.path.insert(0, temp_site_packages)\n\n        # Try to retrieve resources paths and files\n        d = DistributionPath()\n        self.assertEqual(d.get_file_path(dist_name, test_path), test_resource_path)\n        self.assertRaises(KeyError, d.get_file_path, dist_name, 'i-dont-exist')\n\n\nclass DepGraphTestCase(LoggingCatcher, DistlibTestCase):\n\n    DISTROS_DIST = ('choxie', 'grammar', 'towel-stuff')\n    DISTROS_EGG = ('bacon', 'banana', 'strawberry', 'cheese')\n    BAD_EGGS = ('nut', )\n\n    EDGE = re.compile(r'\"(?P<from>.*)\" -> \"(?P<to>.*)\" \\[label=\"(?P<label>.*)\"\\]')\n\n    def checkLists(self, l1, l2):\n        \"\"\" Compare two lists without taking the order into consideration \"\"\"\n        self.assertListEqual(sorted(l1), sorted(l2))\n\n    def setUp(self):\n        super(DepGraphTestCase, self).setUp()\n        path = os.path.join(os.path.dirname(__file__), 'fake_dists')\n        path = os.path.abspath(path)\n        sys.path.insert(0, path)\n        self.addCleanup(sys.path.remove, path)\n\n    def get_dists(self, names, include_egg=False):\n        dists = []\n        d = DistributionPath(include_egg=include_egg)\n        for name in names:\n            dist = d.get_distribution(name)\n            self.assertNotEqual(dist, None)\n            dists.append(dist)\n        return dists\n\n    def test_make_graph(self):\n        dists = self.get_dists(self.DISTROS_DIST)\n\n        choxie, grammar, towel = dists\n\n        graph = make_graph(dists)\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[choxie]]\n        self.checkLists([('towel-stuff', 'towel-stuff (0.1)')], deps)\n        self.assertIn(choxie, graph.reverse_list[towel])\n        self.checkLists(graph.missing[choxie], ['nut'])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[grammar]]\n        self.checkLists([], deps)\n        self.checkLists(graph.missing[grammar], ['truffles (>=1.2)'])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[towel]]\n        self.checkLists([], deps)\n        self.checkLists(graph.missing[towel], ['bacon (<=0.2)'])\n\n    @requires_zlib\n    def test_make_graph_egg(self):\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG, True)\n\n        choxie, grammar, towel, bacon, banana, strawberry, cheese = dists\n\n        graph = make_graph(dists)\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[choxie]]\n        self.checkLists([('towel-stuff', 'towel-stuff (0.1)')], deps)\n        self.assertIn(choxie, graph.reverse_list[towel])\n        self.checkLists(graph.missing[choxie], ['nut'])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[grammar]]\n        self.checkLists([('bacon', 'truffles (>=1.2)')], deps)\n        self.checkLists(graph.missing.get(grammar, []), [])\n        self.assertIn(grammar, graph.reverse_list[bacon])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[towel]]\n        self.checkLists([('bacon', 'bacon (<=0.2)')], deps)\n        self.checkLists(graph.missing.get(towel, []), [])\n        self.assertIn(towel, graph.reverse_list[bacon])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[bacon]]\n        self.checkLists([], deps)\n        self.checkLists(graph.missing.get(bacon, []), [])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[banana]]\n        self.checkLists([('strawberry', 'strawberry (>=0.5)')], deps)\n        self.checkLists(graph.missing.get(banana, []), [])\n        self.assertIn(banana, graph.reverse_list[strawberry])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[strawberry]]\n        self.checkLists([], deps)\n        self.checkLists(graph.missing.get(strawberry, []), [])\n\n        deps = [(x.name, y) for x, y in graph.adjacency_list[cheese]]\n        self.checkLists([], deps)\n        self.checkLists(graph.missing.get(cheese, []), [])\n\n    def test_dependent_dists(self):\n        # import pdb; pdb.set_trace()\n        dists = self.get_dists(self.DISTROS_DIST)\n\n        choxie, grammar, towel = dists\n\n        deps = [d.name for d in get_dependent_dists(dists, choxie)]\n        self.checkLists([], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, grammar)]\n        self.checkLists([], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, towel)]\n        self.checkLists(['choxie'], deps)\n\n    def test_required_dists(self):\n        dists = self.get_dists(self.DISTROS_DIST + ('truffles', 'bacon', 'banana', 'coconuts-aster'), True)\n\n        choxie, grammar, towel, truffles, bacon, banana, coco = dists\n\n        reqs = [d.name for d in get_required_dists(dists, choxie)]\n        self.checkLists(['bacon', 'towel-stuff'], reqs)\n\n        reqs = [d.name for d in get_required_dists(dists, grammar)]\n        self.checkLists(['truffles'], reqs)\n\n        reqs = [d.name for d in get_required_dists(dists, banana)]\n        self.checkLists(['coconuts-aster'], reqs)\n\n        reqs = [d.name for d in get_required_dists(dists, towel)]\n        self.checkLists(['bacon'], reqs)\n\n        # Check the invalid case: pass a dist not in the list\n        dists = dists[:-1]\n        self.assertRaises(DistlibException, get_required_dists, dists, coco)\n\n    @requires_zlib\n    def test_dependent_dists_egg(self):\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG, True)\n\n        choxie, grammar, towel, bacon, banana, strawberry, cheese = dists\n\n        deps = [d.name for d in get_dependent_dists(dists, choxie)]\n        self.checkLists([], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, grammar)]\n        self.checkLists([], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, towel)]\n        self.checkLists(['choxie'], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, bacon)]\n        self.checkLists(['choxie', 'towel-stuff', 'grammar'], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, strawberry)]\n        self.checkLists(['banana'], deps)\n\n        deps = [d.name for d in get_dependent_dists(dists, cheese)]\n        self.checkLists([], deps)\n\n        # Check the invalid case: pass a dist not in the list\n        dists = dists[:-1]\n        self.assertRaises(DistlibException, get_dependent_dists, dists, cheese)\n\n    @requires_zlib\n    def test_graph_to_dot(self):\n        expected = (\n            ('towel-stuff', 'bacon', 'bacon (<=0.2)'),\n            ('grammar', 'bacon', 'truffles (>=1.2)'),\n            ('choxie', 'towel-stuff', 'towel-stuff (0.1)'),\n            ('banana', 'strawberry', 'strawberry (>=0.5)'),\n        )\n\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG, True)\n\n        graph = make_graph(dists)\n        buf = StringIO()\n        graph.to_dot(buf)\n        buf.seek(0)\n        matches = []\n        lines = buf.readlines()\n        for line in lines[1:-1]:  # skip the first and the last lines\n            if line[-1] == '\\n':\n                line = line[:-1]\n            match = self.EDGE.match(line.strip())\n            self.assertIsNot(match, None)\n            matches.append(match.groups())\n\n        self.checkLists(matches, expected)\n\n    @requires_zlib\n    def test_graph_disconnected_to_dot(self):\n        dependencies_expected = (\n            ('towel-stuff', 'bacon', 'bacon (<=0.2)'),\n            ('grammar', 'bacon', 'truffles (>=1.2)'),\n            ('choxie', 'towel-stuff', 'towel-stuff (0.1)'),\n            ('banana', 'strawberry', 'strawberry (>=0.5)'),\n        )\n        disconnected_expected = ('cheese', 'bacon', 'strawberry')\n\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG, True)\n\n        graph = make_graph(dists)\n        buf = StringIO()\n        graph.to_dot(buf, skip_disconnected=False)\n        buf.seek(0)\n        lines = buf.readlines()\n\n        dependencies_lines = []\n        disconnected_lines = []\n\n        # First sort output lines into dependencies and disconnected lines.\n        # We also skip the attribute lines, and don't include the \"{\" and \"}\"\n        # lines.\n        disconnected_active = False\n        for line in lines[1:-1]:  # Skip first and last line\n            if line.startswith('subgraph disconnected'):\n                disconnected_active = True\n                continue\n            if line.startswith('}') and disconnected_active:\n                disconnected_active = False\n                continue\n\n            if disconnected_active:\n                # Skip the 'label = \"Disconnected\"', etc. attribute lines.\n                if ' = ' not in line:\n                    disconnected_lines.append(line)\n            else:\n                dependencies_lines.append(line)\n\n        dependencies_matches = []\n        for line in dependencies_lines:\n            if line[-1] == '\\n':\n                line = line[:-1]\n            match = self.EDGE.match(line.strip())\n            self.assertIsNot(match, None)\n            dependencies_matches.append(match.groups())\n\n        disconnected_matches = []\n        for line in disconnected_lines:\n            if line[-1] == '\\n':\n                line = line[:-1]\n            line = line.strip('\"')\n            disconnected_matches.append(line)\n\n        self.checkLists(dependencies_matches, dependencies_expected)\n        self.checkLists(disconnected_matches, disconnected_expected)\n\n    @requires_zlib\n    def test_graph_bad_version_to_dot(self):\n        expected = (\n            ('towel-stuff', 'bacon', 'bacon (<=0.2)'),\n            ('grammar', 'bacon', 'truffles (>=1.2)'),\n            ('choxie', 'towel-stuff', 'towel-stuff (0.1)'),\n            ('banana', 'strawberry', 'strawberry (>=0.5)'),\n        )\n\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG + self.BAD_EGGS, True)\n\n        graph = make_graph(dists)\n        buf = StringIO()\n        graph.to_dot(buf)\n        buf.seek(0)\n        matches = []\n        lines = buf.readlines()\n        for line in lines[1:-1]:  # skip the first and the last lines\n            if line[-1] == '\\n':\n                line = line[:-1]\n            match = self.EDGE.match(line.strip())\n            self.assertIsNot(match, None)\n            matches.append(match.groups())\n\n        self.checkLists(matches, expected)\n\n    @requires_zlib\n    def test_repr(self):\n        dists = self.get_dists(self.DISTROS_DIST + self.DISTROS_EGG + self.BAD_EGGS, True)\n\n        graph = make_graph(dists)\n        self.assertTrue(repr(graph))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    load = unittest.defaultTestLoader.loadTestsFromTestCase\n    suite.addTest(load(TestDistribution))\n    suite.addTest(load(TestEggInfoDistribution))\n    suite.addTest(load(TestDatabase))\n    suite.addTest(load(DataFilesTestCase))\n    suite.addTest(load(DepGraphTestCase))\n    return suite\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    unittest.main(defaultTest='test_suite')\n", "tests/distlib_tests.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport sys\n\n_ver = sys.version_info[:2]\n\nfrom test_database import (DataFilesTestCase, TestDatabase, TestDistribution, TestEggInfoDistribution, DepGraphTestCase)\nfrom test_index import PackageIndexTestCase\nfrom test_locators import LocatorTestCase\nfrom test_manifest import ManifestTestCase\nfrom test_markers import MarkersTestCase\nfrom test_metadata import MetadataTestCase, LegacyMetadataTestCase\nfrom test_resources import (ZipResourceTestCase, FileResourceTestCase, CacheTestCase)\nfrom test_scripts import ScriptTestCase\nfrom test_version import (VersionTestCase, CompatibilityTestCase, LegacyVersionTestCase, SemanticVersionTestCase)\nfrom test_wheel import WheelTestCase\n\nfrom test_util import (UtilTestCase, ProgressTestCase, FileOpsTestCase, GlobTestCase)\n", "tests/test_version.py": "#\n# Copyright (C) 2012-2023 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"Tests for distlib.version.\"\"\"\nimport doctest\nimport sys\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib.version import (NormalizedVersion as NV, NormalizedMatcher as NM, UnsupportedVersionError,\n                             _suggest_normalized_version, _suggest_semantic_version, LegacyVersion as LV, LegacyMatcher\n                             as LM, SemanticVersion as SV, SemanticMatcher as SM, is_semver, get_scheme,\n                             _normalized_key, _legacy_key, _semantic_key)\n\n\nclass VersionTestCase(DistlibTestCase):\n\n    versions = (\n        (NV('1.0'), '1.0'),\n        (NV('1.1'), '1.1'),\n        (NV('1.2.3'), '1.2.3'),\n        (NV('1.2'), '1.2'),\n        (NV('1.2.3a4'), '1.2.3a4'),\n        (NV('1.2c4'), '1.2c4'),\n        (NV('4.17rc2'), '4.17rc2'),\n        (NV('1.2.3.4'), '1.2.3.4'),\n        # (NV('1.2.3.4.0b3', drop_trailing_zeros=True), '1.2.3.4b3'),\n        # (NV('1.2.0.0.0', drop_trailing_zeros=True), '1.2'),\n        (NV('1.0.dev345'), '1.0.dev345'),\n        (NV('1.0.post456.dev623'), '1.0.post456.dev623'),\n        (NV('1.2.3+1.2'), '1.2.3+1.2'),\n        (NV('1.2.3+a1.b2'), '1.2.3+a1.b2'),\n    )\n\n    def test_repr(self):\n        self.assertEqual(repr(NV('1.0')), \"NormalizedVersion('1.0')\")\n\n    def test_basic_versions(self):\n        for v, s in self.versions:\n            self.assertEqual(str(v), s)\n\n    def test_hash(self):\n        for v, s in self.versions:\n            self.assertEqual(hash(v), hash(NV(s)))\n\n        versions = set([v for v, s in self.versions])\n        for v, s in self.versions:\n            self.assertIn(v, versions)\n\n        self.assertEqual(set([NV('1.0')]), set([NV('1.0'), NV('1.0')]))\n\n    def test_unsupported_versions(self):\n        unsupported = (\n            # '1.2a', '1.2.3b',  # see issue 200 - not unsupported\n            # '1.02', '1.2a03', '1.2a3.04',\n            '1.2.dev.2',\n            # '1.2dev', '1.2.dev',  # see issue 200 - these are not unsupported\n            '1.2-',\n            '1.2-a',\n            '1.2.dev2.post2',\n            '1.2.post2.dev3.post4')\n\n        for s in unsupported:\n            with self.assertRaises(UnsupportedVersionError):\n                NV(s)\n                # print(s)\n                # import pdb; pdb.set_trace()\n\n    def test_huge_version(self):\n        self.assertEqual(str(NV('1980.0')), '1980.0')\n\n    def test_comparison(self):\n        comparison_doctest_string = r\"\"\"\n        >>> NV('1.2.0') == '1.2'\n        Traceback (most recent call last):\n        ...\n        TypeError: cannot compare NormalizedVersion and str\n\n        >>> NV('1.2') < '1.3'\n        Traceback (most recent call last):\n        ...\n        TypeError: cannot compare NormalizedVersion and str\n\n        >>> NV('1.2.0') == NV('1.2')\n        True\n        >>> NV('1.2.0') == NV('1.2.3')\n        False\n        >>> NV('1.2.0') != NV('1.2.3')\n        True\n        >>> NV('1.2.0') < NV('1.2.3')\n        True\n        >>> NV('1.2.0') < NV('1.2.0')\n        False\n        >>> NV('1.2.0') <= NV('1.2.0')\n        True\n        >>> NV('1.2.0') <= NV('1.2.3')\n        True\n        >>> NV('1.2.3') <= NV('1.2.0')\n        False\n        >>> NV('1.2.0') >= NV('1.2.0')\n        True\n        >>> NV('1.2.3') >= NV('1.2.0')\n        True\n        >>> NV('1.2.0') >= NV('1.2.3')\n        False\n        >>> NV('1.2.0rc1') >= NV('1.2.0')\n        False\n        >>> NV('1.0') > NV('1.0b2')\n        True\n        >>> NV('1.0') > NV('1.0c2')\n        True\n        >>> NV('1.0') > NV('1.0rc2')\n        True\n        >>> NV('1.0rc2') > NV('1.0rc1')\n        True\n        >>> NV('1.0c4') > NV('1.0c1')\n        True\n        >>> (NV('1.0') > NV('1.0c2') > NV('1.0c1') > NV('1.0b2') > NV('1.0b1')\n        ...  > NV('1.0a2') > NV('1.0a1'))\n        True\n        >>> (NV('1.0.0') > NV('1.0.0c2') > NV('1.0.0c1') > NV('1.0.0b2') > NV('1.0.0b1')\n        ...  > NV('1.0.0a2') > NV('1.0.0a1'))\n        True\n\n        >>> NV('1.0') < NV('1.0.post456.dev623')\n        True\n\n        >>> NV('1.0.post456.dev623') < NV('1.0.post456')  < NV('1.0.post1234')\n        True\n\n        >>> (NV('1.0a1')\n        ...  < NV('1.0a2.dev456')\n        ...  < NV('1.0a2')\n        ...  < NV('1.0a2.1.dev456')  # e.g. need to do a quick post release on 1.0a2\n        ...  < NV('1.0a2.1')\n        ...  < NV('1.0b1.dev456')\n        ...  < NV('1.0b2')\n        ...  < NV('1.0c1.dev456')\n        ...  < NV('1.0c1')\n        ...  < NV('1.0c1-1')\n        ...  < NV('1.0c1-1.1')\n        ...  < NV('1.0.dev7')\n        ...  < NV('1.0.dev18')\n        ...  < NV('1.0.dev456')\n        ...  < NV('1.0.dev1234')\n        ...  < NV('1.0rc1')\n        ...  < NV('1.0rc2')\n        ...  < NV('1.0')\n        ...  < NV('1.0-1')\n        ...  < NV('1.0-1.1')\n        ...  < NV('1.0.post456.dev623')  # development version of a post release\n        ...  < NV('1.0.post456.dev623-1')\n        ...  < NV('1.0.post456.dev623-1.1')\n        ...  < NV('1.0.post456')\n             < NV('1.0.post456-1')\n             < NV('1.0.post456-1.1'))\n        True\n        \"\"\"\n        doctest.script_from_examples(comparison_doctest_string)\n\n        # the doctest above is never run, so temporarily add real unit\n        # tests until the doctest is rewritten\n        self.assertLessEqual(NV('1.2.0rc1'), NV('1.2.0'))\n        self.assertGreater(NV('1.0'), NV('1.0c2'))\n        self.assertGreater(NV('1.0'), NV('1.0rc2'))\n        self.assertGreater(NV('1.0rc2'), NV('1.0rc1'))\n        self.assertGreater(NV('1.0c4'), NV('1.0c1'))\n        self.assertGreater(NV('2014.04'), NV('2013.10'))\n        self.assertGreater(NV('1!1.1'), NV('2014.04'))\n        self.assertGreater(NV('1!2.0'), NV('1!1.1'))\n\n    def test_suggest_normalized_version(self):\n        suggest = _suggest_normalized_version\n        self.assertEqual(suggest('1.0'), '1.0')\n        self.assertEqual(suggest('1.0-alpha1'), '1.0a1')\n        self.assertEqual(suggest('1.0c2'), '1.0c2')\n        self.assertEqual(suggest('walla walla washington'), None)\n        self.assertEqual(suggest('2.4c1'), '2.4c1')\n        self.assertEqual(suggest('v1.0'), 'v1.0')\n\n        # from setuptools\n        # self.assertEqual(suggest('0.4a1.r10'), '0.4a1.post10')  # see issue #200\n        self.assertEqual(suggest('0.7a1dev-r66608'), '0.7a1.dev66608')\n        self.assertEqual(suggest('0.6a9.dev-r41475'), '0.6a9.dev41475')\n        # self.assertEqual(suggest('2.4preview1'), '2.4c1')  # see issue #200\n        # self.assertEqual(suggest('2.4pre1'), '2.4c1')  # see issue #200\n        self.assertEqual(suggest('2.1-rc2'), '2.1c2')\n\n        # from pypi\n        # self.assertEqual(suggest('0.1dev'), '0.1.dev0')   # see issue 200 - 0.1dev is now rational\n        # self.assertEqual(suggest('0.1.dev'), '0.1.dev0')  # see issue 200 - 0.1.dev is now rational\n\n        # we want to be able to parse Twisted\n        # development versions are like post releases in Twisted\n        # self.assertEqual(suggest('9.0.0+r2363'), '9.0.0.post2363')\n\n        # pre-releases are using markers like \"pre1\"\n        # self.assertEqual(suggest('9.0.0pre1'), '9.0.0c1')  # see issue #200\n\n        # we want to be able to parse Tcl-TK\n        # they us \"p1\" \"p2\" for post releases\n        self.assertEqual(suggest('1.4p1'), '1.4.post1')\n\n    def test_suggestions_other(self):\n        suggest = _suggest_semantic_version\n        self.assertEqual(suggest(''), '0.0.0')\n        self.assertEqual(suggest('1'), '1.0.0')\n        self.assertEqual(suggest('1.2'), '1.2.0')\n\n    def test_matcher(self):\n        # NormalizedMatcher knows how to parse stuff like:\n        #\n        #   Project (>=version, ver2)\n\n        constraints = ('zope.interface (>3.5.0)', 'AnotherProject (3.4)', 'OtherProject (<3.0)', 'NoVersion',\n                       'Hey (>=2.5,<2.7)')\n\n        for constraint in constraints:\n            NM(constraint)\n\n        self.assertTrue(NM('Hey (>=2.5,<2.7)').match('2.6'))\n        self.assertTrue(NM('Ho').match('2.6'))\n        self.assertFalse(NM('Hey (>=2.5,!=2.6,<2.7)').match('2.6'))\n        self.assertTrue(NM('Ho (<3.0)').match('2.6'))\n        self.assertTrue(NM('Ho (<3.0,!=2.5)').match('2.6.0'))\n        self.assertFalse(NM('Ho (<3.0,!=2.6)').match('2.6.0'))\n        self.assertTrue(NM('Ho (2.5)').match('2.5.4'))\n        self.assertFalse(NM('Ho (==2.5)').match('2.50'))\n        self.assertTrue(NM('Ho (!=2.5)').match('2.5.2'))\n        self.assertFalse(NM('Hey (<=2.5)').match('2.5.9'))\n        self.assertFalse(NM('Hey (<=2.5)').match('2.6.0'))\n        self.assertTrue(NM('Hey (>=2.5)').match('2.5.1'))\n\n        self.assertRaises(ValueError, NM, '')\n\n        # We don't allow\n        # self.assertTrue(NM('Hey 2.5').match('2.5.1'))\n        # self.assertTrue(NM('vi5two 1.0').match('1.0'))\n        # self.assertTrue(NM('5two 1.0').match('1.0'))\n\n        self.assertTrue(NM('Ho (<3.0,!=2.6)').match('2.6.3'))\n\n        # Make sure a constraint that ends with a number works\n        self.assertTrue(NM('virtualenv5 (1.0)').match('1.0'))\n        self.assertTrue(NM('virtualenv5').match('1.0'))\n        self.assertTrue(NM('vi5two').match('1.0'))\n        self.assertTrue(NM('5two').match('1.0'))\n\n        # test repr\n        for constraint in constraints:\n            self.assertEqual(str(NM(constraint)), constraint)\n\n        # Test exact_version\n        cases = (\n            ('Dummy', False),\n            ('Dummy (1.0)', False),\n            ('Dummy (<1.0)', False),\n            ('Dummy (<=1.0)', False),\n            ('Dummy (>1.0)', False),\n            ('Dummy (>=1.0)', False),\n            ('Dummy (==1.0)', True),\n            ('Dummy (===1.0)', True),\n            ('Dummy (!=1.0)', False),\n        )\n\n        for s, b in cases:\n            m = NM(s)\n            self.assertEqual(m.exact_version is not None, b)\n\n    def test_matcher_name(self):\n        # Test that names are parsed the right way\n\n        self.assertEqual('Hey', NM('Hey (<1.1)').name)\n        self.assertEqual('9Hey', NM('9Hey (1.1)').name)\n        self.assertEqual('Foo-Bar', NM('Foo-Bar (1.1)').name)\n        self.assertEqual('Foo_Bar', NM('Foo_Bar (1.1)').name)\n        self.assertEqual('Foo.Bar', NM('Foo.Bar (1.1)').name)\n\n    def test_matcher_local(self):\n        self.assertTrue(NM('Foo (>=2.5+1.2)').match('2.6.0+1.3'))\n        self.assertFalse(NM('Foo (>=2.6+1.4)').match('2.6.0+1.3'))\n        self.assertTrue(NM('Foo (>=2.6)').match('2.6+1.3'))\n        # numeric > lexicographic in local versions\n        self.assertTrue(NM('Foo (>2.6+a1.4)').match('2.6+1.4'))\n\n    def test_schemes(self):\n        cases = (\n            ('normalized', (_normalized_key, NV, NM)),\n            ('legacy', (_legacy_key, LV, LM)),\n            ('semantic', (_semantic_key, SV, SM)),\n        )\n\n        for name, values in cases:\n            scheme = get_scheme(name)\n            key, version, matcher = values\n            self.assertIs(key, scheme.key)\n            self.assertIs(matcher, scheme.matcher)\n            self.assertIs(version, scheme.matcher.version_class)\n\n        self.assertIs(get_scheme('default'), get_scheme('normalized'))\n\n        self.assertRaises(ValueError, get_scheme, 'random')\n\n    def test_prereleases(self):\n        pre_releases = (\n            '1.0.dev456',\n            '1.0a1',\n            '1.0a2.dev456',\n            '1.0a12.dev456',\n            '1.0a12',\n            '1.0b1.dev456',\n            '1.0b2',\n            '1.0b2.post345.dev456',\n            '1.0b2.post345',\n            '1.0c1.dev456',\n            '1.0c1',\n            '1.0rc1',\n            '1.0.post345.dev456',\n            '1.1.dev1',\n            '1.1.dev1+1.2',\n        )\n        final_releases = (\n            '1.0',\n            '1.0.post345',\n            '1.0.post345+2.3',\n        )\n        for s in pre_releases:\n            self.assertTrue(NV(s).is_prerelease)\n        for s in final_releases:\n            self.assertFalse(NV(s).is_prerelease)\n\n    def test_comparison_pep440(self):\n        versions = (\n            '1.0.dev456',\n            '1.0a1',\n            '1.0a2.dev456',\n            '1.0a12.dev456',\n            '1.0a12',\n            '1.0b1.dev456',\n            '1.0b2',\n            '1.0b2.post345.dev456',\n            '1.0b2.post345',\n            '1.0c1.dev456',\n            '1.0c1',\n            '1.0rc1',\n            '1.0',\n            '1.0.post345.dev456',\n            '1.0.post345',\n            '1.1.dev1',\n        )\n\n        n = len(versions)\n        for i in range(n - 1):\n            v1 = versions[i]\n            v2 = versions[i + 1]\n            self.assertLess(NV(v1), NV(v2))\n\n    def test_440(self):\n        # compatible release matching\n        for s in ('foo (1.2)', 'foo (~= 1.2)'):\n            m = NM(s)\n            for should_match in ('1.2', '1.3', '1.2.post0'):\n                msg = 'Failed for %s' % should_match\n                self.assertTrue(m.match(should_match), msg)\n            for should_not_match in ('1.0', '1.1', '1.2.dev0', '2.0'):\n                msg = 'Failed for %s' % should_not_match\n                self.assertFalse(m.match(should_not_match), msg)\n        for s in ('foo (1.4.5)', 'foo (~= 1.4.5)', 'foo (1.4.5a4)'):\n            m = NM(s)\n            for should_match in ('1.4.5', '1.4.6', '1.4.7.dev0'):\n                msg = 'Failed for %s' % should_match\n                self.assertTrue(m.match(should_match), msg)\n            for should_not_match in ('1.5', '1.6', '1.4.5.dev0', '2.4.5'):\n                msg = 'Failed for %s' % should_not_match\n                self.assertFalse(m.match(should_not_match), msg)\n        m = NM('foo (1.4.5.0)')\n        for should_match in ('1.4.5.0', '1.4.5.1', '1.4.5.9.post1'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('1.4.6', '1.5', '2.0'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n\n        # prefix matching\n        v = '1.1.post1'\n        cases = (('(== 1.1)', False), ('(== 1.1.post1)', True), ('(== 1.1.*)', True), ('(!= 1.1)', True),\n                 ('(!= 1.1.post1)', False), ('(!= 1.1.*)', False))\n        for s, expected in cases:\n            m = NM('foo %s' % s)\n            actual = m.match(v)\n            self.assertEqual(expected, actual, 'Failed for %s' % s)\n\n        # inclusive ordered\n        m = NM('foo (<= 1.5)')\n        for should_match in ('0.1', '1.4', '1.4.9.post1', '1.5.dev0', '1.5', '1.5.0', '1.5.0.0'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('1.5.post1', '1.5.post0.dev0', '1.6', '2.0'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n        m = NM('foo (>= 1.5)')\n        for should_match in ('1.5.post1', '1.5.post0.dev0', '1.6', '2.0', '1.5', '1.5.0', '1.5.0.0'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('0.1', '1.4', '1.4.9.post1', '1.5.dev0'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n\n        # exclusive ordered\n        m = NM('foo (< 1.5)')\n        for should_match in ('0.1', '1.4', '1.4.9.post1'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('1.5.post1', '1.5.post0.dev0', '1.5.dev0', '1.5', '1.5.0', '1.5.0.1', '1.6', '2.0'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n        m = NM('foo (> 1.5)')\n        for should_match in ('1.6', '2.0'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('0.1', '1.4', '1.4.9.post1', '1.5.dev0', '1.5', '1.5.0', '1.5.post0', '1.5.post0.dev0',\n                                 '1.5.0.1'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n\n        # unusual prefix matching\n        m = NM('foo (== 1.2.post0.*)')\n        for should_match in ('1.2.post0', '1.2.post0.dev0'):\n            msg = 'Failed for %s' % should_match\n            self.assertTrue(m.match(should_match), msg)\n        for should_not_match in ('1.2', '1.2.dev0'):\n            msg = 'Failed for %s' % should_not_match\n            self.assertFalse(m.match(should_not_match), msg)\n\n        # invalid\n        for op in ('<', '<=', '>', '>=', '~='):\n            s = 'foo (%s 1.*)' % op\n            self.assertRaises(ValueError, NM, s)\n        for v in ('', '1.*.*'):\n            s = 'foo (== %s)' % v\n            self.assertRaises((SyntaxError, ValueError), NM, s)\n\n    def test_fix_200(self):\n        versions = (('foo<=0.8.1dev', '0.8.1.dev0'), )\n\n        for v1, v2 in versions:\n            # import pdb; pdb.set_trace()\n            NM(v1).match(v2)\n\n\nclass LegacyVersionTestCase(DistlibTestCase):\n    # These tests are the same as distribute's\n    def test_equality(self):\n\n        def compare(a, b):\n            ka, kb = _legacy_key(a), _legacy_key(b)\n            self.assertEqual(ka, kb)\n\n        compare('0.4', '0.4.0')\n        compare('0.4.0.0', '0.4.0')\n        compare('0.4.0-0', '0.4-0')\n        compare('0pl1', '0.0pl1')\n        compare('0pre1', '0.0c1')\n        compare('0.0.0preview1', '0c1')\n        compare('0.0c1', '0rc1')\n        compare('1.2a1', '1.2.a.1')\n        compare('1.2...a', '1.2a')\n\n    def test_ordering(self):\n\n        def compare(a, b):\n            ka, kb = _legacy_key(a), _legacy_key(b)\n            self.assertLess(ka, kb)\n\n        compare('2.1', '2.1.1')\n        compare('2.1.0', '2.10')\n        compare('2a1', '2b0')\n        compare('2b1', '2c0')\n        compare('2a1', '2.1')\n        compare('2.3a1', '2.3')\n        compare('2.1-1', '2.1-2')\n        compare('2.1-1', '2.1.1')\n        compare('2.1', '2.1.1-1')\n        compare('2.1', '2.1pl4')\n        compare('2.1a0-20040501', '2.1')\n        compare('1.1', '02.1')\n        compare('A56', 'B27')\n        compare('3.2', '3.2.pl0')\n        compare('3.2-1', '3.2pl1')\n        compare('3.2pl1', '3.2pl1-1')\n        compare('0.4', '4.0')\n        compare('0.0.4', '0.4.0')\n        compare('0pl1', '0.4pl1')\n        compare('2.1dev', '2.1a0')\n        compare('2.1.0rc1', '2.1.0')\n        compare('2.1.0-rc0', '2.1.0')\n        compare('2.1.0-a', '2.1.0')\n        compare('2.1.0-alpha', '2.1.0')\n        compare('2.1.0', '2.1.0-foo')\n        compare('1.0', '1.0-1')\n        compare('1.0-1', '1.0.1')\n        compare('1.0a', '1.0b')\n        compare('1.0dev', '1.0rc1')\n        compare('1.0pre', '1.0')\n        compare('1.0pre', '1.0')\n\n        versions = \"\"\"\n        0.80.1-3 0.80.1-2 0.80.1-1 0.79.9999+0.80.0pre4-1\n        0.79.9999+0.80.0pre2-3 0.79.9999+0.80.0pre2-2\n        0.77.2-1 0.77.1-1 0.77.0-1\n        \"\"\".split()\n\n        for i, v1 in enumerate(versions):\n            for v2 in versions[i + 1:]:\n                compare(v2, v1)\n\n    def test_absolute(self):\n        cases = (('1.0-beta6', ('00000001', '*beta', '00000006', '*final')), )\n        for k, v in cases:\n            self.assertEqual(_legacy_key(k), v)\n\n    def test_prereleases(self):\n        pre_releases = (\n            '2.1.0-alpha',\n            '0.79.9999+0.80.0pre4-1',\n            '1.0dev',\n            '2.1a0',\n            '1.0rc1',\n            'A56',\n            '1.0b',\n            '0.79.9999+0.80.0',\n            '2013b',\n            '2013f',\n        )\n        final_releases = (\n            '0.80.1-3',\n            '2.1.0',\n            '3.2pl1-1',\n        )\n        for s in pre_releases:\n            self.assertTrue(LV(s).is_prerelease, s)\n        for s in final_releases:\n            self.assertFalse(LV(s).is_prerelease, s)\n\n\nclass SemanticVersionTestCase(DistlibTestCase):\n\n    def test_basic(self):\n        bad = [\n            'a',\n            '1',\n            '1.',\n            '1.2',\n            '1.2.',\n            '1.2.a',\n            '1.2.3.a',\n        ]\n        good = [\n            '1.2.3',\n            '1.2.3-pre.1.abc.2.def',\n            '1.2.3+post.1.abc.2.def',\n            '1.2.3-pre.1.abc.2.def+post.1.abc.2.def',\n        ]\n        for s in bad:\n            self.assertFalse(is_semver(s))\n            self.assertRaises(UnsupportedVersionError, _semantic_key, s)\n\n        for s in good:\n            self.assertTrue(is_semver(s))\n\n    def test_ordering(self):\n\n        def compare(a, b):\n            ka, kb = _semantic_key(a), _semantic_key(b)\n            self.assertLess(ka, kb)\n\n        # From the semver.org home page\n        versions = (\n            '1.0.0-alpha',\n            '1.0.0-alpha.1',\n            '1.0.0-beta.2',\n            '1.0.0-beta.11',\n            '1.0.0-rc.1',\n            '1.0.0-rc.1+build.1',\n            '1.0.0',\n            '1.0.0+0.3.7',\n            '1.3.7+build',\n            '1.3.7+build.2.b8f12d7',\n            '1.3.7+build.11.e0f985a',\n        )\n\n        for i, v1 in enumerate(versions):\n            for v2 in versions[i + 1:]:\n                compare(v1, v2)\n\n    def test_prereleases(self):\n        pre_releases = (\n            '1.0.0-alpha',\n            '1.0.0-alpha.1',\n            '1.0.0-beta.2',\n            '1.0.0-beta.11',\n            '1.0.0-rc.1',\n            '1.0.0-rc.1+build.1',\n        )\n        final_releases = (\n            '1.0.0',\n            '1.0.0+0.3.7',\n            '1.3.7+build',\n            '1.3.7+build.2.b8f12d7',\n            '1.3.7+build.11.e0f985a',\n        )\n        for s in pre_releases:\n            self.assertTrue(SV(s).is_prerelease)\n        for s in final_releases:\n            self.assertFalse(SV(s).is_prerelease)\n\n\nclass CompatibilityTestCase(DistlibTestCase):\n\n    def test_basic(self):\n\n        def are_equal(v1, v2):\n            return v1 == v2\n\n        def is_less(v1, v2):\n            return v1 < v2\n\n        self.assertRaises(TypeError, are_equal, NV('3.3.0'), SV('3.3.0'))\n        self.assertRaises(TypeError, are_equal, NV('3.3.0'), LV('3.3.0'))\n        self.assertRaises(TypeError, are_equal, LV('3.3.0'), SV('3.3.0'))\n        self.assertRaises(TypeError, are_equal, NM('foo'), LV('foo'))\n        self.assertRaises(TypeError, are_equal, NM('foo'), NM('bar'))\n\n\ndef test_suite():\n    if sys.version_info[:2] < (3, 13):\n        suite = [\n            unittest.makeSuite(VersionTestCase),\n            unittest.makeSuite(CompatibilityTestCase),\n            unittest.makeSuite(LegacyVersionTestCase),\n            unittest.makeSuite(SemanticVersionTestCase)\n        ]\n    else:  # pragma: no cover\n        suite = unittest.defaultTestLoader.loadTestsFromNames(\n            ['VersionTestCase', 'CompatibilityTestCase', 'LegacyVersionTestCase', 'SemanticVersionTestCase'],\n            module=sys.modules['__main__'])\n    return unittest.TestSuite(suite)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import logging\n    import os\n\n    here = os.path.dirname(os.path.abspath(__file__))\n    rundir = os.path.join(here, 'run')\n    if not os.path.exists(rundir):\n        os.mkdir(rundir)\n    elif not os.path.isdir(rundir):\n        raise ValueError('Not a directory: %r' % rundir)\n    fn = os.path.join(rundir, 'test_version_%d.%d.log' % sys.version_info[:2])\n    logging.basicConfig(level=logging.DEBUG, filename=fn, filemode='w', format='%(name)s %(funcName)s %(message)s')\n    unittest.main(defaultTest=\"test_suite\")\n", "tests/test_metadata.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"Tests for distlib.metadata.\"\"\"\nfrom __future__ import unicode_literals\n\nimport codecs\nimport json\nimport os\nimport sys\nfrom textwrap import dedent\n\nfrom compat import unittest\n\nfrom distlib import __version__\nfrom distlib.compat import StringIO\nfrom distlib.metadata import (LegacyMetadata, Metadata, METADATA_FILENAME, LEGACY_METADATA_FILENAME,\n                              PKG_INFO_PREFERRED_VERSION, MetadataMissingError, MetadataUnrecognizedVersionError,\n                              MetadataInvalidError, _ATTR2FIELD)\n\nfrom support import LoggingCatcher, TempdirManager, DistlibTestCase, in_github_workflow\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nIN_GITHUB_WORKFLOW = in_github_workflow()\n\n\nclass LegacyMetadataTestCase(LoggingCatcher, TempdirManager, DistlibTestCase):\n\n    maxDiff = None\n    restore_environ = ['HOME']\n\n    def setUp(self):\n        super(LegacyMetadataTestCase, self).setUp()\n        self.argv = sys.argv, sys.argv[:]\n\n    def tearDown(self):\n        sys.argv = self.argv[0]\n        sys.argv[:] = self.argv[1]\n        super(LegacyMetadataTestCase, self).tearDown()\n\n    # Test various methods of the LegacyMetadata class\n\n    def get_file_contents(self, name):\n        name = os.path.join(HERE, name)\n        f = codecs.open(name, 'r', encoding='utf-8')\n        try:\n            contents = f.read() % sys.platform\n        finally:\n            f.close()\n        return contents\n\n    def test_instantiation(self):\n        PKG_INFO = os.path.join(HERE, 'PKG-INFO')\n        f = codecs.open(PKG_INFO, 'r', encoding='utf-8')\n        try:\n            contents = f.read()\n        finally:\n            f.close()\n\n        fp = StringIO(contents)\n\n        m = LegacyMetadata()\n        self.assertRaises(MetadataUnrecognizedVersionError, m.items)\n\n        m = LegacyMetadata(PKG_INFO)\n        self.assertEqual(len(m.items()), 22)\n\n        m = LegacyMetadata(fileobj=fp)\n        self.assertEqual(len(m.items()), 22)\n\n        m = LegacyMetadata(mapping=dict(name='Test', version='1.0'))\n        self.assertEqual(len(m.items()), 17)\n\n        d = dict(m.items())\n        self.assertRaises(TypeError, LegacyMetadata, PKG_INFO, fileobj=fp)\n        self.assertRaises(TypeError, LegacyMetadata, PKG_INFO, mapping=d)\n        self.assertRaises(TypeError, LegacyMetadata, fileobj=fp, mapping=d)\n        self.assertRaises(TypeError, LegacyMetadata, PKG_INFO, mapping=m, fileobj=fp)\n\n    def test_mapping_api(self):\n        content = self.get_file_contents('PKG-INFO')\n        metadata = LegacyMetadata(fileobj=StringIO(content))\n        self.assertIn('Version', metadata.keys())\n        self.assertIn('0.5', metadata.values())\n        self.assertIn(('Version', '0.5'), metadata.items())\n\n        metadata.update({'version': '0.6'})\n        self.assertEqual(metadata['Version'], '0.6')\n        metadata.update([('version', '0.7')])\n        self.assertEqual(metadata['Version'], '0.7')\n        # use a kwarg to update\n        metadata.update(version='0.6')\n        self.assertEqual(metadata['Version'], '0.6')\n\n        # make sure update method checks values like the set method does\n        metadata.update({'version': '1--2'})\n        self.assertEqual(len(self.get_logs()), 1)\n\n        self.assertEqual(list(metadata), metadata.keys())\n\n    def test_attribute_access(self):\n        content = self.get_file_contents('PKG-INFO')\n        metadata = LegacyMetadata(fileobj=StringIO(content))\n        for attr in _ATTR2FIELD:\n            self.assertEqual(getattr(metadata, attr), metadata[attr])\n\n    def test_read_metadata(self):\n        fields = {\n            'name': 'project',\n            'version': '1.0',\n            'description': 'desc',\n            'summary': 'xxx',\n            'download_url': 'http://example.com',\n            'keywords': ['one', 'two'],\n            'requires_dist': ['foo']\n        }\n\n        metadata = LegacyMetadata(mapping=fields)\n        PKG_INFO = StringIO()\n        metadata.write_file(PKG_INFO)\n        PKG_INFO.seek(0)\n\n        metadata = LegacyMetadata(fileobj=PKG_INFO)\n\n        self.assertEqual(metadata['name'], 'project')\n        self.assertEqual(metadata['version'], '1.0')\n        self.assertEqual(metadata['summary'], 'xxx')\n        self.assertEqual(metadata['download_url'], 'http://example.com')\n        self.assertEqual(metadata['keywords'], ['one', 'two'])\n        self.assertEqual(metadata['platform'], [])\n        self.assertEqual(metadata['obsoletes'], [])\n        self.assertEqual(metadata['requires-dist'], ['foo'])\n\n    def test_write_metadata(self):\n        # check support of non-ASCII values\n        tmp_dir = self.mkdtemp()\n        my_file = os.path.join(tmp_dir, 'f')\n\n        metadata = LegacyMetadata(\n            mapping={\n                'name': 'my.project',\n                'author': 'Caf\u00e9 Junior',\n                'summary': 'Caf\u00e9 torr\u00e9fi\u00e9',\n                'description': 'H\u00e9h\u00e9h\u00e9',\n                'keywords': ['caf\u00e9', 'coffee']\n            })\n        metadata.write(my_file)\n\n        # the file should use UTF-8\n        metadata2 = LegacyMetadata()\n        fp = codecs.open(my_file, encoding='utf-8')\n        try:\n            metadata2.read_file(fp)\n        finally:\n            fp.close()\n\n        # XXX when keywords are not defined, metadata will have\n        # 'Keywords': [] but metadata2 will have 'Keywords': ['']\n        # because of a value.split(',') in LegacyMetadata.get\n        self.assertEqual(metadata.items(), metadata2.items())\n\n        # ASCII also works, it's a subset of UTF-8\n        metadata = LegacyMetadata(\n            mapping={\n                # 'author': 'Mister Cafe',\n                'name': 'my.project',\n                'author': 'Cafe Junior',\n                'summary': 'Cafe torrefie',\n                'description': 'Hehehe'\n            })\n        metadata.write(my_file)\n\n        metadata2 = LegacyMetadata()\n        fp = codecs.open(my_file, encoding='utf-8')\n        try:\n            metadata2.read_file(fp)\n        finally:\n            fp.close()\n\n    def test_metadata_read_write(self):\n        PKG_INFO = os.path.join(HERE, 'PKG-INFO')\n        metadata = LegacyMetadata(PKG_INFO)\n        out = StringIO()\n        metadata.write_file(out)\n\n        out.seek(0)\n        res = LegacyMetadata()\n        res.read_file(out)\n        self.assertEqual(metadata.values(), res.values())\n\n    # Test checks\n\n    def test_check_version(self):\n        metadata = LegacyMetadata()\n        metadata['Name'] = 'vimpdb'\n        metadata['Home-page'] = 'http://pypi.org'\n        metadata['Author'] = 'Monty Python'\n        missing, warnings = metadata.check()\n        self.assertEqual(missing, ['Version'])\n\n    def test_check_version_strict(self):\n        metadata = LegacyMetadata()\n        metadata['Name'] = 'vimpdb'\n        metadata['Home-page'] = 'http://pypi.org'\n        metadata['Author'] = 'Monty Python'\n        self.assertRaises(MetadataMissingError, metadata.check, strict=True)\n\n    def test_check_name(self):\n        metadata = LegacyMetadata()\n        metadata['Version'] = '1.0'\n        metadata['Home-page'] = 'http://pypi.org'\n        metadata['Author'] = 'Monty Python'\n        missing, warnings = metadata.check()\n        self.assertEqual(missing, ['Name'])\n\n    def test_check_name_strict(self):\n        metadata = LegacyMetadata()\n        metadata['Version'] = '1.0'\n        metadata['Home-page'] = 'http://pypi.org'\n        metadata['Author'] = 'Monty Python'\n        self.assertRaises(MetadataMissingError, metadata.check, strict=True)\n\n    def test_check_author(self):\n        metadata = LegacyMetadata()\n        metadata['Version'] = '1.0'\n        metadata['Name'] = 'vimpdb'\n        metadata['Home-page'] = 'http://pypi.org'\n        missing, warnings = metadata.check()\n        self.assertEqual(missing, ['Author'])\n\n    def test_check_homepage(self):\n        metadata = LegacyMetadata()\n        metadata['Version'] = '1.0'\n        metadata['Name'] = 'vimpdb'\n        metadata['Author'] = 'Monty Python'\n        missing, warnings = metadata.check()\n        self.assertEqual(missing, ['Home-page'])\n\n    def test_check_matchers(self):\n        metadata = LegacyMetadata()\n        metadata['Version'] = 'rr'\n        metadata['Name'] = 'vimpdb'\n        metadata['Home-page'] = 'http://pypi.org'\n        metadata['Author'] = 'Monty Python'\n        metadata['Requires-dist'] = ['Foo (a)']\n        metadata['Obsoletes-dist'] = ['Foo (a)']\n        metadata['Provides-dist'] = ['Foo (a)']\n        missing, warnings = metadata.check()\n        self.assertEqual(len(warnings), 4)\n\n    # Test fields and metadata versions\n\n    def test_metadata_versions(self):\n        metadata = LegacyMetadata(mapping={'name': 'project', 'version': '1.0'})\n        self.assertEqual(metadata['Metadata-Version'], PKG_INFO_PREFERRED_VERSION)\n        self.assertNotIn('Provides', metadata)\n        self.assertNotIn('Requires', metadata)\n        self.assertNotIn('Obsoletes', metadata)\n\n        metadata['Classifier'] = ['ok']\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        metadata = LegacyMetadata()\n        metadata['Download-URL'] = 'ok'\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        metadata = LegacyMetadata()\n        metadata['Obsoletes'] = 'ok'\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        del metadata['Obsoletes']\n        metadata['Obsoletes-Dist'] = 'ok'\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.2')\n        metadata.set('Obsoletes', 'ok')\n        # See issue #140. Relaxed checking on Obsoletes\n        # self.assertRaises(MetadataConflictError,\n        # metadata.set_metadata_version)\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '2.2')\n\n        del metadata['Obsoletes']\n        del metadata['Obsoletes-Dist']\n        metadata.set_metadata_version()\n        metadata['Version'] = '1'\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        # make sure the _best_version function works okay with\n        # non-conflicting fields from 1.1 and 1.2 (i.e. we want only the\n        # requires/requires-dist and co. pairs to cause a conflict, not all\n        # fields in _314_MARKERS)\n        metadata = LegacyMetadata()\n        metadata['Requires-Python'] = '3'\n        metadata['Classifier'] = ['Programming language :: Python :: 3']\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.2')\n\n        PKG_INFO = os.path.join(HERE, 'SETUPTOOLS-PKG-INFO')\n        metadata = LegacyMetadata(PKG_INFO)\n        self.assertEqual(metadata['Metadata-Version'], '1.0')\n\n        PKG_INFO = os.path.join(HERE, 'SETUPTOOLS-PKG-INFO2')\n        metadata = LegacyMetadata(PKG_INFO)\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        # make sure an empty list for Obsoletes and Requires-dist gets ignored\n        metadata['Obsoletes'] = []\n        metadata['Requires-dist'] = []\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.1')\n\n        # Update the _fields dict directly to prevent 'Metadata-Version'\n        # from being updated by the _set_best_version() method.\n        metadata._fields['Metadata-Version'] = '1.618'\n        self.assertRaises(MetadataUnrecognizedVersionError, metadata.keys)\n\n        # add a test for 2.1\n        metadata = LegacyMetadata()\n        metadata['Description-Content-Type'] = 'text/markdown; charset=UTF-8; variant=CommonMark'\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '2.1')\n\n    def test_version(self):\n        LegacyMetadata(mapping={'author': 'xxx', 'name': 'xxx', 'version': 'xxx', 'home_page': 'xxxx'})\n        logs = self.get_logs()\n        self.assertEqual(1, len(logs))\n        self.assertIn('not a valid version', logs[0])\n\n    @unittest.skipIf(IN_GITHUB_WORKFLOW, 'This test is end-of-line dependent')\n    def test_description(self):\n        content = self.get_file_contents('PKG-INFO')\n        metadata = LegacyMetadata()\n        metadata.read_file(StringIO(content))\n\n        # see if we can read the description now\n        DESC = os.path.join(HERE, 'LONG_DESC.txt')\n        f = open(DESC)\n        try:\n            wanted = f.read()\n        finally:\n            f.close()\n        self.assertEqual(wanted, metadata['Description'])\n\n        # save the file somewhere and make sure we can read it back\n        out = StringIO()\n        metadata.write_file(out)\n        out.seek(0)\n\n        out.seek(0)\n        metadata = LegacyMetadata()\n        metadata.read_file(out)\n        self.assertEqual(wanted, metadata['Description'])\n\n    def test_description_folding(self):\n        # make sure the indentation is preserved\n        out = StringIO()\n        desc = dedent(\"\"\"\\\n        example::\n              We start here\n            and continue here\n          and end here.\n        \"\"\")\n\n        metadata = LegacyMetadata()\n        metadata['description'] = desc\n        metadata.write_file(out)\n\n        # folded_desc = desc.replace('\\n', '\\n' + (7 * ' ') + '|')\n        folded_desc = desc.replace('\\n', '\\n' + (8 * ' '))\n        self.assertIn(folded_desc, out.getvalue())\n\n    def test_project_url(self):\n        metadata = LegacyMetadata()\n        metadata['Project-URL'] = [('one', 'http://ok')]\n        self.assertEqual(metadata['Project-URL'], [('one', 'http://ok')])\n        metadata.set_metadata_version()\n        self.assertEqual(metadata['Metadata-Version'], '1.2')\n\n        # make sure this particular field is handled properly when written\n        fp = StringIO()\n        metadata.write_file(fp)\n        self.assertIn('Project-URL: one,http://ok', fp.getvalue().split('\\n'))\n\n        fp.seek(0)\n        metadata = LegacyMetadata()\n        metadata.read_file(fp)\n        self.assertEqual(metadata['Project-Url'], [('one', 'http://ok')])\n\n    # TODO copy tests for v1.1 requires, obsoletes and provides from distutils\n    # (they're useless but we support them so we should test them anyway)\n\n    def test_provides_dist(self):\n        fields = {'name': 'project', 'version': '1.0', 'provides_dist': ['project', 'my.project']}\n        metadata = LegacyMetadata(mapping=fields)\n        self.assertEqual(metadata['Provides-Dist'], ['project', 'my.project'])\n        self.assertEqual(metadata['Metadata-Version'], '1.2', metadata)\n        self.assertNotIn('Requires', metadata)\n        self.assertNotIn('Obsoletes', metadata)\n\n    def test_requires_dist(self):\n        fields = {'name': 'project', 'version': '1.0', 'requires_dist': ['other', 'another (==1.0)']}\n        metadata = LegacyMetadata(mapping=fields)\n        self.assertEqual(metadata['Requires-Dist'], ['other', 'another (==1.0)'])\n        self.assertEqual(metadata['Metadata-Version'], '1.2')\n        self.assertNotIn('Provides', metadata)\n        self.assertEqual(metadata['Requires-Dist'], ['other', 'another (==1.0)'])\n        self.assertNotIn('Obsoletes', metadata)\n\n        # make sure write_file uses one RFC 822 header per item\n        fp = StringIO()\n        metadata.write_file(fp)\n        lines = fp.getvalue().split('\\n')\n        self.assertIn('Requires-Dist: other', lines)\n        self.assertIn('Requires-Dist: another (==1.0)', lines)\n\n        # test warnings for invalid version constraints\n        # XXX this would cause no warnings if we used update (or the mapping\n        # argument of the constructor), see comment in LegacyMetadata.update\n        metadata = LegacyMetadata()\n        metadata['Requires-Dist'] = 'Funky (Groovie)'\n        metadata['Requires-Python'] = '1a-4'\n        self.assertEqual(len(self.get_logs()), 2)\n\n        # test multiple version matches\n        metadata = LegacyMetadata()\n\n        # XXX check PEP and see if 3 == 3.0\n        metadata['Requires-Python'] = '>=2.6, <3.0'\n        metadata['Requires-Dist'] = ['Foo (>=2.6, <3.0)']\n        self.assertEqual(self.get_logs(), [])\n\n    def test_obsoletes_dist(self):\n        fields = {'name': 'project', 'version': '1.0', 'obsoletes_dist': ['other', 'another (<1.0)']}\n        metadata = LegacyMetadata(mapping=fields)\n        self.assertEqual(metadata['Obsoletes-Dist'], ['other', 'another (<1.0)'])\n        self.assertEqual(metadata['Metadata-Version'], '1.2')\n        self.assertNotIn('Provides', metadata)\n        self.assertNotIn('Requires', metadata)\n        self.assertEqual(metadata['Obsoletes-Dist'], ['other', 'another (<1.0)'])\n\n    def test_fullname(self):\n        md = LegacyMetadata()\n        md['Name'] = 'a b c'\n        md['Version'] = '1 0 0'\n        s = md.get_fullname()\n        self.assertEqual(s, 'a b c-1 0 0')\n        s = md.get_fullname(True)\n        self.assertEqual(s, 'a-b-c-1.0.0')\n\n    def test_fields(self):\n        md = LegacyMetadata()\n        self.assertTrue(md.is_multi_field('Requires-Dist'))\n        self.assertFalse(md.is_multi_field('Name'))\n        self.assertTrue(md.is_field('Obsoleted-By'))\n        self.assertFalse(md.is_field('Frobozz'))\n\n\nclass MetadataTestCase(LoggingCatcher, TempdirManager, DistlibTestCase):\n\n    def test_init(self):\n        \"Test initialisation\"\n        md = Metadata()\n        self.assertIsNone(md._legacy)\n        self.assertRaises(MetadataMissingError, md.validate)\n        md.name = 'dummy'\n        self.assertRaises(MetadataMissingError, md.validate)\n        md.version = '0.1'\n        self.assertRaises(MetadataMissingError, md.validate)\n        md.summary = 'Summary'\n        md.validate()\n        self.assertEqual(md.name, 'dummy')\n        self.assertEqual(md.version, '0.1')\n\n        # Initialise from mapping\n        md = Metadata(mapping={\n            'metadata_version': '2.0',\n            'name': 'foo',\n            'version': '0.3.4',\n            'summary': 'Summary',\n        })\n        md.validate()\n        self.assertEqual(md.name, 'foo')\n        self.assertEqual(md.version, '0.3.4')\n        self.assertEqual(md.run_requires, [])\n        self.assertEqual(md.meta_requires, [])\n        self.assertEqual(md.provides, ['foo (0.3.4)'])\n\n        # Initialise from legacy metadata\n        fn = os.path.join(HERE, 'fake_dists', 'choxie-2.0.0.9.dist-info', LEGACY_METADATA_FILENAME)\n        md = Metadata(path=fn)\n        md.validate()\n        self.assertIsNotNone(md._legacy)\n        self.assertEqual(set(md.run_requires), set(['towel-stuff (0.1)', 'nut']))\n        self.assertEqual(md.metadata_version, '1.2')\n        self.assertEqual(md.version, '2.0.0.9')\n        self.assertEqual(md.meta_requires, [])\n        self.assertEqual(set(md.provides), set(['choxie (2.0.0.9)', 'truffles (1.0)']))\n\n        # Initialise from new metadata\n        fn = os.path.join(HERE, METADATA_FILENAME)\n        md = Metadata(path=fn)\n        md.validate()\n        self.assertIsNone(md._legacy)\n        self.assertEqual(md.metadata_version, '2.0')\n        self.assertEqual(md.name, 'foobar')\n        self.assertEqual(md.version, '0.1')\n        self.assertEqual(md.provides, ['foobar (0.1)'])\n\n    def test_add_requirements(self):\n        md = Metadata()\n        md.name = 'bar'\n        md.version = '0.5'\n        md.add_requirements(['foo (0.1.2)'])\n        self.assertEqual(md.run_requires, [{'requires': ['foo (0.1.2)']}])\n\n        fn = os.path.join(HERE, 'fake_dists', 'choxie-2.0.0.9.dist-info', LEGACY_METADATA_FILENAME)\n        md = Metadata(path=fn)\n        md.add_requirements(['foo (0.1.2)'])\n        self.assertEqual(set(md.run_requires), set(['towel-stuff (0.1)', 'nut', 'foo (0.1.2)']))\n\n    def test_requirements(self):\n        fn = os.path.join(HERE, METADATA_FILENAME)\n        md = Metadata(path=fn)\n        self.assertEqual(md.meta_requires, [{'requires': ['bar (1.0)']}])\n        r = md.get_requirements(md.run_requires)\n        self.assertEqual(r, ['foo'])\n        r = md.get_requirements(md.run_requires, extras=['certs'])\n        self.assertEqual(r, ['foo', 'certifi (0.0.8)'])\n        r = md.get_requirements(md.run_requires, extras=['certs', 'ssl'])\n        if sys.platform != 'win32':\n            self.assertEqual(r, ['foo', 'certifi (0.0.8)'])\n        else:\n            self.assertEqual(set(r), set(['foo', 'certifi (0.0.8)', 'wincertstore (0.1)']))\n        for ver in ('2.5', '2.4'):\n            env = {'python_version': ver}\n            r = md.get_requirements(md.run_requires, extras=['certs', 'ssl'], env=env)\n            if sys.platform != 'win32':\n                self.assertEqual(set(r), set(['foo', 'certifi (0.0.8)', 'ssl (1.16)']))\n            elif ver == '2.4':\n                self.assertEqual(set(r),\n                                 set(['certifi (0.0.8)', 'ssl (1.16)', 'wincertstore (0.1)', 'foo', 'ctypes (1.0.2)']))\n            else:\n                self.assertEqual(set(r), set(['certifi (0.0.8)', 'ssl (1.16)', 'wincertstore (0.1)', 'foo']))\n        env['sys_platform'] = 'win32'\n        r = md.get_requirements(md.run_requires, extras=['certs', 'ssl'], env=env)\n        self.assertEqual(set(r), set(['foo', 'certifi (0.0.8)', 'ssl (1.16)', 'ctypes (1.0.2)', 'wincertstore (0.1)']))\n        env['python_version'] = '2.5'\n        r = md.get_requirements(md.run_requires, extras=['certs', 'ssl'], env=env)\n        self.assertEqual(set(r), set(['foo', 'certifi (0.0.8)', 'ssl (1.16)', 'wincertstore (0.1)']))\n        r = md.get_requirements(md.run_requires, extras=[':test:'])\n        self.assertEqual(r, ['foo', 'nose'])\n        r = md.get_requirements(md.run_requires, extras=[':test:', 'udp'])\n        self.assertEqual(set(r), set(['foo', 'nose', 'nose-udp']))\n        self.assertEqual(\n            md.dependencies, {\n                'provides': ['foobar (0.1)'],\n                'meta_requires': [{\n                    'requires': ['bar (1.0)']\n                }],\n                'extras': ['ssl', 'certs'],\n                'build_requires': [],\n                'test_requires': [{\n                    'requires': ['nose'],\n                }, {\n                    'requires': ['nose-udp'],\n                    'extra': 'udp',\n                }],\n                'run_requires': [{\n                    'requires': ['foo']\n                }, {\n                    'requires': ['certifi (0.0.8)'],\n                    'extra': 'certs',\n                }, {\n                    'requires': ['wincertstore (0.1)'],\n                    'extra': 'ssl',\n                    'environment': \"sys_platform=='win32'\",\n                }, {\n                    'requires': ['ctypes (1.0.2)'],\n                    'extra': 'ssl',\n                    'environment': \"sys_platform=='win32' and \"\n                    \"python_version=='2.4'\",\n                }, {\n                    'requires': ['ssl (1.16)'],\n                    'extra': 'ssl',\n                    'environment': \"python_version in '2.4, 2.5'\",\n                }]\n            })\n\n    def test_write(self):\n        dfn = self.temp_filename()\n        # Read legacy, write new\n        sfn = os.path.join(HERE, 'fake_dists', 'choxie-2.0.0.9.dist-info', LEGACY_METADATA_FILENAME)\n        md = Metadata(path=sfn)\n        md.write(path=dfn)\n        with codecs.open(dfn, 'r', 'utf-8') as f:\n            data = json.load(f)\n        self.assertEqual(\n            data, {\n                'metadata_version': '2.0',\n                'generator': 'distlib (%s)' % __version__,\n                'name': 'choxie',\n                'version': '2.0.0.9',\n                'license': 'BSD',\n                'summary': 'Chocolate with a kick!',\n                'description': 'Chocolate with a longer kick!',\n                'provides': ['truffles (1.0)', 'choxie (2.0.0.9)'],\n                'run_requires': [{\n                    'requires': ['towel-stuff (0.1)', 'nut']\n                }],\n                'keywords': [],\n            })\n        # Write legacy, compare with original\n        md.write(path=dfn, legacy=True)\n        nmd = Metadata(path=dfn)\n        d1 = md.todict()\n        d2 = nmd.todict()\n        self.assertEqual(d1, d2)\n\n    def test_valid(self):\n        \"\"\"\n        Tests to check that missing and invalid metadata is caught.\n        \"\"\"\n        md = Metadata()\n        self.assertRaises(MetadataMissingError, md.validate)\n        try:\n            md.name = 'Foo Bar'\n        except MetadataInvalidError:\n            pass\n        md.name = 'foo_bar'\n        # Name now OK, but version and summary to be checked\n        self.assertRaises(MetadataMissingError, md.validate)\n        try:\n            md.version = '1.0a'\n        except MetadataInvalidError:\n            pass\n        md.version = '1.0'\n        # Name and version now OK, but summary to be checked\n        self.assertRaises(MetadataMissingError, md.validate)\n        try:\n            md.summary = ''\n        except MetadataInvalidError:\n            pass\n        try:\n            md.summary = ' ' * 2048\n        except MetadataInvalidError:\n            pass\n        md.summary = ' ' * 2047\n        md.validate()\n        md.summary = ' '\n        md.validate()\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/test_wheel.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nimport io\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom compat import unittest\nfrom support import DistlibTestCase\n\nfrom distlib import DistlibException\nfrom distlib.compat import ZipFile, sysconfig, fsencode\nfrom distlib.database import DistributionPath\nfrom distlib.manifest import Manifest\nfrom distlib.metadata import Metadata, METADATA_FILENAME, LEGACY_METADATA_FILENAME\nfrom distlib.scripts import ScriptMaker\nfrom distlib.util import get_executable\nfrom distlib.wheel import (Wheel, PYVER, IMPVER, ARCH, ABI, COMPATIBLE_TAGS, IMP_PREFIX, is_compatible,\n                           _get_glibc_version)\n\ntry:\n    with open(os.devnull, 'wb') as junk:\n        subprocess.check_call(['pip', '--version'], stdout=junk, stderr=subprocess.STDOUT)\n    PIP_AVAILABLE = True\nexcept Exception:\n    PIP_AVAILABLE = False\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\nEGG_INFO_RE = re.compile(r'(-py\\d\\.\\d)?\\.egg-info', re.I)\n\n\ndef pip_version():\n    result = None\n    fd, fn = tempfile.mkstemp(prefix='distlib-test-', suffix='.txt')\n    try:\n        os.close(fd)\n        with open(fn, 'wb') as out:\n            subprocess.check_call(['pip', '--version'], stdout=out, stderr=subprocess.STDOUT)\n        with io.open(fn, encoding='utf-8') as f:\n            data = f.read().split()\n        assert data[0] == 'pip'\n        parts = data[1].split('.')\n        result = []\n        for p in parts:\n            if p.isdigit():\n                result.append(int(p))\n            else:\n                result.append(p)\n        result = tuple(result)\n    finally:\n        os.remove(fn)\n    return result\n\n\ndef convert_egg_info(libdir, prefix):\n    files = os.listdir(libdir)\n    ei = list(filter(lambda d: d.endswith('.egg-info'), files))[0]\n    olddn = os.path.join(libdir, ei)\n    di = EGG_INFO_RE.sub('.dist-info', ei)\n    newdn = os.path.join(libdir, di)\n    os.rename(olddn, newdn)\n    files = os.listdir(newdn)\n    for oldfn in files:\n        pn = os.path.join(newdn, oldfn)\n        if oldfn == 'PKG-INFO':\n            md = Metadata(path=pn)\n            mn = os.path.join(newdn, METADATA_FILENAME)\n            md.write(mn)\n        os.remove(pn)\n    manifest = Manifest(os.path.dirname(libdir))\n    manifest.findall()\n    dp = DistributionPath([libdir])\n    dist = next(dp.get_distributions())\n    dist.write_installed_files(manifest.allfiles, prefix)\n\n\ndef install_dist(distname, workdir):\n    pfx = '--install-option='\n    purelib = pfx + '--install-purelib=%s/purelib' % workdir\n    platlib = pfx + '--install-platlib=%s/platlib' % workdir\n    headers = pfx + '--install-headers=%s/headers' % workdir\n    scripts = pfx + '--install-scripts=%s/scripts' % workdir\n    data = pfx + '--install-data=%s/data' % workdir\n    cmd = [\n        'pip', 'install', '--index-url', 'https://pypi.org/simple/', '--timeout', '3', '--default-timeout', '3',\n        purelib, platlib, headers, scripts, data, distname\n    ]\n    result = {\n        'scripts': os.path.join(workdir, 'scripts'),\n        'headers': os.path.join(workdir, 'headers'),\n        'data': os.path.join(workdir, 'data'),\n    }\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    stdout, _ = p.communicate()\n    if p.returncode:\n        raise ValueError('pip failed to install %s:\\n%s' % (distname, stdout))\n    for dn in ('purelib', 'platlib'):\n        libdir = os.path.join(workdir, dn)\n        if os.path.isdir(libdir):\n            result[dn] = libdir\n            break\n    convert_egg_info(libdir, workdir)\n    dp = DistributionPath([libdir])\n    dist = next(dp.get_distributions())\n    md = dist.metadata\n    result['name'] = md.name\n    result['version'] = md.version\n    return result\n\n\nclass WheelTestCase(DistlibTestCase):\n\n    def test_valid_filename(self):\n        attrs = ('name', 'version', 'buildver', 'pyver', 'abi', 'arch')\n        cases = (\n            ('pkg-1.0.0-cp32.cp33-noabi-noarch.whl', ('pkg', '1.0.0', '', ['cp32', 'cp33'], ['noabi'], ['noarch'])),\n            ('package-1.0.0-cp33-noabi-linux_x86_64.whl', ('package', '1.0.0', '', ['cp33'], ['noabi'],\n                                                           ['linux_x86_64'])),\n            ('test-1.0-1st-py2.py3-none-win32.whl', ('test', '1.0', '1st', ['py2', 'py3'], ['none'], ['win32'])),\n            ('Pillow-2.8.1-cp27-none-macosx_10_6_intel.'\n             'macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.'\n             'macosx_10_10_x86_64.whl', ('Pillow', '2.8.1', '', ['cp27'], ['none'], [\n                 'macosx_10_6_intel', 'macosx_10_9_intel', 'macosx_10_9_x86_64', 'macosx_10_10_intel',\n                 'macosx_10_10_x86_64'\n             ])),\n        )\n\n        for name, values in cases:\n            w = Wheel(name)\n            self.assertEqual(w.wheel_version, (1, 1))\n            self.assertEqual(w.filename, name)\n            for attr, value in zip(attrs, values):\n                self.assertEqual(getattr(w, attr), value)\n\n    def test_invalid_filename(self):\n        names = (\n            '',\n            'package.whl',\n            'package-1.0.0-cp32.cp33.whl',\n            'package-1.0.0-cp32.cp33.whl',\n            'package-1.0.0-cp32.cp33-noabi.whl',\n            'package-1.0.0-cp32.cp33-noabi-noarch.zip',\n        )\n\n        for name in names:\n            self.assertRaises(DistlibException, Wheel, name)\n\n    def test_valid_name(self):\n        attrs = ('name', 'version', 'buildver', 'pyver', 'abi', 'arch')\n        pyver = PYVER\n        cases = (\n            ('pkg-1.0.0', ('pkg', '1.0.0', '', [pyver], ['none'], ['any'])),\n            ('test-1.0-1st', ('test', '1.0', '1st', [pyver], ['none'], ['any'])),\n            (None, ('dummy', '0.1', '', [pyver], ['none'], ['any'])),\n        )\n\n        ENDING = '-%s-none-any.whl' % PYVER\n        for name, values in cases:\n            w = Wheel(name)\n            self.assertEqual(w.wheel_version, (1, 1))\n            self.assertTrue(w.filename.endswith(ENDING))\n            for attr, value in zip(attrs, values):\n                self.assertEqual(getattr(w, attr), value)\n\n    def test_compatible_tags(self):\n        self.assertEqual(PYVER, 'py%d%d' % sys.version_info[:2])\n        tags = COMPATIBLE_TAGS\n        self.assertIn((PYVER, 'none', 'any'), tags)\n        self.assertIn((PYVER[:-1], 'none', 'any'), tags)\n        this_arch = filter(lambda o: o[-1] == ARCH, tags)\n        self.assertTrue(this_arch)\n        if sys.platform.startswith('linux'):\n            arch = ARCH.replace('linux_', '')\n            parts = _get_glibc_version()\n            if len(parts) == 2:\n                self.assertTrue(filter(lambda o: o[-1] == 'manylinux_%s_%s_%s' % (parts[0], parts[1], arch), tags))\n                if parts >= (2, 17):\n                    self.assertTrue(filter(lambda o: o[-1] == 'manylinux2014_%s' % arch, tags))\n                if parts >= (2, 12):\n                    self.assertTrue(filter(lambda o: o[-1] == 'manylinux2010_%s' % arch, tags))\n                if parts >= (2, 5):\n                    self.assertTrue(filter(lambda o: o[-1] == 'manylinux1_%s' % arch, tags))\n\n    def test_is_compatible(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        if PYVER in ('py27', 'py30', 'py31'):\n            self.assertTrue(is_compatible(fn))\n            self.assertTrue(Wheel(fn).is_compatible())\n        # use actual wheel names from PyPI.\n        wheel_names = [\n            'simplejson-3.17.2-cp27-cp27m-macosx_10_13_x86_64.whl',\n            'simplejson-3.17.2-cp27-cp27m-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp27-cp27m-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp27-cp27m-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp27-cp27m-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp27-cp27mu-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp27-cp27mu-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp27-cp27mu-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp27-cp27mu-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp27-cp27m-win32.whl',\n            'simplejson-3.17.2-cp27-cp27m-win_amd64.whl',\n            'simplejson-3.17.2-cp33-cp33m-win32.whl',\n            'simplejson-3.17.2-cp33-cp33m-win_amd64.whl',\n            'simplejson-3.17.2-cp34-cp34m-win32.whl',\n            'simplejson-3.17.2-cp34-cp34m-win_amd64.whl',\n            'simplejson-3.17.2-cp35-cp35m-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp35-cp35m-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp35-cp35m-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp35-cp35m-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp35-cp35m-manylinux2014_aarch64.whl',\n            'simplejson-3.17.2-cp35-cp35m-win32.whl',\n            'simplejson-3.17.2-cp35-cp35m-win_amd64.whl',\n            'simplejson-3.17.2-cp36-cp36m-macosx_10_13_x86_64.whl',\n            'simplejson-3.17.2-cp36-cp36m-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp36-cp36m-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp36-cp36m-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp36-cp36m-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp36-cp36m-manylinux2014_aarch64.whl',\n            'simplejson-3.17.2-cp36-cp36m-win32.whl',\n            'simplejson-3.17.2-cp36-cp36m-win_amd64.whl',\n            'simplejson-3.17.2-cp37-cp37m-macosx_10_14_x86_64.whl',\n            'simplejson-3.17.2-cp37-cp37m-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp37-cp37m-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp37-cp37m-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp37-cp37m-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp37-cp37m-manylinux2014_aarch64.whl',\n            'simplejson-3.17.2-cp37-cp37m-win32.whl',\n            'simplejson-3.17.2-cp37-cp37m-win_amd64.whl',\n            'simplejson-3.17.2-cp38-cp38-macosx_10_14_x86_64.whl',\n            'simplejson-3.17.2-cp38-cp38-manylinux1_i686.whl',\n            'simplejson-3.17.2-cp38-cp38-manylinux1_x86_64.whl',\n            'simplejson-3.17.2-cp38-cp38-manylinux2010_i686.whl',\n            'simplejson-3.17.2-cp38-cp38-manylinux2010_x86_64.whl',\n            'simplejson-3.17.2-cp38-cp38-manylinux2014_aarch64.whl',\n            'Pillow-7.2.0-cp35-cp35m-macosx_10_10_intel.whl',\n            'Pillow-7.2.0-cp35-cp35m-manylinux1_i686.whl',\n            'Pillow-7.2.0-cp35-cp35m-manylinux1_x86_64.whl',\n            'Pillow-7.2.0-cp35-cp35m-manylinux2014_aarch64.whl',\n            'Pillow-7.2.0-cp35-cp35m-win32.whl',\n            'Pillow-7.2.0-cp35-cp35m-win_amd64.whl',\n            'Pillow-7.2.0-cp36-cp36m-macosx_10_10_x86_64.whl',\n            'Pillow-7.2.0-cp36-cp36m-manylinux1_i686.whl',\n            'Pillow-7.2.0-cp36-cp36m-manylinux1_x86_64.whl',\n            'Pillow-7.2.0-cp36-cp36m-manylinux2014_aarch64.whl',\n            'Pillow-7.2.0-cp36-cp36m-win32.whl',\n            'Pillow-7.2.0-cp36-cp36m-win_amd64.whl',\n            'Pillow-7.2.0-cp37-cp37m-macosx_10_10_x86_64.whl',\n            'Pillow-7.2.0-cp37-cp37m-manylinux1_i686.whl',\n            'Pillow-7.2.0-cp37-cp37m-manylinux1_x86_64.whl',\n            'Pillow-7.2.0-cp37-cp37m-manylinux2014_aarch64.whl',\n            'Pillow-7.2.0-cp37-cp37m-win32.whl',\n            'Pillow-7.2.0-cp37-cp37m-win_amd64.whl',\n            'Pillow-7.2.0-cp38-cp38-macosx_10_10_x86_64.whl',\n            'Pillow-7.2.0-cp38-cp38-manylinux1_i686.whl',\n            'Pillow-7.2.0-cp38-cp38-manylinux1_x86_64.whl',\n            'Pillow-7.2.0-cp38-cp38-manylinux2014_aarch64.whl',\n            'Pillow-7.2.0-cp38-cp38-win32.whl',\n            'Pillow-7.2.0-cp38-cp38-win_amd64.whl',\n            'Pillow-7.2.0-pp36-pypy36_pp73-macosx_10_10_x86_64.whl',\n            'Pillow-7.2.0-pp36-pypy36_pp73-manylinux2010_x86_64.whl',\n            'Pillow-7.2.0-pp36-pypy36_pp73-win32.whl',\n            'reportlab-3.5.47-cp27-cp27m-macosx_10_9_x86_64.whl',\n            'reportlab-3.5.47-cp27-cp27m-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp27-cp27m-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp27-cp27m-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp27-cp27m-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp27-cp27mu-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp27-cp27mu-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp27-cp27mu-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp27-cp27mu-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp27-cp27m-win32.whl',\n            'reportlab-3.5.47-cp27-cp27m-win_amd64.whl',\n            'reportlab-3.5.47-cp35-cp35m-macosx_10_6_intel.whl',\n            'reportlab-3.5.47-cp35-cp35m-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp35-cp35m-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp35-cp35m-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp35-cp35m-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp35-cp35m-win32.whl',\n            'reportlab-3.5.47-cp35-cp35m-win_amd64.whl',\n            'reportlab-3.5.47-cp36-cp36m-macosx_10_9_x86_64.whl',\n            'reportlab-3.5.47-cp36-cp36m-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp36-cp36m-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp36-cp36m-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp36-cp36m-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp36-cp36m-win32.whl',\n            'reportlab-3.5.47-cp36-cp36m-win_amd64.whl',\n            'reportlab-3.5.47-cp37-cp37m-macosx_10_9_x86_64.whl',\n            'reportlab-3.5.47-cp37-cp37m-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp37-cp37m-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp37-cp37m-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp37-cp37m-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp37-cp37m-win32.whl',\n            'reportlab-3.5.47-cp37-cp37m-win_amd64.whl',\n            'reportlab-3.5.47-cp38-cp38-macosx_10_9_x86_64.whl',\n            'reportlab-3.5.47-cp38-cp38-manylinux1_i686.whl',\n            'reportlab-3.5.47-cp38-cp38-manylinux1_x86_64.whl',\n            'reportlab-3.5.47-cp38-cp38-manylinux2010_i686.whl',\n            'reportlab-3.5.47-cp38-cp38-manylinux2010_x86_64.whl',\n            'reportlab-3.5.47-cp38-cp38-win32.whl',\n            'reportlab-3.5.47-cp38-cp38-win_amd64.whl',\n        ]\n        for fn in filter(is_compatible, wheel_names):\n            w = Wheel(fn)\n            our_arch = ARCH.replace('linux_', '')\n            for pyver, abi, arch in w.tags:\n                self.assertEqual(pyver, IMPVER)\n                self.assertEqual(abi, ABI)\n                if sys.platform != 'darwin':\n                    self.assertTrue(arch.endswith(our_arch))\n                else:\n                    m = re.match(r'(\\w+)_(\\d+)_(\\d+)_(\\w+)$', our_arch)\n                    self.assertTrue(m)\n                    _, major, minor, our_arch_kind = m.groups()\n                    our_major = int(major)\n                    our_minor = int(minor)\n                    m = re.match(r'(\\w+)_(\\d+)_(\\d+)_(\\w+)$', arch)\n                    self.assertTrue(m)\n                    _, major, minor, arch_kind = m.groups()\n                    major = int(major)\n                    minor = int(minor)\n                    self.assertEqual(major, our_major)\n                    self.assertLessEqual(minor, our_minor)\n                    if arch_kind in ('x86_64', 'i386'):\n                        self.assertEqual(arch_kind, our_arch_kind)\n                    elif arch_kind == 'fat':\n                        self.assertIn(our_arch_kind, ('i386', 'ppc'))\n                    elif arch_kind == 'fat3':\n                        self.assertIn(our_arch_kind, ('i386', 'ppc', 'x86_x64'))\n                    elif arch_kind == 'fat64':\n                        self.assertIn(our_arch_kind, ('ppc64', 'x86_x64'))\n                    elif arch_kind == 'intel':\n                        self.assertIn(our_arch_kind, ('i386', 'x86_x64'))\n                    elif arch_kind == 'universal':\n                        self.assertIn(our_arch_kind, ('i386', 'ppc', 'ppc64', 'x86_x64', 'intel'))\n                if 'manylinux' in arch:\n                    self.assertTrue(sys.platform.startswith('linux'))\n                    parts = _get_glibc_version()\n                    self.assertEqual(len(parts), 2)\n                    if 'manylinux2014_' in arch:\n                        self.assertTrue(parts >= (2, 17))\n                    if 'manylinux2010_' in arch:\n                        self.assertTrue(parts >= (2, 12))\n                    if 'manylinux1_' in arch:\n                        self.assertTrue(parts >= (2, 5))\n                    if 'manylinux_' in arch:\n                        s = 'manylinux_%s_%s_' % parts\n                        self.assertIn(s, arch)\n\n    def test_metadata(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        md = w.metadata\n        self.assertEqual(md.name, 'dummy')\n        self.assertEqual(md.version, '0.1')\n\n    def test_invalid(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        self.assertRaises(DistlibException, w.get_hash, b'', 'badalgo')\n\n    def check_built_wheel(self, wheel, expected):\n        for key in expected:\n            self.assertEqual(expected[key], getattr(wheel, key))\n        fn = os.path.join(wheel.dirname, wheel.filename)\n        self.assertTrue(os.path.exists(fn))\n        name, version = wheel.name, wheel.version\n        with ZipFile(fn, 'r') as zf:\n            for key in ('scripts', 'headers', 'data'):\n                arcname = '%s-%s.data/%s/%s_file.txt' % (name, version, key, key)\n                with zf.open(arcname) as bf:\n                    data = bf.read()\n                expected = ('dummy data - %s' % key).encode('utf-8')\n                if key == 'scripts':\n                    expected = b'#!python\\n' + expected\n                self.assertTrue(data, expected)\n\n    def test_build_tags(self):\n        workdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, workdir)\n        name = 'dummy'\n        version = '0.1'\n        paths = {'prefix': workdir}\n        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):\n            paths[key] = p = os.path.join(workdir, key)\n            os.makedirs(p)\n            fn = os.path.join(p, '%s_file.txt' % key)\n            with open(fn, 'w') as f:\n                f.write('dummy data - %s' % key)\n            if key in ('purelib', 'platlib'):\n                p = os.path.join(p, '%s-%s.dist-info' % (name, version))\n                os.makedirs(p)\n                fn = os.path.join(p, 'RECORD')\n\n        purelib = paths.pop('purelib')\n        platlib = paths.pop('platlib')\n\n        # Make a pure wheel with default tags\n        paths['purelib'] = purelib\n        wheel = Wheel('%s-%s' % (name, version))\n        wheel.dirname = workdir\n        wheel.build(paths)\n        expected = {\n            'name': name,\n            'version': version,\n            'pyver': [PYVER],\n            'abi': ['none'],\n            'arch': ['any'],\n            'filename': 'dummy-0.1-%s-none-any.whl' % PYVER,\n        }\n        self.check_built_wheel(wheel, expected)\n        # Make a pure wheel with custom tags\n        pyver = [PYVER[:-1], PYVER]\n        wheel.build(paths, {'pyver': pyver})\n        expected = {\n            'name': name,\n            'version': version,\n            'pyver': pyver,\n            'abi': ['none'],\n            'arch': ['any'],\n            'filename': 'dummy-0.1-%s-none-any.whl' % '.'.join(pyver),\n        }\n        self.check_built_wheel(wheel, expected)\n\n        # Make a non-pure wheel with default tags\n        paths.pop('purelib')\n        paths['platlib'] = platlib\n        wheel.build(paths)\n        expected['pyver'] = [IMPVER]\n        expected['abi'] = [ABI]\n        expected['arch'] = [ARCH]\n        expected['filename'] = 'dummy-0.1-%s-%s-%s.whl' % (IMPVER, ABI, ARCH)\n        self.check_built_wheel(wheel, expected)\n\n    def do_build_and_install(self, dist):\n        srcdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, srcdir)\n        dstdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, dstdir)\n\n        paths = install_dist(dist, srcdir)\n        paths['prefix'] = srcdir\n        w = Wheel()\n        w.name = paths.pop('name')\n        w.version = paths.pop('version')\n        w.dirname = srcdir\n        pathname = w.build(paths)\n        self.assertTrue(os.path.exists(pathname))\n\n        paths = {'prefix': dstdir}\n        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):\n            paths[key] = os.path.join(dstdir, key)\n        w = Wheel(pathname)\n        maker = ScriptMaker(None, None, add_launchers=False)\n        maker.executable = os.path.join(paths['scripts'], 'python')\n        dist = w.install(paths, maker)\n        self.assertIsNotNone(dist)\n        self.assertEqual(dist.name, w.name)\n        self.assertEqual(dist.version, w.version)\n        shared = dist.shared_locations\n        self.assertTrue(shared)\n        os.remove(pathname)\n        sm = Manifest(srcdir)\n        sm.findall()\n        sfiles = set([os.path.relpath(p, srcdir) for p in sm.allfiles])\n        dm = Manifest(dstdir)\n        dm.findall()\n        dfiles = set([os.path.relpath(p, dstdir) for p in dm.allfiles])\n        omitted = sfiles - dfiles\n        omitted = omitted.pop()\n        endings = os.path.join('.dist-info', 'WHEEL'), '.pyc', '.pyo'\n        self.assertTrue(omitted.endswith(endings))\n\n    def test_version_incompatibility(self):\n\n        class Warner(object):\n\n            def __call__(self, wheel_version, file_version):\n                self.wheel_version = wheel_version\n                self.file_version = file_version\n\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        dstdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, dstdir)\n        w = Wheel(fn)\n        paths = {'prefix': dstdir}\n        for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):\n            paths[key] = os.path.join(dstdir, key)\n        warner = Warner()\n        maker = ScriptMaker(None, None)\n        w.install(paths, maker, warner=warner)\n        self.assertEqual(warner.wheel_version, w.wheel_version)\n        self.assertEqual(warner.file_version, (2, 0))\n        # Now set the wheel's instance to the higher value and ensure\n        # warner isn't called\n        warner = Warner()\n        w.wheel_version = (2, 0)\n        w.install(paths, maker, warner=warner)\n        self.assertFalse(hasattr(warner, 'wheel_version'))\n        self.assertFalse(hasattr(warner, 'file_version'))\n\n    def test_custom_executable(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        for executable in 'mypython', None:\n            dstdir = tempfile.mkdtemp()\n            self.addCleanup(shutil.rmtree, dstdir)\n            w = Wheel(fn)\n            paths = {'prefix': dstdir}\n            for key in ('purelib', 'platlib', 'headers', 'scripts', 'data'):\n                paths[key] = os.path.join(dstdir, key)\n            maker = ScriptMaker(None, None)\n            maker.variants = set([''])\n            maker.executable = executable\n            w.install(paths, maker)\n            # On Windows there will be an exe file, and on POSIX a text file.\n            # The test is structured to not care.\n            p = paths['scripts']\n            # there should be just one file in the directory - dummy.py/dummy.exe\n            p = os.path.join(p, os.listdir(p)[0])\n            with open(p, 'rb') as f:\n                data = f.read()\n            if executable is None:\n                expected = fsencode(get_executable())\n            else:\n                expected = executable.encode('utf-8')\n            expected = b'#!' + expected + b' -E'\n            if not sysconfig.is_python_build():\n                self.assertIn(expected, data)\n\n    def test_verify(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        w.verify()\n        # see issue 115\n        fn = os.path.join(HERE, 'valid_wheel-0.0.1-py3-none-any.whl')\n        w = Wheel(fn)\n        w.verify()\n        fn = os.path.join(HERE, 'bad_wheels', 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        self.assertRaises(DistlibException, w.verify)\n\n    def wheel_modifier_nop(self, path_map):\n        return False\n\n    def wheel_modifier(self, path_map):\n        mdpath = path_map['dummy-0.1.dist-info/%s' % LEGACY_METADATA_FILENAME]\n        md = Metadata(path=mdpath)\n        md.add_requirements(['numpy'])\n        md.write(path=mdpath, legacy=True)\n        return True\n\n    def wheel_modifier_ver(self, path_map):\n        mdpath = path_map['dummy-0.1.dist-info/%s' % LEGACY_METADATA_FILENAME]\n        md = Metadata(path=mdpath)\n        md.version = '0.1+123'\n        md.write(path=mdpath, legacy=True)\n        return True\n\n    def test_update(self):\n        workdir = tempfile.mkdtemp()\n        self.addCleanup(shutil.rmtree, workdir)\n        fn = 'dummy-0.1-py27-none-any.whl'\n        sfn = os.path.join(HERE, fn)\n        dfn = os.path.join(workdir, fn)\n        shutil.copyfile(sfn, dfn)\n        mtime = os.stat(dfn).st_mtime\n        w = Wheel(dfn)\n        modified = w.update(self.wheel_modifier_nop)\n        self.assertFalse(modified)\n        self.assertEqual(mtime, os.stat(dfn).st_mtime)\n        modified = w.update(self.wheel_modifier)\n        self.assertTrue(modified)\n        self.assertLessEqual(mtime, os.stat(dfn).st_mtime)\n        w = Wheel(dfn)\n        w.verify()\n        md = w.metadata\n        self.assertEqual(md.run_requires, ['numpy'])\n        self.assertEqual(md.version, '0.1+1')\n\n        modified = w.update(self.wheel_modifier_ver)\n        self.assertTrue(modified)\n        self.assertLessEqual(mtime, os.stat(dfn).st_mtime)\n        w = Wheel(dfn)\n        w.verify()\n        md = w.metadata\n        self.assertEqual(md.run_requires, ['numpy'])\n        self.assertEqual(md.version, '0.1+123')\n\n    def test_info(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        actual = w.info\n        actual.pop('Generator', None)\n        expected = {'Root-Is-Purelib': 'true', 'Tag': 'py27-none-any', 'Wheel-Version': '2.0'}\n        self.assertEqual(actual, expected)\n\n    @unittest.skipIf(sys.version_info[:2] != (2, 7), 'The test wheel is only '\n                     '2.7 mountable')\n    def test_mount(self):\n        fn = os.path.join(HERE, 'dummy-0.1-py27-none-any.whl')\n        w = Wheel(fn)\n        self.assertNotIn(fn, sys.path)\n        w.mount()\n        self.assertIn(fn, sys.path)\n        w.unmount()\n        self.assertNotIn(fn, sys.path)\n\n    def test_mount_extensions(self):\n        if PYVER == 'py27':\n            fn = 'minimext-0.1-cp27-none-linux_x86_64.whl'\n        elif PYVER == 'py32':\n            fn = 'minimext-0.1-cp32-cp32mu-linux_x86_64.whl'\n        elif PYVER == 'py33':\n            fn = 'minimext-0.1-cp33-cp33m-linux_x86_64.whl'\n        else:\n            fn = None\n        if not fn:  # pragma: no cover\n            raise unittest.SkipTest('Suitable wheel not found.')\n        fn = os.path.join(HERE, fn)\n        w = Wheel(fn)\n        if not w.is_compatible() or not w.is_mountable():  # pragma: no cover\n            raise unittest.SkipTest('Wheel not suitable for mounting.')\n        self.assertRaises(ImportError, __import__, 'minimext')\n        w.mount()\n        mod = __import__('minimext')\n        self.assertIs(mod, sys.modules['minimext'])\n        self.assertEqual(mod.fib(10), 55)\n        w.unmount()\n        del sys.modules['minimext']\n        self.assertRaises(ImportError, __import__, 'minimext')\n\n    def test_local_version(self):\n        w = Wheel('dummy-0.1_1.2')\n        self.assertEqual(w.filename, 'dummy-0.1_1.2-%s'\n                         '-none-any.whl' % PYVER)\n        self.assertEqual(w.name, 'dummy')\n        self.assertEqual(w.version, '0.1-1.2')\n        self.assertFalse(w.exists)\n        w.version = '0.1-1.3'\n        self.assertEqual(w.filename, 'dummy-0.1_1.3-%s'\n                         '-none-any.whl' % PYVER)\n\n    def test_abi(self):\n        pyver = sysconfig.get_config_var('py_version_nodot')\n        if not pyver:\n            pyver = '%s%s' % sys.version_info[:2]\n        parts = ['cp', pyver]\n        if sysconfig.get_config_var('Py_DEBUG'):\n            parts.append('d')\n        # Starting with 3.8, the SOABI doesn't append m when WITH_PYMALLOC is\n        # defined (see bpo-36707)\n        vi = sys.version_info[:2]\n        if IMP_PREFIX == 'cp':\n            if vi < (3, 8):\n                wpm = sysconfig.get_config_var('WITH_PYMALLOC')\n                if wpm or wpm is None:\n                    parts.append('m')\n            if vi < (3, 3):\n                us = sysconfig.get_config_var('Py_UNICODE_SIZE')\n                if us == 4 or (us is None and sys.maxunicode == 0x10FFFF):\n                    parts.append('u')\n        if vi < (3, 5):\n            abi = ABI\n        else:\n            abi = ABI.split('-')[0]\n        self.assertEqual(''.join(parts), abi)\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(PIP_AVAILABLE, 'pip is needed for this test')\n    @unittest.skipIf(sys.version_info[:2] >= (3, 7), 'The test distribution is not '\n                     '3.7+ compatible')\n    def test_build_and_install_pure(self):\n        if pip_version() >= (20, 2, 0):\n            raise unittest.SkipTest('Test not supported by pip version')\n        self.do_build_and_install('sarge == 0.1')\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipIf(hasattr(sys, 'pypy_version_info'), 'The test distribution'\n                     ' does not build on PyPy')\n    @unittest.skipIf(sys.platform != 'linux2', 'The test distribution only '\n                     'builds on Linux')\n    @unittest.skipUnless(PIP_AVAILABLE, 'pip is needed for this test')\n    def test_build_and_install_plat(self):\n        if pip_version() >= (20, 2, 0):\n            raise unittest.SkipTest('Test not supported by pip version')\n        self.do_build_and_install('hiredis == 0.1.1')\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipIf(sys.version_info[0] == 3, 'The test distribution is not '\n                     '3.x compatible')\n    @unittest.skipUnless(PIP_AVAILABLE, 'pip is needed for this test')\n    def test_build_and_install_data(self):\n        if pip_version() >= (20, 2, 0):\n            raise unittest.SkipTest('Test not supported by pip version')\n        self.do_build_and_install('Werkzeug == 0.5')\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipIf(sys.version_info[0] == 3, 'The test distribution is not '\n                     '3.x compatible')\n    @unittest.skipUnless(PIP_AVAILABLE, 'pip is needed for this test')\n    def test_build_and_install_scripts(self):\n        if pip_version() >= (20, 2, 0):\n            raise unittest.SkipTest('Test not supported by pip version')\n        self.do_build_and_install('Babel == 0.9.6')\n\n\nif __name__ == '__main__':  # pragma: no cover\n    import logging\n    logging.basicConfig(level=logging.DEBUG, filename='test_wheel.log', filemode='w', format='%(message)s')\n    unittest.main()\n", "tests/test_index.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport codecs\nimport json\nimport logging\nimport os\nimport shutil\n\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None\nimport subprocess\nimport sys\nimport tempfile\ntry:\n    import threading\nexcept ImportError:\n    import dummy_threading as threading\nimport time\n\nfrom compat import unittest, Request\nfrom support import DistlibTestCase, in_github_workflow\nif ssl:\n    from support import HTTPSServerThread\n\nfrom distlib import DistlibException\nfrom distlib.compat import urlopen, HTTPError, URLError\nfrom distlib.index import PackageIndex\nfrom distlib.metadata import Metadata, MetadataMissingError, METADATA_FILENAME\nfrom distlib.util import zip_dir\n\nif ssl:\n    from distlib.util import HTTPSHandler\n\nlogger = logging.getLogger(__name__)\nlogger.addHandler(logging.NullHandler())\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\nif 'HOME' in os.environ:\n    PYPIRC = os.path.expandvars('$HOME/.pypirc')\nelse:\n    PYPIRC = None\n\nTEST_SERVER_PORT = os.environ.get('TEST_PYPISERVER_PORT', '8086')\n\nIN_GITHUB_WORKFLOW = in_github_workflow()\n\n\nclass PackageIndexTestCase(DistlibTestCase):\n    run_test_server = True\n    test_server_url = 'http://localhost:%s/' % TEST_SERVER_PORT\n\n    @classmethod\n    def setUpClass(cls):\n        if cls.run_test_server:\n            cls.server = None\n            server_script = os.path.join(HERE, 'pypi-server-standalone.py')\n            if not os.path.exists(server_script):\n                logger.debug('test server not available - some tests '\n                             'will be skipped.')\n                return\n            pwdfn = os.path.join(HERE, 'passwords')\n            if not os.path.exists(pwdfn):  # pragma: no cover\n                with open(pwdfn, 'w') as f:\n                    f.write('test:secret\\n')\n            pkgdir = os.path.join(HERE, 'packages')\n            if not os.path.isdir(pkgdir):  # pragma: no cover\n                os.mkdir(pkgdir)\n            fd, cls.sinkfile = tempfile.mkstemp(suffix='.log', prefix='distlib-pypi-')\n            os.close(fd)\n            cls.sink = sink = open(cls.sinkfile, 'w')\n            cmd = [\n                sys.executable, 'pypi-server-standalone.py', '--interface', '127.0.0.1', '--port', TEST_SERVER_PORT,\n                '-P', 'passwords', 'packages'\n            ]\n            cls.server = subprocess.Popen(cmd, stdout=sink, stderr=sink, cwd=HERE)\n            # wait for the server to start up\n            response = None\n            tries = 20\n            timeout = 0.5\n            count = 0\n            while response is None:\n                try:\n                    count += 1\n                    time.sleep(timeout)\n                    response = urlopen(cls.test_server_url)\n                    if response.getcode() != 200:\n                        response = None\n                        break\n                    # In case some other server is listening on the same port ...\n                    # need to check the actual response for pypiserver-specific content\n                    data = response.read()\n                    if b'Welcome to pypiserver!' not in data:\n                        response = None\n                        break\n                except URLError:\n                    if count < tries:\n                        pass\n                    else:\n                        break\n            if response is None or cls.server.poll() is not None:\n                logger.warning('PyPI test server could not be run')\n                cls.server = None\n                cls.sink.close()\n                os.remove(cls.sinkfile)\n\n    @classmethod\n    def tearDownClass(cls):\n        if cls.run_test_server:\n            if cls.server and cls.server.returncode is None:\n                cls.server.kill()\n                cls.server.wait()\n                cls.sink.close()\n                try:\n                    os.remove(cls.sinkfile)\n                except Exception:\n                    logger.warning('Unable to remove test file %s', cls.sinkfile)\n\n    def setUp(self):\n        if not self.run_test_server:\n            self.index = PackageIndex()\n        else:\n            self.index = PackageIndex(self.test_server_url)\n            self.index.username = 'test'\n            self.index.password = 'secret'\n\n    def load_package_metadata(self, path):\n        result = None\n        for bn in (METADATA_FILENAME, 'package.json'):\n            fn = os.path.join(path, bn)\n            if os.path.exists(fn):\n                with codecs.open(fn, 'r', 'utf-8') as jf:\n                    result = json.load(jf)\n                    break\n        if not result:\n            raise ValueError('neither %s nor package.json '\n                             'found in %s' % (METADATA_FILENAME, fn))\n        if bn == 'package.json':\n            result = result.get('index-metadata', {})\n        if result.get('metadata_version') != '2.0':\n            raise ValueError('Not a valid file: %s' % fn)\n        return result\n\n    def check_pypi_server_available(self):\n        if self.run_test_server and not self.server:  # pragma: no cover\n            raise unittest.SkipTest('test server not available')\n\n    def check_testdist_available(self):\n        self.index.check_credentials()\n        self.username = self.index.username.replace('-', '_')\n        self.dist_project = '%s_testdist' % self.username\n        self.dist_version = '0.1'\n        self.testdir = '%s-%s' % (self.dist_project, self.dist_version)\n        destdir = os.path.join(HERE, self.testdir)\n        if not os.path.isdir(destdir):  # pragma: no cover\n            srcdir = os.path.join(HERE, 'testdist-0.1')\n            shutil.copytree(srcdir, destdir)\n            for fn in os.listdir(destdir):\n                fn = os.path.join(destdir, fn)\n                if os.path.isfile(fn):\n                    with codecs.open(fn, 'r', 'utf-8') as f:\n                        data = f.read()\n                    data = data.format(username=self.username)\n                    with codecs.open(fn, 'w', 'utf-8') as f:\n                        f.write(data)\n            zip_data = zip_dir(destdir).getvalue()\n            zip_name = destdir + '.zip'\n            with open(zip_name, 'wb') as f:\n                f.write(zip_data)\n\n    @unittest.skip('The PyPI API changed, so this test is temporarily skipped')\n    def test_register(self):  # pragma: no cover\n        \"Test registration\"\n        self.check_pypi_server_available()\n        self.check_testdist_available()\n        d = os.path.join(HERE, self.testdir)\n        data = self.load_package_metadata(d)\n        md = Metadata()\n        self.assertRaises(MetadataMissingError, self.index.register, md)\n        md.name = self.dist_project\n        self.assertRaises(MetadataMissingError, self.index.register, md)\n        md.version = data['version']\n        md.summary = data['summary']\n        response = self.index.register(md)\n        self.assertEqual(response.code, 200)\n\n    def remove_package(self, name, version):\n        \"\"\"\n        Remove package. Only works with test server; PyPI would require\n        some scraping to get CSRF tokens into the request.\n        \"\"\"\n        d = {\n            ':action': 'remove_pkg',\n            'name': name,\n            'version': version,\n            'submit_remove': 'Remove',\n            'submit_ok': 'OK',\n        }\n        self.index.check_credentials()\n        request = self.index.encode_request(d.items(), [])\n        try:\n            self.index.send_request(request)\n        except HTTPError as e:\n            if e.getcode() != 404:\n                raise\n\n    @unittest.skip('The PyPI API changed, so this test is temporarily skipped')\n    def test_upload(self):\n        \"Test upload\"\n        self.check_pypi_server_available()\n        self.check_testdist_available()\n        if self.run_test_server:\n            self.remove_package(self.dist_project, self.dist_version)\n        d = os.path.join(HERE, self.testdir)\n        data = self.load_package_metadata(d)\n        md = Metadata(mapping=data)\n        self.index.gpg_home = os.path.join(HERE, 'keys')\n        try:\n            zip_name = os.path.join(HERE, '%s.zip' % self.testdir)\n            self.assertRaises(DistlibException, self.index.upload_file, md, 'random-' + zip_name, 'Test User', 'tuser')\n            response = self.index.upload_file(md, zip_name, 'Test User', 'tuser')\n            self.assertEqual(response.code, 200)\n            if self.run_test_server:\n                fn = os.path.join(HERE, 'packages', os.path.basename(zip_name))\n                self.assertTrue(os.path.exists(fn))\n        except HTTPError as e:\n            # Treat as success if it already exists\n            if e.getcode() != 400 or 'already exists' not in e.msg:\n                raise\n\n    def test_upload_documentation(self):\n        \"Test upload of documentation\"\n        raise unittest.SkipTest('Skipped, as pythonhosted.org is being '\n                                'de-emphasised and this functionality may '\n                                'no longer be available')\n        self.check_pypi_server_available()\n        self.check_testdist_available()\n        d = os.path.join(HERE, self.testdir)\n        data = self.load_package_metadata(d)\n        md = Metadata(mapping=data)\n        d = os.path.join(d, 'doc')\n        # Non-existent directory\n        self.assertRaises(DistlibException, self.index.upload_documentation, md, d + '-random')\n        # Directory with no index.html\n        self.assertRaises(DistlibException, self.index.upload_documentation, md, HERE)\n        response = self.index.upload_documentation(md, d)\n        self.assertEqual(response.code, 200)\n        if not self.run_test_server:\n            url = 'http://packages.python.org/%s/' % self.dist_project\n            response = urlopen(url)\n            self.assertEqual(response.code, 200)\n            data = response.read()\n            expected = b'This is dummy documentation'\n            self.assertIn(expected, data)\n\n    @unittest.skipIf(IN_GITHUB_WORKFLOW, 'This test is end-of-line dependent')\n    def test_verify_signature(self):  # pragma: no cover\n        if not self.index.gpg:  # pragma: no cover\n            raise unittest.SkipTest('gpg not available')\n        sig_file = os.path.join(HERE, 'good.bin.asc')\n        good_file = os.path.join(HERE, 'good.bin')\n        bad_file = os.path.join(HERE, 'bad.bin')\n        gpg = self.index.gpg\n        self.index.gpg = None\n        self.assertRaises(DistlibException, self.index.verify_signature, sig_file, good_file)\n        self.index.gpg = gpg\n        # Not pointing to keycd tests\n        self.assertRaises(DistlibException, self.index.verify_signature, sig_file, good_file)\n        self.index.gpg_home = os.path.join(HERE, 'keys')\n        self.assertTrue(self.index.verify_signature(sig_file, good_file))\n        self.assertFalse(self.index.verify_signature(sig_file, bad_file))\n\n    def test_invalid(self):\n        self.assertRaises(DistlibException, PackageIndex, 'ftp://ftp.python.org/')\n        self.index.username = None\n        self.assertRaises(DistlibException, self.index.check_credentials)\n\n    @unittest.skipIf(PYPIRC is None or os.path.exists(PYPIRC), 'because $HOME/.pypirc is unavailable for use')\n    def test_save_configuration(self):\n        try:\n            self.index.save_configuration()\n            self.assertTrue(os.path.exists(PYPIRC))\n        finally:\n            os.remove(PYPIRC)\n\n    if ssl:\n\n        def make_https_server(self, certfile):\n            server = HTTPSServerThread(certfile)\n            flag = threading.Event()\n            server.start(flag)\n            flag.wait()\n\n            def cleanup():\n                server.stop()\n                server.join()\n\n            self.addCleanup(cleanup)\n            return server\n\n        @unittest.skipIf(sys.version_info[:2] > (3, 11), 'Temporary skip')\n        def test_ssl_verification(self):\n            certfile = os.path.join(HERE, 'keycert.pem')\n            server = self.make_https_server(certfile)\n            url = 'https://localhost:%d/' % server.port\n            req = Request(url)\n            self.index.ssl_verifier = HTTPSHandler(certfile)\n            response = self.index.send_request(req)\n            self.assertEqual(response.code, 200)\n\n        @unittest.skipIf(IN_GITHUB_WORKFLOW, 'This test is end-of-line dependent')\n        @unittest.skipIf(sys.version_info[:2] > (3, 11), 'Temporary skip')\n        def test_download(self):  # pragma: no cover\n            digest = '913093474942c5a564c011f232868517'  # for testsrc/README.txt\n            certfile = os.path.join(HERE, 'keycert.pem')\n            server = self.make_https_server(certfile)\n            url = 'https://localhost:%d/README.txt' % server.port\n            fd, fn = tempfile.mkstemp()\n            os.close(fd)\n            self.addCleanup(os.remove, fn)\n            with open(os.path.join(HERE, 'testsrc', 'README.txt'), 'rb') as f:\n                data = f.read()\n            self.index.ssl_verifier = HTTPSHandler(certfile)\n            self.index.download_file(url, fn)  # no digest\n            with open(fn, 'rb') as f:\n                self.assertEqual(data, f.read())\n            self.index.download_file(url, fn, digest)\n            with open(fn, 'rb') as f:\n                self.assertEqual(data, f.read())\n            reporthook = lambda *args: None\n            self.index.download_file(url, fn, ('md5', digest), reporthook)\n            with open(fn, 'rb') as f:\n                self.assertEqual(data, f.read())\n            # bad digest\n            self.assertRaises(DistlibException, self.index.download_file, url, fn, digest[:-1] + '8')\n\n    @unittest.skipIf('SKIP_ONLINE' in os.environ, 'Skipping online test')\n    @unittest.skipUnless(ssl, 'SSL required for this test.')\n    @unittest.skipIf(True, 'skipping due to temporary changes in PyPI')\n    def test_search(self):  # pragma: no cover\n        self.index = PackageIndex()\n        result = self.index.search({'name': 'tatterdemalion'})\n        self.assertEqual(len(result), 1)\n        result = self.index.search({'name': 'ragamuff'})\n        if result:\n            msg = 'got an unexpected result: %s' % result\n        else:\n            msg = None\n        self.assertEqual(len(result), 0, msg)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    unittest.main()\n", "tests/pypi-server-standalone.py": "#! /usr/bin/env python\n\"\"\"standalone pypi-server, version 1.1.0dev\"\"\"\n\nsources = \"\"\"\n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\nYaw3rf1YOGKQDzLJwsiHPktEPoz29J5S0dIlosW2zVvB66v2tf36pdvc7+zW9t3+9knVvXr7tNY2\nV49PBt1a7ditXQyO7enWq3FoBeO9+svyde9m9LL42vk+Lr8+Kx4eVzuvX5XeV44dw/lxUdzbnP4s\ndbeuXlVveh+Gp9/12+HH0/frb/rXb4za29kb3hkbdxCOQr0Wl4pIm7qGhhgGQ7qw7Vigu7N3cRby\nFywnLYlKkyw58dySqvj18NfTw6MPb5qHv6H/EKB/7QqwXiqVnn6+eV35vPlq6+Jtr/H0+6vP793O\nh/FRoTDSCjf7n/vV75dH+sHrk1IDeXwsmJ2JO7YHseKadI2pfM6nTy+1s+2Dl6fT+ulZ7d2b5rG5\nv6OVrdJY0zsNNQXx8JEqZV17enTWKx9+f1d683P/5un3/cNXzun15/LBR3O//a7rvLo6GR1W9daH\nt4GBvX3t9q3xzzvsbKTfI+9tpoPuwYNMXhFb+dS8MTtPHW3nw5utN1frJ/3r8sHqyWFn9+O1tW1e\nfDJKl/0f/YAokOkNJ5m8OI44SOfppL533TmrdJ+edrXe9PT91sHnT83Jj8/62sg6GbY3d+ym6RrG\nai84UrfTD47UfTp+53Yu1y/ePR3+2L4ybt5sH+1umq/cs9OL5qZ7Oywef3r30ervTQ+CI7kjY8CG\n4iOVzdrTvdLhx/rgbPXp9GrV3aldX1eP3ryevDF+GD+3Xn3aPn13+eFT/dOm/iq9LO8j7rXt7vV+\nHNpP64Pvh7Xej+/jkn65bR+XOvqrUnNzfLA/HdvjWudtJo6Ces6k3brLfRDteE8a8lUooqbOoMuy\nCI9FpCHrLXUnTxXxrj+fZSPE/BorcpUeGUipuLnV3NK2drbWdirlirZV21rTtK01vR6+ZXabtfX1\nzZ26tqXXtPXNst4srzXLO1u7a1vN6mZtU19b311f04rVerW2plebof56c21Ta+7s7JSaer1Z3ymt\nrZfL1c1Kbbtcq+3ubpZ3q6WSXi7r5XVdL2/p4VuuVNne0dbXdIC0vLZZ2t7WdrYr9bVquVyvNfWa\nvlXaraxrpXodwCuVdzfD81fWt9brWn2rublVKWt1fatagxmDXJHhtFoJ4zQDu4BiIXt/cTNpUVvf\nrMASN6v19Vq1pper5e21rUqlvhkCbXOnCejUq+vVeqW6VYWPpdrmlqbXK9trGq5qvdKsN8ubpUpz\n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\n1A92DzbT7s5O0tpPttJkq7Wz2+q10r2tVE23s6n+v7m/t7O3u72lFiHdTfcOdlr72zsHSbrf3NxN\nD+ZNvbm5va9eXWry/fH9/Ifk8bMX06f9NxdPhi9+ezO5O7n7Jvnp5/uj33Zm6Q+PH/yY7H733ez9\n3Mk3928w+a10d/8gjuMtNft4b6/ba3W6e614pxl3d7aau7t7av931Fa3es00bR200q3e7t5evJfE\n293W9u7evMm3dlvN7e2l5v5ikMW//bo5Gm99uL549Lj/ff766ufhm59evzy7eDR7/Gr7zs9b44Px\n079/350795tMvZdsJ8n+VrKnDvX2QSdJ497OXnd7r5N0k82umnAn7vT2d7d6SdrZPthMervqdKQH\nB3s7vW63t7k7d+o7y+35nddbb1789CZ/1dn67eCnq0cX3c2nT65mky+/f3Gwu/n+2cGve+ngp5/2\nP1y+WTTv1rLz7ux2m82d3c14Nz5Idptp3FXXvbN3ELd6B3vJ7n5ne3t3S52IONnfSzc3u5t7KdyB\n9GCzu7O73essN+/W3HlP8wc/vHkcj5vnu3n3++nO6KJ/ED95+f3z355Pz7+8+/S7Lx9fPhrff/jz\ni7x83s0b0rj95u7W5s5Oq7Pf2+o0e9v73aTTPDhQu9/d3dtX9ztR29xpdXbUfveAIHa2trf2O4oc\nNPda253WMjSuuXDLz358+vD15NcPee/V09bV4NXV05+3f77f/Pu962k6fXGQv/rwj+3pj8c//f3J\ncfnUt29K3lvNVm+zqQi3ImCdnWRve29rO+lupb3tzThJW8lOM9ncURd6P9kHcq4+3YqbvVa32VW0\nbq+zzNS3F059//zJ5cPznwa7zaY6Vlv39zbvTbenr5PvXr0ctZ7Gr//x+Pn5fv7o3vmjfD6F46mb\nMqBLrUF60D2AGPztzu7ezraibmqKm510p3mQ7nRitRDbwMvS3YPOllqquLvVgVVrHaiL2FSsb2s1\nLG63+/7ed5vT4Q8Pn8bPzy7636c/7h7cffXh/vO48+Ly+/z5neNXj39+8929+OlSayCnDusRnLq6\n3M3Nrc7BZi/dj9OeYkmb3c5Ws9fd77RarZ2Dvb39g+Zub39rSxGCTqLmvn+grvJBst1rKtq4t/zU\nf/6+P/h5GJ56Gj+4P/vHndHk4vyn+0+e9q6fHGc//pT+/eHF2Yd46yK+3H7fj5OTq6u/I5F/50pF\nB2VS0ZYnFTUI1bK6KtGo29xt7e9vKV62lxzstRQV7CTNbk+Rzq3dvc29/b3WQW836XXU+vXS+KDX\nO9hv7uynm8meIjhpslm+eBdHzYMbHZ7LHx8fPz1/edC/vv/w4uWHgzcnP1+mjx73Or3pxa9f/tb7\n8s3DN9vP0u8607urk48SNZu9uBtvHrRa6lLsJLvxvuKEsTpAnTTd6m6nHXWmtrZbqVoSJTYqSap5\n0GltKRkiUVS2uXD+NxGSNn84370+e59d7v3042/39+L86mL24oGSUz78Y9Y8//vuD8n3nePm99NH\nmw9WJyS1DnYTNcf9zc7+5l436aZxnGxvx+nedrOzs7nbayrRefNg56C1u9dp7ive0tzvqRXYVsRD\nSVPdzsIVuIGk9PjH1u7u3dnd3rMPv01ev5ol303/0bk66dz74f0gvTrbe/Dmy87f7z3uXO3nK5OU\n9g8U81enXMkFe53WwU4nVWLx3ubObrynKEZ3u7ndi5NkW4mGndamYqRKPm52O2pK8Q780Vs8/yXF\npSx9f2+4+WYrH//4ZX6v+zAeKhb63cnu1usXrfzs/P3r0aMnx6/HP758tb8ycUmJAjvdtLW3q2ho\nstfb7u7H2wfNpLepqGNTXfeOWpt0B1akubMTN7fS7a4SlhSZSLbTWKlPN5j8fJnp5M5Pz//eGpw3\n75wcj//+qHcv+Uc83Nv9x06a33v4w+hk5+nd9Php8/lvrQerk5mS5q468ztKOTzY30nV7DppnCrh\nsdvbV1ohkoP9uLnbVVy0uatI4HbcbSWKsSoRs9NJu72lid9iwWnzx7NHPz1ovfnp/MVkd/bD2Yft\n2WtFBt6Mfrx6+f7H6cWr/En8PH/Qucj3Vyc4KdXoYGcr2dmPe6AVd9OtpNdU5C7Zjne34/3tdAsO\nxc620pJaiqE2W/s7ip/29vebe9tdJVcsPf/F0tNvv/VPmm8mH7rff/h162py0Xz88+Pz50/VeP7x\n0+tfH109fvj3n788frj5of85pCd1mdP9JFaCkWJy+3tKL1AUfl/Rwt6e0hTVb4pCqNm3Osn+/q7S\nH7ZBi1Yr0dnbTlqtNF0hF3z4ePfZ6LvJl789uvv0uPlrd2/r6uTHZ+/vPRg9Psi+f7P78scnzeFe\n8ux4tr06EaqzuaW0Q6X4ddLeQbO3tb+72dlUXGFbScetLaVLqM/TbpzEvYODTaU4Kmmzu72511JX\n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\nijkeNBiWQJJbx+j3FauBmUhai46zD+DyrP06ad6MLjb66ePMbulmNj4/3T07GB5e92sXeuNus5/u\nnGyu+waeaxzuuEPm9LltQCQ+J8z1iTYygVpw273yi8tYWxYE5acIIeA3m92w/c8XDUps/jv7eytJ\nxYIWKOw3Ym6hSUie0SIRgb9UNtT8+/WIFqj4uRVAWVFa+hD088ClDxltac6+S7XvqXyilPt+hdBH\n1PveFxEK/o+A+5kqfhwKG8dqNvezVWmsi8+q0txPfroqLba8FtZMrVXTa7Xc3bhyeHCXOcvfDk+O\nS9tHedu6a97ubg6218fXDad8v/ucPjmzm9fde+t+c7d8oNrbTWN3dGofVG4qVqnaODupzYYH6dXb\n3FrnzJ9HXtK6RQ5hcryRaZ699IzS1dve+Hp/erOm7+kbR2q7en24tnq6uzorDzbKz3en2tF4d9Sd\n6Ku3t8OD3aPhZC/du1O1tn1lZ0/6nYuSVtGG12eNTuc+G5unoIscw111IzscZsfdykGtc3zSrZ46\nFzujXHPXuDLOMvmrVr4z2y1oA/3VOM7ev7ypk7x1a7Obfu1k9DI4LDf3813jRbt6OTDSN+Vy7m10\n/6KlY/N0eTCGymC7Mp7u3W3f79yVtNb+8s1Os9er3lu9zWl3WLjK2t3D+/L1+s7O9eTianJ6rWvr\nJ/nS+rrTXatq5c3nyvl4WD492lbfMq+HNzu7xtnmzUk3N9is2G+j59V9tePkA3Uj4rxv6xm0VUZN\n1zen2aG+s3xxXTZrr5fX/fPLbvPkYqeXPjAPtPtBf79Uet5pj0pnmT2nYlfMq97q8eq2md7UTw4O\njMu3Ue1NOzx+vtk8q52cHW5f7Thn1xVrclPNDc7U2J/TEK55qqZMLrt8bL9eGMO785vhaDM/uTlf\nfl2fPh8WbtdeZ9dD5+h5O3uXyb3e76xWtarxvN3bH7xkx0fd81G++fry+tprFXK3r1ZhY3Zyfb7n\nbLReuzu22b/qDG/VdHpnam5mDwovs2yUMlEaCZM4lsu7m9VS4WV/0Fpd33vJDZZf0ur5S2ln9zR9\nNCwdHA9GG2tm7/ztbXy5qt4N77SN+6Oj18ON+9bG5v351V3tqDy198qH49pd43S9U9pvXji13k65\nu308GGar2Yv7iXY7nVeuURrMaj67vJ/u9M7N7Hrv4M7KdGp7y8cv6vh++6Bf3b6dvdmVo1tnejQa\nVyoHhVkzc2hn8+O79dlx5vy19Ho7bbw2s5ON3Ur28u2yfNo9tpsbueP0UXej8jK+3ti7v+qP9Lvz\no96HVZTe6DLrG+vLE613u2HuH5ffOkeFanO2fLu+MX7RbrOTu9tmdcepFrav7yY5Z3TTex1qG8P1\nfq/kVDcr6bVMYbV9XLjazqWPDC1zNUsfv+0MK7v99vX0+uz+bWfHut60c13rpL1rp79Xmymj2Nrq\n8urx7YVVzjbenN7d6uH9aPmovdYbXVSvjo8r/eOmVuhWbzLrp1V9tLf3dn1476TP8qNKzb7qHL8M\n15tXrYPR5Hrj1Dq8Ptvpbb6w85i/vzy1W43J2e3wupfpXE+Pnbfsj/FddcdOfiTn5fva0a7B2L/c\nxmleHSzv1/rmW/ttH2Iu9lvZ25f+YKegj0pHxzvn6qj7evI6upsatfxG1xmdvV3vb5vD/l7l4Fl/\nvtq/Hu20x/b+zZTRgmZ+uFfJlNLZ57u70XdXlpyvO5Cnkvlrj3rqe1UsC0hT8aeP93+yqgJunw+p\nB/wNl+1Xc+PKql5rwzPndMxWr3dcLTjnF60N43hSPT24ee6nKxvZ9f38eNs83Dt7Ni+Oxp40EdPt\nw7WNcaFSOzG291rNxl25tcckukpbq+ZXDfONhM8lTzRa+1PKjXe/X67cZNOVte27g+u17ebt/Xjj\n4lq/bezejLR8RX/pZuyGNPqDRuN05/qsau6cpq9Gz4PTzO5w47UyvtcPtmfpu9r2oHq8drD5Yqdn\n+Uuzok1WX9W5E/peFch7IJb7FxvPVr/bub687t4VGqvD+2NtZu+cGJmL7em+daYfX0hzervId/qn\n3Um/v7du7e/eT6+60+xs2rprvqX17FG18ZKfrR2dTqf9DW3c6l2VB5n5e/QRRckPV5PMV5K8N7Tl\n80r7blIrM15v/fqm+Tw9NKqVZ2PWcwzVSg8vbHVyLvXzejq9WNsbrB+uHVp3Z/mdwYm9tjbddDJW\ndcK485t1a/1qcFQ2dif7L62NYWE8mo/O0aqUP6tIie5g+WZ8MbvJ3V2q3e2z4fPzZXd4t5s22oeT\nzOq01dbLswvrdHp42+i9jjIdacIdPatlp/nZ5dXJ0erOjnalV6Z7A6ff3L/X+3v91Z2p02kbpeYC\njPgO3cv7ny9vOzuT55fTo/3pand01L2fTW5enczlSXljfF+wzidNmeT0d54Hk1yvejdWy821WfPq\n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\n\"\"\"\n\nimport sys, base64, zlib\n\n\nclass DictImporter(object):\n    sources = None\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.sources:\n            return self\n        if fullname + '.__init__' in self.sources:\n            return self\n        return None\n\n    def load_module(self, fullname):\n        try:\n            s = self.sources[fullname]\n            is_pkg = False\n        except KeyError:\n            s = self.sources[fullname + '.__init__']\n            is_pkg = True\n\n        co = compile(s, fullname, 'exec')\n        module = sys.modules.setdefault(fullname, type(sys)(fullname))\n        module.__file__ = __file__\n        module.__loader__ = self\n        if is_pkg:\n            module.__path__ = [fullname]\n\n        do_exec(co, module.__dict__)\n        return sys.modules[fullname]\n\n    def get_source(self, name):\n        res = self.sources.get(name)\n        if res is None:\n            res = self.sources.get(name + '.__init__')\n        return res\n\n\nif sys.version_info >= (3, 0):\n    import pickle\n    exec(\"def do_exec(co, loc): exec(co, loc)\\n\")\n    sources = sources.encode(\"ascii\")  # ensure bytes\n    d = zlib.decompress(base64.decodebytes(sources))\n    sources = pickle.loads(zlib.decompress(base64.decodebytes(sources)), encoding=\"utf-8\")\nelse:\n    import cPickle as pickle\n    exec(\"def do_exec(co, loc): exec co in loc\\n\")\n    sources = pickle.loads(zlib.decompress(base64.decodestring(sources)))\n\nimporter = DictImporter()\nimporter.sources = sources\nsys.meta_path.append(importer)\n\nif __name__ == \"__main__\":\n    from pypiserver import core\n    core.DEFAULT_SERVER = \"waitress\"\n    core.main()\n", "tests/test_all.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2013 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport logging\nimport os\nimport sys\n\nfrom compat import unittest\n\n# Always find our sources first\nsys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))\nimport distlib_tests\n\nsys.path.pop(0)\n\n\ndef main():\n    verbosity = 1\n    if '-v' in sys.argv:\n        verbosity = 2\n    loader = unittest.TestLoader()\n    failfast = 'FAILFAST' in os.environ\n    runner = unittest.TextTestRunner(verbosity=verbosity, failfast=failfast)\n    results = runner.run(loader.loadTestsFromModule(distlib_tests))\n    return not results.wasSuccessful()\n\n\nif __name__ == '__main__':\n    here = os.path.dirname(os.path.abspath(__file__))\n    rundir = os.path.join(here, 'run')\n    if not os.path.exists(rundir):\n        os.mkdir(rundir)\n    elif not os.path.isdir(rundir):\n        raise ValueError('Not a directory: %r' % rundir)\n    fn = os.path.join(rundir, 'test_all_%d.%d.log' % sys.version_info[:2])\n    logging.basicConfig(level=logging.DEBUG,\n                        filename=fn,\n                        filemode='w',\n                        format='%(levelname)-8s %(name)-20s %(message)s')\n    sys.exit(main())\n", "tests/compat.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport sys\n\nimport unittest\n\n_ver = sys.version_info[:2]\n\nif _ver[0] < 3:\n    import Queue as queue\n    from SimpleXMLRPCServer import SimpleXMLRPCServer\n    from SimpleHTTPServer import SimpleHTTPRequestHandler\n    from BaseHTTPServer import HTTPServer\n    text_type = unicode\n    from urllib import unquote\n    from urllib2 import Request\n    from urlparse import urlparse\nelse:\n    import queue\n    from xmlrpc.server import SimpleXMLRPCServer\n    from http.server import HTTPServer, SimpleHTTPRequestHandler\n    text_type = str\n    from urllib.parse import urlparse, unquote\n    from urllib.request import Request\n", "tests/foofoo/__init__.py": "# empty\n", "tests/foofoo/bar/__init__.py": "# empty\n", "tests/foofoo/bar/baz.py": "# This is baz\n", "tests/testdist-0.1/testdist.py": "\"\"\"\nThis is a test distribution for distlib.\n\"\"\"\n\n__author__  = \"Test User <test.user@testusers.org>\"\n__status__  = \"alpha\"\n__version__ = \"0.1\"\n__date__    = \"31 January 2013\"\n\n", "tests/scripts/script4.py": "#!pythonw\npass\n\n", "tests/scripts/script6.py": "#!python\nimport sys\nimport os\ninput = repr(sys.stdin.read())\nprint(os.path.basename(sys.argv[0]))\nprint(sys.argv[1:])\nprint(input)\nif __debug__:\n    print('non-optimized')\n", "tests/scripts/script5.py": "#!python -mzippy.activate\npass\n", "tests/scripts/script3.py": "#!/usr/local/bin/python\npass\n\n", "tests/scripts/script8.py": "#!python\nimport sys\nprint(sys.executable)\n", "tests/scripts/script2.py": "#!/usr/bin/python\npass\n\n", "tests/scripts/foo.py": "def main():\n    print('Hello from foo')\n\ndef other_main():\n    print('Hello again from foo')\n\n", "tests/scripts/script1.py": "#! /usr/bin/env python2.3\npass\n\n", "tests/fake_dists/grammar-1.0a4/grammar/utils.py": "# -*- coding: utf-8 -*-\nfrom random import randint\n\ndef is_valid_grammar(sentence):\n    if randint(0, 10) < 2:\n        return False\n    else:\n        return True\n", "tests/fake_dists/grammar-1.0a4/grammar/__init__.py": "# -*- coding: utf-8 -*-\n", "tests/fake_dists/choxie-2.0.0.9/truffles.py": "# -*- coding: utf-8 -*-\nfrom choxie.chocolate import Chocolate\n\nclass Truffle(Chocolate):\n    \"\"\"A truffle.\"\"\"\n", "tests/fake_dists/choxie-2.0.0.9/choxie/chocolate.py": "# -*- coding: utf-8 -*-\nfrom towel_stuff import Towel\n\nclass Chocolate(object):\n    \"\"\"A piece of chocolate.\"\"\"\n\n    def wrap_with_towel(self):\n        towel = Towel()\n        towel.wrap(self)\n        return towel\n", "tests/fake_dists/choxie-2.0.0.9/choxie/__init__.py": "# -*- coding: utf-8 -*-\n", "tests/fake_dists/towel_stuff-0.1/towel_stuff/__init__.py": "# -*- coding: utf-8 -*-\n\nclass Towel(object):\n    \"\"\"A towel, that one should never be without.\"\"\"\n\n    def __init__(self, color='tie-dye'):\n        self.color = color\n        self.wrapped_obj = None\n\n    def wrap(self, obj):\n        \"\"\"Wrap an object up in our towel.\"\"\"\n        self.wrapped_obj = obj\n\n    def unwrap(self):\n        \"\"\"Unwrap whatever is in our towel and return whatever it is.\"\"\"\n        obj = self.wrapped_obj\n        self.wrapped_obj = None\n        return obj\n", "tests/test_testdist-0.1/testdist.py": "\"\"\"\nThis is a test distribution for distlib.\n\"\"\"\n\n__author__  = \"Test User <test.user@testusers.org>\"\n__status__  = \"alpha\"\n__version__ = \"0.1\"\n__date__    = \"31 January 2013\"\n\n", "distlib/locators.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\nimport gzip\nfrom io import BytesIO\nimport json\nimport logging\nimport os\nimport posixpath\nimport re\ntry:\n    import threading\nexcept ImportError:  # pragma: no cover\n    import dummy_threading as threading\nimport zlib\n\nfrom . import DistlibException\nfrom .compat import (urljoin, urlparse, urlunparse, url2pathname, pathname2url, queue, quote, unescape, build_opener,\n                     HTTPRedirectHandler as BaseRedirectHandler, text_type, Request, HTTPError, URLError)\nfrom .database import Distribution, DistributionPath, make_dist\nfrom .metadata import Metadata, MetadataInvalidError\nfrom .util import (cached_property, ensure_slash, split_filename, get_project_data, parse_requirement,\n                   parse_name_and_version, ServerProxy, normalize_name)\nfrom .version import get_scheme, UnsupportedVersionError\nfrom .wheel import Wheel, is_compatible\n\nlogger = logging.getLogger(__name__)\n\nHASHER_HASH = re.compile(r'^(\\w+)=([a-f0-9]+)')\nCHARSET = re.compile(r';\\s*charset\\s*=\\s*(.*)\\s*$', re.I)\nHTML_CONTENT_TYPE = re.compile('text/html|application/x(ht)?ml')\nDEFAULT_INDEX = 'https://pypi.org/pypi'\n\n\ndef get_all_distribution_names(url=None):\n    \"\"\"\n    Return all distribution names known by an index.\n    :param url: The URL of the index.\n    :return: A list of all known distribution names.\n    \"\"\"\n    if url is None:\n        url = DEFAULT_INDEX\n    client = ServerProxy(url, timeout=3.0)\n    try:\n        return client.list_packages()\n    finally:\n        client('close')()\n\n\nclass RedirectHandler(BaseRedirectHandler):\n    \"\"\"\n    A class to work around a bug in some Python 3.2.x releases.\n    \"\"\"\n\n    # There's a bug in the base version for some 3.2.x\n    # (e.g. 3.2.2 on Ubuntu Oneiric). If a Location header\n    # returns e.g. /abc, it bails because it says the scheme ''\n    # is bogus, when actually it should use the request's\n    # URL for the scheme. See Python issue #13696.\n    def http_error_302(self, req, fp, code, msg, headers):\n        # Some servers (incorrectly) return multiple Location headers\n        # (so probably same goes for URI).  Use first header.\n        newurl = None\n        for key in ('location', 'uri'):\n            if key in headers:\n                newurl = headers[key]\n                break\n        if newurl is None:  # pragma: no cover\n            return\n        urlparts = urlparse(newurl)\n        if urlparts.scheme == '':\n            newurl = urljoin(req.get_full_url(), newurl)\n            if hasattr(headers, 'replace_header'):\n                headers.replace_header(key, newurl)\n            else:\n                headers[key] = newurl\n        return BaseRedirectHandler.http_error_302(self, req, fp, code, msg, headers)\n\n    http_error_301 = http_error_303 = http_error_307 = http_error_302\n\n\nclass Locator(object):\n    \"\"\"\n    A base class for locators - things that locate distributions.\n    \"\"\"\n    source_extensions = ('.tar.gz', '.tar.bz2', '.tar', '.zip', '.tgz', '.tbz')\n    binary_extensions = ('.egg', '.exe', '.whl')\n    excluded_extensions = ('.pdf', )\n\n    # A list of tags indicating which wheels you want to match. The default\n    # value of None matches against the tags compatible with the running\n    # Python. If you want to match other values, set wheel_tags on a locator\n    # instance to a list of tuples (pyver, abi, arch) which you want to match.\n    wheel_tags = None\n\n    downloadable_extensions = source_extensions + ('.whl', )\n\n    def __init__(self, scheme='default'):\n        \"\"\"\n        Initialise an instance.\n        :param scheme: Because locators look for most recent versions, they\n                       need to know the version scheme to use. This specifies\n                       the current PEP-recommended scheme - use ``'legacy'``\n                       if you need to support existing distributions on PyPI.\n        \"\"\"\n        self._cache = {}\n        self.scheme = scheme\n        # Because of bugs in some of the handlers on some of the platforms,\n        # we use our own opener rather than just using urlopen.\n        self.opener = build_opener(RedirectHandler())\n        # If get_project() is called from locate(), the matcher instance\n        # is set from the requirement passed to locate(). See issue #18 for\n        # why this can be useful to know.\n        self.matcher = None\n        self.errors = queue.Queue()\n\n    def get_errors(self):\n        \"\"\"\n        Return any errors which have occurred.\n        \"\"\"\n        result = []\n        while not self.errors.empty():  # pragma: no cover\n            try:\n                e = self.errors.get(False)\n                result.append(e)\n            except self.errors.Empty:\n                continue\n            self.errors.task_done()\n        return result\n\n    def clear_errors(self):\n        \"\"\"\n        Clear any errors which may have been logged.\n        \"\"\"\n        # Just get the errors and throw them away\n        self.get_errors()\n\n    def clear_cache(self):\n        self._cache.clear()\n\n    def _get_scheme(self):\n        return self._scheme\n\n    def _set_scheme(self, value):\n        self._scheme = value\n\n    scheme = property(_get_scheme, _set_scheme)\n\n    def _get_project(self, name):\n        \"\"\"\n        For a given project, get a dictionary mapping available versions to Distribution\n        instances.\n\n        This should be implemented in subclasses.\n\n        If called from a locate() request, self.matcher will be set to a\n        matcher for the requirement to satisfy, otherwise it will be None.\n        \"\"\"\n        raise NotImplementedError('Please implement in the subclass')\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        raise NotImplementedError('Please implement in the subclass')\n\n    def get_project(self, name):\n        \"\"\"\n        For a given project, get a dictionary mapping available versions to Distribution\n        instances.\n\n        This calls _get_project to do all the work, and just implements a caching layer on top.\n        \"\"\"\n        if self._cache is None:  # pragma: no cover\n            result = self._get_project(name)\n        elif name in self._cache:\n            result = self._cache[name]\n        else:\n            self.clear_errors()\n            result = self._get_project(name)\n            self._cache[name] = result\n        return result\n\n    def score_url(self, url):\n        \"\"\"\n        Give an url a score which can be used to choose preferred URLs\n        for a given project release.\n        \"\"\"\n        t = urlparse(url)\n        basename = posixpath.basename(t.path)\n        compatible = True\n        is_wheel = basename.endswith('.whl')\n        is_downloadable = basename.endswith(self.downloadable_extensions)\n        if is_wheel:\n            compatible = is_compatible(Wheel(basename), self.wheel_tags)\n        return (t.scheme == 'https', 'pypi.org' in t.netloc, is_downloadable, is_wheel, compatible, basename)\n\n    def prefer_url(self, url1, url2):\n        \"\"\"\n        Choose one of two URLs where both are candidates for distribution\n        archives for the same version of a distribution (for example,\n        .tar.gz vs. zip).\n\n        The current implementation favours https:// URLs over http://, archives\n        from PyPI over those from other locations, wheel compatibility (if a\n        wheel) and then the archive name.\n        \"\"\"\n        result = url2\n        if url1:\n            s1 = self.score_url(url1)\n            s2 = self.score_url(url2)\n            if s1 > s2:\n                result = url1\n            if result != url2:\n                logger.debug('Not replacing %r with %r', url1, url2)\n            else:\n                logger.debug('Replacing %r with %r', url1, url2)\n        return result\n\n    def split_filename(self, filename, project_name):\n        \"\"\"\n        Attempt to split a filename in project name, version and Python version.\n        \"\"\"\n        return split_filename(filename, project_name)\n\n    def convert_url_to_download_info(self, url, project_name):\n        \"\"\"\n        See if a URL is a candidate for a download URL for a project (the URL\n        has typically been scraped from an HTML page).\n\n        If it is, a dictionary is returned with keys \"name\", \"version\",\n        \"filename\" and \"url\"; otherwise, None is returned.\n        \"\"\"\n\n        def same_project(name1, name2):\n            return normalize_name(name1) == normalize_name(name2)\n\n        result = None\n        scheme, netloc, path, params, query, frag = urlparse(url)\n        if frag.lower().startswith('egg='):  # pragma: no cover\n            logger.debug('%s: version hint in fragment: %r', project_name, frag)\n        m = HASHER_HASH.match(frag)\n        if m:\n            algo, digest = m.groups()\n        else:\n            algo, digest = None, None\n        origpath = path\n        if path and path[-1] == '/':  # pragma: no cover\n            path = path[:-1]\n        if path.endswith('.whl'):\n            try:\n                wheel = Wheel(path)\n                if not is_compatible(wheel, self.wheel_tags):\n                    logger.debug('Wheel not compatible: %s', path)\n                else:\n                    if project_name is None:\n                        include = True\n                    else:\n                        include = same_project(wheel.name, project_name)\n                    if include:\n                        result = {\n                            'name': wheel.name,\n                            'version': wheel.version,\n                            'filename': wheel.filename,\n                            'url': urlunparse((scheme, netloc, origpath, params, query, '')),\n                            'python-version': ', '.join(['.'.join(list(v[2:])) for v in wheel.pyver]),\n                        }\n            except Exception:  # pragma: no cover\n                logger.warning('invalid path for wheel: %s', path)\n        elif not path.endswith(self.downloadable_extensions):  # pragma: no cover\n            logger.debug('Not downloadable: %s', path)\n        else:  # downloadable extension\n            path = filename = posixpath.basename(path)\n            for ext in self.downloadable_extensions:\n                if path.endswith(ext):\n                    path = path[:-len(ext)]\n                    t = self.split_filename(path, project_name)\n                    if not t:  # pragma: no cover\n                        logger.debug('No match for project/version: %s', path)\n                    else:\n                        name, version, pyver = t\n                        if not project_name or same_project(project_name, name):\n                            result = {\n                                'name': name,\n                                'version': version,\n                                'filename': filename,\n                                'url': urlunparse((scheme, netloc, origpath, params, query, '')),\n                            }\n                            if pyver:  # pragma: no cover\n                                result['python-version'] = pyver\n                    break\n        if result and algo:\n            result['%s_digest' % algo] = digest\n        return result\n\n    def _get_digest(self, info):\n        \"\"\"\n        Get a digest from a dictionary by looking at a \"digests\" dictionary\n        or keys of the form 'algo_digest'.\n\n        Returns a 2-tuple (algo, digest) if found, else None. Currently\n        looks only for SHA256, then MD5.\n        \"\"\"\n        result = None\n        if 'digests' in info:\n            digests = info['digests']\n            for algo in ('sha256', 'md5'):\n                if algo in digests:\n                    result = (algo, digests[algo])\n                    break\n        if not result:\n            for algo in ('sha256', 'md5'):\n                key = '%s_digest' % algo\n                if key in info:\n                    result = (algo, info[key])\n                    break\n        return result\n\n    def _update_version_data(self, result, info):\n        \"\"\"\n        Update a result dictionary (the final result from _get_project) with a\n        dictionary for a specific version, which typically holds information\n        gleaned from a filename or URL for an archive for the distribution.\n        \"\"\"\n        name = info.pop('name')\n        version = info.pop('version')\n        if version in result:\n            dist = result[version]\n            md = dist.metadata\n        else:\n            dist = make_dist(name, version, scheme=self.scheme)\n            md = dist.metadata\n        dist.digest = digest = self._get_digest(info)\n        url = info['url']\n        result['digests'][url] = digest\n        if md.source_url != info['url']:\n            md.source_url = self.prefer_url(md.source_url, url)\n            result['urls'].setdefault(version, set()).add(url)\n        dist.locator = self\n        result[version] = dist\n\n    def locate(self, requirement, prereleases=False):\n        \"\"\"\n        Find the most recent distribution which matches the given\n        requirement.\n\n        :param requirement: A requirement of the form 'foo (1.0)' or perhaps\n                            'foo (>= 1.0, < 2.0, != 1.3)'\n        :param prereleases: If ``True``, allow pre-release versions\n                            to be located. Otherwise, pre-release versions\n                            are not returned.\n        :return: A :class:`Distribution` instance, or ``None`` if no such\n                 distribution could be located.\n        \"\"\"\n        result = None\n        r = parse_requirement(requirement)\n        if r is None:  # pragma: no cover\n            raise DistlibException('Not a valid requirement: %r' % requirement)\n        scheme = get_scheme(self.scheme)\n        self.matcher = matcher = scheme.matcher(r.requirement)\n        logger.debug('matcher: %s (%s)', matcher, type(matcher).__name__)\n        versions = self.get_project(r.name)\n        if len(versions) > 2:  # urls and digests keys are present\n            # sometimes, versions are invalid\n            slist = []\n            vcls = matcher.version_class\n            for k in versions:\n                if k in ('urls', 'digests'):\n                    continue\n                try:\n                    if not matcher.match(k):\n                        pass  # logger.debug('%s did not match %r', matcher, k)\n                    else:\n                        if prereleases or not vcls(k).is_prerelease:\n                            slist.append(k)\n                except Exception:  # pragma: no cover\n                    logger.warning('error matching %s with %r', matcher, k)\n                    pass  # slist.append(k)\n            if len(slist) > 1:\n                slist = sorted(slist, key=scheme.key)\n            if slist:\n                logger.debug('sorted list: %s', slist)\n                version = slist[-1]\n                result = versions[version]\n        if result:\n            if r.extras:\n                result.extras = r.extras\n            result.download_urls = versions.get('urls', {}).get(version, set())\n            d = {}\n            sd = versions.get('digests', {})\n            for url in result.download_urls:\n                if url in sd:  # pragma: no cover\n                    d[url] = sd[url]\n            result.digests = d\n        self.matcher = None\n        return result\n\n\nclass PyPIRPCLocator(Locator):\n    \"\"\"\n    This locator uses XML-RPC to locate distributions. It therefore\n    cannot be used with simple mirrors (that only mirror file content).\n    \"\"\"\n\n    def __init__(self, url, **kwargs):\n        \"\"\"\n        Initialise an instance.\n\n        :param url: The URL to use for XML-RPC.\n        :param kwargs: Passed to the superclass constructor.\n        \"\"\"\n        super(PyPIRPCLocator, self).__init__(**kwargs)\n        self.base_url = url\n        self.client = ServerProxy(url, timeout=3.0)\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        return set(self.client.list_packages())\n\n    def _get_project(self, name):\n        result = {'urls': {}, 'digests': {}}\n        versions = self.client.package_releases(name, True)\n        for v in versions:\n            urls = self.client.release_urls(name, v)\n            data = self.client.release_data(name, v)\n            metadata = Metadata(scheme=self.scheme)\n            metadata.name = data['name']\n            metadata.version = data['version']\n            metadata.license = data.get('license')\n            metadata.keywords = data.get('keywords', [])\n            metadata.summary = data.get('summary')\n            dist = Distribution(metadata)\n            if urls:\n                info = urls[0]\n                metadata.source_url = info['url']\n                dist.digest = self._get_digest(info)\n                dist.locator = self\n                result[v] = dist\n                for info in urls:\n                    url = info['url']\n                    digest = self._get_digest(info)\n                    result['urls'].setdefault(v, set()).add(url)\n                    result['digests'][url] = digest\n        return result\n\n\nclass PyPIJSONLocator(Locator):\n    \"\"\"\n    This locator uses PyPI's JSON interface. It's very limited in functionality\n    and probably not worth using.\n    \"\"\"\n\n    def __init__(self, url, **kwargs):\n        super(PyPIJSONLocator, self).__init__(**kwargs)\n        self.base_url = ensure_slash(url)\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        raise NotImplementedError('Not available from this locator')\n\n    def _get_project(self, name):\n        result = {'urls': {}, 'digests': {}}\n        url = urljoin(self.base_url, '%s/json' % quote(name))\n        try:\n            resp = self.opener.open(url)\n            data = resp.read().decode()  # for now\n            d = json.loads(data)\n            md = Metadata(scheme=self.scheme)\n            data = d['info']\n            md.name = data['name']\n            md.version = data['version']\n            md.license = data.get('license')\n            md.keywords = data.get('keywords', [])\n            md.summary = data.get('summary')\n            dist = Distribution(md)\n            dist.locator = self\n            # urls = d['urls']\n            result[md.version] = dist\n            for info in d['urls']:\n                url = info['url']\n                dist.download_urls.add(url)\n                dist.digests[url] = self._get_digest(info)\n                result['urls'].setdefault(md.version, set()).add(url)\n                result['digests'][url] = self._get_digest(info)\n            # Now get other releases\n            for version, infos in d['releases'].items():\n                if version == md.version:\n                    continue  # already done\n                omd = Metadata(scheme=self.scheme)\n                omd.name = md.name\n                omd.version = version\n                odist = Distribution(omd)\n                odist.locator = self\n                result[version] = odist\n                for info in infos:\n                    url = info['url']\n                    odist.download_urls.add(url)\n                    odist.digests[url] = self._get_digest(info)\n                    result['urls'].setdefault(version, set()).add(url)\n                    result['digests'][url] = self._get_digest(info)\n\n\n#            for info in urls:\n#                md.source_url = info['url']\n#                dist.digest = self._get_digest(info)\n#                dist.locator = self\n#                for info in urls:\n#                    url = info['url']\n#                    result['urls'].setdefault(md.version, set()).add(url)\n#                    result['digests'][url] = self._get_digest(info)\n        except Exception as e:\n            self.errors.put(text_type(e))\n            logger.exception('JSON fetch failed: %s', e)\n        return result\n\n\nclass Page(object):\n    \"\"\"\n    This class represents a scraped HTML page.\n    \"\"\"\n    # The following slightly hairy-looking regex just looks for the contents of\n    # an anchor link, which has an attribute \"href\" either immediately preceded\n    # or immediately followed by a \"rel\" attribute. The attribute values can be\n    # declared with double quotes, single quotes or no quotes - which leads to\n    # the length of the expression.\n    _href = re.compile(\n        \"\"\"\n(rel\\\\s*=\\\\s*(?:\"(?P<rel1>[^\"]*)\"|'(?P<rel2>[^']*)'|(?P<rel3>[^>\\\\s\\n]*))\\\\s+)?\nhref\\\\s*=\\\\s*(?:\"(?P<url1>[^\"]*)\"|'(?P<url2>[^']*)'|(?P<url3>[^>\\\\s\\n]*))\n(\\\\s+rel\\\\s*=\\\\s*(?:\"(?P<rel4>[^\"]*)\"|'(?P<rel5>[^']*)'|(?P<rel6>[^>\\\\s\\n]*)))?\n\"\"\", re.I | re.S | re.X)\n    _base = re.compile(r\"\"\"<base\\s+href\\s*=\\s*['\"]?([^'\">]+)\"\"\", re.I | re.S)\n\n    def __init__(self, data, url):\n        \"\"\"\n        Initialise an instance with the Unicode page contents and the URL they\n        came from.\n        \"\"\"\n        self.data = data\n        self.base_url = self.url = url\n        m = self._base.search(self.data)\n        if m:\n            self.base_url = m.group(1)\n\n    _clean_re = re.compile(r'[^a-z0-9$&+,/:;=?@.#%_\\\\|-]', re.I)\n\n    @cached_property\n    def links(self):\n        \"\"\"\n        Return the URLs of all the links on a page together with information\n        about their \"rel\" attribute, for determining which ones to treat as\n        downloads and which ones to queue for further scraping.\n        \"\"\"\n\n        def clean(url):\n            \"Tidy up an URL.\"\n            scheme, netloc, path, params, query, frag = urlparse(url)\n            return urlunparse((scheme, netloc, quote(path), params, query, frag))\n\n        result = set()\n        for match in self._href.finditer(self.data):\n            d = match.groupdict('')\n            rel = (d['rel1'] or d['rel2'] or d['rel3'] or d['rel4'] or d['rel5'] or d['rel6'])\n            url = d['url1'] or d['url2'] or d['url3']\n            url = urljoin(self.base_url, url)\n            url = unescape(url)\n            url = self._clean_re.sub(lambda m: '%%%2x' % ord(m.group(0)), url)\n            result.add((url, rel))\n        # We sort the result, hoping to bring the most recent versions\n        # to the front\n        result = sorted(result, key=lambda t: t[0], reverse=True)\n        return result\n\n\nclass SimpleScrapingLocator(Locator):\n    \"\"\"\n    A locator which scrapes HTML pages to locate downloads for a distribution.\n    This runs multiple threads to do the I/O; performance is at least as good\n    as pip's PackageFinder, which works in an analogous fashion.\n    \"\"\"\n\n    # These are used to deal with various Content-Encoding schemes.\n    decoders = {\n        'deflate': zlib.decompress,\n        'gzip': lambda b: gzip.GzipFile(fileobj=BytesIO(b)).read(),\n        'none': lambda b: b,\n    }\n\n    def __init__(self, url, timeout=None, num_workers=10, **kwargs):\n        \"\"\"\n        Initialise an instance.\n        :param url: The root URL to use for scraping.\n        :param timeout: The timeout, in seconds, to be applied to requests.\n                        This defaults to ``None`` (no timeout specified).\n        :param num_workers: The number of worker threads you want to do I/O,\n                            This defaults to 10.\n        :param kwargs: Passed to the superclass.\n        \"\"\"\n        super(SimpleScrapingLocator, self).__init__(**kwargs)\n        self.base_url = ensure_slash(url)\n        self.timeout = timeout\n        self._page_cache = {}\n        self._seen = set()\n        self._to_fetch = queue.Queue()\n        self._bad_hosts = set()\n        self.skip_externals = False\n        self.num_workers = num_workers\n        self._lock = threading.RLock()\n        # See issue #45: we need to be resilient when the locator is used\n        # in a thread, e.g. with concurrent.futures. We can't use self._lock\n        # as it is for coordinating our internal threads - the ones created\n        # in _prepare_threads.\n        self._gplock = threading.RLock()\n        self.platform_check = False  # See issue #112\n\n    def _prepare_threads(self):\n        \"\"\"\n        Threads are created only when get_project is called, and terminate\n        before it returns. They are there primarily to parallelise I/O (i.e.\n        fetching web pages).\n        \"\"\"\n        self._threads = []\n        for i in range(self.num_workers):\n            t = threading.Thread(target=self._fetch)\n            t.daemon = True\n            t.start()\n            self._threads.append(t)\n\n    def _wait_threads(self):\n        \"\"\"\n        Tell all the threads to terminate (by sending a sentinel value) and\n        wait for them to do so.\n        \"\"\"\n        # Note that you need two loops, since you can't say which\n        # thread will get each sentinel\n        for t in self._threads:\n            self._to_fetch.put(None)  # sentinel\n        for t in self._threads:\n            t.join()\n        self._threads = []\n\n    def _get_project(self, name):\n        result = {'urls': {}, 'digests': {}}\n        with self._gplock:\n            self.result = result\n            self.project_name = name\n            url = urljoin(self.base_url, '%s/' % quote(name))\n            self._seen.clear()\n            self._page_cache.clear()\n            self._prepare_threads()\n            try:\n                logger.debug('Queueing %s', url)\n                self._to_fetch.put(url)\n                self._to_fetch.join()\n            finally:\n                self._wait_threads()\n            del self.result\n        return result\n\n    platform_dependent = re.compile(r'\\b(linux_(i\\d86|x86_64|arm\\w+)|'\n                                    r'win(32|_amd64)|macosx_?\\d+)\\b', re.I)\n\n    def _is_platform_dependent(self, url):\n        \"\"\"\n        Does an URL refer to a platform-specific download?\n        \"\"\"\n        return self.platform_dependent.search(url)\n\n    def _process_download(self, url):\n        \"\"\"\n        See if an URL is a suitable download for a project.\n\n        If it is, register information in the result dictionary (for\n        _get_project) about the specific version it's for.\n\n        Note that the return value isn't actually used other than as a boolean\n        value.\n        \"\"\"\n        if self.platform_check and self._is_platform_dependent(url):\n            info = None\n        else:\n            info = self.convert_url_to_download_info(url, self.project_name)\n        logger.debug('process_download: %s -> %s', url, info)\n        if info:\n            with self._lock:  # needed because self.result is shared\n                self._update_version_data(self.result, info)\n        return info\n\n    def _should_queue(self, link, referrer, rel):\n        \"\"\"\n        Determine whether a link URL from a referring page and with a\n        particular \"rel\" attribute should be queued for scraping.\n        \"\"\"\n        scheme, netloc, path, _, _, _ = urlparse(link)\n        if path.endswith(self.source_extensions + self.binary_extensions + self.excluded_extensions):\n            result = False\n        elif self.skip_externals and not link.startswith(self.base_url):\n            result = False\n        elif not referrer.startswith(self.base_url):\n            result = False\n        elif rel not in ('homepage', 'download'):\n            result = False\n        elif scheme not in ('http', 'https', 'ftp'):\n            result = False\n        elif self._is_platform_dependent(link):\n            result = False\n        else:\n            host = netloc.split(':', 1)[0]\n            if host.lower() == 'localhost':\n                result = False\n            else:\n                result = True\n        logger.debug('should_queue: %s (%s) from %s -> %s', link, rel, referrer, result)\n        return result\n\n    def _fetch(self):\n        \"\"\"\n        Get a URL to fetch from the work queue, get the HTML page, examine its\n        links for download candidates and candidates for further scraping.\n\n        This is a handy method to run in a thread.\n        \"\"\"\n        while True:\n            url = self._to_fetch.get()\n            try:\n                if url:\n                    page = self.get_page(url)\n                    if page is None:  # e.g. after an error\n                        continue\n                    for link, rel in page.links:\n                        if link not in self._seen:\n                            try:\n                                self._seen.add(link)\n                                if (not self._process_download(link) and self._should_queue(link, url, rel)):\n                                    logger.debug('Queueing %s from %s', link, url)\n                                    self._to_fetch.put(link)\n                            except MetadataInvalidError:  # e.g. invalid versions\n                                pass\n            except Exception as e:  # pragma: no cover\n                self.errors.put(text_type(e))\n            finally:\n                # always do this, to avoid hangs :-)\n                self._to_fetch.task_done()\n            if not url:\n                # logger.debug('Sentinel seen, quitting.')\n                break\n\n    def get_page(self, url):\n        \"\"\"\n        Get the HTML for an URL, possibly from an in-memory cache.\n\n        XXX TODO Note: this cache is never actually cleared. It's assumed that\n        the data won't get stale over the lifetime of a locator instance (not\n        necessarily true for the default_locator).\n        \"\"\"\n        # http://peak.telecommunity.com/DevCenter/EasyInstall#package-index-api\n        scheme, netloc, path, _, _, _ = urlparse(url)\n        if scheme == 'file' and os.path.isdir(url2pathname(path)):\n            url = urljoin(ensure_slash(url), 'index.html')\n\n        if url in self._page_cache:\n            result = self._page_cache[url]\n            logger.debug('Returning %s from cache: %s', url, result)\n        else:\n            host = netloc.split(':', 1)[0]\n            result = None\n            if host in self._bad_hosts:\n                logger.debug('Skipping %s due to bad host %s', url, host)\n            else:\n                req = Request(url, headers={'Accept-encoding': 'identity'})\n                try:\n                    logger.debug('Fetching %s', url)\n                    resp = self.opener.open(req, timeout=self.timeout)\n                    logger.debug('Fetched %s', url)\n                    headers = resp.info()\n                    content_type = headers.get('Content-Type', '')\n                    if HTML_CONTENT_TYPE.match(content_type):\n                        final_url = resp.geturl()\n                        data = resp.read()\n                        encoding = headers.get('Content-Encoding')\n                        if encoding:\n                            decoder = self.decoders[encoding]  # fail if not found\n                            data = decoder(data)\n                        encoding = 'utf-8'\n                        m = CHARSET.search(content_type)\n                        if m:\n                            encoding = m.group(1)\n                        try:\n                            data = data.decode(encoding)\n                        except UnicodeError:  # pragma: no cover\n                            data = data.decode('latin-1')  # fallback\n                        result = Page(data, final_url)\n                        self._page_cache[final_url] = result\n                except HTTPError as e:\n                    if e.code != 404:\n                        logger.exception('Fetch failed: %s: %s', url, e)\n                except URLError as e:  # pragma: no cover\n                    logger.exception('Fetch failed: %s: %s', url, e)\n                    with self._lock:\n                        self._bad_hosts.add(host)\n                except Exception as e:  # pragma: no cover\n                    logger.exception('Fetch failed: %s: %s', url, e)\n                finally:\n                    self._page_cache[url] = result  # even if None (failure)\n        return result\n\n    _distname_re = re.compile('<a href=[^>]*>([^<]+)<')\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        result = set()\n        page = self.get_page(self.base_url)\n        if not page:\n            raise DistlibException('Unable to get %s' % self.base_url)\n        for match in self._distname_re.finditer(page.data):\n            result.add(match.group(1))\n        return result\n\n\nclass DirectoryLocator(Locator):\n    \"\"\"\n    This class locates distributions in a directory tree.\n    \"\"\"\n\n    def __init__(self, path, **kwargs):\n        \"\"\"\n        Initialise an instance.\n        :param path: The root of the directory tree to search.\n        :param kwargs: Passed to the superclass constructor,\n                       except for:\n                       * recursive - if True (the default), subdirectories are\n                         recursed into. If False, only the top-level directory\n                         is searched,\n        \"\"\"\n        self.recursive = kwargs.pop('recursive', True)\n        super(DirectoryLocator, self).__init__(**kwargs)\n        path = os.path.abspath(path)\n        if not os.path.isdir(path):  # pragma: no cover\n            raise DistlibException('Not a directory: %r' % path)\n        self.base_dir = path\n\n    def should_include(self, filename, parent):\n        \"\"\"\n        Should a filename be considered as a candidate for a distribution\n        archive? As well as the filename, the directory which contains it\n        is provided, though not used by the current implementation.\n        \"\"\"\n        return filename.endswith(self.downloadable_extensions)\n\n    def _get_project(self, name):\n        result = {'urls': {}, 'digests': {}}\n        for root, dirs, files in os.walk(self.base_dir):\n            for fn in files:\n                if self.should_include(fn, root):\n                    fn = os.path.join(root, fn)\n                    url = urlunparse(('file', '', pathname2url(os.path.abspath(fn)), '', '', ''))\n                    info = self.convert_url_to_download_info(url, name)\n                    if info:\n                        self._update_version_data(result, info)\n            if not self.recursive:\n                break\n        return result\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        result = set()\n        for root, dirs, files in os.walk(self.base_dir):\n            for fn in files:\n                if self.should_include(fn, root):\n                    fn = os.path.join(root, fn)\n                    url = urlunparse(('file', '', pathname2url(os.path.abspath(fn)), '', '', ''))\n                    info = self.convert_url_to_download_info(url, None)\n                    if info:\n                        result.add(info['name'])\n            if not self.recursive:\n                break\n        return result\n\n\nclass JSONLocator(Locator):\n    \"\"\"\n    This locator uses special extended metadata (not available on PyPI) and is\n    the basis of performant dependency resolution in distlib. Other locators\n    require archive downloads before dependencies can be determined! As you\n    might imagine, that can be slow.\n    \"\"\"\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        raise NotImplementedError('Not available from this locator')\n\n    def _get_project(self, name):\n        result = {'urls': {}, 'digests': {}}\n        data = get_project_data(name)\n        if data:\n            for info in data.get('files', []):\n                if info['ptype'] != 'sdist' or info['pyversion'] != 'source':\n                    continue\n                # We don't store summary in project metadata as it makes\n                # the data bigger for no benefit during dependency\n                # resolution\n                dist = make_dist(data['name'],\n                                 info['version'],\n                                 summary=data.get('summary', 'Placeholder for summary'),\n                                 scheme=self.scheme)\n                md = dist.metadata\n                md.source_url = info['url']\n                # TODO SHA256 digest\n                if 'digest' in info and info['digest']:\n                    dist.digest = ('md5', info['digest'])\n                md.dependencies = info.get('requirements', {})\n                dist.exports = info.get('exports', {})\n                result[dist.version] = dist\n                result['urls'].setdefault(dist.version, set()).add(info['url'])\n        return result\n\n\nclass DistPathLocator(Locator):\n    \"\"\"\n    This locator finds installed distributions in a path. It can be useful for\n    adding to an :class:`AggregatingLocator`.\n    \"\"\"\n\n    def __init__(self, distpath, **kwargs):\n        \"\"\"\n        Initialise an instance.\n\n        :param distpath: A :class:`DistributionPath` instance to search.\n        \"\"\"\n        super(DistPathLocator, self).__init__(**kwargs)\n        assert isinstance(distpath, DistributionPath)\n        self.distpath = distpath\n\n    def _get_project(self, name):\n        dist = self.distpath.get_distribution(name)\n        if dist is None:\n            result = {'urls': {}, 'digests': {}}\n        else:\n            result = {\n                dist.version: dist,\n                'urls': {\n                    dist.version: set([dist.source_url])\n                },\n                'digests': {\n                    dist.version: set([None])\n                }\n            }\n        return result\n\n\nclass AggregatingLocator(Locator):\n    \"\"\"\n    This class allows you to chain and/or merge a list of locators.\n    \"\"\"\n\n    def __init__(self, *locators, **kwargs):\n        \"\"\"\n        Initialise an instance.\n\n        :param locators: The list of locators to search.\n        :param kwargs: Passed to the superclass constructor,\n                       except for:\n                       * merge - if False (the default), the first successful\n                         search from any of the locators is returned. If True,\n                         the results from all locators are merged (this can be\n                         slow).\n        \"\"\"\n        self.merge = kwargs.pop('merge', False)\n        self.locators = locators\n        super(AggregatingLocator, self).__init__(**kwargs)\n\n    def clear_cache(self):\n        super(AggregatingLocator, self).clear_cache()\n        for locator in self.locators:\n            locator.clear_cache()\n\n    def _set_scheme(self, value):\n        self._scheme = value\n        for locator in self.locators:\n            locator.scheme = value\n\n    scheme = property(Locator.scheme.fget, _set_scheme)\n\n    def _get_project(self, name):\n        result = {}\n        for locator in self.locators:\n            d = locator.get_project(name)\n            if d:\n                if self.merge:\n                    files = result.get('urls', {})\n                    digests = result.get('digests', {})\n                    # next line could overwrite result['urls'], result['digests']\n                    result.update(d)\n                    df = result.get('urls')\n                    if files and df:\n                        for k, v in files.items():\n                            if k in df:\n                                df[k] |= v\n                            else:\n                                df[k] = v\n                    dd = result.get('digests')\n                    if digests and dd:\n                        dd.update(digests)\n                else:\n                    # See issue #18. If any dists are found and we're looking\n                    # for specific constraints, we only return something if\n                    # a match is found. For example, if a DirectoryLocator\n                    # returns just foo (1.0) while we're looking for\n                    # foo (>= 2.0), we'll pretend there was nothing there so\n                    # that subsequent locators can be queried. Otherwise we\n                    # would just return foo (1.0) which would then lead to a\n                    # failure to find foo (>= 2.0), because other locators\n                    # weren't searched. Note that this only matters when\n                    # merge=False.\n                    if self.matcher is None:\n                        found = True\n                    else:\n                        found = False\n                        for k in d:\n                            if self.matcher.match(k):\n                                found = True\n                                break\n                    if found:\n                        result = d\n                        break\n        return result\n\n    def get_distribution_names(self):\n        \"\"\"\n        Return all the distribution names known to this locator.\n        \"\"\"\n        result = set()\n        for locator in self.locators:\n            try:\n                result |= locator.get_distribution_names()\n            except NotImplementedError:\n                pass\n        return result\n\n\n# We use a legacy scheme simply because most of the dists on PyPI use legacy\n# versions which don't conform to PEP 440.\ndefault_locator = AggregatingLocator(\n    # JSONLocator(), # don't use as PEP 426 is withdrawn\n    SimpleScrapingLocator('https://pypi.org/simple/', timeout=3.0),\n    scheme='legacy')\n\nlocate = default_locator.locate\n\n\nclass DependencyFinder(object):\n    \"\"\"\n    Locate dependencies for distributions.\n    \"\"\"\n\n    def __init__(self, locator=None):\n        \"\"\"\n        Initialise an instance, using the specified locator\n        to locate distributions.\n        \"\"\"\n        self.locator = locator or default_locator\n        self.scheme = get_scheme(self.locator.scheme)\n\n    def add_distribution(self, dist):\n        \"\"\"\n        Add a distribution to the finder. This will update internal information\n        about who provides what.\n        :param dist: The distribution to add.\n        \"\"\"\n        logger.debug('adding distribution %s', dist)\n        name = dist.key\n        self.dists_by_name[name] = dist\n        self.dists[(name, dist.version)] = dist\n        for p in dist.provides:\n            name, version = parse_name_and_version(p)\n            logger.debug('Add to provided: %s, %s, %s', name, version, dist)\n            self.provided.setdefault(name, set()).add((version, dist))\n\n    def remove_distribution(self, dist):\n        \"\"\"\n        Remove a distribution from the finder. This will update internal\n        information about who provides what.\n        :param dist: The distribution to remove.\n        \"\"\"\n        logger.debug('removing distribution %s', dist)\n        name = dist.key\n        del self.dists_by_name[name]\n        del self.dists[(name, dist.version)]\n        for p in dist.provides:\n            name, version = parse_name_and_version(p)\n            logger.debug('Remove from provided: %s, %s, %s', name, version, dist)\n            s = self.provided[name]\n            s.remove((version, dist))\n            if not s:\n                del self.provided[name]\n\n    def get_matcher(self, reqt):\n        \"\"\"\n        Get a version matcher for a requirement.\n        :param reqt: The requirement\n        :type reqt: str\n        :return: A version matcher (an instance of\n                 :class:`distlib.version.Matcher`).\n        \"\"\"\n        try:\n            matcher = self.scheme.matcher(reqt)\n        except UnsupportedVersionError:  # pragma: no cover\n            # XXX compat-mode if cannot read the version\n            name = reqt.split()[0]\n            matcher = self.scheme.matcher(name)\n        return matcher\n\n    def find_providers(self, reqt):\n        \"\"\"\n        Find the distributions which can fulfill a requirement.\n\n        :param reqt: The requirement.\n         :type reqt: str\n        :return: A set of distribution which can fulfill the requirement.\n        \"\"\"\n        matcher = self.get_matcher(reqt)\n        name = matcher.key  # case-insensitive\n        result = set()\n        provided = self.provided\n        if name in provided:\n            for version, provider in provided[name]:\n                try:\n                    match = matcher.match(version)\n                except UnsupportedVersionError:\n                    match = False\n\n                if match:\n                    result.add(provider)\n                    break\n        return result\n\n    def try_to_replace(self, provider, other, problems):\n        \"\"\"\n        Attempt to replace one provider with another. This is typically used\n        when resolving dependencies from multiple sources, e.g. A requires\n        (B >= 1.0) while C requires (B >= 1.1).\n\n        For successful replacement, ``provider`` must meet all the requirements\n        which ``other`` fulfills.\n\n        :param provider: The provider we are trying to replace with.\n        :param other: The provider we're trying to replace.\n        :param problems: If False is returned, this will contain what\n                         problems prevented replacement. This is currently\n                         a tuple of the literal string 'cantreplace',\n                         ``provider``, ``other``  and the set of requirements\n                         that ``provider`` couldn't fulfill.\n        :return: True if we can replace ``other`` with ``provider``, else\n                 False.\n        \"\"\"\n        rlist = self.reqts[other]\n        unmatched = set()\n        for s in rlist:\n            matcher = self.get_matcher(s)\n            if not matcher.match(provider.version):\n                unmatched.add(s)\n        if unmatched:\n            # can't replace other with provider\n            problems.add(('cantreplace', provider, other, frozenset(unmatched)))\n            result = False\n        else:\n            # can replace other with provider\n            self.remove_distribution(other)\n            del self.reqts[other]\n            for s in rlist:\n                self.reqts.setdefault(provider, set()).add(s)\n            self.add_distribution(provider)\n            result = True\n        return result\n\n    def find(self, requirement, meta_extras=None, prereleases=False):\n        \"\"\"\n        Find a distribution and all distributions it depends on.\n\n        :param requirement: The requirement specifying the distribution to\n                            find, or a Distribution instance.\n        :param meta_extras: A list of meta extras such as :test:, :build: and\n                            so on.\n        :param prereleases: If ``True``, allow pre-release versions to be\n                            returned - otherwise, don't return prereleases\n                            unless they're all that's available.\n\n        Return a set of :class:`Distribution` instances and a set of\n        problems.\n\n        The distributions returned should be such that they have the\n        :attr:`required` attribute set to ``True`` if they were\n        from the ``requirement`` passed to ``find()``, and they have the\n        :attr:`build_time_dependency` attribute set to ``True`` unless they\n        are post-installation dependencies of the ``requirement``.\n\n        The problems should be a tuple consisting of the string\n        ``'unsatisfied'`` and the requirement which couldn't be satisfied\n        by any distribution known to the locator.\n        \"\"\"\n\n        self.provided = {}\n        self.dists = {}\n        self.dists_by_name = {}\n        self.reqts = {}\n\n        meta_extras = set(meta_extras or [])\n        if ':*:' in meta_extras:\n            meta_extras.remove(':*:')\n            # :meta: and :run: are implicitly included\n            meta_extras |= set([':test:', ':build:', ':dev:'])\n\n        if isinstance(requirement, Distribution):\n            dist = odist = requirement\n            logger.debug('passed %s as requirement', odist)\n        else:\n            dist = odist = self.locator.locate(requirement, prereleases=prereleases)\n            if dist is None:\n                raise DistlibException('Unable to locate %r' % requirement)\n            logger.debug('located %s', odist)\n        dist.requested = True\n        problems = set()\n        todo = set([dist])\n        install_dists = set([odist])\n        while todo:\n            dist = todo.pop()\n            name = dist.key  # case-insensitive\n            if name not in self.dists_by_name:\n                self.add_distribution(dist)\n            else:\n                # import pdb; pdb.set_trace()\n                other = self.dists_by_name[name]\n                if other != dist:\n                    self.try_to_replace(dist, other, problems)\n\n            ireqts = dist.run_requires | dist.meta_requires\n            sreqts = dist.build_requires\n            ereqts = set()\n            if meta_extras and dist in install_dists:\n                for key in ('test', 'build', 'dev'):\n                    e = ':%s:' % key\n                    if e in meta_extras:\n                        ereqts |= getattr(dist, '%s_requires' % key)\n            all_reqts = ireqts | sreqts | ereqts\n            for r in all_reqts:\n                providers = self.find_providers(r)\n                if not providers:\n                    logger.debug('No providers found for %r', r)\n                    provider = self.locator.locate(r, prereleases=prereleases)\n                    # If no provider is found and we didn't consider\n                    # prereleases, consider them now.\n                    if provider is None and not prereleases:\n                        provider = self.locator.locate(r, prereleases=True)\n                    if provider is None:\n                        logger.debug('Cannot satisfy %r', r)\n                        problems.add(('unsatisfied', r))\n                    else:\n                        n, v = provider.key, provider.version\n                        if (n, v) not in self.dists:\n                            todo.add(provider)\n                        providers.add(provider)\n                        if r in ireqts and dist in install_dists:\n                            install_dists.add(provider)\n                            logger.debug('Adding %s to install_dists', provider.name_and_version)\n                for p in providers:\n                    name = p.key\n                    if name not in self.dists_by_name:\n                        self.reqts.setdefault(p, set()).add(r)\n                    else:\n                        other = self.dists_by_name[name]\n                        if other != p:\n                            # see if other can be replaced by p\n                            self.try_to_replace(p, other, problems)\n\n        dists = set(self.dists.values())\n        for dist in dists:\n            dist.build_time_dependency = dist not in install_dists\n            if dist.build_time_dependency:\n                logger.debug('%s is a build-time dependency only.', dist.name_and_version)\n        logger.debug('find done for %s', odist)\n        return dists, problems\n", "distlib/index.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport hashlib\nimport logging\nimport os\nimport shutil\nimport subprocess\nimport tempfile\ntry:\n    from threading import Thread\nexcept ImportError:  # pragma: no cover\n    from dummy_threading import Thread\n\nfrom . import DistlibException\nfrom .compat import (HTTPBasicAuthHandler, Request, HTTPPasswordMgr,\n                     urlparse, build_opener, string_types)\nfrom .util import zip_dir, ServerProxy\n\nlogger = logging.getLogger(__name__)\n\nDEFAULT_INDEX = 'https://pypi.org/pypi'\nDEFAULT_REALM = 'pypi'\n\n\nclass PackageIndex(object):\n    \"\"\"\n    This class represents a package index compatible with PyPI, the Python\n    Package Index.\n    \"\"\"\n\n    boundary = b'----------ThIs_Is_tHe_distlib_index_bouNdaRY_$'\n\n    def __init__(self, url=None):\n        \"\"\"\n        Initialise an instance.\n\n        :param url: The URL of the index. If not specified, the URL for PyPI is\n                    used.\n        \"\"\"\n        self.url = url or DEFAULT_INDEX\n        self.read_configuration()\n        scheme, netloc, path, params, query, frag = urlparse(self.url)\n        if params or query or frag or scheme not in ('http', 'https'):\n            raise DistlibException('invalid repository: %s' % self.url)\n        self.password_handler = None\n        self.ssl_verifier = None\n        self.gpg = None\n        self.gpg_home = None\n        with open(os.devnull, 'w') as sink:\n            # Use gpg by default rather than gpg2, as gpg2 insists on\n            # prompting for passwords\n            for s in ('gpg', 'gpg2'):\n                try:\n                    rc = subprocess.check_call([s, '--version'], stdout=sink,\n                                               stderr=sink)\n                    if rc == 0:\n                        self.gpg = s\n                        break\n                except OSError:\n                    pass\n\n    def _get_pypirc_command(self):\n        \"\"\"\n        Get the distutils command for interacting with PyPI configurations.\n        :return: the command.\n        \"\"\"\n        from .util import _get_pypirc_command as cmd\n        return cmd()\n\n    def read_configuration(self):\n        \"\"\"\n        Read the PyPI access configuration as supported by distutils. This populates\n        ``username``, ``password``, ``realm`` and ``url`` attributes from the\n        configuration.\n        \"\"\"\n        from .util import _load_pypirc\n        cfg = _load_pypirc(self)\n        self.username = cfg.get('username')\n        self.password = cfg.get('password')\n        self.realm = cfg.get('realm', 'pypi')\n        self.url = cfg.get('repository', self.url)\n\n    def save_configuration(self):\n        \"\"\"\n        Save the PyPI access configuration. You must have set ``username`` and\n        ``password`` attributes before calling this method.\n        \"\"\"\n        self.check_credentials()\n        from .util import _store_pypirc\n        _store_pypirc(self)\n\n    def check_credentials(self):\n        \"\"\"\n        Check that ``username`` and ``password`` have been set, and raise an\n        exception if not.\n        \"\"\"\n        if self.username is None or self.password is None:\n            raise DistlibException('username and password must be set')\n        pm = HTTPPasswordMgr()\n        _, netloc, _, _, _, _ = urlparse(self.url)\n        pm.add_password(self.realm, netloc, self.username, self.password)\n        self.password_handler = HTTPBasicAuthHandler(pm)\n\n    def register(self, metadata):  # pragma: no cover\n        \"\"\"\n        Register a distribution on PyPI, using the provided metadata.\n\n        :param metadata: A :class:`Metadata` instance defining at least a name\n                         and version number for the distribution to be\n                         registered.\n        :return: The HTTP response received from PyPI upon submission of the\n                request.\n        \"\"\"\n        self.check_credentials()\n        metadata.validate()\n        d = metadata.todict()\n        d[':action'] = 'verify'\n        request = self.encode_request(d.items(), [])\n        self.send_request(request)\n        d[':action'] = 'submit'\n        request = self.encode_request(d.items(), [])\n        return self.send_request(request)\n\n    def _reader(self, name, stream, outbuf):\n        \"\"\"\n        Thread runner for reading lines of from a subprocess into a buffer.\n\n        :param name: The logical name of the stream (used for logging only).\n        :param stream: The stream to read from. This will typically a pipe\n                       connected to the output stream of a subprocess.\n        :param outbuf: The list to append the read lines to.\n        \"\"\"\n        while True:\n            s = stream.readline()\n            if not s:\n                break\n            s = s.decode('utf-8').rstrip()\n            outbuf.append(s)\n            logger.debug('%s: %s' % (name, s))\n        stream.close()\n\n    def get_sign_command(self, filename, signer, sign_password, keystore=None):  # pragma: no cover\n        \"\"\"\n        Return a suitable command for signing a file.\n\n        :param filename: The pathname to the file to be signed.\n        :param signer: The identifier of the signer of the file.\n        :param sign_password: The passphrase for the signer's\n                              private key used for signing.\n        :param keystore: The path to a directory which contains the keys\n                         used in verification. If not specified, the\n                         instance's ``gpg_home`` attribute is used instead.\n        :return: The signing command as a list suitable to be\n                 passed to :class:`subprocess.Popen`.\n        \"\"\"\n        cmd = [self.gpg, '--status-fd', '2', '--no-tty']\n        if keystore is None:\n            keystore = self.gpg_home\n        if keystore:\n            cmd.extend(['--homedir', keystore])\n        if sign_password is not None:\n            cmd.extend(['--batch', '--passphrase-fd', '0'])\n        td = tempfile.mkdtemp()\n        sf = os.path.join(td, os.path.basename(filename) + '.asc')\n        cmd.extend(['--detach-sign', '--armor', '--local-user',\n                    signer, '--output', sf, filename])\n        logger.debug('invoking: %s', ' '.join(cmd))\n        return cmd, sf\n\n    def run_command(self, cmd, input_data=None):\n        \"\"\"\n        Run a command in a child process , passing it any input data specified.\n\n        :param cmd: The command to run.\n        :param input_data: If specified, this must be a byte string containing\n                           data to be sent to the child process.\n        :return: A tuple consisting of the subprocess' exit code, a list of\n                 lines read from the subprocess' ``stdout``, and a list of\n                 lines read from the subprocess' ``stderr``.\n        \"\"\"\n        kwargs = {\n            'stdout': subprocess.PIPE,\n            'stderr': subprocess.PIPE,\n        }\n        if input_data is not None:\n            kwargs['stdin'] = subprocess.PIPE\n        stdout = []\n        stderr = []\n        p = subprocess.Popen(cmd, **kwargs)\n        # We don't use communicate() here because we may need to\n        # get clever with interacting with the command\n        t1 = Thread(target=self._reader, args=('stdout', p.stdout, stdout))\n        t1.start()\n        t2 = Thread(target=self._reader, args=('stderr', p.stderr, stderr))\n        t2.start()\n        if input_data is not None:\n            p.stdin.write(input_data)\n            p.stdin.close()\n\n        p.wait()\n        t1.join()\n        t2.join()\n        return p.returncode, stdout, stderr\n\n    def sign_file(self, filename, signer, sign_password, keystore=None):  # pragma: no cover\n        \"\"\"\n        Sign a file.\n\n        :param filename: The pathname to the file to be signed.\n        :param signer: The identifier of the signer of the file.\n        :param sign_password: The passphrase for the signer's\n                              private key used for signing.\n        :param keystore: The path to a directory which contains the keys\n                         used in signing. If not specified, the instance's\n                         ``gpg_home`` attribute is used instead.\n        :return: The absolute pathname of the file where the signature is\n                 stored.\n        \"\"\"\n        cmd, sig_file = self.get_sign_command(filename, signer, sign_password,\n                                              keystore)\n        rc, stdout, stderr = self.run_command(cmd,\n                                              sign_password.encode('utf-8'))\n        if rc != 0:\n            raise DistlibException('sign command failed with error '\n                                   'code %s' % rc)\n        return sig_file\n\n    def upload_file(self, metadata, filename, signer=None, sign_password=None,\n                    filetype='sdist', pyversion='source', keystore=None):\n        \"\"\"\n        Upload a release file to the index.\n\n        :param metadata: A :class:`Metadata` instance defining at least a name\n                         and version number for the file to be uploaded.\n        :param filename: The pathname of the file to be uploaded.\n        :param signer: The identifier of the signer of the file.\n        :param sign_password: The passphrase for the signer's\n                              private key used for signing.\n        :param filetype: The type of the file being uploaded. This is the\n                        distutils command which produced that file, e.g.\n                        ``sdist`` or ``bdist_wheel``.\n        :param pyversion: The version of Python which the release relates\n                          to. For code compatible with any Python, this would\n                          be ``source``, otherwise it would be e.g. ``3.2``.\n        :param keystore: The path to a directory which contains the keys\n                         used in signing. If not specified, the instance's\n                         ``gpg_home`` attribute is used instead.\n        :return: The HTTP response received from PyPI upon submission of the\n                request.\n        \"\"\"\n        self.check_credentials()\n        if not os.path.exists(filename):\n            raise DistlibException('not found: %s' % filename)\n        metadata.validate()\n        d = metadata.todict()\n        sig_file = None\n        if signer:\n            if not self.gpg:\n                logger.warning('no signing program available - not signed')\n            else:\n                sig_file = self.sign_file(filename, signer, sign_password,\n                                          keystore)\n        with open(filename, 'rb') as f:\n            file_data = f.read()\n        md5_digest = hashlib.md5(file_data).hexdigest()\n        sha256_digest = hashlib.sha256(file_data).hexdigest()\n        d.update({\n            ':action': 'file_upload',\n            'protocol_version': '1',\n            'filetype': filetype,\n            'pyversion': pyversion,\n            'md5_digest': md5_digest,\n            'sha256_digest': sha256_digest,\n        })\n        files = [('content', os.path.basename(filename), file_data)]\n        if sig_file:\n            with open(sig_file, 'rb') as f:\n                sig_data = f.read()\n            files.append(('gpg_signature', os.path.basename(sig_file),\n                         sig_data))\n            shutil.rmtree(os.path.dirname(sig_file))\n        request = self.encode_request(d.items(), files)\n        return self.send_request(request)\n\n    def upload_documentation(self, metadata, doc_dir):  # pragma: no cover\n        \"\"\"\n        Upload documentation to the index.\n\n        :param metadata: A :class:`Metadata` instance defining at least a name\n                         and version number for the documentation to be\n                         uploaded.\n        :param doc_dir: The pathname of the directory which contains the\n                        documentation. This should be the directory that\n                        contains the ``index.html`` for the documentation.\n        :return: The HTTP response received from PyPI upon submission of the\n                request.\n        \"\"\"\n        self.check_credentials()\n        if not os.path.isdir(doc_dir):\n            raise DistlibException('not a directory: %r' % doc_dir)\n        fn = os.path.join(doc_dir, 'index.html')\n        if not os.path.exists(fn):\n            raise DistlibException('not found: %r' % fn)\n        metadata.validate()\n        name, version = metadata.name, metadata.version\n        zip_data = zip_dir(doc_dir).getvalue()\n        fields = [(':action', 'doc_upload'),\n                  ('name', name), ('version', version)]\n        files = [('content', name, zip_data)]\n        request = self.encode_request(fields, files)\n        return self.send_request(request)\n\n    def get_verify_command(self, signature_filename, data_filename,\n                           keystore=None):\n        \"\"\"\n        Return a suitable command for verifying a file.\n\n        :param signature_filename: The pathname to the file containing the\n                                   signature.\n        :param data_filename: The pathname to the file containing the\n                              signed data.\n        :param keystore: The path to a directory which contains the keys\n                         used in verification. If not specified, the\n                         instance's ``gpg_home`` attribute is used instead.\n        :return: The verifying command as a list suitable to be\n                 passed to :class:`subprocess.Popen`.\n        \"\"\"\n        cmd = [self.gpg, '--status-fd', '2', '--no-tty']\n        if keystore is None:\n            keystore = self.gpg_home\n        if keystore:\n            cmd.extend(['--homedir', keystore])\n        cmd.extend(['--verify', signature_filename, data_filename])\n        logger.debug('invoking: %s', ' '.join(cmd))\n        return cmd\n\n    def verify_signature(self, signature_filename, data_filename,\n                         keystore=None):\n        \"\"\"\n        Verify a signature for a file.\n\n        :param signature_filename: The pathname to the file containing the\n                                   signature.\n        :param data_filename: The pathname to the file containing the\n                              signed data.\n        :param keystore: The path to a directory which contains the keys\n                         used in verification. If not specified, the\n                         instance's ``gpg_home`` attribute is used instead.\n        :return: True if the signature was verified, else False.\n        \"\"\"\n        if not self.gpg:\n            raise DistlibException('verification unavailable because gpg '\n                                   'unavailable')\n        cmd = self.get_verify_command(signature_filename, data_filename,\n                                      keystore)\n        rc, stdout, stderr = self.run_command(cmd)\n        if rc not in (0, 1):\n            raise DistlibException('verify command failed with error code %s' % rc)\n        return rc == 0\n\n    def download_file(self, url, destfile, digest=None, reporthook=None):\n        \"\"\"\n        This is a convenience method for downloading a file from an URL.\n        Normally, this will be a file from the index, though currently\n        no check is made for this (i.e. a file can be downloaded from\n        anywhere).\n\n        The method is just like the :func:`urlretrieve` function in the\n        standard library, except that it allows digest computation to be\n        done during download and checking that the downloaded data\n        matched any expected value.\n\n        :param url: The URL of the file to be downloaded (assumed to be\n                    available via an HTTP GET request).\n        :param destfile: The pathname where the downloaded file is to be\n                         saved.\n        :param digest: If specified, this must be a (hasher, value)\n                       tuple, where hasher is the algorithm used (e.g.\n                       ``'md5'``) and ``value`` is the expected value.\n        :param reporthook: The same as for :func:`urlretrieve` in the\n                           standard library.\n        \"\"\"\n        if digest is None:\n            digester = None\n            logger.debug('No digest specified')\n        else:\n            if isinstance(digest, (list, tuple)):\n                hasher, digest = digest\n            else:\n                hasher = 'md5'\n            digester = getattr(hashlib, hasher)()\n            logger.debug('Digest specified: %s' % digest)\n        # The following code is equivalent to urlretrieve.\n        # We need to do it this way so that we can compute the\n        # digest of the file as we go.\n        with open(destfile, 'wb') as dfp:\n            # addinfourl is not a context manager on 2.x\n            # so we have to use try/finally\n            sfp = self.send_request(Request(url))\n            try:\n                headers = sfp.info()\n                blocksize = 8192\n                size = -1\n                read = 0\n                blocknum = 0\n                if \"content-length\" in headers:\n                    size = int(headers[\"Content-Length\"])\n                if reporthook:\n                    reporthook(blocknum, blocksize, size)\n                while True:\n                    block = sfp.read(blocksize)\n                    if not block:\n                        break\n                    read += len(block)\n                    dfp.write(block)\n                    if digester:\n                        digester.update(block)\n                    blocknum += 1\n                    if reporthook:\n                        reporthook(blocknum, blocksize, size)\n            finally:\n                sfp.close()\n\n        # check that we got the whole file, if we can\n        if size >= 0 and read < size:\n            raise DistlibException(\n                'retrieval incomplete: got only %d out of %d bytes'\n                % (read, size))\n        # if we have a digest, it must match.\n        if digester:\n            actual = digester.hexdigest()\n            if digest != actual:\n                raise DistlibException('%s digest mismatch for %s: expected '\n                                       '%s, got %s' % (hasher, destfile,\n                                                       digest, actual))\n            logger.debug('Digest verified: %s', digest)\n\n    def send_request(self, req):\n        \"\"\"\n        Send a standard library :class:`Request` to PyPI and return its\n        response.\n\n        :param req: The request to send.\n        :return: The HTTP response from PyPI (a standard library HTTPResponse).\n        \"\"\"\n        handlers = []\n        if self.password_handler:\n            handlers.append(self.password_handler)\n        if self.ssl_verifier:\n            handlers.append(self.ssl_verifier)\n        opener = build_opener(*handlers)\n        return opener.open(req)\n\n    def encode_request(self, fields, files):\n        \"\"\"\n        Encode fields and files for posting to an HTTP server.\n\n        :param fields: The fields to send as a list of (fieldname, value)\n                       tuples.\n        :param files: The files to send as a list of (fieldname, filename,\n                      file_bytes) tuple.\n        \"\"\"\n        # Adapted from packaging, which in turn was adapted from\n        # http://code.activestate.com/recipes/146306\n\n        parts = []\n        boundary = self.boundary\n        for k, values in fields:\n            if not isinstance(values, (list, tuple)):\n                values = [values]\n\n            for v in values:\n                parts.extend((\n                    b'--' + boundary,\n                    ('Content-Disposition: form-data; name=\"%s\"' %\n                     k).encode('utf-8'),\n                    b'',\n                    v.encode('utf-8')))\n        for key, filename, value in files:\n            parts.extend((\n                b'--' + boundary,\n                ('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' %\n                 (key, filename)).encode('utf-8'),\n                b'',\n                value))\n\n        parts.extend((b'--' + boundary + b'--', b''))\n\n        body = b'\\r\\n'.join(parts)\n        ct = b'multipart/form-data; boundary=' + boundary\n        headers = {\n            'Content-type': ct,\n            'Content-length': str(len(body))\n        }\n        return Request(self.url, body, headers)\n\n    def search(self, terms, operator=None):  # pragma: no cover\n        if isinstance(terms, string_types):\n            terms = {'name': terms}\n        rpc_proxy = ServerProxy(self.url, timeout=3.0)\n        try:\n            return rpc_proxy.search(terms, operator or 'and')\n        finally:\n            rpc_proxy('close')()\n", "distlib/scripts.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom io import BytesIO\nimport logging\nimport os\nimport re\nimport struct\nimport sys\nimport time\nfrom zipfile import ZipInfo\n\nfrom .compat import sysconfig, detect_encoding, ZipFile\nfrom .resources import finder\nfrom .util import (FileOperator, get_export_entry, convert_path, get_executable, get_platform, in_venv)\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_MANIFEST = '''\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n <assemblyIdentity version=\"1.0.0.0\"\n processorArchitecture=\"X86\"\n name=\"%s\"\n type=\"win32\"/>\n\n <!-- Identify the application security requirements. -->\n <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v3\">\n <security>\n <requestedPrivileges>\n <requestedExecutionLevel level=\"asInvoker\" uiAccess=\"false\"/>\n </requestedPrivileges>\n </security>\n </trustInfo>\n</assembly>'''.strip()\n\n# check if Python is called on the first line with this expression\nFIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \\t].*)?$')\nSCRIPT_TEMPLATE = r'''# -*- coding: utf-8 -*-\nimport re\nimport sys\nfrom %(module)s import %(import_name)s\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw|\\.exe)?$', '', sys.argv[0])\n    sys.exit(%(func)s())\n'''\n\n# Pre-fetch the contents of all executable wrapper stubs.\n# This is to address https://github.com/pypa/pip/issues/12666.\n# When updating pip, we rename the old pip in place before installing the\n# new version. If we try to fetch a wrapper *after* that rename, the finder\n# machinery will be confused as the package is no longer available at the\n# location where it was imported from. So we load everything into memory in\n# advance.\n\nif os.name == 'nt' or (os.name == 'java' and os._name == 'nt'):\n    # Issue 31: don't hardcode an absolute package name, but\n    # determine it relative to the current package\n    DISTLIB_PACKAGE = __name__.rsplit('.', 1)[0]\n\n    WRAPPERS = {\n        r.name: r.bytes\n        for r in finder(DISTLIB_PACKAGE).iterator(\"\")\n        if r.name.endswith(\".exe\")\n    }\n\n\ndef enquote_executable(executable):\n    if ' ' in executable:\n        # make sure we quote only the executable in case of env\n        # for example /usr/bin/env \"/dir with spaces/bin/jython\"\n        # instead of \"/usr/bin/env /dir with spaces/bin/jython\"\n        # otherwise whole\n        if executable.startswith('/usr/bin/env '):\n            env, _executable = executable.split(' ', 1)\n            if ' ' in _executable and not _executable.startswith('\"'):\n                executable = '%s \"%s\"' % (env, _executable)\n        else:\n            if not executable.startswith('\"'):\n                executable = '\"%s\"' % executable\n    return executable\n\n\n# Keep the old name around (for now), as there is at least one project using it!\n_enquote_executable = enquote_executable\n\n\nclass ScriptMaker(object):\n    \"\"\"\n    A class to copy or create scripts from source scripts or callable\n    specifications.\n    \"\"\"\n    script_template = SCRIPT_TEMPLATE\n\n    executable = None  # for shebangs\n\n    def __init__(self, source_dir, target_dir, add_launchers=True, dry_run=False, fileop=None):\n        self.source_dir = source_dir\n        self.target_dir = target_dir\n        self.add_launchers = add_launchers\n        self.force = False\n        self.clobber = False\n        # It only makes sense to set mode bits on POSIX.\n        self.set_mode = (os.name == 'posix') or (os.name == 'java' and os._name == 'posix')\n        self.variants = set(('', 'X.Y'))\n        self._fileop = fileop or FileOperator(dry_run)\n\n        self._is_nt = os.name == 'nt' or (os.name == 'java' and os._name == 'nt')\n        self.version_info = sys.version_info\n\n    def _get_alternate_executable(self, executable, options):\n        if options.get('gui', False) and self._is_nt:  # pragma: no cover\n            dn, fn = os.path.split(executable)\n            fn = fn.replace('python', 'pythonw')\n            executable = os.path.join(dn, fn)\n        return executable\n\n    if sys.platform.startswith('java'):  # pragma: no cover\n\n        def _is_shell(self, executable):\n            \"\"\"\n            Determine if the specified executable is a script\n            (contains a #! line)\n            \"\"\"\n            try:\n                with open(executable) as fp:\n                    return fp.read(2) == '#!'\n            except (OSError, IOError):\n                logger.warning('Failed to open %s', executable)\n                return False\n\n        def _fix_jython_executable(self, executable):\n            if self._is_shell(executable):\n                # Workaround for Jython is not needed on Linux systems.\n                import java\n\n                if java.lang.System.getProperty('os.name') == 'Linux':\n                    return executable\n            elif executable.lower().endswith('jython.exe'):\n                # Use wrapper exe for Jython on Windows\n                return executable\n            return '/usr/bin/env %s' % executable\n\n    def _build_shebang(self, executable, post_interp):\n        \"\"\"\n        Build a shebang line. In the simple case (on Windows, or a shebang line\n        which is not too long or contains spaces) use a simple formulation for\n        the shebang. Otherwise, use /bin/sh as the executable, with a contrived\n        shebang which allows the script to run either under Python or sh, using\n        suitable quoting. Thanks to Harald Nordgren for his input.\n\n        See also: http://www.in-ulm.de/~mascheck/various/shebang/#length\n                  https://hg.mozilla.org/mozilla-central/file/tip/mach\n        \"\"\"\n        if os.name != 'posix':\n            simple_shebang = True\n        else:\n            # Add 3 for '#!' prefix and newline suffix.\n            shebang_length = len(executable) + len(post_interp) + 3\n            if sys.platform == 'darwin':\n                max_shebang_length = 512\n            else:\n                max_shebang_length = 127\n            simple_shebang = ((b' ' not in executable) and (shebang_length <= max_shebang_length))\n\n        if simple_shebang:\n            result = b'#!' + executable + post_interp + b'\\n'\n        else:\n            result = b'#!/bin/sh\\n'\n            result += b\"'''exec' \" + executable + post_interp + b' \"$0\" \"$@\"\\n'\n            result += b\"' '''\"\n        return result\n\n    def _get_shebang(self, encoding, post_interp=b'', options=None):\n        enquote = True\n        if self.executable:\n            executable = self.executable\n            enquote = False  # assume this will be taken care of\n        elif not sysconfig.is_python_build():\n            executable = get_executable()\n        elif in_venv():  # pragma: no cover\n            executable = os.path.join(sysconfig.get_path('scripts'), 'python%s' % sysconfig.get_config_var('EXE'))\n        else:  # pragma: no cover\n            if os.name == 'nt':\n                # for Python builds from source on Windows, no Python executables with\n                # a version suffix are created, so we use python.exe\n                executable = os.path.join(sysconfig.get_config_var('BINDIR'),\n                                          'python%s' % (sysconfig.get_config_var('EXE')))\n            else:\n                executable = os.path.join(\n                    sysconfig.get_config_var('BINDIR'),\n                    'python%s%s' % (sysconfig.get_config_var('VERSION'), sysconfig.get_config_var('EXE')))\n        if options:\n            executable = self._get_alternate_executable(executable, options)\n\n        if sys.platform.startswith('java'):  # pragma: no cover\n            executable = self._fix_jython_executable(executable)\n\n        # Normalise case for Windows - COMMENTED OUT\n        # executable = os.path.normcase(executable)\n        # N.B. The normalising operation above has been commented out: See\n        # issue #124. Although paths in Windows are generally case-insensitive,\n        # they aren't always. For example, a path containing a \u1e9e (which is a\n        # LATIN CAPITAL LETTER SHARP S - U+1E9E) is normcased to \u00df (which is a\n        # LATIN SMALL LETTER SHARP S' - U+00DF). The two are not considered by\n        # Windows as equivalent in path names.\n\n        # If the user didn't specify an executable, it may be necessary to\n        # cater for executable paths with spaces (not uncommon on Windows)\n        if enquote:\n            executable = enquote_executable(executable)\n        # Issue #51: don't use fsencode, since we later try to\n        # check that the shebang is decodable using utf-8.\n        executable = executable.encode('utf-8')\n        # in case of IronPython, play safe and enable frames support\n        if (sys.platform == 'cli' and '-X:Frames' not in post_interp and\n                '-X:FullFrames' not in post_interp):  # pragma: no cover\n            post_interp += b' -X:Frames'\n        shebang = self._build_shebang(executable, post_interp)\n        # Python parser starts to read a script using UTF-8 until\n        # it gets a #coding:xxx cookie. The shebang has to be the\n        # first line of a file, the #coding:xxx cookie cannot be\n        # written before. So the shebang has to be decodable from\n        # UTF-8.\n        try:\n            shebang.decode('utf-8')\n        except UnicodeDecodeError:  # pragma: no cover\n            raise ValueError('The shebang (%r) is not decodable from utf-8' % shebang)\n        # If the script is encoded to a custom encoding (use a\n        # #coding:xxx cookie), the shebang has to be decodable from\n        # the script encoding too.\n        if encoding != 'utf-8':\n            try:\n                shebang.decode(encoding)\n            except UnicodeDecodeError:  # pragma: no cover\n                raise ValueError('The shebang (%r) is not decodable '\n                                 'from the script encoding (%r)' % (shebang, encoding))\n        return shebang\n\n    def _get_script_text(self, entry):\n        return self.script_template % dict(\n            module=entry.prefix, import_name=entry.suffix.split('.')[0], func=entry.suffix)\n\n    manifest = _DEFAULT_MANIFEST\n\n    def get_manifest(self, exename):\n        base = os.path.basename(exename)\n        return self.manifest % base\n\n    def _write_script(self, names, shebang, script_bytes, filenames, ext):\n        use_launcher = self.add_launchers and self._is_nt\n        linesep = os.linesep.encode('utf-8')\n        if not shebang.endswith(linesep):\n            shebang += linesep\n        if not use_launcher:\n            script_bytes = shebang + script_bytes\n        else:  # pragma: no cover\n            if ext == 'py':\n                launcher = self._get_launcher('t')\n            else:\n                launcher = self._get_launcher('w')\n            stream = BytesIO()\n            with ZipFile(stream, 'w') as zf:\n                source_date_epoch = os.environ.get('SOURCE_DATE_EPOCH')\n                if source_date_epoch:\n                    date_time = time.gmtime(int(source_date_epoch))[:6]\n                    zinfo = ZipInfo(filename='__main__.py', date_time=date_time)\n                    zf.writestr(zinfo, script_bytes)\n                else:\n                    zf.writestr('__main__.py', script_bytes)\n            zip_data = stream.getvalue()\n            script_bytes = launcher + shebang + zip_data\n        for name in names:\n            outname = os.path.join(self.target_dir, name)\n            if use_launcher:  # pragma: no cover\n                n, e = os.path.splitext(outname)\n                if e.startswith('.py'):\n                    outname = n\n                outname = '%s.exe' % outname\n                try:\n                    self._fileop.write_binary_file(outname, script_bytes)\n                except Exception:\n                    # Failed writing an executable - it might be in use.\n                    logger.warning('Failed to write executable - trying to '\n                                   'use .deleteme logic')\n                    dfname = '%s.deleteme' % outname\n                    if os.path.exists(dfname):\n                        os.remove(dfname)  # Not allowed to fail here\n                    os.rename(outname, dfname)  # nor here\n                    self._fileop.write_binary_file(outname, script_bytes)\n                    logger.debug('Able to replace executable using '\n                                 '.deleteme logic')\n                    try:\n                        os.remove(dfname)\n                    except Exception:\n                        pass  # still in use - ignore error\n            else:\n                if self._is_nt and not outname.endswith('.' + ext):  # pragma: no cover\n                    outname = '%s.%s' % (outname, ext)\n                if os.path.exists(outname) and not self.clobber:\n                    logger.warning('Skipping existing file %s', outname)\n                    continue\n                self._fileop.write_binary_file(outname, script_bytes)\n                if self.set_mode:\n                    self._fileop.set_executable_mode([outname])\n            filenames.append(outname)\n\n    variant_separator = '-'\n\n    def get_script_filenames(self, name):\n        result = set()\n        if '' in self.variants:\n            result.add(name)\n        if 'X' in self.variants:\n            result.add('%s%s' % (name, self.version_info[0]))\n        if 'X.Y' in self.variants:\n            result.add('%s%s%s.%s' % (name, self.variant_separator, self.version_info[0], self.version_info[1]))\n        return result\n\n    def _make_script(self, entry, filenames, options=None):\n        post_interp = b''\n        if options:\n            args = options.get('interpreter_args', [])\n            if args:\n                args = ' %s' % ' '.join(args)\n                post_interp = args.encode('utf-8')\n        shebang = self._get_shebang('utf-8', post_interp, options=options)\n        script = self._get_script_text(entry).encode('utf-8')\n        scriptnames = self.get_script_filenames(entry.name)\n        if options and options.get('gui', False):\n            ext = 'pyw'\n        else:\n            ext = 'py'\n        self._write_script(scriptnames, shebang, script, filenames, ext)\n\n    def _copy_script(self, script, filenames):\n        adjust = False\n        script = os.path.join(self.source_dir, convert_path(script))\n        outname = os.path.join(self.target_dir, os.path.basename(script))\n        if not self.force and not self._fileop.newer(script, outname):\n            logger.debug('not copying %s (up-to-date)', script)\n            return\n\n        # Always open the file, but ignore failures in dry-run mode --\n        # that way, we'll get accurate feedback if we can read the\n        # script.\n        try:\n            f = open(script, 'rb')\n        except IOError:  # pragma: no cover\n            if not self.dry_run:\n                raise\n            f = None\n        else:\n            first_line = f.readline()\n            if not first_line:  # pragma: no cover\n                logger.warning('%s is an empty file (skipping)', script)\n                return\n\n            match = FIRST_LINE_RE.match(first_line.replace(b'\\r\\n', b'\\n'))\n            if match:\n                adjust = True\n                post_interp = match.group(1) or b''\n\n        if not adjust:\n            if f:\n                f.close()\n            self._fileop.copy_file(script, outname)\n            if self.set_mode:\n                self._fileop.set_executable_mode([outname])\n            filenames.append(outname)\n        else:\n            logger.info('copying and adjusting %s -> %s', script, self.target_dir)\n            if not self._fileop.dry_run:\n                encoding, lines = detect_encoding(f.readline)\n                f.seek(0)\n                shebang = self._get_shebang(encoding, post_interp)\n                if b'pythonw' in first_line:  # pragma: no cover\n                    ext = 'pyw'\n                else:\n                    ext = 'py'\n                n = os.path.basename(outname)\n                self._write_script([n], shebang, f.read(), filenames, ext)\n            if f:\n                f.close()\n\n    @property\n    def dry_run(self):\n        return self._fileop.dry_run\n\n    @dry_run.setter\n    def dry_run(self, value):\n        self._fileop.dry_run = value\n\n    if os.name == 'nt' or (os.name == 'java' and os._name == 'nt'):  # pragma: no cover\n        # Executable launcher support.\n        # Launchers are from https://bitbucket.org/vinay.sajip/simple_launcher/\n\n        def _get_launcher(self, kind):\n            if struct.calcsize('P') == 8:  # 64-bit\n                bits = '64'\n            else:\n                bits = '32'\n            platform_suffix = '-arm' if get_platform() == 'win-arm64' else ''\n            name = '%s%s%s.exe' % (kind, bits, platform_suffix)\n            if name not in WRAPPERS:\n                msg = ('Unable to find resource %s in package %s' %\n                       (name, DISTLIB_PACKAGE))\n                raise ValueError(msg)\n            return WRAPPERS[name]\n\n    # Public API follows\n\n    def make(self, specification, options=None):\n        \"\"\"\n        Make a script.\n\n        :param specification: The specification, which is either a valid export\n                              entry specification (to make a script from a\n                              callable) or a filename (to make a script by\n                              copying from a source location).\n        :param options: A dictionary of options controlling script generation.\n        :return: A list of all absolute pathnames written to.\n        \"\"\"\n        filenames = []\n        entry = get_export_entry(specification)\n        if entry is None:\n            self._copy_script(specification, filenames)\n        else:\n            self._make_script(entry, filenames, options=options)\n        return filenames\n\n    def make_multiple(self, specifications, options=None):\n        \"\"\"\n        Take a list of specifications and make scripts from them,\n        :param specifications: A list of specifications.\n        :return: A list of all absolute pathnames written to,\n        \"\"\"\n        filenames = []\n        for specification in specifications:\n            filenames.extend(self.make(specification, options))\n        return filenames\n", "distlib/resources.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013-2017 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nimport bisect\nimport io\nimport logging\nimport os\nimport pkgutil\nimport sys\nimport types\nimport zipimport\n\nfrom . import DistlibException\nfrom .util import cached_property, get_cache_base, Cache\n\nlogger = logging.getLogger(__name__)\n\n\ncache = None    # created when needed\n\n\nclass ResourceCache(Cache):\n    def __init__(self, base=None):\n        if base is None:\n            # Use native string to avoid issues on 2.x: see Python #20140.\n            base = os.path.join(get_cache_base(), str('resource-cache'))\n        super(ResourceCache, self).__init__(base)\n\n    def is_stale(self, resource, path):\n        \"\"\"\n        Is the cache stale for the given resource?\n\n        :param resource: The :class:`Resource` being cached.\n        :param path: The path of the resource in the cache.\n        :return: True if the cache is stale.\n        \"\"\"\n        # Cache invalidation is a hard problem :-)\n        return True\n\n    def get(self, resource):\n        \"\"\"\n        Get a resource into the cache,\n\n        :param resource: A :class:`Resource` instance.\n        :return: The pathname of the resource in the cache.\n        \"\"\"\n        prefix, path = resource.finder.get_cache_info(resource)\n        if prefix is None:\n            result = path\n        else:\n            result = os.path.join(self.base, self.prefix_to_dir(prefix), path)\n            dirname = os.path.dirname(result)\n            if not os.path.isdir(dirname):\n                os.makedirs(dirname)\n            if not os.path.exists(result):\n                stale = True\n            else:\n                stale = self.is_stale(resource, path)\n            if stale:\n                # write the bytes of the resource to the cache location\n                with open(result, 'wb') as f:\n                    f.write(resource.bytes)\n        return result\n\n\nclass ResourceBase(object):\n    def __init__(self, finder, name):\n        self.finder = finder\n        self.name = name\n\n\nclass Resource(ResourceBase):\n    \"\"\"\n    A class representing an in-package resource, such as a data file. This is\n    not normally instantiated by user code, but rather by a\n    :class:`ResourceFinder` which manages the resource.\n    \"\"\"\n    is_container = False        # Backwards compatibility\n\n    def as_stream(self):\n        \"\"\"\n        Get the resource as a stream.\n\n        This is not a property to make it obvious that it returns a new stream\n        each time.\n        \"\"\"\n        return self.finder.get_stream(self)\n\n    @cached_property\n    def file_path(self):\n        global cache\n        if cache is None:\n            cache = ResourceCache()\n        return cache.get(self)\n\n    @cached_property\n    def bytes(self):\n        return self.finder.get_bytes(self)\n\n    @cached_property\n    def size(self):\n        return self.finder.get_size(self)\n\n\nclass ResourceContainer(ResourceBase):\n    is_container = True     # Backwards compatibility\n\n    @cached_property\n    def resources(self):\n        return self.finder.get_resources(self)\n\n\nclass ResourceFinder(object):\n    \"\"\"\n    Resource finder for file system resources.\n    \"\"\"\n\n    if sys.platform.startswith('java'):\n        skipped_extensions = ('.pyc', '.pyo', '.class')\n    else:\n        skipped_extensions = ('.pyc', '.pyo')\n\n    def __init__(self, module):\n        self.module = module\n        self.loader = getattr(module, '__loader__', None)\n        self.base = os.path.dirname(getattr(module, '__file__', ''))\n\n    def _adjust_path(self, path):\n        return os.path.realpath(path)\n\n    def _make_path(self, resource_name):\n        # Issue #50: need to preserve type of path on Python 2.x\n        # like os.path._get_sep\n        if isinstance(resource_name, bytes):    # should only happen on 2.x\n            sep = b'/'\n        else:\n            sep = '/'\n        parts = resource_name.split(sep)\n        parts.insert(0, self.base)\n        result = os.path.join(*parts)\n        return self._adjust_path(result)\n\n    def _find(self, path):\n        return os.path.exists(path)\n\n    def get_cache_info(self, resource):\n        return None, resource.path\n\n    def find(self, resource_name):\n        path = self._make_path(resource_name)\n        if not self._find(path):\n            result = None\n        else:\n            if self._is_directory(path):\n                result = ResourceContainer(self, resource_name)\n            else:\n                result = Resource(self, resource_name)\n            result.path = path\n        return result\n\n    def get_stream(self, resource):\n        return open(resource.path, 'rb')\n\n    def get_bytes(self, resource):\n        with open(resource.path, 'rb') as f:\n            return f.read()\n\n    def get_size(self, resource):\n        return os.path.getsize(resource.path)\n\n    def get_resources(self, resource):\n        def allowed(f):\n            return (f != '__pycache__' and not\n                    f.endswith(self.skipped_extensions))\n        return set([f for f in os.listdir(resource.path) if allowed(f)])\n\n    def is_container(self, resource):\n        return self._is_directory(resource.path)\n\n    _is_directory = staticmethod(os.path.isdir)\n\n    def iterator(self, resource_name):\n        resource = self.find(resource_name)\n        if resource is not None:\n            todo = [resource]\n            while todo:\n                resource = todo.pop(0)\n                yield resource\n                if resource.is_container:\n                    rname = resource.name\n                    for name in resource.resources:\n                        if not rname:\n                            new_name = name\n                        else:\n                            new_name = '/'.join([rname, name])\n                        child = self.find(new_name)\n                        if child.is_container:\n                            todo.append(child)\n                        else:\n                            yield child\n\n\nclass ZipResourceFinder(ResourceFinder):\n    \"\"\"\n    Resource finder for resources in .zip files.\n    \"\"\"\n    def __init__(self, module):\n        super(ZipResourceFinder, self).__init__(module)\n        archive = self.loader.archive\n        self.prefix_len = 1 + len(archive)\n        # PyPy doesn't have a _files attr on zipimporter, and you can't set one\n        if hasattr(self.loader, '_files'):\n            self._files = self.loader._files\n        else:\n            self._files = zipimport._zip_directory_cache[archive]\n        self.index = sorted(self._files)\n\n    def _adjust_path(self, path):\n        return path\n\n    def _find(self, path):\n        path = path[self.prefix_len:]\n        if path in self._files:\n            result = True\n        else:\n            if path and path[-1] != os.sep:\n                path = path + os.sep\n            i = bisect.bisect(self.index, path)\n            try:\n                result = self.index[i].startswith(path)\n            except IndexError:\n                result = False\n        if not result:\n            logger.debug('_find failed: %r %r', path, self.loader.prefix)\n        else:\n            logger.debug('_find worked: %r %r', path, self.loader.prefix)\n        return result\n\n    def get_cache_info(self, resource):\n        prefix = self.loader.archive\n        path = resource.path[1 + len(prefix):]\n        return prefix, path\n\n    def get_bytes(self, resource):\n        return self.loader.get_data(resource.path)\n\n    def get_stream(self, resource):\n        return io.BytesIO(self.get_bytes(resource))\n\n    def get_size(self, resource):\n        path = resource.path[self.prefix_len:]\n        return self._files[path][3]\n\n    def get_resources(self, resource):\n        path = resource.path[self.prefix_len:]\n        if path and path[-1] != os.sep:\n            path += os.sep\n        plen = len(path)\n        result = set()\n        i = bisect.bisect(self.index, path)\n        while i < len(self.index):\n            if not self.index[i].startswith(path):\n                break\n            s = self.index[i][plen:]\n            result.add(s.split(os.sep, 1)[0])   # only immediate children\n            i += 1\n        return result\n\n    def _is_directory(self, path):\n        path = path[self.prefix_len:]\n        if path and path[-1] != os.sep:\n            path += os.sep\n        i = bisect.bisect(self.index, path)\n        try:\n            result = self.index[i].startswith(path)\n        except IndexError:\n            result = False\n        return result\n\n\n_finder_registry = {\n    type(None): ResourceFinder,\n    zipimport.zipimporter: ZipResourceFinder\n}\n\ntry:\n    # In Python 3.6, _frozen_importlib -> _frozen_importlib_external\n    try:\n        import _frozen_importlib_external as _fi\n    except ImportError:\n        import _frozen_importlib as _fi\n    _finder_registry[_fi.SourceFileLoader] = ResourceFinder\n    _finder_registry[_fi.FileFinder] = ResourceFinder\n    # See issue #146\n    _finder_registry[_fi.SourcelessFileLoader] = ResourceFinder\n    del _fi\nexcept (ImportError, AttributeError):\n    pass\n\n\ndef register_finder(loader, finder_maker):\n    _finder_registry[type(loader)] = finder_maker\n\n\n_finder_cache = {}\n\n\ndef finder(package):\n    \"\"\"\n    Return a resource finder for a package.\n    :param package: The name of the package.\n    :return: A :class:`ResourceFinder` instance for the package.\n    \"\"\"\n    if package in _finder_cache:\n        result = _finder_cache[package]\n    else:\n        if package not in sys.modules:\n            __import__(package)\n        module = sys.modules[package]\n        path = getattr(module, '__path__', None)\n        if path is None:\n            raise DistlibException('You cannot get a finder for a module, '\n                                   'only for a package')\n        loader = getattr(module, '__loader__', None)\n        finder_maker = _finder_registry.get(type(loader))\n        if finder_maker is None:\n            raise DistlibException('Unable to locate finder for %r' % package)\n        result = finder_maker(module)\n        _finder_cache[package] = result\n    return result\n\n\n_dummy_module = types.ModuleType(str('__dummy__'))\n\n\ndef finder_for_path(path):\n    \"\"\"\n    Return a resource finder for a path, which should represent a container.\n\n    :param path: The path.\n    :return: A :class:`ResourceFinder` instance for the path.\n    \"\"\"\n    result = None\n    # calls any path hooks, gets importer into cache\n    pkgutil.get_importer(path)\n    loader = sys.path_importer_cache.get(path)\n    finder = _finder_registry.get(type(loader))\n    if finder:\n        module = _dummy_module\n        module.__file__ = os.path.join(path, '')\n        module.__loader__ = loader\n        result = finder(module)\n    return result\n", "distlib/manifest.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"\nClass representing the list of files in a distribution.\n\nEquivalent to distutils.filelist, but fixes some problems.\n\"\"\"\nimport fnmatch\nimport logging\nimport os\nimport re\nimport sys\n\nfrom . import DistlibException\nfrom .compat import fsdecode\nfrom .util import convert_path\n\n\n__all__ = ['Manifest']\n\nlogger = logging.getLogger(__name__)\n\n# a \\ followed by some spaces + EOL\n_COLLAPSE_PATTERN = re.compile('\\\\\\\\w*\\n', re.M)\n_COMMENTED_LINE = re.compile('#.*?(?=\\n)|\\n(?=$)', re.M | re.S)\n\n#\n# Due to the different results returned by fnmatch.translate, we need\n# to do slightly different processing for Python 2.7 and 3.2 ... this needed\n# to be brought in for Python 3.6 onwards.\n#\n_PYTHON_VERSION = sys.version_info[:2]\n\n\nclass Manifest(object):\n    \"\"\"\n    A list of files built by exploring the filesystem and filtered by applying various\n    patterns to what we find there.\n    \"\"\"\n\n    def __init__(self, base=None):\n        \"\"\"\n        Initialise an instance.\n\n        :param base: The base directory to explore under.\n        \"\"\"\n        self.base = os.path.abspath(os.path.normpath(base or os.getcwd()))\n        self.prefix = self.base + os.sep\n        self.allfiles = None\n        self.files = set()\n\n    #\n    # Public API\n    #\n\n    def findall(self):\n        \"\"\"Find all files under the base and set ``allfiles`` to the absolute\n        pathnames of files found.\n        \"\"\"\n        from stat import S_ISREG, S_ISDIR, S_ISLNK\n\n        self.allfiles = allfiles = []\n        root = self.base\n        stack = [root]\n        pop = stack.pop\n        push = stack.append\n\n        while stack:\n            root = pop()\n            names = os.listdir(root)\n\n            for name in names:\n                fullname = os.path.join(root, name)\n\n                # Avoid excess stat calls -- just one will do, thank you!\n                stat = os.stat(fullname)\n                mode = stat.st_mode\n                if S_ISREG(mode):\n                    allfiles.append(fsdecode(fullname))\n                elif S_ISDIR(mode) and not S_ISLNK(mode):\n                    push(fullname)\n\n    def add(self, item):\n        \"\"\"\n        Add a file to the manifest.\n\n        :param item: The pathname to add. This can be relative to the base.\n        \"\"\"\n        if not item.startswith(self.prefix):\n            item = os.path.join(self.base, item)\n        self.files.add(os.path.normpath(item))\n\n    def add_many(self, items):\n        \"\"\"\n        Add a list of files to the manifest.\n\n        :param items: The pathnames to add. These can be relative to the base.\n        \"\"\"\n        for item in items:\n            self.add(item)\n\n    def sorted(self, wantdirs=False):\n        \"\"\"\n        Return sorted files in directory order\n        \"\"\"\n\n        def add_dir(dirs, d):\n            dirs.add(d)\n            logger.debug('add_dir added %s', d)\n            if d != self.base:\n                parent, _ = os.path.split(d)\n                assert parent not in ('', '/')\n                add_dir(dirs, parent)\n\n        result = set(self.files)    # make a copy!\n        if wantdirs:\n            dirs = set()\n            for f in result:\n                add_dir(dirs, os.path.dirname(f))\n            result |= dirs\n        return [os.path.join(*path_tuple) for path_tuple in\n                sorted(os.path.split(path) for path in result)]\n\n    def clear(self):\n        \"\"\"Clear all collected files.\"\"\"\n        self.files = set()\n        self.allfiles = []\n\n    def process_directive(self, directive):\n        \"\"\"\n        Process a directive which either adds some files from ``allfiles`` to\n        ``files``, or removes some files from ``files``.\n\n        :param directive: The directive to process. This should be in a format\n                     compatible with distutils ``MANIFEST.in`` files:\n\n                     http://docs.python.org/distutils/sourcedist.html#commands\n        \"\"\"\n        # Parse the line: split it up, make sure the right number of words\n        # is there, and return the relevant words.  'action' is always\n        # defined: it's the first word of the line.  Which of the other\n        # three are defined depends on the action; it'll be either\n        # patterns, (dir and patterns), or (dirpattern).\n        action, patterns, thedir, dirpattern = self._parse_directive(directive)\n\n        # OK, now we know that the action is valid and we have the\n        # right number of words on the line for that action -- so we\n        # can proceed with minimal error-checking.\n        if action == 'include':\n            for pattern in patterns:\n                if not self._include_pattern(pattern, anchor=True):\n                    logger.warning('no files found matching %r', pattern)\n\n        elif action == 'exclude':\n            for pattern in patterns:\n                self._exclude_pattern(pattern, anchor=True)\n\n        elif action == 'global-include':\n            for pattern in patterns:\n                if not self._include_pattern(pattern, anchor=False):\n                    logger.warning('no files found matching %r '\n                                   'anywhere in distribution', pattern)\n\n        elif action == 'global-exclude':\n            for pattern in patterns:\n                self._exclude_pattern(pattern, anchor=False)\n\n        elif action == 'recursive-include':\n            for pattern in patterns:\n                if not self._include_pattern(pattern, prefix=thedir):\n                    logger.warning('no files found matching %r '\n                                   'under directory %r', pattern, thedir)\n\n        elif action == 'recursive-exclude':\n            for pattern in patterns:\n                self._exclude_pattern(pattern, prefix=thedir)\n\n        elif action == 'graft':\n            if not self._include_pattern(None, prefix=dirpattern):\n                logger.warning('no directories found matching %r',\n                               dirpattern)\n\n        elif action == 'prune':\n            if not self._exclude_pattern(None, prefix=dirpattern):\n                logger.warning('no previously-included directories found '\n                               'matching %r', dirpattern)\n        else:   # pragma: no cover\n            # This should never happen, as it should be caught in\n            # _parse_template_line\n            raise DistlibException(\n                'invalid action %r' % action)\n\n    #\n    # Private API\n    #\n\n    def _parse_directive(self, directive):\n        \"\"\"\n        Validate a directive.\n        :param directive: The directive to validate.\n        :return: A tuple of action, patterns, thedir, dir_patterns\n        \"\"\"\n        words = directive.split()\n        if len(words) == 1 and words[0] not in ('include', 'exclude',\n                                                'global-include',\n                                                'global-exclude',\n                                                'recursive-include',\n                                                'recursive-exclude',\n                                                'graft', 'prune'):\n            # no action given, let's use the default 'include'\n            words.insert(0, 'include')\n\n        action = words[0]\n        patterns = thedir = dir_pattern = None\n\n        if action in ('include', 'exclude',\n                      'global-include', 'global-exclude'):\n            if len(words) < 2:\n                raise DistlibException(\n                    '%r expects <pattern1> <pattern2> ...' % action)\n\n            patterns = [convert_path(word) for word in words[1:]]\n\n        elif action in ('recursive-include', 'recursive-exclude'):\n            if len(words) < 3:\n                raise DistlibException(\n                    '%r expects <dir> <pattern1> <pattern2> ...' % action)\n\n            thedir = convert_path(words[1])\n            patterns = [convert_path(word) for word in words[2:]]\n\n        elif action in ('graft', 'prune'):\n            if len(words) != 2:\n                raise DistlibException(\n                    '%r expects a single <dir_pattern>' % action)\n\n            dir_pattern = convert_path(words[1])\n\n        else:\n            raise DistlibException('unknown action %r' % action)\n\n        return action, patterns, thedir, dir_pattern\n\n    def _include_pattern(self, pattern, anchor=True, prefix=None,\n                         is_regex=False):\n        \"\"\"Select strings (presumably filenames) from 'self.files' that\n        match 'pattern', a Unix-style wildcard (glob) pattern.\n\n        Patterns are not quite the same as implemented by the 'fnmatch'\n        module: '*' and '?'  match non-special characters, where \"special\"\n        is platform-dependent: slash on Unix; colon, slash, and backslash on\n        DOS/Windows; and colon on Mac OS.\n\n        If 'anchor' is true (the default), then the pattern match is more\n        stringent: \"*.py\" will match \"foo.py\" but not \"foo/bar.py\".  If\n        'anchor' is false, both of these will match.\n\n        If 'prefix' is supplied, then only filenames starting with 'prefix'\n        (itself a pattern) and ending with 'pattern', with anything in between\n        them, will match.  'anchor' is ignored in this case.\n\n        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and\n        'pattern' is assumed to be either a string containing a regex or a\n        regex object -- no translation is done, the regex is just compiled\n        and used as-is.\n\n        Selected strings will be added to self.files.\n\n        Return True if files are found.\n        \"\"\"\n        # XXX docstring lying about what the special chars are?\n        found = False\n        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)\n\n        # delayed loading of allfiles list\n        if self.allfiles is None:\n            self.findall()\n\n        for name in self.allfiles:\n            if pattern_re.search(name):\n                self.files.add(name)\n                found = True\n        return found\n\n    def _exclude_pattern(self, pattern, anchor=True, prefix=None,\n                         is_regex=False):\n        \"\"\"Remove strings (presumably filenames) from 'files' that match\n        'pattern'.\n\n        Other parameters are the same as for 'include_pattern()', above.\n        The list 'self.files' is modified in place. Return True if files are\n        found.\n\n        This API is public to allow e.g. exclusion of SCM subdirs, e.g. when\n        packaging source distributions\n        \"\"\"\n        found = False\n        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)\n        for f in list(self.files):\n            if pattern_re.search(f):\n                self.files.remove(f)\n                found = True\n        return found\n\n    def _translate_pattern(self, pattern, anchor=True, prefix=None,\n                           is_regex=False):\n        \"\"\"Translate a shell-like wildcard pattern to a compiled regular\n        expression.\n\n        Return the compiled regex.  If 'is_regex' true,\n        then 'pattern' is directly compiled to a regex (if it's a string)\n        or just returned as-is (assumes it's a regex object).\n        \"\"\"\n        if is_regex:\n            if isinstance(pattern, str):\n                return re.compile(pattern)\n            else:\n                return pattern\n\n        if _PYTHON_VERSION > (3, 2):\n            # ditch start and end characters\n            start, _, end = self._glob_to_re('_').partition('_')\n\n        if pattern:\n            pattern_re = self._glob_to_re(pattern)\n            if _PYTHON_VERSION > (3, 2):\n                assert pattern_re.startswith(start) and pattern_re.endswith(end)\n        else:\n            pattern_re = ''\n\n        base = re.escape(os.path.join(self.base, ''))\n        if prefix is not None:\n            # ditch end of pattern character\n            if _PYTHON_VERSION <= (3, 2):\n                empty_pattern = self._glob_to_re('')\n                prefix_re = self._glob_to_re(prefix)[:-len(empty_pattern)]\n            else:\n                prefix_re = self._glob_to_re(prefix)\n                assert prefix_re.startswith(start) and prefix_re.endswith(end)\n                prefix_re = prefix_re[len(start): len(prefix_re) - len(end)]\n            sep = os.sep\n            if os.sep == '\\\\':\n                sep = r'\\\\'\n            if _PYTHON_VERSION <= (3, 2):\n                pattern_re = '^' + base + sep.join((prefix_re,\n                                                    '.*' + pattern_re))\n            else:\n                pattern_re = pattern_re[len(start): len(pattern_re) - len(end)]\n                pattern_re = r'%s%s%s%s.*%s%s' % (start, base, prefix_re, sep,\n                                                  pattern_re, end)\n        else:  # no prefix -- respect anchor flag\n            if anchor:\n                if _PYTHON_VERSION <= (3, 2):\n                    pattern_re = '^' + base + pattern_re\n                else:\n                    pattern_re = r'%s%s%s' % (start, base, pattern_re[len(start):])\n\n        return re.compile(pattern_re)\n\n    def _glob_to_re(self, pattern):\n        \"\"\"Translate a shell-like glob pattern to a regular expression.\n\n        Return a string containing the regex.  Differs from\n        'fnmatch.translate()' in that '*' does not match \"special characters\"\n        (which are platform-specific).\n        \"\"\"\n        pattern_re = fnmatch.translate(pattern)\n\n        # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which\n        # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,\n        # and by extension they shouldn't match such \"special characters\" under\n        # any OS.  So change all non-escaped dots in the RE to match any\n        # character except the special characters (currently: just os.sep).\n        sep = os.sep\n        if os.sep == '\\\\':\n            # we're using a regex to manipulate a regex, so we need\n            # to escape the backslash twice\n            sep = r'\\\\\\\\'\n        escaped = r'\\1[^%s]' % sep\n        pattern_re = re.sub(r'((?<!\\\\)(\\\\\\\\)*)\\.', escaped, pattern_re)\n        return pattern_re\n", "distlib/version.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"\nImplementation of a flexible versioning scheme providing support for PEP-440,\nsetuptools-compatible and semantic versioning.\n\"\"\"\n\nimport logging\nimport re\n\nfrom .compat import string_types\nfrom .util import parse_requirement\n\n__all__ = ['NormalizedVersion', 'NormalizedMatcher',\n           'LegacyVersion', 'LegacyMatcher',\n           'SemanticVersion', 'SemanticMatcher',\n           'UnsupportedVersionError', 'get_scheme']\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnsupportedVersionError(ValueError):\n    \"\"\"This is an unsupported version.\"\"\"\n    pass\n\n\nclass Version(object):\n    def __init__(self, s):\n        self._string = s = s.strip()\n        self._parts = parts = self.parse(s)\n        assert isinstance(parts, tuple)\n        assert len(parts) > 0\n\n    def parse(self, s):\n        raise NotImplementedError('please implement in a subclass')\n\n    def _check_compatible(self, other):\n        if type(self) != type(other):\n            raise TypeError('cannot compare %r and %r' % (self, other))\n\n    def __eq__(self, other):\n        self._check_compatible(other)\n        return self._parts == other._parts\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        self._check_compatible(other)\n        return self._parts < other._parts\n\n    def __gt__(self, other):\n        return not (self.__lt__(other) or self.__eq__(other))\n\n    def __le__(self, other):\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __ge__(self, other):\n        return self.__gt__(other) or self.__eq__(other)\n\n    # See http://docs.python.org/reference/datamodel#object.__hash__\n    def __hash__(self):\n        return hash(self._parts)\n\n    def __repr__(self):\n        return \"%s('%s')\" % (self.__class__.__name__, self._string)\n\n    def __str__(self):\n        return self._string\n\n    @property\n    def is_prerelease(self):\n        raise NotImplementedError('Please implement in subclasses.')\n\n\nclass Matcher(object):\n    version_class = None\n\n    # value is either a callable or the name of a method\n    _operators = {\n        '<': lambda v, c, p: v < c,\n        '>': lambda v, c, p: v > c,\n        '<=': lambda v, c, p: v == c or v < c,\n        '>=': lambda v, c, p: v == c or v > c,\n        '==': lambda v, c, p: v == c,\n        '===': lambda v, c, p: v == c,\n        # by default, compatible => >=.\n        '~=': lambda v, c, p: v == c or v > c,\n        '!=': lambda v, c, p: v != c,\n    }\n\n    # this is a method only to support alternative implementations\n    # via overriding\n    def parse_requirement(self, s):\n        return parse_requirement(s)\n\n    def __init__(self, s):\n        if self.version_class is None:\n            raise ValueError('Please specify a version class')\n        self._string = s = s.strip()\n        r = self.parse_requirement(s)\n        if not r:\n            raise ValueError('Not valid: %r' % s)\n        self.name = r.name\n        self.key = self.name.lower()    # for case-insensitive comparisons\n        clist = []\n        if r.constraints:\n            # import pdb; pdb.set_trace()\n            for op, s in r.constraints:\n                if s.endswith('.*'):\n                    if op not in ('==', '!='):\n                        raise ValueError('\\'.*\\' not allowed for '\n                                         '%r constraints' % op)\n                    # Could be a partial version (e.g. for '2.*') which\n                    # won't parse as a version, so keep it as a string\n                    vn, prefix = s[:-2], True\n                    # Just to check that vn is a valid version\n                    self.version_class(vn)\n                else:\n                    # Should parse as a version, so we can create an\n                    # instance for the comparison\n                    vn, prefix = self.version_class(s), False\n                clist.append((op, vn, prefix))\n        self._parts = tuple(clist)\n\n    def match(self, version):\n        \"\"\"\n        Check if the provided version matches the constraints.\n\n        :param version: The version to match against this instance.\n        :type version: String or :class:`Version` instance.\n        \"\"\"\n        if isinstance(version, string_types):\n            version = self.version_class(version)\n        for operator, constraint, prefix in self._parts:\n            f = self._operators.get(operator)\n            if isinstance(f, string_types):\n                f = getattr(self, f)\n            if not f:\n                msg = ('%r not implemented '\n                       'for %s' % (operator, self.__class__.__name__))\n                raise NotImplementedError(msg)\n            if not f(version, constraint, prefix):\n                return False\n        return True\n\n    @property\n    def exact_version(self):\n        result = None\n        if len(self._parts) == 1 and self._parts[0][0] in ('==', '==='):\n            result = self._parts[0][1]\n        return result\n\n    def _check_compatible(self, other):\n        if type(self) != type(other) or self.name != other.name:\n            raise TypeError('cannot compare %s and %s' % (self, other))\n\n    def __eq__(self, other):\n        self._check_compatible(other)\n        return self.key == other.key and self._parts == other._parts\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    # See http://docs.python.org/reference/datamodel#object.__hash__\n    def __hash__(self):\n        return hash(self.key) + hash(self._parts)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self._string)\n\n    def __str__(self):\n        return self._string\n\n\nPEP440_VERSION_RE = re.compile(r'^v?(\\d+!)?(\\d+(\\.\\d+)*)((a|alpha|b|beta|c|rc|pre|preview)(\\d+)?)?'\n                               r'(\\.(post|r|rev)(\\d+)?)?([._-]?(dev)(\\d+)?)?'\n                               r'(\\+([a-zA-Z\\d]+(\\.[a-zA-Z\\d]+)?))?$', re.I)\n\n\ndef _pep_440_key(s):\n    s = s.strip()\n    m = PEP440_VERSION_RE.match(s)\n    if not m:\n        raise UnsupportedVersionError('Not a valid version: %s' % s)\n    groups = m.groups()\n    nums = tuple(int(v) for v in groups[1].split('.'))\n    while len(nums) > 1 and nums[-1] == 0:\n        nums = nums[:-1]\n\n    if not groups[0]:\n        epoch = 0\n    else:\n        epoch = int(groups[0][:-1])\n    pre = groups[4:6]\n    post = groups[7:9]\n    dev = groups[10:12]\n    local = groups[13]\n    if pre == (None, None):\n        pre = ()\n    else:\n        if pre[1] is None:\n            pre = pre[0], 0\n        else:\n            pre = pre[0], int(pre[1])\n    if post == (None, None):\n        post = ()\n    else:\n        if post[1] is None:\n            post = post[0], 0\n        else:\n            post = post[0], int(post[1])\n    if dev == (None, None):\n        dev = ()\n    else:\n        if dev[1] is None:\n            dev = dev[0], 0\n        else:\n            dev = dev[0], int(dev[1])\n    if local is None:\n        local = ()\n    else:\n        parts = []\n        for part in local.split('.'):\n            # to ensure that numeric compares as > lexicographic, avoid\n            # comparing them directly, but encode a tuple which ensures\n            # correct sorting\n            if part.isdigit():\n                part = (1, int(part))\n            else:\n                part = (0, part)\n            parts.append(part)\n        local = tuple(parts)\n    if not pre:\n        # either before pre-release, or final release and after\n        if not post and dev:\n            # before pre-release\n            pre = ('a', -1)     # to sort before a0\n        else:\n            pre = ('z',)        # to sort after all pre-releases\n    # now look at the state of post and dev.\n    if not post:\n        post = ('_',)   # sort before 'a'\n    if not dev:\n        dev = ('final',)\n\n    return epoch, nums, pre, post, dev, local\n\n\n_normalized_key = _pep_440_key\n\n\nclass NormalizedVersion(Version):\n    \"\"\"A rational version.\n\n    Good:\n        1.2         # equivalent to \"1.2.0\"\n        1.2.0\n        1.2a1\n        1.2.3a2\n        1.2.3b1\n        1.2.3c1\n        1.2.3.4\n        TODO: fill this out\n\n    Bad:\n        1           # minimum two numbers\n        1.2a        # release level must have a release serial\n        1.2.3b\n    \"\"\"\n    def parse(self, s):\n        result = _normalized_key(s)\n        # _normalized_key loses trailing zeroes in the release\n        # clause, since that's needed to ensure that X.Y == X.Y.0 == X.Y.0.0\n        # However, PEP 440 prefix matching needs it: for example,\n        # (~= 1.4.5.0) matches differently to (~= 1.4.5.0.0).\n        m = PEP440_VERSION_RE.match(s)      # must succeed\n        groups = m.groups()\n        self._release_clause = tuple(int(v) for v in groups[1].split('.'))\n        return result\n\n    PREREL_TAGS = set(['a', 'b', 'c', 'rc', 'dev'])\n\n    @property\n    def is_prerelease(self):\n        return any(t[0] in self.PREREL_TAGS for t in self._parts if t)\n\n\ndef _match_prefix(x, y):\n    x = str(x)\n    y = str(y)\n    if x == y:\n        return True\n    if not x.startswith(y):\n        return False\n    n = len(y)\n    return x[n] == '.'\n\n\nclass NormalizedMatcher(Matcher):\n    version_class = NormalizedVersion\n\n    # value is either a callable or the name of a method\n    _operators = {\n        '~=': '_match_compatible',\n        '<': '_match_lt',\n        '>': '_match_gt',\n        '<=': '_match_le',\n        '>=': '_match_ge',\n        '==': '_match_eq',\n        '===': '_match_arbitrary',\n        '!=': '_match_ne',\n    }\n\n    def _adjust_local(self, version, constraint, prefix):\n        if prefix:\n            strip_local = '+' not in constraint and version._parts[-1]\n        else:\n            # both constraint and version are\n            # NormalizedVersion instances.\n            # If constraint does not have a local component,\n            # ensure the version doesn't, either.\n            strip_local = not constraint._parts[-1] and version._parts[-1]\n        if strip_local:\n            s = version._string.split('+', 1)[0]\n            version = self.version_class(s)\n        return version, constraint\n\n    def _match_lt(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        if version >= constraint:\n            return False\n        release_clause = constraint._release_clause\n        pfx = '.'.join([str(i) for i in release_clause])\n        return not _match_prefix(version, pfx)\n\n    def _match_gt(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        if version <= constraint:\n            return False\n        release_clause = constraint._release_clause\n        pfx = '.'.join([str(i) for i in release_clause])\n        return not _match_prefix(version, pfx)\n\n    def _match_le(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        return version <= constraint\n\n    def _match_ge(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        return version >= constraint\n\n    def _match_eq(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        if not prefix:\n            result = (version == constraint)\n        else:\n            result = _match_prefix(version, constraint)\n        return result\n\n    def _match_arbitrary(self, version, constraint, prefix):\n        return str(version) == str(constraint)\n\n    def _match_ne(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        if not prefix:\n            result = (version != constraint)\n        else:\n            result = not _match_prefix(version, constraint)\n        return result\n\n    def _match_compatible(self, version, constraint, prefix):\n        version, constraint = self._adjust_local(version, constraint, prefix)\n        if version == constraint:\n            return True\n        if version < constraint:\n            return False\n#        if not prefix:\n#            return True\n        release_clause = constraint._release_clause\n        if len(release_clause) > 1:\n            release_clause = release_clause[:-1]\n        pfx = '.'.join([str(i) for i in release_clause])\n        return _match_prefix(version, pfx)\n\n\n_REPLACEMENTS = (\n    (re.compile('[.+-]$'), ''),                     # remove trailing puncts\n    (re.compile(r'^[.](\\d)'), r'0.\\1'),             # .N -> 0.N at start\n    (re.compile('^[.-]'), ''),                      # remove leading puncts\n    (re.compile(r'^\\((.*)\\)$'), r'\\1'),             # remove parentheses\n    (re.compile(r'^v(ersion)?\\s*(\\d+)'), r'\\2'),    # remove leading v(ersion)\n    (re.compile(r'^r(ev)?\\s*(\\d+)'), r'\\2'),        # remove leading v(ersion)\n    (re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'\n    (re.compile(r'\\b(alfa|apha)\\b'), 'alpha'),      # misspelt alpha\n    (re.compile(r'\\b(pre-alpha|prealpha)\\b'),\n        'pre.alpha'),                               # standardise\n    (re.compile(r'\\(beta\\)$'), 'beta'),             # remove parentheses\n)\n\n_SUFFIX_REPLACEMENTS = (\n    (re.compile('^[:~._+-]+'), ''),                   # remove leading puncts\n    (re.compile('[,*\")([\\\\]]'), ''),                  # remove unwanted chars\n    (re.compile('[~:+_ -]'), '.'),                    # replace illegal chars\n    (re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'\n    (re.compile(r'\\.$'), ''),                       # trailing '.'\n)\n\n_NUMERIC_PREFIX = re.compile(r'(\\d+(\\.\\d+)*)')\n\n\ndef _suggest_semantic_version(s):\n    \"\"\"\n    Try to suggest a semantic form for a version for which\n    _suggest_normalized_version couldn't come up with anything.\n    \"\"\"\n    result = s.strip().lower()\n    for pat, repl in _REPLACEMENTS:\n        result = pat.sub(repl, result)\n    if not result:\n        result = '0.0.0'\n\n    # Now look for numeric prefix, and separate it out from\n    # the rest.\n    # import pdb; pdb.set_trace()\n    m = _NUMERIC_PREFIX.match(result)\n    if not m:\n        prefix = '0.0.0'\n        suffix = result\n    else:\n        prefix = m.groups()[0].split('.')\n        prefix = [int(i) for i in prefix]\n        while len(prefix) < 3:\n            prefix.append(0)\n        if len(prefix) == 3:\n            suffix = result[m.end():]\n        else:\n            suffix = '.'.join([str(i) for i in prefix[3:]]) + result[m.end():]\n            prefix = prefix[:3]\n        prefix = '.'.join([str(i) for i in prefix])\n        suffix = suffix.strip()\n    if suffix:\n        # import pdb; pdb.set_trace()\n        # massage the suffix.\n        for pat, repl in _SUFFIX_REPLACEMENTS:\n            suffix = pat.sub(repl, suffix)\n\n    if not suffix:\n        result = prefix\n    else:\n        sep = '-' if 'dev' in suffix else '+'\n        result = prefix + sep + suffix\n    if not is_semver(result):\n        result = None\n    return result\n\n\ndef _suggest_normalized_version(s):\n    \"\"\"Suggest a normalized version close to the given version string.\n\n    If you have a version string that isn't rational (i.e. NormalizedVersion\n    doesn't like it) then you might be able to get an equivalent (or close)\n    rational version from this function.\n\n    This does a number of simple normalizations to the given string, based\n    on observation of versions currently in use on PyPI. Given a dump of\n    those version during PyCon 2009, 4287 of them:\n    - 2312 (53.93%) match NormalizedVersion without change\n      with the automatic suggestion\n    - 3474 (81.04%) match when using this suggestion method\n\n    @param s {str} An irrational version string.\n    @returns A rational version string, or None, if couldn't determine one.\n    \"\"\"\n    try:\n        _normalized_key(s)\n        return s   # already rational\n    except UnsupportedVersionError:\n        pass\n\n    rs = s.lower()\n\n    # part of this could use maketrans\n    for orig, repl in (('-alpha', 'a'), ('-beta', 'b'), ('alpha', 'a'),\n                       ('beta', 'b'), ('rc', 'c'), ('-final', ''),\n                       ('-pre', 'c'),\n                       ('-release', ''), ('.release', ''), ('-stable', ''),\n                       ('+', '.'), ('_', '.'), (' ', ''), ('.final', ''),\n                       ('final', '')):\n        rs = rs.replace(orig, repl)\n\n    # if something ends with dev or pre, we add a 0\n    rs = re.sub(r\"pre$\", r\"pre0\", rs)\n    rs = re.sub(r\"dev$\", r\"dev0\", rs)\n\n    # if we have something like \"b-2\" or \"a.2\" at the end of the\n    # version, that is probably beta, alpha, etc\n    # let's remove the dash or dot\n    rs = re.sub(r\"([abc]|rc)[\\-\\.](\\d+)$\", r\"\\1\\2\", rs)\n\n    # 1.0-dev-r371 -> 1.0.dev371\n    # 0.1-dev-r79 -> 0.1.dev79\n    rs = re.sub(r\"[\\-\\.](dev)[\\-\\.]?r?(\\d+)$\", r\".\\1\\2\", rs)\n\n    # Clean: 2.0.a.3, 2.0.b1, 0.9.0~c1\n    rs = re.sub(r\"[.~]?([abc])\\.?\", r\"\\1\", rs)\n\n    # Clean: v0.3, v1.0\n    if rs.startswith('v'):\n        rs = rs[1:]\n\n    # Clean leading '0's on numbers.\n    # TODO: unintended side-effect on, e.g., \"2003.05.09\"\n    # PyPI stats: 77 (~2%) better\n    rs = re.sub(r\"\\b0+(\\d+)(?!\\d)\", r\"\\1\", rs)\n\n    # Clean a/b/c with no version. E.g. \"1.0a\" -> \"1.0a0\". Setuptools infers\n    # zero.\n    # PyPI stats: 245 (7.56%) better\n    rs = re.sub(r\"(\\d+[abc])$\", r\"\\g<1>0\", rs)\n\n    # the 'dev-rNNN' tag is a dev tag\n    rs = re.sub(r\"\\.?(dev-r|dev\\.r)\\.?(\\d+)$\", r\".dev\\2\", rs)\n\n    # clean the - when used as a pre delimiter\n    rs = re.sub(r\"-(a|b|c)(\\d+)$\", r\"\\1\\2\", rs)\n\n    # a terminal \"dev\" or \"devel\" can be changed into \".dev0\"\n    rs = re.sub(r\"[\\.\\-](dev|devel)$\", r\".dev0\", rs)\n\n    # a terminal \"dev\" can be changed into \".dev0\"\n    rs = re.sub(r\"(?![\\.\\-])dev$\", r\".dev0\", rs)\n\n    # a terminal \"final\" or \"stable\" can be removed\n    rs = re.sub(r\"(final|stable)$\", \"\", rs)\n\n    # The 'r' and the '-' tags are post release tags\n    #   0.4a1.r10       ->  0.4a1.post10\n    #   0.9.33-17222    ->  0.9.33.post17222\n    #   0.9.33-r17222   ->  0.9.33.post17222\n    rs = re.sub(r\"\\.?(r|-|-r)\\.?(\\d+)$\", r\".post\\2\", rs)\n\n    # Clean 'r' instead of 'dev' usage:\n    #   0.9.33+r17222   ->  0.9.33.dev17222\n    #   1.0dev123       ->  1.0.dev123\n    #   1.0.git123      ->  1.0.dev123\n    #   1.0.bzr123      ->  1.0.dev123\n    #   0.1a0dev.123    ->  0.1a0.dev123\n    # PyPI stats:  ~150 (~4%) better\n    rs = re.sub(r\"\\.?(dev|git|bzr)\\.?(\\d+)$\", r\".dev\\2\", rs)\n\n    # Clean '.pre' (normalized from '-pre' above) instead of 'c' usage:\n    #   0.2.pre1        ->  0.2c1\n    #   0.2-c1         ->  0.2c1\n    #   1.0preview123   ->  1.0c123\n    # PyPI stats: ~21 (0.62%) better\n    rs = re.sub(r\"\\.?(pre|preview|-c)(\\d+)$\", r\"c\\g<2>\", rs)\n\n    # Tcl/Tk uses \"px\" for their post release markers\n    rs = re.sub(r\"p(\\d+)$\", r\".post\\1\", rs)\n\n    try:\n        _normalized_key(rs)\n    except UnsupportedVersionError:\n        rs = None\n    return rs\n\n#\n#   Legacy version processing (distribute-compatible)\n#\n\n\n_VERSION_PART = re.compile(r'([a-z]+|\\d+|[\\.-])', re.I)\n_VERSION_REPLACE = {\n    'pre': 'c',\n    'preview': 'c',\n    '-': 'final-',\n    'rc': 'c',\n    'dev': '@',\n    '': None,\n    '.': None,\n}\n\n\ndef _legacy_key(s):\n    def get_parts(s):\n        result = []\n        for p in _VERSION_PART.split(s.lower()):\n            p = _VERSION_REPLACE.get(p, p)\n            if p:\n                if '0' <= p[:1] <= '9':\n                    p = p.zfill(8)\n                else:\n                    p = '*' + p\n                result.append(p)\n        result.append('*final')\n        return result\n\n    result = []\n    for p in get_parts(s):\n        if p.startswith('*'):\n            if p < '*final':\n                while result and result[-1] == '*final-':\n                    result.pop()\n            while result and result[-1] == '00000000':\n                result.pop()\n        result.append(p)\n    return tuple(result)\n\n\nclass LegacyVersion(Version):\n    def parse(self, s):\n        return _legacy_key(s)\n\n    @property\n    def is_prerelease(self):\n        result = False\n        for x in self._parts:\n            if (isinstance(x, string_types) and x.startswith('*') and x < '*final'):\n                result = True\n                break\n        return result\n\n\nclass LegacyMatcher(Matcher):\n    version_class = LegacyVersion\n\n    _operators = dict(Matcher._operators)\n    _operators['~='] = '_match_compatible'\n\n    numeric_re = re.compile(r'^(\\d+(\\.\\d+)*)')\n\n    def _match_compatible(self, version, constraint, prefix):\n        if version < constraint:\n            return False\n        m = self.numeric_re.match(str(constraint))\n        if not m:\n            logger.warning('Cannot compute compatible match for version %s '\n                           ' and constraint %s', version, constraint)\n            return True\n        s = m.groups()[0]\n        if '.' in s:\n            s = s.rsplit('.', 1)[0]\n        return _match_prefix(version, s)\n\n#\n#   Semantic versioning\n#\n\n\n_SEMVER_RE = re.compile(r'^(\\d+)\\.(\\d+)\\.(\\d+)'\n                        r'(-[a-z0-9]+(\\.[a-z0-9-]+)*)?'\n                        r'(\\+[a-z0-9]+(\\.[a-z0-9-]+)*)?$', re.I)\n\n\ndef is_semver(s):\n    return _SEMVER_RE.match(s)\n\n\ndef _semantic_key(s):\n    def make_tuple(s, absent):\n        if s is None:\n            result = (absent,)\n        else:\n            parts = s[1:].split('.')\n            # We can't compare ints and strings on Python 3, so fudge it\n            # by zero-filling numeric values so simulate a numeric comparison\n            result = tuple([p.zfill(8) if p.isdigit() else p for p in parts])\n        return result\n\n    m = is_semver(s)\n    if not m:\n        raise UnsupportedVersionError(s)\n    groups = m.groups()\n    major, minor, patch = [int(i) for i in groups[:3]]\n    # choose the '|' and '*' so that versions sort correctly\n    pre, build = make_tuple(groups[3], '|'), make_tuple(groups[5], '*')\n    return (major, minor, patch), pre, build\n\n\nclass SemanticVersion(Version):\n    def parse(self, s):\n        return _semantic_key(s)\n\n    @property\n    def is_prerelease(self):\n        return self._parts[1][0] != '|'\n\n\nclass SemanticMatcher(Matcher):\n    version_class = SemanticVersion\n\n\nclass VersionScheme(object):\n    def __init__(self, key, matcher, suggester=None):\n        self.key = key\n        self.matcher = matcher\n        self.suggester = suggester\n\n    def is_valid_version(self, s):\n        try:\n            self.matcher.version_class(s)\n            result = True\n        except UnsupportedVersionError:\n            result = False\n        return result\n\n    def is_valid_matcher(self, s):\n        try:\n            self.matcher(s)\n            result = True\n        except UnsupportedVersionError:\n            result = False\n        return result\n\n    def is_valid_constraint_list(self, s):\n        \"\"\"\n        Used for processing some metadata fields\n        \"\"\"\n        # See issue #140. Be tolerant of a single trailing comma.\n        if s.endswith(','):\n            s = s[:-1]\n        return self.is_valid_matcher('dummy_name (%s)' % s)\n\n    def suggest(self, s):\n        if self.suggester is None:\n            result = None\n        else:\n            result = self.suggester(s)\n        return result\n\n\n_SCHEMES = {\n    'normalized': VersionScheme(_normalized_key, NormalizedMatcher,\n                                _suggest_normalized_version),\n    'legacy': VersionScheme(_legacy_key, LegacyMatcher, lambda self, s: s),\n    'semantic': VersionScheme(_semantic_key, SemanticMatcher,\n                              _suggest_semantic_version),\n}\n\n_SCHEMES['default'] = _SCHEMES['normalized']\n\n\ndef get_scheme(name):\n    if name not in _SCHEMES:\n        raise ValueError('unknown scheme name: %r' % name)\n    return _SCHEMES[name]\n", "distlib/util.py": "#\n# Copyright (C) 2012-2023 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport codecs\nfrom collections import deque\nimport contextlib\nimport csv\nfrom glob import iglob as std_iglob\nimport io\nimport json\nimport logging\nimport os\nimport py_compile\nimport re\nimport socket\ntry:\n    import ssl\nexcept ImportError:  # pragma: no cover\n    ssl = None\nimport subprocess\nimport sys\nimport tarfile\nimport tempfile\nimport textwrap\n\ntry:\n    import threading\nexcept ImportError:  # pragma: no cover\n    import dummy_threading as threading\nimport time\n\nfrom . import DistlibException\nfrom .compat import (string_types, text_type, shutil, raw_input, StringIO, cache_from_source, urlopen, urljoin, httplib,\n                     xmlrpclib, HTTPHandler, BaseConfigurator, valid_ident, Container, configparser, URLError, ZipFile,\n                     fsdecode, unquote, urlparse)\n\nlogger = logging.getLogger(__name__)\n\n#\n# Requirement parsing code as per PEP 508\n#\n\nIDENTIFIER = re.compile(r'^([\\w\\.-]+)\\s*')\nVERSION_IDENTIFIER = re.compile(r'^([\\w\\.*+-]+)\\s*')\nCOMPARE_OP = re.compile(r'^(<=?|>=?|={2,3}|[~!]=)\\s*')\nMARKER_OP = re.compile(r'^((<=?)|(>=?)|={2,3}|[~!]=|in|not\\s+in)\\s*')\nOR = re.compile(r'^or\\b\\s*')\nAND = re.compile(r'^and\\b\\s*')\nNON_SPACE = re.compile(r'(\\S+)\\s*')\nSTRING_CHUNK = re.compile(r'([\\s\\w\\.{}()*+#:;,/?!~`@$%^&=|<>\\[\\]-]+)')\n\n\ndef parse_marker(marker_string):\n    \"\"\"\n    Parse a marker string and return a dictionary containing a marker expression.\n\n    The dictionary will contain keys \"op\", \"lhs\" and \"rhs\" for non-terminals in\n    the expression grammar, or strings. A string contained in quotes is to be\n    interpreted as a literal string, and a string not contained in quotes is a\n    variable (such as os_name).\n    \"\"\"\n\n    def marker_var(remaining):\n        # either identifier, or literal string\n        m = IDENTIFIER.match(remaining)\n        if m:\n            result = m.groups()[0]\n            remaining = remaining[m.end():]\n        elif not remaining:\n            raise SyntaxError('unexpected end of input')\n        else:\n            q = remaining[0]\n            if q not in '\\'\"':\n                raise SyntaxError('invalid expression: %s' % remaining)\n            oq = '\\'\"'.replace(q, '')\n            remaining = remaining[1:]\n            parts = [q]\n            while remaining:\n                # either a string chunk, or oq, or q to terminate\n                if remaining[0] == q:\n                    break\n                elif remaining[0] == oq:\n                    parts.append(oq)\n                    remaining = remaining[1:]\n                else:\n                    m = STRING_CHUNK.match(remaining)\n                    if not m:\n                        raise SyntaxError('error in string literal: %s' % remaining)\n                    parts.append(m.groups()[0])\n                    remaining = remaining[m.end():]\n            else:\n                s = ''.join(parts)\n                raise SyntaxError('unterminated string: %s' % s)\n            parts.append(q)\n            result = ''.join(parts)\n            remaining = remaining[1:].lstrip()  # skip past closing quote\n        return result, remaining\n\n    def marker_expr(remaining):\n        if remaining and remaining[0] == '(':\n            result, remaining = marker(remaining[1:].lstrip())\n            if remaining[0] != ')':\n                raise SyntaxError('unterminated parenthesis: %s' % remaining)\n            remaining = remaining[1:].lstrip()\n        else:\n            lhs, remaining = marker_var(remaining)\n            while remaining:\n                m = MARKER_OP.match(remaining)\n                if not m:\n                    break\n                op = m.groups()[0]\n                remaining = remaining[m.end():]\n                rhs, remaining = marker_var(remaining)\n                lhs = {'op': op, 'lhs': lhs, 'rhs': rhs}\n            result = lhs\n        return result, remaining\n\n    def marker_and(remaining):\n        lhs, remaining = marker_expr(remaining)\n        while remaining:\n            m = AND.match(remaining)\n            if not m:\n                break\n            remaining = remaining[m.end():]\n            rhs, remaining = marker_expr(remaining)\n            lhs = {'op': 'and', 'lhs': lhs, 'rhs': rhs}\n        return lhs, remaining\n\n    def marker(remaining):\n        lhs, remaining = marker_and(remaining)\n        while remaining:\n            m = OR.match(remaining)\n            if not m:\n                break\n            remaining = remaining[m.end():]\n            rhs, remaining = marker_and(remaining)\n            lhs = {'op': 'or', 'lhs': lhs, 'rhs': rhs}\n        return lhs, remaining\n\n    return marker(marker_string)\n\n\ndef parse_requirement(req):\n    \"\"\"\n    Parse a requirement passed in as a string. Return a Container\n    whose attributes contain the various parts of the requirement.\n    \"\"\"\n    remaining = req.strip()\n    if not remaining or remaining.startswith('#'):\n        return None\n    m = IDENTIFIER.match(remaining)\n    if not m:\n        raise SyntaxError('name expected: %s' % remaining)\n    distname = m.groups()[0]\n    remaining = remaining[m.end():]\n    extras = mark_expr = versions = uri = None\n    if remaining and remaining[0] == '[':\n        i = remaining.find(']', 1)\n        if i < 0:\n            raise SyntaxError('unterminated extra: %s' % remaining)\n        s = remaining[1:i]\n        remaining = remaining[i + 1:].lstrip()\n        extras = []\n        while s:\n            m = IDENTIFIER.match(s)\n            if not m:\n                raise SyntaxError('malformed extra: %s' % s)\n            extras.append(m.groups()[0])\n            s = s[m.end():]\n            if not s:\n                break\n            if s[0] != ',':\n                raise SyntaxError('comma expected in extras: %s' % s)\n            s = s[1:].lstrip()\n        if not extras:\n            extras = None\n    if remaining:\n        if remaining[0] == '@':\n            # it's a URI\n            remaining = remaining[1:].lstrip()\n            m = NON_SPACE.match(remaining)\n            if not m:\n                raise SyntaxError('invalid URI: %s' % remaining)\n            uri = m.groups()[0]\n            t = urlparse(uri)\n            # there are issues with Python and URL parsing, so this test\n            # is a bit crude. See bpo-20271, bpo-23505. Python doesn't\n            # always parse invalid URLs correctly - it should raise\n            # exceptions for malformed URLs\n            if not (t.scheme and t.netloc):\n                raise SyntaxError('Invalid URL: %s' % uri)\n            remaining = remaining[m.end():].lstrip()\n        else:\n\n            def get_versions(ver_remaining):\n                \"\"\"\n                Return a list of operator, version tuples if any are\n                specified, else None.\n                \"\"\"\n                m = COMPARE_OP.match(ver_remaining)\n                versions = None\n                if m:\n                    versions = []\n                    while True:\n                        op = m.groups()[0]\n                        ver_remaining = ver_remaining[m.end():]\n                        m = VERSION_IDENTIFIER.match(ver_remaining)\n                        if not m:\n                            raise SyntaxError('invalid version: %s' % ver_remaining)\n                        v = m.groups()[0]\n                        versions.append((op, v))\n                        ver_remaining = ver_remaining[m.end():]\n                        if not ver_remaining or ver_remaining[0] != ',':\n                            break\n                        ver_remaining = ver_remaining[1:].lstrip()\n                        # Some packages have a trailing comma which would break things\n                        # See issue #148\n                        if not ver_remaining:\n                            break\n                        m = COMPARE_OP.match(ver_remaining)\n                        if not m:\n                            raise SyntaxError('invalid constraint: %s' % ver_remaining)\n                    if not versions:\n                        versions = None\n                return versions, ver_remaining\n\n            if remaining[0] != '(':\n                versions, remaining = get_versions(remaining)\n            else:\n                i = remaining.find(')', 1)\n                if i < 0:\n                    raise SyntaxError('unterminated parenthesis: %s' % remaining)\n                s = remaining[1:i]\n                remaining = remaining[i + 1:].lstrip()\n                # As a special diversion from PEP 508, allow a version number\n                # a.b.c in parentheses as a synonym for ~= a.b.c (because this\n                # is allowed in earlier PEPs)\n                if COMPARE_OP.match(s):\n                    versions, _ = get_versions(s)\n                else:\n                    m = VERSION_IDENTIFIER.match(s)\n                    if not m:\n                        raise SyntaxError('invalid constraint: %s' % s)\n                    v = m.groups()[0]\n                    s = s[m.end():].lstrip()\n                    if s:\n                        raise SyntaxError('invalid constraint: %s' % s)\n                    versions = [('~=', v)]\n\n    if remaining:\n        if remaining[0] != ';':\n            raise SyntaxError('invalid requirement: %s' % remaining)\n        remaining = remaining[1:].lstrip()\n\n        mark_expr, remaining = parse_marker(remaining)\n\n    if remaining and remaining[0] != '#':\n        raise SyntaxError('unexpected trailing data: %s' % remaining)\n\n    if not versions:\n        rs = distname\n    else:\n        rs = '%s %s' % (distname, ', '.join(['%s %s' % con for con in versions]))\n    return Container(name=distname, extras=extras, constraints=versions, marker=mark_expr, url=uri, requirement=rs)\n\n\ndef get_resources_dests(resources_root, rules):\n    \"\"\"Find destinations for resources files\"\"\"\n\n    def get_rel_path(root, path):\n        # normalizes and returns a lstripped-/-separated path\n        root = root.replace(os.path.sep, '/')\n        path = path.replace(os.path.sep, '/')\n        assert path.startswith(root)\n        return path[len(root):].lstrip('/')\n\n    destinations = {}\n    for base, suffix, dest in rules:\n        prefix = os.path.join(resources_root, base)\n        for abs_base in iglob(prefix):\n            abs_glob = os.path.join(abs_base, suffix)\n            for abs_path in iglob(abs_glob):\n                resource_file = get_rel_path(resources_root, abs_path)\n                if dest is None:  # remove the entry if it was here\n                    destinations.pop(resource_file, None)\n                else:\n                    rel_path = get_rel_path(abs_base, abs_path)\n                    rel_dest = dest.replace(os.path.sep, '/').rstrip('/')\n                    destinations[resource_file] = rel_dest + '/' + rel_path\n    return destinations\n\n\ndef in_venv():\n    if hasattr(sys, 'real_prefix'):\n        # virtualenv venvs\n        result = True\n    else:\n        # PEP 405 venvs\n        result = sys.prefix != getattr(sys, 'base_prefix', sys.prefix)\n    return result\n\n\ndef get_executable():\n    # The __PYVENV_LAUNCHER__ dance is apparently no longer needed, as\n    # changes to the stub launcher mean that sys.executable always points\n    # to the stub on OS X\n    #    if sys.platform == 'darwin' and ('__PYVENV_LAUNCHER__'\n    #                                     in os.environ):\n    #        result =  os.environ['__PYVENV_LAUNCHER__']\n    #    else:\n    #        result = sys.executable\n    #    return result\n    # Avoid normcasing: see issue #143\n    # result = os.path.normcase(sys.executable)\n    result = sys.executable\n    if not isinstance(result, text_type):\n        result = fsdecode(result)\n    return result\n\n\ndef proceed(prompt, allowed_chars, error_prompt=None, default=None):\n    p = prompt\n    while True:\n        s = raw_input(p)\n        p = prompt\n        if not s and default:\n            s = default\n        if s:\n            c = s[0].lower()\n            if c in allowed_chars:\n                break\n            if error_prompt:\n                p = '%c: %s\\n%s' % (c, error_prompt, prompt)\n    return c\n\n\ndef extract_by_key(d, keys):\n    if isinstance(keys, string_types):\n        keys = keys.split()\n    result = {}\n    for key in keys:\n        if key in d:\n            result[key] = d[key]\n    return result\n\n\ndef read_exports(stream):\n    if sys.version_info[0] >= 3:\n        # needs to be a text stream\n        stream = codecs.getreader('utf-8')(stream)\n    # Try to load as JSON, falling back on legacy format\n    data = stream.read()\n    stream = StringIO(data)\n    try:\n        jdata = json.load(stream)\n        result = jdata['extensions']['python.exports']['exports']\n        for group, entries in result.items():\n            for k, v in entries.items():\n                s = '%s = %s' % (k, v)\n                entry = get_export_entry(s)\n                assert entry is not None\n                entries[k] = entry\n        return result\n    except Exception:\n        stream.seek(0, 0)\n\n    def read_stream(cp, stream):\n        if hasattr(cp, 'read_file'):\n            cp.read_file(stream)\n        else:\n            cp.readfp(stream)\n\n    cp = configparser.ConfigParser()\n    try:\n        read_stream(cp, stream)\n    except configparser.MissingSectionHeaderError:\n        stream.close()\n        data = textwrap.dedent(data)\n        stream = StringIO(data)\n        read_stream(cp, stream)\n\n    result = {}\n    for key in cp.sections():\n        result[key] = entries = {}\n        for name, value in cp.items(key):\n            s = '%s = %s' % (name, value)\n            entry = get_export_entry(s)\n            assert entry is not None\n            # entry.dist = self\n            entries[name] = entry\n    return result\n\n\ndef write_exports(exports, stream):\n    if sys.version_info[0] >= 3:\n        # needs to be a text stream\n        stream = codecs.getwriter('utf-8')(stream)\n    cp = configparser.ConfigParser()\n    for k, v in exports.items():\n        # TODO check k, v for valid values\n        cp.add_section(k)\n        for entry in v.values():\n            if entry.suffix is None:\n                s = entry.prefix\n            else:\n                s = '%s:%s' % (entry.prefix, entry.suffix)\n            if entry.flags:\n                s = '%s [%s]' % (s, ', '.join(entry.flags))\n            cp.set(k, entry.name, s)\n    cp.write(stream)\n\n\n@contextlib.contextmanager\ndef tempdir():\n    td = tempfile.mkdtemp()\n    try:\n        yield td\n    finally:\n        shutil.rmtree(td)\n\n\n@contextlib.contextmanager\ndef chdir(d):\n    cwd = os.getcwd()\n    try:\n        os.chdir(d)\n        yield\n    finally:\n        os.chdir(cwd)\n\n\n@contextlib.contextmanager\ndef socket_timeout(seconds=15):\n    cto = socket.getdefaulttimeout()\n    try:\n        socket.setdefaulttimeout(seconds)\n        yield\n    finally:\n        socket.setdefaulttimeout(cto)\n\n\nclass cached_property(object):\n\n    def __init__(self, func):\n        self.func = func\n        # for attr in ('__name__', '__module__', '__doc__'):\n        #     setattr(self, attr, getattr(func, attr, None))\n\n    def __get__(self, obj, cls=None):\n        if obj is None:\n            return self\n        value = self.func(obj)\n        object.__setattr__(obj, self.func.__name__, value)\n        # obj.__dict__[self.func.__name__] = value = self.func(obj)\n        return value\n\n\ndef convert_path(pathname):\n    \"\"\"Return 'pathname' as a name that will work on the native filesystem.\n\n    The path is split on '/' and put back together again using the current\n    directory separator.  Needed because filenames in the setup script are\n    always supplied in Unix style, and have to be converted to the local\n    convention before we can actually use them in the filesystem.  Raises\n    ValueError on non-Unix-ish systems if 'pathname' either starts or\n    ends with a slash.\n    \"\"\"\n    if os.sep == '/':\n        return pathname\n    if not pathname:\n        return pathname\n    if pathname[0] == '/':\n        raise ValueError(\"path '%s' cannot be absolute\" % pathname)\n    if pathname[-1] == '/':\n        raise ValueError(\"path '%s' cannot end with '/'\" % pathname)\n\n    paths = pathname.split('/')\n    while os.curdir in paths:\n        paths.remove(os.curdir)\n    if not paths:\n        return os.curdir\n    return os.path.join(*paths)\n\n\nclass FileOperator(object):\n\n    def __init__(self, dry_run=False):\n        self.dry_run = dry_run\n        self.ensured = set()\n        self._init_record()\n\n    def _init_record(self):\n        self.record = False\n        self.files_written = set()\n        self.dirs_created = set()\n\n    def record_as_written(self, path):\n        if self.record:\n            self.files_written.add(path)\n\n    def newer(self, source, target):\n        \"\"\"Tell if the target is newer than the source.\n\n        Returns true if 'source' exists and is more recently modified than\n        'target', or if 'source' exists and 'target' doesn't.\n\n        Returns false if both exist and 'target' is the same age or younger\n        than 'source'. Raise PackagingFileError if 'source' does not exist.\n\n        Note that this test is not very accurate: files created in the same\n        second will have the same \"age\".\n        \"\"\"\n        if not os.path.exists(source):\n            raise DistlibException(\"file '%r' does not exist\" % os.path.abspath(source))\n        if not os.path.exists(target):\n            return True\n\n        return os.stat(source).st_mtime > os.stat(target).st_mtime\n\n    def copy_file(self, infile, outfile, check=True):\n        \"\"\"Copy a file respecting dry-run and force flags.\n        \"\"\"\n        self.ensure_dir(os.path.dirname(outfile))\n        logger.info('Copying %s to %s', infile, outfile)\n        if not self.dry_run:\n            msg = None\n            if check:\n                if os.path.islink(outfile):\n                    msg = '%s is a symlink' % outfile\n                elif os.path.exists(outfile) and not os.path.isfile(outfile):\n                    msg = '%s is a non-regular file' % outfile\n            if msg:\n                raise ValueError(msg + ' which would be overwritten')\n            shutil.copyfile(infile, outfile)\n        self.record_as_written(outfile)\n\n    def copy_stream(self, instream, outfile, encoding=None):\n        assert not os.path.isdir(outfile)\n        self.ensure_dir(os.path.dirname(outfile))\n        logger.info('Copying stream %s to %s', instream, outfile)\n        if not self.dry_run:\n            if encoding is None:\n                outstream = open(outfile, 'wb')\n            else:\n                outstream = codecs.open(outfile, 'w', encoding=encoding)\n            try:\n                shutil.copyfileobj(instream, outstream)\n            finally:\n                outstream.close()\n        self.record_as_written(outfile)\n\n    def write_binary_file(self, path, data):\n        self.ensure_dir(os.path.dirname(path))\n        if not self.dry_run:\n            if os.path.exists(path):\n                os.remove(path)\n            with open(path, 'wb') as f:\n                f.write(data)\n        self.record_as_written(path)\n\n    def write_text_file(self, path, data, encoding):\n        self.write_binary_file(path, data.encode(encoding))\n\n    def set_mode(self, bits, mask, files):\n        if os.name == 'posix' or (os.name == 'java' and os._name == 'posix'):\n            # Set the executable bits (owner, group, and world) on\n            # all the files specified.\n            for f in files:\n                if self.dry_run:\n                    logger.info(\"changing mode of %s\", f)\n                else:\n                    mode = (os.stat(f).st_mode | bits) & mask\n                    logger.info(\"changing mode of %s to %o\", f, mode)\n                    os.chmod(f, mode)\n\n    set_executable_mode = lambda s, f: s.set_mode(0o555, 0o7777, f)\n\n    def ensure_dir(self, path):\n        path = os.path.abspath(path)\n        if path not in self.ensured and not os.path.exists(path):\n            self.ensured.add(path)\n            d, f = os.path.split(path)\n            self.ensure_dir(d)\n            logger.info('Creating %s' % path)\n            if not self.dry_run:\n                os.mkdir(path)\n            if self.record:\n                self.dirs_created.add(path)\n\n    def byte_compile(self, path, optimize=False, force=False, prefix=None, hashed_invalidation=False):\n        dpath = cache_from_source(path, not optimize)\n        logger.info('Byte-compiling %s to %s', path, dpath)\n        if not self.dry_run:\n            if force or self.newer(path, dpath):\n                if not prefix:\n                    diagpath = None\n                else:\n                    assert path.startswith(prefix)\n                    diagpath = path[len(prefix):]\n            compile_kwargs = {}\n            if hashed_invalidation and hasattr(py_compile, 'PycInvalidationMode'):\n                if not isinstance(hashed_invalidation, py_compile.PycInvalidationMode):\n                    hashed_invalidation = py_compile.PycInvalidationMode.CHECKED_HASH\n                compile_kwargs['invalidation_mode'] = hashed_invalidation\n            py_compile.compile(path, dpath, diagpath, True, **compile_kwargs)  # raise error\n        self.record_as_written(dpath)\n        return dpath\n\n    def ensure_removed(self, path):\n        if os.path.exists(path):\n            if os.path.isdir(path) and not os.path.islink(path):\n                logger.debug('Removing directory tree at %s', path)\n                if not self.dry_run:\n                    shutil.rmtree(path)\n                if self.record:\n                    if path in self.dirs_created:\n                        self.dirs_created.remove(path)\n            else:\n                if os.path.islink(path):\n                    s = 'link'\n                else:\n                    s = 'file'\n                logger.debug('Removing %s %s', s, path)\n                if not self.dry_run:\n                    os.remove(path)\n                if self.record:\n                    if path in self.files_written:\n                        self.files_written.remove(path)\n\n    def is_writable(self, path):\n        result = False\n        while not result:\n            if os.path.exists(path):\n                result = os.access(path, os.W_OK)\n                break\n            parent = os.path.dirname(path)\n            if parent == path:\n                break\n            path = parent\n        return result\n\n    def commit(self):\n        \"\"\"\n        Commit recorded changes, turn off recording, return\n        changes.\n        \"\"\"\n        assert self.record\n        result = self.files_written, self.dirs_created\n        self._init_record()\n        return result\n\n    def rollback(self):\n        if not self.dry_run:\n            for f in list(self.files_written):\n                if os.path.exists(f):\n                    os.remove(f)\n            # dirs should all be empty now, except perhaps for\n            # __pycache__ subdirs\n            # reverse so that subdirs appear before their parents\n            dirs = sorted(self.dirs_created, reverse=True)\n            for d in dirs:\n                flist = os.listdir(d)\n                if flist:\n                    assert flist == ['__pycache__']\n                    sd = os.path.join(d, flist[0])\n                    os.rmdir(sd)\n                os.rmdir(d)  # should fail if non-empty\n        self._init_record()\n\n\ndef resolve(module_name, dotted_path):\n    if module_name in sys.modules:\n        mod = sys.modules[module_name]\n    else:\n        mod = __import__(module_name)\n    if dotted_path is None:\n        result = mod\n    else:\n        parts = dotted_path.split('.')\n        result = getattr(mod, parts.pop(0))\n        for p in parts:\n            result = getattr(result, p)\n    return result\n\n\nclass ExportEntry(object):\n\n    def __init__(self, name, prefix, suffix, flags):\n        self.name = name\n        self.prefix = prefix\n        self.suffix = suffix\n        self.flags = flags\n\n    @cached_property\n    def value(self):\n        return resolve(self.prefix, self.suffix)\n\n    def __repr__(self):  # pragma: no cover\n        return '<ExportEntry %s = %s:%s %s>' % (self.name, self.prefix, self.suffix, self.flags)\n\n    def __eq__(self, other):\n        if not isinstance(other, ExportEntry):\n            result = False\n        else:\n            result = (self.name == other.name and self.prefix == other.prefix and self.suffix == other.suffix and\n                      self.flags == other.flags)\n        return result\n\n    __hash__ = object.__hash__\n\n\nENTRY_RE = re.compile(\n    r'''(?P<name>([^\\[]\\S*))\n                      \\s*=\\s*(?P<callable>(\\w+)([:\\.]\\w+)*)\n                      \\s*(\\[\\s*(?P<flags>[\\w-]+(=\\w+)?(,\\s*\\w+(=\\w+)?)*)\\s*\\])?\n                      ''', re.VERBOSE)\n\n\ndef get_export_entry(specification):\n    m = ENTRY_RE.search(specification)\n    if not m:\n        result = None\n        if '[' in specification or ']' in specification:\n            raise DistlibException(\"Invalid specification \"\n                                   \"'%s'\" % specification)\n    else:\n        d = m.groupdict()\n        name = d['name']\n        path = d['callable']\n        colons = path.count(':')\n        if colons == 0:\n            prefix, suffix = path, None\n        else:\n            if colons != 1:\n                raise DistlibException(\"Invalid specification \"\n                                       \"'%s'\" % specification)\n            prefix, suffix = path.split(':')\n        flags = d['flags']\n        if flags is None:\n            if '[' in specification or ']' in specification:\n                raise DistlibException(\"Invalid specification \"\n                                       \"'%s'\" % specification)\n            flags = []\n        else:\n            flags = [f.strip() for f in flags.split(',')]\n        result = ExportEntry(name, prefix, suffix, flags)\n    return result\n\n\ndef get_cache_base(suffix=None):\n    \"\"\"\n    Return the default base location for distlib caches. If the directory does\n    not exist, it is created. Use the suffix provided for the base directory,\n    and default to '.distlib' if it isn't provided.\n\n    On Windows, if LOCALAPPDATA is defined in the environment, then it is\n    assumed to be a directory, and will be the parent directory of the result.\n    On POSIX, and on Windows if LOCALAPPDATA is not defined, the user's home\n    directory - using os.expanduser('~') - will be the parent directory of\n    the result.\n\n    The result is just the directory '.distlib' in the parent directory as\n    determined above, or with the name specified with ``suffix``.\n    \"\"\"\n    if suffix is None:\n        suffix = '.distlib'\n    if os.name == 'nt' and 'LOCALAPPDATA' in os.environ:\n        result = os.path.expandvars('$localappdata')\n    else:\n        # Assume posix, or old Windows\n        result = os.path.expanduser('~')\n    # we use 'isdir' instead of 'exists', because we want to\n    # fail if there's a file with that name\n    if os.path.isdir(result):\n        usable = os.access(result, os.W_OK)\n        if not usable:\n            logger.warning('Directory exists but is not writable: %s', result)\n    else:\n        try:\n            os.makedirs(result)\n            usable = True\n        except OSError:\n            logger.warning('Unable to create %s', result, exc_info=True)\n            usable = False\n    if not usable:\n        result = tempfile.mkdtemp()\n        logger.warning('Default location unusable, using %s', result)\n    return os.path.join(result, suffix)\n\n\ndef path_to_cache_dir(path):\n    \"\"\"\n    Convert an absolute path to a directory name for use in a cache.\n\n    The algorithm used is:\n\n    #. On Windows, any ``':'`` in the drive is replaced with ``'---'``.\n    #. Any occurrence of ``os.sep`` is replaced with ``'--'``.\n    #. ``'.cache'`` is appended.\n    \"\"\"\n    d, p = os.path.splitdrive(os.path.abspath(path))\n    if d:\n        d = d.replace(':', '---')\n    p = p.replace(os.sep, '--')\n    return d + p + '.cache'\n\n\ndef ensure_slash(s):\n    if not s.endswith('/'):\n        return s + '/'\n    return s\n\n\ndef parse_credentials(netloc):\n    username = password = None\n    if '@' in netloc:\n        prefix, netloc = netloc.rsplit('@', 1)\n        if ':' not in prefix:\n            username = prefix\n        else:\n            username, password = prefix.split(':', 1)\n    if username:\n        username = unquote(username)\n    if password:\n        password = unquote(password)\n    return username, password, netloc\n\n\ndef get_process_umask():\n    result = os.umask(0o22)\n    os.umask(result)\n    return result\n\n\ndef is_string_sequence(seq):\n    result = True\n    i = None\n    for i, s in enumerate(seq):\n        if not isinstance(s, string_types):\n            result = False\n            break\n    assert i is not None\n    return result\n\n\nPROJECT_NAME_AND_VERSION = re.compile('([a-z0-9_]+([.-][a-z_][a-z0-9_]*)*)-'\n                                      '([a-z0-9_.+-]+)', re.I)\nPYTHON_VERSION = re.compile(r'-py(\\d\\.?\\d?)')\n\n\ndef split_filename(filename, project_name=None):\n    \"\"\"\n    Extract name, version, python version from a filename (no extension)\n\n    Return name, version, pyver or None\n    \"\"\"\n    result = None\n    pyver = None\n    filename = unquote(filename).replace(' ', '-')\n    m = PYTHON_VERSION.search(filename)\n    if m:\n        pyver = m.group(1)\n        filename = filename[:m.start()]\n    if project_name and len(filename) > len(project_name) + 1:\n        m = re.match(re.escape(project_name) + r'\\b', filename)\n        if m:\n            n = m.end()\n            result = filename[:n], filename[n + 1:], pyver\n    if result is None:\n        m = PROJECT_NAME_AND_VERSION.match(filename)\n        if m:\n            result = m.group(1), m.group(3), pyver\n    return result\n\n\n# Allow spaces in name because of legacy dists like \"Twisted Core\"\nNAME_VERSION_RE = re.compile(r'(?P<name>[\\w .-]+)\\s*'\n                             r'\\(\\s*(?P<ver>[^\\s)]+)\\)$')\n\n\ndef parse_name_and_version(p):\n    \"\"\"\n    A utility method used to get name and version from a string.\n\n    From e.g. a Provides-Dist value.\n\n    :param p: A value in a form 'foo (1.0)'\n    :return: The name and version as a tuple.\n    \"\"\"\n    m = NAME_VERSION_RE.match(p)\n    if not m:\n        raise DistlibException('Ill-formed name/version string: \\'%s\\'' % p)\n    d = m.groupdict()\n    return d['name'].strip().lower(), d['ver']\n\n\ndef get_extras(requested, available):\n    result = set()\n    requested = set(requested or [])\n    available = set(available or [])\n    if '*' in requested:\n        requested.remove('*')\n        result |= available\n    for r in requested:\n        if r == '-':\n            result.add(r)\n        elif r.startswith('-'):\n            unwanted = r[1:]\n            if unwanted not in available:\n                logger.warning('undeclared extra: %s' % unwanted)\n            if unwanted in result:\n                result.remove(unwanted)\n        else:\n            if r not in available:\n                logger.warning('undeclared extra: %s' % r)\n            result.add(r)\n    return result\n\n\n#\n# Extended metadata functionality\n#\n\n\ndef _get_external_data(url):\n    result = {}\n    try:\n        # urlopen might fail if it runs into redirections,\n        # because of Python issue #13696. Fixed in locators\n        # using a custom redirect handler.\n        resp = urlopen(url)\n        headers = resp.info()\n        ct = headers.get('Content-Type')\n        if not ct.startswith('application/json'):\n            logger.debug('Unexpected response for JSON request: %s', ct)\n        else:\n            reader = codecs.getreader('utf-8')(resp)\n            # data = reader.read().decode('utf-8')\n            # result = json.loads(data)\n            result = json.load(reader)\n    except Exception as e:\n        logger.exception('Failed to get external data for %s: %s', url, e)\n    return result\n\n\n_external_data_base_url = 'https://www.red-dove.com/pypi/projects/'\n\n\ndef get_project_data(name):\n    url = '%s/%s/project.json' % (name[0].upper(), name)\n    url = urljoin(_external_data_base_url, url)\n    result = _get_external_data(url)\n    return result\n\n\ndef get_package_data(name, version):\n    url = '%s/%s/package-%s.json' % (name[0].upper(), name, version)\n    url = urljoin(_external_data_base_url, url)\n    return _get_external_data(url)\n\n\nclass Cache(object):\n    \"\"\"\n    A class implementing a cache for resources that need to live in the file system\n    e.g. shared libraries. This class was moved from resources to here because it\n    could be used by other modules, e.g. the wheel module.\n    \"\"\"\n\n    def __init__(self, base):\n        \"\"\"\n        Initialise an instance.\n\n        :param base: The base directory where the cache should be located.\n        \"\"\"\n        # we use 'isdir' instead of 'exists', because we want to\n        # fail if there's a file with that name\n        if not os.path.isdir(base):  # pragma: no cover\n            os.makedirs(base)\n        if (os.stat(base).st_mode & 0o77) != 0:\n            logger.warning('Directory \\'%s\\' is not private', base)\n        self.base = os.path.abspath(os.path.normpath(base))\n\n    def prefix_to_dir(self, prefix):\n        \"\"\"\n        Converts a resource prefix to a directory name in the cache.\n        \"\"\"\n        return path_to_cache_dir(prefix)\n\n    def clear(self):\n        \"\"\"\n        Clear the cache.\n        \"\"\"\n        not_removed = []\n        for fn in os.listdir(self.base):\n            fn = os.path.join(self.base, fn)\n            try:\n                if os.path.islink(fn) or os.path.isfile(fn):\n                    os.remove(fn)\n                elif os.path.isdir(fn):\n                    shutil.rmtree(fn)\n            except Exception:\n                not_removed.append(fn)\n        return not_removed\n\n\nclass EventMixin(object):\n    \"\"\"\n    A very simple publish/subscribe system.\n    \"\"\"\n\n    def __init__(self):\n        self._subscribers = {}\n\n    def add(self, event, subscriber, append=True):\n        \"\"\"\n        Add a subscriber for an event.\n\n        :param event: The name of an event.\n        :param subscriber: The subscriber to be added (and called when the\n                           event is published).\n        :param append: Whether to append or prepend the subscriber to an\n                       existing subscriber list for the event.\n        \"\"\"\n        subs = self._subscribers\n        if event not in subs:\n            subs[event] = deque([subscriber])\n        else:\n            sq = subs[event]\n            if append:\n                sq.append(subscriber)\n            else:\n                sq.appendleft(subscriber)\n\n    def remove(self, event, subscriber):\n        \"\"\"\n        Remove a subscriber for an event.\n\n        :param event: The name of an event.\n        :param subscriber: The subscriber to be removed.\n        \"\"\"\n        subs = self._subscribers\n        if event not in subs:\n            raise ValueError('No subscribers: %r' % event)\n        subs[event].remove(subscriber)\n\n    def get_subscribers(self, event):\n        \"\"\"\n        Return an iterator for the subscribers for an event.\n        :param event: The event to return subscribers for.\n        \"\"\"\n        return iter(self._subscribers.get(event, ()))\n\n    def publish(self, event, *args, **kwargs):\n        \"\"\"\n        Publish a event and return a list of values returned by its\n        subscribers.\n\n        :param event: The event to publish.\n        :param args: The positional arguments to pass to the event's\n                     subscribers.\n        :param kwargs: The keyword arguments to pass to the event's\n                       subscribers.\n        \"\"\"\n        result = []\n        for subscriber in self.get_subscribers(event):\n            try:\n                value = subscriber(event, *args, **kwargs)\n            except Exception:\n                logger.exception('Exception during event publication')\n                value = None\n            result.append(value)\n        logger.debug('publish %s: args = %s, kwargs = %s, result = %s', event, args, kwargs, result)\n        return result\n\n\n#\n# Simple sequencing\n#\nclass Sequencer(object):\n\n    def __init__(self):\n        self._preds = {}\n        self._succs = {}\n        self._nodes = set()  # nodes with no preds/succs\n\n    def add_node(self, node):\n        self._nodes.add(node)\n\n    def remove_node(self, node, edges=False):\n        if node in self._nodes:\n            self._nodes.remove(node)\n        if edges:\n            for p in set(self._preds.get(node, ())):\n                self.remove(p, node)\n            for s in set(self._succs.get(node, ())):\n                self.remove(node, s)\n            # Remove empties\n            for k, v in list(self._preds.items()):\n                if not v:\n                    del self._preds[k]\n            for k, v in list(self._succs.items()):\n                if not v:\n                    del self._succs[k]\n\n    def add(self, pred, succ):\n        assert pred != succ\n        self._preds.setdefault(succ, set()).add(pred)\n        self._succs.setdefault(pred, set()).add(succ)\n\n    def remove(self, pred, succ):\n        assert pred != succ\n        try:\n            preds = self._preds[succ]\n            succs = self._succs[pred]\n        except KeyError:  # pragma: no cover\n            raise ValueError('%r not a successor of anything' % succ)\n        try:\n            preds.remove(pred)\n            succs.remove(succ)\n        except KeyError:  # pragma: no cover\n            raise ValueError('%r not a successor of %r' % (succ, pred))\n\n    def is_step(self, step):\n        return (step in self._preds or step in self._succs or step in self._nodes)\n\n    def get_steps(self, final):\n        if not self.is_step(final):\n            raise ValueError('Unknown: %r' % final)\n        result = []\n        todo = []\n        seen = set()\n        todo.append(final)\n        while todo:\n            step = todo.pop(0)\n            if step in seen:\n                # if a step was already seen,\n                # move it to the end (so it will appear earlier\n                # when reversed on return) ... but not for the\n                # final step, as that would be confusing for\n                # users\n                if step != final:\n                    result.remove(step)\n                    result.append(step)\n            else:\n                seen.add(step)\n                result.append(step)\n                preds = self._preds.get(step, ())\n                todo.extend(preds)\n        return reversed(result)\n\n    @property\n    def strong_connections(self):\n        # http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n        index_counter = [0]\n        stack = []\n        lowlinks = {}\n        index = {}\n        result = []\n\n        graph = self._succs\n\n        def strongconnect(node):\n            # set the depth index for this node to the smallest unused index\n            index[node] = index_counter[0]\n            lowlinks[node] = index_counter[0]\n            index_counter[0] += 1\n            stack.append(node)\n\n            # Consider successors\n            try:\n                successors = graph[node]\n            except Exception:\n                successors = []\n            for successor in successors:\n                if successor not in lowlinks:\n                    # Successor has not yet been visited\n                    strongconnect(successor)\n                    lowlinks[node] = min(lowlinks[node], lowlinks[successor])\n                elif successor in stack:\n                    # the successor is in the stack and hence in the current\n                    # strongly connected component (SCC)\n                    lowlinks[node] = min(lowlinks[node], index[successor])\n\n            # If `node` is a root node, pop the stack and generate an SCC\n            if lowlinks[node] == index[node]:\n                connected_component = []\n\n                while True:\n                    successor = stack.pop()\n                    connected_component.append(successor)\n                    if successor == node:\n                        break\n                component = tuple(connected_component)\n                # storing the result\n                result.append(component)\n\n        for node in graph:\n            if node not in lowlinks:\n                strongconnect(node)\n\n        return result\n\n    @property\n    def dot(self):\n        result = ['digraph G {']\n        for succ in self._preds:\n            preds = self._preds[succ]\n            for pred in preds:\n                result.append('  %s -> %s;' % (pred, succ))\n        for node in self._nodes:\n            result.append('  %s;' % node)\n        result.append('}')\n        return '\\n'.join(result)\n\n\n#\n# Unarchiving functionality for zip, tar, tgz, tbz, whl\n#\n\nARCHIVE_EXTENSIONS = ('.tar.gz', '.tar.bz2', '.tar', '.zip', '.tgz', '.tbz', '.whl')\n\n\ndef unarchive(archive_filename, dest_dir, format=None, check=True):\n\n    def check_path(path):\n        if not isinstance(path, text_type):\n            path = path.decode('utf-8')\n        p = os.path.abspath(os.path.join(dest_dir, path))\n        if not p.startswith(dest_dir) or p[plen] != os.sep:\n            raise ValueError('path outside destination: %r' % p)\n\n    dest_dir = os.path.abspath(dest_dir)\n    plen = len(dest_dir)\n    archive = None\n    if format is None:\n        if archive_filename.endswith(('.zip', '.whl')):\n            format = 'zip'\n        elif archive_filename.endswith(('.tar.gz', '.tgz')):\n            format = 'tgz'\n            mode = 'r:gz'\n        elif archive_filename.endswith(('.tar.bz2', '.tbz')):\n            format = 'tbz'\n            mode = 'r:bz2'\n        elif archive_filename.endswith('.tar'):\n            format = 'tar'\n            mode = 'r'\n        else:  # pragma: no cover\n            raise ValueError('Unknown format for %r' % archive_filename)\n    try:\n        if format == 'zip':\n            archive = ZipFile(archive_filename, 'r')\n            if check:\n                names = archive.namelist()\n                for name in names:\n                    check_path(name)\n        else:\n            archive = tarfile.open(archive_filename, mode)\n            if check:\n                names = archive.getnames()\n                for name in names:\n                    check_path(name)\n        if format != 'zip' and sys.version_info[0] < 3:\n            # See Python issue 17153. If the dest path contains Unicode,\n            # tarfile extraction fails on Python 2.x if a member path name\n            # contains non-ASCII characters - it leads to an implicit\n            # bytes -> unicode conversion using ASCII to decode.\n            for tarinfo in archive.getmembers():\n                if not isinstance(tarinfo.name, text_type):\n                    tarinfo.name = tarinfo.name.decode('utf-8')\n\n        # Limit extraction of dangerous items, if this Python\n        # allows it easily. If not, just trust the input.\n        # See: https://docs.python.org/3/library/tarfile.html#extraction-filters\n        def extraction_filter(member, path):\n            \"\"\"Run tarfile.tar_filter, but raise the expected ValueError\"\"\"\n            # This is only called if the current Python has tarfile filters\n            try:\n                return tarfile.tar_filter(member, path)\n            except tarfile.FilterError as exc:\n                raise ValueError(str(exc))\n\n        archive.extraction_filter = extraction_filter\n\n        archive.extractall(dest_dir)\n\n    finally:\n        if archive:\n            archive.close()\n\n\ndef zip_dir(directory):\n    \"\"\"zip a directory tree into a BytesIO object\"\"\"\n    result = io.BytesIO()\n    dlen = len(directory)\n    with ZipFile(result, \"w\") as zf:\n        for root, dirs, files in os.walk(directory):\n            for name in files:\n                full = os.path.join(root, name)\n                rel = root[dlen:]\n                dest = os.path.join(rel, name)\n                zf.write(full, dest)\n    return result\n\n\n#\n# Simple progress bar\n#\n\nUNITS = ('', 'K', 'M', 'G', 'T', 'P')\n\n\nclass Progress(object):\n    unknown = 'UNKNOWN'\n\n    def __init__(self, minval=0, maxval=100):\n        assert maxval is None or maxval >= minval\n        self.min = self.cur = minval\n        self.max = maxval\n        self.started = None\n        self.elapsed = 0\n        self.done = False\n\n    def update(self, curval):\n        assert self.min <= curval\n        assert self.max is None or curval <= self.max\n        self.cur = curval\n        now = time.time()\n        if self.started is None:\n            self.started = now\n        else:\n            self.elapsed = now - self.started\n\n    def increment(self, incr):\n        assert incr >= 0\n        self.update(self.cur + incr)\n\n    def start(self):\n        self.update(self.min)\n        return self\n\n    def stop(self):\n        if self.max is not None:\n            self.update(self.max)\n        self.done = True\n\n    @property\n    def maximum(self):\n        return self.unknown if self.max is None else self.max\n\n    @property\n    def percentage(self):\n        if self.done:\n            result = '100 %'\n        elif self.max is None:\n            result = ' ?? %'\n        else:\n            v = 100.0 * (self.cur - self.min) / (self.max - self.min)\n            result = '%3d %%' % v\n        return result\n\n    def format_duration(self, duration):\n        if (duration <= 0) and self.max is None or self.cur == self.min:\n            result = '??:??:??'\n        # elif duration < 1:\n        #     result = '--:--:--'\n        else:\n            result = time.strftime('%H:%M:%S', time.gmtime(duration))\n        return result\n\n    @property\n    def ETA(self):\n        if self.done:\n            prefix = 'Done'\n            t = self.elapsed\n            # import pdb; pdb.set_trace()\n        else:\n            prefix = 'ETA '\n            if self.max is None:\n                t = -1\n            elif self.elapsed == 0 or (self.cur == self.min):\n                t = 0\n            else:\n                # import pdb; pdb.set_trace()\n                t = float(self.max - self.min)\n                t /= self.cur - self.min\n                t = (t - 1) * self.elapsed\n        return '%s: %s' % (prefix, self.format_duration(t))\n\n    @property\n    def speed(self):\n        if self.elapsed == 0:\n            result = 0.0\n        else:\n            result = (self.cur - self.min) / self.elapsed\n        for unit in UNITS:\n            if result < 1000:\n                break\n            result /= 1000.0\n        return '%d %sB/s' % (result, unit)\n\n\n#\n# Glob functionality\n#\n\nRICH_GLOB = re.compile(r'\\{([^}]*)\\}')\n_CHECK_RECURSIVE_GLOB = re.compile(r'[^/\\\\,{]\\*\\*|\\*\\*[^/\\\\,}]')\n_CHECK_MISMATCH_SET = re.compile(r'^[^{]*\\}|\\{[^}]*$')\n\n\ndef iglob(path_glob):\n    \"\"\"Extended globbing function that supports ** and {opt1,opt2,opt3}.\"\"\"\n    if _CHECK_RECURSIVE_GLOB.search(path_glob):\n        msg = \"\"\"invalid glob %r: recursive glob \"**\" must be used alone\"\"\"\n        raise ValueError(msg % path_glob)\n    if _CHECK_MISMATCH_SET.search(path_glob):\n        msg = \"\"\"invalid glob %r: mismatching set marker '{' or '}'\"\"\"\n        raise ValueError(msg % path_glob)\n    return _iglob(path_glob)\n\n\ndef _iglob(path_glob):\n    rich_path_glob = RICH_GLOB.split(path_glob, 1)\n    if len(rich_path_glob) > 1:\n        assert len(rich_path_glob) == 3, rich_path_glob\n        prefix, set, suffix = rich_path_glob\n        for item in set.split(','):\n            for path in _iglob(''.join((prefix, item, suffix))):\n                yield path\n    else:\n        if '**' not in path_glob:\n            for item in std_iglob(path_glob):\n                yield item\n        else:\n            prefix, radical = path_glob.split('**', 1)\n            if prefix == '':\n                prefix = '.'\n            if radical == '':\n                radical = '*'\n            else:\n                # we support both\n                radical = radical.lstrip('/')\n                radical = radical.lstrip('\\\\')\n            for path, dir, files in os.walk(prefix):\n                path = os.path.normpath(path)\n                for fn in _iglob(os.path.join(path, radical)):\n                    yield fn\n\n\nif ssl:\n    from .compat import (HTTPSHandler as BaseHTTPSHandler, match_hostname, CertificateError)\n\n    #\n    # HTTPSConnection which verifies certificates/matches domains\n    #\n\n    class HTTPSConnection(httplib.HTTPSConnection):\n        ca_certs = None  # set this to the path to the certs file (.pem)\n        check_domain = True  # only used if ca_certs is not None\n\n        # noinspection PyPropertyAccess\n        def connect(self):\n            sock = socket.create_connection((self.host, self.port), self.timeout)\n            if getattr(self, '_tunnel_host', False):\n                self.sock = sock\n                self._tunnel()\n\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            if hasattr(ssl, 'OP_NO_SSLv2'):\n                context.options |= ssl.OP_NO_SSLv2\n            if getattr(self, 'cert_file', None):\n                context.load_cert_chain(self.cert_file, self.key_file)\n            kwargs = {}\n            if self.ca_certs:\n                context.verify_mode = ssl.CERT_REQUIRED\n                context.load_verify_locations(cafile=self.ca_certs)\n                if getattr(ssl, 'HAS_SNI', False):\n                    kwargs['server_hostname'] = self.host\n\n            self.sock = context.wrap_socket(sock, **kwargs)\n            if self.ca_certs and self.check_domain:\n                try:\n                    match_hostname(self.sock.getpeercert(), self.host)\n                    logger.debug('Host verified: %s', self.host)\n                except CertificateError:  # pragma: no cover\n                    self.sock.shutdown(socket.SHUT_RDWR)\n                    self.sock.close()\n                    raise\n\n    class HTTPSHandler(BaseHTTPSHandler):\n\n        def __init__(self, ca_certs, check_domain=True):\n            BaseHTTPSHandler.__init__(self)\n            self.ca_certs = ca_certs\n            self.check_domain = check_domain\n\n        def _conn_maker(self, *args, **kwargs):\n            \"\"\"\n            This is called to create a connection instance. Normally you'd\n            pass a connection class to do_open, but it doesn't actually check for\n            a class, and just expects a callable. As long as we behave just as a\n            constructor would have, we should be OK. If it ever changes so that\n            we *must* pass a class, we'll create an UnsafeHTTPSConnection class\n            which just sets check_domain to False in the class definition, and\n            choose which one to pass to do_open.\n            \"\"\"\n            result = HTTPSConnection(*args, **kwargs)\n            if self.ca_certs:\n                result.ca_certs = self.ca_certs\n                result.check_domain = self.check_domain\n            return result\n\n        def https_open(self, req):\n            try:\n                return self.do_open(self._conn_maker, req)\n            except URLError as e:\n                if 'certificate verify failed' in str(e.reason):\n                    raise CertificateError('Unable to verify server certificate '\n                                           'for %s' % req.host)\n                else:\n                    raise\n\n    #\n    # To prevent against mixing HTTP traffic with HTTPS (examples: A Man-In-The-\n    # Middle proxy using HTTP listens on port 443, or an index mistakenly serves\n    # HTML containing a http://xyz link when it should be https://xyz),\n    # you can use the following handler class, which does not allow HTTP traffic.\n    #\n    # It works by inheriting from HTTPHandler - so build_opener won't add a\n    # handler for HTTP itself.\n    #\n    class HTTPSOnlyHandler(HTTPSHandler, HTTPHandler):\n\n        def http_open(self, req):\n            raise URLError('Unexpected HTTP request on what should be a secure '\n                           'connection: %s' % req)\n\n\n#\n# XML-RPC with timeouts\n#\nclass Transport(xmlrpclib.Transport):\n\n    def __init__(self, timeout, use_datetime=0):\n        self.timeout = timeout\n        xmlrpclib.Transport.__init__(self, use_datetime)\n\n    def make_connection(self, host):\n        h, eh, x509 = self.get_host_info(host)\n        if not self._connection or host != self._connection[0]:\n            self._extra_headers = eh\n            self._connection = host, httplib.HTTPConnection(h)\n        return self._connection[1]\n\n\nif ssl:\n\n    class SafeTransport(xmlrpclib.SafeTransport):\n\n        def __init__(self, timeout, use_datetime=0):\n            self.timeout = timeout\n            xmlrpclib.SafeTransport.__init__(self, use_datetime)\n\n        def make_connection(self, host):\n            h, eh, kwargs = self.get_host_info(host)\n            if not kwargs:\n                kwargs = {}\n            kwargs['timeout'] = self.timeout\n            if not self._connection or host != self._connection[0]:\n                self._extra_headers = eh\n                self._connection = host, httplib.HTTPSConnection(h, None, **kwargs)\n            return self._connection[1]\n\n\nclass ServerProxy(xmlrpclib.ServerProxy):\n\n    def __init__(self, uri, **kwargs):\n        self.timeout = timeout = kwargs.pop('timeout', None)\n        # The above classes only come into play if a timeout\n        # is specified\n        if timeout is not None:\n            # scheme = splittype(uri)  # deprecated as of Python 3.8\n            scheme = urlparse(uri)[0]\n            use_datetime = kwargs.get('use_datetime', 0)\n            if scheme == 'https':\n                tcls = SafeTransport\n            else:\n                tcls = Transport\n            kwargs['transport'] = t = tcls(timeout, use_datetime=use_datetime)\n            self.transport = t\n        xmlrpclib.ServerProxy.__init__(self, uri, **kwargs)\n\n\n#\n# CSV functionality. This is provided because on 2.x, the csv module can't\n# handle Unicode. However, we need to deal with Unicode in e.g. RECORD files.\n#\n\n\ndef _csv_open(fn, mode, **kwargs):\n    if sys.version_info[0] < 3:\n        mode += 'b'\n    else:\n        kwargs['newline'] = ''\n        # Python 3 determines encoding from locale. Force 'utf-8'\n        # file encoding to match other forced utf-8 encoding\n        kwargs['encoding'] = 'utf-8'\n    return open(fn, mode, **kwargs)\n\n\nclass CSVBase(object):\n    defaults = {\n        'delimiter': str(','),  # The strs are used because we need native\n        'quotechar': str('\"'),  # str in the csv API (2.x won't take\n        'lineterminator': str('\\n')  # Unicode)\n    }\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc_info):\n        self.stream.close()\n\n\nclass CSVReader(CSVBase):\n\n    def __init__(self, **kwargs):\n        if 'stream' in kwargs:\n            stream = kwargs['stream']\n            if sys.version_info[0] >= 3:\n                # needs to be a text stream\n                stream = codecs.getreader('utf-8')(stream)\n            self.stream = stream\n        else:\n            self.stream = _csv_open(kwargs['path'], 'r')\n        self.reader = csv.reader(self.stream, **self.defaults)\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        result = next(self.reader)\n        if sys.version_info[0] < 3:\n            for i, item in enumerate(result):\n                if not isinstance(item, text_type):\n                    result[i] = item.decode('utf-8')\n        return result\n\n    __next__ = next\n\n\nclass CSVWriter(CSVBase):\n\n    def __init__(self, fn, **kwargs):\n        self.stream = _csv_open(fn, 'w')\n        self.writer = csv.writer(self.stream, **self.defaults)\n\n    def writerow(self, row):\n        if sys.version_info[0] < 3:\n            r = []\n            for item in row:\n                if isinstance(item, text_type):\n                    item = item.encode('utf-8')\n                r.append(item)\n            row = r\n        self.writer.writerow(row)\n\n\n#\n#   Configurator functionality\n#\n\n\nclass Configurator(BaseConfigurator):\n\n    value_converters = dict(BaseConfigurator.value_converters)\n    value_converters['inc'] = 'inc_convert'\n\n    def __init__(self, config, base=None):\n        super(Configurator, self).__init__(config)\n        self.base = base or os.getcwd()\n\n    def configure_custom(self, config):\n\n        def convert(o):\n            if isinstance(o, (list, tuple)):\n                result = type(o)([convert(i) for i in o])\n            elif isinstance(o, dict):\n                if '()' in o:\n                    result = self.configure_custom(o)\n                else:\n                    result = {}\n                    for k in o:\n                        result[k] = convert(o[k])\n            else:\n                result = self.convert(o)\n            return result\n\n        c = config.pop('()')\n        if not callable(c):\n            c = self.resolve(c)\n        props = config.pop('.', None)\n        # Check for valid identifiers\n        args = config.pop('[]', ())\n        if args:\n            args = tuple([convert(o) for o in args])\n        items = [(k, convert(config[k])) for k in config if valid_ident(k)]\n        kwargs = dict(items)\n        result = c(*args, **kwargs)\n        if props:\n            for n, v in props.items():\n                setattr(result, n, convert(v))\n        return result\n\n    def __getitem__(self, key):\n        result = self.config[key]\n        if isinstance(result, dict) and '()' in result:\n            self.config[key] = result = self.configure_custom(result)\n        return result\n\n    def inc_convert(self, value):\n        \"\"\"Default converter for the inc:// protocol.\"\"\"\n        if not os.path.isabs(value):\n            value = os.path.join(self.base, value)\n        with codecs.open(value, 'r', encoding='utf-8') as f:\n            result = json.load(f)\n        return result\n\n\nclass SubprocessMixin(object):\n    \"\"\"\n    Mixin for running subprocesses and capturing their output\n    \"\"\"\n\n    def __init__(self, verbose=False, progress=None):\n        self.verbose = verbose\n        self.progress = progress\n\n    def reader(self, stream, context):\n        \"\"\"\n        Read lines from a subprocess' output stream and either pass to a progress\n        callable (if specified) or write progress information to sys.stderr.\n        \"\"\"\n        progress = self.progress\n        verbose = self.verbose\n        while True:\n            s = stream.readline()\n            if not s:\n                break\n            if progress is not None:\n                progress(s, context)\n            else:\n                if not verbose:\n                    sys.stderr.write('.')\n                else:\n                    sys.stderr.write(s.decode('utf-8'))\n                sys.stderr.flush()\n        stream.close()\n\n    def run_command(self, cmd, **kwargs):\n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)\n        t1 = threading.Thread(target=self.reader, args=(p.stdout, 'stdout'))\n        t1.start()\n        t2 = threading.Thread(target=self.reader, args=(p.stderr, 'stderr'))\n        t2.start()\n        p.wait()\n        t1.join()\n        t2.join()\n        if self.progress is not None:\n            self.progress('done.', 'main')\n        elif self.verbose:\n            sys.stderr.write('done.\\n')\n        return p\n\n\ndef normalize_name(name):\n    \"\"\"Normalize a python package name a la PEP 503\"\"\"\n    # https://www.python.org/dev/peps/pep-0503/#normalized-names\n    return re.sub('[-_.]+', '-', name).lower()\n\n\n# def _get_pypirc_command():\n# \"\"\"\n# Get the distutils command for interacting with PyPI configurations.\n# :return: the command.\n# \"\"\"\n# from distutils.core import Distribution\n# from distutils.config import PyPIRCCommand\n# d = Distribution()\n# return PyPIRCCommand(d)\n\n\nclass PyPIRCFile(object):\n\n    DEFAULT_REPOSITORY = 'https://upload.pypi.org/legacy/'\n    DEFAULT_REALM = 'pypi'\n\n    def __init__(self, fn=None, url=None):\n        if fn is None:\n            fn = os.path.join(os.path.expanduser('~'), '.pypirc')\n        self.filename = fn\n        self.url = url\n\n    def read(self):\n        result = {}\n\n        if os.path.exists(self.filename):\n            repository = self.url or self.DEFAULT_REPOSITORY\n\n            config = configparser.RawConfigParser()\n            config.read(self.filename)\n            sections = config.sections()\n            if 'distutils' in sections:\n                # let's get the list of servers\n                index_servers = config.get('distutils', 'index-servers')\n                _servers = [server.strip() for server in index_servers.split('\\n') if server.strip() != '']\n                if _servers == []:\n                    # nothing set, let's try to get the default pypi\n                    if 'pypi' in sections:\n                        _servers = ['pypi']\n                else:\n                    for server in _servers:\n                        result = {'server': server}\n                        result['username'] = config.get(server, 'username')\n\n                        # optional params\n                        for key, default in (('repository', self.DEFAULT_REPOSITORY), ('realm', self.DEFAULT_REALM),\n                                             ('password', None)):\n                            if config.has_option(server, key):\n                                result[key] = config.get(server, key)\n                            else:\n                                result[key] = default\n\n                        # work around people having \"repository\" for the \"pypi\"\n                        # section of their config set to the HTTP (rather than\n                        # HTTPS) URL\n                        if (server == 'pypi' and repository in (self.DEFAULT_REPOSITORY, 'pypi')):\n                            result['repository'] = self.DEFAULT_REPOSITORY\n                        elif (result['server'] != repository and result['repository'] != repository):\n                            result = {}\n            elif 'server-login' in sections:\n                # old format\n                server = 'server-login'\n                if config.has_option(server, 'repository'):\n                    repository = config.get(server, 'repository')\n                else:\n                    repository = self.DEFAULT_REPOSITORY\n                result = {\n                    'username': config.get(server, 'username'),\n                    'password': config.get(server, 'password'),\n                    'repository': repository,\n                    'server': server,\n                    'realm': self.DEFAULT_REALM\n                }\n        return result\n\n    def update(self, username, password):\n        # import pdb; pdb.set_trace()\n        config = configparser.RawConfigParser()\n        fn = self.filename\n        config.read(fn)\n        if not config.has_section('pypi'):\n            config.add_section('pypi')\n        config.set('pypi', 'username', username)\n        config.set('pypi', 'password', password)\n        with open(fn, 'w') as f:\n            config.write(f)\n\n\ndef _load_pypirc(index):\n    \"\"\"\n    Read the PyPI access configuration as supported by distutils.\n    \"\"\"\n    return PyPIRCFile(url=index.url).read()\n\n\ndef _store_pypirc(index):\n    PyPIRCFile().update(index.username, index.password)\n\n\n#\n# get_platform()/get_host_platform() copied from Python 3.10.a0 source, with some minor\n# tweaks\n#\n\n\ndef get_host_platform():\n    \"\"\"Return a string that identifies the current platform.  This is used mainly to\n    distinguish platform-specific build directories and platform-specific built\n    distributions.  Typically includes the OS name and version and the\n    architecture (as supplied by 'os.uname()'), although the exact information\n    included depends on the OS; eg. on Linux, the kernel version isn't\n    particularly important.\n\n    Examples of returned values:\n       linux-i586\n       linux-alpha (?)\n       solaris-2.6-sun4u\n\n    Windows will return one of:\n       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n       win32 (all others - specifically, sys.platform is returned)\n\n    For other non-POSIX platforms, currently just returns 'sys.platform'.\n\n    \"\"\"\n    if os.name == 'nt':\n        if 'amd64' in sys.version.lower():\n            return 'win-amd64'\n        if '(arm)' in sys.version.lower():\n            return 'win-arm32'\n        if '(arm64)' in sys.version.lower():\n            return 'win-arm64'\n        return sys.platform\n\n    # Set for cross builds explicitly\n    if \"_PYTHON_HOST_PLATFORM\" in os.environ:\n        return os.environ[\"_PYTHON_HOST_PLATFORM\"]\n\n    if os.name != 'posix' or not hasattr(os, 'uname'):\n        # XXX what about the architecture? NT is Intel or Alpha,\n        # Mac OS is M68k or PPC, etc.\n        return sys.platform\n\n    # Try to distinguish various flavours of Unix\n\n    (osname, host, release, version, machine) = os.uname()\n\n    # Convert the OS name to lowercase, remove '/' characters, and translate\n    # spaces (for \"Power Macintosh\")\n    osname = osname.lower().replace('/', '')\n    machine = machine.replace(' ', '_').replace('/', '-')\n\n    if osname[:5] == 'linux':\n        # At least on Linux/Intel, 'machine' is the processor --\n        # i386, etc.\n        # XXX what about Alpha, SPARC, etc?\n        return \"%s-%s\" % (osname, machine)\n\n    elif osname[:5] == 'sunos':\n        if release[0] >= '5':  # SunOS 5 == Solaris 2\n            osname = 'solaris'\n            release = '%d.%s' % (int(release[0]) - 3, release[2:])\n            # We can't use 'platform.architecture()[0]' because a\n            # bootstrap problem. We use a dict to get an error\n            # if some suspicious happens.\n            bitness = {2147483647: '32bit', 9223372036854775807: '64bit'}\n            machine += '.%s' % bitness[sys.maxsize]\n        # fall through to standard osname-release-machine representation\n    elif osname[:3] == 'aix':\n        from _aix_support import aix_platform\n        return aix_platform()\n    elif osname[:6] == 'cygwin':\n        osname = 'cygwin'\n        rel_re = re.compile(r'[\\d.]+', re.ASCII)\n        m = rel_re.match(release)\n        if m:\n            release = m.group()\n    elif osname[:6] == 'darwin':\n        import _osx_support\n        try:\n            from distutils import sysconfig\n        except ImportError:\n            import sysconfig\n        osname, release, machine = _osx_support.get_platform_osx(sysconfig.get_config_vars(), osname, release, machine)\n\n    return '%s-%s-%s' % (osname, release, machine)\n\n\n_TARGET_TO_PLAT = {\n    'x86': 'win32',\n    'x64': 'win-amd64',\n    'arm': 'win-arm32',\n}\n\n\ndef get_platform():\n    if os.name != 'nt':\n        return get_host_platform()\n    cross_compilation_target = os.environ.get('VSCMD_ARG_TGT_ARCH')\n    if cross_compilation_target not in _TARGET_TO_PLAT:\n        return get_host_platform()\n    return _TARGET_TO_PLAT[cross_compilation_target]\n", "distlib/wheel.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import unicode_literals\n\nimport base64\nimport codecs\nimport datetime\nfrom email import message_from_file\nimport hashlib\nimport json\nimport logging\nimport os\nimport posixpath\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport zipfile\n\nfrom . import __version__, DistlibException\nfrom .compat import sysconfig, ZipFile, fsdecode, text_type, filter\nfrom .database import InstalledDistribution\nfrom .metadata import Metadata, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME\nfrom .util import (FileOperator, convert_path, CSVReader, CSVWriter, Cache, cached_property, get_cache_base,\n                   read_exports, tempdir, get_platform)\nfrom .version import NormalizedVersion, UnsupportedVersionError\n\nlogger = logging.getLogger(__name__)\n\ncache = None  # created when needed\n\nif hasattr(sys, 'pypy_version_info'):  # pragma: no cover\n    IMP_PREFIX = 'pp'\nelif sys.platform.startswith('java'):  # pragma: no cover\n    IMP_PREFIX = 'jy'\nelif sys.platform == 'cli':  # pragma: no cover\n    IMP_PREFIX = 'ip'\nelse:\n    IMP_PREFIX = 'cp'\n\nVER_SUFFIX = sysconfig.get_config_var('py_version_nodot')\nif not VER_SUFFIX:  # pragma: no cover\n    VER_SUFFIX = '%s%s' % sys.version_info[:2]\nPYVER = 'py' + VER_SUFFIX\nIMPVER = IMP_PREFIX + VER_SUFFIX\n\nARCH = get_platform().replace('-', '_').replace('.', '_')\n\nABI = sysconfig.get_config_var('SOABI')\nif ABI and ABI.startswith('cpython-'):\n    ABI = ABI.replace('cpython-', 'cp').split('-')[0]\nelse:\n\n    def _derive_abi():\n        parts = ['cp', VER_SUFFIX]\n        if sysconfig.get_config_var('Py_DEBUG'):\n            parts.append('d')\n        if IMP_PREFIX == 'cp':\n            vi = sys.version_info[:2]\n            if vi < (3, 8):\n                wpm = sysconfig.get_config_var('WITH_PYMALLOC')\n                if wpm is None:\n                    wpm = True\n                if wpm:\n                    parts.append('m')\n                if vi < (3, 3):\n                    us = sysconfig.get_config_var('Py_UNICODE_SIZE')\n                    if us == 4 or (us is None and sys.maxunicode == 0x10FFFF):\n                        parts.append('u')\n        return ''.join(parts)\n\n    ABI = _derive_abi()\n    del _derive_abi\n\nFILENAME_RE = re.compile(\n    r'''\n(?P<nm>[^-]+)\n-(?P<vn>\\d+[^-]*)\n(-(?P<bn>\\d+[^-]*))?\n-(?P<py>\\w+\\d+(\\.\\w+\\d+)*)\n-(?P<bi>\\w+)\n-(?P<ar>\\w+(\\.\\w+)*)\n\\.whl$\n''', re.IGNORECASE | re.VERBOSE)\n\nNAME_VERSION_RE = re.compile(r'''\n(?P<nm>[^-]+)\n-(?P<vn>\\d+[^-]*)\n(-(?P<bn>\\d+[^-]*))?$\n''', re.IGNORECASE | re.VERBOSE)\n\nSHEBANG_RE = re.compile(br'\\s*#![^\\r\\n]*')\nSHEBANG_DETAIL_RE = re.compile(br'^(\\s*#!(\"[^\"]+\"|\\S+))\\s+(.*)$')\nSHEBANG_PYTHON = b'#!python'\nSHEBANG_PYTHONW = b'#!pythonw'\n\nif os.sep == '/':\n    to_posix = lambda o: o\nelse:\n    to_posix = lambda o: o.replace(os.sep, '/')\n\nif sys.version_info[0] < 3:\n    import imp\nelse:\n    imp = None\n    import importlib.machinery\n    import importlib.util\n\n\ndef _get_suffixes():\n    if imp:\n        return [s[0] for s in imp.get_suffixes()]\n    else:\n        return importlib.machinery.EXTENSION_SUFFIXES\n\n\ndef _load_dynamic(name, path):\n    # https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly\n    if imp:\n        return imp.load_dynamic(name, path)\n    else:\n        spec = importlib.util.spec_from_file_location(name, path)\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[name] = module\n        spec.loader.exec_module(module)\n        return module\n\n\nclass Mounter(object):\n\n    def __init__(self):\n        self.impure_wheels = {}\n        self.libs = {}\n\n    def add(self, pathname, extensions):\n        self.impure_wheels[pathname] = extensions\n        self.libs.update(extensions)\n\n    def remove(self, pathname):\n        extensions = self.impure_wheels.pop(pathname)\n        for k, v in extensions:\n            if k in self.libs:\n                del self.libs[k]\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.libs:\n            result = self\n        else:\n            result = None\n        return result\n\n    def load_module(self, fullname):\n        if fullname in sys.modules:\n            result = sys.modules[fullname]\n        else:\n            if fullname not in self.libs:\n                raise ImportError('unable to find extension for %s' % fullname)\n            result = _load_dynamic(fullname, self.libs[fullname])\n            result.__loader__ = self\n            parts = fullname.rsplit('.', 1)\n            if len(parts) > 1:\n                result.__package__ = parts[0]\n        return result\n\n\n_hook = Mounter()\n\n\nclass Wheel(object):\n    \"\"\"\n    Class to build and install from Wheel files (PEP 427).\n    \"\"\"\n\n    wheel_version = (1, 1)\n    hash_kind = 'sha256'\n\n    def __init__(self, filename=None, sign=False, verify=False):\n        \"\"\"\n        Initialise an instance using a (valid) filename.\n        \"\"\"\n        self.sign = sign\n        self.should_verify = verify\n        self.buildver = ''\n        self.pyver = [PYVER]\n        self.abi = ['none']\n        self.arch = ['any']\n        self.dirname = os.getcwd()\n        if filename is None:\n            self.name = 'dummy'\n            self.version = '0.1'\n            self._filename = self.filename\n        else:\n            m = NAME_VERSION_RE.match(filename)\n            if m:\n                info = m.groupdict('')\n                self.name = info['nm']\n                # Reinstate the local version separator\n                self.version = info['vn'].replace('_', '-')\n                self.buildver = info['bn']\n                self._filename = self.filename\n            else:\n                dirname, filename = os.path.split(filename)\n                m = FILENAME_RE.match(filename)\n                if not m:\n                    raise DistlibException('Invalid name or '\n                                           'filename: %r' % filename)\n                if dirname:\n                    self.dirname = os.path.abspath(dirname)\n                self._filename = filename\n                info = m.groupdict('')\n                self.name = info['nm']\n                self.version = info['vn']\n                self.buildver = info['bn']\n                self.pyver = info['py'].split('.')\n                self.abi = info['bi'].split('.')\n                self.arch = info['ar'].split('.')\n\n    @property\n    def filename(self):\n        \"\"\"\n        Build and return a filename from the various components.\n        \"\"\"\n        if self.buildver:\n            buildver = '-' + self.buildver\n        else:\n            buildver = ''\n        pyver = '.'.join(self.pyver)\n        abi = '.'.join(self.abi)\n        arch = '.'.join(self.arch)\n        # replace - with _ as a local version separator\n        version = self.version.replace('-', '_')\n        return '%s-%s%s-%s-%s-%s.whl' % (self.name, version, buildver, pyver, abi, arch)\n\n    @property\n    def exists(self):\n        path = os.path.join(self.dirname, self.filename)\n        return os.path.isfile(path)\n\n    @property\n    def tags(self):\n        for pyver in self.pyver:\n            for abi in self.abi:\n                for arch in self.arch:\n                    yield pyver, abi, arch\n\n    @cached_property\n    def metadata(self):\n        pathname = os.path.join(self.dirname, self.filename)\n        name_ver = '%s-%s' % (self.name, self.version)\n        info_dir = '%s.dist-info' % name_ver\n        wrapper = codecs.getreader('utf-8')\n        with ZipFile(pathname, 'r') as zf:\n            self.get_wheel_metadata(zf)\n            # wv = wheel_metadata['Wheel-Version'].split('.', 1)\n            # file_version = tuple([int(i) for i in wv])\n            # if file_version < (1, 1):\n            # fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME,\n            # LEGACY_METADATA_FILENAME]\n            # else:\n            # fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME]\n            fns = [WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME]\n            result = None\n            for fn in fns:\n                try:\n                    metadata_filename = posixpath.join(info_dir, fn)\n                    with zf.open(metadata_filename) as bf:\n                        wf = wrapper(bf)\n                        result = Metadata(fileobj=wf)\n                        if result:\n                            break\n                except KeyError:\n                    pass\n            if not result:\n                raise ValueError('Invalid wheel, because metadata is '\n                                 'missing: looked in %s' % ', '.join(fns))\n        return result\n\n    def get_wheel_metadata(self, zf):\n        name_ver = '%s-%s' % (self.name, self.version)\n        info_dir = '%s.dist-info' % name_ver\n        metadata_filename = posixpath.join(info_dir, 'WHEEL')\n        with zf.open(metadata_filename) as bf:\n            wf = codecs.getreader('utf-8')(bf)\n            message = message_from_file(wf)\n        return dict(message)\n\n    @cached_property\n    def info(self):\n        pathname = os.path.join(self.dirname, self.filename)\n        with ZipFile(pathname, 'r') as zf:\n            result = self.get_wheel_metadata(zf)\n        return result\n\n    def process_shebang(self, data):\n        m = SHEBANG_RE.match(data)\n        if m:\n            end = m.end()\n            shebang, data_after_shebang = data[:end], data[end:]\n            # Preserve any arguments after the interpreter\n            if b'pythonw' in shebang.lower():\n                shebang_python = SHEBANG_PYTHONW\n            else:\n                shebang_python = SHEBANG_PYTHON\n            m = SHEBANG_DETAIL_RE.match(shebang)\n            if m:\n                args = b' ' + m.groups()[-1]\n            else:\n                args = b''\n            shebang = shebang_python + args\n            data = shebang + data_after_shebang\n        else:\n            cr = data.find(b'\\r')\n            lf = data.find(b'\\n')\n            if cr < 0 or cr > lf:\n                term = b'\\n'\n            else:\n                if data[cr:cr + 2] == b'\\r\\n':\n                    term = b'\\r\\n'\n                else:\n                    term = b'\\r'\n            data = SHEBANG_PYTHON + term + data\n        return data\n\n    def get_hash(self, data, hash_kind=None):\n        if hash_kind is None:\n            hash_kind = self.hash_kind\n        try:\n            hasher = getattr(hashlib, hash_kind)\n        except AttributeError:\n            raise DistlibException('Unsupported hash algorithm: %r' % hash_kind)\n        result = hasher(data).digest()\n        result = base64.urlsafe_b64encode(result).rstrip(b'=').decode('ascii')\n        return hash_kind, result\n\n    def write_record(self, records, record_path, archive_record_path):\n        records = list(records)  # make a copy, as mutated\n        records.append((archive_record_path, '', ''))\n        with CSVWriter(record_path) as writer:\n            for row in records:\n                writer.writerow(row)\n\n    def write_records(self, info, libdir, archive_paths):\n        records = []\n        distinfo, info_dir = info\n        # hasher = getattr(hashlib, self.hash_kind)\n        for ap, p in archive_paths:\n            with open(p, 'rb') as f:\n                data = f.read()\n            digest = '%s=%s' % self.get_hash(data)\n            size = os.path.getsize(p)\n            records.append((ap, digest, size))\n\n        p = os.path.join(distinfo, 'RECORD')\n        ap = to_posix(os.path.join(info_dir, 'RECORD'))\n        self.write_record(records, p, ap)\n        archive_paths.append((ap, p))\n\n    def build_zip(self, pathname, archive_paths):\n        with ZipFile(pathname, 'w', zipfile.ZIP_DEFLATED) as zf:\n            for ap, p in archive_paths:\n                logger.debug('Wrote %s to %s in wheel', p, ap)\n                zf.write(p, ap)\n\n    def build(self, paths, tags=None, wheel_version=None):\n        \"\"\"\n        Build a wheel from files in specified paths, and use any specified tags\n        when determining the name of the wheel.\n        \"\"\"\n        if tags is None:\n            tags = {}\n\n        libkey = list(filter(lambda o: o in paths, ('purelib', 'platlib')))[0]\n        if libkey == 'platlib':\n            is_pure = 'false'\n            default_pyver = [IMPVER]\n            default_abi = [ABI]\n            default_arch = [ARCH]\n        else:\n            is_pure = 'true'\n            default_pyver = [PYVER]\n            default_abi = ['none']\n            default_arch = ['any']\n\n        self.pyver = tags.get('pyver', default_pyver)\n        self.abi = tags.get('abi', default_abi)\n        self.arch = tags.get('arch', default_arch)\n\n        libdir = paths[libkey]\n\n        name_ver = '%s-%s' % (self.name, self.version)\n        data_dir = '%s.data' % name_ver\n        info_dir = '%s.dist-info' % name_ver\n\n        archive_paths = []\n\n        # First, stuff which is not in site-packages\n        for key in ('data', 'headers', 'scripts'):\n            if key not in paths:\n                continue\n            path = paths[key]\n            if os.path.isdir(path):\n                for root, dirs, files in os.walk(path):\n                    for fn in files:\n                        p = fsdecode(os.path.join(root, fn))\n                        rp = os.path.relpath(p, path)\n                        ap = to_posix(os.path.join(data_dir, key, rp))\n                        archive_paths.append((ap, p))\n                        if key == 'scripts' and not p.endswith('.exe'):\n                            with open(p, 'rb') as f:\n                                data = f.read()\n                            data = self.process_shebang(data)\n                            with open(p, 'wb') as f:\n                                f.write(data)\n\n        # Now, stuff which is in site-packages, other than the\n        # distinfo stuff.\n        path = libdir\n        distinfo = None\n        for root, dirs, files in os.walk(path):\n            if root == path:\n                # At the top level only, save distinfo for later\n                # and skip it for now\n                for i, dn in enumerate(dirs):\n                    dn = fsdecode(dn)\n                    if dn.endswith('.dist-info'):\n                        distinfo = os.path.join(root, dn)\n                        del dirs[i]\n                        break\n                assert distinfo, '.dist-info directory expected, not found'\n\n            for fn in files:\n                # comment out next suite to leave .pyc files in\n                if fsdecode(fn).endswith(('.pyc', '.pyo')):\n                    continue\n                p = os.path.join(root, fn)\n                rp = to_posix(os.path.relpath(p, path))\n                archive_paths.append((rp, p))\n\n        # Now distinfo. Assumed to be flat, i.e. os.listdir is enough.\n        files = os.listdir(distinfo)\n        for fn in files:\n            if fn not in ('RECORD', 'INSTALLER', 'SHARED', 'WHEEL'):\n                p = fsdecode(os.path.join(distinfo, fn))\n                ap = to_posix(os.path.join(info_dir, fn))\n                archive_paths.append((ap, p))\n\n        wheel_metadata = [\n            'Wheel-Version: %d.%d' % (wheel_version or self.wheel_version),\n            'Generator: distlib %s' % __version__,\n            'Root-Is-Purelib: %s' % is_pure,\n        ]\n        for pyver, abi, arch in self.tags:\n            wheel_metadata.append('Tag: %s-%s-%s' % (pyver, abi, arch))\n        p = os.path.join(distinfo, 'WHEEL')\n        with open(p, 'w') as f:\n            f.write('\\n'.join(wheel_metadata))\n        ap = to_posix(os.path.join(info_dir, 'WHEEL'))\n        archive_paths.append((ap, p))\n\n        # sort the entries by archive path. Not needed by any spec, but it\n        # keeps the archive listing and RECORD tidier than they would otherwise\n        # be. Use the number of path segments to keep directory entries together,\n        # and keep the dist-info stuff at the end.\n        def sorter(t):\n            ap = t[0]\n            n = ap.count('/')\n            if '.dist-info' in ap:\n                n += 10000\n            return (n, ap)\n\n        archive_paths = sorted(archive_paths, key=sorter)\n\n        # Now, at last, RECORD.\n        # Paths in here are archive paths - nothing else makes sense.\n        self.write_records((distinfo, info_dir), libdir, archive_paths)\n        # Now, ready to build the zip file\n        pathname = os.path.join(self.dirname, self.filename)\n        self.build_zip(pathname, archive_paths)\n        return pathname\n\n    def skip_entry(self, arcname):\n        \"\"\"\n        Determine whether an archive entry should be skipped when verifying\n        or installing.\n        \"\"\"\n        # The signature file won't be in RECORD,\n        # and we  don't currently don't do anything with it\n        # We also skip directories, as they won't be in RECORD\n        # either. See:\n        #\n        # https://github.com/pypa/wheel/issues/294\n        # https://github.com/pypa/wheel/issues/287\n        # https://github.com/pypa/wheel/pull/289\n        #\n        return arcname.endswith(('/', '/RECORD.jws'))\n\n    def install(self, paths, maker, **kwargs):\n        \"\"\"\n        Install a wheel to the specified paths. If kwarg ``warner`` is\n        specified, it should be a callable, which will be called with two\n        tuples indicating the wheel version of this software and the wheel\n        version in the file, if there is a discrepancy in the versions.\n        This can be used to issue any warnings to raise any exceptions.\n        If kwarg ``lib_only`` is True, only the purelib/platlib files are\n        installed, and the headers, scripts, data and dist-info metadata are\n        not written. If kwarg ``bytecode_hashed_invalidation`` is True, written\n        bytecode will try to use file-hash based invalidation (PEP-552) on\n        supported interpreter versions (CPython 3.7+).\n\n        The return value is a :class:`InstalledDistribution` instance unless\n        ``options.lib_only`` is True, in which case the return value is ``None``.\n        \"\"\"\n\n        dry_run = maker.dry_run\n        warner = kwargs.get('warner')\n        lib_only = kwargs.get('lib_only', False)\n        bc_hashed_invalidation = kwargs.get('bytecode_hashed_invalidation', False)\n\n        pathname = os.path.join(self.dirname, self.filename)\n        name_ver = '%s-%s' % (self.name, self.version)\n        data_dir = '%s.data' % name_ver\n        info_dir = '%s.dist-info' % name_ver\n\n        metadata_name = posixpath.join(info_dir, LEGACY_METADATA_FILENAME)\n        wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')\n        record_name = posixpath.join(info_dir, 'RECORD')\n\n        wrapper = codecs.getreader('utf-8')\n\n        with ZipFile(pathname, 'r') as zf:\n            with zf.open(wheel_metadata_name) as bwf:\n                wf = wrapper(bwf)\n                message = message_from_file(wf)\n            wv = message['Wheel-Version'].split('.', 1)\n            file_version = tuple([int(i) for i in wv])\n            if (file_version != self.wheel_version) and warner:\n                warner(self.wheel_version, file_version)\n\n            if message['Root-Is-Purelib'] == 'true':\n                libdir = paths['purelib']\n            else:\n                libdir = paths['platlib']\n\n            records = {}\n            with zf.open(record_name) as bf:\n                with CSVReader(stream=bf) as reader:\n                    for row in reader:\n                        p = row[0]\n                        records[p] = row\n\n            data_pfx = posixpath.join(data_dir, '')\n            info_pfx = posixpath.join(info_dir, '')\n            script_pfx = posixpath.join(data_dir, 'scripts', '')\n\n            # make a new instance rather than a copy of maker's,\n            # as we mutate it\n            fileop = FileOperator(dry_run=dry_run)\n            fileop.record = True  # so we can rollback if needed\n\n            bc = not sys.dont_write_bytecode  # Double negatives. Lovely!\n\n            outfiles = []  # for RECORD writing\n\n            # for script copying/shebang processing\n            workdir = tempfile.mkdtemp()\n            # set target dir later\n            # we default add_launchers to False, as the\n            # Python Launcher should be used instead\n            maker.source_dir = workdir\n            maker.target_dir = None\n            try:\n                for zinfo in zf.infolist():\n                    arcname = zinfo.filename\n                    if isinstance(arcname, text_type):\n                        u_arcname = arcname\n                    else:\n                        u_arcname = arcname.decode('utf-8')\n                    if self.skip_entry(u_arcname):\n                        continue\n                    row = records[u_arcname]\n                    if row[2] and str(zinfo.file_size) != row[2]:\n                        raise DistlibException('size mismatch for '\n                                               '%s' % u_arcname)\n                    if row[1]:\n                        kind, value = row[1].split('=', 1)\n                        with zf.open(arcname) as bf:\n                            data = bf.read()\n                        _, digest = self.get_hash(data, kind)\n                        if digest != value:\n                            raise DistlibException('digest mismatch for '\n                                                   '%s' % arcname)\n\n                    if lib_only and u_arcname.startswith((info_pfx, data_pfx)):\n                        logger.debug('lib_only: skipping %s', u_arcname)\n                        continue\n                    is_script = (u_arcname.startswith(script_pfx) and not u_arcname.endswith('.exe'))\n\n                    if u_arcname.startswith(data_pfx):\n                        _, where, rp = u_arcname.split('/', 2)\n                        outfile = os.path.join(paths[where], convert_path(rp))\n                    else:\n                        # meant for site-packages.\n                        if u_arcname in (wheel_metadata_name, record_name):\n                            continue\n                        outfile = os.path.join(libdir, convert_path(u_arcname))\n                    if not is_script:\n                        with zf.open(arcname) as bf:\n                            fileop.copy_stream(bf, outfile)\n                        # Issue #147: permission bits aren't preserved. Using\n                        # zf.extract(zinfo, libdir) should have worked, but didn't,\n                        # see https://www.thetopsites.net/article/53834422.shtml\n                        # So ... manually preserve permission bits as given in zinfo\n                        if os.name == 'posix':\n                            # just set the normal permission bits\n                            os.chmod(outfile, (zinfo.external_attr >> 16) & 0x1FF)\n                        outfiles.append(outfile)\n                        # Double check the digest of the written file\n                        if not dry_run and row[1]:\n                            with open(outfile, 'rb') as bf:\n                                data = bf.read()\n                                _, newdigest = self.get_hash(data, kind)\n                                if newdigest != digest:\n                                    raise DistlibException('digest mismatch '\n                                                           'on write for '\n                                                           '%s' % outfile)\n                        if bc and outfile.endswith('.py'):\n                            try:\n                                pyc = fileop.byte_compile(outfile, hashed_invalidation=bc_hashed_invalidation)\n                                outfiles.append(pyc)\n                            except Exception:\n                                # Don't give up if byte-compilation fails,\n                                # but log it and perhaps warn the user\n                                logger.warning('Byte-compilation failed', exc_info=True)\n                    else:\n                        fn = os.path.basename(convert_path(arcname))\n                        workname = os.path.join(workdir, fn)\n                        with zf.open(arcname) as bf:\n                            fileop.copy_stream(bf, workname)\n\n                        dn, fn = os.path.split(outfile)\n                        maker.target_dir = dn\n                        filenames = maker.make(fn)\n                        fileop.set_executable_mode(filenames)\n                        outfiles.extend(filenames)\n\n                if lib_only:\n                    logger.debug('lib_only: returning None')\n                    dist = None\n                else:\n                    # Generate scripts\n\n                    # Try to get pydist.json so we can see if there are\n                    # any commands to generate. If this fails (e.g. because\n                    # of a legacy wheel), log a warning but don't give up.\n                    commands = None\n                    file_version = self.info['Wheel-Version']\n                    if file_version == '1.0':\n                        # Use legacy info\n                        ep = posixpath.join(info_dir, 'entry_points.txt')\n                        try:\n                            with zf.open(ep) as bwf:\n                                epdata = read_exports(bwf)\n                            commands = {}\n                            for key in ('console', 'gui'):\n                                k = '%s_scripts' % key\n                                if k in epdata:\n                                    commands['wrap_%s' % key] = d = {}\n                                    for v in epdata[k].values():\n                                        s = '%s:%s' % (v.prefix, v.suffix)\n                                        if v.flags:\n                                            s += ' [%s]' % ','.join(v.flags)\n                                        d[v.name] = s\n                        except Exception:\n                            logger.warning('Unable to read legacy script '\n                                           'metadata, so cannot generate '\n                                           'scripts')\n                    else:\n                        try:\n                            with zf.open(metadata_name) as bwf:\n                                wf = wrapper(bwf)\n                                commands = json.load(wf).get('extensions')\n                                if commands:\n                                    commands = commands.get('python.commands')\n                        except Exception:\n                            logger.warning('Unable to read JSON metadata, so '\n                                           'cannot generate scripts')\n                    if commands:\n                        console_scripts = commands.get('wrap_console', {})\n                        gui_scripts = commands.get('wrap_gui', {})\n                        if console_scripts or gui_scripts:\n                            script_dir = paths.get('scripts', '')\n                            if not os.path.isdir(script_dir):\n                                raise ValueError('Valid script path not '\n                                                 'specified')\n                            maker.target_dir = script_dir\n                            for k, v in console_scripts.items():\n                                script = '%s = %s' % (k, v)\n                                filenames = maker.make(script)\n                                fileop.set_executable_mode(filenames)\n\n                            if gui_scripts:\n                                options = {'gui': True}\n                                for k, v in gui_scripts.items():\n                                    script = '%s = %s' % (k, v)\n                                    filenames = maker.make(script, options)\n                                    fileop.set_executable_mode(filenames)\n\n                    p = os.path.join(libdir, info_dir)\n                    dist = InstalledDistribution(p)\n\n                    # Write SHARED\n                    paths = dict(paths)  # don't change passed in dict\n                    del paths['purelib']\n                    del paths['platlib']\n                    paths['lib'] = libdir\n                    p = dist.write_shared_locations(paths, dry_run)\n                    if p:\n                        outfiles.append(p)\n\n                    # Write RECORD\n                    dist.write_installed_files(outfiles, paths['prefix'], dry_run)\n                return dist\n            except Exception:  # pragma: no cover\n                logger.exception('installation failed.')\n                fileop.rollback()\n                raise\n            finally:\n                shutil.rmtree(workdir)\n\n    def _get_dylib_cache(self):\n        global cache\n        if cache is None:\n            # Use native string to avoid issues on 2.x: see Python #20140.\n            base = os.path.join(get_cache_base(), str('dylib-cache'), '%s.%s' % sys.version_info[:2])\n            cache = Cache(base)\n        return cache\n\n    def _get_extensions(self):\n        pathname = os.path.join(self.dirname, self.filename)\n        name_ver = '%s-%s' % (self.name, self.version)\n        info_dir = '%s.dist-info' % name_ver\n        arcname = posixpath.join(info_dir, 'EXTENSIONS')\n        wrapper = codecs.getreader('utf-8')\n        result = []\n        with ZipFile(pathname, 'r') as zf:\n            try:\n                with zf.open(arcname) as bf:\n                    wf = wrapper(bf)\n                    extensions = json.load(wf)\n                    cache = self._get_dylib_cache()\n                    prefix = cache.prefix_to_dir(pathname)\n                    cache_base = os.path.join(cache.base, prefix)\n                    if not os.path.isdir(cache_base):\n                        os.makedirs(cache_base)\n                    for name, relpath in extensions.items():\n                        dest = os.path.join(cache_base, convert_path(relpath))\n                        if not os.path.exists(dest):\n                            extract = True\n                        else:\n                            file_time = os.stat(dest).st_mtime\n                            file_time = datetime.datetime.fromtimestamp(file_time)\n                            info = zf.getinfo(relpath)\n                            wheel_time = datetime.datetime(*info.date_time)\n                            extract = wheel_time > file_time\n                        if extract:\n                            zf.extract(relpath, cache_base)\n                        result.append((name, dest))\n            except KeyError:\n                pass\n        return result\n\n    def is_compatible(self):\n        \"\"\"\n        Determine if a wheel is compatible with the running system.\n        \"\"\"\n        return is_compatible(self)\n\n    def is_mountable(self):\n        \"\"\"\n        Determine if a wheel is asserted as mountable by its metadata.\n        \"\"\"\n        return True  # for now - metadata details TBD\n\n    def mount(self, append=False):\n        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))\n        if not self.is_compatible():\n            msg = 'Wheel %s not compatible with this Python.' % pathname\n            raise DistlibException(msg)\n        if not self.is_mountable():\n            msg = 'Wheel %s is marked as not mountable.' % pathname\n            raise DistlibException(msg)\n        if pathname in sys.path:\n            logger.debug('%s already in path', pathname)\n        else:\n            if append:\n                sys.path.append(pathname)\n            else:\n                sys.path.insert(0, pathname)\n            extensions = self._get_extensions()\n            if extensions:\n                if _hook not in sys.meta_path:\n                    sys.meta_path.append(_hook)\n                _hook.add(pathname, extensions)\n\n    def unmount(self):\n        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))\n        if pathname not in sys.path:\n            logger.debug('%s not in path', pathname)\n        else:\n            sys.path.remove(pathname)\n            if pathname in _hook.impure_wheels:\n                _hook.remove(pathname)\n            if not _hook.impure_wheels:\n                if _hook in sys.meta_path:\n                    sys.meta_path.remove(_hook)\n\n    def verify(self):\n        pathname = os.path.join(self.dirname, self.filename)\n        name_ver = '%s-%s' % (self.name, self.version)\n        # data_dir = '%s.data' % name_ver\n        info_dir = '%s.dist-info' % name_ver\n\n        # metadata_name = posixpath.join(info_dir, LEGACY_METADATA_FILENAME)\n        wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')\n        record_name = posixpath.join(info_dir, 'RECORD')\n\n        wrapper = codecs.getreader('utf-8')\n\n        with ZipFile(pathname, 'r') as zf:\n            with zf.open(wheel_metadata_name) as bwf:\n                wf = wrapper(bwf)\n                message_from_file(wf)\n            # wv = message['Wheel-Version'].split('.', 1)\n            # file_version = tuple([int(i) for i in wv])\n            # TODO version verification\n\n            records = {}\n            with zf.open(record_name) as bf:\n                with CSVReader(stream=bf) as reader:\n                    for row in reader:\n                        p = row[0]\n                        records[p] = row\n\n            for zinfo in zf.infolist():\n                arcname = zinfo.filename\n                if isinstance(arcname, text_type):\n                    u_arcname = arcname\n                else:\n                    u_arcname = arcname.decode('utf-8')\n                # See issue #115: some wheels have .. in their entries, but\n                # in the filename ... e.g. __main__..py ! So the check is\n                # updated to look for .. in the directory portions\n                p = u_arcname.split('/')\n                if '..' in p:\n                    raise DistlibException('invalid entry in '\n                                           'wheel: %r' % u_arcname)\n\n                if self.skip_entry(u_arcname):\n                    continue\n                row = records[u_arcname]\n                if row[2] and str(zinfo.file_size) != row[2]:\n                    raise DistlibException('size mismatch for '\n                                           '%s' % u_arcname)\n                if row[1]:\n                    kind, value = row[1].split('=', 1)\n                    with zf.open(arcname) as bf:\n                        data = bf.read()\n                    _, digest = self.get_hash(data, kind)\n                    if digest != value:\n                        raise DistlibException('digest mismatch for '\n                                               '%s' % arcname)\n\n    def update(self, modifier, dest_dir=None, **kwargs):\n        \"\"\"\n        Update the contents of a wheel in a generic way. The modifier should\n        be a callable which expects a dictionary argument: its keys are\n        archive-entry paths, and its values are absolute filesystem paths\n        where the contents the corresponding archive entries can be found. The\n        modifier is free to change the contents of the files pointed to, add\n        new entries and remove entries, before returning. This method will\n        extract the entire contents of the wheel to a temporary location, call\n        the modifier, and then use the passed (and possibly updated)\n        dictionary to write a new wheel. If ``dest_dir`` is specified, the new\n        wheel is written there -- otherwise, the original wheel is overwritten.\n\n        The modifier should return True if it updated the wheel, else False.\n        This method returns the same value the modifier returns.\n        \"\"\"\n\n        def get_version(path_map, info_dir):\n            version = path = None\n            key = '%s/%s' % (info_dir, LEGACY_METADATA_FILENAME)\n            if key not in path_map:\n                key = '%s/PKG-INFO' % info_dir\n            if key in path_map:\n                path = path_map[key]\n                version = Metadata(path=path).version\n            return version, path\n\n        def update_version(version, path):\n            updated = None\n            try:\n                NormalizedVersion(version)\n                i = version.find('-')\n                if i < 0:\n                    updated = '%s+1' % version\n                else:\n                    parts = [int(s) for s in version[i + 1:].split('.')]\n                    parts[-1] += 1\n                    updated = '%s+%s' % (version[:i], '.'.join(str(i) for i in parts))\n            except UnsupportedVersionError:\n                logger.debug('Cannot update non-compliant (PEP-440) '\n                             'version %r', version)\n            if updated:\n                md = Metadata(path=path)\n                md.version = updated\n                legacy = path.endswith(LEGACY_METADATA_FILENAME)\n                md.write(path=path, legacy=legacy)\n                logger.debug('Version updated from %r to %r', version, updated)\n\n        pathname = os.path.join(self.dirname, self.filename)\n        name_ver = '%s-%s' % (self.name, self.version)\n        info_dir = '%s.dist-info' % name_ver\n        record_name = posixpath.join(info_dir, 'RECORD')\n        with tempdir() as workdir:\n            with ZipFile(pathname, 'r') as zf:\n                path_map = {}\n                for zinfo in zf.infolist():\n                    arcname = zinfo.filename\n                    if isinstance(arcname, text_type):\n                        u_arcname = arcname\n                    else:\n                        u_arcname = arcname.decode('utf-8')\n                    if u_arcname == record_name:\n                        continue\n                    if '..' in u_arcname:\n                        raise DistlibException('invalid entry in '\n                                               'wheel: %r' % u_arcname)\n                    zf.extract(zinfo, workdir)\n                    path = os.path.join(workdir, convert_path(u_arcname))\n                    path_map[u_arcname] = path\n\n            # Remember the version.\n            original_version, _ = get_version(path_map, info_dir)\n            # Files extracted. Call the modifier.\n            modified = modifier(path_map, **kwargs)\n            if modified:\n                # Something changed - need to build a new wheel.\n                current_version, path = get_version(path_map, info_dir)\n                if current_version and (current_version == original_version):\n                    # Add or update local version to signify changes.\n                    update_version(current_version, path)\n                # Decide where the new wheel goes.\n                if dest_dir is None:\n                    fd, newpath = tempfile.mkstemp(suffix='.whl', prefix='wheel-update-', dir=workdir)\n                    os.close(fd)\n                else:\n                    if not os.path.isdir(dest_dir):\n                        raise DistlibException('Not a directory: %r' % dest_dir)\n                    newpath = os.path.join(dest_dir, self.filename)\n                archive_paths = list(path_map.items())\n                distinfo = os.path.join(workdir, info_dir)\n                info = distinfo, info_dir\n                self.write_records(info, workdir, archive_paths)\n                self.build_zip(newpath, archive_paths)\n                if dest_dir is None:\n                    shutil.copyfile(newpath, pathname)\n        return modified\n\n\ndef _get_glibc_version():\n    import platform\n    ver = platform.libc_ver()\n    result = []\n    if ver[0] == 'glibc':\n        for s in ver[1].split('.'):\n            result.append(int(s) if s.isdigit() else 0)\n        result = tuple(result)\n    return result\n\n\ndef compatible_tags():\n    \"\"\"\n    Return (pyver, abi, arch) tuples compatible with this Python.\n    \"\"\"\n    versions = [VER_SUFFIX]\n    major = VER_SUFFIX[0]\n    for minor in range(sys.version_info[1] - 1, -1, -1):\n        versions.append(''.join([major, str(minor)]))\n\n    abis = []\n    for suffix in _get_suffixes():\n        if suffix.startswith('.abi'):\n            abis.append(suffix.split('.', 2)[1])\n    abis.sort()\n    if ABI != 'none':\n        abis.insert(0, ABI)\n    abis.append('none')\n    result = []\n\n    arches = [ARCH]\n    if sys.platform == 'darwin':\n        m = re.match(r'(\\w+)_(\\d+)_(\\d+)_(\\w+)$', ARCH)\n        if m:\n            name, major, minor, arch = m.groups()\n            minor = int(minor)\n            matches = [arch]\n            if arch in ('i386', 'ppc'):\n                matches.append('fat')\n            if arch in ('i386', 'ppc', 'x86_64'):\n                matches.append('fat3')\n            if arch in ('ppc64', 'x86_64'):\n                matches.append('fat64')\n            if arch in ('i386', 'x86_64'):\n                matches.append('intel')\n            if arch in ('i386', 'x86_64', 'intel', 'ppc', 'ppc64'):\n                matches.append('universal')\n            while minor >= 0:\n                for match in matches:\n                    s = '%s_%s_%s_%s' % (name, major, minor, match)\n                    if s != ARCH:  # already there\n                        arches.append(s)\n                minor -= 1\n\n    # Most specific - our Python version, ABI and arch\n    for abi in abis:\n        for arch in arches:\n            result.append((''.join((IMP_PREFIX, versions[0])), abi, arch))\n            # manylinux\n            if abi != 'none' and sys.platform.startswith('linux'):\n                arch = arch.replace('linux_', '')\n                parts = _get_glibc_version()\n                if len(parts) == 2:\n                    if parts >= (2, 5):\n                        result.append((''.join((IMP_PREFIX, versions[0])), abi, 'manylinux1_%s' % arch))\n                    if parts >= (2, 12):\n                        result.append((''.join((IMP_PREFIX, versions[0])), abi, 'manylinux2010_%s' % arch))\n                    if parts >= (2, 17):\n                        result.append((''.join((IMP_PREFIX, versions[0])), abi, 'manylinux2014_%s' % arch))\n                    result.append((''.join(\n                        (IMP_PREFIX, versions[0])), abi, 'manylinux_%s_%s_%s' % (parts[0], parts[1], arch)))\n\n    # where no ABI / arch dependency, but IMP_PREFIX dependency\n    for i, version in enumerate(versions):\n        result.append((''.join((IMP_PREFIX, version)), 'none', 'any'))\n        if i == 0:\n            result.append((''.join((IMP_PREFIX, version[0])), 'none', 'any'))\n\n    # no IMP_PREFIX, ABI or arch dependency\n    for i, version in enumerate(versions):\n        result.append((''.join(('py', version)), 'none', 'any'))\n        if i == 0:\n            result.append((''.join(('py', version[0])), 'none', 'any'))\n\n    return set(result)\n\n\nCOMPATIBLE_TAGS = compatible_tags()\n\ndel compatible_tags\n\n\ndef is_compatible(wheel, tags=None):\n    if not isinstance(wheel, Wheel):\n        wheel = Wheel(wheel)  # assume it's a filename\n    result = False\n    if tags is None:\n        tags = COMPATIBLE_TAGS\n    for ver, abi, arch in tags:\n        if ver in wheel.pyver and abi in wheel.abi and arch in wheel.arch:\n            result = True\n            break\n    return result\n", "distlib/database.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"PEP 376 implementation.\"\"\"\n\nfrom __future__ import unicode_literals\n\nimport base64\nimport codecs\nimport contextlib\nimport hashlib\nimport logging\nimport os\nimport posixpath\nimport sys\nimport zipimport\n\nfrom . import DistlibException, resources\nfrom .compat import StringIO\nfrom .version import get_scheme, UnsupportedVersionError\nfrom .metadata import (Metadata, METADATA_FILENAME, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME)\nfrom .util import (parse_requirement, cached_property, parse_name_and_version, read_exports, write_exports, CSVReader,\n                   CSVWriter)\n\n__all__ = [\n    'Distribution', 'BaseInstalledDistribution', 'InstalledDistribution', 'EggInfoDistribution', 'DistributionPath'\n]\n\nlogger = logging.getLogger(__name__)\n\nEXPORTS_FILENAME = 'pydist-exports.json'\nCOMMANDS_FILENAME = 'pydist-commands.json'\n\nDIST_FILES = ('INSTALLER', METADATA_FILENAME, 'RECORD', 'REQUESTED', 'RESOURCES', EXPORTS_FILENAME, 'SHARED')\n\nDISTINFO_EXT = '.dist-info'\n\n\nclass _Cache(object):\n    \"\"\"\n    A simple cache mapping names and .dist-info paths to distributions\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialise an instance. There is normally one for each DistributionPath.\n        \"\"\"\n        self.name = {}\n        self.path = {}\n        self.generated = False\n\n    def clear(self):\n        \"\"\"\n        Clear the cache, setting it to its initial state.\n        \"\"\"\n        self.name.clear()\n        self.path.clear()\n        self.generated = False\n\n    def add(self, dist):\n        \"\"\"\n        Add a distribution to the cache.\n        :param dist: The distribution to add.\n        \"\"\"\n        if dist.path not in self.path:\n            self.path[dist.path] = dist\n            self.name.setdefault(dist.key, []).append(dist)\n\n\nclass DistributionPath(object):\n    \"\"\"\n    Represents a set of distributions installed on a path (typically sys.path).\n    \"\"\"\n\n    def __init__(self, path=None, include_egg=False):\n        \"\"\"\n        Create an instance from a path, optionally including legacy (distutils/\n        setuptools/distribute) distributions.\n        :param path: The path to use, as a list of directories. If not specified,\n                     sys.path is used.\n        :param include_egg: If True, this instance will look for and return legacy\n                            distributions as well as those based on PEP 376.\n        \"\"\"\n        if path is None:\n            path = sys.path\n        self.path = path\n        self._include_dist = True\n        self._include_egg = include_egg\n\n        self._cache = _Cache()\n        self._cache_egg = _Cache()\n        self._cache_enabled = True\n        self._scheme = get_scheme('default')\n\n    def _get_cache_enabled(self):\n        return self._cache_enabled\n\n    def _set_cache_enabled(self, value):\n        self._cache_enabled = value\n\n    cache_enabled = property(_get_cache_enabled, _set_cache_enabled)\n\n    def clear_cache(self):\n        \"\"\"\n        Clears the internal cache.\n        \"\"\"\n        self._cache.clear()\n        self._cache_egg.clear()\n\n    def _yield_distributions(self):\n        \"\"\"\n        Yield .dist-info and/or .egg(-info) distributions.\n        \"\"\"\n        # We need to check if we've seen some resources already, because on\n        # some Linux systems (e.g. some Debian/Ubuntu variants) there are\n        # symlinks which alias other files in the environment.\n        seen = set()\n        for path in self.path:\n            finder = resources.finder_for_path(path)\n            if finder is None:\n                continue\n            r = finder.find('')\n            if not r or not r.is_container:\n                continue\n            rset = sorted(r.resources)\n            for entry in rset:\n                r = finder.find(entry)\n                if not r or r.path in seen:\n                    continue\n                try:\n                    if self._include_dist and entry.endswith(DISTINFO_EXT):\n                        possible_filenames = [METADATA_FILENAME, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME]\n                        for metadata_filename in possible_filenames:\n                            metadata_path = posixpath.join(entry, metadata_filename)\n                            pydist = finder.find(metadata_path)\n                            if pydist:\n                                break\n                        else:\n                            continue\n\n                        with contextlib.closing(pydist.as_stream()) as stream:\n                            metadata = Metadata(fileobj=stream, scheme='legacy')\n                        logger.debug('Found %s', r.path)\n                        seen.add(r.path)\n                        yield new_dist_class(r.path, metadata=metadata, env=self)\n                    elif self._include_egg and entry.endswith(('.egg-info', '.egg')):\n                        logger.debug('Found %s', r.path)\n                        seen.add(r.path)\n                        yield old_dist_class(r.path, self)\n                except Exception as e:\n                    msg = 'Unable to read distribution at %s, perhaps due to bad metadata: %s'\n                    logger.warning(msg, r.path, e)\n                    import warnings\n                    warnings.warn(msg % (r.path, e), stacklevel=2)\n\n    def _generate_cache(self):\n        \"\"\"\n        Scan the path for distributions and populate the cache with\n        those that are found.\n        \"\"\"\n        gen_dist = not self._cache.generated\n        gen_egg = self._include_egg and not self._cache_egg.generated\n        if gen_dist or gen_egg:\n            for dist in self._yield_distributions():\n                if isinstance(dist, InstalledDistribution):\n                    self._cache.add(dist)\n                else:\n                    self._cache_egg.add(dist)\n\n            if gen_dist:\n                self._cache.generated = True\n            if gen_egg:\n                self._cache_egg.generated = True\n\n    @classmethod\n    def distinfo_dirname(cls, name, version):\n        \"\"\"\n        The *name* and *version* parameters are converted into their\n        filename-escaped form, i.e. any ``'-'`` characters are replaced\n        with ``'_'`` other than the one in ``'dist-info'`` and the one\n        separating the name from the version number.\n\n        :parameter name: is converted to a standard distribution name by replacing\n                         any runs of non- alphanumeric characters with a single\n                         ``'-'``.\n        :type name: string\n        :parameter version: is converted to a standard version string. Spaces\n                            become dots, and all other non-alphanumeric characters\n                            (except dots) become dashes, with runs of multiple\n                            dashes condensed to a single dash.\n        :type version: string\n        :returns: directory name\n        :rtype: string\"\"\"\n        name = name.replace('-', '_')\n        return '-'.join([name, version]) + DISTINFO_EXT\n\n    def get_distributions(self):\n        \"\"\"\n        Provides an iterator that looks for distributions and returns\n        :class:`InstalledDistribution` or\n        :class:`EggInfoDistribution` instances for each one of them.\n\n        :rtype: iterator of :class:`InstalledDistribution` and\n                :class:`EggInfoDistribution` instances\n        \"\"\"\n        if not self._cache_enabled:\n            for dist in self._yield_distributions():\n                yield dist\n        else:\n            self._generate_cache()\n\n            for dist in self._cache.path.values():\n                yield dist\n\n            if self._include_egg:\n                for dist in self._cache_egg.path.values():\n                    yield dist\n\n    def get_distribution(self, name):\n        \"\"\"\n        Looks for a named distribution on the path.\n\n        This function only returns the first result found, as no more than one\n        value is expected. If nothing is found, ``None`` is returned.\n\n        :rtype: :class:`InstalledDistribution`, :class:`EggInfoDistribution`\n                or ``None``\n        \"\"\"\n        result = None\n        name = name.lower()\n        if not self._cache_enabled:\n            for dist in self._yield_distributions():\n                if dist.key == name:\n                    result = dist\n                    break\n        else:\n            self._generate_cache()\n\n            if name in self._cache.name:\n                result = self._cache.name[name][0]\n            elif self._include_egg and name in self._cache_egg.name:\n                result = self._cache_egg.name[name][0]\n        return result\n\n    def provides_distribution(self, name, version=None):\n        \"\"\"\n        Iterates over all distributions to find which distributions provide *name*.\n        If a *version* is provided, it will be used to filter the results.\n\n        This function only returns the first result found, since no more than\n        one values are expected. If the directory is not found, returns ``None``.\n\n        :parameter version: a version specifier that indicates the version\n                            required, conforming to the format in ``PEP-345``\n\n        :type name: string\n        :type version: string\n        \"\"\"\n        matcher = None\n        if version is not None:\n            try:\n                matcher = self._scheme.matcher('%s (%s)' % (name, version))\n            except ValueError:\n                raise DistlibException('invalid name or version: %r, %r' % (name, version))\n\n        for dist in self.get_distributions():\n            # We hit a problem on Travis where enum34 was installed and doesn't\n            # have a provides attribute ...\n            if not hasattr(dist, 'provides'):\n                logger.debug('No \"provides\": %s', dist)\n            else:\n                provided = dist.provides\n\n                for p in provided:\n                    p_name, p_ver = parse_name_and_version(p)\n                    if matcher is None:\n                        if p_name == name:\n                            yield dist\n                            break\n                    else:\n                        if p_name == name and matcher.match(p_ver):\n                            yield dist\n                            break\n\n    def get_file_path(self, name, relative_path):\n        \"\"\"\n        Return the path to a resource file.\n        \"\"\"\n        dist = self.get_distribution(name)\n        if dist is None:\n            raise LookupError('no distribution named %r found' % name)\n        return dist.get_resource_path(relative_path)\n\n    def get_exported_entries(self, category, name=None):\n        \"\"\"\n        Return all of the exported entries in a particular category.\n\n        :param category: The category to search for entries.\n        :param name: If specified, only entries with that name are returned.\n        \"\"\"\n        for dist in self.get_distributions():\n            r = dist.exports\n            if category in r:\n                d = r[category]\n                if name is not None:\n                    if name in d:\n                        yield d[name]\n                else:\n                    for v in d.values():\n                        yield v\n\n\nclass Distribution(object):\n    \"\"\"\n    A base class for distributions, whether installed or from indexes.\n    Either way, it must have some metadata, so that's all that's needed\n    for construction.\n    \"\"\"\n\n    build_time_dependency = False\n    \"\"\"\n    Set to True if it's known to be only a build-time dependency (i.e.\n    not needed after installation).\n    \"\"\"\n\n    requested = False\n    \"\"\"A boolean that indicates whether the ``REQUESTED`` metadata file is\n    present (in other words, whether the package was installed by user\n    request or it was installed as a dependency).\"\"\"\n\n    def __init__(self, metadata):\n        \"\"\"\n        Initialise an instance.\n        :param metadata: The instance of :class:`Metadata` describing this\n        distribution.\n        \"\"\"\n        self.metadata = metadata\n        self.name = metadata.name\n        self.key = self.name.lower()  # for case-insensitive comparisons\n        self.version = metadata.version\n        self.locator = None\n        self.digest = None\n        self.extras = None  # additional features requested\n        self.context = None  # environment marker overrides\n        self.download_urls = set()\n        self.digests = {}\n\n    @property\n    def source_url(self):\n        \"\"\"\n        The source archive download URL for this distribution.\n        \"\"\"\n        return self.metadata.source_url\n\n    download_url = source_url  # Backward compatibility\n\n    @property\n    def name_and_version(self):\n        \"\"\"\n        A utility property which displays the name and version in parentheses.\n        \"\"\"\n        return '%s (%s)' % (self.name, self.version)\n\n    @property\n    def provides(self):\n        \"\"\"\n        A set of distribution names and versions provided by this distribution.\n        :return: A set of \"name (version)\" strings.\n        \"\"\"\n        plist = self.metadata.provides\n        s = '%s (%s)' % (self.name, self.version)\n        if s not in plist:\n            plist.append(s)\n        return plist\n\n    def _get_requirements(self, req_attr):\n        md = self.metadata\n        reqts = getattr(md, req_attr)\n        logger.debug('%s: got requirements %r from metadata: %r', self.name, req_attr, reqts)\n        return set(md.get_requirements(reqts, extras=self.extras, env=self.context))\n\n    @property\n    def run_requires(self):\n        return self._get_requirements('run_requires')\n\n    @property\n    def meta_requires(self):\n        return self._get_requirements('meta_requires')\n\n    @property\n    def build_requires(self):\n        return self._get_requirements('build_requires')\n\n    @property\n    def test_requires(self):\n        return self._get_requirements('test_requires')\n\n    @property\n    def dev_requires(self):\n        return self._get_requirements('dev_requires')\n\n    def matches_requirement(self, req):\n        \"\"\"\n        Say if this instance matches (fulfills) a requirement.\n        :param req: The requirement to match.\n        :rtype req: str\n        :return: True if it matches, else False.\n        \"\"\"\n        # Requirement may contain extras - parse to lose those\n        # from what's passed to the matcher\n        r = parse_requirement(req)\n        scheme = get_scheme(self.metadata.scheme)\n        try:\n            matcher = scheme.matcher(r.requirement)\n        except UnsupportedVersionError:\n            # XXX compat-mode if cannot read the version\n            logger.warning('could not read version %r - using name only', req)\n            name = req.split()[0]\n            matcher = scheme.matcher(name)\n\n        name = matcher.key  # case-insensitive\n\n        result = False\n        for p in self.provides:\n            p_name, p_ver = parse_name_and_version(p)\n            if p_name != name:\n                continue\n            try:\n                result = matcher.match(p_ver)\n                break\n            except UnsupportedVersionError:\n                pass\n        return result\n\n    def __repr__(self):\n        \"\"\"\n        Return a textual representation of this instance,\n        \"\"\"\n        if self.source_url:\n            suffix = ' [%s]' % self.source_url\n        else:\n            suffix = ''\n        return '<Distribution %s (%s)%s>' % (self.name, self.version, suffix)\n\n    def __eq__(self, other):\n        \"\"\"\n        See if this distribution is the same as another.\n        :param other: The distribution to compare with. To be equal to one\n                      another. distributions must have the same type, name,\n                      version and source_url.\n        :return: True if it is the same, else False.\n        \"\"\"\n        if type(other) is not type(self):\n            result = False\n        else:\n            result = (self.name == other.name and self.version == other.version and self.source_url == other.source_url)\n        return result\n\n    def __hash__(self):\n        \"\"\"\n        Compute hash in a way which matches the equality test.\n        \"\"\"\n        return hash(self.name) + hash(self.version) + hash(self.source_url)\n\n\nclass BaseInstalledDistribution(Distribution):\n    \"\"\"\n    This is the base class for installed distributions (whether PEP 376 or\n    legacy).\n    \"\"\"\n\n    hasher = None\n\n    def __init__(self, metadata, path, env=None):\n        \"\"\"\n        Initialise an instance.\n        :param metadata: An instance of :class:`Metadata` which describes the\n                         distribution. This will normally have been initialised\n                         from a metadata file in the ``path``.\n        :param path:     The path of the ``.dist-info`` or ``.egg-info``\n                         directory for the distribution.\n        :param env:      This is normally the :class:`DistributionPath`\n                         instance where this distribution was found.\n        \"\"\"\n        super(BaseInstalledDistribution, self).__init__(metadata)\n        self.path = path\n        self.dist_path = env\n\n    def get_hash(self, data, hasher=None):\n        \"\"\"\n        Get the hash of some data, using a particular hash algorithm, if\n        specified.\n\n        :param data: The data to be hashed.\n        :type data: bytes\n        :param hasher: The name of a hash implementation, supported by hashlib,\n                       or ``None``. Examples of valid values are ``'sha1'``,\n                       ``'sha224'``, ``'sha384'``, '``sha256'``, ``'md5'`` and\n                       ``'sha512'``. If no hasher is specified, the ``hasher``\n                       attribute of the :class:`InstalledDistribution` instance\n                       is used. If the hasher is determined to be ``None``, MD5\n                       is used as the hashing algorithm.\n        :returns: The hash of the data. If a hasher was explicitly specified,\n                  the returned hash will be prefixed with the specified hasher\n                  followed by '='.\n        :rtype: str\n        \"\"\"\n        if hasher is None:\n            hasher = self.hasher\n        if hasher is None:\n            hasher = hashlib.md5\n            prefix = ''\n        else:\n            hasher = getattr(hashlib, hasher)\n            prefix = '%s=' % self.hasher\n        digest = hasher(data).digest()\n        digest = base64.urlsafe_b64encode(digest).rstrip(b'=').decode('ascii')\n        return '%s%s' % (prefix, digest)\n\n\nclass InstalledDistribution(BaseInstalledDistribution):\n    \"\"\"\n    Created with the *path* of the ``.dist-info`` directory provided to the\n    constructor. It reads the metadata contained in ``pydist.json`` when it is\n    instantiated., or uses a passed in Metadata instance (useful for when\n    dry-run mode is being used).\n    \"\"\"\n\n    hasher = 'sha256'\n\n    def __init__(self, path, metadata=None, env=None):\n        self.modules = []\n        self.finder = finder = resources.finder_for_path(path)\n        if finder is None:\n            raise ValueError('finder unavailable for %s' % path)\n        if env and env._cache_enabled and path in env._cache.path:\n            metadata = env._cache.path[path].metadata\n        elif metadata is None:\n            r = finder.find(METADATA_FILENAME)\n            # Temporary - for Wheel 0.23 support\n            if r is None:\n                r = finder.find(WHEEL_METADATA_FILENAME)\n            # Temporary - for legacy support\n            if r is None:\n                r = finder.find(LEGACY_METADATA_FILENAME)\n            if r is None:\n                raise ValueError('no %s found in %s' % (METADATA_FILENAME, path))\n            with contextlib.closing(r.as_stream()) as stream:\n                metadata = Metadata(fileobj=stream, scheme='legacy')\n\n        super(InstalledDistribution, self).__init__(metadata, path, env)\n\n        if env and env._cache_enabled:\n            env._cache.add(self)\n\n        r = finder.find('REQUESTED')\n        self.requested = r is not None\n        p = os.path.join(path, 'top_level.txt')\n        if os.path.exists(p):\n            with open(p, 'rb') as f:\n                data = f.read().decode('utf-8')\n            self.modules = data.splitlines()\n\n    def __repr__(self):\n        return '<InstalledDistribution %r %s at %r>' % (self.name, self.version, self.path)\n\n    def __str__(self):\n        return \"%s %s\" % (self.name, self.version)\n\n    def _get_records(self):\n        \"\"\"\n        Get the list of installed files for the distribution\n        :return: A list of tuples of path, hash and size. Note that hash and\n                 size might be ``None`` for some entries. The path is exactly\n                 as stored in the file (which is as in PEP 376).\n        \"\"\"\n        results = []\n        r = self.get_distinfo_resource('RECORD')\n        with contextlib.closing(r.as_stream()) as stream:\n            with CSVReader(stream=stream) as record_reader:\n                # Base location is parent dir of .dist-info dir\n                # base_location = os.path.dirname(self.path)\n                # base_location = os.path.abspath(base_location)\n                for row in record_reader:\n                    missing = [None for i in range(len(row), 3)]\n                    path, checksum, size = row + missing\n                    # if not os.path.isabs(path):\n                    #     path = path.replace('/', os.sep)\n                    #     path = os.path.join(base_location, path)\n                    results.append((path, checksum, size))\n        return results\n\n    @cached_property\n    def exports(self):\n        \"\"\"\n        Return the information exported by this distribution.\n        :return: A dictionary of exports, mapping an export category to a dict\n                 of :class:`ExportEntry` instances describing the individual\n                 export entries, and keyed by name.\n        \"\"\"\n        result = {}\n        r = self.get_distinfo_resource(EXPORTS_FILENAME)\n        if r:\n            result = self.read_exports()\n        return result\n\n    def read_exports(self):\n        \"\"\"\n        Read exports data from a file in .ini format.\n\n        :return: A dictionary of exports, mapping an export category to a list\n                 of :class:`ExportEntry` instances describing the individual\n                 export entries.\n        \"\"\"\n        result = {}\n        r = self.get_distinfo_resource(EXPORTS_FILENAME)\n        if r:\n            with contextlib.closing(r.as_stream()) as stream:\n                result = read_exports(stream)\n        return result\n\n    def write_exports(self, exports):\n        \"\"\"\n        Write a dictionary of exports to a file in .ini format.\n        :param exports: A dictionary of exports, mapping an export category to\n                        a list of :class:`ExportEntry` instances describing the\n                        individual export entries.\n        \"\"\"\n        rf = self.get_distinfo_file(EXPORTS_FILENAME)\n        with open(rf, 'w') as f:\n            write_exports(exports, f)\n\n    def get_resource_path(self, relative_path):\n        \"\"\"\n        NOTE: This API may change in the future.\n\n        Return the absolute path to a resource file with the given relative\n        path.\n\n        :param relative_path: The path, relative to .dist-info, of the resource\n                              of interest.\n        :return: The absolute path where the resource is to be found.\n        \"\"\"\n        r = self.get_distinfo_resource('RESOURCES')\n        with contextlib.closing(r.as_stream()) as stream:\n            with CSVReader(stream=stream) as resources_reader:\n                for relative, destination in resources_reader:\n                    if relative == relative_path:\n                        return destination\n        raise KeyError('no resource file with relative path %r '\n                       'is installed' % relative_path)\n\n    def list_installed_files(self):\n        \"\"\"\n        Iterates over the ``RECORD`` entries and returns a tuple\n        ``(path, hash, size)`` for each line.\n\n        :returns: iterator of (path, hash, size)\n        \"\"\"\n        for result in self._get_records():\n            yield result\n\n    def write_installed_files(self, paths, prefix, dry_run=False):\n        \"\"\"\n        Writes the ``RECORD`` file, using the ``paths`` iterable passed in. Any\n        existing ``RECORD`` file is silently overwritten.\n\n        prefix is used to determine when to write absolute paths.\n        \"\"\"\n        prefix = os.path.join(prefix, '')\n        base = os.path.dirname(self.path)\n        base_under_prefix = base.startswith(prefix)\n        base = os.path.join(base, '')\n        record_path = self.get_distinfo_file('RECORD')\n        logger.info('creating %s', record_path)\n        if dry_run:\n            return None\n        with CSVWriter(record_path) as writer:\n            for path in paths:\n                if os.path.isdir(path) or path.endswith(('.pyc', '.pyo')):\n                    # do not put size and hash, as in PEP-376\n                    hash_value = size = ''\n                else:\n                    size = '%d' % os.path.getsize(path)\n                    with open(path, 'rb') as fp:\n                        hash_value = self.get_hash(fp.read())\n                if path.startswith(base) or (base_under_prefix and path.startswith(prefix)):\n                    path = os.path.relpath(path, base)\n                writer.writerow((path, hash_value, size))\n\n            # add the RECORD file itself\n            if record_path.startswith(base):\n                record_path = os.path.relpath(record_path, base)\n            writer.writerow((record_path, '', ''))\n        return record_path\n\n    def check_installed_files(self):\n        \"\"\"\n        Checks that the hashes and sizes of the files in ``RECORD`` are\n        matched by the files themselves. Returns a (possibly empty) list of\n        mismatches. Each entry in the mismatch list will be a tuple consisting\n        of the path, 'exists', 'size' or 'hash' according to what didn't match\n        (existence is checked first, then size, then hash), the expected\n        value and the actual value.\n        \"\"\"\n        mismatches = []\n        base = os.path.dirname(self.path)\n        record_path = self.get_distinfo_file('RECORD')\n        for path, hash_value, size in self.list_installed_files():\n            if not os.path.isabs(path):\n                path = os.path.join(base, path)\n            if path == record_path:\n                continue\n            if not os.path.exists(path):\n                mismatches.append((path, 'exists', True, False))\n            elif os.path.isfile(path):\n                actual_size = str(os.path.getsize(path))\n                if size and actual_size != size:\n                    mismatches.append((path, 'size', size, actual_size))\n                elif hash_value:\n                    if '=' in hash_value:\n                        hasher = hash_value.split('=', 1)[0]\n                    else:\n                        hasher = None\n\n                    with open(path, 'rb') as f:\n                        actual_hash = self.get_hash(f.read(), hasher)\n                        if actual_hash != hash_value:\n                            mismatches.append((path, 'hash', hash_value, actual_hash))\n        return mismatches\n\n    @cached_property\n    def shared_locations(self):\n        \"\"\"\n        A dictionary of shared locations whose keys are in the set 'prefix',\n        'purelib', 'platlib', 'scripts', 'headers', 'data' and 'namespace'.\n        The corresponding value is the absolute path of that category for\n        this distribution, and takes into account any paths selected by the\n        user at installation time (e.g. via command-line arguments). In the\n        case of the 'namespace' key, this would be a list of absolute paths\n        for the roots of namespace packages in this distribution.\n\n        The first time this property is accessed, the relevant information is\n        read from the SHARED file in the .dist-info directory.\n        \"\"\"\n        result = {}\n        shared_path = os.path.join(self.path, 'SHARED')\n        if os.path.isfile(shared_path):\n            with codecs.open(shared_path, 'r', encoding='utf-8') as f:\n                lines = f.read().splitlines()\n            for line in lines:\n                key, value = line.split('=', 1)\n                if key == 'namespace':\n                    result.setdefault(key, []).append(value)\n                else:\n                    result[key] = value\n        return result\n\n    def write_shared_locations(self, paths, dry_run=False):\n        \"\"\"\n        Write shared location information to the SHARED file in .dist-info.\n        :param paths: A dictionary as described in the documentation for\n        :meth:`shared_locations`.\n        :param dry_run: If True, the action is logged but no file is actually\n                        written.\n        :return: The path of the file written to.\n        \"\"\"\n        shared_path = os.path.join(self.path, 'SHARED')\n        logger.info('creating %s', shared_path)\n        if dry_run:\n            return None\n        lines = []\n        for key in ('prefix', 'lib', 'headers', 'scripts', 'data'):\n            path = paths[key]\n            if os.path.isdir(paths[key]):\n                lines.append('%s=%s' % (key, path))\n        for ns in paths.get('namespace', ()):\n            lines.append('namespace=%s' % ns)\n\n        with codecs.open(shared_path, 'w', encoding='utf-8') as f:\n            f.write('\\n'.join(lines))\n        return shared_path\n\n    def get_distinfo_resource(self, path):\n        if path not in DIST_FILES:\n            raise DistlibException('invalid path for a dist-info file: '\n                                   '%r at %r' % (path, self.path))\n        finder = resources.finder_for_path(self.path)\n        if finder is None:\n            raise DistlibException('Unable to get a finder for %s' % self.path)\n        return finder.find(path)\n\n    def get_distinfo_file(self, path):\n        \"\"\"\n        Returns a path located under the ``.dist-info`` directory. Returns a\n        string representing the path.\n\n        :parameter path: a ``'/'``-separated path relative to the\n                         ``.dist-info`` directory or an absolute path;\n                         If *path* is an absolute path and doesn't start\n                         with the ``.dist-info`` directory path,\n                         a :class:`DistlibException` is raised\n        :type path: str\n        :rtype: str\n        \"\"\"\n        # Check if it is an absolute path  # XXX use relpath, add tests\n        if path.find(os.sep) >= 0:\n            # it's an absolute path?\n            distinfo_dirname, path = path.split(os.sep)[-2:]\n            if distinfo_dirname != self.path.split(os.sep)[-1]:\n                raise DistlibException('dist-info file %r does not belong to the %r %s '\n                                       'distribution' % (path, self.name, self.version))\n\n        # The file must be relative\n        if path not in DIST_FILES:\n            raise DistlibException('invalid path for a dist-info file: '\n                                   '%r at %r' % (path, self.path))\n\n        return os.path.join(self.path, path)\n\n    def list_distinfo_files(self):\n        \"\"\"\n        Iterates over the ``RECORD`` entries and returns paths for each line if\n        the path is pointing to a file located in the ``.dist-info`` directory\n        or one of its subdirectories.\n\n        :returns: iterator of paths\n        \"\"\"\n        base = os.path.dirname(self.path)\n        for path, checksum, size in self._get_records():\n            # XXX add separator or use real relpath algo\n            if not os.path.isabs(path):\n                path = os.path.join(base, path)\n            if path.startswith(self.path):\n                yield path\n\n    def __eq__(self, other):\n        return (isinstance(other, InstalledDistribution) and self.path == other.path)\n\n    # See http://docs.python.org/reference/datamodel#object.__hash__\n    __hash__ = object.__hash__\n\n\nclass EggInfoDistribution(BaseInstalledDistribution):\n    \"\"\"Created with the *path* of the ``.egg-info`` directory or file provided\n    to the constructor. It reads the metadata contained in the file itself, or\n    if the given path happens to be a directory, the metadata is read from the\n    file ``PKG-INFO`` under that directory.\"\"\"\n\n    requested = True  # as we have no way of knowing, assume it was\n    shared_locations = {}\n\n    def __init__(self, path, env=None):\n\n        def set_name_and_version(s, n, v):\n            s.name = n\n            s.key = n.lower()  # for case-insensitive comparisons\n            s.version = v\n\n        self.path = path\n        self.dist_path = env\n        if env and env._cache_enabled and path in env._cache_egg.path:\n            metadata = env._cache_egg.path[path].metadata\n            set_name_and_version(self, metadata.name, metadata.version)\n        else:\n            metadata = self._get_metadata(path)\n\n            # Need to be set before caching\n            set_name_and_version(self, metadata.name, metadata.version)\n\n            if env and env._cache_enabled:\n                env._cache_egg.add(self)\n        super(EggInfoDistribution, self).__init__(metadata, path, env)\n\n    def _get_metadata(self, path):\n        requires = None\n\n        def parse_requires_data(data):\n            \"\"\"Create a list of dependencies from a requires.txt file.\n\n            *data*: the contents of a setuptools-produced requires.txt file.\n            \"\"\"\n            reqs = []\n            lines = data.splitlines()\n            for line in lines:\n                line = line.strip()\n                # sectioned files have bare newlines (separating sections)\n                if not line:  # pragma: no cover\n                    continue\n                if line.startswith('['):  # pragma: no cover\n                    logger.warning('Unexpected line: quitting requirement scan: %r', line)\n                    break\n                r = parse_requirement(line)\n                if not r:  # pragma: no cover\n                    logger.warning('Not recognised as a requirement: %r', line)\n                    continue\n                if r.extras:  # pragma: no cover\n                    logger.warning('extra requirements in requires.txt are '\n                                   'not supported')\n                if not r.constraints:\n                    reqs.append(r.name)\n                else:\n                    cons = ', '.join('%s%s' % c for c in r.constraints)\n                    reqs.append('%s (%s)' % (r.name, cons))\n            return reqs\n\n        def parse_requires_path(req_path):\n            \"\"\"Create a list of dependencies from a requires.txt file.\n\n            *req_path*: the path to a setuptools-produced requires.txt file.\n            \"\"\"\n\n            reqs = []\n            try:\n                with codecs.open(req_path, 'r', 'utf-8') as fp:\n                    reqs = parse_requires_data(fp.read())\n            except IOError:\n                pass\n            return reqs\n\n        tl_path = tl_data = None\n        if path.endswith('.egg'):\n            if os.path.isdir(path):\n                p = os.path.join(path, 'EGG-INFO')\n                meta_path = os.path.join(p, 'PKG-INFO')\n                metadata = Metadata(path=meta_path, scheme='legacy')\n                req_path = os.path.join(p, 'requires.txt')\n                tl_path = os.path.join(p, 'top_level.txt')\n                requires = parse_requires_path(req_path)\n            else:\n                # FIXME handle the case where zipfile is not available\n                zipf = zipimport.zipimporter(path)\n                fileobj = StringIO(zipf.get_data('EGG-INFO/PKG-INFO').decode('utf8'))\n                metadata = Metadata(fileobj=fileobj, scheme='legacy')\n                try:\n                    data = zipf.get_data('EGG-INFO/requires.txt')\n                    tl_data = zipf.get_data('EGG-INFO/top_level.txt').decode('utf-8')\n                    requires = parse_requires_data(data.decode('utf-8'))\n                except IOError:\n                    requires = None\n        elif path.endswith('.egg-info'):\n            if os.path.isdir(path):\n                req_path = os.path.join(path, 'requires.txt')\n                requires = parse_requires_path(req_path)\n                path = os.path.join(path, 'PKG-INFO')\n                tl_path = os.path.join(path, 'top_level.txt')\n            metadata = Metadata(path=path, scheme='legacy')\n        else:\n            raise DistlibException('path must end with .egg-info or .egg, '\n                                   'got %r' % path)\n\n        if requires:\n            metadata.add_requirements(requires)\n        # look for top-level modules in top_level.txt, if present\n        if tl_data is None:\n            if tl_path is not None and os.path.exists(tl_path):\n                with open(tl_path, 'rb') as f:\n                    tl_data = f.read().decode('utf-8')\n        if not tl_data:\n            tl_data = []\n        else:\n            tl_data = tl_data.splitlines()\n        self.modules = tl_data\n        return metadata\n\n    def __repr__(self):\n        return '<EggInfoDistribution %r %s at %r>' % (self.name, self.version, self.path)\n\n    def __str__(self):\n        return \"%s %s\" % (self.name, self.version)\n\n    def check_installed_files(self):\n        \"\"\"\n        Checks that the hashes and sizes of the files in ``RECORD`` are\n        matched by the files themselves. Returns a (possibly empty) list of\n        mismatches. Each entry in the mismatch list will be a tuple consisting\n        of the path, 'exists', 'size' or 'hash' according to what didn't match\n        (existence is checked first, then size, then hash), the expected\n        value and the actual value.\n        \"\"\"\n        mismatches = []\n        record_path = os.path.join(self.path, 'installed-files.txt')\n        if os.path.exists(record_path):\n            for path, _, _ in self.list_installed_files():\n                if path == record_path:\n                    continue\n                if not os.path.exists(path):\n                    mismatches.append((path, 'exists', True, False))\n        return mismatches\n\n    def list_installed_files(self):\n        \"\"\"\n        Iterates over the ``installed-files.txt`` entries and returns a tuple\n        ``(path, hash, size)`` for each line.\n\n        :returns: a list of (path, hash, size)\n        \"\"\"\n\n        def _md5(path):\n            f = open(path, 'rb')\n            try:\n                content = f.read()\n            finally:\n                f.close()\n            return hashlib.md5(content).hexdigest()\n\n        def _size(path):\n            return os.stat(path).st_size\n\n        record_path = os.path.join(self.path, 'installed-files.txt')\n        result = []\n        if os.path.exists(record_path):\n            with codecs.open(record_path, 'r', encoding='utf-8') as f:\n                for line in f:\n                    line = line.strip()\n                    p = os.path.normpath(os.path.join(self.path, line))\n                    # \"./\" is present as a marker between installed files\n                    # and installation metadata files\n                    if not os.path.exists(p):\n                        logger.warning('Non-existent file: %s', p)\n                        if p.endswith(('.pyc', '.pyo')):\n                            continue\n                        # otherwise fall through and fail\n                    if not os.path.isdir(p):\n                        result.append((p, _md5(p), _size(p)))\n            result.append((record_path, None, None))\n        return result\n\n    def list_distinfo_files(self, absolute=False):\n        \"\"\"\n        Iterates over the ``installed-files.txt`` entries and returns paths for\n        each line if the path is pointing to a file located in the\n        ``.egg-info`` directory or one of its subdirectories.\n\n        :parameter absolute: If *absolute* is ``True``, each returned path is\n                          transformed into a local absolute path. Otherwise the\n                          raw value from ``installed-files.txt`` is returned.\n        :type absolute: boolean\n        :returns: iterator of paths\n        \"\"\"\n        record_path = os.path.join(self.path, 'installed-files.txt')\n        if os.path.exists(record_path):\n            skip = True\n            with codecs.open(record_path, 'r', encoding='utf-8') as f:\n                for line in f:\n                    line = line.strip()\n                    if line == './':\n                        skip = False\n                        continue\n                    if not skip:\n                        p = os.path.normpath(os.path.join(self.path, line))\n                        if p.startswith(self.path):\n                            if absolute:\n                                yield p\n                            else:\n                                yield line\n\n    def __eq__(self, other):\n        return (isinstance(other, EggInfoDistribution) and self.path == other.path)\n\n    # See http://docs.python.org/reference/datamodel#object.__hash__\n    __hash__ = object.__hash__\n\n\nnew_dist_class = InstalledDistribution\nold_dist_class = EggInfoDistribution\n\n\nclass DependencyGraph(object):\n    \"\"\"\n    Represents a dependency graph between distributions.\n\n    The dependency relationships are stored in an ``adjacency_list`` that maps\n    distributions to a list of ``(other, label)`` tuples where  ``other``\n    is a distribution and the edge is labeled with ``label`` (i.e. the version\n    specifier, if such was provided). Also, for more efficient traversal, for\n    every distribution ``x``, a list of predecessors is kept in\n    ``reverse_list[x]``. An edge from distribution ``a`` to\n    distribution ``b`` means that ``a`` depends on ``b``. If any missing\n    dependencies are found, they are stored in ``missing``, which is a\n    dictionary that maps distributions to a list of requirements that were not\n    provided by any other distributions.\n    \"\"\"\n\n    def __init__(self):\n        self.adjacency_list = {}\n        self.reverse_list = {}\n        self.missing = {}\n\n    def add_distribution(self, distribution):\n        \"\"\"Add the *distribution* to the graph.\n\n        :type distribution: :class:`distutils2.database.InstalledDistribution`\n                            or :class:`distutils2.database.EggInfoDistribution`\n        \"\"\"\n        self.adjacency_list[distribution] = []\n        self.reverse_list[distribution] = []\n        # self.missing[distribution] = []\n\n    def add_edge(self, x, y, label=None):\n        \"\"\"Add an edge from distribution *x* to distribution *y* with the given\n        *label*.\n\n        :type x: :class:`distutils2.database.InstalledDistribution` or\n                 :class:`distutils2.database.EggInfoDistribution`\n        :type y: :class:`distutils2.database.InstalledDistribution` or\n                 :class:`distutils2.database.EggInfoDistribution`\n        :type label: ``str`` or ``None``\n        \"\"\"\n        self.adjacency_list[x].append((y, label))\n        # multiple edges are allowed, so be careful\n        if x not in self.reverse_list[y]:\n            self.reverse_list[y].append(x)\n\n    def add_missing(self, distribution, requirement):\n        \"\"\"\n        Add a missing *requirement* for the given *distribution*.\n\n        :type distribution: :class:`distutils2.database.InstalledDistribution`\n                            or :class:`distutils2.database.EggInfoDistribution`\n        :type requirement: ``str``\n        \"\"\"\n        logger.debug('%s missing %r', distribution, requirement)\n        self.missing.setdefault(distribution, []).append(requirement)\n\n    def _repr_dist(self, dist):\n        return '%s %s' % (dist.name, dist.version)\n\n    def repr_node(self, dist, level=1):\n        \"\"\"Prints only a subgraph\"\"\"\n        output = [self._repr_dist(dist)]\n        for other, label in self.adjacency_list[dist]:\n            dist = self._repr_dist(other)\n            if label is not None:\n                dist = '%s [%s]' % (dist, label)\n            output.append('    ' * level + str(dist))\n            suboutput = self.repr_node(other, level + 1)\n            subs = suboutput.split('\\n')\n            output.extend(subs[1:])\n        return '\\n'.join(output)\n\n    def to_dot(self, f, skip_disconnected=True):\n        \"\"\"Writes a DOT output for the graph to the provided file *f*.\n\n        If *skip_disconnected* is set to ``True``, then all distributions\n        that are not dependent on any other distribution are skipped.\n\n        :type f: has to support ``file``-like operations\n        :type skip_disconnected: ``bool``\n        \"\"\"\n        disconnected = []\n\n        f.write(\"digraph dependencies {\\n\")\n        for dist, adjs in self.adjacency_list.items():\n            if len(adjs) == 0 and not skip_disconnected:\n                disconnected.append(dist)\n            for other, label in adjs:\n                if label is not None:\n                    f.write('\"%s\" -> \"%s\" [label=\"%s\"]\\n' % (dist.name, other.name, label))\n                else:\n                    f.write('\"%s\" -> \"%s\"\\n' % (dist.name, other.name))\n        if not skip_disconnected and len(disconnected) > 0:\n            f.write('subgraph disconnected {\\n')\n            f.write('label = \"Disconnected\"\\n')\n            f.write('bgcolor = red\\n')\n\n            for dist in disconnected:\n                f.write('\"%s\"' % dist.name)\n                f.write('\\n')\n            f.write('}\\n')\n        f.write('}\\n')\n\n    def topological_sort(self):\n        \"\"\"\n        Perform a topological sort of the graph.\n        :return: A tuple, the first element of which is a topologically sorted\n                 list of distributions, and the second element of which is a\n                 list of distributions that cannot be sorted because they have\n                 circular dependencies and so form a cycle.\n        \"\"\"\n        result = []\n        # Make a shallow copy of the adjacency list\n        alist = {}\n        for k, v in self.adjacency_list.items():\n            alist[k] = v[:]\n        while True:\n            # See what we can remove in this run\n            to_remove = []\n            for k, v in list(alist.items())[:]:\n                if not v:\n                    to_remove.append(k)\n                    del alist[k]\n            if not to_remove:\n                # What's left in alist (if anything) is a cycle.\n                break\n            # Remove from the adjacency list of others\n            for k, v in alist.items():\n                alist[k] = [(d, r) for d, r in v if d not in to_remove]\n            logger.debug('Moving to result: %s', ['%s (%s)' % (d.name, d.version) for d in to_remove])\n            result.extend(to_remove)\n        return result, list(alist.keys())\n\n    def __repr__(self):\n        \"\"\"Representation of the graph\"\"\"\n        output = []\n        for dist, adjs in self.adjacency_list.items():\n            output.append(self.repr_node(dist))\n        return '\\n'.join(output)\n\n\ndef make_graph(dists, scheme='default'):\n    \"\"\"Makes a dependency graph from the given distributions.\n\n    :parameter dists: a list of distributions\n    :type dists: list of :class:`distutils2.database.InstalledDistribution` and\n                 :class:`distutils2.database.EggInfoDistribution` instances\n    :rtype: a :class:`DependencyGraph` instance\n    \"\"\"\n    scheme = get_scheme(scheme)\n    graph = DependencyGraph()\n    provided = {}  # maps names to lists of (version, dist) tuples\n\n    # first, build the graph and find out what's provided\n    for dist in dists:\n        graph.add_distribution(dist)\n\n        for p in dist.provides:\n            name, version = parse_name_and_version(p)\n            logger.debug('Add to provided: %s, %s, %s', name, version, dist)\n            provided.setdefault(name, []).append((version, dist))\n\n    # now make the edges\n    for dist in dists:\n        requires = (dist.run_requires | dist.meta_requires | dist.build_requires | dist.dev_requires)\n        for req in requires:\n            try:\n                matcher = scheme.matcher(req)\n            except UnsupportedVersionError:\n                # XXX compat-mode if cannot read the version\n                logger.warning('could not read version %r - using name only', req)\n                name = req.split()[0]\n                matcher = scheme.matcher(name)\n\n            name = matcher.key  # case-insensitive\n\n            matched = False\n            if name in provided:\n                for version, provider in provided[name]:\n                    try:\n                        match = matcher.match(version)\n                    except UnsupportedVersionError:\n                        match = False\n\n                    if match:\n                        graph.add_edge(dist, provider, req)\n                        matched = True\n                        break\n            if not matched:\n                graph.add_missing(dist, req)\n    return graph\n\n\ndef get_dependent_dists(dists, dist):\n    \"\"\"Recursively generate a list of distributions from *dists* that are\n    dependent on *dist*.\n\n    :param dists: a list of distributions\n    :param dist: a distribution, member of *dists* for which we are interested\n    \"\"\"\n    if dist not in dists:\n        raise DistlibException('given distribution %r is not a member '\n                               'of the list' % dist.name)\n    graph = make_graph(dists)\n\n    dep = [dist]  # dependent distributions\n    todo = graph.reverse_list[dist]  # list of nodes we should inspect\n\n    while todo:\n        d = todo.pop()\n        dep.append(d)\n        for succ in graph.reverse_list[d]:\n            if succ not in dep:\n                todo.append(succ)\n\n    dep.pop(0)  # remove dist from dep, was there to prevent infinite loops\n    return dep\n\n\ndef get_required_dists(dists, dist):\n    \"\"\"Recursively generate a list of distributions from *dists* that are\n    required by *dist*.\n\n    :param dists: a list of distributions\n    :param dist: a distribution, member of *dists* for which we are interested\n                 in finding the dependencies.\n    \"\"\"\n    if dist not in dists:\n        raise DistlibException('given distribution %r is not a member '\n                               'of the list' % dist.name)\n    graph = make_graph(dists)\n\n    req = set()  # required distributions\n    todo = graph.adjacency_list[dist]  # list of nodes we should inspect\n    seen = set(t[0] for t in todo)  # already added to todo\n\n    while todo:\n        d = todo.pop()[0]\n        req.add(d)\n        pred_list = graph.adjacency_list[d]\n        for pred in pred_list:\n            d = pred[0]\n            if d not in req and d not in seen:\n                seen.add(d)\n                todo.append(pred)\n    return req\n\n\ndef make_dist(name, version, **kwargs):\n    \"\"\"\n    A convenience method for making a dist given just a name and version.\n    \"\"\"\n    summary = kwargs.pop('summary', 'Placeholder for summary')\n    md = Metadata(**kwargs)\n    md.name = name\n    md.version = version\n    md.summary = summary or 'Placeholder for summary'\n    return Distribution(md)\n", "distlib/metadata.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012 The Python Software Foundation.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"Implementation of the Metadata for Python packages PEPs.\n\nSupports all metadata formats (1.0, 1.1, 1.2, 1.3/2.1 and 2.2).\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport codecs\nfrom email import message_from_file\nimport json\nimport logging\nimport re\n\nfrom . import DistlibException, __version__\nfrom .compat import StringIO, string_types, text_type\nfrom .markers import interpret\nfrom .util import extract_by_key, get_extras\nfrom .version import get_scheme, PEP440_VERSION_RE\n\nlogger = logging.getLogger(__name__)\n\n\nclass MetadataMissingError(DistlibException):\n    \"\"\"A required metadata is missing\"\"\"\n\n\nclass MetadataConflictError(DistlibException):\n    \"\"\"Attempt to read or write metadata fields that are conflictual.\"\"\"\n\n\nclass MetadataUnrecognizedVersionError(DistlibException):\n    \"\"\"Unknown metadata version number.\"\"\"\n\n\nclass MetadataInvalidError(DistlibException):\n    \"\"\"A metadata value is invalid\"\"\"\n\n\n# public API of this module\n__all__ = ['Metadata', 'PKG_INFO_ENCODING', 'PKG_INFO_PREFERRED_VERSION']\n\n# Encoding used for the PKG-INFO files\nPKG_INFO_ENCODING = 'utf-8'\n\n# preferred version. Hopefully will be changed\n# to 1.2 once PEP 345 is supported everywhere\nPKG_INFO_PREFERRED_VERSION = '1.1'\n\n_LINE_PREFIX_1_2 = re.compile('\\n       \\\\|')\n_LINE_PREFIX_PRE_1_2 = re.compile('\\n        ')\n_241_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Summary', 'Description', 'Keywords', 'Home-page',\n               'Author', 'Author-email', 'License')\n\n_314_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',\n               'Keywords', 'Home-page', 'Author', 'Author-email', 'License', 'Classifier', 'Download-URL', 'Obsoletes',\n               'Provides', 'Requires')\n\n_314_MARKERS = ('Obsoletes', 'Provides', 'Requires', 'Classifier', 'Download-URL')\n\n_345_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',\n               'Keywords', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License',\n               'Classifier', 'Download-URL', 'Obsoletes-Dist', 'Project-URL', 'Provides-Dist', 'Requires-Dist',\n               'Requires-Python', 'Requires-External')\n\n_345_MARKERS = ('Provides-Dist', 'Requires-Dist', 'Requires-Python', 'Obsoletes-Dist', 'Requires-External',\n                'Maintainer', 'Maintainer-email', 'Project-URL')\n\n_426_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform', 'Supported-Platform', 'Summary', 'Description',\n               'Keywords', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License',\n               'Classifier', 'Download-URL', 'Obsoletes-Dist', 'Project-URL', 'Provides-Dist', 'Requires-Dist',\n               'Requires-Python', 'Requires-External', 'Private-Version', 'Obsoleted-By', 'Setup-Requires-Dist',\n               'Extension', 'Provides-Extra')\n\n_426_MARKERS = ('Private-Version', 'Provides-Extra', 'Obsoleted-By', 'Setup-Requires-Dist', 'Extension')\n\n# See issue #106: Sometimes 'Requires' and 'Provides' occur wrongly in\n# the metadata. Include them in the tuple literal below to allow them\n# (for now).\n# Ditto for Obsoletes - see issue #140.\n_566_FIELDS = _426_FIELDS + ('Description-Content-Type', 'Requires', 'Provides', 'Obsoletes')\n\n_566_MARKERS = ('Description-Content-Type', )\n\n_643_MARKERS = ('Dynamic', 'License-File')\n\n_643_FIELDS = _566_FIELDS + _643_MARKERS\n\n_ALL_FIELDS = set()\n_ALL_FIELDS.update(_241_FIELDS)\n_ALL_FIELDS.update(_314_FIELDS)\n_ALL_FIELDS.update(_345_FIELDS)\n_ALL_FIELDS.update(_426_FIELDS)\n_ALL_FIELDS.update(_566_FIELDS)\n_ALL_FIELDS.update(_643_FIELDS)\n\nEXTRA_RE = re.compile(r'''extra\\s*==\\s*(\"([^\"]+)\"|'([^']+)')''')\n\n\ndef _version2fieldlist(version):\n    if version == '1.0':\n        return _241_FIELDS\n    elif version == '1.1':\n        return _314_FIELDS\n    elif version == '1.2':\n        return _345_FIELDS\n    elif version in ('1.3', '2.1'):\n        # avoid adding field names if already there\n        return _345_FIELDS + tuple(f for f in _566_FIELDS if f not in _345_FIELDS)\n    elif version == '2.0':\n        raise ValueError('Metadata 2.0 is withdrawn and not supported')\n        # return _426_FIELDS\n    elif version == '2.2':\n        return _643_FIELDS\n    raise MetadataUnrecognizedVersionError(version)\n\n\ndef _best_version(fields):\n    \"\"\"Detect the best version depending on the fields used.\"\"\"\n\n    def _has_marker(keys, markers):\n        return any(marker in keys for marker in markers)\n\n    keys = [key for key, value in fields.items() if value not in ([], 'UNKNOWN', None)]\n    possible_versions = ['1.0', '1.1', '1.2', '1.3', '2.1', '2.2']  # 2.0 removed\n\n    # first let's try to see if a field is not part of one of the version\n    for key in keys:\n        if key not in _241_FIELDS and '1.0' in possible_versions:\n            possible_versions.remove('1.0')\n            logger.debug('Removed 1.0 due to %s', key)\n        if key not in _314_FIELDS and '1.1' in possible_versions:\n            possible_versions.remove('1.1')\n            logger.debug('Removed 1.1 due to %s', key)\n        if key not in _345_FIELDS and '1.2' in possible_versions:\n            possible_versions.remove('1.2')\n            logger.debug('Removed 1.2 due to %s', key)\n        if key not in _566_FIELDS and '1.3' in possible_versions:\n            possible_versions.remove('1.3')\n            logger.debug('Removed 1.3 due to %s', key)\n        if key not in _566_FIELDS and '2.1' in possible_versions:\n            if key != 'Description':  # In 2.1, description allowed after headers\n                possible_versions.remove('2.1')\n                logger.debug('Removed 2.1 due to %s', key)\n        if key not in _643_FIELDS and '2.2' in possible_versions:\n            possible_versions.remove('2.2')\n            logger.debug('Removed 2.2 due to %s', key)\n        # if key not in _426_FIELDS and '2.0' in possible_versions:\n        # possible_versions.remove('2.0')\n        # logger.debug('Removed 2.0 due to %s', key)\n\n    # possible_version contains qualified versions\n    if len(possible_versions) == 1:\n        return possible_versions[0]  # found !\n    elif len(possible_versions) == 0:\n        logger.debug('Out of options - unknown metadata set: %s', fields)\n        raise MetadataConflictError('Unknown metadata set')\n\n    # let's see if one unique marker is found\n    is_1_1 = '1.1' in possible_versions and _has_marker(keys, _314_MARKERS)\n    is_1_2 = '1.2' in possible_versions and _has_marker(keys, _345_MARKERS)\n    is_2_1 = '2.1' in possible_versions and _has_marker(keys, _566_MARKERS)\n    # is_2_0 = '2.0' in possible_versions and _has_marker(keys, _426_MARKERS)\n    is_2_2 = '2.2' in possible_versions and _has_marker(keys, _643_MARKERS)\n    if int(is_1_1) + int(is_1_2) + int(is_2_1) + int(is_2_2) > 1:\n        raise MetadataConflictError('You used incompatible 1.1/1.2/2.1/2.2 fields')\n\n    # we have the choice, 1.0, or 1.2, 2.1 or 2.2\n    #   - 1.0 has a broken Summary field but works with all tools\n    #   - 1.1 is to avoid\n    #   - 1.2 fixes Summary but has little adoption\n    #   - 2.1 adds more features\n    #   - 2.2 is the latest\n    if not is_1_1 and not is_1_2 and not is_2_1 and not is_2_2:\n        # we couldn't find any specific marker\n        if PKG_INFO_PREFERRED_VERSION in possible_versions:\n            return PKG_INFO_PREFERRED_VERSION\n    if is_1_1:\n        return '1.1'\n    if is_1_2:\n        return '1.2'\n    if is_2_1:\n        return '2.1'\n    # if is_2_2:\n    # return '2.2'\n\n    return '2.2'\n\n\n# This follows the rules about transforming keys as described in\n# https://www.python.org/dev/peps/pep-0566/#id17\n_ATTR2FIELD = {name.lower().replace(\"-\", \"_\"): name for name in _ALL_FIELDS}\n_FIELD2ATTR = {field: attr for attr, field in _ATTR2FIELD.items()}\n\n_PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist')\n_VERSIONS_FIELDS = ('Requires-Python', )\n_VERSION_FIELDS = ('Version', )\n_LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes', 'Requires', 'Provides', 'Obsoletes-Dist', 'Provides-Dist',\n               'Requires-Dist', 'Requires-External', 'Project-URL', 'Supported-Platform', 'Setup-Requires-Dist',\n               'Provides-Extra', 'Extension', 'License-File')\n_LISTTUPLEFIELDS = ('Project-URL', )\n\n_ELEMENTSFIELD = ('Keywords', )\n\n_UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description')\n\n_MISSING = object()\n\n_FILESAFE = re.compile('[^A-Za-z0-9.]+')\n\n\ndef _get_name_and_version(name, version, for_filename=False):\n    \"\"\"Return the distribution name with version.\n\n    If for_filename is true, return a filename-escaped form.\"\"\"\n    if for_filename:\n        # For both name and version any runs of non-alphanumeric or '.'\n        # characters are replaced with a single '-'.  Additionally any\n        # spaces in the version string become '.'\n        name = _FILESAFE.sub('-', name)\n        version = _FILESAFE.sub('-', version.replace(' ', '.'))\n    return '%s-%s' % (name, version)\n\n\nclass LegacyMetadata(object):\n    \"\"\"The legacy metadata of a release.\n\n    Supports versions 1.0, 1.1, 1.2, 2.0 and 1.3/2.1 (auto-detected). You can\n    instantiate the class with one of these arguments (or none):\n    - *path*, the path to a metadata file\n    - *fileobj* give a file-like object with metadata as content\n    - *mapping* is a dict-like object\n    - *scheme* is a version scheme name\n    \"\"\"\n\n    # TODO document the mapping API and UNKNOWN default key\n\n    def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):\n        if [path, fileobj, mapping].count(None) < 2:\n            raise TypeError('path, fileobj and mapping are exclusive')\n        self._fields = {}\n        self.requires_files = []\n        self._dependencies = None\n        self.scheme = scheme\n        if path is not None:\n            self.read(path)\n        elif fileobj is not None:\n            self.read_file(fileobj)\n        elif mapping is not None:\n            self.update(mapping)\n            self.set_metadata_version()\n\n    def set_metadata_version(self):\n        self._fields['Metadata-Version'] = _best_version(self._fields)\n\n    def _write_field(self, fileobj, name, value):\n        fileobj.write('%s: %s\\n' % (name, value))\n\n    def __getitem__(self, name):\n        return self.get(name)\n\n    def __setitem__(self, name, value):\n        return self.set(name, value)\n\n    def __delitem__(self, name):\n        field_name = self._convert_name(name)\n        try:\n            del self._fields[field_name]\n        except KeyError:\n            raise KeyError(name)\n\n    def __contains__(self, name):\n        return (name in self._fields or self._convert_name(name) in self._fields)\n\n    def _convert_name(self, name):\n        if name in _ALL_FIELDS:\n            return name\n        name = name.replace('-', '_').lower()\n        return _ATTR2FIELD.get(name, name)\n\n    def _default_value(self, name):\n        if name in _LISTFIELDS or name in _ELEMENTSFIELD:\n            return []\n        return 'UNKNOWN'\n\n    def _remove_line_prefix(self, value):\n        if self.metadata_version in ('1.0', '1.1'):\n            return _LINE_PREFIX_PRE_1_2.sub('\\n', value)\n        else:\n            return _LINE_PREFIX_1_2.sub('\\n', value)\n\n    def __getattr__(self, name):\n        if name in _ATTR2FIELD:\n            return self[name]\n        raise AttributeError(name)\n\n    #\n    # Public API\n    #\n\n    def get_fullname(self, filesafe=False):\n        \"\"\"\n        Return the distribution name with version.\n\n        If filesafe is true, return a filename-escaped form.\n        \"\"\"\n        return _get_name_and_version(self['Name'], self['Version'], filesafe)\n\n    def is_field(self, name):\n        \"\"\"return True if name is a valid metadata key\"\"\"\n        name = self._convert_name(name)\n        return name in _ALL_FIELDS\n\n    def is_multi_field(self, name):\n        name = self._convert_name(name)\n        return name in _LISTFIELDS\n\n    def read(self, filepath):\n        \"\"\"Read the metadata values from a file path.\"\"\"\n        fp = codecs.open(filepath, 'r', encoding='utf-8')\n        try:\n            self.read_file(fp)\n        finally:\n            fp.close()\n\n    def read_file(self, fileob):\n        \"\"\"Read the metadata values from a file object.\"\"\"\n        msg = message_from_file(fileob)\n        self._fields['Metadata-Version'] = msg['metadata-version']\n\n        # When reading, get all the fields we can\n        for field in _ALL_FIELDS:\n            if field not in msg:\n                continue\n            if field in _LISTFIELDS:\n                # we can have multiple lines\n                values = msg.get_all(field)\n                if field in _LISTTUPLEFIELDS and values is not None:\n                    values = [tuple(value.split(',')) for value in values]\n                self.set(field, values)\n            else:\n                # single line\n                value = msg[field]\n                if value is not None and value != 'UNKNOWN':\n                    self.set(field, value)\n\n        # PEP 566 specifies that the body be used for the description, if\n        # available\n        body = msg.get_payload()\n        self[\"Description\"] = body if body else self[\"Description\"]\n        # logger.debug('Attempting to set metadata for %s', self)\n        # self.set_metadata_version()\n\n    def write(self, filepath, skip_unknown=False):\n        \"\"\"Write the metadata fields to filepath.\"\"\"\n        fp = codecs.open(filepath, 'w', encoding='utf-8')\n        try:\n            self.write_file(fp, skip_unknown)\n        finally:\n            fp.close()\n\n    def write_file(self, fileobject, skip_unknown=False):\n        \"\"\"Write the PKG-INFO format data to a file object.\"\"\"\n        self.set_metadata_version()\n\n        for field in _version2fieldlist(self['Metadata-Version']):\n            values = self.get(field)\n            if skip_unknown and values in ('UNKNOWN', [], ['UNKNOWN']):\n                continue\n            if field in _ELEMENTSFIELD:\n                self._write_field(fileobject, field, ','.join(values))\n                continue\n            if field not in _LISTFIELDS:\n                if field == 'Description':\n                    if self.metadata_version in ('1.0', '1.1'):\n                        values = values.replace('\\n', '\\n        ')\n                    else:\n                        values = values.replace('\\n', '\\n       |')\n                values = [values]\n\n            if field in _LISTTUPLEFIELDS:\n                values = [','.join(value) for value in values]\n\n            for value in values:\n                self._write_field(fileobject, field, value)\n\n    def update(self, other=None, **kwargs):\n        \"\"\"Set metadata values from the given iterable `other` and kwargs.\n\n        Behavior is like `dict.update`: If `other` has a ``keys`` method,\n        they are looped over and ``self[key]`` is assigned ``other[key]``.\n        Else, ``other`` is an iterable of ``(key, value)`` iterables.\n\n        Keys that don't match a metadata field or that have an empty value are\n        dropped.\n        \"\"\"\n\n        def _set(key, value):\n            if key in _ATTR2FIELD and value:\n                self.set(self._convert_name(key), value)\n\n        if not other:\n            # other is None or empty container\n            pass\n        elif hasattr(other, 'keys'):\n            for k in other.keys():\n                _set(k, other[k])\n        else:\n            for k, v in other:\n                _set(k, v)\n\n        if kwargs:\n            for k, v in kwargs.items():\n                _set(k, v)\n\n    def set(self, name, value):\n        \"\"\"Control then set a metadata field.\"\"\"\n        name = self._convert_name(name)\n\n        if ((name in _ELEMENTSFIELD or name == 'Platform') and not isinstance(value, (list, tuple))):\n            if isinstance(value, string_types):\n                value = [v.strip() for v in value.split(',')]\n            else:\n                value = []\n        elif (name in _LISTFIELDS and not isinstance(value, (list, tuple))):\n            if isinstance(value, string_types):\n                value = [value]\n            else:\n                value = []\n\n        if logger.isEnabledFor(logging.WARNING):\n            project_name = self['Name']\n\n            scheme = get_scheme(self.scheme)\n            if name in _PREDICATE_FIELDS and value is not None:\n                for v in value:\n                    # check that the values are valid\n                    if not scheme.is_valid_matcher(v.split(';')[0]):\n                        logger.warning(\"'%s': '%s' is not valid (field '%s')\", project_name, v, name)\n            # FIXME this rejects UNKNOWN, is that right?\n            elif name in _VERSIONS_FIELDS and value is not None:\n                if not scheme.is_valid_constraint_list(value):\n                    logger.warning(\"'%s': '%s' is not a valid version (field '%s')\", project_name, value, name)\n            elif name in _VERSION_FIELDS and value is not None:\n                if not scheme.is_valid_version(value):\n                    logger.warning(\"'%s': '%s' is not a valid version (field '%s')\", project_name, value, name)\n\n        if name in _UNICODEFIELDS:\n            if name == 'Description':\n                value = self._remove_line_prefix(value)\n\n        self._fields[name] = value\n\n    def get(self, name, default=_MISSING):\n        \"\"\"Get a metadata field.\"\"\"\n        name = self._convert_name(name)\n        if name not in self._fields:\n            if default is _MISSING:\n                default = self._default_value(name)\n            return default\n        if name in _UNICODEFIELDS:\n            value = self._fields[name]\n            return value\n        elif name in _LISTFIELDS:\n            value = self._fields[name]\n            if value is None:\n                return []\n            res = []\n            for val in value:\n                if name not in _LISTTUPLEFIELDS:\n                    res.append(val)\n                else:\n                    # That's for Project-URL\n                    res.append((val[0], val[1]))\n            return res\n\n        elif name in _ELEMENTSFIELD:\n            value = self._fields[name]\n            if isinstance(value, string_types):\n                return value.split(',')\n        return self._fields[name]\n\n    def check(self, strict=False):\n        \"\"\"Check if the metadata is compliant. If strict is True then raise if\n        no Name or Version are provided\"\"\"\n        self.set_metadata_version()\n\n        # XXX should check the versions (if the file was loaded)\n        missing, warnings = [], []\n\n        for attr in ('Name', 'Version'):  # required by PEP 345\n            if attr not in self:\n                missing.append(attr)\n\n        if strict and missing != []:\n            msg = 'missing required metadata: %s' % ', '.join(missing)\n            raise MetadataMissingError(msg)\n\n        for attr in ('Home-page', 'Author'):\n            if attr not in self:\n                missing.append(attr)\n\n        # checking metadata 1.2 (XXX needs to check 1.1, 1.0)\n        if self['Metadata-Version'] != '1.2':\n            return missing, warnings\n\n        scheme = get_scheme(self.scheme)\n\n        def are_valid_constraints(value):\n            for v in value:\n                if not scheme.is_valid_matcher(v.split(';')[0]):\n                    return False\n            return True\n\n        for fields, controller in ((_PREDICATE_FIELDS, are_valid_constraints),\n                                   (_VERSIONS_FIELDS, scheme.is_valid_constraint_list), (_VERSION_FIELDS,\n                                                                                         scheme.is_valid_version)):\n            for field in fields:\n                value = self.get(field, None)\n                if value is not None and not controller(value):\n                    warnings.append(\"Wrong value for '%s': %s\" % (field, value))\n\n        return missing, warnings\n\n    def todict(self, skip_missing=False):\n        \"\"\"Return fields as a dict.\n\n        Field names will be converted to use the underscore-lowercase style\n        instead of hyphen-mixed case (i.e. home_page instead of Home-page).\n        This is as per https://www.python.org/dev/peps/pep-0566/#id17.\n        \"\"\"\n        self.set_metadata_version()\n\n        fields = _version2fieldlist(self['Metadata-Version'])\n\n        data = {}\n\n        for field_name in fields:\n            if not skip_missing or field_name in self._fields:\n                key = _FIELD2ATTR[field_name]\n                if key != 'project_url':\n                    data[key] = self[field_name]\n                else:\n                    data[key] = [','.join(u) for u in self[field_name]]\n\n        return data\n\n    def add_requirements(self, requirements):\n        if self['Metadata-Version'] == '1.1':\n            # we can't have 1.1 metadata *and* Setuptools requires\n            for field in ('Obsoletes', 'Requires', 'Provides'):\n                if field in self:\n                    del self[field]\n        self['Requires-Dist'] += requirements\n\n    # Mapping API\n    # TODO could add iter* variants\n\n    def keys(self):\n        return list(_version2fieldlist(self['Metadata-Version']))\n\n    def __iter__(self):\n        for key in self.keys():\n            yield key\n\n    def values(self):\n        return [self[key] for key in self.keys()]\n\n    def items(self):\n        return [(key, self[key]) for key in self.keys()]\n\n    def __repr__(self):\n        return '<%s %s %s>' % (self.__class__.__name__, self.name, self.version)\n\n\nMETADATA_FILENAME = 'pydist.json'\nWHEEL_METADATA_FILENAME = 'metadata.json'\nLEGACY_METADATA_FILENAME = 'METADATA'\n\n\nclass Metadata(object):\n    \"\"\"\n    The metadata of a release. This implementation uses 2.1\n    metadata where possible. If not possible, it wraps a LegacyMetadata\n    instance which handles the key-value metadata format.\n    \"\"\"\n\n    METADATA_VERSION_MATCHER = re.compile(r'^\\d+(\\.\\d+)*$')\n\n    NAME_MATCHER = re.compile('^[0-9A-Z]([0-9A-Z_.-]*[0-9A-Z])?$', re.I)\n\n    FIELDNAME_MATCHER = re.compile('^[A-Z]([0-9A-Z-]*[0-9A-Z])?$', re.I)\n\n    VERSION_MATCHER = PEP440_VERSION_RE\n\n    SUMMARY_MATCHER = re.compile('.{1,2047}')\n\n    METADATA_VERSION = '2.0'\n\n    GENERATOR = 'distlib (%s)' % __version__\n\n    MANDATORY_KEYS = {\n        'name': (),\n        'version': (),\n        'summary': ('legacy', ),\n    }\n\n    INDEX_KEYS = ('name version license summary description author '\n                  'author_email keywords platform home_page classifiers '\n                  'download_url')\n\n    DEPENDENCY_KEYS = ('extras run_requires test_requires build_requires '\n                       'dev_requires provides meta_requires obsoleted_by '\n                       'supports_environments')\n\n    SYNTAX_VALIDATORS = {\n        'metadata_version': (METADATA_VERSION_MATCHER, ()),\n        'name': (NAME_MATCHER, ('legacy', )),\n        'version': (VERSION_MATCHER, ('legacy', )),\n        'summary': (SUMMARY_MATCHER, ('legacy', )),\n        'dynamic': (FIELDNAME_MATCHER, ('legacy', )),\n    }\n\n    __slots__ = ('_legacy', '_data', 'scheme')\n\n    def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):\n        if [path, fileobj, mapping].count(None) < 2:\n            raise TypeError('path, fileobj and mapping are exclusive')\n        self._legacy = None\n        self._data = None\n        self.scheme = scheme\n        # import pdb; pdb.set_trace()\n        if mapping is not None:\n            try:\n                self._validate_mapping(mapping, scheme)\n                self._data = mapping\n            except MetadataUnrecognizedVersionError:\n                self._legacy = LegacyMetadata(mapping=mapping, scheme=scheme)\n                self.validate()\n        else:\n            data = None\n            if path:\n                with open(path, 'rb') as f:\n                    data = f.read()\n            elif fileobj:\n                data = fileobj.read()\n            if data is None:\n                # Initialised with no args - to be added\n                self._data = {\n                    'metadata_version': self.METADATA_VERSION,\n                    'generator': self.GENERATOR,\n                }\n            else:\n                if not isinstance(data, text_type):\n                    data = data.decode('utf-8')\n                try:\n                    self._data = json.loads(data)\n                    self._validate_mapping(self._data, scheme)\n                except ValueError:\n                    # Note: MetadataUnrecognizedVersionError does not\n                    # inherit from ValueError (it's a DistlibException,\n                    # which should not inherit from ValueError).\n                    # The ValueError comes from the json.load - if that\n                    # succeeds and we get a validation error, we want\n                    # that to propagate\n                    self._legacy = LegacyMetadata(fileobj=StringIO(data), scheme=scheme)\n                    self.validate()\n\n    common_keys = set(('name', 'version', 'license', 'keywords', 'summary'))\n\n    none_list = (None, list)\n    none_dict = (None, dict)\n\n    mapped_keys = {\n        'run_requires': ('Requires-Dist', list),\n        'build_requires': ('Setup-Requires-Dist', list),\n        'dev_requires': none_list,\n        'test_requires': none_list,\n        'meta_requires': none_list,\n        'extras': ('Provides-Extra', list),\n        'modules': none_list,\n        'namespaces': none_list,\n        'exports': none_dict,\n        'commands': none_dict,\n        'classifiers': ('Classifier', list),\n        'source_url': ('Download-URL', None),\n        'metadata_version': ('Metadata-Version', None),\n    }\n\n    del none_list, none_dict\n\n    def __getattribute__(self, key):\n        common = object.__getattribute__(self, 'common_keys')\n        mapped = object.__getattribute__(self, 'mapped_keys')\n        if key in mapped:\n            lk, maker = mapped[key]\n            if self._legacy:\n                if lk is None:\n                    result = None if maker is None else maker()\n                else:\n                    result = self._legacy.get(lk)\n            else:\n                value = None if maker is None else maker()\n                if key not in ('commands', 'exports', 'modules', 'namespaces', 'classifiers'):\n                    result = self._data.get(key, value)\n                else:\n                    # special cases for PEP 459\n                    sentinel = object()\n                    result = sentinel\n                    d = self._data.get('extensions')\n                    if d:\n                        if key == 'commands':\n                            result = d.get('python.commands', value)\n                        elif key == 'classifiers':\n                            d = d.get('python.details')\n                            if d:\n                                result = d.get(key, value)\n                        else:\n                            d = d.get('python.exports')\n                            if not d:\n                                d = self._data.get('python.exports')\n                            if d:\n                                result = d.get(key, value)\n                    if result is sentinel:\n                        result = value\n        elif key not in common:\n            result = object.__getattribute__(self, key)\n        elif self._legacy:\n            result = self._legacy.get(key)\n        else:\n            result = self._data.get(key)\n        return result\n\n    def _validate_value(self, key, value, scheme=None):\n        if key in self.SYNTAX_VALIDATORS:\n            pattern, exclusions = self.SYNTAX_VALIDATORS[key]\n            if (scheme or self.scheme) not in exclusions:\n                m = pattern.match(value)\n                if not m:\n                    raise MetadataInvalidError(\"'%s' is an invalid value for \"\n                                               \"the '%s' property\" % (value, key))\n\n    def __setattr__(self, key, value):\n        self._validate_value(key, value)\n        common = object.__getattribute__(self, 'common_keys')\n        mapped = object.__getattribute__(self, 'mapped_keys')\n        if key in mapped:\n            lk, _ = mapped[key]\n            if self._legacy:\n                if lk is None:\n                    raise NotImplementedError\n                self._legacy[lk] = value\n            elif key not in ('commands', 'exports', 'modules', 'namespaces', 'classifiers'):\n                self._data[key] = value\n            else:\n                # special cases for PEP 459\n                d = self._data.setdefault('extensions', {})\n                if key == 'commands':\n                    d['python.commands'] = value\n                elif key == 'classifiers':\n                    d = d.setdefault('python.details', {})\n                    d[key] = value\n                else:\n                    d = d.setdefault('python.exports', {})\n                    d[key] = value\n        elif key not in common:\n            object.__setattr__(self, key, value)\n        else:\n            if key == 'keywords':\n                if isinstance(value, string_types):\n                    value = value.strip()\n                    if value:\n                        value = value.split()\n                    else:\n                        value = []\n            if self._legacy:\n                self._legacy[key] = value\n            else:\n                self._data[key] = value\n\n    @property\n    def name_and_version(self):\n        return _get_name_and_version(self.name, self.version, True)\n\n    @property\n    def provides(self):\n        if self._legacy:\n            result = self._legacy['Provides-Dist']\n        else:\n            result = self._data.setdefault('provides', [])\n        s = '%s (%s)' % (self.name, self.version)\n        if s not in result:\n            result.append(s)\n        return result\n\n    @provides.setter\n    def provides(self, value):\n        if self._legacy:\n            self._legacy['Provides-Dist'] = value\n        else:\n            self._data['provides'] = value\n\n    def get_requirements(self, reqts, extras=None, env=None):\n        \"\"\"\n        Base method to get dependencies, given a set of extras\n        to satisfy and an optional environment context.\n        :param reqts: A list of sometimes-wanted dependencies,\n                      perhaps dependent on extras and environment.\n        :param extras: A list of optional components being requested.\n        :param env: An optional environment for marker evaluation.\n        \"\"\"\n        if self._legacy:\n            result = reqts\n        else:\n            result = []\n            extras = get_extras(extras or [], self.extras)\n            for d in reqts:\n                if 'extra' not in d and 'environment' not in d:\n                    # unconditional\n                    include = True\n                else:\n                    if 'extra' not in d:\n                        # Not extra-dependent - only environment-dependent\n                        include = True\n                    else:\n                        include = d.get('extra') in extras\n                    if include:\n                        # Not excluded because of extras, check environment\n                        marker = d.get('environment')\n                        if marker:\n                            include = interpret(marker, env)\n                if include:\n                    result.extend(d['requires'])\n            for key in ('build', 'dev', 'test'):\n                e = ':%s:' % key\n                if e in extras:\n                    extras.remove(e)\n                    # A recursive call, but it should terminate since 'test'\n                    # has been removed from the extras\n                    reqts = self._data.get('%s_requires' % key, [])\n                    result.extend(self.get_requirements(reqts, extras=extras, env=env))\n        return result\n\n    @property\n    def dictionary(self):\n        if self._legacy:\n            return self._from_legacy()\n        return self._data\n\n    @property\n    def dependencies(self):\n        if self._legacy:\n            raise NotImplementedError\n        else:\n            return extract_by_key(self._data, self.DEPENDENCY_KEYS)\n\n    @dependencies.setter\n    def dependencies(self, value):\n        if self._legacy:\n            raise NotImplementedError\n        else:\n            self._data.update(value)\n\n    def _validate_mapping(self, mapping, scheme):\n        if mapping.get('metadata_version') != self.METADATA_VERSION:\n            raise MetadataUnrecognizedVersionError()\n        missing = []\n        for key, exclusions in self.MANDATORY_KEYS.items():\n            if key not in mapping:\n                if scheme not in exclusions:\n                    missing.append(key)\n        if missing:\n            msg = 'Missing metadata items: %s' % ', '.join(missing)\n            raise MetadataMissingError(msg)\n        for k, v in mapping.items():\n            self._validate_value(k, v, scheme)\n\n    def validate(self):\n        if self._legacy:\n            missing, warnings = self._legacy.check(True)\n            if missing or warnings:\n                logger.warning('Metadata: missing: %s, warnings: %s', missing, warnings)\n        else:\n            self._validate_mapping(self._data, self.scheme)\n\n    def todict(self):\n        if self._legacy:\n            return self._legacy.todict(True)\n        else:\n            result = extract_by_key(self._data, self.INDEX_KEYS)\n            return result\n\n    def _from_legacy(self):\n        assert self._legacy and not self._data\n        result = {\n            'metadata_version': self.METADATA_VERSION,\n            'generator': self.GENERATOR,\n        }\n        lmd = self._legacy.todict(True)  # skip missing ones\n        for k in ('name', 'version', 'license', 'summary', 'description', 'classifier'):\n            if k in lmd:\n                if k == 'classifier':\n                    nk = 'classifiers'\n                else:\n                    nk = k\n                result[nk] = lmd[k]\n        kw = lmd.get('Keywords', [])\n        if kw == ['']:\n            kw = []\n        result['keywords'] = kw\n        keys = (('requires_dist', 'run_requires'), ('setup_requires_dist', 'build_requires'))\n        for ok, nk in keys:\n            if ok in lmd and lmd[ok]:\n                result[nk] = [{'requires': lmd[ok]}]\n        result['provides'] = self.provides\n        # author = {}\n        # maintainer = {}\n        return result\n\n    LEGACY_MAPPING = {\n        'name': 'Name',\n        'version': 'Version',\n        ('extensions', 'python.details', 'license'): 'License',\n        'summary': 'Summary',\n        'description': 'Description',\n        ('extensions', 'python.project', 'project_urls', 'Home'): 'Home-page',\n        ('extensions', 'python.project', 'contacts', 0, 'name'): 'Author',\n        ('extensions', 'python.project', 'contacts', 0, 'email'): 'Author-email',\n        'source_url': 'Download-URL',\n        ('extensions', 'python.details', 'classifiers'): 'Classifier',\n    }\n\n    def _to_legacy(self):\n\n        def process_entries(entries):\n            reqts = set()\n            for e in entries:\n                extra = e.get('extra')\n                env = e.get('environment')\n                rlist = e['requires']\n                for r in rlist:\n                    if not env and not extra:\n                        reqts.add(r)\n                    else:\n                        marker = ''\n                        if extra:\n                            marker = 'extra == \"%s\"' % extra\n                        if env:\n                            if marker:\n                                marker = '(%s) and %s' % (env, marker)\n                            else:\n                                marker = env\n                        reqts.add(';'.join((r, marker)))\n            return reqts\n\n        assert self._data and not self._legacy\n        result = LegacyMetadata()\n        nmd = self._data\n        # import pdb; pdb.set_trace()\n        for nk, ok in self.LEGACY_MAPPING.items():\n            if not isinstance(nk, tuple):\n                if nk in nmd:\n                    result[ok] = nmd[nk]\n            else:\n                d = nmd\n                found = True\n                for k in nk:\n                    try:\n                        d = d[k]\n                    except (KeyError, IndexError):\n                        found = False\n                        break\n                if found:\n                    result[ok] = d\n        r1 = process_entries(self.run_requires + self.meta_requires)\n        r2 = process_entries(self.build_requires + self.dev_requires)\n        if self.extras:\n            result['Provides-Extra'] = sorted(self.extras)\n        result['Requires-Dist'] = sorted(r1)\n        result['Setup-Requires-Dist'] = sorted(r2)\n        # TODO: any other fields wanted\n        return result\n\n    def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):\n        if [path, fileobj].count(None) != 1:\n            raise ValueError('Exactly one of path and fileobj is needed')\n        self.validate()\n        if legacy:\n            if self._legacy:\n                legacy_md = self._legacy\n            else:\n                legacy_md = self._to_legacy()\n            if path:\n                legacy_md.write(path, skip_unknown=skip_unknown)\n            else:\n                legacy_md.write_file(fileobj, skip_unknown=skip_unknown)\n        else:\n            if self._legacy:\n                d = self._from_legacy()\n            else:\n                d = self._data\n            if fileobj:\n                json.dump(d, fileobj, ensure_ascii=True, indent=2, sort_keys=True)\n            else:\n                with codecs.open(path, 'w', 'utf-8') as f:\n                    json.dump(d, f, ensure_ascii=True, indent=2, sort_keys=True)\n\n    def add_requirements(self, requirements):\n        if self._legacy:\n            self._legacy.add_requirements(requirements)\n        else:\n            run_requires = self._data.setdefault('run_requires', [])\n            always = None\n            for entry in run_requires:\n                if 'environment' not in entry and 'extra' not in entry:\n                    always = entry\n                    break\n            if always is None:\n                always = {'requires': requirements}\n                run_requires.insert(0, always)\n            else:\n                rset = set(always['requires']) | set(requirements)\n                always['requires'] = sorted(rset)\n\n    def __repr__(self):\n        name = self.name or '(no name)'\n        version = self.version or 'no version'\n        return '<%s %s %s (%s)>' % (self.__class__.__name__, self.metadata_version, name, version)\n", "distlib/__init__.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nimport logging\n\n__version__ = '0.3.9.dev0'\n\n\nclass DistlibException(Exception):\n    pass\n\n\ntry:\n    from logging import NullHandler\nexcept ImportError:  # pragma: no cover\n\n    class NullHandler(logging.Handler):\n\n        def handle(self, record):\n            pass\n\n        def emit(self, record):\n            pass\n\n        def createLock(self):\n            self.lock = None\n\n\nlogger = logging.getLogger(__name__)\nlogger.addHandler(NullHandler())\n", "distlib/compat.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2013-2017 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\nfrom __future__ import absolute_import\n\nimport os\nimport re\nimport shutil\nimport sys\n\ntry:\n    import ssl\nexcept ImportError:  # pragma: no cover\n    ssl = None\n\nif sys.version_info[0] < 3:  # pragma: no cover\n    from StringIO import StringIO\n    string_types = basestring,\n    text_type = unicode\n    from types import FileType as file_type\n    import __builtin__ as builtins\n    import ConfigParser as configparser\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit\n    from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,\n                        pathname2url, ContentTooShortError, splittype)\n\n    def quote(s):\n        if isinstance(s, unicode):\n            s = s.encode('utf-8')\n        return _quote(s)\n\n    import urllib2\n    from urllib2 import (Request, urlopen, URLError, HTTPError,\n                         HTTPBasicAuthHandler, HTTPPasswordMgr, HTTPHandler,\n                         HTTPRedirectHandler, build_opener)\n    if ssl:\n        from urllib2 import HTTPSHandler\n    import httplib\n    import xmlrpclib\n    import Queue as queue\n    from HTMLParser import HTMLParser\n    import htmlentitydefs\n    raw_input = raw_input\n    from itertools import ifilter as filter\n    from itertools import ifilterfalse as filterfalse\n\n    # Leaving this around for now, in case it needs resurrecting in some way\n    # _userprog = None\n    # def splituser(host):\n    # \"\"\"splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'.\"\"\"\n    # global _userprog\n    # if _userprog is None:\n    # import re\n    # _userprog = re.compile('^(.*)@(.*)$')\n\n    # match = _userprog.match(host)\n    # if match: return match.group(1, 2)\n    # return None, host\n\nelse:  # pragma: no cover\n    from io import StringIO\n    string_types = str,\n    text_type = str\n    from io import TextIOWrapper as file_type\n    import builtins\n    import configparser\n    from urllib.parse import (urlparse, urlunparse, urljoin, quote, unquote,\n                              urlsplit, urlunsplit, splittype)\n    from urllib.request import (urlopen, urlretrieve, Request, url2pathname,\n                                pathname2url, HTTPBasicAuthHandler,\n                                HTTPPasswordMgr, HTTPHandler,\n                                HTTPRedirectHandler, build_opener)\n    if ssl:\n        from urllib.request import HTTPSHandler\n    from urllib.error import HTTPError, URLError, ContentTooShortError\n    import http.client as httplib\n    import urllib.request as urllib2\n    import xmlrpc.client as xmlrpclib\n    import queue\n    from html.parser import HTMLParser\n    import html.entities as htmlentitydefs\n    raw_input = input\n    from itertools import filterfalse\n    filter = filter\n\ntry:\n    from ssl import match_hostname, CertificateError\nexcept ImportError:  # pragma: no cover\n\n    class CertificateError(ValueError):\n        pass\n\n    def _dnsname_match(dn, hostname, max_wildcards=1):\n        \"\"\"Matching according to RFC 6125, section 6.4.3\n\n        http://tools.ietf.org/html/rfc6125#section-6.4.3\n        \"\"\"\n        pats = []\n        if not dn:\n            return False\n\n        parts = dn.split('.')\n        leftmost, remainder = parts[0], parts[1:]\n\n        wildcards = leftmost.count('*')\n        if wildcards > max_wildcards:\n            # Issue #17980: avoid denials of service by refusing more\n            # than one wildcard per fragment.  A survey of established\n            # policy among SSL implementations showed it to be a\n            # reasonable choice.\n            raise CertificateError(\n                \"too many wildcards in certificate DNS name: \" + repr(dn))\n\n        # speed up common case w/o wildcards\n        if not wildcards:\n            return dn.lower() == hostname.lower()\n\n        # RFC 6125, section 6.4.3, subitem 1.\n        # The client SHOULD NOT attempt to match a presented identifier in which\n        # the wildcard character comprises a label other than the left-most label.\n        if leftmost == '*':\n            # When '*' is a fragment by itself, it matches a non-empty dotless\n            # fragment.\n            pats.append('[^.]+')\n        elif leftmost.startswith('xn--') or hostname.startswith('xn--'):\n            # RFC 6125, section 6.4.3, subitem 3.\n            # The client SHOULD NOT attempt to match a presented identifier\n            # where the wildcard character is embedded within an A-label or\n            # U-label of an internationalized domain name.\n            pats.append(re.escape(leftmost))\n        else:\n            # Otherwise, '*' matches any dotless string, e.g. www*\n            pats.append(re.escape(leftmost).replace(r'\\*', '[^.]*'))\n\n        # add the remaining fragments, ignore any wildcards\n        for frag in remainder:\n            pats.append(re.escape(frag))\n\n        pat = re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\n        return pat.match(hostname)\n\n    def match_hostname(cert, hostname):\n        \"\"\"Verify that *cert* (in decoded format as returned by\n        SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n        rules are followed, but IP addresses are not accepted for *hostname*.\n\n        CertificateError is raised on failure. On success, the function\n        returns nothing.\n        \"\"\"\n        if not cert:\n            raise ValueError(\"empty or no certificate, match_hostname needs a \"\n                             \"SSL socket or SSL context with either \"\n                             \"CERT_OPTIONAL or CERT_REQUIRED\")\n        dnsnames = []\n        san = cert.get('subjectAltName', ())\n        for key, value in san:\n            if key == 'DNS':\n                if _dnsname_match(value, hostname):\n                    return\n                dnsnames.append(value)\n        if not dnsnames:\n            # The subject is only checked when there is no dNSName entry\n            # in subjectAltName\n            for sub in cert.get('subject', ()):\n                for key, value in sub:\n                    # XXX according to RFC 2818, the most specific Common Name\n                    # must be used.\n                    if key == 'commonName':\n                        if _dnsname_match(value, hostname):\n                            return\n                        dnsnames.append(value)\n        if len(dnsnames) > 1:\n            raise CertificateError(\"hostname %r \"\n                                   \"doesn't match either of %s\" %\n                                   (hostname, ', '.join(map(repr, dnsnames))))\n        elif len(dnsnames) == 1:\n            raise CertificateError(\"hostname %r \"\n                                   \"doesn't match %r\" %\n                                   (hostname, dnsnames[0]))\n        else:\n            raise CertificateError(\"no appropriate commonName or \"\n                                   \"subjectAltName fields were found\")\n\n\ntry:\n    from types import SimpleNamespace as Container\nexcept ImportError:  # pragma: no cover\n\n    class Container(object):\n        \"\"\"\n        A generic container for when multiple values need to be returned\n        \"\"\"\n\n        def __init__(self, **kwargs):\n            self.__dict__.update(kwargs)\n\n\ntry:\n    from shutil import which\nexcept ImportError:  # pragma: no cover\n    # Implementation from Python 3.3\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n\n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n\n        \"\"\"\n\n        # Check that a given file can be accessed with the correct mode.\n        # Additionally check that `file` is not a directory, as on Windows\n        # directories pass the os.access check.\n        def _access_check(fn, mode):\n            return (os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn))\n\n        # If we're given a path with a directory part, look it up directly rather\n        # than referring to PATH directories. This includes checking relative to the\n        # current directory, e.g. ./script\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n\n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n\n        if sys.platform == \"win32\":\n            # The current directory takes precedence on Windows.\n            if os.curdir not in path:\n                path.insert(0, os.curdir)\n\n            # PATHEXT is necessary to check on Windows.\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            # See if the given file matches any of the expected path extensions.\n            # This will allow us to short circuit when given \"python.exe\".\n            # If it does match, only test that one, otherwise we have to try\n            # others.\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            # On other platforms you don't have things like PATHEXT to tell you\n            # what file suffixes are executable, so just pass on cmd as-is.\n            files = [cmd]\n\n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if normdir not in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\n# ZipFile is a context manager in 2.7, but not in 2.6\n\nfrom zipfile import ZipFile as BaseZipFile\n\nif hasattr(BaseZipFile, '__enter__'):  # pragma: no cover\n    ZipFile = BaseZipFile\nelse:  # pragma: no cover\n    from zipfile import ZipExtFile as BaseZipExtFile\n\n    class ZipExtFile(BaseZipExtFile):\n\n        def __init__(self, base):\n            self.__dict__.update(base.__dict__)\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, *exc_info):\n            self.close()\n            # return None, so if an exception occurred, it will propagate\n\n    class ZipFile(BaseZipFile):\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, *exc_info):\n            self.close()\n            # return None, so if an exception occurred, it will propagate\n\n        def open(self, *args, **kwargs):\n            base = BaseZipFile.open(self, *args, **kwargs)\n            return ZipExtFile(base)\n\n\ntry:\n    from platform import python_implementation\nexcept ImportError:  # pragma: no cover\n\n    def python_implementation():\n        \"\"\"Return a string identifying the Python implementation.\"\"\"\n        if 'PyPy' in sys.version:\n            return 'PyPy'\n        if os.name == 'java':\n            return 'Jython'\n        if sys.version.startswith('IronPython'):\n            return 'IronPython'\n        return 'CPython'\n\n\nimport sysconfig\n\ntry:\n    callable = callable\nexcept NameError:  # pragma: no cover\n    from collections.abc import Callable\n\n    def callable(obj):\n        return isinstance(obj, Callable)\n\n\ntry:\n    fsencode = os.fsencode\n    fsdecode = os.fsdecode\nexcept AttributeError:  # pragma: no cover\n    # Issue #99: on some systems (e.g. containerised),\n    # sys.getfilesystemencoding() returns None, and we need a real value,\n    # so fall back to utf-8. From the CPython 2.7 docs relating to Unix and\n    # sys.getfilesystemencoding(): the return value is \"the user\u2019s preference\n    # according to the result of nl_langinfo(CODESET), or None if the\n    # nl_langinfo(CODESET) failed.\"\n    _fsencoding = sys.getfilesystemencoding() or 'utf-8'\n    if _fsencoding == 'mbcs':\n        _fserrors = 'strict'\n    else:\n        _fserrors = 'surrogateescape'\n\n    def fsencode(filename):\n        if isinstance(filename, bytes):\n            return filename\n        elif isinstance(filename, text_type):\n            return filename.encode(_fsencoding, _fserrors)\n        else:\n            raise TypeError(\"expect bytes or str, not %s\" %\n                            type(filename).__name__)\n\n    def fsdecode(filename):\n        if isinstance(filename, text_type):\n            return filename\n        elif isinstance(filename, bytes):\n            return filename.decode(_fsencoding, _fserrors)\n        else:\n            raise TypeError(\"expect bytes or str, not %s\" %\n                            type(filename).__name__)\n\n\ntry:\n    from tokenize import detect_encoding\nexcept ImportError:  # pragma: no cover\n    from codecs import BOM_UTF8, lookup\n\n    cookie_re = re.compile(r\"coding[:=]\\s*([-\\w.]+)\")\n\n    def _get_normal_name(orig_enc):\n        \"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n        # Only care about the first 12 characters.\n        enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n        if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n            return \"utf-8\"\n        if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n           enc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n            return \"iso-8859-1\"\n        return orig_enc\n\n    def detect_encoding(readline):\n        \"\"\"\n        The detect_encoding() function is used to detect the encoding that should\n        be used to decode a Python source file.  It requires one argument, readline,\n        in the same way as the tokenize() generator.\n\n        It will call readline a maximum of twice, and return the encoding used\n        (as a string) and a list of any lines (left as bytes) it has read in.\n\n        It detects the encoding from the presence of a utf-8 bom or an encoding\n        cookie as specified in pep-0263.  If both a bom and a cookie are present,\n        but disagree, a SyntaxError will be raised.  If the encoding cookie is an\n        invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n        'utf-8-sig' is returned.\n\n        If no encoding is specified, then the default of 'utf-8' will be returned.\n        \"\"\"\n        try:\n            filename = readline.__self__.name\n        except AttributeError:\n            filename = None\n        bom_found = False\n        encoding = None\n        default = 'utf-8'\n\n        def read_or_stop():\n            try:\n                return readline()\n            except StopIteration:\n                return b''\n\n        def find_cookie(line):\n            try:\n                # Decode as UTF-8. Either the line is an encoding declaration,\n                # in which case it should be pure ASCII, or it must be UTF-8\n                # per default encoding.\n                line_string = line.decode('utf-8')\n            except UnicodeDecodeError:\n                msg = \"invalid or missing encoding declaration\"\n                if filename is not None:\n                    msg = '{} for {!r}'.format(msg, filename)\n                raise SyntaxError(msg)\n\n            matches = cookie_re.findall(line_string)\n            if not matches:\n                return None\n            encoding = _get_normal_name(matches[0])\n            try:\n                codec = lookup(encoding)\n            except LookupError:\n                # This behaviour mimics the Python interpreter\n                if filename is None:\n                    msg = \"unknown encoding: \" + encoding\n                else:\n                    msg = \"unknown encoding for {!r}: {}\".format(\n                        filename, encoding)\n                raise SyntaxError(msg)\n\n            if bom_found:\n                if codec.name != 'utf-8':\n                    # This behaviour mimics the Python interpreter\n                    if filename is None:\n                        msg = 'encoding problem: utf-8'\n                    else:\n                        msg = 'encoding problem for {!r}: utf-8'.format(\n                            filename)\n                    raise SyntaxError(msg)\n                encoding += '-sig'\n            return encoding\n\n        first = read_or_stop()\n        if first.startswith(BOM_UTF8):\n            bom_found = True\n            first = first[3:]\n            default = 'utf-8-sig'\n        if not first:\n            return default, []\n\n        encoding = find_cookie(first)\n        if encoding:\n            return encoding, [first]\n\n        second = read_or_stop()\n        if not second:\n            return default, [first]\n\n        encoding = find_cookie(second)\n        if encoding:\n            return encoding, [first, second]\n\n        return default, [first, second]\n\n\n# For converting & <-> &amp; etc.\ntry:\n    from html import escape\nexcept ImportError:\n    from cgi import escape\nif sys.version_info[:2] < (3, 4):\n    unescape = HTMLParser().unescape\nelse:\n    from html import unescape\n\ntry:\n    from collections import ChainMap\nexcept ImportError:  # pragma: no cover\n    from collections import MutableMapping\n\n    try:\n        from reprlib import recursive_repr as _recursive_repr\n    except ImportError:\n\n        def _recursive_repr(fillvalue='...'):\n            '''\n            Decorator to make a repr function return fillvalue for a recursive\n            call\n            '''\n\n            def decorating_function(user_function):\n                repr_running = set()\n\n                def wrapper(self):\n                    key = id(self), get_ident()\n                    if key in repr_running:\n                        return fillvalue\n                    repr_running.add(key)\n                    try:\n                        result = user_function(self)\n                    finally:\n                        repr_running.discard(key)\n                    return result\n\n                # Can't use functools.wraps() here because of bootstrap issues\n                wrapper.__module__ = getattr(user_function, '__module__')\n                wrapper.__doc__ = getattr(user_function, '__doc__')\n                wrapper.__name__ = getattr(user_function, '__name__')\n                wrapper.__annotations__ = getattr(user_function,\n                                                  '__annotations__', {})\n                return wrapper\n\n            return decorating_function\n\n    class ChainMap(MutableMapping):\n        '''\n        A ChainMap groups multiple dicts (or other mappings) together\n        to create a single, updateable view.\n\n        The underlying mappings are stored in a list.  That list is public and can\n        accessed or updated using the *maps* attribute.  There is no other state.\n\n        Lookups search the underlying mappings successively until a key is found.\n        In contrast, writes, updates, and deletions only operate on the first\n        mapping.\n        '''\n\n        def __init__(self, *maps):\n            '''Initialize a ChainMap by setting *maps* to the given mappings.\n            If no mappings are provided, a single empty dictionary is used.\n\n            '''\n            self.maps = list(maps) or [{}]  # always at least one map\n\n        def __missing__(self, key):\n            raise KeyError(key)\n\n        def __getitem__(self, key):\n            for mapping in self.maps:\n                try:\n                    return mapping[\n                        key]  # can't use 'key in mapping' with defaultdict\n                except KeyError:\n                    pass\n            return self.__missing__(\n                key)  # support subclasses that define __missing__\n\n        def get(self, key, default=None):\n            return self[key] if key in self else default\n\n        def __len__(self):\n            return len(set().union(\n                *self.maps))  # reuses stored hash values if possible\n\n        def __iter__(self):\n            return iter(set().union(*self.maps))\n\n        def __contains__(self, key):\n            return any(key in m for m in self.maps)\n\n        def __bool__(self):\n            return any(self.maps)\n\n        @_recursive_repr()\n        def __repr__(self):\n            return '{0.__class__.__name__}({1})'.format(\n                self, ', '.join(map(repr, self.maps)))\n\n        @classmethod\n        def fromkeys(cls, iterable, *args):\n            'Create a ChainMap with a single dict created from the iterable.'\n            return cls(dict.fromkeys(iterable, *args))\n\n        def copy(self):\n            'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'\n            return self.__class__(self.maps[0].copy(), *self.maps[1:])\n\n        __copy__ = copy\n\n        def new_child(self):  # like Django's Context.push()\n            'New ChainMap with a new dict followed by all previous maps.'\n            return self.__class__({}, *self.maps)\n\n        @property\n        def parents(self):  # like Django's Context.pop()\n            'New ChainMap from maps[1:].'\n            return self.__class__(*self.maps[1:])\n\n        def __setitem__(self, key, value):\n            self.maps[0][key] = value\n\n        def __delitem__(self, key):\n            try:\n                del self.maps[0][key]\n            except KeyError:\n                raise KeyError(\n                    'Key not found in the first mapping: {!r}'.format(key))\n\n        def popitem(self):\n            'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'\n            try:\n                return self.maps[0].popitem()\n            except KeyError:\n                raise KeyError('No keys found in the first mapping.')\n\n        def pop(self, key, *args):\n            'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'\n            try:\n                return self.maps[0].pop(key, *args)\n            except KeyError:\n                raise KeyError(\n                    'Key not found in the first mapping: {!r}'.format(key))\n\n        def clear(self):\n            'Clear maps[0], leaving maps[1:] intact.'\n            self.maps[0].clear()\n\n\ntry:\n    from importlib.util import cache_from_source  # Python >= 3.4\nexcept ImportError:  # pragma: no cover\n\n    def cache_from_source(path, debug_override=None):\n        assert path.endswith('.py')\n        if debug_override is None:\n            debug_override = __debug__\n        if debug_override:\n            suffix = 'c'\n        else:\n            suffix = 'o'\n        return path + suffix\n\n\ntry:\n    from collections import OrderedDict\nexcept ImportError:  # pragma: no cover\n    # {{{ http://code.activestate.com/recipes/576693/ (r9)\n    # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.\n    # Passes Python2.7's test suite and incorporates all the latest updates.\n    try:\n        from thread import get_ident as _get_ident\n    except ImportError:\n        from dummy_thread import get_ident as _get_ident\n\n    try:\n        from _abcoll import KeysView, ValuesView, ItemsView\n    except ImportError:\n        pass\n\n    class OrderedDict(dict):\n        'Dictionary that remembers insertion order'\n\n        # An inherited dict maps keys to values.\n        # The inherited dict provides __getitem__, __len__, __contains__, and get.\n        # The remaining methods are order-aware.\n        # Big-O running times for all methods are the same as for regular dictionaries.\n\n        # The internal self.__map dictionary maps keys to links in a doubly linked list.\n        # The circular doubly linked list starts and ends with a sentinel element.\n        # The sentinel element never gets deleted (this simplifies the algorithm).\n        # Each link is stored as a list of length three:  [PREV, NEXT, KEY].\n\n        def __init__(self, *args, **kwds):\n            '''Initialize an ordered dictionary.  Signature is the same as for\n            regular dictionaries, but keyword arguments are not recommended\n            because their insertion order is arbitrary.\n\n            '''\n            if len(args) > 1:\n                raise TypeError('expected at most 1 arguments, got %d' %\n                                len(args))\n            try:\n                self.__root\n            except AttributeError:\n                self.__root = root = []  # sentinel node\n                root[:] = [root, root, None]\n                self.__map = {}\n            self.__update(*args, **kwds)\n\n        def __setitem__(self, key, value, dict_setitem=dict.__setitem__):\n            'od.__setitem__(i, y) <==> od[i]=y'\n            # Setting a new item creates a new link which goes at the end of the linked\n            # list, and the inherited dictionary is updated with the new key/value pair.\n            if key not in self:\n                root = self.__root\n                last = root[0]\n                last[1] = root[0] = self.__map[key] = [last, root, key]\n            dict_setitem(self, key, value)\n\n        def __delitem__(self, key, dict_delitem=dict.__delitem__):\n            'od.__delitem__(y) <==> del od[y]'\n            # Deleting an existing item uses self.__map to find the link which is\n            # then removed by updating the links in the predecessor and successor nodes.\n            dict_delitem(self, key)\n            link_prev, link_next, key = self.__map.pop(key)\n            link_prev[1] = link_next\n            link_next[0] = link_prev\n\n        def __iter__(self):\n            'od.__iter__() <==> iter(od)'\n            root = self.__root\n            curr = root[1]\n            while curr is not root:\n                yield curr[2]\n                curr = curr[1]\n\n        def __reversed__(self):\n            'od.__reversed__() <==> reversed(od)'\n            root = self.__root\n            curr = root[0]\n            while curr is not root:\n                yield curr[2]\n                curr = curr[0]\n\n        def clear(self):\n            'od.clear() -> None.  Remove all items from od.'\n            try:\n                for node in self.__map.itervalues():\n                    del node[:]\n                root = self.__root\n                root[:] = [root, root, None]\n                self.__map.clear()\n            except AttributeError:\n                pass\n            dict.clear(self)\n\n        def popitem(self, last=True):\n            '''od.popitem() -> (k, v), return and remove a (key, value) pair.\n            Pairs are returned in LIFO order if last is true or FIFO order if false.\n\n            '''\n            if not self:\n                raise KeyError('dictionary is empty')\n            root = self.__root\n            if last:\n                link = root[0]\n                link_prev = link[0]\n                link_prev[1] = root\n                root[0] = link_prev\n            else:\n                link = root[1]\n                link_next = link[1]\n                root[1] = link_next\n                link_next[0] = root\n            key = link[2]\n            del self.__map[key]\n            value = dict.pop(self, key)\n            return key, value\n\n        # -- the following methods do not depend on the internal structure --\n\n        def keys(self):\n            'od.keys() -> list of keys in od'\n            return list(self)\n\n        def values(self):\n            'od.values() -> list of values in od'\n            return [self[key] for key in self]\n\n        def items(self):\n            'od.items() -> list of (key, value) pairs in od'\n            return [(key, self[key]) for key in self]\n\n        def iterkeys(self):\n            'od.iterkeys() -> an iterator over the keys in od'\n            return iter(self)\n\n        def itervalues(self):\n            'od.itervalues -> an iterator over the values in od'\n            for k in self:\n                yield self[k]\n\n        def iteritems(self):\n            'od.iteritems -> an iterator over the (key, value) items in od'\n            for k in self:\n                yield (k, self[k])\n\n        def update(*args, **kwds):\n            '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.\n\n            If E is a dict instance, does:           for k in E: od[k] = E[k]\n            If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]\n            Or if E is an iterable of items, does:   for k, v in E: od[k] = v\n            In either case, this is followed by:     for k, v in F.items(): od[k] = v\n\n            '''\n            if len(args) > 2:\n                raise TypeError('update() takes at most 2 positional '\n                                'arguments (%d given)' % (len(args), ))\n            elif not args:\n                raise TypeError('update() takes at least 1 argument (0 given)')\n            self = args[0]\n            # Make progressively weaker assumptions about \"other\"\n            other = ()\n            if len(args) == 2:\n                other = args[1]\n            if isinstance(other, dict):\n                for key in other:\n                    self[key] = other[key]\n            elif hasattr(other, 'keys'):\n                for key in other.keys():\n                    self[key] = other[key]\n            else:\n                for key, value in other:\n                    self[key] = value\n            for key, value in kwds.items():\n                self[key] = value\n\n        __update = update  # let subclasses override update without breaking __init__\n\n        __marker = object()\n\n        def pop(self, key, default=__marker):\n            '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n            If key is not found, d is returned if given, otherwise KeyError is raised.\n\n            '''\n            if key in self:\n                result = self[key]\n                del self[key]\n                return result\n            if default is self.__marker:\n                raise KeyError(key)\n            return default\n\n        def setdefault(self, key, default=None):\n            'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'\n            if key in self:\n                return self[key]\n            self[key] = default\n            return default\n\n        def __repr__(self, _repr_running=None):\n            'od.__repr__() <==> repr(od)'\n            if not _repr_running:\n                _repr_running = {}\n            call_key = id(self), _get_ident()\n            if call_key in _repr_running:\n                return '...'\n            _repr_running[call_key] = 1\n            try:\n                if not self:\n                    return '%s()' % (self.__class__.__name__, )\n                return '%s(%r)' % (self.__class__.__name__, self.items())\n            finally:\n                del _repr_running[call_key]\n\n        def __reduce__(self):\n            'Return state information for pickling'\n            items = [[k, self[k]] for k in self]\n            inst_dict = vars(self).copy()\n            for k in vars(OrderedDict()):\n                inst_dict.pop(k, None)\n            if inst_dict:\n                return (self.__class__, (items, ), inst_dict)\n            return self.__class__, (items, )\n\n        def copy(self):\n            'od.copy() -> a shallow copy of od'\n            return self.__class__(self)\n\n        @classmethod\n        def fromkeys(cls, iterable, value=None):\n            '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S\n            and values equal to v (which defaults to None).\n\n            '''\n            d = cls()\n            for key in iterable:\n                d[key] = value\n            return d\n\n        def __eq__(self, other):\n            '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive\n            while comparison to a regular mapping is order-insensitive.\n\n            '''\n            if isinstance(other, OrderedDict):\n                return len(self) == len(\n                    other) and self.items() == other.items()\n            return dict.__eq__(self, other)\n\n        def __ne__(self, other):\n            return not self == other\n\n        # -- the following methods are only used in Python 2.7 --\n\n        def viewkeys(self):\n            \"od.viewkeys() -> a set-like object providing a view on od's keys\"\n            return KeysView(self)\n\n        def viewvalues(self):\n            \"od.viewvalues() -> an object providing a view on od's values\"\n            return ValuesView(self)\n\n        def viewitems(self):\n            \"od.viewitems() -> a set-like object providing a view on od's items\"\n            return ItemsView(self)\n\n\ntry:\n    from logging.config import BaseConfigurator, valid_ident\nexcept ImportError:  # pragma: no cover\n    IDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)\n\n    def valid_ident(s):\n        m = IDENTIFIER.match(s)\n        if not m:\n            raise ValueError('Not a valid Python identifier: %r' % s)\n        return True\n\n    # The ConvertingXXX classes are wrappers around standard Python containers,\n    # and they serve to convert any suitable values in the container. The\n    # conversion converts base dicts, lists and tuples to their wrapped\n    # equivalents, whereas strings which match a conversion format are converted\n    # appropriately.\n    #\n    # Each wrapper should have a configurator attribute holding the actual\n    # configurator to use for conversion.\n\n    class ConvertingDict(dict):\n        \"\"\"A converting dictionary wrapper.\"\"\"\n\n        def __getitem__(self, key):\n            value = dict.__getitem__(self, key)\n            result = self.configurator.convert(value)\n            # If the converted value is different, save for next time\n            if value is not result:\n                self[key] = result\n                if type(result) in (ConvertingDict, ConvertingList,\n                                    ConvertingTuple):\n                    result.parent = self\n                    result.key = key\n            return result\n\n        def get(self, key, default=None):\n            value = dict.get(self, key, default)\n            result = self.configurator.convert(value)\n            # If the converted value is different, save for next time\n            if value is not result:\n                self[key] = result\n                if type(result) in (ConvertingDict, ConvertingList,\n                                    ConvertingTuple):\n                    result.parent = self\n                    result.key = key\n            return result\n\n    def pop(self, key, default=None):\n        value = dict.pop(self, key, default)\n        result = self.configurator.convert(value)\n        if value is not result:\n            if type(result) in (ConvertingDict, ConvertingList,\n                                ConvertingTuple):\n                result.parent = self\n                result.key = key\n        return result\n\n    class ConvertingList(list):\n        \"\"\"A converting list wrapper.\"\"\"\n\n        def __getitem__(self, key):\n            value = list.__getitem__(self, key)\n            result = self.configurator.convert(value)\n            # If the converted value is different, save for next time\n            if value is not result:\n                self[key] = result\n                if type(result) in (ConvertingDict, ConvertingList,\n                                    ConvertingTuple):\n                    result.parent = self\n                    result.key = key\n            return result\n\n        def pop(self, idx=-1):\n            value = list.pop(self, idx)\n            result = self.configurator.convert(value)\n            if value is not result:\n                if type(result) in (ConvertingDict, ConvertingList,\n                                    ConvertingTuple):\n                    result.parent = self\n            return result\n\n    class ConvertingTuple(tuple):\n        \"\"\"A converting tuple wrapper.\"\"\"\n\n        def __getitem__(self, key):\n            value = tuple.__getitem__(self, key)\n            result = self.configurator.convert(value)\n            if value is not result:\n                if type(result) in (ConvertingDict, ConvertingList,\n                                    ConvertingTuple):\n                    result.parent = self\n                    result.key = key\n            return result\n\n    class BaseConfigurator(object):\n        \"\"\"\n        The configurator base class which defines some useful defaults.\n        \"\"\"\n\n        CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')\n\n        WORD_PATTERN = re.compile(r'^\\s*(\\w+)\\s*')\n        DOT_PATTERN = re.compile(r'^\\.\\s*(\\w+)\\s*')\n        INDEX_PATTERN = re.compile(r'^\\[\\s*(\\w+)\\s*\\]\\s*')\n        DIGIT_PATTERN = re.compile(r'^\\d+$')\n\n        value_converters = {\n            'ext': 'ext_convert',\n            'cfg': 'cfg_convert',\n        }\n\n        # We might want to use a different one, e.g. importlib\n        importer = staticmethod(__import__)\n\n        def __init__(self, config):\n            self.config = ConvertingDict(config)\n            self.config.configurator = self\n\n        def resolve(self, s):\n            \"\"\"\n            Resolve strings to objects using standard import and attribute\n            syntax.\n            \"\"\"\n            name = s.split('.')\n            used = name.pop(0)\n            try:\n                found = self.importer(used)\n                for frag in name:\n                    used += '.' + frag\n                    try:\n                        found = getattr(found, frag)\n                    except AttributeError:\n                        self.importer(used)\n                        found = getattr(found, frag)\n                return found\n            except ImportError:\n                e, tb = sys.exc_info()[1:]\n                v = ValueError('Cannot resolve %r: %s' % (s, e))\n                v.__cause__, v.__traceback__ = e, tb\n                raise v\n\n        def ext_convert(self, value):\n            \"\"\"Default converter for the ext:// protocol.\"\"\"\n            return self.resolve(value)\n\n        def cfg_convert(self, value):\n            \"\"\"Default converter for the cfg:// protocol.\"\"\"\n            rest = value\n            m = self.WORD_PATTERN.match(rest)\n            if m is None:\n                raise ValueError(\"Unable to convert %r\" % value)\n            else:\n                rest = rest[m.end():]\n                d = self.config[m.groups()[0]]\n                while rest:\n                    m = self.DOT_PATTERN.match(rest)\n                    if m:\n                        d = d[m.groups()[0]]\n                    else:\n                        m = self.INDEX_PATTERN.match(rest)\n                        if m:\n                            idx = m.groups()[0]\n                            if not self.DIGIT_PATTERN.match(idx):\n                                d = d[idx]\n                            else:\n                                try:\n                                    n = int(\n                                        idx\n                                    )  # try as number first (most likely)\n                                    d = d[n]\n                                except TypeError:\n                                    d = d[idx]\n                    if m:\n                        rest = rest[m.end():]\n                    else:\n                        raise ValueError('Unable to convert '\n                                         '%r at %r' % (value, rest))\n            # rest should be empty\n            return d\n\n        def convert(self, value):\n            \"\"\"\n            Convert values to an appropriate type. dicts, lists and tuples are\n            replaced by their converting alternatives. Strings are checked to\n            see if they have a conversion format and are converted if they do.\n            \"\"\"\n            if not isinstance(value, ConvertingDict) and isinstance(\n                    value, dict):\n                value = ConvertingDict(value)\n                value.configurator = self\n            elif not isinstance(value, ConvertingList) and isinstance(\n                    value, list):\n                value = ConvertingList(value)\n                value.configurator = self\n            elif not isinstance(value, ConvertingTuple) and isinstance(value, tuple):\n                value = ConvertingTuple(value)\n                value.configurator = self\n            elif isinstance(value, string_types):\n                m = self.CONVERT_PATTERN.match(value)\n                if m:\n                    d = m.groupdict()\n                    prefix = d['prefix']\n                    converter = self.value_converters.get(prefix, None)\n                    if converter:\n                        suffix = d['suffix']\n                        converter = getattr(self, converter)\n                        value = converter(suffix)\n            return value\n\n        def configure_custom(self, config):\n            \"\"\"Configure an object with a user-supplied factory.\"\"\"\n            c = config.pop('()')\n            if not callable(c):\n                c = self.resolve(c)\n            props = config.pop('.', None)\n            # Check for valid identifiers\n            kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])\n            result = c(**kwargs)\n            if props:\n                for name, value in props.items():\n                    setattr(result, name, value)\n            return result\n\n        def as_tuple(self, value):\n            \"\"\"Utility function which converts lists to tuples.\"\"\"\n            if isinstance(value, list):\n                value = tuple(value)\n            return value\n", "distlib/markers.py": "# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"\nParser for the environment markers micro-language defined in PEP 508.\n\"\"\"\n\n# Note: In PEP 345, the micro-language was Python compatible, so the ast\n# module could be used to parse it. However, PEP 508 introduced operators such\n# as ~= and === which aren't in Python, necessitating a different approach.\n\nimport os\nimport re\nimport sys\nimport platform\n\nfrom .compat import string_types\nfrom .util import in_venv, parse_marker\nfrom .version import LegacyVersion as LV\n\n__all__ = ['interpret']\n\n_VERSION_PATTERN = re.compile(r'((\\d+(\\.\\d+)*\\w*)|\\'(\\d+(\\.\\d+)*\\w*)\\'|\\\"(\\d+(\\.\\d+)*\\w*)\\\")')\n_VERSION_MARKERS = {'python_version', 'python_full_version'}\n\n\ndef _is_version_marker(s):\n    return isinstance(s, string_types) and s in _VERSION_MARKERS\n\n\ndef _is_literal(o):\n    if not isinstance(o, string_types) or not o:\n        return False\n    return o[0] in '\\'\"'\n\n\ndef _get_versions(s):\n    return {LV(m.groups()[0]) for m in _VERSION_PATTERN.finditer(s)}\n\n\nclass Evaluator(object):\n    \"\"\"\n    This class is used to evaluate marker expressions.\n    \"\"\"\n\n    operations = {\n        '==': lambda x, y: x == y,\n        '===': lambda x, y: x == y,\n        '~=': lambda x, y: x == y or x > y,\n        '!=': lambda x, y: x != y,\n        '<': lambda x, y: x < y,\n        '<=': lambda x, y: x == y or x < y,\n        '>': lambda x, y: x > y,\n        '>=': lambda x, y: x == y or x > y,\n        'and': lambda x, y: x and y,\n        'or': lambda x, y: x or y,\n        'in': lambda x, y: x in y,\n        'not in': lambda x, y: x not in y,\n    }\n\n    def evaluate(self, expr, context):\n        \"\"\"\n        Evaluate a marker expression returned by the :func:`parse_requirement`\n        function in the specified context.\n        \"\"\"\n        if isinstance(expr, string_types):\n            if expr[0] in '\\'\"':\n                result = expr[1:-1]\n            else:\n                if expr not in context:\n                    raise SyntaxError('unknown variable: %s' % expr)\n                result = context[expr]\n        else:\n            assert isinstance(expr, dict)\n            op = expr['op']\n            if op not in self.operations:\n                raise NotImplementedError('op not implemented: %s' % op)\n            elhs = expr['lhs']\n            erhs = expr['rhs']\n            if _is_literal(expr['lhs']) and _is_literal(expr['rhs']):\n                raise SyntaxError('invalid comparison: %s %s %s' % (elhs, op, erhs))\n\n            lhs = self.evaluate(elhs, context)\n            rhs = self.evaluate(erhs, context)\n            if ((_is_version_marker(elhs) or _is_version_marker(erhs)) and\n                    op in ('<', '<=', '>', '>=', '===', '==', '!=', '~=')):\n                lhs = LV(lhs)\n                rhs = LV(rhs)\n            elif _is_version_marker(elhs) and op in ('in', 'not in'):\n                lhs = LV(lhs)\n                rhs = _get_versions(rhs)\n            result = self.operations[op](lhs, rhs)\n        return result\n\n\n_DIGITS = re.compile(r'\\d+\\.\\d+')\n\n\ndef default_context():\n\n    def format_full_version(info):\n        version = '%s.%s.%s' % (info.major, info.minor, info.micro)\n        kind = info.releaselevel\n        if kind != 'final':\n            version += kind[0] + str(info.serial)\n        return version\n\n    if hasattr(sys, 'implementation'):\n        implementation_version = format_full_version(sys.implementation.version)\n        implementation_name = sys.implementation.name\n    else:\n        implementation_version = '0'\n        implementation_name = ''\n\n    ppv = platform.python_version()\n    m = _DIGITS.match(ppv)\n    pv = m.group(0)\n    result = {\n        'implementation_name': implementation_name,\n        'implementation_version': implementation_version,\n        'os_name': os.name,\n        'platform_machine': platform.machine(),\n        'platform_python_implementation': platform.python_implementation(),\n        'platform_release': platform.release(),\n        'platform_system': platform.system(),\n        'platform_version': platform.version(),\n        'platform_in_venv': str(in_venv()),\n        'python_full_version': ppv,\n        'python_version': pv,\n        'sys_platform': sys.platform,\n    }\n    return result\n\n\nDEFAULT_CONTEXT = default_context()\ndel default_context\n\nevaluator = Evaluator()\n\n\ndef interpret(marker, execution_context=None):\n    \"\"\"\n    Interpret a marker and return a result depending on environment.\n\n    :param marker: The marker to interpret.\n    :type marker: str\n    :param execution_context: The context used for name lookup.\n    :type execution_context: mapping\n    \"\"\"\n    try:\n        expr, rest = parse_marker(marker)\n    except Exception as e:\n        raise SyntaxError('Unable to interpret marker syntax: %s: %s' % (marker, e))\n    if rest and rest[0] != '#':\n        raise SyntaxError('unexpected trailing data in marker: %s: %s' % (marker, rest))\n    context = dict(DEFAULT_CONTEXT)\n    if execution_context:\n        context.update(execution_context)\n    return evaluator.evaluate(expr, context)\n"}