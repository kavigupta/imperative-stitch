{"noxfile.py": "from __future__ import annotations\n\nimport os\nimport shutil\nimport sys\nimport typing\nfrom pathlib import Path\n\nimport nox\n\nnox.options.error_on_missing_interpreters = True\n\n\ndef tests_impl(\n    session: nox.Session,\n    extras: str = \"socks,brotli,zstd,h2\",\n    # hypercorn dependency h2 compares bytes and strings\n    # https://github.com/python-hyper/h2/issues/1236\n    byte_string_comparisons: bool = False,\n    integration: bool = False,\n    pytest_extra_args: list[str] = [],\n) -> None:\n    # Retrieve sys info from the Python implementation under test\n    # to avoid enabling memray when nox runs under CPython but tests PyPy\n    session_python_info = session.run(\n        \"python\",\n        \"-c\",\n        \"import sys; print(sys.implementation.name, sys.version_info.releaselevel)\",\n        silent=True,\n    ).strip()  # type: ignore[union-attr] # mypy doesn't know that silent=True  will return a string\n    implementation_name, release_level = session_python_info.split(\" \")\n\n    # zstd cannot be installed on CPython 3.13 yet because it pins\n    # an incompatible CFFI version.\n    # https://github.com/indygreg/python-zstandard/issues/210\n    if release_level != \"final\":\n        extras = extras.replace(\",zstd\", \"\")\n\n    # Install deps and the package itself.\n    session.install(\"-r\", \"dev-requirements.txt\")\n    session.install(f\".[{extras}]\")\n\n    # Show the pip version.\n    session.run(\"pip\", \"--version\")\n    # Print the Python version and bytesize.\n    session.run(\"python\", \"--version\")\n    session.run(\"python\", \"-c\", \"import struct; print(struct.calcsize('P') * 8)\")\n    # Print OpenSSL information.\n    session.run(\"python\", \"-m\", \"OpenSSL.debug\")\n\n    memray_supported = True\n    if implementation_name != \"cpython\" or release_level != \"final\":\n        memray_supported = False  # pytest-memray requires CPython 3.8+\n    elif sys.platform == \"win32\":\n        memray_supported = False\n\n    # Environment variables being passed to the pytest run.\n    pytest_session_envvars = {\n        \"PYTHONWARNINGS\": \"always::DeprecationWarning\",\n    }\n\n    # In coverage 7.4.0 we can only set the setting for Python 3.12+\n    # Future versions of coverage will use sys.monitoring based on availability.\n    if (\n        isinstance(session.python, str)\n        and \".\" in session.python\n        and int(session.python.split(\".\")[1]) >= 12\n    ):\n        pytest_session_envvars[\"COVERAGE_CORE\"] = \"sysmon\"\n\n    # Inspired from https://hynek.me/articles/ditch-codecov-python/\n    # We use parallel mode and then combine in a later CI step\n    session.run(\n        \"python\",\n        *((\"-bb\",) if byte_string_comparisons else ()),\n        \"-m\",\n        \"coverage\",\n        \"run\",\n        \"--parallel-mode\",\n        \"-m\",\n        \"pytest\",\n        *(\"--memray\", \"--hide-memray-summary\") if memray_supported else (),\n        \"-v\",\n        \"-ra\",\n        *((\"--integration\",) if integration else ()),\n        f\"--color={'yes' if 'GITHUB_ACTIONS' in os.environ else 'auto'}\",\n        \"--tb=native\",\n        \"--durations=10\",\n        \"--strict-config\",\n        \"--strict-markers\",\n        \"--disable-socket\",\n        \"--allow-unix-socket\",\n        \"--allow-hosts=localhost,::1,127.0.0.0,240.0.0.0\",  # See `TARPIT_HOST`\n        *pytest_extra_args,\n        *(session.posargs or (\"test/\",)),\n        env=pytest_session_envvars,\n    )\n\n\n@nox.session(\n    python=[\n        \"3.8\",\n        \"3.9\",\n        \"3.10\",\n        \"3.11\",\n        \"3.12\",\n        \"3.13\",\n        \"pypy3.8\",\n        \"pypy3.9\",\n        \"pypy3.10\",\n    ]\n)\ndef test(session: nox.Session) -> None:\n    tests_impl(session)\n\n\n@nox.session(python=\"3\")\ndef test_integration(session: nox.Session) -> None:\n    \"\"\"Run integration tests\"\"\"\n    tests_impl(session, integration=True)\n\n\n@nox.session(python=\"3\")\ndef test_brotlipy(session: nox.Session) -> None:\n    \"\"\"Check that if 'brotlipy' is installed instead of 'brotli' or\n    'brotlicffi' that we still don't blow up.\n    \"\"\"\n    session.install(\"brotlipy\")\n    tests_impl(session, extras=\"socks\", byte_string_comparisons=False)\n\n\ndef git_clone(session: nox.Session, git_url: str) -> None:\n    \"\"\"We either clone the target repository or if already exist\n    simply reset the state and pull.\n    \"\"\"\n    expected_directory = git_url.split(\"/\")[-1]\n\n    if expected_directory.endswith(\".git\"):\n        expected_directory = expected_directory[:-4]\n\n    if not os.path.isdir(expected_directory):\n        session.run(\"git\", \"clone\", \"--depth\", \"1\", git_url, external=True)\n    else:\n        session.run(\n            \"git\", \"-C\", expected_directory, \"reset\", \"--hard\", \"HEAD\", external=True\n        )\n        session.run(\"git\", \"-C\", expected_directory, \"pull\", external=True)\n\n\n@nox.session()\ndef downstream_botocore(session: nox.Session) -> None:\n    root = os.getcwd()\n    tmp_dir = session.create_tmp()\n\n    session.cd(tmp_dir)\n    git_clone(session, \"https://github.com/boto/botocore\")\n    session.chdir(\"botocore\")\n    session.run(\"git\", \"rev-parse\", \"HEAD\", external=True)\n    session.run(\"python\", \"scripts/ci/install\")\n\n    session.cd(root)\n    session.install(\".\", silent=False)\n    session.cd(f\"{tmp_dir}/botocore\")\n\n    session.run(\"python\", \"-c\", \"import urllib3; print(urllib3.__version__)\")\n    session.run(\"python\", \"scripts/ci/run-tests\")\n\n\n@nox.session()\ndef downstream_requests(session: nox.Session) -> None:\n    root = os.getcwd()\n    tmp_dir = session.create_tmp()\n\n    session.cd(tmp_dir)\n    git_clone(session, \"https://github.com/psf/requests\")\n    session.chdir(\"requests\")\n    session.run(\"git\", \"rev-parse\", \"HEAD\", external=True)\n    session.install(\".[socks]\", silent=False)\n    session.install(\"-r\", \"requirements-dev.txt\", silent=False)\n\n    session.cd(root)\n    session.install(\".\", silent=False)\n    session.cd(f\"{tmp_dir}/requests\")\n\n    session.run(\"python\", \"-c\", \"import urllib3; print(urllib3.__version__)\")\n    session.run(\"pytest\", \"tests\")\n\n\n@nox.session()\ndef format(session: nox.Session) -> None:\n    \"\"\"Run code formatters.\"\"\"\n    lint(session)\n\n\n@nox.session(python=\"3.12\")\ndef lint(session: nox.Session) -> None:\n    session.install(\"pre-commit\")\n    session.run(\"pre-commit\", \"run\", \"--all-files\")\n\n    mypy(session)\n\n\n@nox.session(python=\"3.11\")\ndef pyodideconsole(session: nox.Session) -> None:\n    # build wheel into dist folder\n    session.install(\"build\")\n    session.run(\"python\", \"-m\", \"build\")\n    session.run(\n        \"cp\",\n        \"test/contrib/emscripten/templates/pyodide-console.html\",\n        \"dist/index.html\",\n        external=True,\n    )\n    session.cd(\"dist\")\n    session.run(\"python\", \"-m\", \"http.server\")\n\n\n# TODO: node support is not tested yet - it should work if you require('xmlhttprequest') before\n# loading pyodide, but there is currently no nice way to do this with pytest-pyodide\n# because you can't override the test runner properties easily - see\n# https://github.com/pyodide/pytest-pyodide/issues/118 for more\n@nox.session(python=\"3.11\")\n@nox.parametrize(\"runner\", [\"firefox\", \"chrome\"])\ndef emscripten(session: nox.Session, runner: str) -> None:\n    \"\"\"Test on Emscripten with Pyodide & Chrome / Firefox\"\"\"\n    session.install(\"-r\", \"emscripten-requirements.txt\")\n    # build wheel into dist folder\n    session.run(\"python\", \"-m\", \"build\")\n    # make sure we have a dist dir for pyodide\n    dist_dir = None\n    if \"PYODIDE_ROOT\" in os.environ:\n        # we have a pyodide build tree checked out\n        # use the dist directory from that\n        dist_dir = Path(os.environ[\"PYODIDE_ROOT\"]) / \"dist\"\n    else:\n        # we don't have a build tree, get one\n        # that matches the version of pyodide build\n        pyodide_version = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"import pyodide_build;print(pyodide_build.__version__)\",\n                silent=True,\n            ),\n        ).strip()\n\n        pyodide_artifacts_path = Path(session.cache_dir) / f\"pyodide-{pyodide_version}\"\n        if not pyodide_artifacts_path.exists():\n            print(\"Fetching pyodide build artifacts\")\n            session.run(\n                \"wget\",\n                f\"https://github.com/pyodide/pyodide/releases/download/{pyodide_version}/pyodide-{pyodide_version}.tar.bz2\",\n                \"-O\",\n                f\"{pyodide_artifacts_path}.tar.bz2\",\n            )\n            pyodide_artifacts_path.mkdir(parents=True)\n            session.run(\n                \"tar\",\n                \"-xjf\",\n                f\"{pyodide_artifacts_path}.tar.bz2\",\n                \"-C\",\n                str(pyodide_artifacts_path),\n                \"--strip-components\",\n                \"1\",\n            )\n\n        dist_dir = pyodide_artifacts_path\n    assert dist_dir is not None\n    assert dist_dir.exists()\n    if runner == \"chrome\":\n        # install chrome webdriver and add it to path\n        driver = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"from webdriver_manager.chrome import ChromeDriverManager;print(ChromeDriverManager().install())\",\n                silent=True,\n            ),\n        ).strip()\n        session.env[\"PATH\"] = f\"{Path(driver).parent}:{session.env['PATH']}\"\n\n        tests_impl(\n            session,\n            pytest_extra_args=[\n                \"--rt\",\n                \"chrome-no-host\",\n                \"--dist-dir\",\n                str(dist_dir),\n                \"test\",\n            ],\n        )\n    elif runner == \"firefox\":\n        driver = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"from webdriver_manager.firefox import GeckoDriverManager;print(GeckoDriverManager().install())\",\n                silent=True,\n            ),\n        ).strip()\n        session.env[\"PATH\"] = f\"{Path(driver).parent}:{session.env['PATH']}\"\n\n        tests_impl(\n            session,\n            pytest_extra_args=[\n                \"--rt\",\n                \"firefox-no-host\",\n                \"--dist-dir\",\n                str(dist_dir),\n                \"test\",\n            ],\n        )\n    else:\n        raise ValueError(f\"Unknown runner: {runner}\")\n\n\n@nox.session(python=\"3.12\")\ndef mypy(session: nox.Session) -> None:\n    \"\"\"Run mypy.\"\"\"\n    session.install(\"-r\", \"mypy-requirements.txt\")\n    session.run(\"mypy\", \"--version\")\n    session.run(\n        \"mypy\",\n        \"-p\",\n        \"dummyserver\",\n        \"-m\",\n        \"noxfile\",\n        \"-p\",\n        \"urllib3\",\n        \"-p\",\n        \"test\",\n    )\n\n\n@nox.session\ndef docs(session: nox.Session) -> None:\n    session.install(\"-r\", \"docs/requirements.txt\")\n    session.install(\".[socks,brotli,zstd]\")\n\n    session.chdir(\"docs\")\n    if os.path.exists(\"_build\"):\n        shutil.rmtree(\"_build\")\n    session.run(\"sphinx-build\", \"-b\", \"html\", \"-W\", \".\", \"_build/html\")\n", "src/urllib3/response.py": "from __future__ import annotations\n\nimport collections\nimport io\nimport json as _json\nimport logging\nimport re\nimport sys\nimport typing\nimport warnings\nimport zlib\nfrom contextlib import contextmanager\nfrom http.client import HTTPMessage as _HttplibHTTPMessage\nfrom http.client import HTTPResponse as _HttplibHTTPResponse\nfrom socket import timeout as SocketTimeout\n\nif typing.TYPE_CHECKING:\n    from ._base_connection import BaseHTTPConnection\n\ntry:\n    try:\n        import brotlicffi as brotli  # type: ignore[import-not-found]\n    except ImportError:\n        import brotli  # type: ignore[import-not-found]\nexcept ImportError:\n    brotli = None\n\ntry:\n    import zstandard as zstd\nexcept (AttributeError, ImportError, ValueError):  # Defensive:\n    HAS_ZSTD = False\nelse:\n    # The package 'zstandard' added the 'eof' property starting\n    # in v0.18.0 which we require to ensure a complete and\n    # valid zstd stream was fed into the ZstdDecoder.\n    # See: https://github.com/urllib3/urllib3/pull/2624\n    _zstd_version = tuple(\n        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n    )\n    if _zstd_version < (0, 18):  # Defensive:\n        HAS_ZSTD = False\n    else:\n        HAS_ZSTD = True\n\nfrom . import util\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom .connection import BaseSSLError, HTTPConnection, HTTPException\nfrom .exceptions import (\n    BodyNotHttplibCompatible,\n    DecodeError,\n    HTTPError,\n    IncompleteRead,\n    InvalidChunkLength,\n    InvalidHeader,\n    ProtocolError,\n    ReadTimeoutError,\n    ResponseNotChunked,\n    SSLError,\n)\nfrom .util.response import is_fp_closed, is_response_to_head\nfrom .util.retry import Retry\n\nif typing.TYPE_CHECKING:\n    from .connectionpool import HTTPConnectionPool\n\nlog = logging.getLogger(__name__)\n\n\nclass ContentDecoder:\n    def decompress(self, data: bytes) -> bytes:\n        raise NotImplementedError()\n\n    def flush(self) -> bytes:\n        raise NotImplementedError()\n\n\nclass DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._first_try = True\n        self._data = b\"\"\n        self._obj = zlib.decompressobj()\n\n    def decompress(self, data: bytes) -> bytes:\n        if not data:\n            return data\n\n        if not self._first_try:\n            return self._obj.decompress(data)\n\n        self._data += data\n        try:\n            decompressed = self._obj.decompress(data)\n            if decompressed:\n                self._first_try = False\n                self._data = None  # type: ignore[assignment]\n            return decompressed\n        except zlib.error:\n            self._first_try = False\n            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)\n            try:\n                return self.decompress(self._data)\n            finally:\n                self._data = None  # type: ignore[assignment]\n\n    def flush(self) -> bytes:\n        return self._obj.flush()\n\n\nclass GzipDecoderState:\n    FIRST_MEMBER = 0\n    OTHER_MEMBERS = 1\n    SWALLOW_DATA = 2\n\n\nclass GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n\n    def decompress(self, data: bytes) -> bytes:\n        ret = bytearray()\n        if self._state == GzipDecoderState.SWALLOW_DATA or not data:\n            return bytes(ret)\n        while True:\n            try:\n                ret += self._obj.decompress(data)\n            except zlib.error:\n                previous_state = self._state\n                # Ignore data after the first error\n                self._state = GzipDecoderState.SWALLOW_DATA\n                if previous_state == GzipDecoderState.OTHER_MEMBERS:\n                    # Allow trailing garbage acceptable in other gzip clients\n                    return bytes(ret)\n                raise\n            data = self._obj.unused_data\n            if not data:\n                return bytes(ret)\n            self._state = GzipDecoderState.OTHER_MEMBERS\n            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n\n    def flush(self) -> bytes:\n        return self._obj.flush()\n\n\nif brotli is not None:\n\n    class BrotliDecoder(ContentDecoder):\n        # Supports both 'brotlipy' and 'Brotli' packages\n        # since they share an import name. The top branches\n        # are for 'brotlipy' and bottom branches for 'Brotli'\n        def __init__(self) -> None:\n            self._obj = brotli.Decompressor()\n            if hasattr(self._obj, \"decompress\"):\n                setattr(self, \"decompress\", self._obj.decompress)\n            else:\n                setattr(self, \"decompress\", self._obj.process)\n\n        def flush(self) -> bytes:\n            if hasattr(self._obj, \"flush\"):\n                return self._obj.flush()  # type: ignore[no-any-return]\n            return b\"\"\n\n\nif HAS_ZSTD:\n\n    class ZstdDecoder(ContentDecoder):\n        def __init__(self) -> None:\n            self._obj = zstd.ZstdDecompressor().decompressobj()\n\n        def decompress(self, data: bytes) -> bytes:\n            if not data:\n                return b\"\"\n            data_parts = [self._obj.decompress(data)]\n            while self._obj.eof and self._obj.unused_data:\n                unused_data = self._obj.unused_data\n                self._obj = zstd.ZstdDecompressor().decompressobj()\n                data_parts.append(self._obj.decompress(unused_data))\n            return b\"\".join(data_parts)\n\n        def flush(self) -> bytes:\n            ret = self._obj.flush()  # note: this is a no-op\n            if not self._obj.eof:\n                raise DecodeError(\"Zstandard data is incomplete\")\n            return ret\n\n\nclass MultiDecoder(ContentDecoder):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n\n    def __init__(self, modes: str) -> None:\n        self._decoders = [_get_decoder(m.strip()) for m in modes.split(\",\")]\n\n    def flush(self) -> bytes:\n        return self._decoders[0].flush()\n\n    def decompress(self, data: bytes) -> bytes:\n        for d in reversed(self._decoders):\n            data = d.decompress(data)\n        return data\n\n\ndef _get_decoder(mode: str) -> ContentDecoder:\n    if \",\" in mode:\n        return MultiDecoder(mode)\n\n    # According to RFC 9110 section 8.4.1.3, recipients should\n    # consider x-gzip equivalent to gzip\n    if mode in (\"gzip\", \"x-gzip\"):\n        return GzipDecoder()\n\n    if brotli is not None and mode == \"br\":\n        return BrotliDecoder()\n\n    if HAS_ZSTD and mode == \"zstd\":\n        return ZstdDecoder()\n\n    return DeflateDecoder()\n\n\nclass BytesQueueBuffer:\n    \"\"\"Memory-efficient bytes buffer\n\n    To return decoded data in read() and still follow the BufferedIOBase API, we need a\n    buffer to always return the correct amount of bytes.\n\n    This buffer should be filled using calls to put()\n\n    Our maximum memory usage is determined by the sum of the size of:\n\n     * self.buffer, which contains the full data\n     * the largest chunk that we will copy in get()\n\n    The worst case scenario is a single chunk, in which case we'll make a full copy of\n    the data inside get().\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.buffer: typing.Deque[bytes] = collections.deque()\n        self._size: int = 0\n\n    def __len__(self) -> int:\n        return self._size\n\n    def put(self, data: bytes) -> None:\n        self.buffer.append(data)\n        self._size += len(data)\n\n    def get(self, n: int) -> bytes:\n        if n == 0:\n            return b\"\"\n        elif not self.buffer:\n            raise RuntimeError(\"buffer is empty\")\n        elif n < 0:\n            raise ValueError(\"n should be > 0\")\n\n        fetched = 0\n        ret = io.BytesIO()\n        while fetched < n:\n            remaining = n - fetched\n            chunk = self.buffer.popleft()\n            chunk_length = len(chunk)\n            if remaining < chunk_length:\n                left_chunk, right_chunk = chunk[:remaining], chunk[remaining:]\n                ret.write(left_chunk)\n                self.buffer.appendleft(right_chunk)\n                self._size -= remaining\n                break\n            else:\n                ret.write(chunk)\n                self._size -= chunk_length\n            fetched += chunk_length\n\n            if not self.buffer:\n                break\n\n        return ret.getvalue()\n\n    def get_all(self) -> bytes:\n        buffer = self.buffer\n        if not buffer:\n            assert self._size == 0\n            return b\"\"\n        if len(buffer) == 1:\n            result = buffer.pop()\n        else:\n            ret = io.BytesIO()\n            ret.writelines(buffer.popleft() for _ in range(len(buffer)))\n            result = ret.getvalue()\n        self._size = 0\n        return result\n\n\nclass BaseHTTPResponse(io.IOBase):\n    CONTENT_DECODERS = [\"gzip\", \"x-gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    if HAS_ZSTD:\n        CONTENT_DECODERS += [\"zstd\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n\n    DECODER_ERROR_CLASSES: tuple[type[Exception], ...] = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)\n\n    if HAS_ZSTD:\n        DECODER_ERROR_CLASSES += (zstd.ZstdError,)\n\n    def __init__(\n        self,\n        *,\n        headers: typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None = None,\n        status: int,\n        version: int,\n        version_string: str,\n        reason: str | None,\n        decode_content: bool,\n        request_url: str | None,\n        retries: Retry | None = None,\n    ) -> None:\n        if isinstance(headers, HTTPHeaderDict):\n            self.headers = headers\n        else:\n            self.headers = HTTPHeaderDict(headers)  # type: ignore[arg-type]\n        self.status = status\n        self.version = version\n        self.version_string = version_string\n        self.reason = reason\n        self.decode_content = decode_content\n        self._has_decoded_content = False\n        self._request_url: str | None = request_url\n        self.retries = retries\n\n        self.chunked = False\n        tr_enc = self.headers.get(\"transfer-encoding\", \"\").lower()\n        # Don't incur the penalty of creating a list and then discarding it\n        encodings = (enc.strip() for enc in tr_enc.split(\",\"))\n        if \"chunked\" in encodings:\n            self.chunked = True\n\n        self._decoder: ContentDecoder | None = None\n        self.length_remaining: int | None\n\n    def get_redirect_location(self) -> str | None | typing.Literal[False]:\n        \"\"\"\n        Should we redirect and where to?\n\n        :returns: Truthy redirect location string if we got a redirect status\n            code and valid location. ``None`` if redirect status and no\n            location. ``False`` if not a redirect status code.\n        \"\"\"\n        if self.status in self.REDIRECT_STATUSES:\n            return self.headers.get(\"location\")\n        return False\n\n    @property\n    def data(self) -> bytes:\n        raise NotImplementedError()\n\n    def json(self) -> typing.Any:\n        \"\"\"\n        Deserializes the body of the HTTP response as a Python object.\n\n        The body of the HTTP response must be encoded using UTF-8, as per\n        `RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\n        To use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\n        your custom decoder instead.\n\n        If the body of the HTTP response is not decodable to UTF-8, a\n        `UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\n        valid JSON document, a `json.JSONDecodeError` will be raised.\n\n        Read more :ref:`here <json_content>`.\n\n        :returns: The body of the HTTP response as a Python object.\n        \"\"\"\n        data = self.data.decode(\"utf-8\")\n        return _json.loads(data)\n\n    @property\n    def url(self) -> str | None:\n        raise NotImplementedError()\n\n    @url.setter\n    def url(self, url: str | None) -> None:\n        raise NotImplementedError()\n\n    @property\n    def connection(self) -> BaseHTTPConnection | None:\n        raise NotImplementedError()\n\n    @property\n    def retries(self) -> Retry | None:\n        return self._retries\n\n    @retries.setter\n    def retries(self, retries: Retry | None) -> None:\n        # Override the request_url if retries has a redirect location.\n        if retries is not None and retries.history:\n            self.url = retries.history[-1].redirect_location\n        self._retries = retries\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Iterator[bytes]:\n        raise NotImplementedError()\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n        cache_content: bool = False,\n    ) -> bytes:\n        raise NotImplementedError()\n\n    def read1(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> bytes:\n        raise NotImplementedError()\n\n    def read_chunked(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> typing.Iterator[bytes]:\n        raise NotImplementedError()\n\n    def release_conn(self) -> None:\n        raise NotImplementedError()\n\n    def drain_conn(self) -> None:\n        raise NotImplementedError()\n\n    def close(self) -> None:\n        raise NotImplementedError()\n\n    def _init_decoder(self) -> None:\n        \"\"\"\n        Set-up the _decoder attribute if necessary.\n        \"\"\"\n        # Note: content-encoding value should be case-insensitive, per RFC 7230\n        # Section 3.2\n        content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n        if self._decoder is None:\n            if content_encoding in self.CONTENT_DECODERS:\n                self._decoder = _get_decoder(content_encoding)\n            elif \",\" in content_encoding:\n                encodings = [\n                    e.strip()\n                    for e in content_encoding.split(\",\")\n                    if e.strip() in self.CONTENT_DECODERS\n                ]\n                if encodings:\n                    self._decoder = _get_decoder(content_encoding)\n\n    def _decode(\n        self, data: bytes, decode_content: bool | None, flush_decoder: bool\n    ) -> bytes:\n        \"\"\"\n        Decode the data passed in and potentially flush the decoder.\n        \"\"\"\n        if not decode_content:\n            if self._has_decoded_content:\n                raise RuntimeError(\n                    \"Calling read(decode_content=False) is not supported after \"\n                    \"read(decode_content=True) was called.\"\n                )\n            return data\n\n        try:\n            if self._decoder:\n                data = self._decoder.decompress(data)\n                self._has_decoded_content = True\n        except self.DECODER_ERROR_CLASSES as e:\n            content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n            raise DecodeError(\n                \"Received response with content-encoding: %s, but \"\n                \"failed to decode it.\" % content_encoding,\n                e,\n            ) from e\n        if flush_decoder:\n            data += self._flush_decoder()\n\n        return data\n\n    def _flush_decoder(self) -> bytes:\n        \"\"\"\n        Flushes the decoder. Should only be called if the decoder is actually\n        being used.\n        \"\"\"\n        if self._decoder:\n            return self._decoder.decompress(b\"\") + self._decoder.flush()\n        return b\"\"\n\n    # Compatibility methods for `io` module\n    def readinto(self, b: bytearray) -> int:\n        temp = self.read(len(b))\n        if len(temp) == 0:\n            return 0\n        else:\n            b[: len(temp)] = temp\n            return len(temp)\n\n    # Compatibility methods for http.client.HTTPResponse\n    def getheaders(self) -> HTTPHeaderDict:\n        warnings.warn(\n            \"HTTPResponse.getheaders() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead access HTTPResponse.headers directly.\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.headers\n\n    def getheader(self, name: str, default: str | None = None) -> str | None:\n        warnings.warn(\n            \"HTTPResponse.getheader() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead use HTTPResponse.headers.get(name, default).\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.headers.get(name, default)\n\n    # Compatibility method for http.cookiejar\n    def info(self) -> HTTPHeaderDict:\n        return self.headers\n\n    def geturl(self) -> str | None:\n        return self.url\n\n\nclass HTTPResponse(BaseHTTPResponse):\n    \"\"\"\n    HTTP Response container.\n\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n\n    :param preload_content:\n        If True, the response's body will be preloaded during construction.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param original_response:\n        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`\n        object, it's convenient to include the original for debug purposes. It's\n        otherwise unused.\n\n    :param retries:\n        The retries contains the last :class:`~urllib3.util.retry.Retry` that\n        was used during the request.\n\n    :param enforce_content_length:\n        Enforce content length checking. Body returned by server must match\n        value of Content-Length header, if present. Otherwise, raise error.\n    \"\"\"\n\n    def __init__(\n        self,\n        body: _TYPE_BODY = \"\",\n        headers: typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None = None,\n        status: int = 0,\n        version: int = 0,\n        version_string: str = \"HTTP/?\",\n        reason: str | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        original_response: _HttplibHTTPResponse | None = None,\n        pool: HTTPConnectionPool | None = None,\n        connection: HTTPConnection | None = None,\n        msg: _HttplibHTTPMessage | None = None,\n        retries: Retry | None = None,\n        enforce_content_length: bool = True,\n        request_method: str | None = None,\n        request_url: str | None = None,\n        auto_close: bool = True,\n    ) -> None:\n        super().__init__(\n            headers=headers,\n            status=status,\n            version=version,\n            version_string=version_string,\n            reason=reason,\n            decode_content=decode_content,\n            request_url=request_url,\n            retries=retries,\n        )\n\n        self.enforce_content_length = enforce_content_length\n        self.auto_close = auto_close\n\n        self._body = None\n        self._fp: _HttplibHTTPResponse | None = None\n        self._original_response = original_response\n        self._fp_bytes_read = 0\n        self.msg = msg\n\n        if body and isinstance(body, (str, bytes)):\n            self._body = body\n\n        self._pool = pool\n        self._connection = connection\n\n        if hasattr(body, \"read\"):\n            self._fp = body  # type: ignore[assignment]\n\n        # Are we using the chunked-style of transfer encoding?\n        self.chunk_left: int | None = None\n\n        # Determine length of response\n        self.length_remaining = self._init_length(request_method)\n\n        # Used to return the correct amount of bytes for partial read()s\n        self._decoded_buffer = BytesQueueBuffer()\n\n        # If requested, preload the body.\n        if preload_content and not self._body:\n            self._body = self.read(decode_content=decode_content)\n\n    def release_conn(self) -> None:\n        if not self._pool or not self._connection:\n            return None\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self) -> None:\n        \"\"\"\n        Read and discard any remaining HTTP response data in the response connection.\n\n        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n        \"\"\"\n        try:\n            self.read()\n        except (HTTPError, OSError, BaseSSLError, HTTPException):\n            pass\n\n    @property\n    def data(self) -> bytes:\n        # For backwards-compat with earlier urllib3 0.4 and earlier.\n        if self._body:\n            return self._body  # type: ignore[return-value]\n\n        if self._fp:\n            return self.read(cache_content=True)\n\n        return None  # type: ignore[return-value]\n\n    @property\n    def connection(self) -> HTTPConnection | None:\n        return self._connection\n\n    def isclosed(self) -> bool:\n        return is_fp_closed(self._fp)\n\n    def tell(self) -> int:\n        \"\"\"\n        Obtain the number of bytes pulled over the wire so far. May differ from\n        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n        if bytes are encoded on the wire (e.g, compressed).\n        \"\"\"\n        return self._fp_bytes_read\n\n    def _init_length(self, request_method: str | None) -> int | None:\n        \"\"\"\n        Set initial length value for Response content if available.\n        \"\"\"\n        length: int | None\n        content_length: str | None = self.headers.get(\"content-length\")\n\n        if content_length is not None:\n            if self.chunked:\n                # This Response will fail with an IncompleteRead if it can't be\n                # received as chunked. This method falls back to attempt reading\n                # the response before raising an exception.\n                log.warning(\n                    \"Received response with both Content-Length and \"\n                    \"Transfer-Encoding set. This is expressly forbidden \"\n                    \"by RFC 7230 sec 3.3.2. Ignoring Content-Length and \"\n                    \"attempting to process response as Transfer-Encoding: \"\n                    \"chunked.\"\n                )\n                return None\n\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = {int(val) for val in content_length.split(\",\")}\n                if len(lengths) > 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % content_length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length < 0:\n                    length = None\n\n        else:  # if content_length is None\n            length = None\n\n        # Convert status to int for comparison\n        # In some cases, httplib returns a status of \"_UNKNOWN\"\n        try:\n            status = int(self.status)\n        except ValueError:\n            status = 0\n\n        # Check for responses that shouldn't include a body\n        if status in (204, 304) or 100 <= status < 200 or request_method == \"HEAD\":\n            length = 0\n\n        return length\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n\n        try:\n            try:\n                yield\n\n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n\n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n\n            except IncompleteRead as e:\n                if (\n                    e.expected is not None\n                    and e.partial is not None\n                    and e.expected == -e.partial\n                ):\n                    arg = \"Response may not contain content.\"\n                else:\n                    arg = f\"Connection broken: {e!r}\"\n                raise ProtocolError(arg, e) from e\n\n            except (HTTPException, OSError) as e:\n                raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\n\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now to ensure that the connection is\n                # released back to the pool.\n                if self._original_response:\n                    self._original_response.close()\n\n                # Closing the response may not actually be sufficient to close\n                # everything, so if we have a hold of the connection close that\n                # too.\n                if self._connection:\n                    self._connection.close()\n\n            # If we hold the original response but it's closed now, we should\n            # return the connection back to the pool.\n            if self._original_response and self._original_response.isclosed():\n                self.release_conn()\n\n    def _fp_read(\n        self,\n        amt: int | None = None,\n        *,\n        read1: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Read a response with the thought that reading the number of bytes\n        larger than can fit in a 32-bit int at a time via SSL in some\n        known cases leads to an overflow error that has to be prevented\n        if `amt` or `self.length_remaining` indicate that a problem may\n        happen.\n\n        The known cases:\n          * 3.8 <= CPython < 3.9.7 because of a bug\n            https://github.com/urllib3/urllib3/issues/2513#issuecomment-1152559900.\n          * urllib3 injected with pyOpenSSL-backed SSL-support.\n          * CPython < 3.10 only when `amt` does not fit 32-bit int.\n        \"\"\"\n        assert self._fp\n        c_int_max = 2**31 - 1\n        if (\n            (amt and amt > c_int_max)\n            or (\n                amt is None\n                and self.length_remaining\n                and self.length_remaining > c_int_max\n            )\n        ) and (util.IS_PYOPENSSL or sys.version_info < (3, 10)):\n            if read1:\n                return self._fp.read1(c_int_max)\n            buffer = io.BytesIO()\n            # Besides `max_chunk_amt` being a maximum chunk size, it\n            # affects memory overhead of reading a response by this\n            # method in CPython.\n            # `c_int_max` equal to 2 GiB - 1 byte is the actual maximum\n            # chunk size that does not lead to an overflow error, but\n            # 256 MiB is a compromise.\n            max_chunk_amt = 2**28\n            while amt is None or amt != 0:\n                if amt is not None:\n                    chunk_amt = min(amt, max_chunk_amt)\n                    amt -= chunk_amt\n                else:\n                    chunk_amt = max_chunk_amt\n                data = self._fp.read(chunk_amt)\n                if not data:\n                    break\n                buffer.write(data)\n                del data  # to reduce peak memory usage by `max_chunk_amt`.\n            return buffer.getvalue()\n        elif read1:\n            return self._fp.read1(amt) if amt is not None else self._fp.read1()\n        else:\n            # StringIO doesn't like amt=None\n            return self._fp.read(amt) if amt is not None else self._fp.read()\n\n    def _raw_read(\n        self,\n        amt: int | None = None,\n        *,\n        read1: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Reads `amt` of bytes from the socket.\n        \"\"\"\n        if self._fp is None:\n            return None  # type: ignore[return-value]\n\n        fp_closed = getattr(self._fp, \"closed\", False)\n\n        with self._error_catcher():\n            data = self._fp_read(amt, read1=read1) if not fp_closed else b\"\"\n            if amt is not None and amt != 0 and not data:\n                # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                if (\n                    self.enforce_content_length\n                    and self.length_remaining is not None\n                    and self.length_remaining != 0\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n                    raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n            elif read1 and (\n                (amt != 0 and not data) or self.length_remaining == len(data)\n            ):\n                # All data has been read, but `self._fp.read1` in\n                # CPython 3.12 and older doesn't always close\n                # `http.client.HTTPResponse`, so we close it here.\n                # See https://github.com/python/cpython/issues/113199\n                self._fp.close()\n\n        if data:\n            self._fp_bytes_read += len(data)\n            if self.length_remaining is not None:\n                self.length_remaining -= len(data)\n        return data\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n        cache_content: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n\n        if amt and amt < 0:\n            # Negative numbers and `None` should be treated the same.\n            amt = None\n        elif amt is not None:\n            cache_content = False\n\n            if len(self._decoded_buffer) >= amt:\n                return self._decoded_buffer.get(amt)\n\n        data = self._raw_read(amt)\n\n        flush_decoder = amt is None or (amt != 0 and not data)\n\n        if not data and len(self._decoded_buffer) == 0:\n            return data\n\n        if amt is None:\n            data = self._decode(data, decode_content, flush_decoder)\n            if cache_content:\n                self._body = data\n        else:\n            # do not waste memory on buffer when not decoding\n            if not decode_content:\n                if self._has_decoded_content:\n                    raise RuntimeError(\n                        \"Calling read(decode_content=False) is not supported after \"\n                        \"read(decode_content=True) was called.\"\n                    )\n                return data\n\n            decoded_data = self._decode(data, decode_content, flush_decoder)\n            self._decoded_buffer.put(decoded_data)\n\n            while len(self._decoded_buffer) < amt and data:\n                # TODO make sure to initially read enough data to get past the headers\n                # For example, the GZ file header takes 10 bytes, we don't want to read\n                # it one byte at a time\n                data = self._raw_read(amt)\n                decoded_data = self._decode(data, decode_content, flush_decoder)\n                self._decoded_buffer.put(decoded_data)\n            data = self._decoded_buffer.get(amt)\n\n        return data\n\n    def read1(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> bytes:\n        \"\"\"\n        Similar to ``http.client.HTTPResponse.read1`` and documented\n        in :meth:`io.BufferedReader.read1`, but with an additional parameter:\n        ``decode_content``.\n\n        :param amt:\n            How much of the content to read.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if decode_content is None:\n            decode_content = self.decode_content\n        if amt and amt < 0:\n            # Negative numbers and `None` should be treated the same.\n            amt = None\n        # try and respond without going to the network\n        if self._has_decoded_content:\n            if not decode_content:\n                raise RuntimeError(\n                    \"Calling read1(decode_content=False) is not supported after \"\n                    \"read1(decode_content=True) was called.\"\n                )\n            if len(self._decoded_buffer) > 0:\n                if amt is None:\n                    return self._decoded_buffer.get_all()\n                return self._decoded_buffer.get(amt)\n        if amt == 0:\n            return b\"\"\n\n        # FIXME, this method's type doesn't say returning None is possible\n        data = self._raw_read(amt, read1=True)\n        if not decode_content or data is None:\n            return data\n\n        self._init_decoder()\n        while True:\n            flush_decoder = not data\n            decoded_data = self._decode(data, decode_content, flush_decoder)\n            self._decoded_buffer.put(decoded_data)\n            if decoded_data or flush_decoder:\n                break\n            data = self._raw_read(8192, read1=True)\n\n        if amt is None:\n            return self._decoded_buffer.get_all()\n        return self._decoded_buffer.get(amt)\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            yield from self.read_chunked(amt, decode_content=decode_content)\n        else:\n            while not is_fp_closed(self._fp) or len(self._decoded_buffer) > 0:\n                data = self.read(amt=amt, decode_content=decode_content)\n\n                if data:\n                    yield data\n\n    # Overrides from io.IOBase\n    def readable(self) -> bool:\n        return True\n\n    def close(self) -> None:\n        if not self.closed and self._fp:\n            self._fp.close()\n\n        if self._connection:\n            self._connection.close()\n\n        if not self.auto_close:\n            io.IOBase.close(self)\n\n    @property\n    def closed(self) -> bool:\n        if not self.auto_close:\n            return io.IOBase.closed.__get__(self)  # type: ignore[no-any-return]\n        elif self._fp is None:\n            return True\n        elif hasattr(self._fp, \"isclosed\"):\n            return self._fp.isclosed()\n        elif hasattr(self._fp, \"closed\"):\n            return self._fp.closed\n        else:\n            return True\n\n    def fileno(self) -> int:\n        if self._fp is None:\n            raise OSError(\"HTTPResponse has no file to get a fileno from\")\n        elif hasattr(self._fp, \"fileno\"):\n            return self._fp.fileno()\n        else:\n            raise OSError(\n                \"The file-like object this HTTPResponse is wrapped \"\n                \"around has no file descriptor\"\n            )\n\n    def flush(self) -> None:\n        if (\n            self._fp is not None\n            and hasattr(self._fp, \"flush\")\n            and not getattr(self._fp, \"closed\", False)\n        ):\n            return self._fp.flush()\n\n    def supports_chunked_reads(self) -> bool:\n        \"\"\"\n        Checks if the underlying file-like object looks like a\n        :class:`http.client.HTTPResponse` object. We do this by testing for\n        the fp attribute. If it is present we assume it returns raw chunks as\n        processed by read_chunked().\n        \"\"\"\n        return hasattr(self._fp, \"fp\")\n\n    def _update_chunk_length(self) -> None:\n        # First, we'll figure out length of a chunk and then\n        # we'll try to read it from socket.\n        if self.chunk_left is not None:\n            return None\n        line = self._fp.fp.readline()  # type: ignore[union-attr]\n        line = line.split(b\";\", 1)[0]\n        try:\n            self.chunk_left = int(line, 16)\n        except ValueError:\n            self.close()\n            if line:\n                # Invalid chunked protocol response, abort.\n                raise InvalidChunkLength(self, line) from None\n            else:\n                # Truncated at start of next chunk\n                raise ProtocolError(\"Response ended prematurely\") from None\n\n    def _handle_chunk(self, amt: int | None) -> bytes:\n        returned_chunk = None\n        if amt is None:\n            chunk = self._fp._safe_read(self.chunk_left)  # type: ignore[union-attr]\n            returned_chunk = chunk\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        elif self.chunk_left is not None and amt < self.chunk_left:\n            value = self._fp._safe_read(amt)  # type: ignore[union-attr]\n            self.chunk_left = self.chunk_left - amt\n            returned_chunk = value\n        elif amt == self.chunk_left:\n            value = self._fp._safe_read(amt)  # type: ignore[union-attr]\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n            returned_chunk = value\n        else:  # amt > self.chunk_left\n            returned_chunk = self._fp._safe_read(self.chunk_left)  # type: ignore[union-attr]\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        return returned_chunk  # type: ignore[no-any-return]\n\n    def read_chunked(\n        self, amt: int | None = None, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        Similar to :meth:`HTTPResponse.read`, but with an additional\n        parameter: ``decode_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        self._init_decoder()\n        # FIXME: Rewrite this method and make it a class with a better structured logic.\n        if not self.chunked:\n            raise ResponseNotChunked(\n                \"Response is not chunked. \"\n                \"Header 'transfer-encoding: chunked' is missing.\"\n            )\n        if not self.supports_chunked_reads():\n            raise BodyNotHttplibCompatible(\n                \"Body should be http.client.HTTPResponse like. \"\n                \"It should have have an fp attribute which returns raw chunks.\"\n            )\n\n        with self._error_catcher():\n            # Don't bother reading the body of a HEAD request.\n            if self._original_response and is_response_to_head(self._original_response):\n                self._original_response.close()\n                return None\n\n            # If a response is already read and closed\n            # then return immediately.\n            if self._fp.fp is None:  # type: ignore[union-attr]\n                return None\n\n            if amt and amt < 0:\n                # Negative numbers and `None` should be treated the same,\n                # but httplib handles only `None` correctly.\n                amt = None\n\n            while True:\n                self._update_chunk_length()\n                if self.chunk_left == 0:\n                    break\n                chunk = self._handle_chunk(amt)\n                decoded = self._decode(\n                    chunk, decode_content=decode_content, flush_decoder=False\n                )\n                if decoded:\n                    yield decoded\n\n            if decode_content:\n                # On CPython and PyPy, we should never need to flush the\n                # decoder. However, on Jython we *might* need to, so\n                # lets defensively do it anyway.\n                decoded = self._flush_decoder()\n                if decoded:  # Platform-specific: Jython.\n                    yield decoded\n\n            # Chunk content ends with \\r\\n: discard it.\n            while self._fp is not None:\n                line = self._fp.fp.readline()\n                if not line:\n                    # Some sites may not end with '\\r\\n'.\n                    break\n                if line == b\"\\r\\n\":\n                    break\n\n            # We read everything; close the \"file\".\n            if self._original_response:\n                self._original_response.close()\n\n    @property\n    def url(self) -> str | None:\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        return self._request_url\n\n    @url.setter\n    def url(self, url: str) -> None:\n        self._request_url = url\n\n    def __iter__(self) -> typing.Iterator[bytes]:\n        buffer: list[bytes] = []\n        for chunk in self.stream(decode_content=True):\n            if b\"\\n\" in chunk:\n                chunks = chunk.split(b\"\\n\")\n                yield b\"\".join(buffer) + chunks[0] + b\"\\n\"\n                for x in chunks[1:-1]:\n                    yield x + b\"\\n\"\n                if chunks[-1]:\n                    buffer = [chunks[-1]]\n                else:\n                    buffer = []\n            else:\n                buffer.append(chunk)\n        if buffer:\n            yield b\"\".join(buffer)\n", "src/urllib3/connection.py": "from __future__ import annotations\n\nimport datetime\nimport logging\nimport os\nimport re\nimport socket\nimport sys\nimport typing\nimport warnings\nfrom http.client import HTTPConnection as _HTTPConnection\nfrom http.client import HTTPException as HTTPException  # noqa: F401\nfrom http.client import ResponseNotReady\nfrom socket import timeout as SocketTimeout\n\nif typing.TYPE_CHECKING:\n    from .response import HTTPResponse\n    from .util.ssl_ import _TYPE_PEER_CERT_RET_DICT\n    from .util.ssltransport import SSLTransport\n\nfrom ._collections import HTTPHeaderDict\nfrom .util.response import assert_header_parsing\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT, Timeout\nfrom .util.util import to_str\nfrom .util.wait import wait_for_read\n\ntry:  # Compiled with SSL?\n    import ssl\n\n    BaseSSLError = ssl.SSLError\nexcept (ImportError, AttributeError):\n    ssl = None  # type: ignore[assignment]\n\n    class BaseSSLError(BaseException):  # type: ignore[no-redef]\n        pass\n\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._base_connection import ProxyConfig as ProxyConfig\nfrom ._base_connection import _ResponseOptions as _ResponseOptions\nfrom ._version import __version__\nfrom .exceptions import (\n    ConnectTimeoutError,\n    HeaderParsingError,\n    NameResolutionError,\n    NewConnectionError,\n    ProxyError,\n    SystemTimeWarning,\n)\nfrom .util import SKIP_HEADER, SKIPPABLE_HEADERS, connection, ssl_\nfrom .util.request import body_to_chunks\nfrom .util.ssl_ import assert_fingerprint as _assert_fingerprint\nfrom .util.ssl_ import (\n    create_urllib3_context,\n    is_ipaddress,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom .util.ssl_match_hostname import CertificateError, match_hostname\nfrom .util.url import Url\n\n# Not a no-op, we're adding this to the namespace so it can be imported.\nConnectionError = ConnectionError\nBrokenPipeError = BrokenPipeError\n\n\nlog = logging.getLogger(__name__)\n\nport_by_scheme = {\"http\": 80, \"https\": 443}\n\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2023, 6, 1)\n\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\n\n_HAS_SYS_AUDIT = hasattr(sys, \"audit\")\n\n\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.\n\n      For example, if you wish to enable TCP Keep Alive in addition to the defaults,\n      you might pass:\n\n      .. code-block:: python\n\n         HTTPConnection.default_socket_options + [\n             (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),\n         ]\n\n      Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).\n    \"\"\"\n\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]  # type: ignore[misc]\n\n    #: Disable Nagle's algorithm by default.\n    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``\n    default_socket_options: typing.ClassVar[connection._TYPE_SOCKET_OPTIONS] = [\n        (socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    ]\n\n    #: Whether this connection verifies the host's certificate.\n    is_verified: bool = False\n\n    #: Whether this proxy connection verified the proxy host's certificate.\n    # If no proxy is currently connected to the value will be ``None``.\n    proxy_is_verified: bool | None = None\n\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: connection._TYPE_SOCKET_OPTIONS | None\n\n    _has_connected_to_proxy: bool\n    _response_options: _ResponseOptions | None\n    _tunnel_host: str | None\n    _tunnel_port: int | None\n    _tunnel_scheme: str | None\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | (connection._TYPE_SOCKET_OPTIONS) = default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n    ) -> None:\n        super().__init__(\n            host=host,\n            port=port,\n            timeout=Timeout.resolve_default_timeout(timeout),\n            source_address=source_address,\n            blocksize=blocksize,\n        )\n        self.socket_options = socket_options\n        self.proxy = proxy\n        self.proxy_config = proxy_config\n\n        self._has_connected_to_proxy = False\n        self._response_options = None\n        self._tunnel_host: str | None = None\n        self._tunnel_port: int | None = None\n        self._tunnel_scheme: str | None = None\n\n    @property\n    def host(self) -> str:\n        \"\"\"\n        Getter method to remove any trailing dots that indicate the hostname is an FQDN.\n\n        In general, SSL certificates don't include the trailing dot indicating a\n        fully-qualified domain name, and thus, they don't validate properly when\n        checked against a domain name that includes the dot. In addition, some\n        servers may not expect to receive the trailing dot when provided.\n\n        However, the hostname with trailing dot is critical to DNS resolution; doing a\n        lookup with the trailing dot will properly only resolve the appropriate FQDN,\n        whereas a lookup without a trailing dot will search the system's search domain\n        list. Thus, it's important to keep the original host around for use only in\n        those cases where it's appropriate (i.e., when doing DNS lookup to establish the\n        actual TCP connection across which we're going to send HTTP requests).\n        \"\"\"\n        return self._dns_host.rstrip(\".\")\n\n    @host.setter\n    def host(self, value: str) -> None:\n        \"\"\"\n        Setter for the `host` property.\n\n        We assume that only urllib3 uses the _dns_host attribute; httplib itself\n        only uses `host`, and it seems reasonable that other libraries follow suit.\n        \"\"\"\n        self._dns_host = value\n\n    def _new_conn(self) -> socket.socket:\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n\n        :return: New socket connection.\n        \"\"\"\n        try:\n            sock = connection.create_connection(\n                (self._dns_host, self.port),\n                self.timeout,\n                source_address=self.source_address,\n                socket_options=self.socket_options,\n            )\n        except socket.gaierror as e:\n            raise NameResolutionError(self.host, self, e) from e\n        except SocketTimeout as e:\n            raise ConnectTimeoutError(\n                self,\n                f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n            ) from e\n\n        except OSError as e:\n            raise NewConnectionError(\n                self, f\"Failed to establish a new connection: {e}\"\n            ) from e\n\n        # Audit hooks are only available in Python 3.8+\n        if _HAS_SYS_AUDIT:\n            sys.audit(\"http.client.connect\", self, self.host, self.port)\n\n        return sock\n\n    def set_tunnel(\n        self,\n        host: str,\n        port: int | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        scheme: str = \"http\",\n    ) -> None:\n        if scheme not in (\"http\", \"https\"):\n            raise ValueError(\n                f\"Invalid proxy scheme for tunneling: {scheme!r}, must be either 'http' or 'https'\"\n            )\n        super().set_tunnel(host, port=port, headers=headers)\n        self._tunnel_scheme = scheme\n\n    def connect(self) -> None:\n        self.sock = self._new_conn()\n        if self._tunnel_host:\n            # If we're tunneling it means we're connected to our proxy.\n            self._has_connected_to_proxy = True\n\n            # TODO: Fix tunnel so it doesn't depend on self.sock state.\n            self._tunnel()  # type: ignore[attr-defined]\n\n        # If there's a proxy to be connected to we are fully connected.\n        # This is set twice (once above and here) due to forwarding proxies\n        # not using tunnelling.\n        self._has_connected_to_proxy = bool(self.proxy)\n\n        if self._has_connected_to_proxy:\n            self.proxy_is_verified = False\n\n    @property\n    def is_closed(self) -> bool:\n        return self.sock is None\n\n    @property\n    def is_connected(self) -> bool:\n        if self.sock is None:\n            return False\n        return not wait_for_read(self.sock, timeout=0.0)\n\n    @property\n    def has_connected_to_proxy(self) -> bool:\n        return self._has_connected_to_proxy\n\n    @property\n    def proxy_is_forwarding(self) -> bool:\n        \"\"\"\n        Return True if a forwarding proxy is configured, else return False\n        \"\"\"\n        return bool(self.proxy) and self._tunnel_host is None\n\n    def close(self) -> None:\n        try:\n            super().close()\n        finally:\n            # Reset all stateful properties so connection\n            # can be re-used without leaking prior configs.\n            self.sock = None\n            self.is_verified = False\n            self.proxy_is_verified = None\n            self._has_connected_to_proxy = False\n            self._response_options = None\n            self._tunnel_host = None\n            self._tunnel_port = None\n            self._tunnel_scheme = None\n\n    def putrequest(\n        self,\n        method: str,\n        url: str,\n        skip_host: bool = False,\n        skip_accept_encoding: bool = False,\n    ) -> None:\n        \"\"\"\"\"\"\n        # Empty docstring because the indentation of CPython's implementation\n        # is broken but we don't want this method in our documentation.\n        match = _CONTAINS_CONTROL_CHAR_RE.search(method)\n        if match:\n            raise ValueError(\n                f\"Method cannot contain non-token characters {method!r} (found at least {match.group()!r})\"\n            )\n\n        return super().putrequest(\n            method, url, skip_host=skip_host, skip_accept_encoding=skip_accept_encoding\n        )\n\n    def putheader(self, header: str, *values: str) -> None:  # type: ignore[override]\n        \"\"\"\"\"\"\n        if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):\n            super().putheader(header, *values)\n        elif to_str(header.lower()) not in SKIPPABLE_HEADERS:\n            skippable_headers = \"', '\".join(\n                [str.title(header) for header in sorted(SKIPPABLE_HEADERS)]\n            )\n            raise ValueError(\n                f\"urllib3.util.SKIP_HEADER only supports '{skippable_headers}'\"\n            )\n\n    # `request` method's signature intentionally violates LSP.\n    # urllib3's API is different from `http.client.HTTPConnection` and the subclassing is only incidental.\n    def request(  # type: ignore[override]\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        *,\n        chunked: bool = False,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> None:\n        # Update the inner socket's timeout value to send the request.\n        # This only triggers if the connection is re-used.\n        if self.sock is not None:\n            self.sock.settimeout(self.timeout)\n\n        # Store these values to be fed into the HTTPResponse\n        # object later. TODO: Remove this in favor of a real\n        # HTTP lifecycle mechanism.\n\n        # We have to store these before we call .request()\n        # because sometimes we can still salvage a response\n        # off the wire even if we aren't able to completely\n        # send the request body.\n        self._response_options = _ResponseOptions(\n            request_method=method,\n            request_url=url,\n            preload_content=preload_content,\n            decode_content=decode_content,\n            enforce_content_length=enforce_content_length,\n        )\n\n        if headers is None:\n            headers = {}\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\n        skip_accept_encoding = \"accept-encoding\" in header_keys\n        skip_host = \"host\" in header_keys\n        self.putrequest(\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n        )\n\n        # Transform the body into an iterable of sendall()-able chunks\n        # and detect if an explicit Content-Length is doable.\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\n        chunks = chunks_and_cl.chunks\n        content_length = chunks_and_cl.content_length\n\n        # When chunked is explicit set to 'True' we respect that.\n        if chunked:\n            if \"transfer-encoding\" not in header_keys:\n                self.putheader(\"Transfer-Encoding\", \"chunked\")\n        else:\n            # Detect whether a framing mechanism is already in use. If so\n            # we respect that value, otherwise we pick chunked vs content-length\n            # depending on the type of 'body'.\n            if \"content-length\" in header_keys:\n                chunked = False\n            elif \"transfer-encoding\" in header_keys:\n                chunked = True\n\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\n            else:\n                chunked = False\n                if content_length is None:\n                    if chunks is not None:\n                        chunked = True\n                        self.putheader(\"Transfer-Encoding\", \"chunked\")\n                else:\n                    self.putheader(\"Content-Length\", str(content_length))\n\n        # Now that framing headers are out of the way we send all the other headers.\n        if \"user-agent\" not in header_keys:\n            self.putheader(\"User-Agent\", _get_default_user_agent())\n        for header, value in headers.items():\n            self.putheader(header, value)\n        self.endheaders()\n\n        # If we're given a body we start sending that in chunks.\n        if chunks is not None:\n            for chunk in chunks:\n                # Sending empty chunks isn't allowed for TE: chunked\n                # as it indicates the end of the body.\n                if not chunk:\n                    continue\n                if isinstance(chunk, str):\n                    chunk = chunk.encode(\"utf-8\")\n                if chunked:\n                    self.send(b\"%x\\r\\n%b\\r\\n\" % (len(chunk), chunk))\n                else:\n                    self.send(chunk)\n\n        # Regardless of whether we have a body or not, if we're in\n        # chunked mode we want to send an explicit empty chunk.\n        if chunked:\n            self.send(b\"0\\r\\n\\r\\n\")\n\n    def request_chunked(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n    ) -> None:\n        \"\"\"\n        Alternative to the common request method, which sends the\n        body with chunked encoding and not as one block\n        \"\"\"\n        warnings.warn(\n            \"HTTPConnection.request_chunked() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead use HTTPConnection.request(..., chunked=True).\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        self.request(method, url, body=body, headers=headers, chunked=True)\n\n    def getresponse(  # type: ignore[override]\n        self,\n    ) -> HTTPResponse:\n        \"\"\"\n        Get the response from the server.\n\n        If the HTTPConnection is in the correct state, returns an instance of HTTPResponse or of whatever object is returned by the response_class variable.\n\n        If a request has not been sent or if a previous response has not be handled, ResponseNotReady is raised. If the HTTP response indicates that the connection should be closed, then it will be closed before the response is returned. When the connection is closed, the underlying socket is closed.\n        \"\"\"\n        # Raise the same error as http.client.HTTPConnection\n        if self._response_options is None:\n            raise ResponseNotReady()\n\n        # Reset this attribute for being used again.\n        resp_options = self._response_options\n        self._response_options = None\n\n        # Since the connection's timeout value may have been updated\n        # we need to set the timeout on the socket.\n        self.sock.settimeout(self.timeout)\n\n        # This is needed here to avoid circular import errors\n        from .response import HTTPResponse\n\n        # Get the response from http.client.HTTPConnection\n        httplib_response = super().getresponse()\n\n        try:\n            assert_header_parsing(httplib_response.msg)\n        except (HeaderParsingError, TypeError) as hpe:\n            log.warning(\n                \"Failed to parse headers (url=%s): %s\",\n                _url_from_connection(self, resp_options.request_url),\n                hpe,\n                exc_info=True,\n            )\n\n        headers = HTTPHeaderDict(httplib_response.msg.items())\n\n        response = HTTPResponse(\n            body=httplib_response,\n            headers=headers,\n            status=httplib_response.status,\n            version=httplib_response.version,\n            version_string=getattr(self, \"_http_vsn_str\", \"HTTP/?\"),\n            reason=httplib_response.reason,\n            preload_content=resp_options.preload_content,\n            decode_content=resp_options.decode_content,\n            original_response=httplib_response,\n            enforce_content_length=resp_options.enforce_content_length,\n            request_method=resp_options.request_method,\n            request_url=resp_options.request_url,\n        )\n        return response\n\n\nclass HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n\n    default_port = port_by_scheme[\"https\"]  # type: ignore[misc]\n\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    ssl_version: int | str | None = None\n    ssl_minimum_version: int | None = None\n    ssl_maximum_version: int | None = None\n    assert_fingerprint: str | None = None\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | (connection._TYPE_SOCKET_OPTIONS) = HTTPConnection.default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n        cert_reqs: int | str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        server_hostname: str | None = None,\n        ssl_context: ssl.SSLContext | None = None,\n        ca_certs: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n        ssl_minimum_version: int | None = None,\n        ssl_maximum_version: int | None = None,\n        ssl_version: int | str | None = None,  # Deprecated\n        cert_file: str | None = None,\n        key_file: str | None = None,\n        key_password: str | None = None,\n    ) -> None:\n        super().__init__(\n            host,\n            port=port,\n            timeout=timeout,\n            source_address=source_address,\n            blocksize=blocksize,\n            socket_options=socket_options,\n            proxy=proxy,\n            proxy_config=proxy_config,\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.key_password = key_password\n        self.ssl_context = ssl_context\n        self.server_hostname = server_hostname\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n        # cert_reqs depends on ssl_context so calculate last.\n        if cert_reqs is None:\n            if self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n            else:\n                cert_reqs = resolve_cert_reqs(None)\n        self.cert_reqs = cert_reqs\n\n    def set_cert(\n        self,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n    ) -> None:\n        \"\"\"\n        This method should only be called once, before the connection is used.\n        \"\"\"\n        warnings.warn(\n            \"HTTPSConnection.set_cert() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead provide the parameters to the \"\n            \"HTTPSConnection constructor.\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n\n        # If cert_reqs is not provided we'll assume CERT_REQUIRED unless we also\n        # have an SSLContext object in which case we'll use its verify_mode.\n        if cert_reqs is None:\n            if self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n            else:\n                cert_reqs = resolve_cert_reqs(None)\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n    def connect(self) -> None:\n        sock: socket.socket | ssl.SSLSocket\n        self.sock = sock = self._new_conn()\n        server_hostname: str = self.host\n        tls_in_tls = False\n\n        # Do we need to establish a tunnel?\n        if self._tunnel_host is not None:\n            # We're tunneling to an HTTPS origin so need to do TLS-in-TLS.\n            if self._tunnel_scheme == \"https\":\n                # _connect_tls_proxy will verify and assign proxy_is_verified\n                self.sock = sock = self._connect_tls_proxy(self.host, sock)\n                tls_in_tls = True\n            elif self._tunnel_scheme == \"http\":\n                self.proxy_is_verified = False\n\n            # If we're tunneling it means we're connected to our proxy.\n            self._has_connected_to_proxy = True\n\n            self._tunnel()  # type: ignore[attr-defined]\n            # Override the host with the one we're requesting data from.\n            server_hostname = self._tunnel_host\n\n        if self.server_hostname is not None:\n            server_hostname = self.server_hostname\n\n        is_time_off = datetime.date.today() < RECENT_DATE\n        if is_time_off:\n            warnings.warn(\n                (\n                    f\"System time is way off (before {RECENT_DATE}). This will probably \"\n                    \"lead to SSL verification errors\"\n                ),\n                SystemTimeWarning,\n            )\n\n        # Remove trailing '.' from fqdn hostnames to allow certificate validation\n        server_hostname_rm_dot = server_hostname.rstrip(\".\")\n\n        sock_and_verified = _ssl_wrap_socket_and_match_hostname(\n            sock=sock,\n            cert_reqs=self.cert_reqs,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            server_hostname=server_hostname_rm_dot,\n            ssl_context=self.ssl_context,\n            tls_in_tls=tls_in_tls,\n            assert_hostname=self.assert_hostname,\n            assert_fingerprint=self.assert_fingerprint,\n        )\n        self.sock = sock_and_verified.socket\n\n        # Forwarding proxies can never have a verified target since\n        # the proxy is the one doing the verification. Should instead\n        # use a CONNECT tunnel in order to verify the target.\n        # See: https://github.com/urllib3/urllib3/issues/3267.\n        if self.proxy_is_forwarding:\n            self.is_verified = False\n        else:\n            self.is_verified = sock_and_verified.is_verified\n\n        # If there's a proxy to be connected to we are fully connected.\n        # This is set twice (once above and here) due to forwarding proxies\n        # not using tunnelling.\n        self._has_connected_to_proxy = bool(self.proxy)\n\n        # Set `self.proxy_is_verified` unless it's already set while\n        # establishing a tunnel.\n        if self._has_connected_to_proxy and self.proxy_is_verified is None:\n            self.proxy_is_verified = sock_and_verified.is_verified\n\n    def _connect_tls_proxy(self, hostname: str, sock: socket.socket) -> ssl.SSLSocket:\n        \"\"\"\n        Establish a TLS connection to the proxy using the provided SSL context.\n        \"\"\"\n        # `_connect_tls_proxy` is called when self._tunnel_host is truthy.\n        proxy_config = typing.cast(ProxyConfig, self.proxy_config)\n        ssl_context = proxy_config.ssl_context\n        sock_and_verified = _ssl_wrap_socket_and_match_hostname(\n            sock,\n            cert_reqs=self.cert_reqs,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            server_hostname=hostname,\n            ssl_context=ssl_context,\n            assert_hostname=proxy_config.assert_hostname,\n            assert_fingerprint=proxy_config.assert_fingerprint,\n            # Features that aren't implemented for proxies yet:\n            cert_file=None,\n            key_file=None,\n            key_password=None,\n            tls_in_tls=False,\n        )\n        self.proxy_is_verified = sock_and_verified.is_verified\n        return sock_and_verified.socket  # type: ignore[return-value]\n\n\nclass _WrappedAndVerifiedSocket(typing.NamedTuple):\n    \"\"\"\n    Wrapped socket and whether the connection is\n    verified after the TLS handshake\n    \"\"\"\n\n    socket: ssl.SSLSocket | SSLTransport\n    is_verified: bool\n\n\ndef _ssl_wrap_socket_and_match_hostname(\n    sock: socket.socket,\n    *,\n    cert_reqs: None | str | int,\n    ssl_version: None | str | int,\n    ssl_minimum_version: int | None,\n    ssl_maximum_version: int | None,\n    cert_file: str | None,\n    key_file: str | None,\n    key_password: str | None,\n    ca_certs: str | None,\n    ca_cert_dir: str | None,\n    ca_cert_data: None | str | bytes,\n    assert_hostname: None | str | typing.Literal[False],\n    assert_fingerprint: str | None,\n    server_hostname: str | None,\n    ssl_context: ssl.SSLContext | None,\n    tls_in_tls: bool = False,\n) -> _WrappedAndVerifiedSocket:\n    \"\"\"Logic for constructing an SSLContext from all TLS parameters, passing\n    that down into ssl_wrap_socket, and then doing certificate verification\n    either via hostname or fingerprint. This function exists to guarantee\n    that both proxies and targets have the same behavior when connecting via TLS.\n    \"\"\"\n    default_ssl_context = False\n    if ssl_context is None:\n        default_ssl_context = True\n        context = create_urllib3_context(\n            ssl_version=resolve_ssl_version(ssl_version),\n            ssl_minimum_version=ssl_minimum_version,\n            ssl_maximum_version=ssl_maximum_version,\n            cert_reqs=resolve_cert_reqs(cert_reqs),\n        )\n    else:\n        context = ssl_context\n\n    context.verify_mode = resolve_cert_reqs(cert_reqs)\n\n    # In some cases, we want to verify hostnames ourselves\n    if (\n        # `ssl` can't verify fingerprints or alternate hostnames\n        assert_fingerprint\n        or assert_hostname\n        # assert_hostname can be set to False to disable hostname checking\n        or assert_hostname is False\n        # We still support OpenSSL 1.0.2, which prevents us from verifying\n        # hostnames easily: https://github.com/pyca/pyopenssl/pull/933\n        or ssl_.IS_PYOPENSSL\n        or not ssl_.HAS_NEVER_CHECK_COMMON_NAME\n    ):\n        context.check_hostname = False\n\n    # Try to load OS default certs if none are given. We need to do the hasattr() check\n    # for custom pyOpenSSL SSLContext objects because they don't support\n    # load_default_certs().\n    if (\n        not ca_certs\n        and not ca_cert_dir\n        and not ca_cert_data\n        and default_ssl_context\n        and hasattr(context, \"load_default_certs\")\n    ):\n        context.load_default_certs()\n\n    # Ensure that IPv6 addresses are in the proper format and don't have a\n    # scope ID. Python's SSL module fails to recognize scoped IPv6 addresses\n    # and interprets them as DNS hostnames.\n    if server_hostname is not None:\n        normalized = server_hostname.strip(\"[]\")\n        if \"%\" in normalized:\n            normalized = normalized[: normalized.rfind(\"%\")]\n        if is_ipaddress(normalized):\n            server_hostname = normalized\n\n    ssl_sock = ssl_wrap_socket(\n        sock=sock,\n        keyfile=key_file,\n        certfile=cert_file,\n        key_password=key_password,\n        ca_certs=ca_certs,\n        ca_cert_dir=ca_cert_dir,\n        ca_cert_data=ca_cert_data,\n        server_hostname=server_hostname,\n        ssl_context=context,\n        tls_in_tls=tls_in_tls,\n    )\n\n    try:\n        if assert_fingerprint:\n            _assert_fingerprint(\n                ssl_sock.getpeercert(binary_form=True), assert_fingerprint\n            )\n        elif (\n            context.verify_mode != ssl.CERT_NONE\n            and not context.check_hostname\n            and assert_hostname is not False\n        ):\n            cert: _TYPE_PEER_CERT_RET_DICT = ssl_sock.getpeercert()  # type: ignore[assignment]\n\n            # Need to signal to our match_hostname whether to use 'commonName' or not.\n            # If we're using our own constructed SSLContext we explicitly set 'False'\n            # because PyPy hard-codes 'True' from SSLContext.hostname_checks_common_name.\n            if default_ssl_context:\n                hostname_checks_common_name = False\n            else:\n                hostname_checks_common_name = (\n                    getattr(context, \"hostname_checks_common_name\", False) or False\n                )\n\n            _match_hostname(\n                cert,\n                assert_hostname or server_hostname,  # type: ignore[arg-type]\n                hostname_checks_common_name,\n            )\n\n        return _WrappedAndVerifiedSocket(\n            socket=ssl_sock,\n            is_verified=context.verify_mode == ssl.CERT_REQUIRED\n            or bool(assert_fingerprint),\n        )\n    except BaseException:\n        ssl_sock.close()\n        raise\n\n\ndef _match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    asserted_hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    # Our upstream implementation of ssl.match_hostname()\n    # only applies this normalization to IP addresses so it doesn't\n    # match DNS SANs so we do the same thing!\n    stripped_hostname = asserted_hostname.strip(\"[]\")\n    if is_ipaddress(stripped_hostname):\n        asserted_hostname = stripped_hostname\n\n    try:\n        match_hostname(cert, asserted_hostname, hostname_checks_common_name)\n    except CertificateError as e:\n        log.warning(\n            \"Certificate did not match expected hostname: %s. Certificate: %s\",\n            asserted_hostname,\n            cert,\n        )\n        # Add cert to exception and reraise so client code can inspect\n        # the cert when catching the exception, if they want to\n        e._peer_cert = cert  # type: ignore[attr-defined]\n        raise\n\n\ndef _wrap_proxy_error(err: Exception, proxy_scheme: str | None) -> ProxyError:\n    # Look for the phrase 'wrong version number', if found\n    # then we should warn the user that we're very sure that\n    # this proxy is HTTP-only and they have a configuration issue.\n    error_normalized = \" \".join(re.split(\"[^a-z]\", str(err).lower()))\n    is_likely_http_proxy = (\n        \"wrong version number\" in error_normalized\n        or \"unknown protocol\" in error_normalized\n        or \"record layer failure\" in error_normalized\n    )\n    http_proxy_warning = (\n        \". Your proxy appears to only use HTTP and not HTTPS, \"\n        \"try changing your proxy URL to be HTTP. See: \"\n        \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"\n        \"#https-proxy-error-http-proxy\"\n    )\n    new_err = ProxyError(\n        f\"Unable to connect to proxy\"\n        f\"{http_proxy_warning if is_likely_http_proxy and proxy_scheme == 'https' else ''}\",\n        err,\n    )\n    new_err.__cause__ = err\n    return new_err\n\n\ndef _get_default_user_agent() -> str:\n    return f\"python-urllib3/{__version__}\"\n\n\nclass DummyConnection:\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\n\n\nif not ssl:\n    HTTPSConnection = DummyConnection  # type: ignore[misc, assignment] # noqa: F811\n\n\nVerifiedHTTPSConnection = HTTPSConnection\n\n\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"\n\n    return Url(scheme=scheme, host=conn.host, port=conn.port, path=path).url\n", "src/urllib3/_base_connection.py": "from __future__ import annotations\n\nimport typing\n\nfrom .util.connection import _TYPE_SOCKET_OPTIONS\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\nfrom .util.url import Url\n\n_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]\n\n\nclass ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\n\n\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str\n    preload_content: bool\n    decode_content: bool\n    enforce_content_length: bool\n\n\nif typing.TYPE_CHECKING:\n    import ssl\n    from typing import Protocol\n\n    from .response import BaseHTTPResponse\n\n    class BaseHTTPConnection(Protocol):\n        default_port: typing.ClassVar[int]\n        default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n        host: str\n        port: int\n        timeout: None | (\n            float\n        )  # Instance doesn't store _DEFAULT_TIMEOUT, must be resolved.\n        blocksize: int\n        source_address: tuple[str, int] | None\n        socket_options: _TYPE_SOCKET_OPTIONS | None\n\n        proxy: Url | None\n        proxy_config: ProxyConfig | None\n\n        is_verified: bool\n        proxy_is_verified: bool | None\n\n        def __init__(\n            self,\n            host: str,\n            port: int | None = None,\n            *,\n            timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n            source_address: tuple[str, int] | None = None,\n            blocksize: int = 8192,\n            socket_options: _TYPE_SOCKET_OPTIONS | None = ...,\n            proxy: Url | None = None,\n            proxy_config: ProxyConfig | None = None,\n        ) -> None:\n            ...\n\n        def set_tunnel(\n            self,\n            host: str,\n            port: int | None = None,\n            headers: typing.Mapping[str, str] | None = None,\n            scheme: str = \"http\",\n        ) -> None:\n            ...\n\n        def connect(self) -> None:\n            ...\n\n        def request(\n            self,\n            method: str,\n            url: str,\n            body: _TYPE_BODY | None = None,\n            headers: typing.Mapping[str, str] | None = None,\n            # We know *at least* botocore is depending on the order of the\n            # first 3 parameters so to be safe we only mark the later ones\n            # as keyword-only to ensure we have space to extend.\n            *,\n            chunked: bool = False,\n            preload_content: bool = True,\n            decode_content: bool = True,\n            enforce_content_length: bool = True,\n        ) -> None:\n            ...\n\n        def getresponse(self) -> BaseHTTPResponse:\n            ...\n\n        def close(self) -> None:\n            ...\n\n        @property\n        def is_closed(self) -> bool:\n            \"\"\"Whether the connection either is brand new or has been previously closed.\n            If this property is True then both ``is_connected`` and ``has_connected_to_proxy``\n            properties must be False.\n            \"\"\"\n\n        @property\n        def is_connected(self) -> bool:\n            \"\"\"Whether the connection is actively connected to any origin (proxy or target)\"\"\"\n\n        @property\n        def has_connected_to_proxy(self) -> bool:\n            \"\"\"Whether the connection has successfully connected to its proxy.\n            This returns False if no proxy is in use. Used to determine whether\n            errors are coming from the proxy layer or from tunnelling to the target origin.\n            \"\"\"\n\n    class BaseHTTPSConnection(BaseHTTPConnection, Protocol):\n        default_port: typing.ClassVar[int]\n        default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n        # Certificate verification methods\n        cert_reqs: int | str | None\n        assert_hostname: None | str | typing.Literal[False]\n        assert_fingerprint: str | None\n        ssl_context: ssl.SSLContext | None\n\n        # Trusted CAs\n        ca_certs: str | None\n        ca_cert_dir: str | None\n        ca_cert_data: None | str | bytes\n\n        # TLS version\n        ssl_minimum_version: int | None\n        ssl_maximum_version: int | None\n        ssl_version: int | str | None  # Deprecated\n\n        # Client certificates\n        cert_file: str | None\n        key_file: str | None\n        key_password: str | None\n\n        def __init__(\n            self,\n            host: str,\n            port: int | None = None,\n            *,\n            timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n            source_address: tuple[str, int] | None = None,\n            blocksize: int = 16384,\n            socket_options: _TYPE_SOCKET_OPTIONS | None = ...,\n            proxy: Url | None = None,\n            proxy_config: ProxyConfig | None = None,\n            cert_reqs: int | str | None = None,\n            assert_hostname: None | str | typing.Literal[False] = None,\n            assert_fingerprint: str | None = None,\n            server_hostname: str | None = None,\n            ssl_context: ssl.SSLContext | None = None,\n            ca_certs: str | None = None,\n            ca_cert_dir: str | None = None,\n            ca_cert_data: None | str | bytes = None,\n            ssl_minimum_version: int | None = None,\n            ssl_maximum_version: int | None = None,\n            ssl_version: int | str | None = None,  # Deprecated\n            cert_file: str | None = None,\n            key_file: str | None = None,\n            key_password: str | None = None,\n        ) -> None:\n            ...\n", "src/urllib3/exceptions.py": "from __future__ import annotations\n\nimport socket\nimport typing\nimport warnings\nfrom email.errors import MessageDefect\nfrom http.client import IncompleteRead as httplib_IncompleteRead\n\nif typing.TYPE_CHECKING:\n    from .connection import HTTPConnection\n    from .connectionpool import ConnectionPool\n    from .response import HTTPResponse\n    from .util.retry import Retry\n\n# Base Exceptions\n\n\nclass HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\n\n\nclass HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n\n\n_TYPE_REDUCE_RESULT = typing.Tuple[\n    typing.Callable[..., object], typing.Tuple[object, ...]\n]\n\n\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        super().__init__(f\"{pool}: {message}\")\n\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, None)\n\n\nclass RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n\n    def __init__(self, pool: ConnectionPool, url: str, message: str) -> None:\n        self.url = url\n        super().__init__(pool, message)\n\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self.url, None)\n\n\nclass SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\n\n\nclass ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n\n    # The original error is also available as __cause__.\n    original_error: Exception\n\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\n\n\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\n\n\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n\n\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n\n\n# Leaf Exceptions\n\n\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n\n    \"\"\"\n\n    def __init__(\n        self, pool: ConnectionPool, url: str, reason: Exception | None = None\n    ) -> None:\n        self.reason = reason\n\n        message = f\"Max retries exceeded with url: {url} (Caused by {reason!r})\"\n\n        super().__init__(pool, url, message)\n\n\nclass HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n\n    def __init__(\n        self, pool: ConnectionPool, url: str, retries: Retry | int = 3\n    ) -> None:\n        message = f\"Tried to open a foreign host with url: {url}\"\n        super().__init__(pool, url, message)\n        self.retries = retries\n\n\nclass TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\n\n\nclass TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\n\n\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n\n\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\n\n\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        super().__init__(f\"{conn}: {message}\")\n\n    @property\n    def pool(self) -> HTTPConnection:\n        warnings.warn(\n            \"The 'pool' property is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Use 'conn' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        return self.conn\n\n\nclass NameResolutionError(NewConnectionError):\n    \"\"\"Raised when host name resolution fails.\"\"\"\n\n    def __init__(self, host: str, conn: HTTPConnection, reason: socket.gaierror):\n        message = f\"Failed to resolve '{host}' ({reason})\"\n        super().__init__(conn, message)\n\n\nclass EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\n\n\nclass FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\n\n\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\n\n\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\n\n\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n\n        self.location = location\n\n\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"\n        super().__init__(message)\n\n        self.scheme = scheme\n\n\nclass ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\n\n\nclass SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\n\n\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\n\n\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\n\n\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\n\n\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\n\n\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\n\n\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\n\n\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\n\n\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n\n    partial: int  # type: ignore[assignment]\n    expected: int\n\n    def __init__(self, partial: int, expected: int) -> None:\n        self.partial = partial\n        self.expected = expected\n\n    def __repr__(self) -> str:\n        return \"IncompleteRead(%i bytes read, %i more expected)\" % (\n            self.partial,\n            self.expected,\n        )\n\n\nclass InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n\n    def __init__(self, response: HTTPResponse, length: bytes) -> None:\n        self.partial: int = response.tell()  # type: ignore[assignment]\n        self.expected: int | None = response.length_remaining\n        self.response = response\n        self.length = length\n\n    def __repr__(self) -> str:\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,\n            self.partial,\n        )\n\n\nclass InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\n\n\nclass ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"\n        else:\n            message = f\"Proxy URL had unsupported scheme {scheme}, should use http:// or https://\"\n        super().__init__(message)\n\n\nclass ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\n\n\nclass HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\n\n\nclass UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"\n", "src/urllib3/http2.py": "from __future__ import annotations\n\nimport threading\nimport types\nimport typing\n\nimport h2.config  # type: ignore[import-untyped]\nimport h2.connection  # type: ignore[import-untyped]\nimport h2.events  # type: ignore[import-untyped]\n\nimport urllib3.connection\nimport urllib3.util.ssl_\nfrom urllib3.response import BaseHTTPResponse\n\nfrom ._collections import HTTPHeaderDict\nfrom .connection import HTTPSConnection\nfrom .connectionpool import HTTPSConnectionPool\n\norig_HTTPSConnection = HTTPSConnection\n\nT = typing.TypeVar(\"T\")\n\n\nclass _LockedObject(typing.Generic[T]):\n    \"\"\"\n    A wrapper class that hides a specific object behind a lock.\n\n    The goal here is to provide a simple way to protect access to an object\n    that cannot safely be simultaneously accessed from multiple threads. The\n    intended use of this class is simple: take hold of it with a context\n    manager, which returns the protected object.\n    \"\"\"\n\n    def __init__(self, obj: T):\n        self.lock = threading.RLock()\n        self._obj = obj\n\n    def __enter__(self) -> T:\n        self.lock.acquire()\n        return self._obj\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: types.TracebackType | None,\n    ) -> None:\n        self.lock.release()\n\n\nclass HTTP2Connection(HTTPSConnection):\n    def __init__(\n        self, host: str, port: int | None = None, **kwargs: typing.Any\n    ) -> None:\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream: int | None = None\n        self._h2_headers: list[tuple[bytes, bytes]] = []\n\n        if \"proxy\" in kwargs or \"proxy_config\" in kwargs:  # Defensive:\n            raise NotImplementedError(\"Proxies aren't supported with HTTP/2\")\n\n        super().__init__(host, port, **kwargs)\n\n    def _new_h2_conn(self) -> _LockedObject[h2.connection.H2Connection]:\n        config = h2.config.H2Configuration(client_side=True)\n        return _LockedObject(h2.connection.H2Connection(config=config))\n\n    def connect(self) -> None:\n        super().connect()\n\n        with self._h2_conn as h2_conn:\n            h2_conn.initiate_connection()\n            self.sock.sendall(h2_conn.data_to_send())\n\n    def putrequest(\n        self,\n        method: str,\n        url: str,\n        skip_host: bool = False,\n        skip_accept_encoding: bool = False,\n    ) -> None:\n        with self._h2_conn as h2_conn:\n            self._request_url = url\n            self._h2_stream = h2_conn.get_next_available_stream_id()\n\n            if \":\" in self.host:\n                authority = f\"[{self.host}]:{self.port or 443}\"\n            else:\n                authority = f\"{self.host}:{self.port or 443}\"\n\n            self._h2_headers.extend(\n                (\n                    (b\":scheme\", b\"https\"),\n                    (b\":method\", method.encode()),\n                    (b\":authority\", authority.encode()),\n                    (b\":path\", url.encode()),\n                )\n            )\n\n    def putheader(self, header: str, *values: str) -> None:  # type: ignore[override]\n        for value in values:\n            self._h2_headers.append(\n                (header.encode(\"utf-8\").lower(), value.encode(\"utf-8\"))\n            )\n\n    def endheaders(self) -> None:  # type: ignore[override]\n        with self._h2_conn as h2_conn:\n            h2_conn.send_headers(\n                stream_id=self._h2_stream,\n                headers=self._h2_headers,\n                end_stream=True,\n            )\n            if data_to_send := h2_conn.data_to_send():\n                self.sock.sendall(data_to_send)\n\n    def send(self, data: bytes) -> None:  # type: ignore[override]  # Defensive:\n        if not data:\n            return\n        raise NotImplementedError(\"Sending data isn't supported yet\")\n\n    def getresponse(  # type: ignore[override]\n        self,\n    ) -> HTTP2Response:\n        status = None\n        data = bytearray()\n        with self._h2_conn as h2_conn:\n            end_stream = False\n            while not end_stream:\n                # TODO: Arbitrary read value.\n                if received_data := self.sock.recv(65535):\n                    events = h2_conn.receive_data(received_data)\n                    for event in events:\n                        if isinstance(event, h2.events.ResponseReceived):\n                            headers = HTTPHeaderDict()\n                            for header, value in event.headers:\n                                if header == b\":status\":\n                                    status = int(value.decode())\n                                else:\n                                    headers.add(\n                                        header.decode(\"ascii\"), value.decode(\"ascii\")\n                                    )\n\n                        elif isinstance(event, h2.events.DataReceived):\n                            data += event.data\n                            h2_conn.acknowledge_received_data(\n                                event.flow_controlled_length, event.stream_id\n                            )\n\n                        elif isinstance(event, h2.events.StreamEnded):\n                            end_stream = True\n\n                if data_to_send := h2_conn.data_to_send():\n                    self.sock.sendall(data_to_send)\n\n        # We always close to not have to handle connection management.\n        self.close()\n\n        assert status is not None\n        return HTTP2Response(\n            status=status,\n            headers=headers,\n            request_url=self._request_url,\n            data=bytes(data),\n        )\n\n    def close(self) -> None:\n        with self._h2_conn as h2_conn:\n            try:\n                h2_conn.close_connection()\n                if data := h2_conn.data_to_send():\n                    self.sock.sendall(data)\n            except Exception:\n                pass\n\n        # Reset all our HTTP/2 connection state.\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream = None\n        self._h2_headers = []\n\n        super().close()\n\n\nclass HTTP2Response(BaseHTTPResponse):\n    # TODO: This is a woefully incomplete response object, but works for non-streaming.\n    def __init__(\n        self,\n        status: int,\n        headers: HTTPHeaderDict,\n        request_url: str,\n        data: bytes,\n        decode_content: bool = False,  # TODO: support decoding\n    ) -> None:\n        super().__init__(\n            status=status,\n            headers=headers,\n            # Following CPython, we map HTTP versions to major * 10 + minor integers\n            version=20,\n            version_string=\"HTTP/2\",\n            # No reason phrase in HTTP/2\n            reason=None,\n            decode_content=decode_content,\n            request_url=request_url,\n        )\n        self._data = data\n        self.length_remaining = 0\n\n    @property\n    def data(self) -> bytes:\n        return self._data\n\n    def get_redirect_location(self) -> None:\n        return None\n\n    def close(self) -> None:\n        pass\n\n\ndef inject_into_urllib3() -> None:\n    HTTPSConnectionPool.ConnectionCls = HTTP2Connection\n    urllib3.connection.HTTPSConnection = HTTP2Connection  # type: ignore[misc]\n\n    # TODO: Offer 'http/1.1' as well, but for testing purposes this is handy.\n    urllib3.util.ssl_.ALPN_PROTOCOLS = [\"h2\"]\n\n\ndef extract_from_urllib3() -> None:\n    HTTPSConnectionPool.ConnectionCls = orig_HTTPSConnection\n    urllib3.connection.HTTPSConnection = orig_HTTPSConnection  # type: ignore[misc]\n\n    urllib3.util.ssl_.ALPN_PROTOCOLS = [\"http/1.1\"]\n", "src/urllib3/connectionpool.py": "from __future__ import annotations\n\nimport errno\nimport logging\nimport queue\nimport sys\nimport typing\nimport warnings\nimport weakref\nfrom socket import timeout as SocketTimeout\nfrom types import TracebackType\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom ._request_methods import RequestMethods\nfrom .connection import (\n    BaseSSLError,\n    BrokenPipeError,\n    DummyConnection,\n    HTTPConnection,\n    HTTPException,\n    HTTPSConnection,\n    ProxyConfig,\n    _wrap_proxy_error,\n)\nfrom .connection import port_by_scheme as port_by_scheme\nfrom .exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    FullPoolError,\n    HostChangedError,\n    InsecureRequestWarning,\n    LocationValueError,\n    MaxRetryError,\n    NewConnectionError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.request import _TYPE_BODY_POSITION, set_file_position\nfrom .util.retry import Retry\nfrom .util.ssl_match_hostname import CertificateError\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_DEFAULT, Timeout\nfrom .util.url import Url, _encode_target\nfrom .util.url import _normalize_host as normalize_host\nfrom .util.url import parse_url\nfrom .util.util import to_str\n\nif typing.TYPE_CHECKING:\n    import ssl\n\n    from typing_extensions import Self\n\n    from ._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\nlog = logging.getLogger(__name__)\n\n_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n\n\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n\n    scheme: str | None = None\n    QueueCls = queue.LifoQueue\n\n    def __init__(self, host: str, port: int | None = None) -> None:\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        self.host = _normalize_host(host, scheme=self.scheme)\n        self.port = port\n\n        # This property uses 'normalize_host()' (not '_normalize_host()')\n        # to avoid removing square braces around IPv6 addresses.\n        # This value is sent to `HTTPConnection.set_tunnel()` if called\n        # because square braces are required for HTTP CONNECT tunneling.\n        self._tunnel_host = normalize_host(host, scheme=self.scheme).lower()\n\n    def __str__(self) -> str:\n        return f\"{type(self).__name__}(host={self.host!r}, port={self.port!r})\"\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> typing.Literal[False]:\n        self.close()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def close(self) -> None:\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n\n\n# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252\n_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}\n\n\nclass HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n\n    :param timeout:\n        Socket timeout in seconds for each individual connection. This can\n        be a float or integer, which sets the timeout for the HTTP request,\n        or an instance of :class:`urllib3.util.Timeout` which gives you more\n        fine-grained control over request timeouts. After the constructor has\n        been parsed, this is always a `urllib3.util.Timeout` object.\n\n    :param maxsize:\n        Number of connections to save that can be reused. More than 1 is useful\n        in multithreaded situations. If ``block`` is set to False, more\n        connections will be created but they will not be saved once they've\n        been used.\n\n    :param block:\n        If set to True, no more than ``maxsize`` connections will be used at\n        a time. When no free connections are available, the call will block\n        until a connection has been released. This is a useful side effect for\n        particular multithreaded situations where one does not want to use more\n        than maxsize connections per host to prevent flooding.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param retries:\n        Retry configuration to use by default with requests in this pool.\n\n    :param _proxy:\n        Parsed proxy URL, should not be used directly, instead, see\n        :class:`urllib3.ProxyManager`\n\n    :param _proxy_headers:\n        A dictionary with proxy headers, should not be used directly,\n        instead, see :class:`urllib3.ProxyManager`\n\n    :param \\\\**conn_kw:\n        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n        :class:`urllib3.connection.HTTPSConnection` instances.\n    \"\"\"\n\n    scheme = \"http\"\n    ConnectionCls: (\n        type[BaseHTTPConnection] | type[BaseHTTPSConnection]\n    ) = HTTPConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        _proxy_config: ProxyConfig | None = None,\n        **conn_kw: typing.Any,\n    ):\n        ConnectionPool.__init__(self, host, port)\n        RequestMethods.__init__(self, headers)\n\n        if not isinstance(timeout, Timeout):\n            timeout = Timeout.from_float(timeout)\n\n        if retries is None:\n            retries = Retry.DEFAULT\n\n        self.timeout = timeout\n        self.retries = retries\n\n        self.pool: queue.LifoQueue[typing.Any] | None = self.QueueCls(maxsize)\n        self.block = block\n\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.proxy_config = _proxy_config\n\n        # Fill the queue up so that doing get() on it will block properly\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n        # These are mostly for testing and debugging purposes.\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        if self.proxy:\n            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.\n            # We cannot know if the user has added default socket options, so we cannot replace the\n            # list.\n            self.conn_kw.setdefault(\"socket_options\", [])\n\n            self.conn_kw[\"proxy\"] = self.proxy\n            self.conn_kw[\"proxy_config\"] = self.proxy_config\n\n        # Do not pass 'self' as callback to 'finalize'.\n        # Then the 'finalize' would keep an endless living (leak) to self.\n        # By just passing a reference to the pool allows the garbage collector\n        # to free self if nobody else has a reference to it.\n        pool = self.pool\n\n        # Close all the HTTPConnections in the pool before the\n        # HTTPConnectionPool object is garbage collected.\n        weakref.finalize(self, _close_pool_connections, pool)\n\n    def _new_conn(self) -> BaseHTTPConnection:\n        \"\"\"\n        Return a fresh :class:`HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTP connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"80\",\n        )\n\n        conn = self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw,\n        )\n        return conn\n\n    def _get_conn(self, timeout: float | None = None) -> BaseHTTPConnection:\n        \"\"\"\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        \"\"\"\n        conn = None\n\n        if self.pool is None:\n            raise ClosedPoolError(self, \"Pool is closed.\")\n\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n\n        except AttributeError:  # self.pool is None\n            raise ClosedPoolError(self, \"Pool is closed.\") from None  # Defensive:\n\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(\n                    self,\n                    \"Pool is empty and a new connection can't be opened due to blocking mode.\",\n                ) from None\n            pass  # Oh well, we'll create a new connection then\n\n        # If this is a persistent connection, check if it got disconnected\n        if conn and is_connection_dropped(conn):\n            log.debug(\"Resetting dropped connection: %s\", self.host)\n            conn.close()\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn: BaseHTTPConnection | None) -> None:\n        \"\"\"\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        \"\"\"\n        if self.pool is not None:\n            try:\n                self.pool.put(conn, block=False)\n                return  # Everything is dandy, done.\n            except AttributeError:\n                # self.pool is None.\n                pass\n            except queue.Full:\n                # Connection never got put back into the pool, close it.\n                if conn:\n                    conn.close()\n\n                if self.block:\n                    # This should never happen if you got the conn from self._get_conn\n                    raise FullPoolError(\n                        self,\n                        \"Pool reached maximum size and no more connections are allowed.\",\n                    ) from None\n\n                log.warning(\n                    \"Connection pool is full, discarding connection: %s. Connection pool size: %s\",\n                    self.host,\n                    self.pool.qsize(),\n                )\n\n        # Connection never got put back into the pool, close it.\n        if conn:\n            conn.close()\n\n    def _validate_conn(self, conn: BaseHTTPConnection) -> None:\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n\n    def _prepare_proxy(self, conn: BaseHTTPConnection) -> None:\n        # Nothing to do for HTTP connections.\n        pass\n\n    def _get_timeout(self, timeout: _TYPE_TIMEOUT) -> Timeout:\n        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"\n        if timeout is _DEFAULT_TIMEOUT:\n            return self.timeout.clone()\n\n        if isinstance(timeout, Timeout):\n            return timeout.clone()\n        else:\n            # User passed us an int/float. This is for backwards compatibility,\n            # can be removed later\n            return Timeout.from_float(timeout)\n\n    def _raise_timeout(\n        self,\n        err: BaseSSLError | OSError | SocketTimeout,\n        url: str,\n        timeout_value: _TYPE_TIMEOUT | None,\n    ) -> None:\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n\n        if isinstance(err, SocketTimeout):\n            raise ReadTimeoutError(\n                self, url, f\"Read timed out. (read timeout={timeout_value})\"\n            ) from err\n\n        # See the above comment about EAGAIN in Python 3.\n        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:\n            raise ReadTimeoutError(\n                self, url, f\"Read timed out. (read timeout={timeout_value})\"\n            ) from err\n\n    def _make_request(\n        self,\n        conn: BaseHTTPConnection,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | None = None,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        chunked: bool = False,\n        response_conn: BaseHTTPConnection | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param response_conn:\n            Set this to ``None`` if you will handle releasing the connection or\n            set the connection to have the response release it.\n\n        :param preload_content:\n          If True, the response's body will be preloaded during construction.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param enforce_content_length:\n            Enforce content length checking. Body returned by server must match\n            value of Content-Length header, if present. Otherwise, raise error.\n        \"\"\"\n        self.num_requests += 1\n\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\n\n        try:\n            # Trigger any extra validation we need to do.\n            try:\n                self._validate_conn(conn)\n            except (SocketTimeout, BaseSSLError) as e:\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n                raise\n\n        # _validate_conn() starts the connection to an HTTPS proxy\n        # so we need to wrap errors with 'ProxyError' here too.\n        except (\n            OSError,\n            NewConnectionError,\n            TimeoutError,\n            BaseSSLError,\n            CertificateError,\n            SSLError,\n        ) as e:\n            new_e: Exception = e\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                new_e = SSLError(e)\n            # If the connection didn't successfully connect to it's proxy\n            # then there\n            if isinstance(\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\n            raise new_e\n\n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            conn.request(\n                method,\n                url,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                enforce_content_length=enforce_content_length,\n            )\n\n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            pass\n        except OSError as e:\n            # MacOS/Linux\n            # EPROTOTYPE and ECONNRESET are needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.\n            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:\n                raise\n\n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n\n        if not conn.is_closed:\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, f\"Read timed out. (read timeout={read_timeout})\"\n                )\n            conn.timeout = read_timeout\n\n        # Receive the response from the server\n        try:\n            response = conn.getresponse()\n        except (BaseSSLError, OSError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        # Set properties that are used by the pooling layer.\n        response.retries = retries\n        response._connection = response_conn  # type: ignore[attr-defined]\n        response._pool = self  # type: ignore[attr-defined]\n\n        log.debug(\n            '%s://%s:%s \"%s %s HTTP/%s\" %s %s',\n            self.scheme,\n            self.host,\n            self.port,\n            method,\n            url,\n            response.version,\n            response.status,\n            response.length_remaining,\n        )\n\n        return response\n\n    def close(self) -> None:\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n        if self.pool is None:\n            return\n        # Disable access to the pool\n        old_pool, self.pool = self.pool, None\n\n        # Close all the HTTPConnections in the pool.\n        _close_pool_connections(old_pool)\n\n    def is_same_host(self, url: str) -> bool:\n        \"\"\"\n        Check if the given ``url`` is a member of the same host as this\n        connection pool.\n        \"\"\"\n        if url.startswith(\"/\"):\n            return True\n\n        # TODO: Add optional support for socket.gethostbyname checking.\n        scheme, _, host, port, *_ = parse_url(url)\n        scheme = scheme or \"http\"\n        if host is not None:\n            host = _normalize_host(host, scheme=scheme)\n\n        # Use explicit default port for comparison when none is given\n        if self.port and not port:\n            port = port_by_scheme.get(scheme)\n        elif not self.port and port == port_by_scheme.get(scheme):\n            port = None\n\n        return (scheme, host, port) == (self.scheme, self.host, self.port)\n\n    def urlopen(  # type: ignore[override]\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        redirect: bool = True,\n        assert_same_host: bool = True,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        pool_timeout: int | None = None,\n        release_conn: bool | None = None,\n        chunked: bool = False,\n        body_pos: _TYPE_BODY_POSITION | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method\n           such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param bool preload_content:\n            If True, the response's body will be preloaded into memory.\n\n        :param bool decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of ``preload_content``\n            which defaults to ``True``.\n\n        :param bool chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n        \"\"\"\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if release_conn is None:\n            release_conn = preload_content\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = to_str(_encode_target(url))\n        else:\n            url = to_str(parsed_url.url)\n\n        conn = None\n\n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()  # type: ignore[attr-defined]\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\n\n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n\n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n\n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n\n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\n\n            # Is this a closed/new connection that requires CONNECT tunnelling?\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\n                try:\n                    self._prepare_proxy(conn)\n                except (BaseSSLError, OSError, SocketTimeout) as e:\n                    self._raise_timeout(\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\n                    )\n                    raise\n\n            # If we're going to release the connection in ``finally:``, then\n            # the response doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = conn if not release_conn else None\n\n            # Make the request on the HTTPConnection object\n            response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n                retries=retries,\n                response_conn=response_conn,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n            # Everything went great!\n            clean_exit = True\n\n        except EmptyPoolError:\n            # Didn't get a connection from the pool, no need to clean up\n            clean_exit = True\n            release_this_conn = False\n            raise\n\n        except (\n            TimeoutError,\n            HTTPException,\n            OSError,\n            ProtocolError,\n            BaseSSLError,\n            SSLError,\n            CertificateError,\n            ProxyError,\n        ) as e:\n            # Discard the connection for these exceptions. It will be\n            # replaced during the next _get_conn() call.\n            clean_exit = False\n            new_e: Exception = e\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                new_e = SSLError(e)\n            if isinstance(\n                new_e,\n                (\n                    OSError,\n                    NewConnectionError,\n                    TimeoutError,\n                    SSLError,\n                    HTTPException,\n                ),\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\n            elif isinstance(new_e, (OSError, HTTPException)):\n                new_e = ProtocolError(\"Connection aborted.\", new_e)\n\n            retries = retries.increment(\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n\n            # Keep track of the error for the retry warning.\n            err = e\n\n        finally:\n            if not clean_exit:\n                # We hit some kind of exception, handled or otherwise. We need\n                # to throw the connection away unless explicitly told not to.\n                # Close the connection, set the variable to None, and make sure\n                # we put the None back in the pool to avoid leaking it.\n                if conn:\n                    conn.close()\n                    conn = None\n                release_this_conn = True\n\n            if release_this_conn:\n                # Put the connection back to be reused. If the connection is\n                # expired then it will be None, which will get replaced with a\n                # fresh connection during _get_conn.\n                self._put_conn(conn)\n\n        if not conn:\n            # Try again\n            log.warning(\n                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n            )\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        # Handle redirect?\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            if response.status == 303:\n                # Change the method according to RFC 9110, Section 15.4.4.\n                method = \"GET\"\n                # And lose the body not to transfer anything sensitive.\n                body = None\n                headers = HTTPHeaderDict(headers)._prepare_for_method_change()\n\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_redirect:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep_for_retry(response)\n            log.debug(\"Redirecting %s -> %s\", url, redirect_location)\n            return self.urlopen(\n                method,\n                redirect_location,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        # Check if we should retry the HTTP response.\n        has_retry_after = bool(response.headers.get(\"Retry-After\"))\n        if retries.is_retry(method, response.status, has_retry_after):\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_status:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep(response)\n            log.debug(\"Retry: %s\", url)\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        return response\n\n\nclass HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.\n    \"\"\"\n\n    scheme = \"https\"\n    ConnectionCls: type[BaseHTTPSConnection] = HTTPSConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        ssl_version: int | str | None = None,\n        ssl_minimum_version: ssl.TLSVersion | None = None,\n        ssl_maximum_version: ssl.TLSVersion | None = None,\n        assert_hostname: str | typing.Literal[False] | None = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        **conn_kw: typing.Any,\n    ) -> None:\n        super().__init__(\n            host,\n            port,\n            timeout,\n            maxsize,\n            block,\n            headers,\n            retries,\n            _proxy,\n            _proxy_headers,\n            **conn_kw,\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.ca_certs = ca_certs\n        self.ca_cert_dir = ca_cert_dir\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_proxy(self, conn: HTTPSConnection) -> None:  # type: ignore[override]\n        \"\"\"Establishes a tunnel connection through HTTP CONNECT.\"\"\"\n        if self.proxy and self.proxy.scheme == \"https\":\n            tunnel_scheme = \"https\"\n        else:\n            tunnel_scheme = \"http\"\n\n        conn.set_tunnel(\n            scheme=tunnel_scheme,\n            host=self._tunnel_host,\n            port=self.port,\n            headers=self.proxy_headers,\n        )\n        conn.connect()\n\n    def _new_conn(self) -> BaseHTTPSConnection:\n        \"\"\"\n        Return a fresh :class:`urllib3.connection.HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTPS connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"443\",\n        )\n\n        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:  # type: ignore[comparison-overlap]\n            raise ImportError(\n                \"Can't connect to HTTPS URL because the SSL module is not available.\"\n            )\n\n        actual_host: str = self.host\n        actual_port = self.port\n        if self.proxy is not None and self.proxy.host is not None:\n            actual_host = self.proxy.host\n            actual_port = self.proxy.port\n\n        return self.ConnectionCls(\n            host=actual_host,\n            port=actual_port,\n            timeout=self.timeout.connect_timeout,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            cert_reqs=self.cert_reqs,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            assert_hostname=self.assert_hostname,\n            assert_fingerprint=self.assert_fingerprint,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            **self.conn_kw,\n        )\n\n    def _validate_conn(self, conn: BaseHTTPConnection) -> None:\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        super()._validate_conn(conn)\n\n        # Force connect early to allow us to validate the connection.\n        if conn.is_closed:\n            conn.connect()\n\n        # TODO revise this, see https://github.com/urllib3/urllib3/issues/2791\n        if not conn.is_verified and not conn.proxy_is_verified:\n            warnings.warn(\n                (\n                    f\"Unverified HTTPS request is being made to host '{conn.host}'. \"\n                    \"Adding certificate verification is strongly advised. See: \"\n                    \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"\n                    \"#tls-warnings\"\n                ),\n                InsecureRequestWarning,\n            )\n\n\ndef connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like\n        timeout, maxsize, headers, etc.\n\n    Example::\n\n        >>> conn = connection_from_url('http://google.com/')\n        >>> r = conn.request('GET', '/')\n    \"\"\"\n    scheme, _, host, port, *_ = parse_url(url)\n    scheme = scheme or \"http\"\n    port = port or port_by_scheme.get(scheme, 80)\n    if scheme == \"https\":\n        return HTTPSConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]\n    else:\n        return HTTPConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]\n\n\n@typing.overload\ndef _normalize_host(host: None, scheme: str | None) -> None:\n    ...\n\n\n@typing.overload\ndef _normalize_host(host: str, scheme: str | None) -> str:\n    ...\n\n\ndef _normalize_host(host: str | None, scheme: str | None) -> str | None:\n    \"\"\"\n    Normalize hosts for comparisons and use with sockets.\n    \"\"\"\n\n    host = normalize_host(host, scheme)\n\n    # httplib doesn't like it when we include brackets in IPv6 addresses\n    # Specifically, if we include brackets but also pass the port then\n    # httplib crazily doubles up the square brackets on the Host header.\n    # Instead, we need to make sure we never pass ``None`` as the port.\n    # However, for backward compatibility reasons we can't actually\n    # *assert* that.  See http://bugs.python.org/issue28539\n    if host and host.startswith(\"[\") and host.endswith(\"]\"):\n        host = host[1:-1]\n    return host\n\n\ndef _url_from_pool(\n    pool: HTTPConnectionPool | HTTPSConnectionPool, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection pool. This is mainly used for testing and logging.\"\"\"\n    return Url(scheme=pool.scheme, host=pool.host, port=pool.port, path=path).url\n\n\ndef _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:\n    \"\"\"Drains a queue of connections and closes each one.\"\"\"\n    try:\n        while True:\n            conn = pool.get(block=False)\n            if conn:\n                conn.close()\n    except queue.Empty:\n        pass  # Done.\n", "src/urllib3/fields.py": "from __future__ import annotations\n\nimport email.utils\nimport mimetypes\nimport typing\n\n_TYPE_FIELD_VALUE = typing.Union[str, bytes]\n_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    typing.Tuple[str, _TYPE_FIELD_VALUE],\n    typing.Tuple[str, _TYPE_FIELD_VALUE, str],\n]\n\n\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"\n    if filename:\n        return mimetypes.guess_type(filename)[0] or default\n    return default\n\n\ndef format_header_param_rfc2231(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :returns:\n        An RFC-2231-formatted unicode string.\n\n    .. deprecated:: 2.0.0\n        Will be removed in urllib3 v2.1.0. This is not valid for\n        ``multipart/form-data`` header parameters.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param_rfc2231' is deprecated and will be \"\n        \"removed in urllib3 v2.1.0. This is not valid for \"\n        \"multipart/form-data header parameters.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n\n    if not any(ch in value for ch in '\"\\\\\\r\\n'):\n        result = f'{name}=\"{value}\"'\n        try:\n            result.encode(\"ascii\")\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\n        else:\n            return result\n\n    value = email.utils.encode_rfc2231(value, \"utf-8\")\n    value = f\"{name}*={value}\"\n\n    return value\n\n\ndef format_multipart_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Format and quote a single multipart header parameter.\n\n    This follows the `WHATWG HTML Standard`_ as of 2021/06/10, matching\n    the behavior of current browser and curl versions. Values are\n    assumed to be UTF-8. The ``\\\\n``, ``\\\\r``, and ``\"`` characters are\n    percent encoded.\n\n    .. _WHATWG HTML Standard:\n        https://html.spec.whatwg.org/multipage/\n        form-control-infrastructure.html#multipart-form-data\n\n    :param name:\n        The name of the parameter, an ASCII-only ``str``.\n    :param value:\n        The value of the parameter, a ``str`` or UTF-8 encoded\n        ``bytes``.\n    :returns:\n        A string ``name=\"value\"`` with the escaped value.\n\n    .. versionchanged:: 2.0.0\n        Matches the WHATWG HTML Standard as of 2021/06/10. Control\n        characters are no longer percent encoded.\n\n    .. versionchanged:: 2.0.0\n        Renamed from ``format_header_param_html5`` and\n        ``format_header_param``. The old names will be removed in\n        urllib3 v2.1.0.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n\n    # percent encode \\n \\r \"\n    value = value.translate({10: \"%0A\", 13: \"%0D\", 34: \"%22\"})\n    return f'{name}=\"{value}\"'\n\n\ndef format_header_param_html5(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param_html5' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"\n        \"removed in urllib3 v2.1.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return format_multipart_header_param(name, value)\n\n\ndef format_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"\n        \"removed in urllib3 v2.1.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return format_multipart_header_param(name, value)\n\n\nclass RequestField:\n    \"\"\"\n    A data container for request body parameters.\n\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:\n        An optional dict-like object of headers to initially use for the field.\n\n    .. versionchanged:: 2.0.0\n        The ``header_formatter`` parameter is deprecated and will\n        be removed in urllib3 v2.1.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        data: _TYPE_FIELD_VALUE,\n        filename: str | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        header_formatter: typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None = None,\n    ):\n        self._name = name\n        self._filename = filename\n        self.data = data\n        self.headers: dict[str, str | None] = {}\n        if headers:\n            self.headers = dict(headers)\n\n        if header_formatter is not None:\n            import warnings\n\n            warnings.warn(\n                \"The 'header_formatter' parameter is deprecated and \"\n                \"will be removed in urllib3 v2.1.0.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.header_formatter = header_formatter\n        else:\n            self.header_formatter = format_multipart_header_param\n\n    @classmethod\n    def from_tuples(\n        cls,\n        fieldname: str,\n        value: _TYPE_FIELD_VALUE_TUPLE,\n        header_formatter: typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None = None,\n    ) -> RequestField:\n        \"\"\"\n        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\n        Supports constructing :class:`~urllib3.fields.RequestField` from\n        parameter of key/value strings AND key/filetuple. A filetuple is a\n        (filename, data, MIME type) tuple where the MIME type is optional.\n        For example::\n\n            'foo': 'bar',\n            'fakefile': ('foofile.txt', 'contents of foofile'),\n            'realfile': ('barfile.txt', open('realfile').read()),\n            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n            'nonamefile': 'contents of nonamefile field',\n\n        Field names and filenames must be unicode.\n        \"\"\"\n        filename: str | None\n        content_type: str | None\n        data: _TYPE_FIELD_VALUE\n\n        if isinstance(value, tuple):\n            if len(value) == 3:\n                filename, data, content_type = value\n            else:\n                filename, data = value\n                content_type = guess_content_type(filename)\n        else:\n            filename = None\n            content_type = None\n            data = value\n\n        request_param = cls(\n            fieldname, data, filename=filename, header_formatter=header_formatter\n        )\n        request_param.make_multipart(content_type=content_type)\n\n        return request_param\n\n    def _render_part(self, name: str, value: _TYPE_FIELD_VALUE) -> str:\n        \"\"\"\n        Override this method to change how each multipart header\n        parameter is formatted. By default, this calls\n        :func:`format_multipart_header_param`.\n\n        :param name:\n            The name of the parameter, an ASCII-only ``str``.\n        :param value:\n            The value of the parameter, a ``str`` or UTF-8 encoded\n            ``bytes``.\n\n        :meta public:\n        \"\"\"\n        return self.header_formatter(name, value)\n\n    def _render_parts(\n        self,\n        header_parts: (\n            dict[str, _TYPE_FIELD_VALUE | None]\n            | typing.Sequence[tuple[str, _TYPE_FIELD_VALUE | None]]\n        ),\n    ) -> str:\n        \"\"\"\n        Helper function to format and quote a single header.\n\n        Useful for single headers that are composed of multiple items. E.g.,\n        'Content-Disposition' fields.\n\n        :param header_parts:\n            A sequence of (k, v) tuples or a :class:`dict` of (k, v) to format\n            as `k1=\"v1\"; k2=\"v2\"; ...`.\n        \"\"\"\n        iterable: typing.Iterable[tuple[str, _TYPE_FIELD_VALUE | None]]\n\n        parts = []\n        if isinstance(header_parts, dict):\n            iterable = header_parts.items()\n        else:\n            iterable = header_parts\n\n        for name, value in iterable:\n            if value is not None:\n                parts.append(self._render_part(name, value))\n\n        return \"; \".join(parts)\n\n    def render_headers(self) -> str:\n        \"\"\"\n        Renders the headers for this request field.\n        \"\"\"\n        lines = []\n\n        sort_keys = [\"Content-Disposition\", \"Content-Type\", \"Content-Location\"]\n        for sort_key in sort_keys:\n            if self.headers.get(sort_key, False):\n                lines.append(f\"{sort_key}: {self.headers[sort_key]}\")\n\n        for header_name, header_value in self.headers.items():\n            if header_name not in sort_keys:\n                if header_value:\n                    lines.append(f\"{header_name}: {header_value}\")\n\n        lines.append(\"\\r\\n\")\n        return \"\\r\\n\".join(lines)\n\n    def make_multipart(\n        self,\n        content_disposition: str | None = None,\n        content_type: str | None = None,\n        content_location: str | None = None,\n    ) -> None:\n        \"\"\"\n        Makes this request field into a multipart request field.\n\n        This method overrides \"Content-Disposition\", \"Content-Type\" and\n        \"Content-Location\" headers to the request parameter.\n\n        :param content_disposition:\n            The 'Content-Disposition' of the request body. Defaults to 'form-data'\n        :param content_type:\n            The 'Content-Type' of the request body.\n        :param content_location:\n            The 'Content-Location' of the request body.\n\n        \"\"\"\n        content_disposition = (content_disposition or \"form-data\") + \"; \".join(\n            [\n                \"\",\n                self._render_parts(\n                    ((\"name\", self._name), (\"filename\", self._filename))\n                ),\n            ]\n        )\n\n        self.headers[\"Content-Disposition\"] = content_disposition\n        self.headers[\"Content-Type\"] = content_type\n        self.headers[\"Content-Location\"] = content_location\n", "src/urllib3/filepost.py": "from __future__ import annotations\n\nimport binascii\nimport codecs\nimport os\nimport typing\nfrom io import BytesIO\n\nfrom .fields import _TYPE_FIELD_VALUE_TUPLE, RequestField\n\nwriter = codecs.lookup(\"utf-8\")[3]\n\n_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[typing.Tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\n\n\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\n\n\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n\n    \"\"\"\n    iterable: typing.Iterable[RequestField | tuple[str, _TYPE_FIELD_VALUE_TUPLE]]\n\n    if isinstance(fields, typing.Mapping):\n        iterable = fields.items()\n    else:\n        iterable = fields\n\n    for field in iterable:\n        if isinstance(field, RequestField):\n            yield field\n        else:\n            yield RequestField.from_tuples(*field)\n\n\ndef encode_multipart_formdata(\n    fields: _TYPE_FIELDS, boundary: str | None = None\n) -> tuple[bytes, str]:\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n        Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n\n    :param boundary:\n        If not specified, then a random boundary will be generated using\n        :func:`urllib3.filepost.choose_boundary`.\n    \"\"\"\n    body = BytesIO()\n    if boundary is None:\n        boundary = choose_boundary()\n\n    for field in iter_field_objects(fields):\n        body.write(f\"--{boundary}\\r\\n\".encode(\"latin-1\"))\n\n        writer(body).write(field.render_headers())\n        data = field.data\n\n        if isinstance(data, int):\n            data = str(data)  # Backwards compatibility\n\n        if isinstance(data, str):\n            writer(body).write(data)\n        else:\n            body.write(data)\n\n        body.write(b\"\\r\\n\")\n\n    body.write(f\"--{boundary}--\\r\\n\".encode(\"latin-1\"))\n\n    content_type = f\"multipart/form-data; boundary={boundary}\"\n\n    return body.getvalue(), content_type\n", "src/urllib3/_collections.py": "from __future__ import annotations\n\nimport typing\nfrom collections import OrderedDict\nfrom enum import Enum, auto\nfrom threading import RLock\n\nif typing.TYPE_CHECKING:\n    # We can only import Protocol if TYPE_CHECKING because it's a development\n    # dependency, and is not available at runtime.\n    from typing import Protocol\n\n    from typing_extensions import Self\n\n    class HasGettableStringKeys(Protocol):\n        def keys(self) -> typing.Iterator[str]:\n            ...\n\n        def __getitem__(self, key: str) -> str:\n            ...\n\n\n__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]\n\n\n# Key type\n_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\n\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[typing.Tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\n\n\nclass _Sentinel(Enum):\n    not_passed = auto()\n\n\ndef ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.\n        return typing.cast(typing.Mapping[str, str], potential)\n    elif isinstance(potential, typing.Iterable):\n        # Similarly to Mapping, full runtime checking of the contents of an Iterable is\n        # expensive, so for the purposes of typechecking, we assume that any Iterable\n        # is the right shape.\n        return typing.cast(typing.Iterable[typing.Tuple[str, str]], potential)\n    elif hasattr(potential, \"keys\") and hasattr(potential, \"__getitem__\"):\n        return typing.cast(\"HasGettableStringKeys\", potential)\n    else:\n        return None\n\n\nclass RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n\n    :param maxsize:\n        Maximum number of recent elements to retain.\n\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called\n    \"\"\"\n\n    _container: typing.OrderedDict[_KT, _VT]\n    _maxsize: int\n    dispose_func: typing.Callable[[_VT], None] | None\n    lock: RLock\n\n    def __init__(\n        self,\n        maxsize: int = 10,\n        dispose_func: typing.Callable[[_VT], None] | None = None,\n    ) -> None:\n        super().__init__()\n        self._maxsize = maxsize\n        self.dispose_func = dispose_func\n        self._container = OrderedDict()\n        self.lock = RLock()\n\n    def __getitem__(self, key: _KT) -> _VT:\n        # Re-insert the item, moving it to the end of the eviction line.\n        with self.lock:\n            item = self._container.pop(key)\n            self._container[key] = item\n            return item\n\n    def __setitem__(self, key: _KT, value: _VT) -> None:\n        evicted_item = None\n        with self.lock:\n            # Possibly evict the existing value of 'key'\n            try:\n                # If the key exists, we'll overwrite it, which won't change the\n                # size of the pool. Because accessing a key should move it to\n                # the end of the eviction line, we pop it out first.\n                evicted_item = key, self._container.pop(key)\n                self._container[key] = value\n            except KeyError:\n                # When the key does not exist, we insert the value first so that\n                # evicting works in all cases, including when self._maxsize is 0\n                self._container[key] = value\n                if len(self._container) > self._maxsize:\n                    # If we didn't evict an existing value, and we've hit our maximum\n                    # size, then we have to evict the least recently used item from\n                    # the beginning of the container.\n                    evicted_item = self._container.popitem(last=False)\n\n        # After releasing the lock on the pool, dispose of any evicted value.\n        if evicted_item is not None and self.dispose_func:\n            _, evicted_value = evicted_item\n            self.dispose_func(evicted_value)\n\n    def __delitem__(self, key: _KT) -> None:\n        with self.lock:\n            value = self._container.pop(key)\n\n        if self.dispose_func:\n            self.dispose_func(value)\n\n    def __len__(self) -> int:\n        with self.lock:\n            return len(self._container)\n\n    def __iter__(self) -> typing.NoReturn:\n        raise NotImplementedError(\n            \"Iteration over this class is unlikely to be threadsafe.\"\n        )\n\n    def clear(self) -> None:\n        with self.lock:\n            # Copy pointers to all values, then wipe the mapping\n            values = list(self._container.values())\n            self._container.clear()\n\n        if self.dispose_func:\n            for value in values:\n                self.dispose_func(value)\n\n    def keys(self) -> set[_KT]:  # type: ignore[override]\n        with self.lock:\n            return set(self._container.keys())\n\n\nclass HTTPHeaderDictItemView(typing.Set[typing.Tuple[str, str]]):\n    \"\"\"\n    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\n    address.\n\n    If we directly try to get an item with a particular name, we will get a string\n    back that is the concatenated version of all the values:\n\n    >>> d['X-Header-Name']\n    'Value1, Value2, Value3'\n\n    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine\n    these values based on whether combine=True was called when building up the dictionary\n\n    >>> d = HTTPHeaderDict({\"A\": \"1\", \"B\": \"foo\"})\n    >>> d.add(\"A\", \"2\", combine=True)\n    >>> d.add(\"B\", \"bar\")\n    >>> list(d.items())\n    [\n        ('A', '1, 2'),\n        ('B', 'foo'),\n        ('B', 'bar'),\n    ]\n\n    This class conforms to the interface required by the MutableMapping ABC while\n    also giving us the nonstandard iteration behavior we want; items with duplicate\n    keys, ordered by time of first insertion.\n    \"\"\"\n\n    _headers: HTTPHeaderDict\n\n    def __init__(self, headers: HTTPHeaderDict) -> None:\n        self._headers = headers\n\n    def __len__(self) -> int:\n        return len(list(self._headers.iteritems()))\n\n    def __iter__(self) -> typing.Iterator[tuple[str, str]]:\n        return self._headers.iteritems()\n\n    def __contains__(self, item: object) -> bool:\n        if isinstance(item, tuple) and len(item) == 2:\n            passed_key, passed_val = item\n            if isinstance(passed_key, str) and isinstance(passed_val, str):\n                return self._headers._has_value_for_header(passed_key, passed_val)\n        return False\n\n\nclass HTTPHeaderDict(typing.MutableMapping[str, str]):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n\n    A ``dict`` like container for storing HTTP Headers.\n\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each\n    case-insensitive pair.\n\n    Using ``__setitem__`` syntax overwrites fields that compare equal\n    case-insensitively in order to maintain ``dict``'s api. For fields that\n    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``\n    in a loop.\n\n    If multiple fields that are equal case-insensitively are passed to the\n    constructor or ``.update``, the behavior is undefined and some will be\n    lost.\n\n    >>> headers = HTTPHeaderDict()\n    >>> headers.add('Set-Cookie', 'foo=bar')\n    >>> headers.add('set-cookie', 'baz=quxx')\n    >>> headers['content-length'] = '7'\n    >>> headers['SET-cookie']\n    'foo=bar, baz=quxx'\n    >>> headers['Content-Length']\n    '7'\n    \"\"\"\n\n    _container: typing.MutableMapping[str, list[str]]\n\n    def __init__(self, headers: ValidHTTPHeaderSource | None = None, **kwargs: str):\n        super().__init__()\n        self._container = {}  # 'dict' is insert-ordered\n        if headers is not None:\n            if isinstance(headers, HTTPHeaderDict):\n                self._copy_from(headers)\n            else:\n                self.extend(headers)\n        if kwargs:\n            self.extend(kwargs)\n\n    def __setitem__(self, key: str, val: str) -> None:\n        # avoid a bytes/str comparison by decoding before httplib\n        if isinstance(key, bytes):\n            key = key.decode(\"latin-1\")\n        self._container[key.lower()] = [key, val]\n\n    def __getitem__(self, key: str) -> str:\n        val = self._container[key.lower()]\n        return \", \".join(val[1:])\n\n    def __delitem__(self, key: str) -> None:\n        del self._container[key.lower()]\n\n    def __contains__(self, key: object) -> bool:\n        if isinstance(key, str):\n            return key.lower() in self._container\n        return False\n\n    def setdefault(self, key: str, default: str = \"\") -> str:\n        return super().setdefault(key, default)\n\n    def __eq__(self, other: object) -> bool:\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return False\n        else:\n            other_as_http_header_dict = type(self)(maybe_constructable)\n\n        return {k.lower(): v for k, v in self.itermerged()} == {\n            k.lower(): v for k, v in other_as_http_header_dict.itermerged()\n        }\n\n    def __ne__(self, other: object) -> bool:\n        return not self.__eq__(other)\n\n    def __len__(self) -> int:\n        return len(self._container)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        # Only provide the originally cased names\n        for vals in self._container.values():\n            yield vals[0]\n\n    def discard(self, key: str) -> None:\n        try:\n            del self[key]\n        except KeyError:\n            pass\n\n    def add(self, key: str, val: str, *, combine: bool = False) -> None:\n        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already\n        exists.\n\n        If this is called with combine=True, instead of adding a new header value\n        as a distinct item during iteration, this will instead append the value to\n        any existing header value with a comma. If no existing header value exists\n        for the key, then the value will simply be added, ignoring the combine parameter.\n\n        >>> headers = HTTPHeaderDict(foo='bar')\n        >>> headers.add('Foo', 'baz')\n        >>> headers['foo']\n        'bar, baz'\n        >>> list(headers.items())\n        [('foo', 'bar'), ('foo', 'baz')]\n        >>> headers.add('foo', 'quz', combine=True)\n        >>> list(headers.items())\n        [('foo', 'bar, baz, quz')]\n        \"\"\"\n        # avoid a bytes/str comparison by decoding before httplib\n        if isinstance(key, bytes):\n            key = key.decode(\"latin-1\")\n        key_lower = key.lower()\n        new_vals = [key, val]\n        # Keep the common case aka no item present as fast as possible\n        vals = self._container.setdefault(key_lower, new_vals)\n        if new_vals is not vals:\n            # if there are values here, then there is at least the initial\n            # key/value pair\n            assert len(vals) >= 2\n            if combine:\n                vals[-1] = vals[-1] + \", \" + val\n            else:\n                vals.append(val)\n\n    def extend(self, *args: ValidHTTPHeaderSource, **kwargs: str) -> None:\n        \"\"\"Generic import function for any type of header-like object.\n        Adapted version of MutableMapping.update in order to insert items\n        with self.add instead of self.__setitem__\n        \"\"\"\n        if len(args) > 1:\n            raise TypeError(\n                f\"extend() takes at most 1 positional arguments ({len(args)} given)\"\n            )\n        other = args[0] if len(args) >= 1 else ()\n\n        if isinstance(other, HTTPHeaderDict):\n            for key, val in other.iteritems():\n                self.add(key, val)\n        elif isinstance(other, typing.Mapping):\n            for key, val in other.items():\n                self.add(key, val)\n        elif isinstance(other, typing.Iterable):\n            other = typing.cast(typing.Iterable[typing.Tuple[str, str]], other)\n            for key, value in other:\n                self.add(key, value)\n        elif hasattr(other, \"keys\") and hasattr(other, \"__getitem__\"):\n            # THIS IS NOT A TYPESAFE BRANCH\n            # In this branch, the object has a `keys` attr but is not a Mapping or any of\n            # the other types indicated in the method signature. We do some stuff with\n            # it as though it partially implements the Mapping interface, but we're not\n            # doing that stuff safely AT ALL.\n            for key in other.keys():\n                self.add(key, other[key])\n\n        for key, value in kwargs.items():\n            self.add(key, value)\n\n    @typing.overload\n    def getlist(self, key: str) -> list[str]:\n        ...\n\n    @typing.overload\n    def getlist(self, key: str, default: _DT) -> list[str] | _DT:\n        ...\n\n    def getlist(\n        self, key: str, default: _Sentinel | _DT = _Sentinel.not_passed\n    ) -> list[str] | _DT:\n        \"\"\"Returns a list of all the values for the named field. Returns an\n        empty list if the key doesn't exist.\"\"\"\n        try:\n            vals = self._container[key.lower()]\n        except KeyError:\n            if default is _Sentinel.not_passed:\n                # _DT is unbound; empty list is instance of List[str]\n                return []\n            # _DT is bound; default is instance of _DT\n            return default\n        else:\n            # _DT may or may not be bound; vals[1:] is instance of List[str], which\n            # meets our external interface requirement of `Union[List[str], _DT]`.\n            return vals[1:]\n\n    def _prepare_for_method_change(self) -> Self:\n        \"\"\"\n        Remove content-specific header fields before changing the request\n        method to GET or HEAD according to RFC 9110, Section 15.4.\n        \"\"\"\n        content_specific_headers = [\n            \"Content-Encoding\",\n            \"Content-Language\",\n            \"Content-Location\",\n            \"Content-Type\",\n            \"Content-Length\",\n            \"Digest\",\n            \"Last-Modified\",\n        ]\n        for header in content_specific_headers:\n            self.discard(header)\n        return self\n\n    # Backwards compatibility for httplib\n    getheaders = getlist\n    getallmatchingheaders = getlist\n    iget = getlist\n\n    # Backwards compatibility for http.cookiejar\n    get_all = getlist\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}({dict(self.itermerged())})\"\n\n    def _copy_from(self, other: HTTPHeaderDict) -> None:\n        for key in other:\n            val = other.getlist(key)\n            self._container[key.lower()] = [key, *val]\n\n    def copy(self) -> Self:\n        clone = type(self)()\n        clone._copy_from(self)\n        return clone\n\n    def iteritems(self) -> typing.Iterator[tuple[str, str]]:\n        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"\n        for key in self:\n            vals = self._container[key.lower()]\n            for val in vals[1:]:\n                yield vals[0], val\n\n    def itermerged(self) -> typing.Iterator[tuple[str, str]]:\n        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"\n        for key in self:\n            val = self._container[key.lower()]\n            yield val[0], \", \".join(val[1:])\n\n    def items(self) -> HTTPHeaderDictItemView:  # type: ignore[override]\n        return HTTPHeaderDictItemView(self)\n\n    def _has_value_for_header(self, header_name: str, potential_value: str) -> bool:\n        if header_name in self:\n            return potential_value in self._container[header_name.lower()][1:]\n        return False\n\n    def __ior__(self, other: object) -> HTTPHeaderDict:\n        # Supports extending a header dict in-place using operator |=\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        self.extend(maybe_constructable)\n        return self\n\n    def __or__(self, other: object) -> Self:\n        # Supports merging header dicts using operator |\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        result = self.copy()\n        result.extend(maybe_constructable)\n        return result\n\n    def __ror__(self, other: object) -> Self:\n        # Supports merging header dicts using operator | when other is on left side\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        result = type(self)(maybe_constructable)\n        result.extend(self)\n        return result\n", "src/urllib3/poolmanager.py": "from __future__ import annotations\n\nimport functools\nimport logging\nimport typing\nimport warnings\nfrom types import TracebackType\nfrom urllib.parse import urljoin\n\nfrom ._collections import HTTPHeaderDict, RecentlyUsedContainer\nfrom ._request_methods import RequestMethods\nfrom .connection import ProxyConfig\nfrom .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme\nfrom .exceptions import (\n    LocationValueError,\n    MaxRetryError,\n    ProxySchemeUnknown,\n    URLSchemeUnknown,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import _TYPE_SOCKET_OPTIONS\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import Url, parse_url\n\nif typing.TYPE_CHECKING:\n    import ssl\n\n    from typing_extensions import Self\n\n__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]\n\n\nlog = logging.getLogger(__name__)\n\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",\n    \"ca_cert_dir\",\n    \"ssl_context\",\n    \"key_password\",\n    \"server_hostname\",\n)\n# Default value for `blocksize` - a new parameter introduced to\n# http.client.HTTPConnection & http.client.HTTPSConnection in Python 3.7\n_DEFAULT_BLOCKSIZE = 16384\n\n\nclass PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n\n    key_scheme: str\n    key_host: str\n    key_port: int | None\n    key_timeout: Timeout | float | int | None\n    key_retries: Retry | bool | int | None\n    key_block: bool | None\n    key_source_address: tuple[str, int] | None\n    key_key_file: str | None\n    key_key_password: str | None\n    key_cert_file: str | None\n    key_cert_reqs: str | None\n    key_ca_certs: str | None\n    key_ca_cert_data: str | bytes | None\n    key_ssl_version: int | str | None\n    key_ssl_minimum_version: ssl.TLSVersion | None\n    key_ssl_maximum_version: ssl.TLSVersion | None\n    key_ca_cert_dir: str | None\n    key_ssl_context: ssl.SSLContext | None\n    key_maxsize: int | None\n    key_headers: frozenset[tuple[str, str]] | None\n    key__proxy: Url | None\n    key__proxy_headers: frozenset[tuple[str, str]] | None\n    key__proxy_config: ProxyConfig | None\n    key_socket_options: _TYPE_SOCKET_OPTIONS | None\n    key__socks_options: frozenset[tuple[str, str]] | None\n    key_assert_hostname: bool | str | None\n    key_assert_fingerprint: str | None\n    key_server_hostname: str | None\n    key_blocksize: int | None\n\n\ndef _default_key_normalizer(\n    key_class: type[PoolKey], request_context: dict[str, typing.Any]\n) -> PoolKey:\n    \"\"\"\n    Create a pool key out of a request context dictionary.\n\n    According to RFC 3986, both the scheme and host are case-insensitive.\n    Therefore, this function normalizes both before constructing the pool\n    key for an HTTPS request. If you wish to change this behaviour, provide\n    alternate callables to ``key_fn_by_scheme``.\n\n    :param key_class:\n        The class to use when constructing the key. This should be a namedtuple\n        with the ``scheme`` and ``host`` keys at a minimum.\n    :type  key_class: namedtuple\n    :param request_context:\n        A dictionary-like object that contain the context for a request.\n    :type  request_context: dict\n\n    :return: A namedtuple that can be used as a connection pool key.\n    :rtype:  PoolKey\n    \"\"\"\n    # Since we mutate the dictionary, make a copy first\n    context = request_context.copy()\n    context[\"scheme\"] = context[\"scheme\"].lower()\n    context[\"host\"] = context[\"host\"].lower()\n\n    # These are both dictionaries and need to be transformed into frozensets\n    for key in (\"headers\", \"_proxy_headers\", \"_socks_options\"):\n        if key in context and context[key] is not None:\n            context[key] = frozenset(context[key].items())\n\n    # The socket_options key may be a list and needs to be transformed into a\n    # tuple.\n    socket_opts = context.get(\"socket_options\")\n    if socket_opts is not None:\n        context[\"socket_options\"] = tuple(socket_opts)\n\n    # Map the kwargs to the names in the namedtuple - this is necessary since\n    # namedtuples can't have fields starting with '_'.\n    for key in list(context.keys()):\n        context[\"key_\" + key] = context.pop(key)\n\n    # Default to ``None`` for keys missing from the context\n    for field in key_class._fields:\n        if field not in context:\n            context[field] = None\n\n    # Default key_blocksize to _DEFAULT_BLOCKSIZE if missing from the context\n    if context.get(\"key_blocksize\") is None:\n        context[\"key_blocksize\"] = _DEFAULT_BLOCKSIZE\n\n    return key_class(**context)\n\n\n#: A dictionary that maps a scheme to a callable that creates a pool key.\n#: This can be used to alter the way pool keys are constructed, if desired.\n#: Each PoolManager makes a copy of this dictionary so they can be configured\n#: globally here, or individually on the instance.\nkey_fn_by_scheme = {\n    \"http\": functools.partial(_default_key_normalizer, PoolKey),\n    \"https\": functools.partial(_default_key_normalizer, PoolKey),\n}\n\npool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\n\n\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param \\\\**connection_pool_kw:\n        Additional parameters are used to create fresh\n        :class:`urllib3.connectionpool.ConnectionPool` instances.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        http = urllib3.PoolManager(num_pools=2)\n\n        resp1 = http.request(\"GET\", \"https://google.com/\")\n        resp2 = http.request(\"GET\", \"https://google.com/mail\")\n        resp3 = http.request(\"GET\", \"https://yahoo.com/\")\n\n        print(len(http.pools))\n        # 2\n\n    \"\"\"\n\n    proxy: Url | None = None\n    proxy_config: ProxyConfig | None = None\n\n    def __init__(\n        self,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        **connection_pool_kw: typing.Any,\n    ) -> None:\n        super().__init__(headers)\n        self.connection_pool_kw = connection_pool_kw\n\n        self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]\n        self.pools = RecentlyUsedContainer(num_pools)\n\n        # Locally set the pool classes and keys so other PoolManagers can\n        # override them.\n        self.pool_classes_by_scheme = pool_classes_by_scheme\n        self.key_fn_by_scheme = key_fn_by_scheme.copy()\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> typing.Literal[False]:\n        self.clear()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def _new_pool(\n        self,\n        scheme: str,\n        host: str,\n        port: int,\n        request_context: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\n        any additional pool keyword arguments.\n\n        If ``request_context`` is provided, it is provided as keyword arguments\n        to the pool class used. This method is used to actually create the\n        connection pools handed out by :meth:`connection_from_url` and\n        companion methods. It is intended to be overridden for customization.\n        \"\"\"\n        pool_cls: type[HTTPConnectionPool] = self.pool_classes_by_scheme[scheme]\n        if request_context is None:\n            request_context = self.connection_pool_kw.copy()\n\n        # Default blocksize to _DEFAULT_BLOCKSIZE if missing or explicitly\n        # set to 'None' in the request_context.\n        if request_context.get(\"blocksize\") is None:\n            request_context[\"blocksize\"] = _DEFAULT_BLOCKSIZE\n\n        # Although the context has everything necessary to create the pool,\n        # this function has historically only used the scheme, host, and port\n        # in the positional args. When an API change is acceptable these can\n        # be removed.\n        for key in (\"scheme\", \"host\", \"port\"):\n            request_context.pop(key, None)\n\n        if scheme == \"http\":\n            for kw in SSL_KEYWORDS:\n                request_context.pop(kw, None)\n\n        return pool_cls(host, port, **request_context)\n\n    def clear(self) -> None:\n        \"\"\"\n        Empty our store of pools and direct them all to close.\n\n        This will not affect in-flight connections, but they will not be\n        re-used after completion.\n        \"\"\"\n        self.pools.clear()\n\n    def connection_from_host(\n        self,\n        host: str | None,\n        port: int | None = None,\n        scheme: str | None = \"http\",\n        pool_kwargs: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n        provided, it is merged with the instance's ``connection_pool_kw``\n        variable and used to create the new connection pool, if one is\n        needed.\n        \"\"\"\n\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        request_context = self._merge_pool_kwargs(pool_kwargs)\n        request_context[\"scheme\"] = scheme or \"http\"\n        if not port:\n            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n        request_context[\"port\"] = port\n        request_context[\"host\"] = host\n\n        return self.connection_from_context(request_context)\n\n    def connection_from_context(\n        self, request_context: dict[str, typing.Any]\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n        ``request_context`` must at least contain the ``scheme`` key and its\n        value must be a key in ``key_fn_by_scheme`` instance variable.\n        \"\"\"\n        if \"strict\" in request_context:\n            warnings.warn(\n                \"The 'strict' parameter is no longer needed on Python 3+. \"\n                \"This will raise an error in urllib3 v2.1.0.\",\n                DeprecationWarning,\n            )\n            request_context.pop(\"strict\")\n\n        scheme = request_context[\"scheme\"].lower()\n        pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n        if not pool_key_constructor:\n            raise URLSchemeUnknown(scheme)\n        pool_key = pool_key_constructor(request_context)\n\n        return self.connection_from_pool_key(pool_key, request_context=request_context)\n\n    def connection_from_pool_key(\n        self, pool_key: PoolKey, request_context: dict[str, typing.Any]\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n        ``pool_key`` should be a namedtuple that only contains immutable\n        objects. At a minimum it must have the ``scheme``, ``host``, and\n        ``port`` fields.\n        \"\"\"\n        with self.pools.lock:\n            # If the scheme, host, or port doesn't match existing open\n            # connections, open a new ConnectionPool.\n            pool = self.pools.get(pool_key)\n            if pool:\n                return pool\n\n            # Make a fresh ConnectionPool of the desired type\n            scheme = request_context[\"scheme\"]\n            host = request_context[\"host\"]\n            port = request_context[\"port\"]\n            pool = self._new_pool(scheme, host, port, request_context=request_context)\n            self.pools[pool_key] = pool\n\n        return pool\n\n    def connection_from_url(\n        self, url: str, pool_kwargs: dict[str, typing.Any] | None = None\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n        If ``pool_kwargs`` is not provided and a new pool needs to be\n        constructed, ``self.connection_pool_kw`` is used to initialize\n        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n        is provided, it is used instead. Note that if a new pool does not\n        need to be created for the request, the provided ``pool_kwargs`` are\n        not used.\n        \"\"\"\n        u = parse_url(url)\n        return self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _merge_pool_kwargs(\n        self, override: dict[str, typing.Any] | None\n    ) -> dict[str, typing.Any]:\n        \"\"\"\n        Merge a dictionary of override values for self.connection_pool_kw.\n\n        This does not modify self.connection_pool_kw and returns a new dict.\n        Any keys in the override dictionary with a value of ``None`` are\n        removed from the merged dictionary.\n        \"\"\"\n        base_pool_kwargs = self.connection_pool_kw.copy()\n        if override:\n            for key, value in override.items():\n                if value is None:\n                    try:\n                        del base_pool_kwargs[key]\n                    except KeyError:\n                        pass\n                else:\n                    base_pool_kwargs[key] = value\n        return base_pool_kwargs\n\n    def _proxy_requires_url_absolute_form(self, parsed_url: Url) -> bool:\n        \"\"\"\n        Indicates if the proxy requires the complete destination URL in the\n        request.  Normally this is only needed when not using an HTTP CONNECT\n        tunnel.\n        \"\"\"\n        if self.proxy is None:\n            return False\n\n        return not connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, parsed_url.scheme\n        )\n\n    def urlopen(  # type: ignore[override]\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n\n        if u.scheme is None:\n            warnings.warn(\n                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"\n                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"\n                \"start with 'https://' or 'http://'. Read more in this issue: \"\n                \"https://github.com/urllib3/urllib3/issues/2920\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        if response.status == 303:\n            # Change the method according to RFC 9110, Section 15.4.4.\n            method = \"GET\"\n            # And lose the body not to transfer anything sensitive.\n            kw[\"body\"] = None\n            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])._prepare_for_method_change()\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            new_headers = kw[\"headers\"].copy()\n            for header in kw[\"headers\"]:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    new_headers.pop(header, None)\n            kw[\"headers\"] = new_headers\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -> %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)\n\n\nclass ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n\n    :param proxy_url:\n        The URL of the proxy to be used.\n\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n        authentication.\n\n    :param proxy_ssl_context:\n        The proxy SSL context is used to establish the TLS connection to the\n        proxy when using HTTPS proxies.\n\n    :param use_forwarding_for_https:\n        (Defaults to False) If set to True will forward requests to the HTTPS\n        proxy to be made on behalf of the client instead of creating a TLS\n        tunnel via the CONNECT method. **Enabling this flag means that request\n        and response headers and content will be visible from the HTTPS proxy**\n        whereas tunneling keeps request and response headers and content\n        private.  IP address, target hostname, SNI, and port are always visible\n        to an HTTPS proxy even when this flag is disabled.\n\n    :param proxy_assert_hostname:\n        The hostname of the certificate to verify against.\n\n    :param proxy_assert_fingerprint:\n        The fingerprint of the certificate to verify against.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        proxy = urllib3.ProxyManager(\"https://localhost:3128/\")\n\n        resp1 = proxy.request(\"GET\", \"https://google.com/\")\n        resp2 = proxy.request(\"GET\", \"https://httpbin.org/\")\n\n        print(len(proxy.pools))\n        # 1\n\n        resp3 = proxy.request(\"GET\", \"https://httpbin.org/\")\n        resp4 = proxy.request(\"GET\", \"https://twitter.com/\")\n\n        print(len(proxy.pools))\n        # 3\n\n    \"\"\"\n\n    def __init__(\n        self,\n        proxy_url: str,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        proxy_headers: typing.Mapping[str, str] | None = None,\n        proxy_ssl_context: ssl.SSLContext | None = None,\n        use_forwarding_for_https: bool = False,\n        proxy_assert_hostname: None | str | typing.Literal[False] = None,\n        proxy_assert_fingerprint: str | None = None,\n        **connection_pool_kw: typing.Any,\n    ) -> None:\n        if isinstance(proxy_url, HTTPConnectionPool):\n            str_proxy_url = f\"{proxy_url.scheme}://{proxy_url.host}:{proxy_url.port}\"\n        else:\n            str_proxy_url = proxy_url\n        proxy = parse_url(str_proxy_url)\n\n        if proxy.scheme not in (\"http\", \"https\"):\n            raise ProxySchemeUnknown(proxy.scheme)\n\n        if not proxy.port:\n            port = port_by_scheme.get(proxy.scheme, 80)\n            proxy = proxy._replace(port=port)\n\n        self.proxy = proxy\n        self.proxy_headers = proxy_headers or {}\n        self.proxy_ssl_context = proxy_ssl_context\n        self.proxy_config = ProxyConfig(\n            proxy_ssl_context,\n            use_forwarding_for_https,\n            proxy_assert_hostname,\n            proxy_assert_fingerprint,\n        )\n\n        connection_pool_kw[\"_proxy\"] = self.proxy\n        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers\n        connection_pool_kw[\"_proxy_config\"] = self.proxy_config\n\n        super().__init__(num_pools, headers, **connection_pool_kw)\n\n    def connection_from_host(\n        self,\n        host: str | None,\n        port: int | None = None,\n        scheme: str | None = \"http\",\n        pool_kwargs: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        if scheme == \"https\":\n            return super().connection_from_host(\n                host, port, scheme, pool_kwargs=pool_kwargs\n            )\n\n        return super().connection_from_host(\n            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs  # type: ignore[union-attr]\n        )\n\n    def _set_proxy_headers(\n        self, url: str, headers: typing.Mapping[str, str] | None = None\n    ) -> typing.Mapping[str, str]:\n        \"\"\"\n        Sets headers needed by proxies: specifically, the Accept and Host\n        headers. Only sets headers not provided by the user.\n        \"\"\"\n        headers_ = {\"Accept\": \"*/*\"}\n\n        netloc = parse_url(url).netloc\n        if netloc:\n            headers_[\"Host\"] = netloc\n\n        if headers:\n            headers_.update(headers)\n        return headers_\n\n    def urlopen(  # type: ignore[override]\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> BaseHTTPResponse:\n        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n        u = parse_url(url)\n        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n            # For connections using HTTP CONNECT, httplib sets the necessary\n            # headers on the CONNECT to the proxy. If we're not using CONNECT,\n            # we'll definitely need to set 'Host' at the very least.\n            headers = kw.get(\"headers\", self.headers)\n            kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n        return super().urlopen(method, url, redirect=redirect, **kw)\n\n\ndef proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:\n    return ProxyManager(proxy_url=url, **kw)\n", "src/urllib3/__init__.py": "\"\"\"\nPython HTTP library with thread-safe connection pooling, file post support, user friendly, and more\n\"\"\"\n\nfrom __future__ import annotations\n\n# Set default logging handler to avoid \"No handler found\" warnings.\nimport logging\nimport sys\nimport typing\nimport warnings\nfrom logging import NullHandler\n\nfrom . import exceptions\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom ._version import __version__\nfrom .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, connection_from_url\nfrom .filepost import _TYPE_FIELDS, encode_multipart_formdata\nfrom .poolmanager import PoolManager, ProxyManager, proxy_from_url\nfrom .response import BaseHTTPResponse, HTTPResponse\nfrom .util.request import make_headers\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\n\n# Ensure that Python is compiled with OpenSSL 1.1.1+\n# If the 'ssl' module isn't available at all that's\n# fine, we only care if the module is available.\ntry:\n    import ssl\nexcept ImportError:\n    pass\nelse:\n    if not ssl.OPENSSL_VERSION.startswith(\"OpenSSL \"):  # Defensive:\n        warnings.warn(\n            \"urllib3 v2 only supports OpenSSL 1.1.1+, currently \"\n            f\"the 'ssl' module is compiled with {ssl.OPENSSL_VERSION!r}. \"\n            \"See: https://github.com/urllib3/urllib3/issues/3020\",\n            exceptions.NotOpenSSLWarning,\n        )\n    elif ssl.OPENSSL_VERSION_INFO < (1, 1, 1):  # Defensive:\n        raise ImportError(\n            \"urllib3 v2 only supports OpenSSL 1.1.1+, currently \"\n            f\"the 'ssl' module is compiled with {ssl.OPENSSL_VERSION!r}. \"\n            \"See: https://github.com/urllib3/urllib3/issues/2168\"\n        )\n\n__author__ = \"Andrey Petrov (andrey.petrov@shazow.net)\"\n__license__ = \"MIT\"\n__version__ = __version__\n\n__all__ = (\n    \"HTTPConnectionPool\",\n    \"HTTPHeaderDict\",\n    \"HTTPSConnectionPool\",\n    \"PoolManager\",\n    \"ProxyManager\",\n    \"HTTPResponse\",\n    \"Retry\",\n    \"Timeout\",\n    \"add_stderr_logger\",\n    \"connection_from_url\",\n    \"disable_warnings\",\n    \"encode_multipart_formdata\",\n    \"make_headers\",\n    \"proxy_from_url\",\n    \"request\",\n    \"BaseHTTPResponse\",\n)\n\nlogging.getLogger(__name__).addHandler(NullHandler())\n\n\ndef add_stderr_logger(\n    level: int = logging.DEBUG,\n) -> logging.StreamHandler[typing.TextIO]:\n    \"\"\"\n    Helper for quickly adding a StreamHandler to the logger. Useful for\n    debugging.\n\n    Returns the handler after adding it.\n    \"\"\"\n    # This method needs to be in this __init__.py to get the __name__ correct\n    # even if urllib3 is vendored within another package.\n    logger = logging.getLogger(__name__)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)s %(message)s\"))\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    logger.debug(\"Added a stderr logging handler to logger: %s\", __name__)\n    return handler\n\n\n# ... Clean up.\ndel NullHandler\n\n\n# All warning filters *must* be appended unless you're really certain that they\n# shouldn't be: otherwise, it's very hard for users to use most Python\n# mechanisms to silence them.\n# SecurityWarning's always go off by default.\nwarnings.simplefilter(\"always\", exceptions.SecurityWarning, append=True)\n# InsecurePlatformWarning's don't vary between requests, so we keep it default.\nwarnings.simplefilter(\"default\", exceptions.InsecurePlatformWarning, append=True)\n\n\ndef disable_warnings(category: type[Warning] = exceptions.HTTPWarning) -> None:\n    \"\"\"\n    Helper for quickly disabling all urllib3 warnings.\n    \"\"\"\n    warnings.simplefilter(\"ignore\", category)\n\n\n_DEFAULT_POOL = PoolManager()\n\n\ndef request(\n    method: str,\n    url: str,\n    *,\n    body: _TYPE_BODY | None = None,\n    fields: _TYPE_FIELDS | None = None,\n    headers: typing.Mapping[str, str] | None = None,\n    preload_content: bool | None = True,\n    decode_content: bool | None = True,\n    redirect: bool | None = True,\n    retries: Retry | bool | int | None = None,\n    timeout: Timeout | float | int | None = 3,\n    json: typing.Any | None = None,\n) -> BaseHTTPResponse:\n    \"\"\"\n    A convenience, top-level request method. It uses a module-global ``PoolManager`` instance.\n    Therefore, its side effects could be shared across dependencies relying on it.\n    To avoid side effects create a new ``PoolManager`` instance and use it instead.\n    The method does not accept low-level ``**urlopen_kw`` keyword arguments.\n\n    :param method:\n        HTTP request method (such as GET, POST, PUT, etc.)\n\n    :param url:\n        The URL to perform the request on.\n\n    :param body:\n        Data to send in the request body, either :class:`str`, :class:`bytes`,\n        an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n    :param fields:\n        Data to encode and send in the request body.\n\n    :param headers:\n        Dictionary of custom headers to send, such as User-Agent,\n        If-None-Match, etc.\n\n    :param bool preload_content:\n        If True, the response's body will be preloaded into memory.\n\n    :param bool decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param redirect:\n        If True, automatically handle redirects (status codes 301, 302,\n        303, 307, 308). Each redirect counts as a retry. Disabling retries\n        will disable redirect, too.\n\n    :param retries:\n        Configure the number of retries to allow before raising a\n        :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n        If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n        :class:`~urllib3.util.retry.Retry` object for fine-grained control\n        over different types of retries.\n        Pass an integer number to retry connection errors that many times,\n        but no other types of errors. Pass zero to never retry.\n\n        If ``False``, then retries are disabled and any exception is raised\n        immediately. Also, instead of raising a MaxRetryError on redirects,\n        the redirect response will be returned.\n\n    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n    :param timeout:\n        If specified, overrides the default timeout for this one\n        request. It may be a float (in seconds) or an instance of\n        :class:`urllib3.util.Timeout`.\n\n    :param json:\n        Data to encode and send as JSON with UTF-encoded in the request body.\n        The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n        unless specified otherwise.\n    \"\"\"\n\n    return _DEFAULT_POOL.request(\n        method,\n        url,\n        body=body,\n        fields=fields,\n        headers=headers,\n        preload_content=preload_content,\n        decode_content=decode_content,\n        redirect=redirect,\n        retries=retries,\n        timeout=timeout,\n        json=json,\n    )\n\n\nif sys.platform == \"emscripten\":\n    from .contrib.emscripten import inject_into_urllib3  # noqa: 401\n\n    inject_into_urllib3()\n", "src/urllib3/_request_methods.py": "from __future__ import annotations\n\nimport json as _json\nimport typing\nfrom urllib.parse import urlencode\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom .filepost import _TYPE_FIELDS, encode_multipart_formdata\nfrom .response import BaseHTTPResponse\n\n__all__ = [\"RequestMethods\"]\n\n_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[typing.Tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\n\n\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n\n    Specifically,\n\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).\n\n    :meth:`.request_encode_body` is for sending requests whose fields are\n    encoded in the *body* of the request using multipart or www-form-urlencoded\n    (such as for POST, PUT, PATCH).\n\n    :meth:`.request` is for making any kind of request, it will look up the\n    appropriate encoding format and use one of the above two methods to make\n    the request.\n\n    Initializer parameters:\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n    \"\"\"\n\n    _encode_url_methods = {\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\"}\n\n    def __init__(self, headers: typing.Mapping[str, str] | None = None) -> None:\n        self.headers = headers or {}\n\n    def urlopen(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        encode_multipart: bool = True,\n        multipart_boundary: str | None = None,\n        **kw: typing.Any,\n    ) -> BaseHTTPResponse:  # Abstract\n        raise NotImplementedError(\n            \"Classes extending RequestMethods must implement \"\n            \"their own ``urlopen`` method.\"\n        )\n\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        fields: _TYPE_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        json: typing.Any | None = None,\n        **urlopen_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the appropriate encoding of\n        ``fields`` based on the ``method`` used.\n\n        This is a convenience method that requires the least amount of manual\n        effort. It can be used in most situations, while still having the\n        option to drop down to more specific methods when necessary, such as\n        :meth:`request_encode_url`, :meth:`request_encode_body`,\n        or even the lowest level :meth:`urlopen`.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param fields:\n            Data to encode and send in the request body.  Values are processed\n            by :func:`urllib.parse.urlencode`.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param json:\n            Data to encode and send as JSON with UTF-encoded in the request body.\n            The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n            unless specified otherwise.\n        \"\"\"\n        method = method.upper()\n\n        if json is not None and body is not None:\n            raise TypeError(\n                \"request got values for both 'body' and 'json' parameters which are mutually exclusive\"\n            )\n\n        if json is not None:\n            if headers is None:\n                headers = self.headers\n\n            if not (\"content-type\" in map(str.lower, headers.keys())):\n                headers = HTTPHeaderDict(headers)\n                headers[\"Content-Type\"] = \"application/json\"\n\n            body = _json.dumps(json, separators=(\",\", \":\"), ensure_ascii=False).encode(\n                \"utf-8\"\n            )\n\n        if body is not None:\n            urlopen_kw[\"body\"] = body\n\n        if method in self._encode_url_methods:\n            return self.request_encode_url(\n                method,\n                url,\n                fields=fields,  # type: ignore[arg-type]\n                headers=headers,\n                **urlopen_kw,\n            )\n        else:\n            return self.request_encode_body(\n                method, url, fields=fields, headers=headers, **urlopen_kw\n            )\n\n    def request_encode_url(\n        self,\n        method: str,\n        url: str,\n        fields: _TYPE_ENCODE_URL_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        **urlopen_kw: str,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param fields:\n            Data to encode and send in the request body.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw: dict[str, typing.Any] = {\"headers\": headers}\n        extra_kw.update(urlopen_kw)\n\n        if fields:\n            url += \"?\" + urlencode(fields)\n\n        return self.urlopen(method, url, **extra_kw)\n\n    def request_encode_body(\n        self,\n        method: str,\n        url: str,\n        fields: _TYPE_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        encode_multipart: bool = True,\n        multipart_boundary: str | None = None,\n        **urlopen_kw: str,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the body. This is useful for request methods like POST, PUT, PATCH, etc.\n\n        When ``encode_multipart=True`` (default), then\n        :func:`urllib3.encode_multipart_formdata` is used to encode\n        the payload with the appropriate content type. Otherwise\n        :func:`urllib.parse.urlencode` is used with the\n        'application/x-www-form-urlencoded' content type.\n\n        Multipart encoding must be used when posting files, and it's reasonably\n        safe to use it in other times too. However, it may break request\n        signing, such as with OAuth.\n\n        Supports an optional ``fields`` parameter of key/value strings AND\n        key/filetuple. A filetuple is a (filename, data, MIME type) tuple where\n        the MIME type is optional. For example::\n\n            fields = {\n                'foo': 'bar',\n                'fakefile': ('foofile.txt', 'contents of foofile'),\n                'realfile': ('barfile.txt', open('realfile').read()),\n                'typedfile': ('bazfile.bin', open('bazfile').read(),\n                              'image/jpeg'),\n                'nonamefile': 'contents of nonamefile field',\n            }\n\n        When uploading a file, providing a filename (the first parameter of the\n        tuple) is optional but recommended to best mimic behavior of browsers.\n\n        Note that if ``headers`` are supplied, the 'Content-Type' header will\n        be overwritten because it depends on the dynamic random boundary string\n        which is used to compose the body of the request. The random boundary\n        string can be explicitly set with the ``multipart_boundary`` parameter.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param fields:\n            Data to encode and send in the request body.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param encode_multipart:\n            If True, encode the ``fields`` using the multipart/form-data MIME\n            format.\n\n        :param multipart_boundary:\n            If not specified, then a random boundary will be generated using\n            :func:`urllib3.filepost.choose_boundary`.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw: dict[str, typing.Any] = {\"headers\": HTTPHeaderDict(headers)}\n        body: bytes | str\n\n        if fields:\n            if \"body\" in urlopen_kw:\n                raise TypeError(\n                    \"request got values for both 'fields' and 'body', can only specify one.\"\n                )\n\n            if encode_multipart:\n                body, content_type = encode_multipart_formdata(\n                    fields, boundary=multipart_boundary\n                )\n            else:\n                body, content_type = (\n                    urlencode(fields),  # type: ignore[arg-type]\n                    \"application/x-www-form-urlencoded\",\n                )\n\n            extra_kw[\"body\"] = body\n            extra_kw[\"headers\"].setdefault(\"Content-Type\", content_type)\n\n        extra_kw.update(urlopen_kw)\n\n        return self.urlopen(method, url, **extra_kw)\n", "src/urllib3/contrib/socks.py": "\"\"\"\nThis module contains provisional support for SOCKS proxies from within\nurllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and\nSOCKS5. To enable its functionality, either install PySocks or install this\nmodule with the ``socks`` extra.\n\nThe SOCKS implementation supports the full range of urllib3 features. It also\nsupports the following SOCKS features:\n\n- SOCKS4A (``proxy_url='socks4a://...``)\n- SOCKS4 (``proxy_url='socks4://...``)\n- SOCKS5 with remote DNS (``proxy_url='socks5h://...``)\n- SOCKS5 with local DNS (``proxy_url='socks5://...``)\n- Usernames and passwords for the SOCKS proxy\n\n.. note::\n   It is recommended to use ``socks5h://`` or ``socks4a://`` schemes in\n   your ``proxy_url`` to ensure that DNS resolution is done from the remote\n   server instead of client-side when connecting to a domain name.\n\nSOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5\nsupports IPv4, IPv6, and domain names.\n\nWhen connecting to a SOCKS4 proxy the ``username`` portion of the ``proxy_url``\nwill be sent as the ``userid`` section of the SOCKS request:\n\n.. code-block:: python\n\n    proxy_url=\"socks4a://<userid>@proxy-host\"\n\nWhen connecting to a SOCKS5 proxy the ``username`` and ``password`` portion\nof the ``proxy_url`` will be sent as the username/password to authenticate\nwith the proxy:\n\n.. code-block:: python\n\n    proxy_url=\"socks5h://<username>:<password>@proxy-host\"\n\n\"\"\"\n\nfrom __future__ import annotations\n\ntry:\n    import socks  # type: ignore[import-not-found]\nexcept ImportError:\n    import warnings\n\n    from ..exceptions import DependencyWarning\n\n    warnings.warn(\n        (\n            \"SOCKS support in urllib3 requires the installation of optional \"\n            \"dependencies: specifically, PySocks.  For more information, see \"\n            \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html#socks-proxies\"\n        ),\n        DependencyWarning,\n    )\n    raise\n\nimport typing\nfrom socket import timeout as SocketTimeout\n\nfrom ..connection import HTTPConnection, HTTPSConnection\nfrom ..connectionpool import HTTPConnectionPool, HTTPSConnectionPool\nfrom ..exceptions import ConnectTimeoutError, NewConnectionError\nfrom ..poolmanager import PoolManager\nfrom ..util.url import parse_url\n\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None  # type: ignore[assignment]\n\n\nclass _TYPE_SOCKS_OPTIONS(typing.TypedDict):\n    socks_version: int\n    proxy_host: str | None\n    proxy_port: str | None\n    username: str | None\n    password: str | None\n    rdns: bool\n\n\nclass SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n\n    def __init__(\n        self,\n        _socks_options: _TYPE_SOCKS_OPTIONS,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> None:\n        self._socks_options = _socks_options\n        super().__init__(*args, **kwargs)\n\n    def _new_conn(self) -> socks.socksocket:\n        \"\"\"\n        Establish a new connection via the SOCKS proxy.\n        \"\"\"\n        extra_kw: dict[str, typing.Any] = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n\n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n\n        try:\n            conn = socks.create_connection(\n                (self.host, self.port),\n                proxy_type=self._socks_options[\"socks_version\"],\n                proxy_addr=self._socks_options[\"proxy_host\"],\n                proxy_port=self._socks_options[\"proxy_port\"],\n                proxy_username=self._socks_options[\"username\"],\n                proxy_password=self._socks_options[\"password\"],\n                proxy_rdns=self._socks_options[\"rdns\"],\n                timeout=self.timeout,\n                **extra_kw,\n            )\n\n        except SocketTimeout as e:\n            raise ConnectTimeoutError(\n                self,\n                f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n            ) from e\n\n        except socks.ProxyError as e:\n            # This is fragile as hell, but it seems to be the only way to raise\n            # useful errors here.\n            if e.socket_err:\n                error = e.socket_err\n                if isinstance(error, SocketTimeout):\n                    raise ConnectTimeoutError(\n                        self,\n                        f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n                    ) from e\n                else:\n                    # Adding `from e` messes with coverage somehow, so it's omitted.\n                    # See #2386.\n                    raise NewConnectionError(\n                        self, f\"Failed to establish a new connection: {error}\"\n                    )\n            else:\n                raise NewConnectionError(\n                    self, f\"Failed to establish a new connection: {e}\"\n                ) from e\n\n        except OSError as e:  # Defensive: PySocks should catch all these.\n            raise NewConnectionError(\n                self, f\"Failed to establish a new connection: {e}\"\n            ) from e\n\n        return conn\n\n\n# We don't need to duplicate the Verified/Unverified distinction from\n# urllib3/connection.py here because the HTTPSConnection will already have been\n# correctly set to either the Verified or Unverified form by that module. This\n# means the SOCKSHTTPSConnection will automatically be the correct type.\nclass SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):\n    pass\n\n\nclass SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\n\n\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\n\n\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n\n    def __init__(\n        self,\n        proxy_url: str,\n        username: str | None = None,\n        password: str | None = None,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        **connection_pool_kw: typing.Any,\n    ):\n        parsed = parse_url(proxy_url)\n\n        if username is None and password is None and parsed.auth is not None:\n            split = parsed.auth.split(\":\")\n            if len(split) == 2:\n                username, password = split\n        if parsed.scheme == \"socks5\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = False\n        elif parsed.scheme == \"socks5h\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = True\n        elif parsed.scheme == \"socks4\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = False\n        elif parsed.scheme == \"socks4a\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = True\n        else:\n            raise ValueError(f\"Unable to determine SOCKS version from {proxy_url}\")\n\n        self.proxy_url = proxy_url\n\n        socks_options = {\n            \"socks_version\": socks_version,\n            \"proxy_host\": parsed.host,\n            \"proxy_port\": parsed.port,\n            \"username\": username,\n            \"password\": password,\n            \"rdns\": rdns,\n        }\n        connection_pool_kw[\"_socks_options\"] = socks_options\n\n        super().__init__(num_pools, headers, **connection_pool_kw)\n\n        self.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme\n", "src/urllib3/contrib/__init__.py": "", "src/urllib3/contrib/pyopenssl.py": "\"\"\"\nModule for using pyOpenSSL as a TLS backend. This module was relevant before\nthe standard library ``ssl`` module supported SNI, but now that we've dropped\nsupport for Python 2.7 all relevant Python versions support SNI so\n**this module is no longer recommended**.\n\nThis needs the following packages installed:\n\n* `pyOpenSSL`_ (tested with 16.0.0)\n* `cryptography`_ (minimum 1.3.4, from pyopenssl)\n* `idna`_ (minimum 2.0)\n\nHowever, pyOpenSSL depends on cryptography, so while we use all three directly here we\nend up having relatively few packages required.\n\nYou can install them with the following command:\n\n.. code-block:: bash\n\n    $ python -m pip install pyopenssl cryptography idna\n\nTo activate certificate checking, call\n:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code\nbefore you begin making HTTP requests. This can be done in a ``sitecustomize``\nmodule, or at any other time before your application begins using ``urllib3``,\nlike this:\n\n.. code-block:: python\n\n    try:\n        import urllib3.contrib.pyopenssl\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n    except ImportError:\n        pass\n\n.. _pyopenssl: https://www.pyopenssl.org\n.. _cryptography: https://cryptography.io\n.. _idna: https://github.com/kjd/idna\n\"\"\"\n\nfrom __future__ import annotations\n\nimport OpenSSL.SSL  # type: ignore[import-untyped]\nfrom cryptography import x509\n\ntry:\n    from cryptography.x509 import UnsupportedExtension  # type: ignore[attr-defined]\nexcept ImportError:\n    # UnsupportedExtension is gone in cryptography >= 2.1.0\n    class UnsupportedExtension(Exception):  # type: ignore[no-redef]\n        pass\n\n\nimport logging\nimport ssl\nimport typing\nfrom io import BytesIO\nfrom socket import socket as socket_cls\nfrom socket import timeout\n\nfrom .. import util\n\nif typing.TYPE_CHECKING:\n    from OpenSSL.crypto import X509  # type: ignore[import-untyped]\n\n\n__all__ = [\"inject_into_urllib3\", \"extract_from_urllib3\"]\n\n# Map from urllib3 to PyOpenSSL compatible parameter-values.\n_openssl_versions: dict[int, int] = {\n    util.ssl_.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    util.ssl_.PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,\n}\n\nif hasattr(ssl, \"PROTOCOL_TLSv1_1\") and hasattr(OpenSSL.SSL, \"TLSv1_1_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD\n\nif hasattr(ssl, \"PROTOCOL_TLSv1_2\") and hasattr(OpenSSL.SSL, \"TLSv1_2_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD\n\n\n_stdlib_to_openssl_verify = {\n    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,\n    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,\n    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER\n    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n}\n_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(\n    OpenSSL.SSL, \"OP_NO_SSLv3\", 0\n)\n_OP_NO_TLSv1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1\", 0)\n_OP_NO_TLSv1_1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_1\", 0)\n_OP_NO_TLSv1_2: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_2\", 0)\n_OP_NO_TLSv1_3: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_3\", 0)\n\n_openssl_to_ssl_minimum_version: dict[int, int] = {\n    ssl.TLSVersion.MINIMUM_SUPPORTED: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.TLSv1: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.TLSv1_1: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1,\n    ssl.TLSVersion.TLSv1_2: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1,\n    ssl.TLSVersion.TLSv1_3: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2\n    ),\n    ssl.TLSVersion.MAXIMUM_SUPPORTED: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2\n    ),\n}\n_openssl_to_ssl_maximum_version: dict[int, int] = {\n    ssl.TLSVersion.MINIMUM_SUPPORTED: (\n        _OP_NO_SSLv2_OR_SSLv3\n        | _OP_NO_TLSv1\n        | _OP_NO_TLSv1_1\n        | _OP_NO_TLSv1_2\n        | _OP_NO_TLSv1_3\n    ),\n    ssl.TLSVersion.TLSv1: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2 | _OP_NO_TLSv1_3\n    ),\n    ssl.TLSVersion.TLSv1_1: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_2 | _OP_NO_TLSv1_3,\n    ssl.TLSVersion.TLSv1_2: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_3,\n    ssl.TLSVersion.TLSv1_3: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.MAXIMUM_SUPPORTED: _OP_NO_SSLv2_OR_SSLv3,\n}\n\n# OpenSSL will only write 16K at a time\nSSL_WRITE_BLOCKSIZE = 16384\n\norig_util_SSLContext = util.ssl_.SSLContext\n\n\nlog = logging.getLogger(__name__)\n\n\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n\n    _validate_dependencies_met()\n\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\n\n\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\n\n\ndef _validate_dependencies_met() -> None:\n    \"\"\"\n    Verifies that PyOpenSSL's package-level dependencies have been met.\n    Throws `ImportError` if they are not met.\n    \"\"\"\n    # Method added in `cryptography==1.1`; not available in older versions\n    from cryptography.x509.extensions import Extensions\n\n    if getattr(Extensions, \"get_extension_for_class\", None) is None:\n        raise ImportError(\n            \"'cryptography' module missing required functionality.  \"\n            \"Try upgrading to v1.3.4 or newer.\"\n        )\n\n    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509\n    # attribute is only present on those versions.\n    from OpenSSL.crypto import X509\n\n    x509 = X509()\n    if getattr(x509, \"_x509\", None) is None:\n        raise ImportError(\n            \"'pyOpenSSL' module missing required functionality. \"\n            \"Try upgrading to v0.14 or newer.\"\n        )\n\n\ndef _dnsname_to_stdlib(name: str) -> str | None:\n    \"\"\"\n    Converts a dNSName SubjectAlternativeName field to the form used by the\n    standard library on the given Python version.\n\n    Cryptography produces a dNSName as a unicode string that was idna-decoded\n    from ASCII bytes. We need to idna-encode that string to get it back, and\n    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib\n    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).\n\n    If the name cannot be idna-encoded then we return None signalling that\n    the name given should be skipped.\n    \"\"\"\n\n    def idna_encode(name: str) -> bytes | None:\n        \"\"\"\n        Borrowed wholesale from the Python Cryptography Project. It turns out\n        that we can't just safely call `idna.encode`: it can explode for\n        wildcard names. This avoids that problem.\n        \"\"\"\n        import idna\n\n        try:\n            for prefix in [\"*.\", \".\"]:\n                if name.startswith(prefix):\n                    name = name[len(prefix) :]\n                    return prefix.encode(\"ascii\") + idna.encode(name)\n            return idna.encode(name)\n        except idna.core.IDNAError:\n            return None\n\n    # Don't send IPv6 addresses through the IDNA encoder.\n    if \":\" in name:\n        return name\n\n    encoded_name = idna_encode(name)\n    if encoded_name is None:\n        return None\n    return encoded_name.decode(\"utf-8\")\n\n\ndef get_subj_alt_name(peer_cert: X509) -> list[tuple[str, str]]:\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    cert = peer_cert.to_cryptography()\n\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:\n        # No such extension, return the empty list.\n        return []\n    except (\n        x509.DuplicateExtension,\n        UnsupportedExtension,\n        x509.UnsupportedGeneralNameType,\n        UnicodeError,\n    ) as e:\n        # A problem has been found with the quality of the certificate. Assume\n        # no SAN field is present.\n        log.warning(\n            \"A problem was encountered with the certificate that prevented \"\n            \"urllib3 from finding the SubjectAlternativeName field. This can \"\n            \"affect certificate validation. The error was %s\",\n            e,\n        )\n        return []\n\n    # We want to return dNSName and iPAddress fields. We need to cast the IPs\n    # back to strings because the match_hostname function wants them as\n    # strings.\n    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8\n    # decoded. This is pretty frustrating, but that's what the standard library\n    # does with certificates, and so we need to attempt to do the same.\n    # We also want to skip over names which cannot be idna encoded.\n    names = [\n        (\"DNS\", name)\n        for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))\n        if name is not None\n    ]\n    names.extend(\n        (\"IP Address\", str(name)) for name in ext.get_values_for_type(x509.IPAddress)\n    )\n\n    return names\n\n\nclass WrappedSocket:\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\"\"\"\n\n    def __init__(\n        self,\n        connection: OpenSSL.SSL.Connection,\n        socket: socket_cls,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        self.connection = connection\n        self.socket = socket\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self._io_refs = 0\n        self._closed = False\n\n    def fileno(self) -> int:\n        return self.socket.fileno()\n\n    # Copy-pasted from Python 3.5 source code\n    def _decref_socketios(self) -> None:\n        if self._io_refs > 0:\n            self._io_refs -= 1\n        if self._closed:\n            self.close()\n\n    def recv(self, *args: typing.Any, **kwargs: typing.Any) -> bytes:\n        try:\n            data = self.connection.recv(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return b\"\"\n            else:\n                raise OSError(e.args[0], str(e)) from e\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return b\"\"\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError as e:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\") from e\n            else:\n                return self.recv(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"read error: {e!r}\") from e\n        else:\n            return data  # type: ignore[no-any-return]\n\n    def recv_into(self, *args: typing.Any, **kwargs: typing.Any) -> int:\n        try:\n            return self.connection.recv_into(*args, **kwargs)  # type: ignore[no-any-return]\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return 0\n            else:\n                raise OSError(e.args[0], str(e)) from e\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return 0\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError as e:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\") from e\n            else:\n                return self.recv_into(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"read error: {e!r}\") from e\n\n    def settimeout(self, timeout: float) -> None:\n        return self.socket.settimeout(timeout)\n\n    def _send_until_done(self, data: bytes) -> int:\n        while True:\n            try:\n                return self.connection.send(data)  # type: ignore[no-any-return]\n            except OpenSSL.SSL.WantWriteError as e:\n                if not util.wait_for_write(self.socket, self.socket.gettimeout()):\n                    raise timeout() from e\n                continue\n            except OpenSSL.SSL.SysCallError as e:\n                raise OSError(e.args[0], str(e)) from e\n\n    def sendall(self, data: bytes) -> None:\n        total_sent = 0\n        while total_sent < len(data):\n            sent = self._send_until_done(\n                data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE]\n            )\n            total_sent += sent\n\n    def shutdown(self) -> None:\n        # FIXME rethrow compatible exceptions should we ever use this\n        self.connection.shutdown()\n\n    def close(self) -> None:\n        self._closed = True\n        if self._io_refs <= 0:\n            self._real_close()\n\n    def _real_close(self) -> None:\n        try:\n            return self.connection.close()  # type: ignore[no-any-return]\n        except OpenSSL.SSL.Error:\n            return\n\n    def getpeercert(\n        self, binary_form: bool = False\n    ) -> dict[str, list[typing.Any]] | None:\n        x509 = self.connection.get_peer_certificate()\n\n        if not x509:\n            return x509  # type: ignore[no-any-return]\n\n        if binary_form:\n            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)  # type: ignore[no-any-return]\n\n        return {\n            \"subject\": (((\"commonName\", x509.get_subject().CN),),),  # type: ignore[dict-item]\n            \"subjectAltName\": get_subj_alt_name(x509),\n        }\n\n    def version(self) -> str:\n        return self.connection.get_protocol_version_name()  # type: ignore[no-any-return]\n\n\nWrappedSocket.makefile = socket_cls.makefile  # type: ignore[attr-defined]\n\n\nclass PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0\n        self.check_hostname = False\n        self._minimum_version: int = ssl.TLSVersion.MINIMUM_SUPPORTED\n        self._maximum_version: int = ssl.TLSVersion.MAXIMUM_SUPPORTED\n\n    @property\n    def options(self) -> int:\n        return self._options\n\n    @options.setter\n    def options(self, value: int) -> None:\n        self._options = value\n        self._set_ctx_options()\n\n    @property\n    def verify_mode(self) -> int:\n        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]\n\n    @verify_mode.setter\n    def verify_mode(self, value: ssl.VerifyMode) -> None:\n        self._ctx.set_verify(_stdlib_to_openssl_verify[value], _verify_callback)\n\n    def set_default_verify_paths(self) -> None:\n        self._ctx.set_default_verify_paths()\n\n    def set_ciphers(self, ciphers: bytes | str) -> None:\n        if isinstance(ciphers, str):\n            ciphers = ciphers.encode(\"utf-8\")\n        self._ctx.set_cipher_list(ciphers)\n\n    def load_verify_locations(\n        self,\n        cafile: str | None = None,\n        capath: str | None = None,\n        cadata: bytes | None = None,\n    ) -> None:\n        if cafile is not None:\n            cafile = cafile.encode(\"utf-8\")  # type: ignore[assignment]\n        if capath is not None:\n            capath = capath.encode(\"utf-8\")  # type: ignore[assignment]\n        try:\n            self._ctx.load_verify_locations(cafile, capath)\n            if cadata is not None:\n                self._ctx.load_verify_locations(BytesIO(cadata))\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"unable to load trusted certificates: {e!r}\") from e\n\n    def load_cert_chain(\n        self,\n        certfile: str,\n        keyfile: str | None = None,\n        password: str | None = None,\n    ) -> None:\n        try:\n            self._ctx.use_certificate_chain_file(certfile)\n            if password is not None:\n                if not isinstance(password, bytes):\n                    password = password.encode(\"utf-8\")  # type: ignore[assignment]\n                self._ctx.set_passwd_cb(lambda *_: password)\n            self._ctx.use_privatekey_file(keyfile or certfile)\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"Unable to load certificate chain: {e!r}\") from e\n\n    def set_alpn_protocols(self, protocols: list[bytes | str]) -> None:\n        protocols = [util.util.to_bytes(p, \"ascii\") for p in protocols]\n        return self._ctx.set_alpn_protos(protocols)  # type: ignore[no-any-return]\n\n    def wrap_socket(\n        self,\n        sock: socket_cls,\n        server_side: bool = False,\n        do_handshake_on_connect: bool = True,\n        suppress_ragged_eofs: bool = True,\n        server_hostname: bytes | str | None = None,\n    ) -> WrappedSocket:\n        cnx = OpenSSL.SSL.Connection(self._ctx, sock)\n\n        # If server_hostname is an IP, don't use it for SNI, per RFC6066 Section 3\n        if server_hostname and not util.ssl_.is_ipaddress(server_hostname):\n            if isinstance(server_hostname, str):\n                server_hostname = server_hostname.encode(\"utf-8\")\n            cnx.set_tlsext_host_name(server_hostname)\n\n        cnx.set_connect_state()\n\n        while True:\n            try:\n                cnx.do_handshake()\n            except OpenSSL.SSL.WantReadError as e:\n                if not util.wait_for_read(sock, sock.gettimeout()):\n                    raise timeout(\"select timed out\") from e\n                continue\n            except OpenSSL.SSL.Error as e:\n                raise ssl.SSLError(f\"bad handshake: {e!r}\") from e\n            break\n\n        return WrappedSocket(cnx, sock)\n\n    def _set_ctx_options(self) -> None:\n        self._ctx.set_options(\n            self._options\n            | _openssl_to_ssl_minimum_version[self._minimum_version]\n            | _openssl_to_ssl_maximum_version[self._maximum_version]\n        )\n\n    @property\n    def minimum_version(self) -> int:\n        return self._minimum_version\n\n    @minimum_version.setter\n    def minimum_version(self, minimum_version: int) -> None:\n        self._minimum_version = minimum_version\n        self._set_ctx_options()\n\n    @property\n    def maximum_version(self) -> int:\n        return self._maximum_version\n\n    @maximum_version.setter\n    def maximum_version(self, maximum_version: int) -> None:\n        self._maximum_version = maximum_version\n        self._set_ctx_options()\n\n\ndef _verify_callback(\n    cnx: OpenSSL.SSL.Connection,\n    x509: X509,\n    err_no: int,\n    err_depth: int,\n    return_code: int,\n) -> bool:\n    return err_no == 0\n", "src/urllib3/contrib/emscripten/response.py": "from __future__ import annotations\n\nimport json as _json\nimport logging\nimport typing\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom http.client import HTTPException as HTTPException\nfrom io import BytesIO, IOBase\n\nfrom ...exceptions import InvalidHeader, TimeoutError\nfrom ...response import BaseHTTPResponse\nfrom ...util.retry import Retry\nfrom .request import EmscriptenRequest\n\nif typing.TYPE_CHECKING:\n    from ..._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\nlog = logging.getLogger(__name__)\n\n\n@dataclass\nclass EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\n\n\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,\n        connection: BaseHTTPConnection | BaseHTTPSConnection | None = None,\n    ):\n        self._pool = None  # set by pool class\n        self._body = None\n        self._response = internal_response\n        self._url = url\n        self._connection = connection\n        self._closed = False\n        super().__init__(\n            headers=internal_response.headers,\n            status=internal_response.status_code,\n            request_url=url,\n            version=0,\n            version_string=\"HTTP/?\",\n            reason=\"\",\n            decode_content=True,\n        )\n        self.length_remaining = self._init_length(self._response.request.method)\n        self.length_is_certain = False\n\n    @property\n    def url(self) -> str | None:\n        return self._url\n\n    @url.setter\n    def url(self, url: str | None) -> None:\n        self._url = url\n\n    @property\n    def connection(self) -> BaseHTTPConnection | BaseHTTPSConnection | None:\n        return self._connection\n\n    @property\n    def retries(self) -> Retry | None:\n        return self._retries\n\n    @retries.setter\n    def retries(self, retries: Retry | None) -> None:\n        # Override the request_url if retries has a redirect location.\n        self._retries = retries\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        while True:\n            data = self.read(amt=amt, decode_content=decode_content)\n\n            if data:\n                yield data\n            else:\n                break\n\n    def _init_length(self, request_method: str | None) -> int | None:\n        length: int | None\n        content_length: str | None = self.headers.get(\"content-length\")\n\n        if content_length is not None:\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = {int(val) for val in content_length.split(\",\")}\n                if len(lengths) > 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % content_length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length < 0:\n                    length = None\n\n        else:  # if content_length is None\n            length = None\n\n        # Check for responses that shouldn't include a body\n        if (\n            self.status in (204, 304)\n            or 100 <= self.status < 200\n            or request_method == \"HEAD\"\n        ):\n            length = 0\n\n        return length\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,  # ignored because browser decodes always\n        cache_content: bool = False,\n    ) -> bytes:\n        if (\n            self._closed\n            or self._response is None\n            or (isinstance(self._response.body, IOBase) and self._response.body.closed)\n        ):\n            return b\"\"\n\n        with self._error_catcher():\n            # body has been preloaded as a string by XmlHttpRequest\n            if not isinstance(self._response.body, IOBase):\n                self.length_remaining = len(self._response.body)\n                self.length_is_certain = True\n                # wrap body in IOStream\n                self._response.body = BytesIO(self._response.body)\n            if amt is not None and amt >= 0:\n                # don't cache partial content\n                cache_content = False\n                data = self._response.body.read(amt)\n                if self.length_remaining is not None:\n                    self.length_remaining = max(self.length_remaining - len(data), 0)\n                if (self.length_is_certain and self.length_remaining == 0) or len(\n                    data\n                ) < amt:\n                    # definitely finished reading, close response stream\n                    self._response.body.close()\n                return typing.cast(bytes, data)\n            else:  # read all we can (and cache it)\n                data = self._response.body.read()\n                if cache_content:\n                    self._body = data\n                if self.length_remaining is not None:\n                    self.length_remaining = max(self.length_remaining - len(data), 0)\n                if len(data) == 0 or (\n                    self.length_is_certain and self.length_remaining == 0\n                ):\n                    # definitely finished reading, close response stream\n                    self._response.body.close()\n                return typing.cast(bytes, data)\n\n    def read_chunked(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> typing.Generator[bytes, None, None]:\n        # chunked is handled by browser\n        while True:\n            bytes = self.read(amt, decode_content)\n            if not bytes:\n                break\n            yield bytes\n\n    def release_conn(self) -> None:\n        if not self._pool or not self._connection:\n            return None\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self) -> None:\n        self.close()\n\n    @property\n    def data(self) -> bytes:\n        if self._body:\n            return self._body\n        else:\n            return self.read(cache_content=True)\n\n    def json(self) -> typing.Any:\n        \"\"\"\n        Deserializes the body of the HTTP response as a Python object.\n\n        The body of the HTTP response must be encoded using UTF-8, as per\n        `RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\n        To use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\n        your custom decoder instead.\n\n        If the body of the HTTP response is not decodable to UTF-8, a\n        `UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\n        valid JSON document, a `json.JSONDecodeError` will be raised.\n\n        Read more :ref:`here <json_content>`.\n\n        :returns: The body of the HTTP response as a Python object.\n        \"\"\"\n        data = self.data.decode(\"utf-8\")\n        return _json.loads(data)\n\n    def close(self) -> None:\n        if not self._closed:\n            if isinstance(self._response.body, IOBase):\n                self._response.body.close()\n            if self._connection:\n                self._connection.close()\n                self._connection = None\n            self._closed = True\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch Emscripten specific exceptions thrown by fetch.py,\n        instead re-raising urllib3 variants, so that low-level exceptions\n        are not leaked in the high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        from .fetch import _RequestError, _TimeoutError  # avoid circular import\n\n        clean_exit = False\n\n        try:\n            yield\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        except _TimeoutError as e:\n            raise TimeoutError(str(e))\n        except _RequestError as e:\n            raise HTTPException(str(e))\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now\n                if (\n                    isinstance(self._response.body, IOBase)\n                    and not self._response.body.closed\n                ):\n                    self._response.body.close()\n                # release the connection back to the pool\n                self.release_conn()\n            else:\n                # If we have read everything from the response stream,\n                # return the connection back to the pool.\n                if (\n                    isinstance(self._response.body, IOBase)\n                    and self._response.body.closed\n                ):\n                    self.release_conn()\n", "src/urllib3/contrib/emscripten/fetch.py": "\"\"\"\nSupport for streaming http requests in emscripten.\n\nA few caveats -\n\nFirstly, you can't do streaming http in the main UI thread, because atomics.wait isn't allowed.\nStreaming only works if you're running pyodide in a web worker.\n\nSecondly, this uses an extra web worker and SharedArrayBuffer to do the asynchronous fetch\noperation, so it requires that you have crossOriginIsolation enabled, by serving over https\n(or from localhost) with the two headers below set:\n\n    Cross-Origin-Opener-Policy: same-origin\n    Cross-Origin-Embedder-Policy: require-corp\n\nYou can tell if cross origin isolation is successfully enabled by looking at the global crossOriginIsolated variable in\njavascript console. If it isn't, streaming requests will fallback to XMLHttpRequest, i.e. getting the whole\nrequest into a buffer and then returning it. it shows a warning in the javascript console in this case.\n\nFinally, the webworker which does the streaming fetch is created on initial import, but will only be started once\ncontrol is returned to javascript. Call `await wait_for_streaming_ready()` to wait for streaming fetch.\n\nNB: in this code, there are a lot of javascript objects. They are named js_*\nto make it clear what type of object they are.\n\"\"\"\nfrom __future__ import annotations\n\nimport io\nimport json\nfrom email.parser import Parser\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING, Any\n\nimport js  # type: ignore[import-not-found]\nfrom pyodide.ffi import (  # type: ignore[import-not-found]\n    JsArray,\n    JsException,\n    JsProxy,\n    to_js,\n)\n\nif TYPE_CHECKING:\n    from typing_extensions import Buffer\n\nfrom .request import EmscriptenRequest\nfrom .response import EmscriptenResponse\n\n\"\"\"\nThere are some headers that trigger unintended CORS preflight requests.\nSee also https://github.com/koenvo/pyodide-http/issues/22\n\"\"\"\nHEADERS_TO_IGNORE = (\"user-agent\",)\n\nSUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\n\n_STREAMING_WORKER_CODE = (\n    files(__package__)\n    .joinpath(\"emscripten_fetch_worker.js\")\n    .read_text(encoding=\"utf-8\")\n)\n\n\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request\n        self.response = response\n        self.message = message\n        super().__init__(self.message)\n\n\nclass _StreamingError(_RequestError):\n    pass\n\n\nclass _TimeoutError(_RequestError):\n    pass\n\n\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\n\n\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,\n        worker: JsProxy,\n        connection_id: int,\n        request: EmscriptenRequest,\n    ):\n        self.int_buffer = int_buffer\n        self.byte_buffer = byte_buffer\n        self.read_pos = 0\n        self.read_len = 0\n        self.connection_id = connection_id\n        self.worker = worker\n        self.timeout = int(1000 * timeout) if timeout > 0 else None\n        self.is_live = True\n        self._is_closed = False\n        self.request: EmscriptenRequest | None = request\n\n    def __del__(self) -> None:\n        self.close()\n\n    # this is compatible with _base_connection\n    def is_closed(self) -> bool:\n        return self._is_closed\n\n    # for compatibility with RawIOBase\n    @property\n    def closed(self) -> bool:\n        return self.is_closed()\n\n    def close(self) -> None:\n        if not self.is_closed():\n            self.read_len = 0\n            self.read_pos = 0\n            self.int_buffer = None\n            self.byte_buffer = None\n            self._is_closed = True\n            self.request = None\n            if self.is_live:\n                self.worker.postMessage(_obj_from_dict({\"close\": self.connection_id}))\n                self.is_live = False\n            super().close()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def seekable(self) -> bool:\n        return False\n\n    def readinto(self, byte_obj: Buffer) -> int:\n        if not self.int_buffer:\n            raise _StreamingError(\n                \"No buffer for stream in _ReadStream.readinto\",\n                request=self.request,\n                response=None,\n            )\n        if self.read_len == 0:\n            # wait for the worker to send something\n            js.Atomics.store(self.int_buffer, 0, ERROR_TIMEOUT)\n            self.worker.postMessage(_obj_from_dict({\"getMore\": self.connection_id}))\n            if (\n                js.Atomics.wait(self.int_buffer, 0, ERROR_TIMEOUT, self.timeout)\n                == \"timed-out\"\n            ):\n                raise _TimeoutError\n            data_len = self.int_buffer[0]\n            if data_len > 0:\n                self.read_len = data_len\n                self.read_pos = 0\n            elif data_len == ERROR_EXCEPTION:\n                string_len = self.int_buffer[1]\n                # decode the error string\n                js_decoder = js.TextDecoder.new()\n                json_str = js_decoder.decode(self.byte_buffer.slice(0, string_len))\n                raise _StreamingError(\n                    f\"Exception thrown in fetch: {json_str}\",\n                    request=self.request,\n                    response=None,\n                )\n            else:\n                # EOF, free the buffers and return zero\n                # and free the request\n                self.is_live = False\n                self.close()\n                return 0\n        # copy from int32array to python bytes\n        ret_length = min(self.read_len, len(memoryview(byte_obj)))\n        subarray = self.byte_buffer.subarray(\n            self.read_pos, self.read_pos + ret_length\n        ).to_py()\n        memoryview(byte_obj)[0:ret_length] = subarray\n        self.read_len -= ret_length\n        self.read_pos += ret_length\n        return ret_length\n\n\nclass _StreamingFetcher:\n    def __init__(self) -> None:\n        # make web-worker and data buffer on startup\n        self.streaming_ready = False\n\n        js_data_blob = js.Blob.new(\n            [_STREAMING_WORKER_CODE], _obj_from_dict({\"type\": \"application/javascript\"})\n        )\n\n        def promise_resolver(js_resolve_fn: JsProxy, js_reject_fn: JsProxy) -> None:\n            def onMsg(e: JsProxy) -> None:\n                self.streaming_ready = True\n                js_resolve_fn(e)\n\n            def onErr(e: JsProxy) -> None:\n                js_reject_fn(e)  # Defensive: never happens in ci\n\n            self.js_worker.onmessage = onMsg\n            self.js_worker.onerror = onErr\n\n        js_data_url = js.URL.createObjectURL(js_data_blob)\n        self.js_worker = js.globalThis.Worker.new(js_data_url)\n        self.js_worker_ready_promise = js.globalThis.Promise.new(promise_resolver)\n\n    def send(self, request: EmscriptenRequest) -> EmscriptenResponse:\n        headers = {\n            k: v for k, v in request.headers.items() if k not in HEADERS_TO_IGNORE\n        }\n\n        body = request.body\n        fetch_data = {\"headers\": headers, \"body\": to_js(body), \"method\": request.method}\n        # start the request off in the worker\n        timeout = int(1000 * request.timeout) if request.timeout > 0 else None\n        js_shared_buffer = js.SharedArrayBuffer.new(1048576)\n        js_int_buffer = js.Int32Array.new(js_shared_buffer)\n        js_byte_buffer = js.Uint8Array.new(js_shared_buffer, 8)\n\n        js.Atomics.store(js_int_buffer, 0, ERROR_TIMEOUT)\n        js.Atomics.notify(js_int_buffer, 0)\n        js_absolute_url = js.URL.new(request.url, js.location).href\n        self.js_worker.postMessage(\n            _obj_from_dict(\n                {\n                    \"buffer\": js_shared_buffer,\n                    \"url\": js_absolute_url,\n                    \"fetchParams\": fetch_data,\n                }\n            )\n        )\n        # wait for the worker to send something\n        js.Atomics.wait(js_int_buffer, 0, ERROR_TIMEOUT, timeout)\n        if js_int_buffer[0] == ERROR_TIMEOUT:\n            raise _TimeoutError(\n                \"Timeout connecting to streaming request\",\n                request=request,\n                response=None,\n            )\n        elif js_int_buffer[0] == SUCCESS_HEADER:\n            # got response\n            # header length is in second int of intBuffer\n            string_len = js_int_buffer[1]\n            # decode the rest to a JSON string\n            js_decoder = js.TextDecoder.new()\n            # this does a copy (the slice) because decode can't work on shared array\n            # for some silly reason\n            json_str = js_decoder.decode(js_byte_buffer.slice(0, string_len))\n            # get it as an object\n            response_obj = json.loads(json_str)\n            return EmscriptenResponse(\n                request=request,\n                status_code=response_obj[\"status\"],\n                headers=response_obj[\"headers\"],\n                body=_ReadStream(\n                    js_int_buffer,\n                    js_byte_buffer,\n                    request.timeout,\n                    self.js_worker,\n                    response_obj[\"connectionID\"],\n                    request,\n                ),\n            )\n        elif js_int_buffer[0] == ERROR_EXCEPTION:\n            string_len = js_int_buffer[1]\n            # decode the error string\n            js_decoder = js.TextDecoder.new()\n            json_str = js_decoder.decode(js_byte_buffer.slice(0, string_len))\n            raise _StreamingError(\n                f\"Exception thrown in fetch: {json_str}\", request=request, response=None\n            )\n        else:\n            raise _StreamingError(\n                f\"Unknown status from worker in fetch: {js_int_buffer[0]}\",\n                request=request,\n                response=None,\n            )\n\n\n# check if we are in a worker or not\ndef is_in_browser_main_thread() -> bool:\n    return hasattr(js, \"window\") and hasattr(js, \"self\") and js.self == js.window\n\n\ndef is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\n\n\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\n\n\ndef is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n\n\n_fetcher: _StreamingFetcher | None = None\n\nif is_worker_available() and (\n    (is_cross_origin_isolated() and not is_in_browser_main_thread())\n    and (not is_in_node())\n):\n    _fetcher = _StreamingFetcher()\nelse:\n    _fetcher = None\n\n\ndef send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if _fetcher and streaming_ready():\n        return _fetcher.send(request)\n    else:\n        _show_streaming_warning()\n        return None\n\n\n_SHOWN_TIMEOUT_WARNING = False\n\n\ndef _show_timeout_warning() -> None:\n    global _SHOWN_TIMEOUT_WARNING\n    if not _SHOWN_TIMEOUT_WARNING:\n        _SHOWN_TIMEOUT_WARNING = True\n        message = \"Warning: Timeout is not available on main browser thread\"\n        js.console.warn(message)\n\n\n_SHOWN_STREAMING_WARNING = False\n\n\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING\n    if not _SHOWN_STREAMING_WARNING:\n        _SHOWN_STREAMING_WARNING = True\n        message = \"Can't stream HTTP requests because: \\n\"\n        if not is_cross_origin_isolated():\n            message += \"  Page is not cross-origin isolated\\n\"\n        if is_in_browser_main_thread():\n            message += \"  Python is running in main browser thread\\n\"\n        if not is_worker_available():\n            message += \" Worker or Blob classes are not available in this environment.\"  # Defensive: this is always False in browsers that we test in\n        if streaming_ready() is False:\n            message += \"\"\" Streaming fetch worker isn't ready. If you want to be sure that streaming fetch\nis working, you need to call: 'await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()`\"\"\"\n        from js import console\n\n        console.warn(message)\n\n\ndef send_request(request: EmscriptenRequest) -> EmscriptenResponse:\n    try:\n        js_xhr = js.XMLHttpRequest.new()\n\n        if not is_in_browser_main_thread():\n            js_xhr.responseType = \"arraybuffer\"\n            if request.timeout:\n                js_xhr.timeout = int(request.timeout * 1000)\n        else:\n            js_xhr.overrideMimeType(\"text/plain; charset=ISO-8859-15\")\n            if request.timeout:\n                # timeout isn't available on the main thread - show a warning in console\n                # if it is set\n                _show_timeout_warning()\n\n        js_xhr.open(request.method, request.url, False)\n        for name, value in request.headers.items():\n            if name.lower() not in HEADERS_TO_IGNORE:\n                js_xhr.setRequestHeader(name, value)\n\n        js_xhr.send(to_js(request.body))\n\n        headers = dict(Parser().parsestr(js_xhr.getAllResponseHeaders()))\n\n        if not is_in_browser_main_thread():\n            body = js_xhr.response.to_py().tobytes()\n        else:\n            body = js_xhr.response.encode(\"ISO-8859-15\")\n        return EmscriptenResponse(\n            status_code=js_xhr.status, headers=headers, body=body, request=request\n        )\n    except JsException as err:\n        if err.name == \"TimeoutError\":\n            raise _TimeoutError(err.message, request=request)\n        elif err.name == \"NetworkError\":\n            raise _RequestError(err.message, request=request)\n        else:\n            # general http error\n            raise _RequestError(err.message, request=request)\n\n\ndef streaming_ready() -> bool | None:\n    if _fetcher:\n        return _fetcher.streaming_ready\n    else:\n        return None  # no fetcher, return None to signify that\n\n\nasync def wait_for_streaming_ready() -> bool:\n    if _fetcher:\n        await _fetcher.js_worker_ready_promise\n        return True\n    else:\n        return False\n", "src/urllib3/contrib/emscripten/connection.py": "from __future__ import annotations\n\nimport os\nimport typing\n\n# use http.client.HTTPException for consistency with non-emscripten\nfrom http.client import HTTPException as HTTPException  # noqa: F401\nfrom http.client import ResponseNotReady\n\nfrom ..._base_connection import _TYPE_BODY\nfrom ...connection import HTTPConnection, ProxyConfig, port_by_scheme\nfrom ...exceptions import TimeoutError\nfrom ...response import BaseHTTPResponse\nfrom ...util.connection import _TYPE_SOCKET_OPTIONS\nfrom ...util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\nfrom ...util.url import Url\nfrom .fetch import _RequestError, _TimeoutError, send_request, send_streaming_request\nfrom .request import EmscriptenRequest\nfrom .response import EmscriptenHttpResponseWrapper, EmscriptenResponse\n\nif typing.TYPE_CHECKING:\n    from ..._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\n\nclass EmscriptenHTTPConnection:\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n    timeout: None | (float)\n\n    host: str\n    port: int\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: _TYPE_SOCKET_OPTIONS | None\n\n    proxy: Url | None\n    proxy_config: ProxyConfig | None\n\n    is_verified: bool = False\n    proxy_is_verified: bool | None = None\n\n    _response: EmscriptenResponse | None\n\n    def __init__(\n        self,\n        host: str,\n        port: int = 0,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 8192,\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n    ) -> None:\n        self.host = host\n        self.port = port\n        self.timeout = timeout if isinstance(timeout, float) else 0.0\n        self.scheme = \"http\"\n        self._closed = True\n        self._response = None\n        # ignore these things because we don't\n        # have control over that stuff\n        self.proxy = None\n        self.proxy_config = None\n        self.blocksize = blocksize\n        self.source_address = None\n        self.socket_options = None\n        self.is_verified = False\n\n    def set_tunnel(\n        self,\n        host: str,\n        port: int | None = 0,\n        headers: typing.Mapping[str, str] | None = None,\n        scheme: str = \"http\",\n    ) -> None:\n        pass\n\n    def connect(self) -> None:\n        pass\n\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        # We know *at least* botocore is depending on the order of the\n        # first 3 parameters so to be safe we only mark the later ones\n        # as keyword-only to ensure we have space to extend.\n        *,\n        chunked: bool = False,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> None:\n        self._closed = False\n        if url.startswith(\"/\"):\n            # no scheme / host / port included, make a full url\n            url = f\"{self.scheme}://{self.host}:{self.port}\" + url\n        request = EmscriptenRequest(\n            url=url,\n            method=method,\n            timeout=self.timeout if self.timeout else 0,\n            decode_content=decode_content,\n        )\n        request.set_body(body)\n        if headers:\n            for k, v in headers.items():\n                request.set_header(k, v)\n        self._response = None\n        try:\n            if not preload_content:\n                self._response = send_streaming_request(request)\n            if self._response is None:\n                self._response = send_request(request)\n        except _TimeoutError as e:\n            raise TimeoutError(e.message) from e\n        except _RequestError as e:\n            raise HTTPException(e.message) from e\n\n    def getresponse(self) -> BaseHTTPResponse:\n        if self._response is not None:\n            return EmscriptenHttpResponseWrapper(\n                internal_response=self._response,\n                url=self._response.request.url,\n                connection=self,\n            )\n        else:\n            raise ResponseNotReady()\n\n    def close(self) -> None:\n        self._closed = True\n        self._response = None\n\n    @property\n    def is_closed(self) -> bool:\n        \"\"\"Whether the connection either is brand new or has been previously closed.\n        If this property is True then both ``is_connected`` and ``has_connected_to_proxy``\n        properties must be False.\n        \"\"\"\n        return self._closed\n\n    @property\n    def is_connected(self) -> bool:\n        \"\"\"Whether the connection is actively connected to any origin (proxy or target)\"\"\"\n        return True\n\n    @property\n    def has_connected_to_proxy(self) -> bool:\n        \"\"\"Whether the connection has successfully connected to its proxy.\n        This returns False if no proxy is in use. Used to determine whether\n        errors are coming from the proxy layer or from tunnelling to the target origin.\n        \"\"\"\n        return False\n\n\nclass EmscriptenHTTPSConnection(EmscriptenHTTPConnection):\n    default_port = port_by_scheme[\"https\"]\n    # all this is basically ignored, as browser handles https\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    cert_file: str | None\n    key_file: str | None\n    key_password: str | None\n    ssl_context: typing.Any | None\n    ssl_version: int | str | None = None\n    ssl_minimum_version: int | None = None\n    ssl_maximum_version: int | None = None\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None = None\n\n    def __init__(\n        self,\n        host: str,\n        port: int = 0,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | _TYPE_SOCKET_OPTIONS = HTTPConnection.default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n        cert_reqs: int | str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        server_hostname: str | None = None,\n        ssl_context: typing.Any | None = None,\n        ca_certs: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n        ssl_minimum_version: int | None = None,\n        ssl_maximum_version: int | None = None,\n        ssl_version: int | str | None = None,  # Deprecated\n        cert_file: str | None = None,\n        key_file: str | None = None,\n        key_password: str | None = None,\n    ) -> None:\n        super().__init__(\n            host,\n            port=port,\n            timeout=timeout,\n            source_address=source_address,\n            blocksize=blocksize,\n            socket_options=socket_options,\n            proxy=proxy,\n            proxy_config=proxy_config,\n        )\n        self.scheme = \"https\"\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.key_password = key_password\n        self.ssl_context = ssl_context\n        self.server_hostname = server_hostname\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n        self.cert_reqs = None\n\n        # The browser will automatically verify all requests.\n        # We have no control over that setting.\n        self.is_verified = True\n\n    def set_cert(\n        self,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n    ) -> None:\n        pass\n\n\n# verify that this class implements BaseHTTP(s) connection correctly\nif typing.TYPE_CHECKING:\n    _supports_http_protocol: BaseHTTPConnection = EmscriptenHTTPConnection(\"\", 0)\n    _supports_https_protocol: BaseHTTPSConnection = EmscriptenHTTPSConnection(\"\", 0)\n", "src/urllib3/contrib/emscripten/request.py": "from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nfrom ..._base_connection import _TYPE_BODY\n\n\n@dataclass\nclass EmscriptenRequest:\n    method: str\n    url: str\n    params: dict[str, str] | None = None\n    body: _TYPE_BODY | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    timeout: float = 0\n    decode_content: bool = True\n\n    def set_header(self, name: str, value: str) -> None:\n        self.headers[name.capitalize()] = value\n\n    def set_body(self, body: _TYPE_BODY | None) -> None:\n        self.body = body\n", "src/urllib3/contrib/emscripten/__init__.py": "from __future__ import annotations\n\nimport urllib3.connection\n\nfrom ...connectionpool import HTTPConnectionPool, HTTPSConnectionPool\nfrom .connection import EmscriptenHTTPConnection, EmscriptenHTTPSConnection\n\n\ndef inject_into_urllib3() -> None:\n    # override connection classes to use emscripten specific classes\n    # n.b. mypy complains about the overriding of classes below\n    # if it isn't ignored\n    HTTPConnectionPool.ConnectionCls = EmscriptenHTTPConnection\n    HTTPSConnectionPool.ConnectionCls = EmscriptenHTTPSConnection\n    urllib3.connection.HTTPConnection = EmscriptenHTTPConnection  # type: ignore[misc,assignment]\n    urllib3.connection.HTTPSConnection = EmscriptenHTTPSConnection  # type: ignore[misc,assignment]\n", "src/urllib3/util/response.py": "from __future__ import annotations\n\nimport http.client as httplib\nfrom email.errors import MultipartInvariantViolationDefect, StartBoundaryNotFoundDefect\n\nfrom ..exceptions import HeaderParsingError\n\n\ndef is_fp_closed(obj: object) -> bool:\n    \"\"\"\n    Checks whether a given file-like object is closed.\n\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()  # type: ignore[no-any-return, attr-defined]\n    except AttributeError:\n        pass\n\n    try:\n        # Check via the official file-like-object way.\n        return obj.closed  # type: ignore[no-any-return, attr-defined]\n    except AttributeError:\n        pass\n\n    try:\n        # Check if the object is a container for another file-like object that\n        # gets released on exhaustion (e.g. HTTPResponse).\n        return obj.fp is None  # type: ignore[attr-defined]\n    except AttributeError:\n        pass\n\n    raise ValueError(\"Unable to determine whether fp is closed.\")\n\n\ndef assert_header_parsing(headers: httplib.HTTPMessage) -> None:\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n\n    Only works on Python 3.\n\n    :param http.client.HTTPMessage headers: Headers to verify.\n\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n\n    # This will fail silently if we pass in the wrong kind of parameter.\n    # To make debugging easier add an explicit check.\n    if not isinstance(headers, httplib.HTTPMessage):\n        raise TypeError(f\"expected httplib.Message, got {type(headers)}.\")\n\n    unparsed_data = None\n\n    # get_payload is actually email.message.Message.get_payload;\n    # we're only interested in the result if it's not a multipart message\n    if not headers.is_multipart():\n        payload = headers.get_payload()\n\n        if isinstance(payload, (bytes, str)):\n            unparsed_data = payload\n\n    # httplib is assuming a response body is available\n    # when parsing headers even when httplib only sends\n    # header data to parse_headers() This results in\n    # defects on multipart responses in particular.\n    # See: https://github.com/urllib3/urllib3/issues/800\n\n    # So we ignore the following defects:\n    # - StartBoundaryNotFoundDefect:\n    #     The claimed start boundary was never found.\n    # - MultipartInvariantViolationDefect:\n    #     A message claimed to be a multipart but no subparts were found.\n    defects = [\n        defect\n        for defect in headers.defects\n        if not isinstance(\n            defect, (StartBoundaryNotFoundDefect, MultipartInvariantViolationDefect)\n        )\n    ]\n\n    if defects or unparsed_data:\n        raise HeaderParsingError(defects=defects, unparsed_data=unparsed_data)\n\n\ndef is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method_str = response._method  # type: str  # type: ignore[attr-defined]\n    return method_str.upper() == \"HEAD\"\n", "src/urllib3/util/connection.py": "from __future__ import annotations\n\nimport socket\nimport typing\n\nfrom ..exceptions import LocationParseError\nfrom .timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\n\n_TYPE_SOCKET_OPTIONS = typing.Sequence[typing.Tuple[int, int, typing.Union[int, bytes]]]\n\nif typing.TYPE_CHECKING:\n    from .._base_connection import BaseHTTPConnection\n\n\ndef is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n\n\n# This function is copied from socket.py in the Python 2.7 standard\n# library test suite. Added to its signature is only `socket_options`.\n# One additional modification is that we avoid binding to IPv6 servers\n# discovered in DNS if the system doesn't have IPv6 functionality.\ndef create_connection(\n    address: tuple[str, int],\n    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    source_address: tuple[str, int] | None = None,\n    socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n) -> socket.socket:\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`socket.getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n    \"\"\"\n\n    host, port = address\n    if host.startswith(\"[\"):\n        host = host.strip(\"[]\")\n    err = None\n\n    # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n    # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n    # The original create_connection function always returns all records.\n    family = allowed_gai_family()\n\n    try:\n        host.encode(\"idna\")\n    except UnicodeError:\n        raise LocationParseError(f\"'{host}', label empty or too long\") from None\n\n    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n\n            # If provided, set socket level options before connecting.\n            _set_socket_options(sock, socket_options)\n\n            if timeout is not _DEFAULT_TIMEOUT:\n                sock.settimeout(timeout)\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            # Break explicitly a reference cycle\n            err = None\n            return sock\n\n        except OSError as _:\n            err = _\n            if sock is not None:\n                sock.close()\n\n    if err is not None:\n        try:\n            raise err\n        finally:\n            # Break explicitly a reference cycle\n            err = None\n    else:\n        raise OSError(\"getaddrinfo returns an empty list\")\n\n\ndef _set_socket_options(\n    sock: socket.socket, options: _TYPE_SOCKET_OPTIONS | None\n) -> None:\n    if options is None:\n        return\n\n    for opt in options:\n        sock.setsockopt(*opt)\n\n\ndef allowed_gai_family() -> socket.AddressFamily:\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\n\n\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        # has_ipv6 returns true if cPython was compiled with IPv6 support.\n        # It does not tell us if the system has IPv6 support enabled. To\n        # determine that we must bind to an IPv6 address.\n        # https://github.com/urllib3/urllib3/pull/611\n        # https://bugs.python.org/issue658327\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = True\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6\n\n\nHAS_IPV6 = _has_ipv6(\"::1\")\n", "src/urllib3/util/retry.py": "from __future__ import annotations\n\nimport email\nimport logging\nimport random\nimport re\nimport time\nimport typing\nfrom itertools import takewhile\nfrom types import TracebackType\n\nfrom ..exceptions import (\n    ConnectTimeoutError,\n    InvalidHeader,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    ResponseError,\n)\nfrom .util import reraise\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from ..connectionpool import ConnectionPool\n    from ..response import BaseHTTPResponse\n\nlog = logging.getLogger(__name__)\n\n\n# Data structure for representing the metadata of requests that result in a retry.\nclass RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\n\n\nclass Retry:\n    \"\"\"Retry configuration.\n\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n\n    Retries can be defined as a default for a pool:\n\n    .. code-block:: python\n\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request(\"GET\", \"https://example.com/\")\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n        response = http.request(\"GET\", \"https://example.com/\", retries=Retry(10))\n\n    Retries can be disabled by passing ``False``:\n\n    .. code-block:: python\n\n        response = http.request(\"GET\", \"https://example.com/\", retries=False)\n\n    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\n    retries are disabled, in which case the causing exception will be raised.\n\n    :param int total:\n        Total number of retries to allow. Takes precedence over other counts.\n\n        Set to ``None`` to remove this constraint and fall back on other\n        counts.\n\n        Set to ``0`` to fail on the first retry.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int connect:\n        How many connection-related errors to retry on.\n\n        These are errors raised before the request is sent to the remote server,\n        which we assume has not triggered the server to process the request.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int read:\n        How many times to retry on read errors.\n\n        These errors are raised after the request was sent to the server, so the\n        request may have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int redirect:\n        How many redirects to perform. Limit this to avoid infinite redirect\n        loops.\n\n        A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n        308.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int status:\n        How many times to retry on bad status codes.\n\n        These are retries made on responses, where status code matches\n        ``status_forcelist``.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int other:\n        How many times to retry on other errors.\n\n        Other errors are errors that are not connect, read, redirect or status errors.\n        These errors might be raised after the request was sent to the server, so the\n        request might have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        If ``total`` is not set, it's a good idea to set this to 0 to account\n        for unexpected edge cases and avoid infinite retry loops.\n\n    :param Collection allowed_methods:\n        Set of uppercased HTTP method verbs that we should retry on.\n\n        By default, we only retry on methods which are considered to be\n        idempotent (multiple requests with the same parameters end with the\n        same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n        Set to a ``None`` value to retry on any verb.\n\n    :param Collection status_forcelist:\n        A set of integer HTTP status codes that we should force a retry on.\n        A retry is initiated if the request method is in ``allowed_methods``\n        and the response status code is in ``status_forcelist``.\n\n        By default, this is disabled with ``None``.\n\n    :param float backoff_factor:\n        A backoff factor to apply between attempts after the second try\n        (most errors are resolved immediately by a second try without a\n        delay). urllib3 will sleep for::\n\n            {backoff factor} * (2 ** ({number of previous retries}))\n\n        seconds. If `backoff_jitter` is non-zero, this sleep is extended by::\n\n            random.uniform(0, {backoff jitter})\n\n        seconds. For example, if the backoff_factor is 0.1, then :func:`Retry.sleep` will\n        sleep for [0.0s, 0.2s, 0.4s, 0.8s, ...] between retries. No backoff will ever\n        be longer than `backoff_max`.\n\n        By default, backoff is disabled (factor set to 0).\n\n    :param bool raise_on_redirect: Whether, if the number of redirects is\n        exhausted, to raise a MaxRetryError, or to return a response with a\n        response code in the 3xx range.\n\n    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n        whether we should raise an exception, or return a response,\n        if status falls in ``status_forcelist`` range and retries have\n        been exhausted.\n\n    :param tuple history: The history of the request encountered during\n        each call to :meth:`~Retry.increment`. The list is in the order\n        the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n    :param bool respect_retry_after_header:\n        Whether to respect Retry-After header on status codes defined as\n        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n    :param Collection remove_headers_on_redirect:\n        Sequence of headers to remove from the request when a response\n        indicating a redirect is returned before firing off the redirected\n        request.\n    \"\"\"\n\n    #: Default methods to be used for ``allowed_methods``\n    DEFAULT_ALLOWED_METHODS = frozenset(\n        [\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"]\n    )\n\n    #: Default status codes to be used for ``status_forcelist``\n    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])\n\n    #: Default headers to be used for ``remove_headers_on_redirect``\n    DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset(\n        [\"Cookie\", \"Authorization\", \"Proxy-Authorization\"]\n    )\n\n    #: Default maximum backoff time.\n    DEFAULT_BACKOFF_MAX = 120\n\n    # Backward compatibility; assigned outside of the class.\n    DEFAULT: typing.ClassVar[Retry]\n\n    def __init__(\n        self,\n        total: bool | int | None = 10,\n        connect: int | None = None,\n        read: int | None = None,\n        redirect: bool | int | None = None,\n        status: int | None = None,\n        other: int | None = None,\n        allowed_methods: typing.Collection[str] | None = DEFAULT_ALLOWED_METHODS,\n        status_forcelist: typing.Collection[int] | None = None,\n        backoff_factor: float = 0,\n        backoff_max: float = DEFAULT_BACKOFF_MAX,\n        raise_on_redirect: bool = True,\n        raise_on_status: bool = True,\n        history: tuple[RequestHistory, ...] | None = None,\n        respect_retry_after_header: bool = True,\n        remove_headers_on_redirect: typing.Collection[\n            str\n        ] = DEFAULT_REMOVE_HEADERS_ON_REDIRECT,\n        backoff_jitter: float = 0.0,\n    ) -> None:\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.status = status\n        self.other = other\n\n        if redirect is False or total is False:\n            redirect = 0\n            raise_on_redirect = False\n\n        self.redirect = redirect\n        self.status_forcelist = status_forcelist or set()\n        self.allowed_methods = allowed_methods\n        self.backoff_factor = backoff_factor\n        self.backoff_max = backoff_max\n        self.raise_on_redirect = raise_on_redirect\n        self.raise_on_status = raise_on_status\n        self.history = history or ()\n        self.respect_retry_after_header = respect_retry_after_header\n        self.remove_headers_on_redirect = frozenset(\n            h.lower() for h in remove_headers_on_redirect\n        )\n        self.backoff_jitter = backoff_jitter\n\n    def new(self, **kw: typing.Any) -> Self:\n        params = dict(\n            total=self.total,\n            connect=self.connect,\n            read=self.read,\n            redirect=self.redirect,\n            status=self.status,\n            other=self.other,\n            allowed_methods=self.allowed_methods,\n            status_forcelist=self.status_forcelist,\n            backoff_factor=self.backoff_factor,\n            backoff_max=self.backoff_max,\n            raise_on_redirect=self.raise_on_redirect,\n            raise_on_status=self.raise_on_status,\n            history=self.history,\n            remove_headers_on_redirect=self.remove_headers_on_redirect,\n            respect_retry_after_header=self.respect_retry_after_header,\n            backoff_jitter=self.backoff_jitter,\n        )\n\n        params.update(kw)\n        return type(self)(**params)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_int(\n        cls,\n        retries: Retry | bool | int | None,\n        redirect: bool | int | None = True,\n        default: Retry | bool | int | None = None,\n    ) -> Retry:\n        \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -> %r\", retries, new_retries)\n        return new_retries\n\n    def get_backoff_time(self) -> float:\n        \"\"\"Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        # We want to consider only the last consecutive errors sequence (Ignore redirects).\n        consecutive_errors_len = len(\n            list(\n                takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n            )\n        )\n        if consecutive_errors_len <= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n        if self.backoff_jitter != 0.0:\n            backoff_value += random.random() * self.backoff_jitter\n        return float(max(0, min(self.backoff_max, backoff_value)))\n\n    def parse_retry_after(self, retry_after: str) -> float:\n        seconds: float\n        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4\n        if re.match(r\"^\\s*[0-9]+\\s*$\", retry_after):\n            seconds = int(retry_after)\n        else:\n            retry_date_tuple = email.utils.parsedate_tz(retry_after)\n            if retry_date_tuple is None:\n                raise InvalidHeader(f\"Invalid Retry-After header: {retry_after}\")\n\n            retry_date = email.utils.mktime_tz(retry_date_tuple)\n            seconds = retry_date - time.time()\n\n        seconds = max(seconds, 0)\n\n        return seconds\n\n    def get_retry_after(self, response: BaseHTTPResponse) -> float | None:\n        \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n        retry_after = response.headers.get(\"Retry-After\")\n\n        if retry_after is None:\n            return None\n\n        return self.parse_retry_after(retry_after)\n\n    def sleep_for_retry(self, response: BaseHTTPResponse) -> bool:\n        retry_after = self.get_retry_after(response)\n        if retry_after:\n            time.sleep(retry_after)\n            return True\n\n        return False\n\n    def _sleep_backoff(self) -> None:\n        backoff = self.get_backoff_time()\n        if backoff <= 0:\n            return\n        time.sleep(backoff)\n\n    def sleep(self, response: BaseHTTPResponse | None = None) -> None:\n        \"\"\"Sleep between retry attempts.\n\n        This method will respect a server's ``Retry-After`` response header\n        and sleep the duration of the time requested. If that is not present, it\n        will use an exponential backoff. By default, the backoff factor is 0 and\n        this method will return immediately.\n        \"\"\"\n\n        if self.respect_retry_after_header and response:\n            slept = self.sleep_for_retry(response)\n            if slept:\n                return\n\n        self._sleep_backoff()\n\n    def _is_connection_error(self, err: Exception) -> bool:\n        \"\"\"Errors when we're fairly sure that the server did not receive the\n        request, so it should be safe to retry.\n        \"\"\"\n        if isinstance(err, ProxyError):\n            err = err.original_error\n        return isinstance(err, ConnectTimeoutError)\n\n    def _is_read_error(self, err: Exception) -> bool:\n        \"\"\"Errors that occur after the request has been started, so we should\n        assume that the server began processing it.\n        \"\"\"\n        return isinstance(err, (ReadTimeoutError, ProtocolError))\n\n    def _is_method_retryable(self, method: str) -> bool:\n        \"\"\"Checks if a given HTTP method should be retried upon, depending if\n        it is included in the allowed_methods\n        \"\"\"\n        if self.allowed_methods and method.upper() not in self.allowed_methods:\n            return False\n        return True\n\n    def is_retry(\n        self, method: str, status_code: int, has_retry_after: bool = False\n    ) -> bool:\n        \"\"\"Is this method/status code retryable? (Based on allowlists and control\n        variables such as the number of total retries to allow, whether to\n        respect the Retry-After header, whether this header is present, and\n        whether the returned status code is on the list of status codes to\n        be retried upon on the presence of the aforementioned header)\n        \"\"\"\n        if not self._is_method_retryable(method):\n            return False\n\n        if self.status_forcelist and status_code in self.status_forcelist:\n            return True\n\n        return bool(\n            self.total\n            and self.respect_retry_after_header\n            and has_retry_after\n            and (status_code in self.RETRY_AFTER_STATUS_CODES)\n        )\n\n    def is_exhausted(self) -> bool:\n        \"\"\"Are we out of retries?\"\"\"\n        retry_counts = [\n            x\n            for x in (\n                self.total,\n                self.connect,\n                self.read,\n                self.redirect,\n                self.status,\n                self.other,\n            )\n            if x\n        ]\n        if not retry_counts:\n            return False\n\n        return min(retry_counts) < 0\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n\n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n\n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n\n        total = self.total\n        if total is not None:\n            total -= 1\n\n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n\n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n\n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n\n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n\n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n\n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n\n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n\n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n\n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n            raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\n\n        log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n        return new_retry\n\n    def __repr__(self) -> str:\n        return (\n            f\"{type(self).__name__}(total={self.total}, connect={self.connect}, \"\n            f\"read={self.read}, redirect={self.redirect}, status={self.status})\"\n        )\n\n\n# For backwards compatibility (equivalent to pre-v1.9):\nRetry.DEFAULT = Retry(3)\n", "src/urllib3/util/wait.py": "from __future__ import annotations\n\nimport select\nimport socket\nfrom functools import partial\n\n__all__ = [\"wait_for_read\", \"wait_for_write\"]\n\n\n# How should we wait on sockets?\n#\n# There are two types of APIs you can use for waiting on sockets: the fancy\n# modern stateful APIs like epoll/kqueue, and the older stateless APIs like\n# select/poll. The stateful APIs are more efficient when you have a lots of\n# sockets to keep track of, because you can set them up once and then use them\n# lots of times. But we only ever want to wait on a single socket at a time\n# and don't want to keep track of state, so the stateless APIs are actually\n# more efficient. So we want to use select() or poll().\n#\n# Now, how do we choose between select() and poll()? On traditional Unixes,\n# select() has a strange calling convention that makes it slow, or fail\n# altogether, for high-numbered file descriptors. The point of poll() is to fix\n# that, so on Unixes, we prefer poll().\n#\n# On Windows, there is no poll() (or at least Python doesn't provide a wrapper\n# for it), but that's OK, because on Windows, select() doesn't have this\n# strange calling convention; plain select() works fine.\n#\n# So: on Windows we use select(), and everywhere else we use poll(). We also\n# fall back to select() in case poll() is somehow broken or missing.\n\n\ndef select_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    rcheck = []\n    wcheck = []\n    if read:\n        rcheck.append(sock)\n    if write:\n        wcheck.append(sock)\n    # When doing a non-blocking connect, most systems signal success by\n    # marking the socket writable. Windows, though, signals success by marked\n    # it as \"exceptional\". We paper over the difference by checking the write\n    # sockets for both conditions. (The stdlib selectors module does the same\n    # thing.)\n    fn = partial(select.select, rcheck, wcheck, wcheck)\n    rready, wready, xready = fn(timeout)\n    return bool(rready or wready or xready)\n\n\ndef poll_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    mask = 0\n    if read:\n        mask |= select.POLLIN\n    if write:\n        mask |= select.POLLOUT\n    poll_obj = select.poll()\n    poll_obj.register(sock, mask)\n\n    # For some reason, poll() takes timeout in milliseconds\n    def do_poll(t: float | None) -> list[tuple[int, int]]:\n        if t is not None:\n            t *= 1000\n        return poll_obj.poll(t)\n\n    return bool(do_poll(timeout))\n\n\ndef _have_working_poll() -> bool:\n    # Apparently some systems have a select.poll that fails as soon as you try\n    # to use it, either due to strange configuration or broken monkeypatching\n    # from libraries like eventlet/greenlet.\n    try:\n        poll_obj = select.poll()\n        poll_obj.poll(0)\n    except (AttributeError, OSError):\n        return False\n    else:\n        return True\n\n\ndef wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    # We delay choosing which implementation to use until the first time we're\n    # called. We could do it at import time, but then we might make the wrong\n    # decision if someone goes wild with monkeypatching select.poll after\n    # we're imported.\n    global wait_for_socket\n    if _have_working_poll():\n        wait_for_socket = poll_wait_for_socket\n    elif hasattr(select, \"select\"):\n        wait_for_socket = select_wait_for_socket\n    return wait_for_socket(sock, read, write, timeout)\n\n\ndef wait_for_read(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\n\n\ndef wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)\n", "src/urllib3/util/request.py": "from __future__ import annotations\n\nimport io\nimport typing\nfrom base64 import b64encode\nfrom enum import Enum\n\nfrom ..exceptions import UnrewindableBodyError\nfrom .util import to_bytes\n\nif typing.TYPE_CHECKING:\n    from typing import Final\n\n# Pass as a value within ``headers`` to skip\n# emitting some HTTP headers that are added automatically.\n# The only headers that are supported are ``Accept-Encoding``,\n# ``Host``, and ``User-Agent``.\nSKIP_HEADER = \"@@@SKIP_HEADER@@@\"\nSKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\n\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",br\"\ntry:\n    import zstandard as _unused_module_zstd  # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",zstd\"\n\n\nclass _TYPE_FAILEDTELL(Enum):\n    token = 0\n\n\n_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token\n\n_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\n\n\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.  If either the ``brotli`` or\n        ``brotlicffi`` package is installed 'gzip,deflate,br' is used instead.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    :param proxy_basic_auth:\n        Colon-separated username:password string for 'proxy-authorization: basic ...'\n        auth header.\n\n    :param disable_cache:\n        If ``True``, adds 'cache-control: no-cache' header.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        print(urllib3.util.make_headers(keep_alive=True, user_agent=\"Batman/1.0\"))\n        # {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        print(urllib3.util.make_headers(accept_encoding=True))\n        # {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers: dict[str, str] = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"accept-encoding\"] = accept_encoding\n\n    if user_agent:\n        headers[\"user-agent\"] = user_agent\n\n    if keep_alive:\n        headers[\"connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\n            \"authorization\"\n        ] = f\"Basic {b64encode(basic_auth.encode('latin-1')).decode()}\"\n\n    if proxy_basic_auth:\n        headers[\n            \"proxy-authorization\"\n        ] = f\"Basic {b64encode(proxy_basic_auth.encode('latin-1')).decode()}\"\n\n    if disable_cache:\n        headers[\"cache-control\"] = \"no-cache\"\n\n    return headers\n\n\ndef set_file_position(\n    body: typing.Any, pos: _TYPE_BODY_POSITION | None\n) -> _TYPE_BODY_POSITION | None:\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:\n        try:\n            pos = body.tell()\n        except OSError:\n            # This differentiates from None, allowing us to catch\n            # a failed `tell()` later when trying to rewind the body.\n            pos = _FAILEDTELL\n\n    return pos\n\n\ndef rewind_body(body: typing.IO[typing.AnyStr], body_pos: _TYPE_BODY_POSITION) -> None:\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n\n    :param body:\n        File-like object that supports seek.\n\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)\n    if body_seek is not None and isinstance(body_pos, int):\n        try:\n            body_seek(body_pos)\n        except OSError as e:\n            raise UnrewindableBodyError(\n                \"An error occurred when rewinding request body for redirect/retry.\"\n            ) from e\n    elif body_pos is _FAILEDTELL:\n        raise UnrewindableBodyError(\n            \"Unable to record file position for rewinding \"\n            \"request body during a redirect/retry.\"\n        )\n    else:\n        raise ValueError(\n            f\"body_pos must be of type integer, instead it was {type(body_pos)}.\"\n        )\n\n\nclass ChunksAndContentLength(typing.NamedTuple):\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\n\n\ndef body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n\n    A 'Content-Length' of 'None' indicates the length of the body\n    can't be determined so should use 'Transfer-Encoding: chunked'\n    for framing instead.\n    \"\"\"\n\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\n\n    # No body, we need to make a recommendation on 'Content-Length'\n    # based on whether that request method is expected to have\n    # a body or not.\n    if body is None:\n        chunks = None\n        if method.upper() not in _METHODS_NOT_EXPECTING_BODY:\n            content_length = 0\n        else:\n            content_length = None\n\n    # Bytes or strings become bytes\n    elif isinstance(body, (str, bytes)):\n        chunks = (to_bytes(body),)\n        content_length = len(chunks[0])\n\n    # File-like object, TODO: use seek() and tell() for length?\n    elif hasattr(body, \"read\"):\n\n        def chunk_readable() -> typing.Iterable[bytes]:\n            nonlocal body, blocksize\n            encode = isinstance(body, io.TextIOBase)\n            while True:\n                datablock = body.read(blocksize)\n                if not datablock:\n                    break\n                if encode:\n                    datablock = datablock.encode(\"iso-8859-1\")\n                yield datablock\n\n        chunks = chunk_readable()\n        content_length = None\n\n    # Otherwise we need to start checking via duck-typing.\n    else:\n        try:\n            # Check if the body implements the buffer API.\n            mv = memoryview(body)\n        except TypeError:\n            try:\n                # Check if the body is an iterable\n                chunks = iter(body)\n                content_length = None\n            except TypeError:\n                raise TypeError(\n                    f\"'body' must be a bytes-like object, file-like \"\n                    f\"object, or iterable. Instead was {body!r}\"\n                ) from None\n        else:\n            # Since it implements the buffer API can be passed directly to socket.sendall()\n            chunks = (body,)\n            content_length = mv.nbytes\n\n    return ChunksAndContentLength(chunks=chunks, content_length=content_length)\n", "src/urllib3/util/proxy.py": "from __future__ import annotations\n\nimport typing\n\nfrom .url import Url\n\nif typing.TYPE_CHECKING:\n    from ..connection import ProxyConfig\n\n\ndef connection_requires_http_tunnel(\n    proxy_url: Url | None = None,\n    proxy_config: ProxyConfig | None = None,\n    destination_scheme: str | None = None,\n) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    # If we're not using a proxy, no way to use a tunnel.\n    if proxy_url is None:\n        return False\n\n    # HTTP destinations never require tunneling, we always forward.\n    if destination_scheme == \"http\":\n        return False\n\n    # Support for forwarding with HTTPS proxies and HTTPS destinations.\n    if (\n        proxy_url.scheme == \"https\"\n        and proxy_config\n        and proxy_config.use_forwarding_for_https\n    ):\n        return False\n\n    # Otherwise always use a tunnel.\n    return True\n", "src/urllib3/util/ssl_match_hostname.py": "\"\"\"The match_hostname() function from Python 3.5, essential when using SSL.\"\"\"\n\n# Note: This file is under the PSF license as the code comes from the python\n# stdlib.   http://docs.python.org/3/license.html\n# It is modified to remove commonName support.\n\nfrom __future__ import annotations\n\nimport ipaddress\nimport re\nimport typing\nfrom ipaddress import IPv4Address, IPv6Address\n\nif typing.TYPE_CHECKING:\n    from .ssl_ import _TYPE_PEER_CERT_RET_DICT\n\n__version__ = \"3.5.0.1\"\n\n\nclass CertificateError(ValueError):\n    pass\n\n\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:\n        return False\n\n    # Ported from python3-syntax:\n    # leftmost, *remainder = dn.split(r'.')\n    parts = dn.split(r\".\")\n    leftmost = parts[0]\n    remainder = parts[1:]\n\n    wildcards = leftmost.count(\"*\")\n    if wildcards > max_wildcards:\n        # Issue #17980: avoid denials of service by refusing more\n        # than one wildcard per fragment.  A survey of established\n        # policy among SSL implementations showed it to be a\n        # reasonable choice.\n        raise CertificateError(\n            \"too many wildcards in certificate DNS name: \" + repr(dn)\n        )\n\n    # speed up common case w/o wildcards\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n\n    # RFC 6125, section 6.4.3, subitem 1.\n    # The client SHOULD NOT attempt to match a presented identifier in which\n    # the wildcard character comprises a label other than the left-most label.\n    if leftmost == \"*\":\n        # When '*' is a fragment by itself, it matches a non-empty dotless\n        # fragment.\n        pats.append(\"[^.]+\")\n    elif leftmost.startswith(\"xn--\") or hostname.startswith(\"xn--\"):\n        # RFC 6125, section 6.4.3, subitem 3.\n        # The client SHOULD NOT attempt to match a presented identifier\n        # where the wildcard character is embedded within an A-label or\n        # U-label of an internationalized domain name.\n        pats.append(re.escape(leftmost))\n    else:\n        # Otherwise, '*' matches any dotless string, e.g. www*\n        pats.append(re.escape(leftmost).replace(r\"\\*\", \"[^.]*\"))\n\n    # add the remaining fragments, ignore any wildcards\n    for frag in remainder:\n        pats.append(re.escape(frag))\n\n    pat = re.compile(r\"\\A\" + r\"\\.\".join(pats) + r\"\\Z\", re.IGNORECASE)\n    return pat.match(hostname)\n\n\ndef _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    \"\"\"Exact matching of IP addresses.\n\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\n    matches if the address is identical to an iPAddress value of the\n    subjectAltName extension of the certificate.\"\n    \"\"\"\n    # OpenSSL may add a trailing newline to a subjectAltName's IP address\n    # Divergence from upstream: ipaddress can't handle byte str\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)\n\n\ndef match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError(\n            \"empty or no certificate, match_hostname needs a \"\n            \"SSL socket or SSL context with either \"\n            \"CERT_OPTIONAL or CERT_REQUIRED\"\n        )\n    try:\n        # Divergence from upstream: ipaddress can't handle byte str\n        #\n        # The ipaddress module shipped with Python < 3.9 does not support\n        # scoped IPv6 addresses so we unconditionally strip the Zone IDs for\n        # now. Once we drop support for Python 3.9 we can remove this branch.\n        if \"%\" in hostname:\n            host_ip = ipaddress.ip_address(hostname[: hostname.rfind(\"%\")])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n\n    except ValueError:\n        # Not an IP address (common case)\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get(\"subjectAltName\", ())\n    key: str\n    value: str\n    for key, value in san:\n        if key == \"DNS\":\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == \"IP Address\":\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n\n    # We only check 'commonName' if it's enabled and we're not verifying\n    # an IP address. IP addresses aren't valid within 'commonName'.\n    if hostname_checks_common_name and host_ip is None and not dnsnames:\n        for sub in cert.get(\"subject\", ()):\n            for key, value in sub:\n                if key == \"commonName\":\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n\n    if len(dnsnames) > 1:\n        raise CertificateError(\n            \"hostname %r \"\n            \"doesn't match either of %s\" % (hostname, \", \".join(map(repr, dnsnames)))\n        )\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError(\"no appropriate subjectAltName fields were found\")\n", "src/urllib3/util/util.py": "from __future__ import annotations\n\nimport typing\nfrom types import TracebackType\n\n\ndef to_bytes(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> bytes:\n    if isinstance(x, bytes):\n        return x\n    elif not isinstance(x, str):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.encode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.encode()\n\n\ndef to_str(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> str:\n    if isinstance(x, str):\n        return x\n    elif not isinstance(x, bytes):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.decode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.decode()\n\n\ndef reraise(\n    tp: type[BaseException] | None,\n    value: BaseException,\n    tb: TracebackType | None = None,\n) -> typing.NoReturn:\n    try:\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:\n        value = None  # type: ignore[assignment]\n        tb = None\n", "src/urllib3/util/timeout.py": "from __future__ import annotations\n\nimport time\nimport typing\nfrom enum import Enum\nfrom socket import getdefaulttimeout\n\nfrom ..exceptions import TimeoutStateError\n\nif typing.TYPE_CHECKING:\n    from typing import Final\n\n\nclass _TYPE_DEFAULT(Enum):\n    # This value should never be passed to socket.settimeout() so for safety we use a -1.\n    # socket.settimout() raises a ValueError for negative values.\n    token = -1\n\n\n_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token\n\n_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\n\n\nclass Timeout:\n    \"\"\"Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n        import urllib3\n\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n\n        http = urllib3.PoolManager(timeout=timeout)\n\n        resp = http.request(\"GET\", \"https://example.com/\")\n\n        print(resp.status)\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request(\"GET\", \"https://example.com/\", timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request(\"GET\", \"https://example.com/\", timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python's DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n    \"\"\"\n\n    #: A sentinel object representing the default timeout value\n    DEFAULT_TIMEOUT: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT\n\n    def __init__(\n        self,\n        total: _TYPE_TIMEOUT = None,\n        connect: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        read: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    ) -> None:\n        self._connect = self._validate_timeout(connect, \"connect\")\n        self._read = self._validate_timeout(read, \"read\")\n        self.total = self._validate_timeout(total, \"total\")\n        self._start_connect: float | None = None\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}(connect={self._connect!r}, read={self._read!r}, total={self.total!r})\"\n\n    # __str__ provided for backwards compatibility\n    __str__ = __repr__\n\n    @staticmethod\n    def resolve_default_timeout(timeout: _TYPE_TIMEOUT) -> float | None:\n        return getdefaulttimeout() if timeout is _DEFAULT_TIMEOUT else timeout\n\n    @classmethod\n    def _validate_timeout(cls, value: _TYPE_TIMEOUT, name: str) -> _TYPE_TIMEOUT:\n        \"\"\"Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        \"\"\"\n        if value is None or value is _DEFAULT_TIMEOUT:\n            return value\n\n        if isinstance(value, bool):\n            raise ValueError(\n                \"Timeout cannot be a boolean value. It must \"\n                \"be an int, float or None.\"\n            )\n        try:\n            float(value)\n        except (TypeError, ValueError):\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            ) from None\n\n        try:\n            if value <= 0:\n                raise ValueError(\n                    \"Attempted to set %s timeout to %s, but the \"\n                    \"timeout cannot be set to a value less \"\n                    \"than or equal to 0.\" % (name, value)\n                )\n        except TypeError:\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            ) from None\n\n        return value\n\n    @classmethod\n    def from_float(cls, timeout: _TYPE_TIMEOUT) -> Timeout:\n        \"\"\"Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, :attr:`urllib3.util.Timeout.DEFAULT_TIMEOUT`, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        return Timeout(read=timeout, connect=timeout)\n\n    def clone(self) -> Timeout:\n        \"\"\"Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        # We can't use copy.deepcopy because that will also create a new object\n        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n        # detect the user default.\n        return Timeout(connect=self._connect, read=self._read, total=self.total)\n\n    def start_connect(self) -> float:\n        \"\"\"Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        \"\"\"\n        if self._start_connect is not None:\n            raise TimeoutStateError(\"Timeout timer has already been started.\")\n        self._start_connect = time.monotonic()\n        return self._start_connect\n\n    def get_connect_duration(self) -> float:\n        \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        \"\"\"\n        if self._start_connect is None:\n            raise TimeoutStateError(\n                \"Can't get connect duration for timer that has not started.\"\n            )\n        return time.monotonic() - self._start_connect\n\n    @property\n    def connect_timeout(self) -> _TYPE_TIMEOUT:\n        \"\"\"Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        \"\"\"\n        if self.total is None:\n            return self._connect\n\n        if self._connect is None or self._connect is _DEFAULT_TIMEOUT:\n            return self.total\n\n        return min(self._connect, self.total)  # type: ignore[type-var]\n\n    @property\n    def read_timeout(self) -> float | None:\n        \"\"\"Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        \"\"\"\n        if (\n            self.total is not None\n            and self.total is not _DEFAULT_TIMEOUT\n            and self._read is not None\n            and self._read is not _DEFAULT_TIMEOUT\n        ):\n            # In case the connect timeout has not yet been established.\n            if self._start_connect is None:\n                return self._read\n            return max(0, min(self.total - self.get_connect_duration(), self._read))\n        elif self.total is not None and self.total is not _DEFAULT_TIMEOUT:\n            return max(0, self.total - self.get_connect_duration())\n        else:\n            return self.resolve_default_timeout(self._read)\n", "src/urllib3/util/url.py": "from __future__ import annotations\n\nimport re\nimport typing\n\nfrom ..exceptions import LocationParseError\nfrom .util import to_str\n\n# We only want to normalize urls with an HTTP(S) scheme.\n# urllib3 infers URLs without a scheme (None) to be http.\n_NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\n_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s\",\n    # [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    \"(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s\",\n    # [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    \"(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s\",\n    # [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    \"(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s\",\n    # [ *6( h16 \":\" ) h16 ] \"::\"\n    \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",\n]\n\n_UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\-~\"\n_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\n\n\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),\n            (\"query\", typing.Optional[str]),\n            (\"fragment\", typing.Optional[str]),\n        ],\n    )\n):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    def __new__(  # type: ignore[no-untyped-def]\n        cls,\n        scheme: str | None = None,\n        auth: str | None = None,\n        host: str | None = None,\n        port: int | None = None,\n        path: str | None = None,\n        query: str | None = None,\n        fragment: str | None = None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super().__new__(cls, scheme, auth, host, port, path, query, fragment)\n\n    @property\n    def hostname(self) -> str | None:\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self) -> str:\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def authority(self) -> str | None:\n        \"\"\"\n        Authority component as defined in RFC 3986 3.2.\n        This includes userinfo (auth), host and port.\n\n        i.e.\n            userinfo@host:port\n        \"\"\"\n        userinfo = self.auth\n        netloc = self.netloc\n        if netloc is None or userinfo is None:\n            return netloc\n        else:\n            return f\"{userinfo}@{netloc}\"\n\n    @property\n    def netloc(self) -> str | None:\n        \"\"\"\n        Network location including host and port.\n\n        If you need the equivalent of urllib.parse's ``netloc``,\n        use the ``authority`` property instead.\n        \"\"\"\n        if self.host is None:\n            return None\n        if self.port:\n            return f\"{self.host}:{self.port}\"\n        return self.host\n\n    @property\n    def url(self) -> str:\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example:\n\n        .. code-block:: python\n\n            import urllib3\n\n            U = urllib3.util.parse_url(\"https://google.com/mail/\")\n\n            print(U.url)\n            # \"https://google.com/mail/\"\n\n            print( urllib3.util.Url(\"https\", \"username:password\",\n                                    \"host.com\", 80, \"/path\", \"query\", \"fragment\"\n                                    ).url\n                )\n            # \"https://username:password@host.com:80/path?query#fragment\"\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = \"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + \"://\"\n        if auth is not None:\n            url += auth + \"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += \":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += \"?\" + query\n        if fragment is not None:\n            url += \"#\" + fragment\n\n        return url\n\n    def __str__(self) -> str:\n        return self.url\n\n\n@typing.overload\ndef _encode_invalid_chars(\n    component: str, allowed_chars: typing.Container[str]\n) -> str:  # Abstract\n    ...\n\n\n@typing.overload\ndef _encode_invalid_chars(\n    component: None, allowed_chars: typing.Container[str]\n) -> None:  # Abstract\n    ...\n\n\ndef _encode_invalid_chars(\n    component: str | None, allowed_chars: typing.Container[str]\n) -> str | None:\n    \"\"\"Percent-encodes a URI component without reapplying\n    onto an already percent-encoded component.\n    \"\"\"\n    if component is None:\n        return component\n\n    component = to_str(component)\n\n    # Normalize existing percent-encoded bytes.\n    # Try to see if the component we're encoding is already percent-encoded\n    # so we can skip all '%' characters but still encode all others.\n    component, percent_encodings = _PERCENT_RE.subn(\n        lambda match: match.group(0).upper(), component\n    )\n\n    uri_bytes = component.encode(\"utf-8\", \"surrogatepass\")\n    is_percent_encoded = percent_encodings == uri_bytes.count(b\"%\")\n    encoded_component = bytearray()\n\n    for i in range(0, len(uri_bytes)):\n        # Will return a single character bytestring\n        byte = uri_bytes[i : i + 1]\n        byte_ord = ord(byte)\n        if (is_percent_encoded and byte == b\"%\") or (\n            byte_ord < 128 and byte.decode() in allowed_chars\n        ):\n            encoded_component += byte\n            continue\n        encoded_component.extend(b\"%\" + (hex(byte_ord)[2:].encode().zfill(2).upper()))\n\n    return encoded_component.decode()\n\n\ndef _remove_path_dot_segments(path: str) -> str:\n    # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code\n    segments = path.split(\"/\")  # Turn the path into a list of segments\n    output = []  # Initialize the variable to use to store output\n\n    for segment in segments:\n        # '.' is the current directory, so ignore it, it is superfluous\n        if segment == \".\":\n            continue\n        # Anything other than '..', should be appended to the output\n        if segment != \"..\":\n            output.append(segment)\n        # In this case segment == '..', if we can, we should pop the last\n        # element\n        elif output:\n            output.pop()\n\n    # If the path starts with '/' and the output is empty or the first string\n    # is non-empty\n    if path.startswith(\"/\") and (not output or output[0]):\n        output.insert(0, \"\")\n\n    # If the path starts with '/.' or '/..' ensure we add one more empty\n    # string to add a trailing '/'\n    if path.endswith((\"/.\", \"/..\")):\n        output.append(\"\")\n\n    return \"/\".join(output)\n\n\n@typing.overload\ndef _normalize_host(host: None, scheme: str | None) -> None:\n    ...\n\n\n@typing.overload\ndef _normalize_host(host: str, scheme: str | None) -> str:\n    ...\n\n\ndef _normalize_host(host: str | None, scheme: str | None) -> str | None:\n    if host:\n        if scheme in _NORMALIZABLE_SCHEMES:\n            is_ipv6 = _IPV6_ADDRZ_RE.match(host)\n            if is_ipv6:\n                # IPv6 hosts of the form 'a::b%zone' are encoded in a URL as\n                # such per RFC 6874: 'a::b%25zone'. Unquote the ZoneID\n                # separator as necessary to return a valid RFC 4007 scoped IP.\n                match = _ZONE_ID_RE.search(host)\n                if match:\n                    start, end = match.span(1)\n                    zone_id = host[start:end]\n\n                    if zone_id.startswith(\"%25\") and zone_id != \"%25\":\n                        zone_id = zone_id[3:]\n                    else:\n                        zone_id = zone_id[1:]\n                    zone_id = _encode_invalid_chars(zone_id, _UNRESERVED_CHARS)\n                    return f\"{host[:start].lower()}%{zone_id}{host[end:]}\"\n                else:\n                    return host.lower()\n            elif not _IPV4_RE.match(host):\n                return to_str(\n                    b\".\".join([_idna_encode(label) for label in host.split(\".\")]),\n                    \"ascii\",\n                )\n    return host\n\n\ndef _idna_encode(name: str) -> bytes:\n    if not name.isascii():\n        try:\n            import idna\n        except ImportError:\n            raise LocationParseError(\n                \"Unable to parse URL without the 'idna' module\"\n            ) from None\n\n        try:\n            return idna.encode(name.lower(), strict=True, std3_rules=True)\n        except idna.IDNAError:\n            raise LocationParseError(\n                f\"Name '{name}' is not a valid IDNA label\"\n            ) from None\n\n    return name.lower().encode(\"ascii\")\n\n\ndef _encode_target(target: str) -> str:\n    \"\"\"Percent-encodes a request target so that there are no invalid characters\n\n    Pre-condition for this function is that 'target' must start with '/'.\n    If that is the case then _TARGET_RE will always produce a match.\n    \"\"\"\n    match = _TARGET_RE.match(target)\n    if not match:  # Defensive:\n        raise LocationParseError(f\"{target!r} is not a valid request URI\")\n\n    path, query = match.groups()\n    encoded_target = _encode_invalid_chars(path, _PATH_CHARS)\n    if query is not None:\n        query = _encode_invalid_chars(query, _QUERY_CHARS)\n        encoded_target += \"?\" + query\n    return encoded_target\n\n\ndef parse_url(url: str) -> Url:\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 and RFC 6874 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urllib.parse`.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        print( urllib3.util.parse_url('http://google.com/mail/'))\n        # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n\n        print( urllib3.util.parse_url('google.com:80'))\n        # Url(scheme=None, host='google.com', port=80, path=None, ...)\n\n        print( urllib3.util.parse_url('/foo?bar'))\n        # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not _SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    scheme: str | None\n    authority: str | None\n    auth: str | None\n    host: str | None\n    port: str | None\n    port_int: int | None\n    path: str | None\n    query: str | None\n    fragment: str | None\n\n    try:\n        scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n        normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, _, host_port = authority.rpartition(\"@\")\n            auth = auth or None\n            host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port_int = int(port)\n            if not (0 <= port_int <= 65535):\n                raise LocationParseError(url)\n        else:\n            port_int = None\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, _PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, _QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError) as e:\n        raise LocationParseError(source_url) from e\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    return Url(\n        scheme=scheme,\n        auth=auth,\n        host=host,\n        port=port_int,\n        path=path,\n        query=query,\n        fragment=fragment,\n    )\n", "src/urllib3/util/__init__.py": "# For backwards compatibility, provide imports that used to be here.\nfrom __future__ import annotations\n\nfrom .connection import is_connection_dropped\nfrom .request import SKIP_HEADER, SKIPPABLE_HEADERS, make_headers\nfrom .response import is_fp_closed\nfrom .retry import Retry\nfrom .ssl_ import (\n    ALPN_PROTOCOLS,\n    IS_PYOPENSSL,\n    SSLContext,\n    assert_fingerprint,\n    create_urllib3_context,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom .timeout import Timeout\nfrom .url import Url, parse_url\nfrom .wait import wait_for_read, wait_for_write\n\n__all__ = (\n    \"IS_PYOPENSSL\",\n    \"SSLContext\",\n    \"ALPN_PROTOCOLS\",\n    \"Retry\",\n    \"Timeout\",\n    \"Url\",\n    \"assert_fingerprint\",\n    \"create_urllib3_context\",\n    \"is_connection_dropped\",\n    \"is_fp_closed\",\n    \"parse_url\",\n    \"make_headers\",\n    \"resolve_cert_reqs\",\n    \"resolve_ssl_version\",\n    \"ssl_wrap_socket\",\n    \"wait_for_read\",\n    \"wait_for_write\",\n    \"SKIP_HEADER\",\n    \"SKIPPABLE_HEADERS\",\n)\n", "src/urllib3/util/ssltransport.py": "from __future__ import annotations\n\nimport io\nimport socket\nimport ssl\nimport typing\n\nfrom ..exceptions import ProxySchemeUnsupported\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from .ssl_ import _TYPE_PEER_CERT_RET, _TYPE_PEER_CERT_RET_DICT\n\n\n_WriteBuffer = typing.Union[bytearray, memoryview]\n_ReturnValue = typing.TypeVar(\"_ReturnValue\")\n\nSSL_BLOCKSIZE = 16384\n\n\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n\n    The class supports most of the socket API operations.\n    \"\"\"\n\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None:\n        \"\"\"\n        Raises a ProxySchemeUnsupported if the provided ssl_context can't be used\n        for TLS in TLS.\n\n        The only requirement is that the ssl_context provides the 'wrap_bio'\n        methods.\n        \"\"\"\n\n        if not hasattr(ssl_context, \"wrap_bio\"):\n            raise ProxySchemeUnsupported(\n                \"TLS in TLS requires SSLContext.wrap_bio() which isn't \"\n                \"available on non-native SSLContext\"\n            )\n\n    def __init__(\n        self,\n        socket: socket.socket,\n        ssl_context: ssl.SSLContext,\n        server_hostname: str | None = None,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        \"\"\"\n        Create an SSLTransport around socket using the provided ssl_context.\n        \"\"\"\n        self.incoming = ssl.MemoryBIO()\n        self.outgoing = ssl.MemoryBIO()\n\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self.socket = socket\n\n        self.sslobj = ssl_context.wrap_bio(\n            self.incoming, self.outgoing, server_hostname=server_hostname\n        )\n\n        # Perform initial handshake.\n        self._ssl_io_loop(self.sslobj.do_handshake)\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(self, *_: typing.Any) -> None:\n        self.close()\n\n    def fileno(self) -> int:\n        return self.socket.fileno()\n\n    def read(self, len: int = 1024, buffer: typing.Any | None = None) -> int | bytes:\n        return self._wrap_ssl_read(len, buffer)\n\n    def recv(self, buflen: int = 1024, flags: int = 0) -> int | bytes:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv\")\n        return self._wrap_ssl_read(buflen)\n\n    def recv_into(\n        self,\n        buffer: _WriteBuffer,\n        nbytes: int | None = None,\n        flags: int = 0,\n    ) -> None | int | bytes:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv_into\")\n        if nbytes is None:\n            nbytes = len(buffer)\n        return self.read(nbytes, buffer)\n\n    def sendall(self, data: bytes, flags: int = 0) -> None:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to sendall\")\n        count = 0\n        with memoryview(data) as view, view.cast(\"B\") as byte_view:\n            amount = len(byte_view)\n            while count < amount:\n                v = self.send(byte_view[count:])\n                count += v\n\n    def send(self, data: bytes, flags: int = 0) -> int:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to send\")\n        return self._ssl_io_loop(self.sslobj.write, data)\n\n    def makefile(\n        self,\n        mode: str,\n        buffering: int | None = None,\n        *,\n        encoding: str | None = None,\n        errors: str | None = None,\n        newline: str | None = None,\n    ) -> typing.BinaryIO | typing.TextIO | socket.SocketIO:\n        \"\"\"\n        Python's httpclient uses makefile and buffered io when reading HTTP\n        messages and we need to support it.\n\n        This is unfortunately a copy and paste of socket.py makefile with small\n        changes to point to the socket directly.\n        \"\"\"\n        if not set(mode) <= {\"r\", \"w\", \"b\"}:\n            raise ValueError(f\"invalid mode {mode!r} (only r, w, b allowed)\")\n\n        writing = \"w\" in mode\n        reading = \"r\" in mode or not writing\n        assert reading or writing\n        binary = \"b\" in mode\n        rawmode = \"\"\n        if reading:\n            rawmode += \"r\"\n        if writing:\n            rawmode += \"w\"\n        raw = socket.SocketIO(self, rawmode)  # type: ignore[arg-type]\n        self.socket._io_refs += 1  # type: ignore[attr-defined]\n        if buffering is None:\n            buffering = -1\n        if buffering < 0:\n            buffering = io.DEFAULT_BUFFER_SIZE\n        if buffering == 0:\n            if not binary:\n                raise ValueError(\"unbuffered streams must be binary\")\n            return raw\n        buffer: typing.BinaryIO\n        if reading and writing:\n            buffer = io.BufferedRWPair(raw, raw, buffering)  # type: ignore[assignment]\n        elif reading:\n            buffer = io.BufferedReader(raw, buffering)\n        else:\n            assert writing\n            buffer = io.BufferedWriter(raw, buffering)\n        if binary:\n            return buffer\n        text = io.TextIOWrapper(buffer, encoding, errors, newline)\n        text.mode = mode  # type: ignore[misc]\n        return text\n\n    def unwrap(self) -> None:\n        self._ssl_io_loop(self.sslobj.unwrap)\n\n    def close(self) -> None:\n        self.socket.close()\n\n    @typing.overload\n    def getpeercert(\n        self, binary_form: typing.Literal[False] = ...\n    ) -> _TYPE_PEER_CERT_RET_DICT | None:\n        ...\n\n    @typing.overload\n    def getpeercert(self, binary_form: typing.Literal[True]) -> bytes | None:\n        ...\n\n    def getpeercert(self, binary_form: bool = False) -> _TYPE_PEER_CERT_RET:\n        return self.sslobj.getpeercert(binary_form)  # type: ignore[return-value]\n\n    def version(self) -> str | None:\n        return self.sslobj.version()\n\n    def cipher(self) -> tuple[str, str, int] | None:\n        return self.sslobj.cipher()\n\n    def selected_alpn_protocol(self) -> str | None:\n        return self.sslobj.selected_alpn_protocol()\n\n    def selected_npn_protocol(self) -> str | None:\n        return self.sslobj.selected_npn_protocol()\n\n    def shared_ciphers(self) -> list[tuple[str, str, int]] | None:\n        return self.sslobj.shared_ciphers()\n\n    def compression(self) -> str | None:\n        return self.sslobj.compression()\n\n    def settimeout(self, value: float | None) -> None:\n        self.socket.settimeout(value)\n\n    def gettimeout(self) -> float | None:\n        return self.socket.gettimeout()\n\n    def _decref_socketios(self) -> None:\n        self.socket._decref_socketios()  # type: ignore[attr-defined]\n\n    def _wrap_ssl_read(self, len: int, buffer: bytearray | None = None) -> int | bytes:\n        try:\n            return self._ssl_io_loop(self.sslobj.read, len, buffer)\n        except ssl.SSLError as e:\n            if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:\n                return 0  # eof, return 0.\n            else:\n                raise\n\n    # func is sslobj.do_handshake or sslobj.unwrap\n    @typing.overload\n    def _ssl_io_loop(self, func: typing.Callable[[], None]) -> None:\n        ...\n\n    # func is sslobj.write, arg1 is data\n    @typing.overload\n    def _ssl_io_loop(self, func: typing.Callable[[bytes], int], arg1: bytes) -> int:\n        ...\n\n    # func is sslobj.read, arg1 is len, arg2 is buffer\n    @typing.overload\n    def _ssl_io_loop(\n        self,\n        func: typing.Callable[[int, bytearray | None], bytes],\n        arg1: int,\n        arg2: bytearray | None,\n    ) -> bytes:\n        ...\n\n    def _ssl_io_loop(\n        self,\n        func: typing.Callable[..., _ReturnValue],\n        arg1: None | bytes | int = None,\n        arg2: bytearray | None = None,\n    ) -> _ReturnValue:\n        \"\"\"Performs an I/O loop between incoming/outgoing and the socket.\"\"\"\n        should_loop = True\n        ret = None\n\n        while should_loop:\n            errno = None\n            try:\n                if arg1 is None and arg2 is None:\n                    ret = func()\n                elif arg2 is None:\n                    ret = func(arg1)\n                else:\n                    ret = func(arg1, arg2)\n            except ssl.SSLError as e:\n                if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):\n                    # WANT_READ, and WANT_WRITE are expected, others are not.\n                    raise e\n                errno = e.errno\n\n            buf = self.outgoing.read()\n            self.socket.sendall(buf)\n\n            if errno is None:\n                should_loop = False\n            elif errno == ssl.SSL_ERROR_WANT_READ:\n                buf = self.socket.recv(SSL_BLOCKSIZE)\n                if buf:\n                    self.incoming.write(buf)\n                else:\n                    self.incoming.write_eof()\n        return typing.cast(_ReturnValue, ret)\n", "src/urllib3/util/ssl_.py": "from __future__ import annotations\n\nimport hmac\nimport os\nimport socket\nimport sys\nimport typing\nimport warnings\nfrom binascii import unhexlify\nfrom hashlib import md5, sha1, sha256\n\nfrom ..exceptions import ProxySchemeUnsupported, SSLError\nfrom .url import _BRACELESS_IPV6_ADDRZ_RE, _IPV4_RE\n\nSSLContext = None\nSSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n\n_TYPE_VERSION_INFO = typing.Tuple[int, int, int, str, int]\n\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {32: md5, 40: sha1, 64: sha256}\n\n\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    \"\"\"Return True for CPython 3.8.9+, 3.9.3+ or 3.10+ and PyPy 7.3.8+ where\n    setting SSLContext.hostname_checks_common_name to False works.\n\n    Outside of CPython and PyPy we don't know which implementations work\n    or not so we conservatively use our hostname matching as we know that works\n    on all implementations.\n\n    https://github.com/urllib3/urllib3/issues/2192#issuecomment-821832963\n    https://foss.heptapod.net/pypy/pypy/-/issues/3539\n    \"\"\"\n    if implementation_name == \"pypy\":\n        # https://foss.heptapod.net/pypy/pypy/-/issues/3129\n        return pypy_version_info >= (7, 3, 8)  # type: ignore[operator]\n    elif implementation_name == \"cpython\":\n        major_minor = version_info[:2]\n        micro = version_info[2]\n        return (\n            (major_minor == (3, 8) and micro >= 9)\n            or (major_minor == (3, 9) and micro >= 3)\n            or major_minor >= (3, 10)\n        )\n    else:  # Defensive:\n        return False\n\n\ndef _is_has_never_check_common_name_reliable(\n    openssl_version: str,\n    openssl_version_number: int,\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    # As of May 2023, all released versions of LibreSSL fail to reject certificates with\n    # only common names, see https://github.com/urllib3/urllib3/pull/3024\n    is_openssl = openssl_version.startswith(\"OpenSSL \")\n    # Before fixing OpenSSL issue #14579, the SSL_new() API was not copying hostflags\n    # like X509_CHECK_FLAG_NEVER_CHECK_SUBJECT, which tripped up CPython.\n    # https://github.com/openssl/openssl/issues/14579\n    # This was released in OpenSSL 1.1.1l+ (>=0x101010cf)\n    is_openssl_issue_14579_fixed = openssl_version_number >= 0x101010CF\n\n    return is_openssl and (\n        is_openssl_issue_14579_fixed\n        or _is_bpo_43522_fixed(implementation_name, version_info, pypy_version_info)\n    )\n\n\nif typing.TYPE_CHECKING:\n    from ssl import VerifyMode\n    from typing import TypedDict\n\n    from .ssltransport import SSLTransport as SSLTransportType\n\n    class _TYPE_PEER_CERT_RET_DICT(TypedDict, total=False):\n        subjectAltName: tuple[tuple[str, str], ...]\n        subject: tuple[tuple[tuple[str, str], ...], ...]\n        serialNumber: str\n\n\n# Mapping from 'ssl.PROTOCOL_TLSX' to 'TLSVersion.X'\n_SSL_VERSION_TO_TLS_VERSION: dict[int, int] = {}\n\ntry:  # Do we have ssl at all?\n    import ssl\n    from ssl import (  # type: ignore[assignment]\n        CERT_REQUIRED,\n        HAS_NEVER_CHECK_COMMON_NAME,\n        OP_NO_COMPRESSION,\n        OP_NO_TICKET,\n        OPENSSL_VERSION,\n        OPENSSL_VERSION_NUMBER,\n        PROTOCOL_TLS,\n        PROTOCOL_TLS_CLIENT,\n        OP_NO_SSLv2,\n        OP_NO_SSLv3,\n        SSLContext,\n        TLSVersion,\n    )\n\n    PROTOCOL_SSLv23 = PROTOCOL_TLS\n\n    # Setting SSLContext.hostname_checks_common_name = False didn't work before CPython\n    # 3.8.9, 3.9.3, and 3.10 (but OK on PyPy) or OpenSSL 1.1.1l+\n    if HAS_NEVER_CHECK_COMMON_NAME and not _is_has_never_check_common_name_reliable(\n        OPENSSL_VERSION,\n        OPENSSL_VERSION_NUMBER,\n        sys.implementation.name,\n        sys.version_info,\n        sys.pypy_version_info if sys.implementation.name == \"pypy\" else None,  # type: ignore[attr-defined]\n    ):\n        HAS_NEVER_CHECK_COMMON_NAME = False\n\n    # Need to be careful here in case old TLS versions get\n    # removed in future 'ssl' module implementations.\n    for attr in (\"TLSv1\", \"TLSv1_1\", \"TLSv1_2\"):\n        try:\n            _SSL_VERSION_TO_TLS_VERSION[getattr(ssl, f\"PROTOCOL_{attr}\")] = getattr(\n                TLSVersion, attr\n            )\n        except AttributeError:  # Defensive:\n            continue\n\n    from .ssltransport import SSLTransport  # type: ignore[assignment]\nexcept ImportError:\n    OP_NO_COMPRESSION = 0x20000  # type: ignore[assignment]\n    OP_NO_TICKET = 0x4000  # type: ignore[assignment]\n    OP_NO_SSLv2 = 0x1000000  # type: ignore[assignment]\n    OP_NO_SSLv3 = 0x2000000  # type: ignore[assignment]\n    PROTOCOL_SSLv23 = PROTOCOL_TLS = 2  # type: ignore[assignment]\n    PROTOCOL_TLS_CLIENT = 16  # type: ignore[assignment]\n\n\n_TYPE_PEER_CERT_RET = typing.Union[\"_TYPE_PEER_CERT_RET_DICT\", bytes, None]\n\n\ndef assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    if cert is None:\n        raise SSLError(\"No certificate for the peer.\")\n\n    fingerprint = fingerprint.replace(\":\", \"\").lower()\n    digest_length = len(fingerprint)\n    hashfunc = HASHFUNC_MAP.get(digest_length)\n    if not hashfunc:\n        raise SSLError(f\"Fingerprint of invalid length: {fingerprint}\")\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not hmac.compare_digest(cert_digest, fingerprint_bytes):\n        raise SSLError(\n            f'Fingerprints did not match. Expected \"{fingerprint}\", got \"{cert_digest.hex()}\"'\n        )\n\n\ndef resolve_cert_reqs(candidate: None | int | str) -> VerifyMode:\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.\n    \"\"\"\n    if candidate is None:\n        return CERT_REQUIRED\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"CERT_\" + candidate)\n        return res  # type: ignore[no-any-return]\n\n    return candidate  # type: ignore[return-value]\n\n\ndef resolve_ssl_version(candidate: None | int | str) -> int:\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)\n        return typing.cast(int, res)\n\n    return candidate\n\n\ndef create_urllib3_context(\n    ssl_version: int | None = None,\n    cert_reqs: int | None = None,\n    options: int | None = None,\n    ciphers: str | None = None,\n    ssl_minimum_version: int | None = None,\n    ssl_maximum_version: int | None = None,\n) -> ssl.SSLContext:\n    \"\"\"Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3.\n\n    :param ssl_version:\n        The desired protocol version to use. This will default to\n        PROTOCOL_SSLv23 which will negotiate the highest protocol that both\n        the server and your installation of OpenSSL support.\n\n        This parameter is deprecated instead use 'ssl_minimum_version'.\n    :param ssl_minimum_version:\n        The minimum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\n    :param ssl_maximum_version:\n        The maximum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\n        Not recommended to set to anything other than 'ssl.TLSVersion.MAXIMUM_SUPPORTED' which is the\n        default value.\n    :param cert_reqs:\n        Whether to require the certificate verification. This defaults to\n        ``ssl.CERT_REQUIRED``.\n    :param options:\n        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,\n        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.\n    :param ciphers:\n        Which cipher suites to allow the server to select. Defaults to either system configured\n        ciphers if OpenSSL 1.1.1+, otherwise uses a secure default set of ciphers.\n    :returns:\n        Constructed SSLContext object with specified options\n    :rtype: SSLContext\n    \"\"\"\n    if SSLContext is None:\n        raise TypeError(\"Can't create an SSLContext object without an ssl module\")\n\n    # This means 'ssl_version' was specified as an exact value.\n    if ssl_version not in (None, PROTOCOL_TLS, PROTOCOL_TLS_CLIENT):\n        # Disallow setting 'ssl_version' and 'ssl_minimum|maximum_version'\n        # to avoid conflicts.\n        if ssl_minimum_version is not None or ssl_maximum_version is not None:\n            raise ValueError(\n                \"Can't specify both 'ssl_version' and either \"\n                \"'ssl_minimum_version' or 'ssl_maximum_version'\"\n            )\n\n        # 'ssl_version' is deprecated and will be removed in the future.\n        else:\n            # Use 'ssl_minimum_version' and 'ssl_maximum_version' instead.\n            ssl_minimum_version = _SSL_VERSION_TO_TLS_VERSION.get(\n                ssl_version, TLSVersion.MINIMUM_SUPPORTED\n            )\n            ssl_maximum_version = _SSL_VERSION_TO_TLS_VERSION.get(\n                ssl_version, TLSVersion.MAXIMUM_SUPPORTED\n            )\n\n            # This warning message is pushing users to use 'ssl_minimum_version'\n            # instead of both min/max. Best practice is to only set the minimum version and\n            # keep the maximum version to be it's default value: 'TLSVersion.MAXIMUM_SUPPORTED'\n            warnings.warn(\n                \"'ssl_version' option is deprecated and will be \"\n                \"removed in urllib3 v2.1.0. Instead use 'ssl_minimum_version'\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n    # PROTOCOL_TLS is deprecated in Python 3.10 so we always use PROTOCOL_TLS_CLIENT\n    context = SSLContext(PROTOCOL_TLS_CLIENT)\n\n    if ssl_minimum_version is not None:\n        context.minimum_version = ssl_minimum_version\n    else:  # Python <3.10 defaults to 'MINIMUM_SUPPORTED' so explicitly set TLSv1.2 here\n        context.minimum_version = TLSVersion.TLSv1_2\n\n    if ssl_maximum_version is not None:\n        context.maximum_version = ssl_maximum_version\n\n    # Unless we're given ciphers defer to either system ciphers in\n    # the case of OpenSSL 1.1.1+ or use our own secure default ciphers.\n    if ciphers:\n        context.set_ciphers(ciphers)\n\n    # Setting the default here, as we may have no ssl module on import\n    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs\n\n    if options is None:\n        options = 0\n        # SSLv2 is easily broken and is considered harmful and dangerous\n        options |= OP_NO_SSLv2\n        # SSLv3 has several problems and is now dangerous\n        options |= OP_NO_SSLv3\n        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+\n        # (issue #309)\n        options |= OP_NO_COMPRESSION\n        # TLSv1.2 only. Unless set explicitly, do not request tickets.\n        # This may save some bandwidth on wire, and although the ticket is encrypted,\n        # there is a risk associated with it being on wire,\n        # if the server is not rotating its ticketing keys properly.\n        options |= OP_NO_TICKET\n\n    context.options |= options\n\n    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is\n    # necessary for conditional client cert authentication with TLS 1.3.\n    # The attribute is None for OpenSSL <= 1.1.0 or does not exist when using\n    # an SSLContext created by pyOpenSSL.\n    if getattr(context, \"post_handshake_auth\", None) is not None:\n        context.post_handshake_auth = True\n\n    # The order of the below lines setting verify_mode and check_hostname\n    # matter due to safe-guards SSLContext has to prevent an SSLContext with\n    # check_hostname=True, verify_mode=NONE/OPTIONAL.\n    # We always set 'check_hostname=False' for pyOpenSSL so we rely on our own\n    # 'ssl.match_hostname()' implementation.\n    if cert_reqs == ssl.CERT_REQUIRED and not IS_PYOPENSSL:\n        context.verify_mode = cert_reqs\n        context.check_hostname = True\n    else:\n        context.check_hostname = False\n        context.verify_mode = cert_reqs\n\n    try:\n        context.hostname_checks_common_name = False\n    except AttributeError:  # Defensive: for CPython < 3.8.9 and 3.9.3; for PyPy < 7.3.8\n        pass\n\n    # Enable logging of TLS session keys via defacto standard environment variable\n    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.\n    if hasattr(context, \"keylog_filename\"):\n        sslkeylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n        if sslkeylogfile:\n            context.keylog_filename = sslkeylogfile\n\n    return context\n\n\n@typing.overload\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,\n    ca_cert_dir: str | None = ...,\n    key_password: str | None = ...,\n    ca_cert_data: None | str | bytes = ...,\n    tls_in_tls: typing.Literal[False] = ...,\n) -> ssl.SSLSocket:\n    ...\n\n\n@typing.overload\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,\n    ca_cert_dir: str | None = ...,\n    key_password: str | None = ...,\n    ca_cert_data: None | str | bytes = ...,\n    tls_in_tls: bool = ...,\n) -> ssl.SSLSocket | SSLTransportType:\n    ...\n\n\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = None,\n    certfile: str | None = None,\n    cert_reqs: int | None = None,\n    ca_certs: str | None = None,\n    server_hostname: str | None = None,\n    ssl_version: int | None = None,\n    ciphers: str | None = None,\n    ssl_context: ssl.SSLContext | None = None,\n    ca_cert_dir: str | None = None,\n    key_password: str | None = None,\n    ca_cert_data: None | str | bytes = None,\n    tls_in_tls: bool = False,\n) -> ssl.SSLSocket | SSLTransportType:\n    \"\"\"\n    All arguments except for server_hostname, ssl_context, tls_in_tls, ca_cert_data and\n    ca_cert_dir have the same meaning as they do when using\n    :func:`ssl.create_default_context`, :meth:`ssl.SSLContext.load_cert_chain`,\n    :meth:`ssl.SSLContext.set_ciphers` and :meth:`ssl.SSLContext.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support.\n    :param ca_cert_dir:\n        A directory containing CA certificates in multiple separate files, as\n        supported by OpenSSL's -CApath flag or the capath argument to\n        SSLContext.load_verify_locations().\n    :param key_password:\n        Optional password if the keyfile is encrypted.\n    :param ca_cert_data:\n        Optional string containing CA certificates in PEM format suitable for\n        passing as the cadata parameter to SSLContext.load_verify_locations()\n    :param tls_in_tls:\n        Use SSLTransport to wrap the existing socket.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        # Note: This branch of code and all the variables in it are only used in tests.\n        # We should consider deprecating and removing this code.\n        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n\n    if ca_certs or ca_cert_dir or ca_cert_data:\n        try:\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n        except OSError as e:\n            raise SSLError(e) from e\n\n    elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n        # try to load OS default certs; works well on Windows.\n        context.load_default_certs()\n\n    # Attempt to detect if we get the goofy behavior of the\n    # keyfile being encrypted and OpenSSL asking for the\n    # passphrase via the terminal and instead error out.\n    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n        raise SSLError(\"Client private key is encrypted, password is required\")\n\n    if certfile:\n        if key_password is None:\n            context.load_cert_chain(certfile, keyfile)\n        else:\n            context.load_cert_chain(certfile, keyfile, key_password)\n\n    try:\n        context.set_alpn_protocols(ALPN_PROTOCOLS)\n    except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols\n        pass\n\n    ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls, server_hostname)\n    return ssl_sock\n\n\ndef is_ipaddress(hostname: str | bytes) -> bool:\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(_IPV4_RE.match(hostname) or _BRACELESS_IPV6_ADDRZ_RE.match(hostname))\n\n\ndef _is_key_file_encrypted(key_file: str) -> bool:\n    \"\"\"Detects if a key file is encrypted or not.\"\"\"\n    with open(key_file) as f:\n        for line in f:\n            # Look for Proc-Type: 4,ENCRYPTED\n            if \"ENCRYPTED\" in line:\n                return True\n\n    return False\n\n\ndef _ssl_wrap_socket_impl(\n    sock: socket.socket,\n    ssl_context: ssl.SSLContext,\n    tls_in_tls: bool,\n    server_hostname: str | None = None,\n) -> ssl.SSLSocket | SSLTransportType:\n    if tls_in_tls:\n        if not SSLTransport:\n            # Import error, ssl is not available.\n            raise ProxySchemeUnsupported(\n                \"TLS in TLS requires support for the 'ssl' module\"\n            )\n\n        SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)\n        return SSLTransport(sock, ssl_context, server_hostname)\n\n    return ssl_context.wrap_socket(sock, server_hostname=server_hostname)\n", "dummyserver/hypercornserver.py": "from __future__ import annotations\n\nimport concurrent.futures\nimport contextlib\nimport functools\nimport sys\nimport threading\nfrom typing import Generator\n\nimport hypercorn\nimport hypercorn.trio\nimport hypercorn.typing\nimport trio\nfrom quart_trio import QuartTrio\n\n\n# https://github.com/pgjones/hypercorn/blob/19dfb96411575a6a647cdea63fa581b48ebb9180/src/hypercorn/utils.py#L172-L178\nasync def graceful_shutdown(shutdown_event: threading.Event) -> None:\n    while True:\n        if shutdown_event.is_set():\n            return\n        await trio.sleep(0.1)\n\n\nasync def _start_server(\n    config: hypercorn.Config,\n    app: QuartTrio,\n    ready_event: threading.Event,\n    shutdown_event: threading.Event,\n) -> None:\n    async with trio.open_nursery() as nursery:\n        config.bind = await nursery.start(\n            functools.partial(\n                hypercorn.trio.serve,\n                app,\n                config,\n                shutdown_trigger=functools.partial(graceful_shutdown, shutdown_event),\n            )\n        )\n        ready_event.set()\n\n\n@contextlib.contextmanager\ndef run_hypercorn_in_thread(\n    config: hypercorn.Config, app: hypercorn.typing.ASGIFramework\n) -> Generator[None, None, None]:\n    ready_event = threading.Event()\n    shutdown_event = threading.Event()\n\n    with concurrent.futures.ThreadPoolExecutor(\n        1, thread_name_prefix=\"hypercorn dummyserver\"\n    ) as executor:\n        future = executor.submit(\n            trio.run,\n            _start_server,\n            config,\n            app,\n            ready_event,\n            shutdown_event,\n        )\n        ready_event.wait(5)\n        if not ready_event.is_set():\n            raise Exception(\"most likely failed to start server\")\n\n        try:\n            yield\n        finally:\n            shutdown_event.set()\n            future.result()\n\n\ndef main() -> int:\n    # For debugging dummyserver itself - PYTHONPATH=src python -m dummyserver.hypercornserver\n    from .app import hypercorn_app\n\n    config = hypercorn.Config()\n    config.bind = [\"localhost:0\"]\n    ready_event = threading.Event()\n    shutdown_event = threading.Event()\n    trio.run(_start_server, config, hypercorn_app, ready_event, shutdown_event)\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "dummyserver/asgi_proxy.py": "from __future__ import annotations\n\nimport typing\n\nimport httpx\nimport trio\nfrom hypercorn.typing import (\n    ASGIReceiveCallable,\n    ASGISendCallable,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n    Scope,\n)\n\n\nasync def _read_body(receive: ASGIReceiveCallable) -> bytes:\n    body = bytearray()\n    body_consumed = False\n    while not body_consumed:\n        event = await receive()\n        if event[\"type\"] == \"http.request\":\n            body.extend(event[\"body\"])\n            body_consumed = not event[\"more_body\"]\n        else:\n            raise ValueError(event[\"type\"])\n    return bytes(body)\n\n\nclass ProxyApp:\n    def __init__(self, upstream_ca_certs: str | None = None):\n        self.upstream_ca_certs = upstream_ca_certs\n\n    async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -> None:\n        assert scope[\"type\"] == \"http\"\n        if scope[\"method\"] in [\"GET\", \"POST\"]:\n            await self.absolute_uri(scope, receive, send)\n        elif scope[\"method\"] == \"CONNECT\":\n            await self.connect(scope, send)\n        else:\n            raise ValueError(scope[\"method\"])\n\n    async def absolute_uri(\n        self,\n        scope: HTTPScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -> None:\n        async with httpx.AsyncClient(verify=self.upstream_ca_certs or True) as client:\n            client_response = await client.request(\n                method=scope[\"method\"],\n                url=scope[\"path\"],\n                headers=list(scope[\"headers\"]),\n                content=await _read_body(receive),\n            )\n\n        headers = []\n        for header in (\n            \"Date\",\n            \"Cache-Control\",\n            \"Server\",\n            \"Content-Type\",\n            \"Location\",\n        ):\n            v = client_response.headers.get(header)\n            if v:\n                headers.append((header.encode(), v.encode()))\n        headers.append((b\"Content-Length\", str(len(client_response.content)).encode()))\n\n        await send(\n            HTTPResponseStartEvent(\n                type=\"http.response.start\",\n                status=client_response.status_code,\n                headers=headers,\n            )\n        )\n        await send(\n            HTTPResponseBodyEvent(\n                type=\"http.response.body\",\n                body=client_response.content,\n                more_body=False,\n            )\n        )\n\n    async def connect(self, scope: HTTPScope, send: ASGISendCallable) -> None:\n        async def start_forward(\n            reader: trio.SocketStream, writer: trio.SocketStream\n        ) -> None:\n            while True:\n                try:\n                    data = await reader.receive_some(4096)\n                except trio.ClosedResourceError:\n                    break\n                if not data:\n                    break\n                await writer.send_all(data)\n            await writer.aclose()\n\n        host, port = scope[\"path\"].split(\":\")\n        async with await trio.open_tcp_stream(host, int(port)) as upstream:\n            await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": True})\n\n            client = typing.cast(trio.SocketStream, scope[\"extensions\"][\"_transport\"])\n\n            async with trio.open_nursery(strict_exception_groups=True) as nursery:\n                nursery.start_soon(start_forward, client, upstream)\n                nursery.start_soon(start_forward, upstream, client)\n", "dummyserver/socketserver.py": "#!/usr/bin/env python\n\n\"\"\"\nDummy server used for unit testing.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport socket\nimport ssl\nimport sys\nimport threading\nimport typing\nimport warnings\n\nimport trustme\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\n\nfrom urllib3.exceptions import HTTPWarning\nfrom urllib3.util import resolve_cert_reqs, resolve_ssl_version\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import ParamSpec\n\n    P = ParamSpec(\"P\")\n\nlog = logging.getLogger(__name__)\n\nCERTS_PATH = os.path.join(os.path.dirname(__file__), \"certs\")\nDEFAULT_CERTS: dict[str, typing.Any] = {\n    \"certfile\": os.path.join(CERTS_PATH, \"server.crt\"),\n    \"keyfile\": os.path.join(CERTS_PATH, \"server.key\"),\n    \"cert_reqs\": ssl.CERT_OPTIONAL,\n    \"ca_certs\": os.path.join(CERTS_PATH, \"cacert.pem\"),\n    \"alpn_protocols\": [\"h2\", \"http/1.1\"],\n}\nDEFAULT_CA = os.path.join(CERTS_PATH, \"cacert.pem\")\nDEFAULT_CA_KEY = os.path.join(CERTS_PATH, \"cacert.key\")\n\n\ndef _resolves_to_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system resolves host to an IPv6 address by default.\"\"\"\n    resolves_to_ipv6 = False\n    try:\n        for res in socket.getaddrinfo(host, None, socket.AF_UNSPEC):\n            af, _, _, _, _ = res\n            if af == socket.AF_INET6:\n                resolves_to_ipv6 = True\n    except socket.gaierror:\n        pass\n\n    return resolves_to_ipv6\n\n\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        # has_ipv6 returns true if cPython was compiled with IPv6 support.\n        # It does not tell us if the system has IPv6 support enabled. To\n        # determine that we must bind to an IPv6 address.\n        # https://github.com/urllib3/urllib3/pull/611\n        # https://bugs.python.org/issue658327\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = _resolves_to_ipv6(\"localhost\")\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6\n\n\n# Some systems may have IPv6 support but DNS may not be configured\n# properly. We can not count that localhost will resolve to ::1 on all\n# systems. See https://github.com/urllib3/urllib3/pull/611 and\n# https://bugs.python.org/issue18792\nHAS_IPV6_AND_DNS = _has_ipv6(\"localhost\")\nHAS_IPV6 = _has_ipv6(\"::1\")\n\n\n# Different types of servers we have:\n\n\nclass NoIPv6Warning(HTTPWarning):\n    \"IPv6 is not available\"\n\n\nclass SocketServerThread(threading.Thread):\n    \"\"\"\n    :param socket_handler: Callable which receives a socket argument for one\n        request.\n    :param ready_event: Event which gets set when the socket handler is\n        ready to receive requests.\n    \"\"\"\n\n    USE_IPV6 = HAS_IPV6_AND_DNS\n\n    def __init__(\n        self,\n        socket_handler: typing.Callable[[socket.socket], None],\n        host: str = \"localhost\",\n        ready_event: threading.Event | None = None,\n        quit_event: threading.Event | None = None,\n    ) -> None:\n        super().__init__()\n        self.daemon = True\n\n        self.socket_handler = socket_handler\n        self.host = host\n        self.ready_event = ready_event\n        self.quit_event = quit_event\n\n    def _start_server(self) -> None:\n        if self.USE_IPV6:\n            sock = socket.socket(socket.AF_INET6)\n        else:\n            warnings.warn(\"No IPv6 support. Falling back to IPv4.\", NoIPv6Warning)\n            sock = socket.socket(socket.AF_INET)\n        if sys.platform != \"win32\":\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        with sock:\n            sock.bind((self.host, 0))\n            self.port = sock.getsockname()[1]\n\n            # Once listen() returns, the server socket is ready\n            sock.listen(1)\n\n            if self.ready_event:\n                self.ready_event.set()\n\n            self.socket_handler(sock)\n\n    def run(self) -> None:\n        self._start_server()\n\n\ndef ssl_options_to_context(  # type: ignore[no-untyped-def]\n    keyfile=None,\n    certfile=None,\n    server_side=None,\n    cert_reqs=None,\n    ssl_version: str | int | None = None,\n    ca_certs=None,\n    do_handshake_on_connect=None,\n    suppress_ragged_eofs=None,\n    ciphers=None,\n    alpn_protocols=None,\n) -> ssl.SSLContext:\n    \"\"\"Return an equivalent SSLContext based on ssl.wrap_socket args.\"\"\"\n    ssl_version = resolve_ssl_version(ssl_version)\n    cert_none = resolve_cert_reqs(\"CERT_NONE\")\n    if cert_reqs is None:\n        cert_reqs = cert_none\n    else:\n        cert_reqs = resolve_cert_reqs(cert_reqs)\n\n    ctx = ssl.SSLContext(ssl_version)\n    ctx.load_cert_chain(certfile, keyfile)\n    ctx.verify_mode = cert_reqs\n    if ctx.verify_mode != cert_none:\n        ctx.load_verify_locations(cafile=ca_certs)\n    if alpn_protocols and hasattr(ctx, \"set_alpn_protocols\"):\n        try:\n            ctx.set_alpn_protocols(alpn_protocols)\n        except NotImplementedError:\n            pass\n    return ctx\n\n\ndef get_unreachable_address() -> tuple[str, int]:\n    # reserved as per rfc2606\n    return (\"something.invalid\", 54321)\n\n\ndef encrypt_key_pem(private_key_pem: trustme.Blob, password: bytes) -> trustme.Blob:\n    private_key = serialization.load_pem_private_key(\n        private_key_pem.bytes(), password=None, backend=default_backend()\n    )\n    encrypted_key = private_key.private_bytes(\n        serialization.Encoding.PEM,\n        serialization.PrivateFormat.TraditionalOpenSSL,\n        serialization.BestAvailableEncryption(password),\n    )\n    return trustme.Blob(encrypted_key)\n", "dummyserver/__init__.py": "", "dummyserver/app.py": "from __future__ import annotations\n\nimport collections\nimport contextlib\nimport datetime\nimport email.utils\nimport gzip\nimport mimetypes\nimport zlib\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Iterator\n\nimport trio\nfrom quart import Response, make_response, request\nfrom quart.typing import ResponseReturnValue\nfrom quart_trio import QuartTrio\n\nhypercorn_app = QuartTrio(__name__)\n\n# Globals are not safe in Flask/Quart but work for our Hypercorn use case\nRETRY_TEST_NAMES: collections.Counter[str] = collections.Counter()\nLAST_RETRY_AFTER_REQ: datetime.datetime = datetime.datetime.min\n\n\npyodide_testing_app = QuartTrio(__name__)\nDEFAULT_HEADERS = [\n    # Allow cross-origin requests for emscripten\n    (\"Access-Control-Allow-Origin\", \"*\"),\n    (\"Cross-Origin-Opener-Policy\", \"same-origin\"),\n    (\"Cross-Origin-Embedder-Policy\", \"require-corp\"),\n    (\"Feature-Policy\", \"sync-xhr *;\"),\n    (\"Access-Control-Allow-Headers\", \"*\"),\n]\n\n\n@hypercorn_app.route(\"/\")\n@pyodide_testing_app.route(\"/\")\n@pyodide_testing_app.route(\"/index\")\nasync def index() -> ResponseReturnValue:\n    return await make_response(\"Dummy server!\")\n\n\n@hypercorn_app.route(\"/alpn_protocol\")\nasync def alpn_protocol() -> ResponseReturnValue:\n    \"\"\"Return the requester's certificate.\"\"\"\n    alpn_protocol = request.scope[\"extensions\"][\"tls\"][\"alpn_protocol\"]\n    return await make_response(alpn_protocol)\n\n\n@hypercorn_app.route(\"/certificate\")\nasync def certificate() -> ResponseReturnValue:\n    \"\"\"Return the requester's certificate.\"\"\"\n    print(\"scope\", request.scope)\n    subject = request.scope[\"extensions\"][\"tls\"][\"client_cert_name\"]\n    subject_as_dict = dict(part.split(\"=\") for part in subject.split(\", \"))\n    return await make_response(subject_as_dict)\n\n\n@hypercorn_app.route(\"/specific_method\", methods=[\"GET\", \"POST\", \"PUT\"])\n@pyodide_testing_app.route(\"/specific_method\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def specific_method() -> ResponseReturnValue:\n    \"Confirm that the request matches the desired method type\"\n    method_param = (await request.values).get(\"method\", \"\")\n\n    if request.method.upper() == method_param.upper():\n        return await make_response(\"\", 200)\n    else:\n        return await make_response(\n            f\"Wrong method: {method_param} != {request.method}\", 400\n        )\n\n\n@hypercorn_app.route(\"/upload\", methods=[\"POST\"])\nasync def upload() -> ResponseReturnValue:\n    \"Confirm that the uploaded file conforms to specification\"\n    params = await request.form\n    param = params.get(\"upload_param\")\n    filename_param = params.get(\"upload_filename\")\n    size = int(params.get(\"upload_size\", \"0\"))\n    files_ = (await request.files).getlist(param)\n    assert files_ is not None\n\n    if len(files_) != 1:\n        return await make_response(\n            f\"Expected 1 file for '{param}', not {len(files_)}\", 400\n        )\n\n    file_ = files_[0]\n    # data is short enough to read synchronously without blocking the event loop\n    with contextlib.closing(file_.stream) as stream:\n        data = stream.read()\n\n    if int(size) != len(data):\n        return await make_response(f\"Wrong size: {int(size)} != {len(data)}\", 400)\n\n    if filename_param != file_.filename:\n        return await make_response(\n            f\"Wrong filename: {filename_param} != {file_.filename}\", 400\n        )\n\n    return await make_response()\n\n\n@hypercorn_app.route(\"/chunked\")\nasync def chunked() -> ResponseReturnValue:\n    def generate() -> Iterator[str]:\n        for _ in range(4):\n            yield \"123\"\n\n    return await make_response(generate())\n\n\n@hypercorn_app.route(\"/chunked_gzip\")\nasync def chunked_gzip() -> ResponseReturnValue:\n    def generate() -> Iterator[bytes]:\n        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n\n        for uncompressed in [b\"123\"] * 4:\n            yield compressor.compress(uncompressed)\n        yield compressor.flush()\n\n    return await make_response(generate(), 200, [(\"Content-Encoding\", \"gzip\")])\n\n\n@hypercorn_app.route(\"/keepalive\")\nasync def keepalive() -> ResponseReturnValue:\n    if request.args.get(\"close\", b\"0\") == b\"1\":\n        headers = [(\"Connection\", \"close\")]\n        return await make_response(\"Closing\", 200, headers)\n\n    headers = [(\"Connection\", \"keep-alive\")]\n    return await make_response(\"Keeping alive\", 200, headers)\n\n\n@hypercorn_app.route(\"/echo\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def echo() -> ResponseReturnValue:\n    \"Echo back the params\"\n    if request.method == \"GET\":\n        return await make_response(request.query_string)\n\n    return await make_response(await request.get_data())\n\n\n@hypercorn_app.route(\"/echo_json\", methods=[\"POST\"])\n@pyodide_testing_app.route(\"/echo_json\", methods=[\"POST\", \"OPTIONS\"])\nasync def echo_json() -> ResponseReturnValue:\n    \"Echo back the JSON\"\n    if request.method == \"OPTIONS\":\n        return await make_response(\"\", 200)\n    data = await request.get_data()\n    return await make_response(data, 200, request.headers)\n\n\n@hypercorn_app.route(\"/echo_uri/<path:rest>\")\n@hypercorn_app.route(\"/echo_uri\", defaults={\"rest\": \"\"})\nasync def echo_uri(rest: str) -> ResponseReturnValue:\n    \"Echo back the requested URI\"\n    assert request.full_path is not None\n    return await make_response(request.full_path)\n\n\n@hypercorn_app.route(\"/echo_params\")\nasync def echo_params() -> ResponseReturnValue:\n    \"Echo back the query parameters\"\n    await request.get_data()\n    echod = sorted((k, v) for k, v in request.args.items())\n    return await make_response(repr(echod))\n\n\n@hypercorn_app.route(\"/headers\", methods=[\"GET\", \"POST\"])\nasync def headers() -> ResponseReturnValue:\n    return await make_response(dict(request.headers.items()))\n\n\n@hypercorn_app.route(\"/headers_and_params\")\nasync def headers_and_params() -> ResponseReturnValue:\n    return await make_response(\n        {\n            \"headers\": dict(request.headers),\n            \"params\": request.args,\n        }\n    )\n\n\n@hypercorn_app.route(\"/multi_headers\", methods=[\"GET\", \"POST\"])\nasync def multi_headers() -> ResponseReturnValue:\n    return await make_response({\"headers\": list(request.headers)})\n\n\n@hypercorn_app.route(\"/multi_redirect\")\nasync def multi_redirect() -> ResponseReturnValue:\n    \"Performs a redirect chain based on ``redirect_codes``\"\n    params = request.args\n    codes = params.get(\"redirect_codes\", \"200\")\n    head, tail = codes.split(\",\", 1) if \",\" in codes else (codes, None)\n    assert head is not None\n    status = head\n    if not tail:\n        return await make_response(\"Done redirecting\", status)\n\n    headers = [(\"Location\", f\"/multi_redirect?redirect_codes={tail}\")]\n    return await make_response(\"\", status, headers)\n\n\n@hypercorn_app.route(\"/encodingrequest\")\nasync def encodingrequest() -> ResponseReturnValue:\n    \"Check for UA accepting gzip/deflate encoding\"\n    data = b\"hello, world!\"\n    encoding = request.headers.get(\"Accept-Encoding\", \"\")\n    headers = []\n    if encoding == \"gzip\":\n        headers = [(\"Content-Encoding\", \"gzip\")]\n        file_ = BytesIO()\n        with contextlib.closing(gzip.GzipFile(\"\", mode=\"w\", fileobj=file_)) as zipfile:\n            zipfile.write(data)\n        data = file_.getvalue()\n    elif encoding == \"deflate\":\n        headers = [(\"Content-Encoding\", \"deflate\")]\n        data = zlib.compress(data)\n    elif encoding == \"garbage-gzip\":\n        headers = [(\"Content-Encoding\", \"gzip\")]\n        data = b\"garbage\"\n    elif encoding == \"garbage-deflate\":\n        headers = [(\"Content-Encoding\", \"deflate\")]\n        data = b\"garbage\"\n    return await make_response(data, 200, headers)\n\n\n@hypercorn_app.route(\"/redirect\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def redirect() -> ResponseReturnValue:\n    \"Perform a redirect to ``target``\"\n    values = await request.values\n    target = values.get(\"target\", \"/\")\n    status = values.get(\"status\", \"303 See Other\")\n    status_code = status.split(\" \")[0]\n\n    headers = [(\"Location\", target)]\n    return await make_response(\"\", status_code, headers)\n\n\n@hypercorn_app.route(\"/redirect_after\")\nasync def redirect_after() -> ResponseReturnValue:\n    \"Perform a redirect to ``target``\"\n    params = request.args\n    date = params.get(\"date\")\n    if date:\n        dt = datetime.datetime.fromtimestamp(float(date), tz=datetime.timezone.utc)\n        http_dt = email.utils.format_datetime(dt, usegmt=True)\n        retry_after = str(http_dt)\n    else:\n        retry_after = \"1\"\n    target = params.get(\"target\", \"/\")\n    headers = [(\"Location\", target), (\"Retry-After\", retry_after)]\n    return await make_response(\"\", 303, headers)\n\n\n@hypercorn_app.route(\"/retry_after\")\nasync def retry_after() -> ResponseReturnValue:\n    global LAST_RETRY_AFTER_REQ\n    params = request.args\n    if datetime.datetime.now() - LAST_RETRY_AFTER_REQ < datetime.timedelta(seconds=1):\n        status = params.get(\"status\", \"429 Too Many Requests\")\n        status_code = status.split(\" \")[0]\n\n        return await make_response(\"\", status_code, [(\"Retry-After\", \"1\")])\n\n    LAST_RETRY_AFTER_REQ = datetime.datetime.now()\n    return await make_response(\"\", 200)\n\n\n@hypercorn_app.route(\"/status\")\n@pyodide_testing_app.route(\"/status\")\nasync def status() -> ResponseReturnValue:\n    values = await request.values\n    status = values.get(\"status\", \"200 OK\")\n    status_code = status.split(\" \")[0]\n    return await make_response(\"\", status_code)\n\n\n@hypercorn_app.route(\"/source_address\")\nasync def source_address() -> ResponseReturnValue:\n    \"\"\"Return the requester's IP address.\"\"\"\n    return await make_response(request.remote_addr)\n\n\n@hypercorn_app.route(\"/successful_retry\", methods=[\"GET\", \"PUT\"])\nasync def successful_retry() -> ResponseReturnValue:\n    \"\"\"First return an error and then success\n\n    It's not currently very flexible as the number of retries is hard-coded.\n    \"\"\"\n    test_name = request.headers.get(\"test-name\", None)\n    if not test_name:\n        return await make_response(\"test-name header not set\", 400)\n\n    RETRY_TEST_NAMES[test_name] += 1\n\n    if RETRY_TEST_NAMES[test_name] >= 2:\n        return await make_response(\"Retry successful!\", 200)\n    else:\n        return await make_response(\"need to keep retrying!\", 418)\n\n\n@pyodide_testing_app.after_request\ndef apply_caching(response: Response) -> ResponseReturnValue:\n    for header, value in DEFAULT_HEADERS:\n        response.headers[header] = value\n    return response\n\n\n@pyodide_testing_app.route(\"/slow\")\nasync def slow() -> ResponseReturnValue:\n    await trio.sleep(10)\n    return await make_response(\"TEN SECONDS LATER\", 200)\n\n\n@pyodide_testing_app.route(\"/bigfile\")\nasync def bigfile() -> ResponseReturnValue:\n    # great big text file, should force streaming\n    # if supported\n    bigdata = 1048576 * b\"WOOO YAY BOOYAKAH\"\n    return await make_response(bigdata, 200)\n\n\n@pyodide_testing_app.route(\"/mediumfile\")\nasync def mediumfile() -> ResponseReturnValue:\n    # quite big file\n    bigdata = 1024 * b\"WOOO YAY BOOYAKAH\"\n    return await make_response(bigdata, 200)\n\n\n@pyodide_testing_app.route(\"/upload\", methods=[\"POST\", \"OPTIONS\"])\nasync def pyodide_upload() -> ResponseReturnValue:\n    if request.method == \"OPTIONS\":\n        return await make_response(\"\", 200)\n    spare_data = await request.get_data(parse_form_data=True)\n    if len(spare_data) != 0:\n        return await make_response(\"Bad upload data\", 404)\n    files = await request.files\n    form = await request.form\n    if form[\"upload_param\"] != \"filefield\" or form[\"upload_filename\"] != \"lolcat.txt\":\n        return await make_response(\"Bad upload form values\", 404)\n    if len(files) != 1 or files.get(\"filefield\") is None:\n        return await make_response(\"Missing file in form\", 404)\n    file = files[\"filefield\"]\n    if file.filename != \"lolcat.txt\":\n        return await make_response(f\"File name incorrect {file.name}\", 404)\n    with contextlib.closing(file):\n        data = file.read().decode(\"utf-8\")\n    if data != \"I'm in ur multipart form-data, hazing a cheezburgr\":\n        return await make_response(f\"File data incorrect {data}\", 200)\n    return await make_response(\"Uploaded file correct\", 200)\n\n\n@pyodide_testing_app.route(\"/pyodide/<py_file>\")\nasync def pyodide(py_file: str) -> ResponseReturnValue:\n    file_path = Path(pyodide_testing_app.config[\"pyodide_dist_dir\"], py_file)\n    if file_path.exists():\n        mime_type, encoding = mimetypes.guess_type(file_path)\n        if not mime_type:\n            mime_type = \"text/plain\"\n        return await make_response(\n            file_path.read_bytes(), 200, [(\"Content-Type\", mime_type)]\n        )\n    else:\n        return await make_response(\"\", 404)\n\n\n@pyodide_testing_app.route(\"/wheel/dist.whl\")\nasync def wheel() -> ResponseReturnValue:\n    # serve our wheel\n    wheel_folder = Path(__file__).parent.parent / \"dist\"\n    wheels = list(wheel_folder.glob(\"*.whl\"))\n    if len(wheels) > 0:\n        wheel = wheels[0]\n        headers = [(\"Content-Disposition\", f\"inline; filename='{wheel.name}'\")]\n        resp = await make_response(wheel.read_bytes(), 200, headers)\n        return resp\n    else:\n        return await make_response(f\"NO WHEEL IN {wheel_folder}\", 404)\n"}