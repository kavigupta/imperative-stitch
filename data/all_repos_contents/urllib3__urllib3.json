{"noxfile.py": "from __future__ import annotations\n\nimport os\nimport shutil\nimport sys\nimport typing\nfrom pathlib import Path\n\nimport nox\n\nnox.options.error_on_missing_interpreters = True\n\n\ndef tests_impl(\n    session: nox.Session,\n    extras: str = \"socks,brotli,zstd,h2\",\n    # hypercorn dependency h2 compares bytes and strings\n    # https://github.com/python-hyper/h2/issues/1236\n    byte_string_comparisons: bool = False,\n    integration: bool = False,\n    pytest_extra_args: list[str] = [],\n) -> None:\n    # Retrieve sys info from the Python implementation under test\n    # to avoid enabling memray when nox runs under CPython but tests PyPy\n    session_python_info = session.run(\n        \"python\",\n        \"-c\",\n        \"import sys; print(sys.implementation.name, sys.version_info.releaselevel)\",\n        silent=True,\n    ).strip()  # type: ignore[union-attr] # mypy doesn't know that silent=True  will return a string\n    implementation_name, release_level = session_python_info.split(\" \")\n\n    # zstd cannot be installed on CPython 3.13 yet because it pins\n    # an incompatible CFFI version.\n    # https://github.com/indygreg/python-zstandard/issues/210\n    if release_level != \"final\":\n        extras = extras.replace(\",zstd\", \"\")\n\n    # Install deps and the package itself.\n    session.install(\"-r\", \"dev-requirements.txt\")\n    session.install(f\".[{extras}]\")\n\n    # Show the pip version.\n    session.run(\"pip\", \"--version\")\n    # Print the Python version and bytesize.\n    session.run(\"python\", \"--version\")\n    session.run(\"python\", \"-c\", \"import struct; print(struct.calcsize('P') * 8)\")\n    # Print OpenSSL information.\n    session.run(\"python\", \"-m\", \"OpenSSL.debug\")\n\n    memray_supported = True\n    if implementation_name != \"cpython\" or release_level != \"final\":\n        memray_supported = False  # pytest-memray requires CPython 3.8+\n    elif sys.platform == \"win32\":\n        memray_supported = False\n\n    # Environment variables being passed to the pytest run.\n    pytest_session_envvars = {\n        \"PYTHONWARNINGS\": \"always::DeprecationWarning\",\n    }\n\n    # In coverage 7.4.0 we can only set the setting for Python 3.12+\n    # Future versions of coverage will use sys.monitoring based on availability.\n    if (\n        isinstance(session.python, str)\n        and \".\" in session.python\n        and int(session.python.split(\".\")[1]) >= 12\n    ):\n        pytest_session_envvars[\"COVERAGE_CORE\"] = \"sysmon\"\n\n    # Inspired from https://hynek.me/articles/ditch-codecov-python/\n    # We use parallel mode and then combine in a later CI step\n    session.run(\n        \"python\",\n        *((\"-bb\",) if byte_string_comparisons else ()),\n        \"-m\",\n        \"coverage\",\n        \"run\",\n        \"--parallel-mode\",\n        \"-m\",\n        \"pytest\",\n        *(\"--memray\", \"--hide-memray-summary\") if memray_supported else (),\n        \"-v\",\n        \"-ra\",\n        *((\"--integration\",) if integration else ()),\n        f\"--color={'yes' if 'GITHUB_ACTIONS' in os.environ else 'auto'}\",\n        \"--tb=native\",\n        \"--durations=10\",\n        \"--strict-config\",\n        \"--strict-markers\",\n        \"--disable-socket\",\n        \"--allow-unix-socket\",\n        \"--allow-hosts=localhost,::1,127.0.0.0,240.0.0.0\",  # See `TARPIT_HOST`\n        *pytest_extra_args,\n        *(session.posargs or (\"test/\",)),\n        env=pytest_session_envvars,\n    )\n\n\n@nox.session(\n    python=[\n        \"3.8\",\n        \"3.9\",\n        \"3.10\",\n        \"3.11\",\n        \"3.12\",\n        \"3.13\",\n        \"pypy3.8\",\n        \"pypy3.9\",\n        \"pypy3.10\",\n    ]\n)\ndef test(session: nox.Session) -> None:\n    tests_impl(session)\n\n\n@nox.session(python=\"3\")\ndef test_integration(session: nox.Session) -> None:\n    \"\"\"Run integration tests\"\"\"\n    tests_impl(session, integration=True)\n\n\n@nox.session(python=\"3\")\ndef test_brotlipy(session: nox.Session) -> None:\n    \"\"\"Check that if 'brotlipy' is installed instead of 'brotli' or\n    'brotlicffi' that we still don't blow up.\n    \"\"\"\n    session.install(\"brotlipy\")\n    tests_impl(session, extras=\"socks\", byte_string_comparisons=False)\n\n\ndef git_clone(session: nox.Session, git_url: str) -> None:\n    \"\"\"We either clone the target repository or if already exist\n    simply reset the state and pull.\n    \"\"\"\n    expected_directory = git_url.split(\"/\")[-1]\n\n    if expected_directory.endswith(\".git\"):\n        expected_directory = expected_directory[:-4]\n\n    if not os.path.isdir(expected_directory):\n        session.run(\"git\", \"clone\", \"--depth\", \"1\", git_url, external=True)\n    else:\n        session.run(\n            \"git\", \"-C\", expected_directory, \"reset\", \"--hard\", \"HEAD\", external=True\n        )\n        session.run(\"git\", \"-C\", expected_directory, \"pull\", external=True)\n\n\n@nox.session()\ndef downstream_botocore(session: nox.Session) -> None:\n    root = os.getcwd()\n    tmp_dir = session.create_tmp()\n\n    session.cd(tmp_dir)\n    git_clone(session, \"https://github.com/boto/botocore\")\n    session.chdir(\"botocore\")\n    session.run(\"git\", \"rev-parse\", \"HEAD\", external=True)\n    session.run(\"python\", \"scripts/ci/install\")\n\n    session.cd(root)\n    session.install(\".\", silent=False)\n    session.cd(f\"{tmp_dir}/botocore\")\n\n    session.run(\"python\", \"-c\", \"import urllib3; print(urllib3.__version__)\")\n    session.run(\"python\", \"scripts/ci/run-tests\")\n\n\n@nox.session()\ndef downstream_requests(session: nox.Session) -> None:\n    root = os.getcwd()\n    tmp_dir = session.create_tmp()\n\n    session.cd(tmp_dir)\n    git_clone(session, \"https://github.com/psf/requests\")\n    session.chdir(\"requests\")\n    session.run(\"git\", \"rev-parse\", \"HEAD\", external=True)\n    session.install(\".[socks]\", silent=False)\n    session.install(\"-r\", \"requirements-dev.txt\", silent=False)\n\n    session.cd(root)\n    session.install(\".\", silent=False)\n    session.cd(f\"{tmp_dir}/requests\")\n\n    session.run(\"python\", \"-c\", \"import urllib3; print(urllib3.__version__)\")\n    session.run(\"pytest\", \"tests\")\n\n\n@nox.session()\ndef format(session: nox.Session) -> None:\n    \"\"\"Run code formatters.\"\"\"\n    lint(session)\n\n\n@nox.session(python=\"3.12\")\ndef lint(session: nox.Session) -> None:\n    session.install(\"pre-commit\")\n    session.run(\"pre-commit\", \"run\", \"--all-files\")\n\n    mypy(session)\n\n\n@nox.session(python=\"3.11\")\ndef pyodideconsole(session: nox.Session) -> None:\n    # build wheel into dist folder\n    session.install(\"build\")\n    session.run(\"python\", \"-m\", \"build\")\n    session.run(\n        \"cp\",\n        \"test/contrib/emscripten/templates/pyodide-console.html\",\n        \"dist/index.html\",\n        external=True,\n    )\n    session.cd(\"dist\")\n    session.run(\"python\", \"-m\", \"http.server\")\n\n\n# TODO: node support is not tested yet - it should work if you require('xmlhttprequest') before\n# loading pyodide, but there is currently no nice way to do this with pytest-pyodide\n# because you can't override the test runner properties easily - see\n# https://github.com/pyodide/pytest-pyodide/issues/118 for more\n@nox.session(python=\"3.11\")\n@nox.parametrize(\"runner\", [\"firefox\", \"chrome\"])\ndef emscripten(session: nox.Session, runner: str) -> None:\n    \"\"\"Test on Emscripten with Pyodide & Chrome / Firefox\"\"\"\n    session.install(\"-r\", \"emscripten-requirements.txt\")\n    # build wheel into dist folder\n    session.run(\"python\", \"-m\", \"build\")\n    # make sure we have a dist dir for pyodide\n    dist_dir = None\n    if \"PYODIDE_ROOT\" in os.environ:\n        # we have a pyodide build tree checked out\n        # use the dist directory from that\n        dist_dir = Path(os.environ[\"PYODIDE_ROOT\"]) / \"dist\"\n    else:\n        # we don't have a build tree, get one\n        # that matches the version of pyodide build\n        pyodide_version = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"import pyodide_build;print(pyodide_build.__version__)\",\n                silent=True,\n            ),\n        ).strip()\n\n        pyodide_artifacts_path = Path(session.cache_dir) / f\"pyodide-{pyodide_version}\"\n        if not pyodide_artifacts_path.exists():\n            print(\"Fetching pyodide build artifacts\")\n            session.run(\n                \"wget\",\n                f\"https://github.com/pyodide/pyodide/releases/download/{pyodide_version}/pyodide-{pyodide_version}.tar.bz2\",\n                \"-O\",\n                f\"{pyodide_artifacts_path}.tar.bz2\",\n            )\n            pyodide_artifacts_path.mkdir(parents=True)\n            session.run(\n                \"tar\",\n                \"-xjf\",\n                f\"{pyodide_artifacts_path}.tar.bz2\",\n                \"-C\",\n                str(pyodide_artifacts_path),\n                \"--strip-components\",\n                \"1\",\n            )\n\n        dist_dir = pyodide_artifacts_path\n    assert dist_dir is not None\n    assert dist_dir.exists()\n    if runner == \"chrome\":\n        # install chrome webdriver and add it to path\n        driver = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"from webdriver_manager.chrome import ChromeDriverManager;print(ChromeDriverManager().install())\",\n                silent=True,\n            ),\n        ).strip()\n        session.env[\"PATH\"] = f\"{Path(driver).parent}:{session.env['PATH']}\"\n\n        tests_impl(\n            session,\n            pytest_extra_args=[\n                \"--rt\",\n                \"chrome-no-host\",\n                \"--dist-dir\",\n                str(dist_dir),\n                \"test\",\n            ],\n        )\n    elif runner == \"firefox\":\n        driver = typing.cast(\n            str,\n            session.run(\n                \"python\",\n                \"-c\",\n                \"from webdriver_manager.firefox import GeckoDriverManager;print(GeckoDriverManager().install())\",\n                silent=True,\n            ),\n        ).strip()\n        session.env[\"PATH\"] = f\"{Path(driver).parent}:{session.env['PATH']}\"\n\n        tests_impl(\n            session,\n            pytest_extra_args=[\n                \"--rt\",\n                \"firefox-no-host\",\n                \"--dist-dir\",\n                str(dist_dir),\n                \"test\",\n            ],\n        )\n    else:\n        raise ValueError(f\"Unknown runner: {runner}\")\n\n\n@nox.session(python=\"3.12\")\ndef mypy(session: nox.Session) -> None:\n    \"\"\"Run mypy.\"\"\"\n    session.install(\"-r\", \"mypy-requirements.txt\")\n    session.run(\"mypy\", \"--version\")\n    session.run(\n        \"mypy\",\n        \"-p\",\n        \"dummyserver\",\n        \"-m\",\n        \"noxfile\",\n        \"-p\",\n        \"urllib3\",\n        \"-p\",\n        \"test\",\n    )\n\n\n@nox.session\ndef docs(session: nox.Session) -> None:\n    session.install(\"-r\", \"docs/requirements.txt\")\n    session.install(\".[socks,brotli,zstd]\")\n\n    session.chdir(\"docs\")\n    if os.path.exists(\"_build\"):\n        shutil.rmtree(\"_build\")\n    session.run(\"sphinx-build\", \"-b\", \"html\", \"-W\", \".\", \"_build/html\")\n", "test/test_collections.py": "from __future__ import annotations\n\nimport typing\n\nimport pytest\n\nfrom urllib3._collections import HTTPHeaderDict\nfrom urllib3._collections import RecentlyUsedContainer as Container\n\n\nclass TestLRUContainer:\n    def test_maxsize(self) -> None:\n        d: Container[int, str] = Container(5)\n\n        for i in range(5):\n            d[i] = str(i)\n\n        assert len(d) == 5\n\n        for i in range(5):\n            assert d[i] == str(i)\n\n        d[i + 1] = str(i + 1)\n\n        assert len(d) == 5\n        assert 0 not in d\n        assert (i + 1) in d\n\n    def test_maxsize_0(self) -> None:\n        d: Container[int, int] = Container(0)\n        d[1] = 1\n        assert len(d) == 0\n\n    def test_expire(self) -> None:\n        d: Container[int, str] = Container(5)\n\n        for i in range(5):\n            d[i] = str(i)\n\n        for i in range(5):\n            d.get(0)\n\n        # Add one more entry\n        d[5] = \"5\"\n\n        # Check state\n        assert list(d._container.keys()) == [2, 3, 4, 0, 5]\n\n    def test_same_key(self) -> None:\n        d: Container[str, int] = Container(5)\n\n        for i in range(10):\n            d[\"foo\"] = i\n\n        assert list(d._container.keys()) == [\"foo\"]\n        assert len(d) == 1\n\n    def test_access_ordering(self) -> None:\n        d: Container[int, bool] = Container(5)\n\n        for i in range(10):\n            d[i] = True\n\n        # Keys should be ordered by access time\n        assert list(d._container.keys()) == [5, 6, 7, 8, 9]\n\n        new_order = [7, 8, 6, 9, 5]\n        for k in new_order:\n            d[k]\n\n        assert list(d._container.keys()) == new_order\n\n    def test_delete(self) -> None:\n        d: Container[int, bool] = Container(5)\n\n        for i in range(5):\n            d[i] = True\n\n        del d[0]\n        assert 0 not in d\n\n        d.pop(1)\n        assert 1 not in d\n\n        d.pop(1, None)\n\n    def test_get(self) -> None:\n        d: Container[int, bool | int] = Container(5)\n\n        for i in range(5):\n            d[i] = True\n\n        r = d.get(4)\n        assert r is True\n\n        r = d.get(5)\n        assert r is None\n\n        r = d.get(5, 42)\n        assert r == 42\n\n        with pytest.raises(KeyError):\n            d[5]\n\n    def test_disposal(self) -> None:\n        evicted_items: list[int] = []\n\n        def dispose_func(arg: int) -> None:\n            # Save the evicted datum for inspection\n            evicted_items.append(arg)\n\n        d: Container[int, int] = Container(5, dispose_func=dispose_func)\n        for i in range(5):\n            d[i] = i\n        assert list(d._container.keys()) == list(range(5))\n        assert evicted_items == []  # Nothing disposed\n\n        d[5] = 5\n        assert list(d._container.keys()) == list(range(1, 6))\n        assert evicted_items == [0]\n\n        del d[1]\n        assert evicted_items == [0, 1]\n\n        d.clear()\n        assert evicted_items == [0, 1, 2, 3, 4, 5]\n\n    def test_iter(self) -> None:\n        d: Container[str, str] = Container()\n\n        with pytest.raises(NotImplementedError):\n            d.__iter__()\n\n\nclass NonMappingHeaderContainer:\n    def __init__(self, **kwargs: str) -> None:\n        self._data = {}\n        self._data.update(kwargs)\n\n    def keys(self) -> typing.Iterator[str]:\n        return iter(self._data)\n\n    def __getitem__(self, key: str) -> str:\n        return self._data[key]\n\n\n@pytest.fixture()\ndef d() -> HTTPHeaderDict:\n    header_dict = HTTPHeaderDict(Cookie=\"foo\")\n    header_dict.add(\"cookie\", \"bar\")\n    return header_dict\n\n\nclass TestHTTPHeaderDict:\n    def test_create_from_kwargs(self) -> None:\n        h = HTTPHeaderDict(ab=\"1\", cd=\"2\", ef=\"3\", gh=\"4\")\n        assert len(h) == 4\n        assert \"ab\" in h\n\n    def test_setdefault(self) -> None:\n        h = HTTPHeaderDict(a=\"1\")\n        assert h.setdefault(\"A\", \"3\") == \"1\"\n        assert h.setdefault(\"b\", \"2\") == \"2\"\n        assert h.setdefault(\"c\") == \"\"\n        assert h[\"c\"] == \"\"\n        assert h[\"b\"] == \"2\"\n\n    def test_create_from_dict(self) -> None:\n        h = HTTPHeaderDict(dict(ab=\"1\", cd=\"2\", ef=\"3\", gh=\"4\"))\n        assert len(h) == 4\n        assert \"ab\" in h\n\n    def test_create_from_iterator(self) -> None:\n        teststr = \"urllib3ontherocks\"\n        h = HTTPHeaderDict((c, c * 5) for c in teststr)\n        assert len(h) == len(set(teststr))\n\n    def test_create_from_list(self) -> None:\n        headers = [\n            (\"ab\", \"A\"),\n            (\"cd\", \"B\"),\n            (\"cookie\", \"C\"),\n            (\"cookie\", \"D\"),\n            (\"cookie\", \"E\"),\n        ]\n        h = HTTPHeaderDict(headers)\n        assert len(h) == 3\n        assert \"ab\" in h\n        clist = h.getlist(\"cookie\")\n        assert len(clist) == 3\n        assert clist[0] == \"C\"\n        assert clist[-1] == \"E\"\n\n    def test_create_from_headerdict(self) -> None:\n        headers = [\n            (\"ab\", \"A\"),\n            (\"cd\", \"B\"),\n            (\"cookie\", \"C\"),\n            (\"cookie\", \"D\"),\n            (\"cookie\", \"E\"),\n        ]\n        org = HTTPHeaderDict(headers)\n        h = HTTPHeaderDict(org)\n        assert len(h) == 3\n        assert \"ab\" in h\n        clist = h.getlist(\"cookie\")\n        assert len(clist) == 3\n        assert clist[0] == \"C\"\n        assert clist[-1] == \"E\"\n        assert h is not org\n        assert h == org\n\n    def test_setitem(self, d: HTTPHeaderDict) -> None:\n        d[\"Cookie\"] = \"foo\"\n        # The bytes value gets converted to str. The API is typed for str only,\n        # but the implementation continues supports bytes.\n        d[b\"Cookie\"] = \"bar\"  # type: ignore[index]\n        assert d[\"cookie\"] == \"bar\"\n        d[\"cookie\"] = \"with, comma\"\n        assert d.getlist(\"cookie\") == [\"with, comma\"]\n\n    def test_update(self, d: HTTPHeaderDict) -> None:\n        d.update(dict(Cookie=\"foo\"))\n        assert d[\"cookie\"] == \"foo\"\n        d.update(dict(cookie=\"with, comma\"))\n        assert d.getlist(\"cookie\") == [\"with, comma\"]\n\n    def test_delitem(self, d: HTTPHeaderDict) -> None:\n        del d[\"cookie\"]\n        assert \"cookie\" not in d\n        assert \"COOKIE\" not in d\n\n    def test_add_well_known_multiheader(self, d: HTTPHeaderDict) -> None:\n        d.add(\"COOKIE\", \"asdf\")\n        assert d.getlist(\"cookie\") == [\"foo\", \"bar\", \"asdf\"]\n        assert d[\"cookie\"] == \"foo, bar, asdf\"\n\n    def test_add_comma_separated_multiheader(self, d: HTTPHeaderDict) -> None:\n        d.add(\"bar\", \"foo\")\n        # The bytes value gets converted to str. The API is typed for str only,\n        # but the implementation continues supports bytes.\n        d.add(b\"BAR\", \"bar\")  # type: ignore[arg-type]\n        d.add(\"Bar\", \"asdf\")\n        assert d.getlist(\"bar\") == [\"foo\", \"bar\", \"asdf\"]\n        assert d[\"bar\"] == \"foo, bar, asdf\"\n\n    def test_extend_from_list(self, d: HTTPHeaderDict) -> None:\n        d.extend([(\"set-cookie\", \"100\"), (\"set-cookie\", \"200\"), (\"set-cookie\", \"300\")])\n        assert d[\"set-cookie\"] == \"100, 200, 300\"\n\n    def test_extend_from_dict(self, d: HTTPHeaderDict) -> None:\n        d.extend(dict(cookie=\"asdf\"), b=\"100\")\n        assert d[\"cookie\"] == \"foo, bar, asdf\"\n        assert d[\"b\"] == \"100\"\n        d.add(\"cookie\", \"with, comma\")\n        assert d.getlist(\"cookie\") == [\"foo\", \"bar\", \"asdf\", \"with, comma\"]\n\n    def test_extend_from_container(self, d: HTTPHeaderDict) -> None:\n        h = NonMappingHeaderContainer(Cookie=\"foo\", e=\"foofoo\")\n        d.extend(h)\n        assert d[\"cookie\"] == \"foo, bar, foo\"\n        assert d[\"e\"] == \"foofoo\"\n        assert len(d) == 2\n\n    def test_header_repeat(self, d: HTTPHeaderDict) -> None:\n        d[\"other-header\"] = \"hello\"\n        d.add(\"other-header\", \"world\")\n\n        assert list(d.items()) == [\n            (\"Cookie\", \"foo\"),\n            (\"Cookie\", \"bar\"),\n            (\"other-header\", \"hello\"),\n            (\"other-header\", \"world\"),\n        ]\n\n        d.add(\"other-header\", \"!\", combine=True)\n        expected_results = [\n            (\"Cookie\", \"foo\"),\n            (\"Cookie\", \"bar\"),\n            (\"other-header\", \"hello\"),\n            (\"other-header\", \"world, !\"),\n        ]\n\n        assert list(d.items()) == expected_results\n        # make sure the values persist over copies\n        assert list(d.copy().items()) == expected_results\n\n        other_dict = HTTPHeaderDict()\n        # we also need for extensions to properly maintain results\n        other_dict.extend(d)\n        assert list(other_dict.items()) == expected_results\n\n    def test_extend_from_headerdict(self, d: HTTPHeaderDict) -> None:\n        h = HTTPHeaderDict(Cookie=\"foo\", e=\"foofoo\")\n        d.extend(h)\n        assert d[\"cookie\"] == \"foo, bar, foo\"\n        assert d[\"e\"] == \"foofoo\"\n        assert len(d) == 2\n\n    @pytest.mark.parametrize(\"args\", [(1, 2), (1, 2, 3, 4, 5)])\n    def test_extend_with_wrong_number_of_args_is_typeerror(\n        self, d: HTTPHeaderDict, args: tuple[int, ...]\n    ) -> None:\n        with pytest.raises(\n            TypeError, match=r\"extend\\(\\) takes at most 1 positional arguments\"\n        ):\n            d.extend(*args)  # type: ignore[arg-type]\n\n    def test_copy(self, d: HTTPHeaderDict) -> None:\n        h = d.copy()\n        assert d is not h\n        assert d == h\n\n    def test_getlist(self, d: HTTPHeaderDict) -> None:\n        assert d.getlist(\"cookie\") == [\"foo\", \"bar\"]\n        assert d.getlist(\"Cookie\") == [\"foo\", \"bar\"]\n        assert d.getlist(\"b\") == []\n        d.add(\"b\", \"asdf\")\n        assert d.getlist(\"b\") == [\"asdf\"]\n\n    def test_getlist_after_copy(self, d: HTTPHeaderDict) -> None:\n        assert d.getlist(\"cookie\") == HTTPHeaderDict(d).getlist(\"cookie\")\n\n    def test_equal(self, d: HTTPHeaderDict) -> None:\n        b = HTTPHeaderDict(cookie=\"foo, bar\")\n        c = NonMappingHeaderContainer(cookie=\"foo, bar\")\n        e = [(\"cookie\", \"foo, bar\")]\n        assert d == b\n        assert d == c\n        assert d == e\n        assert d != 2\n\n    def test_not_equal(self, d: HTTPHeaderDict) -> None:\n        b = HTTPHeaderDict(cookie=\"foo, bar\")\n        c = NonMappingHeaderContainer(cookie=\"foo, bar\")\n        e = [(\"cookie\", \"foo, bar\")]\n        assert not (d != b)\n        assert not (d != c)\n        assert not (d != e)\n        assert d != 2\n\n    def test_pop(self, d: HTTPHeaderDict) -> None:\n        key = \"Cookie\"\n        a = d[key]\n        b = d.pop(key)\n        assert a == b\n        assert key not in d\n        with pytest.raises(KeyError):\n            d.pop(key)\n        dummy = object()\n        assert dummy is d.pop(key, dummy)\n\n    def test_discard(self, d: HTTPHeaderDict) -> None:\n        d.discard(\"cookie\")\n        assert \"cookie\" not in d\n        d.discard(\"cookie\")\n\n    def test_len(self, d: HTTPHeaderDict) -> None:\n        assert len(d) == 1\n        d.add(\"cookie\", \"bla\")\n        d.add(\"asdf\", \"foo\")\n        # len determined by unique fieldnames\n        assert len(d) == 2\n\n    def test_repr(self, d: HTTPHeaderDict) -> None:\n        rep = \"HTTPHeaderDict({'Cookie': 'foo, bar'})\"\n        assert repr(d) == rep\n\n    def test_items(self, d: HTTPHeaderDict) -> None:\n        items = d.items()\n        assert len(items) == 2\n        assert list(items) == [\n            (\"Cookie\", \"foo\"),\n            (\"Cookie\", \"bar\"),\n        ]\n        assert (\"Cookie\", \"foo\") in items\n        assert (\"Cookie\", \"bar\") in items\n        assert (\"X-Some-Header\", \"foo\") not in items\n        assert (\"Cookie\", \"not_present\") not in items\n        assert (\"Cookie\", 1) not in items  # type: ignore[comparison-overlap]\n        assert \"Cookie\" not in items  # type: ignore[comparison-overlap]\n\n    def test_dict_conversion(self, d: HTTPHeaderDict) -> None:\n        # Also tested in connectionpool, needs to preserve case\n        hdict = {\n            \"Content-Length\": \"0\",\n            \"Content-type\": \"text/plain\",\n            \"Server\": \"Hypercorn/1.2.3\",\n        }\n        h = dict(HTTPHeaderDict(hdict).items())\n        assert hdict == h\n        assert hdict == dict(HTTPHeaderDict(hdict))\n\n    def test_string_enforcement(self, d: HTTPHeaderDict) -> None:\n        # This currently throws AttributeError on key.lower(), should\n        # probably be something nicer\n        with pytest.raises(Exception):\n            d[3] = \"5\"  # type: ignore[index]\n        with pytest.raises(Exception):\n            d.add(3, \"4\")  # type: ignore[arg-type]\n        with pytest.raises(Exception):\n            del d[3]  # type: ignore[arg-type]\n        with pytest.raises(Exception):\n            HTTPHeaderDict({3: 3})  # type: ignore[arg-type]\n\n    def test_dunder_contains(self, d: HTTPHeaderDict) -> None:\n        \"\"\"\n        Test:\n\n        HTTPHeaderDict.__contains__ returns True\n          - for matched string objects\n          - for case-similar string objects\n        HTTPHeaderDict.__contains__ returns False\n          - for non-similar strings\n          - for non-strings, even if they are keys\n            in the underlying datastructure\n        \"\"\"\n        assert \"cookie\" in d\n        assert \"CoOkIe\" in d\n        assert \"Not a cookie\" not in d\n\n        marker = object()\n        d._container[marker] = [\"some\", \"strings\"]  # type: ignore[index]\n        assert marker not in d\n        assert marker in d._container\n\n    def test_union(self, d: HTTPHeaderDict) -> None:\n        to_merge = {\"Cookie\": \"tim-tam\"}\n        result = d | to_merge\n        assert result == HTTPHeaderDict({\"Cookie\": \"foo, bar, tim-tam\"})\n        assert to_merge == {\"Cookie\": \"tim-tam\"}\n        assert d == HTTPHeaderDict({\"Cookie\": \"foo, bar\"})\n\n    def test_union_rhs(self, d: HTTPHeaderDict) -> None:\n        to_merge = {\"Cookie\": \"tim-tam\"}\n        result = to_merge | d\n        assert result == HTTPHeaderDict({\"Cookie\": \"tim-tam, foo, bar\"})\n        assert to_merge == {\"Cookie\": \"tim-tam\"}\n        assert d == HTTPHeaderDict({\"Cookie\": \"foo, bar\"})\n\n    def test_inplace_union(self, d: HTTPHeaderDict) -> None:\n        to_merge = {\"Cookie\": \"tim-tam\"}\n        d |= to_merge\n        assert d == HTTPHeaderDict({\"Cookie\": \"foo, bar, tim-tam\"})\n\n    def test_union_with_unsupported_type(self, d: HTTPHeaderDict) -> None:\n        with pytest.raises(TypeError, match=\"unsupported operand type.*'int'\"):\n            d | 42\n        with pytest.raises(TypeError, match=\"unsupported operand type.*'float'\"):\n            3.14 | d\n\n    def test_inplace_union_with_unsupported_type(self, d: HTTPHeaderDict) -> None:\n        with pytest.raises(TypeError, match=\"unsupported operand type.*'NoneType'\"):\n            d |= None\n", "test/test_queue_monkeypatch.py": "from __future__ import annotations\n\nimport queue\nfrom unittest import mock\n\nimport pytest\n\nfrom urllib3 import HTTPConnectionPool\nfrom urllib3.exceptions import EmptyPoolError\n\n\nclass BadError(Exception):\n    \"\"\"\n    This should not be raised.\n    \"\"\"\n\n\nclass TestMonkeypatchResistance:\n    \"\"\"\n    Test that connection pool works even with a monkey patched Queue module,\n    see obspy/obspy#1599, psf/requests#3742, urllib3/urllib3#1061.\n    \"\"\"\n\n    def test_queue_monkeypatching(self) -> None:\n        with mock.patch.object(queue, \"Empty\", BadError):\n            with HTTPConnectionPool(host=\"localhost\", block=True) as http:\n                http._get_conn()\n                with pytest.raises(EmptyPoolError):\n                    http._get_conn(timeout=0)\n", "test/port_helpers.py": "# These helpers are copied from test/support/socket_helper.py in the Python 3.9 standard\n# library test suite.\n\nfrom __future__ import annotations\n\nimport socket\n\n# Don't use \"localhost\", since resolving it uses the DNS under recent\n# Windows versions (see issue #18792).\nHOST = \"127.0.0.1\"\nHOSTv6 = \"::1\"\n\n\ndef find_unused_port(\n    family: socket.AddressFamily = socket.AF_INET,\n    socktype: socket.SocketKind = socket.SOCK_STREAM,\n) -> int:\n    \"\"\"Returns an unused port that should be suitable for binding.  This is\n    achieved by creating a temporary socket with the same family and type as\n    the 'sock' parameter (default is AF_INET, SOCK_STREAM), and binding it to\n    the specified host address (defaults to 0.0.0.0) with the port set to 0,\n    eliciting an unused ephemeral port from the OS.  The temporary socket is\n    then closed and deleted, and the ephemeral port is returned.\n\n    Either this method or bind_port() should be used for any tests where a\n    server socket needs to be bound to a particular port for the duration of\n    the test.  Which one to use depends on whether the calling code is creating\n    a python socket, or if an unused port needs to be provided in a constructor\n    or passed to an external program (i.e. the -accept argument to openssl's\n    s_server mode).  Always prefer bind_port() over find_unused_port() where\n    possible.  Hard coded ports should *NEVER* be used.  As soon as a server\n    socket is bound to a hard coded port, the ability to run multiple instances\n    of the test simultaneously on the same host is compromised, which makes the\n    test a ticking time bomb in a buildbot environment. On Unix buildbots, this\n    may simply manifest as a failed test, which can be recovered from without\n    intervention in most cases, but on Windows, the entire python process can\n    completely and utterly wedge, requiring someone to log in to the buildbot\n    and manually kill the affected process.\n\n    (This is easy to reproduce on Windows, unfortunately, and can be traced to\n    the SO_REUSEADDR socket option having different semantics on Windows versus\n    Unix/Linux.  On Unix, you can't have two AF_INET SOCK_STREAM sockets bind,\n    listen and then accept connections on identical host/ports.  An EADDRINUSE\n    OSError will be raised at some point (depending on the platform and\n    the order bind and listen were called on each socket).\n\n    However, on Windows, if SO_REUSEADDR is set on the sockets, no EADDRINUSE\n    will ever be raised when attempting to bind two identical host/ports. When\n    accept() is called on each socket, the second caller's process will steal\n    the port from the first caller, leaving them both in an awkwardly wedged\n    state where they'll no longer respond to any signals or graceful kills, and\n    must be forcibly killed via OpenProcess()/TerminateProcess().\n\n    The solution on Windows is to use the SO_EXCLUSIVEADDRUSE socket option\n    instead of SO_REUSEADDR, which effectively affords the same semantics as\n    SO_REUSEADDR on Unix.  Given the propensity of Unix developers in the Open\n    Source world compared to Windows ones, this is a common mistake.  A quick\n    look over OpenSSL's 0.9.8g source shows that they use SO_REUSEADDR when\n    openssl.exe is called with the 's_server' option, for example. See\n    http://bugs.python.org/issue2550 for more info.  The following site also\n    has a very thorough description about the implications of both REUSEADDR\n    and EXCLUSIVEADDRUSE on Windows:\n    http://msdn2.microsoft.com/en-us/library/ms740621(VS.85).aspx)\n\n    XXX: although this approach is a vast improvement on previous attempts to\n    elicit unused ports, it rests heavily on the assumption that the ephemeral\n    port returned to us by the OS won't immediately be dished back out to some\n    other process when we close and delete our temporary socket but before our\n    calling code has a chance to bind the returned port.  We can deal with this\n    issue if/when we come across it.\"\"\"\n\n    with socket.socket(family, socktype) as tempsock:\n        port = bind_port(tempsock)\n    del tempsock\n    return port\n\n\ndef bind_port(sock: socket.socket, host: str = HOST) -> int:\n    \"\"\"Bind the socket to a free port and return the port number. Relies on\n    ephemeral ports in order to ensure we are using an unbound port.  This is\n    important as many tests may be running simultaneously, especially in a\n    buildbot environment.  This method raises an exception if the sock.family\n    is AF_INET and sock.type is SOCK_STREAM, *and* the socket has SO_REUSEADDR\n    or SO_REUSEPORT set on it.  Tests should *never* set these socket options\n    for TCP/IP sockets.  The only case for setting these options is testing\n    multicasting via multiple UDP sockets.\n\n    Additionally, if the SO_EXCLUSIVEADDRUSE socket option is available (i.e.\n    on Windows), it will be set on the socket.  This will prevent anyone else\n    from bind()'ing to our host/port for the duration of the test.\n    \"\"\"\n\n    if sock.family == socket.AF_INET and sock.type == socket.SOCK_STREAM:\n        if hasattr(socket, \"SO_REUSEADDR\"):\n            if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR) == 1:\n                raise ValueError(\n                    \"tests should never set the SO_REUSEADDR \"\n                    \"socket option on TCP/IP sockets!\"\n                )\n        if hasattr(socket, \"SO_REUSEPORT\"):\n            try:\n                if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:\n                    raise ValueError(\n                        \"tests should never set the SO_REUSEPORT \"\n                        \"socket option on TCP/IP sockets!\"\n                    )\n            except OSError:\n                # Python's socket module was compiled using modern headers\n                # thus defining SO_REUSEPORT but this process is running\n                # under an older kernel that does not support SO_REUSEPORT.\n                pass\n        if hasattr(socket, \"SO_EXCLUSIVEADDRUSE\"):\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)\n\n    sock.bind((host, 0))\n    port = sock.getsockname()[1]\n    assert isinstance(port, int)\n    return port\n", "test/test_util.py": "from __future__ import annotations\n\nimport io\nimport logging\nimport socket\nimport ssl\nimport sys\nimport typing\nimport warnings\nfrom itertools import chain\nfrom test import ImportBlocker, ModuleStash, notBrotli, notZstd, onlyBrotli, onlyZstd\nfrom unittest import mock\nfrom unittest.mock import MagicMock, Mock, patch\nfrom urllib.parse import urlparse\n\nimport pytest\n\nfrom urllib3 import add_stderr_logger, disable_warnings\nfrom urllib3.connection import ProxyConfig\nfrom urllib3.exceptions import (\n    InsecureRequestWarning,\n    LocationParseError,\n    TimeoutStateError,\n    UnrewindableBodyError,\n)\nfrom urllib3.util import is_fp_closed\nfrom urllib3.util.connection import _has_ipv6, allowed_gai_family, create_connection\nfrom urllib3.util.proxy import connection_requires_http_tunnel\nfrom urllib3.util.request import _FAILEDTELL, make_headers, rewind_body\nfrom urllib3.util.response import assert_header_parsing\nfrom urllib3.util.ssl_ import (\n    _TYPE_VERSION_INFO,\n    _is_has_never_check_common_name_reliable,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom urllib3.util.timeout import _DEFAULT_TIMEOUT, Timeout\nfrom urllib3.util.url import Url, _encode_invalid_chars, parse_url\nfrom urllib3.util.util import to_bytes, to_str\n\nfrom . import clear_warnings\n\n# This number represents a time in seconds, it doesn't mean anything in\n# isolation. Setting to a high-ish value to avoid conflicts with the smaller\n# numbers used for timeouts\nTIMEOUT_EPOCH = 1000\n\n\nclass TestUtil:\n    url_host_map = [\n        # Hosts\n        (\"http://google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/mail/\", (\"http\", \"google.com\", None)),\n        (\"google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/\", (\"http\", \"google.com\", None)),\n        (\"http://google.com\", (\"http\", \"google.com\", None)),\n        (\"http://www.google.com\", (\"http\", \"www.google.com\", None)),\n        (\"http://mail.google.com\", (\"http\", \"mail.google.com\", None)),\n        (\"http://google.com:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"http://google.com:8000\", (\"http\", \"google.com\", 8000)),\n        (\"https://google.com\", (\"https\", \"google.com\", None)),\n        (\"https://google.com:8000\", (\"https\", \"google.com\", 8000)),\n        (\"http://user:password@127.0.0.1:1234\", (\"http\", \"127.0.0.1\", 1234)),\n        (\"http://google.com/foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com?foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com#foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        # IPv4\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7/test\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7:80\", (\"http\", \"173.194.35.7\", 80)),\n        (\"http://173.194.35.7:80/test\", (\"http\", \"173.194.35.7\", 80)),\n        # IPv6\n        (\"[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\"http://[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\n            \"http://[2a00:1450:4001:c01::67]/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", None),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        # More IPv6 from http://www.ietf.org/rfc/rfc2732.txt\n        (\n            \"http://[fedc:ba98:7654:3210:fedc:ba98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"http://[1080:0:0:0:8:800:200c:417a]/index.html\",\n            (\"http\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"http://[3ffe:2a00:100:7031::1]\", (\"http\", \"[3ffe:2a00:100:7031::1]\", None)),\n        (\n            \"http://[1080::8:800:200c:417a]/foo\",\n            (\"http\", \"[1080::8:800:200c:417a]\", None),\n        ),\n        (\"http://[::192.9.5.5]/ipng\", (\"http\", \"[::192.9.5.5]\", None)),\n        (\n            \"http://[::ffff:129.144.52.38]:42/index.html\",\n            (\"http\", \"[::ffff:129.144.52.38]\", 42),\n        ),\n        (\n            \"http://[2010:836b:4179::836b:4179]\",\n            (\"http\", \"[2010:836b:4179::836b:4179]\", None),\n        ),\n        # Scoped IPv6 (with ZoneID), both RFC 6874 compliant and not.\n        (\"http://[a::b%25zone]\", (\"http\", \"[a::b%zone]\", None)),\n        (\"http://[a::b%zone]\", (\"http\", \"[a::b%zone]\", None)),\n        # Hosts\n        (\"HTTP://GOOGLE.COM/mail/\", (\"http\", \"google.com\", None)),\n        (\"GOogle.COM/mail\", (\"http\", \"google.com\", None)),\n        (\"HTTP://GoOgLe.CoM:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"HTTP://user:password@EXAMPLE.COM:1234\", (\"http\", \"example.com\", 1234)),\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"HTTP://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\n            \"HTTP://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"HTTP://[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"HTTPS://[1080:0:0:0:8:800:200c:417A]/index.html\",\n            (\"https\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"abOut://eXamPlE.com?info=1\", (\"about\", \"eXamPlE.com\", None)),\n        (\n            \"http+UNIX://%2fvar%2frun%2fSOCKET/path\",\n            (\"http+unix\", \"%2fvar%2frun%2fSOCKET\", None),\n        ),\n    ]\n\n    @pytest.mark.parametrize([\"url\", \"scheme_host_port\"], url_host_map)\n    def test_scheme_host_port(\n        self, url: str, scheme_host_port: tuple[str, str, int | None]\n    ) -> None:\n        parsed_url = parse_url(url)\n        scheme, host, port = scheme_host_port\n\n        assert (parsed_url.scheme or \"http\") == scheme\n        assert parsed_url.hostname == parsed_url.host == host\n        assert parsed_url.port == port\n\n    def test_encode_invalid_chars_none(self) -> None:\n        assert _encode_invalid_chars(None, set()) is None\n\n    @pytest.mark.parametrize(\n        \"url\",\n        [\n            \"http://google.com:foo\",\n            \"http://::1/\",\n            \"http://::1:80/\",\n            \"http://google.com:-80\",\n            \"http://google.com:65536\",\n            \"http://google.com:\\xb2\\xb2\",  # \\xb2 = ^2\n            # Invalid IDNA labels\n            \"http://\\uD7FF.com\",\n            \"http://\u2764\ufe0f\",\n            # Unicode surrogates\n            \"http://\\uD800.com\",\n            \"http://\\uDC00.com\",\n        ],\n    )\n    def test_invalid_url(self, url: str) -> None:\n        with pytest.raises(LocationParseError):\n            parse_url(url)\n\n    @pytest.mark.parametrize(\n        \"url, expected_normalized_url\",\n        [\n            (\"HTTP://GOOGLE.COM/MAIL/\", \"http://google.com/MAIL/\"),\n            (\n                \"http://user@domain.com:password@example.com/~tilde@?@\",\n                \"http://user%40domain.com:password@example.com/~tilde@?@\",\n            ),\n            (\n                \"HTTP://JeremyCline:Hunter2@Example.com:8080/\",\n                \"http://JeremyCline:Hunter2@example.com:8080/\",\n            ),\n            (\"HTTPS://Example.Com/?Key=Value\", \"https://example.com/?Key=Value\"),\n            (\"Https://Example.Com/#Fragment\", \"https://example.com/#Fragment\"),\n            # IPv6 addresses with zone IDs. Both RFC 6874 (%25) as well as\n            # non-standard (unquoted %) variants.\n            (\"[::1%zone]\", \"[::1%zone]\"),\n            (\"[::1%25zone]\", \"[::1%zone]\"),\n            (\"[::1%25]\", \"[::1%25]\"),\n            (\"[::Ff%etH0%Ff]/%ab%Af\", \"[::ff%etH0%FF]/%AB%AF\"),\n            (\n                \"http://user:pass@[AaAa::Ff%25etH0%Ff]/%ab%Af\",\n                \"http://user:pass@[aaaa::ff%etH0%FF]/%AB%AF\",\n            ),\n            # Invalid characters for the query/fragment getting encoded\n            (\n                'http://google.com/p[]?parameter[]=\"hello\"#fragment#',\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n            # Percent encoding isn't applied twice despite '%' being invalid\n            # but the percent encoding is still normalized.\n            (\n                \"http://google.com/p%5B%5d?parameter%5b%5D=%22hello%22#fragment%23\",\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n        ],\n    )\n    def test_parse_url_normalization(\n        self, url: str, expected_normalized_url: str\n    ) -> None:\n        \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"\n        actual_normalized_url = parse_url(url).url\n        assert actual_normalized_url == expected_normalized_url\n\n    @pytest.mark.parametrize(\"char\", [chr(i) for i in range(0x00, 0x21)] + [\"\\x7F\"])\n    def test_control_characters_are_percent_encoded(self, char: str) -> None:\n        percent_char = \"%\" + (hex(ord(char))[2:].zfill(2).upper())\n        url = parse_url(\n            f\"http://user{char}@example.com/path{char}?query{char}#fragment{char}\"\n        )\n\n        assert url == Url(\n            \"http\",\n            auth=\"user\" + percent_char,\n            host=\"example.com\",\n            path=\"/path\" + percent_char,\n            query=\"query\" + percent_char,\n            fragment=\"fragment\" + percent_char,\n        )\n\n    parse_url_host_map = [\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/mail/\", Url(\"http\", host=\"google.com\", path=\"/mail/\")),\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"mail\")),\n        (\"google.com/mail\", Url(host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com?foo\", Url(\"http\", host=\"google.com\", path=\"\", query=\"foo\")),\n        # Path/query/fragment\n        (\"\", Url()),\n        (\"/\", Url(path=\"/\")),\n        (\"#?/!google.com/?foo\", Url(path=\"\", fragment=\"?/!google.com/?foo\")),\n        (\"/foo\", Url(path=\"/foo\")),\n        (\"/foo?bar=baz\", Url(path=\"/foo\", query=\"bar=baz\")),\n        (\n            \"/foo?bar=baz#banana?apple/orange\",\n            Url(path=\"/foo\", query=\"bar=baz\", fragment=\"banana?apple/orange\"),\n        ),\n        (\n            \"/redirect?target=http://localhost:61020/\",\n            Url(path=\"redirect\", query=\"target=http://localhost:61020/\"),\n        ),\n        # Port\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com:80/\", Url(\"http\", host=\"google.com\", port=80, path=\"/\")),\n        (\"http://google.com:80\", Url(\"http\", host=\"google.com\", port=80)),\n        # Auth\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n        (\"http://foo@localhost/\", Url(\"http\", auth=\"foo\", host=\"localhost\", path=\"/\")),\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n    ]\n\n    non_round_tripping_parse_url_host_map = [\n        # Path/query/fragment\n        (\"?\", Url(path=\"\", query=\"\")),\n        (\"#\", Url(path=\"\", fragment=\"\")),\n        # Path normalization\n        (\"/abc/../def\", Url(path=\"/def\")),\n        # Empty Port\n        (\"http://google.com:\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com:/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        # Uppercase IRI\n        (\n            \"http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe\",\n            Url(\"http\", host=\"xn--knigsgchen-b4a3dun.de\", path=\"/stra%C3%9Fe\"),\n        ),\n        # Percent-encode in userinfo\n        (\n            \"http://user@email.com:password@example.com/\",\n            Url(\"http\", auth=\"user%40email.com:password\", host=\"example.com\", path=\"/\"),\n        ),\n        (\n            'http://user\":quoted@example.com/',\n            Url(\"http\", auth=\"user%22:quoted\", host=\"example.com\", path=\"/\"),\n        ),\n        # Unicode Surrogates\n        (\"http://google.com/\\uD800\", Url(\"http\", host=\"google.com\", path=\"%ED%A0%80\")),\n        (\n            \"http://google.com?q=\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", query=\"q=%ED%B0%80\"),\n        ),\n        (\n            \"http://google.com#\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"%ED%B0%80\"),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\n        \"url, expected_url\",\n        chain(parse_url_host_map, non_round_tripping_parse_url_host_map),\n    )\n    def test_parse_url(self, url: str, expected_url: Url) -> None:\n        returned_url = parse_url(url)\n        assert returned_url == expected_url\n        assert returned_url.hostname == returned_url.host == expected_url.host\n\n    @pytest.mark.parametrize(\"url, expected_url\", parse_url_host_map)\n    def test_unparse_url(self, url: str, expected_url: Url) -> None:\n        assert url == expected_url.url\n\n    @pytest.mark.parametrize(\n        [\"url\", \"expected_url\"],\n        [\n            # RFC 3986 5.2.4\n            (\"/abc/../def\", Url(path=\"/def\")),\n            (\"/..\", Url(path=\"/\")),\n            (\"/./abc/./def/\", Url(path=\"/abc/def/\")),\n            (\"/.\", Url(path=\"/\")),\n            (\"/./\", Url(path=\"/\")),\n            (\"/abc/./.././d/././e/.././f/./../../ghi\", Url(path=\"/ghi\")),\n        ],\n    )\n    def test_parse_and_normalize_url_paths(self, url: str, expected_url: Url) -> None:\n        actual_url = parse_url(url)\n        assert actual_url == expected_url\n        assert actual_url.url == expected_url.url\n\n    def test_parse_url_invalid_IPv6(self) -> None:\n        with pytest.raises(LocationParseError):\n            parse_url(\"[::1\")\n\n    def test_parse_url_negative_port(self) -> None:\n        with pytest.raises(LocationParseError):\n            parse_url(\"https://www.google.com:-80/\")\n\n    def test_parse_url_remove_leading_zeros(self) -> None:\n        url = parse_url(\"https://example.com:0000000000080\")\n        assert url.port == 80\n\n    def test_parse_url_only_zeros(self) -> None:\n        url = parse_url(\"https://example.com:0\")\n        assert url.port == 0\n\n        url = parse_url(\"https://example.com:000000000000\")\n        assert url.port == 0\n\n    def test_Url_str(self) -> None:\n        U = Url(\"http\", host=\"google.com\")\n        assert str(U) == U.url\n\n    request_uri_map = [\n        (\"http://google.com/mail\", \"/mail\"),\n        (\"http://google.com/mail/\", \"/mail/\"),\n        (\"http://google.com/\", \"/\"),\n        (\"http://google.com\", \"/\"),\n        (\"\", \"/\"),\n        (\"/\", \"/\"),\n        (\"?\", \"/?\"),\n        (\"#\", \"/\"),\n        (\"/foo?bar=baz\", \"/foo?bar=baz\"),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_request_uri\", request_uri_map)\n    def test_request_uri(self, url: str, expected_request_uri: str) -> None:\n        returned_url = parse_url(url)\n        assert returned_url.request_uri == expected_request_uri\n\n    url_authority_map: list[tuple[str, str | None]] = [\n        (\"http://user:pass@google.com/mail\", \"user:pass@google.com\"),\n        (\"http://user:pass@google.com:80/mail\", \"user:pass@google.com:80\"),\n        (\"http://user@google.com:80/mail\", \"user@google.com:80\"),\n        (\"http://user:pass@192.168.1.1/path\", \"user:pass@192.168.1.1\"),\n        (\"http://user:pass@192.168.1.1:80/path\", \"user:pass@192.168.1.1:80\"),\n        (\"http://user@192.168.1.1:80/path\", \"user@192.168.1.1:80\"),\n        (\"http://user:pass@[::1]/path\", \"user:pass@[::1]\"),\n        (\"http://user:pass@[::1]:80/path\", \"user:pass@[::1]:80\"),\n        (\"http://user@[::1]:80/path\", \"user@[::1]:80\"),\n        (\"http://user:pass@localhost/path\", \"user:pass@localhost\"),\n        (\"http://user:pass@localhost:80/path\", \"user:pass@localhost:80\"),\n        (\"http://user@localhost:80/path\", \"user@localhost:80\"),\n    ]\n\n    url_netloc_map = [\n        (\"http://google.com/mail\", \"google.com\"),\n        (\"http://google.com:80/mail\", \"google.com:80\"),\n        (\"http://192.168.0.1/path\", \"192.168.0.1\"),\n        (\"http://192.168.0.1:80/path\", \"192.168.0.1:80\"),\n        (\"http://[::1]/path\", \"[::1]\"),\n        (\"http://[::1]:80/path\", \"[::1]:80\"),\n        (\"http://localhost\", \"localhost\"),\n        (\"http://localhost:80\", \"localhost:80\"),\n        (\"google.com/foobar\", \"google.com\"),\n        (\"google.com:12345\", \"google.com:12345\"),\n        (\"/\", None),\n    ]\n\n    combined_netloc_authority_map = url_authority_map + url_netloc_map\n\n    # We compose this list due to variances between parse_url\n    # and urlparse when URIs don't provide a scheme.\n    url_authority_with_schemes_map = [\n        u for u in combined_netloc_authority_map if u[0].startswith(\"http\")\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_authority\", combined_netloc_authority_map)\n    def test_authority(self, url: str, expected_authority: str | None) -> None:\n        assert parse_url(url).authority == expected_authority\n\n    @pytest.mark.parametrize(\"url, expected_authority\", url_authority_with_schemes_map)\n    def test_authority_matches_urllib_netloc(\n        self, url: str, expected_authority: str | None\n    ) -> None:\n        \"\"\"Validate this matches the behavior of urlparse().netloc\"\"\"\n        assert urlparse(url).netloc == expected_authority\n\n    @pytest.mark.parametrize(\"url, expected_netloc\", url_netloc_map)\n    def test_netloc(self, url: str, expected_netloc: str | None) -> None:\n        assert parse_url(url).netloc == expected_netloc\n\n    url_vulnerabilities = [\n        # urlparse doesn't follow RFC 3986 Section 3.2\n        (\n            \"http://google.com#@evil.com/\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"@evil.com/\"),\n        ),\n        # CVE-2016-5699\n        (\n            \"http://127.0.0.1%0d%0aConnection%3a%20keep-alive\",\n            Url(\"http\", host=\"127.0.0.1%0d%0aconnection%3a%20keep-alive\"),\n        ),\n        # NodeJS unicode -> double dot\n        (\n            \"http://google.com/\\uff2e\\uff2e/abc\",\n            Url(\"http\", host=\"google.com\", path=\"/%EF%BC%AE%EF%BC%AE/abc\"),\n        ),\n        # Scheme without ://\n        (\n            \"javascript:a='@google.com:12345/';alert(0)\",\n            Url(scheme=\"javascript\", path=\"a='@google.com:12345/';alert(0)\"),\n        ),\n        (\"//google.com/a/b/c\", Url(host=\"google.com\", path=\"/a/b/c\")),\n        # International URLs\n        (\n            \"http://\u30d2:\u30ad@\u30d2.abc.\u30cb/\u30d2?\u30ad#\u30ef\",\n            Url(\n                \"http\",\n                host=\"xn--pdk.abc.xn--idk\",\n                auth=\"%E3%83%92:%E3%82%AD\",\n                path=\"/%E3%83%92\",\n                query=\"%E3%82%AD\",\n                fragment=\"%E3%83%AF\",\n            ),\n        ),\n        # Injected headers (CVE-2016-5699, CVE-2019-9740, CVE-2019-9947)\n        (\n            \"10.251.0.83:7777?a=1 HTTP/1.1\\r\\nX-injected: header\",\n            Url(\n                host=\"10.251.0.83\",\n                port=7777,\n                path=\"\",\n                query=\"a=1%20HTTP/1.1%0D%0AX-injected:%20header\",\n            ),\n        ),\n        (\n            \"http://127.0.0.1:6379?\\r\\nSET test failure12\\r\\n:8080/test/?test=a\",\n            Url(\n                scheme=\"http\",\n                host=\"127.0.0.1\",\n                port=6379,\n                path=\"\",\n                query=\"%0D%0ASET%20test%20failure12%0D%0A:8080/test/?test=a\",\n            ),\n        ),\n        # See https://bugs.xdavidhu.me/google/2020/03/08/the-unexpected-google-wide-domain-check-bypass/\n        (\n            \"https://user:pass@xdavidhu.me\\\\test.corp.google.com:8080/path/to/something?param=value#hash\",\n            Url(\n                scheme=\"https\",\n                auth=\"user:pass\",\n                host=\"xdavidhu.me\",\n                path=\"/%5Ctest.corp.google.com:8080/path/to/something\",\n                query=\"param=value\",\n                fragment=\"hash\",\n            ),\n        ),\n        # Tons of '@' causing backtracking\n        pytest.param(\n            \"https://\" + (\"@\" * 10000) + \"[\",\n            False,\n            id=\"Tons of '@' causing backtracking 1\",\n        ),\n        pytest.param(\n            \"https://user:\" + (\"@\" * 10000) + \"example.com\",\n            Url(\n                scheme=\"https\",\n                auth=\"user:\" + (\"%40\" * 9999),\n                host=\"example.com\",\n            ),\n            id=\"Tons of '@' causing backtracking 2\",\n        ),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_url\", url_vulnerabilities)\n    def test_url_vulnerabilities(\n        self, url: str, expected_url: typing.Literal[False] | Url\n    ) -> None:\n        if expected_url is False:\n            with pytest.raises(LocationParseError):\n                parse_url(url)\n        else:\n            assert parse_url(url) == expected_url\n\n    def test_parse_url_bytes_type_error(self) -> None:\n        with pytest.raises(TypeError):\n            parse_url(b\"https://www.google.com/\")  # type: ignore[arg-type]\n\n    @pytest.mark.parametrize(\n        \"kwargs, expected\",\n        [\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate,br,zstd\"},\n                marks=[onlyBrotli(), onlyZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate,br\"},\n                marks=[onlyBrotli(), notZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate,zstd\"},\n                marks=[notBrotli(), onlyZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate\"},\n                marks=[notBrotli(), notZstd()],  # type: ignore[list-item]\n            ),\n            ({\"accept_encoding\": \"foo,bar\"}, {\"accept-encoding\": \"foo,bar\"}),\n            ({\"accept_encoding\": [\"foo\", \"bar\"]}, {\"accept-encoding\": \"foo,bar\"}),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate,br,zstd\", \"user-agent\": \"banana\"},\n                marks=[onlyBrotli(), onlyZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate,br\", \"user-agent\": \"banana\"},\n                marks=[onlyBrotli(), notZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate,zstd\", \"user-agent\": \"banana\"},\n                marks=[notBrotli(), onlyZstd()],  # type: ignore[list-item]\n            ),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate\", \"user-agent\": \"banana\"},\n                marks=[notBrotli(), notZstd()],  # type: ignore[list-item]\n            ),\n            ({\"user_agent\": \"banana\"}, {\"user-agent\": \"banana\"}),\n            ({\"keep_alive\": True}, {\"connection\": \"keep-alive\"}),\n            ({\"basic_auth\": \"foo:bar\"}, {\"authorization\": \"Basic Zm9vOmJhcg==\"}),\n            (\n                {\"proxy_basic_auth\": \"foo:bar\"},\n                {\"proxy-authorization\": \"Basic Zm9vOmJhcg==\"},\n            ),\n            ({\"disable_cache\": True}, {\"cache-control\": \"no-cache\"}),\n        ],\n    )\n    def test_make_headers(\n        self, kwargs: dict[str, bool | str], expected: dict[str, str]\n    ) -> None:\n        assert make_headers(**kwargs) == expected  # type: ignore[arg-type]\n\n    def test_rewind_body(self) -> None:\n        body = io.BytesIO(b\"test data\")\n        assert body.read() == b\"test data\"\n\n        # Assert the file object has been consumed\n        assert body.read() == b\"\"\n\n        # Rewind it back to just be b'data'\n        rewind_body(body, 5)\n        assert body.read() == b\"data\"\n\n    def test_rewind_body_failed_tell(self) -> None:\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Simulate failed tell()\n        body_pos = _FAILEDTELL\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(body, body_pos)\n\n    def test_rewind_body_bad_position(self) -> None:\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Pass non-integer position\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=None)  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=object())  # type: ignore[arg-type]\n\n    def test_rewind_body_failed_seek(self) -> None:\n        class BadSeek(io.StringIO):\n            def seek(self, offset: int, whence: int = 0) -> typing.NoReturn:\n                raise OSError\n\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(BadSeek(), body_pos=2)\n\n    def test_add_stderr_logger(self) -> None:\n        handler = add_stderr_logger(level=logging.INFO)  # Don't actually print debug\n        logger = logging.getLogger(\"urllib3\")\n        assert handler in logger.handlers\n\n        logger.debug(\"Testing add_stderr_logger\")\n        logger.removeHandler(handler)\n\n    def test_disable_warnings(self) -> None:\n        with warnings.catch_warnings(record=True) as w:\n            clear_warnings()\n            warnings.simplefilter(\"default\", InsecureRequestWarning)\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n            disable_warnings()\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n\n    def _make_time_pass(\n        self, seconds: int, timeout: Timeout, time_mock: Mock\n    ) -> Timeout:\n        \"\"\"Make some time pass for the timeout object\"\"\"\n        time_mock.return_value = TIMEOUT_EPOCH\n        timeout.start_connect()\n        time_mock.return_value = TIMEOUT_EPOCH + seconds\n        return timeout\n\n    @pytest.mark.parametrize(\n        \"kwargs, message\",\n        [\n            ({\"total\": -1}, \"less than\"),\n            ({\"connect\": 2, \"total\": -1}, \"less than\"),\n            ({\"read\": -1}, \"less than\"),\n            ({\"connect\": False}, \"cannot be a boolean\"),\n            ({\"read\": True}, \"cannot be a boolean\"),\n            ({\"connect\": 0}, \"less than or equal\"),\n            ({\"read\": \"foo\"}, \"int, float or None\"),\n            ({\"read\": \"1.0\"}, \"int, float or None\"),\n        ],\n    )\n    def test_invalid_timeouts(\n        self, kwargs: dict[str, int | bool], message: str\n    ) -> None:\n        with pytest.raises(ValueError, match=message):\n            Timeout(**kwargs)\n\n    @patch(\"time.monotonic\")\n    def test_timeout(self, time_monotonic: MagicMock) -> None:\n        timeout = Timeout(total=3)\n\n        # make 'no time' elapse\n        timeout = self._make_time_pass(\n            seconds=0, timeout=timeout, time_mock=time_monotonic\n        )\n        assert timeout.read_timeout == 3\n        assert timeout.connect_timeout == 3\n\n        timeout = Timeout(total=3, connect=2)\n        assert timeout.connect_timeout == 2\n\n        timeout = Timeout()\n        assert timeout.connect_timeout == _DEFAULT_TIMEOUT\n\n        # Connect takes 5 seconds, leaving 5 seconds for read\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=5, timeout=timeout, time_mock=time_monotonic\n        )\n        assert timeout.read_timeout == 5\n\n        # Connect takes 2 seconds, read timeout still 7 seconds\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=2, timeout=timeout, time_mock=time_monotonic\n        )\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=10, read=7)\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=None, read=None, connect=None)\n        assert timeout.connect_timeout is None\n        assert timeout.read_timeout is None\n        assert timeout.total is None\n\n        timeout = Timeout(5)\n        assert timeout.total == 5\n\n    def test_timeout_default_resolve(self) -> None:\n        \"\"\"The timeout default is resolved when read_timeout is accessed.\"\"\"\n        timeout = Timeout()\n        with patch(\"urllib3.util.timeout.getdefaulttimeout\", return_value=2):\n            assert timeout.read_timeout == 2\n\n        with patch(\"urllib3.util.timeout.getdefaulttimeout\", return_value=3):\n            assert timeout.read_timeout == 3\n\n    def test_timeout_str(self) -> None:\n        timeout = Timeout(connect=1, read=2, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=2, total=3)\"\n        timeout = Timeout(connect=1, read=None, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=None, total=3)\"\n\n    @patch(\"time.monotonic\")\n    def test_timeout_elapsed(self, time_monotonic: MagicMock) -> None:\n        time_monotonic.return_value = TIMEOUT_EPOCH\n        timeout = Timeout(total=3)\n        with pytest.raises(TimeoutStateError):\n            timeout.get_connect_duration()\n\n        timeout.start_connect()\n        with pytest.raises(TimeoutStateError):\n            timeout.start_connect()\n\n        time_monotonic.return_value = TIMEOUT_EPOCH + 2\n        assert timeout.get_connect_duration() == 2\n        time_monotonic.return_value = TIMEOUT_EPOCH + 37\n        assert timeout.get_connect_duration() == 37\n\n    def test_is_fp_closed_object_supports_closed(self) -> None:\n        class ClosedFile:\n            @property\n            def closed(self) -> typing.Literal[True]:\n                return True\n\n        assert is_fp_closed(ClosedFile())\n\n    def test_is_fp_closed_object_has_none_fp(self) -> None:\n        class NoneFpFile:\n            @property\n            def fp(self) -> None:\n                return None\n\n        assert is_fp_closed(NoneFpFile())\n\n    def test_is_fp_closed_object_has_fp(self) -> None:\n        class FpFile:\n            @property\n            def fp(self) -> typing.Literal[True]:\n                return True\n\n        assert not is_fp_closed(FpFile())\n\n    def test_is_fp_closed_object_has_neither_fp_nor_closed(self) -> None:\n        class NotReallyAFile:\n            pass\n\n        with pytest.raises(ValueError):\n            is_fp_closed(NotReallyAFile())\n\n    def test_has_ipv6_disabled_on_compile(self) -> None:\n        with patch(\"socket.has_ipv6\", False):\n            assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_but_fails(self) -> None:\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind = Mock(side_effect=Exception(\"No IPv6 here!\"))\n                assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_and_working(self) -> None:\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind.return_value = True\n                assert _has_ipv6(\"::1\")\n\n    def test_ip_family_ipv6_enabled(self) -> None:\n        with patch(\"urllib3.util.connection.HAS_IPV6\", True):\n            assert allowed_gai_family() == socket.AF_UNSPEC\n\n    def test_ip_family_ipv6_disabled(self) -> None:\n        with patch(\"urllib3.util.connection.HAS_IPV6\", False):\n            assert allowed_gai_family() == socket.AF_INET\n\n    @pytest.mark.parametrize(\"headers\", [b\"foo\", None, object])\n    def test_assert_header_parsing_throws_typeerror_with_non_headers(\n        self, headers: bytes | object | None\n    ) -> None:\n        with pytest.raises(TypeError):\n            assert_header_parsing(headers)  # type: ignore[arg-type]\n\n    def test_connection_requires_http_tunnel_no_proxy(self) -> None:\n        assert not connection_requires_http_tunnel(\n            proxy_url=None, proxy_config=None, destination_scheme=None\n        )\n\n    def test_connection_requires_http_tunnel_http_proxy(self) -> None:\n        proxy = parse_url(\"http://proxy:8080\")\n        proxy_config = ProxyConfig(\n            ssl_context=None,\n            use_forwarding_for_https=False,\n            assert_hostname=None,\n            assert_fingerprint=None,\n        )\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n        destination_scheme = \"https\"\n        assert connection_requires_http_tunnel(proxy, proxy_config, destination_scheme)\n\n    def test_connection_requires_http_tunnel_https_proxy(self) -> None:\n        proxy = parse_url(\"https://proxy:8443\")\n        proxy_config = ProxyConfig(\n            ssl_context=None,\n            use_forwarding_for_https=False,\n            assert_hostname=None,\n            assert_fingerprint=None,\n        )\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n    def test_assert_header_parsing_no_error_on_multipart(self) -> None:\n        from http import client\n\n        header_msg = io.BytesIO()\n        header_msg.write(\n            b'Content-Type: multipart/encrypted;protocol=\"application/'\n            b'HTTP-SPNEGO-session-encrypted\";boundary=\"Encrypted Boundary\"'\n            b\"\\nServer: Microsoft-HTTPAPI/2.0\\nDate: Fri, 16 Aug 2019 19:28:01 GMT\"\n            b\"\\nContent-Length: 1895\\n\\n\\n\"\n        )\n        header_msg.seek(0)\n        assert_header_parsing(client.parse_headers(header_msg))\n\n    @pytest.mark.parametrize(\"host\", [\".localhost\", \"...\", \"t\" * 64])\n    def test_create_connection_with_invalid_idna_labels(self, host: str) -> None:\n        with pytest.raises(\n            LocationParseError,\n            match=f\"Failed to parse: '{host}', label empty or too long\",\n        ):\n            create_connection((host, 80))\n\n    @pytest.mark.parametrize(\n        \"host\",\n        [\n            \"a.example.com\",\n            \"localhost.\",\n            \"[dead::beef]\",\n            \"[dead::beef%en5]\",\n            \"[dead::beef%en5.]\",\n        ],\n    )\n    @patch(\"socket.getaddrinfo\")\n    @patch(\"socket.socket\")\n    def test_create_connection_with_valid_idna_labels(\n        self, socket: MagicMock, getaddrinfo: MagicMock, host: str\n    ) -> None:\n        getaddrinfo.return_value = [(None, None, None, None, None)]\n        socket.return_value = Mock()\n        create_connection((host, 80))\n\n    @patch(\"socket.getaddrinfo\")\n    def test_create_connection_error(self, getaddrinfo: MagicMock) -> None:\n        getaddrinfo.return_value = []\n        with pytest.raises(OSError, match=\"getaddrinfo returns an empty list\"):\n            create_connection((\"example.com\", 80))\n\n    @patch(\"socket.getaddrinfo\")\n    def test_dnsresolver_forced_error(self, getaddrinfo: MagicMock) -> None:\n        getaddrinfo.side_effect = socket.gaierror()\n        with pytest.raises(socket.gaierror):\n            # dns is valid but we force the error just for the sake of the test\n            create_connection((\"example.com\", 80))\n\n    def test_dnsresolver_expected_error(self) -> None:\n        with pytest.raises(socket.gaierror):\n            # windows: [Errno 11001] getaddrinfo failed in windows\n            # linux: [Errno -2] Name or service not known\n            # macos: [Errno 8] nodename nor servname provided, or not known\n            create_connection((\"badhost.invalid\", 80))\n\n    @patch(\"socket.getaddrinfo\")\n    @patch(\"socket.socket\")\n    def test_create_connection_with_scoped_ipv6(\n        self, socket: MagicMock, getaddrinfo: MagicMock\n    ) -> None:\n        # Check that providing create_connection with a scoped IPv6 address\n        # properly propagates the scope to getaddrinfo, and that the returned\n        # scoped ID makes it to the socket creation call.\n        fake_scoped_sa6 = (\"a::b\", 80, 0, 42)\n        getaddrinfo.return_value = [\n            (\n                socket.AF_INET6,\n                socket.SOCK_STREAM,\n                socket.IPPROTO_TCP,\n                \"\",\n                fake_scoped_sa6,\n            )\n        ]\n        socket.return_value = fake_sock = MagicMock()\n\n        create_connection((\"a::b%iface\", 80))\n        assert getaddrinfo.call_args[0][0] == \"a::b%iface\"\n        fake_sock.connect.assert_called_once_with(fake_scoped_sa6)\n\n    @pytest.mark.parametrize(\n        \"input,params,expected\",\n        (\n            (\"test\", {}, \"test\"),  # str input\n            (b\"test\", {}, \"test\"),  # bytes input\n            (b\"test\", {\"encoding\": \"utf-8\"}, \"test\"),  # bytes input with utf-8\n            (b\"test\", {\"encoding\": \"ascii\"}, \"test\"),  # bytes input with ascii\n        ),\n    )\n    def test_to_str(\n        self, input: bytes | str, params: dict[str, str], expected: str\n    ) -> None:\n        assert to_str(input, **params) == expected\n\n    def test_to_str_error(self) -> None:\n        with pytest.raises(TypeError, match=\"not expecting type int\"):\n            to_str(1)  # type: ignore[arg-type]\n\n    @pytest.mark.parametrize(\n        \"input,params,expected\",\n        (\n            (b\"test\", {}, b\"test\"),  # str input\n            (\"test\", {}, b\"test\"),  # bytes input\n            (\"\u00e9\", {}, b\"\\xc3\\xa9\"),  # bytes input\n            (\"test\", {\"encoding\": \"utf-8\"}, b\"test\"),  # bytes input with utf-8\n            (\"test\", {\"encoding\": \"ascii\"}, b\"test\"),  # bytes input with ascii\n        ),\n    )\n    def test_to_bytes(\n        self, input: bytes | str, params: dict[str, str], expected: bytes\n    ) -> None:\n        assert to_bytes(input, **params) == expected\n\n    def test_to_bytes_error(self) -> None:\n        with pytest.raises(TypeError, match=\"not expecting type int\"):\n            to_bytes(1)  # type: ignore[arg-type]\n\n\nclass TestUtilSSL:\n    \"\"\"Test utils that use an SSL backend.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"candidate, requirements\",\n        [\n            (None, ssl.CERT_REQUIRED),\n            (ssl.CERT_NONE, ssl.CERT_NONE),\n            (ssl.CERT_REQUIRED, ssl.CERT_REQUIRED),\n            (\"REQUIRED\", ssl.CERT_REQUIRED),\n            (\"CERT_REQUIRED\", ssl.CERT_REQUIRED),\n        ],\n    )\n    def test_resolve_cert_reqs(\n        self, candidate: int | str | None, requirements: int\n    ) -> None:\n        assert resolve_cert_reqs(candidate) == requirements\n\n    @pytest.mark.parametrize(\n        \"candidate, version\",\n        [\n            (ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1),\n            (\"PROTOCOL_TLSv1\", ssl.PROTOCOL_TLSv1),\n            (\"TLSv1\", ssl.PROTOCOL_TLSv1),\n            (ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23),\n        ],\n    )\n    def test_resolve_ssl_version(self, candidate: int | str, version: int) -> None:\n        assert resolve_ssl_version(candidate) == version\n\n    def test_ssl_wrap_socket_loads_the_cert_chain(self) -> None:\n        socket = Mock()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, sock=socket, certfile=\"/path/to/certfile\"\n        )\n\n        mock_context.load_cert_chain.assert_called_once_with(\"/path/to/certfile\", None)\n\n    @patch(\"urllib3.util.ssl_.create_urllib3_context\")\n    def test_ssl_wrap_socket_creates_new_context(\n        self, create_urllib3_context: mock.MagicMock\n    ) -> None:\n        socket = Mock()\n        ssl_wrap_socket(socket, cert_reqs=ssl.CERT_REQUIRED)\n\n        create_urllib3_context.assert_called_once_with(None, 2, ciphers=None)\n\n    def test_ssl_wrap_socket_loads_verify_locations(self) -> None:\n        socket = Mock()\n        mock_context = Mock()\n        ssl_wrap_socket(ssl_context=mock_context, ca_certs=\"/path/to/pem\", sock=socket)\n        mock_context.load_verify_locations.assert_called_once_with(\n            \"/path/to/pem\", None, None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_directories(self) -> None:\n        socket = Mock()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_dir=\"/path/to/pems\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, \"/path/to/pems\", None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_data(self) -> None:\n        socket = Mock()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_data=\"TOTALLY PEM DATA\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, None, \"TOTALLY PEM DATA\"\n        )\n\n    def _wrap_socket_and_mock_warn(\n        self, sock: socket.socket, server_hostname: str | None\n    ) -> tuple[Mock, MagicMock]:\n        mock_context = Mock()\n        with patch(\"warnings.warn\") as warn:\n            ssl_wrap_socket(\n                ssl_context=mock_context,\n                sock=sock,\n                server_hostname=server_hostname,\n            )\n        return mock_context, warn\n\n    def test_ssl_wrap_socket_sni_ip_address_no_warn(self) -> None:\n        \"\"\"Test that a warning is not made if server_hostname is an IP address.\"\"\"\n        sock = Mock()\n        context, warn = self._wrap_socket_and_mock_warn(sock, \"8.8.8.8\")\n        context.wrap_socket.assert_called_once_with(sock, server_hostname=\"8.8.8.8\")\n        warn.assert_not_called()\n\n    def test_ssl_wrap_socket_sni_none_no_warn(self) -> None:\n        \"\"\"Test that a warning is not made if server_hostname is not given.\"\"\"\n        sock = Mock()\n        context, warn = self._wrap_socket_and_mock_warn(sock, None)\n        context.wrap_socket.assert_called_once_with(sock, server_hostname=None)\n        warn.assert_not_called()\n\n    @pytest.mark.parametrize(\n        \"openssl_version, openssl_version_number, implementation_name, version_info, pypy_version_info, reliable\",\n        [\n            # OpenSSL and Python OK -> reliable\n            (\"OpenSSL 1.1.1\", 0x101010CF, \"cpython\", (3, 9, 3), None, True),\n            # Python OK -> reliable\n            (\"OpenSSL 1.1.1\", 0x10101000, \"cpython\", (3, 9, 3), None, True),\n            # PyPy: depends on the version\n            (\"OpenSSL 1.1.1\", 0x10101000, \"pypy\", (3, 9, 9), (7, 3, 7), False),\n            (\"OpenSSL 1.1.1\", 0x101010CF, \"pypy\", (3, 8, 12), (7, 3, 8), True),\n            # OpenSSL OK -> reliable\n            (\"OpenSSL 1.1.1\", 0x101010CF, \"cpython\", (3, 9, 2), None, True),\n            # not OpenSSSL -> unreliable\n            (\"LibreSSL 2.8.3\", 0x101010CF, \"cpython\", (3, 10, 0), None, False),\n            # old OpenSSL and old Python, unreliable\n            (\"OpenSSL 1.1.0\", 0x10101000, \"cpython\", (3, 9, 2), None, False),\n        ],\n    )\n    def test_is_has_never_check_common_name_reliable(\n        self,\n        openssl_version: str,\n        openssl_version_number: int,\n        implementation_name: str,\n        version_info: _TYPE_VERSION_INFO,\n        pypy_version_info: _TYPE_VERSION_INFO | None,\n        reliable: bool,\n    ) -> None:\n        assert (\n            _is_has_never_check_common_name_reliable(\n                openssl_version,\n                openssl_version_number,\n                implementation_name,\n                version_info,\n                pypy_version_info,\n            )\n            == reliable\n        )\n\n\nidna_blocker = ImportBlocker(\"idna\")\nmodule_stash = ModuleStash(\"urllib3\")\n\n\nclass TestUtilWithoutIdna:\n    @classmethod\n    def setup_class(cls) -> None:\n        sys.modules.pop(\"idna\", None)\n\n        module_stash.stash()\n        sys.meta_path.insert(0, idna_blocker)\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        sys.meta_path.remove(idna_blocker)\n        module_stash.pop()\n\n    def test_parse_url_without_idna(self) -> None:\n        url = \"http://\\uD7FF.com\"\n        with pytest.raises(LocationParseError, match=f\"Failed to parse: {url}\"):\n            parse_url(url)\n", "test/test_filepost.py": "from __future__ import annotations\n\nimport pytest\n\nfrom urllib3.fields import RequestField\nfrom urllib3.filepost import _TYPE_FIELDS, encode_multipart_formdata\n\nBOUNDARY = \"!! test boundary !!\"\nBOUNDARY_BYTES = BOUNDARY.encode()\n\n\nclass TestMultipartEncoding:\n    @pytest.mark.parametrize(\n        \"fields\", [dict(k=\"v\", k2=\"v2\"), [(\"k\", \"v\"), (\"k2\", \"v2\")]]\n    )\n    def test_input_datastructures(self, fields: _TYPE_FIELDS) -> None:\n        encoded, _ = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        assert encoded.count(BOUNDARY_BYTES) == 3\n\n    @pytest.mark.parametrize(\n        \"fields\",\n        [\n            [(\"k\", \"v\"), (\"k2\", \"v2\")],\n            [(\"k\", b\"v\"), (\"k2\", b\"v2\")],\n            [(\"k\", b\"v\"), (\"k2\", \"v2\")],\n        ],\n    )\n    def test_field_encoding(self, fields: _TYPE_FIELDS) -> None:\n        encoded, content_type = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        expected = (\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b'Content-Disposition: form-data; name=\"k\"\\r\\n'\n            b\"\\r\\n\"\n            b\"v\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b'Content-Disposition: form-data; name=\"k2\"\\r\\n'\n            b\"\\r\\n\"\n            b\"v2\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"--\\r\\n\"\n        )\n\n        assert encoded == expected\n\n        assert content_type == \"multipart/form-data; boundary=\" + str(BOUNDARY)\n\n    def test_filename(self) -> None:\n        fields = [(\"k\", (\"somename\", b\"v\"))]\n\n        encoded, content_type = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        expected = (\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b'Content-Disposition: form-data; name=\"k\"; filename=\"somename\"\\r\\n'\n            b\"Content-Type: application/octet-stream\\r\\n\"\n            b\"\\r\\n\"\n            b\"v\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"--\\r\\n\"\n        )\n\n        assert encoded == expected\n\n        assert content_type == \"multipart/form-data; boundary=\" + str(BOUNDARY)\n\n    def test_textplain(self) -> None:\n        fields = [(\"k\", (\"somefile.txt\", b\"v\"))]\n\n        encoded, content_type = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        expected = (\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b'Content-Disposition: form-data; name=\"k\"; filename=\"somefile.txt\"\\r\\n'\n            b\"Content-Type: text/plain\\r\\n\"\n            b\"\\r\\n\"\n            b\"v\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"--\\r\\n\"\n        )\n\n        assert encoded == expected\n\n        assert content_type == \"multipart/form-data; boundary=\" + str(BOUNDARY)\n\n    def test_explicit(self) -> None:\n        fields = [(\"k\", (\"somefile.txt\", b\"v\", \"image/jpeg\"))]\n\n        encoded, content_type = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        expected = (\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b'Content-Disposition: form-data; name=\"k\"; filename=\"somefile.txt\"\\r\\n'\n            b\"Content-Type: image/jpeg\\r\\n\"\n            b\"\\r\\n\"\n            b\"v\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"--\\r\\n\"\n        )\n\n        assert encoded == expected\n\n        assert content_type == \"multipart/form-data; boundary=\" + str(BOUNDARY)\n\n    def test_request_fields(self) -> None:\n        fields = [\n            RequestField(\n                \"k\",\n                b\"v\",\n                filename=\"somefile.txt\",\n                headers={\"Content-Type\": \"image/jpeg\"},\n            )\n        ]\n\n        encoded, content_type = encode_multipart_formdata(fields, boundary=BOUNDARY)\n        expected = (\n            b\"--\" + BOUNDARY_BYTES + b\"\\r\\n\"\n            b\"Content-Type: image/jpeg\\r\\n\"\n            b\"\\r\\n\"\n            b\"v\\r\\n\"\n            b\"--\" + BOUNDARY_BYTES + b\"--\\r\\n\"\n        )\n\n        assert encoded == expected\n", "test/test_retry.py": "from __future__ import annotations\n\nimport datetime\nfrom test import DUMMY_POOL\nfrom unittest import mock\n\nimport pytest\n\nfrom urllib3.exceptions import (\n    ConnectTimeoutError,\n    InvalidHeader,\n    MaxRetryError,\n    ReadTimeoutError,\n    ResponseError,\n    SSLError,\n)\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util.retry import RequestHistory, Retry\n\n\nclass TestRetry:\n    def test_string(self) -> None:\n        \"\"\"Retry string representation looks the way we expect\"\"\"\n        retry = Retry()\n        assert (\n            str(retry)\n            == \"Retry(total=10, connect=None, read=None, redirect=None, status=None)\"\n        )\n        for _ in range(3):\n            retry = retry.increment(method=\"GET\")\n        assert (\n            str(retry)\n            == \"Retry(total=7, connect=None, read=None, redirect=None, status=None)\"\n        )\n\n    def test_retry_both_specified(self) -> None:\n        \"\"\"Total can win if it's lower than the connect value\"\"\"\n        error = ConnectTimeoutError()\n        retry = Retry(connect=3, total=2)\n        retry = retry.increment(error=error)\n        retry = retry.increment(error=error)\n        with pytest.raises(MaxRetryError) as e:\n            retry.increment(error=error)\n        assert e.value.reason == error\n\n    def test_retry_higher_total_loses(self) -> None:\n        \"\"\"A lower connect timeout than the total is honored\"\"\"\n        error = ConnectTimeoutError()\n        retry = Retry(connect=2, total=3)\n        retry = retry.increment(error=error)\n        retry = retry.increment(error=error)\n        with pytest.raises(MaxRetryError):\n            retry.increment(error=error)\n\n    def test_retry_higher_total_loses_vs_read(self) -> None:\n        \"\"\"A lower read timeout than the total is honored\"\"\"\n        error = ReadTimeoutError(DUMMY_POOL, \"/\", \"read timed out\")\n        retry = Retry(read=2, total=3)\n        retry = retry.increment(method=\"GET\", error=error)\n        retry = retry.increment(method=\"GET\", error=error)\n        with pytest.raises(MaxRetryError):\n            retry.increment(method=\"GET\", error=error)\n\n    def test_retry_total_none(self) -> None:\n        \"\"\"if Total is none, connect error should take precedence\"\"\"\n        error = ConnectTimeoutError()\n        retry = Retry(connect=2, total=None)\n        retry = retry.increment(error=error)\n        retry = retry.increment(error=error)\n        with pytest.raises(MaxRetryError) as e:\n            retry.increment(error=error)\n        assert e.value.reason == error\n\n        timeout_error = ReadTimeoutError(DUMMY_POOL, \"/\", \"read timed out\")\n        retry = Retry(connect=2, total=None)\n        retry = retry.increment(method=\"GET\", error=timeout_error)\n        retry = retry.increment(method=\"GET\", error=timeout_error)\n        retry = retry.increment(method=\"GET\", error=timeout_error)\n        assert not retry.is_exhausted()\n\n    def test_retry_default(self) -> None:\n        \"\"\"If no value is specified, should retry connects 3 times\"\"\"\n        retry = Retry()\n        assert retry.total == 10\n        assert retry.connect is None\n        assert retry.read is None\n        assert retry.redirect is None\n        assert retry.other is None\n\n        error = ConnectTimeoutError()\n        retry = Retry(connect=1)\n        retry = retry.increment(error=error)\n        with pytest.raises(MaxRetryError):\n            retry.increment(error=error)\n\n        retry = Retry(connect=1)\n        retry = retry.increment(error=error)\n        assert not retry.is_exhausted()\n\n        assert Retry(0).raise_on_redirect\n        assert not Retry(False).raise_on_redirect\n\n    def test_retry_other(self) -> None:\n        \"\"\"If an unexpected error is raised, should retry other times\"\"\"\n        other_error = SSLError()\n        retry = Retry(connect=1)\n        retry = retry.increment(error=other_error)\n        retry = retry.increment(error=other_error)\n        assert not retry.is_exhausted()\n\n        retry = Retry(other=1)\n        retry = retry.increment(error=other_error)\n        with pytest.raises(MaxRetryError) as e:\n            retry.increment(error=other_error)\n        assert e.value.reason == other_error\n\n    def test_retry_read_zero(self) -> None:\n        \"\"\"No second chances on read timeouts, by default\"\"\"\n        error = ReadTimeoutError(DUMMY_POOL, \"/\", \"read timed out\")\n        retry = Retry(read=0)\n        with pytest.raises(MaxRetryError) as e:\n            retry.increment(method=\"GET\", error=error)\n        assert e.value.reason == error\n\n    def test_status_counter(self) -> None:\n        resp = HTTPResponse(status=400)\n        retry = Retry(status=2)\n        retry = retry.increment(response=resp)\n        retry = retry.increment(response=resp)\n        msg = ResponseError.SPECIFIC_ERROR.format(status_code=400)\n        with pytest.raises(MaxRetryError, match=msg):\n            retry.increment(response=resp)\n\n    def test_backoff(self) -> None:\n        \"\"\"Backoff is computed correctly\"\"\"\n        max_backoff = Retry.DEFAULT_BACKOFF_MAX\n\n        retry = Retry(total=100, backoff_factor=0.2)\n        assert retry.get_backoff_time() == 0  # First request\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0  # First retry\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.backoff_factor == 0.2\n        assert retry.total == 98\n        assert retry.get_backoff_time() == 0.4  # Start backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0.8\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 1.6\n\n        for _ in range(10):\n            retry = retry.increment(method=\"GET\")\n\n        assert retry.get_backoff_time() == max_backoff\n\n    def test_configurable_backoff_max(self) -> None:\n        \"\"\"Configurable backoff is computed correctly\"\"\"\n        max_backoff = 1\n\n        retry = Retry(total=100, backoff_factor=0.2, backoff_max=max_backoff)\n        assert retry.get_backoff_time() == 0  # First request\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0  # First retry\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.backoff_factor == 0.2\n        assert retry.total == 98\n        assert retry.get_backoff_time() == 0.4  # Start backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0.8\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == max_backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == max_backoff\n\n    def test_backoff_jitter(self) -> None:\n        \"\"\"Backoff with jitter is computed correctly\"\"\"\n        max_backoff = 1\n        jitter = 0.4\n        retry = Retry(\n            total=100,\n            backoff_factor=0.2,\n            backoff_max=max_backoff,\n            backoff_jitter=jitter,\n        )\n        assert retry.get_backoff_time() == 0  # First request\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0  # First retry\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.backoff_factor == 0.2\n        assert retry.total == 98\n        assert 0.4 <= retry.get_backoff_time() <= 0.8  # Start backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert 0.8 <= retry.get_backoff_time() <= max_backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == max_backoff\n\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == max_backoff\n\n    def test_zero_backoff(self) -> None:\n        retry = Retry()\n        assert retry.get_backoff_time() == 0\n        retry = retry.increment(method=\"GET\")\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0\n\n    def test_backoff_reset_after_redirect(self) -> None:\n        retry = Retry(total=100, redirect=5, backoff_factor=0.2)\n        retry = retry.increment(method=\"GET\")\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0.4\n        redirect_response = HTTPResponse(status=302, headers={\"location\": \"test\"})\n        retry = retry.increment(method=\"GET\", response=redirect_response)\n        assert retry.get_backoff_time() == 0\n        retry = retry.increment(method=\"GET\")\n        retry = retry.increment(method=\"GET\")\n        assert retry.get_backoff_time() == 0.4\n\n    def test_sleep(self) -> None:\n        # sleep a very small amount of time so our code coverage is happy\n        retry = Retry(backoff_factor=0.0001)\n        retry = retry.increment(method=\"GET\")\n        retry = retry.increment(method=\"GET\")\n        retry.sleep()\n\n    def test_status_forcelist(self) -> None:\n        retry = Retry(status_forcelist=range(500, 600))\n        assert not retry.is_retry(\"GET\", status_code=200)\n        assert not retry.is_retry(\"GET\", status_code=400)\n        assert retry.is_retry(\"GET\", status_code=500)\n\n        retry = Retry(total=1, status_forcelist=[418])\n        assert not retry.is_retry(\"GET\", status_code=400)\n        assert retry.is_retry(\"GET\", status_code=418)\n\n        # String status codes are not matched.\n        retry = Retry(total=1, status_forcelist=[\"418\"])  # type: ignore[list-item]\n        assert not retry.is_retry(\"GET\", status_code=418)\n\n    def test_allowed_methods_with_status_forcelist(self) -> None:\n        # Falsey allowed_methods means to retry on any method.\n        retry = Retry(status_forcelist=[500], allowed_methods=None)\n        assert retry.is_retry(\"GET\", status_code=500)\n        assert retry.is_retry(\"POST\", status_code=500)\n\n        # Criteria of allowed_methods and status_forcelist are ANDed.\n        retry = Retry(status_forcelist=[500], allowed_methods=[\"POST\"])\n        assert not retry.is_retry(\"GET\", status_code=500)\n        assert retry.is_retry(\"POST\", status_code=500)\n\n    def test_exhausted(self) -> None:\n        assert not Retry(0).is_exhausted()\n        assert Retry(-1).is_exhausted()\n        assert Retry(1).increment(method=\"GET\").total == 0\n\n    @pytest.mark.parametrize(\"total\", [-1, 0])\n    def test_disabled(self, total: int) -> None:\n        with pytest.raises(MaxRetryError):\n            Retry(total).increment(method=\"GET\")\n\n    def test_error_message(self) -> None:\n        retry = Retry(total=0)\n        with pytest.raises(MaxRetryError, match=\"read timed out\") as e:\n            retry = retry.increment(\n                method=\"GET\", error=ReadTimeoutError(DUMMY_POOL, \"/\", \"read timed out\")\n            )\n        assert \"Caused by redirect\" not in str(e.value)\n\n        retry = Retry(total=1)\n        retry = retry.increment(\"POST\", \"/\")\n        with pytest.raises(MaxRetryError, match=ResponseError.GENERIC_ERROR) as e:\n            retry = retry.increment(\"POST\", \"/\")\n        assert \"Caused by redirect\" not in str(e.value)\n        assert isinstance(e.value.reason, ResponseError)\n\n        retry = Retry(total=1)\n        response = HTTPResponse(status=500)\n        msg = ResponseError.SPECIFIC_ERROR.format(status_code=500)\n        retry = retry.increment(\"POST\", \"/\", response=response)\n        with pytest.raises(MaxRetryError, match=msg) as e:\n            retry = retry.increment(\"POST\", \"/\", response=response)\n        assert \"Caused by redirect\" not in str(e.value)\n\n        retry = Retry(connect=1)\n        retry = retry.increment(error=ConnectTimeoutError(\"conntimeout\"))\n        with pytest.raises(MaxRetryError, match=\"conntimeout\") as e:\n            retry = retry.increment(error=ConnectTimeoutError(\"conntimeout\"))\n        assert \"Caused by redirect\" not in str(e.value)\n\n    def test_history(self) -> None:\n        retry = Retry(total=10, allowed_methods=frozenset([\"GET\", \"POST\"]))\n        assert retry.history == tuple()\n        connection_error = ConnectTimeoutError(\"conntimeout\")\n        retry = retry.increment(\"GET\", \"/test1\", None, connection_error)\n        test_history1 = (RequestHistory(\"GET\", \"/test1\", connection_error, None, None),)\n        assert retry.history == test_history1\n\n        read_error = ReadTimeoutError(DUMMY_POOL, \"/test2\", \"read timed out\")\n        retry = retry.increment(\"POST\", \"/test2\", None, read_error)\n        test_history2 = (\n            RequestHistory(\"GET\", \"/test1\", connection_error, None, None),\n            RequestHistory(\"POST\", \"/test2\", read_error, None, None),\n        )\n        assert retry.history == test_history2\n\n        response = HTTPResponse(status=500)\n        retry = retry.increment(\"GET\", \"/test3\", response, None)\n        test_history3 = (\n            RequestHistory(\"GET\", \"/test1\", connection_error, None, None),\n            RequestHistory(\"POST\", \"/test2\", read_error, None, None),\n            RequestHistory(\"GET\", \"/test3\", None, 500, None),\n        )\n        assert retry.history == test_history3\n\n    def test_retry_method_not_allowed(self) -> None:\n        error = ReadTimeoutError(DUMMY_POOL, \"/\", \"read timed out\")\n        retry = Retry()\n        with pytest.raises(ReadTimeoutError):\n            retry.increment(method=\"POST\", error=error)\n\n    def test_retry_default_remove_headers_on_redirect(self) -> None:\n        retry = Retry()\n\n        assert retry.remove_headers_on_redirect == {\n            \"authorization\",\n            \"proxy-authorization\",\n            \"cookie\",\n        }\n\n    def test_retry_set_remove_headers_on_redirect(self) -> None:\n        retry = Retry(remove_headers_on_redirect=[\"X-API-Secret\"])\n\n        assert retry.remove_headers_on_redirect == {\"x-api-secret\"}\n\n    @pytest.mark.parametrize(\"value\", [\"-1\", \"+1\", \"1.0\", \"\\xb2\"])  # \\xb2 = ^2\n    def test_parse_retry_after_invalid(self, value: str) -> None:\n        retry = Retry()\n        with pytest.raises(InvalidHeader):\n            retry.parse_retry_after(value)\n\n    @pytest.mark.parametrize(\n        \"value, expected\", [(\"0\", 0), (\"1000\", 1000), (\"\\t42 \", 42)]\n    )\n    def test_parse_retry_after(self, value: str, expected: int) -> None:\n        retry = Retry()\n        assert retry.parse_retry_after(value) == expected\n\n    @pytest.mark.parametrize(\"respect_retry_after_header\", [True, False])\n    def test_respect_retry_after_header_propagated(\n        self, respect_retry_after_header: bool\n    ) -> None:\n        retry = Retry(respect_retry_after_header=respect_retry_after_header)\n        new_retry = retry.new()\n        assert new_retry.respect_retry_after_header == respect_retry_after_header\n\n    @pytest.mark.parametrize(\n        \"retry_after_header,respect_retry_after_header,sleep_duration\",\n        [\n            (\"3600\", True, 3600),\n            (\"3600\", False, None),\n            # Will sleep due to header is 1 hour in future\n            (\"Mon, 3 Jun 2019 12:00:00 UTC\", True, 3600),\n            # Won't sleep due to not respecting header\n            (\"Mon, 3 Jun 2019 12:00:00 UTC\", False, None),\n            # Won't sleep due to current time reached\n            (\"Mon, 3 Jun 2019 11:00:00 UTC\", True, None),\n            # Won't sleep due to current time reached + not respecting header\n            (\"Mon, 3 Jun 2019 11:00:00 UTC\", False, None),\n            # Handle all the formats in RFC 7231 Section 7.1.1.1\n            (\"Mon, 03 Jun 2019 11:30:12 GMT\", True, 1812),\n            (\"Monday, 03-Jun-19 11:30:12 GMT\", True, 1812),\n            # Assume that datetimes without a timezone are in UTC per RFC 7231\n            (\"Mon Jun  3 11:30:12 2019\", True, 1812),\n        ],\n    )\n    @pytest.mark.parametrize(\n        \"stub_timezone\",\n        [\n            \"UTC\",\n            \"Asia/Jerusalem\",\n            None,\n        ],\n        indirect=True,\n    )\n    @pytest.mark.usefixtures(\"stub_timezone\")\n    def test_respect_retry_after_header_sleep(\n        self,\n        retry_after_header: str,\n        respect_retry_after_header: bool,\n        sleep_duration: int | None,\n    ) -> None:\n        retry = Retry(respect_retry_after_header=respect_retry_after_header)\n\n        with mock.patch(\n            \"time.time\",\n            return_value=datetime.datetime(\n                2019, 6, 3, 11, tzinfo=datetime.timezone.utc\n            ).timestamp(),\n        ), mock.patch(\"time.sleep\") as sleep_mock:\n            # for the default behavior, it must be in RETRY_AFTER_STATUS_CODES\n            response = HTTPResponse(\n                status=503, headers={\"Retry-After\": retry_after_header}\n            )\n\n            retry.sleep(response)\n\n            # The expected behavior is that we'll only sleep if respecting\n            # this header (since we won't have any backoff sleep attempts)\n            if respect_retry_after_header and sleep_duration is not None:\n                sleep_mock.assert_called_with(sleep_duration)\n            else:\n                sleep_mock.assert_not_called()\n", "test/tz_stub.py": "from __future__ import annotations\n\nimport datetime\nimport os\nimport time\nimport typing\nfrom contextlib import contextmanager\n\nimport pytest\n\ntry:\n    import zoneinfo\nexcept ImportError:\n    # Python < 3.9\n    from backports import zoneinfo  # type: ignore[no-redef]\n\n\n@contextmanager\ndef stub_timezone_ctx(tzname: str | None) -> typing.Generator[None, None, None]:\n    \"\"\"\n    Switch to a locally-known timezone specified by `tzname`.\n    On exit, restore the previous timezone.\n    If `tzname` is `None`, do nothing.\n    \"\"\"\n    if tzname is None:\n        yield\n        return\n\n    # Only supported on Unix\n    if not hasattr(time, \"tzset\"):\n        pytest.skip(\"Timezone patching is not supported\")\n\n    # Make sure the new timezone exists\n    try:\n        zoneinfo.ZoneInfo(tzname)\n    except zoneinfo.ZoneInfoNotFoundError:\n        raise ValueError(f\"Invalid timezone specified: {tzname!r}\")\n\n    # Get the current timezone\n    old_tzname = datetime.datetime.now().astimezone().tzname()\n    if old_tzname is None:\n        raise OSError(\"Cannot determine current timezone\")\n\n    os.environ[\"TZ\"] = tzname\n    time.tzset()\n    yield\n    os.environ[\"TZ\"] = old_tzname\n    time.tzset()\n", "test/test_response.py": "from __future__ import annotations\n\nimport contextlib\nimport http.client as httplib\nimport socket\nimport ssl\nimport typing\nimport zlib\nfrom base64 import b64decode\nfrom http.client import IncompleteRead as httplib_IncompleteRead\nfrom io import BufferedReader, BytesIO, TextIOWrapper\nfrom test import onlyBrotli, onlyZstd\nfrom unittest import mock\n\nimport pytest\n\nfrom urllib3 import HTTPHeaderDict\nfrom urllib3.exceptions import (\n    BodyNotHttplibCompatible,\n    DecodeError,\n    IncompleteRead,\n    InvalidChunkLength,\n    InvalidHeader,\n    ProtocolError,\n    ResponseNotChunked,\n    SSLError,\n)\nfrom urllib3.response import (  # type: ignore[attr-defined]\n    BaseHTTPResponse,\n    BytesQueueBuffer,\n    HTTPResponse,\n    brotli,\n)\nfrom urllib3.util.response import is_fp_closed\nfrom urllib3.util.retry import RequestHistory, Retry\n\n\nclass TestBytesQueueBuffer:\n    def test_single_chunk(self) -> None:\n        buffer = BytesQueueBuffer()\n        assert len(buffer) == 0\n        with pytest.raises(RuntimeError, match=\"buffer is empty\"):\n            assert buffer.get(10)\n\n        assert buffer.get(0) == b\"\"\n\n        buffer.put(b\"foo\")\n        with pytest.raises(ValueError, match=\"n should be > 0\"):\n            buffer.get(-1)\n\n        assert buffer.get(1) == b\"f\"\n        assert buffer.get(2) == b\"oo\"\n        with pytest.raises(RuntimeError, match=\"buffer is empty\"):\n            assert buffer.get(10)\n\n    def test_read_too_much(self) -> None:\n        buffer = BytesQueueBuffer()\n        buffer.put(b\"foo\")\n        assert buffer.get(100) == b\"foo\"\n\n    def test_multiple_chunks(self) -> None:\n        buffer = BytesQueueBuffer()\n        buffer.put(b\"foo\")\n        buffer.put(b\"bar\")\n        buffer.put(b\"baz\")\n        assert len(buffer) == 9\n\n        assert buffer.get(1) == b\"f\"\n        assert len(buffer) == 8\n        assert buffer.get(4) == b\"ooba\"\n        assert len(buffer) == 4\n        assert buffer.get(4) == b\"rbaz\"\n        assert len(buffer) == 0\n\n    def test_get_all_empty(self) -> None:\n        q = BytesQueueBuffer()\n        assert q.get_all() == b\"\"\n        assert len(q) == 0\n\n    def test_get_all_single(self) -> None:\n        q = BytesQueueBuffer()\n        q.put(b\"a\")\n        assert q.get_all() == b\"a\"\n        assert len(q) == 0\n\n    def test_get_all_many(self) -> None:\n        q = BytesQueueBuffer()\n        q.put(b\"a\")\n        q.put(b\"b\")\n        q.put(b\"c\")\n        assert q.get_all() == b\"abc\"\n        assert len(q) == 0\n\n    @pytest.mark.parametrize(\n        \"get_func\",\n        (lambda b: b.get(len(b)), lambda b: b.get_all()),\n        ids=(\"get\", \"get_all\"),\n    )\n    @pytest.mark.limit_memory(\"12.5 MB\")  # assert that we're not doubling memory usage\n    def test_memory_usage(\n        self, get_func: typing.Callable[[BytesQueueBuffer], str]\n    ) -> None:\n        # Allocate 10 1MiB chunks\n        buffer = BytesQueueBuffer()\n        for i in range(10):\n            # This allocates 2MiB, putting the max at around 12MiB. Not sure why.\n            buffer.put(bytes(2**20))\n\n        assert len(get_func(buffer)) == 10 * 2**20\n\n    @pytest.mark.limit_memory(\"10.01 MB\")\n    def test_get_all_memory_usage_single_chunk(self) -> None:\n        buffer = BytesQueueBuffer()\n        chunk = bytes(10 * 2**20)  # 10 MiB\n        buffer.put(chunk)\n        assert buffer.get_all() is chunk\n\n\n# A known random (i.e, not-too-compressible) payload generated with:\n#    \"\".join(random.choice(string.printable) for i in range(512))\n#    .encode(\"zlib\").encode(\"base64\")\n# Randomness in tests == bad, and fixing a seed may not be sufficient.\nZLIB_PAYLOAD = b64decode(\n    b\"\"\"\\\neJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+\nlzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi\npis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk\nnufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ\nKhe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn\na3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ\nauHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW\nS5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV\nnP4HF2uWHA==\"\"\"\n)\n\n\n@pytest.fixture\ndef sock() -> typing.Generator[socket.socket, None, None]:\n    s = socket.socket()\n    yield s\n    s.close()\n\n\nclass TestLegacyResponse:\n    def test_getheaders(self) -> None:\n        headers = {\"host\": \"example.com\"}\n        r = HTTPResponse(headers=headers)\n        with pytest.warns(\n            DeprecationWarning,\n            match=r\"HTTPResponse.getheaders\\(\\) is deprecated\",\n        ):\n            assert r.getheaders() == HTTPHeaderDict(headers)\n\n    def test_getheader(self) -> None:\n        headers = {\"host\": \"example.com\"}\n        r = HTTPResponse(headers=headers)\n        with pytest.warns(\n            DeprecationWarning,\n            match=r\"HTTPResponse.getheader\\(\\) is deprecated\",\n        ):\n            assert r.getheader(\"host\") == \"example.com\"\n\n\nclass TestResponse:\n    def test_cache_content(self) -> None:\n        r = HTTPResponse(b\"foo\")\n        assert r._body == b\"foo\"\n        assert r.data == b\"foo\"\n        assert r._body == b\"foo\"\n\n    def test_cache_content_preload_false(self) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert not r._body\n        assert r.data == b\"foo\"\n        assert r._body == b\"foo\"\n        assert r.data == b\"foo\"\n\n    def test_default(self) -> None:\n        r = HTTPResponse()\n        assert r.data is None\n\n    def test_none(self) -> None:\n        r = HTTPResponse(None)  # type: ignore[arg-type]\n        assert r.data is None\n\n    def test_preload(self) -> None:\n        fp = BytesIO(b\"foo\")\n\n        r = HTTPResponse(fp, preload_content=True)\n\n        assert fp.tell() == len(b\"foo\")\n        assert r.data == b\"foo\"\n\n    def test_no_preload(self) -> None:\n        fp = BytesIO(b\"foo\")\n\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert fp.tell() == 0\n        assert r.data == b\"foo\"\n        assert fp.tell() == len(b\"foo\")\n\n    def test_decode_bad_data(self) -> None:\n        fp = BytesIO(b\"\\x00\" * 10)\n        with pytest.raises(DecodeError):\n            HTTPResponse(fp, headers={\"content-encoding\": \"deflate\"})\n\n    def test_reference_read(self) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert r.read(0) == b\"\"\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"\n\n    @pytest.mark.parametrize(\"read_args\", ((), (None,), (-1,)))\n    def test_reference_read_until_eof(self, read_args: tuple[typing.Any, ...]) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n        assert r.read(*read_args) == b\"foo\"\n\n    def test_reference_read1(self) -> None:\n        fp = BytesIO(b\"foobar\")\n        r = HTTPResponse(fp, preload_content=False)\n\n        assert r.read1(0) == b\"\"\n        assert r.read1(1) == b\"f\"\n        assert r.read1(2) == b\"oo\"\n        assert r.read1() == b\"bar\"\n        assert r.read1() == b\"\"\n\n    @pytest.mark.parametrize(\"read1_args\", ((), (None,), (-1,)))\n    def test_reference_read1_without_limit(\n        self, read1_args: tuple[typing.Any, ...]\n    ) -> None:\n        fp = BytesIO(b\"foo\")\n        r = HTTPResponse(fp, preload_content=False)\n        assert r.read1(*read1_args) == b\"foo\"\n\n    def test_reference_read1_nodecode(self) -> None:\n        fp = BytesIO(b\"foobar\")\n        r = HTTPResponse(fp, preload_content=False, decode_content=False)\n\n        assert r.read1(0) == b\"\"\n        assert r.read1(1) == b\"f\"\n        assert r.read1(2) == b\"oo\"\n        assert r.read1() == b\"bar\"\n        assert r.read1() == b\"\"\n\n    def test_decoding_read1(self) -> None:\n        data = zlib.compress(b\"foobar\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n\n        assert r.read1(1) == b\"f\"\n        assert r.read1(2) == b\"oo\"\n        assert r.read1() == b\"bar\"\n        assert r.read1() == b\"\"\n\n    def test_decode_deflate(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"deflate\"})\n\n        assert r.data == b\"foo\"\n\n    def test_decode_deflate_case_insensitve(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"DeFlAtE\"})\n\n        assert r.data == b\"foo\"\n\n    def test_chunked_decoding_deflate(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"\n\n    def test_chunked_decoding_deflate2(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"\n\n    @pytest.mark.parametrize(\"content_encoding\", [\"gzip\", \"x-gzip\"])\n    def test_chunked_decoding_gzip(self, content_encoding: str) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": content_encoding}, preload_content=False\n        )\n\n        assert r.read(1) == b\"f\"\n        assert r.read(2) == b\"oo\"\n        assert r.read() == b\"\"\n        assert r.read() == b\"\"\n\n    def test_decode_gzip_multi_member(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n        data = data * 3\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"gzip\"})\n\n        assert r.data == b\"foofoofoo\"\n\n    def test_decode_gzip_error(self) -> None:\n        fp = BytesIO(b\"foo\")\n        with pytest.raises(DecodeError):\n            HTTPResponse(fp, headers={\"content-encoding\": \"gzip\"})\n\n    def test_decode_gzip_swallow_garbage(self) -> None:\n        # When data comes from multiple calls to read(), data after\n        # the first zlib error (here triggered by garbage) should be\n        # ignored.\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n        data = data * 3 + b\"foo\"\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"gzip\"}, preload_content=False\n        )\n        ret = b\"\"\n        for _ in range(100):\n            ret += r.read(1)\n            if r.closed:\n                break\n\n        assert ret == b\"foofoofoo\"\n\n    def test_chunked_decoding_gzip_swallow_garbage(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n        data = data * 3 + b\"foo\"\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"gzip\"})\n\n        assert r.data == b\"foofoofoo\"\n\n    @onlyBrotli()\n    def test_decode_brotli(self) -> None:\n        data = brotli.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"br\"})\n        assert r.data == b\"foo\"\n\n    @onlyBrotli()\n    def test_chunked_decoding_brotli(self) -> None:\n        data = brotli.compress(b\"foobarbaz\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"br\"}, preload_content=False)\n\n        ret = b\"\"\n        for _ in range(100):\n            ret += r.read(1)\n            if r.closed:\n                break\n        assert ret == b\"foobarbaz\"\n\n    @onlyBrotli()\n    def test_decode_brotli_error(self) -> None:\n        fp = BytesIO(b\"foo\")\n        with pytest.raises(DecodeError):\n            HTTPResponse(fp, headers={\"content-encoding\": \"br\"})\n\n    @onlyZstd()\n    def test_decode_zstd(self) -> None:\n        import zstandard as zstd\n\n        data = zstd.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"zstd\"})\n        assert r.data == b\"foo\"\n\n    @onlyZstd()\n    def test_decode_multiframe_zstd(self) -> None:\n        import zstandard as zstd\n\n        data = (\n            # Zstandard frame\n            zstd.compress(b\"foo\")\n            # skippable frame (must be ignored)\n            + bytes.fromhex(\n                \"50 2A 4D 18\"  # Magic_Number (little-endian)\n                \"07 00 00 00\"  # Frame_Size (little-endian)\n                \"00 00 00 00 00 00 00\"  # User_Data\n            )\n            # Zstandard frame\n            + zstd.compress(b\"bar\")\n        )\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"zstd\"})\n        assert r.data == b\"foobar\"\n\n    @onlyZstd()\n    def test_chunked_decoding_zstd(self) -> None:\n        import zstandard as zstd\n\n        data = zstd.compress(b\"foobarbaz\")\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"zstd\"}, preload_content=False\n        )\n\n        ret = b\"\"\n\n        for _ in range(100):\n            ret += r.read(1)\n            if r.closed:\n                break\n        assert ret == b\"foobarbaz\"\n\n    decode_param_set = [\n        b\"foo\",\n        b\"x\" * 100,\n    ]\n\n    @onlyZstd()\n    @pytest.mark.parametrize(\"data\", decode_param_set)\n    def test_decode_zstd_error(self, data: bytes) -> None:\n        fp = BytesIO(data)\n\n        with pytest.raises(DecodeError):\n            HTTPResponse(fp, headers={\"content-encoding\": \"zstd\"})\n\n    @onlyZstd()\n    @pytest.mark.parametrize(\"data\", decode_param_set)\n    def test_decode_zstd_incomplete_preload_content(self, data: bytes) -> None:\n        import zstandard as zstd\n\n        data = zstd.compress(data)\n        fp = BytesIO(data[:-1])\n\n        with pytest.raises(DecodeError):\n            HTTPResponse(fp, headers={\"content-encoding\": \"zstd\"})\n\n    @onlyZstd()\n    @pytest.mark.parametrize(\"data\", decode_param_set)\n    def test_decode_zstd_incomplete_read(self, data: bytes) -> None:\n        import zstandard as zstd\n\n        data = zstd.compress(data)\n        fp = BytesIO(data[:-1])  # shorten the data to trigger DecodeError\n\n        # create response object without(!) reading/decoding the content\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"zstd\"}, preload_content=False\n        )\n\n        # read/decode, expecting DecodeError\n        with pytest.raises(DecodeError):\n            r.read(decode_content=True)\n\n    @onlyZstd()\n    @pytest.mark.parametrize(\"data\", decode_param_set)\n    def test_decode_zstd_incomplete_read1(self, data: bytes) -> None:\n        import zstandard as zstd\n\n        data = zstd.compress(data)\n        fp = BytesIO(data[:-1])\n\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"zstd\"}, preload_content=False\n        )\n\n        # read/decode via read1(!), expecting DecodeError\n        with pytest.raises(DecodeError):\n            amt_decoded = 0\n            # loop, as read1() may return just partial data\n            while amt_decoded < len(data):\n                part = r.read1(decode_content=True)\n                amt_decoded += len(part)\n\n    @onlyZstd()\n    @pytest.mark.parametrize(\"data\", decode_param_set)\n    def test_decode_zstd_read1(self, data: bytes) -> None:\n        import zstandard as zstd\n\n        encoded_data = zstd.compress(data)\n        fp = BytesIO(encoded_data)\n\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"zstd\"}, preload_content=False\n        )\n\n        amt_decoded = 0\n        decoded_data = b\"\"\n        # loop, as read1() may return just partial data\n        while amt_decoded < len(data):\n            part = r.read1(decode_content=True)\n            amt_decoded += len(part)\n            decoded_data += part\n        assert decoded_data == data\n\n    def test_multi_decoding_deflate_deflate(self) -> None:\n        data = zlib.compress(zlib.compress(b\"foo\"))\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"deflate, deflate\"})\n\n        assert r.data == b\"foo\"\n\n    def test_multi_decoding_deflate_gzip(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(zlib.compress(b\"foo\"))\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"deflate, gzip\"})\n\n        assert r.data == b\"foo\"\n\n    def test_multi_decoding_gzip_gzip(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(data)\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        r = HTTPResponse(fp, headers={\"content-encoding\": \"gzip, gzip\"})\n\n        assert r.data == b\"foo\"\n\n    def test_read_multi_decoding_deflate_deflate(self) -> None:\n        msg = b\"foobarbaz\" * 42\n        data = zlib.compress(zlib.compress(msg))\n\n        fp = BytesIO(data)\n        r = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate, deflate\"}, preload_content=False\n        )\n\n        assert r.read(3) == b\"foo\"\n        assert r.read(3) == b\"bar\"\n        assert r.read(3) == b\"baz\"\n        assert r.read(9) == b\"foobarbaz\"\n        assert r.read(9 * 3) == b\"foobarbaz\" * 3\n        assert r.read(9 * 37) == b\"foobarbaz\" * 37\n        assert r.read() == b\"\"\n\n    def test_body_blob(self) -> None:\n        resp = HTTPResponse(b\"foo\")\n        assert resp.data == b\"foo\"\n        assert resp.closed\n\n    @pytest.mark.filterwarnings(\"ignore::pytest.PytestUnraisableExceptionWarning\")\n    def test_base_io(self) -> None:\n        resp = BaseHTTPResponse(\n            status=200,\n            version=11,\n            version_string=\"HTTP/1.1\",\n            reason=None,\n            decode_content=False,\n            request_url=None,\n        )\n\n        assert not resp.closed\n        assert not resp.readable()\n        assert not resp.writable()\n\n        with pytest.raises(NotImplementedError):\n            resp.read()\n        with pytest.raises(NotImplementedError):\n            resp.close()\n\n    def test_io(self, sock: socket.socket) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(fp, preload_content=False)\n\n        assert not resp.closed\n        assert resp.readable()\n        assert not resp.writable()\n        with pytest.raises(IOError):\n            resp.fileno()\n\n        resp.close()\n        assert resp.closed\n\n        # Try closing with an `httplib.HTTPResponse`, because it has an\n        # `isclosed` method.\n        try:\n            hlr = httplib.HTTPResponse(sock)\n            resp2 = HTTPResponse(hlr, preload_content=False)\n            assert not resp2.closed\n            resp2.close()\n            assert resp2.closed\n        finally:\n            hlr.close()\n\n        # also try when only data is present.\n        resp3 = HTTPResponse(\"foodata\")\n        with pytest.raises(IOError):\n            resp3.fileno()\n\n        resp3._fp = 2\n        # A corner case where _fp is present but doesn't have `closed`,\n        # `isclosed`, or `fileno`.  Unlikely, but possible.\n        assert resp3.closed\n        with pytest.raises(IOError):\n            resp3.fileno()\n\n    def test_io_closed_consistently_by_read(self, sock: socket.socket) -> None:\n        try:\n            hlr = httplib.HTTPResponse(sock)\n            hlr.fp = BytesIO(b\"foo\")  # type: ignore[assignment]\n            hlr.chunked = 0  # type: ignore[assignment]\n            hlr.length = 3\n            with HTTPResponse(hlr, preload_content=False) as resp:\n                assert not resp.closed\n                assert resp._fp is not None\n                assert not resp._fp.isclosed()\n                assert not is_fp_closed(resp._fp)\n                assert not resp.isclosed()\n                resp.read()\n                assert resp.closed\n                assert resp._fp.isclosed()\n                assert is_fp_closed(resp._fp)\n                assert resp.isclosed()\n        finally:\n            hlr.close()\n\n    @pytest.mark.parametrize(\"read_amt\", (None, 3))\n    @pytest.mark.parametrize(\"length_known\", (True, False))\n    def test_io_closed_consistently_by_read1(\n        self, sock: socket.socket, length_known: bool, read_amt: int | None\n    ) -> None:\n        with httplib.HTTPResponse(sock) as hlr:\n            hlr.fp = BytesIO(b\"foo\")  # type: ignore[assignment]\n            hlr.chunked = 0  # type: ignore[assignment]\n            hlr.length = 3 if length_known else None\n            with HTTPResponse(hlr, preload_content=False) as resp:\n                if length_known:\n                    resp.length_remaining = 3\n                assert not resp.closed\n                assert resp._fp is not None\n                assert not resp._fp.isclosed()\n                assert not is_fp_closed(resp._fp)\n                assert not resp.isclosed()\n                resp.read1(read_amt)\n                # If content length is unknown, IO is not closed until\n                # the next read returning zero bytes.\n                if not length_known:\n                    assert not resp.closed\n                    assert resp._fp is not None\n                    assert not resp._fp.isclosed()\n                    assert not is_fp_closed(resp._fp)\n                    assert not resp.isclosed()\n                    resp.read1(read_amt)\n                assert resp.closed\n                assert resp._fp.isclosed()\n                assert is_fp_closed(resp._fp)\n                assert resp.isclosed()\n\n    @pytest.mark.parametrize(\"length_known\", (True, False))\n    def test_io_not_closed_until_all_data_is_read(\n        self, sock: socket.socket, length_known: bool\n    ) -> None:\n        with httplib.HTTPResponse(sock) as hlr:\n            hlr.fp = BytesIO(b\"foo\")  # type: ignore[assignment]\n            hlr.chunked = 0  # type: ignore[assignment]\n            length_remaining = 3\n            hlr.length = length_remaining if length_known else None\n            with HTTPResponse(hlr, preload_content=False) as resp:\n                if length_known:\n                    resp.length_remaining = length_remaining\n                while length_remaining:\n                    assert not resp.closed\n                    assert resp._fp is not None\n                    assert not resp._fp.isclosed()\n                    assert not is_fp_closed(resp._fp)\n                    assert not resp.isclosed()\n                    data = resp.read(1)\n                    assert len(data) == 1\n                    length_remaining -= 1\n                # If content length is unknown, IO is not closed until\n                # the next read returning zero bytes.\n                if not length_known:\n                    assert not resp.closed\n                    assert resp._fp is not None\n                    assert not resp._fp.isclosed()\n                    assert not is_fp_closed(resp._fp)\n                    assert not resp.isclosed()\n                    data = resp.read(1)\n                    assert len(data) == 0\n                assert resp.closed\n                assert resp._fp.isclosed()  # type: ignore[union-attr]\n                assert is_fp_closed(resp._fp)\n                assert resp.isclosed()\n\n    @pytest.mark.parametrize(\"length_known\", (True, False))\n    def test_io_not_closed_after_requesting_0_bytes(\n        self, sock: socket.socket, length_known: bool\n    ) -> None:\n        with httplib.HTTPResponse(sock) as hlr:\n            hlr.fp = BytesIO(b\"foo\")  # type: ignore[assignment]\n            hlr.chunked = 0  # type: ignore[assignment]\n            length_remaining = 3\n            hlr.length = length_remaining if length_known else None\n            with HTTPResponse(hlr, preload_content=False) as resp:\n                if length_known:\n                    resp.length_remaining = length_remaining\n                assert not resp.closed\n                assert resp._fp is not None\n                assert not resp._fp.isclosed()\n                assert not is_fp_closed(resp._fp)\n                assert not resp.isclosed()\n                data = resp.read(0)\n                assert data == b\"\"\n                assert not resp.closed\n                assert resp._fp is not None\n                assert not resp._fp.isclosed()\n                assert not is_fp_closed(resp._fp)\n                assert not resp.isclosed()\n\n    def test_io_bufferedreader(self) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(fp, preload_content=False)\n        br = BufferedReader(resp)  # type: ignore[arg-type]\n\n        assert br.read() == b\"foo\"\n\n        br.close()\n        assert resp.closed\n\n        # HTTPResponse.read() by default closes the response\n        # https://github.com/urllib3/urllib3/issues/1305\n        fp = BytesIO(b\"hello\\nworld\")\n        resp = HTTPResponse(fp, preload_content=False)\n        with pytest.raises(ValueError, match=\"readline of closed file\"):\n            list(BufferedReader(resp))  # type: ignore[arg-type]\n\n        b = b\"fooandahalf\"\n        fp = BytesIO(b)\n        resp = HTTPResponse(fp, preload_content=False)\n        br = BufferedReader(resp, 5)  # type: ignore[arg-type]\n\n        br.read(1)  # sets up the buffer, reading 5\n        assert len(fp.read()) == (len(b) - 5)\n\n        # This is necessary to make sure the \"no bytes left\" part of `readinto`\n        # gets tested.\n        while not br.closed:\n            br.read(5)\n\n    def test_io_not_autoclose_bufferedreader(self) -> None:\n        fp = BytesIO(b\"hello\\nworld\")\n        resp = HTTPResponse(fp, preload_content=False, auto_close=False)\n        reader = BufferedReader(resp)  # type: ignore[arg-type]\n        assert list(reader) == [b\"hello\\n\", b\"world\"]\n\n        assert not reader.closed\n        assert not resp.closed\n        with pytest.raises(StopIteration):\n            next(reader)\n\n        reader.close()\n        assert reader.closed\n        assert resp.closed\n        with pytest.raises(ValueError, match=\"readline of closed file\"):\n            next(reader)\n\n    def test_io_textiowrapper(self) -> None:\n        fp = BytesIO(b\"\\xc3\\xa4\\xc3\\xb6\\xc3\\xbc\\xc3\\x9f\")\n        resp = HTTPResponse(fp, preload_content=False)\n        br = TextIOWrapper(resp, encoding=\"utf8\")  # type: ignore[arg-type]\n\n        assert br.read() == \"\u00e4\u00f6\u00fc\u00df\"\n\n        br.close()\n        assert resp.closed\n\n        # HTTPResponse.read() by default closes the response\n        # https://github.com/urllib3/urllib3/issues/1305\n        fp = BytesIO(\n            b\"\\xc3\\xa4\\xc3\\xb6\\xc3\\xbc\\xc3\\x9f\\n\\xce\\xb1\\xce\\xb2\\xce\\xb3\\xce\\xb4\"\n        )\n        resp = HTTPResponse(fp, preload_content=False)\n        with pytest.raises(ValueError, match=\"I/O operation on closed file.?\"):\n            list(TextIOWrapper(resp))  # type: ignore[arg-type]\n\n    def test_io_not_autoclose_textiowrapper(self) -> None:\n        fp = BytesIO(\n            b\"\\xc3\\xa4\\xc3\\xb6\\xc3\\xbc\\xc3\\x9f\\n\\xce\\xb1\\xce\\xb2\\xce\\xb3\\xce\\xb4\"\n        )\n        resp = HTTPResponse(fp, preload_content=False, auto_close=False)\n        reader = TextIOWrapper(resp, encoding=\"utf8\")  # type: ignore[arg-type]\n        assert list(reader) == [\"\u00e4\u00f6\u00fc\u00df\\n\", \"\u03b1\u03b2\u03b3\u03b4\"]\n\n        assert not reader.closed\n        assert not resp.closed\n        with pytest.raises(StopIteration):\n            next(reader)\n\n        reader.close()\n        assert reader.closed\n        assert resp.closed\n        with pytest.raises(ValueError, match=\"I/O operation on closed file.?\"):\n            next(reader)\n\n    def test_read_with_illegal_mix_decode_toggle(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n\n        assert resp.read(1) == b\"f\"\n\n        with pytest.raises(\n            RuntimeError,\n            match=(\n                r\"Calling read\\(decode_content=False\\) is not supported after \"\n                r\"read\\(decode_content=True\\) was called\"\n            ),\n        ):\n            resp.read(1, decode_content=False)\n\n        with pytest.raises(\n            RuntimeError,\n            match=(\n                r\"Calling read\\(decode_content=False\\) is not supported after \"\n                r\"read\\(decode_content=True\\) was called\"\n            ),\n        ):\n            resp.read(decode_content=False)\n\n    def test_read1_with_illegal_mix_decode_toggle(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n\n        assert resp.read1(1) == b\"f\"\n\n        with pytest.raises(\n            RuntimeError,\n            match=(\n                r\"Calling read1\\(decode_content=False\\) is not supported after \"\n                r\"read1\\(decode_content=True\\) was called\"\n            ),\n        ):\n            resp.read1(1, decode_content=False)\n\n        with pytest.raises(\n            RuntimeError,\n            match=(\n                r\"Calling read1\\(decode_content=False\\) is not supported after \"\n                r\"read1\\(decode_content=True\\) was called\"\n            ),\n        ):\n            resp.read1(decode_content=False)\n\n    def test_read_with_mix_decode_toggle(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n        assert resp.read(2, decode_content=False) is not None\n        assert resp.read(1, decode_content=True) == b\"f\"\n\n    def test_streaming(self) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(fp, preload_content=False)\n        stream = resp.stream(2, decode_content=False)\n\n        assert next(stream) == b\"fo\"\n        assert next(stream) == b\"o\"\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_streaming_tell(self) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(fp, preload_content=False)\n        stream = resp.stream(2, decode_content=False)\n\n        position = 0\n\n        position += len(next(stream))\n        assert 2 == position\n        assert position == resp.tell()\n\n        position += len(next(stream))\n        assert 3 == position\n        assert position == resp.tell()\n\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_gzipped_streaming(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"gzip\"}, preload_content=False\n        )\n        stream = resp.stream(2)\n\n        assert next(stream) == b\"fo\"\n        assert next(stream) == b\"o\"\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_gzipped_streaming_tell(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n        uncompressed_data = b\"foo\"\n        data = compress.compress(uncompressed_data)\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"gzip\"}, preload_content=False\n        )\n        stream = resp.stream()\n\n        # Read everything\n        payload = next(stream)\n        assert payload == uncompressed_data\n\n        assert len(data) == resp.tell()\n\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_deflate_streaming_tell_intermediate_point(self) -> None:\n        # Ensure that ``tell()`` returns the correct number of bytes when\n        # part-way through streaming compressed content.\n        NUMBER_OF_READS = 10\n        PART_SIZE = 64\n\n        class MockCompressedDataReading(BytesIO):\n            \"\"\"\n            A BytesIO-like reader returning ``payload`` in ``NUMBER_OF_READS``\n            calls to ``read``.\n            \"\"\"\n\n            def __init__(self, payload: bytes, payload_part_size: int) -> None:\n                self.payloads = [\n                    payload[i * payload_part_size : (i + 1) * payload_part_size]\n                    for i in range(NUMBER_OF_READS + 1)\n                ]\n\n                assert b\"\".join(self.payloads) == payload\n\n            def read(self, _: int) -> bytes:  # type: ignore[override]\n                # Amount is unused.\n                if len(self.payloads) > 0:\n                    return self.payloads.pop(0)\n                return b\"\"\n\n            def read1(self, amt: int) -> bytes:  # type: ignore[override]\n                return self.read(amt)\n\n        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)\n\n        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS\n        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n        stream = resp.stream(PART_SIZE)\n\n        parts_positions = [(part, resp.tell()) for part in stream]\n        end_of_stream = resp.tell()\n\n        with pytest.raises(StopIteration):\n            next(stream)\n\n        parts, positions = zip(*parts_positions)\n\n        # Check that the payload is equal to the uncompressed data\n        payload = b\"\".join(parts)\n        assert uncompressed_data == payload\n\n        # Check that the positions in the stream are correct\n        # It is difficult to determine programmatically what the positions\n        # returned by `tell` will be because the `HTTPResponse.read` method may\n        # call socket `read` a couple of times if it doesn't have enough data\n        # in the buffer or not call socket `read` at all if it has enough. All\n        # this depends on the message, how it was compressed, what is\n        # `PART_SIZE` and `payload_part_size`.\n        # So for simplicity the expected values are hardcoded.\n        expected = (92, 184, 230, 276, 322, 368, 414, 460)\n        assert expected == positions\n\n        # Check that the end of the stream is in the correct place\n        assert len(ZLIB_PAYLOAD) == end_of_stream\n\n        # Check that all parts have expected length\n        expected_last_part_size = len(uncompressed_data) % PART_SIZE\n        whole_parts = len(uncompressed_data) // PART_SIZE\n        if expected_last_part_size == 0:\n            expected_lengths = [PART_SIZE] * whole_parts\n        else:\n            expected_lengths = [PART_SIZE] * whole_parts + [expected_last_part_size]\n        assert expected_lengths == [len(part) for part in parts]\n\n    def test_deflate_streaming(self) -> None:\n        data = zlib.compress(b\"foo\")\n\n        fp = BytesIO(data)\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n        stream = resp.stream(2)\n\n        assert next(stream) == b\"fo\"\n        assert next(stream) == b\"o\"\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_deflate2_streaming(self) -> None:\n        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)\n        data = compress.compress(b\"foo\")\n        data += compress.flush()\n\n        fp = BytesIO(data)\n        resp = HTTPResponse(\n            fp, headers={\"content-encoding\": \"deflate\"}, preload_content=False\n        )\n        stream = resp.stream(2)\n\n        assert next(stream) == b\"fo\"\n        assert next(stream) == b\"o\"\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_empty_stream(self) -> None:\n        fp = BytesIO(b\"\")\n        resp = HTTPResponse(fp, preload_content=False)\n        stream = resp.stream(2, decode_content=False)\n\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    @pytest.mark.parametrize(\n        \"preload_content, amt, read_meth\",\n        [\n            (True, None, \"read\"),\n            (False, None, \"read\"),\n            (False, 10 * 2**20, \"read\"),\n            (False, None, \"read1\"),\n            (False, 10 * 2**20, \"read1\"),\n        ],\n    )\n    @pytest.mark.limit_memory(\"25 MB\")\n    def test_buffer_memory_usage_decode_one_chunk(\n        self, preload_content: bool, amt: int, read_meth: str\n    ) -> None:\n        content_length = 10 * 2**20  # 10 MiB\n        fp = BytesIO(zlib.compress(bytes(content_length)))\n        resp = HTTPResponse(\n            fp,\n            preload_content=preload_content,\n            headers={\"content-encoding\": \"deflate\"},\n        )\n        data = resp.data if preload_content else getattr(resp, read_meth)(amt)\n        assert len(data) == content_length\n\n    @pytest.mark.parametrize(\n        \"preload_content, amt, read_meth\",\n        [\n            (True, None, \"read\"),\n            (False, None, \"read\"),\n            (False, 10 * 2**20, \"read\"),\n            (False, None, \"read1\"),\n            (False, 10 * 2**20, \"read1\"),\n        ],\n    )\n    @pytest.mark.limit_memory(\"10.5 MB\")\n    def test_buffer_memory_usage_no_decoding(\n        self, preload_content: bool, amt: int, read_meth: str\n    ) -> None:\n        content_length = 10 * 2**20  # 10 MiB\n        fp = BytesIO(bytes(content_length))\n        resp = HTTPResponse(fp, preload_content=preload_content, decode_content=False)\n        data = resp.data if preload_content else getattr(resp, read_meth)(amt)\n        assert len(data) == content_length\n\n    def test_length_no_header(self) -> None:\n        fp = BytesIO(b\"12345\")\n        resp = HTTPResponse(fp, preload_content=False)\n        assert resp.length_remaining is None\n\n    def test_length_w_valid_header(self) -> None:\n        headers = {\"content-length\": \"5\"}\n        fp = BytesIO(b\"12345\")\n\n        resp = HTTPResponse(fp, headers=headers, preload_content=False)\n        assert resp.length_remaining == 5\n\n    def test_length_w_bad_header(self) -> None:\n        garbage = {\"content-length\": \"foo\"}\n        fp = BytesIO(b\"12345\")\n\n        resp = HTTPResponse(fp, headers=garbage, preload_content=False)\n        assert resp.length_remaining is None\n\n        garbage[\"content-length\"] = \"-10\"\n        resp = HTTPResponse(fp, headers=garbage, preload_content=False)\n        assert resp.length_remaining is None\n\n    def test_length_when_chunked(self) -> None:\n        # This is expressly forbidden in RFC 7230 sec 3.3.2\n        # We fall back to chunked in this case and try to\n        # handle response ignoring content length.\n        headers = {\"content-length\": \"5\", \"transfer-encoding\": \"chunked\"}\n        fp = BytesIO(b\"12345\")\n\n        resp = HTTPResponse(fp, headers=headers, preload_content=False)\n        assert resp.length_remaining is None\n\n    def test_length_with_multiple_content_lengths(self) -> None:\n        headers = {\"content-length\": \"5, 5, 5\"}\n        garbage = {\"content-length\": \"5, 42\"}\n        fp = BytesIO(b\"abcde\")\n\n        resp = HTTPResponse(fp, headers=headers, preload_content=False)\n        assert resp.length_remaining == 5\n\n        with pytest.raises(InvalidHeader):\n            HTTPResponse(fp, headers=garbage, preload_content=False)\n\n    def test_length_after_read(self) -> None:\n        headers = {\"content-length\": \"5\"}\n\n        # Test no defined length\n        fp = BytesIO(b\"12345\")\n        resp = HTTPResponse(fp, preload_content=False)\n        resp.read()\n        assert resp.length_remaining is None\n\n        # Test our update from content-length\n        fp = BytesIO(b\"12345\")\n        resp = HTTPResponse(fp, headers=headers, preload_content=False)\n        resp.read()\n        assert resp.length_remaining == 0\n\n        # Test partial read\n        fp = BytesIO(b\"12345\")\n        resp = HTTPResponse(fp, headers=headers, preload_content=False)\n        data = resp.stream(2)\n        next(data)\n        assert resp.length_remaining == 3\n\n    def test_mock_httpresponse_stream(self) -> None:\n        # Mock out a HTTP Request that does enough to make it through urllib3's\n        # read() and close() calls, and also exhausts and underlying file\n        # object.\n        class MockHTTPRequest:\n            def __init__(self) -> None:\n                self.fp: BytesIO | None = None\n\n            def read(self, amt: int) -> bytes:\n                assert self.fp is not None\n                data = self.fp.read(amt)\n                if not data:\n                    self.fp = None\n\n                return data\n\n            def read1(self, amt: int) -> bytes:\n                return self.read(1)\n\n            def close(self) -> None:\n                self.fp = None\n\n        bio = BytesIO(b\"foo\")\n        fp = MockHTTPRequest()\n        fp.fp = bio\n        resp = HTTPResponse(fp, preload_content=False)  # type: ignore[arg-type]\n        stream = resp.stream(2)\n\n        assert next(stream) == b\"fo\"\n        assert next(stream) == b\"o\"\n        with pytest.raises(StopIteration):\n            next(stream)\n\n    def test_mock_transfer_encoding_chunked(self) -> None:\n        stream = [b\"fo\", b\"o\", b\"bar\"]\n        fp = MockChunkedEncodingResponse(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n\n        for i, c in enumerate(resp.stream()):\n            assert c == stream[i]\n\n    def test_mock_gzipped_transfer_encoding_chunked_decoded(self) -> None:\n        \"\"\"Show that we can decode the gzipped and chunked body.\"\"\"\n\n        def stream() -> typing.Generator[bytes, None, None]:\n            # Set up a generator to chunk the gzipped body\n            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n            data = compress.compress(b\"foobar\")\n            data += compress.flush()\n            for i in range(0, len(data), 2):\n                yield data[i : i + 2]\n\n        fp = MockChunkedEncodingResponse(list(stream()))\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        headers = {\"transfer-encoding\": \"chunked\", \"content-encoding\": \"gzip\"}\n        resp = HTTPResponse(r, preload_content=False, headers=headers)\n\n        data = b\"\"\n        for c in resp.stream(decode_content=True):\n            data += c\n\n        assert b\"foobar\" == data\n\n    def test_mock_transfer_encoding_chunked_custom_read(self) -> None:\n        stream = [b\"foooo\", b\"bbbbaaaaar\"]\n        fp = MockChunkedEncodingResponse(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        expected_response = [b\"fo\", b\"oo\", b\"o\", b\"bb\", b\"bb\", b\"aa\", b\"aa\", b\"ar\"]\n        response = list(resp.read_chunked(2))\n        assert expected_response == response\n\n    @pytest.mark.parametrize(\"read_chunked_args\", ((), (None,), (-1,)))\n    def test_mock_transfer_encoding_chunked_unlmtd_read(\n        self, read_chunked_args: tuple[typing.Any, ...]\n    ) -> None:\n        stream = [b\"foooo\", b\"bbbbaaaaar\"]\n        fp = MockChunkedEncodingResponse(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        assert stream == list(resp.read_chunked(*read_chunked_args))\n\n    def test_read_not_chunked_response_as_chunks(self) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(fp, preload_content=False)\n        r = resp.read_chunked()\n        with pytest.raises(ResponseNotChunked):\n            next(r)\n\n    def test_read_chunked_not_supported(self) -> None:\n        fp = BytesIO(b\"foo\")\n        resp = HTTPResponse(\n            fp, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        r = resp.read_chunked()\n        with pytest.raises(BodyNotHttplibCompatible):\n            next(r)\n\n    def test_buggy_incomplete_read(self) -> None:\n        # Simulate buggy versions of Python (<2.7.4)\n        # See http://bugs.python.org/issue16298\n        content_length = 1337\n        fp = BytesIO(b\"\")\n        resp = HTTPResponse(\n            fp,\n            headers={\"content-length\": str(content_length)},\n            preload_content=False,\n            enforce_content_length=True,\n        )\n        with pytest.raises(ProtocolError) as ctx:\n            resp.read(3)\n\n        orig_ex = ctx.value.args[1]\n        assert isinstance(orig_ex, IncompleteRead)\n        assert orig_ex.partial == 0\n        assert orig_ex.expected == content_length\n\n    def test_incomplete_chunk(self) -> None:\n        stream = [b\"foooo\", b\"bbbbaaaaar\"]\n        fp = MockChunkedIncompleteRead(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        with pytest.raises(ProtocolError) as ctx:\n            next(resp.read_chunked())\n\n        orig_ex = ctx.value.args[1]\n        assert isinstance(orig_ex, httplib_IncompleteRead)\n\n    def test_invalid_chunk_length(self) -> None:\n        stream = [b\"foooo\", b\"bbbbaaaaar\"]\n        fp = MockChunkedInvalidChunkLength(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        with pytest.raises(ProtocolError) as ctx:\n            next(resp.read_chunked())\n\n        orig_ex = ctx.value.args[1]\n        msg = (\n            \"(\\\"Connection broken: InvalidChunkLength(got length b'ZZZ\\\\\\\\r\\\\\\\\n', 0 bytes read)\\\", \"\n            \"InvalidChunkLength(got length b'ZZZ\\\\r\\\\n', 0 bytes read))\"\n        )\n        assert str(ctx.value) == msg\n        assert isinstance(orig_ex, InvalidChunkLength)\n        assert orig_ex.length == fp.BAD_LENGTH_LINE.encode()\n\n    def test_truncated_before_chunk(self) -> None:\n        stream = [b\"foooo\", b\"bbbbaaaaar\"]\n        fp = MockChunkedNoChunks(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        with pytest.raises(ProtocolError) as ctx:\n            next(resp.read_chunked())\n\n        assert str(ctx.value) == \"Response ended prematurely\"\n\n    def test_chunked_response_without_crlf_on_end(self) -> None:\n        stream = [b\"foo\", b\"bar\", b\"baz\"]\n        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        assert stream == list(resp.stream())\n\n    def test_chunked_response_with_extensions(self) -> None:\n        stream = [b\"foo\", b\"bar\"]\n        fp = MockChunkedEncodingWithExtensions(stream)\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            r, preload_content=False, headers={\"transfer-encoding\": \"chunked\"}\n        )\n        assert stream == list(resp.stream())\n\n    def test_chunked_head_response(self) -> None:\n        r = httplib.HTTPResponse(MockSock, method=\"HEAD\")  # type: ignore[arg-type]\n        r.chunked = True\n        r.chunk_left = None\n        resp = HTTPResponse(\n            \"\",\n            preload_content=False,\n            headers={\"transfer-encoding\": \"chunked\"},\n            original_response=r,\n        )\n        assert resp.chunked is True\n\n        setattr(resp, \"supports_chunked_reads\", lambda: True)\n        setattr(resp, \"release_conn\", mock.Mock())\n        for _ in resp.stream():\n            continue\n        resp.release_conn.assert_called_once_with()  # type: ignore[attr-defined]\n\n    def test_get_case_insensitive_headers(self) -> None:\n        headers = {\"host\": \"example.com\"}\n        r = HTTPResponse(headers=headers)\n        assert r.headers.get(\"host\") == \"example.com\"\n        assert r.headers.get(\"Host\") == \"example.com\"\n\n    def test_retries(self) -> None:\n        fp = BytesIO(b\"\")\n        resp = HTTPResponse(fp)\n        assert resp.retries is None\n        retry = Retry()\n        resp = HTTPResponse(fp, retries=retry)\n        assert resp.retries == retry\n\n    def test_geturl(self) -> None:\n        fp = BytesIO(b\"\")\n        request_url = \"https://example.com\"\n        resp = HTTPResponse(fp, request_url=request_url)\n        assert resp.geturl() == request_url\n\n    def test_url(self) -> None:\n        fp = BytesIO(b\"\")\n        request_url = \"https://example.com\"\n        resp = HTTPResponse(fp, request_url=request_url)\n        assert resp.url == request_url\n        resp.url = \"https://anotherurl.com\"\n        assert resp.url == \"https://anotherurl.com\"\n\n    def test_geturl_retries(self) -> None:\n        fp = BytesIO(b\"\")\n        resp = HTTPResponse(fp, request_url=\"http://example.com\")\n        request_histories = (\n            RequestHistory(\n                method=\"GET\",\n                url=\"http://example.com\",\n                error=None,\n                status=301,\n                redirect_location=\"https://example.com/\",\n            ),\n            RequestHistory(\n                method=\"GET\",\n                url=\"https://example.com/\",\n                error=None,\n                status=301,\n                redirect_location=\"https://www.example.com\",\n            ),\n        )\n        retry = Retry(history=request_histories)\n        resp = HTTPResponse(fp, retries=retry)\n        assert resp.geturl() == \"https://www.example.com\"\n\n    @pytest.mark.parametrize(\n        [\"payload\", \"expected_stream\"],\n        [\n            (b\"\", []),\n            (b\"\\n\", [b\"\\n\"]),\n            (b\"\\n\\n\\n\", [b\"\\n\", b\"\\n\", b\"\\n\"]),\n            (b\"abc\\ndef\", [b\"abc\\n\", b\"def\"]),\n            (b\"Hello\\nworld\\n\\n\\n!\", [b\"Hello\\n\", b\"world\\n\", b\"\\n\", b\"\\n\", b\"!\"]),\n        ],\n    )\n    def test__iter__(self, payload: bytes, expected_stream: list[bytes]) -> None:\n        actual_stream = []\n        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):\n            actual_stream.append(chunk)\n\n        assert actual_stream == expected_stream\n\n    def test__iter__decode_content(self) -> None:\n        def stream() -> typing.Generator[bytes, None, None]:\n            # Set up a generator to chunk the gzipped body\n            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n            data = compress.compress(b\"foo\\nbar\")\n            data += compress.flush()\n            for i in range(0, len(data), 2):\n                yield data[i : i + 2]\n\n        fp = MockChunkedEncodingResponse(list(stream()))\n        r = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n        r.fp = fp  # type: ignore[assignment]\n        headers = {\"transfer-encoding\": \"chunked\", \"content-encoding\": \"gzip\"}\n        resp = HTTPResponse(r, preload_content=False, headers=headers)\n\n        data = b\"\"\n        for c in resp:\n            data += c\n\n        assert b\"foo\\nbar\" == data\n\n    def test_non_timeout_ssl_error_on_read(self) -> None:\n        mac_error = ssl.SSLError(\n            \"SSL routines\", \"ssl3_get_record\", \"decryption failed or bad record mac\"\n        )\n\n        @contextlib.contextmanager\n        def make_bad_mac_fp() -> typing.Generator[BytesIO, None, None]:\n            fp = BytesIO(b\"\")\n            with mock.patch.object(fp, \"read\") as fp_read:\n                # mac/decryption error\n                fp_read.side_effect = mac_error\n                yield fp\n\n        with make_bad_mac_fp() as fp:\n            with pytest.raises(SSLError) as e:\n                HTTPResponse(fp)\n            assert e.value.args[0] == mac_error\n\n        with make_bad_mac_fp() as fp:\n            resp = HTTPResponse(fp, preload_content=False)\n            with pytest.raises(SSLError) as e:\n                resp.read()\n            assert e.value.args[0] == mac_error\n\n    def test_unexpected_body(self) -> None:\n        with pytest.raises(ProtocolError) as excinfo:\n            fp = BytesIO(b\"12345\")\n            headers = {\"content-length\": \"5\"}\n            resp = HTTPResponse(fp, status=204, headers=headers)\n            resp.read(16)\n        assert \"Response may not contain content\" in str(excinfo.value)\n\n        with pytest.raises(ProtocolError):\n            fp = BytesIO(b\"12345\")\n            headers = {\"content-length\": \"0\"}\n            resp = HTTPResponse(fp, status=204, headers=headers)\n            resp.read(16)\n        assert \"Response may not contain content\" in str(excinfo.value)\n\n        with pytest.raises(ProtocolError):\n            fp = BytesIO(b\"12345\")\n            resp = HTTPResponse(fp, status=204)\n            resp.read(16)\n        assert \"Response may not contain content\" in str(excinfo.value)\n\n\nclass MockChunkedEncodingResponse:\n    def __init__(self, content: list[bytes]) -> None:\n        \"\"\"\n        content: collection of str, each str is a chunk in response\n        \"\"\"\n        self.content = content\n        self.index = 0  # This class iterates over self.content.\n        self.closed = False\n        self.cur_chunk = b\"\"\n        self.chunks_exhausted = False\n\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        # In the general case, we can't decode the chunk to unicode\n        length = f\"{len(chunk):X}\\r\\n\"\n        return length.encode() + chunk + b\"\\r\\n\"\n\n    def _pop_new_chunk(self) -> bytes:\n        if self.chunks_exhausted:\n            return b\"\"\n        try:\n            chunk = self.content[self.index]\n        except IndexError:\n            chunk = b\"\"\n            self.chunks_exhausted = True\n        else:\n            self.index += 1\n        chunk = self._encode_chunk(chunk)\n        if not isinstance(chunk, bytes):\n            chunk = chunk.encode()\n        assert isinstance(chunk, bytes)\n        return chunk\n\n    def pop_current_chunk(self, amt: int = -1, till_crlf: bool = False) -> bytes:\n        if amt > 0 and till_crlf:\n            raise ValueError(\"Can't specify amt and till_crlf.\")\n        if len(self.cur_chunk) <= 0:\n            self.cur_chunk = self._pop_new_chunk()\n        if till_crlf:\n            try:\n                i = self.cur_chunk.index(b\"\\r\\n\")\n            except ValueError:\n                # No CRLF in current chunk -- probably caused by encoder.\n                self.cur_chunk = b\"\"\n                return b\"\"\n            else:\n                chunk_part = self.cur_chunk[: i + 2]\n                self.cur_chunk = self.cur_chunk[i + 2 :]\n                return chunk_part\n        elif amt <= -1:\n            chunk_part = self.cur_chunk\n            self.cur_chunk = b\"\"\n            return chunk_part\n        else:\n            try:\n                chunk_part = self.cur_chunk[:amt]\n            except IndexError:\n                chunk_part = self.cur_chunk\n                self.cur_chunk = b\"\"\n            else:\n                self.cur_chunk = self.cur_chunk[amt:]\n            return chunk_part\n\n    def readline(self) -> bytes:\n        return self.pop_current_chunk(till_crlf=True)\n\n    def read(self, amt: int = -1) -> bytes:\n        return self.pop_current_chunk(amt)\n\n    def read1(self, amt: int = -1) -> bytes:\n        return self.pop_current_chunk(amt)\n\n    def flush(self) -> None:\n        # Python 3 wants this method.\n        pass\n\n    def close(self) -> None:\n        self.closed = True\n\n\nclass MockChunkedIncompleteRead(MockChunkedEncodingResponse):\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        return f\"9999\\r\\n{chunk.decode()}\\r\\n\".encode()\n\n\nclass MockChunkedInvalidChunkLength(MockChunkedEncodingResponse):\n    BAD_LENGTH_LINE = \"ZZZ\\r\\n\"\n\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        return f\"{self.BAD_LENGTH_LINE}{chunk.decode()}\\r\\n\".encode()\n\n\nclass MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        return \"{:X}\\r\\n{}{}\".format(\n            len(chunk),\n            chunk.decode(),\n            \"\\r\\n\" if len(chunk) > 0 else \"\",\n        ).encode()\n\n\nclass MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        return f\"{len(chunk):X};asd=qwe\\r\\n{chunk.decode()}\\r\\n\".encode()\n\n\nclass MockChunkedNoChunks(MockChunkedEncodingResponse):\n    def _encode_chunk(self, chunk: bytes) -> bytes:\n        return b\"\"\n\n\nclass MockSock:\n    @classmethod\n    def makefile(cls, *args: typing.Any, **kwargs: typing.Any) -> None:\n        return\n", "test/test_exceptions.py": "from __future__ import annotations\n\nimport pickle\nfrom email.errors import MessageDefect\nfrom test import DUMMY_POOL\n\nimport pytest\n\nfrom urllib3.connection import HTTPConnection\nfrom urllib3.connectionpool import HTTPConnectionPool\nfrom urllib3.exceptions import (\n    ClosedPoolError,\n    ConnectTimeoutError,\n    EmptyPoolError,\n    HeaderParsingError,\n    HostChangedError,\n    HTTPError,\n    LocationParseError,\n    MaxRetryError,\n    NewConnectionError,\n    ReadTimeoutError,\n)\n\n\nclass TestPickle:\n    @pytest.mark.parametrize(\n        \"exception\",\n        [\n            HTTPError(None),\n            MaxRetryError(DUMMY_POOL, \"\", None),\n            LocationParseError(\"\"),\n            ConnectTimeoutError(None),\n            HTTPError(\"foo\"),\n            HTTPError(\"foo\", IOError(\"foo\")),\n            MaxRetryError(HTTPConnectionPool(\"localhost\"), \"/\", None),\n            LocationParseError(\"fake location\"),\n            ClosedPoolError(HTTPConnectionPool(\"localhost\"), \"\"),\n            EmptyPoolError(HTTPConnectionPool(\"localhost\"), \"\"),\n            HostChangedError(HTTPConnectionPool(\"localhost\"), \"/\", 0),\n            ReadTimeoutError(HTTPConnectionPool(\"localhost\"), \"/\", \"\"),\n        ],\n    )\n    def test_exceptions(self, exception: Exception) -> None:\n        result = pickle.loads(pickle.dumps(exception))\n        assert isinstance(result, type(exception))\n\n\nclass TestFormat:\n    def test_header_parsing_errors(self) -> None:\n        hpe = HeaderParsingError([MessageDefect(\"defects\")], \"unparsed_data\")\n\n        assert \"defects\" in str(hpe)\n        assert \"unparsed_data\" in str(hpe)\n\n\nclass TestNewConnectionError:\n    def test_pool_property_deprecation_warning(self) -> None:\n        err = NewConnectionError(HTTPConnection(\"localhost\"), \"test\")\n        with pytest.warns(DeprecationWarning) as records:\n            err_pool = err.pool\n\n        assert err_pool is err.conn\n        msg = (\n            \"The 'pool' property is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Use 'conn' instead.\"\n        )\n        record = records[0]\n        assert isinstance(record.message, Warning)\n        assert record.message.args[0] == msg\n", "test/conftest.py": "from __future__ import annotations\n\nimport contextlib\nimport socket\nimport ssl\nimport typing\nfrom pathlib import Path\n\nimport hypercorn\nimport pytest\nimport trustme\n\nimport urllib3.http2\nfrom dummyserver.app import hypercorn_app\nfrom dummyserver.asgi_proxy import ProxyApp\nfrom dummyserver.hypercornserver import run_hypercorn_in_thread\nfrom dummyserver.socketserver import HAS_IPV6\nfrom dummyserver.testcase import HTTPSHypercornDummyServerTestCase\nfrom urllib3.util import ssl_\nfrom urllib3.util.url import parse_url\n\nfrom .tz_stub import stub_timezone_ctx\n\n\ndef pytest_addoption(parser: pytest.Parser) -> None:\n    parser.addoption(\n        \"--integration\",\n        action=\"store_true\",\n        default=False,\n        help=\"run integration tests only\",\n    )\n\n\ndef pytest_collection_modifyitems(\n    config: pytest.Config, items: list[pytest.Item]\n) -> None:\n    integration_mode = bool(config.getoption(\"--integration\"))\n    skip_integration = pytest.mark.skip(\n        reason=\"skipping, need --integration option to run\"\n    )\n    skip_normal = pytest.mark.skip(\n        reason=\"skipping non integration tests in --integration mode\"\n    )\n    for item in items:\n        if \"integration\" in item.keywords and not integration_mode:\n            item.add_marker(skip_integration)\n        elif integration_mode and \"integration\" not in item.keywords:\n            item.add_marker(skip_normal)\n\n\nclass ServerConfig(typing.NamedTuple):\n    scheme: str\n    host: str\n    port: int\n    ca_certs: str\n\n    @property\n    def base_url(self) -> str:\n        host = self.host\n        if \":\" in host:\n            host = f\"[{host}]\"\n        return f\"{self.scheme}://{host}:{self.port}\"\n\n\ndef _write_cert_to_dir(\n    cert: trustme.LeafCert, tmpdir: Path, file_prefix: str = \"server\"\n) -> dict[str, str]:\n    cert_path = str(tmpdir / (\"%s.pem\" % file_prefix))\n    key_path = str(tmpdir / (\"%s.key\" % file_prefix))\n    cert.private_key_pem.write_to_path(key_path)\n    cert.cert_chain_pems[0].write_to_path(cert_path)\n    certs = {\"keyfile\": key_path, \"certfile\": cert_path}\n    return certs\n\n\n@contextlib.contextmanager\ndef run_server_in_thread(\n    scheme: str, host: str, tmpdir: Path, ca: trustme.CA, server_cert: trustme.LeafCert\n) -> typing.Generator[ServerConfig, None, None]:\n    ca_cert_path = str(tmpdir / \"ca.pem\")\n    ca.cert_pem.write_to_path(ca_cert_path)\n    server_certs = _write_cert_to_dir(server_cert, tmpdir)\n\n    config = hypercorn.Config()\n    config.certfile = server_certs[\"certfile\"]\n    config.keyfile = server_certs[\"keyfile\"]\n    config.bind = [f\"{host}:0\"]\n    with run_hypercorn_in_thread(config, hypercorn_app):\n        port = typing.cast(int, parse_url(config.bind[0]).port)\n        yield ServerConfig(scheme, host, port, ca_cert_path)\n\n\n@contextlib.contextmanager\ndef run_server_and_proxy_in_thread(\n    proxy_scheme: str,\n    proxy_host: str,\n    tmpdir: Path,\n    ca: trustme.CA,\n    proxy_cert: trustme.LeafCert,\n    server_cert: trustme.LeafCert,\n) -> typing.Generator[tuple[ServerConfig, ServerConfig], None, None]:\n    ca_cert_path = str(tmpdir / \"ca.pem\")\n    ca.cert_pem.write_to_path(ca_cert_path)\n\n    server_certs = _write_cert_to_dir(server_cert, tmpdir)\n    proxy_certs = _write_cert_to_dir(proxy_cert, tmpdir, \"proxy\")\n\n    with contextlib.ExitStack() as stack:\n        server_config = hypercorn.Config()\n        server_config.certfile = server_certs[\"certfile\"]\n        server_config.keyfile = server_certs[\"keyfile\"]\n        server_config.bind = [\"localhost:0\"]\n        stack.enter_context(run_hypercorn_in_thread(server_config, hypercorn_app))\n        port = typing.cast(int, parse_url(server_config.bind[0]).port)\n\n        proxy_config = hypercorn.Config()\n        proxy_config.certfile = proxy_certs[\"certfile\"]\n        proxy_config.keyfile = proxy_certs[\"keyfile\"]\n        proxy_config.bind = [f\"{proxy_host}:0\"]\n        stack.enter_context(run_hypercorn_in_thread(proxy_config, ProxyApp()))\n        proxy_port = typing.cast(int, parse_url(proxy_config.bind[0]).port)\n\n        yield (\n            ServerConfig(proxy_scheme, proxy_host, proxy_port, ca_cert_path),\n            ServerConfig(\"https\", \"localhost\", port, ca_cert_path),\n        )\n\n\n@pytest.fixture(params=[\"localhost\", \"127.0.0.1\", \"::1\"])\ndef loopback_host(request: typing.Any) -> typing.Generator[str, None, None]:\n    host = request.param\n    if host == \"::1\" and not HAS_IPV6:\n        pytest.skip(\"Test requires IPv6 on loopback\")\n    yield host\n\n\n@pytest.fixture()\ndef san_server(\n    loopback_host: str, tmp_path_factory: pytest.TempPathFactory\n) -> typing.Generator[ServerConfig, None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n\n    server_cert = ca.issue_cert(loopback_host)\n\n    with run_server_in_thread(\"https\", loopback_host, tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture()\ndef no_san_server(\n    loopback_host: str, tmp_path_factory: pytest.TempPathFactory\n) -> typing.Generator[ServerConfig, None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    server_cert = ca.issue_cert(common_name=loopback_host)\n\n    with run_server_in_thread(\"https\", loopback_host, tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture()\ndef no_san_server_with_different_commmon_name(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[ServerConfig, None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    server_cert = ca.issue_cert(common_name=\"example.com\")\n\n    with run_server_in_thread(\"https\", \"localhost\", tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef san_proxy_with_server(\n    loopback_host: str, tmp_path_factory: pytest.TempPathFactory\n) -> typing.Generator[tuple[ServerConfig, ServerConfig], None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    proxy_cert = ca.issue_cert(loopback_host)\n    server_cert = ca.issue_cert(\"localhost\")\n\n    with run_server_and_proxy_in_thread(\n        \"https\", loopback_host, tmpdir, ca, proxy_cert, server_cert\n    ) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef no_san_proxy_with_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[tuple[ServerConfig, ServerConfig], None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # only common name, no subject alternative names\n    proxy_cert = ca.issue_cert(common_name=\"localhost\")\n    server_cert = ca.issue_cert(\"localhost\")\n\n    with run_server_and_proxy_in_thread(\n        \"https\", \"localhost\", tmpdir, ca, proxy_cert, server_cert\n    ) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef no_localhost_san_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[ServerConfig, None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # non localhost common name\n    server_cert = ca.issue_cert(\"example.com\")\n\n    with run_server_in_thread(\"https\", \"localhost\", tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef ipv4_san_proxy_with_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[tuple[ServerConfig, ServerConfig], None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # IP address in Subject Alternative Name\n    proxy_cert = ca.issue_cert(\"127.0.0.1\")\n\n    server_cert = ca.issue_cert(\"localhost\")\n\n    with run_server_and_proxy_in_thread(\n        \"https\", \"127.0.0.1\", tmpdir, ca, proxy_cert, server_cert\n    ) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef ipv6_san_proxy_with_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[tuple[ServerConfig, ServerConfig], None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # IP addresses in Subject Alternative Name\n    proxy_cert = ca.issue_cert(\"::1\")\n\n    server_cert = ca.issue_cert(\"localhost\")\n\n    with run_server_and_proxy_in_thread(\n        \"https\", \"::1\", tmpdir, ca, proxy_cert, server_cert\n    ) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef ipv4_san_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[ServerConfig, None, None]:\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # IP address in Subject Alternative Name\n    server_cert = ca.issue_cert(\"127.0.0.1\")\n\n    with run_server_in_thread(\"https\", \"127.0.0.1\", tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef ipv6_san_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[ServerConfig, None, None]:\n    if not HAS_IPV6:\n        pytest.skip(\"Only runs on IPv6 systems\")\n\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # IP address in Subject Alternative Name\n    server_cert = ca.issue_cert(\"::1\")\n\n    with run_server_in_thread(\"https\", \"::1\", tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef ipv6_no_san_server(\n    tmp_path_factory: pytest.TempPathFactory,\n) -> typing.Generator[ServerConfig, None, None]:\n    if not HAS_IPV6:\n        pytest.skip(\"Only runs on IPv6 systems\")\n\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # IP address in Common Name\n    server_cert = ca.issue_cert(common_name=\"::1\")\n\n    with run_server_in_thread(\"https\", \"::1\", tmpdir, ca, server_cert) as cfg:\n        yield cfg\n\n\n@pytest.fixture\ndef stub_timezone(request: pytest.FixtureRequest) -> typing.Generator[None, None, None]:\n    \"\"\"\n    A pytest fixture that runs the test with a stub timezone.\n    \"\"\"\n    with stub_timezone_ctx(request.param):\n        yield\n\n\n@pytest.fixture(scope=\"session\")\ndef supported_tls_versions() -> typing.AbstractSet[str | None]:\n    # We have to create an actual TLS connection\n    # to test if the TLS version is not disabled by\n    # OpenSSL config. Ubuntu 20.04 specifically\n    # disables TLSv1 and TLSv1.1.\n    tls_versions = set()\n\n    _server = HTTPSHypercornDummyServerTestCase\n    _server.setup_class()\n    for _ssl_version_name, min_max_version in (\n        (\"PROTOCOL_TLSv1\", ssl.TLSVersion.TLSv1),\n        (\"PROTOCOL_TLSv1_1\", ssl.TLSVersion.TLSv1_1),\n        (\"PROTOCOL_TLSv1_2\", ssl.TLSVersion.TLSv1_2),\n        (\"PROTOCOL_TLS\", None),\n    ):\n        _ssl_version = getattr(ssl, _ssl_version_name, 0)\n        if _ssl_version == 0:\n            continue\n        _sock = socket.create_connection((_server.host, _server.port))\n        try:\n            _sock = ssl_.ssl_wrap_socket(\n                _sock,\n                ssl_context=ssl_.create_urllib3_context(\n                    cert_reqs=ssl.CERT_NONE,\n                    ssl_minimum_version=min_max_version,\n                    ssl_maximum_version=min_max_version,\n                ),\n            )\n        except ssl.SSLError:\n            pass\n        else:\n            tls_versions.add(_sock.version())\n        _sock.close()\n    _server.teardown_class()\n    return tls_versions\n\n\n@pytest.fixture(scope=\"function\")\ndef requires_tlsv1(supported_tls_versions: typing.AbstractSet[str]) -> None:\n    \"\"\"Test requires TLSv1 available\"\"\"\n    if not hasattr(ssl, \"PROTOCOL_TLSv1\") or \"TLSv1\" not in supported_tls_versions:\n        pytest.skip(\"Test requires TLSv1\")\n\n\n@pytest.fixture(scope=\"function\")\ndef requires_tlsv1_1(supported_tls_versions: typing.AbstractSet[str]) -> None:\n    \"\"\"Test requires TLSv1.1 available\"\"\"\n    if not hasattr(ssl, \"PROTOCOL_TLSv1_1\") or \"TLSv1.1\" not in supported_tls_versions:\n        pytest.skip(\"Test requires TLSv1.1\")\n\n\n@pytest.fixture(scope=\"function\")\ndef requires_tlsv1_2(supported_tls_versions: typing.AbstractSet[str]) -> None:\n    \"\"\"Test requires TLSv1.2 available\"\"\"\n    if not hasattr(ssl, \"PROTOCOL_TLSv1_2\") or \"TLSv1.2\" not in supported_tls_versions:\n        pytest.skip(\"Test requires TLSv1.2\")\n\n\n@pytest.fixture(scope=\"function\")\ndef requires_tlsv1_3(supported_tls_versions: typing.AbstractSet[str]) -> None:\n    \"\"\"Test requires TLSv1.3 available\"\"\"\n    if (\n        not getattr(ssl, \"HAS_TLSv1_3\", False)\n        or \"TLSv1.3\" not in supported_tls_versions\n    ):\n        pytest.skip(\"Test requires TLSv1.3\")\n\n\n@pytest.fixture(params=[\"h11\", \"h2\"])\ndef http_version(request: pytest.FixtureRequest) -> typing.Generator[str, None, None]:\n    if request.param == \"h2\":\n        urllib3.http2.inject_into_urllib3()\n\n    yield request.param\n\n    if request.param == \"h2\":\n        urllib3.http2.extract_from_urllib3()\n", "test/test_compatibility.py": "from __future__ import annotations\n\nimport http.cookiejar\nimport urllib\n\nfrom urllib3.response import HTTPResponse\n\n\nclass TestCookiejar:\n    def test_extract(self) -> None:\n        request = urllib.request.Request(\"http://google.com\")\n        cookiejar = http.cookiejar.CookieJar()\n        response = HTTPResponse()\n\n        cookies = [\n            \"sessionhash=abcabcabcabcab; path=/; HttpOnly\",\n            \"lastvisit=1348253375; expires=Sat, 21-Sep-2050 18:49:35 GMT; path=/\",\n        ]\n        for c in cookies:\n            response.headers.add(\"set-cookie\", c)\n        cookiejar.extract_cookies(response, request)  # type: ignore[arg-type]\n        assert len(cookiejar) == len(cookies)\n", "test/test_no_ssl.py": "\"\"\"\nTest what happens if Python was built without SSL\n\n* Everything that does not involve HTTPS should still work\n* HTTPS requests must fail with an error that points at the ssl module\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom test import ImportBlocker, ModuleStash\n\nimport pytest\n\nssl_blocker = ImportBlocker(\"ssl\", \"_ssl\")\nmodule_stash = ModuleStash(\"urllib3\")\n\n\nclass TestWithoutSSL:\n    @classmethod\n    def setup_class(cls) -> None:\n        sys.modules.pop(\"ssl\", None)\n        sys.modules.pop(\"_ssl\", None)\n\n        module_stash.stash()\n        sys.meta_path.insert(0, ssl_blocker)\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        sys.meta_path.remove(ssl_blocker)\n        module_stash.pop()\n\n\nclass TestImportWithoutSSL(TestWithoutSSL):\n    def test_cannot_import_ssl(self) -> None:\n        with pytest.raises(ImportError):\n            import ssl  # noqa: F401\n\n    def test_import_urllib3(self) -> None:\n        import urllib3  # noqa: F401\n", "test/test_fields.py": "from __future__ import annotations\n\nimport pytest\n\nfrom urllib3.fields import (\n    RequestField,\n    format_header_param,\n    format_header_param_html5,\n    format_header_param_rfc2231,\n    format_multipart_header_param,\n    guess_content_type,\n)\n\n\nclass TestRequestField:\n    @pytest.mark.parametrize(\n        \"filename, content_types\",\n        [\n            (\"image.jpg\", [\"image/jpeg\", \"image/pjpeg\"]),\n            (\"notsure\", [\"application/octet-stream\"]),\n            (None, [\"application/octet-stream\"]),\n        ],\n    )\n    def test_guess_content_type(\n        self, filename: str | None, content_types: list[str]\n    ) -> None:\n        assert guess_content_type(filename) in content_types\n\n    def test_create(self) -> None:\n        simple_field = RequestField(\"somename\", \"data\")\n        assert simple_field.render_headers() == \"\\r\\n\"\n        filename_field = RequestField(\"somename\", \"data\", filename=\"somefile.txt\")\n        assert filename_field.render_headers() == \"\\r\\n\"\n        headers_field = RequestField(\n            \"somename\", \"data\", headers={\"Content-Length\": \"4\"}\n        )\n        assert headers_field.render_headers() == \"Content-Length: 4\\r\\n\\r\\n\"\n\n    def test_make_multipart(self) -> None:\n        field = RequestField(\"somename\", \"data\")\n        field.make_multipart(content_type=\"image/jpg\", content_location=\"/test\")\n        assert (\n            field.render_headers()\n            == 'Content-Disposition: form-data; name=\"somename\"\\r\\n'\n            \"Content-Type: image/jpg\\r\\n\"\n            \"Content-Location: /test\\r\\n\"\n            \"\\r\\n\"\n        )\n\n    def test_make_multipart_empty_filename(self) -> None:\n        field = RequestField(\"somename\", \"data\", \"\")\n        field.make_multipart(content_type=\"application/octet-stream\")\n        assert (\n            field.render_headers()\n            == 'Content-Disposition: form-data; name=\"somename\"; filename=\"\"\\r\\n'\n            \"Content-Type: application/octet-stream\\r\\n\"\n            \"\\r\\n\"\n        )\n\n    def test_render_parts(self) -> None:\n        field = RequestField(\"somename\", \"data\")\n        parts = field._render_parts({\"name\": \"value\", \"filename\": \"value\"})\n        assert 'name=\"value\"' in parts\n        assert 'filename=\"value\"' in parts\n        parts = field._render_parts([(\"name\", \"value\"), (\"filename\", \"value\")])\n        assert parts == 'name=\"value\"; filename=\"value\"'\n\n    @pytest.mark.parametrize(\n        (\"value\", \"expect\"),\n        [(\"n\u00e4me\", \"filename*=utf-8''n%C3%A4me\"), (b\"name\", 'filename=\"name\"')],\n    )\n    def test_format_header_param_rfc2231_deprecated(\n        self, value: bytes | str, expect: str\n    ) -> None:\n        with pytest.deprecated_call(match=r\"urllib3 v2\\.1\\.0\"):\n            param = format_header_param_rfc2231(\"filename\", value)\n\n        assert param == expect\n\n    def test_format_header_param_html5_deprecated(self) -> None:\n        with pytest.deprecated_call(match=r\"urllib3 v2\\.1\\.0\"):\n            param2 = format_header_param_html5(\"filename\", \"name\")\n\n        with pytest.deprecated_call(match=r\"urllib3 v2\\.1\\.0\"):\n            param1 = format_header_param(\"filename\", \"name\")\n\n        assert param1 == param2\n\n    @pytest.mark.parametrize(\n        (\"value\", \"expect\"),\n        [\n            (\"name\", \"name\"),\n            (\"n\u00e4me\", \"n\u00e4me\"),\n            (b\"n\\xc3\\xa4me\", \"n\u00e4me\"),\n            (\"ski \u26f7.txt\", \"ski \u26f7.txt\"),\n            (\"control \\x1A\\x1B\\x1C\", \"control \\x1A\\x1B\\x1C\"),\n            (\"backslash \\\\\", \"backslash \\\\\"),\n            (\"quotes '\\\"\", \"quotes '%22\"),\n            (\"newline \\n\\r\", \"newline %0A%0D\"),\n        ],\n    )\n    def test_format_multipart_header_param(\n        self, value: bytes | str, expect: str\n    ) -> None:\n        param = format_multipart_header_param(\"filename\", value)\n        assert param == f'filename=\"{expect}\"'\n\n    def test_from_tuples(self) -> None:\n        field = RequestField.from_tuples(\"file\", (\"\u30b9\u30ad\u30fc\u65c5\u884c.txt\", \"data\"))\n        cd = field.headers[\"Content-Disposition\"]\n        assert cd == 'form-data; name=\"file\"; filename=\"\u30b9\u30ad\u30fc\u65c5\u884c.txt\"'\n\n    def test_from_tuples_rfc2231(self) -> None:\n        with pytest.deprecated_call(match=r\"urllib3 v2\\.1\\.0\"):\n            field = RequestField.from_tuples(\n                \"file\", (\"n\u00e4me\", \"data\"), header_formatter=format_header_param_rfc2231\n            )\n\n        cd = field.headers[\"Content-Disposition\"]\n        assert cd == \"form-data; name=\\\"file\\\"; filename*=utf-8''n%C3%A4me\"\n", "test/test_ssl.py": "from __future__ import annotations\n\nimport ssl\nimport typing\nfrom unittest import mock\n\nimport pytest\n\nfrom urllib3.exceptions import ProxySchemeUnsupported, SSLError\nfrom urllib3.util import ssl_\n\n\nclass TestSSL:\n    @pytest.mark.parametrize(\n        \"addr\",\n        [\n            # IPv6\n            \"::1\",\n            \"::\",\n            \"FE80::8939:7684:D84b:a5A4%251\",\n            # IPv4\n            \"127.0.0.1\",\n            \"8.8.8.8\",\n            b\"127.0.0.1\",\n            # IPv6 w/ Zone IDs\n            \"FE80::8939:7684:D84b:a5A4%251\",\n            b\"FE80::8939:7684:D84b:a5A4%251\",\n            \"FE80::8939:7684:D84b:a5A4%19\",\n            b\"FE80::8939:7684:D84b:a5A4%19\",\n        ],\n    )\n    def test_is_ipaddress_true(self, addr: bytes | str) -> None:\n        assert ssl_.is_ipaddress(addr)\n\n    @pytest.mark.parametrize(\n        \"addr\",\n        [\n            \"www.python.org\",\n            b\"www.python.org\",\n            \"v2.sg.media-imdb.com\",\n            b\"v2.sg.media-imdb.com\",\n        ],\n    )\n    def test_is_ipaddress_false(self, addr: bytes | str) -> None:\n        assert not ssl_.is_ipaddress(addr)\n\n    def test_create_urllib3_context_set_ciphers(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        ciphers = \"ECDH+AESGCM:ECDH+CHACHA20\"\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.set_ciphers = mock.Mock()\n        context.options = 0\n        monkeypatch.setattr(ssl_, \"SSLContext\", lambda *_, **__: context)\n\n        assert ssl_.create_urllib3_context(ciphers=ciphers) is context\n\n        assert context.set_ciphers.call_count == 1\n        assert context.set_ciphers.call_args == mock.call(ciphers)\n\n    def test_create_urllib3_no_context(self) -> None:\n        with mock.patch(\"urllib3.util.ssl_.SSLContext\", None):\n            with pytest.raises(TypeError):\n                ssl_.create_urllib3_context()\n\n    def test_wrap_socket_given_context_no_load_default_certs(self) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.load_default_certs = mock.Mock()\n\n        sock = mock.Mock()\n        ssl_.ssl_wrap_socket(sock, ssl_context=context)\n\n        context.load_default_certs.assert_not_called()\n\n    def test_wrap_socket_given_ca_certs_no_load_default_certs(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.load_default_certs = mock.Mock()\n        context.options = 0\n\n        monkeypatch.setattr(ssl_, \"SSLContext\", lambda *_, **__: context)\n\n        sock = mock.Mock()\n        ssl_.ssl_wrap_socket(sock, ca_certs=\"/tmp/fake-file\")\n\n        context.load_default_certs.assert_not_called()\n        context.load_verify_locations.assert_called_with(\"/tmp/fake-file\", None, None)\n\n    def test_wrap_socket_default_loads_default_certs(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.load_default_certs = mock.Mock()\n        context.options = 0\n\n        monkeypatch.setattr(ssl_, \"SSLContext\", lambda *_, **__: context)\n\n        sock = mock.Mock()\n        ssl_.ssl_wrap_socket(sock)\n\n        context.load_default_certs.assert_called_with()\n\n    def test_wrap_socket_no_ssltransport(self) -> None:\n        with mock.patch(\"urllib3.util.ssl_.SSLTransport\", None):\n            with pytest.raises(ProxySchemeUnsupported):\n                sock = mock.Mock()\n                ssl_.ssl_wrap_socket(sock, tls_in_tls=True)\n\n    @pytest.mark.parametrize(\n        [\"pha\", \"expected_pha\", \"cert_reqs\"],\n        [\n            (None, None, None),\n            (None, None, ssl.CERT_NONE),\n            (None, None, ssl.CERT_OPTIONAL),\n            (None, None, ssl.CERT_REQUIRED),\n            (False, True, None),\n            (False, True, ssl.CERT_NONE),\n            (False, True, ssl.CERT_OPTIONAL),\n            (False, True, ssl.CERT_REQUIRED),\n            (True, True, None),\n            (True, True, ssl.CERT_NONE),\n            (True, True, ssl.CERT_OPTIONAL),\n            (True, True, ssl.CERT_REQUIRED),\n        ],\n    )\n    def test_create_urllib3_context_pha(\n        self,\n        monkeypatch: pytest.MonkeyPatch,\n        pha: bool | None,\n        expected_pha: bool | None,\n        cert_reqs: int | None,\n    ) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.set_ciphers = mock.Mock()\n        context.options = 0\n        context.post_handshake_auth = pha\n        monkeypatch.setattr(ssl_, \"SSLContext\", lambda *_, **__: context)\n\n        assert ssl_.create_urllib3_context(cert_reqs=cert_reqs) is context\n\n        assert context.post_handshake_auth == expected_pha\n\n    def test_create_urllib3_context_default_ciphers(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.set_ciphers = mock.Mock()\n        context.options = 0\n        monkeypatch.setattr(ssl_, \"SSLContext\", lambda *_, **__: context)\n\n        ssl_.create_urllib3_context()\n\n        context.set_ciphers.assert_not_called()\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLSv1,\n                \"ssl_minimum_version\": ssl.TLSVersion.MINIMUM_SUPPORTED,\n            },\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLSv1,\n                \"ssl_maximum_version\": ssl.TLSVersion.TLSv1,\n            },\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLSv1,\n                \"ssl_minimum_version\": ssl.TLSVersion.MINIMUM_SUPPORTED,\n                \"ssl_maximum_version\": ssl.TLSVersion.MAXIMUM_SUPPORTED,\n            },\n        ],\n    )\n    def test_create_urllib3_context_ssl_version_and_ssl_min_max_version_errors(\n        self, kwargs: dict[str, typing.Any]\n    ) -> None:\n        with pytest.raises(ValueError) as e:\n            ssl_.create_urllib3_context(**kwargs)\n\n        assert str(e.value) == (\n            \"Can't specify both 'ssl_version' and either 'ssl_minimum_version' or 'ssl_maximum_version'\"\n        )\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLS,\n                \"ssl_minimum_version\": ssl.TLSVersion.MINIMUM_SUPPORTED,\n            },\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLS_CLIENT,\n                \"ssl_minimum_version\": ssl.TLSVersion.MINIMUM_SUPPORTED,\n            },\n            {\n                \"ssl_version\": None,\n                \"ssl_minimum_version\": ssl.TLSVersion.MINIMUM_SUPPORTED,\n            },\n        ],\n    )\n    def test_create_urllib3_context_ssl_version_and_ssl_min_max_version_no_warning(\n        self, kwargs: dict[str, typing.Any]\n    ) -> None:\n        ssl_.create_urllib3_context(**kwargs)\n\n    @pytest.mark.parametrize(\n        \"kwargs\",\n        [\n            {\"ssl_version\": ssl.PROTOCOL_TLSv1, \"ssl_minimum_version\": None},\n            {\"ssl_version\": ssl.PROTOCOL_TLSv1, \"ssl_maximum_version\": None},\n            {\n                \"ssl_version\": ssl.PROTOCOL_TLSv1,\n                \"ssl_minimum_version\": None,\n                \"ssl_maximum_version\": None,\n            },\n        ],\n    )\n    def test_create_urllib3_context_ssl_version_and_ssl_min_max_version_no_error(\n        self, kwargs: dict[str, typing.Any]\n    ) -> None:\n        with pytest.warns(\n            DeprecationWarning,\n            match=r\"'ssl_version' option is deprecated and will be removed in \"\n            r\"urllib3 v2\\.1\\.0\\. Instead use 'ssl_minimum_version'\",\n        ):\n            ssl_.create_urllib3_context(**kwargs)\n\n    def test_assert_fingerprint_raises_exception_on_none_cert(self) -> None:\n        with pytest.raises(SSLError):\n            ssl_.assert_fingerprint(\n                cert=None, fingerprint=\"55:39:BF:70:05:12:43:FA:1F:D1:BF:4E:E8:1B:07:1D\"\n            )\n", "test/__init__.py": "from __future__ import annotations\n\nimport errno\nimport importlib.util\nimport logging\nimport os\nimport platform\nimport socket\nimport sys\nimport typing\nimport warnings\nfrom collections.abc import Sequence\nfrom functools import wraps\nfrom importlib.abc import Loader, MetaPathFinder\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType, TracebackType\n\nimport pytest\n\ntry:\n    try:\n        import brotlicffi as brotli  # type: ignore[import-not-found]\n    except ImportError:\n        import brotli  # type: ignore[import-not-found]\nexcept ImportError:\n    brotli = None\n\ntry:\n    import zstandard as _unused_module_zstd  # noqa: F401\nexcept ImportError:\n    HAS_ZSTD = False\nelse:\n    HAS_ZSTD = True\n\nfrom urllib3 import util\nfrom urllib3.connectionpool import ConnectionPool\nfrom urllib3.exceptions import HTTPWarning\nfrom urllib3.util import ssl_\n\ntry:\n    import urllib3.contrib.pyopenssl as pyopenssl\nexcept ImportError:\n    pyopenssl = None  # type: ignore[assignment]\n\nif typing.TYPE_CHECKING:\n    import ssl\n\n\n_RT = typing.TypeVar(\"_RT\")  # return type\n_TestFuncT = typing.TypeVar(\"_TestFuncT\", bound=typing.Callable[..., typing.Any])\n\n\n# We need a host that will not immediately close the connection with a TCP\n# Reset.\nif platform.system() == \"Windows\":\n    # Reserved loopback subnet address\n    TARPIT_HOST = \"127.0.0.0\"\nelse:\n    # Reserved internet scoped address\n    # https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n    TARPIT_HOST = \"240.0.0.0\"\n\n# (Arguments for socket, is it IPv6 address?)\nVALID_SOURCE_ADDRESSES = [((\"::1\", 0), True), ((\"127.0.0.1\", 0), False)]\n# RFC 5737: 192.0.2.0/24 is for testing only.\n# RFC 3849: 2001:db8::/32 is for documentation only.\nINVALID_SOURCE_ADDRESSES = [((\"192.0.2.255\", 0), False), ((\"2001:db8::1\", 0), True)]\n\n# We use timeouts in three different ways in our tests\n#\n# 1. To make sure that the operation timeouts, we can use a short timeout.\n# 2. To make sure that the test does not hang even if the operation should succeed, we\n#    want to use a long timeout, even more so on CI where tests can be really slow\n# 3. To test our timeout logic by using two different values, eg. by using different\n#    values at the pool level and at the request level.\nSHORT_TIMEOUT = 0.001\nLONG_TIMEOUT = 0.1\nif os.environ.get(\"CI\") or os.environ.get(\"GITHUB_ACTIONS\") == \"true\":\n    LONG_TIMEOUT = 0.5\n\nDUMMY_POOL = ConnectionPool(\"dummy\")\n\n\ndef _can_resolve(host: str) -> bool:\n    \"\"\"Returns True if the system can resolve host to an address.\"\"\"\n    try:\n        socket.getaddrinfo(host, None, socket.AF_UNSPEC)\n        return True\n    except socket.gaierror:\n        return False\n\n\ndef has_alpn(ctx_cls: type[ssl.SSLContext] | None = None) -> bool:\n    \"\"\"Detect if ALPN support is enabled.\"\"\"\n    ctx_cls = ctx_cls or util.SSLContext\n    ctx = ctx_cls(protocol=ssl_.PROTOCOL_TLS)  # type: ignore[misc, attr-defined]\n    try:\n        if hasattr(ctx, \"set_alpn_protocols\"):\n            ctx.set_alpn_protocols(ssl_.ALPN_PROTOCOLS)\n            return True\n    except NotImplementedError:\n        pass\n    return False\n\n\n# Some systems might not resolve \"localhost.\" correctly.\n# See https://github.com/urllib3/urllib3/issues/1809 and\n# https://github.com/urllib3/urllib3/pull/1475#issuecomment-440788064.\nRESOLVES_LOCALHOST_FQDN = _can_resolve(\"localhost.\")\n\n\ndef clear_warnings(cls: type[Warning] = HTTPWarning) -> None:\n    new_filters = []\n    for f in warnings.filters:\n        if issubclass(f[2], cls):\n            continue\n        new_filters.append(f)\n    warnings.filters[:] = new_filters  # type: ignore[index]\n\n\ndef setUp() -> None:\n    clear_warnings()\n    warnings.simplefilter(\"ignore\", HTTPWarning)\n\n\ndef notWindows() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    \"\"\"Skips this test on Windows\"\"\"\n    return pytest.mark.skipif(\n        platform.system() == \"Windows\",\n        reason=\"Test does not run on Windows\",\n    )\n\n\ndef onlyBrotli() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    return pytest.mark.skipif(\n        brotli is None, reason=\"only run if brotli library is present\"\n    )\n\n\ndef notBrotli() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    return pytest.mark.skipif(\n        brotli is not None, reason=\"only run if a brotli library is absent\"\n    )\n\n\ndef onlyZstd() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    return pytest.mark.skipif(\n        not HAS_ZSTD, reason=\"only run if a python-zstandard library is installed\"\n    )\n\n\ndef notZstd() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    return pytest.mark.skipif(\n        HAS_ZSTD,\n        reason=\"only run if a python-zstandard library is not installed\",\n    )\n\n\n_requires_network_has_route = None\n\n\ndef requires_network() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    \"\"\"Helps you skip tests that require the network\"\"\"\n\n    def _is_unreachable_err(err: Exception) -> bool:\n        return getattr(err, \"errno\", None) in (\n            errno.ENETUNREACH,\n            errno.EHOSTUNREACH,  # For OSX\n        )\n\n    def _has_route() -> bool:\n        try:\n            sock = socket.create_connection((TARPIT_HOST, 80), 0.0001)\n            sock.close()\n            return True\n        except socket.timeout:\n            return True\n        except OSError as e:\n            if _is_unreachable_err(e):\n                return False\n            else:\n                raise\n\n    def _skip_if_no_route(f: _TestFuncT) -> _TestFuncT:\n        \"\"\"Skip test exuction if network is unreachable\"\"\"\n\n        @wraps(f)\n        def wrapper(*args: typing.Any, **kwargs: typing.Any) -> typing.Any:\n            global _requires_network_has_route\n            if _requires_network_has_route is None:\n                _requires_network_has_route = _has_route()\n            if not _requires_network_has_route:\n                pytest.skip(\"Can't run the test because the network is unreachable\")\n            return f(*args, **kwargs)\n\n        return typing.cast(_TestFuncT, wrapper)\n\n    def _decorator_requires_internet(\n        decorator: typing.Callable[[_TestFuncT], _TestFuncT]\n    ) -> typing.Callable[[_TestFuncT], _TestFuncT]:\n        \"\"\"Mark a decorator with the \"requires_internet\" mark\"\"\"\n\n        def wrapper(f: _TestFuncT) -> typing.Any:\n            return pytest.mark.requires_network(decorator(f))\n\n        return wrapper\n\n    return _decorator_requires_internet(_skip_if_no_route)\n\n\ndef resolvesLocalhostFQDN() -> typing.Callable[[_TestFuncT], _TestFuncT]:\n    \"\"\"Test requires successful resolving of 'localhost.'\"\"\"\n    return pytest.mark.skipif(\n        not RESOLVES_LOCALHOST_FQDN,\n        reason=\"Can't resolve localhost.\",\n    )\n\n\ndef withPyOpenSSL(test: typing.Callable[..., _RT]) -> typing.Callable[..., _RT]:\n    @wraps(test)\n    def wrapper(*args: typing.Any, **kwargs: typing.Any) -> _RT:\n        if not pyopenssl:\n            pytest.skip(\"pyopenssl not available, skipping test.\")\n            return test(*args, **kwargs)\n\n        pyopenssl.inject_into_urllib3()\n        result = test(*args, **kwargs)\n        pyopenssl.extract_from_urllib3()\n        return result\n\n    return wrapper\n\n\nclass _ListHandler(logging.Handler):\n    def __init__(self) -> None:\n        super().__init__()\n        self.records: list[logging.LogRecord] = []\n\n    def emit(self, record: logging.LogRecord) -> None:\n        self.records.append(record)\n\n\nclass LogRecorder:\n    def __init__(self, target: logging.Logger = logging.root) -> None:\n        super().__init__()\n        self._target = target\n        self._handler = _ListHandler()\n\n    @property\n    def records(self) -> list[logging.LogRecord]:\n        return self._handler.records\n\n    def install(self) -> None:\n        self._target.addHandler(self._handler)\n\n    def uninstall(self) -> None:\n        self._target.removeHandler(self._handler)\n\n    def __enter__(self) -> list[logging.LogRecord]:\n        self.install()\n        return self.records\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -> typing.Literal[False]:\n        self.uninstall()\n        return False\n\n\nclass ImportBlockerLoader(Loader):\n    def __init__(self, fullname: str) -> None:\n        self._fullname = fullname\n\n    def load_module(self, fullname: str) -> ModuleType:\n        raise ImportError(f\"import of {fullname} is blocked\")\n\n    def exec_module(self, module: ModuleType) -> None:\n        raise ImportError(f\"import of {self._fullname} is blocked\")\n\n\nclass ImportBlocker(MetaPathFinder):\n    \"\"\"\n    Block Imports\n\n    To be placed on ``sys.meta_path``. This ensures that the modules\n    specified cannot be imported, even if they are a builtin.\n    \"\"\"\n\n    def __init__(self, *namestoblock: str) -> None:\n        self.namestoblock = namestoblock\n\n    def find_module(\n        self, fullname: str, path: typing.Sequence[bytes | str] | None = None\n    ) -> Loader | None:\n        if fullname in self.namestoblock:\n            return ImportBlockerLoader(fullname)\n        return None\n\n    def find_spec(\n        self,\n        fullname: str,\n        path: Sequence[bytes | str] | None,\n        target: ModuleType | None = None,\n    ) -> ModuleSpec | None:\n        loader = self.find_module(fullname, path)\n        if loader is None:\n            return None\n\n        return importlib.util.spec_from_loader(fullname, loader)\n\n\nclass ModuleStash(MetaPathFinder):\n    \"\"\"\n    Stashes away previously imported modules\n\n    If we reimport a module the data from coverage is lost, so we reuse the old\n    modules\n    \"\"\"\n\n    def __init__(\n        self, namespace: str, modules: dict[str, ModuleType] = sys.modules\n    ) -> None:\n        self.namespace = namespace\n        self.modules = modules\n        self._data: dict[str, ModuleType] = {}\n\n    def stash(self) -> None:\n        if self.namespace in self.modules:\n            self._data[self.namespace] = self.modules.pop(self.namespace)\n\n        for module in list(self.modules.keys()):\n            if module.startswith(self.namespace + \".\"):\n                self._data[module] = self.modules.pop(module)\n\n    def pop(self) -> None:\n        self.modules.pop(self.namespace, None)\n\n        for module in list(self.modules.keys()):\n            if module.startswith(self.namespace + \".\"):\n                self.modules.pop(module)\n\n        self.modules.update(self._data)\n", "test/test_proxymanager.py": "from __future__ import annotations\n\nimport pytest\n\nfrom urllib3.exceptions import MaxRetryError, NewConnectionError, ProxyError\nfrom urllib3.poolmanager import ProxyManager\nfrom urllib3.util.retry import Retry\nfrom urllib3.util.url import parse_url\n\nfrom .port_helpers import find_unused_port\n\n\nclass TestProxyManager:\n    @pytest.mark.parametrize(\"proxy_scheme\", [\"http\", \"https\"])\n    def test_proxy_headers(self, proxy_scheme: str) -> None:\n        url = \"http://pypi.org/project/urllib3/\"\n        proxy_url = f\"{proxy_scheme}://something:1234\"\n        with ProxyManager(proxy_url) as p:\n            # Verify default headers\n            default_headers = {\"Accept\": \"*/*\", \"Host\": \"pypi.org\"}\n            headers = p._set_proxy_headers(url)\n\n            assert headers == default_headers\n\n            # Verify default headers don't overwrite provided headers\n            provided_headers = {\n                \"Accept\": \"application/json\",\n                \"custom\": \"header\",\n                \"Host\": \"test.python.org\",\n            }\n            headers = p._set_proxy_headers(url, provided_headers)\n\n            assert headers == provided_headers\n\n            # Verify proxy with nonstandard port\n            provided_headers = {\"Accept\": \"application/json\"}\n            expected_headers = provided_headers.copy()\n            expected_headers.update({\"Host\": \"pypi.org:8080\"})\n            url_with_port = \"http://pypi.org:8080/project/urllib3/\"\n            headers = p._set_proxy_headers(url_with_port, provided_headers)\n\n            assert headers == expected_headers\n\n    def test_default_port(self) -> None:\n        with ProxyManager(\"http://something\") as p:\n            assert p.proxy is not None\n            assert p.proxy.port == 80\n        with ProxyManager(\"https://something\") as p:\n            assert p.proxy is not None\n            assert p.proxy.port == 443\n\n    def test_invalid_scheme(self) -> None:\n        with pytest.raises(AssertionError):\n            ProxyManager(\"invalid://host/p\")\n        with pytest.raises(ValueError):\n            ProxyManager(\"invalid://host/p\")\n\n    def test_proxy_tunnel(self) -> None:\n        http_url = parse_url(\"http://example.com\")\n        https_url = parse_url(\"https://example.com\")\n        with ProxyManager(\"http://proxy:8080\") as p:\n            assert p._proxy_requires_url_absolute_form(http_url)\n            assert p._proxy_requires_url_absolute_form(https_url) is False\n\n        with ProxyManager(\"https://proxy:8080\") as p:\n            assert p._proxy_requires_url_absolute_form(http_url)\n            assert p._proxy_requires_url_absolute_form(https_url) is False\n\n        with ProxyManager(\"https://proxy:8080\", use_forwarding_for_https=True) as p:\n            assert p._proxy_requires_url_absolute_form(http_url)\n            assert p._proxy_requires_url_absolute_form(https_url)\n\n    def test_proxy_connect_retry(self) -> None:\n        retry = Retry(total=None, connect=False)\n        port = find_unused_port()\n        with ProxyManager(f\"http://localhost:{port}\") as p:\n            with pytest.raises(ProxyError) as ei:\n                p.urlopen(\"HEAD\", url=\"http://localhost/\", retries=retry)\n            assert isinstance(ei.value.original_error, NewConnectionError)\n\n        retry = Retry(total=None, connect=2)\n        with ProxyManager(f\"http://localhost:{port}\") as p:\n            with pytest.raises(MaxRetryError) as ei1:\n                p.urlopen(\"HEAD\", url=\"http://localhost/\", retries=retry)\n            assert ei1.value.reason is not None\n            assert isinstance(ei1.value.reason, ProxyError)\n            assert isinstance(ei1.value.reason.original_error, NewConnectionError)\n", "test/test_connectionpool.py": "from __future__ import annotations\n\nimport http.client as httplib\nimport ssl\nimport typing\nfrom http.client import HTTPException\nfrom queue import Empty\nfrom socket import error as SocketError\nfrom ssl import SSLError as BaseSSLError\nfrom test import SHORT_TIMEOUT\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom dummyserver.socketserver import DEFAULT_CA\nfrom urllib3 import Retry\nfrom urllib3.connection import HTTPConnection\nfrom urllib3.connectionpool import (\n    HTTPConnectionPool,\n    HTTPSConnectionPool,\n    _url_from_pool,\n    connection_from_url,\n)\nfrom urllib3.exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    FullPoolError,\n    HostChangedError,\n    LocationValueError,\n    MaxRetryError,\n    ProtocolError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n)\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util.ssl_match_hostname import CertificateError\nfrom urllib3.util.timeout import _DEFAULT_TIMEOUT, Timeout\n\nfrom .test_response import MockChunkedEncodingResponse, MockSock\n\n\nclass HTTPUnixConnection(HTTPConnection):\n    def __init__(self, host: str, timeout: int = 60, **kwargs: typing.Any) -> None:\n        super().__init__(\"localhost\")\n        self.unix_socket = host\n        self.timeout = timeout\n        self.sock = None\n\n\nclass HTTPUnixConnectionPool(HTTPConnectionPool):\n    scheme = \"http+unix\"\n    ConnectionCls = HTTPUnixConnection\n\n\nclass TestConnectionPool:\n    \"\"\"\n    Tests in this suite should exercise the ConnectionPool functionality\n    without actually making any network requests or connections.\n    \"\"\"\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"http://google.com/\", \"/\"),\n            (\"http://google.com/\", \"http://google.com/\"),\n            (\"http://google.com/\", \"http://google.com\"),\n            (\"http://google.com/\", \"http://google.com/abra/cadabra\"),\n            (\"http://google.com:42/\", \"http://google.com:42/abracadabra\"),\n            # Test comparison using default ports\n            (\"http://google.com:80/\", \"http://google.com/abracadabra\"),\n            (\"http://google.com/\", \"http://google.com:80/abracadabra\"),\n            (\"https://google.com:443/\", \"https://google.com/abracadabra\"),\n            (\"https://google.com/\", \"https://google.com:443/abracadabra\"),\n            (\n                \"http://[2607:f8b0:4005:805::200e%25eth0]/\",\n                \"http://[2607:f8b0:4005:805::200e%eth0]/\",\n            ),\n            (\n                \"https://[2607:f8b0:4005:805::200e%25eth0]:443/\",\n                \"https://[2607:f8b0:4005:805::200e%eth0]:443/\",\n            ),\n            (\"http://[::1]/\", \"http://[::1]\"),\n            (\n                \"http://[2001:558:fc00:200:f816:3eff:fef9:b954%lo]/\",\n                \"http://[2001:558:fc00:200:f816:3eff:fef9:b954%25lo]\",\n            ),\n        ],\n    )\n    def test_same_host(self, a: str, b: str) -> None:\n        with connection_from_url(a) as c:\n            assert c.is_same_host(b)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"https://google.com/\", \"http://google.com/\"),\n            (\"http://google.com/\", \"https://google.com/\"),\n            (\"http://yahoo.com/\", \"http://google.com/\"),\n            (\"http://google.com:42\", \"https://google.com/abracadabra\"),\n            (\"http://google.com\", \"https://google.net/\"),\n            # Test comparison with default ports\n            (\"http://google.com:42\", \"http://google.com\"),\n            (\"https://google.com:42\", \"https://google.com\"),\n            (\"http://google.com:443\", \"http://google.com\"),\n            (\"https://google.com:80\", \"https://google.com\"),\n            (\"http://google.com:443\", \"https://google.com\"),\n            (\"https://google.com:80\", \"http://google.com\"),\n            (\"https://google.com:443\", \"http://google.com\"),\n            (\"http://google.com:80\", \"https://google.com\"),\n            # Zone identifiers are unique connection end points and should\n            # never be equivalent.\n            (\"http://[dead::beef]\", \"https://[dead::beef%en5]/\"),\n        ],\n    )\n    def test_not_same_host(self, a: str, b: str) -> None:\n        with connection_from_url(a) as c:\n            assert not c.is_same_host(b)\n\n        with connection_from_url(b) as c:\n            assert not c.is_same_host(a)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"google.com\", \"/\"),\n            (\"google.com\", \"http://google.com/\"),\n            (\"google.com\", \"http://google.com\"),\n            (\"google.com\", \"http://google.com/abra/cadabra\"),\n            # Test comparison using default ports\n            (\"google.com\", \"http://google.com:80/abracadabra\"),\n        ],\n    )\n    def test_same_host_no_port_http(self, a: str, b: str) -> None:\n        # This test was introduced in #801 to deal with the fact that urllib3\n        # never initializes ConnectionPool objects with port=None.\n        with HTTPConnectionPool(a) as c:\n            assert c.is_same_host(b)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"google.com\", \"/\"),\n            (\"google.com\", \"https://google.com/\"),\n            (\"google.com\", \"https://google.com\"),\n            (\"google.com\", \"https://google.com/abra/cadabra\"),\n            # Test comparison using default ports\n            (\"google.com\", \"https://google.com:443/abracadabra\"),\n        ],\n    )\n    def test_same_host_no_port_https(self, a: str, b: str) -> None:\n        # This test was introduced in #801 to deal with the fact that urllib3\n        # never initializes ConnectionPool objects with port=None.\n        with HTTPSConnectionPool(a) as c:\n            assert c.is_same_host(b)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"google.com\", \"https://google.com/\"),\n            (\"yahoo.com\", \"http://google.com/\"),\n            (\"google.com\", \"https://google.net/\"),\n            (\"google.com\", \"http://google.com./\"),\n        ],\n    )\n    def test_not_same_host_no_port_http(self, a: str, b: str) -> None:\n        with HTTPConnectionPool(a) as c:\n            assert not c.is_same_host(b)\n\n        with HTTPConnectionPool(b) as c:\n            assert not c.is_same_host(a)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"google.com\", \"http://google.com/\"),\n            (\"yahoo.com\", \"https://google.com/\"),\n            (\"google.com\", \"https://google.net/\"),\n            (\"google.com\", \"https://google.com./\"),\n        ],\n    )\n    def test_not_same_host_no_port_https(self, a: str, b: str) -> None:\n        with HTTPSConnectionPool(a) as c:\n            assert not c.is_same_host(b)\n\n        with HTTPSConnectionPool(b) as c:\n            assert not c.is_same_host(a)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"%2Fvar%2Frun%2Fdocker.sock\", \"http+unix://%2Fvar%2Frun%2Fdocker.sock\"),\n            (\"%2Fvar%2Frun%2Fdocker.sock\", \"http+unix://%2Fvar%2Frun%2Fdocker.sock/\"),\n            (\n                \"%2Fvar%2Frun%2Fdocker.sock\",\n                \"http+unix://%2Fvar%2Frun%2Fdocker.sock/abracadabra\",\n            ),\n            (\"%2Ftmp%2FTEST.sock\", \"http+unix://%2Ftmp%2FTEST.sock\"),\n            (\"%2Ftmp%2FTEST.sock\", \"http+unix://%2Ftmp%2FTEST.sock/\"),\n            (\"%2Ftmp%2FTEST.sock\", \"http+unix://%2Ftmp%2FTEST.sock/abracadabra\"),\n        ],\n    )\n    def test_same_host_custom_protocol(self, a: str, b: str) -> None:\n        with HTTPUnixConnectionPool(a) as c:\n            assert c.is_same_host(b)\n\n    @pytest.mark.parametrize(\n        \"a, b\",\n        [\n            (\"%2Ftmp%2Ftest.sock\", \"http+unix://%2Ftmp%2FTEST.sock\"),\n            (\"%2Ftmp%2Ftest.sock\", \"http+unix://%2Ftmp%2FTEST.sock/\"),\n            (\"%2Ftmp%2Ftest.sock\", \"http+unix://%2Ftmp%2FTEST.sock/abracadabra\"),\n            (\"%2Fvar%2Frun%2Fdocker.sock\", \"http+unix://%2Ftmp%2FTEST.sock\"),\n        ],\n    )\n    def test_not_same_host_custom_protocol(self, a: str, b: str) -> None:\n        with HTTPUnixConnectionPool(a) as c:\n            assert not c.is_same_host(b)\n\n    def test_max_connections(self) -> None:\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=True) as pool:\n            pool._get_conn(timeout=SHORT_TIMEOUT)\n\n            with pytest.raises(EmptyPoolError):\n                pool._get_conn(timeout=SHORT_TIMEOUT)\n\n            with pytest.raises(EmptyPoolError):\n                pool.request(\"GET\", \"/\", pool_timeout=SHORT_TIMEOUT)\n\n            assert pool.num_connections == 1\n\n    def test_put_conn_when_pool_is_full_nonblocking(\n        self, caplog: pytest.LogCaptureFixture\n    ) -> None:\n        \"\"\"\n        If maxsize = n and we _put_conn n + 1 conns, the n + 1th conn will\n        get closed and will not get added to the pool.\n        \"\"\"\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=False) as pool:\n            conn1 = pool._get_conn()\n            # pool.pool is empty because we popped the one None that pool.pool was initialized with\n            # but this pool._get_conn call will not raise EmptyPoolError because block is False\n            conn2 = pool._get_conn()\n\n            with patch.object(conn1, \"close\") as conn1_close:\n                with patch.object(conn2, \"close\") as conn2_close:\n                    pool._put_conn(conn1)\n                    pool._put_conn(conn2)\n\n            assert conn1_close.called is False\n            assert conn2_close.called is True\n\n            assert conn1 == pool._get_conn()\n            assert conn2 != pool._get_conn()\n\n            assert pool.num_connections == 3\n            assert \"Connection pool is full, discarding connection\" in caplog.text\n            assert \"Connection pool size: 1\" in caplog.text\n\n    def test_put_conn_when_pool_is_full_blocking(self) -> None:\n        \"\"\"\n        If maxsize = n and we _put_conn n + 1 conns, the n + 1th conn will\n        cause a FullPoolError.\n        \"\"\"\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=True) as pool:\n            conn1 = pool._get_conn()\n            conn2 = pool._new_conn()\n\n            with patch.object(conn1, \"close\") as conn1_close:\n                with patch.object(conn2, \"close\") as conn2_close:\n                    pool._put_conn(conn1)\n                    with pytest.raises(FullPoolError):\n                        pool._put_conn(conn2)\n\n            assert conn1_close.called is False\n            assert conn2_close.called is True\n\n            assert conn1 == pool._get_conn()\n\n    def test_put_conn_closed_pool(self) -> None:\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=True) as pool:\n            conn1 = pool._get_conn()\n            with patch.object(conn1, \"close\") as conn1_close:\n                pool.close()\n\n                assert pool.pool is None\n\n                # Accessing pool.pool will raise AttributeError, which will get\n                # caught and will close conn1\n                pool._put_conn(conn1)\n\n            assert conn1_close.called is True\n\n    def test_exception_str(self) -> None:\n        assert (\n            str(EmptyPoolError(HTTPConnectionPool(host=\"localhost\"), \"Test.\"))\n            == \"HTTPConnectionPool(host='localhost', port=None): Test.\"\n        )\n\n    def test_retry_exception_str(self) -> None:\n        assert (\n            str(MaxRetryError(HTTPConnectionPool(host=\"localhost\"), \"Test.\", None))\n            == \"HTTPConnectionPool(host='localhost', port=None): \"\n            \"Max retries exceeded with url: Test. (Caused by None)\"\n        )\n\n        err = SocketError(\"Test\")\n\n        # using err.__class__ here, as socket.error is an alias for OSError\n        # since Py3.3 and gets printed as this\n        assert (\n            str(MaxRetryError(HTTPConnectionPool(host=\"localhost\"), \"Test.\", err))\n            == \"HTTPConnectionPool(host='localhost', port=None): \"\n            \"Max retries exceeded with url: Test. \"\n            \"(Caused by %r)\" % err\n        )\n\n    def test_pool_size(self) -> None:\n        POOL_SIZE = 1\n        with HTTPConnectionPool(\n            host=\"localhost\", maxsize=POOL_SIZE, block=True\n        ) as pool:\n\n            def _test(\n                exception: type[BaseException],\n                expect: type[BaseException],\n                reason: type[BaseException] | None = None,\n            ) -> None:\n                with patch.object(pool, \"_make_request\", side_effect=exception()):\n                    with pytest.raises(expect) as excinfo:\n                        pool.request(\"GET\", \"/\")\n                if reason is not None:\n                    assert isinstance(excinfo.value.reason, reason)  # type: ignore[attr-defined]\n                assert pool.pool is not None\n                assert pool.pool.qsize() == POOL_SIZE\n\n            # Make sure that all of the exceptions return the connection\n            # to the pool\n            _test(BaseSSLError, MaxRetryError, SSLError)\n            _test(CertificateError, MaxRetryError, SSLError)\n\n            # The pool should never be empty, and with these two exceptions\n            # being raised, a retry will be triggered, but that retry will\n            # fail, eventually raising MaxRetryError, not EmptyPoolError\n            # See: https://github.com/urllib3/urllib3/issues/76\n            with patch.object(pool, \"_make_request\", side_effect=HTTPException()):\n                with pytest.raises(MaxRetryError):\n                    pool.request(\"GET\", \"/\", retries=1, pool_timeout=SHORT_TIMEOUT)\n            assert pool.pool is not None\n            assert pool.pool.qsize() == POOL_SIZE\n\n    def test_empty_does_not_put_conn(self) -> None:\n        \"\"\"Do not put None back in the pool if the pool was empty\"\"\"\n\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=True) as pool:\n            with patch.object(\n                pool, \"_get_conn\", side_effect=EmptyPoolError(pool, \"Pool is empty\")\n            ):\n                with patch.object(\n                    pool,\n                    \"_put_conn\",\n                    side_effect=AssertionError(\"Unexpected _put_conn\"),\n                ):\n                    with pytest.raises(EmptyPoolError):\n                        pool.request(\"GET\", \"/\")\n\n    def test_assert_same_host(self) -> None:\n        with connection_from_url(\"http://google.com:80\") as c:\n            with pytest.raises(HostChangedError):\n                c.request(\"GET\", \"http://yahoo.com:80\", assert_same_host=True)\n\n    def test_pool_close(self) -> None:\n        pool = connection_from_url(\"http://google.com:80\")\n\n        # Populate with some connections\n        conn1 = pool._get_conn()\n        conn2 = pool._get_conn()\n        conn3 = pool._get_conn()\n        pool._put_conn(conn1)\n        pool._put_conn(conn2)\n\n        old_pool_queue = pool.pool\n\n        pool.close()\n        assert pool.pool is None\n\n        with pytest.raises(ClosedPoolError):\n            pool._get_conn()\n\n        pool._put_conn(conn3)\n\n        with pytest.raises(ClosedPoolError):\n            pool._get_conn()\n\n        with pytest.raises(Empty):\n            assert old_pool_queue is not None\n            old_pool_queue.get(block=False)\n\n    def test_pool_close_twice(self) -> None:\n        pool = connection_from_url(\"http://google.com:80\")\n\n        # Populate with some connections\n        conn1 = pool._get_conn()\n        conn2 = pool._get_conn()\n        pool._put_conn(conn1)\n        pool._put_conn(conn2)\n\n        pool.close()\n        assert pool.pool is None\n\n        try:\n            pool.close()\n        except AttributeError:\n            pytest.fail(\"Pool of the ConnectionPool is None and has no attribute get.\")\n\n    def test_pool_timeouts(self) -> None:\n        with HTTPConnectionPool(host=\"localhost\") as pool:\n            conn = pool._new_conn()\n            assert conn.__class__ == HTTPConnection\n            assert pool.timeout.__class__ == Timeout\n            assert pool.timeout._read == _DEFAULT_TIMEOUT\n            assert pool.timeout._connect == _DEFAULT_TIMEOUT\n            assert pool.timeout.total is None\n\n            pool = HTTPConnectionPool(host=\"localhost\", timeout=SHORT_TIMEOUT)\n            assert pool.timeout._read == SHORT_TIMEOUT\n            assert pool.timeout._connect == SHORT_TIMEOUT\n            assert pool.timeout.total is None\n\n    def test_no_host(self) -> None:\n        with pytest.raises(LocationValueError):\n            HTTPConnectionPool(None)  # type: ignore[arg-type]\n\n    def test_contextmanager(self) -> None:\n        with connection_from_url(\"http://google.com:80\") as pool:\n            # Populate with some connections\n            conn1 = pool._get_conn()\n            conn2 = pool._get_conn()\n            conn3 = pool._get_conn()\n            pool._put_conn(conn1)\n            pool._put_conn(conn2)\n\n            old_pool_queue = pool.pool\n\n        assert pool.pool is None\n        with pytest.raises(ClosedPoolError):\n            pool._get_conn()\n\n        pool._put_conn(conn3)\n        with pytest.raises(ClosedPoolError):\n            pool._get_conn()\n        with pytest.raises(Empty):\n            assert old_pool_queue is not None\n            old_pool_queue.get(block=False)\n\n    def test_url_from_pool(self) -> None:\n        with connection_from_url(\"http://google.com:80\") as pool:\n            path = \"path?query=foo\"\n            assert f\"http://google.com:80/{path}\" == _url_from_pool(pool, path)\n\n    def test_ca_certs_default_cert_required(self) -> None:\n        with connection_from_url(\"https://google.com:80\", ca_certs=DEFAULT_CA) as pool:\n            conn = pool._get_conn()\n            assert conn.cert_reqs == ssl.CERT_REQUIRED  # type: ignore[attr-defined]\n\n    def test_cleanup_on_extreme_connection_error(self) -> None:\n        \"\"\"\n        This test validates that we clean up properly even on exceptions that\n        we'd not otherwise catch, i.e. those that inherit from BaseException\n        like KeyboardInterrupt or gevent.Timeout. See #805 for more details.\n        \"\"\"\n\n        class RealBad(BaseException):\n            pass\n\n        def kaboom(*args: typing.Any, **kwargs: typing.Any) -> None:\n            raise RealBad()\n\n        with connection_from_url(\"http://localhost:80\") as c:\n            with patch.object(c, \"_make_request\", kaboom):\n                assert c.pool is not None\n                initial_pool_size = c.pool.qsize()\n\n                try:\n                    # We need to release_conn this way or we'd put it away\n                    # regardless.\n                    c.urlopen(\"GET\", \"/\", release_conn=False)\n                except RealBad:\n                    pass\n\n            new_pool_size = c.pool.qsize()\n            assert initial_pool_size == new_pool_size\n\n    def test_release_conn_param_is_respected_after_http_error_retry(self) -> None:\n        \"\"\"For successful ```urlopen(release_conn=False)```,\n        the connection isn't released, even after a retry.\n\n        This is a regression test for issue #651 [1], where the connection\n        would be released if the initial request failed, even if a retry\n        succeeded.\n\n        [1] <https://github.com/urllib3/urllib3/issues/651>\n        \"\"\"\n\n        class _raise_once_make_request_function:\n            \"\"\"Callable that can mimic `_make_request()`.\n\n            Raises the given exception on its first call, but returns a\n            successful response on subsequent calls.\n            \"\"\"\n\n            def __init__(\n                self, ex: type[BaseException], pool: HTTPConnectionPool\n            ) -> None:\n                super().__init__()\n                self._ex: type[BaseException] | None = ex\n                self._pool = pool\n\n            def __call__(\n                self,\n                conn: HTTPConnection,\n                method: str,\n                url: str,\n                *args: typing.Any,\n                retries: Retry,\n                **kwargs: typing.Any,\n            ) -> HTTPResponse:\n                if self._ex:\n                    ex, self._ex = self._ex, None\n                    raise ex()\n                httplib_response = httplib.HTTPResponse(MockSock)  # type: ignore[arg-type]\n                httplib_response.fp = MockChunkedEncodingResponse([b\"f\", b\"o\", b\"o\"])  # type: ignore[assignment]\n                httplib_response.headers = httplib_response.msg = httplib.HTTPMessage()\n\n                response_conn: HTTPConnection | None = kwargs.get(\"response_conn\")\n\n                response = HTTPResponse(\n                    body=httplib_response,\n                    headers=httplib_response.headers,  # type: ignore[arg-type]\n                    status=httplib_response.status,\n                    version=httplib_response.version,\n                    reason=httplib_response.reason,\n                    original_response=httplib_response,\n                    retries=retries,\n                    request_method=method,\n                    request_url=url,\n                    preload_content=False,\n                    connection=response_conn,\n                    pool=self._pool,\n                )\n                return response\n\n        def _test(exception: type[BaseException]) -> None:\n            with HTTPConnectionPool(host=\"localhost\", maxsize=1, block=True) as pool:\n                # Verify that the request succeeds after two attempts, and that the\n                # connection is left on the response object, instead of being\n                # released back into the pool.\n                with patch.object(\n                    pool,\n                    \"_make_request\",\n                    _raise_once_make_request_function(exception, pool),\n                ):\n                    response = pool.urlopen(\n                        \"GET\",\n                        \"/\",\n                        retries=1,\n                        release_conn=False,\n                        preload_content=False,\n                        chunked=True,\n                    )\n                assert pool.pool is not None\n                assert pool.pool.qsize() == 0\n                assert pool.num_connections == 2\n                assert response.connection is not None\n\n                response.release_conn()\n                assert pool.pool.qsize() == 1\n                assert response.connection is None\n\n        # Run the test case for all the retriable exceptions.\n        _test(TimeoutError)\n        _test(HTTPException)\n        _test(SocketError)\n        _test(ProtocolError)\n\n    def test_read_timeout_0_does_not_raise_bad_status_line_error(self) -> None:\n        with HTTPConnectionPool(host=\"localhost\", maxsize=1) as pool:\n            conn = Mock(spec=HTTPConnection)\n            # Needed to tell the pool that the connection is alive.\n            conn.is_closed = False\n            with patch.object(Timeout, \"read_timeout\", 0):\n                timeout = Timeout(1, 1, 1)\n                with pytest.raises(ReadTimeoutError):\n                    pool._make_request(conn, \"\", \"\", timeout=timeout)\n", "test/test_connection.py": "from __future__ import annotations\n\nimport datetime\nimport socket\nimport typing\nfrom http.client import ResponseNotReady\nfrom unittest import mock\n\nimport pytest\n\nfrom urllib3.connection import (  # type: ignore[attr-defined]\n    RECENT_DATE,\n    CertificateError,\n    HTTPConnection,\n    HTTPSConnection,\n    _match_hostname,\n    _url_from_connection,\n    _wrap_proxy_error,\n)\nfrom urllib3.exceptions import HTTPError, ProxyError, SSLError\nfrom urllib3.util import ssl_\nfrom urllib3.util.request import SKIP_HEADER\nfrom urllib3.util.ssl_match_hostname import (\n    CertificateError as ImplementationCertificateError,\n)\nfrom urllib3.util.ssl_match_hostname import _dnsname_match, match_hostname\n\nif typing.TYPE_CHECKING:\n    from urllib3.util.ssl_ import _TYPE_PEER_CERT_RET_DICT\n\n\nclass TestConnection:\n    \"\"\"\n    Tests in this suite should not make any network requests or connections.\n    \"\"\"\n\n    def test_match_hostname_no_cert(self) -> None:\n        cert = None\n        asserted_hostname = \"foo\"\n        with pytest.raises(ValueError):\n            _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_empty_cert(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {}\n        asserted_hostname = \"foo\"\n        with pytest.raises(ValueError):\n            _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_match(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"DNS\", \"foo\"),)}\n        asserted_hostname = \"foo\"\n        _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_mismatch(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"DNS\", \"foo\"),)}\n        asserted_hostname = \"bar\"\n        try:\n            with mock.patch(\"urllib3.connection.log.warning\") as mock_log:\n                _match_hostname(cert, asserted_hostname)\n        except CertificateError as e:\n            assert \"hostname 'bar' doesn't match 'foo'\" in str(e)\n            mock_log.assert_called_once_with(\n                \"Certificate did not match expected hostname: %s. Certificate: %s\",\n                \"bar\",\n                {\"subjectAltName\": ((\"DNS\", \"foo\"),)},\n            )\n            assert e._peer_cert == cert  # type: ignore[attr-defined]\n\n    def test_match_hostname_no_dns(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"DNS\", \"\"),)}\n        asserted_hostname = \"bar\"\n        try:\n            with mock.patch(\"urllib3.connection.log.warning\") as mock_log:\n                _match_hostname(cert, asserted_hostname)\n        except CertificateError as e:\n            assert \"hostname 'bar' doesn't match ''\" in str(e)\n            mock_log.assert_called_once_with(\n                \"Certificate did not match expected hostname: %s. Certificate: %s\",\n                \"bar\",\n                {\"subjectAltName\": ((\"DNS\", \"\"),)},\n            )\n            assert e._peer_cert == cert  # type: ignore[attr-defined]\n\n    def test_match_hostname_startwith_wildcard(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"DNS\", \"*\"),)}\n        asserted_hostname = \"foo\"\n        _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_dnsname(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": ((\"DNS\", \"xn--p1b6ci4b4b3a*.xn--11b5bs8d\"),)\n        }\n        asserted_hostname = \"xn--p1b6ci4b4b3a*.xn--11b5bs8d\"\n        _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_include_wildcard(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"DNS\", \"foo*\"),)}\n        asserted_hostname = \"foobar\"\n        _match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_more_than_one_dnsname_error(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": ((\"DNS\", \"foo*\"), (\"DNS\", \"fo*\"))\n        }\n        asserted_hostname = \"bar\"\n        with pytest.raises(CertificateError, match=\"doesn't match either of\"):\n            _match_hostname(cert, asserted_hostname)\n\n    def test_dnsname_match_include_more_than_one_wildcard_error(self) -> None:\n        with pytest.raises(CertificateError, match=\"too many wildcards in certificate\"):\n            _dnsname_match(\"foo**\", \"foobar\")\n\n    def test_match_hostname_ignore_common_name(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subject\": (((\"commonName\", \"foo\"),),)}\n        asserted_hostname = \"foo\"\n        with pytest.raises(\n            ImplementationCertificateError,\n            match=\"no appropriate subjectAltName fields were found\",\n        ):\n            match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_check_common_name(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subject\": (((\"commonName\", \"foo\"),),)}\n        asserted_hostname = \"foo\"\n        match_hostname(cert, asserted_hostname, True)\n\n    def test_match_hostname_ip_address(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": ((\"IP Address\", \"1.1.1.1\"),)\n        }\n        asserted_hostname = \"1.1.1.2\"\n        try:\n            with mock.patch(\"urllib3.connection.log.warning\") as mock_log:\n                _match_hostname(cert, asserted_hostname)\n        except CertificateError as e:\n            assert \"hostname '1.1.1.2' doesn't match '1.1.1.1'\" in str(e)\n            mock_log.assert_called_once_with(\n                \"Certificate did not match expected hostname: %s. Certificate: %s\",\n                \"1.1.1.2\",\n                {\"subjectAltName\": ((\"IP Address\", \"1.1.1.1\"),)},\n            )\n            assert e._peer_cert == cert  # type: ignore[attr-defined]\n\n    @pytest.mark.parametrize(\n        [\"asserted_hostname\", \"san_ip\"],\n        [\n            (\"1:2::3:4\", \"1:2:0:0:0:0:3:4\"),\n            (\"1:2:0:0::3:4\", \"1:2:0:0:0:0:3:4\"),\n            (\"::0.1.0.2\", \"0:0:0:0:0:0:1:2\"),\n            (\"::1%42\", \"0:0:0:0:0:0:0:1\"),\n            (\"::2%iface\", \"0:0:0:0:0:0:0:2\"),\n        ],\n    )\n    def test_match_hostname_ip_address_ipv6(\n        self, asserted_hostname: str, san_ip: str\n    ) -> None:\n        \"\"\"Check that hostname matches follow RFC 9110 rules for IPv6.\"\"\"\n        cert: _TYPE_PEER_CERT_RET_DICT = {\"subjectAltName\": ((\"IP Address\", san_ip),)}\n        match_hostname(cert, asserted_hostname)\n\n    def test_match_hostname_ip_address_ipv6_doesnt_match(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": ((\"IP Address\", \"1:2::2:1\"),)\n        }\n        asserted_hostname = \"1:2::2:2\"\n        try:\n            with mock.patch(\"urllib3.connection.log.warning\") as mock_log:\n                _match_hostname(cert, asserted_hostname)\n        except CertificateError as e:\n            assert \"hostname '1:2::2:2' doesn't match '1:2::2:1'\" in str(e)\n            mock_log.assert_called_once_with(\n                \"Certificate did not match expected hostname: %s. Certificate: %s\",\n                \"1:2::2:2\",\n                {\"subjectAltName\": ((\"IP Address\", \"1:2::2:1\"),)},\n            )\n            assert e._peer_cert == cert  # type: ignore[attr-defined]\n\n    def test_match_hostname_dns_with_brackets_doesnt_match(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": (\n                (\"DNS\", \"localhost\"),\n                (\"IP Address\", \"localhost\"),\n            )\n        }\n        asserted_hostname = \"[localhost]\"\n        with pytest.raises(CertificateError) as e:\n            _match_hostname(cert, asserted_hostname)\n        assert (\n            \"hostname '[localhost]' doesn't match either of 'localhost', 'localhost'\"\n            in str(e.value)\n        )\n\n    def test_match_hostname_ip_address_ipv6_brackets(self) -> None:\n        cert: _TYPE_PEER_CERT_RET_DICT = {\n            \"subjectAltName\": ((\"IP Address\", \"1:2::2:1\"),)\n        }\n        asserted_hostname = \"[1:2::2:1]\"\n        # Assert no error is raised\n        _match_hostname(cert, asserted_hostname)\n\n    def test_recent_date(self) -> None:\n        # This test is to make sure that the RECENT_DATE value\n        # doesn't get too far behind what the current date is.\n        # When this test fails update urllib3.connection.RECENT_DATE\n        # according to the rules defined in that file.\n        two_years = datetime.timedelta(days=365 * 2)\n        assert RECENT_DATE > (datetime.datetime.today() - two_years).date()\n\n    def test_HTTPSConnection_default_socket_options(self) -> None:\n        conn = HTTPSConnection(\"not.a.real.host\", port=443)\n        assert conn.socket_options == [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]\n\n    @pytest.mark.parametrize(\n        \"proxy_scheme, err_part\",\n        [\n            (\"http\", \"Unable to connect to proxy\"),\n            (\n                \"https\",\n                \"Unable to connect to proxy. Your proxy appears to only use HTTP and not HTTPS\",\n            ),\n        ],\n    )\n    def test_wrap_proxy_error(self, proxy_scheme: str, err_part: str) -> None:\n        new_err = _wrap_proxy_error(HTTPError(\"unknown protocol\"), proxy_scheme)\n        assert isinstance(new_err, ProxyError) is True\n        assert err_part in new_err.args[0]\n\n    def test_url_from_pool(self) -> None:\n        conn = HTTPConnection(\"google.com\", port=80)\n\n        path = \"path?query=foo\"\n        assert f\"http://google.com:80/{path}\" == _url_from_connection(conn, path)\n\n    def test_getresponse_requires_reponseoptions(self) -> None:\n        conn = HTTPConnection(\"google.com\", port=80)\n\n        # Should error if a request has not been sent\n        with pytest.raises(ResponseNotReady):\n            conn.getresponse()\n\n    def test_assert_fingerprint_closes_socket(self) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.wrap_socket.return_value.getpeercert.return_value = b\"fake cert\"\n        conn = HTTPSConnection(\n            \"google.com\",\n            port=443,\n            assert_fingerprint=\"AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\",\n            ssl_context=context,\n        )\n        with mock.patch.object(conn, \"_new_conn\"):\n            with pytest.raises(SSLError):\n                conn.connect()\n\n        context.wrap_socket.return_value.close.assert_called_once_with()\n\n    def test_assert_hostname_closes_socket(self) -> None:\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.wrap_socket.return_value.getpeercert.return_value = {\n            \"subjectAltName\": ((\"DNS\", \"google.com\"),)\n        }\n        conn = HTTPSConnection(\n            \"google.com\", port=443, assert_hostname=\"example.com\", ssl_context=context\n        )\n        with mock.patch.object(conn, \"_new_conn\"):\n            with pytest.raises(ImplementationCertificateError):\n                conn.connect()\n\n        context.wrap_socket.return_value.close.assert_called_once_with()\n\n    @pytest.mark.parametrize(\n        \"accept_encoding\",\n        [\n            \"Accept-Encoding\",\n            \"accept-encoding\",\n            b\"Accept-Encoding\",\n            b\"accept-encoding\",\n            None,\n        ],\n    )\n    @pytest.mark.parametrize(\"host\", [\"Host\", \"host\", b\"Host\", b\"host\", None])\n    @pytest.mark.parametrize(\n        \"user_agent\", [\"User-Agent\", \"user-agent\", b\"User-Agent\", b\"user-agent\", None]\n    )\n    @pytest.mark.parametrize(\"chunked\", [True, False])\n    def test_skip_header(\n        self,\n        accept_encoding: str | None,\n        host: str | None,\n        user_agent: str | None,\n        chunked: bool,\n    ) -> None:\n        headers = {}\n        if accept_encoding is not None:\n            headers[accept_encoding] = SKIP_HEADER\n        if host is not None:\n            headers[host] = SKIP_HEADER\n        if user_agent is not None:\n            headers[user_agent] = SKIP_HEADER\n\n        # When dropping support for Python 3.9, this can be rewritten to parenthesized\n        # context managers\n        with mock.patch(\"urllib3.util.connection.create_connection\"):\n            with mock.patch(\n                \"urllib3.connection._HTTPConnection.putheader\"\n            ) as http_client_putheader:\n                conn = HTTPConnection(\"\")\n                conn.request(\"GET\", \"/headers\", headers=headers, chunked=chunked)\n\n        request_headers = {}\n        for call in http_client_putheader.call_args_list:\n            header, value = call.args\n            request_headers[header] = value\n\n        if accept_encoding is None:\n            assert \"Accept-Encoding\" in request_headers\n        else:\n            assert accept_encoding not in request_headers\n        if host is None:\n            assert \"Host\" in request_headers\n        else:\n            assert host not in request_headers\n        if user_agent is None:\n            assert \"User-Agent\" in request_headers\n        else:\n            assert user_agent not in request_headers\n", "test/test_ssltransport.py": "from __future__ import annotations\n\nimport platform\nimport select\nimport socket\nimport ssl\nimport threading\nimport typing\nfrom unittest import mock\n\nimport pytest\n\nfrom dummyserver.socketserver import DEFAULT_CA, DEFAULT_CERTS\nfrom dummyserver.testcase import SocketDummyServerTestCase, consume_socket\nfrom urllib3.util import ssl_\nfrom urllib3.util.ssltransport import SSLTransport\n\n# consume_socket can iterate forever, we add timeouts to prevent halting.\nPER_TEST_TIMEOUT = 60\n\n\ndef server_client_ssl_contexts() -> tuple[ssl.SSLContext, ssl.SSLContext]:\n    if hasattr(ssl, \"PROTOCOL_TLS_SERVER\"):\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    server_context.load_cert_chain(DEFAULT_CERTS[\"certfile\"], DEFAULT_CERTS[\"keyfile\"])\n\n    if hasattr(ssl, \"PROTOCOL_TLS_CLIENT\"):\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n    client_context.load_verify_locations(DEFAULT_CA)\n    return server_context, client_context\n\n\n@typing.overload\ndef sample_request(binary: typing.Literal[True] = ...) -> bytes:\n    ...\n\n\n@typing.overload\ndef sample_request(binary: typing.Literal[False]) -> str:\n    ...\n\n\ndef sample_request(binary: bool = True) -> bytes | str:\n    request = (\n        b\"GET http://www.testing.com/ HTTP/1.1\\r\\n\"\n        b\"Host: www.testing.com\\r\\n\"\n        b\"User-Agent: awesome-test\\r\\n\"\n        b\"\\r\\n\"\n    )\n    return request if binary else request.decode(\"utf-8\")\n\n\ndef validate_request(\n    provided_request: bytearray, binary: typing.Literal[False, True] = True\n) -> None:\n    assert provided_request is not None\n    expected_request = sample_request(binary)\n    assert provided_request == expected_request\n\n\n@typing.overload\ndef sample_response(binary: typing.Literal[True] = ...) -> bytes:\n    ...\n\n\n@typing.overload\ndef sample_response(binary: typing.Literal[False]) -> str:\n    ...\n\n\n@typing.overload\ndef sample_response(binary: bool = ...) -> bytes | str:\n    ...\n\n\ndef sample_response(binary: bool = True) -> bytes | str:\n    response = b\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n    return response if binary else response.decode(\"utf-8\")\n\n\ndef validate_response(\n    provided_response: bytes | bytearray | str, binary: bool = True\n) -> None:\n    assert provided_response is not None\n    expected_response = sample_response(binary)\n    assert provided_response == expected_response\n\n\ndef validate_peercert(ssl_socket: SSLTransport) -> None:\n    binary_cert = ssl_socket.getpeercert(binary_form=True)\n    assert type(binary_cert) is bytes\n    assert len(binary_cert) > 0\n\n    cert = ssl_socket.getpeercert()\n    assert type(cert) is dict\n    assert \"serialNumber\" in cert\n    assert cert[\"serialNumber\"] != \"\"\n\n\nclass SingleTLSLayerTestCase(SocketDummyServerTestCase):\n    \"\"\"\n    Uses the SocketDummyServer to validate a single TLS layer can be\n    established through the SSLTransport.\n    \"\"\"\n\n    @classmethod\n    def setup_class(cls) -> None:\n        cls.server_context, cls.client_context = server_client_ssl_contexts()\n\n    def start_dummy_server(\n        self,\n        handler: typing.Callable[[socket.socket], None] | None = None,\n        validate: bool = True,\n    ) -> None:\n        quit_event = threading.Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            try:\n                with self.server_context.wrap_socket(sock, server_side=True) as ssock:\n                    request = consume_socket(\n                        ssock,\n                        quit_event=quit_event,\n                    )\n                    if not validate:\n                        return\n                    validate_request(request)\n                    ssock.send(sample_response())\n            except (ConnectionAbortedError, ConnectionResetError):\n                return\n\n        chosen_handler = handler if handler else socket_handler\n        self._start_server(chosen_handler, quit_event=quit_event)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_start_closed_socket(self) -> None:\n        \"\"\"Errors generated from an unconnected socket should bubble up.\"\"\"\n        sock = socket.socket(socket.AF_INET)\n        context = ssl.create_default_context()\n        sock.close()\n        with pytest.raises(OSError):\n            SSLTransport(sock, context)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_close_after_handshake(self) -> None:\n        \"\"\"Socket errors should be bubbled up\"\"\"\n        self.start_dummy_server(validate=False)\n\n        sock = socket.create_connection((self.host, self.port))\n        with SSLTransport(\n            sock, self.client_context, server_hostname=\"localhost\"\n        ) as ssock:\n            ssock.close()\n            with pytest.raises(OSError):\n                ssock.send(b\"blaaargh\")\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_wrap_existing_socket(self) -> None:\n        \"\"\"Validates a single TLS layer can be established.\"\"\"\n        self.start_dummy_server()\n\n        sock = socket.create_connection((self.host, self.port))\n        with SSLTransport(\n            sock, self.client_context, server_hostname=\"localhost\"\n        ) as ssock:\n            assert ssock.version() is not None\n            ssock.send(sample_request())\n            response = consume_socket(ssock)\n            validate_response(response)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_unbuffered_text_makefile(self) -> None:\n        self.start_dummy_server()\n\n        sock = socket.create_connection((self.host, self.port))\n        with SSLTransport(\n            sock, self.client_context, server_hostname=\"localhost\"\n        ) as ssock:\n            with pytest.raises(ValueError):\n                ssock.makefile(\"r\", buffering=0)\n            ssock.send(sample_request())\n            response = consume_socket(ssock)\n            validate_response(response)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_unwrap_existing_socket(self) -> None:\n        \"\"\"\n        Validates we can break up the TLS layer\n        A full request/response is sent over TLS, and later over plain text.\n        \"\"\"\n\n        def shutdown_handler(listener: socket.socket) -> None:\n            with listener.accept()[0] as sock, self.server_context.wrap_socket(\n                sock, server_side=True\n            ) as ssl_sock:\n                request = consume_socket(ssl_sock)\n                validate_request(request)\n                ssl_sock.sendall(sample_response())\n\n                with ssl_sock.unwrap() as unwrapped_sock:\n                    request = consume_socket(unwrapped_sock)\n                    validate_request(request)\n                    unwrapped_sock.sendall(sample_response())\n\n        self.start_dummy_server(shutdown_handler)\n        with socket.create_connection((self.host, self.port)) as sock:\n            ssock = SSLTransport(sock, self.client_context, server_hostname=\"localhost\")\n\n            # request/response over TLS.\n            ssock.sendall(sample_request())\n            response = consume_socket(ssock)\n            validate_response(response)\n\n            # request/response over plaintext after unwrap.\n            ssock.unwrap()\n            sock.sendall(sample_request())\n            response = consume_socket(sock)\n            validate_response(response)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_ssl_object_attributes(self) -> None:\n        \"\"\"Ensures common ssl attributes are exposed\"\"\"\n        self.start_dummy_server()\n\n        sock = socket.create_connection((self.host, self.port))\n        with SSLTransport(\n            sock, self.client_context, server_hostname=\"localhost\"\n        ) as ssock:\n            cipher = ssock.cipher()\n            assert type(cipher) is tuple\n\n            # No chosen protocol through ALPN or NPN.\n            assert ssock.selected_alpn_protocol() is None\n            assert ssock.selected_npn_protocol() is None\n\n            shared_ciphers = ssock.shared_ciphers()\n            # SSLContext.shared_ciphers() changed behavior completely in a patch version.\n            # See: https://github.com/python/cpython/issues/96931\n            assert shared_ciphers is None or (\n                type(shared_ciphers) is list and len(shared_ciphers) > 0\n            )\n\n            assert ssock.compression() is None\n\n            validate_peercert(ssock)\n\n            ssock.send(sample_request())\n            response = consume_socket(ssock)\n            validate_response(response)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_socket_object_attributes(self) -> None:\n        \"\"\"Ensures common socket attributes are exposed\"\"\"\n        self.start_dummy_server()\n\n        sock = socket.create_connection((self.host, self.port))\n        with SSLTransport(\n            sock, self.client_context, server_hostname=\"localhost\"\n        ) as ssock:\n            assert ssock.fileno() is not None\n            test_timeout = 10\n            ssock.settimeout(test_timeout)\n            assert ssock.gettimeout() == test_timeout\n            assert ssock.socket.gettimeout() == test_timeout\n\n            ssock.send(sample_request())\n            response = consume_socket(ssock)\n            validate_response(response)\n\n\nclass SocketProxyDummyServer(SocketDummyServerTestCase):\n    \"\"\"\n    Simulates a proxy that performs a simple I/O loop on client/server\n    socket.\n    \"\"\"\n\n    def __init__(\n        self, destination_server_host: str, destination_server_port: int\n    ) -> None:\n        self.destination_server_host = destination_server_host\n        self.destination_server_port = destination_server_port\n        self.server_ctx, _ = server_client_ssl_contexts()\n\n    def start_proxy_handler(self) -> None:\n        \"\"\"\n        Socket handler for the proxy. Terminates the first TLS layer and tunnels\n        any bytes needed for client <-> server communicatin.\n        \"\"\"\n\n        def proxy_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            with self.server_ctx.wrap_socket(sock, server_side=True) as client_sock:\n                upstream_sock = socket.create_connection(\n                    (self.destination_server_host, self.destination_server_port)\n                )\n                self._read_write_loop(client_sock, upstream_sock)\n                upstream_sock.close()\n                client_sock.close()\n\n        self._start_server(proxy_handler)\n\n    def _read_write_loop(\n        self,\n        client_sock: socket.socket,\n        server_sock: socket.socket,\n        chunks: int = 65536,\n    ) -> None:\n        inputs = [client_sock, server_sock]\n        output = [client_sock, server_sock]\n\n        while inputs:\n            readable, writable, exception = select.select(inputs, output, inputs)\n\n            if exception:\n                # Error occurred with either of the sockets, time to\n                # wrap up, parent func will close sockets.\n                break\n\n            for s in readable:\n                read_socket, write_socket = None, None\n                if s == client_sock:\n                    read_socket = client_sock\n                    write_socket = server_sock\n                else:\n                    read_socket = server_sock\n                    write_socket = client_sock\n\n                # Ensure buffer is not full before writing\n                if write_socket in writable:\n                    try:\n                        b = read_socket.recv(chunks)\n                        if len(b) == 0:\n                            # One of the sockets has EOFed, we return to close\n                            # both.\n                            return\n                        write_socket.send(b)\n                    except ssl.SSLEOFError:\n                        # It's possible, depending on shutdown order, that we'll\n                        # try to use a socket that was closed between select\n                        # calls.\n                        return\n\n\nclass TlsInTlsTestCase(SocketDummyServerTestCase):\n    \"\"\"\n    Creates a TLS in TLS tunnel by chaining a 'SocketProxyDummyServer' and a\n    `SocketDummyServerTestCase`.\n\n    Client will first connect to the proxy, who will then proxy any bytes send\n    to the destination server. First TLS layer terminates at the proxy, second\n    TLS layer terminates at the destination server.\n    \"\"\"\n\n    @classmethod\n    def setup_class(cls) -> None:\n        cls.server_context, cls.client_context = server_client_ssl_contexts()\n\n    @classmethod\n    def start_proxy_server(cls) -> None:\n        # Proxy server will handle the first TLS connection and create a\n        # connection to the destination server.\n        cls.proxy_server = SocketProxyDummyServer(cls.host, cls.port)\n        cls.proxy_server.start_proxy_handler()\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        if hasattr(cls, \"proxy_server\"):\n            cls.proxy_server.teardown_class()\n        super().teardown_class()\n\n    @classmethod\n    def start_destination_server(cls) -> None:\n        \"\"\"\n        Socket handler for the destination_server. Terminates the second TLS\n        layer and send a basic HTTP response.\n        \"\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            try:\n                with cls.server_context.wrap_socket(sock, server_side=True) as ssock:\n                    request = consume_socket(ssock)\n                    validate_request(request)\n                    ssock.send(sample_response())\n            except (ssl.SSLEOFError, ssl.SSLZeroReturnError, OSError):\n                return\n            sock.close()\n\n        cls._start_server(socket_handler)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_tls_in_tls_tunnel(self) -> None:\n        \"\"\"\n        Basic communication over the TLS in TLS tunnel.\n        \"\"\"\n        self.start_destination_server()\n        self.start_proxy_server()\n\n        sock = socket.create_connection(\n            (self.proxy_server.host, self.proxy_server.port)\n        )\n        with self.client_context.wrap_socket(\n            sock, server_hostname=\"localhost\"\n        ) as proxy_sock:\n            with SSLTransport(\n                proxy_sock, self.client_context, server_hostname=\"localhost\"\n            ) as destination_sock:\n                assert destination_sock.version() is not None\n                destination_sock.send(sample_request())\n                response = consume_socket(destination_sock)\n                validate_response(response)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_wrong_sni_hint(self) -> None:\n        \"\"\"\n        Provides a wrong sni hint to validate an exception is thrown.\n        \"\"\"\n        self.start_destination_server()\n        self.start_proxy_server()\n\n        sock = socket.create_connection(\n            (self.proxy_server.host, self.proxy_server.port)\n        )\n        with self.client_context.wrap_socket(\n            sock, server_hostname=\"localhost\"\n        ) as proxy_sock:\n            with pytest.raises(ssl.SSLCertVerificationError):\n                SSLTransport(\n                    proxy_sock, self.client_context, server_hostname=\"veryverywrong\"\n                )\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    @pytest.mark.parametrize(\"buffering\", [None, 0])\n    def test_tls_in_tls_makefile_raw_rw_binary(self, buffering: int | None) -> None:\n        \"\"\"\n        Uses makefile with read, write and binary modes without buffering.\n        \"\"\"\n        self.start_destination_server()\n        self.start_proxy_server()\n\n        sock = socket.create_connection(\n            (self.proxy_server.host, self.proxy_server.port)\n        )\n        with self.client_context.wrap_socket(\n            sock, server_hostname=\"localhost\"\n        ) as proxy_sock:\n            with SSLTransport(\n                proxy_sock, self.client_context, server_hostname=\"localhost\"\n            ) as destination_sock:\n                file = destination_sock.makefile(\"rwb\", buffering)\n                file.write(sample_request())  # type: ignore[call-overload]\n                file.flush()\n\n                response = bytearray(65536)\n                wrote = file.readinto(response)  # type: ignore[union-attr]\n                assert wrote is not None\n                # Allocated response is bigger than the actual response, we\n                # rtrim remaining x00 bytes.\n                str_response = response.decode(\"utf-8\").rstrip(\"\\x00\")\n                validate_response(str_response, binary=False)\n                file.close()\n\n    @pytest.mark.skipif(\n        platform.system() == \"Windows\",\n        reason=\"Skipping windows due to text makefile support\",\n    )\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_tls_in_tls_makefile_rw_text(self) -> None:\n        \"\"\"\n        Creates a separate buffer for reading and writing using text mode and\n        utf-8 encoding.\n        \"\"\"\n        self.start_destination_server()\n        self.start_proxy_server()\n\n        sock = socket.create_connection(\n            (self.proxy_server.host, self.proxy_server.port)\n        )\n        with self.client_context.wrap_socket(\n            sock, server_hostname=\"localhost\"\n        ) as proxy_sock:\n            with SSLTransport(\n                proxy_sock, self.client_context, server_hostname=\"localhost\"\n            ) as destination_sock:\n                read = destination_sock.makefile(\"r\", encoding=\"utf-8\")\n                write = destination_sock.makefile(\"w\", encoding=\"utf-8\")\n\n                write.write(sample_request(binary=False))  # type: ignore[arg-type, call-overload]\n                write.flush()\n\n                response = read.read()\n                assert type(response) is str\n                if \"\\r\" not in response:\n                    # Carriage return will be removed when reading as a file on\n                    # some platforms.  We add it before the comparison.\n                    assert type(response) is str\n                    response = response.replace(\"\\n\", \"\\r\\n\")\n                validate_response(response, binary=False)\n\n    @pytest.mark.timeout(PER_TEST_TIMEOUT)\n    def test_tls_in_tls_recv_into_sendall(self) -> None:\n        \"\"\"\n        Valides recv_into and sendall also work as expected. Other tests are\n        using recv/send.\n        \"\"\"\n        self.start_destination_server()\n        self.start_proxy_server()\n\n        sock = socket.create_connection(\n            (self.proxy_server.host, self.proxy_server.port)\n        )\n        with self.client_context.wrap_socket(\n            sock, server_hostname=\"localhost\"\n        ) as proxy_sock:\n            with SSLTransport(\n                proxy_sock, self.client_context, server_hostname=\"localhost\"\n            ) as destination_sock:\n                destination_sock.sendall(sample_request())\n                response = bytearray(65536)\n                destination_sock.recv_into(response)\n                str_response = response.decode(\"utf-8\").rstrip(\"\\x00\")\n                validate_response(str_response, binary=False)\n\n\nclass TestSSLTransportWithMock:\n    def test_constructor_params(self) -> None:\n        server_hostname = \"example-domain.com\"\n        sock = mock.Mock()\n        context = mock.create_autospec(ssl_.SSLContext)\n        ssl_transport = SSLTransport(\n            sock, context, server_hostname=server_hostname, suppress_ragged_eofs=False\n        )\n        context.wrap_bio.assert_called_with(\n            mock.ANY, mock.ANY, server_hostname=server_hostname\n        )\n        assert not ssl_transport.suppress_ragged_eofs\n\n    def test_various_flags_errors(self) -> None:\n        server_hostname = \"example-domain.com\"\n        sock = mock.Mock()\n        context = mock.create_autospec(ssl_.SSLContext)\n        ssl_transport = SSLTransport(\n            sock, context, server_hostname=server_hostname, suppress_ragged_eofs=False\n        )\n        with pytest.raises(ValueError):\n            ssl_transport.recv(flags=1)\n\n        with pytest.raises(ValueError):\n            ssl_transport.recv_into(bytearray(), flags=1)\n\n        with pytest.raises(ValueError):\n            ssl_transport.sendall(bytearray(), flags=1)\n\n        with pytest.raises(ValueError):\n            ssl_transport.send(None, flags=1)  # type: ignore[arg-type]\n\n    def test_makefile_wrong_mode_error(self) -> None:\n        server_hostname = \"example-domain.com\"\n        sock = mock.Mock()\n        context = mock.create_autospec(ssl_.SSLContext)\n        ssl_transport = SSLTransport(\n            sock, context, server_hostname=server_hostname, suppress_ragged_eofs=False\n        )\n        with pytest.raises(ValueError):\n            ssl_transport.makefile(mode=\"x\")\n\n    def test_wrap_ssl_read_error(self) -> None:\n        server_hostname = \"example-domain.com\"\n        sock = mock.Mock()\n        context = mock.create_autospec(ssl_.SSLContext)\n        ssl_transport = SSLTransport(\n            sock, context, server_hostname=server_hostname, suppress_ragged_eofs=False\n        )\n        with mock.patch.object(ssl_transport, \"_ssl_io_loop\") as _ssl_io_loop:\n            _ssl_io_loop.side_effect = ssl.SSLError()\n            with pytest.raises(ssl.SSLError):\n                ssl_transport._wrap_ssl_read(1)\n", "test/test_wait.py": "from __future__ import annotations\n\nimport signal\nimport threading\nimport time\nimport typing\nfrom socket import socket, socketpair\nfrom types import FrameType\n\nimport pytest\n\nfrom urllib3.util.wait import (\n    _have_working_poll,\n    poll_wait_for_socket,\n    select_wait_for_socket,\n    wait_for_read,\n    wait_for_socket,\n    wait_for_write,\n)\n\nTYPE_SOCKET_PAIR = typing.Tuple[socket, socket]\nTYPE_WAIT_FOR = typing.Callable[..., bool]\n\n\n@pytest.fixture\ndef spair() -> typing.Generator[TYPE_SOCKET_PAIR, None, None]:\n    a, b = socketpair()\n    yield a, b\n    a.close()\n    b.close()\n\n\nvariants: list[TYPE_WAIT_FOR] = [wait_for_socket, select_wait_for_socket]\nif _have_working_poll():\n    variants.append(poll_wait_for_socket)\n\n\n@pytest.mark.parametrize(\"wfs\", variants)\ndef test_wait_for_socket(wfs: TYPE_WAIT_FOR, spair: TYPE_SOCKET_PAIR) -> None:\n    a, b = spair\n\n    with pytest.raises(RuntimeError):\n        wfs(a, read=False, write=False)\n\n    assert not wfs(a, read=True, timeout=0)\n    assert wfs(a, write=True, timeout=0)\n\n    b.send(b\"x\")\n    assert wfs(a, read=True, timeout=0)\n    assert wfs(a, read=True, timeout=10)\n    assert wfs(a, read=True, timeout=None)\n\n    # Fill up the socket with data\n    a.setblocking(False)\n    try:\n        while True:\n            a.send(b\"x\" * 999999)\n    except OSError:\n        pass\n\n    # Now it's not writable anymore\n    assert not wfs(a, write=True, timeout=0)\n\n    # But if we ask for read-or-write, that succeeds\n    assert wfs(a, read=True, write=True, timeout=0)\n\n    # Unless we read from it\n    assert a.recv(1) == b\"x\"\n    assert not wfs(a, read=True, write=True, timeout=0)\n\n    # But if the remote peer closes the socket, then it becomes readable\n    b.close()\n    assert wfs(a, read=True, timeout=0)\n\n    # Waiting for a socket that's actually been closed is just a bug, and\n    # raises some kind of helpful exception (exact details depend on the\n    # platform).\n    with pytest.raises(Exception):\n        wfs(b, read=True)\n\n\ndef test_wait_for_read_write(spair: TYPE_SOCKET_PAIR) -> None:\n    a, b = spair\n\n    assert not wait_for_read(a, 0)\n    assert wait_for_write(a, 0)\n\n    b.send(b\"x\")\n\n    assert wait_for_read(a, 0)\n    assert wait_for_write(a, 0)\n\n    # Fill up the socket with data\n    a.setblocking(False)\n    try:\n        while True:\n            a.send(b\"x\" * 999999)\n    except OSError:\n        pass\n\n    # Now it's not writable anymore\n    assert not wait_for_write(a, 0)\n\n\n@pytest.mark.skipif(not hasattr(signal, \"setitimer\"), reason=\"need setitimer() support\")\n@pytest.mark.parametrize(\"wfs\", variants)\ndef test_eintr(wfs: TYPE_WAIT_FOR, spair: TYPE_SOCKET_PAIR) -> None:\n    a, b = spair\n    interrupt_count = [0]\n\n    def handler(sig: int, frame: FrameType | None) -> typing.Any:\n        assert sig == signal.SIGALRM\n        interrupt_count[0] += 1\n\n    old_handler = signal.signal(signal.SIGALRM, handler)\n    try:\n        assert not wfs(a, read=True, timeout=0)\n        start = time.monotonic()\n        try:\n            # Start delivering SIGALRM 10 times per second\n            signal.setitimer(signal.ITIMER_REAL, 0.1, 0.1)\n            # Sleep for 1 second (we hope!)\n            wfs(a, read=True, timeout=1)\n        finally:\n            # Stop delivering SIGALRM\n            signal.setitimer(signal.ITIMER_REAL, 0)\n        end = time.monotonic()\n        dur = end - start\n        assert 0.9 < dur < 3\n    finally:\n        signal.signal(signal.SIGALRM, old_handler)\n\n    assert interrupt_count[0] > 0\n\n\n@pytest.mark.skipif(not hasattr(signal, \"setitimer\"), reason=\"need setitimer() support\")\n@pytest.mark.parametrize(\"wfs\", variants)\ndef test_eintr_zero_timeout(wfs: TYPE_WAIT_FOR, spair: TYPE_SOCKET_PAIR) -> None:\n    a, b = spair\n    interrupt_count = [0]\n\n    def handler(sig: int, frame: FrameType | None) -> typing.Any:\n        assert sig == signal.SIGALRM\n        interrupt_count[0] += 1\n\n    old_handler = signal.signal(signal.SIGALRM, handler)\n    try:\n        assert not wfs(a, read=True, timeout=0)\n        try:\n            # Start delivering SIGALRM 1000 times per second,\n            # to trigger race conditions such as\n            # https://github.com/urllib3/urllib3/issues/1396.\n            signal.setitimer(signal.ITIMER_REAL, 0.001, 0.001)\n            # Hammer the system call for a while to trigger the\n            # race.\n            end = time.monotonic() + 5\n            for i in range(100000):\n                wfs(a, read=True, timeout=0)\n                if time.monotonic() >= end:\n                    break\n        finally:\n            # Stop delivering SIGALRM\n            signal.setitimer(signal.ITIMER_REAL, 0)\n    finally:\n        signal.signal(signal.SIGALRM, old_handler)\n\n    assert interrupt_count[0] > 0\n\n\n@pytest.mark.skipif(not hasattr(signal, \"setitimer\"), reason=\"need setitimer() support\")\n@pytest.mark.parametrize(\"wfs\", variants)\ndef test_eintr_infinite_timeout(wfs: TYPE_WAIT_FOR, spair: TYPE_SOCKET_PAIR) -> None:\n    a, b = spair\n    interrupt_count = [0]\n\n    def handler(sig: int, frame: FrameType | None) -> typing.Any:\n        assert sig == signal.SIGALRM\n        interrupt_count[0] += 1\n\n    def make_a_readable_after_one_second() -> None:\n        time.sleep(1)\n        b.send(b\"x\")\n\n    old_handler = signal.signal(signal.SIGALRM, handler)\n    try:\n        assert not wfs(a, read=True, timeout=0)\n        start = time.monotonic()\n        try:\n            # Start delivering SIGALRM 10 times per second\n            signal.setitimer(signal.ITIMER_REAL, 0.1, 0.1)\n            # Sleep for 1 second (we hope!)\n            thread = threading.Thread(target=make_a_readable_after_one_second)\n            thread.start()\n            wfs(a, read=True)\n        finally:\n            # Stop delivering SIGALRM\n            signal.setitimer(signal.ITIMER_REAL, 0)\n            thread.join()\n        end = time.monotonic()\n        dur = end - start\n        assert 0.9 < dur < 3\n    finally:\n        signal.signal(signal.SIGALRM, old_handler)\n\n    assert interrupt_count[0] > 0\n", "test/test_poolmanager.py": "from __future__ import annotations\n\nimport gc\nimport socket\nfrom test import resolvesLocalhostFQDN\nfrom unittest import mock\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\n\nfrom urllib3 import connection_from_url\nfrom urllib3.connectionpool import HTTPSConnectionPool\nfrom urllib3.exceptions import LocationValueError\nfrom urllib3.poolmanager import (\n    _DEFAULT_BLOCKSIZE,\n    PoolKey,\n    PoolManager,\n    key_fn_by_scheme,\n)\nfrom urllib3.util import retry, timeout\nfrom urllib3.util.url import Url\n\n\nclass TestPoolManager:\n    @resolvesLocalhostFQDN()\n    def test_same_url(self) -> None:\n        # Convince ourselves that normally we don't get the same object\n        conn1 = connection_from_url(\"http://localhost:8081/foo\")\n        conn2 = connection_from_url(\"http://localhost:8081/bar\")\n\n        assert conn1 != conn2\n\n        # Now try again using the PoolManager\n        p = PoolManager(1)\n\n        conn1 = p.connection_from_url(\"http://localhost:8081/foo\")\n        conn2 = p.connection_from_url(\"http://localhost:8081/bar\")\n\n        assert conn1 == conn2\n\n        # Ensure that FQDNs are handled separately from relative domains\n        p = PoolManager(2)\n\n        conn1 = p.connection_from_url(\"http://localhost.:8081/foo\")\n        conn2 = p.connection_from_url(\"http://localhost:8081/bar\")\n\n        assert conn1 != conn2\n\n    def test_many_urls(self) -> None:\n        urls = [\n            \"http://localhost:8081/foo\",\n            \"http://www.google.com/mail\",\n            \"http://localhost:8081/bar\",\n            \"https://www.google.com/\",\n            \"https://www.google.com/mail\",\n            \"http://yahoo.com\",\n            \"http://bing.com\",\n            \"http://yahoo.com/\",\n        ]\n\n        connections = set()\n\n        p = PoolManager(10)\n\n        for url in urls:\n            conn = p.connection_from_url(url)\n            connections.add(conn)\n\n        assert len(connections) == 5\n\n    def test_manager_clear(self) -> None:\n        p = PoolManager(5)\n\n        p.connection_from_url(\"http://google.com\")\n        assert len(p.pools) == 1\n\n        p.clear()\n        assert len(p.pools) == 0\n\n    @pytest.mark.parametrize(\"url\", [\"http://@\", None])\n    def test_nohost(self, url: str | None) -> None:\n        p = PoolManager(5)\n        with pytest.raises(LocationValueError):\n            p.connection_from_url(url=url)  # type: ignore[arg-type]\n\n    def test_contextmanager(self) -> None:\n        with PoolManager(1) as p:\n            p.connection_from_url(\"http://google.com\")\n            assert len(p.pools) == 1\n\n        assert len(p.pools) == 0\n\n    def test_http_pool_key_fields(self) -> None:\n        \"\"\"Assert the HTTPPoolKey fields are honored when selecting a pool.\"\"\"\n        connection_pool_kw = {\n            \"timeout\": timeout.Timeout(3.14),\n            \"retries\": retry.Retry(total=6, connect=2),\n            \"block\": True,\n            \"source_address\": \"127.0.0.1\",\n            \"blocksize\": _DEFAULT_BLOCKSIZE + 1,\n        }\n        p = PoolManager()\n        conn_pools = [\n            p.connection_from_url(\"http://example.com/\"),\n            p.connection_from_url(\"http://example.com:8000/\"),\n            p.connection_from_url(\"http://other.example.com/\"),\n        ]\n\n        for key, value in connection_pool_kw.items():\n            p.connection_pool_kw[key] = value\n            conn_pools.append(p.connection_from_url(\"http://example.com/\"))\n\n        assert all(\n            x is not y\n            for i, x in enumerate(conn_pools)\n            for j, y in enumerate(conn_pools)\n            if i != j\n        )\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_https_pool_key_fields(self) -> None:\n        \"\"\"Assert the HTTPSPoolKey fields are honored when selecting a pool.\"\"\"\n        connection_pool_kw = {\n            \"timeout\": timeout.Timeout(3.14),\n            \"retries\": retry.Retry(total=6, connect=2),\n            \"block\": True,\n            \"source_address\": \"127.0.0.1\",\n            \"key_file\": \"/root/totally_legit.key\",\n            \"cert_file\": \"/root/totally_legit.crt\",\n            \"cert_reqs\": \"CERT_REQUIRED\",\n            \"ca_certs\": \"/root/path_to_pem\",\n            \"ssl_version\": \"SSLv23_METHOD\",\n            \"blocksize\": _DEFAULT_BLOCKSIZE + 1,\n        }\n        p = PoolManager()\n        conn_pools = [\n            p.connection_from_url(\"https://example.com/\"),\n            p.connection_from_url(\"https://example.com:4333/\"),\n            p.connection_from_url(\"https://other.example.com/\"),\n        ]\n        # Asking for a connection pool with the same key should give us an\n        # existing pool.\n        dup_pools = []\n\n        for key, value in connection_pool_kw.items():\n            p.connection_pool_kw[key] = value\n            conn_pools.append(p.connection_from_url(\"https://example.com/\"))\n            dup_pools.append(p.connection_from_url(\"https://example.com/\"))\n\n        assert all(\n            x is not y\n            for i, x in enumerate(conn_pools)\n            for j, y in enumerate(conn_pools)\n            if i != j\n        )\n        assert all(pool in conn_pools for pool in dup_pools)\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_default_pool_key_funcs_copy(self) -> None:\n        \"\"\"Assert each PoolManager gets a copy of ``pool_keys_by_scheme``.\"\"\"\n        p = PoolManager()\n        assert p.key_fn_by_scheme == p.key_fn_by_scheme\n        assert p.key_fn_by_scheme is not key_fn_by_scheme\n\n    def test_pools_keyed_with_from_host(self) -> None:\n        \"\"\"Assert pools are still keyed correctly with connection_from_host.\"\"\"\n        ssl_kw = {\n            \"key_file\": \"/root/totally_legit.key\",\n            \"cert_file\": \"/root/totally_legit.crt\",\n            \"cert_reqs\": \"CERT_REQUIRED\",\n            \"ca_certs\": \"/root/path_to_pem\",\n            \"ssl_version\": \"SSLv23_METHOD\",\n        }\n        p = PoolManager(5, **ssl_kw)  # type: ignore[arg-type]\n        conns = [p.connection_from_host(\"example.com\", 443, scheme=\"https\")]\n\n        for k in ssl_kw:\n            p.connection_pool_kw[k] = \"newval\"\n            conns.append(p.connection_from_host(\"example.com\", 443, scheme=\"https\"))\n\n        assert all(\n            x is not y\n            for i, x in enumerate(conns)\n            for j, y in enumerate(conns)\n            if i != j\n        )\n\n    def test_https_connection_from_url_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when pooling HTTPS connections.\"\"\"\n        p = PoolManager()\n        pool = p.connection_from_url(\"https://example.com/\")\n        other_pool = p.connection_from_url(\"HTTPS://EXAMPLE.COM/\")\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_https_connection_from_host_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when getting the https key class.\"\"\"\n        p = PoolManager()\n        pool = p.connection_from_host(\"example.com\", scheme=\"https\")\n        other_pool = p.connection_from_host(\"EXAMPLE.COM\", scheme=\"HTTPS\")\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_https_connection_from_context_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when getting the https key class.\"\"\"\n        p = PoolManager()\n        context = {\"scheme\": \"https\", \"host\": \"example.com\", \"port\": \"443\"}\n        other_context = {\"scheme\": \"HTTPS\", \"host\": \"EXAMPLE.COM\", \"port\": \"443\"}\n        pool = p.connection_from_context(context)\n        other_pool = p.connection_from_context(other_context)\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_http_connection_from_url_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when pooling HTTP connections.\"\"\"\n        p = PoolManager()\n        pool = p.connection_from_url(\"http://example.com/\")\n        other_pool = p.connection_from_url(\"HTTP://EXAMPLE.COM/\")\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_http_connection_from_host_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when getting the https key class.\"\"\"\n        p = PoolManager()\n        pool = p.connection_from_host(\"example.com\", scheme=\"http\")\n        other_pool = p.connection_from_host(\"EXAMPLE.COM\", scheme=\"HTTP\")\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    def test_assert_hostname_and_fingerprint_flag(self) -> None:\n        \"\"\"Assert that pool manager can accept hostname and fingerprint flags.\"\"\"\n        fingerprint = \"92:81:FE:85:F7:0C:26:60:EC:D6:B3:BF:93:CF:F9:71:CC:07:7D:0A\"\n        p = PoolManager(assert_hostname=True, assert_fingerprint=fingerprint)\n        pool = p.connection_from_url(\"https://example.com/\")\n        assert 1 == len(p.pools)\n        assert isinstance(pool, HTTPSConnectionPool)\n        assert pool.assert_hostname\n        assert fingerprint == pool.assert_fingerprint\n\n    def test_http_connection_from_context_case_insensitive(self) -> None:\n        \"\"\"Assert scheme case is ignored when getting the https key class.\"\"\"\n        p = PoolManager()\n        context = {\"scheme\": \"http\", \"host\": \"example.com\", \"port\": \"8080\"}\n        other_context = {\"scheme\": \"HTTP\", \"host\": \"EXAMPLE.COM\", \"port\": \"8080\"}\n        pool = p.connection_from_context(context)\n        other_pool = p.connection_from_context(other_context)\n\n        assert 1 == len(p.pools)\n        assert pool is other_pool\n        assert all(isinstance(key, PoolKey) for key in p.pools.keys())\n\n    @patch(\"urllib3.poolmanager.PoolManager.connection_from_host\")\n    def test_deprecated_no_scheme(self, connection_from_host: mock.MagicMock) -> None:\n        # Don't actually make a network connection, just verify the DeprecationWarning\n        connection_from_host.side_effect = ConnectionError(\"Not attempting connection\")\n        p = PoolManager()\n\n        with pytest.warns(DeprecationWarning) as records:\n            with pytest.raises(ConnectionError):\n                p.request(method=\"GET\", url=\"evil.com://good.com\")\n\n        msg = (\n            \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"\n            \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"\n            \"start with 'https://' or 'http://'. Read more in this issue: \"\n            \"https://github.com/urllib3/urllib3/issues/2920\"\n        )\n\n        assert len(records) == 1\n        assert isinstance(records[0].message, DeprecationWarning)\n        assert records[0].message.args[0] == msg\n\n    @patch(\"urllib3.poolmanager.PoolManager.connection_from_pool_key\")\n    def test_connection_from_context_strict_param(\n        self, connection_from_pool_key: mock.MagicMock\n    ) -> None:\n        p = PoolManager()\n        context = {\n            \"scheme\": \"http\",\n            \"host\": \"example.com\",\n            \"port\": 8080,\n            \"strict\": True,\n        }\n        with pytest.warns(DeprecationWarning) as records:\n            p.connection_from_context(context)\n\n        msg = (\n            \"The 'strict' parameter is no longer needed on Python 3+. \"\n            \"This will raise an error in urllib3 v2.1.0.\"\n        )\n        record = records[0]\n        assert isinstance(record.message, Warning)\n        assert record.message.args[0] == msg\n\n        _, kwargs = connection_from_pool_key.call_args\n        assert kwargs[\"request_context\"] == {\n            \"scheme\": \"http\",\n            \"host\": \"example.com\",\n            \"port\": 8080,\n        }\n\n    def test_custom_pool_key(self) -> None:\n        \"\"\"Assert it is possible to define a custom key function.\"\"\"\n        p = PoolManager(10)\n\n        p.key_fn_by_scheme[\"http\"] = lambda x: tuple(x[\"key\"])  # type: ignore[assignment]\n        pool1 = p.connection_from_url(\n            \"http://example.com\", pool_kwargs={\"key\": \"value\"}\n        )\n        pool2 = p.connection_from_url(\n            \"http://example.com\", pool_kwargs={\"key\": \"other\"}\n        )\n        pool3 = p.connection_from_url(\n            \"http://example.com\", pool_kwargs={\"key\": \"value\", \"x\": \"y\"}\n        )\n\n        assert 2 == len(p.pools)\n        assert pool1 is pool3\n        assert pool1 is not pool2\n\n    def test_override_pool_kwargs_url(self) -> None:\n        \"\"\"Assert overriding pool kwargs works with connection_from_url.\"\"\"\n        p = PoolManager()\n        pool_kwargs = {\"retries\": 100, \"block\": True}\n\n        default_pool = p.connection_from_url(\"http://example.com/\")\n        override_pool = p.connection_from_url(\n            \"http://example.com/\", pool_kwargs=pool_kwargs\n        )\n\n        assert retry.Retry.DEFAULT == default_pool.retries\n        assert not default_pool.block\n\n        assert 100 == override_pool.retries\n        assert override_pool.block\n\n    def test_override_pool_kwargs_host(self) -> None:\n        \"\"\"Assert overriding pool kwargs works with connection_from_host\"\"\"\n        p = PoolManager()\n        pool_kwargs = {\"retries\": 100, \"block\": True}\n\n        default_pool = p.connection_from_host(\"example.com\", scheme=\"http\")\n        override_pool = p.connection_from_host(\n            \"example.com\", scheme=\"http\", pool_kwargs=pool_kwargs\n        )\n\n        assert retry.Retry.DEFAULT == default_pool.retries\n        assert not default_pool.block\n\n        assert 100 == override_pool.retries\n        assert override_pool.block\n\n    def test_pool_kwargs_socket_options(self) -> None:\n        \"\"\"Assert passing socket options works with connection_from_host\"\"\"\n        p = PoolManager(socket_options=[])\n        override_opts = [\n            (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1),\n            (socket.IPPROTO_TCP, socket.TCP_NODELAY, 1),\n        ]\n        pool_kwargs = {\"socket_options\": override_opts}\n\n        default_pool = p.connection_from_host(\"example.com\", scheme=\"http\")\n        override_pool = p.connection_from_host(\n            \"example.com\", scheme=\"http\", pool_kwargs=pool_kwargs\n        )\n\n        assert default_pool.conn_kw[\"socket_options\"] == []\n        assert override_pool.conn_kw[\"socket_options\"] == override_opts\n\n    def test_merge_pool_kwargs(self) -> None:\n        \"\"\"Assert _merge_pool_kwargs works in the happy case\"\"\"\n        p = PoolManager(retries=100)\n        merged = p._merge_pool_kwargs({\"new_key\": \"value\"})\n        assert {\"retries\": 100, \"new_key\": \"value\"} == merged\n\n    def test_merge_pool_kwargs_none(self) -> None:\n        \"\"\"Assert false-y values to _merge_pool_kwargs result in defaults\"\"\"\n        p = PoolManager(retries=100)\n        merged = p._merge_pool_kwargs({})\n        assert p.connection_pool_kw == merged\n        merged = p._merge_pool_kwargs(None)\n        assert p.connection_pool_kw == merged\n\n    def test_merge_pool_kwargs_remove_key(self) -> None:\n        \"\"\"Assert keys can be removed with _merge_pool_kwargs\"\"\"\n        p = PoolManager(retries=100)\n        merged = p._merge_pool_kwargs({\"retries\": None})\n        assert \"retries\" not in merged\n\n    def test_merge_pool_kwargs_invalid_key(self) -> None:\n        \"\"\"Assert removing invalid keys with _merge_pool_kwargs doesn't break\"\"\"\n        p = PoolManager(retries=100)\n        merged = p._merge_pool_kwargs({\"invalid_key\": None})\n        assert p.connection_pool_kw == merged\n\n    def test_pool_manager_no_url_absolute_form(self) -> None:\n        \"\"\"Valides we won't send a request with absolute form without a proxy\"\"\"\n        p = PoolManager()\n        assert p._proxy_requires_url_absolute_form(Url(\"http://example.com\")) is False\n        assert p._proxy_requires_url_absolute_form(Url(\"https://example.com\")) is False\n\n    @pytest.mark.parametrize(\n        \"input_blocksize,expected_blocksize\",\n        [\n            (_DEFAULT_BLOCKSIZE, _DEFAULT_BLOCKSIZE),\n            (None, _DEFAULT_BLOCKSIZE),\n            (8192, 8192),\n        ],\n    )\n    def test_poolmanager_blocksize(\n        self, input_blocksize: int, expected_blocksize: int\n    ) -> None:\n        \"\"\"Assert PoolManager sets blocksize properly\"\"\"\n        p = PoolManager()\n\n        pool_blocksize = p.connection_from_url(\n            \"http://example.com\", {\"blocksize\": input_blocksize}\n        )\n        assert pool_blocksize.conn_kw[\"blocksize\"] == expected_blocksize\n        assert pool_blocksize._get_conn().blocksize == expected_blocksize\n\n    @pytest.mark.parametrize(\n        \"url\",\n        [\n            \"[a::b%zone]\",\n            \"[a::b%25zone]\",\n            \"http://[a::b%zone]\",\n            \"http://[a::b%25zone]\",\n        ],\n    )\n    @patch(\"urllib3.util.connection.create_connection\")\n    def test_e2e_connect_to_ipv6_scoped(\n        self, create_connection: MagicMock, url: str\n    ) -> None:\n        \"\"\"Checks that IPv6 scoped addresses are properly handled end-to-end.\n\n        This is not strictly speaking a pool manager unit test - this test\n        lives here in absence of a better code location for e2e/integration\n        tests.\n        \"\"\"\n        p = PoolManager()\n        conn_pool = p.connection_from_url(url)\n        conn = conn_pool._get_conn()\n        conn.connect()\n\n        assert create_connection.call_args[0][0] == (\"a::b%zone\", 80)\n\n    @patch(\"urllib3.connection.ssl_wrap_socket\")\n    @patch(\"urllib3.util.connection.create_connection\")\n    def test_e2e_connect_to_ipv6_scoped_tls(\n        self, create_connection: MagicMock, ssl_wrap_socket: MagicMock\n    ) -> None:\n        p = PoolManager()\n        conn_pool = p.connection_from_url(\n            \"https://[a::b%zone]\", pool_kwargs={\"assert_hostname\": False}\n        )\n        conn = conn_pool._get_conn()\n        conn.connect()\n\n        assert ssl_wrap_socket.call_args[1][\"server_hostname\"] == \"a::b\"\n\n    def test_thread_safty(self) -> None:\n        pool_manager = PoolManager(num_pools=2)\n\n        # thread 1 gets a pool for host x\n        pool_1 = pool_manager.connection_from_url(\"http://host_x:80/\")\n\n        # thread 2 gets a pool for host y\n        pool_2 = pool_manager.connection_from_url(\"http://host_y:80/\")\n\n        # thread 3 gets a pool for host z\n        pool_3 = pool_manager.connection_from_url(\"http://host_z:80\")\n\n        # None of the pools should be closed, since all of them are referenced.\n        assert pool_1.pool is not None\n        assert pool_2.pool is not None\n        assert pool_3.pool is not None\n\n        conn_queue = pool_1.pool\n        assert conn_queue.qsize() > 0\n\n        # thread 1 stops.\n        del pool_1\n        gc.collect()\n\n        # Connection should be closed, because reference to pool_1 is gone.\n        assert conn_queue.qsize() == 0\n", "test/contrib/test_pyopenssl_dependencies.py": "from __future__ import annotations\n\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\ntry:\n    from urllib3.contrib.pyopenssl import extract_from_urllib3, inject_into_urllib3\nexcept ImportError:\n    pass\n\n\ndef setup_module() -> None:\n    try:\n        from urllib3.contrib.pyopenssl import inject_into_urllib3\n\n        inject_into_urllib3()\n    except ImportError as e:\n        pytest.skip(f\"Could not import PyOpenSSL: {e!r}\")\n\n\ndef teardown_module() -> None:\n    try:\n        from urllib3.contrib.pyopenssl import extract_from_urllib3\n\n        extract_from_urllib3()\n    except ImportError:\n        pass\n\n\nclass TestPyOpenSSLInjection:\n    \"\"\"\n    Tests for error handling in pyopenssl's 'inject_into urllib3'\n    \"\"\"\n\n    def test_inject_validate_fail_cryptography(self) -> None:\n        \"\"\"\n        Injection should not be supported if cryptography is too old.\n        \"\"\"\n        try:\n            with patch(\"cryptography.x509.extensions.Extensions\") as mock:\n                del mock.get_extension_for_class\n                with pytest.raises(ImportError):\n                    inject_into_urllib3()\n        finally:\n            # `inject_into_urllib3` is not supposed to succeed.\n            # If it does, this test should fail, but we need to\n            # clean up so that subsequent tests are unaffected.\n            extract_from_urllib3()\n\n    def test_inject_validate_fail_pyopenssl(self) -> None:\n        \"\"\"\n        Injection should not be supported if pyOpenSSL is too old.\n        \"\"\"\n        try:\n            return_val = Mock()\n            del return_val._x509\n            with patch(\"OpenSSL.crypto.X509\", return_value=return_val):\n                with pytest.raises(ImportError):\n                    inject_into_urllib3()\n        finally:\n            # `inject_into_urllib3` is not supposed to succeed.\n            # If it does, this test should fail, but we need to\n            # clean up so that subsequent tests are unaffected.\n            extract_from_urllib3()\n", "test/contrib/test_socks.py": "from __future__ import annotations\n\nimport socket\nimport threading\nimport typing\nfrom socket import getaddrinfo as real_getaddrinfo\nfrom socket import timeout as SocketTimeout\nfrom test import SHORT_TIMEOUT\nfrom unittest.mock import Mock, patch\n\nimport pytest\nimport socks as py_socks  # type: ignore[import-not-found]\n\nfrom dummyserver.socketserver import DEFAULT_CA, DEFAULT_CERTS\nfrom dummyserver.testcase import IPV4SocketDummyServerTestCase\nfrom urllib3.contrib import socks\nfrom urllib3.exceptions import ConnectTimeoutError, NewConnectionError\n\ntry:\n    import ssl\n\n    from urllib3.util import ssl_ as better_ssl\n\n    HAS_SSL = True\nexcept ImportError:\n    ssl = None  # type: ignore[assignment]\n    better_ssl = None  # type: ignore[assignment]\n    HAS_SSL = False\n\n\nSOCKS_NEGOTIATION_NONE = b\"\\x00\"\nSOCKS_NEGOTIATION_PASSWORD = b\"\\x02\"\n\nSOCKS_VERSION_SOCKS4 = b\"\\x04\"\nSOCKS_VERSION_SOCKS5 = b\"\\x05\"\n\n\ndef _get_free_port(host: str) -> int:\n    \"\"\"\n    Gets a free port by opening a socket, binding it, checking the assigned\n    port, and then closing it.\n    \"\"\"\n    s = socket.socket()\n    s.bind((host, 0))\n    port = s.getsockname()[1]\n    s.close()\n    return port  # type: ignore[no-any-return]\n\n\ndef _read_exactly(sock: socket.socket, amt: int) -> bytes:\n    \"\"\"\n    Read *exactly* ``amt`` bytes from the socket ``sock``.\n    \"\"\"\n    data = b\"\"\n\n    while amt > 0:\n        chunk = sock.recv(amt)\n        data += chunk\n        amt -= len(chunk)\n\n    return data\n\n\ndef _read_until(sock: socket.socket, char: bytes) -> bytes:\n    \"\"\"\n    Read from the socket until the character is received.\n    \"\"\"\n    chunks = []\n    while True:\n        chunk = sock.recv(1)\n        chunks.append(chunk)\n        if chunk == char:\n            break\n\n    return b\"\".join(chunks)\n\n\ndef _address_from_socket(sock: socket.socket) -> bytes | str:\n    \"\"\"\n    Returns the address from the SOCKS socket\n    \"\"\"\n    addr_type = sock.recv(1)\n\n    if addr_type == b\"\\x01\":\n        ipv4_addr = _read_exactly(sock, 4)\n        return socket.inet_ntoa(ipv4_addr)\n    elif addr_type == b\"\\x04\":\n        ipv6_addr = _read_exactly(sock, 16)\n        return socket.inet_ntop(socket.AF_INET6, ipv6_addr)\n    elif addr_type == b\"\\x03\":\n        addr_len = ord(sock.recv(1))\n        return _read_exactly(sock, addr_len)\n    else:\n        raise RuntimeError(f\"Unexpected addr type: {addr_type!r}\")\n\n\ndef _set_up_fake_getaddrinfo(monkeypatch: pytest.MonkeyPatch) -> None:\n    # Work around https://github.com/urllib3/urllib3/pull/2034\n    # Nothing prevents localhost to point to two different IPs. For example, in the\n    # Ubuntu set up by GitHub Actions, localhost points both to 127.0.0.1 and ::1.\n    #\n    # In case of failure, PySocks will try the same request on both IPs, but our\n    # handle_socks[45]_negotiation functions don't handle retries, which leads either to\n    # a deadlock or a timeout in case of a failure on the first address.\n    #\n    # However, some tests need to exercise failure. We don't want retries there, but\n    # can't affect PySocks retries via its API. Instead, we monkeypatch PySocks so that\n    # it only sees a single address, which effectively disables retries.\n    def fake_getaddrinfo(\n        addr: str, port: int, family: int, socket_type: int\n    ) -> list[\n        tuple[\n            socket.AddressFamily,\n            socket.SocketKind,\n            int,\n            str,\n            tuple[str, int] | tuple[str, int, int, int],\n        ]\n    ]:\n        gai_list = real_getaddrinfo(addr, port, family, socket_type)\n        gai_list = [gai for gai in gai_list if gai[0] == socket.AF_INET]\n        return gai_list[:1]\n\n    monkeypatch.setattr(py_socks.socket, \"getaddrinfo\", fake_getaddrinfo)\n\n\ndef handle_socks5_negotiation(\n    sock: socket.socket,\n    negotiate: bool,\n    username: bytes | None = None,\n    password: bytes | None = None,\n) -> typing.Generator[tuple[bytes | str, int], bool, None]:\n    \"\"\"\n    Handle the SOCKS5 handshake.\n\n    Returns a generator object that allows us to break the handshake into\n    steps so that the test code can intervene at certain useful points.\n    \"\"\"\n    received_version = sock.recv(1)\n    assert received_version == SOCKS_VERSION_SOCKS5\n    nmethods = ord(sock.recv(1))\n    methods = _read_exactly(sock, nmethods)\n\n    if negotiate:\n        assert SOCKS_NEGOTIATION_PASSWORD in methods\n        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_PASSWORD\n        sock.sendall(send_data)\n\n        # This is the password negotiation.\n        negotiation_version = sock.recv(1)\n        assert negotiation_version == b\"\\x01\"\n        ulen = ord(sock.recv(1))\n        provided_username = _read_exactly(sock, ulen)\n        plen = ord(sock.recv(1))\n        provided_password = _read_exactly(sock, plen)\n\n        if username == provided_username and password == provided_password:\n            sock.sendall(b\"\\x01\\x00\")\n        else:\n            sock.sendall(b\"\\x01\\x01\")\n            sock.close()\n            return\n    else:\n        assert SOCKS_NEGOTIATION_NONE in methods\n        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_NONE\n        sock.sendall(send_data)\n\n    # Client sends where they want to go.\n    received_version = sock.recv(1)\n    command = sock.recv(1)\n    reserved = sock.recv(1)\n    addr = _address_from_socket(sock)\n    port_raw = _read_exactly(sock, 2)\n    port = (ord(port_raw[0:1]) << 8) + (ord(port_raw[1:2]))\n\n    # Check some basic stuff.\n    assert received_version == SOCKS_VERSION_SOCKS5\n    assert command == b\"\\x01\"  # Only support connect, not bind.\n    assert reserved == b\"\\x00\"\n\n    # Yield the address port tuple.\n    succeed = yield addr, port\n\n    if succeed:\n        # Hard-coded response for now.\n        response = SOCKS_VERSION_SOCKS5 + b\"\\x00\\x00\\x01\\x7f\\x00\\x00\\x01\\xea\\x60\"\n    else:\n        # Hard-coded response for now.\n        response = SOCKS_VERSION_SOCKS5 + b\"\\x01\\00\"\n\n    sock.sendall(response)\n\n\ndef handle_socks4_negotiation(\n    sock: socket.socket, username: bytes | None = None\n) -> typing.Generator[tuple[bytes | str, int], bool, None]:\n    \"\"\"\n    Handle the SOCKS4 handshake.\n\n    Returns a generator object that allows us to break the handshake into\n    steps so that the test code can intervene at certain useful points.\n    \"\"\"\n    received_version = sock.recv(1)\n    command = sock.recv(1)\n    port_raw = _read_exactly(sock, 2)\n    port = (ord(port_raw[0:1]) << 8) + (ord(port_raw[1:2]))\n    addr_raw = _read_exactly(sock, 4)\n    provided_username = _read_until(sock, b\"\\x00\")[:-1]  # Strip trailing null.\n\n    addr: bytes | str\n    if addr_raw == b\"\\x00\\x00\\x00\\x01\":\n        # Magic string: means DNS name.\n        addr = _read_until(sock, b\"\\x00\")[:-1]  # Strip trailing null.\n    else:\n        addr = socket.inet_ntoa(addr_raw)\n\n    # Check some basic stuff.\n    assert received_version == SOCKS_VERSION_SOCKS4\n    assert command == b\"\\x01\"  # Only support connect, not bind.\n\n    if username is not None and username != provided_username:\n        sock.sendall(b\"\\x00\\x5d\\x00\\x00\\x00\\x00\\x00\\x00\")\n        sock.close()\n        return\n\n    # Yield the address port tuple.\n    succeed = yield addr, port\n\n    if succeed:\n        response = b\"\\x00\\x5a\\xea\\x60\\x7f\\x00\\x00\\x01\"\n    else:\n        response = b\"\\x00\\x5b\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n    sock.sendall(response)\n\n\nclass TestSOCKSProxyManager:\n    def test_invalid_socks_version_is_valueerror(self) -> None:\n        with pytest.raises(ValueError, match=\"Unable to determine SOCKS version\"):\n            socks.SOCKSProxyManager(proxy_url=\"http://example.org\")\n\n\nclass TestSocks5Proxy(IPV4SocketDummyServerTestCase):\n    \"\"\"\n    Test the SOCKS proxy in SOCKS5 mode.\n    \"\"\"\n\n    def test_basic_request(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n\n    def test_local_dns(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n\n            assert addr in [\"127.0.0.1\", \"::1\"]\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://localhost\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n\n    def test_correct_header_line(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n\n            assert addr == b\"example.com\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            buf = b\"\"\n            while True:\n                buf += sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            assert buf.startswith(b\"GET / HTTP/1.1\")\n            assert b\"Host: example.com\" in buf\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://example.com\")\n            assert response.status == 200\n\n    def test_connection_timeouts(self) -> None:\n        event = threading.Event()\n\n        def request_handler(listener: socket.socket) -> None:\n            event.wait()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            with pytest.raises(ConnectTimeoutError):\n                pm.request(\n                    \"GET\", \"http://example.com\", timeout=SHORT_TIMEOUT, retries=False\n                )\n            event.set()\n\n    @patch(\"socks.create_connection\")\n    def test_socket_timeout(self, create_connection: Mock) -> None:\n        create_connection.side_effect = SocketTimeout()\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            with pytest.raises(ConnectTimeoutError, match=\"timed out\"):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n\n    def test_connection_failure(self) -> None:\n        event = threading.Event()\n\n        def request_handler(listener: socket.socket) -> None:\n            listener.close()\n            event.set()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            event.wait()\n            with pytest.raises(NewConnectionError):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n\n    def test_proxy_rejection(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        _set_up_fake_getaddrinfo(monkeypatch)\n        evt = threading.Event()\n\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n            with pytest.raises(StopIteration):\n                handler.send(False)\n\n            evt.wait()\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            with pytest.raises(NewConnectionError):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n            evt.set()\n\n    def test_socks_with_password(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(\n                sock, negotiate=True, username=b\"user\", password=b\"pass\"\n            )\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url, username=\"user\", password=\"pass\") as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n\n    def test_socks_with_auth_in_url(self) -> None:\n        \"\"\"\n        Test when we have auth info in url, i.e.\n        socks5://user:pass@host:port and no username/password as params\n        \"\"\"\n\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(\n                sock, negotiate=True, username=b\"user\", password=b\"pass\"\n            )\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5://user:pass@{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n\n    def test_socks_with_invalid_password(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        _set_up_fake_getaddrinfo(monkeypatch)\n\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(\n                sock, negotiate=True, username=b\"user\", password=b\"pass\"\n            )\n            with pytest.raises(StopIteration):\n                next(handler)\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(\n            proxy_url, username=\"user\", password=\"badpass\"\n        ) as pm:\n            with pytest.raises(\n                NewConnectionError, match=\"SOCKS5 authentication failed\"\n            ):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n\n    def test_source_address_works(self) -> None:\n        expected_port = _get_free_port(self.host)\n\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            assert sock.getpeername()[0] == \"127.0.0.1\"\n            assert sock.getpeername()[1] == expected_port\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(\n            proxy_url, source_address=(\"127.0.0.1\", expected_port)\n        ) as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n            assert response.status == 200\n\n\nclass TestSOCKS4Proxy(IPV4SocketDummyServerTestCase):\n    \"\"\"\n    Test the SOCKS proxy in SOCKS4 mode.\n\n    Has relatively fewer tests than the SOCKS5 case, mostly because once the\n    negotiation is done the two cases behave identically.\n    \"\"\"\n\n    def test_basic_request(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock)\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n\n            assert response.status == 200\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n            assert response.data == b\"\"\n\n    def test_local_dns(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock)\n            addr, port = next(handler)\n\n            assert addr == \"127.0.0.1\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://localhost\")\n\n            assert response.status == 200\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n            assert response.data == b\"\"\n\n    def test_correct_header_line(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock)\n            addr, port = next(handler)\n\n            assert addr == b\"example.com\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            buf = b\"\"\n            while True:\n                buf += sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            assert buf.startswith(b\"GET / HTTP/1.1\")\n            assert b\"Host: example.com\" in buf\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4a://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            response = pm.request(\"GET\", \"http://example.com\")\n            assert response.status == 200\n\n    def test_proxy_rejection(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        _set_up_fake_getaddrinfo(monkeypatch)\n        evt = threading.Event()\n\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock)\n            addr, port = next(handler)\n            with pytest.raises(StopIteration):\n                handler.send(False)\n\n            evt.wait()\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4a://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url) as pm:\n            with pytest.raises(NewConnectionError):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n            evt.set()\n\n    def test_socks4_with_username(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock, username=b\"user\")\n            addr, port = next(handler)\n\n            assert addr == \"16.17.18.19\"\n            assert port == 80\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            while True:\n                buf = sock.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url, username=\"user\") as pm:\n            response = pm.request(\"GET\", \"http://16.17.18.19\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n\n    def test_socks_with_invalid_username(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks4_negotiation(sock, username=b\"user\")\n            next(handler, None)\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks4a://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url, username=\"baduser\") as pm:\n            with pytest.raises(NewConnectionError, match=\"different user-ids\"):\n                pm.request(\"GET\", \"http://example.com\", retries=False)\n\n\nclass TestSOCKSWithTLS(IPV4SocketDummyServerTestCase):\n    \"\"\"\n    Test that TLS behaves properly for SOCKS proxies.\n    \"\"\"\n\n    @pytest.mark.skipif(not HAS_SSL, reason=\"No TLS available\")\n    def test_basic_request(self) -> None:\n        def request_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            handler = handle_socks5_negotiation(sock, negotiate=False)\n            addr, port = next(handler)\n\n            assert addr == b\"localhost\"\n            assert port == 443\n            with pytest.raises(StopIteration):\n                handler.send(True)\n\n            # Wrap in TLS\n            context = better_ssl.SSLContext(ssl.PROTOCOL_SSLv23)  # type: ignore[misc]\n            context.load_cert_chain(DEFAULT_CERTS[\"certfile\"], DEFAULT_CERTS[\"keyfile\"])\n            tls = context.wrap_socket(sock, server_side=True)\n            buf = b\"\"\n\n            while True:\n                buf += tls.recv(65535)\n                if buf.endswith(b\"\\r\\n\\r\\n\"):\n                    break\n\n            assert buf.startswith(b\"GET / HTTP/1.1\\r\\n\")\n\n            tls.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: SocksTestServer\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            tls.close()\n            sock.close()\n\n        self._start_server(request_handler)\n        proxy_url = f\"socks5h://{self.host}:{self.port}\"\n        with socks.SOCKSProxyManager(proxy_url, ca_certs=DEFAULT_CA) as pm:\n            response = pm.request(\"GET\", \"https://localhost\")\n\n            assert response.status == 200\n            assert response.data == b\"\"\n            assert response.headers[\"Server\"] == \"SocksTestServer\"\n", "test/contrib/test_pyopenssl.py": "from __future__ import annotations\n\nimport os\nfrom unittest import mock\n\nimport pytest\n\ntry:\n    from cryptography import x509\n    from OpenSSL.crypto import (  # type: ignore[import-untyped]\n        FILETYPE_PEM,\n        load_certificate,\n    )\n\n    from urllib3.contrib.pyopenssl import _dnsname_to_stdlib, get_subj_alt_name\nexcept ImportError:\n    pass\n\n\ndef setup_module() -> None:\n    try:\n        from urllib3.contrib.pyopenssl import inject_into_urllib3\n\n        inject_into_urllib3()\n    except ImportError as e:\n        pytest.skip(f\"Could not import PyOpenSSL: {e!r}\")\n\n\ndef teardown_module() -> None:\n    try:\n        from urllib3.contrib.pyopenssl import extract_from_urllib3\n\n        extract_from_urllib3()\n    except ImportError:\n        pass\n\n\nfrom ..test_ssl import TestSSL  # noqa: E402, F401\nfrom ..test_util import TestUtilSSL  # noqa: E402, F401\nfrom ..with_dummyserver.test_https import (  # noqa: E402, F401\n    TestHTTPS_IPV4SAN,\n    TestHTTPS_IPV6SAN,\n    TestHTTPS_TLSv1,\n    TestHTTPS_TLSv1_1,\n    TestHTTPS_TLSv1_2,\n    TestHTTPS_TLSv1_3,\n)\nfrom ..with_dummyserver.test_socketlevel import (  # noqa: E402, F401\n    TestClientCerts,\n    TestSNI,\n    TestSocketClosing,\n)\nfrom ..with_dummyserver.test_socketlevel import (  # noqa: E402, F401\n    TestSSL as TestSocketSSL,\n)\n\n\nclass TestPyOpenSSLHelpers:\n    \"\"\"\n    Tests for PyOpenSSL helper functions.\n    \"\"\"\n\n    def test_dnsname_to_stdlib_simple(self) -> None:\n        \"\"\"\n        We can convert a dnsname to a native string when the domain is simple.\n        \"\"\"\n        name = \"\u0909\u0926\u093e\u0939\u0930\u0923.\u092a\u0930\u0940\u0915\"\n        expected_result = \"xn--p1b6ci4b4b3a.xn--11b5bs8d\"\n\n        assert _dnsname_to_stdlib(name) == expected_result\n\n    def test_dnsname_to_stdlib_leading_period(self) -> None:\n        \"\"\"\n        If there is a . in front of the domain name we correctly encode it.\n        \"\"\"\n        name = \".\u0909\u0926\u093e\u0939\u0930\u0923.\u092a\u0930\u0940\u0915\"\n        expected_result = \".xn--p1b6ci4b4b3a.xn--11b5bs8d\"\n\n        assert _dnsname_to_stdlib(name) == expected_result\n\n    def test_dnsname_to_stdlib_leading_splat(self) -> None:\n        \"\"\"\n        If there's a wildcard character in the front of the string we handle it\n        appropriately.\n        \"\"\"\n        name = \"*.\u0909\u0926\u093e\u0939\u0930\u0923.\u092a\u0930\u0940\u0915\"\n        expected_result = \"*.xn--p1b6ci4b4b3a.xn--11b5bs8d\"\n\n        assert _dnsname_to_stdlib(name) == expected_result\n\n    @mock.patch(\"urllib3.contrib.pyopenssl.log.warning\")\n    def test_get_subj_alt_name(self, mock_warning: mock.MagicMock) -> None:\n        \"\"\"\n        If a certificate has two subject alternative names, cryptography raises\n        an x509.DuplicateExtension exception.\n        \"\"\"\n        path = os.path.join(os.path.dirname(__file__), \"duplicate_san.pem\")\n        with open(path) as fp:\n            cert = load_certificate(FILETYPE_PEM, fp.read())\n\n        assert get_subj_alt_name(cert) == []\n\n        assert mock_warning.call_count == 1\n        assert isinstance(mock_warning.call_args[0][1], x509.DuplicateExtension)\n", "test/contrib/__init__.py": "", "test/contrib/emscripten/test_emscripten.py": "from __future__ import annotations\n\nimport sys\nimport typing\n\nimport pytest\n\nfrom urllib3.fields import _TYPE_FIELD_VALUE_TUPLE\n\nfrom ...port_helpers import find_unused_port\n\nif sys.version_info < (3, 11):\n    # pyodide only works on 3.11+\n    pytest.skip(allow_module_level=True)\n\n# only run these tests if pytest_pyodide is installed\n# so we don't break non-emscripten pytest running\npytest_pyodide = pytest.importorskip(\"pytest_pyodide\")\n\nfrom pytest_pyodide import run_in_pyodide  # type: ignore[import-not-found] # noqa: E402\nfrom pytest_pyodide.decorator import (  # type: ignore[import-not-found] # noqa: E402\n    copy_files_to_pyodide,\n)\n\nfrom .conftest import PyodideServerInfo, ServerRunnerInfo  # noqa: E402\n\n# make our ssl certificates work in chrome\npytest_pyodide.runner.CHROME_FLAGS.append(\"ignore-certificate-errors\")\n\n\n# copy our wheel file to pyodide and install it\ndef install_urllib3_wheel() -> (\n    typing.Callable[\n        [typing.Callable[..., typing.Any]], typing.Callable[..., typing.Any]\n    ]\n):\n    return copy_files_to_pyodide(  # type: ignore[no-any-return]\n        file_list=[(\"dist/*.whl\", \"/tmp\")], install_wheels=True\n    )\n\n\n@install_urllib3_wheel()\ndef test_index(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3.connection import HTTPConnection\n        from urllib3.response import BaseHTTPResponse\n\n        conn = HTTPConnection(host, port)\n        url = f\"http://{host}:{port}/\"\n        conn.request(\"GET\", url)\n        response = conn.getresponse()\n        # check methods of response\n        assert isinstance(response, BaseHTTPResponse)\n        assert response.url == url\n        response.url = \"http://woo\"\n        assert response.url == \"http://woo\"\n        assert response.connection == conn\n        assert response.retries is None\n        data1 = response.data\n        decoded1 = data1.decode(\"utf-8\")\n        data2 = response.data  # check that getting data twice works\n        decoded2 = data2.decode(\"utf-8\")\n        assert decoded1 == decoded2 == \"Dummy server!\"\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_pool_requests(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int, https_port: int) -> None:  # type: ignore[no-untyped-def]\n        # first with PoolManager\n        import urllib3\n\n        http = urllib3.PoolManager()\n        resp = http.request(\"GET\", f\"http://{host}:{port}/\")\n        assert resp.data.decode(\"utf-8\") == \"Dummy server!\"\n\n        resp2 = http.request(\"GET\", f\"http://{host}:{port}/index\")\n        assert resp2.data.decode(\"utf-8\") == \"Dummy server!\"\n\n        # should all have come from one pool\n        assert len(http.pools) == 1\n\n        resp3 = http.request(\"GET\", f\"https://{host}:{https_port}/\")\n        assert resp2.data.decode(\"utf-8\") == \"Dummy server!\"\n\n        # one http pool + one https pool\n        assert len(http.pools) == 2\n\n        # now with ConnectionPool\n        # because block == True, this will fail if the connection isn't\n        # returned to the pool correctly after the first request\n        pool = urllib3.HTTPConnectionPool(host, port, maxsize=1, block=True)\n        resp3 = pool.urlopen(\"GET\", \"/index\")\n        assert resp3.data.decode(\"utf-8\") == \"Dummy server!\"\n\n        resp4 = pool.urlopen(\"GET\", \"/\")\n        assert resp4.data.decode(\"utf-8\") == \"Dummy server!\"\n\n        # now with manual release of connection\n        # first - connection should be released once all\n        # data is read\n        pool2 = urllib3.HTTPConnectionPool(host, port, maxsize=1, block=True)\n\n        resp5 = pool2.urlopen(\"GET\", \"/index\", preload_content=False)\n        assert pool2.pool is not None\n        # at this point, the connection should not be in the pool\n        assert pool2.pool.qsize() == 0\n        assert resp5.data.decode(\"utf-8\") == \"Dummy server!\"\n        # now we've read all the data, connection should be back to the pool\n        assert pool2.pool.qsize() == 1\n        resp6 = pool2.urlopen(\"GET\", \"/index\", preload_content=False)\n        assert pool2.pool.qsize() == 0\n        # force it back to the pool\n        resp6.release_conn()\n        assert pool2.pool.qsize() == 1\n        read_str = resp6.read()\n        # for consistency with urllib3, this still returns the correct data even though\n        # we are in theory not using the connection any more\n        assert read_str.decode(\"utf-8\") == \"Dummy server!\"\n\n    pyodide_test(\n        selenium_coverage,\n        testserver_http.http_host,\n        testserver_http.http_port,\n        testserver_http.https_port,\n    )\n\n\n# wrong protocol / protocol error etc. should raise an exception of http.client.HTTPException\n@install_urllib3_wheel()\ndef test_wrong_protocol(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import http.client\n\n        import pytest\n\n        from urllib3.connection import HTTPConnection\n\n        conn = HTTPConnection(host, port)\n        with pytest.raises(http.client.HTTPException):\n            conn.request(\"GET\", f\"http://{host}:{port}/\")\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n# wrong protocol / protocol error etc. should raise an exception of http.client.HTTPException\n@install_urllib3_wheel()\ndef test_bad_method(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide(packages=(\"pytest\",))  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import http.client\n\n        import pytest\n\n        from urllib3.connection import HTTPConnection\n\n        conn = HTTPConnection(host, port)\n        with pytest.raises(http.client.HTTPException):\n            conn.request(\"TRACE\", f\"http://{host}:{port}/\")\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n# no connection - should raise\n@install_urllib3_wheel()\ndef test_no_response(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide(packages=(\"pytest\",))  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import http.client\n\n        import pytest\n\n        from urllib3.connection import HTTPConnection\n\n        conn = HTTPConnection(host, port)\n        with pytest.raises(http.client.HTTPException):\n            conn.request(\"GET\", f\"http://{host}:{port}/\")\n            _ = conn.getresponse()\n\n    pyodide_test(selenium_coverage, testserver_http.http_host, find_unused_port())\n\n\n@install_urllib3_wheel()\ndef test_404(selenium_coverage: typing.Any, testserver_http: PyodideServerInfo) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3.connection import HTTPConnection\n        from urllib3.response import BaseHTTPResponse\n\n        conn = HTTPConnection(host, port)\n        conn.request(\"GET\", f\"http://{host}:{port}/status?status=404 NOT FOUND\")\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        assert response.status == 404\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n# setting timeout should show a warning to js console\n# if we're on the ui thread, because XMLHttpRequest doesn't\n# support timeout in async mode if globalThis == Window\n@install_urllib3_wheel()\ndef test_timeout_warning(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide()  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import js  # type: ignore[import-not-found]\n\n        import urllib3.contrib.emscripten.fetch\n        from urllib3.connection import HTTPConnection\n\n        old_log = js.console.warn\n        log_msgs = []\n\n        def capture_log(*args):  # type: ignore[no-untyped-def]\n            log_msgs.append(str(args))\n            old_log(*args)\n\n        js.console.warn = capture_log\n\n        conn = HTTPConnection(host, port, timeout=1.0)\n        conn.request(\"GET\", f\"http://{host}:{port}/\")\n        conn.getresponse()\n        js.console.warn = old_log\n        # should have shown timeout warning exactly once by now\n        assert len([x for x in log_msgs if x.find(\"Warning: Timeout\") != -1]) == 1\n        assert urllib3.contrib.emscripten.fetch._SHOWN_TIMEOUT_WARNING\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_timeout_in_worker_non_streaming(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    worker_code = f\"\"\"\n        import pyodide_js as pjs\n        await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n        from urllib3.exceptions import TimeoutError\n        from urllib3.connection import HTTPConnection\n        conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port},timeout=1.0)\n        result=-1\n        try:\n            conn.request(\"GET\",\"/slow\")\n            _response = conn.getresponse()\n            result=-3\n        except TimeoutError as e:\n            result=1 # we've got the correct exception\n        except BaseException as e:\n            result=-2\n        assert result == 1\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_timeout_in_worker_streaming(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    worker_code = f\"\"\"\n        import pyodide_js as pjs\n        await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n        import urllib3.contrib.emscripten.fetch\n        await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n        from urllib3.exceptions import TimeoutError\n        from urllib3.connection import HTTPConnection\n        conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port},timeout=1.0)\n        result=-1\n        try:\n            conn.request(\"GET\",\"/slow\",preload_content=False)\n            _response = conn.getresponse()\n            result=-3\n        except TimeoutError as e:\n            result=1 # we've got the correct exception\n        except BaseException as e:\n            result=-2\n        assert result == 1\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_index_https(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3.connection import HTTPSConnection\n        from urllib3.response import BaseHTTPResponse\n\n        conn = HTTPSConnection(host, port)\n        conn.request(\"GET\", f\"https://{host}:{port}/\")\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        data = response.data\n        assert data.decode(\"utf-8\") == \"Dummy server!\"\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_non_streaming_no_fallback_warning(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import js\n\n        import urllib3.contrib.emscripten.fetch\n        from urllib3.connection import HTTPSConnection\n        from urllib3.response import BaseHTTPResponse\n\n        log_msgs = []\n        old_log = js.console.warn\n\n        def capture_log(*args):  # type: ignore[no-untyped-def]\n            log_msgs.append(str(args))\n            old_log(*args)\n\n        js.console.warn = capture_log\n        conn = HTTPSConnection(host, port)\n        conn.request(\"GET\", f\"https://{host}:{port}/\", preload_content=True)\n        response = conn.getresponse()\n        js.console.warn = old_log\n        assert isinstance(response, BaseHTTPResponse)\n        data = response.data\n        assert data.decode(\"utf-8\") == \"Dummy server!\"\n        # no console warnings because we didn't ask it to stream the response\n        # check no log messages\n        assert (\n            len([x for x in log_msgs if x.find(\"Can't stream HTTP requests\") != -1])\n            == 0\n        )\n        assert not urllib3.contrib.emscripten.fetch._SHOWN_STREAMING_WARNING\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_streaming_fallback_warning(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import js\n\n        import urllib3.contrib.emscripten.fetch\n        from urllib3.connection import HTTPSConnection\n        from urllib3.response import BaseHTTPResponse\n\n        # monkeypatch is_cross_origin_isolated so that it warns about that\n        # even if we're serving it so it is fine\n        urllib3.contrib.emscripten.fetch.is_cross_origin_isolated = lambda: False\n\n        log_msgs = []\n        old_log = js.console.warn\n\n        def capture_log(*args):  # type: ignore[no-untyped-def]\n            log_msgs.append(str(args))\n            old_log(*args)\n\n        js.console.warn = capture_log\n\n        conn = HTTPSConnection(host, port)\n        conn.request(\"GET\", f\"https://{host}:{port}/\", preload_content=False)\n        response = conn.getresponse()\n        js.console.warn = old_log\n        assert isinstance(response, BaseHTTPResponse)\n        data = response.data\n        assert data.decode(\"utf-8\") == \"Dummy server!\"\n        # check that it has warned about falling back to non-streaming fetch exactly once\n        assert (\n            len([x for x in log_msgs if x.find(\"Can't stream HTTP requests\") != -1])\n            == 1\n        )\n        assert urllib3.contrib.emscripten.fetch._SHOWN_STREAMING_WARNING\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_specific_method(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3 import HTTPSConnectionPool\n\n        with HTTPSConnectionPool(host, port) as pool:\n            path = \"/specific_method?method=POST\"\n            response = pool.request(\"POST\", path)\n            assert response.status == 200\n\n            response = pool.request(\"PUT\", path)\n            assert response.status == 400\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.https_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_streaming_download(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    # test streaming download, which must be in a webworker\n    # as you can't do it on main thread\n\n    # this should return the 17mb big file, and\n    # should not log any warning about falling back\n    bigfile_url = (\n        f\"http://{testserver_http.http_host}:{testserver_http.http_port}/bigfile\"\n    )\n    worker_code = f\"\"\"\n            import pyodide_js as pjs\n            await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n\n            import urllib3.contrib.emscripten.fetch\n            await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n            from urllib3.response import BaseHTTPResponse\n            from urllib3.connection import HTTPConnection\n\n            conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port})\n            conn.request(\"GET\", \"{bigfile_url}\",preload_content=False)\n            response = conn.getresponse()\n            assert isinstance(response, BaseHTTPResponse)\n            assert urllib3.contrib.emscripten.fetch._SHOWN_STREAMING_WARNING==False\n            data=response.data.decode('utf-8')\n            assert len(data) == 17825792\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_streaming_close(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    # test streaming download, which must be in a webworker\n    # as you can't do it on main thread\n\n    # this should return the 17mb big file, and\n    # should not log any warning about falling back\n    url = f\"http://{testserver_http.http_host}:{testserver_http.http_port}/\"\n    worker_code = f\"\"\"\n            import pyodide_js as pjs\n            await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n\n            import urllib3.contrib.emscripten.fetch\n            await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n            from urllib3.response import BaseHTTPResponse\n            from urllib3.connection import HTTPConnection\n            from io import RawIOBase\n\n            conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port})\n            conn.request(\"GET\", \"{url}\",preload_content=False)\n            response = conn.getresponse()\n            # check body is a RawIOBase stream and isn't seekable, writeable\n            body_internal = response._response.body\n            assert(isinstance(body_internal,RawIOBase))\n            assert(body_internal.writable() is False)\n            assert(body_internal.seekable() is False)\n            assert(body_internal.readable() is True)\n            response.drain_conn()\n            x=response.read()\n            assert(not x)\n            response.close()\n            conn.close()\n            # try and make destructor be covered\n            # by killing everything\n            del response\n            del body_internal\n            del conn\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_streaming_bad_url(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    # this should cause an error\n    # because the protocol is bad\n    bad_url = f\"hsffsdfttp://{testserver_http.http_host}:{testserver_http.http_port}/\"\n    # this must be in a webworker\n    # as you can't do it on main thread\n    worker_code = f\"\"\"\n            import pytest\n            import pyodide_js as pjs\n            await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n            import http.client\n            import urllib3.contrib.emscripten.fetch\n            await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n            from urllib3.response import BaseHTTPResponse\n            from urllib3.connection import HTTPConnection\n\n            conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port})\n            with pytest.raises(http.client.HTTPException):\n                conn.request(\"GET\", \"{bad_url}\",preload_content=False)\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_streaming_bad_method(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    # this should cause an error\n    # because the protocol is bad\n    bad_url = f\"http://{testserver_http.http_host}:{testserver_http.http_port}/\"\n    # this must be in a webworker\n    # as you can't do it on main thread\n    worker_code = f\"\"\"\n            import pytest\n            import http.client\n            import pyodide_js as pjs\n            await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n\n            import urllib3.contrib.emscripten.fetch\n            await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n            from urllib3.response import BaseHTTPResponse\n            from urllib3.connection import HTTPConnection\n\n            conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port})\n            with pytest.raises(http.client.HTTPException):\n                # TRACE method should throw SecurityError in Javascript\n                conn.request(\"TRACE\", \"{bad_url}\",preload_content=False)\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_streaming_notready_warning(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    # test streaming download but don't wait for\n    # worker to be ready - should fallback to non-streaming\n    # and log a warning\n    file_url = f\"http://{testserver_http.http_host}:{testserver_http.http_port}/\"\n    worker_code = f\"\"\"\n        import pyodide_js as pjs\n        await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n        import js\n        import urllib3\n        from urllib3.response import BaseHTTPResponse\n        from urllib3.connection import HTTPConnection\n\n        log_msgs=[]\n        old_log=js.console.warn\n        def capture_log(*args):\n            log_msgs.append(str(args))\n            old_log(*args)\n        js.console.warn=capture_log\n\n        conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port})\n        conn.request(\"GET\", \"{file_url}\",preload_content=False)\n        js.console.warn=old_log\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        data=response.data.decode('utf-8')\n        assert len([x for x in log_msgs if x.find(\"Can't stream HTTP requests\")!=-1])==1\n        assert urllib3.contrib.emscripten.fetch._SHOWN_STREAMING_WARNING==True\n        \"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_post_receive_json(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import json\n\n        from urllib3.connection import HTTPConnection\n        from urllib3.response import BaseHTTPResponse\n\n        json_data = {\n            \"Bears\": \"like\",\n            \"to\": {\"eat\": \"buns\", \"with\": [\"marmalade\", \"and custard\"]},\n        }\n        conn = HTTPConnection(host, port)\n        conn.request(\n            \"POST\",\n            f\"http://{host}:{port}/echo_json\",\n            body=json.dumps(json_data).encode(\"utf-8\"),\n            headers={\"Content-type\": \"application/json\"},\n        )\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        data = response.json()\n        assert data == json_data\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_upload(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3 import HTTPConnectionPool\n\n        data = \"I'm in ur multipart form-data, hazing a cheezburgr\"\n        fields: dict[str, _TYPE_FIELD_VALUE_TUPLE] = {\n            \"upload_param\": \"filefield\",\n            \"upload_filename\": \"lolcat.txt\",\n            \"filefield\": (\"lolcat.txt\", data),\n        }\n        fields[\"upload_size\"] = str(len(data))\n        with HTTPConnectionPool(host, port) as pool:\n            r = pool.request(\"POST\", \"/upload\", fields=fields)\n            assert r.status == 200\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_streaming_not_ready_in_browser(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    # streaming ready should always be false\n    # if we're in the main browser thread\n    selenium_coverage.run_async(\n        \"\"\"\n        import urllib3.contrib.emscripten.fetch\n        result=await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n        assert(result is False)\n        assert(urllib3.contrib.emscripten.fetch.streaming_ready() is None )\n        \"\"\"\n    )\n\n\n@install_urllib3_wheel()\ndef test_requests_with_micropip(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    # this can't be @run_in_pyodide because of the async code\n    selenium_coverage.run_async(\n        f\"\"\"\n        import micropip\n        await micropip.install(\"requests\")\n        import requests\n        import json\n        r = requests.get(\"http://{testserver_http.http_host}:{testserver_http.http_port}/\")\n        assert(r.status_code == 200)\n        assert(r.text == \"Dummy server!\")\n        json_data={{\"woo\":\"yay\"}}\n        # try posting some json with requests\n        r = requests.post(\"http://{testserver_http.http_host}:{testserver_http.http_port}/echo_json\",json=json_data)\n        import js\n        assert(r.json() == json_data)\n    \"\"\"\n    )\n\n\n@install_urllib3_wheel()\ndef test_open_close(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from http.client import ResponseNotReady\n\n        import pytest\n\n        from urllib3.connection import HTTPConnection\n\n        conn = HTTPConnection(host, port)\n        # initially connection should be closed\n        assert conn.is_closed is True\n        # connection should have no response\n        with pytest.raises(ResponseNotReady):\n            response = conn.getresponse()\n        # now make the response\n        conn.request(\"GET\", f\"http://{host}:{port}/\")\n        # we never connect to proxy (or if we do, browser handles it)\n        assert conn.has_connected_to_proxy is False\n        # now connection should be open\n        assert conn.is_closed is False\n        # and should have a response\n        response = conn.getresponse()\n        assert response is not None\n        conn.close()\n        # now it is closed\n        assert conn.is_closed is True\n        # closed connection shouldn't have any response\n        with pytest.raises(ResponseNotReady):\n            conn.getresponse()\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n# check that various ways that the worker may be broken\n# throw exceptions nicely, by deliberately breaking things\n# this is for coverage\n@install_urllib3_wheel()\ndef test_break_worker_streaming(\n    selenium_coverage: typing.Any,\n    testserver_http: PyodideServerInfo,\n    run_from_server: ServerRunnerInfo,\n) -> None:\n    worker_code = f\"\"\"\n        import pyodide_js as pjs\n        await pjs.loadPackage('http://{testserver_http.http_host}:{testserver_http.http_port}/wheel/dist.whl',deps=False)\n        import pytest\n        import urllib3.contrib.emscripten.fetch\n        import js\n        import http.client\n\n        await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()\n        from urllib3.exceptions import TimeoutError\n        from urllib3.connection import HTTPConnection\n        conn = HTTPConnection(\"{testserver_http.http_host}\", {testserver_http.http_port},timeout=1.0)\n        # make the fetch worker return a bad response by:\n        # 1) Clearing the int buffer\n        #    in the receive stream\n        with pytest.raises(http.client.HTTPException):\n            conn.request(\"GET\",\"/\",preload_content=False)\n            response = conn.getresponse()\n            body_internal = response._response.body\n            assert(body_internal.int_buffer!=None)\n            body_internal.int_buffer=None\n            data=response.read()\n        # 2) Monkeypatch postMessage so that it just sets an\n        #    exception status\n        old_pm= body_internal.worker.postMessage\n        with pytest.raises(http.client.HTTPException):\n            conn.request(\"GET\",\"/\",preload_content=False)\n            response = conn.getresponse()\n            # make posted messages set an exception\n            body_internal = response._response.body\n            def set_exception(*args):\n                body_internal.worker.postMessage = old_pm\n                body_internal.int_buffer[1]=4\n                body_internal.byte_buffer[0]=ord(\"W\")\n                body_internal.byte_buffer[1]=ord(\"O\")\n                body_internal.byte_buffer[2]=ord(\"O\")\n                body_internal.byte_buffer[3]=ord(\"!\")\n                body_internal.byte_buffer[4]=0\n                js.Atomics.store(body_internal.int_buffer, 0, -4)\n                js.Atomics.notify(body_internal.int_buffer,0)\n            body_internal.worker.postMessage = set_exception\n            data=response.read()\n        # monkeypatch so it returns an unknown value for the magic number on initial fetch call\n        with pytest.raises(http.client.HTTPException):\n            # make posted messages set an exception\n            worker=urllib3.contrib.emscripten.fetch._fetcher.js_worker\n            def set_exception(self,*args):\n                array=js.Int32Array.new(args[0].buffer)\n                array[0]=-1234\n            worker.postMessage=set_exception.__get__(worker,worker.__class__)\n            conn.request(\"GET\",\"/\",preload_content=False)\n            response = conn.getresponse()\n            data=response.read()\n        urllib3.contrib.emscripten.fetch._fetcher.js_worker.postMessage=old_pm\n        # 3) Stopping the worker receiving any messages which should cause a timeout error\n        #    in the receive stream\n        with pytest.raises(TimeoutError):\n            conn.request(\"GET\",\"/\",preload_content=False)\n            response = conn.getresponse()\n            # make posted messages not be send\n            body_internal = response._response.body\n            def ignore_message(*args):\n                pass\n            old_pm= body_internal.worker.postMessage\n            body_internal.worker.postMessage = ignore_message\n            data=response.read()\n        body_internal.worker.postMessage = old_pm\n\n\"\"\"\n    run_from_server.run_webworker(worker_code)\n\n\n@install_urllib3_wheel()\ndef test_response_init_length(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import pytest\n\n        import urllib3.exceptions\n        from urllib3.connection import HTTPConnection\n        from urllib3.response import BaseHTTPResponse\n\n        conn = HTTPConnection(host, port)\n        conn.request(\"GET\", f\"http://{host}:{port}/\")\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        # head shouldn't have length\n        length = response._init_length(\"HEAD\")\n        assert length == 0\n        # multiple inconsistent lengths - should raise invalid header\n        with pytest.raises(urllib3.exceptions.InvalidHeader):\n            response.headers[\"Content-Length\"] = \"4,5,6\"\n            length = response._init_length(\"GET\")\n        # non-numeric length - should return None\n        response.headers[\"Content-Length\"] = \"anna\"\n        length = response._init_length(\"GET\")\n        assert length is None\n        # numeric length - should return it\n        response.headers[\"Content-Length\"] = \"54\"\n        length = response._init_length(\"GET\")\n        assert length == 54\n        # negative length - should return None\n        response.headers[\"Content-Length\"] = \"-12\"\n        length = response._init_length(\"GET\")\n        assert length is None\n        # none -> None\n        del response.headers[\"Content-Length\"]\n        length = response._init_length(\"GET\")\n        assert length is None\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_response_close_connection(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3.connection import HTTPConnection\n        from urllib3.response import BaseHTTPResponse\n\n        conn = HTTPConnection(host, port)\n        conn.request(\"GET\", f\"http://{host}:{port}/\")\n        response = conn.getresponse()\n        assert isinstance(response, BaseHTTPResponse)\n        response.close()\n        assert conn.is_closed\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_read_chunked(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        from urllib3.connection import HTTPConnection\n\n        conn = HTTPConnection(host, port)\n        conn.request(\"GET\", f\"http://{host}:{port}/mediumfile\", preload_content=False)\n        response = conn.getresponse()\n        count = 0\n        for x in response.read_chunked(512):\n            count += 1\n            if count < 10:\n                assert len(x) == 512\n\n    pyodide_test(\n        selenium_coverage, testserver_http.http_host, testserver_http.http_port\n    )\n\n\n@install_urllib3_wheel()\ndef test_retries(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int) -> None:  # type: ignore[no-untyped-def]\n        import pytest\n\n        import urllib3\n\n        pool = urllib3.HTTPConnectionPool(\n            host,\n            port,\n            maxsize=1,\n            block=True,\n            retries=urllib3.util.Retry(connect=5, read=5, redirect=5),\n        )\n\n        # monkeypatch connection class to count calls\n        old_request = urllib3.connection.HTTPConnection.request\n        count = 0\n\n        def count_calls(self, *args, **argv):  # type: ignore[no-untyped-def]\n            nonlocal count\n            count += 1\n            return old_request(self, *args, **argv)\n\n        urllib3.connection.HTTPConnection.request = count_calls  # type: ignore[method-assign]\n        with pytest.raises(urllib3.exceptions.MaxRetryError):\n            pool.urlopen(\"GET\", \"/\")\n        # this should fail, but should have tried 6 times total\n        assert count == 6\n\n    pyodide_test(selenium_coverage, testserver_http.http_host, find_unused_port())\n\n\n@install_urllib3_wheel()\ndef test_insecure_requests_warning(\n    selenium_coverage: typing.Any, testserver_http: PyodideServerInfo\n) -> None:\n    @run_in_pyodide  # type: ignore[misc]\n    def pyodide_test(selenium_coverage, host: str, port: int, https_port: int) -> None:  # type: ignore[no-untyped-def]\n        import warnings\n\n        import urllib3\n        import urllib3.exceptions\n\n        http = urllib3.PoolManager()\n\n        with warnings.catch_warnings(record=True) as w:\n            http.request(\"GET\", f\"https://{host}:{https_port}\")\n        assert len(w) == 0\n\n    pyodide_test(\n        selenium_coverage,\n        testserver_http.http_host,\n        testserver_http.http_port,\n        testserver_http.https_port,\n    )\n", "test/contrib/emscripten/conftest.py": "from __future__ import annotations\n\nimport contextlib\nimport os\nimport random\nimport textwrap\nimport typing\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, Generator\n\nimport hypercorn\nimport pytest\n\nfrom dummyserver.app import pyodide_testing_app\nfrom dummyserver.hypercornserver import run_hypercorn_in_thread\nfrom dummyserver.socketserver import DEFAULT_CERTS\nfrom urllib3.util.url import parse_url\n\n_coverage_count = 0\n\n\ndef _get_coverage_filename(prefix: str) -> str:\n    global _coverage_count\n    _coverage_count += 1\n    rand_part = \"\".join([random.choice(\"1234567890\") for x in range(20)])\n    return prefix + rand_part + f\".{_coverage_count}\"\n\n\n@pytest.fixture(scope=\"module\")\ndef testserver_http(\n    request: pytest.FixtureRequest,\n) -> Generator[PyodideServerInfo, None, None]:\n    pyodide_dist_dir = Path(os.getcwd(), request.config.getoption(\"--dist-dir\"))\n    pyodide_testing_app.config[\"pyodide_dist_dir\"] = str(pyodide_dist_dir)\n    http_host = \"localhost\"\n    with contextlib.ExitStack() as stack:\n        http_server_config = hypercorn.Config()\n        http_server_config.bind = [f\"{http_host}:0\"]\n        stack.enter_context(\n            run_hypercorn_in_thread(http_server_config, pyodide_testing_app)\n        )\n        http_port = typing.cast(int, parse_url(http_server_config.bind[0]).port)\n\n        https_server_config = hypercorn.Config()\n        https_server_config.certfile = DEFAULT_CERTS[\"certfile\"]\n        https_server_config.keyfile = DEFAULT_CERTS[\"keyfile\"]\n        https_server_config.verify_mode = DEFAULT_CERTS[\"cert_reqs\"]\n        https_server_config.ca_certs = DEFAULT_CERTS[\"ca_certs\"]\n        https_server_config.alpn_protocols = DEFAULT_CERTS[\"alpn_protocols\"]\n        https_server_config.bind = [f\"{http_host}:0\"]\n        stack.enter_context(\n            run_hypercorn_in_thread(https_server_config, pyodide_testing_app)\n        )\n        https_port = typing.cast(int, parse_url(https_server_config.bind[0]).port)\n\n        yield PyodideServerInfo(\n            http_host=http_host,\n            http_port=http_port,\n            https_port=https_port,\n        )\n        print(\"Server teardown\")\n\n\n@pytest.fixture()\ndef selenium_coverage(selenium: Any) -> Generator[Any, None, None]:\n    def _install_coverage(self: Any) -> None:\n        self.run_js(\n            \"\"\"\n            await pyodide.loadPackage(\"coverage\")\n            await pyodide.runPythonAsync(`import coverage\n_coverage= coverage.Coverage(source_pkgs=['urllib3'])\n_coverage.start()\n        `\n        )\"\"\"\n        )\n\n    setattr(\n        selenium,\n        \"_install_coverage\",\n        _install_coverage.__get__(selenium, selenium.__class__),\n    )\n    selenium._install_coverage()\n    yield selenium\n    # on teardown, save _coverage output\n    coverage_out_binary = bytes(\n        selenium.run_js(\n            \"\"\"\nreturn await pyodide.runPythonAsync(`\n_coverage.stop()\n_coverage.save()\n_coverage_datafile = open(\".coverage\",\"rb\")\n_coverage_outdata = _coverage_datafile.read()\n# avoid polluting main namespace too much\nimport js as _coverage_js\n# convert to js Array (as default conversion is TypedArray which does\n# bad things in firefox)\n_coverage_js.Array.from_(_coverage_outdata)\n`)\n    \"\"\"\n        )\n    )\n    with open(f\"{_get_coverage_filename('.coverage.emscripten.')}\", \"wb\") as outfile:\n        outfile.write(coverage_out_binary)\n\n\nclass ServerRunnerInfo:\n    def __init__(self, host: str, port: int, selenium: Any) -> None:\n        self.host = host\n        self.port = port\n        self.selenium = selenium\n\n    def run_webworker(self, code: str) -> Any:\n        if isinstance(code, str) and code.startswith(\"\\n\"):\n            # we have a multiline string, fix indentation\n            code = textwrap.dedent(code)\n            # add coverage collection to this code\n            code = (\n                textwrap.dedent(\n                    \"\"\"\n            import coverage\n            _coverage= coverage.Coverage(source_pkgs=['urllib3'])\n            _coverage.start()\n            \"\"\"\n                )\n                + code\n            )\n            code += textwrap.dedent(\n                \"\"\"\n            _coverage.stop()\n            _coverage.save()\n            _coverage_datafile = open(\".coverage\",\"rb\")\n            _coverage_outdata = _coverage_datafile.read()\n            # avoid polluting main namespace too much\n            import js as _coverage_js\n            # convert to js Array (as default conversion is TypedArray which does\n            # bad things in firefox)\n            _coverage_js.Array.from_(_coverage_outdata)\n            \"\"\"\n            )\n\n        coverage_out_binary = bytes(\n            self.selenium.run_js(\n                f\"\"\"\n            let worker = new Worker('https://{self.host}:{self.port}/pyodide/webworker_dev.js');\n            let p = new Promise((res, rej) => {{\n                worker.onmessageerror = e => rej(e);\n                worker.onerror = e => rej(e);\n                worker.onmessage = e => {{\n                    if (e.data.results) {{\n                       res(e.data.results);\n                    }} else {{\n                       rej(e.data.error);\n                    }}\n                }};\n                worker.postMessage({{ python: {repr(code)} }});\n            }});\n            return await p;\n            \"\"\",\n                pyodide_checks=False,\n            )\n        )\n        with open(\n            f\"{_get_coverage_filename('.coverage.emscripten.worker.')}\", \"wb\"\n        ) as outfile:\n            outfile.write(coverage_out_binary)\n\n\n# run pyodide on our test server instead of on the default\n# pytest-pyodide one - this makes it so that\n# we are at the same origin as web requests to server_host\n@pytest.fixture()\ndef run_from_server(\n    selenium_coverage: Any, testserver_http: PyodideServerInfo\n) -> Generator[ServerRunnerInfo, None, None]:\n    addr = f\"https://{testserver_http.http_host}:{testserver_http.https_port}/pyodide/test.html\"\n    selenium_coverage.goto(addr)\n    selenium_coverage.javascript_setup()\n    selenium_coverage.load_pyodide()\n    selenium_coverage.initialize_pyodide()\n    selenium_coverage.save_state()\n    selenium_coverage.restore_state()\n    # install the wheel, which is served at /wheel/*\n    selenium_coverage.run_js(\n        \"\"\"\nawait pyodide.loadPackage('/wheel/dist.whl')\n\"\"\"\n    )\n    selenium_coverage._install_coverage()\n    yield ServerRunnerInfo(\n        testserver_http.http_host, testserver_http.https_port, selenium_coverage\n    )\n\n\n@dataclass\nclass PyodideServerInfo:\n    http_port: int\n    https_port: int\n    http_host: str\n", "test/contrib/emscripten/__init__.py": "", "test/with_dummyserver/test_socketlevel.py": "# TODO: Break this module up into pieces. Maybe group by functionality tested\n# rather than the socket level-ness of it.\nfrom __future__ import annotations\n\nimport contextlib\nimport errno\nimport io\nimport os\nimport os.path\nimport select\nimport shutil\nimport socket\nimport ssl\nimport tempfile\nimport threading\nimport typing\nimport zlib\nfrom collections import OrderedDict\nfrom pathlib import Path\nfrom test import LONG_TIMEOUT, SHORT_TIMEOUT, notWindows, resolvesLocalhostFQDN\nfrom threading import Event\nfrom unittest import mock\n\nimport pytest\nimport trustme\n\nfrom dummyserver.socketserver import (\n    DEFAULT_CA,\n    DEFAULT_CERTS,\n    encrypt_key_pem,\n    get_unreachable_address,\n)\nfrom dummyserver.testcase import SocketDummyServerTestCase, consume_socket\nfrom urllib3 import HTTPConnectionPool, HTTPSConnectionPool, ProxyManager, util\nfrom urllib3._collections import HTTPHeaderDict\nfrom urllib3.connection import HTTPConnection, _get_default_user_agent\nfrom urllib3.connectionpool import _url_from_pool\nfrom urllib3.exceptions import (\n    InsecureRequestWarning,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n)\nfrom urllib3.poolmanager import proxy_from_url\nfrom urllib3.util import ssl_, ssl_wrap_socket\nfrom urllib3.util.retry import Retry\nfrom urllib3.util.timeout import Timeout\n\nfrom .. import LogRecorder, has_alpn\n\nif typing.TYPE_CHECKING:\n    from _typeshed import StrOrBytesPath\nelse:\n    StrOrBytesPath = object\n\n\nclass TestCookies(SocketDummyServerTestCase):\n    def test_multi_setcookie(self) -> None:\n        def multicookie_response_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Set-Cookie: foo=1\\r\\n\"\n                b\"Set-Cookie: bar=1\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(multicookie_response_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/\", retries=0)\n            assert r.headers == {\"set-cookie\": \"foo=1, bar=1\"}\n            assert r.headers.getlist(\"set-cookie\") == [\"foo=1\", \"bar=1\"]\n\n\nclass TestSNI(SocketDummyServerTestCase):\n    def test_hostname_in_first_request_packet(self) -> None:\n        done_receiving = Event()\n        self.buf = b\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            self.buf = sock.recv(65536)  # We only accept one packet\n            done_receiving.set()  # let the test know it can proceed\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(self.host, self.port) as pool:\n            try:\n                pool.request(\"GET\", \"/\", retries=0)\n            except MaxRetryError:  # We are violating the protocol\n                pass\n            successful = done_receiving.wait(LONG_TIMEOUT)\n            assert successful, \"Timed out waiting for connection accept\"\n            assert (\n                self.host.encode(\"ascii\") in self.buf\n            ), \"missing hostname in SSL handshake\"\n\n\nclass TestALPN(SocketDummyServerTestCase):\n    def test_alpn_protocol_in_first_request_packet(self) -> None:\n        if not has_alpn():\n            pytest.skip(\"ALPN-support not available\")\n\n        done_receiving = Event()\n        self.buf = b\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            self.buf = sock.recv(65536)  # We only accept one packet\n            done_receiving.set()  # let the test know it can proceed\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(self.host, self.port) as pool:\n            try:\n                pool.request(\"GET\", \"/\", retries=0)\n            except MaxRetryError:  # We are violating the protocol\n                pass\n            successful = done_receiving.wait(LONG_TIMEOUT)\n            assert successful, \"Timed out waiting for connection accept\"\n            for protocol in util.ALPN_PROTOCOLS:\n                assert (\n                    protocol.encode(\"ascii\") in self.buf\n                ), \"missing ALPN protocol in SSL handshake\"\n\n\ndef original_ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: StrOrBytesPath | None = None,\n    certfile: StrOrBytesPath | None = None,\n    server_side: bool = False,\n    cert_reqs: ssl.VerifyMode = ssl.CERT_NONE,\n    ssl_version: int = ssl.PROTOCOL_TLS,\n    ca_certs: str | None = None,\n    do_handshake_on_connect: bool = True,\n    suppress_ragged_eofs: bool = True,\n    ciphers: str | None = None,\n) -> ssl.SSLSocket:\n    if server_side and not certfile:\n        raise ValueError(\"certfile must be specified for server-side operations\")\n    if keyfile and not certfile:\n        raise ValueError(\"certfile must be specified\")\n    context = ssl.SSLContext(ssl_version)\n    context.verify_mode = cert_reqs\n    if ca_certs:\n        context.load_verify_locations(ca_certs)\n    if certfile:\n        context.load_cert_chain(certfile, keyfile)\n    if ciphers:\n        context.set_ciphers(ciphers)\n    return context.wrap_socket(\n        sock=sock,\n        server_side=server_side,\n        do_handshake_on_connect=do_handshake_on_connect,\n        suppress_ragged_eofs=suppress_ragged_eofs,\n    )\n\n\nclass TestClientCerts(SocketDummyServerTestCase):\n    \"\"\"\n    Tests for client certificate support.\n    \"\"\"\n\n    @classmethod\n    def setup_class(cls) -> None:\n        cls.tmpdir = tempfile.mkdtemp()\n        ca = trustme.CA()\n        cert = ca.issue_cert(\"localhost\")\n        encrypted_key = encrypt_key_pem(cert.private_key_pem, b\"letmein\")\n\n        cls.ca_path = os.path.join(cls.tmpdir, \"ca.pem\")\n        cls.cert_combined_path = os.path.join(cls.tmpdir, \"server.combined.pem\")\n        cls.cert_path = os.path.join(cls.tmpdir, \"server.pem\")\n        cls.key_path = os.path.join(cls.tmpdir, \"key.pem\")\n        cls.password_key_path = os.path.join(cls.tmpdir, \"password_key.pem\")\n\n        ca.cert_pem.write_to_path(cls.ca_path)\n        cert.private_key_and_cert_chain_pem.write_to_path(cls.cert_combined_path)\n        cert.cert_chain_pems[0].write_to_path(cls.cert_path)\n        cert.private_key_pem.write_to_path(cls.key_path)\n        encrypted_key.write_to_path(cls.password_key_path)\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        shutil.rmtree(cls.tmpdir)\n\n    def _wrap_in_ssl(self, sock: socket.socket) -> ssl.SSLSocket:\n        \"\"\"\n        Given a single socket, wraps it in TLS.\n        \"\"\"\n        return original_ssl_wrap_socket(\n            sock,\n            ssl_version=ssl.PROTOCOL_SSLv23,\n            cert_reqs=ssl.CERT_REQUIRED,\n            ca_certs=self.ca_path,\n            certfile=self.cert_path,\n            keyfile=self.key_path,\n            server_side=True,\n        )\n\n    def test_client_certs_two_files(self) -> None:\n        \"\"\"\n        Having a client cert in a separate file to its associated key works\n        properly.\n        \"\"\"\n        done_receiving = Event()\n        client_certs = []\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            sock = self._wrap_in_ssl(sock)\n\n            client_certs.append(sock.getpeercert())\n\n            data = b\"\"\n            while not data.endswith(b\"\\r\\n\\r\\n\"):\n                data += sock.recv(8192)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: testsocket\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"Content-Length: 6\\r\\n\"\n                b\"\\r\\n\"\n                b\"Valid!\"\n            )\n\n            done_receiving.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_file=self.cert_path,\n            key_file=self.key_path,\n            cert_reqs=\"REQUIRED\",\n            ca_certs=self.ca_path,\n        ) as pool:\n            pool.request(\"GET\", \"/\", retries=0)\n            done_receiving.set()\n\n            assert len(client_certs) == 1\n\n    def test_client_certs_one_file(self) -> None:\n        \"\"\"\n        Having a client cert and its associated private key in just one file\n        works properly.\n        \"\"\"\n        done_receiving = Event()\n        client_certs = []\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            sock = self._wrap_in_ssl(sock)\n\n            client_certs.append(sock.getpeercert())\n\n            data = b\"\"\n            while not data.endswith(b\"\\r\\n\\r\\n\"):\n                data += sock.recv(8192)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: testsocket\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"Content-Length: 6\\r\\n\"\n                b\"\\r\\n\"\n                b\"Valid!\"\n            )\n\n            done_receiving.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_file=self.cert_combined_path,\n            cert_reqs=\"REQUIRED\",\n            ca_certs=self.ca_path,\n        ) as pool:\n            pool.request(\"GET\", \"/\", retries=0)\n            done_receiving.set()\n\n            assert len(client_certs) == 1\n\n    def test_missing_client_certs_raises_error(self) -> None:\n        \"\"\"\n        Having client certs not be present causes an error.\n        \"\"\"\n        done_receiving = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            try:\n                self._wrap_in_ssl(sock)\n            except ssl.SSLError:\n                pass\n\n            done_receiving.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(\n            self.host, self.port, cert_reqs=\"REQUIRED\", ca_certs=self.ca_path\n        ) as pool:\n            with pytest.raises(MaxRetryError):\n                pool.request(\"GET\", \"/\", retries=0)\n                done_receiving.set()\n            done_receiving.set()\n\n    def test_client_cert_with_string_password(self) -> None:\n        self.run_client_cert_with_password_test(\"letmein\")\n\n    def test_client_cert_with_bytes_password(self) -> None:\n        self.run_client_cert_with_password_test(b\"letmein\")\n\n    def run_client_cert_with_password_test(self, password: bytes | str) -> None:\n        \"\"\"\n        Tests client certificate password functionality\n        \"\"\"\n        done_receiving = Event()\n        client_certs = []\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            sock = self._wrap_in_ssl(sock)\n\n            client_certs.append(sock.getpeercert())\n\n            data = b\"\"\n            while not data.endswith(b\"\\r\\n\\r\\n\"):\n                data += sock.recv(8192)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: testsocket\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"Content-Length: 6\\r\\n\"\n                b\"\\r\\n\"\n                b\"Valid!\"\n            )\n\n            done_receiving.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        assert ssl_.SSLContext is not None\n        ssl_context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)\n        ssl_context.load_cert_chain(\n            certfile=self.cert_path, keyfile=self.password_key_path, password=password\n        )\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ssl_context=ssl_context,\n            cert_reqs=\"REQUIRED\",\n            ca_certs=self.ca_path,\n        ) as pool:\n            pool.request(\"GET\", \"/\", retries=0)\n            done_receiving.set()\n\n            assert len(client_certs) == 1\n\n    def test_load_keyfile_with_invalid_password(self) -> None:\n        assert ssl_.SSLContext is not None\n        context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)\n        with pytest.raises(ssl.SSLError):\n            context.load_cert_chain(\n                certfile=self.cert_path,\n                keyfile=self.password_key_path,\n                password=b\"letmei\",\n            )\n\n    def test_load_invalid_cert_file(self) -> None:\n        assert ssl_.SSLContext is not None\n        context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)\n        with pytest.raises(ssl.SSLError):\n            context.load_cert_chain(certfile=self.password_key_path)\n\n\nclass TestSocketClosing(SocketDummyServerTestCase):\n    def test_recovery_when_server_closes_connection(self) -> None:\n        # Does the pool work seamlessly if an open connection in the\n        # connection pool gets hung up on by the server, then reaches\n        # the front of the queue again?\n\n        done_closing = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            for i in 0, 1:\n                sock = listener.accept()[0]\n\n                buf = b\"\"\n                while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                    buf = sock.recv(65536)\n\n                body = f\"Response {int(i)}\"\n                sock.send(\n                    (\n                        \"HTTP/1.1 200 OK\\r\\n\"\n                        \"Content-Type: text/plain\\r\\n\"\n                        \"Content-Length: %d\\r\\n\"\n                        \"\\r\\n\"\n                        \"%s\" % (len(body), body)\n                    ).encode(\"utf-8\")\n                )\n\n                sock.close()  # simulate a server timing out, closing socket\n                done_closing.set()  # let the test know it can proceed\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/\", retries=0)\n            assert response.status == 200\n            assert response.data == b\"Response 0\"\n\n            done_closing.wait()  # wait until the socket in our pool gets closed\n\n            response = pool.request(\"GET\", \"/\", retries=0)\n            assert response.status == 200\n            assert response.data == b\"Response 1\"\n\n    def test_connection_refused(self) -> None:\n        # Does the pool retry if there is no listener on the port?\n        host, port = get_unreachable_address()\n        with HTTPConnectionPool(host, port, maxsize=3, block=True) as http:\n            with pytest.raises(MaxRetryError):\n                http.request(\"GET\", \"/\", retries=0, release_conn=False)\n            assert http.pool is not None\n            assert http.pool.qsize() == http.pool.maxsize\n\n    def test_connection_read_timeout(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            while not sock.recv(65536).endswith(b\"\\r\\n\\r\\n\"):\n                pass\n\n            timed_out.wait()\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(\n            self.host,\n            self.port,\n            timeout=SHORT_TIMEOUT,\n            retries=False,\n            maxsize=3,\n            block=True,\n        ) as http:\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    http.request(\"GET\", \"/\", release_conn=False)\n            finally:\n                timed_out.set()\n\n            assert http.pool is not None\n            assert http.pool.qsize() == http.pool.maxsize\n\n    def test_read_timeout_dont_retry_method_not_in_allowlist(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            sock.recv(65536)\n            timed_out.wait()\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=LONG_TIMEOUT, retries=True\n        ) as pool:\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    pool.request(\"POST\", \"/\")\n            finally:\n                timed_out.set()\n\n    def test_https_connection_read_timeout(self) -> None:\n        \"\"\"Handshake timeouts should fail with a Timeout\"\"\"\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            while not sock.recv(65536):\n                pass\n\n            timed_out.wait()\n            sock.close()\n\n        # first ReadTimeoutError due to SocketTimeout\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(\n            self.host, self.port, timeout=LONG_TIMEOUT, retries=False\n        ) as pool:\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    pool.request(\"GET\", \"/\")\n            finally:\n                timed_out.set()\n\n        # second ReadTimeoutError due to errno\n        with HTTPSConnectionPool(host=self.host):\n            err = OSError()\n            err.errno = errno.EAGAIN\n            with pytest.raises(ReadTimeoutError):\n                pool._raise_timeout(err, \"\", 0)\n\n    def test_timeout_errors_cause_retries(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            sock_timeout = listener.accept()[0]\n\n            # Wait for a second request before closing the first socket.\n            sock = listener.accept()[0]\n            sock_timeout.close()\n\n            # Second request.\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            # Now respond immediately.\n            body = \"Response 2\"\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(body), body)\n                ).encode(\"utf-8\")\n            )\n\n            sock.close()\n\n        # In situations where the main thread throws an exception, the server\n        # thread can hang on an accept() call. This ensures everything times\n        # out within 1 second. This should be long enough for any socket\n        # operations in the test suite to complete\n        default_timeout = socket.getdefaulttimeout()\n        socket.setdefaulttimeout(1)\n\n        try:\n            self._start_server(socket_handler)\n            t = Timeout(connect=LONG_TIMEOUT, read=LONG_TIMEOUT)\n            with HTTPConnectionPool(self.host, self.port, timeout=t) as pool:\n                response = pool.request(\"GET\", \"/\", retries=1)\n                assert response.status == 200\n                assert response.data == b\"Response 2\"\n        finally:\n            socket.setdefaulttimeout(default_timeout)\n\n    def test_delayed_body_read_timeout(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            buf = b\"\"\n            body = \"Hi\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65536)\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\" % len(body)\n                ).encode(\"utf-8\")\n            )\n\n            timed_out.wait()\n            sock.send(body.encode(\"utf-8\"))\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.urlopen(\n                \"GET\",\n                \"/\",\n                retries=0,\n                preload_content=False,\n                timeout=Timeout(connect=1, read=LONG_TIMEOUT),\n            )\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    response.read()\n            finally:\n                timed_out.set()\n\n    def test_delayed_body_read_timeout_with_preload(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            buf = b\"\"\n            body = \"Hi\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\" % len(body)\n                ).encode(\"utf-8\")\n            )\n\n            timed_out.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)\n                    pool.urlopen(\"GET\", \"/\", retries=False, timeout=timeout)\n            finally:\n                timed_out.set()\n\n    def test_incomplete_response(self) -> None:\n        body = \"Response\"\n        partial_body = body[:2]\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            # Consume request\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65536)\n\n            # Send partial response and close socket.\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(body), partial_body)\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/\", retries=0, preload_content=False)\n            with pytest.raises(ProtocolError):\n                response.read()\n\n    def test_retry_weird_http_version(self) -> None:\n        \"\"\"Retry class should handle httplib.BadStatusLine errors properly\"\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            # First request.\n            # Pause before responding so the first request times out.\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            # send unknown http protocol\n            body = \"bad http 0.5 response\"\n            sock.send(\n                (\n                    \"HTTP/0.5 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(body), body)\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n\n            # Second request.\n            sock = listener.accept()[0]\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            # Now respond immediately.\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"foo\" % (len(\"foo\"))\n                ).encode(\"utf-8\")\n            )\n\n            sock.close()  # Close the socket.\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            retry = Retry(read=1)\n            response = pool.request(\"GET\", \"/\", retries=retry)\n            assert response.status == 200\n            assert response.data == b\"foo\"\n\n    def test_connection_cleanup_on_read_timeout(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            buf = b\"\"\n            body = \"Hi\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65536)\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\" % len(body)\n                ).encode(\"utf-8\")\n            )\n\n            timed_out.wait()\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            assert pool.pool is not None\n            poolsize = pool.pool.qsize()\n            response = pool.urlopen(\n                \"GET\", \"/\", retries=0, preload_content=False, timeout=LONG_TIMEOUT\n            )\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    response.read()\n                assert poolsize == pool.pool.qsize()\n            finally:\n                timed_out.set()\n\n    def test_connection_cleanup_on_protocol_error_during_read(self) -> None:\n        body = \"Response\"\n        partial_body = body[:2]\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            # Consume request\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65536)\n\n            # Send partial response and close socket.\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(body), partial_body)\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            assert pool.pool is not None\n            poolsize = pool.pool.qsize()\n            response = pool.request(\"GET\", \"/\", retries=0, preload_content=False)\n\n            with pytest.raises(ProtocolError):\n                response.read()\n            assert poolsize == pool.pool.qsize()\n\n    def test_connection_closed_on_read_timeout_preload_false(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            # Consume request\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65535)\n\n            # Send partial chunked response and then hang.\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Transfer-Encoding: chunked\\r\\n\"\n                b\"\\r\\n\"\n                b\"8\\r\\n\"\n                b\"12345678\\r\\n\"\n            )\n            timed_out.wait(5)\n\n            # Expect a new request, but keep hold of the old socket to avoid\n            # leaking it. Because we don't want to hang this thread, we\n            # actually use select.select to confirm that a new request is\n            # coming in: this lets us time the thread out.\n            rlist, _, _ = select.select([listener], [], [], 1)\n            assert rlist\n            new_sock = listener.accept()[0]\n\n            # Consume request\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = new_sock.recv(65535)\n\n            # Send complete chunked response.\n            new_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Transfer-Encoding: chunked\\r\\n\"\n                b\"\\r\\n\"\n                b\"8\\r\\n\"\n                b\"12345678\\r\\n\"\n                b\"0\\r\\n\\r\\n\"\n            )\n\n            new_sock.close()\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # First request should fail.\n            response = pool.urlopen(\n                \"GET\", \"/\", retries=0, preload_content=False, timeout=LONG_TIMEOUT\n            )\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    response.read()\n            finally:\n                timed_out.set()\n\n            # Second should succeed.\n            response = pool.urlopen(\n                \"GET\", \"/\", retries=0, preload_content=False, timeout=LONG_TIMEOUT\n            )\n            assert len(response.read()) == 8\n\n    def test_closing_response_actually_closes_connection(self) -> None:\n        done_closing = Event()\n        complete = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf = sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n\n            # Wait for the socket to close.\n            done_closing.wait(timeout=LONG_TIMEOUT)\n\n            # Look for the empty string to show that the connection got closed.\n            # Don't get stuck in a timeout.\n            sock.settimeout(LONG_TIMEOUT)\n            new_data = sock.recv(65536)\n            assert not new_data\n            sock.close()\n            complete.set()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/\", retries=0, preload_content=False)\n            assert response.status == 200\n            response.close()\n\n            done_closing.set()  # wait until the socket in our pool gets closed\n            successful = complete.wait(timeout=LONG_TIMEOUT)\n            assert successful, \"Timed out waiting for connection close\"\n\n    def test_release_conn_param_is_respected_after_timeout_retry(self) -> None:\n        \"\"\"For successful ```urlopen(release_conn=False)```,\n        the connection isn't released, even after a retry.\n\n        This test allows a retry: one request fails, the next request succeeds.\n\n        This is a regression test for issue #651 [1], where the connection\n        would be released if the initial request failed, even if a retry\n        succeeded.\n\n        [1] <https://github.com/urllib3/urllib3/issues/651>\n        \"\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            consume_socket(sock)\n\n            # Close the connection, without sending any response (not even the\n            # HTTP status line). This will trigger a `Timeout` on the client,\n            # inside `urlopen()`.\n            sock.close()\n\n            # Expect a new request. Because we don't want to hang this thread,\n            # we actually use select.select to confirm that a new request is\n            # coming in: this lets us time the thread out.\n            rlist, _, _ = select.select([listener], [], [], 5)\n            assert rlist\n            sock = listener.accept()[0]\n            consume_socket(sock)\n\n            # Send complete chunked response.\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Transfer-Encoding: chunked\\r\\n\"\n                b\"\\r\\n\"\n                b\"8\\r\\n\"\n                b\"12345678\\r\\n\"\n                b\"0\\r\\n\\r\\n\"\n            )\n\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:\n            # First request should fail, but the timeout and `retries=1` should\n            # save it.\n            response = pool.urlopen(\n                \"GET\",\n                \"/\",\n                retries=1,\n                release_conn=False,\n                preload_content=False,\n                timeout=LONG_TIMEOUT,\n            )\n\n            # The connection should still be on the response object, and none\n            # should be in the pool. We opened two though.\n            assert pool.num_connections == 2\n            assert pool.pool is not None\n            assert pool.pool.qsize() == 0\n            assert response.connection is not None\n\n            # Consume the data. This should put the connection back.\n            response.read()\n            assert pool.pool.qsize() == 1\n            assert response.connection is None\n\n    def test_socket_close_socket_then_file(self) -> None:\n        quit_event = threading.Event()\n\n        def consume_ssl_socket(\n            listener: socket.socket,\n        ) -> None:\n            try:\n                with listener.accept()[0] as sock, original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                ) as ssl_sock:\n                    consume_socket(ssl_sock, quit_event=quit_event)\n            except (ConnectionResetError, ConnectionAbortedError, OSError):\n                pass\n\n        self._start_server(consume_ssl_socket, quit_event=quit_event)\n        with socket.create_connection(\n            (self.host, self.port)\n        ) as sock, contextlib.closing(\n            ssl_wrap_socket(sock, server_hostname=self.host, ca_certs=DEFAULT_CA)\n        ) as ssl_sock, ssl_sock.makefile(\n            \"rb\"\n        ) as f:\n            ssl_sock.close()\n            f.close()\n            with pytest.raises(OSError):\n                ssl_sock.sendall(b\"hello\")\n            assert ssl_sock.fileno() == -1\n\n    def test_socket_close_stays_open_with_makefile_open(self) -> None:\n        quit_event = threading.Event()\n\n        def consume_ssl_socket(listener: socket.socket) -> None:\n            try:\n                with listener.accept()[0] as sock, original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                ) as ssl_sock:\n                    consume_socket(ssl_sock, quit_event=quit_event)\n            except (ConnectionResetError, ConnectionAbortedError, OSError):\n                pass\n\n        self._start_server(consume_ssl_socket, quit_event=quit_event)\n        with socket.create_connection(\n            (self.host, self.port)\n        ) as sock, contextlib.closing(\n            ssl_wrap_socket(sock, server_hostname=self.host, ca_certs=DEFAULT_CA)\n        ) as ssl_sock, ssl_sock.makefile(\n            \"rb\"\n        ):\n            ssl_sock.close()\n            ssl_sock.close()\n            ssl_sock.sendall(b\"hello\")\n            assert ssl_sock.fileno() > 0\n\n\nclass TestProxyManager(SocketDummyServerTestCase):\n    def test_simple(self) -> None:\n        def echo_socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(buf), buf.decode(\"utf-8\"))\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n\n        self._start_server(echo_socket_handler)\n        base_url = f\"http://{self.host}:{self.port}\"\n        with proxy_from_url(base_url) as proxy:\n            r = proxy.request(\"GET\", \"http://google.com/\")\n\n            assert r.status == 200\n            # FIXME: The order of the headers is not predictable right now. We\n            # should fix that someday (maybe when we migrate to\n            # OrderedDict/MultiDict).\n            assert sorted(r.data.split(b\"\\r\\n\")) == sorted(\n                [\n                    b\"GET http://google.com/ HTTP/1.1\",\n                    b\"Host: google.com\",\n                    b\"Accept-Encoding: identity\",\n                    b\"Accept: */*\",\n                    b\"User-Agent: \" + _get_default_user_agent().encode(\"utf-8\"),\n                    b\"\",\n                    b\"\",\n                ]\n            )\n\n    def test_headers(self) -> None:\n        def echo_socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(buf), buf.decode(\"utf-8\"))\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n\n        self._start_server(echo_socket_handler)\n        base_url = f\"http://{self.host}:{self.port}\"\n\n        # Define some proxy headers.\n        proxy_headers = HTTPHeaderDict({\"For The Proxy\": \"YEAH!\"})\n        with proxy_from_url(base_url, proxy_headers=proxy_headers) as proxy:\n            conn = proxy.connection_from_url(\"http://www.google.com/\")\n\n            r = conn.urlopen(\"GET\", \"http://www.google.com/\", assert_same_host=False)\n\n            assert r.status == 200\n            # FIXME: The order of the headers is not predictable right now. We\n            # should fix that someday (maybe when we migrate to\n            # OrderedDict/MultiDict).\n            assert b\"For The Proxy: YEAH!\\r\\n\" in r.data\n\n    def test_retries(self) -> None:\n        close_event = Event()\n\n        def echo_socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            # First request, which should fail\n            sock.close()\n\n            # Second request\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                (\n                    \"HTTP/1.1 200 OK\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Content-Length: %d\\r\\n\"\n                    \"\\r\\n\"\n                    \"%s\" % (len(buf), buf.decode(\"utf-8\"))\n                ).encode(\"utf-8\")\n            )\n            sock.close()\n            close_event.set()\n\n        self._start_server(echo_socket_handler)\n        base_url = f\"http://{self.host}:{self.port}\"\n\n        with proxy_from_url(base_url) as proxy:\n            conn = proxy.connection_from_url(\"http://www.google.com\")\n\n            r = conn.urlopen(\n                \"GET\", \"http://www.google.com\", assert_same_host=False, retries=1\n            )\n            assert r.status == 200\n\n            close_event.wait(timeout=LONG_TIMEOUT)\n            with pytest.raises(ProxyError):\n                conn.urlopen(\n                    \"GET\",\n                    \"http://www.google.com\",\n                    assert_same_host=False,\n                    retries=False,\n                )\n\n    def test_connect_reconn(self) -> None:\n        def proxy_ssl_one(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n            s = buf.decode(\"utf-8\")\n            if not s.startswith(\"CONNECT \"):\n                sock.send(b\"HTTP/1.1 405 Method not allowed\\r\\nAllow: CONNECT\\r\\n\\r\\n\")\n                sock.close()\n                return\n\n            if not s.startswith(f\"CONNECT {self.host}:443\"):\n                sock.send(b\"HTTP/1.1 403 Forbidden\\r\\n\\r\\n\")\n                sock.close()\n                return\n\n            sock.send(b\"HTTP/1.1 200 Connection Established\\r\\n\\r\\n\")\n            ssl_sock = original_ssl_wrap_socket(\n                sock,\n                server_side=True,\n                keyfile=DEFAULT_CERTS[\"keyfile\"],\n                certfile=DEFAULT_CERTS[\"certfile\"],\n                ca_certs=DEFAULT_CA,\n            )\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 2\\r\\n\"\n                b\"Connection: close\\r\\n\"\n                b\"\\r\\n\"\n                b\"Hi\"\n            )\n            ssl_sock.close()\n\n        def echo_socket_handler(listener: socket.socket) -> None:\n            proxy_ssl_one(listener)\n            proxy_ssl_one(listener)\n\n        self._start_server(echo_socket_handler)\n        base_url = f\"http://{self.host}:{self.port}\"\n\n        with proxy_from_url(base_url, ca_certs=DEFAULT_CA) as proxy:\n            url = f\"https://{self.host}\"\n            conn = proxy.connection_from_url(url)\n            r = conn.urlopen(\"GET\", url, retries=0)\n            assert r.status == 200\n            r = conn.urlopen(\"GET\", url, retries=0)\n            assert r.status == 200\n\n    def test_connect_ipv6_addr(self) -> None:\n        ipv6_addr = \"2001:4998:c:a06::2:4008\"\n\n        def echo_socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n            s = buf.decode(\"utf-8\")\n\n            if s.startswith(f\"CONNECT [{ipv6_addr}]:443\"):\n                sock.send(b\"HTTP/1.1 200 Connection Established\\r\\n\\r\\n\")\n                ssl_sock = original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                )\n                buf = b\"\"\n                while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                    buf += ssl_sock.recv(65536)\n\n                ssl_sock.send(\n                    b\"HTTP/1.1 200 OK\\r\\n\"\n                    b\"Content-Type: text/plain\\r\\n\"\n                    b\"Content-Length: 2\\r\\n\"\n                    b\"Connection: close\\r\\n\"\n                    b\"\\r\\n\"\n                    b\"Hi\"\n                )\n                ssl_sock.close()\n            else:\n                sock.close()\n\n        self._start_server(echo_socket_handler)\n        base_url = f\"http://{self.host}:{self.port}\"\n\n        with proxy_from_url(base_url, cert_reqs=\"NONE\") as proxy:\n            url = f\"https://[{ipv6_addr}]\"\n            conn = proxy.connection_from_url(url)\n            try:\n                with pytest.warns(InsecureRequestWarning):\n                    r = conn.urlopen(\"GET\", url, retries=0)\n                assert r.status == 200\n            except MaxRetryError:\n                pytest.fail(\"Invalid IPv6 format in HTTP CONNECT request\")\n\n    @pytest.mark.parametrize(\"target_scheme\", [\"http\", \"https\"])\n    def test_https_proxymanager_connected_to_http_proxy(\n        self, target_scheme: str\n    ) -> None:\n        errored = Event()\n\n        def http_socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            sock.send(b\"HTTP/1.0 501 Not Implemented\\r\\nConnection: close\\r\\n\\r\\n\")\n            errored.wait()\n            sock.close()\n\n        self._start_server(http_socket_handler)\n        base_url = f\"https://{self.host}:{self.port}\"\n\n        with ProxyManager(base_url, cert_reqs=\"NONE\") as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                proxy.request(\"GET\", f\"{target_scheme}://example.com\", retries=0)\n\n            errored.set()  # Avoid a ConnectionAbortedError on Windows.\n\n            assert type(e.value.reason) is ProxyError\n            assert \"Your proxy appears to only use HTTP and not HTTPS\" in str(\n                e.value.reason\n            )\n\n\nclass TestSSL(SocketDummyServerTestCase):\n    def test_ssl_failure_midway_through_conn(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            with listener.accept()[0] as sock, sock.dup() as sock2:\n                ssl_sock = original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                )\n\n                buf = b\"\"\n                while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                    buf += ssl_sock.recv(65536)\n\n                # Deliberately send from the non-SSL socket.\n                sock2.send(\n                    b\"HTTP/1.1 200 OK\\r\\n\"\n                    b\"Content-Type: text/plain\\r\\n\"\n                    b\"Content-Length: 2\\r\\n\"\n                    b\"\\r\\n\"\n                    b\"Hi\"\n                )\n                ssl_sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:\n            with pytest.raises(\n                SSLError,\n                match=r\"(wrong version number|record overflow|record layer failure)\",\n            ):\n                pool.request(\"GET\", \"/\", retries=False)\n\n    def test_ssl_read_timeout(self) -> None:\n        timed_out = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            # disable Nagle's algorithm so there's no delay in sending a partial body\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, True)\n            ssl_sock = original_ssl_wrap_socket(\n                sock,\n                server_side=True,\n                keyfile=DEFAULT_CERTS[\"keyfile\"],\n                certfile=DEFAULT_CERTS[\"certfile\"],\n            )\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n\n            # Send incomplete message (note Content-Length)\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 10\\r\\n\"\n                b\"\\r\\n\"\n                b\"Hi-\"\n            )\n            timed_out.wait()\n\n            sock.close()\n            ssl_sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:\n            response = pool.urlopen(\n                \"GET\", \"/\", retries=0, preload_content=False, timeout=LONG_TIMEOUT\n            )\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    response.read()\n            finally:\n                timed_out.set()\n\n    def test_ssl_failed_fingerprint_verification(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            for i in range(2):\n                sock = listener.accept()[0]\n                try:\n                    ssl_sock = original_ssl_wrap_socket(\n                        sock,\n                        server_side=True,\n                        keyfile=DEFAULT_CERTS[\"keyfile\"],\n                        certfile=DEFAULT_CERTS[\"certfile\"],\n                        ca_certs=DEFAULT_CA,\n                    )\n                except (ssl.SSLError, ConnectionResetError, ConnectionAbortedError):\n                    pass\n\n                else:\n                    with ssl_sock:\n                        try:\n                            ssl_sock.send(\n                                b\"HTTP/1.1 200 OK\\r\\n\"\n                                b\"Content-Type: text/plain\\r\\n\"\n                                b\"Content-Length: 5\\r\\n\\r\\n\"\n                                b\"Hello\"\n                            )\n                        except (ssl.SSLEOFError, ConnectionResetError, BrokenPipeError):\n                            pass\n\n                sock.close()\n\n        self._start_server(socket_handler)\n        # GitHub's fingerprint. Valid, but not matching.\n        fingerprint = \"A0:C4:A7:46:00:ED:A7:2D:C0:BE:CB:9A:8C:B6:07:CA:58:EE:74:5E\"\n\n        def request() -> None:\n            pool = HTTPSConnectionPool(\n                self.host,\n                self.port,\n                assert_fingerprint=fingerprint,\n                cert_reqs=\"CERT_NONE\",\n            )\n            try:\n                timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)\n                response = pool.urlopen(\n                    \"GET\", \"/\", preload_content=False, retries=0, timeout=timeout\n                )\n                response.read()\n            finally:\n                pool.close()\n\n        with pytest.raises(MaxRetryError) as cm:\n            request()\n        assert type(cm.value.reason) is SSLError\n        assert str(cm.value.reason) == (\n            \"Fingerprints did not match. Expected \"\n            '\"a0c4a74600eda72dc0becb9a8cb607ca58ee745e\", got '\n            '\"728b554c9afc1e88a11cad1bb2e7cc3edbc8f98a\"'\n        )\n        # Should not hang, see https://github.com/urllib3/urllib3/issues/529\n        with pytest.raises(MaxRetryError) as cm2:\n            request()\n        assert type(cm2.value.reason) is SSLError\n        assert str(cm2.value.reason) == (\n            \"Fingerprints did not match. Expected \"\n            '\"a0c4a74600eda72dc0becb9a8cb607ca58ee745e\", got '\n            '\"728b554c9afc1e88a11cad1bb2e7cc3edbc8f98a\"'\n        )\n\n    def test_retry_ssl_error(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            # first request, trigger an SSLError\n            sock = listener.accept()[0]\n            sock2 = sock.dup()\n            ssl_sock = original_ssl_wrap_socket(\n                sock,\n                server_side=True,\n                keyfile=DEFAULT_CERTS[\"keyfile\"],\n                certfile=DEFAULT_CERTS[\"certfile\"],\n            )\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n\n            # Deliberately send from the non-SSL socket to trigger an SSLError\n            sock2.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 4\\r\\n\"\n                b\"\\r\\n\"\n                b\"Fail\"\n            )\n            sock2.close()\n            ssl_sock.close()\n\n            # retried request\n            sock = listener.accept()[0]\n            ssl_sock = original_ssl_wrap_socket(\n                sock,\n                server_side=True,\n                keyfile=DEFAULT_CERTS[\"keyfile\"],\n                certfile=DEFAULT_CERTS[\"certfile\"],\n            )\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 7\\r\\n\\r\\n\"\n                b\"Success\"\n            )\n            ssl_sock.close()\n\n        self._start_server(socket_handler)\n\n        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:\n            response = pool.urlopen(\"GET\", \"/\", retries=1)\n            assert response.data == b\"Success\"\n\n    def test_ssl_load_default_certs_when_empty(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            try:\n                ssl_sock = original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                )\n            except (ssl.SSLError, OSError):\n                return\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 5\\r\\n\\r\\n\"\n                b\"Hello\"\n            )\n\n            ssl_sock.close()\n            sock.close()\n\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.load_default_certs = mock.Mock()\n        context.options = 0\n\n        class MockSSLSocket:\n            def __init__(\n                self, sock: socket.socket, *args: object, **kwargs: object\n            ) -> None:\n                self._sock = sock\n\n            def close(self) -> None:\n                self._sock.close()\n\n        context.wrap_socket = MockSSLSocket\n\n        with mock.patch(\"urllib3.util.ssl_.SSLContext\", lambda *_, **__: context):\n            self._start_server(socket_handler)\n            with HTTPSConnectionPool(self.host, self.port) as pool:\n                # Without a proper `SSLContext`, this request will fail in some\n                # arbitrary way, but we only want to know if load_default_certs() was\n                # called, which is why we accept any `Exception` here.\n                with pytest.raises(Exception):\n                    pool.request(\"GET\", \"/\", timeout=SHORT_TIMEOUT)\n                context.load_default_certs.assert_called_with()\n\n    def test_ssl_dont_load_default_certs_when_given(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            try:\n                ssl_sock = original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                )\n            except (ssl.SSLError, OSError):\n                return\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += ssl_sock.recv(65536)\n\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: 5\\r\\n\\r\\n\"\n                b\"Hello\"\n            )\n\n            ssl_sock.close()\n            sock.close()\n\n        context = mock.create_autospec(ssl_.SSLContext)\n        context.load_default_certs = mock.Mock()\n        context.options = 0\n\n        class MockSSLSocket:\n            def __init__(\n                self, sock: socket.socket, *args: object, **kwargs: object\n            ) -> None:\n                self._sock = sock\n\n            def close(self) -> None:\n                self._sock.close()\n\n        context.wrap_socket = MockSSLSocket\n\n        with mock.patch(\"urllib3.util.ssl_.SSLContext\", lambda *_, **__: context):\n            for kwargs in [\n                {\"ca_certs\": \"/a\"},\n                {\"ca_cert_dir\": \"/a\"},\n                {\"ca_certs\": \"a\", \"ca_cert_dir\": \"a\"},\n                {\"ssl_context\": context},\n            ]:\n                self._start_server(socket_handler)\n\n                with HTTPSConnectionPool(self.host, self.port, **kwargs) as pool:\n                    with pytest.raises(Exception):\n                        pool.request(\"GET\", \"/\", timeout=SHORT_TIMEOUT)\n                    context.load_default_certs.assert_not_called()\n\n    def test_load_verify_locations_exception(self) -> None:\n        \"\"\"\n        Ensure that load_verify_locations raises SSLError for all backends\n        \"\"\"\n        with pytest.raises(SSLError):\n            ssl_wrap_socket(None, ca_certs=\"/tmp/fake-file\")  # type: ignore[call-overload]\n\n    def test_ssl_custom_validation_failure_terminates(self, tmpdir: Path) -> None:\n        \"\"\"\n        Ensure that the underlying socket is terminated if custom validation fails.\n        \"\"\"\n        server_closed = Event()\n\n        def is_closed_socket(sock: socket.socket) -> bool:\n            try:\n                sock.settimeout(SHORT_TIMEOUT)\n            except OSError:\n                return True\n            return False\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            try:\n                _ = original_ssl_wrap_socket(\n                    sock,\n                    server_side=True,\n                    keyfile=DEFAULT_CERTS[\"keyfile\"],\n                    certfile=DEFAULT_CERTS[\"certfile\"],\n                    ca_certs=DEFAULT_CA,\n                )\n            except ConnectionResetError:\n                return\n            except ssl.SSLError as e:\n                assert \"alert unknown ca\" in str(e)\n                if is_closed_socket(sock):\n                    server_closed.set()\n\n        self._start_server(socket_handler)\n\n        # client uses a different ca\n        other_ca = trustme.CA()\n        other_ca_path = str(tmpdir / \"ca.pem\")\n        other_ca.cert_pem.write_to_path(other_ca_path)\n\n        with HTTPSConnectionPool(\n            self.host, self.port, cert_reqs=\"REQUIRED\", ca_certs=other_ca_path\n        ) as pool:\n            with pytest.raises(SSLError):\n                pool.request(\"GET\", \"/\", retries=False, timeout=LONG_TIMEOUT)\n        assert server_closed.wait(LONG_TIMEOUT), \"The socket was not terminated\"\n\n    def _run_preload(self, pool: HTTPSConnectionPool, content_length: int) -> None:\n        response = pool.request(\"GET\", \"/\")\n        assert len(response.data) == content_length\n\n    def _run_read_None(self, pool: HTTPSConnectionPool, content_length: int) -> None:\n        response = pool.request(\"GET\", \"/\", preload_content=False)\n        assert len(response.read(None)) == content_length\n        assert response.read(None) == b\"\"\n\n    def _run_read_amt(self, pool: HTTPSConnectionPool, content_length: int) -> None:\n        response = pool.request(\"GET\", \"/\", preload_content=False)\n        assert len(response.read(content_length)) == content_length\n        assert response.read(5) == b\"\"\n\n    def _run_read1_None(self, pool: HTTPSConnectionPool, content_length: int) -> None:\n        response = pool.request(\"GET\", \"/\", preload_content=False)\n        remaining = content_length\n        while True:\n            chunk = response.read1(None)\n            if not chunk:\n                break\n            remaining -= len(chunk)\n        assert remaining == 0\n\n    def _run_read1_amt(self, pool: HTTPSConnectionPool, content_length: int) -> None:\n        response = pool.request(\"GET\", \"/\", preload_content=False)\n        remaining = content_length\n        while True:\n            chunk = response.read1(content_length)\n            if not chunk:\n                break\n            remaining -= len(chunk)\n        assert remaining == 0\n\n    @pytest.mark.integration\n    @pytest.mark.parametrize(\n        \"method\",\n        [_run_preload, _run_read_None, _run_read_amt, _run_read1_None, _run_read1_amt],\n    )\n    def test_requesting_large_resources_via_ssl(\n        self, method: typing.Callable[[typing.Any, HTTPSConnectionPool, int], None]\n    ) -> None:\n        \"\"\"\n        Ensure that it is possible to read 2 GiB or more via an SSL\n        socket.\n        https://github.com/urllib3/urllib3/issues/2513\n        \"\"\"\n        content_length = 2**31  # (`int` max value in C) + 1.\n        ssl_ready = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n            ssl_sock = original_ssl_wrap_socket(\n                sock,\n                server_side=True,\n                keyfile=DEFAULT_CERTS[\"keyfile\"],\n                certfile=DEFAULT_CERTS[\"certfile\"],\n                ca_certs=DEFAULT_CA,\n            )\n            ssl_ready.set()\n\n            while not ssl_sock.recv(65536).endswith(b\"\\r\\n\\r\\n\"):\n                continue\n\n            ssl_sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Type: text/plain\\r\\n\"\n                b\"Content-Length: %d\\r\\n\\r\\n\" % content_length\n            )\n\n            chunks = 2\n            for i in range(chunks):\n                ssl_sock.sendall(bytes(content_length // chunks))\n\n            ssl_sock.close()\n            sock.close()\n\n        self._start_server(socket_handler)\n        ssl_ready.wait(5)\n        with HTTPSConnectionPool(\n            self.host, self.port, ca_certs=DEFAULT_CA, retries=False\n        ) as pool:\n            method(self, pool, content_length)\n\n\nclass TestErrorWrapping(SocketDummyServerTestCase):\n    def test_bad_statusline(self) -> None:\n        self.start_response_handler(\n            b\"HTTP/1.1 Omg What Is This?\\r\\n\" b\"Content-Length: 0\\r\\n\" b\"\\r\\n\"\n        )\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            with pytest.raises(ProtocolError):\n                pool.request(\"GET\", \"/\")\n\n    def test_unknown_protocol(self) -> None:\n        self.start_response_handler(\n            b\"HTTP/1000 200 OK\\r\\n\" b\"Content-Length: 0\\r\\n\" b\"\\r\\n\"\n        )\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            with pytest.raises(ProtocolError):\n                pool.request(\"GET\", \"/\")\n\n\nclass TestHeaders(SocketDummyServerTestCase):\n    def test_httplib_headers_case_insensitive(self) -> None:\n        self.start_response_handler(\n            b\"HTTP/1.1 200 OK\\r\\n\"\n            b\"Content-Length: 0\\r\\n\"\n            b\"Content-type: text/plain\\r\\n\"\n            b\"\\r\\n\"\n        )\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            HEADERS = {\"Content-Length\": \"0\", \"Content-type\": \"text/plain\"}\n            r = pool.request(\"GET\", \"/\")\n            assert HEADERS == dict(r.headers.items())  # to preserve case sensitivity\n\n    def start_parsing_handler(self) -> None:\n        self.parsed_headers: typing.OrderedDict[str, str] = OrderedDict()\n        self.received_headers: list[bytes] = []\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            self.received_headers = [\n                header for header in buf.split(b\"\\r\\n\")[1:] if header\n            ]\n\n            for header in self.received_headers:\n                (key, value) = header.split(b\": \")\n                self.parsed_headers[key.decode(\"ascii\")] = value.decode(\"ascii\")\n\n            sock.send(b\"HTTP/1.1 204 No Content\\r\\nContent-Length: 0\\r\\n\\r\\n\")\n\n            sock.close()\n\n        self._start_server(socket_handler)\n\n    def test_headers_are_sent_with_the_original_case(self) -> None:\n        headers = {\"foo\": \"bar\", \"bAz\": \"quux\"}\n\n        self.start_parsing_handler()\n        expected_headers = {\n            \"Accept-Encoding\": \"identity\",\n            \"Host\": f\"{self.host}:{self.port}\",\n            \"User-Agent\": _get_default_user_agent(),\n        }\n        expected_headers.update(headers)\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.request(\"GET\", \"/\", headers=HTTPHeaderDict(headers))\n            assert expected_headers == self.parsed_headers\n\n    def test_ua_header_can_be_overridden(self) -> None:\n        headers = {\"uSeR-AgENt\": \"Definitely not urllib3!\"}\n\n        self.start_parsing_handler()\n        expected_headers = {\n            \"Accept-Encoding\": \"identity\",\n            \"Host\": f\"{self.host}:{self.port}\",\n        }\n        expected_headers.update(headers)\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.request(\"GET\", \"/\", headers=HTTPHeaderDict(headers))\n            assert expected_headers == self.parsed_headers\n\n    def test_request_headers_are_sent_in_the_original_order(self) -> None:\n        # NOTE: Probability this test gives a false negative is 1/(K!)\n        K = 16\n        # NOTE: Provide headers in non-sorted order (i.e. reversed)\n        #       so that if the internal implementation tries to sort them,\n        #       a change will be detected.\n        expected_request_headers = [\n            (f\"X-Header-{int(i)}\", str(i)) for i in reversed(range(K))\n        ]\n\n        def filter_non_x_headers(\n            d: typing.OrderedDict[str, str]\n        ) -> list[tuple[str, str]]:\n            return [(k, v) for (k, v) in d.items() if k.startswith(\"X-Header-\")]\n\n        self.start_parsing_handler()\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.request(\"GET\", \"/\", headers=OrderedDict(expected_request_headers))\n            assert expected_request_headers == filter_non_x_headers(self.parsed_headers)\n\n    @resolvesLocalhostFQDN()\n    def test_request_host_header_ignores_fqdn_dot(self) -> None:\n        self.start_parsing_handler()\n\n        with HTTPConnectionPool(self.host + \".\", self.port, retries=False) as pool:\n            pool.request(\"GET\", \"/\")\n            self.assert_header_received(\n                self.received_headers, \"Host\", f\"{self.host}:{self.port}\"\n            )\n\n    def test_response_headers_are_returned_in_the_original_order(self) -> None:\n        # NOTE: Probability this test gives a false negative is 1/(K!)\n        K = 16\n        # NOTE: Provide headers in non-sorted order (i.e. reversed)\n        #       so that if the internal implementation tries to sort them,\n        #       a change will be detected.\n        expected_response_headers = [\n            (f\"X-Header-{int(i)}\", str(i)) for i in reversed(range(K))\n        ]\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                + b\"\\r\\n\".join(\n                    [\n                        (k.encode(\"utf8\") + b\": \" + v.encode(\"utf8\"))\n                        for (k, v) in expected_response_headers\n                    ]\n                )\n                + b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/\", retries=0)\n            actual_response_headers = [\n                (k, v) for (k, v) in r.headers.items() if k.startswith(\"X-Header-\")\n            ]\n            assert expected_response_headers == actual_response_headers\n\n    @pytest.mark.parametrize(\n        \"method_type, body_type\",\n        [\n            (\"GET\", None),\n            (\"POST\", None),\n            (\"POST\", \"bytes\"),\n            (\"POST\", \"bytes-io\"),\n        ],\n    )\n    def test_headers_sent_with_add(\n        self, method_type: str, body_type: str | None\n    ) -> None:\n        \"\"\"\n        Confirm that when adding headers with combine=True that we simply append to the\n        most recent value, rather than create a new header line.\n        \"\"\"\n        body: None | bytes | io.BytesIO\n        if body_type is None:\n            body = None\n            expected = b\"\\r\\n\\r\\n\"\n        elif body_type == \"bytes\":\n            body = b\"my-body\"\n            expected = b\"\\r\\n\\r\\nmy-body\"\n        elif body_type == \"bytes-io\":\n            body = io.BytesIO(b\"bytes-io-body\")\n            body.seek(0, 0)\n            expected = b\"bytes-io-body\\r\\n0\\r\\n\\r\\n\"\n        else:\n            raise ValueError(\"Unknown body type\")\n\n        buffer: bytes = b\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            nonlocal buffer\n            sock = listener.accept()[0]\n            sock.settimeout(0)\n\n            while expected not in buffer:\n                with contextlib.suppress(BlockingIOError):\n                    buffer += sock.recv(65536)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: example.com\\r\\n\"\n                b\"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n\n        headers = HTTPHeaderDict()\n        headers.add(\"A\", \"1\")\n        headers.add(\"C\", \"3\")\n        headers.add(\"B\", \"2\")\n        headers.add(\"B\", \"3\")\n        headers.add(\"A\", \"4\", combine=False)\n        headers.add(\"C\", \"5\", combine=True)\n        headers.add(\"C\", \"6\")\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.request(\n                method_type,\n                \"/\",\n                body=body,\n                headers=headers,\n            )\n            assert r.status == 200\n            assert b\"A: 1\\r\\nA: 4\\r\\nC: 3, 5\\r\\nC: 6\\r\\nB: 2\\r\\nB: 3\" in buffer\n\n\nclass TestBrokenHeaders(SocketDummyServerTestCase):\n    def _test_broken_header_parsing(\n        self, headers: list[bytes], unparsed_data_check: str | None = None\n    ) -> None:\n        self.start_response_handler(\n            (\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"Content-type: text/plain\\r\\n\"\n            )\n            + b\"\\r\\n\".join(headers)\n            + b\"\\r\\n\\r\\n\"\n        )\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            with LogRecorder() as logs:\n                pool.request(\"GET\", \"/\")\n\n            for record in logs:\n                if (\n                    \"Failed to parse headers\" in record.msg\n                    and type(record.args) is tuple\n                    and _url_from_pool(pool, \"/\") == record.args[0]\n                ):\n                    if (\n                        unparsed_data_check is None\n                        or unparsed_data_check in record.getMessage()\n                    ):\n                        return\n            pytest.fail(\"Missing log about unparsed headers\")\n\n    def test_header_without_name(self) -> None:\n        self._test_broken_header_parsing([b\": Value\", b\"Another: Header\"])\n\n    def test_header_without_name_or_value(self) -> None:\n        self._test_broken_header_parsing([b\":\", b\"Another: Header\"])\n\n    def test_header_without_colon_or_value(self) -> None:\n        self._test_broken_header_parsing(\n            [b\"Broken Header\", b\"Another: Header\"], \"Broken Header\"\n        )\n\n\nclass TestHeaderParsingContentType(SocketDummyServerTestCase):\n    def _test_okay_header_parsing(self, header: bytes) -> None:\n        self.start_response_handler(\n            (b\"HTTP/1.1 200 OK\\r\\n\" b\"Content-Length: 0\\r\\n\") + header + b\"\\r\\n\\r\\n\"\n        )\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            with LogRecorder() as logs:\n                pool.request(\"GET\", \"/\")\n\n            for record in logs:\n                assert \"Failed to parse headers\" not in record.msg\n\n    def test_header_text_plain(self) -> None:\n        self._test_okay_header_parsing(b\"Content-type: text/plain\")\n\n    def test_header_message_rfc822(self) -> None:\n        self._test_okay_header_parsing(b\"Content-type: message/rfc822\")\n\n\nclass TestHEAD(SocketDummyServerTestCase):\n    def test_chunked_head_response_does_not_hang(self) -> None:\n        self.start_response_handler(\n            b\"HTTP/1.1 200 OK\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n            b\"Content-type: text/plain\\r\\n\"\n            b\"\\r\\n\"\n        )\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.request(\"HEAD\", \"/\", timeout=LONG_TIMEOUT, preload_content=False)\n\n            # stream will use the read_chunked method here.\n            assert [] == list(r.stream())\n\n    def test_empty_head_response_does_not_hang(self) -> None:\n        self.start_response_handler(\n            b\"HTTP/1.1 200 OK\\r\\n\"\n            b\"Content-Length: 256\\r\\n\"\n            b\"Content-type: text/plain\\r\\n\"\n            b\"\\r\\n\"\n        )\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.request(\"HEAD\", \"/\", timeout=LONG_TIMEOUT, preload_content=False)\n\n            # stream will use the read method here.\n            assert [] == list(r.stream())\n\n\nclass TestStream(SocketDummyServerTestCase):\n    def test_stream_none_unchunked_response_does_not_hang(self) -> None:\n        done_event = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 12\\r\\n\"\n                b\"Content-type: text/plain\\r\\n\"\n                b\"\\r\\n\"\n                b\"hello, world\"\n            )\n            done_event.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.request(\"GET\", \"/\", timeout=LONG_TIMEOUT, preload_content=False)\n\n            # Stream should read to the end.\n            assert [b\"hello, world\"] == list(r.stream(None))\n\n            done_event.set()\n\n    def test_large_compressed_stream(self) -> None:\n        done_event = Event()\n        expected_total_length = 296085\n\n        def socket_handler(listener: socket.socket) -> None:\n            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n            data = compress.compress(b\"x\" * expected_total_length)\n            data += compress.flush()\n\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: %d\\r\\n\"\n                b\"Content-Encoding: gzip\\r\\n\"\n                b\"\\r\\n\" % (len(data),) + data\n            )\n\n            done_event.wait(5)\n            sock.close()\n\n        self._start_server(socket_handler)\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.request(\"GET\", \"/\", timeout=LONG_TIMEOUT, preload_content=False)\n\n            # Chunks must all be equal or less than 10240\n            # and only the last chunk is allowed to be smaller\n            # than 10240.\n            total_length = 0\n            chunks_smaller_than_10240 = 0\n            for chunk in r.stream(10240, decode_content=True):\n                assert 0 < len(chunk) <= 10240\n                if len(chunk) < 10240:\n                    chunks_smaller_than_10240 += 1\n                else:\n                    assert chunks_smaller_than_10240 == 0\n                total_length += len(chunk)\n\n            assert chunks_smaller_than_10240 == 1\n            assert expected_total_length == total_length\n\n            done_event.set()\n\n\nclass TestBadContentLength(SocketDummyServerTestCase):\n    def test_enforce_content_length_get(self) -> None:\n        done_event = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 22\\r\\n\"\n                b\"Content-type: text/plain\\r\\n\"\n                b\"\\r\\n\"\n                b\"hello, world\"\n            )\n            done_event.wait(LONG_TIMEOUT)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port, maxsize=1) as conn:\n            # Test stream read when content length less than headers claim\n            get_response = conn.request(\n                \"GET\", url=\"/\", preload_content=False, enforce_content_length=True\n            )\n            data = get_response.stream(100)\n            with pytest.raises(ProtocolError, match=\"12 bytes read, 10 more expected\"):\n                next(data)\n            done_event.set()\n\n    def test_enforce_content_length_no_body(self) -> None:\n        done_event = Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            buf = b\"\"\n            while not buf.endswith(b\"\\r\\n\\r\\n\"):\n                buf += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 22\\r\\n\"\n                b\"Content-type: text/plain\\r\\n\"\n                b\"\\r\\n\"\n            )\n            done_event.wait(1)\n            sock.close()\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port, maxsize=1) as conn:\n            # Test stream on 0 length body\n            head_response = conn.request(\n                \"HEAD\", url=\"/\", preload_content=False, enforce_content_length=True\n            )\n            data = [chunk for chunk in head_response.stream(1)]\n            assert len(data) == 0\n\n            done_event.set()\n\n\nclass TestRetryPoolSizeDrainFail(SocketDummyServerTestCase):\n    def test_pool_size_retry_drain_fail(self) -> None:\n        def socket_handler(listener: socket.socket) -> None:\n            for _ in range(2):\n                sock = listener.accept()[0]\n                while not sock.recv(65536).endswith(b\"\\r\\n\\r\\n\"):\n                    pass\n\n                # send a response with an invalid content length -- this causes\n                # a ProtocolError to raise when trying to drain the connection\n                sock.send(\n                    b\"HTTP/1.1 404 NOT FOUND\\r\\n\"\n                    b\"Content-Length: 1000\\r\\n\"\n                    b\"Content-Type: text/plain\\r\\n\"\n                    b\"\\r\\n\"\n                )\n                sock.close()\n\n        self._start_server(socket_handler)\n        retries = Retry(total=1, raise_on_status=False, status_forcelist=[404])\n        with HTTPConnectionPool(\n            self.host, self.port, maxsize=10, retries=retries, block=True\n        ) as pool:\n            pool.urlopen(\"GET\", \"/not_found\", preload_content=False)\n            assert pool.num_connections == 1\n\n\nclass TestBrokenPipe(SocketDummyServerTestCase):\n    @notWindows()\n    def test_ignore_broken_pipe_errors(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        # On Windows an aborted connection raises an error on\n        # attempts to read data out of a socket that's been closed.\n        sock_shut = Event()\n        orig_connect = HTTPConnection.connect\n        # a buffer that will cause two sendall calls\n        buf = \"a\" * 1024 * 1024 * 4\n\n        def connect_and_wait(*args: typing.Any, **kw: typing.Any) -> None:\n            ret = orig_connect(*args, **kw)\n            assert sock_shut.wait(5)\n            return ret\n\n        def socket_handler(listener: socket.socket) -> None:\n            for i in range(2):\n                sock = listener.accept()[0]\n                sock.send(\n                    b\"HTTP/1.1 404 Not Found\\r\\n\"\n                    b\"Connection: close\\r\\n\"\n                    b\"Content-Length: 10\\r\\n\"\n                    b\"\\r\\n\"\n                    b\"xxxxxxxxxx\"\n                )\n                sock.shutdown(socket.SHUT_RDWR)\n                sock_shut.set()\n                sock.close()\n\n        monkeypatch.setattr(HTTPConnection, \"connect\", connect_and_wait)\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"POST\", \"/\", body=buf)\n            assert r.status == 404\n            assert r.headers[\"content-length\"] == \"10\"\n            assert r.data == b\"xxxxxxxxxx\"\n\n            r = pool.request(\"POST\", \"/admin\", chunked=True, body=buf)\n            assert r.status == 404\n            assert r.headers[\"content-length\"] == \"10\"\n            assert r.data == b\"xxxxxxxxxx\"\n\n\nclass TestMultipartResponse(SocketDummyServerTestCase):\n    def test_multipart_assert_header_parsing_no_defects(self) -> None:\n        quit_event = threading.Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            for _ in range(2):\n                listener.settimeout(LONG_TIMEOUT)\n\n                while True:\n                    if quit_event and quit_event.is_set():\n                        return\n                    try:\n                        sock = listener.accept()[0]\n                        break\n                    except (TimeoutError, socket.timeout):\n                        continue\n\n                sock.settimeout(LONG_TIMEOUT)\n                while True:\n                    if quit_event and quit_event.is_set():\n                        sock.close()\n                        return\n                    if sock.recv(65536).endswith(b\"\\r\\n\\r\\n\"):\n                        break\n\n                sock.sendall(\n                    b\"HTTP/1.1 404 Not Found\\r\\n\"\n                    b\"Server: example.com\\r\\n\"\n                    b\"Content-Type: multipart/mixed; boundary=36eeb8c4e26d842a\\r\\n\"\n                    b\"Content-Length: 73\\r\\n\"\n                    b\"\\r\\n\"\n                    b\"--36eeb8c4e26d842a\\r\\n\"\n                    b\"Content-Type: text/plain\\r\\n\"\n                    b\"\\r\\n\"\n                    b\"1\\r\\n\"\n                    b\"--36eeb8c4e26d842a--\\r\\n\",\n                )\n                sock.close()\n\n        self._start_server(socket_handler, quit_event=quit_event)\n        from urllib3.connectionpool import log\n\n        with mock.patch.object(log, \"warning\") as log_warning:\n            with HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT) as pool:\n                resp = pool.urlopen(\"GET\", \"/\")\n                assert resp.status == 404\n                assert (\n                    resp.headers[\"content-type\"]\n                    == \"multipart/mixed; boundary=36eeb8c4e26d842a\"\n                )\n                assert len(resp.data) == 73\n                log_warning.assert_not_called()\n\n\nclass TestContentFraming(SocketDummyServerTestCase):\n    @pytest.mark.parametrize(\"content_length\", [None, 0])\n    @pytest.mark.parametrize(\"method\", [\"POST\", \"PUT\", \"PATCH\"])\n    def test_content_length_0_by_default(\n        self, method: str, content_length: int | None\n    ) -> None:\n        buffer = bytearray()\n\n        def socket_handler(listener: socket.socket) -> None:\n            nonlocal buffer\n            sock = listener.accept()[0]\n            while not buffer.endswith(b\"\\r\\n\\r\\n\"):\n                buffer += sock.recv(65536)\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: example.com\\r\\n\"\n                b\"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n\n        headers = {}\n        if content_length is not None:\n            headers[\"Content-Length\"] = str(content_length)\n\n        with HTTPConnectionPool(self.host, self.port, timeout=3) as pool:\n            resp = pool.request(method, \"/\")\n            assert resp.status == 200\n\n        sent_bytes = bytes(buffer)\n        assert b\"Accept-Encoding: identity\\r\\n\" in sent_bytes\n        assert b\"Content-Length: 0\\r\\n\" in sent_bytes\n        assert b\"transfer-encoding\" not in sent_bytes.lower()\n\n    @pytest.mark.parametrize(\"chunked\", [True, False])\n    @pytest.mark.parametrize(\"method\", [\"POST\", \"PUT\", \"PATCH\"])\n    @pytest.mark.parametrize(\"body_type\", [\"file\", \"generator\", \"bytes\"])\n    def test_chunked_specified(\n        self, method: str, chunked: bool, body_type: str\n    ) -> None:\n        quit_event = threading.Event()\n        buffer = bytearray()\n        expected_bytes = b\"\\r\\n\\r\\na\\r\\nxxxxxxxxxx\\r\\n0\\r\\n\\r\\n\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            nonlocal buffer\n            listener.settimeout(LONG_TIMEOUT)\n            while True:\n                if quit_event.is_set():\n                    return\n                try:\n                    sock = listener.accept()[0]\n                    break\n                except (TimeoutError, socket.timeout):\n                    continue\n            sock.settimeout(LONG_TIMEOUT)\n\n            while expected_bytes not in buffer:\n                if quit_event.is_set():\n                    return\n                with contextlib.suppress(BlockingIOError):\n                    buffer += sock.recv(65536)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: example.com\\r\\n\"\n                b\"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler, quit_event=quit_event)\n\n        body: typing.Any\n        if body_type == \"generator\":\n\n            def body_generator() -> typing.Generator[bytes, None, None]:\n                yield b\"x\" * 10\n\n            body = body_generator()\n        elif body_type == \"file\":\n            body = io.BytesIO(b\"x\" * 10)\n            body.seek(0, 0)\n        else:\n            if chunked is False:\n                pytest.skip(\"urllib3 uses Content-Length in this case\")\n            body = b\"x\" * 10\n\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=LONG_TIMEOUT, retries=False\n        ) as pool:\n            resp = pool.request(method, \"/\", chunked=chunked, body=body)\n            assert resp.status == 200\n\n        sent_bytes = bytes(buffer)\n        assert sent_bytes.count(b\":\") == 5\n        assert b\"Host: localhost:\" in sent_bytes\n        assert b\"Accept-Encoding: identity\\r\\n\" in sent_bytes\n        assert b\"Transfer-Encoding: chunked\\r\\n\" in sent_bytes\n        assert b\"User-Agent: python-urllib3/\" in sent_bytes\n        assert b\"content-length\" not in sent_bytes.lower()\n        assert expected_bytes in sent_bytes\n\n    @pytest.mark.parametrize(\"method\", [\"POST\", \"PUT\", \"PATCH\"])\n    @pytest.mark.parametrize(\n        \"body_type\", [\"file\", \"generator\", \"bytes\", \"bytearray\", \"file_text\"]\n    )\n    def test_chunked_not_specified(self, method: str, body_type: str) -> None:\n        buffer = bytearray()\n        expected_bytes: bytes\n        body: typing.Any\n\n        if body_type == \"generator\":\n\n            def body_generator() -> typing.Generator[bytes, None, None]:\n                yield b\"x\" * 10\n\n            body = body_generator()\n            should_be_chunked = True\n        elif body_type == \"file\":\n            body = io.BytesIO(b\"x\" * 10)\n            body.seek(0, 0)\n            should_be_chunked = True\n        elif body_type == \"file_text\":\n            body = io.StringIO(\"x\" * 10)\n            body.seek(0, 0)\n            should_be_chunked = True\n        elif body_type == \"bytearray\":\n            body = bytearray(b\"x\" * 10)\n            should_be_chunked = False\n        else:\n            body = b\"x\" * 10\n            should_be_chunked = False\n\n        if should_be_chunked:\n            expected_bytes = b\"\\r\\n\\r\\na\\r\\nxxxxxxxxxx\\r\\n0\\r\\n\\r\\n\"\n        else:\n            expected_bytes = b\"\\r\\n\\r\\nxxxxxxxxxx\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            nonlocal buffer\n            sock = listener.accept()[0]\n            sock.settimeout(0)\n\n            while expected_bytes not in buffer:\n                with contextlib.suppress(BlockingIOError):\n                    buffer += sock.recv(65536)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: example.com\\r\\n\"\n                b\"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=LONG_TIMEOUT, retries=False\n        ) as pool:\n            resp = pool.request(method, \"/\", body=body)\n            assert resp.status == 200\n\n        sent_bytes = bytes(buffer)\n        assert sent_bytes.count(b\":\") == 5\n        assert b\"Host: localhost:\" in sent_bytes\n        assert b\"Accept-Encoding: identity\\r\\n\" in sent_bytes\n        assert b\"User-Agent: python-urllib3/\" in sent_bytes\n\n        if should_be_chunked:\n            assert b\"content-length\" not in sent_bytes.lower()\n            assert b\"Transfer-Encoding: chunked\\r\\n\" in sent_bytes\n            assert expected_bytes in sent_bytes\n\n        else:\n            assert b\"Content-Length: 10\\r\\n\" in sent_bytes\n            assert b\"transfer-encoding\" not in sent_bytes.lower()\n            assert sent_bytes.endswith(expected_bytes)\n\n    @pytest.mark.parametrize(\n        \"header_transform\",\n        [str.lower, str.title, str.upper],\n    )\n    @pytest.mark.parametrize(\n        [\"header\", \"header_value\", \"expected\"],\n        [\n            (\"content-length\", \"10\", b\": 10\\r\\n\\r\\nxxxxxxxx\"),\n            (\n                \"transfer-encoding\",\n                \"chunked\",\n                b\": chunked\\r\\n\\r\\n8\\r\\nxxxxxxxx\\r\\n0\\r\\n\\r\\n\",\n            ),\n        ],\n    )\n    def test_framing_set_via_headers(\n        self,\n        header_transform: typing.Callable[[str], str],\n        header: str,\n        header_value: str,\n        expected: bytes,\n    ) -> None:\n        buffer = bytearray()\n\n        def socket_handler(listener: socket.socket) -> None:\n            nonlocal buffer\n            sock = listener.accept()[0]\n            sock.settimeout(0)\n\n            while expected not in buffer:\n                with contextlib.suppress(BlockingIOError):\n                    buffer += sock.recv(65536)\n\n            sock.sendall(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Server: example.com\\r\\n\"\n                b\"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=LONG_TIMEOUT, retries=False\n        ) as pool:\n            resp = pool.request(\n                \"POST\",\n                \"/\",\n                body=b\"xxxxxxxx\",\n                headers={header_transform(header): header_value},\n            )\n            assert resp.status == 200\n\n            sent_bytes = bytes(buffer)\n            assert sent_bytes.endswith(expected)\n", "test/with_dummyserver/test_proxy_poolmanager.py": "from __future__ import annotations\n\nimport binascii\nimport contextlib\nimport hashlib\nimport ipaddress\nimport os.path\nimport pathlib\nimport shutil\nimport socket\nimport ssl\nimport tempfile\nfrom test import LONG_TIMEOUT, SHORT_TIMEOUT, resolvesLocalhostFQDN, withPyOpenSSL\nfrom test.conftest import ServerConfig\n\nimport pytest\nimport trustme\n\nimport urllib3.exceptions\nfrom dummyserver.socketserver import DEFAULT_CA, HAS_IPV6, get_unreachable_address\nfrom dummyserver.testcase import (\n    HypercornDummyProxyTestCase,\n    IPv6HypercornDummyProxyTestCase,\n)\nfrom urllib3 import HTTPResponse\nfrom urllib3._collections import HTTPHeaderDict\nfrom urllib3.connection import VerifiedHTTPSConnection\nfrom urllib3.connectionpool import connection_from_url\nfrom urllib3.exceptions import (\n    ConnectTimeoutError,\n    InsecureRequestWarning,\n    MaxRetryError,\n    ProxyError,\n    ProxySchemeUnknown,\n    ProxySchemeUnsupported,\n    ReadTimeoutError,\n    SSLError,\n)\nfrom urllib3.poolmanager import ProxyManager, proxy_from_url\nfrom urllib3.util.ssl_ import create_urllib3_context\nfrom urllib3.util.timeout import Timeout\n\nfrom .. import TARPIT_HOST, requires_network\n\n\ndef assert_is_verified(pm: ProxyManager, *, proxy: bool, target: bool) -> None:\n    pool = list(pm.pools._container.values())[-1]  # retrieve last pool entry\n    connection = (\n        pool.pool.queue[-1] if pool.pool is not None else None\n    )  # retrieve last connection entry\n\n    assert connection.proxy_is_verified is proxy\n    assert connection.is_verified is target\n\n\nclass TestHTTPProxyManager(HypercornDummyProxyTestCase):\n    @classmethod\n    def setup_class(cls) -> None:\n        super().setup_class()\n        cls.http_url = f\"http://{cls.http_host}:{int(cls.http_port)}\"\n        cls.http_url_alt = f\"http://{cls.http_host_alt}:{int(cls.http_port)}\"\n        cls.https_url = f\"https://{cls.https_host}:{int(cls.https_port)}\"\n        cls.https_url_alt = f\"https://{cls.https_host_alt}:{int(cls.https_port)}\"\n        cls.https_url_fqdn = f\"https://{cls.https_host}.:{int(cls.https_port)}\"\n        cls.proxy_url = f\"http://{cls.proxy_host}:{int(cls.proxy_port)}\"\n        cls.https_proxy_url = f\"https://{cls.proxy_host}:{int(cls.https_proxy_port)}\"\n\n        # Generate another CA to test verification failure\n        cls.certs_dir = tempfile.mkdtemp()\n        bad_ca = trustme.CA()\n\n        cls.bad_ca_path = os.path.join(cls.certs_dir, \"ca_bad.pem\")\n        bad_ca.cert_pem.write_to_path(cls.bad_ca_path)\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        super().teardown_class()\n        shutil.rmtree(cls.certs_dir)\n\n    def test_basic_proxy(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n            r = http.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n    def test_https_proxy(self) -> None:\n        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:\n            r = https.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n    def test_is_verified_http_proxy_to_http_target(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n            assert_is_verified(http, proxy=False, target=False)\n\n    def test_is_verified_http_proxy_to_https_target(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n            assert_is_verified(http, proxy=False, target=True)\n\n    def test_is_verified_https_proxy_to_http_target(self) -> None:\n        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n            assert_is_verified(https, proxy=True, target=False)\n\n    def test_is_verified_https_proxy_to_https_target(self) -> None:\n        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:\n            r = https.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n            assert_is_verified(https, proxy=True, target=True)\n\n    def test_http_and_https_kwarg_ca_cert_data_proxy(self) -> None:\n        with open(DEFAULT_CA) as pem_file:\n            pem_file_data = pem_file.read()\n        with proxy_from_url(self.https_proxy_url, ca_cert_data=pem_file_data) as https:\n            r = https.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n    def test_https_proxy_with_proxy_ssl_context(self) -> None:\n        proxy_ssl_context = create_urllib3_context()\n        proxy_ssl_context.load_verify_locations(DEFAULT_CA)\n        with proxy_from_url(\n            self.https_proxy_url,\n            proxy_ssl_context=proxy_ssl_context,\n            ca_certs=DEFAULT_CA,\n        ) as https:\n            r = https.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n    @withPyOpenSSL\n    def test_https_proxy_pyopenssl_not_supported(self) -> None:\n        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n            with pytest.raises(\n                ProxySchemeUnsupported, match=\"isn't available on non-native SSLContext\"\n            ):\n                https.request(\"GET\", f\"{self.https_url}/\")\n\n    def test_https_proxy_forwarding_for_https(self) -> None:\n        with proxy_from_url(\n            self.https_proxy_url,\n            ca_certs=DEFAULT_CA,\n            use_forwarding_for_https=True,\n        ) as https:\n            r = https.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n            r = https.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n    def test_nagle_proxy(self) -> None:\n        \"\"\"Test that proxy connections do not have TCP_NODELAY turned on\"\"\"\n        with ProxyManager(self.proxy_url) as http:\n            hc2 = http.connection_from_host(self.http_host, self.http_port)\n            conn = hc2._get_conn()\n            try:\n                hc2._make_request(conn, \"GET\", f\"{self.http_url}/\")\n                tcp_nodelay_setting = conn.sock.getsockopt(  # type: ignore[attr-defined]\n                    socket.IPPROTO_TCP, socket.TCP_NODELAY\n                )\n                assert tcp_nodelay_setting == 0, (\n                    \"Expected TCP_NODELAY for proxies to be set \"\n                    \"to zero, instead was %s\" % tcp_nodelay_setting\n                )\n            finally:\n                conn.close()\n\n    @pytest.mark.parametrize(\"proxy_scheme\", [\"http\", \"https\"])\n    @pytest.mark.parametrize(\"target_scheme\", [\"http\", \"https\"])\n    def test_proxy_conn_fail_from_dns(\n        self, proxy_scheme: str, target_scheme: str\n    ) -> None:\n        host, port = get_unreachable_address()\n        with proxy_from_url(\n            f\"{proxy_scheme}://{host}:{port}/\", retries=1, timeout=LONG_TIMEOUT\n        ) as http:\n            if target_scheme == \"https\":\n                target_url = self.https_url\n            else:\n                target_url = self.http_url\n\n            with pytest.raises(MaxRetryError) as e:\n                http.request(\"GET\", f\"{target_url}/\")\n            assert isinstance(e.value.reason, ProxyError)\n            assert isinstance(\n                e.value.reason.original_error, urllib3.exceptions.NameResolutionError\n            )\n\n    def test_oldapi(self) -> None:\n        with ProxyManager(\n            connection_from_url(self.proxy_url), ca_certs=DEFAULT_CA  # type: ignore[arg-type]\n        ) as http:\n            r = http.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n            r = http.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n    @resolvesLocalhostFQDN()\n    def test_proxy_https_fqdn(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.https_url_fqdn}/\")\n            assert r.status == 200\n\n    def test_proxy_verified(self) -> None:\n        with proxy_from_url(\n            self.proxy_url, cert_reqs=\"REQUIRED\", ca_certs=self.bad_ca_path\n        ) as http:\n            with http._new_pool(\n                \"https\", self.https_host, self.https_port\n            ) as https_pool:\n                with pytest.raises(MaxRetryError) as e:\n                    https_pool.request(\"GET\", \"/\", retries=0)\n            assert isinstance(e.value.reason, SSLError)\n            assert (\n                \"certificate verify failed\" in str(e.value.reason)\n                # PyPy is more specific\n                or \"self signed certificate in certificate chain\" in str(e.value.reason)\n            ), f\"Expected 'certificate verify failed', instead got: {e.value.reason!r}\"\n\n            http = proxy_from_url(\n                self.proxy_url, cert_reqs=\"REQUIRED\", ca_certs=DEFAULT_CA\n            )\n            with http._new_pool(\n                \"https\", self.https_host, self.https_port\n            ) as https_pool2:\n                with contextlib.closing(https_pool._new_conn()) as conn:\n                    assert conn.__class__ == VerifiedHTTPSConnection\n                    https_pool2.request(\n                        \"GET\", \"/\"\n                    )  # Should succeed without exceptions.\n\n            http = proxy_from_url(\n                self.proxy_url, cert_reqs=\"REQUIRED\", ca_certs=DEFAULT_CA\n            )\n            with http._new_pool(\n                \"https\", \"127.0.0.1\", self.https_port\n            ) as https_fail_pool:\n                with pytest.raises(\n                    MaxRetryError, match=\"doesn't match|IP address mismatch\"\n                ) as e:\n                    https_fail_pool.request(\"GET\", \"/\", retries=0)\n                assert isinstance(e.value.reason, SSLError)\n\n    def test_redirect(self) -> None:\n        with proxy_from_url(self.proxy_url) as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.http_url}/redirect\",\n                fields={\"target\": f\"{self.http_url}/\"},\n                redirect=False,\n            )\n\n            assert r.status == 303\n\n            r = http.request(\n                \"GET\",\n                f\"{self.http_url}/redirect\",\n                fields={\"target\": f\"{self.http_url}/\"},\n            )\n\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_cross_host_redirect(self) -> None:\n        with proxy_from_url(self.proxy_url) as http:\n            cross_host_location = f\"{self.http_url_alt}/echo?a=b\"\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    f\"{self.http_url}/redirect\",\n                    fields={\"target\": cross_host_location},\n                    retries=0,\n                )\n\n            r = http.request(\n                \"GET\",\n                f\"{self.http_url}/redirect\",\n                fields={\"target\": f\"{self.http_url_alt}/echo?a=b\"},\n                retries=1,\n            )\n            assert isinstance(r, HTTPResponse)\n            assert r._pool is not None\n            assert r._pool.host != self.http_host_alt\n\n    def test_cross_protocol_redirect(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            cross_protocol_location = f\"{self.https_url}/echo?a=b\"\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    f\"{self.http_url}/redirect\",\n                    fields={\"target\": cross_protocol_location},\n                    retries=0,\n                )\n\n            r = http.request(\n                \"GET\",\n                f\"{self.http_url}/redirect\",\n                fields={\"target\": f\"{self.https_url}/echo?a=b\"},\n                retries=1,\n            )\n            assert isinstance(r, HTTPResponse)\n            assert r._pool is not None\n            assert r._pool.host == self.https_host\n\n    def test_headers(self) -> None:\n        with proxy_from_url(\n            self.proxy_url,\n            headers={\"Foo\": \"bar\"},\n            proxy_headers={\"Hickory\": \"dickory\"},\n            ca_certs=DEFAULT_CA,\n        ) as http:\n            r = http.request_encode_url(\"GET\", f\"{self.http_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert returned_headers.get(\"Host\") == f\"{self.http_host}:{self.http_port}\"\n\n            r = http.request_encode_url(\"GET\", f\"{self.http_url_alt}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.http_host_alt}:{self.http_port}\"\n            )\n\n            r = http.request_encode_url(\"GET\", f\"{self.https_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") is None\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.https_host}:{self.https_port}\"\n            )\n\n            r = http.request_encode_body(\"POST\", f\"{self.http_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert returned_headers.get(\"Host\") == f\"{self.http_host}:{self.http_port}\"\n\n            r = http.request_encode_url(\n                \"GET\", f\"{self.http_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert returned_headers.get(\"Host\") == f\"{self.http_host}:{self.http_port}\"\n\n            r = http.request_encode_url(\n                \"GET\", f\"{self.https_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n            assert returned_headers.get(\"Hickory\") is None\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.https_host}:{self.https_port}\"\n            )\n\n            r = http.request_encode_body(\n                \"GET\", f\"{self.http_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert returned_headers.get(\"Host\") == f\"{self.http_host}:{self.http_port}\"\n\n            r = http.request_encode_body(\n                \"GET\", f\"{self.https_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n            assert returned_headers.get(\"Hickory\") is None\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.https_host}:{self.https_port}\"\n            )\n\n    def test_https_headers(self) -> None:\n        with proxy_from_url(\n            self.https_proxy_url,\n            headers={\"Foo\": \"bar\"},\n            proxy_headers={\"Hickory\": \"dickory\"},\n            ca_certs=DEFAULT_CA,\n        ) as http:\n            r = http.request_encode_url(\"GET\", f\"{self.http_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert returned_headers.get(\"Host\") == f\"{self.http_host}:{self.http_port}\"\n\n            r = http.request_encode_url(\"GET\", f\"{self.http_url_alt}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.http_host_alt}:{self.http_port}\"\n            )\n\n            r = http.request_encode_body(\n                \"GET\", f\"{self.https_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n            assert returned_headers.get(\"Hickory\") is None\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.https_host}:{self.https_port}\"\n            )\n\n    def test_https_headers_forwarding_for_https(self) -> None:\n        with proxy_from_url(\n            self.https_proxy_url,\n            headers={\"Foo\": \"bar\"},\n            proxy_headers={\"Hickory\": \"dickory\"},\n            ca_certs=DEFAULT_CA,\n            use_forwarding_for_https=True,\n        ) as http:\n            r = http.request_encode_url(\"GET\", f\"{self.https_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Hickory\") == \"dickory\"\n            assert (\n                returned_headers.get(\"Host\") == f\"{self.https_host}:{self.https_port}\"\n            )\n\n    def test_headerdict(self) -> None:\n        default_headers = HTTPHeaderDict(a=\"b\")\n        proxy_headers = HTTPHeaderDict()\n        proxy_headers.add(\"foo\", \"bar\")\n\n        with proxy_from_url(\n            self.proxy_url, headers=default_headers, proxy_headers=proxy_headers\n        ) as http:\n            request_headers = HTTPHeaderDict(baz=\"quux\")\n            r = http.request(\"GET\", f\"{self.http_url}/headers\", headers=request_headers)\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n            assert returned_headers.get(\"Baz\") == \"quux\"\n\n    def test_proxy_pooling(self) -> None:\n        with proxy_from_url(self.proxy_url, cert_reqs=\"NONE\") as http:\n            for x in range(2):\n                http.urlopen(\"GET\", self.http_url)\n            assert len(http.pools) == 1\n\n            for x in range(2):\n                http.urlopen(\"GET\", self.http_url_alt)\n            assert len(http.pools) == 1\n\n            for x in range(2):\n                with pytest.warns(InsecureRequestWarning):\n                    http.urlopen(\"GET\", self.https_url)\n            assert len(http.pools) == 2\n\n            for x in range(2):\n                with pytest.warns(InsecureRequestWarning):\n                    http.urlopen(\"GET\", self.https_url_alt)\n            assert len(http.pools) == 3\n\n    def test_proxy_pooling_ext(self) -> None:\n        with proxy_from_url(self.proxy_url) as http:\n            hc1 = http.connection_from_url(self.http_url)\n            hc2 = http.connection_from_host(self.http_host, self.http_port)\n            hc3 = http.connection_from_url(self.http_url_alt)\n            hc4 = http.connection_from_host(self.http_host_alt, self.http_port)\n            assert hc1 == hc2\n            assert hc2 == hc3\n            assert hc3 == hc4\n\n            sc1 = http.connection_from_url(self.https_url)\n            sc2 = http.connection_from_host(\n                self.https_host, self.https_port, scheme=\"https\"\n            )\n            sc3 = http.connection_from_url(self.https_url_alt)\n            sc4 = http.connection_from_host(\n                self.https_host_alt, self.https_port, scheme=\"https\"\n            )\n            assert sc1 == sc2\n            assert sc2 != sc3\n            assert sc3 == sc4\n\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"proxy_scheme\", \"target_scheme\", \"use_forwarding_for_https\"],\n        [\n            (\"http\", \"http\", False),\n            (\"https\", \"http\", False),\n            # 'use_forwarding_for_https' is only valid for HTTPS+HTTPS.\n            (\"https\", \"https\", True),\n        ],\n    )\n    def test_forwarding_proxy_request_timeout(\n        self, proxy_scheme: str, target_scheme: str, use_forwarding_for_https: bool\n    ) -> None:\n        proxy_url = self.https_proxy_url if proxy_scheme == \"https\" else self.proxy_url\n        target_url = f\"{target_scheme}://{TARPIT_HOST}\"\n\n        with proxy_from_url(\n            proxy_url,\n            ca_certs=DEFAULT_CA,\n            use_forwarding_for_https=use_forwarding_for_https,\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)\n                proxy.request(\"GET\", target_url, timeout=timeout)\n\n            # We sent the request to the proxy but didn't get any response\n            # so we're not sure if that's being caused by the proxy or the\n            # target so we put the blame on the target.\n            assert isinstance(e.value.reason, ReadTimeoutError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"proxy_scheme\", \"target_scheme\"], [(\"http\", \"https\"), (\"https\", \"https\")]\n    )\n    def test_tunneling_proxy_request_timeout(\n        self, proxy_scheme: str, target_scheme: str\n    ) -> None:\n        proxy_url = self.https_proxy_url if proxy_scheme == \"https\" else self.proxy_url\n        target_url = f\"{target_scheme}://{TARPIT_HOST}\"\n\n        with proxy_from_url(\n            proxy_url,\n            ca_certs=DEFAULT_CA,\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)\n                proxy.request(\"GET\", target_url, timeout=timeout)\n\n            assert isinstance(e.value.reason, ReadTimeoutError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"proxy_scheme\", \"target_scheme\", \"use_forwarding_for_https\"],\n        [\n            (\"http\", \"http\", False),\n            (\"https\", \"http\", False),\n            # 'use_forwarding_for_https' is only valid for HTTPS+HTTPS.\n            (\"https\", \"https\", True),\n        ],\n    )\n    def test_forwarding_proxy_connect_timeout(\n        self, proxy_scheme: str, target_scheme: str, use_forwarding_for_https: bool\n    ) -> None:\n        proxy_url = f\"{proxy_scheme}://{TARPIT_HOST}\"\n        target_url = self.https_url if target_scheme == \"https\" else self.http_url\n\n        with proxy_from_url(\n            proxy_url,\n            ca_certs=DEFAULT_CA,\n            timeout=SHORT_TIMEOUT,\n            use_forwarding_for_https=use_forwarding_for_https,\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                proxy.request(\"GET\", target_url)\n\n            assert isinstance(e.value.reason, ProxyError)\n            assert isinstance(e.value.reason.original_error, ConnectTimeoutError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"proxy_scheme\", \"target_scheme\"], [(\"http\", \"https\"), (\"https\", \"https\")]\n    )\n    def test_tunneling_proxy_connect_timeout(\n        self, proxy_scheme: str, target_scheme: str\n    ) -> None:\n        proxy_url = f\"{proxy_scheme}://{TARPIT_HOST}\"\n        target_url = self.https_url if target_scheme == \"https\" else self.http_url\n\n        with proxy_from_url(\n            proxy_url, ca_certs=DEFAULT_CA, timeout=SHORT_TIMEOUT\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                proxy.request(\"GET\", target_url)\n\n            assert isinstance(e.value.reason, ProxyError)\n            assert isinstance(e.value.reason.original_error, ConnectTimeoutError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"target_scheme\", \"use_forwarding_for_https\"],\n        [\n            (\"http\", False),\n            (\"https\", False),\n            (\"https\", True),\n        ],\n    )\n    def test_https_proxy_tls_error(\n        self, target_scheme: str, use_forwarding_for_https: str\n    ) -> None:\n        target_url = self.https_url if target_scheme == \"https\" else self.http_url\n        proxy_ctx = ssl.create_default_context()\n        with proxy_from_url(\n            self.https_proxy_url,\n            proxy_ssl_context=proxy_ctx,\n            use_forwarding_for_https=use_forwarding_for_https,\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                proxy.request(\"GET\", target_url)\n            assert isinstance(e.value.reason, ProxyError)\n            assert isinstance(e.value.reason.original_error, SSLError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    @requires_network()\n    @pytest.mark.parametrize(\n        [\"proxy_scheme\", \"use_forwarding_for_https\"],\n        [\n            (\"http\", False),\n            (\"https\", False),\n            (\"https\", True),\n        ],\n    )\n    def test_proxy_https_target_tls_error(\n        self, proxy_scheme: str, use_forwarding_for_https: str\n    ) -> None:\n        if proxy_scheme == \"https\" and use_forwarding_for_https:\n            pytest.skip(\"Test is expected to fail due to urllib3/urllib3#2577\")\n\n        proxy_url = self.https_proxy_url if proxy_scheme == \"https\" else self.proxy_url\n        proxy_ctx = ssl.create_default_context()\n        proxy_ctx.load_verify_locations(DEFAULT_CA)\n        ctx = ssl.create_default_context()\n\n        with proxy_from_url(\n            proxy_url,\n            proxy_ssl_context=proxy_ctx,\n            ssl_context=ctx,\n            use_forwarding_for_https=use_forwarding_for_https,\n        ) as proxy:\n            with pytest.raises(MaxRetryError) as e:\n                proxy.request(\"GET\", self.https_url)\n            assert isinstance(e.value.reason, SSLError)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_scheme_host_case_insensitive(self) -> None:\n        \"\"\"Assert that upper-case schemes and hosts are normalized.\"\"\"\n        with proxy_from_url(self.proxy_url.upper(), ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.http_url.upper()}/\")\n            assert r.status == 200\n\n            r = http.request(\"GET\", f\"{self.https_url.upper()}/\")\n            assert r.status == 200\n\n    @pytest.mark.parametrize(\n        \"url, error_msg\",\n        [\n            (\n                \"127.0.0.1\",\n                \"Proxy URL had no scheme, should start with http:// or https://\",\n            ),\n            (\n                \"localhost:8080\",\n                \"Proxy URL had no scheme, should start with http:// or https://\",\n            ),\n            (\n                \"ftp://google.com\",\n                \"Proxy URL had unsupported scheme ftp, should use http:// or https://\",\n            ),\n        ],\n    )\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_invalid_schema(self, url: str, error_msg: str) -> None:\n        with pytest.raises(ProxySchemeUnknown, match=error_msg):\n            proxy_from_url(url)\n\n\n@pytest.mark.skipif(not HAS_IPV6, reason=\"Only runs on IPv6 systems\")\nclass TestIPv6HTTPProxyManager(IPv6HypercornDummyProxyTestCase):\n    @classmethod\n    def setup_class(cls) -> None:\n        super().setup_class()\n        cls.http_url = f\"http://{cls.http_host}:{int(cls.http_port)}\"\n        cls.http_url_alt = f\"http://{cls.http_host_alt}:{int(cls.http_port)}\"\n        cls.https_url = f\"https://{cls.https_host}:{int(cls.https_port)}\"\n        cls.https_url_alt = f\"https://{cls.https_host_alt}:{int(cls.https_port)}\"\n        cls.proxy_url = f\"http://[{cls.proxy_host}]:{int(cls.proxy_port)}\"\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_basic_ipv6_proxy(self) -> None:\n        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:\n            r = http.request(\"GET\", f\"{self.http_url}/\")\n            assert r.status == 200\n\n            r = http.request(\"GET\", f\"{self.https_url}/\")\n            assert r.status == 200\n\n\nclass TestHTTPSProxyVerification:\n    @staticmethod\n    def _get_proxy_fingerprint_md5(ca_path: str) -> str:\n        proxy_pem_path = pathlib.Path(ca_path).parent / \"proxy.pem\"\n        proxy_der = ssl.PEM_cert_to_DER_cert(proxy_pem_path.read_text())\n        proxy_hashed = hashlib.md5(proxy_der).digest()\n        fingerprint = binascii.hexlify(proxy_hashed).decode(\"ascii\")\n        return fingerprint\n\n    @staticmethod\n    def _get_certificate_formatted_proxy_host(host: str) -> str:\n        try:\n            addr = ipaddress.ip_address(host)\n        except ValueError:\n            return host\n\n        if addr.version != 6:\n            return host\n\n        # Transform ipv6 like '::1' to 0:0:0:0:0:0:0:1 via '0000:0000:0000:0000:0000:0000:0000:0001'\n        return addr.exploded.replace(\"0000\", \"0\").replace(\"000\", \"\")\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_assert_fingerprint_md5(\n        self, no_san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = no_san_proxy_with_server\n        proxy_url = f\"https://{proxy.host}:{proxy.port}\"\n        destination_url = f\"https://{server.host}:{server.port}\"\n\n        proxy_fingerprint = self._get_proxy_fingerprint_md5(proxy.ca_certs)\n        with proxy_from_url(\n            proxy_url,\n            ca_certs=proxy.ca_certs,\n            proxy_assert_fingerprint=proxy_fingerprint,\n        ) as https:\n            https.request(\"GET\", destination_url)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_assert_fingerprint_md5_non_matching(\n        self, no_san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = no_san_proxy_with_server\n        proxy_url = f\"https://{proxy.host}:{proxy.port}\"\n        destination_url = f\"https://{server.host}:{server.port}\"\n\n        proxy_fingerprint = self._get_proxy_fingerprint_md5(proxy.ca_certs)\n        new_char = \"b\" if proxy_fingerprint[5] == \"a\" else \"a\"\n        proxy_fingerprint = proxy_fingerprint[:5] + new_char + proxy_fingerprint[6:]\n\n        with proxy_from_url(\n            proxy_url,\n            ca_certs=proxy.ca_certs,\n            proxy_assert_fingerprint=proxy_fingerprint,\n        ) as https:\n            with pytest.raises(MaxRetryError) as e:\n                https.request(\"GET\", destination_url)\n\n            assert \"Fingerprints did not match\" in str(e)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_assert_hostname(\n        self, san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = san_proxy_with_server\n        destination_url = f\"https://{server.host}:{server.port}\"\n\n        with proxy_from_url(\n            proxy.base_url, ca_certs=proxy.ca_certs, proxy_assert_hostname=proxy.host\n        ) as https:\n            https.request(\"GET\", destination_url)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_assert_hostname_non_matching(\n        self, san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = san_proxy_with_server\n        destination_url = f\"https://{server.host}:{server.port}\"\n\n        proxy_hostname = \"example.com\"\n        with proxy_from_url(\n            proxy.base_url,\n            ca_certs=proxy.ca_certs,\n            proxy_assert_hostname=proxy_hostname,\n        ) as https:\n            with pytest.raises(MaxRetryError) as e:\n                https.request(\"GET\", destination_url)\n\n            proxy_host = self._get_certificate_formatted_proxy_host(proxy.host)\n            msg = f\"hostname \\\\'{proxy_hostname}\\\\' doesn\\\\'t match \\\\'{proxy_host}\\\\'\"\n            assert msg in str(e)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_hostname_verification(\n        self, no_localhost_san_server: ServerConfig\n    ) -> None:\n        bad_server = no_localhost_san_server\n        bad_proxy_url = f\"https://{bad_server.host}:{bad_server.port}\"\n\n        # An exception will be raised before we contact the destination domain.\n        test_url = \"testing.com\"\n        with proxy_from_url(bad_proxy_url, ca_certs=bad_server.ca_certs) as https:\n            with pytest.raises(MaxRetryError) as e:\n                https.request(\"GET\", \"http://%s/\" % test_url)\n            assert isinstance(e.value.reason, ProxyError)\n\n            ssl_error = e.value.reason.original_error\n            assert isinstance(ssl_error, SSLError)\n            assert \"hostname 'localhost' doesn't match\" in str(\n                ssl_error\n            ) or \"Hostname mismatch\" in str(ssl_error)\n\n            with pytest.raises(MaxRetryError) as e:\n                https.request(\"GET\", \"https://%s/\" % test_url)\n            assert isinstance(e.value.reason, ProxyError)\n\n            ssl_error = e.value.reason.original_error\n            assert isinstance(ssl_error, SSLError)\n            assert \"hostname 'localhost' doesn't match\" in str(\n                ssl_error\n            ) or \"Hostname mismatch\" in str(ssl_error)\n\n    # stdlib http.client.HTTPConnection._tunnel() causes a ResourceWarning\n    # see https://github.com/python/cpython/issues/103472\n    @pytest.mark.filterwarnings(\"default::ResourceWarning\")\n    def test_https_proxy_ipv4_san(\n        self, ipv4_san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = ipv4_san_proxy_with_server\n        proxy_url = f\"https://{proxy.host}:{proxy.port}\"\n        destination_url = f\"https://{server.host}:{server.port}\"\n        with proxy_from_url(proxy_url, ca_certs=proxy.ca_certs) as https:\n            r = https.request(\"GET\", destination_url)\n            assert r.status == 200\n\n    def test_https_proxy_ipv6_san(\n        self, ipv6_san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = ipv6_san_proxy_with_server\n        proxy_url = f\"https://[{proxy.host}]:{proxy.port}\"\n        destination_url = f\"https://{server.host}:{server.port}\"\n        with proxy_from_url(proxy_url, ca_certs=proxy.ca_certs) as https:\n            r = https.request(\"GET\", destination_url)\n            assert r.status == 200\n\n    @pytest.mark.parametrize(\"target_scheme\", [\"http\", \"https\"])\n    def test_https_proxy_no_san(\n        self,\n        no_san_proxy_with_server: tuple[ServerConfig, ServerConfig],\n        target_scheme: str,\n    ) -> None:\n        proxy, server = no_san_proxy_with_server\n        proxy_url = f\"https://{proxy.host}:{proxy.port}\"\n        destination_url = f\"{target_scheme}://{server.host}:{server.port}\"\n\n        with proxy_from_url(proxy_url, ca_certs=proxy.ca_certs) as https:\n            with pytest.raises(MaxRetryError) as e:\n                https.request(\"GET\", destination_url)\n            assert isinstance(e.value.reason, ProxyError)\n\n            ssl_error = e.value.reason.original_error\n            assert isinstance(ssl_error, SSLError)\n            assert \"no appropriate subjectAltName fields were found\" in str(\n                ssl_error\n            ) or \"Hostname mismatch, certificate is not valid for 'localhost'\" in str(\n                ssl_error\n            )\n\n    def test_https_proxy_no_san_hostname_checks_common_name(\n        self, no_san_proxy_with_server: tuple[ServerConfig, ServerConfig]\n    ) -> None:\n        proxy, server = no_san_proxy_with_server\n        proxy_url = f\"https://{proxy.host}:{proxy.port}\"\n        destination_url = f\"https://{server.host}:{server.port}\"\n\n        proxy_ctx = urllib3.util.ssl_.create_urllib3_context()\n        try:\n            proxy_ctx.hostname_checks_common_name = True\n        # PyPy doesn't like us setting 'hostname_checks_common_name'\n        # but also has it enabled by default so we need to handle that.\n        except AttributeError:\n            pass\n        if getattr(proxy_ctx, \"hostname_checks_common_name\", False) is not True:\n            pytest.skip(\"Test requires 'SSLContext.hostname_checks_common_name=True'\")\n\n        with proxy_from_url(\n            proxy_url, ca_certs=proxy.ca_certs, proxy_ssl_context=proxy_ctx\n        ) as https:\n            https.request(\"GET\", destination_url)\n", "test/with_dummyserver/test_chunked_transfer.py": "from __future__ import annotations\n\nimport socket\n\nimport pytest\n\nfrom dummyserver.testcase import (\n    ConnectionMarker,\n    SocketDummyServerTestCase,\n    consume_socket,\n)\nfrom urllib3 import HTTPConnectionPool\nfrom urllib3.util import SKIP_HEADER\nfrom urllib3.util.retry import Retry\n\n\nclass TestChunkedTransfer(SocketDummyServerTestCase):\n    def start_chunked_handler(self) -> None:\n        self.buffer = b\"\"\n\n        def socket_handler(listener: socket.socket) -> None:\n            sock = listener.accept()[0]\n\n            while not self.buffer.endswith(b\"\\r\\n0\\r\\n\\r\\n\"):\n                self.buffer += sock.recv(65536)\n\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-type: text/plain\\r\\n\"\n                b\"Content-Length: 0\\r\\n\"\n                b\"\\r\\n\"\n            )\n            sock.close()\n\n        self._start_server(socket_handler)\n\n    @pytest.mark.parametrize(\n        \"chunks\",\n        [\n            [\"foo\", \"bar\", \"\", \"bazzzzzzzzzzzzzzzzzzzzzz\"],\n            [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"],\n        ],\n    )\n    def test_chunks(self, chunks: list[bytes | str]) -> None:\n        self.start_chunked_handler()\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\"GET\", \"/\", body=chunks, headers=dict(DNT=\"1\"), chunked=True)  # type: ignore[arg-type]\n\n            assert b\"Transfer-Encoding\" in self.buffer\n            body = self.buffer.split(b\"\\r\\n\\r\\n\", 1)[1]\n            lines = body.split(b\"\\r\\n\")\n            # Empty chunks should have been skipped, as this could not be distinguished\n            # from terminating the transmission\n            for i, chunk in enumerate(\n                [c.decode() if isinstance(c, bytes) else c for c in chunks if c]\n            ):\n                assert lines[i * 2] == hex(len(chunk))[2:].encode(\"utf-8\")\n                assert lines[i * 2 + 1] == chunk.encode(\"utf-8\")\n\n    def _test_body(self, data: bytes | str | None) -> None:\n        self.start_chunked_handler()\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\"GET\", \"/\", data, chunked=True)\n            header, body = self.buffer.split(b\"\\r\\n\\r\\n\", 1)\n\n            assert b\"Transfer-Encoding: chunked\" in header.split(b\"\\r\\n\")\n            if data:\n                bdata = data if isinstance(data, bytes) else data.encode(\"utf-8\")\n                assert b\"\\r\\n\" + bdata + b\"\\r\\n\" in body\n                assert body.endswith(b\"\\r\\n0\\r\\n\\r\\n\")\n\n                len_str = body.split(b\"\\r\\n\", 1)[0]\n                stated_len = int(len_str, 16)\n                assert stated_len == len(bdata)\n            else:\n                assert body == b\"0\\r\\n\\r\\n\"\n\n    def test_bytestring_body(self) -> None:\n        self._test_body(b\"thisshouldbeonechunk\\r\\nasdf\")\n\n    def test_unicode_body(self) -> None:\n        self._test_body(\"thisshouldbeonechunk\\r\\n\u00e4\u00f6\u00fc\u00df\")\n\n    def test_empty_body(self) -> None:\n        self._test_body(None)\n\n    def test_empty_string_body(self) -> None:\n        self._test_body(\"\")\n\n    def test_empty_iterable_body(self) -> None:\n        self._test_body(None)\n\n    def _get_header_lines(self, prefix: bytes) -> list[bytes]:\n        header_block = self.buffer.split(b\"\\r\\n\\r\\n\", 1)[0].lower()\n        header_lines = header_block.split(b\"\\r\\n\")[1:]\n        return [x for x in header_lines if x.startswith(prefix)]\n\n    def test_removes_duplicate_host_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\n                \"GET\", \"/\", body=chunks, headers={\"Host\": \"test.org\"}, chunked=True\n            )\n\n            host_headers = self._get_header_lines(b\"host\")\n            assert len(host_headers) == 1\n\n    def test_provides_default_host_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\"GET\", \"/\", body=chunks, chunked=True)\n\n            host_headers = self._get_header_lines(b\"host\")\n            assert len(host_headers) == 1\n\n    def test_provides_default_user_agent_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\"GET\", \"/\", body=chunks, chunked=True)\n\n            ua_headers = self._get_header_lines(b\"user-agent\")\n            assert len(ua_headers) == 1\n\n    def test_preserve_user_agent_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\n                \"GET\",\n                \"/\",\n                body=chunks,\n                headers={\"user-Agent\": \"test-agent\"},\n                chunked=True,\n            )\n\n            ua_headers = self._get_header_lines(b\"user-agent\")\n            # Validate that there is only one User-Agent header.\n            assert len(ua_headers) == 1\n            # Validate that the existing User-Agent header is the one that was\n            # provided.\n            assert ua_headers[0] == b\"user-agent: test-agent\"\n\n    def test_remove_user_agent_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\n                \"GET\",\n                \"/\",\n                body=chunks,\n                headers={\"User-Agent\": SKIP_HEADER},\n                chunked=True,\n            )\n\n            ua_headers = self._get_header_lines(b\"user-agent\")\n            assert len(ua_headers) == 0\n\n    def test_provides_default_transfer_encoding_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\"GET\", \"/\", body=chunks, chunked=True)\n\n            te_headers = self._get_header_lines(b\"transfer-encoding\")\n            assert len(te_headers) == 1\n\n    def test_preserve_transfer_encoding_header(self) -> None:\n        self.start_chunked_handler()\n        chunks = [b\"foo\", b\"bar\", b\"\", b\"bazzzzzzzzzzzzzzzzzzzzzz\"]\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            pool.urlopen(\n                \"GET\",\n                \"/\",\n                body=chunks,\n                headers={\"transfer-Encoding\": \"test-transfer-encoding\"},\n                chunked=True,\n            )\n\n            te_headers = self._get_header_lines(b\"transfer-encoding\")\n            # Validate that there is only one Transfer-Encoding header.\n            assert len(te_headers) == 1\n            # Validate that the existing Transfer-Encoding header is the one that\n            # was provided.\n            assert te_headers[0] == b\"transfer-encoding: test-transfer-encoding\"\n\n    def test_preserve_chunked_on_retry_after(self) -> None:\n        self.chunked_requests = 0\n        self.socks: list[socket.socket] = []\n\n        def socket_handler(listener: socket.socket) -> None:\n            for _ in range(2):\n                sock = listener.accept()[0]\n                self.socks.append(sock)\n                request = consume_socket(sock)\n                if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                    self.chunked_requests += 1\n\n                sock.send(\n                    b\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n                    b\"Content-Type: text/plain\\r\\n\"\n                    b\"Retry-After: 1\\r\\n\"\n                    b\"Content-Length: 0\\r\\n\"\n                    b\"Connection: close\\r\\n\"\n                    b\"\\r\\n\"\n                )\n\n        self._start_server(socket_handler)\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            retries = Retry(total=1)\n            pool.urlopen(\"GET\", \"/\", chunked=True, retries=retries)\n            for sock in self.socks:\n                sock.close()\n        assert self.chunked_requests == 2\n\n    def test_preserve_chunked_on_redirect(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        self.chunked_requests = 0\n\n        def socket_handler(listener: socket.socket) -> None:\n            for i in range(2):\n                sock = listener.accept()[0]\n                request = ConnectionMarker.consume_request(sock)\n                if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                    self.chunked_requests += 1\n\n                if i == 0:\n                    sock.sendall(\n                        b\"HTTP/1.1 301 Moved Permanently\\r\\n\"\n                        b\"Location: /redirect\\r\\n\\r\\n\"\n                    )\n                else:\n                    sock.sendall(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\")\n                sock.close()\n\n        self._start_server(socket_handler)\n        with ConnectionMarker.mark(monkeypatch):\n            with HTTPConnectionPool(self.host, self.port) as pool:\n                retries = Retry(redirect=1)\n                pool.urlopen(\n                    \"GET\", \"/\", chunked=True, preload_content=False, retries=retries\n                )\n        assert self.chunked_requests == 2\n\n    def test_preserve_chunked_on_broken_connection(\n        self, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        self.chunked_requests = 0\n\n        def socket_handler(listener: socket.socket) -> None:\n            for i in range(2):\n                sock = listener.accept()[0]\n                request = ConnectionMarker.consume_request(sock)\n                if b\"Transfer-Encoding: chunked\" in request.split(b\"\\r\\n\"):\n                    self.chunked_requests += 1\n\n                if i == 0:\n                    # Bad HTTP version will trigger a connection close\n                    sock.sendall(b\"HTTP/0.5 200 OK\\r\\n\\r\\n\")\n                else:\n                    sock.sendall(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\")\n                sock.close()\n\n        self._start_server(socket_handler)\n        with ConnectionMarker.mark(monkeypatch):\n            with HTTPConnectionPool(self.host, self.port) as pool:\n                retries = Retry(read=1)\n                pool.urlopen(\n                    \"GET\", \"/\", chunked=True, preload_content=False, retries=retries\n                )\n            assert self.chunked_requests == 2\n", "test/with_dummyserver/test_no_ssl.py": "\"\"\"\nTest connections without the builtin ssl module\n\nNote: Import urllib3 inside the test functions to get the importblocker to work\n\"\"\"\nfrom __future__ import annotations\n\nimport pytest\n\nimport urllib3\nfrom dummyserver.testcase import (\n    HTTPSHypercornDummyServerTestCase,\n    HypercornDummyServerTestCase,\n)\nfrom urllib3.exceptions import InsecureRequestWarning\n\nfrom ..test_no_ssl import TestWithoutSSL\n\n\nclass TestHTTPWithoutSSL(HypercornDummyServerTestCase, TestWithoutSSL):\n    def test_simple(self) -> None:\n        with urllib3.HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n\n\nclass TestHTTPSWithoutSSL(HTTPSHypercornDummyServerTestCase, TestWithoutSSL):\n    def test_simple(self) -> None:\n        with urllib3.HTTPSConnectionPool(\n            self.host, self.port, cert_reqs=\"NONE\"\n        ) as pool:\n            with pytest.warns(InsecureRequestWarning):\n                try:\n                    pool.request(\"GET\", \"/\")\n                except urllib3.exceptions.SSLError as e:\n                    assert \"SSL module is not available\" in str(e)\n", "test/with_dummyserver/__init__.py": "", "test/with_dummyserver/test_connectionpool.py": "from __future__ import annotations\n\nimport io\nimport socket\nimport time\nimport typing\nimport warnings\nfrom test import LONG_TIMEOUT, SHORT_TIMEOUT\nfrom threading import Event\nfrom unittest import mock\nfrom urllib.parse import urlencode\n\nimport pytest\n\nfrom dummyserver.socketserver import NoIPv6Warning\nfrom dummyserver.testcase import HypercornDummyServerTestCase, SocketDummyServerTestCase\nfrom urllib3 import HTTPConnectionPool, encode_multipart_formdata\nfrom urllib3._collections import HTTPHeaderDict\nfrom urllib3.connection import _get_default_user_agent\nfrom urllib3.exceptions import (\n    ConnectTimeoutError,\n    DecodeError,\n    EmptyPoolError,\n    MaxRetryError,\n    NameResolutionError,\n    NewConnectionError,\n    ReadTimeoutError,\n    UnrewindableBodyError,\n)\nfrom urllib3.fields import _TYPE_FIELD_VALUE_TUPLE\nfrom urllib3.util import SKIP_HEADER, SKIPPABLE_HEADERS\nfrom urllib3.util.retry import RequestHistory, Retry\nfrom urllib3.util.timeout import _TYPE_TIMEOUT, Timeout\n\nfrom .. import INVALID_SOURCE_ADDRESSES, TARPIT_HOST, VALID_SOURCE_ADDRESSES\nfrom ..port_helpers import find_unused_port\n\n\ndef wait_for_socket(ready_event: Event) -> None:\n    ready_event.wait()\n    ready_event.clear()\n\n\nclass TestConnectionPoolTimeouts(SocketDummyServerTestCase):\n    def test_timeout_float(self) -> None:\n        block_event = Event()\n        ready_event = self.start_basic_handler(block_send=block_event, num=2)\n\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            wait_for_socket(ready_event)\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\", timeout=SHORT_TIMEOUT)\n            block_event.set()  # Release block\n\n            # Shouldn't raise this time\n            wait_for_socket(ready_event)\n            block_event.set()  # Pre-release block\n            pool.request(\"GET\", \"/\", timeout=LONG_TIMEOUT)\n\n    def test_conn_closed(self) -> None:\n        block_event = Event()\n        self.start_basic_handler(block_send=block_event, num=1)\n\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=SHORT_TIMEOUT, retries=False\n        ) as pool:\n            conn = pool._get_conn()\n            pool._put_conn(conn)\n            try:\n                with pytest.raises(ReadTimeoutError):\n                    pool.urlopen(\"GET\", \"/\")\n                if not conn.is_closed:\n                    with pytest.raises(socket.error):\n                        conn.sock.recv(1024)  # type: ignore[attr-defined]\n            finally:\n                pool._put_conn(conn)\n\n            block_event.set()\n\n    def test_timeout(self) -> None:\n        # Requests should time out when expected\n        block_event = Event()\n        ready_event = self.start_basic_handler(block_send=block_event, num=3)\n\n        # Pool-global timeout\n        short_timeout = Timeout(read=SHORT_TIMEOUT)\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=short_timeout, retries=False\n        ) as pool:\n            wait_for_socket(ready_event)\n            block_event.clear()\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\")\n            block_event.set()  # Release request\n\n        # Request-specific timeouts should raise errors\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=short_timeout, retries=False\n        ) as pool:\n            wait_for_socket(ready_event)\n            now = time.perf_counter()\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\", timeout=LONG_TIMEOUT)\n            delta = time.perf_counter() - now\n\n            message = \"timeout was pool-level SHORT_TIMEOUT rather than request-level LONG_TIMEOUT\"\n            assert delta >= (LONG_TIMEOUT - 1e-5), message\n            block_event.set()  # Release request\n\n            # Timeout passed directly to request should raise a request timeout\n            wait_for_socket(ready_event)\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\", timeout=SHORT_TIMEOUT)\n            block_event.set()  # Release request\n\n    def test_connect_timeout(self) -> None:\n        url = \"/\"\n        host, port = TARPIT_HOST, 80\n        timeout = Timeout(connect=SHORT_TIMEOUT)\n\n        # Pool-global timeout\n        with HTTPConnectionPool(host, port, timeout=timeout) as pool:\n            conn = pool._get_conn()\n            with pytest.raises(ConnectTimeoutError):\n                pool._make_request(conn, \"GET\", url)\n\n            # Retries\n            retries = Retry(connect=0)\n            with pytest.raises(MaxRetryError):\n                pool.request(\"GET\", url, retries=retries)\n\n        # Request-specific connection timeouts\n        big_timeout = Timeout(read=LONG_TIMEOUT, connect=LONG_TIMEOUT)\n        with HTTPConnectionPool(host, port, timeout=big_timeout, retries=False) as pool:\n            conn = pool._get_conn()\n            with pytest.raises(ConnectTimeoutError):\n                pool._make_request(conn, \"GET\", url, timeout=timeout)\n\n            pool._put_conn(conn)\n            with pytest.raises(ConnectTimeoutError):\n                pool.request(\"GET\", url, timeout=timeout)\n\n    def test_total_applies_connect(self) -> None:\n        host, port = TARPIT_HOST, 80\n\n        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)\n        with HTTPConnectionPool(host, port, timeout=timeout) as pool:\n            conn = pool._get_conn()\n            try:\n                with pytest.raises(ConnectTimeoutError):\n                    pool._make_request(conn, \"GET\", \"/\")\n            finally:\n                conn.close()\n\n        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)\n        with HTTPConnectionPool(host, port, timeout=timeout) as pool:\n            conn = pool._get_conn()\n            try:\n                with pytest.raises(ConnectTimeoutError):\n                    pool._make_request(conn, \"GET\", \"/\")\n            finally:\n                conn.close()\n\n    def test_total_timeout(self) -> None:\n        block_event = Event()\n        ready_event = self.start_basic_handler(block_send=block_event, num=2)\n\n        wait_for_socket(ready_event)\n        # This will get the socket to raise an EAGAIN on the read\n        timeout = Timeout(connect=3, read=SHORT_TIMEOUT)\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=timeout, retries=False\n        ) as pool:\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\")\n\n            block_event.set()\n            wait_for_socket(ready_event)\n            block_event.clear()\n\n        # The connect should succeed and this should hit the read timeout\n        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)\n        with HTTPConnectionPool(\n            self.host, self.port, timeout=timeout, retries=False\n        ) as pool:\n            with pytest.raises(ReadTimeoutError):\n                pool.request(\"GET\", \"/\")\n\n    def test_create_connection_timeout(self) -> None:\n        self.start_basic_handler(block_send=Event(), num=0)  # needed for self.port\n\n        timeout = Timeout(connect=SHORT_TIMEOUT, total=LONG_TIMEOUT)\n        with HTTPConnectionPool(\n            TARPIT_HOST, self.port, timeout=timeout, retries=False\n        ) as pool:\n            conn = pool._new_conn()\n            with pytest.raises(ConnectTimeoutError):\n                conn.connect()\n\n\nclass TestConnectionPool(HypercornDummyServerTestCase):\n    def test_get(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/specific_method\", fields={\"method\": \"GET\"})\n            assert r.status == 200, r.data\n\n    def test_post_url(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"POST\", \"/specific_method\", fields={\"method\": \"POST\"})\n            assert r.status == 200, r.data\n\n    def test_urlopen_put(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.urlopen(\"PUT\", \"/specific_method?method=PUT\")\n            assert r.status == 200, r.data\n\n    def test_wrong_specific_method(self) -> None:\n        # To make sure the dummy server is actually returning failed responses\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/specific_method\", fields={\"method\": \"POST\"})\n            assert r.status == 400, r.data\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"POST\", \"/specific_method\", fields={\"method\": \"GET\"})\n            assert r.status == 400, r.data\n\n    def test_upload(self) -> None:\n        data = \"I'm in ur multipart form-data, hazing a cheezburgr\"\n        fields: dict[str, _TYPE_FIELD_VALUE_TUPLE] = {\n            \"upload_param\": \"filefield\",\n            \"upload_filename\": \"lolcat.txt\",\n            \"filefield\": (\"lolcat.txt\", data),\n        }\n        fields[\"upload_size\"] = len(data)  # type: ignore[assignment]\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"POST\", \"/upload\", fields=fields)\n            assert r.status == 200, r.data\n\n    def test_one_name_multiple_values(self) -> None:\n        fields = [(\"foo\", \"a\"), (\"foo\", \"b\")]\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # urlencode\n            r = pool.request(\"GET\", \"/echo\", fields=fields)\n            assert r.data == b\"foo=a&foo=b\"\n\n            # multipart\n            r = pool.request(\"POST\", \"/echo\", fields=fields)\n            assert r.data.count(b'name=\"foo\"') == 2\n\n    def test_request_method_body(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            body = b\"hi\"\n            r = pool.request(\"POST\", \"/echo\", body=body)\n            assert r.data == body\n\n            fields = [(\"hi\", \"hello\")]\n            with pytest.raises(TypeError):\n                pool.request(\"POST\", \"/echo\", body=body, fields=fields)\n\n    def test_unicode_upload(self) -> None:\n        fieldname = \"myfile\"\n        filename = \"\\xe2\\x99\\xa5.txt\"\n        data = \"\\xe2\\x99\\xa5\".encode()\n        size = len(data)\n\n        fields: dict[str, _TYPE_FIELD_VALUE_TUPLE] = {\n            \"upload_param\": fieldname,\n            \"upload_filename\": filename,\n            fieldname: (filename, data),\n        }\n        fields[\"upload_size\"] = size  # type: ignore[assignment]\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"POST\", \"/upload\", fields=fields)\n            assert r.status == 200, r.data\n\n    def test_nagle(self) -> None:\n        \"\"\"Test that connections have TCP_NODELAY turned on\"\"\"\n        # This test needs to be here in order to be run. socket.create_connection actually tries\n        # to connect to the host provided so we need a dummyserver to be running.\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            conn = pool._get_conn()\n            try:\n                pool._make_request(conn, \"GET\", \"/\")\n                tcp_nodelay_setting = conn.sock.getsockopt(  # type: ignore[attr-defined]\n                    socket.IPPROTO_TCP, socket.TCP_NODELAY\n                )\n                assert tcp_nodelay_setting\n            finally:\n                conn.close()\n\n    @pytest.mark.parametrize(\n        \"socket_options\",\n        [\n            [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)],\n            ((socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),),\n        ],\n    )\n    def test_socket_options(self, socket_options: tuple[int, int, int]) -> None:\n        \"\"\"Test that connections accept socket options.\"\"\"\n        # This test needs to be here in order to be run. socket.create_connection actually tries to\n        # connect to the host provided so we need a dummyserver to be running.\n        with HTTPConnectionPool(\n            self.host,\n            self.port,\n            socket_options=socket_options,\n        ) as pool:\n            # Get the socket of a new connection.\n            s = pool._new_conn()._new_conn()  # type: ignore[attr-defined]\n            try:\n                using_keepalive = (\n                    s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0\n                )\n                assert using_keepalive\n            finally:\n                s.close()\n\n    @pytest.mark.parametrize(\"socket_options\", [None, []])\n    def test_disable_default_socket_options(\n        self, socket_options: list[int] | None\n    ) -> None:\n        \"\"\"Test that passing None or empty list disables all socket options.\"\"\"\n        # This test needs to be here in order to be run. socket.create_connection actually tries\n        # to connect to the host provided so we need a dummyserver to be running.\n        with HTTPConnectionPool(\n            self.host, self.port, socket_options=socket_options\n        ) as pool:\n            s = pool._new_conn()._new_conn()  # type: ignore[attr-defined]\n            try:\n                using_nagle = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) == 0\n                assert using_nagle\n            finally:\n                s.close()\n\n    def test_defaults_are_applied(self) -> None:\n        \"\"\"Test that modifying the default socket options works.\"\"\"\n        # This test needs to be here in order to be run. socket.create_connection actually tries\n        # to connect to the host provided so we need a dummyserver to be running.\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # Get the HTTPConnection instance\n            conn = pool._new_conn()\n            try:\n                # Update the default socket options\n                assert conn.socket_options is not None\n                conn.socket_options += [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]  # type: ignore[operator]\n                s = conn._new_conn()  # type: ignore[attr-defined]\n                nagle_disabled = (\n                    s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) > 0\n                )\n                using_keepalive = (\n                    s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0\n                )\n                assert nagle_disabled\n                assert using_keepalive\n            finally:\n                conn.close()\n                s.close()\n\n    def test_connection_error_retries(self) -> None:\n        \"\"\"ECONNREFUSED error should raise a connection error, with retries\"\"\"\n        port = find_unused_port()\n        with HTTPConnectionPool(self.host, port) as pool:\n            with pytest.raises(MaxRetryError) as e:\n                pool.request(\"GET\", \"/\", retries=Retry(connect=3))\n            assert type(e.value.reason) is NewConnectionError\n\n    def test_timeout_success(self) -> None:\n        timeout = Timeout(connect=3, read=5, total=None)\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            pool.request(\"GET\", \"/\")\n            # This should not raise a \"Timeout already started\" error\n            pool.request(\"GET\", \"/\")\n\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            # This should also not raise a \"Timeout already started\" error\n            pool.request(\"GET\", \"/\")\n\n        timeout = Timeout(total=None)\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            pool.request(\"GET\", \"/\")\n\n    socket_timeout_reuse_testdata = pytest.mark.parametrize(\n        [\"timeout\", \"expect_settimeout_calls\"],\n        [\n            (1, (1, 1)),\n            (None, (None, None)),\n            (Timeout(read=4), (None, 4)),\n            (Timeout(read=4, connect=5), (5, 4)),\n            (Timeout(connect=6), (6, None)),\n        ],\n    )\n\n    @socket_timeout_reuse_testdata\n    def test_socket_timeout_updated_on_reuse_constructor(\n        self,\n        timeout: _TYPE_TIMEOUT,\n        expect_settimeout_calls: typing.Sequence[float | None],\n    ) -> None:\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            # Make a request to create a new connection.\n            pool.urlopen(\"GET\", \"/\")\n\n            # Grab the connection and mock the inner socket.\n            assert pool.pool is not None\n            conn = pool.pool.get_nowait()\n            conn_sock = mock.Mock(wraps=conn.sock)\n            conn.sock = conn_sock\n            pool._put_conn(conn)\n\n            # Assert that sock.settimeout() is called with the new connect timeout, then the read timeout.\n            pool.urlopen(\"GET\", \"/\", timeout=timeout)\n            conn_sock.settimeout.assert_has_calls(\n                [mock.call(x) for x in expect_settimeout_calls]\n            )\n\n    @socket_timeout_reuse_testdata\n    def test_socket_timeout_updated_on_reuse_parameter(\n        self,\n        timeout: _TYPE_TIMEOUT,\n        expect_settimeout_calls: typing.Sequence[float | None],\n    ) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # Make a request to create a new connection.\n            pool.urlopen(\"GET\", \"/\", timeout=LONG_TIMEOUT)\n\n            # Grab the connection and mock the inner socket.\n            assert pool.pool is not None\n            conn = pool.pool.get_nowait()\n            conn_sock = mock.Mock(wraps=conn.sock)\n            conn.sock = conn_sock\n            pool._put_conn(conn)\n\n            # Assert that sock.settimeout() is called with the new connect timeout, then the read timeout.\n            pool.urlopen(\"GET\", \"/\", timeout=timeout)\n            conn_sock.settimeout.assert_has_calls(\n                [mock.call(x) for x in expect_settimeout_calls]\n            )\n\n    def test_tunnel(self) -> None:\n        # note the actual httplib.py has no tests for this functionality\n        timeout = Timeout(total=None)\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            conn = pool._get_conn()\n            try:\n                conn.set_tunnel(self.host, self.port)\n                with mock.patch.object(\n                    conn, \"_tunnel\", create=True, return_value=None\n                ) as conn_tunnel:\n                    pool._make_request(conn, \"GET\", \"/\")\n                conn_tunnel.assert_called_once_with()\n            finally:\n                conn.close()\n\n        # test that it's not called when tunnel is not set\n        timeout = Timeout(total=None)\n        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:\n            conn = pool._get_conn()\n            try:\n                with mock.patch.object(\n                    conn, \"_tunnel\", create=True, return_value=None\n                ) as conn_tunnel:\n                    pool._make_request(conn, \"GET\", \"/\")\n                assert not conn_tunnel.called\n            finally:\n                conn.close()\n\n    def test_redirect_relative_url_no_deprecation(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"error\", DeprecationWarning)\n                pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"})\n\n    def test_redirect(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"}, redirect=False)\n            assert r.status == 303\n\n            r = pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"})\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_303_redirect_makes_request_lose_body(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\n                \"POST\",\n                \"/redirect\",\n                fields={\"target\": \"/headers_and_params\", \"status\": \"303 See Other\"},\n            )\n        data = response.json()\n        assert data[\"params\"] == {}\n        assert \"Content-Type\" not in HTTPHeaderDict(data[\"headers\"])\n\n    def test_bad_connect(self) -> None:\n        with HTTPConnectionPool(\"badhost.invalid\", self.port) as pool:\n            with pytest.raises(MaxRetryError) as e:\n                pool.request(\"GET\", \"/\", retries=5)\n            assert type(e.value.reason) is NameResolutionError\n\n    def test_keepalive(self) -> None:\n        with HTTPConnectionPool(self.host, self.port, block=True, maxsize=1) as pool:\n            r = pool.request(\"GET\", \"/keepalive?close=0\")\n            r = pool.request(\"GET\", \"/keepalive?close=0\")\n\n            assert r.status == 200\n            assert pool.num_connections == 1\n            assert pool.num_requests == 2\n\n    def test_keepalive_close(self) -> None:\n        with HTTPConnectionPool(\n            self.host, self.port, block=True, maxsize=1, timeout=2\n        ) as pool:\n            r = pool.request(\n                \"GET\", \"/keepalive?close=1\", retries=0, headers={\"Connection\": \"close\"}\n            )\n\n            assert pool.num_connections == 1\n\n            # The dummyserver will have responded with Connection:close,\n            # and httplib will properly cleanup the socket.\n\n            # We grab the HTTPConnection object straight from the Queue,\n            # because _get_conn() is where the check & reset occurs\n            assert pool.pool is not None\n            conn = pool.pool.get()\n            assert conn.sock is None\n            pool._put_conn(conn)\n\n            # Now with keep-alive\n            r = pool.request(\n                \"GET\",\n                \"/keepalive?close=0\",\n                retries=0,\n                headers={\"Connection\": \"keep-alive\"},\n            )\n\n            # The dummyserver responded with Connection:keep-alive, the connection\n            # persists.\n            conn = pool.pool.get()\n            assert conn.sock is not None\n            pool._put_conn(conn)\n\n            # Another request asking the server to close the connection. This one\n            # should get cleaned up for the next request.\n            r = pool.request(\n                \"GET\", \"/keepalive?close=1\", retries=0, headers={\"Connection\": \"close\"}\n            )\n\n            assert r.status == 200\n\n            conn = pool.pool.get()\n            assert conn.sock is None\n            pool._put_conn(conn)\n\n            # Next request\n            r = pool.request(\"GET\", \"/keepalive?close=0\")\n\n    def test_post_with_urlencode(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            data = {\"banana\": \"hammock\", \"lol\": \"cat\"}\n            r = pool.request(\"POST\", \"/echo\", fields=data, encode_multipart=False)\n            assert r.data.decode(\"utf-8\") == urlencode(data)\n\n    def test_post_with_multipart(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            data = {\"banana\": \"hammock\", \"lol\": \"cat\"}\n            r = pool.request(\"POST\", \"/echo\", fields=data, encode_multipart=True)\n            body = r.data.split(b\"\\r\\n\")\n\n            encoded_data = encode_multipart_formdata(data)[0]\n            expected_body = encoded_data.split(b\"\\r\\n\")\n\n            # TODO: Get rid of extra parsing stuff when you can specify\n            # a custom boundary to encode_multipart_formdata\n            \"\"\"\n            We need to loop the return lines because a timestamp is attached\n            from within encode_multipart_formdata. When the server echos back\n            the data, it has the timestamp from when the data was encoded, which\n            is not equivalent to when we run encode_multipart_formdata on\n            the data again.\n            \"\"\"\n            for i, line in enumerate(body):\n                if line.startswith(b\"--\"):\n                    continue\n\n                assert body[i] == expected_body[i]\n\n    def test_post_with_multipart__iter__(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            data = {\"hello\": \"world\"}\n            r = pool.request(\n                \"POST\",\n                \"/echo\",\n                fields=data,\n                preload_content=False,\n                multipart_boundary=\"boundary\",\n                encode_multipart=True,\n            )\n\n            chunks = [chunk for chunk in r]\n            assert chunks == [\n                b\"--boundary\\r\\n\",\n                b'Content-Disposition: form-data; name=\"hello\"\\r\\n',\n                b\"\\r\\n\",\n                b\"world\\r\\n\",\n                b\"--boundary--\\r\\n\",\n            ]\n\n    def test_check_gzip(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\n                \"GET\", \"/encodingrequest\", headers={\"accept-encoding\": \"gzip\"}\n            )\n            assert r.headers.get(\"content-encoding\") == \"gzip\"\n            assert r.data == b\"hello, world!\"\n\n    def test_check_deflate(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\n                \"GET\", \"/encodingrequest\", headers={\"accept-encoding\": \"deflate\"}\n            )\n            assert r.headers.get(\"content-encoding\") == \"deflate\"\n            assert r.data == b\"hello, world!\"\n\n    def test_bad_decode(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            with pytest.raises(DecodeError):\n                pool.request(\n                    \"GET\",\n                    \"/encodingrequest\",\n                    headers={\"accept-encoding\": \"garbage-deflate\"},\n                )\n\n            with pytest.raises(DecodeError):\n                pool.request(\n                    \"GET\",\n                    \"/encodingrequest\",\n                    headers={\"accept-encoding\": \"garbage-gzip\"},\n                )\n\n    def test_connection_count(self) -> None:\n        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:\n            pool.request(\"GET\", \"/\")\n            pool.request(\"GET\", \"/\")\n            pool.request(\"GET\", \"/\")\n\n            assert pool.num_connections == 1\n            assert pool.num_requests == 3\n\n    def test_connection_count_bigpool(self) -> None:\n        with HTTPConnectionPool(self.host, self.port, maxsize=16) as http_pool:\n            http_pool.request(\"GET\", \"/\")\n            http_pool.request(\"GET\", \"/\")\n            http_pool.request(\"GET\", \"/\")\n\n            assert http_pool.num_connections == 1\n            assert http_pool.num_requests == 3\n\n    def test_partial_response(self) -> None:\n        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:\n            req_data = {\"lol\": \"cat\"}\n            resp_data = urlencode(req_data).encode(\"utf-8\")\n\n            r = pool.request(\"GET\", \"/echo\", fields=req_data, preload_content=False)\n\n            assert r.read(5) == resp_data[:5]\n            assert r.read() == resp_data[5:]\n\n    def test_lazy_load_twice(self) -> None:\n        # This test is sad and confusing. Need to figure out what's\n        # going on with partial reads and socket reuse.\n\n        with HTTPConnectionPool(\n            self.host, self.port, block=True, maxsize=1, timeout=2\n        ) as pool:\n            payload_size = 1024 * 2\n            first_chunk = 512\n\n            boundary = \"foo\"\n\n            req_data = {\"count\": \"a\" * payload_size}\n            resp_data = encode_multipart_formdata(req_data, boundary=boundary)[0]\n\n            req2_data = {\"count\": \"b\" * payload_size}\n            resp2_data = encode_multipart_formdata(req2_data, boundary=boundary)[0]\n\n            r1 = pool.request(\n                \"POST\",\n                \"/echo\",\n                fields=req_data,\n                multipart_boundary=boundary,\n                preload_content=False,\n            )\n\n            assert r1.read(first_chunk) == resp_data[:first_chunk]\n\n            try:\n                r2 = pool.request(\n                    \"POST\",\n                    \"/echo\",\n                    fields=req2_data,\n                    multipart_boundary=boundary,\n                    preload_content=False,\n                    pool_timeout=0.001,\n                )\n\n                # This branch should generally bail here, but maybe someday it will\n                # work? Perhaps by some sort of magic. Consider it a TODO.\n\n                assert r2.read(first_chunk) == resp2_data[:first_chunk]\n\n                assert r1.read() == resp_data[first_chunk:]\n                assert r2.read() == resp2_data[first_chunk:]\n                assert pool.num_requests == 2\n\n            except EmptyPoolError:\n                assert r1.read() == resp_data[first_chunk:]\n                assert pool.num_requests == 1\n\n            assert pool.num_connections == 1\n\n    def test_for_double_release(self) -> None:\n        MAXSIZE = 5\n\n        # Check default state\n        with HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE) as pool:\n            assert pool.num_connections == 0\n            assert pool.pool is not None\n            assert pool.pool.qsize() == MAXSIZE\n\n            # Make an empty slot for testing\n            pool.pool.get()\n            assert pool.pool.qsize() == MAXSIZE - 1\n\n            # Check state after simple request\n            pool.urlopen(\"GET\", \"/\")\n            assert pool.pool.qsize() == MAXSIZE - 1\n\n            # Check state without release\n            pool.urlopen(\"GET\", \"/\", preload_content=False)\n            assert pool.pool.qsize() == MAXSIZE - 2\n\n            pool.urlopen(\"GET\", \"/\")\n            assert pool.pool.qsize() == MAXSIZE - 2\n\n            # Check state after read\n            pool.urlopen(\"GET\", \"/\").data\n            assert pool.pool.qsize() == MAXSIZE - 2\n\n            pool.urlopen(\"GET\", \"/\")\n            assert pool.pool.qsize() == MAXSIZE - 2\n\n    def test_release_conn_parameter(self) -> None:\n        MAXSIZE = 5\n        with HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE) as pool:\n            assert pool.pool is not None\n            assert pool.pool.qsize() == MAXSIZE\n\n            # Make request without releasing connection\n            pool.request(\"GET\", \"/\", release_conn=False, preload_content=False)\n            assert pool.pool.qsize() == MAXSIZE - 1\n\n    def test_dns_error(self) -> None:\n        with HTTPConnectionPool(\n            \"thishostdoesnotexist.invalid\", self.port, timeout=0.001\n        ) as pool:\n            with pytest.raises(MaxRetryError):\n                pool.request(\"GET\", \"/test\", retries=2)\n\n    @pytest.mark.parametrize(\"char\", [\" \", \"\\r\", \"\\n\", \"\\x00\"])\n    def test_invalid_method_not_allowed(self, char: str) -> None:\n        with pytest.raises(ValueError):\n            with HTTPConnectionPool(self.host, self.port) as pool:\n                pool.request(\"GET\" + char, \"/\")\n\n    def test_percent_encode_invalid_target_chars(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/echo_params?q=\\r&k=\\n \\n\")\n            assert r.data == b\"[('k', '\\\\n \\\\n'), ('q', '\\\\r')]\"\n\n    def test_source_address(self) -> None:\n        for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:\n            if is_ipv6:\n                # TODO enable if HAS_IPV6_AND_DNS when this is fixed:\n                # https://github.com/pgjones/hypercorn/issues/160\n                warnings.warn(\"No IPv6 support: skipping.\", NoIPv6Warning)\n                continue\n            with HTTPConnectionPool(\n                self.host, self.port, source_address=addr, retries=False\n            ) as pool:\n                r = pool.request(\"GET\", \"/source_address\")\n                assert r.data == addr[0].encode()\n\n    @pytest.mark.parametrize(\n        \"invalid_source_address, is_ipv6\", INVALID_SOURCE_ADDRESSES\n    )\n    def test_source_address_error(\n        self, invalid_source_address: tuple[str, int], is_ipv6: bool\n    ) -> None:\n        with HTTPConnectionPool(\n            self.host, self.port, source_address=invalid_source_address, retries=False\n        ) as pool:\n            if is_ipv6:\n                with pytest.raises(NameResolutionError):\n                    pool.request(\"GET\", f\"/source_address?{invalid_source_address}\")\n            else:\n                with pytest.raises(NewConnectionError):\n                    pool.request(\"GET\", f\"/source_address?{invalid_source_address}\")\n\n    def test_stream_keepalive(self) -> None:\n        x = 2\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            for _ in range(x):\n                response = pool.request(\n                    \"GET\",\n                    \"/chunked\",\n                    headers={\"Connection\": \"keep-alive\"},\n                    preload_content=False,\n                    retries=False,\n                )\n                for chunk in response.stream():\n                    assert chunk == b\"123\"\n\n            assert pool.num_connections == 1\n            assert pool.num_requests == x\n\n    def test_read_chunked_short_circuit(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/chunked\", preload_content=False)\n            response.read()\n            with pytest.raises(StopIteration):\n                next(response.read_chunked())\n\n    def test_read_chunked_on_closed_response(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/chunked\", preload_content=False)\n            response.close()\n            with pytest.raises(StopIteration):\n                next(response.read_chunked())\n\n    def test_chunked_gzip(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\n                \"GET\", \"/chunked_gzip\", preload_content=False, decode_content=True\n            )\n\n            assert b\"123\" * 4 == response.read()\n\n    def test_cleanup_on_connection_error(self) -> None:\n        \"\"\"\n        Test that connections are recycled to the pool on\n        connection errors where no http response is received.\n        \"\"\"\n        poolsize = 3\n        with HTTPConnectionPool(\n            self.host, self.port, maxsize=poolsize, block=True\n        ) as http:\n            assert http.pool is not None\n            assert http.pool.qsize() == poolsize\n\n            # force a connection error by supplying a non-existent\n            # url. We won't get a response for this  and so the\n            # conn won't be implicitly returned to the pool.\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    \"/redirect\",\n                    fields={\"target\": \"/\"},\n                    release_conn=False,\n                    retries=0,\n                )\n\n            r = http.request(\n                \"GET\",\n                \"/redirect\",\n                fields={\"target\": \"/\"},\n                release_conn=False,\n                retries=1,\n            )\n            r.release_conn()\n\n            # the pool should still contain poolsize elements\n            assert http.pool.qsize() == http.pool.maxsize\n\n    def test_mixed_case_hostname(self) -> None:\n        with HTTPConnectionPool(\"LoCaLhOsT\", self.port) as pool:\n            response = pool.request(\"GET\", f\"http://LoCaLhOsT:{self.port}/\")\n            assert response.status == 200\n\n    def test_preserves_path_dot_segments(self) -> None:\n        \"\"\"ConnectionPool preserves dot segments in the URI\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            response = pool.request(\"GET\", \"/echo_uri/seg0/../seg2\")\n            assert response.data == b\"/echo_uri/seg0/../seg2?\"\n\n    def test_default_user_agent_header(self) -> None:\n        \"\"\"ConnectionPool has a default user agent\"\"\"\n        default_ua = _get_default_user_agent()\n        custom_ua = \"I'm not a web scraper, what are you talking about?\"\n        custom_ua2 = \"Yet Another User Agent\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # Use default user agent if no user agent was specified.\n            r = pool.request(\"GET\", \"/headers\")\n            request_headers = r.json()\n            assert request_headers.get(\"User-Agent\") == _get_default_user_agent()\n\n            # Prefer the request user agent over the default.\n            headers = {\"UsEr-AGENt\": custom_ua}\n            r = pool.request(\"GET\", \"/headers\", headers=headers)\n            request_headers = r.json()\n            assert request_headers.get(\"User-Agent\") == custom_ua\n\n            # Do not modify pool headers when using the default user agent.\n            pool_headers = {\"foo\": \"bar\"}\n            pool.headers = pool_headers\n            r = pool.request(\"GET\", \"/headers\")\n            request_headers = r.json()\n            assert request_headers.get(\"User-Agent\") == default_ua\n            assert \"User-Agent\" not in pool_headers\n\n            pool.headers.update({\"User-Agent\": custom_ua2})\n            r = pool.request(\"GET\", \"/headers\")\n            request_headers = r.json()\n            assert request_headers.get(\"User-Agent\") == custom_ua2\n\n    @pytest.mark.parametrize(\n        \"headers\",\n        [\n            None,\n            {},\n            {\"User-Agent\": \"key\"},\n            {\"user-agent\": \"key\"},\n            {b\"uSeR-AgEnT\": b\"key\"},\n            {b\"user-agent\": \"key\"},\n        ],\n    )\n    @pytest.mark.parametrize(\"chunked\", [True, False])\n    def test_user_agent_header_not_sent_twice(\n        self, headers: dict[str, str] | None, chunked: bool\n    ) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/headers\", headers=headers, chunked=chunked)\n            request_headers = r.json()\n\n            if not headers:\n                assert request_headers[\"User-Agent\"].startswith(\"python-urllib3/\")\n                assert \"key\" not in request_headers[\"User-Agent\"]\n            else:\n                assert request_headers[\"User-Agent\"] == \"key\"\n\n    def test_no_user_agent_header(self) -> None:\n        \"\"\"ConnectionPool can suppress sending a user agent header\"\"\"\n        custom_ua = \"I'm not a web scraper, what are you talking about?\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            # Suppress user agent in the request headers.\n            no_ua_headers = {\"User-Agent\": SKIP_HEADER}\n            r = pool.request(\"GET\", \"/headers\", headers=no_ua_headers)\n            request_headers = r.json()\n            assert \"User-Agent\" not in request_headers\n            assert no_ua_headers[\"User-Agent\"] == SKIP_HEADER\n\n            # Suppress user agent in the pool headers.\n            pool.headers = no_ua_headers\n            r = pool.request(\"GET\", \"/headers\")\n            request_headers = r.json()\n            assert \"User-Agent\" not in request_headers\n            assert no_ua_headers[\"User-Agent\"] == SKIP_HEADER\n\n            # Request headers override pool headers.\n            pool_headers = {\"User-Agent\": custom_ua}\n            pool.headers = pool_headers\n            r = pool.request(\"GET\", \"/headers\", headers=no_ua_headers)\n            request_headers = r.json()\n            assert \"User-Agent\" not in request_headers\n            assert no_ua_headers[\"User-Agent\"] == SKIP_HEADER\n            assert pool_headers.get(\"User-Agent\") == custom_ua\n\n    @pytest.mark.parametrize(\"header\", [\"Content-Length\", \"content-length\"])\n    @pytest.mark.parametrize(\"chunked\", [True, False])\n    def test_skip_header_non_supported(self, header: str, chunked: bool) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            with pytest.raises(\n                ValueError,\n                match=\"urllib3.util.SKIP_HEADER only supports 'Accept-Encoding', 'Host', 'User-Agent'\",\n            ) as e:\n                pool.request(\n                    \"GET\", \"/headers\", headers={header: SKIP_HEADER}, chunked=chunked\n                )\n            # Ensure that the error message stays up to date with 'SKIP_HEADER_SUPPORTED_HEADERS'\n            assert all(\n                (\"'\" + header.title() + \"'\") in str(e.value)\n                for header in SKIPPABLE_HEADERS\n            )\n\n    @pytest.mark.parametrize(\"chunked\", [True, False])\n    @pytest.mark.parametrize(\"pool_request\", [True, False])\n    @pytest.mark.parametrize(\"header_type\", [dict, HTTPHeaderDict])\n    def test_headers_not_modified_by_request(\n        self,\n        chunked: bool,\n        pool_request: bool,\n        header_type: type[dict[str, str] | HTTPHeaderDict],\n    ) -> None:\n        # Test that the .request*() methods of ConnectionPool and HTTPConnection\n        # don't modify the given 'headers' structure, instead they should\n        # make their own internal copies at request time.\n        headers = header_type()\n        headers[\"key\"] = \"val\"\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            pool.headers = headers\n            if pool_request:\n                pool.request(\"GET\", \"/headers\", chunked=chunked)\n            else:\n                conn = pool._get_conn()\n                conn.request(\"GET\", \"/headers\", chunked=chunked)\n                conn.getresponse().close()\n                conn.close()\n\n            assert pool.headers == {\"key\": \"val\"}\n            assert type(pool.headers) is header_type\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            if pool_request:\n                pool.request(\"GET\", \"/headers\", headers=headers, chunked=chunked)\n            else:\n                conn = pool._get_conn()\n                conn.request(\"GET\", \"/headers\", headers=headers, chunked=chunked)\n                conn.getresponse().close()\n                conn.close()\n\n            assert headers == {\"key\": \"val\"}\n\n    def test_request_chunked_is_deprecated(\n        self,\n    ) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            conn = pool._get_conn()\n\n            with pytest.warns(DeprecationWarning) as w:\n                conn.request_chunked(\"GET\", \"/headers\")  # type: ignore[attr-defined]\n            assert len(w) == 1 and str(w[0].message) == (\n                \"HTTPConnection.request_chunked() is deprecated and will be removed in urllib3 v2.1.0. \"\n                \"Instead use HTTPConnection.request(..., chunked=True).\"\n            )\n\n            resp = conn.getresponse()\n            assert resp.status == 200\n            assert resp.json()[\"Transfer-Encoding\"] == \"chunked\"\n            conn.close()\n\n    def test_bytes_header(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"User-Agent\": \"test header\"}\n            r = pool.request(\"GET\", \"/headers\", headers=headers)\n            request_headers = r.json()\n            assert \"User-Agent\" in request_headers\n            assert request_headers[\"User-Agent\"] == \"test header\"\n\n    @pytest.mark.parametrize(\n        \"user_agent\", [\"Sch\u00f6nefeld/1.18.0\", \"Sch\u00f6nefeld/1.18.0\".encode(\"iso-8859-1\")]\n    )\n    def test_user_agent_non_ascii_user_agent(self, user_agent: str) -> None:\n        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:\n            r = pool.urlopen(\n                \"GET\",\n                \"/headers\",\n                headers={\"User-Agent\": user_agent},\n            )\n            request_headers = r.json()\n            assert \"User-Agent\" in request_headers\n            assert request_headers[\"User-Agent\"] == \"Sch\u00f6nefeld/1.18.0\"\n\n\nclass TestRetry(HypercornDummyServerTestCase):\n    def test_max_retry(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            with pytest.raises(MaxRetryError):\n                pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"}, retries=0)\n\n    def test_disabled_retry(self) -> None:\n        \"\"\"Disabled retries should disable redirect handling.\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"}, retries=False)\n            assert r.status == 303\n\n            r = pool.request(\n                \"GET\",\n                \"/redirect\",\n                fields={\"target\": \"/\"},\n                retries=Retry(redirect=False),\n            )\n            assert r.status == 303\n\n        with HTTPConnectionPool(\n            \"thishostdoesnotexist.invalid\", self.port, timeout=0.001\n        ) as pool:\n            with pytest.raises(NameResolutionError):\n                pool.request(\"GET\", \"/test\", retries=False)\n\n    def test_read_retries(self) -> None:\n        \"\"\"Should retry for status codes in the forcelist\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            retry = Retry(read=1, status_forcelist=[418])\n            resp = pool.request(\n                \"GET\",\n                \"/successful_retry\",\n                headers={\"test-name\": \"test_read_retries\"},\n                retries=retry,\n            )\n            assert resp.status == 200\n\n    def test_read_total_retries(self) -> None:\n        \"\"\"HTTP response w/ status code in the forcelist should be retried\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"test-name\": \"test_read_total_retries\"}\n            retry = Retry(total=1, status_forcelist=[418])\n            resp = pool.request(\n                \"GET\", \"/successful_retry\", headers=headers, retries=retry\n            )\n            assert resp.status == 200\n\n    def test_retries_wrong_forcelist(self) -> None:\n        \"\"\"HTTP response w/ status code not in forcelist shouldn't be retried\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            retry = Retry(total=1, status_forcelist=[202])\n            resp = pool.request(\n                \"GET\",\n                \"/successful_retry\",\n                headers={\"test-name\": \"test_wrong_forcelist\"},\n                retries=retry,\n            )\n            assert resp.status == 418\n\n    def test_default_method_forcelist_retried(self) -> None:\n        \"\"\"urllib3 should retry methods in the default method forcelist\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            retry = Retry(total=1, status_forcelist=[418])\n            resp = pool.request(\n                \"OPTIONS\",\n                \"/successful_retry\",\n                headers={\"test-name\": \"test_default_forcelist\"},\n                retries=retry,\n            )\n            assert resp.status == 200\n\n    def test_retries_wrong_method_list(self) -> None:\n        \"\"\"Method not in our allowed list should not be retried, even if code matches\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"test-name\": \"test_wrong_allowed_method\"}\n            retry = Retry(total=1, status_forcelist=[418], allowed_methods=[\"POST\"])\n            resp = pool.request(\n                \"GET\", \"/successful_retry\", headers=headers, retries=retry\n            )\n            assert resp.status == 418\n\n    def test_read_retries_unsuccessful(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"test-name\": \"test_read_retries_unsuccessful\"}\n            resp = pool.request(\"GET\", \"/successful_retry\", headers=headers, retries=1)\n            assert resp.status == 418\n\n    def test_retry_reuse_safe(self) -> None:\n        \"\"\"It should be possible to reuse a Retry object across requests\"\"\"\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"test-name\": \"test_retry_safe\"}\n            retry = Retry(total=1, status_forcelist=[418])\n            resp = pool.request(\n                \"GET\", \"/successful_retry\", headers=headers, retries=retry\n            )\n            assert resp.status == 200\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            resp = pool.request(\n                \"GET\", \"/successful_retry\", headers=headers, retries=retry\n            )\n            assert resp.status == 200\n\n    def test_retry_return_in_response(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            headers = {\"test-name\": \"test_retry_return_in_response\"}\n            retry = Retry(total=2, status_forcelist=[418])\n            resp = pool.request(\n                \"GET\", \"/successful_retry\", headers=headers, retries=retry\n            )\n            assert resp.status == 200\n            assert resp.retries is not None\n            assert resp.retries.total == 1\n            assert resp.retries.history == (\n                RequestHistory(\"GET\", \"/successful_retry\", None, 418, None),\n            )\n\n    def test_retry_redirect_history(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            resp = pool.request(\"GET\", \"/redirect\", fields={\"target\": \"/\"})\n            assert resp.status == 200\n            assert resp.retries is not None\n            assert resp.retries.history == (\n                RequestHistory(\"GET\", \"/redirect?target=%2F\", None, 303, \"/\"),\n            )\n\n    def test_multi_redirect_history(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\n                \"GET\",\n                \"/multi_redirect\",\n                fields={\"redirect_codes\": \"303,302,200\"},\n                redirect=False,\n            )\n            assert r.status == 303\n            assert r.retries is not None\n            assert r.retries.history == tuple()\n\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\n                \"GET\",\n                \"/multi_redirect\",\n                retries=10,\n                fields={\"redirect_codes\": \"303,302,301,307,302,200\"},\n            )\n            assert r.status == 200\n            assert r.data == b\"Done redirecting\"\n\n            expected = [\n                (303, \"/multi_redirect?redirect_codes=302,301,307,302,200\"),\n                (302, \"/multi_redirect?redirect_codes=301,307,302,200\"),\n                (301, \"/multi_redirect?redirect_codes=307,302,200\"),\n                (307, \"/multi_redirect?redirect_codes=302,200\"),\n                (302, \"/multi_redirect?redirect_codes=200\"),\n            ]\n            assert r.retries is not None\n            actual = [\n                (history.status, history.redirect_location)\n                for history in r.retries.history\n            ]\n            assert actual == expected\n\n\nclass TestRetryAfter(HypercornDummyServerTestCase):\n    def test_retry_after(self) -> None:\n        # Request twice in a second to get a 429 response.\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"429 Too Many Requests\"},\n                retries=False,\n            )\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"429 Too Many Requests\"},\n                retries=False,\n            )\n            assert r.status == 429\n\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"429 Too Many Requests\"},\n                retries=True,\n            )\n            assert r.status == 200\n\n            # Request twice in a second to get a 503 response.\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"503 Service Unavailable\"},\n                retries=False,\n            )\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"503 Service Unavailable\"},\n                retries=False,\n            )\n            assert r.status == 503\n\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"503 Service Unavailable\"},\n                retries=True,\n            )\n            assert r.status == 200\n\n            # Ignore Retry-After header on status which is not defined in\n            # Retry.RETRY_AFTER_STATUS_CODES.\n            r = pool.request(\n                \"GET\",\n                \"/retry_after\",\n                fields={\"status\": \"418 I'm a teapot\"},\n                retries=True,\n            )\n            assert r.status == 418\n\n    def test_redirect_after(self) -> None:\n        with HTTPConnectionPool(self.host, self.port) as pool:\n            r = pool.request(\"GET\", \"/redirect_after\", retries=False)\n            assert r.status == 303\n\n            # Real timestamps are needed for this test\n            t = time.time()\n            r = pool.request(\"GET\", \"/redirect_after\")\n            assert r.status == 200\n            delta = time.time() - t\n            assert delta >= 1\n\n            t = time.time()\n            timestamp = t + 2\n            r = pool.request(\"GET\", \"/redirect_after?date=\" + str(timestamp))\n            assert r.status == 200\n            delta = time.time() - t\n            assert delta >= 1\n\n            # Retry-After is past\n            t = time.time()\n            timestamp = t - 1\n            r = pool.request(\"GET\", \"/redirect_after?date=\" + str(timestamp))\n            delta = time.time() - t\n            assert r.status == 200\n            assert delta < 1\n\n\nclass TestFileBodiesOnRetryOrRedirect(HypercornDummyServerTestCase):\n    def test_retries_put_filehandle(self) -> None:\n        \"\"\"HTTP PUT retry with a file-like object should not timeout\"\"\"\n        with HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT) as pool:\n            retry = Retry(total=3, status_forcelist=[418])\n            # httplib reads in 8k chunks; use a larger content length\n            content_length = 65535\n            data = b\"A\" * content_length\n            uploaded_file = io.BytesIO(data)\n            headers = {\n                \"test-name\": \"test_retries_put_filehandle\",\n                \"Content-Length\": str(content_length),\n            }\n            resp = pool.urlopen(\n                \"PUT\",\n                \"/successful_retry\",\n                headers=headers,\n                retries=retry,\n                body=uploaded_file,\n                assert_same_host=False,\n                redirect=False,\n            )\n            assert resp.status == 200\n\n    def test_redirect_put_file(self) -> None:\n        \"\"\"PUT with file object should work with a redirection response\"\"\"\n        with HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT) as pool:\n            retry = Retry(total=3, status_forcelist=[418])\n            # httplib reads in 8k chunks; use a larger content length\n            content_length = 65535\n            data = b\"A\" * content_length\n            uploaded_file = io.BytesIO(data)\n            headers = {\n                \"test-name\": \"test_redirect_put_file\",\n                \"Content-Length\": str(content_length),\n            }\n            url = \"/redirect?target=/echo&status=307\"\n            resp = pool.urlopen(\n                \"PUT\",\n                url,\n                headers=headers,\n                retries=retry,\n                body=uploaded_file,\n                assert_same_host=False,\n                redirect=True,\n            )\n            assert resp.status == 200\n            assert resp.data == data\n\n    def test_redirect_with_failed_tell(self) -> None:\n        \"\"\"Abort request if failed to get a position from tell()\"\"\"\n\n        class BadTellObject(io.BytesIO):\n            def tell(self) -> typing.NoReturn:\n                raise OSError\n\n        body = BadTellObject(b\"the data\")\n        url = \"/redirect?target=/successful_retry\"\n        # httplib uses fileno if Content-Length isn't supplied,\n        # which is unsupported by BytesIO.\n        headers = {\"Content-Length\": \"8\"}\n        with HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT) as pool:\n            with pytest.raises(\n                UnrewindableBodyError, match=\"Unable to record file position for\"\n            ):\n                pool.urlopen(\"PUT\", url, headers=headers, body=body)\n\n\nclass TestRetryPoolSize(HypercornDummyServerTestCase):\n    def test_pool_size_retry(self) -> None:\n        retries = Retry(total=1, raise_on_status=False, status_forcelist=[404])\n        with HTTPConnectionPool(\n            self.host, self.port, maxsize=10, retries=retries, block=True\n        ) as pool:\n            pool.urlopen(\"GET\", \"/not_found\", preload_content=False)\n            assert pool.num_connections == 1\n\n\nclass TestRedirectPoolSize(HypercornDummyServerTestCase):\n    def test_pool_size_redirect(self) -> None:\n        retries = Retry(\n            total=1, raise_on_status=False, status_forcelist=[404], redirect=True\n        )\n        with HTTPConnectionPool(\n            self.host, self.port, maxsize=10, retries=retries, block=True\n        ) as pool:\n            pool.urlopen(\"GET\", \"/redirect\", preload_content=False)\n            assert pool.num_connections == 1\n", "test/with_dummyserver/test_connection.py": "from __future__ import annotations\n\nimport contextlib\nimport sys\nimport typing\nfrom http.client import ResponseNotReady\nfrom unittest import mock\n\nimport pytest\n\nfrom dummyserver.testcase import HypercornDummyServerTestCase as server\nfrom urllib3 import HTTPConnectionPool\nfrom urllib3.response import HTTPResponse\n\n\n@pytest.fixture()\ndef pool() -> typing.Generator[HTTPConnectionPool, None, None]:\n    server.setup_class()\n\n    with HTTPConnectionPool(server.host, server.port) as pool:\n        yield pool\n\n    server.teardown_class()\n\n\ndef test_returns_urllib3_HTTPResponse(pool: HTTPConnectionPool) -> None:\n    with contextlib.closing(pool._get_conn()) as conn:\n        conn.request(\"GET\", \"/\")\n        response = conn.getresponse()\n        assert isinstance(response, HTTPResponse)\n\n\n@pytest.mark.skipif(not hasattr(sys, \"audit\"), reason=\"requires python 3.8+\")\n@mock.patch(\"urllib3.connection.sys.audit\")\ndef test_audit_event(audit_mock: mock.Mock, pool: HTTPConnectionPool) -> None:\n    with contextlib.closing(pool._get_conn()) as conn:\n        conn.request(\"GET\", \"/\")\n        audit_mock.assert_any_call(\"http.client.connect\", conn, conn.host, conn.port)\n        # Ensure the event is raised only once.\n        connect_events = [\n            call\n            for call in audit_mock.mock_calls\n            if call.args[0] == \"http.client.connect\"\n        ]\n        assert len(connect_events) == 1\n\n\ndef test_does_not_release_conn(pool: HTTPConnectionPool) -> None:\n    with contextlib.closing(pool._get_conn()) as conn:\n        conn.request(\"GET\", \"/\")\n        response = conn.getresponse()\n\n        response.release_conn()\n        assert pool.pool.qsize() == 0  # type: ignore[union-attr]\n\n\ndef test_releases_conn(pool: HTTPConnectionPool) -> None:\n    with contextlib.closing(pool._get_conn()) as conn:\n        conn.request(\"GET\", \"/\")\n        response = conn.getresponse()\n\n        # If these variables are set by the pool\n        # then the response can release the connection\n        # back into the pool.\n        response._pool = pool  # type: ignore[attr-defined]\n        response._connection = conn  # type: ignore[attr-defined]\n\n        response.release_conn()\n        assert pool.pool.qsize() == 1  # type: ignore[union-attr]\n\n\ndef test_double_getresponse(pool: HTTPConnectionPool) -> None:\n    with contextlib.closing(pool._get_conn()) as conn:\n        conn.request(\"GET\", \"/\")\n        _ = conn.getresponse()\n\n        # Calling getrepsonse() twice should cause an error\n        with pytest.raises(ResponseNotReady):\n            conn.getresponse()\n\n\ndef test_connection_state_properties(pool: HTTPConnectionPool) -> None:\n    conn = pool._get_conn()\n\n    assert conn.is_closed is True\n    assert conn.is_connected is False\n    assert conn.has_connected_to_proxy is False\n    assert conn.is_verified is False\n    assert conn.proxy_is_verified is None\n\n    conn.connect()\n\n    assert conn.is_closed is False\n    assert conn.is_connected is True\n    assert conn.has_connected_to_proxy is False\n    assert conn.is_verified is False\n    assert conn.proxy_is_verified is None\n\n    conn.request(\"GET\", \"/\")\n    resp = conn.getresponse()\n    assert resp.status == 200\n\n    conn.close()\n\n    assert conn.is_closed is True\n    assert conn.is_connected is False\n    assert conn.has_connected_to_proxy is False\n    assert conn.is_verified is False\n    assert conn.proxy_is_verified is None\n\n\ndef test_set_tunnel_is_reset(pool: HTTPConnectionPool) -> None:\n    conn = pool._get_conn()\n\n    assert conn.is_closed is True\n    assert conn.is_connected is False\n    assert conn.has_connected_to_proxy is False\n    assert conn.is_verified is False\n    assert conn.proxy_is_verified is None\n\n    conn.set_tunnel(host=\"host\", port=8080, scheme=\"http\")\n\n    assert conn._tunnel_host == \"host\"  # type: ignore[attr-defined]\n    assert conn._tunnel_port == 8080  # type: ignore[attr-defined]\n    assert conn._tunnel_scheme == \"http\"  # type: ignore[attr-defined]\n\n    conn.close()\n\n    assert conn._tunnel_host is None  # type: ignore[attr-defined]\n    assert conn._tunnel_port is None  # type: ignore[attr-defined]\n    assert conn._tunnel_scheme is None  # type: ignore[attr-defined]\n\n\ndef test_invalid_tunnel_scheme(pool: HTTPConnectionPool) -> None:\n    conn = pool._get_conn()\n\n    with pytest.raises(ValueError) as e:\n        conn.set_tunnel(host=\"host\", port=8080, scheme=\"socks\")\n    assert (\n        str(e.value)\n        == \"Invalid proxy scheme for tunneling: 'socks', must be either 'http' or 'https'\"\n    )\n", "test/with_dummyserver/test_https.py": "from __future__ import annotations\n\nimport contextlib\nimport datetime\nimport os.path\nimport shutil\nimport ssl\nimport tempfile\nimport warnings\nfrom pathlib import Path\nfrom test import (\n    LONG_TIMEOUT,\n    SHORT_TIMEOUT,\n    TARPIT_HOST,\n    requires_network,\n    resolvesLocalhostFQDN,\n)\nfrom test.conftest import ServerConfig\nfrom unittest import mock\n\nimport pytest\nimport trustme\n\nimport urllib3.util as util\nimport urllib3.util.ssl_\nfrom dummyserver.socketserver import (\n    DEFAULT_CA,\n    DEFAULT_CA_KEY,\n    DEFAULT_CERTS,\n    encrypt_key_pem,\n)\nfrom dummyserver.testcase import HTTPSHypercornDummyServerTestCase\nfrom urllib3 import HTTPSConnectionPool\nfrom urllib3.connection import RECENT_DATE, HTTPSConnection, VerifiedHTTPSConnection\nfrom urllib3.exceptions import (\n    ConnectTimeoutError,\n    InsecureRequestWarning,\n    MaxRetryError,\n    ProtocolError,\n    SSLError,\n    SystemTimeWarning,\n)\nfrom urllib3.util.ssl_match_hostname import CertificateError\nfrom urllib3.util.timeout import Timeout\n\nfrom .. import has_alpn\n\nTLSv1_CERTS = DEFAULT_CERTS.copy()\nTLSv1_CERTS[\"ssl_version\"] = getattr(ssl, \"PROTOCOL_TLSv1\", None)\n\nTLSv1_1_CERTS = DEFAULT_CERTS.copy()\nTLSv1_1_CERTS[\"ssl_version\"] = getattr(ssl, \"PROTOCOL_TLSv1_1\", None)\n\nTLSv1_2_CERTS = DEFAULT_CERTS.copy()\nTLSv1_2_CERTS[\"ssl_version\"] = getattr(ssl, \"PROTOCOL_TLSv1_2\", None)\n\nTLSv1_3_CERTS = DEFAULT_CERTS.copy()\nTLSv1_3_CERTS[\"ssl_version\"] = getattr(ssl, \"PROTOCOL_TLS\", None)\n\n\nCLIENT_INTERMEDIATE_PEM = \"client_intermediate.pem\"\nCLIENT_NO_INTERMEDIATE_PEM = \"client_no_intermediate.pem\"\nCLIENT_INTERMEDIATE_KEY = \"client_intermediate.key\"\nPASSWORD_CLIENT_KEYFILE = \"client_password.key\"\nCLIENT_CERT = CLIENT_INTERMEDIATE_PEM\n\n\nclass BaseTestHTTPS(HTTPSHypercornDummyServerTestCase):\n    tls_protocol_name: str | None = None\n\n    def tls_protocol_not_default(self) -> bool:\n        return self.tls_protocol_name in {\"TLSv1\", \"TLSv1.1\"}\n\n    def tls_version(self) -> ssl.TLSVersion:\n        if self.tls_protocol_name is None:\n            return pytest.skip(\"Skipping base test class\")\n        try:\n            from ssl import TLSVersion\n        except ImportError:\n            return pytest.skip(\"ssl.TLSVersion isn't available\")\n        return TLSVersion[self.tls_protocol_name.replace(\".\", \"_\")]\n\n    def ssl_version(self) -> int:\n        if self.tls_protocol_name is None:\n            return pytest.skip(\"Skipping base test class\")\n\n        if self.tls_protocol_name == \"TLSv1.3\" and ssl.HAS_TLSv1_3:\n            return ssl.PROTOCOL_TLS_CLIENT\n        if self.tls_protocol_name == \"TLSv1.2\" and ssl.HAS_TLSv1_2:\n            return ssl.PROTOCOL_TLSv1_2\n        if self.tls_protocol_name == \"TLSv1.1\" and ssl.HAS_TLSv1_1:\n            return ssl.PROTOCOL_TLSv1_1\n        if self.tls_protocol_name == \"TLSv1\" and ssl.HAS_TLSv1:\n            return ssl.PROTOCOL_TLSv1\n        else:\n            return pytest.skip(f\"{self.tls_protocol_name} isn't available\")\n\n    @classmethod\n    def setup_class(cls) -> None:\n        super().setup_class()\n\n        cls.certs_dir = tempfile.mkdtemp()\n        # Start from existing root CA as we don't want to change the server certificate yet\n        with open(DEFAULT_CA, \"rb\") as crt, open(DEFAULT_CA_KEY, \"rb\") as key:\n            root_ca = trustme.CA.from_pem(crt.read(), key.read())\n\n        # Generate another CA to test verification failure\n        bad_ca = trustme.CA()\n        cls.bad_ca_path = os.path.join(cls.certs_dir, \"ca_bad.pem\")\n        bad_ca.cert_pem.write_to_path(cls.bad_ca_path)\n\n        # client cert chain\n        intermediate_ca = root_ca.create_child_ca()\n        cert = intermediate_ca.issue_cert(\"example.com\")\n        encrypted_key = encrypt_key_pem(cert.private_key_pem, b\"letmein\")\n\n        cert.private_key_pem.write_to_path(\n            os.path.join(cls.certs_dir, CLIENT_INTERMEDIATE_KEY)\n        )\n        encrypted_key.write_to_path(\n            os.path.join(cls.certs_dir, PASSWORD_CLIENT_KEYFILE)\n        )\n        # Write the client cert and the intermediate CA\n        client_cert = os.path.join(cls.certs_dir, CLIENT_INTERMEDIATE_PEM)\n        cert.cert_chain_pems[0].write_to_path(client_cert)\n        cert.cert_chain_pems[1].write_to_path(client_cert, append=True)\n        # Write only the client cert\n        cert.cert_chain_pems[0].write_to_path(\n            os.path.join(cls.certs_dir, CLIENT_NO_INTERMEDIATE_PEM)\n        )\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        super().teardown_class()\n\n        shutil.rmtree(cls.certs_dir)\n\n    def test_simple(self, http_version: str) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n            assert r.headers[\"server\"] == f\"hypercorn-{http_version}\"\n            assert r.data == b\"Dummy server!\"\n\n    @resolvesLocalhostFQDN()\n    def test_dotted_fqdn(self) -> None:\n        with HTTPSConnectionPool(\n            self.host + \".\",\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as pool:\n            r = pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n\n    def test_client_intermediate(self) -> None:\n        \"\"\"Check that certificate chains work well with client certs\n\n        We generate an intermediate CA from the root CA, and issue a client certificate\n        from that intermediate CA. Since the server only knows about the root CA, we\n        need to send it the certificate *and* the intermediate CA, so that it can check\n        the whole chain.\n        \"\"\"\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            key_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_KEY),\n            cert_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_PEM),\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/certificate\")\n            subject = r.json()\n            assert subject[\"organizationalUnitName\"].startswith(\"Testing cert\")\n\n    def test_client_no_intermediate(self) -> None:\n        \"\"\"Check that missing links in certificate chains indeed break\n\n        The only difference with test_client_intermediate is that we don't send the\n        intermediate CA to the server, only the client cert.\n        \"\"\"\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_file=os.path.join(self.certs_dir, CLIENT_NO_INTERMEDIATE_PEM),\n            key_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_KEY),\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises((SSLError, ProtocolError)):\n                https_pool.request(\"GET\", \"/certificate\", retries=False)\n\n    def test_client_key_password(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            key_file=os.path.join(self.certs_dir, PASSWORD_CLIENT_KEYFILE),\n            cert_file=os.path.join(self.certs_dir, CLIENT_CERT),\n            key_password=\"letmein\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/certificate\")\n            subject = r.json()\n            assert subject[\"organizationalUnitName\"].startswith(\"Testing cert\")\n\n    def test_client_encrypted_key_requires_password(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            key_file=os.path.join(self.certs_dir, PASSWORD_CLIENT_KEYFILE),\n            cert_file=os.path.join(self.certs_dir, CLIENT_CERT),\n            key_password=None,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises(MaxRetryError, match=\"password is required\") as e:\n                https_pool.request(\"GET\", \"/certificate\")\n\n            assert type(e.value.reason) is SSLError\n\n    def test_verified(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                assert conn.__class__ == VerifiedHTTPSConnection\n\n            with warnings.catch_warnings(record=True) as w:\n                r = https_pool.request(\"GET\", \"/\")\n                assert r.status == 200\n\n            assert [str(wm) for wm in w] == []\n\n    def test_verified_with_context(self) -> None:\n        ctx = util.ssl_.create_urllib3_context(\n            cert_reqs=ssl.CERT_REQUIRED, ssl_minimum_version=self.tls_version()\n        )\n        ctx.load_verify_locations(cafile=DEFAULT_CA)\n        with HTTPSConnectionPool(self.host, self.port, ssl_context=ctx) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                assert conn.__class__ == VerifiedHTTPSConnection\n\n            with mock.patch(\"warnings.warn\") as warn:\n                r = https_pool.request(\"GET\", \"/\")\n                assert r.status == 200\n                assert not warn.called, warn.call_args_list\n\n    def test_context_combines_with_ca_certs(self) -> None:\n        ctx = util.ssl_.create_urllib3_context(\n            cert_reqs=ssl.CERT_REQUIRED, ssl_minimum_version=self.tls_version()\n        )\n        with HTTPSConnectionPool(\n            self.host, self.port, ca_certs=DEFAULT_CA, ssl_context=ctx\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                assert conn.__class__ == VerifiedHTTPSConnection\n\n            with mock.patch(\"warnings.warn\") as warn:\n                r = https_pool.request(\"GET\", \"/\")\n                assert r.status == 200\n                assert not warn.called, warn.call_args_list\n\n    def test_ca_dir_verified(self, tmp_path: Path) -> None:\n        # OpenSSL looks up certificates by the hash for their name, see c_rehash\n        # TODO infer the bytes using `cryptography.x509.Name.public_bytes`.\n        # https://github.com/pyca/cryptography/pull/3236\n        shutil.copyfile(DEFAULT_CA, str(tmp_path / \"81deb5f7.0\"))\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_cert_dir=str(tmp_path),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                assert conn.__class__ == VerifiedHTTPSConnection\n\n            with warnings.catch_warnings(record=True) as w:\n                r = https_pool.request(\"GET\", \"/\")\n                assert r.status == 200\n\n            assert [str(wm) for wm in w] == []\n\n    def test_invalid_common_name(self) -> None:\n        with HTTPSConnectionPool(\n            \"127.0.0.1\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises(MaxRetryError) as e:\n                https_pool.request(\"GET\", \"/\", retries=0)\n            assert type(e.value.reason) is SSLError\n            assert \"doesn't match\" in str(\n                e.value.reason\n            ) or \"certificate verify failed\" in str(e.value.reason)\n\n    def test_verified_with_bad_ca_certs(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=self.bad_ca_path,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises(MaxRetryError) as e:\n                https_pool.request(\"GET\", \"/\")\n            assert type(e.value.reason) is SSLError\n            assert (\n                \"certificate verify failed\" in str(e.value.reason)\n                # PyPy is more specific\n                or \"self signed certificate in certificate chain\" in str(e.value.reason)\n            ), f\"Expected 'certificate verify failed', instead got: {e.value.reason!r}\"\n\n    def test_wrap_socket_failure_resource_leak(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=self.bad_ca_path,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with contextlib.closing(https_pool._get_conn()) as conn:\n                with pytest.raises(ssl.SSLError):\n                    conn.connect()\n\n                assert conn.sock is not None  # type: ignore[attr-defined]\n\n    def test_verified_without_ca_certs(self) -> None:\n        # default is cert_reqs=None which is ssl.CERT_NONE\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises(MaxRetryError) as e:\n                https_pool.request(\"GET\", \"/\")\n            assert type(e.value.reason) is SSLError\n            # there is a different error message depending on whether or\n            # not pyopenssl is injected\n            assert (\n                \"No root certificates specified\" in str(e.value.reason)\n                # PyPy is more specific\n                or \"self signed certificate in certificate chain\" in str(e.value.reason)\n                # PyPy sometimes uses all-caps here\n                or \"certificate verify failed\" in str(e.value.reason).lower()\n                or \"invalid certificate chain\" in str(e.value.reason)\n            ), (\n                \"Expected 'No root certificates specified',  \"\n                \"'certificate verify failed', or \"\n                \"'invalid certificate chain', \"\n                \"instead got: %r\" % e.value.reason\n            )\n\n    def test_no_ssl(self) -> None:\n        with HTTPSConnectionPool(self.host, self.port) as pool:\n            pool.ConnectionCls = None  # type: ignore[assignment]\n            with pytest.raises(ImportError):\n                pool._new_conn()\n            with pytest.raises(ImportError):\n                pool.request(\"GET\", \"/\", retries=0)\n\n    def test_unverified_ssl(self) -> None:\n        \"\"\"Test that bare HTTPSConnection can connect, make requests\"\"\"\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=ssl.CERT_NONE,\n            ssl_minimum_version=self.tls_version(),\n        ) as pool:\n            with mock.patch(\"warnings.warn\") as warn:\n                r = pool.request(\"GET\", \"/\")\n                assert r.status == 200\n                assert warn.called\n\n                # Modern versions of Python, or systems using PyOpenSSL, only emit\n                # the unverified warning. Older systems may also emit other\n                # warnings, which we want to ignore here.\n                calls = warn.call_args_list\n                assert InsecureRequestWarning in [x[0][1] for x in calls]\n\n    def test_ssl_unverified_with_ca_certs(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_NONE\",\n            ca_certs=self.bad_ca_path,\n            ssl_minimum_version=self.tls_version(),\n        ) as pool:\n            with mock.patch(\"warnings.warn\") as warn:\n                r = pool.request(\"GET\", \"/\")\n                assert r.status == 200\n                assert warn.called\n\n                # Modern versions of Python, or systems using PyOpenSSL, only emit\n                # the unverified warning. Older systems may also emit other\n                # warnings, which we want to ignore here.\n                calls = warn.call_args_list\n\n                category = calls[0][0][1]\n                assert category == InsecureRequestWarning\n\n    def test_assert_hostname_false(self) -> None:\n        with HTTPSConnectionPool(\n            \"localhost\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.assert_hostname = False\n            https_pool.request(\"GET\", \"/\")\n\n    def test_assert_specific_hostname(self) -> None:\n        with HTTPSConnectionPool(\n            \"localhost\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.assert_hostname = \"localhost\"\n            https_pool.request(\"GET\", \"/\")\n\n    def test_server_hostname(self) -> None:\n        with HTTPSConnectionPool(\n            \"127.0.0.1\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            server_hostname=\"localhost\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            conn = https_pool._new_conn()\n            conn.request(\"GET\", \"/\")\n\n            # Assert the wrapping socket is using the passed-through SNI name.\n            # pyopenssl doesn't let you pull the server_hostname back off the\n            # socket, so only add this assertion if the attribute is there (i.e.\n            # the python ssl module).\n            if hasattr(conn.sock, \"server_hostname\"):  # type: ignore[attr-defined]\n                assert conn.sock.server_hostname == \"localhost\"  # type: ignore[attr-defined]\n            conn.getresponse().close()\n            conn.close()\n\n    def test_assert_fingerprint_md5(self) -> None:\n        with HTTPSConnectionPool(\n            \"localhost\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=(\"55:39:BF:70:05:12:43:FA:1F:D1:BF:4E:E8:1B:07:1D\"),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    def test_assert_fingerprint_sha1(self) -> None:\n        with HTTPSConnectionPool(\n            \"localhost\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=(\n                \"72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n            ),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    def test_assert_fingerprint_sha256(self) -> None:\n        with HTTPSConnectionPool(\n            \"localhost\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=(\n                \"E3:59:8E:69:FF:C5:9F:C7:88:87:44:58:22:7F:90:8D:D9:BC:12:C4:90:79:D5:\"\n                \"DC:A8:5D:4F:60:40:1E:A6:D2\"\n            ),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    def test_assert_invalid_fingerprint(self) -> None:\n        def _test_request(pool: HTTPSConnectionPool) -> SSLError:\n            with pytest.raises(MaxRetryError) as cm:\n                pool.request(\"GET\", \"/\", retries=0)\n            assert type(cm.value.reason) is SSLError\n            return cm.value.reason\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.assert_fingerprint = (\n                \"AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\"\n            )\n            e = _test_request(https_pool)\n            expected = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n            got = \"728b554c9afc1e88a11cad1bb2e7cc3edbc8f98a\"\n            assert (\n                str(e)\n                == f'Fingerprints did not match. Expected \"{expected}\", got \"{got}\"'\n            )\n\n            # Uneven length\n            https_pool.assert_fingerprint = \"AA:A\"\n            e = _test_request(https_pool)\n            assert \"Fingerprint of invalid length:\" in str(e)\n\n            # Invalid length\n            https_pool.assert_fingerprint = \"AA\"\n            e = _test_request(https_pool)\n            assert \"Fingerprint of invalid length:\" in str(e)\n\n    def test_verify_none_and_bad_fingerprint(self) -> None:\n        with HTTPSConnectionPool(\n            \"127.0.0.1\",\n            self.port,\n            cert_reqs=\"CERT_NONE\",\n            assert_hostname=False,\n            assert_fingerprint=(\n                \"AA:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n            ),\n        ) as https_pool:\n            with pytest.raises(MaxRetryError) as cm:\n                https_pool.request(\"GET\", \"/\", retries=0)\n            assert type(cm.value.reason) is SSLError\n\n    def test_verify_none_and_good_fingerprint(self) -> None:\n        with HTTPSConnectionPool(\n            \"127.0.0.1\",\n            self.port,\n            cert_reqs=\"CERT_NONE\",\n            assert_hostname=False,\n            assert_fingerprint=(\n                \"72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n            ),\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    def test_good_fingerprint_and_hostname_mismatch(self) -> None:\n        with HTTPSConnectionPool(\n            \"127.0.0.1\",\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=(\n                \"72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n            ),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    @requires_network()\n    def test_https_timeout(self) -> None:\n        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)\n        with HTTPSConnectionPool(\n            TARPIT_HOST,\n            self.port,\n            timeout=timeout,\n            retries=False,\n            cert_reqs=\"CERT_REQUIRED\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.raises(ConnectTimeoutError):\n                https_pool.request(\"GET\", \"/\")\n\n        timeout = Timeout(read=0.01)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            timeout=timeout,\n            retries=False,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=(\n                \"72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n            ),\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            # TODO This was removed in https://github.com/urllib3/urllib3/pull/703/files\n            # We need to put something back or remove this block.\n            pass\n\n        timeout = Timeout(total=None)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            timeout=timeout,\n            cert_reqs=\"CERT_NONE\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with pytest.warns(InsecureRequestWarning):\n                https_pool.request(\"GET\", \"/\")\n\n    def test_tunnel(self) -> None:\n        \"\"\"test the _tunnel behavior\"\"\"\n        timeout = Timeout(total=None)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            timeout=timeout,\n            cert_reqs=\"CERT_NONE\",\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                conn.set_tunnel(self.host, self.port)\n                with mock.patch.object(\n                    conn, \"_tunnel\", create=True, return_value=None\n                ) as conn_tunnel:\n                    with pytest.warns(InsecureRequestWarning):\n                        https_pool._make_request(conn, \"GET\", \"/\")\n                conn_tunnel.assert_called_once_with()\n\n    @requires_network()\n    def test_enhanced_timeout(self) -> None:\n        with HTTPSConnectionPool(\n            TARPIT_HOST,\n            self.port,\n            timeout=Timeout(connect=SHORT_TIMEOUT),\n            retries=False,\n            cert_reqs=\"CERT_REQUIRED\",\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                with pytest.raises(ConnectTimeoutError):\n                    https_pool.request(\"GET\", \"/\")\n                with pytest.raises(ConnectTimeoutError):\n                    https_pool._make_request(conn, \"GET\", \"/\")\n\n        with HTTPSConnectionPool(\n            TARPIT_HOST,\n            self.port,\n            timeout=Timeout(connect=LONG_TIMEOUT),\n            retries=False,\n            cert_reqs=\"CERT_REQUIRED\",\n        ) as https_pool:\n            with pytest.raises(ConnectTimeoutError):\n                https_pool.request(\"GET\", \"/\", timeout=Timeout(connect=SHORT_TIMEOUT))\n\n        with HTTPSConnectionPool(\n            TARPIT_HOST,\n            self.port,\n            timeout=Timeout(total=None),\n            retries=False,\n            cert_reqs=\"CERT_REQUIRED\",\n        ) as https_pool:\n            with contextlib.closing(https_pool._new_conn()) as conn:\n                with pytest.raises(ConnectTimeoutError):\n                    https_pool.request(\n                        \"GET\", \"/\", timeout=Timeout(total=None, connect=SHORT_TIMEOUT)\n                    )\n\n    def test_enhanced_ssl_connection(self) -> None:\n        fingerprint = \"72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A\"\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=DEFAULT_CA,\n            assert_fingerprint=fingerprint,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200\n\n    def test_ssl_correct_system_time(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.cert_reqs = \"CERT_REQUIRED\"\n            https_pool.ca_certs = DEFAULT_CA\n\n            w = self._request_without_resource_warnings(\"GET\", \"/\")\n            assert [] == w\n\n    def test_ssl_wrong_system_time(self) -> None:\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            https_pool.cert_reqs = \"CERT_REQUIRED\"\n            https_pool.ca_certs = DEFAULT_CA\n            with mock.patch(\"urllib3.connection.datetime\") as mock_date:\n                mock_date.date.today.return_value = datetime.date(1970, 1, 1)\n\n                w = self._request_without_resource_warnings(\"GET\", \"/\")\n\n                assert len(w) == 1\n                warning = w[0]\n\n                assert SystemTimeWarning == warning.category\n                assert isinstance(warning.message, Warning)\n                assert str(RECENT_DATE) in warning.message.args[0]\n\n    def _request_without_resource_warnings(\n        self, method: str, url: str\n    ) -> list[warnings.WarningMessage]:\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"always\")\n            with HTTPSConnectionPool(\n                self.host,\n                self.port,\n                ca_certs=DEFAULT_CA,\n                ssl_minimum_version=self.tls_version(),\n            ) as https_pool:\n                https_pool.request(method, url)\n\n        w = [x for x in w if not isinstance(x.message, ResourceWarning)]\n\n        return w\n\n    def test_set_ssl_version_to_tls_version(self) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n\n        with HTTPSConnectionPool(\n            self.host, self.port, ca_certs=DEFAULT_CA\n        ) as https_pool:\n            https_pool.ssl_version = ssl_version = self.certs[\"ssl_version\"]\n            if ssl_version is getattr(ssl, \"PROTOCOL_TLS\", object()):\n                cmgr: contextlib.AbstractContextManager[\n                    object\n                ] = contextlib.nullcontext()\n            else:\n                cmgr = pytest.warns(\n                    DeprecationWarning,\n                    match=r\"'ssl_version' option is deprecated and will be removed \"\n                    r\"in urllib3 v2\\.1\\.0\\. Instead use 'ssl_minimum_version'\",\n                )\n            with cmgr:\n                r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n\n    def test_set_cert_default_cert_required(self) -> None:\n        conn = VerifiedHTTPSConnection(self.host, self.port)\n        with pytest.warns(DeprecationWarning) as w:\n            conn.set_cert()\n        assert conn.cert_reqs == ssl.CERT_REQUIRED\n        assert len(w) == 1 and str(w[0].message) == (\n            \"HTTPSConnection.set_cert() is deprecated and will be removed in urllib3 v2.1.0. \"\n            \"Instead provide the parameters to the HTTPSConnection constructor.\"\n        )\n\n    @pytest.mark.parametrize(\"verify_mode\", [ssl.CERT_NONE, ssl.CERT_REQUIRED])\n    def test_set_cert_inherits_cert_reqs_from_ssl_context(\n        self, verify_mode: int\n    ) -> None:\n        ssl_context = urllib3.util.ssl_.create_urllib3_context(cert_reqs=verify_mode)\n        assert ssl_context.verify_mode == verify_mode\n\n        conn = HTTPSConnection(self.host, self.port, ssl_context=ssl_context)\n        with pytest.warns(DeprecationWarning) as w:\n            conn.set_cert()\n\n        assert conn.cert_reqs == verify_mode\n        assert (\n            conn.ssl_context is not None and conn.ssl_context.verify_mode == verify_mode\n        )\n        assert len(w) == 1 and str(w[0].message) == (\n            \"HTTPSConnection.set_cert() is deprecated and will be removed in urllib3 v2.1.0. \"\n            \"Instead provide the parameters to the HTTPSConnection constructor.\"\n        )\n\n    def test_tls_protocol_name_of_socket(self) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n            ssl_maximum_version=self.tls_version(),\n        ) as https_pool:\n            with contextlib.closing(https_pool._get_conn()) as conn:\n                conn.connect()\n                if not hasattr(conn.sock, \"version\"):  # type: ignore[attr-defined]\n                    pytest.skip(\"SSLSocket.version() not available\")\n                assert conn.sock.version() == self.tls_protocol_name  # type: ignore[attr-defined]\n\n    def test_ssl_version_is_deprecated(self) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n        if self.ssl_version() == ssl.PROTOCOL_TLS_CLIENT:\n            pytest.skip(\n                \"Skipping because ssl_version=ssl.PROTOCOL_TLS_CLIENT is not deprecated\"\n            )\n\n        with HTTPSConnectionPool(\n            self.host, self.port, ca_certs=DEFAULT_CA, ssl_version=self.ssl_version()\n        ) as https_pool:\n            with contextlib.closing(https_pool._get_conn()) as conn:\n                with pytest.warns(DeprecationWarning) as w:\n                    conn.connect()\n\n        assert len(w) >= 1\n        assert any(x.category == DeprecationWarning for x in w)\n        assert any(\n            str(x.message)\n            == (\n                \"'ssl_version' option is deprecated and will be removed in \"\n                \"urllib3 v2.1.0. Instead use 'ssl_minimum_version'\"\n            )\n            for x in w\n        )\n\n    @pytest.mark.parametrize(\n        \"ssl_version\", [None, ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS_CLIENT]\n    )\n    def test_ssl_version_with_protocol_tls_or_client_not_deprecated(\n        self, ssl_version: int | None\n    ) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n        if self.tls_protocol_not_default():\n            pytest.skip(\n                f\"Skipping because '{self.tls_protocol_name}' isn't set by default\"\n            )\n\n        with HTTPSConnectionPool(\n            self.host, self.port, ca_certs=DEFAULT_CA, ssl_version=ssl_version\n        ) as https_pool:\n            with contextlib.closing(https_pool._get_conn()) as conn:\n                with warnings.catch_warnings(record=True) as w:\n                    conn.connect()\n\n        assert [str(wm) for wm in w if wm.category != ResourceWarning] == []\n\n    def test_no_tls_version_deprecation_with_ssl_context(self) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n\n        ctx = util.ssl_.create_urllib3_context(ssl_minimum_version=self.tls_version())\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_context=ctx,\n        ) as https_pool:\n            with contextlib.closing(https_pool._get_conn()) as conn:\n                with warnings.catch_warnings(record=True) as w:\n                    conn.connect()\n\n        assert [str(wm) for wm in w if wm.category != ResourceWarning] == []\n\n    def test_tls_version_maximum_and_minimum(self) -> None:\n        if self.tls_protocol_name is None:\n            pytest.skip(\"Skipping base test class\")\n\n        from ssl import TLSVersion\n\n        min_max_versions = [\n            (self.tls_version(), self.tls_version()),\n            (TLSVersion.MINIMUM_SUPPORTED, self.tls_version()),\n            (TLSVersion.MINIMUM_SUPPORTED, TLSVersion.MAXIMUM_SUPPORTED),\n        ]\n\n        for minimum_version, maximum_version in min_max_versions:\n            with HTTPSConnectionPool(\n                self.host,\n                self.port,\n                ca_certs=DEFAULT_CA,\n                ssl_minimum_version=minimum_version,\n                ssl_maximum_version=maximum_version,\n            ) as https_pool:\n                conn = https_pool._get_conn()\n                try:\n                    conn.connect()\n                    if maximum_version == TLSVersion.MAXIMUM_SUPPORTED:\n                        # A higher protocol than tls_protocol_name could be negotiated\n                        assert conn.sock.version() >= self.tls_protocol_name  # type: ignore[attr-defined]\n                    else:\n                        assert conn.sock.version() == self.tls_protocol_name  # type: ignore[attr-defined]\n                finally:\n                    conn.close()\n\n    def test_sslkeylogfile(\n        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n    ) -> None:\n        if not hasattr(util.SSLContext, \"keylog_filename\"):\n            pytest.skip(\"requires OpenSSL 1.1.1+\")\n\n        keylog_file = tmp_path / \"keylogfile.txt\"\n        monkeypatch.setenv(\"SSLKEYLOGFILE\", str(keylog_file))\n\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n            assert keylog_file.is_file(), \"keylogfile '%s' should exist\" % str(\n                keylog_file\n            )\n            assert keylog_file.read_text().startswith(\n                \"# TLS secrets log file\"\n            ), \"keylogfile '%s' should start with '# TLS secrets log file'\" % str(\n                keylog_file\n            )\n\n    @pytest.mark.parametrize(\"sslkeylogfile\", [None, \"\"])\n    def test_sslkeylogfile_empty(\n        self, monkeypatch: pytest.MonkeyPatch, sslkeylogfile: str | None\n    ) -> None:\n        # Assert that an HTTPS connection doesn't error out when given\n        # no SSLKEYLOGFILE or an empty value (ie 'SSLKEYLOGFILE=')\n        if sslkeylogfile is not None:\n            monkeypatch.setenv(\"SSLKEYLOGFILE\", sslkeylogfile)\n        else:\n            monkeypatch.delenv(\"SSLKEYLOGFILE\", raising=False)\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as pool:\n            r = pool.request(\"GET\", \"/\")\n            assert r.status == 200, r.data\n\n    def test_alpn_default(self) -> None:\n        \"\"\"Default ALPN protocols are sent by default.\"\"\"\n        if not has_alpn() or not has_alpn(ssl.SSLContext):\n            pytest.skip(\"ALPN-support not available\")\n        with HTTPSConnectionPool(\n            self.host,\n            self.port,\n            ca_certs=DEFAULT_CA,\n            ssl_minimum_version=self.tls_version(),\n        ) as pool:\n            r = pool.request(\"GET\", \"/alpn_protocol\", retries=0)\n            assert r.status == 200\n            assert r.data.decode(\"utf-8\") == util.ALPN_PROTOCOLS[0]\n\n    def test_default_ssl_context_ssl_min_max_versions(self) -> None:\n        ctx = urllib3.util.ssl_.create_urllib3_context()\n        assert ctx.minimum_version == ssl.TLSVersion.TLSv1_2\n        # urllib3 sets a default maximum version only when it is\n        # injected with PyOpenSSL SSL-support.\n        # Otherwise, the default maximum version is set by Python's\n        # `ssl.SSLContext`. The value respects OpenSSL configuration and\n        # can be different from `ssl.TLSVersion.MAXIMUM_SUPPORTED`.\n        # https://github.com/urllib3/urllib3/issues/2477#issuecomment-1151452150\n        if util.IS_PYOPENSSL:\n            expected_maximum_version = ssl.TLSVersion.MAXIMUM_SUPPORTED\n        else:\n            expected_maximum_version = ssl.SSLContext(\n                ssl.PROTOCOL_TLS_CLIENT\n            ).maximum_version\n        assert ctx.maximum_version == expected_maximum_version\n\n    def test_ssl_context_ssl_version_uses_ssl_min_max_versions(self) -> None:\n        if self.ssl_version() == ssl.PROTOCOL_TLS_CLIENT:\n            pytest.skip(\n                \"Skipping because ssl_version=ssl.PROTOCOL_TLS_CLIENT is not deprecated\"\n            )\n\n        with pytest.warns(\n            DeprecationWarning,\n            match=r\"'ssl_version' option is deprecated and will be removed in \"\n            r\"urllib3 v2\\.1\\.0\\. Instead use 'ssl_minimum_version'\",\n        ):\n            ctx = urllib3.util.ssl_.create_urllib3_context(\n                ssl_version=self.ssl_version()\n            )\n        assert ctx.minimum_version == self.tls_version()\n        assert ctx.maximum_version == self.tls_version()\n\n\n@pytest.mark.usefixtures(\"requires_tlsv1\")\nclass TestHTTPS_TLSv1(BaseTestHTTPS):\n    tls_protocol_name = \"TLSv1\"\n    certs = TLSv1_CERTS\n\n\n@pytest.mark.usefixtures(\"requires_tlsv1_1\")\nclass TestHTTPS_TLSv1_1(BaseTestHTTPS):\n    tls_protocol_name = \"TLSv1.1\"\n    certs = TLSv1_1_CERTS\n\n\n@pytest.mark.usefixtures(\"requires_tlsv1_2\")\nclass TestHTTPS_TLSv1_2(BaseTestHTTPS):\n    tls_protocol_name = \"TLSv1.2\"\n    certs = TLSv1_2_CERTS\n\n\n@pytest.mark.usefixtures(\"requires_tlsv1_3\")\nclass TestHTTPS_TLSv1_3(BaseTestHTTPS):\n    tls_protocol_name = \"TLSv1.3\"\n    certs = TLSv1_3_CERTS\n\n\nclass TestHTTPS_Hostname:\n    def test_can_validate_san(self, san_server: ServerConfig) -> None:\n        \"\"\"Ensure that urllib3 can validate SANs with IP addresses in them.\"\"\"\n        with HTTPSConnectionPool(\n            san_server.host,\n            san_server.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=san_server.ca_certs,\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200\n\n    def test_common_name_without_san_fails(self, no_san_server: ServerConfig) -> None:\n        with HTTPSConnectionPool(\n            no_san_server.host,\n            no_san_server.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=no_san_server.ca_certs,\n        ) as https_pool:\n            with pytest.raises(\n                MaxRetryError,\n            ) as e:\n                https_pool.request(\"GET\", \"/\")\n            assert \"mismatch, certificate is not valid\" in str(\n                e.value\n            ) or \"no appropriate subjectAltName\" in str(e.value)\n\n    def test_common_name_without_san_with_different_common_name(\n        self, no_san_server_with_different_commmon_name: ServerConfig\n    ) -> None:\n        ctx = urllib3.util.ssl_.create_urllib3_context()\n        try:\n            ctx.hostname_checks_common_name = True\n        except AttributeError:\n            pytest.skip(\"Couldn't set 'SSLContext.hostname_checks_common_name'\")\n\n        with HTTPSConnectionPool(\n            no_san_server_with_different_commmon_name.host,\n            no_san_server_with_different_commmon_name.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=no_san_server_with_different_commmon_name.ca_certs,\n            ssl_context=ctx,\n        ) as https_pool:\n            with pytest.raises(MaxRetryError) as e:\n                https_pool.request(\"GET\", \"/\")\n            assert \"mismatch, certificate is not valid for 'localhost'\" in str(\n                e.value\n            ) or \"hostname 'localhost' doesn't match 'example.com'\" in str(e.value)\n\n    @pytest.mark.parametrize(\"use_assert_hostname\", [True, False])\n    def test_hostname_checks_common_name_respected(\n        self, no_san_server: ServerConfig, use_assert_hostname: bool\n    ) -> None:\n        ctx = urllib3.util.ssl_.create_urllib3_context()\n        if not hasattr(ctx, \"hostname_checks_common_name\"):\n            pytest.skip(\"Test requires 'SSLContext.hostname_checks_common_name'\")\n        ctx.load_verify_locations(no_san_server.ca_certs)\n        try:\n            ctx.hostname_checks_common_name = True\n        except AttributeError:\n            pytest.skip(\"Couldn't set 'SSLContext.hostname_checks_common_name'\")\n\n        err: MaxRetryError | None\n        try:\n            with HTTPSConnectionPool(\n                no_san_server.host,\n                no_san_server.port,\n                cert_reqs=\"CERT_REQUIRED\",\n                ssl_context=ctx,\n                assert_hostname=no_san_server.host if use_assert_hostname else None,\n            ) as https_pool:\n                https_pool.request(\"GET\", \"/\")\n        except MaxRetryError as e:\n            err = e\n        else:\n            err = None\n\n        # commonName is only valid for DNS names, not IP addresses.\n        if no_san_server.host == \"localhost\":\n            assert err is None\n\n        # IP addresses should fail for commonName.\n        else:\n            assert err is not None\n            assert type(err.reason) is SSLError\n            assert isinstance(\n                err.reason.args[0], (ssl.SSLCertVerificationError, CertificateError)\n            )\n\n    def test_assert_hostname_invalid_san(\n        self, no_localhost_san_server: ServerConfig\n    ) -> None:\n        \"\"\"Ensure SAN errors are not raised while assert_hostname is false\"\"\"\n        with HTTPSConnectionPool(\n            no_localhost_san_server.host,\n            no_localhost_san_server.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=no_localhost_san_server.ca_certs,\n            assert_hostname=False,\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n    def test_assert_hostname_invalid_cn(\n        self, no_san_server_with_different_commmon_name: ServerConfig\n    ) -> None:\n        \"\"\"Ensure CN errors are not raised while assert_hostname is false\"\"\"\n        with HTTPSConnectionPool(\n            no_san_server_with_different_commmon_name.host,\n            no_san_server_with_different_commmon_name.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=no_san_server_with_different_commmon_name.ca_certs,\n            assert_hostname=False,\n        ) as https_pool:\n            https_pool.request(\"GET\", \"/\")\n\n\nclass TestHTTPS_IPV4SAN:\n    def test_can_validate_ip_san(self, ipv4_san_server: ServerConfig) -> None:\n        \"\"\"Ensure that urllib3 can validate SANs with IP addresses in them.\"\"\"\n        with HTTPSConnectionPool(\n            ipv4_san_server.host,\n            ipv4_san_server.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=ipv4_san_server.ca_certs,\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200\n\n\nclass TestHTTPS_IPV6SAN:\n    @pytest.mark.parametrize(\"host\", [\"::1\", \"[::1]\"])\n    def test_can_validate_ipv6_san(\n        self, ipv6_san_server: ServerConfig, host: str, http_version: str\n    ) -> None:\n        \"\"\"Ensure that urllib3 can validate SANs with IPv6 addresses in them.\"\"\"\n        with HTTPSConnectionPool(\n            host,\n            ipv6_san_server.port,\n            cert_reqs=\"CERT_REQUIRED\",\n            ca_certs=ipv6_san_server.ca_certs,\n        ) as https_pool:\n            r = https_pool.request(\"GET\", \"/\")\n            assert r.status == 200\n            assert r.headers[\"server\"] == f\"hypercorn-{http_version}\"\n", "test/with_dummyserver/test_poolmanager.py": "from __future__ import annotations\n\nimport gzip\nimport typing\nfrom test import LONG_TIMEOUT\nfrom unittest import mock\n\nimport pytest\n\nfrom dummyserver.socketserver import HAS_IPV6\nfrom dummyserver.testcase import (\n    HypercornDummyServerTestCase,\n    IPv6HypercornDummyServerTestCase,\n)\nfrom urllib3 import HTTPHeaderDict, HTTPResponse, request\nfrom urllib3.connectionpool import port_by_scheme\nfrom urllib3.exceptions import MaxRetryError, URLSchemeUnknown\nfrom urllib3.poolmanager import PoolManager\nfrom urllib3.util.retry import Retry\n\n\nclass TestPoolManager(HypercornDummyServerTestCase):\n    @classmethod\n    def setup_class(cls) -> None:\n        super().setup_class()\n        cls.base_url = f\"http://{cls.host}:{cls.port}\"\n        cls.base_url_alt = f\"http://{cls.host_alt}:{cls.port}\"\n\n    def test_redirect(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url}/\"},\n                redirect=False,\n            )\n\n            assert r.status == 303\n\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url}/\"},\n            )\n\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_redirect_twice(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url}/redirect\"},\n                redirect=False,\n            )\n\n            assert r.status == 303\n\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url}/redirect?target={self.base_url}/\"},\n            )\n\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_redirect_to_relative_url(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": \"/redirect\"},\n                redirect=False,\n            )\n\n            assert r.status == 303\n\n            r = http.request(\n                \"GET\", f\"{self.base_url}/redirect\", fields={\"target\": \"/redirect\"}\n            )\n\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_cross_host_redirect(self) -> None:\n        with PoolManager() as http:\n            cross_host_location = f\"{self.base_url_alt}/echo?a=b\"\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    f\"{self.base_url}/redirect\",\n                    fields={\"target\": cross_host_location},\n                    timeout=LONG_TIMEOUT,\n                    retries=0,\n                )\n\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/echo?a=b\"},\n                timeout=LONG_TIMEOUT,\n                retries=1,\n            )\n\n            assert isinstance(r, HTTPResponse)\n            assert r._pool is not None\n            assert r._pool.host == self.host_alt\n\n    def test_too_many_redirects(self) -> None:\n        with PoolManager() as http:\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    f\"{self.base_url}/redirect\",\n                    fields={\n                        \"target\": f\"{self.base_url}/redirect?target={self.base_url}/\"\n                    },\n                    retries=1,\n                    preload_content=False,\n                )\n\n            with pytest.raises(MaxRetryError):\n                http.request(\n                    \"GET\",\n                    f\"{self.base_url}/redirect\",\n                    fields={\n                        \"target\": f\"{self.base_url}/redirect?target={self.base_url}/\"\n                    },\n                    retries=Retry(total=None, redirect=1),\n                    preload_content=False,\n                )\n\n            # Even with preload_content=False and raise on redirects, we reused the same\n            # connection\n            assert len(http.pools) == 1\n            pool = http.connection_from_host(self.host, self.port)\n            assert pool.num_connections == 1\n\n    def test_redirect_cross_host_remove_headers(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/headers\"},\n                headers={\n                    \"Authorization\": \"foo\",\n                    \"Proxy-Authorization\": \"bar\",\n                    \"Cookie\": \"foo=bar\",\n                },\n            )\n\n            assert r.status == 200\n\n            data = r.json()\n\n            assert \"Authorization\" not in data\n            assert \"Proxy-Authorization\" not in data\n            assert \"Cookie\" not in data\n\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/headers\"},\n                headers={\n                    \"authorization\": \"foo\",\n                    \"proxy-authorization\": \"baz\",\n                    \"cookie\": \"foo=bar\",\n                },\n            )\n\n            assert r.status == 200\n\n            data = r.json()\n\n            assert \"authorization\" not in data\n            assert \"Authorization\" not in data\n            assert \"proxy-authorization\" not in data\n            assert \"Proxy-Authorization\" not in data\n            assert \"cookie\" not in data\n            assert \"Cookie\" not in data\n\n    def test_redirect_cross_host_no_remove_headers(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/headers\"},\n                headers={\n                    \"Authorization\": \"foo\",\n                    \"Proxy-Authorization\": \"bar\",\n                    \"Cookie\": \"foo=bar\",\n                },\n                retries=Retry(remove_headers_on_redirect=[]),\n            )\n\n            assert r.status == 200\n\n            data = r.json()\n\n            assert data[\"Authorization\"] == \"foo\"\n            assert data[\"Proxy-Authorization\"] == \"bar\"\n            assert data[\"Cookie\"] == \"foo=bar\"\n\n    def test_redirect_cross_host_set_removed_headers(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/headers\"},\n                headers={\n                    \"X-API-Secret\": \"foo\",\n                    \"Authorization\": \"bar\",\n                    \"Proxy-Authorization\": \"baz\",\n                    \"Cookie\": \"foo=bar\",\n                },\n                retries=Retry(remove_headers_on_redirect=[\"X-API-Secret\"]),\n            )\n\n            assert r.status == 200\n\n            data = r.json()\n\n            assert \"X-API-Secret\" not in data\n            assert data[\"Authorization\"] == \"bar\"\n            assert data[\"Proxy-Authorization\"] == \"baz\"\n            assert data[\"Cookie\"] == \"foo=bar\"\n\n            headers = {\n                \"x-api-secret\": \"foo\",\n                \"authorization\": \"bar\",\n                \"proxy-authorization\": \"baz\",\n                \"cookie\": \"foo=bar\",\n            }\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url_alt}/headers\"},\n                headers=headers,\n                retries=Retry(remove_headers_on_redirect=[\"X-API-Secret\"]),\n            )\n\n            assert r.status == 200\n\n            data = r.json()\n\n            assert \"x-api-secret\" not in data\n            assert \"X-API-Secret\" not in data\n            assert data[\"Authorization\"] == \"bar\"\n            assert data[\"Proxy-Authorization\"] == \"baz\"\n            assert data[\"Cookie\"] == \"foo=bar\"\n\n            # Ensure the header argument itself is not modified in-place.\n            assert headers == {\n                \"x-api-secret\": \"foo\",\n                \"authorization\": \"bar\",\n                \"proxy-authorization\": \"baz\",\n                \"cookie\": \"foo=bar\",\n            }\n\n    def test_redirect_without_preload_releases_connection(self) -> None:\n        with PoolManager(block=True, maxsize=2) as http:\n            r = http.request(\"GET\", f\"{self.base_url}/redirect\", preload_content=False)\n            assert isinstance(r, HTTPResponse)\n            assert r._pool is not None\n            assert r._pool.num_requests == 2\n            assert r._pool.num_connections == 1\n            assert len(http.pools) == 1\n\n    def test_303_redirect_makes_request_lose_body(self) -> None:\n        with PoolManager() as http:\n            response = http.request(\n                \"POST\",\n                f\"{self.base_url}/redirect\",\n                fields={\n                    \"target\": f\"{self.base_url}/headers_and_params\",\n                    \"status\": \"303 See Other\",\n                },\n            )\n        data = response.json()\n        assert data[\"params\"] == {}\n        assert \"Content-Type\" not in HTTPHeaderDict(data[\"headers\"])\n\n    def test_unknown_scheme(self) -> None:\n        with PoolManager() as http:\n            unknown_scheme = \"unknown\"\n            unknown_scheme_url = f\"{unknown_scheme}://host\"\n            with pytest.raises(URLSchemeUnknown) as e:\n                r = http.request(\"GET\", unknown_scheme_url)\n            assert e.value.scheme == unknown_scheme\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": unknown_scheme_url},\n                redirect=False,\n            )\n            assert r.status == 303\n            assert r.headers.get(\"Location\") == unknown_scheme_url\n            with pytest.raises(URLSchemeUnknown) as e:\n                r = http.request(\n                    \"GET\",\n                    f\"{self.base_url}/redirect\",\n                    fields={\"target\": unknown_scheme_url},\n                )\n            assert e.value.scheme == unknown_scheme\n\n    def test_raise_on_redirect(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                fields={\"target\": f\"{self.base_url}/redirect?target={self.base_url}/\"},\n                retries=Retry(total=None, redirect=1, raise_on_redirect=False),\n            )\n\n            assert r.status == 303\n\n    def test_raise_on_status(self) -> None:\n        with PoolManager() as http:\n            with pytest.raises(MaxRetryError):\n                # the default is to raise\n                r = http.request(\n                    \"GET\",\n                    f\"{self.base_url}/status\",\n                    fields={\"status\": \"500 Internal Server Error\"},\n                    retries=Retry(total=1, status_forcelist=range(500, 600)),\n                )\n\n            with pytest.raises(MaxRetryError):\n                # raise explicitly\n                r = http.request(\n                    \"GET\",\n                    f\"{self.base_url}/status\",\n                    fields={\"status\": \"500 Internal Server Error\"},\n                    retries=Retry(\n                        total=1, status_forcelist=range(500, 600), raise_on_status=True\n                    ),\n                )\n\n            # don't raise\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/status\",\n                fields={\"status\": \"500 Internal Server Error\"},\n                retries=Retry(\n                    total=1, status_forcelist=range(500, 600), raise_on_status=False\n                ),\n            )\n\n            assert r.status == 500\n\n    def test_missing_port(self) -> None:\n        # Can a URL that lacks an explicit port like ':80' succeed, or\n        # will all such URLs fail with an error?\n\n        with PoolManager() as http:\n            # By globally adjusting `port_by_scheme` we pretend for a moment\n            # that HTTP's default port is not 80, but is the port at which\n            # our test server happens to be listening.\n            port_by_scheme[\"http\"] = self.port\n            try:\n                r = http.request(\"GET\", f\"http://{self.host}/\", retries=0)\n            finally:\n                port_by_scheme[\"http\"] = 80\n\n            assert r.status == 200\n            assert r.data == b\"Dummy server!\"\n\n    def test_headers(self) -> None:\n        with PoolManager(headers={\"Foo\": \"bar\"}) as http:\n            r = http.request(\"GET\", f\"{self.base_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n\n            r = http.request(\"POST\", f\"{self.base_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n\n            r = http.request_encode_url(\"GET\", f\"{self.base_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n\n            r = http.request_encode_body(\"POST\", f\"{self.base_url}/headers\")\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") == \"bar\"\n\n            r = http.request_encode_url(\n                \"GET\", f\"{self.base_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n\n            r = http.request_encode_body(\n                \"GET\", f\"{self.base_url}/headers\", headers={\"Baz\": \"quux\"}\n            )\n            returned_headers = r.json()\n            assert returned_headers.get(\"Foo\") is None\n            assert returned_headers.get(\"Baz\") == \"quux\"\n\n    def test_headers_http_header_dict(self) -> None:\n        # Test uses a list of headers to assert the order\n        # that headers are sent in the request too.\n\n        headers = HTTPHeaderDict()\n        headers.add(\"Foo\", \"bar\")\n        headers.add(\"Multi\", \"1\")\n        headers.add(\"Baz\", \"quux\")\n        headers.add(\"Multi\", \"2\")\n\n        with PoolManager(headers=headers) as http:\n            r = http.request(\"GET\", f\"{self.base_url}/multi_headers\")\n            returned_headers = r.json()[\"headers\"]\n            assert returned_headers[-4:] == [\n                [\"Foo\", \"bar\"],\n                [\"Multi\", \"1\"],\n                [\"Multi\", \"2\"],\n                [\"Baz\", \"quux\"],\n            ]\n\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/multi_headers\",\n                headers={\n                    **headers,\n                    \"Extra\": \"extra\",\n                    \"Foo\": \"new\",\n                },\n            )\n            returned_headers = r.json()[\"headers\"]\n            assert returned_headers[-4:] == [\n                [\"Foo\", \"new\"],\n                [\"Multi\", \"1, 2\"],\n                [\"Baz\", \"quux\"],\n                [\"Extra\", \"extra\"],\n            ]\n\n    def test_merge_headers_with_pool_manager_headers(self) -> None:\n        headers = HTTPHeaderDict()\n        headers.add(\"Cookie\", \"choc-chip\")\n        headers.add(\"Cookie\", \"oatmeal-raisin\")\n        orig = headers.copy()\n        added_headers = {\"Cookie\": \"tim-tam\"}\n\n        with PoolManager(headers=headers) as http:\n            r = http.request(\n                \"GET\",\n                f\"{self.base_url}/multi_headers\",\n                headers=typing.cast(HTTPHeaderDict, http.headers) | added_headers,\n            )\n            returned_headers = r.json()[\"headers\"]\n            assert returned_headers[-3:] == [\n                [\"Cookie\", \"choc-chip\"],\n                [\"Cookie\", \"oatmeal-raisin\"],\n                [\"Cookie\", \"tim-tam\"],\n            ]\n            # make sure the pool headers weren't modified\n            assert http.headers == orig\n\n    def test_headers_http_multi_header_multipart(self) -> None:\n        headers = HTTPHeaderDict()\n        headers.add(\"Multi\", \"1\")\n        headers.add(\"Multi\", \"2\")\n        old_headers = headers.copy()\n\n        with PoolManager(headers=headers) as http:\n            r = http.request(\n                \"POST\",\n                f\"{self.base_url}/multi_headers\",\n                fields={\"k\": \"v\"},\n                multipart_boundary=\"b\",\n                encode_multipart=True,\n            )\n            returned_headers = r.json()[\"headers\"]\n            assert returned_headers[5:] == [\n                [\"Multi\", \"1\"],\n                [\"Multi\", \"2\"],\n                [\"Content-Type\", \"multipart/form-data; boundary=b\"],\n            ]\n            # Assert that the previous headers weren't modified.\n            assert headers == old_headers\n\n            # Set a default value for the Content-Type\n            headers[\"Content-Type\"] = \"multipart/form-data; boundary=b; field=value\"\n            r = http.request(\n                \"POST\",\n                f\"{self.base_url}/multi_headers\",\n                fields={\"k\": \"v\"},\n                multipart_boundary=\"b\",\n                encode_multipart=True,\n            )\n            returned_headers = r.json()[\"headers\"]\n            assert returned_headers[5:] == [\n                [\"Multi\", \"1\"],\n                [\"Multi\", \"2\"],\n                # Uses the set value, not the one that would be generated.\n                [\"Content-Type\", \"multipart/form-data; boundary=b; field=value\"],\n            ]\n\n    def test_body(self) -> None:\n        with PoolManager() as http:\n            r = http.request(\"POST\", f\"{self.base_url}/echo\", body=b\"test\")\n            assert r.data == b\"test\"\n\n    def test_http_with_ssl_keywords(self) -> None:\n        with PoolManager(ca_certs=\"REQUIRED\") as http:\n            r = http.request(\"GET\", f\"http://{self.host}:{self.port}/\")\n            assert r.status == 200\n\n    def test_http_with_server_hostname(self) -> None:\n        with PoolManager(server_hostname=\"example.com\") as http:\n            r = http.request(\"GET\", f\"http://{self.host}:{self.port}/\")\n            assert r.status == 200\n\n    def test_http_with_ca_cert_dir(self) -> None:\n        with PoolManager(ca_certs=\"REQUIRED\", ca_cert_dir=\"/nosuchdir\") as http:\n            r = http.request(\"GET\", f\"http://{self.host}:{self.port}/\")\n            assert r.status == 200\n\n    @pytest.mark.parametrize(\n        [\"target\", \"expected_target\"],\n        [\n            # annoyingly quart.request.full_path adds a stray `?`\n            (\"/echo_uri\", b\"/echo_uri?\"),\n            (\"/echo_uri?q=1#fragment\", b\"/echo_uri?q=1\"),\n            (\"/echo_uri?#\", b\"/echo_uri?\"),\n            (\"/echo_uri#!\", b\"/echo_uri?\"),\n            (\"/echo_uri#!#\", b\"/echo_uri?\"),\n            (\"/echo_uri??#\", b\"/echo_uri??\"),\n            (\"/echo_uri?%3f#\", b\"/echo_uri?%3F\"),\n            (\"/echo_uri?%3F#\", b\"/echo_uri?%3F\"),\n            (\"/echo_uri?[]\", b\"/echo_uri?%5B%5D\"),\n        ],\n    )\n    def test_encode_http_target(self, target: str, expected_target: bytes) -> None:\n        with PoolManager() as http:\n            url = f\"http://{self.host}:{self.port}{target}\"\n            r = http.request(\"GET\", url)\n            assert r.data == expected_target\n\n    def test_top_level_request(self) -> None:\n        r = request(\"GET\", f\"{self.base_url}/\")\n        assert r.status == 200\n        assert r.data == b\"Dummy server!\"\n\n    def test_top_level_request_without_keyword_args(self) -> None:\n        body = \"\"\n        with pytest.raises(TypeError):\n            request(\"GET\", f\"{self.base_url}/\", body)  # type: ignore[misc]\n\n    def test_top_level_request_with_body(self) -> None:\n        r = request(\"POST\", f\"{self.base_url}/echo\", body=b\"test\")\n        assert r.status == 200\n        assert r.data == b\"test\"\n\n    def test_top_level_request_with_preload_content(self) -> None:\n        r = request(\"GET\", f\"{self.base_url}/echo\", preload_content=False)\n        assert r.status == 200\n        assert r.connection is not None\n        r.data\n        assert r.connection is None\n\n    def test_top_level_request_with_decode_content(self) -> None:\n        r = request(\n            \"GET\",\n            f\"{self.base_url}/encodingrequest\",\n            headers={\"accept-encoding\": \"gzip\"},\n            decode_content=False,\n        )\n        assert r.status == 200\n        assert gzip.decompress(r.data) == b\"hello, world!\"\n\n        r = request(\n            \"GET\",\n            f\"{self.base_url}/encodingrequest\",\n            headers={\"accept-encoding\": \"gzip\"},\n            decode_content=True,\n        )\n        assert r.status == 200\n        assert r.data == b\"hello, world!\"\n\n    def test_top_level_request_with_redirect(self) -> None:\n        r = request(\n            \"GET\",\n            f\"{self.base_url}/redirect\",\n            fields={\"target\": f\"{self.base_url}/\"},\n            redirect=False,\n        )\n\n        assert r.status == 303\n\n        r = request(\n            \"GET\",\n            f\"{self.base_url}/redirect\",\n            fields={\"target\": f\"{self.base_url}/\"},\n            redirect=True,\n        )\n\n        assert r.status == 200\n        assert r.data == b\"Dummy server!\"\n\n    def test_top_level_request_with_retries(self) -> None:\n        r = request(\"GET\", f\"{self.base_url}/redirect\", retries=False)\n        assert r.status == 303\n\n        r = request(\"GET\", f\"{self.base_url}/redirect\", retries=3)\n        assert r.status == 200\n\n    def test_top_level_request_with_timeout(self) -> None:\n        with mock.patch(\"urllib3.poolmanager.RequestMethods.request\") as mockRequest:\n            mockRequest.return_value = HTTPResponse(status=200)\n\n            r = request(\"GET\", f\"{self.base_url}/redirect\", timeout=2.5)\n\n            assert r.status == 200\n\n            mockRequest.assert_called_with(\n                \"GET\",\n                f\"{self.base_url}/redirect\",\n                body=None,\n                fields=None,\n                headers=None,\n                preload_content=True,\n                decode_content=True,\n                redirect=True,\n                retries=None,\n                timeout=2.5,\n                json=None,\n            )\n\n    @pytest.mark.parametrize(\n        \"headers\",\n        [\n            None,\n            {\"content-Type\": \"application/json\"},\n            {\"content-Type\": \"text/plain\"},\n            {\"attribute\": \"value\", \"CONTENT-TYPE\": \"application/json\"},\n            HTTPHeaderDict(cookie=\"foo, bar\"),\n        ],\n    )\n    def test_request_with_json(self, headers: HTTPHeaderDict) -> None:\n        old_headers = None if headers is None else headers.copy()\n        body = {\"attribute\": \"value\"}\n        r = request(\n            method=\"POST\", url=f\"{self.base_url}/echo_json\", headers=headers, json=body\n        )\n        assert r.status == 200\n        assert r.json() == body\n        content_type = HTTPHeaderDict(old_headers).get(\n            \"Content-Type\", \"application/json\"\n        )\n        assert content_type in r.headers[\"Content-Type\"].replace(\" \", \"\").split(\",\")\n\n        # Ensure the header argument itself is not modified in-place.\n        assert headers == old_headers\n\n    def test_top_level_request_with_json_with_httpheaderdict(self) -> None:\n        body = {\"attribute\": \"value\"}\n        header = HTTPHeaderDict(cookie=\"foo, bar\")\n        with PoolManager(headers=header) as http:\n            r = http.request(method=\"POST\", url=f\"{self.base_url}/echo_json\", json=body)\n            assert r.status == 200\n            assert r.json() == body\n            assert \"application/json\" in r.headers[\"Content-Type\"].replace(\n                \" \", \"\"\n            ).split(\",\")\n\n    def test_top_level_request_with_body_and_json(self) -> None:\n        match = \"request got values for both 'body' and 'json' parameters which are mutually exclusive\"\n        with pytest.raises(TypeError, match=match):\n            body = {\"attribute\": \"value\"}\n            request(method=\"POST\", url=f\"{self.base_url}/echo\", body=\"\", json=body)\n\n    def test_top_level_request_with_invalid_body(self) -> None:\n        class BadBody:\n            def __repr__(self) -> str:\n                return \"<BadBody>\"\n\n        with pytest.raises(TypeError) as e:\n            request(\n                method=\"POST\",\n                url=f\"{self.base_url}/echo\",\n                body=BadBody(),  # type: ignore[arg-type]\n            )\n        assert str(e.value) == (\n            \"'body' must be a bytes-like object, file-like \"\n            \"object, or iterable. Instead was <BadBody>\"\n        )\n\n\n@pytest.mark.skipif(not HAS_IPV6, reason=\"IPv6 is not supported on this system\")\nclass TestIPv6PoolManager(IPv6HypercornDummyServerTestCase):\n    @classmethod\n    def setup_class(cls) -> None:\n        super().setup_class()\n        cls.base_url = f\"http://[{cls.host}]:{cls.port}\"\n\n    def test_ipv6(self) -> None:\n        with PoolManager() as http:\n            http.request(\"GET\", self.base_url)\n", "docs/conf.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom datetime import date\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n\nroot_path = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\nsys.path.insert(0, root_path)\n\n# https://docs.readthedocs.io/en/stable/builds.html#build-environment\nif \"READTHEDOCS\" in os.environ:\n    import glob\n\n    if glob.glob(\"../changelog/*.*.rst\"):\n        print(\"-- Found changes; running towncrier --\", flush=True)\n        import subprocess\n\n        subprocess.run(\n            [\"towncrier\", \"--yes\", \"--date\", \"not released yet\"], cwd=\"..\", check=True\n        )\n\nimport urllib3\n\n# -- General configuration -----------------------------------------------------\n\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx_copybutton\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinxext.opengraph\",\n]\n\n# Open Graph metadata\nogp_title = \"urllib3 documentation\"\nogp_type = \"website\"\nogp_social_cards = {\"image\": \"images/logo.png\", \"line_color\": \"#F09837\"}\nogp_description = \"urllib3 is a user-friendly HTTP client library for Python.\"\n\n# Test code blocks only when explicitly specified\ndoctest_test_doctest_blocks = \"\"\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"urllib3\"\ncopyright = f\"{date.today().year}, Andrey Petrov\"\n\n# The short X.Y version.\nversion = urllib3.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"friendly\"\n\n# The base URL with a proper language and version.\nhtml_baseurl = os.environ.get(\"READTHEDOCS_CANONICAL_URL\", \"/\")\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"furo\"\nhtml_favicon = \"images/favicon.png\"\n\nhtml_static_path = [\"_static\"]\nhtml_theme_options = {\n    \"announcement\": \"\"\"\n        <a style=\\\"text-decoration: none; color: white;\\\" \n           href=\\\"https://opencollective.com/urllib3/updates/urllib3-is-fundraising-for-http-2-support\\\">\n           <img src=\\\"/en/latest/_static/favicon.png\\\"/> urllib3 is fundraising for HTTP/2 support!\n        </a>\n    \"\"\",\n    \"sidebar_hide_name\": True,\n    \"light_logo\": \"banner.svg\",\n    \"dark_logo\": \"dark-logo.svg\",\n}\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\n\n# Show typehints as content of the function or method\nautodoc_typehints = \"description\"\n\n# Warn about all references to unknown targets\nnitpicky = True\n# Except for these ones, which we expect to point to unknown targets:\nnitpick_ignore = [\n    (\"py:class\", \"_TYPE_SOCKS_OPTIONS\"),\n    (\"py:class\", \"_TYPE_SOCKET_OPTIONS\"),\n    (\"py:class\", \"_TYPE_TIMEOUT\"),\n    (\"py:class\", \"_TYPE_FIELD_VALUE\"),\n    (\"py:class\", \"_TYPE_BODY\"),\n    (\"py:class\", \"_HttplibHTTPResponse\"),\n    (\"py:class\", \"_HttplibHTTPMessage\"),\n    (\"py:class\", \"TracebackType\"),\n    (\"py:class\", \"email.errors.MessageDefect\"),\n    (\"py:class\", \"MessageDefect\"),\n    (\"py:class\", \"http.client.HTTPMessage\"),\n    (\"py:class\", \"RequestHistory\"),\n    (\"py:class\", \"SSLTransportType\"),\n    (\"py:class\", \"VerifyMode\"),\n    (\"py:class\", \"_ssl._SSLContext\"),\n    (\"py:class\", \"urllib3._collections.HTTPHeaderDict\"),\n    (\"py:class\", \"urllib3._collections.RecentlyUsedContainer\"),\n    (\"py:class\", \"urllib3._request_methods.RequestMethods\"),\n    (\"py:class\", \"urllib3.contrib.socks._TYPE_SOCKS_OPTIONS\"),\n    (\"py:class\", \"urllib3.util.timeout._TYPE_DEFAULT\"),\n    (\"py:class\", \"BaseHTTPConnection\"),\n]\n", "src/urllib3/response.py": "from __future__ import annotations\n\nimport collections\nimport io\nimport json as _json\nimport logging\nimport re\nimport sys\nimport typing\nimport warnings\nimport zlib\nfrom contextlib import contextmanager\nfrom http.client import HTTPMessage as _HttplibHTTPMessage\nfrom http.client import HTTPResponse as _HttplibHTTPResponse\nfrom socket import timeout as SocketTimeout\n\nif typing.TYPE_CHECKING:\n    from ._base_connection import BaseHTTPConnection\n\ntry:\n    try:\n        import brotlicffi as brotli  # type: ignore[import-not-found]\n    except ImportError:\n        import brotli  # type: ignore[import-not-found]\nexcept ImportError:\n    brotli = None\n\ntry:\n    import zstandard as zstd\nexcept (AttributeError, ImportError, ValueError):  # Defensive:\n    HAS_ZSTD = False\nelse:\n    # The package 'zstandard' added the 'eof' property starting\n    # in v0.18.0 which we require to ensure a complete and\n    # valid zstd stream was fed into the ZstdDecoder.\n    # See: https://github.com/urllib3/urllib3/pull/2624\n    _zstd_version = tuple(\n        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n    )\n    if _zstd_version < (0, 18):  # Defensive:\n        HAS_ZSTD = False\n    else:\n        HAS_ZSTD = True\n\nfrom . import util\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom .connection import BaseSSLError, HTTPConnection, HTTPException\nfrom .exceptions import (\n    BodyNotHttplibCompatible,\n    DecodeError,\n    HTTPError,\n    IncompleteRead,\n    InvalidChunkLength,\n    InvalidHeader,\n    ProtocolError,\n    ReadTimeoutError,\n    ResponseNotChunked,\n    SSLError,\n)\nfrom .util.response import is_fp_closed, is_response_to_head\nfrom .util.retry import Retry\n\nif typing.TYPE_CHECKING:\n    from .connectionpool import HTTPConnectionPool\n\nlog = logging.getLogger(__name__)\n\n\nclass ContentDecoder:\n    def decompress(self, data: bytes) -> bytes:\n        raise NotImplementedError()\n\n    def flush(self) -> bytes:\n        raise NotImplementedError()\n\n\nclass DeflateDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._first_try = True\n        self._data = b\"\"\n        self._obj = zlib.decompressobj()\n\n    def decompress(self, data: bytes) -> bytes:\n        if not data:\n            return data\n\n        if not self._first_try:\n            return self._obj.decompress(data)\n\n        self._data += data\n        try:\n            decompressed = self._obj.decompress(data)\n            if decompressed:\n                self._first_try = False\n                self._data = None  # type: ignore[assignment]\n            return decompressed\n        except zlib.error:\n            self._first_try = False\n            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)\n            try:\n                return self.decompress(self._data)\n            finally:\n                self._data = None  # type: ignore[assignment]\n\n    def flush(self) -> bytes:\n        return self._obj.flush()\n\n\nclass GzipDecoderState:\n    FIRST_MEMBER = 0\n    OTHER_MEMBERS = 1\n    SWALLOW_DATA = 2\n\n\nclass GzipDecoder(ContentDecoder):\n    def __init__(self) -> None:\n        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        self._state = GzipDecoderState.FIRST_MEMBER\n\n    def decompress(self, data: bytes) -> bytes:\n        ret = bytearray()\n        if self._state == GzipDecoderState.SWALLOW_DATA or not data:\n            return bytes(ret)\n        while True:\n            try:\n                ret += self._obj.decompress(data)\n            except zlib.error:\n                previous_state = self._state\n                # Ignore data after the first error\n                self._state = GzipDecoderState.SWALLOW_DATA\n                if previous_state == GzipDecoderState.OTHER_MEMBERS:\n                    # Allow trailing garbage acceptable in other gzip clients\n                    return bytes(ret)\n                raise\n            data = self._obj.unused_data\n            if not data:\n                return bytes(ret)\n            self._state = GzipDecoderState.OTHER_MEMBERS\n            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n\n    def flush(self) -> bytes:\n        return self._obj.flush()\n\n\nif brotli is not None:\n\n    class BrotliDecoder(ContentDecoder):\n        # Supports both 'brotlipy' and 'Brotli' packages\n        # since they share an import name. The top branches\n        # are for 'brotlipy' and bottom branches for 'Brotli'\n        def __init__(self) -> None:\n            self._obj = brotli.Decompressor()\n            if hasattr(self._obj, \"decompress\"):\n                setattr(self, \"decompress\", self._obj.decompress)\n            else:\n                setattr(self, \"decompress\", self._obj.process)\n\n        def flush(self) -> bytes:\n            if hasattr(self._obj, \"flush\"):\n                return self._obj.flush()  # type: ignore[no-any-return]\n            return b\"\"\n\n\nif HAS_ZSTD:\n\n    class ZstdDecoder(ContentDecoder):\n        def __init__(self) -> None:\n            self._obj = zstd.ZstdDecompressor().decompressobj()\n\n        def decompress(self, data: bytes) -> bytes:\n            if not data:\n                return b\"\"\n            data_parts = [self._obj.decompress(data)]\n            while self._obj.eof and self._obj.unused_data:\n                unused_data = self._obj.unused_data\n                self._obj = zstd.ZstdDecompressor().decompressobj()\n                data_parts.append(self._obj.decompress(unused_data))\n            return b\"\".join(data_parts)\n\n        def flush(self) -> bytes:\n            ret = self._obj.flush()  # note: this is a no-op\n            if not self._obj.eof:\n                raise DecodeError(\"Zstandard data is incomplete\")\n            return ret\n\n\nclass MultiDecoder(ContentDecoder):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n\n    def __init__(self, modes: str) -> None:\n        self._decoders = [_get_decoder(m.strip()) for m in modes.split(\",\")]\n\n    def flush(self) -> bytes:\n        return self._decoders[0].flush()\n\n    def decompress(self, data: bytes) -> bytes:\n        for d in reversed(self._decoders):\n            data = d.decompress(data)\n        return data\n\n\ndef _get_decoder(mode: str) -> ContentDecoder:\n    if \",\" in mode:\n        return MultiDecoder(mode)\n\n    # According to RFC 9110 section 8.4.1.3, recipients should\n    # consider x-gzip equivalent to gzip\n    if mode in (\"gzip\", \"x-gzip\"):\n        return GzipDecoder()\n\n    if brotli is not None and mode == \"br\":\n        return BrotliDecoder()\n\n    if HAS_ZSTD and mode == \"zstd\":\n        return ZstdDecoder()\n\n    return DeflateDecoder()\n\n\nclass BytesQueueBuffer:\n    \"\"\"Memory-efficient bytes buffer\n\n    To return decoded data in read() and still follow the BufferedIOBase API, we need a\n    buffer to always return the correct amount of bytes.\n\n    This buffer should be filled using calls to put()\n\n    Our maximum memory usage is determined by the sum of the size of:\n\n     * self.buffer, which contains the full data\n     * the largest chunk that we will copy in get()\n\n    The worst case scenario is a single chunk, in which case we'll make a full copy of\n    the data inside get().\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.buffer: typing.Deque[bytes] = collections.deque()\n        self._size: int = 0\n\n    def __len__(self) -> int:\n        return self._size\n\n    def put(self, data: bytes) -> None:\n        self.buffer.append(data)\n        self._size += len(data)\n\n    def get(self, n: int) -> bytes:\n        if n == 0:\n            return b\"\"\n        elif not self.buffer:\n            raise RuntimeError(\"buffer is empty\")\n        elif n < 0:\n            raise ValueError(\"n should be > 0\")\n\n        fetched = 0\n        ret = io.BytesIO()\n        while fetched < n:\n            remaining = n - fetched\n            chunk = self.buffer.popleft()\n            chunk_length = len(chunk)\n            if remaining < chunk_length:\n                left_chunk, right_chunk = chunk[:remaining], chunk[remaining:]\n                ret.write(left_chunk)\n                self.buffer.appendleft(right_chunk)\n                self._size -= remaining\n                break\n            else:\n                ret.write(chunk)\n                self._size -= chunk_length\n            fetched += chunk_length\n\n            if not self.buffer:\n                break\n\n        return ret.getvalue()\n\n    def get_all(self) -> bytes:\n        buffer = self.buffer\n        if not buffer:\n            assert self._size == 0\n            return b\"\"\n        if len(buffer) == 1:\n            result = buffer.pop()\n        else:\n            ret = io.BytesIO()\n            ret.writelines(buffer.popleft() for _ in range(len(buffer)))\n            result = ret.getvalue()\n        self._size = 0\n        return result\n\n\nclass BaseHTTPResponse(io.IOBase):\n    CONTENT_DECODERS = [\"gzip\", \"x-gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    if HAS_ZSTD:\n        CONTENT_DECODERS += [\"zstd\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n\n    DECODER_ERROR_CLASSES: tuple[type[Exception], ...] = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)\n\n    if HAS_ZSTD:\n        DECODER_ERROR_CLASSES += (zstd.ZstdError,)\n\n    def __init__(\n        self,\n        *,\n        headers: typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None = None,\n        status: int,\n        version: int,\n        version_string: str,\n        reason: str | None,\n        decode_content: bool,\n        request_url: str | None,\n        retries: Retry | None = None,\n    ) -> None:\n        if isinstance(headers, HTTPHeaderDict):\n            self.headers = headers\n        else:\n            self.headers = HTTPHeaderDict(headers)  # type: ignore[arg-type]\n        self.status = status\n        self.version = version\n        self.version_string = version_string\n        self.reason = reason\n        self.decode_content = decode_content\n        self._has_decoded_content = False\n        self._request_url: str | None = request_url\n        self.retries = retries\n\n        self.chunked = False\n        tr_enc = self.headers.get(\"transfer-encoding\", \"\").lower()\n        # Don't incur the penalty of creating a list and then discarding it\n        encodings = (enc.strip() for enc in tr_enc.split(\",\"))\n        if \"chunked\" in encodings:\n            self.chunked = True\n\n        self._decoder: ContentDecoder | None = None\n        self.length_remaining: int | None\n\n    def get_redirect_location(self) -> str | None | typing.Literal[False]:\n        \"\"\"\n        Should we redirect and where to?\n\n        :returns: Truthy redirect location string if we got a redirect status\n            code and valid location. ``None`` if redirect status and no\n            location. ``False`` if not a redirect status code.\n        \"\"\"\n        if self.status in self.REDIRECT_STATUSES:\n            return self.headers.get(\"location\")\n        return False\n\n    @property\n    def data(self) -> bytes:\n        raise NotImplementedError()\n\n    def json(self) -> typing.Any:\n        \"\"\"\n        Deserializes the body of the HTTP response as a Python object.\n\n        The body of the HTTP response must be encoded using UTF-8, as per\n        `RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\n        To use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\n        your custom decoder instead.\n\n        If the body of the HTTP response is not decodable to UTF-8, a\n        `UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\n        valid JSON document, a `json.JSONDecodeError` will be raised.\n\n        Read more :ref:`here <json_content>`.\n\n        :returns: The body of the HTTP response as a Python object.\n        \"\"\"\n        data = self.data.decode(\"utf-8\")\n        return _json.loads(data)\n\n    @property\n    def url(self) -> str | None:\n        raise NotImplementedError()\n\n    @url.setter\n    def url(self, url: str | None) -> None:\n        raise NotImplementedError()\n\n    @property\n    def connection(self) -> BaseHTTPConnection | None:\n        raise NotImplementedError()\n\n    @property\n    def retries(self) -> Retry | None:\n        return self._retries\n\n    @retries.setter\n    def retries(self, retries: Retry | None) -> None:\n        # Override the request_url if retries has a redirect location.\n        if retries is not None and retries.history:\n            self.url = retries.history[-1].redirect_location\n        self._retries = retries\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Iterator[bytes]:\n        raise NotImplementedError()\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n        cache_content: bool = False,\n    ) -> bytes:\n        raise NotImplementedError()\n\n    def read1(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> bytes:\n        raise NotImplementedError()\n\n    def read_chunked(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> typing.Iterator[bytes]:\n        raise NotImplementedError()\n\n    def release_conn(self) -> None:\n        raise NotImplementedError()\n\n    def drain_conn(self) -> None:\n        raise NotImplementedError()\n\n    def close(self) -> None:\n        raise NotImplementedError()\n\n    def _init_decoder(self) -> None:\n        \"\"\"\n        Set-up the _decoder attribute if necessary.\n        \"\"\"\n        # Note: content-encoding value should be case-insensitive, per RFC 7230\n        # Section 3.2\n        content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n        if self._decoder is None:\n            if content_encoding in self.CONTENT_DECODERS:\n                self._decoder = _get_decoder(content_encoding)\n            elif \",\" in content_encoding:\n                encodings = [\n                    e.strip()\n                    for e in content_encoding.split(\",\")\n                    if e.strip() in self.CONTENT_DECODERS\n                ]\n                if encodings:\n                    self._decoder = _get_decoder(content_encoding)\n\n    def _decode(\n        self, data: bytes, decode_content: bool | None, flush_decoder: bool\n    ) -> bytes:\n        \"\"\"\n        Decode the data passed in and potentially flush the decoder.\n        \"\"\"\n        if not decode_content:\n            if self._has_decoded_content:\n                raise RuntimeError(\n                    \"Calling read(decode_content=False) is not supported after \"\n                    \"read(decode_content=True) was called.\"\n                )\n            return data\n\n        try:\n            if self._decoder:\n                data = self._decoder.decompress(data)\n                self._has_decoded_content = True\n        except self.DECODER_ERROR_CLASSES as e:\n            content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n            raise DecodeError(\n                \"Received response with content-encoding: %s, but \"\n                \"failed to decode it.\" % content_encoding,\n                e,\n            ) from e\n        if flush_decoder:\n            data += self._flush_decoder()\n\n        return data\n\n    def _flush_decoder(self) -> bytes:\n        \"\"\"\n        Flushes the decoder. Should only be called if the decoder is actually\n        being used.\n        \"\"\"\n        if self._decoder:\n            return self._decoder.decompress(b\"\") + self._decoder.flush()\n        return b\"\"\n\n    # Compatibility methods for `io` module\n    def readinto(self, b: bytearray) -> int:\n        temp = self.read(len(b))\n        if len(temp) == 0:\n            return 0\n        else:\n            b[: len(temp)] = temp\n            return len(temp)\n\n    # Compatibility methods for http.client.HTTPResponse\n    def getheaders(self) -> HTTPHeaderDict:\n        warnings.warn(\n            \"HTTPResponse.getheaders() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead access HTTPResponse.headers directly.\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.headers\n\n    def getheader(self, name: str, default: str | None = None) -> str | None:\n        warnings.warn(\n            \"HTTPResponse.getheader() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead use HTTPResponse.headers.get(name, default).\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.headers.get(name, default)\n\n    # Compatibility method for http.cookiejar\n    def info(self) -> HTTPHeaderDict:\n        return self.headers\n\n    def geturl(self) -> str | None:\n        return self.url\n\n\nclass HTTPResponse(BaseHTTPResponse):\n    \"\"\"\n    HTTP Response container.\n\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n\n    :param preload_content:\n        If True, the response's body will be preloaded during construction.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param original_response:\n        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`\n        object, it's convenient to include the original for debug purposes. It's\n        otherwise unused.\n\n    :param retries:\n        The retries contains the last :class:`~urllib3.util.retry.Retry` that\n        was used during the request.\n\n    :param enforce_content_length:\n        Enforce content length checking. Body returned by server must match\n        value of Content-Length header, if present. Otherwise, raise error.\n    \"\"\"\n\n    def __init__(\n        self,\n        body: _TYPE_BODY = \"\",\n        headers: typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None = None,\n        status: int = 0,\n        version: int = 0,\n        version_string: str = \"HTTP/?\",\n        reason: str | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        original_response: _HttplibHTTPResponse | None = None,\n        pool: HTTPConnectionPool | None = None,\n        connection: HTTPConnection | None = None,\n        msg: _HttplibHTTPMessage | None = None,\n        retries: Retry | None = None,\n        enforce_content_length: bool = True,\n        request_method: str | None = None,\n        request_url: str | None = None,\n        auto_close: bool = True,\n    ) -> None:\n        super().__init__(\n            headers=headers,\n            status=status,\n            version=version,\n            version_string=version_string,\n            reason=reason,\n            decode_content=decode_content,\n            request_url=request_url,\n            retries=retries,\n        )\n\n        self.enforce_content_length = enforce_content_length\n        self.auto_close = auto_close\n\n        self._body = None\n        self._fp: _HttplibHTTPResponse | None = None\n        self._original_response = original_response\n        self._fp_bytes_read = 0\n        self.msg = msg\n\n        if body and isinstance(body, (str, bytes)):\n            self._body = body\n\n        self._pool = pool\n        self._connection = connection\n\n        if hasattr(body, \"read\"):\n            self._fp = body  # type: ignore[assignment]\n\n        # Are we using the chunked-style of transfer encoding?\n        self.chunk_left: int | None = None\n\n        # Determine length of response\n        self.length_remaining = self._init_length(request_method)\n\n        # Used to return the correct amount of bytes for partial read()s\n        self._decoded_buffer = BytesQueueBuffer()\n\n        # If requested, preload the body.\n        if preload_content and not self._body:\n            self._body = self.read(decode_content=decode_content)\n\n    def release_conn(self) -> None:\n        if not self._pool or not self._connection:\n            return None\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self) -> None:\n        \"\"\"\n        Read and discard any remaining HTTP response data in the response connection.\n\n        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n        \"\"\"\n        try:\n            self.read()\n        except (HTTPError, OSError, BaseSSLError, HTTPException):\n            pass\n\n    @property\n    def data(self) -> bytes:\n        # For backwards-compat with earlier urllib3 0.4 and earlier.\n        if self._body:\n            return self._body  # type: ignore[return-value]\n\n        if self._fp:\n            return self.read(cache_content=True)\n\n        return None  # type: ignore[return-value]\n\n    @property\n    def connection(self) -> HTTPConnection | None:\n        return self._connection\n\n    def isclosed(self) -> bool:\n        return is_fp_closed(self._fp)\n\n    def tell(self) -> int:\n        \"\"\"\n        Obtain the number of bytes pulled over the wire so far. May differ from\n        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n        if bytes are encoded on the wire (e.g, compressed).\n        \"\"\"\n        return self._fp_bytes_read\n\n    def _init_length(self, request_method: str | None) -> int | None:\n        \"\"\"\n        Set initial length value for Response content if available.\n        \"\"\"\n        length: int | None\n        content_length: str | None = self.headers.get(\"content-length\")\n\n        if content_length is not None:\n            if self.chunked:\n                # This Response will fail with an IncompleteRead if it can't be\n                # received as chunked. This method falls back to attempt reading\n                # the response before raising an exception.\n                log.warning(\n                    \"Received response with both Content-Length and \"\n                    \"Transfer-Encoding set. This is expressly forbidden \"\n                    \"by RFC 7230 sec 3.3.2. Ignoring Content-Length and \"\n                    \"attempting to process response as Transfer-Encoding: \"\n                    \"chunked.\"\n                )\n                return None\n\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = {int(val) for val in content_length.split(\",\")}\n                if len(lengths) > 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % content_length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length < 0:\n                    length = None\n\n        else:  # if content_length is None\n            length = None\n\n        # Convert status to int for comparison\n        # In some cases, httplib returns a status of \"_UNKNOWN\"\n        try:\n            status = int(self.status)\n        except ValueError:\n            status = 0\n\n        # Check for responses that shouldn't include a body\n        if status in (204, 304) or 100 <= status < 200 or request_method == \"HEAD\":\n            length = 0\n\n        return length\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n\n        try:\n            try:\n                yield\n\n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n\n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n\n            except IncompleteRead as e:\n                if (\n                    e.expected is not None\n                    and e.partial is not None\n                    and e.expected == -e.partial\n                ):\n                    arg = \"Response may not contain content.\"\n                else:\n                    arg = f\"Connection broken: {e!r}\"\n                raise ProtocolError(arg, e) from e\n\n            except (HTTPException, OSError) as e:\n                raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\n\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now to ensure that the connection is\n                # released back to the pool.\n                if self._original_response:\n                    self._original_response.close()\n\n                # Closing the response may not actually be sufficient to close\n                # everything, so if we have a hold of the connection close that\n                # too.\n                if self._connection:\n                    self._connection.close()\n\n            # If we hold the original response but it's closed now, we should\n            # return the connection back to the pool.\n            if self._original_response and self._original_response.isclosed():\n                self.release_conn()\n\n    def _fp_read(\n        self,\n        amt: int | None = None,\n        *,\n        read1: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Read a response with the thought that reading the number of bytes\n        larger than can fit in a 32-bit int at a time via SSL in some\n        known cases leads to an overflow error that has to be prevented\n        if `amt` or `self.length_remaining` indicate that a problem may\n        happen.\n\n        The known cases:\n          * 3.8 <= CPython < 3.9.7 because of a bug\n            https://github.com/urllib3/urllib3/issues/2513#issuecomment-1152559900.\n          * urllib3 injected with pyOpenSSL-backed SSL-support.\n          * CPython < 3.10 only when `amt` does not fit 32-bit int.\n        \"\"\"\n        assert self._fp\n        c_int_max = 2**31 - 1\n        if (\n            (amt and amt > c_int_max)\n            or (\n                amt is None\n                and self.length_remaining\n                and self.length_remaining > c_int_max\n            )\n        ) and (util.IS_PYOPENSSL or sys.version_info < (3, 10)):\n            if read1:\n                return self._fp.read1(c_int_max)\n            buffer = io.BytesIO()\n            # Besides `max_chunk_amt` being a maximum chunk size, it\n            # affects memory overhead of reading a response by this\n            # method in CPython.\n            # `c_int_max` equal to 2 GiB - 1 byte is the actual maximum\n            # chunk size that does not lead to an overflow error, but\n            # 256 MiB is a compromise.\n            max_chunk_amt = 2**28\n            while amt is None or amt != 0:\n                if amt is not None:\n                    chunk_amt = min(amt, max_chunk_amt)\n                    amt -= chunk_amt\n                else:\n                    chunk_amt = max_chunk_amt\n                data = self._fp.read(chunk_amt)\n                if not data:\n                    break\n                buffer.write(data)\n                del data  # to reduce peak memory usage by `max_chunk_amt`.\n            return buffer.getvalue()\n        elif read1:\n            return self._fp.read1(amt) if amt is not None else self._fp.read1()\n        else:\n            # StringIO doesn't like amt=None\n            return self._fp.read(amt) if amt is not None else self._fp.read()\n\n    def _raw_read(\n        self,\n        amt: int | None = None,\n        *,\n        read1: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Reads `amt` of bytes from the socket.\n        \"\"\"\n        if self._fp is None:\n            return None  # type: ignore[return-value]\n\n        fp_closed = getattr(self._fp, \"closed\", False)\n\n        with self._error_catcher():\n            data = self._fp_read(amt, read1=read1) if not fp_closed else b\"\"\n            if amt is not None and amt != 0 and not data:\n                # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                if (\n                    self.enforce_content_length\n                    and self.length_remaining is not None\n                    and self.length_remaining != 0\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n                    raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n            elif read1 and (\n                (amt != 0 and not data) or self.length_remaining == len(data)\n            ):\n                # All data has been read, but `self._fp.read1` in\n                # CPython 3.12 and older doesn't always close\n                # `http.client.HTTPResponse`, so we close it here.\n                # See https://github.com/python/cpython/issues/113199\n                self._fp.close()\n\n        if data:\n            self._fp_bytes_read += len(data)\n            if self.length_remaining is not None:\n                self.length_remaining -= len(data)\n        return data\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n        cache_content: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n\n        if amt and amt < 0:\n            # Negative numbers and `None` should be treated the same.\n            amt = None\n        elif amt is not None:\n            cache_content = False\n\n            if len(self._decoded_buffer) >= amt:\n                return self._decoded_buffer.get(amt)\n\n        data = self._raw_read(amt)\n\n        flush_decoder = amt is None or (amt != 0 and not data)\n\n        if not data and len(self._decoded_buffer) == 0:\n            return data\n\n        if amt is None:\n            data = self._decode(data, decode_content, flush_decoder)\n            if cache_content:\n                self._body = data\n        else:\n            # do not waste memory on buffer when not decoding\n            if not decode_content:\n                if self._has_decoded_content:\n                    raise RuntimeError(\n                        \"Calling read(decode_content=False) is not supported after \"\n                        \"read(decode_content=True) was called.\"\n                    )\n                return data\n\n            decoded_data = self._decode(data, decode_content, flush_decoder)\n            self._decoded_buffer.put(decoded_data)\n\n            while len(self._decoded_buffer) < amt and data:\n                # TODO make sure to initially read enough data to get past the headers\n                # For example, the GZ file header takes 10 bytes, we don't want to read\n                # it one byte at a time\n                data = self._raw_read(amt)\n                decoded_data = self._decode(data, decode_content, flush_decoder)\n                self._decoded_buffer.put(decoded_data)\n            data = self._decoded_buffer.get(amt)\n\n        return data\n\n    def read1(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> bytes:\n        \"\"\"\n        Similar to ``http.client.HTTPResponse.read1`` and documented\n        in :meth:`io.BufferedReader.read1`, but with an additional parameter:\n        ``decode_content``.\n\n        :param amt:\n            How much of the content to read.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if decode_content is None:\n            decode_content = self.decode_content\n        if amt and amt < 0:\n            # Negative numbers and `None` should be treated the same.\n            amt = None\n        # try and respond without going to the network\n        if self._has_decoded_content:\n            if not decode_content:\n                raise RuntimeError(\n                    \"Calling read1(decode_content=False) is not supported after \"\n                    \"read1(decode_content=True) was called.\"\n                )\n            if len(self._decoded_buffer) > 0:\n                if amt is None:\n                    return self._decoded_buffer.get_all()\n                return self._decoded_buffer.get(amt)\n        if amt == 0:\n            return b\"\"\n\n        # FIXME, this method's type doesn't say returning None is possible\n        data = self._raw_read(amt, read1=True)\n        if not decode_content or data is None:\n            return data\n\n        self._init_decoder()\n        while True:\n            flush_decoder = not data\n            decoded_data = self._decode(data, decode_content, flush_decoder)\n            self._decoded_buffer.put(decoded_data)\n            if decoded_data or flush_decoder:\n                break\n            data = self._raw_read(8192, read1=True)\n\n        if amt is None:\n            return self._decoded_buffer.get_all()\n        return self._decoded_buffer.get(amt)\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            yield from self.read_chunked(amt, decode_content=decode_content)\n        else:\n            while not is_fp_closed(self._fp) or len(self._decoded_buffer) > 0:\n                data = self.read(amt=amt, decode_content=decode_content)\n\n                if data:\n                    yield data\n\n    # Overrides from io.IOBase\n    def readable(self) -> bool:\n        return True\n\n    def close(self) -> None:\n        if not self.closed and self._fp:\n            self._fp.close()\n\n        if self._connection:\n            self._connection.close()\n\n        if not self.auto_close:\n            io.IOBase.close(self)\n\n    @property\n    def closed(self) -> bool:\n        if not self.auto_close:\n            return io.IOBase.closed.__get__(self)  # type: ignore[no-any-return]\n        elif self._fp is None:\n            return True\n        elif hasattr(self._fp, \"isclosed\"):\n            return self._fp.isclosed()\n        elif hasattr(self._fp, \"closed\"):\n            return self._fp.closed\n        else:\n            return True\n\n    def fileno(self) -> int:\n        if self._fp is None:\n            raise OSError(\"HTTPResponse has no file to get a fileno from\")\n        elif hasattr(self._fp, \"fileno\"):\n            return self._fp.fileno()\n        else:\n            raise OSError(\n                \"The file-like object this HTTPResponse is wrapped \"\n                \"around has no file descriptor\"\n            )\n\n    def flush(self) -> None:\n        if (\n            self._fp is not None\n            and hasattr(self._fp, \"flush\")\n            and not getattr(self._fp, \"closed\", False)\n        ):\n            return self._fp.flush()\n\n    def supports_chunked_reads(self) -> bool:\n        \"\"\"\n        Checks if the underlying file-like object looks like a\n        :class:`http.client.HTTPResponse` object. We do this by testing for\n        the fp attribute. If it is present we assume it returns raw chunks as\n        processed by read_chunked().\n        \"\"\"\n        return hasattr(self._fp, \"fp\")\n\n    def _update_chunk_length(self) -> None:\n        # First, we'll figure out length of a chunk and then\n        # we'll try to read it from socket.\n        if self.chunk_left is not None:\n            return None\n        line = self._fp.fp.readline()  # type: ignore[union-attr]\n        line = line.split(b\";\", 1)[0]\n        try:\n            self.chunk_left = int(line, 16)\n        except ValueError:\n            self.close()\n            if line:\n                # Invalid chunked protocol response, abort.\n                raise InvalidChunkLength(self, line) from None\n            else:\n                # Truncated at start of next chunk\n                raise ProtocolError(\"Response ended prematurely\") from None\n\n    def _handle_chunk(self, amt: int | None) -> bytes:\n        returned_chunk = None\n        if amt is None:\n            chunk = self._fp._safe_read(self.chunk_left)  # type: ignore[union-attr]\n            returned_chunk = chunk\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        elif self.chunk_left is not None and amt < self.chunk_left:\n            value = self._fp._safe_read(amt)  # type: ignore[union-attr]\n            self.chunk_left = self.chunk_left - amt\n            returned_chunk = value\n        elif amt == self.chunk_left:\n            value = self._fp._safe_read(amt)  # type: ignore[union-attr]\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n            returned_chunk = value\n        else:  # amt > self.chunk_left\n            returned_chunk = self._fp._safe_read(self.chunk_left)  # type: ignore[union-attr]\n            self._fp._safe_read(2)  # type: ignore[union-attr] # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        return returned_chunk  # type: ignore[no-any-return]\n\n    def read_chunked(\n        self, amt: int | None = None, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        Similar to :meth:`HTTPResponse.read`, but with an additional\n        parameter: ``decode_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        self._init_decoder()\n        # FIXME: Rewrite this method and make it a class with a better structured logic.\n        if not self.chunked:\n            raise ResponseNotChunked(\n                \"Response is not chunked. \"\n                \"Header 'transfer-encoding: chunked' is missing.\"\n            )\n        if not self.supports_chunked_reads():\n            raise BodyNotHttplibCompatible(\n                \"Body should be http.client.HTTPResponse like. \"\n                \"It should have have an fp attribute which returns raw chunks.\"\n            )\n\n        with self._error_catcher():\n            # Don't bother reading the body of a HEAD request.\n            if self._original_response and is_response_to_head(self._original_response):\n                self._original_response.close()\n                return None\n\n            # If a response is already read and closed\n            # then return immediately.\n            if self._fp.fp is None:  # type: ignore[union-attr]\n                return None\n\n            if amt and amt < 0:\n                # Negative numbers and `None` should be treated the same,\n                # but httplib handles only `None` correctly.\n                amt = None\n\n            while True:\n                self._update_chunk_length()\n                if self.chunk_left == 0:\n                    break\n                chunk = self._handle_chunk(amt)\n                decoded = self._decode(\n                    chunk, decode_content=decode_content, flush_decoder=False\n                )\n                if decoded:\n                    yield decoded\n\n            if decode_content:\n                # On CPython and PyPy, we should never need to flush the\n                # decoder. However, on Jython we *might* need to, so\n                # lets defensively do it anyway.\n                decoded = self._flush_decoder()\n                if decoded:  # Platform-specific: Jython.\n                    yield decoded\n\n            # Chunk content ends with \\r\\n: discard it.\n            while self._fp is not None:\n                line = self._fp.fp.readline()\n                if not line:\n                    # Some sites may not end with '\\r\\n'.\n                    break\n                if line == b\"\\r\\n\":\n                    break\n\n            # We read everything; close the \"file\".\n            if self._original_response:\n                self._original_response.close()\n\n    @property\n    def url(self) -> str | None:\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        return self._request_url\n\n    @url.setter\n    def url(self, url: str) -> None:\n        self._request_url = url\n\n    def __iter__(self) -> typing.Iterator[bytes]:\n        buffer: list[bytes] = []\n        for chunk in self.stream(decode_content=True):\n            if b\"\\n\" in chunk:\n                chunks = chunk.split(b\"\\n\")\n                yield b\"\".join(buffer) + chunks[0] + b\"\\n\"\n                for x in chunks[1:-1]:\n                    yield x + b\"\\n\"\n                if chunks[-1]:\n                    buffer = [chunks[-1]]\n                else:\n                    buffer = []\n            else:\n                buffer.append(chunk)\n        if buffer:\n            yield b\"\".join(buffer)\n", "src/urllib3/connection.py": "from __future__ import annotations\n\nimport datetime\nimport logging\nimport os\nimport re\nimport socket\nimport sys\nimport typing\nimport warnings\nfrom http.client import HTTPConnection as _HTTPConnection\nfrom http.client import HTTPException as HTTPException  # noqa: F401\nfrom http.client import ResponseNotReady\nfrom socket import timeout as SocketTimeout\n\nif typing.TYPE_CHECKING:\n    from .response import HTTPResponse\n    from .util.ssl_ import _TYPE_PEER_CERT_RET_DICT\n    from .util.ssltransport import SSLTransport\n\nfrom ._collections import HTTPHeaderDict\nfrom .util.response import assert_header_parsing\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT, Timeout\nfrom .util.util import to_str\nfrom .util.wait import wait_for_read\n\ntry:  # Compiled with SSL?\n    import ssl\n\n    BaseSSLError = ssl.SSLError\nexcept (ImportError, AttributeError):\n    ssl = None  # type: ignore[assignment]\n\n    class BaseSSLError(BaseException):  # type: ignore[no-redef]\n        pass\n\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._base_connection import ProxyConfig as ProxyConfig\nfrom ._base_connection import _ResponseOptions as _ResponseOptions\nfrom ._version import __version__\nfrom .exceptions import (\n    ConnectTimeoutError,\n    HeaderParsingError,\n    NameResolutionError,\n    NewConnectionError,\n    ProxyError,\n    SystemTimeWarning,\n)\nfrom .util import SKIP_HEADER, SKIPPABLE_HEADERS, connection, ssl_\nfrom .util.request import body_to_chunks\nfrom .util.ssl_ import assert_fingerprint as _assert_fingerprint\nfrom .util.ssl_ import (\n    create_urllib3_context,\n    is_ipaddress,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom .util.ssl_match_hostname import CertificateError, match_hostname\nfrom .util.url import Url\n\n# Not a no-op, we're adding this to the namespace so it can be imported.\nConnectionError = ConnectionError\nBrokenPipeError = BrokenPipeError\n\n\nlog = logging.getLogger(__name__)\n\nport_by_scheme = {\"http\": 80, \"https\": 443}\n\n# When it comes time to update this value as a part of regular maintenance\n# (ie test_recent_date is failing) update it to ~6 months before the current date.\nRECENT_DATE = datetime.date(2023, 6, 1)\n\n_CONTAINS_CONTROL_CHAR_RE = re.compile(r\"[^-!#$%&'*+.^_`|~0-9a-zA-Z]\")\n\n_HAS_SYS_AUDIT = hasattr(sys, \"audit\")\n\n\nclass HTTPConnection(_HTTPConnection):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.\n\n      For example, if you wish to enable TCP Keep Alive in addition to the defaults,\n      you might pass:\n\n      .. code-block:: python\n\n         HTTPConnection.default_socket_options + [\n             (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),\n         ]\n\n      Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).\n    \"\"\"\n\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]  # type: ignore[misc]\n\n    #: Disable Nagle's algorithm by default.\n    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``\n    default_socket_options: typing.ClassVar[connection._TYPE_SOCKET_OPTIONS] = [\n        (socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    ]\n\n    #: Whether this connection verifies the host's certificate.\n    is_verified: bool = False\n\n    #: Whether this proxy connection verified the proxy host's certificate.\n    # If no proxy is currently connected to the value will be ``None``.\n    proxy_is_verified: bool | None = None\n\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: connection._TYPE_SOCKET_OPTIONS | None\n\n    _has_connected_to_proxy: bool\n    _response_options: _ResponseOptions | None\n    _tunnel_host: str | None\n    _tunnel_port: int | None\n    _tunnel_scheme: str | None\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | (connection._TYPE_SOCKET_OPTIONS) = default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n    ) -> None:\n        super().__init__(\n            host=host,\n            port=port,\n            timeout=Timeout.resolve_default_timeout(timeout),\n            source_address=source_address,\n            blocksize=blocksize,\n        )\n        self.socket_options = socket_options\n        self.proxy = proxy\n        self.proxy_config = proxy_config\n\n        self._has_connected_to_proxy = False\n        self._response_options = None\n        self._tunnel_host: str | None = None\n        self._tunnel_port: int | None = None\n        self._tunnel_scheme: str | None = None\n\n    @property\n    def host(self) -> str:\n        \"\"\"\n        Getter method to remove any trailing dots that indicate the hostname is an FQDN.\n\n        In general, SSL certificates don't include the trailing dot indicating a\n        fully-qualified domain name, and thus, they don't validate properly when\n        checked against a domain name that includes the dot. In addition, some\n        servers may not expect to receive the trailing dot when provided.\n\n        However, the hostname with trailing dot is critical to DNS resolution; doing a\n        lookup with the trailing dot will properly only resolve the appropriate FQDN,\n        whereas a lookup without a trailing dot will search the system's search domain\n        list. Thus, it's important to keep the original host around for use only in\n        those cases where it's appropriate (i.e., when doing DNS lookup to establish the\n        actual TCP connection across which we're going to send HTTP requests).\n        \"\"\"\n        return self._dns_host.rstrip(\".\")\n\n    @host.setter\n    def host(self, value: str) -> None:\n        \"\"\"\n        Setter for the `host` property.\n\n        We assume that only urllib3 uses the _dns_host attribute; httplib itself\n        only uses `host`, and it seems reasonable that other libraries follow suit.\n        \"\"\"\n        self._dns_host = value\n\n    def _new_conn(self) -> socket.socket:\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n\n        :return: New socket connection.\n        \"\"\"\n        try:\n            sock = connection.create_connection(\n                (self._dns_host, self.port),\n                self.timeout,\n                source_address=self.source_address,\n                socket_options=self.socket_options,\n            )\n        except socket.gaierror as e:\n            raise NameResolutionError(self.host, self, e) from e\n        except SocketTimeout as e:\n            raise ConnectTimeoutError(\n                self,\n                f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n            ) from e\n\n        except OSError as e:\n            raise NewConnectionError(\n                self, f\"Failed to establish a new connection: {e}\"\n            ) from e\n\n        # Audit hooks are only available in Python 3.8+\n        if _HAS_SYS_AUDIT:\n            sys.audit(\"http.client.connect\", self, self.host, self.port)\n\n        return sock\n\n    def set_tunnel(\n        self,\n        host: str,\n        port: int | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        scheme: str = \"http\",\n    ) -> None:\n        if scheme not in (\"http\", \"https\"):\n            raise ValueError(\n                f\"Invalid proxy scheme for tunneling: {scheme!r}, must be either 'http' or 'https'\"\n            )\n        super().set_tunnel(host, port=port, headers=headers)\n        self._tunnel_scheme = scheme\n\n    def connect(self) -> None:\n        self.sock = self._new_conn()\n        if self._tunnel_host:\n            # If we're tunneling it means we're connected to our proxy.\n            self._has_connected_to_proxy = True\n\n            # TODO: Fix tunnel so it doesn't depend on self.sock state.\n            self._tunnel()  # type: ignore[attr-defined]\n\n        # If there's a proxy to be connected to we are fully connected.\n        # This is set twice (once above and here) due to forwarding proxies\n        # not using tunnelling.\n        self._has_connected_to_proxy = bool(self.proxy)\n\n        if self._has_connected_to_proxy:\n            self.proxy_is_verified = False\n\n    @property\n    def is_closed(self) -> bool:\n        return self.sock is None\n\n    @property\n    def is_connected(self) -> bool:\n        if self.sock is None:\n            return False\n        return not wait_for_read(self.sock, timeout=0.0)\n\n    @property\n    def has_connected_to_proxy(self) -> bool:\n        return self._has_connected_to_proxy\n\n    @property\n    def proxy_is_forwarding(self) -> bool:\n        \"\"\"\n        Return True if a forwarding proxy is configured, else return False\n        \"\"\"\n        return bool(self.proxy) and self._tunnel_host is None\n\n    def close(self) -> None:\n        try:\n            super().close()\n        finally:\n            # Reset all stateful properties so connection\n            # can be re-used without leaking prior configs.\n            self.sock = None\n            self.is_verified = False\n            self.proxy_is_verified = None\n            self._has_connected_to_proxy = False\n            self._response_options = None\n            self._tunnel_host = None\n            self._tunnel_port = None\n            self._tunnel_scheme = None\n\n    def putrequest(\n        self,\n        method: str,\n        url: str,\n        skip_host: bool = False,\n        skip_accept_encoding: bool = False,\n    ) -> None:\n        \"\"\"\"\"\"\n        # Empty docstring because the indentation of CPython's implementation\n        # is broken but we don't want this method in our documentation.\n        match = _CONTAINS_CONTROL_CHAR_RE.search(method)\n        if match:\n            raise ValueError(\n                f\"Method cannot contain non-token characters {method!r} (found at least {match.group()!r})\"\n            )\n\n        return super().putrequest(\n            method, url, skip_host=skip_host, skip_accept_encoding=skip_accept_encoding\n        )\n\n    def putheader(self, header: str, *values: str) -> None:  # type: ignore[override]\n        \"\"\"\"\"\"\n        if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):\n            super().putheader(header, *values)\n        elif to_str(header.lower()) not in SKIPPABLE_HEADERS:\n            skippable_headers = \"', '\".join(\n                [str.title(header) for header in sorted(SKIPPABLE_HEADERS)]\n            )\n            raise ValueError(\n                f\"urllib3.util.SKIP_HEADER only supports '{skippable_headers}'\"\n            )\n\n    # `request` method's signature intentionally violates LSP.\n    # urllib3's API is different from `http.client.HTTPConnection` and the subclassing is only incidental.\n    def request(  # type: ignore[override]\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        *,\n        chunked: bool = False,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> None:\n        # Update the inner socket's timeout value to send the request.\n        # This only triggers if the connection is re-used.\n        if self.sock is not None:\n            self.sock.settimeout(self.timeout)\n\n        # Store these values to be fed into the HTTPResponse\n        # object later. TODO: Remove this in favor of a real\n        # HTTP lifecycle mechanism.\n\n        # We have to store these before we call .request()\n        # because sometimes we can still salvage a response\n        # off the wire even if we aren't able to completely\n        # send the request body.\n        self._response_options = _ResponseOptions(\n            request_method=method,\n            request_url=url,\n            preload_content=preload_content,\n            decode_content=decode_content,\n            enforce_content_length=enforce_content_length,\n        )\n\n        if headers is None:\n            headers = {}\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\n        skip_accept_encoding = \"accept-encoding\" in header_keys\n        skip_host = \"host\" in header_keys\n        self.putrequest(\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n        )\n\n        # Transform the body into an iterable of sendall()-able chunks\n        # and detect if an explicit Content-Length is doable.\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\n        chunks = chunks_and_cl.chunks\n        content_length = chunks_and_cl.content_length\n\n        # When chunked is explicit set to 'True' we respect that.\n        if chunked:\n            if \"transfer-encoding\" not in header_keys:\n                self.putheader(\"Transfer-Encoding\", \"chunked\")\n        else:\n            # Detect whether a framing mechanism is already in use. If so\n            # we respect that value, otherwise we pick chunked vs content-length\n            # depending on the type of 'body'.\n            if \"content-length\" in header_keys:\n                chunked = False\n            elif \"transfer-encoding\" in header_keys:\n                chunked = True\n\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\n            else:\n                chunked = False\n                if content_length is None:\n                    if chunks is not None:\n                        chunked = True\n                        self.putheader(\"Transfer-Encoding\", \"chunked\")\n                else:\n                    self.putheader(\"Content-Length\", str(content_length))\n\n        # Now that framing headers are out of the way we send all the other headers.\n        if \"user-agent\" not in header_keys:\n            self.putheader(\"User-Agent\", _get_default_user_agent())\n        for header, value in headers.items():\n            self.putheader(header, value)\n        self.endheaders()\n\n        # If we're given a body we start sending that in chunks.\n        if chunks is not None:\n            for chunk in chunks:\n                # Sending empty chunks isn't allowed for TE: chunked\n                # as it indicates the end of the body.\n                if not chunk:\n                    continue\n                if isinstance(chunk, str):\n                    chunk = chunk.encode(\"utf-8\")\n                if chunked:\n                    self.send(b\"%x\\r\\n%b\\r\\n\" % (len(chunk), chunk))\n                else:\n                    self.send(chunk)\n\n        # Regardless of whether we have a body or not, if we're in\n        # chunked mode we want to send an explicit empty chunk.\n        if chunked:\n            self.send(b\"0\\r\\n\\r\\n\")\n\n    def request_chunked(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n    ) -> None:\n        \"\"\"\n        Alternative to the common request method, which sends the\n        body with chunked encoding and not as one block\n        \"\"\"\n        warnings.warn(\n            \"HTTPConnection.request_chunked() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead use HTTPConnection.request(..., chunked=True).\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n        self.request(method, url, body=body, headers=headers, chunked=True)\n\n    def getresponse(  # type: ignore[override]\n        self,\n    ) -> HTTPResponse:\n        \"\"\"\n        Get the response from the server.\n\n        If the HTTPConnection is in the correct state, returns an instance of HTTPResponse or of whatever object is returned by the response_class variable.\n\n        If a request has not been sent or if a previous response has not be handled, ResponseNotReady is raised. If the HTTP response indicates that the connection should be closed, then it will be closed before the response is returned. When the connection is closed, the underlying socket is closed.\n        \"\"\"\n        # Raise the same error as http.client.HTTPConnection\n        if self._response_options is None:\n            raise ResponseNotReady()\n\n        # Reset this attribute for being used again.\n        resp_options = self._response_options\n        self._response_options = None\n\n        # Since the connection's timeout value may have been updated\n        # we need to set the timeout on the socket.\n        self.sock.settimeout(self.timeout)\n\n        # This is needed here to avoid circular import errors\n        from .response import HTTPResponse\n\n        # Get the response from http.client.HTTPConnection\n        httplib_response = super().getresponse()\n\n        try:\n            assert_header_parsing(httplib_response.msg)\n        except (HeaderParsingError, TypeError) as hpe:\n            log.warning(\n                \"Failed to parse headers (url=%s): %s\",\n                _url_from_connection(self, resp_options.request_url),\n                hpe,\n                exc_info=True,\n            )\n\n        headers = HTTPHeaderDict(httplib_response.msg.items())\n\n        response = HTTPResponse(\n            body=httplib_response,\n            headers=headers,\n            status=httplib_response.status,\n            version=httplib_response.version,\n            version_string=getattr(self, \"_http_vsn_str\", \"HTTP/?\"),\n            reason=httplib_response.reason,\n            preload_content=resp_options.preload_content,\n            decode_content=resp_options.decode_content,\n            original_response=httplib_response,\n            enforce_content_length=resp_options.enforce_content_length,\n            request_method=resp_options.request_method,\n            request_url=resp_options.request_url,\n        )\n        return response\n\n\nclass HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n\n    default_port = port_by_scheme[\"https\"]  # type: ignore[misc]\n\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    ssl_version: int | str | None = None\n    ssl_minimum_version: int | None = None\n    ssl_maximum_version: int | None = None\n    assert_fingerprint: str | None = None\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | (connection._TYPE_SOCKET_OPTIONS) = HTTPConnection.default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n        cert_reqs: int | str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        server_hostname: str | None = None,\n        ssl_context: ssl.SSLContext | None = None,\n        ca_certs: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n        ssl_minimum_version: int | None = None,\n        ssl_maximum_version: int | None = None,\n        ssl_version: int | str | None = None,  # Deprecated\n        cert_file: str | None = None,\n        key_file: str | None = None,\n        key_password: str | None = None,\n    ) -> None:\n        super().__init__(\n            host,\n            port=port,\n            timeout=timeout,\n            source_address=source_address,\n            blocksize=blocksize,\n            socket_options=socket_options,\n            proxy=proxy,\n            proxy_config=proxy_config,\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.key_password = key_password\n        self.ssl_context = ssl_context\n        self.server_hostname = server_hostname\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n        # cert_reqs depends on ssl_context so calculate last.\n        if cert_reqs is None:\n            if self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n            else:\n                cert_reqs = resolve_cert_reqs(None)\n        self.cert_reqs = cert_reqs\n\n    def set_cert(\n        self,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n    ) -> None:\n        \"\"\"\n        This method should only be called once, before the connection is used.\n        \"\"\"\n        warnings.warn(\n            \"HTTPSConnection.set_cert() is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Instead provide the parameters to the \"\n            \"HTTPSConnection constructor.\",\n            category=DeprecationWarning,\n            stacklevel=2,\n        )\n\n        # If cert_reqs is not provided we'll assume CERT_REQUIRED unless we also\n        # have an SSLContext object in which case we'll use its verify_mode.\n        if cert_reqs is None:\n            if self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n            else:\n                cert_reqs = resolve_cert_reqs(None)\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n    def connect(self) -> None:\n        sock: socket.socket | ssl.SSLSocket\n        self.sock = sock = self._new_conn()\n        server_hostname: str = self.host\n        tls_in_tls = False\n\n        # Do we need to establish a tunnel?\n        if self._tunnel_host is not None:\n            # We're tunneling to an HTTPS origin so need to do TLS-in-TLS.\n            if self._tunnel_scheme == \"https\":\n                # _connect_tls_proxy will verify and assign proxy_is_verified\n                self.sock = sock = self._connect_tls_proxy(self.host, sock)\n                tls_in_tls = True\n            elif self._tunnel_scheme == \"http\":\n                self.proxy_is_verified = False\n\n            # If we're tunneling it means we're connected to our proxy.\n            self._has_connected_to_proxy = True\n\n            self._tunnel()  # type: ignore[attr-defined]\n            # Override the host with the one we're requesting data from.\n            server_hostname = self._tunnel_host\n\n        if self.server_hostname is not None:\n            server_hostname = self.server_hostname\n\n        is_time_off = datetime.date.today() < RECENT_DATE\n        if is_time_off:\n            warnings.warn(\n                (\n                    f\"System time is way off (before {RECENT_DATE}). This will probably \"\n                    \"lead to SSL verification errors\"\n                ),\n                SystemTimeWarning,\n            )\n\n        # Remove trailing '.' from fqdn hostnames to allow certificate validation\n        server_hostname_rm_dot = server_hostname.rstrip(\".\")\n\n        sock_and_verified = _ssl_wrap_socket_and_match_hostname(\n            sock=sock,\n            cert_reqs=self.cert_reqs,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            server_hostname=server_hostname_rm_dot,\n            ssl_context=self.ssl_context,\n            tls_in_tls=tls_in_tls,\n            assert_hostname=self.assert_hostname,\n            assert_fingerprint=self.assert_fingerprint,\n        )\n        self.sock = sock_and_verified.socket\n\n        # Forwarding proxies can never have a verified target since\n        # the proxy is the one doing the verification. Should instead\n        # use a CONNECT tunnel in order to verify the target.\n        # See: https://github.com/urllib3/urllib3/issues/3267.\n        if self.proxy_is_forwarding:\n            self.is_verified = False\n        else:\n            self.is_verified = sock_and_verified.is_verified\n\n        # If there's a proxy to be connected to we are fully connected.\n        # This is set twice (once above and here) due to forwarding proxies\n        # not using tunnelling.\n        self._has_connected_to_proxy = bool(self.proxy)\n\n        # Set `self.proxy_is_verified` unless it's already set while\n        # establishing a tunnel.\n        if self._has_connected_to_proxy and self.proxy_is_verified is None:\n            self.proxy_is_verified = sock_and_verified.is_verified\n\n    def _connect_tls_proxy(self, hostname: str, sock: socket.socket) -> ssl.SSLSocket:\n        \"\"\"\n        Establish a TLS connection to the proxy using the provided SSL context.\n        \"\"\"\n        # `_connect_tls_proxy` is called when self._tunnel_host is truthy.\n        proxy_config = typing.cast(ProxyConfig, self.proxy_config)\n        ssl_context = proxy_config.ssl_context\n        sock_and_verified = _ssl_wrap_socket_and_match_hostname(\n            sock,\n            cert_reqs=self.cert_reqs,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            server_hostname=hostname,\n            ssl_context=ssl_context,\n            assert_hostname=proxy_config.assert_hostname,\n            assert_fingerprint=proxy_config.assert_fingerprint,\n            # Features that aren't implemented for proxies yet:\n            cert_file=None,\n            key_file=None,\n            key_password=None,\n            tls_in_tls=False,\n        )\n        self.proxy_is_verified = sock_and_verified.is_verified\n        return sock_and_verified.socket  # type: ignore[return-value]\n\n\nclass _WrappedAndVerifiedSocket(typing.NamedTuple):\n    \"\"\"\n    Wrapped socket and whether the connection is\n    verified after the TLS handshake\n    \"\"\"\n\n    socket: ssl.SSLSocket | SSLTransport\n    is_verified: bool\n\n\ndef _ssl_wrap_socket_and_match_hostname(\n    sock: socket.socket,\n    *,\n    cert_reqs: None | str | int,\n    ssl_version: None | str | int,\n    ssl_minimum_version: int | None,\n    ssl_maximum_version: int | None,\n    cert_file: str | None,\n    key_file: str | None,\n    key_password: str | None,\n    ca_certs: str | None,\n    ca_cert_dir: str | None,\n    ca_cert_data: None | str | bytes,\n    assert_hostname: None | str | typing.Literal[False],\n    assert_fingerprint: str | None,\n    server_hostname: str | None,\n    ssl_context: ssl.SSLContext | None,\n    tls_in_tls: bool = False,\n) -> _WrappedAndVerifiedSocket:\n    \"\"\"Logic for constructing an SSLContext from all TLS parameters, passing\n    that down into ssl_wrap_socket, and then doing certificate verification\n    either via hostname or fingerprint. This function exists to guarantee\n    that both proxies and targets have the same behavior when connecting via TLS.\n    \"\"\"\n    default_ssl_context = False\n    if ssl_context is None:\n        default_ssl_context = True\n        context = create_urllib3_context(\n            ssl_version=resolve_ssl_version(ssl_version),\n            ssl_minimum_version=ssl_minimum_version,\n            ssl_maximum_version=ssl_maximum_version,\n            cert_reqs=resolve_cert_reqs(cert_reqs),\n        )\n    else:\n        context = ssl_context\n\n    context.verify_mode = resolve_cert_reqs(cert_reqs)\n\n    # In some cases, we want to verify hostnames ourselves\n    if (\n        # `ssl` can't verify fingerprints or alternate hostnames\n        assert_fingerprint\n        or assert_hostname\n        # assert_hostname can be set to False to disable hostname checking\n        or assert_hostname is False\n        # We still support OpenSSL 1.0.2, which prevents us from verifying\n        # hostnames easily: https://github.com/pyca/pyopenssl/pull/933\n        or ssl_.IS_PYOPENSSL\n        or not ssl_.HAS_NEVER_CHECK_COMMON_NAME\n    ):\n        context.check_hostname = False\n\n    # Try to load OS default certs if none are given. We need to do the hasattr() check\n    # for custom pyOpenSSL SSLContext objects because they don't support\n    # load_default_certs().\n    if (\n        not ca_certs\n        and not ca_cert_dir\n        and not ca_cert_data\n        and default_ssl_context\n        and hasattr(context, \"load_default_certs\")\n    ):\n        context.load_default_certs()\n\n    # Ensure that IPv6 addresses are in the proper format and don't have a\n    # scope ID. Python's SSL module fails to recognize scoped IPv6 addresses\n    # and interprets them as DNS hostnames.\n    if server_hostname is not None:\n        normalized = server_hostname.strip(\"[]\")\n        if \"%\" in normalized:\n            normalized = normalized[: normalized.rfind(\"%\")]\n        if is_ipaddress(normalized):\n            server_hostname = normalized\n\n    ssl_sock = ssl_wrap_socket(\n        sock=sock,\n        keyfile=key_file,\n        certfile=cert_file,\n        key_password=key_password,\n        ca_certs=ca_certs,\n        ca_cert_dir=ca_cert_dir,\n        ca_cert_data=ca_cert_data,\n        server_hostname=server_hostname,\n        ssl_context=context,\n        tls_in_tls=tls_in_tls,\n    )\n\n    try:\n        if assert_fingerprint:\n            _assert_fingerprint(\n                ssl_sock.getpeercert(binary_form=True), assert_fingerprint\n            )\n        elif (\n            context.verify_mode != ssl.CERT_NONE\n            and not context.check_hostname\n            and assert_hostname is not False\n        ):\n            cert: _TYPE_PEER_CERT_RET_DICT = ssl_sock.getpeercert()  # type: ignore[assignment]\n\n            # Need to signal to our match_hostname whether to use 'commonName' or not.\n            # If we're using our own constructed SSLContext we explicitly set 'False'\n            # because PyPy hard-codes 'True' from SSLContext.hostname_checks_common_name.\n            if default_ssl_context:\n                hostname_checks_common_name = False\n            else:\n                hostname_checks_common_name = (\n                    getattr(context, \"hostname_checks_common_name\", False) or False\n                )\n\n            _match_hostname(\n                cert,\n                assert_hostname or server_hostname,  # type: ignore[arg-type]\n                hostname_checks_common_name,\n            )\n\n        return _WrappedAndVerifiedSocket(\n            socket=ssl_sock,\n            is_verified=context.verify_mode == ssl.CERT_REQUIRED\n            or bool(assert_fingerprint),\n        )\n    except BaseException:\n        ssl_sock.close()\n        raise\n\n\ndef _match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    asserted_hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    # Our upstream implementation of ssl.match_hostname()\n    # only applies this normalization to IP addresses so it doesn't\n    # match DNS SANs so we do the same thing!\n    stripped_hostname = asserted_hostname.strip(\"[]\")\n    if is_ipaddress(stripped_hostname):\n        asserted_hostname = stripped_hostname\n\n    try:\n        match_hostname(cert, asserted_hostname, hostname_checks_common_name)\n    except CertificateError as e:\n        log.warning(\n            \"Certificate did not match expected hostname: %s. Certificate: %s\",\n            asserted_hostname,\n            cert,\n        )\n        # Add cert to exception and reraise so client code can inspect\n        # the cert when catching the exception, if they want to\n        e._peer_cert = cert  # type: ignore[attr-defined]\n        raise\n\n\ndef _wrap_proxy_error(err: Exception, proxy_scheme: str | None) -> ProxyError:\n    # Look for the phrase 'wrong version number', if found\n    # then we should warn the user that we're very sure that\n    # this proxy is HTTP-only and they have a configuration issue.\n    error_normalized = \" \".join(re.split(\"[^a-z]\", str(err).lower()))\n    is_likely_http_proxy = (\n        \"wrong version number\" in error_normalized\n        or \"unknown protocol\" in error_normalized\n        or \"record layer failure\" in error_normalized\n    )\n    http_proxy_warning = (\n        \". Your proxy appears to only use HTTP and not HTTPS, \"\n        \"try changing your proxy URL to be HTTP. See: \"\n        \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"\n        \"#https-proxy-error-http-proxy\"\n    )\n    new_err = ProxyError(\n        f\"Unable to connect to proxy\"\n        f\"{http_proxy_warning if is_likely_http_proxy and proxy_scheme == 'https' else ''}\",\n        err,\n    )\n    new_err.__cause__ = err\n    return new_err\n\n\ndef _get_default_user_agent() -> str:\n    return f\"python-urllib3/{__version__}\"\n\n\nclass DummyConnection:\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\n\n\nif not ssl:\n    HTTPSConnection = DummyConnection  # type: ignore[misc, assignment] # noqa: F811\n\n\nVerifiedHTTPSConnection = HTTPSConnection\n\n\ndef _url_from_connection(\n    conn: HTTPConnection | HTTPSConnection, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection. This is mainly used for testing and logging.\"\"\"\n\n    scheme = \"https\" if isinstance(conn, HTTPSConnection) else \"http\"\n\n    return Url(scheme=scheme, host=conn.host, port=conn.port, path=path).url\n", "src/urllib3/_base_connection.py": "from __future__ import annotations\n\nimport typing\n\nfrom .util.connection import _TYPE_SOCKET_OPTIONS\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\nfrom .util.url import Url\n\n_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]\n\n\nclass ProxyConfig(typing.NamedTuple):\n    ssl_context: ssl.SSLContext | None\n    use_forwarding_for_https: bool\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None\n\n\nclass _ResponseOptions(typing.NamedTuple):\n    # TODO: Remove this in favor of a better\n    # HTTP request/response lifecycle tracking.\n    request_method: str\n    request_url: str\n    preload_content: bool\n    decode_content: bool\n    enforce_content_length: bool\n\n\nif typing.TYPE_CHECKING:\n    import ssl\n    from typing import Protocol\n\n    from .response import BaseHTTPResponse\n\n    class BaseHTTPConnection(Protocol):\n        default_port: typing.ClassVar[int]\n        default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n        host: str\n        port: int\n        timeout: None | (\n            float\n        )  # Instance doesn't store _DEFAULT_TIMEOUT, must be resolved.\n        blocksize: int\n        source_address: tuple[str, int] | None\n        socket_options: _TYPE_SOCKET_OPTIONS | None\n\n        proxy: Url | None\n        proxy_config: ProxyConfig | None\n\n        is_verified: bool\n        proxy_is_verified: bool | None\n\n        def __init__(\n            self,\n            host: str,\n            port: int | None = None,\n            *,\n            timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n            source_address: tuple[str, int] | None = None,\n            blocksize: int = 8192,\n            socket_options: _TYPE_SOCKET_OPTIONS | None = ...,\n            proxy: Url | None = None,\n            proxy_config: ProxyConfig | None = None,\n        ) -> None:\n            ...\n\n        def set_tunnel(\n            self,\n            host: str,\n            port: int | None = None,\n            headers: typing.Mapping[str, str] | None = None,\n            scheme: str = \"http\",\n        ) -> None:\n            ...\n\n        def connect(self) -> None:\n            ...\n\n        def request(\n            self,\n            method: str,\n            url: str,\n            body: _TYPE_BODY | None = None,\n            headers: typing.Mapping[str, str] | None = None,\n            # We know *at least* botocore is depending on the order of the\n            # first 3 parameters so to be safe we only mark the later ones\n            # as keyword-only to ensure we have space to extend.\n            *,\n            chunked: bool = False,\n            preload_content: bool = True,\n            decode_content: bool = True,\n            enforce_content_length: bool = True,\n        ) -> None:\n            ...\n\n        def getresponse(self) -> BaseHTTPResponse:\n            ...\n\n        def close(self) -> None:\n            ...\n\n        @property\n        def is_closed(self) -> bool:\n            \"\"\"Whether the connection either is brand new or has been previously closed.\n            If this property is True then both ``is_connected`` and ``has_connected_to_proxy``\n            properties must be False.\n            \"\"\"\n\n        @property\n        def is_connected(self) -> bool:\n            \"\"\"Whether the connection is actively connected to any origin (proxy or target)\"\"\"\n\n        @property\n        def has_connected_to_proxy(self) -> bool:\n            \"\"\"Whether the connection has successfully connected to its proxy.\n            This returns False if no proxy is in use. Used to determine whether\n            errors are coming from the proxy layer or from tunnelling to the target origin.\n            \"\"\"\n\n    class BaseHTTPSConnection(BaseHTTPConnection, Protocol):\n        default_port: typing.ClassVar[int]\n        default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n        # Certificate verification methods\n        cert_reqs: int | str | None\n        assert_hostname: None | str | typing.Literal[False]\n        assert_fingerprint: str | None\n        ssl_context: ssl.SSLContext | None\n\n        # Trusted CAs\n        ca_certs: str | None\n        ca_cert_dir: str | None\n        ca_cert_data: None | str | bytes\n\n        # TLS version\n        ssl_minimum_version: int | None\n        ssl_maximum_version: int | None\n        ssl_version: int | str | None  # Deprecated\n\n        # Client certificates\n        cert_file: str | None\n        key_file: str | None\n        key_password: str | None\n\n        def __init__(\n            self,\n            host: str,\n            port: int | None = None,\n            *,\n            timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n            source_address: tuple[str, int] | None = None,\n            blocksize: int = 16384,\n            socket_options: _TYPE_SOCKET_OPTIONS | None = ...,\n            proxy: Url | None = None,\n            proxy_config: ProxyConfig | None = None,\n            cert_reqs: int | str | None = None,\n            assert_hostname: None | str | typing.Literal[False] = None,\n            assert_fingerprint: str | None = None,\n            server_hostname: str | None = None,\n            ssl_context: ssl.SSLContext | None = None,\n            ca_certs: str | None = None,\n            ca_cert_dir: str | None = None,\n            ca_cert_data: None | str | bytes = None,\n            ssl_minimum_version: int | None = None,\n            ssl_maximum_version: int | None = None,\n            ssl_version: int | str | None = None,  # Deprecated\n            cert_file: str | None = None,\n            key_file: str | None = None,\n            key_password: str | None = None,\n        ) -> None:\n            ...\n", "src/urllib3/exceptions.py": "from __future__ import annotations\n\nimport socket\nimport typing\nimport warnings\nfrom email.errors import MessageDefect\nfrom http.client import IncompleteRead as httplib_IncompleteRead\n\nif typing.TYPE_CHECKING:\n    from .connection import HTTPConnection\n    from .connectionpool import ConnectionPool\n    from .response import HTTPResponse\n    from .util.retry import Retry\n\n# Base Exceptions\n\n\nclass HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\n\n\nclass HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n\n\n_TYPE_REDUCE_RESULT = typing.Tuple[\n    typing.Callable[..., object], typing.Tuple[object, ...]\n]\n\n\nclass PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n\n    def __init__(self, pool: ConnectionPool, message: str) -> None:\n        self.pool = pool\n        super().__init__(f\"{pool}: {message}\")\n\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, None)\n\n\nclass RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n\n    def __init__(self, pool: ConnectionPool, url: str, message: str) -> None:\n        self.url = url\n        super().__init__(pool, message)\n\n    def __reduce__(self) -> _TYPE_REDUCE_RESULT:\n        # For pickling purposes.\n        return self.__class__, (None, self.url, None)\n\n\nclass SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\n\n\nclass ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n\n    # The original error is also available as __cause__.\n    original_error: Exception\n\n    def __init__(self, message: str, error: Exception) -> None:\n        super().__init__(message, error)\n        self.original_error = error\n\n\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\n\n\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n\n\n#: Renamed to ProtocolError but aliased for backwards compatibility.\nConnectionError = ProtocolError\n\n\n# Leaf Exceptions\n\n\nclass MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param str url: The requested Url\n    :param reason: The underlying error\n    :type reason: :class:`Exception`\n\n    \"\"\"\n\n    def __init__(\n        self, pool: ConnectionPool, url: str, reason: Exception | None = None\n    ) -> None:\n        self.reason = reason\n\n        message = f\"Max retries exceeded with url: {url} (Caused by {reason!r})\"\n\n        super().__init__(pool, url, message)\n\n\nclass HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n\n    def __init__(\n        self, pool: ConnectionPool, url: str, retries: Retry | int = 3\n    ) -> None:\n        message = f\"Tried to open a foreign host with url: {url}\"\n        super().__init__(pool, url, message)\n        self.retries = retries\n\n\nclass TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\n\n\nclass TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.\n    \"\"\"\n\n\nclass ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n\n\n# This timeout error does not have a URL attached and needs to inherit from the\n# base HTTPError\nclass ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\n\n\nclass NewConnectionError(ConnectTimeoutError, HTTPError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n\n    def __init__(self, conn: HTTPConnection, message: str) -> None:\n        self.conn = conn\n        super().__init__(f\"{conn}: {message}\")\n\n    @property\n    def pool(self) -> HTTPConnection:\n        warnings.warn(\n            \"The 'pool' property is deprecated and will be removed \"\n            \"in urllib3 v2.1.0. Use 'conn' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        return self.conn\n\n\nclass NameResolutionError(NewConnectionError):\n    \"\"\"Raised when host name resolution fails.\"\"\"\n\n    def __init__(self, host: str, conn: HTTPConnection, reason: socket.gaierror):\n        message = f\"Failed to resolve '{host}' ({reason})\"\n        super().__init__(conn, message)\n\n\nclass EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\n\n\nclass FullPoolError(PoolError):\n    \"\"\"Raised when we try to add a connection to a full pool in blocking mode.\"\"\"\n\n\nclass ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\n\n\nclass LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\n\n\nclass LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n\n    def __init__(self, location: str) -> None:\n        message = f\"Failed to parse: {location}\"\n        super().__init__(message)\n\n        self.location = location\n\n\nclass URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n\n    def __init__(self, scheme: str):\n        message = f\"Not supported URL scheme {scheme}\"\n        super().__init__(message)\n\n        self.scheme = scheme\n\n\nclass ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\n\n\nclass SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\n\n\nclass InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\n\n\nclass NotOpenSSLWarning(SecurityWarning):\n    \"\"\"Warned when using unsupported SSL library\"\"\"\n\n\nclass SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\n\n\nclass InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\n\n\nclass DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\n\n\nclass ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\n\n\nclass BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\n\n\nclass IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n\n    partial: int  # type: ignore[assignment]\n    expected: int\n\n    def __init__(self, partial: int, expected: int) -> None:\n        self.partial = partial\n        self.expected = expected\n\n    def __repr__(self) -> str:\n        return \"IncompleteRead(%i bytes read, %i more expected)\" % (\n            self.partial,\n            self.expected,\n        )\n\n\nclass InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n\n    def __init__(self, response: HTTPResponse, length: bytes) -> None:\n        self.partial: int = response.tell()  # type: ignore[assignment]\n        self.expected: int | None = response.length_remaining\n        self.response = response\n        self.length = length\n\n    def __repr__(self) -> str:\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,\n            self.partial,\n        )\n\n\nclass InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\n\n\nclass ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n\n    def __init__(self, scheme: str | None) -> None:\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -> scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"\n        else:\n            message = f\"Proxy URL had unsupported scheme {scheme}, should use http:// or https://\"\n        super().__init__(message)\n\n\nclass ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\n\n\nclass HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n\n    def __init__(\n        self, defects: list[MessageDefect], unparsed_data: bytes | str | None\n    ) -> None:\n        message = f\"{defects or 'Unknown'}, unparsed data: {unparsed_data!r}\"\n        super().__init__(message)\n\n\nclass UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"\n", "src/urllib3/http2.py": "from __future__ import annotations\n\nimport threading\nimport types\nimport typing\n\nimport h2.config  # type: ignore[import-untyped]\nimport h2.connection  # type: ignore[import-untyped]\nimport h2.events  # type: ignore[import-untyped]\n\nimport urllib3.connection\nimport urllib3.util.ssl_\nfrom urllib3.response import BaseHTTPResponse\n\nfrom ._collections import HTTPHeaderDict\nfrom .connection import HTTPSConnection\nfrom .connectionpool import HTTPSConnectionPool\n\norig_HTTPSConnection = HTTPSConnection\n\nT = typing.TypeVar(\"T\")\n\n\nclass _LockedObject(typing.Generic[T]):\n    \"\"\"\n    A wrapper class that hides a specific object behind a lock.\n\n    The goal here is to provide a simple way to protect access to an object\n    that cannot safely be simultaneously accessed from multiple threads. The\n    intended use of this class is simple: take hold of it with a context\n    manager, which returns the protected object.\n    \"\"\"\n\n    def __init__(self, obj: T):\n        self.lock = threading.RLock()\n        self._obj = obj\n\n    def __enter__(self) -> T:\n        self.lock.acquire()\n        return self._obj\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: types.TracebackType | None,\n    ) -> None:\n        self.lock.release()\n\n\nclass HTTP2Connection(HTTPSConnection):\n    def __init__(\n        self, host: str, port: int | None = None, **kwargs: typing.Any\n    ) -> None:\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream: int | None = None\n        self._h2_headers: list[tuple[bytes, bytes]] = []\n\n        if \"proxy\" in kwargs or \"proxy_config\" in kwargs:  # Defensive:\n            raise NotImplementedError(\"Proxies aren't supported with HTTP/2\")\n\n        super().__init__(host, port, **kwargs)\n\n    def _new_h2_conn(self) -> _LockedObject[h2.connection.H2Connection]:\n        config = h2.config.H2Configuration(client_side=True)\n        return _LockedObject(h2.connection.H2Connection(config=config))\n\n    def connect(self) -> None:\n        super().connect()\n\n        with self._h2_conn as h2_conn:\n            h2_conn.initiate_connection()\n            self.sock.sendall(h2_conn.data_to_send())\n\n    def putrequest(\n        self,\n        method: str,\n        url: str,\n        skip_host: bool = False,\n        skip_accept_encoding: bool = False,\n    ) -> None:\n        with self._h2_conn as h2_conn:\n            self._request_url = url\n            self._h2_stream = h2_conn.get_next_available_stream_id()\n\n            if \":\" in self.host:\n                authority = f\"[{self.host}]:{self.port or 443}\"\n            else:\n                authority = f\"{self.host}:{self.port or 443}\"\n\n            self._h2_headers.extend(\n                (\n                    (b\":scheme\", b\"https\"),\n                    (b\":method\", method.encode()),\n                    (b\":authority\", authority.encode()),\n                    (b\":path\", url.encode()),\n                )\n            )\n\n    def putheader(self, header: str, *values: str) -> None:  # type: ignore[override]\n        for value in values:\n            self._h2_headers.append(\n                (header.encode(\"utf-8\").lower(), value.encode(\"utf-8\"))\n            )\n\n    def endheaders(self) -> None:  # type: ignore[override]\n        with self._h2_conn as h2_conn:\n            h2_conn.send_headers(\n                stream_id=self._h2_stream,\n                headers=self._h2_headers,\n                end_stream=True,\n            )\n            if data_to_send := h2_conn.data_to_send():\n                self.sock.sendall(data_to_send)\n\n    def send(self, data: bytes) -> None:  # type: ignore[override]  # Defensive:\n        if not data:\n            return\n        raise NotImplementedError(\"Sending data isn't supported yet\")\n\n    def getresponse(  # type: ignore[override]\n        self,\n    ) -> HTTP2Response:\n        status = None\n        data = bytearray()\n        with self._h2_conn as h2_conn:\n            end_stream = False\n            while not end_stream:\n                # TODO: Arbitrary read value.\n                if received_data := self.sock.recv(65535):\n                    events = h2_conn.receive_data(received_data)\n                    for event in events:\n                        if isinstance(event, h2.events.ResponseReceived):\n                            headers = HTTPHeaderDict()\n                            for header, value in event.headers:\n                                if header == b\":status\":\n                                    status = int(value.decode())\n                                else:\n                                    headers.add(\n                                        header.decode(\"ascii\"), value.decode(\"ascii\")\n                                    )\n\n                        elif isinstance(event, h2.events.DataReceived):\n                            data += event.data\n                            h2_conn.acknowledge_received_data(\n                                event.flow_controlled_length, event.stream_id\n                            )\n\n                        elif isinstance(event, h2.events.StreamEnded):\n                            end_stream = True\n\n                if data_to_send := h2_conn.data_to_send():\n                    self.sock.sendall(data_to_send)\n\n        # We always close to not have to handle connection management.\n        self.close()\n\n        assert status is not None\n        return HTTP2Response(\n            status=status,\n            headers=headers,\n            request_url=self._request_url,\n            data=bytes(data),\n        )\n\n    def close(self) -> None:\n        with self._h2_conn as h2_conn:\n            try:\n                h2_conn.close_connection()\n                if data := h2_conn.data_to_send():\n                    self.sock.sendall(data)\n            except Exception:\n                pass\n\n        # Reset all our HTTP/2 connection state.\n        self._h2_conn = self._new_h2_conn()\n        self._h2_stream = None\n        self._h2_headers = []\n\n        super().close()\n\n\nclass HTTP2Response(BaseHTTPResponse):\n    # TODO: This is a woefully incomplete response object, but works for non-streaming.\n    def __init__(\n        self,\n        status: int,\n        headers: HTTPHeaderDict,\n        request_url: str,\n        data: bytes,\n        decode_content: bool = False,  # TODO: support decoding\n    ) -> None:\n        super().__init__(\n            status=status,\n            headers=headers,\n            # Following CPython, we map HTTP versions to major * 10 + minor integers\n            version=20,\n            version_string=\"HTTP/2\",\n            # No reason phrase in HTTP/2\n            reason=None,\n            decode_content=decode_content,\n            request_url=request_url,\n        )\n        self._data = data\n        self.length_remaining = 0\n\n    @property\n    def data(self) -> bytes:\n        return self._data\n\n    def get_redirect_location(self) -> None:\n        return None\n\n    def close(self) -> None:\n        pass\n\n\ndef inject_into_urllib3() -> None:\n    HTTPSConnectionPool.ConnectionCls = HTTP2Connection\n    urllib3.connection.HTTPSConnection = HTTP2Connection  # type: ignore[misc]\n\n    # TODO: Offer 'http/1.1' as well, but for testing purposes this is handy.\n    urllib3.util.ssl_.ALPN_PROTOCOLS = [\"h2\"]\n\n\ndef extract_from_urllib3() -> None:\n    HTTPSConnectionPool.ConnectionCls = orig_HTTPSConnection\n    urllib3.connection.HTTPSConnection = orig_HTTPSConnection  # type: ignore[misc]\n\n    urllib3.util.ssl_.ALPN_PROTOCOLS = [\"http/1.1\"]\n", "src/urllib3/connectionpool.py": "from __future__ import annotations\n\nimport errno\nimport logging\nimport queue\nimport sys\nimport typing\nimport warnings\nimport weakref\nfrom socket import timeout as SocketTimeout\nfrom types import TracebackType\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom ._request_methods import RequestMethods\nfrom .connection import (\n    BaseSSLError,\n    BrokenPipeError,\n    DummyConnection,\n    HTTPConnection,\n    HTTPException,\n    HTTPSConnection,\n    ProxyConfig,\n    _wrap_proxy_error,\n)\nfrom .connection import port_by_scheme as port_by_scheme\nfrom .exceptions import (\n    ClosedPoolError,\n    EmptyPoolError,\n    FullPoolError,\n    HostChangedError,\n    InsecureRequestWarning,\n    LocationValueError,\n    MaxRetryError,\n    NewConnectionError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    SSLError,\n    TimeoutError,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import is_connection_dropped\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.request import _TYPE_BODY_POSITION, set_file_position\nfrom .util.retry import Retry\nfrom .util.ssl_match_hostname import CertificateError\nfrom .util.timeout import _DEFAULT_TIMEOUT, _TYPE_DEFAULT, Timeout\nfrom .util.url import Url, _encode_target\nfrom .util.url import _normalize_host as normalize_host\nfrom .util.url import parse_url\nfrom .util.util import to_str\n\nif typing.TYPE_CHECKING:\n    import ssl\n\n    from typing_extensions import Self\n\n    from ._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\nlog = logging.getLogger(__name__)\n\n_TYPE_TIMEOUT = typing.Union[Timeout, float, _TYPE_DEFAULT, None]\n\n\n# Pool objects\nclass ConnectionPool:\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n\n    scheme: str | None = None\n    QueueCls = queue.LifoQueue\n\n    def __init__(self, host: str, port: int | None = None) -> None:\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        self.host = _normalize_host(host, scheme=self.scheme)\n        self.port = port\n\n        # This property uses 'normalize_host()' (not '_normalize_host()')\n        # to avoid removing square braces around IPv6 addresses.\n        # This value is sent to `HTTPConnection.set_tunnel()` if called\n        # because square braces are required for HTTP CONNECT tunneling.\n        self._tunnel_host = normalize_host(host, scheme=self.scheme).lower()\n\n    def __str__(self) -> str:\n        return f\"{type(self).__name__}(host={self.host!r}, port={self.port!r})\"\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> typing.Literal[False]:\n        self.close()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def close(self) -> None:\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n\n\n# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252\n_blocking_errnos = {errno.EAGAIN, errno.EWOULDBLOCK}\n\n\nclass HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n\n    :param timeout:\n        Socket timeout in seconds for each individual connection. This can\n        be a float or integer, which sets the timeout for the HTTP request,\n        or an instance of :class:`urllib3.util.Timeout` which gives you more\n        fine-grained control over request timeouts. After the constructor has\n        been parsed, this is always a `urllib3.util.Timeout` object.\n\n    :param maxsize:\n        Number of connections to save that can be reused. More than 1 is useful\n        in multithreaded situations. If ``block`` is set to False, more\n        connections will be created but they will not be saved once they've\n        been used.\n\n    :param block:\n        If set to True, no more than ``maxsize`` connections will be used at\n        a time. When no free connections are available, the call will block\n        until a connection has been released. This is a useful side effect for\n        particular multithreaded situations where one does not want to use more\n        than maxsize connections per host to prevent flooding.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param retries:\n        Retry configuration to use by default with requests in this pool.\n\n    :param _proxy:\n        Parsed proxy URL, should not be used directly, instead, see\n        :class:`urllib3.ProxyManager`\n\n    :param _proxy_headers:\n        A dictionary with proxy headers, should not be used directly,\n        instead, see :class:`urllib3.ProxyManager`\n\n    :param \\\\**conn_kw:\n        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n        :class:`urllib3.connection.HTTPSConnection` instances.\n    \"\"\"\n\n    scheme = \"http\"\n    ConnectionCls: (\n        type[BaseHTTPConnection] | type[BaseHTTPSConnection]\n    ) = HTTPConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        _proxy_config: ProxyConfig | None = None,\n        **conn_kw: typing.Any,\n    ):\n        ConnectionPool.__init__(self, host, port)\n        RequestMethods.__init__(self, headers)\n\n        if not isinstance(timeout, Timeout):\n            timeout = Timeout.from_float(timeout)\n\n        if retries is None:\n            retries = Retry.DEFAULT\n\n        self.timeout = timeout\n        self.retries = retries\n\n        self.pool: queue.LifoQueue[typing.Any] | None = self.QueueCls(maxsize)\n        self.block = block\n\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.proxy_config = _proxy_config\n\n        # Fill the queue up so that doing get() on it will block properly\n        for _ in range(maxsize):\n            self.pool.put(None)\n\n        # These are mostly for testing and debugging purposes.\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        if self.proxy:\n            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.\n            # We cannot know if the user has added default socket options, so we cannot replace the\n            # list.\n            self.conn_kw.setdefault(\"socket_options\", [])\n\n            self.conn_kw[\"proxy\"] = self.proxy\n            self.conn_kw[\"proxy_config\"] = self.proxy_config\n\n        # Do not pass 'self' as callback to 'finalize'.\n        # Then the 'finalize' would keep an endless living (leak) to self.\n        # By just passing a reference to the pool allows the garbage collector\n        # to free self if nobody else has a reference to it.\n        pool = self.pool\n\n        # Close all the HTTPConnections in the pool before the\n        # HTTPConnectionPool object is garbage collected.\n        weakref.finalize(self, _close_pool_connections, pool)\n\n    def _new_conn(self) -> BaseHTTPConnection:\n        \"\"\"\n        Return a fresh :class:`HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTP connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"80\",\n        )\n\n        conn = self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            **self.conn_kw,\n        )\n        return conn\n\n    def _get_conn(self, timeout: float | None = None) -> BaseHTTPConnection:\n        \"\"\"\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        \"\"\"\n        conn = None\n\n        if self.pool is None:\n            raise ClosedPoolError(self, \"Pool is closed.\")\n\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n\n        except AttributeError:  # self.pool is None\n            raise ClosedPoolError(self, \"Pool is closed.\") from None  # Defensive:\n\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(\n                    self,\n                    \"Pool is empty and a new connection can't be opened due to blocking mode.\",\n                ) from None\n            pass  # Oh well, we'll create a new connection then\n\n        # If this is a persistent connection, check if it got disconnected\n        if conn and is_connection_dropped(conn):\n            log.debug(\"Resetting dropped connection: %s\", self.host)\n            conn.close()\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn: BaseHTTPConnection | None) -> None:\n        \"\"\"\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        \"\"\"\n        if self.pool is not None:\n            try:\n                self.pool.put(conn, block=False)\n                return  # Everything is dandy, done.\n            except AttributeError:\n                # self.pool is None.\n                pass\n            except queue.Full:\n                # Connection never got put back into the pool, close it.\n                if conn:\n                    conn.close()\n\n                if self.block:\n                    # This should never happen if you got the conn from self._get_conn\n                    raise FullPoolError(\n                        self,\n                        \"Pool reached maximum size and no more connections are allowed.\",\n                    ) from None\n\n                log.warning(\n                    \"Connection pool is full, discarding connection: %s. Connection pool size: %s\",\n                    self.host,\n                    self.pool.qsize(),\n                )\n\n        # Connection never got put back into the pool, close it.\n        if conn:\n            conn.close()\n\n    def _validate_conn(self, conn: BaseHTTPConnection) -> None:\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n\n    def _prepare_proxy(self, conn: BaseHTTPConnection) -> None:\n        # Nothing to do for HTTP connections.\n        pass\n\n    def _get_timeout(self, timeout: _TYPE_TIMEOUT) -> Timeout:\n        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"\n        if timeout is _DEFAULT_TIMEOUT:\n            return self.timeout.clone()\n\n        if isinstance(timeout, Timeout):\n            return timeout.clone()\n        else:\n            # User passed us an int/float. This is for backwards compatibility,\n            # can be removed later\n            return Timeout.from_float(timeout)\n\n    def _raise_timeout(\n        self,\n        err: BaseSSLError | OSError | SocketTimeout,\n        url: str,\n        timeout_value: _TYPE_TIMEOUT | None,\n    ) -> None:\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n\n        if isinstance(err, SocketTimeout):\n            raise ReadTimeoutError(\n                self, url, f\"Read timed out. (read timeout={timeout_value})\"\n            ) from err\n\n        # See the above comment about EAGAIN in Python 3.\n        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:\n            raise ReadTimeoutError(\n                self, url, f\"Read timed out. (read timeout={timeout_value})\"\n            ) from err\n\n    def _make_request(\n        self,\n        conn: BaseHTTPConnection,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | None = None,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        chunked: bool = False,\n        response_conn: BaseHTTPConnection | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param response_conn:\n            Set this to ``None`` if you will handle releasing the connection or\n            set the connection to have the response release it.\n\n        :param preload_content:\n          If True, the response's body will be preloaded during construction.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param enforce_content_length:\n            Enforce content length checking. Body returned by server must match\n            value of Content-Length header, if present. Otherwise, raise error.\n        \"\"\"\n        self.num_requests += 1\n\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\n\n        try:\n            # Trigger any extra validation we need to do.\n            try:\n                self._validate_conn(conn)\n            except (SocketTimeout, BaseSSLError) as e:\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n                raise\n\n        # _validate_conn() starts the connection to an HTTPS proxy\n        # so we need to wrap errors with 'ProxyError' here too.\n        except (\n            OSError,\n            NewConnectionError,\n            TimeoutError,\n            BaseSSLError,\n            CertificateError,\n            SSLError,\n        ) as e:\n            new_e: Exception = e\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                new_e = SSLError(e)\n            # If the connection didn't successfully connect to it's proxy\n            # then there\n            if isinstance(\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\n            raise new_e\n\n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            conn.request(\n                method,\n                url,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                enforce_content_length=enforce_content_length,\n            )\n\n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            pass\n        except OSError as e:\n            # MacOS/Linux\n            # EPROTOTYPE and ECONNRESET are needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.\n            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:\n                raise\n\n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n\n        if not conn.is_closed:\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, f\"Read timed out. (read timeout={read_timeout})\"\n                )\n            conn.timeout = read_timeout\n\n        # Receive the response from the server\n        try:\n            response = conn.getresponse()\n        except (BaseSSLError, OSError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        # Set properties that are used by the pooling layer.\n        response.retries = retries\n        response._connection = response_conn  # type: ignore[attr-defined]\n        response._pool = self  # type: ignore[attr-defined]\n\n        log.debug(\n            '%s://%s:%s \"%s %s HTTP/%s\" %s %s',\n            self.scheme,\n            self.host,\n            self.port,\n            method,\n            url,\n            response.version,\n            response.status,\n            response.length_remaining,\n        )\n\n        return response\n\n    def close(self) -> None:\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n        if self.pool is None:\n            return\n        # Disable access to the pool\n        old_pool, self.pool = self.pool, None\n\n        # Close all the HTTPConnections in the pool.\n        _close_pool_connections(old_pool)\n\n    def is_same_host(self, url: str) -> bool:\n        \"\"\"\n        Check if the given ``url`` is a member of the same host as this\n        connection pool.\n        \"\"\"\n        if url.startswith(\"/\"):\n            return True\n\n        # TODO: Add optional support for socket.gethostbyname checking.\n        scheme, _, host, port, *_ = parse_url(url)\n        scheme = scheme or \"http\"\n        if host is not None:\n            host = _normalize_host(host, scheme=scheme)\n\n        # Use explicit default port for comparison when none is given\n        if self.port and not port:\n            port = port_by_scheme.get(scheme)\n        elif not self.port and port == port_by_scheme.get(scheme):\n            port = None\n\n        return (scheme, host, port) == (self.scheme, self.host, self.port)\n\n    def urlopen(  # type: ignore[override]\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        redirect: bool = True,\n        assert_same_host: bool = True,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        pool_timeout: int | None = None,\n        release_conn: bool | None = None,\n        chunked: bool = False,\n        body_pos: _TYPE_BODY_POSITION | None = None,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        **response_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method\n           such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param bool preload_content:\n            If True, the response's body will be preloaded into memory.\n\n        :param bool decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of ``preload_content``\n            which defaults to ``True``.\n\n        :param bool chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n        \"\"\"\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if release_conn is None:\n            release_conn = preload_content\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = to_str(_encode_target(url))\n        else:\n            url = to_str(parsed_url.url)\n\n        conn = None\n\n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()  # type: ignore[attr-defined]\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\n\n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n\n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n\n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n\n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\n\n            # Is this a closed/new connection that requires CONNECT tunnelling?\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\n                try:\n                    self._prepare_proxy(conn)\n                except (BaseSSLError, OSError, SocketTimeout) as e:\n                    self._raise_timeout(\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\n                    )\n                    raise\n\n            # If we're going to release the connection in ``finally:``, then\n            # the response doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = conn if not release_conn else None\n\n            # Make the request on the HTTPConnection object\n            response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n                retries=retries,\n                response_conn=response_conn,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n            # Everything went great!\n            clean_exit = True\n\n        except EmptyPoolError:\n            # Didn't get a connection from the pool, no need to clean up\n            clean_exit = True\n            release_this_conn = False\n            raise\n\n        except (\n            TimeoutError,\n            HTTPException,\n            OSError,\n            ProtocolError,\n            BaseSSLError,\n            SSLError,\n            CertificateError,\n            ProxyError,\n        ) as e:\n            # Discard the connection for these exceptions. It will be\n            # replaced during the next _get_conn() call.\n            clean_exit = False\n            new_e: Exception = e\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                new_e = SSLError(e)\n            if isinstance(\n                new_e,\n                (\n                    OSError,\n                    NewConnectionError,\n                    TimeoutError,\n                    SSLError,\n                    HTTPException,\n                ),\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\n            elif isinstance(new_e, (OSError, HTTPException)):\n                new_e = ProtocolError(\"Connection aborted.\", new_e)\n\n            retries = retries.increment(\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n\n            # Keep track of the error for the retry warning.\n            err = e\n\n        finally:\n            if not clean_exit:\n                # We hit some kind of exception, handled or otherwise. We need\n                # to throw the connection away unless explicitly told not to.\n                # Close the connection, set the variable to None, and make sure\n                # we put the None back in the pool to avoid leaking it.\n                if conn:\n                    conn.close()\n                    conn = None\n                release_this_conn = True\n\n            if release_this_conn:\n                # Put the connection back to be reused. If the connection is\n                # expired then it will be None, which will get replaced with a\n                # fresh connection during _get_conn.\n                self._put_conn(conn)\n\n        if not conn:\n            # Try again\n            log.warning(\n                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n            )\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        # Handle redirect?\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            if response.status == 303:\n                # Change the method according to RFC 9110, Section 15.4.4.\n                method = \"GET\"\n                # And lose the body not to transfer anything sensitive.\n                body = None\n                headers = HTTPHeaderDict(headers)._prepare_for_method_change()\n\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_redirect:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep_for_retry(response)\n            log.debug(\"Redirecting %s -> %s\", url, redirect_location)\n            return self.urlopen(\n                method,\n                redirect_location,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        # Check if we should retry the HTTP response.\n        has_retry_after = bool(response.headers.get(\"Retry-After\"))\n        if retries.is_retry(method, response.status, has_retry_after):\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_status:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep(response)\n            log.debug(\"Retry: %s\", url)\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                preload_content=preload_content,\n                decode_content=decode_content,\n                **response_kw,\n            )\n\n        return response\n\n\nclass HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.\n    \"\"\"\n\n    scheme = \"https\"\n    ConnectionCls: type[BaseHTTPSConnection] = HTTPSConnection\n\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: _TYPE_TIMEOUT | None = _DEFAULT_TIMEOUT,\n        maxsize: int = 1,\n        block: bool = False,\n        headers: typing.Mapping[str, str] | None = None,\n        retries: Retry | bool | int | None = None,\n        _proxy: Url | None = None,\n        _proxy_headers: typing.Mapping[str, str] | None = None,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        ssl_version: int | str | None = None,\n        ssl_minimum_version: ssl.TLSVersion | None = None,\n        ssl_maximum_version: ssl.TLSVersion | None = None,\n        assert_hostname: str | typing.Literal[False] | None = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        **conn_kw: typing.Any,\n    ) -> None:\n        super().__init__(\n            host,\n            port,\n            timeout,\n            maxsize,\n            block,\n            headers,\n            retries,\n            _proxy,\n            _proxy_headers,\n            **conn_kw,\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.ca_certs = ca_certs\n        self.ca_cert_dir = ca_cert_dir\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_proxy(self, conn: HTTPSConnection) -> None:  # type: ignore[override]\n        \"\"\"Establishes a tunnel connection through HTTP CONNECT.\"\"\"\n        if self.proxy and self.proxy.scheme == \"https\":\n            tunnel_scheme = \"https\"\n        else:\n            tunnel_scheme = \"http\"\n\n        conn.set_tunnel(\n            scheme=tunnel_scheme,\n            host=self._tunnel_host,\n            port=self.port,\n            headers=self.proxy_headers,\n        )\n        conn.connect()\n\n    def _new_conn(self) -> BaseHTTPSConnection:\n        \"\"\"\n        Return a fresh :class:`urllib3.connection.HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTPS connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"443\",\n        )\n\n        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:  # type: ignore[comparison-overlap]\n            raise ImportError(\n                \"Can't connect to HTTPS URL because the SSL module is not available.\"\n            )\n\n        actual_host: str = self.host\n        actual_port = self.port\n        if self.proxy is not None and self.proxy.host is not None:\n            actual_host = self.proxy.host\n            actual_port = self.proxy.port\n\n        return self.ConnectionCls(\n            host=actual_host,\n            port=actual_port,\n            timeout=self.timeout.connect_timeout,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            cert_reqs=self.cert_reqs,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            assert_hostname=self.assert_hostname,\n            assert_fingerprint=self.assert_fingerprint,\n            ssl_version=self.ssl_version,\n            ssl_minimum_version=self.ssl_minimum_version,\n            ssl_maximum_version=self.ssl_maximum_version,\n            **self.conn_kw,\n        )\n\n    def _validate_conn(self, conn: BaseHTTPConnection) -> None:\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        super()._validate_conn(conn)\n\n        # Force connect early to allow us to validate the connection.\n        if conn.is_closed:\n            conn.connect()\n\n        # TODO revise this, see https://github.com/urllib3/urllib3/issues/2791\n        if not conn.is_verified and not conn.proxy_is_verified:\n            warnings.warn(\n                (\n                    f\"Unverified HTTPS request is being made to host '{conn.host}'. \"\n                    \"Adding certificate verification is strongly advised. See: \"\n                    \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html\"\n                    \"#tls-warnings\"\n                ),\n                InsecureRequestWarning,\n            )\n\n\ndef connection_from_url(url: str, **kw: typing.Any) -> HTTPConnectionPool:\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like\n        timeout, maxsize, headers, etc.\n\n    Example::\n\n        >>> conn = connection_from_url('http://google.com/')\n        >>> r = conn.request('GET', '/')\n    \"\"\"\n    scheme, _, host, port, *_ = parse_url(url)\n    scheme = scheme or \"http\"\n    port = port or port_by_scheme.get(scheme, 80)\n    if scheme == \"https\":\n        return HTTPSConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]\n    else:\n        return HTTPConnectionPool(host, port=port, **kw)  # type: ignore[arg-type]\n\n\n@typing.overload\ndef _normalize_host(host: None, scheme: str | None) -> None:\n    ...\n\n\n@typing.overload\ndef _normalize_host(host: str, scheme: str | None) -> str:\n    ...\n\n\ndef _normalize_host(host: str | None, scheme: str | None) -> str | None:\n    \"\"\"\n    Normalize hosts for comparisons and use with sockets.\n    \"\"\"\n\n    host = normalize_host(host, scheme)\n\n    # httplib doesn't like it when we include brackets in IPv6 addresses\n    # Specifically, if we include brackets but also pass the port then\n    # httplib crazily doubles up the square brackets on the Host header.\n    # Instead, we need to make sure we never pass ``None`` as the port.\n    # However, for backward compatibility reasons we can't actually\n    # *assert* that.  See http://bugs.python.org/issue28539\n    if host and host.startswith(\"[\") and host.endswith(\"]\"):\n        host = host[1:-1]\n    return host\n\n\ndef _url_from_pool(\n    pool: HTTPConnectionPool | HTTPSConnectionPool, path: str | None = None\n) -> str:\n    \"\"\"Returns the URL from a given connection pool. This is mainly used for testing and logging.\"\"\"\n    return Url(scheme=pool.scheme, host=pool.host, port=pool.port, path=path).url\n\n\ndef _close_pool_connections(pool: queue.LifoQueue[typing.Any]) -> None:\n    \"\"\"Drains a queue of connections and closes each one.\"\"\"\n    try:\n        while True:\n            conn = pool.get(block=False)\n            if conn:\n                conn.close()\n    except queue.Empty:\n        pass  # Done.\n", "src/urllib3/fields.py": "from __future__ import annotations\n\nimport email.utils\nimport mimetypes\nimport typing\n\n_TYPE_FIELD_VALUE = typing.Union[str, bytes]\n_TYPE_FIELD_VALUE_TUPLE = typing.Union[\n    _TYPE_FIELD_VALUE,\n    typing.Tuple[str, _TYPE_FIELD_VALUE],\n    typing.Tuple[str, _TYPE_FIELD_VALUE, str],\n]\n\n\ndef guess_content_type(\n    filename: str | None, default: str = \"application/octet-stream\"\n) -> str:\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"\n    if filename:\n        return mimetypes.guess_type(filename)[0] or default\n    return default\n\n\ndef format_header_param_rfc2231(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :returns:\n        An RFC-2231-formatted unicode string.\n\n    .. deprecated:: 2.0.0\n        Will be removed in urllib3 v2.1.0. This is not valid for\n        ``multipart/form-data`` header parameters.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param_rfc2231' is deprecated and will be \"\n        \"removed in urllib3 v2.1.0. This is not valid for \"\n        \"multipart/form-data header parameters.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n\n    if not any(ch in value for ch in '\"\\\\\\r\\n'):\n        result = f'{name}=\"{value}\"'\n        try:\n            result.encode(\"ascii\")\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\n        else:\n            return result\n\n    value = email.utils.encode_rfc2231(value, \"utf-8\")\n    value = f\"{name}*={value}\"\n\n    return value\n\n\ndef format_multipart_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    Format and quote a single multipart header parameter.\n\n    This follows the `WHATWG HTML Standard`_ as of 2021/06/10, matching\n    the behavior of current browser and curl versions. Values are\n    assumed to be UTF-8. The ``\\\\n``, ``\\\\r``, and ``\"`` characters are\n    percent encoded.\n\n    .. _WHATWG HTML Standard:\n        https://html.spec.whatwg.org/multipage/\n        form-control-infrastructure.html#multipart-form-data\n\n    :param name:\n        The name of the parameter, an ASCII-only ``str``.\n    :param value:\n        The value of the parameter, a ``str`` or UTF-8 encoded\n        ``bytes``.\n    :returns:\n        A string ``name=\"value\"`` with the escaped value.\n\n    .. versionchanged:: 2.0.0\n        Matches the WHATWG HTML Standard as of 2021/06/10. Control\n        characters are no longer percent encoded.\n\n    .. versionchanged:: 2.0.0\n        Renamed from ``format_header_param_html5`` and\n        ``format_header_param``. The old names will be removed in\n        urllib3 v2.1.0.\n    \"\"\"\n    if isinstance(value, bytes):\n        value = value.decode(\"utf-8\")\n\n    # percent encode \\n \\r \"\n    value = value.translate({10: \"%0A\", 13: \"%0D\", 34: \"%22\"})\n    return f'{name}=\"{value}\"'\n\n\ndef format_header_param_html5(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param_html5' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"\n        \"removed in urllib3 v2.1.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return format_multipart_header_param(name, value)\n\n\ndef format_header_param(name: str, value: _TYPE_FIELD_VALUE) -> str:\n    \"\"\"\n    .. deprecated:: 2.0.0\n        Renamed to :func:`format_multipart_header_param`. Will be\n        removed in urllib3 v2.1.0.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"'format_header_param' has been renamed to \"\n        \"'format_multipart_header_param'. The old name will be \"\n        \"removed in urllib3 v2.1.0.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return format_multipart_header_param(name, value)\n\n\nclass RequestField:\n    \"\"\"\n    A data container for request body parameters.\n\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:\n        An optional dict-like object of headers to initially use for the field.\n\n    .. versionchanged:: 2.0.0\n        The ``header_formatter`` parameter is deprecated and will\n        be removed in urllib3 v2.1.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        data: _TYPE_FIELD_VALUE,\n        filename: str | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        header_formatter: typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None = None,\n    ):\n        self._name = name\n        self._filename = filename\n        self.data = data\n        self.headers: dict[str, str | None] = {}\n        if headers:\n            self.headers = dict(headers)\n\n        if header_formatter is not None:\n            import warnings\n\n            warnings.warn(\n                \"The 'header_formatter' parameter is deprecated and \"\n                \"will be removed in urllib3 v2.1.0.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            self.header_formatter = header_formatter\n        else:\n            self.header_formatter = format_multipart_header_param\n\n    @classmethod\n    def from_tuples(\n        cls,\n        fieldname: str,\n        value: _TYPE_FIELD_VALUE_TUPLE,\n        header_formatter: typing.Callable[[str, _TYPE_FIELD_VALUE], str] | None = None,\n    ) -> RequestField:\n        \"\"\"\n        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\n        Supports constructing :class:`~urllib3.fields.RequestField` from\n        parameter of key/value strings AND key/filetuple. A filetuple is a\n        (filename, data, MIME type) tuple where the MIME type is optional.\n        For example::\n\n            'foo': 'bar',\n            'fakefile': ('foofile.txt', 'contents of foofile'),\n            'realfile': ('barfile.txt', open('realfile').read()),\n            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n            'nonamefile': 'contents of nonamefile field',\n\n        Field names and filenames must be unicode.\n        \"\"\"\n        filename: str | None\n        content_type: str | None\n        data: _TYPE_FIELD_VALUE\n\n        if isinstance(value, tuple):\n            if len(value) == 3:\n                filename, data, content_type = value\n            else:\n                filename, data = value\n                content_type = guess_content_type(filename)\n        else:\n            filename = None\n            content_type = None\n            data = value\n\n        request_param = cls(\n            fieldname, data, filename=filename, header_formatter=header_formatter\n        )\n        request_param.make_multipart(content_type=content_type)\n\n        return request_param\n\n    def _render_part(self, name: str, value: _TYPE_FIELD_VALUE) -> str:\n        \"\"\"\n        Override this method to change how each multipart header\n        parameter is formatted. By default, this calls\n        :func:`format_multipart_header_param`.\n\n        :param name:\n            The name of the parameter, an ASCII-only ``str``.\n        :param value:\n            The value of the parameter, a ``str`` or UTF-8 encoded\n            ``bytes``.\n\n        :meta public:\n        \"\"\"\n        return self.header_formatter(name, value)\n\n    def _render_parts(\n        self,\n        header_parts: (\n            dict[str, _TYPE_FIELD_VALUE | None]\n            | typing.Sequence[tuple[str, _TYPE_FIELD_VALUE | None]]\n        ),\n    ) -> str:\n        \"\"\"\n        Helper function to format and quote a single header.\n\n        Useful for single headers that are composed of multiple items. E.g.,\n        'Content-Disposition' fields.\n\n        :param header_parts:\n            A sequence of (k, v) tuples or a :class:`dict` of (k, v) to format\n            as `k1=\"v1\"; k2=\"v2\"; ...`.\n        \"\"\"\n        iterable: typing.Iterable[tuple[str, _TYPE_FIELD_VALUE | None]]\n\n        parts = []\n        if isinstance(header_parts, dict):\n            iterable = header_parts.items()\n        else:\n            iterable = header_parts\n\n        for name, value in iterable:\n            if value is not None:\n                parts.append(self._render_part(name, value))\n\n        return \"; \".join(parts)\n\n    def render_headers(self) -> str:\n        \"\"\"\n        Renders the headers for this request field.\n        \"\"\"\n        lines = []\n\n        sort_keys = [\"Content-Disposition\", \"Content-Type\", \"Content-Location\"]\n        for sort_key in sort_keys:\n            if self.headers.get(sort_key, False):\n                lines.append(f\"{sort_key}: {self.headers[sort_key]}\")\n\n        for header_name, header_value in self.headers.items():\n            if header_name not in sort_keys:\n                if header_value:\n                    lines.append(f\"{header_name}: {header_value}\")\n\n        lines.append(\"\\r\\n\")\n        return \"\\r\\n\".join(lines)\n\n    def make_multipart(\n        self,\n        content_disposition: str | None = None,\n        content_type: str | None = None,\n        content_location: str | None = None,\n    ) -> None:\n        \"\"\"\n        Makes this request field into a multipart request field.\n\n        This method overrides \"Content-Disposition\", \"Content-Type\" and\n        \"Content-Location\" headers to the request parameter.\n\n        :param content_disposition:\n            The 'Content-Disposition' of the request body. Defaults to 'form-data'\n        :param content_type:\n            The 'Content-Type' of the request body.\n        :param content_location:\n            The 'Content-Location' of the request body.\n\n        \"\"\"\n        content_disposition = (content_disposition or \"form-data\") + \"; \".join(\n            [\n                \"\",\n                self._render_parts(\n                    ((\"name\", self._name), (\"filename\", self._filename))\n                ),\n            ]\n        )\n\n        self.headers[\"Content-Disposition\"] = content_disposition\n        self.headers[\"Content-Type\"] = content_type\n        self.headers[\"Content-Location\"] = content_location\n", "src/urllib3/filepost.py": "from __future__ import annotations\n\nimport binascii\nimport codecs\nimport os\nimport typing\nfrom io import BytesIO\n\nfrom .fields import _TYPE_FIELD_VALUE_TUPLE, RequestField\n\nwriter = codecs.lookup(\"utf-8\")[3]\n\n_TYPE_FIELDS_SEQUENCE = typing.Sequence[\n    typing.Union[typing.Tuple[str, _TYPE_FIELD_VALUE_TUPLE], RequestField]\n]\n_TYPE_FIELDS = typing.Union[\n    _TYPE_FIELDS_SEQUENCE,\n    typing.Mapping[str, _TYPE_FIELD_VALUE_TUPLE],\n]\n\n\ndef choose_boundary() -> str:\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    return binascii.hexlify(os.urandom(16)).decode()\n\n\ndef iter_field_objects(fields: _TYPE_FIELDS) -> typing.Iterable[RequestField]:\n    \"\"\"\n    Iterate over fields.\n\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n\n    \"\"\"\n    iterable: typing.Iterable[RequestField | tuple[str, _TYPE_FIELD_VALUE_TUPLE]]\n\n    if isinstance(fields, typing.Mapping):\n        iterable = fields.items()\n    else:\n        iterable = fields\n\n    for field in iterable:\n        if isinstance(field, RequestField):\n            yield field\n        else:\n            yield RequestField.from_tuples(*field)\n\n\ndef encode_multipart_formdata(\n    fields: _TYPE_FIELDS, boundary: str | None = None\n) -> tuple[bytes, str]:\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n        Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n\n    :param boundary:\n        If not specified, then a random boundary will be generated using\n        :func:`urllib3.filepost.choose_boundary`.\n    \"\"\"\n    body = BytesIO()\n    if boundary is None:\n        boundary = choose_boundary()\n\n    for field in iter_field_objects(fields):\n        body.write(f\"--{boundary}\\r\\n\".encode(\"latin-1\"))\n\n        writer(body).write(field.render_headers())\n        data = field.data\n\n        if isinstance(data, int):\n            data = str(data)  # Backwards compatibility\n\n        if isinstance(data, str):\n            writer(body).write(data)\n        else:\n            body.write(data)\n\n        body.write(b\"\\r\\n\")\n\n    body.write(f\"--{boundary}--\\r\\n\".encode(\"latin-1\"))\n\n    content_type = f\"multipart/form-data; boundary={boundary}\"\n\n    return body.getvalue(), content_type\n", "src/urllib3/_collections.py": "from __future__ import annotations\n\nimport typing\nfrom collections import OrderedDict\nfrom enum import Enum, auto\nfrom threading import RLock\n\nif typing.TYPE_CHECKING:\n    # We can only import Protocol if TYPE_CHECKING because it's a development\n    # dependency, and is not available at runtime.\n    from typing import Protocol\n\n    from typing_extensions import Self\n\n    class HasGettableStringKeys(Protocol):\n        def keys(self) -> typing.Iterator[str]:\n            ...\n\n        def __getitem__(self, key: str) -> str:\n            ...\n\n\n__all__ = [\"RecentlyUsedContainer\", \"HTTPHeaderDict\"]\n\n\n# Key type\n_KT = typing.TypeVar(\"_KT\")\n# Value type\n_VT = typing.TypeVar(\"_VT\")\n# Default type\n_DT = typing.TypeVar(\"_DT\")\n\nValidHTTPHeaderSource = typing.Union[\n    \"HTTPHeaderDict\",\n    typing.Mapping[str, str],\n    typing.Iterable[typing.Tuple[str, str]],\n    \"HasGettableStringKeys\",\n]\n\n\nclass _Sentinel(Enum):\n    not_passed = auto()\n\n\ndef ensure_can_construct_http_header_dict(\n    potential: object,\n) -> ValidHTTPHeaderSource | None:\n    if isinstance(potential, HTTPHeaderDict):\n        return potential\n    elif isinstance(potential, typing.Mapping):\n        # Full runtime checking of the contents of a Mapping is expensive, so for the\n        # purposes of typechecking, we assume that any Mapping is the right shape.\n        return typing.cast(typing.Mapping[str, str], potential)\n    elif isinstance(potential, typing.Iterable):\n        # Similarly to Mapping, full runtime checking of the contents of an Iterable is\n        # expensive, so for the purposes of typechecking, we assume that any Iterable\n        # is the right shape.\n        return typing.cast(typing.Iterable[typing.Tuple[str, str]], potential)\n    elif hasattr(potential, \"keys\") and hasattr(potential, \"__getitem__\"):\n        return typing.cast(\"HasGettableStringKeys\", potential)\n    else:\n        return None\n\n\nclass RecentlyUsedContainer(typing.Generic[_KT, _VT], typing.MutableMapping[_KT, _VT]):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n\n    :param maxsize:\n        Maximum number of recent elements to retain.\n\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called\n    \"\"\"\n\n    _container: typing.OrderedDict[_KT, _VT]\n    _maxsize: int\n    dispose_func: typing.Callable[[_VT], None] | None\n    lock: RLock\n\n    def __init__(\n        self,\n        maxsize: int = 10,\n        dispose_func: typing.Callable[[_VT], None] | None = None,\n    ) -> None:\n        super().__init__()\n        self._maxsize = maxsize\n        self.dispose_func = dispose_func\n        self._container = OrderedDict()\n        self.lock = RLock()\n\n    def __getitem__(self, key: _KT) -> _VT:\n        # Re-insert the item, moving it to the end of the eviction line.\n        with self.lock:\n            item = self._container.pop(key)\n            self._container[key] = item\n            return item\n\n    def __setitem__(self, key: _KT, value: _VT) -> None:\n        evicted_item = None\n        with self.lock:\n            # Possibly evict the existing value of 'key'\n            try:\n                # If the key exists, we'll overwrite it, which won't change the\n                # size of the pool. Because accessing a key should move it to\n                # the end of the eviction line, we pop it out first.\n                evicted_item = key, self._container.pop(key)\n                self._container[key] = value\n            except KeyError:\n                # When the key does not exist, we insert the value first so that\n                # evicting works in all cases, including when self._maxsize is 0\n                self._container[key] = value\n                if len(self._container) > self._maxsize:\n                    # If we didn't evict an existing value, and we've hit our maximum\n                    # size, then we have to evict the least recently used item from\n                    # the beginning of the container.\n                    evicted_item = self._container.popitem(last=False)\n\n        # After releasing the lock on the pool, dispose of any evicted value.\n        if evicted_item is not None and self.dispose_func:\n            _, evicted_value = evicted_item\n            self.dispose_func(evicted_value)\n\n    def __delitem__(self, key: _KT) -> None:\n        with self.lock:\n            value = self._container.pop(key)\n\n        if self.dispose_func:\n            self.dispose_func(value)\n\n    def __len__(self) -> int:\n        with self.lock:\n            return len(self._container)\n\n    def __iter__(self) -> typing.NoReturn:\n        raise NotImplementedError(\n            \"Iteration over this class is unlikely to be threadsafe.\"\n        )\n\n    def clear(self) -> None:\n        with self.lock:\n            # Copy pointers to all values, then wipe the mapping\n            values = list(self._container.values())\n            self._container.clear()\n\n        if self.dispose_func:\n            for value in values:\n                self.dispose_func(value)\n\n    def keys(self) -> set[_KT]:  # type: ignore[override]\n        with self.lock:\n            return set(self._container.keys())\n\n\nclass HTTPHeaderDictItemView(typing.Set[typing.Tuple[str, str]]):\n    \"\"\"\n    HTTPHeaderDict is unusual for a Mapping[str, str] in that it has two modes of\n    address.\n\n    If we directly try to get an item with a particular name, we will get a string\n    back that is the concatenated version of all the values:\n\n    >>> d['X-Header-Name']\n    'Value1, Value2, Value3'\n\n    However, if we iterate over an HTTPHeaderDict's items, we will optionally combine\n    these values based on whether combine=True was called when building up the dictionary\n\n    >>> d = HTTPHeaderDict({\"A\": \"1\", \"B\": \"foo\"})\n    >>> d.add(\"A\", \"2\", combine=True)\n    >>> d.add(\"B\", \"bar\")\n    >>> list(d.items())\n    [\n        ('A', '1, 2'),\n        ('B', 'foo'),\n        ('B', 'bar'),\n    ]\n\n    This class conforms to the interface required by the MutableMapping ABC while\n    also giving us the nonstandard iteration behavior we want; items with duplicate\n    keys, ordered by time of first insertion.\n    \"\"\"\n\n    _headers: HTTPHeaderDict\n\n    def __init__(self, headers: HTTPHeaderDict) -> None:\n        self._headers = headers\n\n    def __len__(self) -> int:\n        return len(list(self._headers.iteritems()))\n\n    def __iter__(self) -> typing.Iterator[tuple[str, str]]:\n        return self._headers.iteritems()\n\n    def __contains__(self, item: object) -> bool:\n        if isinstance(item, tuple) and len(item) == 2:\n            passed_key, passed_val = item\n            if isinstance(passed_key, str) and isinstance(passed_val, str):\n                return self._headers._has_value_for_header(passed_key, passed_val)\n        return False\n\n\nclass HTTPHeaderDict(typing.MutableMapping[str, str]):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n\n    A ``dict`` like container for storing HTTP Headers.\n\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each\n    case-insensitive pair.\n\n    Using ``__setitem__`` syntax overwrites fields that compare equal\n    case-insensitively in order to maintain ``dict``'s api. For fields that\n    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``\n    in a loop.\n\n    If multiple fields that are equal case-insensitively are passed to the\n    constructor or ``.update``, the behavior is undefined and some will be\n    lost.\n\n    >>> headers = HTTPHeaderDict()\n    >>> headers.add('Set-Cookie', 'foo=bar')\n    >>> headers.add('set-cookie', 'baz=quxx')\n    >>> headers['content-length'] = '7'\n    >>> headers['SET-cookie']\n    'foo=bar, baz=quxx'\n    >>> headers['Content-Length']\n    '7'\n    \"\"\"\n\n    _container: typing.MutableMapping[str, list[str]]\n\n    def __init__(self, headers: ValidHTTPHeaderSource | None = None, **kwargs: str):\n        super().__init__()\n        self._container = {}  # 'dict' is insert-ordered\n        if headers is not None:\n            if isinstance(headers, HTTPHeaderDict):\n                self._copy_from(headers)\n            else:\n                self.extend(headers)\n        if kwargs:\n            self.extend(kwargs)\n\n    def __setitem__(self, key: str, val: str) -> None:\n        # avoid a bytes/str comparison by decoding before httplib\n        if isinstance(key, bytes):\n            key = key.decode(\"latin-1\")\n        self._container[key.lower()] = [key, val]\n\n    def __getitem__(self, key: str) -> str:\n        val = self._container[key.lower()]\n        return \", \".join(val[1:])\n\n    def __delitem__(self, key: str) -> None:\n        del self._container[key.lower()]\n\n    def __contains__(self, key: object) -> bool:\n        if isinstance(key, str):\n            return key.lower() in self._container\n        return False\n\n    def setdefault(self, key: str, default: str = \"\") -> str:\n        return super().setdefault(key, default)\n\n    def __eq__(self, other: object) -> bool:\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return False\n        else:\n            other_as_http_header_dict = type(self)(maybe_constructable)\n\n        return {k.lower(): v for k, v in self.itermerged()} == {\n            k.lower(): v for k, v in other_as_http_header_dict.itermerged()\n        }\n\n    def __ne__(self, other: object) -> bool:\n        return not self.__eq__(other)\n\n    def __len__(self) -> int:\n        return len(self._container)\n\n    def __iter__(self) -> typing.Iterator[str]:\n        # Only provide the originally cased names\n        for vals in self._container.values():\n            yield vals[0]\n\n    def discard(self, key: str) -> None:\n        try:\n            del self[key]\n        except KeyError:\n            pass\n\n    def add(self, key: str, val: str, *, combine: bool = False) -> None:\n        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already\n        exists.\n\n        If this is called with combine=True, instead of adding a new header value\n        as a distinct item during iteration, this will instead append the value to\n        any existing header value with a comma. If no existing header value exists\n        for the key, then the value will simply be added, ignoring the combine parameter.\n\n        >>> headers = HTTPHeaderDict(foo='bar')\n        >>> headers.add('Foo', 'baz')\n        >>> headers['foo']\n        'bar, baz'\n        >>> list(headers.items())\n        [('foo', 'bar'), ('foo', 'baz')]\n        >>> headers.add('foo', 'quz', combine=True)\n        >>> list(headers.items())\n        [('foo', 'bar, baz, quz')]\n        \"\"\"\n        # avoid a bytes/str comparison by decoding before httplib\n        if isinstance(key, bytes):\n            key = key.decode(\"latin-1\")\n        key_lower = key.lower()\n        new_vals = [key, val]\n        # Keep the common case aka no item present as fast as possible\n        vals = self._container.setdefault(key_lower, new_vals)\n        if new_vals is not vals:\n            # if there are values here, then there is at least the initial\n            # key/value pair\n            assert len(vals) >= 2\n            if combine:\n                vals[-1] = vals[-1] + \", \" + val\n            else:\n                vals.append(val)\n\n    def extend(self, *args: ValidHTTPHeaderSource, **kwargs: str) -> None:\n        \"\"\"Generic import function for any type of header-like object.\n        Adapted version of MutableMapping.update in order to insert items\n        with self.add instead of self.__setitem__\n        \"\"\"\n        if len(args) > 1:\n            raise TypeError(\n                f\"extend() takes at most 1 positional arguments ({len(args)} given)\"\n            )\n        other = args[0] if len(args) >= 1 else ()\n\n        if isinstance(other, HTTPHeaderDict):\n            for key, val in other.iteritems():\n                self.add(key, val)\n        elif isinstance(other, typing.Mapping):\n            for key, val in other.items():\n                self.add(key, val)\n        elif isinstance(other, typing.Iterable):\n            other = typing.cast(typing.Iterable[typing.Tuple[str, str]], other)\n            for key, value in other:\n                self.add(key, value)\n        elif hasattr(other, \"keys\") and hasattr(other, \"__getitem__\"):\n            # THIS IS NOT A TYPESAFE BRANCH\n            # In this branch, the object has a `keys` attr but is not a Mapping or any of\n            # the other types indicated in the method signature. We do some stuff with\n            # it as though it partially implements the Mapping interface, but we're not\n            # doing that stuff safely AT ALL.\n            for key in other.keys():\n                self.add(key, other[key])\n\n        for key, value in kwargs.items():\n            self.add(key, value)\n\n    @typing.overload\n    def getlist(self, key: str) -> list[str]:\n        ...\n\n    @typing.overload\n    def getlist(self, key: str, default: _DT) -> list[str] | _DT:\n        ...\n\n    def getlist(\n        self, key: str, default: _Sentinel | _DT = _Sentinel.not_passed\n    ) -> list[str] | _DT:\n        \"\"\"Returns a list of all the values for the named field. Returns an\n        empty list if the key doesn't exist.\"\"\"\n        try:\n            vals = self._container[key.lower()]\n        except KeyError:\n            if default is _Sentinel.not_passed:\n                # _DT is unbound; empty list is instance of List[str]\n                return []\n            # _DT is bound; default is instance of _DT\n            return default\n        else:\n            # _DT may or may not be bound; vals[1:] is instance of List[str], which\n            # meets our external interface requirement of `Union[List[str], _DT]`.\n            return vals[1:]\n\n    def _prepare_for_method_change(self) -> Self:\n        \"\"\"\n        Remove content-specific header fields before changing the request\n        method to GET or HEAD according to RFC 9110, Section 15.4.\n        \"\"\"\n        content_specific_headers = [\n            \"Content-Encoding\",\n            \"Content-Language\",\n            \"Content-Location\",\n            \"Content-Type\",\n            \"Content-Length\",\n            \"Digest\",\n            \"Last-Modified\",\n        ]\n        for header in content_specific_headers:\n            self.discard(header)\n        return self\n\n    # Backwards compatibility for httplib\n    getheaders = getlist\n    getallmatchingheaders = getlist\n    iget = getlist\n\n    # Backwards compatibility for http.cookiejar\n    get_all = getlist\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}({dict(self.itermerged())})\"\n\n    def _copy_from(self, other: HTTPHeaderDict) -> None:\n        for key in other:\n            val = other.getlist(key)\n            self._container[key.lower()] = [key, *val]\n\n    def copy(self) -> Self:\n        clone = type(self)()\n        clone._copy_from(self)\n        return clone\n\n    def iteritems(self) -> typing.Iterator[tuple[str, str]]:\n        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"\n        for key in self:\n            vals = self._container[key.lower()]\n            for val in vals[1:]:\n                yield vals[0], val\n\n    def itermerged(self) -> typing.Iterator[tuple[str, str]]:\n        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"\n        for key in self:\n            val = self._container[key.lower()]\n            yield val[0], \", \".join(val[1:])\n\n    def items(self) -> HTTPHeaderDictItemView:  # type: ignore[override]\n        return HTTPHeaderDictItemView(self)\n\n    def _has_value_for_header(self, header_name: str, potential_value: str) -> bool:\n        if header_name in self:\n            return potential_value in self._container[header_name.lower()][1:]\n        return False\n\n    def __ior__(self, other: object) -> HTTPHeaderDict:\n        # Supports extending a header dict in-place using operator |=\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        self.extend(maybe_constructable)\n        return self\n\n    def __or__(self, other: object) -> Self:\n        # Supports merging header dicts using operator |\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        result = self.copy()\n        result.extend(maybe_constructable)\n        return result\n\n    def __ror__(self, other: object) -> Self:\n        # Supports merging header dicts using operator | when other is on left side\n        # combining items with add instead of __setitem__\n        maybe_constructable = ensure_can_construct_http_header_dict(other)\n        if maybe_constructable is None:\n            return NotImplemented\n        result = type(self)(maybe_constructable)\n        result.extend(self)\n        return result\n", "src/urllib3/poolmanager.py": "from __future__ import annotations\n\nimport functools\nimport logging\nimport typing\nimport warnings\nfrom types import TracebackType\nfrom urllib.parse import urljoin\n\nfrom ._collections import HTTPHeaderDict, RecentlyUsedContainer\nfrom ._request_methods import RequestMethods\nfrom .connection import ProxyConfig\nfrom .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme\nfrom .exceptions import (\n    LocationValueError,\n    MaxRetryError,\n    ProxySchemeUnknown,\n    URLSchemeUnknown,\n)\nfrom .response import BaseHTTPResponse\nfrom .util.connection import _TYPE_SOCKET_OPTIONS\nfrom .util.proxy import connection_requires_http_tunnel\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\nfrom .util.url import Url, parse_url\n\nif typing.TYPE_CHECKING:\n    import ssl\n\n    from typing_extensions import Self\n\n__all__ = [\"PoolManager\", \"ProxyManager\", \"proxy_from_url\"]\n\n\nlog = logging.getLogger(__name__)\n\nSSL_KEYWORDS = (\n    \"key_file\",\n    \"cert_file\",\n    \"cert_reqs\",\n    \"ca_certs\",\n    \"ca_cert_data\",\n    \"ssl_version\",\n    \"ssl_minimum_version\",\n    \"ssl_maximum_version\",\n    \"ca_cert_dir\",\n    \"ssl_context\",\n    \"key_password\",\n    \"server_hostname\",\n)\n# Default value for `blocksize` - a new parameter introduced to\n# http.client.HTTPConnection & http.client.HTTPSConnection in Python 3.7\n_DEFAULT_BLOCKSIZE = 16384\n\n\nclass PoolKey(typing.NamedTuple):\n    \"\"\"\n    All known keyword arguments that could be provided to the pool manager, its\n    pools, or the underlying connections.\n\n    All custom key schemes should include the fields in this key at a minimum.\n    \"\"\"\n\n    key_scheme: str\n    key_host: str\n    key_port: int | None\n    key_timeout: Timeout | float | int | None\n    key_retries: Retry | bool | int | None\n    key_block: bool | None\n    key_source_address: tuple[str, int] | None\n    key_key_file: str | None\n    key_key_password: str | None\n    key_cert_file: str | None\n    key_cert_reqs: str | None\n    key_ca_certs: str | None\n    key_ca_cert_data: str | bytes | None\n    key_ssl_version: int | str | None\n    key_ssl_minimum_version: ssl.TLSVersion | None\n    key_ssl_maximum_version: ssl.TLSVersion | None\n    key_ca_cert_dir: str | None\n    key_ssl_context: ssl.SSLContext | None\n    key_maxsize: int | None\n    key_headers: frozenset[tuple[str, str]] | None\n    key__proxy: Url | None\n    key__proxy_headers: frozenset[tuple[str, str]] | None\n    key__proxy_config: ProxyConfig | None\n    key_socket_options: _TYPE_SOCKET_OPTIONS | None\n    key__socks_options: frozenset[tuple[str, str]] | None\n    key_assert_hostname: bool | str | None\n    key_assert_fingerprint: str | None\n    key_server_hostname: str | None\n    key_blocksize: int | None\n\n\ndef _default_key_normalizer(\n    key_class: type[PoolKey], request_context: dict[str, typing.Any]\n) -> PoolKey:\n    \"\"\"\n    Create a pool key out of a request context dictionary.\n\n    According to RFC 3986, both the scheme and host are case-insensitive.\n    Therefore, this function normalizes both before constructing the pool\n    key for an HTTPS request. If you wish to change this behaviour, provide\n    alternate callables to ``key_fn_by_scheme``.\n\n    :param key_class:\n        The class to use when constructing the key. This should be a namedtuple\n        with the ``scheme`` and ``host`` keys at a minimum.\n    :type  key_class: namedtuple\n    :param request_context:\n        A dictionary-like object that contain the context for a request.\n    :type  request_context: dict\n\n    :return: A namedtuple that can be used as a connection pool key.\n    :rtype:  PoolKey\n    \"\"\"\n    # Since we mutate the dictionary, make a copy first\n    context = request_context.copy()\n    context[\"scheme\"] = context[\"scheme\"].lower()\n    context[\"host\"] = context[\"host\"].lower()\n\n    # These are both dictionaries and need to be transformed into frozensets\n    for key in (\"headers\", \"_proxy_headers\", \"_socks_options\"):\n        if key in context and context[key] is not None:\n            context[key] = frozenset(context[key].items())\n\n    # The socket_options key may be a list and needs to be transformed into a\n    # tuple.\n    socket_opts = context.get(\"socket_options\")\n    if socket_opts is not None:\n        context[\"socket_options\"] = tuple(socket_opts)\n\n    # Map the kwargs to the names in the namedtuple - this is necessary since\n    # namedtuples can't have fields starting with '_'.\n    for key in list(context.keys()):\n        context[\"key_\" + key] = context.pop(key)\n\n    # Default to ``None`` for keys missing from the context\n    for field in key_class._fields:\n        if field not in context:\n            context[field] = None\n\n    # Default key_blocksize to _DEFAULT_BLOCKSIZE if missing from the context\n    if context.get(\"key_blocksize\") is None:\n        context[\"key_blocksize\"] = _DEFAULT_BLOCKSIZE\n\n    return key_class(**context)\n\n\n#: A dictionary that maps a scheme to a callable that creates a pool key.\n#: This can be used to alter the way pool keys are constructed, if desired.\n#: Each PoolManager makes a copy of this dictionary so they can be configured\n#: globally here, or individually on the instance.\nkey_fn_by_scheme = {\n    \"http\": functools.partial(_default_key_normalizer, PoolKey),\n    \"https\": functools.partial(_default_key_normalizer, PoolKey),\n}\n\npool_classes_by_scheme = {\"http\": HTTPConnectionPool, \"https\": HTTPSConnectionPool}\n\n\nclass PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param \\\\**connection_pool_kw:\n        Additional parameters are used to create fresh\n        :class:`urllib3.connectionpool.ConnectionPool` instances.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        http = urllib3.PoolManager(num_pools=2)\n\n        resp1 = http.request(\"GET\", \"https://google.com/\")\n        resp2 = http.request(\"GET\", \"https://google.com/mail\")\n        resp3 = http.request(\"GET\", \"https://yahoo.com/\")\n\n        print(len(http.pools))\n        # 2\n\n    \"\"\"\n\n    proxy: Url | None = None\n    proxy_config: ProxyConfig | None = None\n\n    def __init__(\n        self,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        **connection_pool_kw: typing.Any,\n    ) -> None:\n        super().__init__(headers)\n        self.connection_pool_kw = connection_pool_kw\n\n        self.pools: RecentlyUsedContainer[PoolKey, HTTPConnectionPool]\n        self.pools = RecentlyUsedContainer(num_pools)\n\n        # Locally set the pool classes and keys so other PoolManagers can\n        # override them.\n        self.pool_classes_by_scheme = pool_classes_by_scheme\n        self.key_fn_by_scheme = key_fn_by_scheme.copy()\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> typing.Literal[False]:\n        self.clear()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def _new_pool(\n        self,\n        scheme: str,\n        host: str,\n        port: int,\n        request_context: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\n        any additional pool keyword arguments.\n\n        If ``request_context`` is provided, it is provided as keyword arguments\n        to the pool class used. This method is used to actually create the\n        connection pools handed out by :meth:`connection_from_url` and\n        companion methods. It is intended to be overridden for customization.\n        \"\"\"\n        pool_cls: type[HTTPConnectionPool] = self.pool_classes_by_scheme[scheme]\n        if request_context is None:\n            request_context = self.connection_pool_kw.copy()\n\n        # Default blocksize to _DEFAULT_BLOCKSIZE if missing or explicitly\n        # set to 'None' in the request_context.\n        if request_context.get(\"blocksize\") is None:\n            request_context[\"blocksize\"] = _DEFAULT_BLOCKSIZE\n\n        # Although the context has everything necessary to create the pool,\n        # this function has historically only used the scheme, host, and port\n        # in the positional args. When an API change is acceptable these can\n        # be removed.\n        for key in (\"scheme\", \"host\", \"port\"):\n            request_context.pop(key, None)\n\n        if scheme == \"http\":\n            for kw in SSL_KEYWORDS:\n                request_context.pop(kw, None)\n\n        return pool_cls(host, port, **request_context)\n\n    def clear(self) -> None:\n        \"\"\"\n        Empty our store of pools and direct them all to close.\n\n        This will not affect in-flight connections, but they will not be\n        re-used after completion.\n        \"\"\"\n        self.pools.clear()\n\n    def connection_from_host(\n        self,\n        host: str | None,\n        port: int | None = None,\n        scheme: str | None = \"http\",\n        pool_kwargs: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n        provided, it is merged with the instance's ``connection_pool_kw``\n        variable and used to create the new connection pool, if one is\n        needed.\n        \"\"\"\n\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        request_context = self._merge_pool_kwargs(pool_kwargs)\n        request_context[\"scheme\"] = scheme or \"http\"\n        if not port:\n            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n        request_context[\"port\"] = port\n        request_context[\"host\"] = host\n\n        return self.connection_from_context(request_context)\n\n    def connection_from_context(\n        self, request_context: dict[str, typing.Any]\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n        ``request_context`` must at least contain the ``scheme`` key and its\n        value must be a key in ``key_fn_by_scheme`` instance variable.\n        \"\"\"\n        if \"strict\" in request_context:\n            warnings.warn(\n                \"The 'strict' parameter is no longer needed on Python 3+. \"\n                \"This will raise an error in urllib3 v2.1.0.\",\n                DeprecationWarning,\n            )\n            request_context.pop(\"strict\")\n\n        scheme = request_context[\"scheme\"].lower()\n        pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n        if not pool_key_constructor:\n            raise URLSchemeUnknown(scheme)\n        pool_key = pool_key_constructor(request_context)\n\n        return self.connection_from_pool_key(pool_key, request_context=request_context)\n\n    def connection_from_pool_key(\n        self, pool_key: PoolKey, request_context: dict[str, typing.Any]\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n        ``pool_key`` should be a namedtuple that only contains immutable\n        objects. At a minimum it must have the ``scheme``, ``host``, and\n        ``port`` fields.\n        \"\"\"\n        with self.pools.lock:\n            # If the scheme, host, or port doesn't match existing open\n            # connections, open a new ConnectionPool.\n            pool = self.pools.get(pool_key)\n            if pool:\n                return pool\n\n            # Make a fresh ConnectionPool of the desired type\n            scheme = request_context[\"scheme\"]\n            host = request_context[\"host\"]\n            port = request_context[\"port\"]\n            pool = self._new_pool(scheme, host, port, request_context=request_context)\n            self.pools[pool_key] = pool\n\n        return pool\n\n    def connection_from_url(\n        self, url: str, pool_kwargs: dict[str, typing.Any] | None = None\n    ) -> HTTPConnectionPool:\n        \"\"\"\n        Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n        If ``pool_kwargs`` is not provided and a new pool needs to be\n        constructed, ``self.connection_pool_kw`` is used to initialize\n        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n        is provided, it is used instead. Note that if a new pool does not\n        need to be created for the request, the provided ``pool_kwargs`` are\n        not used.\n        \"\"\"\n        u = parse_url(url)\n        return self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _merge_pool_kwargs(\n        self, override: dict[str, typing.Any] | None\n    ) -> dict[str, typing.Any]:\n        \"\"\"\n        Merge a dictionary of override values for self.connection_pool_kw.\n\n        This does not modify self.connection_pool_kw and returns a new dict.\n        Any keys in the override dictionary with a value of ``None`` are\n        removed from the merged dictionary.\n        \"\"\"\n        base_pool_kwargs = self.connection_pool_kw.copy()\n        if override:\n            for key, value in override.items():\n                if value is None:\n                    try:\n                        del base_pool_kwargs[key]\n                    except KeyError:\n                        pass\n                else:\n                    base_pool_kwargs[key] = value\n        return base_pool_kwargs\n\n    def _proxy_requires_url_absolute_form(self, parsed_url: Url) -> bool:\n        \"\"\"\n        Indicates if the proxy requires the complete destination URL in the\n        request.  Normally this is only needed when not using an HTTP CONNECT\n        tunnel.\n        \"\"\"\n        if self.proxy is None:\n            return False\n\n        return not connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, parsed_url.scheme\n        )\n\n    def urlopen(  # type: ignore[override]\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n\n        if u.scheme is None:\n            warnings.warn(\n                \"URLs without a scheme (ie 'https://') are deprecated and will raise an error \"\n                \"in a future version of urllib3. To avoid this DeprecationWarning ensure all URLs \"\n                \"start with 'https://' or 'http://'. Read more in this issue: \"\n                \"https://github.com/urllib3/urllib3/issues/2920\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        if response.status == 303:\n            # Change the method according to RFC 9110, Section 15.4.4.\n            method = \"GET\"\n            # And lose the body not to transfer anything sensitive.\n            kw[\"body\"] = None\n            kw[\"headers\"] = HTTPHeaderDict(kw[\"headers\"])._prepare_for_method_change()\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            new_headers = kw[\"headers\"].copy()\n            for header in kw[\"headers\"]:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    new_headers.pop(header, None)\n            kw[\"headers\"] = new_headers\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -> %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)\n\n\nclass ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n\n    :param proxy_url:\n        The URL of the proxy to be used.\n\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n        authentication.\n\n    :param proxy_ssl_context:\n        The proxy SSL context is used to establish the TLS connection to the\n        proxy when using HTTPS proxies.\n\n    :param use_forwarding_for_https:\n        (Defaults to False) If set to True will forward requests to the HTTPS\n        proxy to be made on behalf of the client instead of creating a TLS\n        tunnel via the CONNECT method. **Enabling this flag means that request\n        and response headers and content will be visible from the HTTPS proxy**\n        whereas tunneling keeps request and response headers and content\n        private.  IP address, target hostname, SNI, and port are always visible\n        to an HTTPS proxy even when this flag is disabled.\n\n    :param proxy_assert_hostname:\n        The hostname of the certificate to verify against.\n\n    :param proxy_assert_fingerprint:\n        The fingerprint of the certificate to verify against.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        proxy = urllib3.ProxyManager(\"https://localhost:3128/\")\n\n        resp1 = proxy.request(\"GET\", \"https://google.com/\")\n        resp2 = proxy.request(\"GET\", \"https://httpbin.org/\")\n\n        print(len(proxy.pools))\n        # 1\n\n        resp3 = proxy.request(\"GET\", \"https://httpbin.org/\")\n        resp4 = proxy.request(\"GET\", \"https://twitter.com/\")\n\n        print(len(proxy.pools))\n        # 3\n\n    \"\"\"\n\n    def __init__(\n        self,\n        proxy_url: str,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        proxy_headers: typing.Mapping[str, str] | None = None,\n        proxy_ssl_context: ssl.SSLContext | None = None,\n        use_forwarding_for_https: bool = False,\n        proxy_assert_hostname: None | str | typing.Literal[False] = None,\n        proxy_assert_fingerprint: str | None = None,\n        **connection_pool_kw: typing.Any,\n    ) -> None:\n        if isinstance(proxy_url, HTTPConnectionPool):\n            str_proxy_url = f\"{proxy_url.scheme}://{proxy_url.host}:{proxy_url.port}\"\n        else:\n            str_proxy_url = proxy_url\n        proxy = parse_url(str_proxy_url)\n\n        if proxy.scheme not in (\"http\", \"https\"):\n            raise ProxySchemeUnknown(proxy.scheme)\n\n        if not proxy.port:\n            port = port_by_scheme.get(proxy.scheme, 80)\n            proxy = proxy._replace(port=port)\n\n        self.proxy = proxy\n        self.proxy_headers = proxy_headers or {}\n        self.proxy_ssl_context = proxy_ssl_context\n        self.proxy_config = ProxyConfig(\n            proxy_ssl_context,\n            use_forwarding_for_https,\n            proxy_assert_hostname,\n            proxy_assert_fingerprint,\n        )\n\n        connection_pool_kw[\"_proxy\"] = self.proxy\n        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers\n        connection_pool_kw[\"_proxy_config\"] = self.proxy_config\n\n        super().__init__(num_pools, headers, **connection_pool_kw)\n\n    def connection_from_host(\n        self,\n        host: str | None,\n        port: int | None = None,\n        scheme: str | None = \"http\",\n        pool_kwargs: dict[str, typing.Any] | None = None,\n    ) -> HTTPConnectionPool:\n        if scheme == \"https\":\n            return super().connection_from_host(\n                host, port, scheme, pool_kwargs=pool_kwargs\n            )\n\n        return super().connection_from_host(\n            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs  # type: ignore[union-attr]\n        )\n\n    def _set_proxy_headers(\n        self, url: str, headers: typing.Mapping[str, str] | None = None\n    ) -> typing.Mapping[str, str]:\n        \"\"\"\n        Sets headers needed by proxies: specifically, the Accept and Host\n        headers. Only sets headers not provided by the user.\n        \"\"\"\n        headers_ = {\"Accept\": \"*/*\"}\n\n        netloc = parse_url(url).netloc\n        if netloc:\n            headers_[\"Host\"] = netloc\n\n        if headers:\n            headers_.update(headers)\n        return headers_\n\n    def urlopen(  # type: ignore[override]\n        self, method: str, url: str, redirect: bool = True, **kw: typing.Any\n    ) -> BaseHTTPResponse:\n        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n        u = parse_url(url)\n        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n            # For connections using HTTP CONNECT, httplib sets the necessary\n            # headers on the CONNECT to the proxy. If we're not using CONNECT,\n            # we'll definitely need to set 'Host' at the very least.\n            headers = kw.get(\"headers\", self.headers)\n            kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n        return super().urlopen(method, url, redirect=redirect, **kw)\n\n\ndef proxy_from_url(url: str, **kw: typing.Any) -> ProxyManager:\n    return ProxyManager(proxy_url=url, **kw)\n", "src/urllib3/__init__.py": "\"\"\"\nPython HTTP library with thread-safe connection pooling, file post support, user friendly, and more\n\"\"\"\n\nfrom __future__ import annotations\n\n# Set default logging handler to avoid \"No handler found\" warnings.\nimport logging\nimport sys\nimport typing\nimport warnings\nfrom logging import NullHandler\n\nfrom . import exceptions\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom ._version import __version__\nfrom .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, connection_from_url\nfrom .filepost import _TYPE_FIELDS, encode_multipart_formdata\nfrom .poolmanager import PoolManager, ProxyManager, proxy_from_url\nfrom .response import BaseHTTPResponse, HTTPResponse\nfrom .util.request import make_headers\nfrom .util.retry import Retry\nfrom .util.timeout import Timeout\n\n# Ensure that Python is compiled with OpenSSL 1.1.1+\n# If the 'ssl' module isn't available at all that's\n# fine, we only care if the module is available.\ntry:\n    import ssl\nexcept ImportError:\n    pass\nelse:\n    if not ssl.OPENSSL_VERSION.startswith(\"OpenSSL \"):  # Defensive:\n        warnings.warn(\n            \"urllib3 v2 only supports OpenSSL 1.1.1+, currently \"\n            f\"the 'ssl' module is compiled with {ssl.OPENSSL_VERSION!r}. \"\n            \"See: https://github.com/urllib3/urllib3/issues/3020\",\n            exceptions.NotOpenSSLWarning,\n        )\n    elif ssl.OPENSSL_VERSION_INFO < (1, 1, 1):  # Defensive:\n        raise ImportError(\n            \"urllib3 v2 only supports OpenSSL 1.1.1+, currently \"\n            f\"the 'ssl' module is compiled with {ssl.OPENSSL_VERSION!r}. \"\n            \"See: https://github.com/urllib3/urllib3/issues/2168\"\n        )\n\n__author__ = \"Andrey Petrov (andrey.petrov@shazow.net)\"\n__license__ = \"MIT\"\n__version__ = __version__\n\n__all__ = (\n    \"HTTPConnectionPool\",\n    \"HTTPHeaderDict\",\n    \"HTTPSConnectionPool\",\n    \"PoolManager\",\n    \"ProxyManager\",\n    \"HTTPResponse\",\n    \"Retry\",\n    \"Timeout\",\n    \"add_stderr_logger\",\n    \"connection_from_url\",\n    \"disable_warnings\",\n    \"encode_multipart_formdata\",\n    \"make_headers\",\n    \"proxy_from_url\",\n    \"request\",\n    \"BaseHTTPResponse\",\n)\n\nlogging.getLogger(__name__).addHandler(NullHandler())\n\n\ndef add_stderr_logger(\n    level: int = logging.DEBUG,\n) -> logging.StreamHandler[typing.TextIO]:\n    \"\"\"\n    Helper for quickly adding a StreamHandler to the logger. Useful for\n    debugging.\n\n    Returns the handler after adding it.\n    \"\"\"\n    # This method needs to be in this __init__.py to get the __name__ correct\n    # even if urllib3 is vendored within another package.\n    logger = logging.getLogger(__name__)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)s %(message)s\"))\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    logger.debug(\"Added a stderr logging handler to logger: %s\", __name__)\n    return handler\n\n\n# ... Clean up.\ndel NullHandler\n\n\n# All warning filters *must* be appended unless you're really certain that they\n# shouldn't be: otherwise, it's very hard for users to use most Python\n# mechanisms to silence them.\n# SecurityWarning's always go off by default.\nwarnings.simplefilter(\"always\", exceptions.SecurityWarning, append=True)\n# InsecurePlatformWarning's don't vary between requests, so we keep it default.\nwarnings.simplefilter(\"default\", exceptions.InsecurePlatformWarning, append=True)\n\n\ndef disable_warnings(category: type[Warning] = exceptions.HTTPWarning) -> None:\n    \"\"\"\n    Helper for quickly disabling all urllib3 warnings.\n    \"\"\"\n    warnings.simplefilter(\"ignore\", category)\n\n\n_DEFAULT_POOL = PoolManager()\n\n\ndef request(\n    method: str,\n    url: str,\n    *,\n    body: _TYPE_BODY | None = None,\n    fields: _TYPE_FIELDS | None = None,\n    headers: typing.Mapping[str, str] | None = None,\n    preload_content: bool | None = True,\n    decode_content: bool | None = True,\n    redirect: bool | None = True,\n    retries: Retry | bool | int | None = None,\n    timeout: Timeout | float | int | None = 3,\n    json: typing.Any | None = None,\n) -> BaseHTTPResponse:\n    \"\"\"\n    A convenience, top-level request method. It uses a module-global ``PoolManager`` instance.\n    Therefore, its side effects could be shared across dependencies relying on it.\n    To avoid side effects create a new ``PoolManager`` instance and use it instead.\n    The method does not accept low-level ``**urlopen_kw`` keyword arguments.\n\n    :param method:\n        HTTP request method (such as GET, POST, PUT, etc.)\n\n    :param url:\n        The URL to perform the request on.\n\n    :param body:\n        Data to send in the request body, either :class:`str`, :class:`bytes`,\n        an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n    :param fields:\n        Data to encode and send in the request body.\n\n    :param headers:\n        Dictionary of custom headers to send, such as User-Agent,\n        If-None-Match, etc.\n\n    :param bool preload_content:\n        If True, the response's body will be preloaded into memory.\n\n    :param bool decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param redirect:\n        If True, automatically handle redirects (status codes 301, 302,\n        303, 307, 308). Each redirect counts as a retry. Disabling retries\n        will disable redirect, too.\n\n    :param retries:\n        Configure the number of retries to allow before raising a\n        :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n        If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n        :class:`~urllib3.util.retry.Retry` object for fine-grained control\n        over different types of retries.\n        Pass an integer number to retry connection errors that many times,\n        but no other types of errors. Pass zero to never retry.\n\n        If ``False``, then retries are disabled and any exception is raised\n        immediately. Also, instead of raising a MaxRetryError on redirects,\n        the redirect response will be returned.\n\n    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n    :param timeout:\n        If specified, overrides the default timeout for this one\n        request. It may be a float (in seconds) or an instance of\n        :class:`urllib3.util.Timeout`.\n\n    :param json:\n        Data to encode and send as JSON with UTF-encoded in the request body.\n        The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n        unless specified otherwise.\n    \"\"\"\n\n    return _DEFAULT_POOL.request(\n        method,\n        url,\n        body=body,\n        fields=fields,\n        headers=headers,\n        preload_content=preload_content,\n        decode_content=decode_content,\n        redirect=redirect,\n        retries=retries,\n        timeout=timeout,\n        json=json,\n    )\n\n\nif sys.platform == \"emscripten\":\n    from .contrib.emscripten import inject_into_urllib3  # noqa: 401\n\n    inject_into_urllib3()\n", "src/urllib3/_request_methods.py": "from __future__ import annotations\n\nimport json as _json\nimport typing\nfrom urllib.parse import urlencode\n\nfrom ._base_connection import _TYPE_BODY\nfrom ._collections import HTTPHeaderDict\nfrom .filepost import _TYPE_FIELDS, encode_multipart_formdata\nfrom .response import BaseHTTPResponse\n\n__all__ = [\"RequestMethods\"]\n\n_TYPE_ENCODE_URL_FIELDS = typing.Union[\n    typing.Sequence[typing.Tuple[str, typing.Union[str, bytes]]],\n    typing.Mapping[str, typing.Union[str, bytes]],\n]\n\n\nclass RequestMethods:\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n\n    Specifically,\n\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).\n\n    :meth:`.request_encode_body` is for sending requests whose fields are\n    encoded in the *body* of the request using multipart or www-form-urlencoded\n    (such as for POST, PUT, PATCH).\n\n    :meth:`.request` is for making any kind of request, it will look up the\n    appropriate encoding format and use one of the above two methods to make\n    the request.\n\n    Initializer parameters:\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n    \"\"\"\n\n    _encode_url_methods = {\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\"}\n\n    def __init__(self, headers: typing.Mapping[str, str] | None = None) -> None:\n        self.headers = headers or {}\n\n    def urlopen(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        encode_multipart: bool = True,\n        multipart_boundary: str | None = None,\n        **kw: typing.Any,\n    ) -> BaseHTTPResponse:  # Abstract\n        raise NotImplementedError(\n            \"Classes extending RequestMethods must implement \"\n            \"their own ``urlopen`` method.\"\n        )\n\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        fields: _TYPE_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        json: typing.Any | None = None,\n        **urlopen_kw: typing.Any,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the appropriate encoding of\n        ``fields`` based on the ``method`` used.\n\n        This is a convenience method that requires the least amount of manual\n        effort. It can be used in most situations, while still having the\n        option to drop down to more specific methods when necessary, such as\n        :meth:`request_encode_url`, :meth:`request_encode_body`,\n        or even the lowest level :meth:`urlopen`.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param fields:\n            Data to encode and send in the request body.  Values are processed\n            by :func:`urllib.parse.urlencode`.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param json:\n            Data to encode and send as JSON with UTF-encoded in the request body.\n            The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n            unless specified otherwise.\n        \"\"\"\n        method = method.upper()\n\n        if json is not None and body is not None:\n            raise TypeError(\n                \"request got values for both 'body' and 'json' parameters which are mutually exclusive\"\n            )\n\n        if json is not None:\n            if headers is None:\n                headers = self.headers\n\n            if not (\"content-type\" in map(str.lower, headers.keys())):\n                headers = HTTPHeaderDict(headers)\n                headers[\"Content-Type\"] = \"application/json\"\n\n            body = _json.dumps(json, separators=(\",\", \":\"), ensure_ascii=False).encode(\n                \"utf-8\"\n            )\n\n        if body is not None:\n            urlopen_kw[\"body\"] = body\n\n        if method in self._encode_url_methods:\n            return self.request_encode_url(\n                method,\n                url,\n                fields=fields,  # type: ignore[arg-type]\n                headers=headers,\n                **urlopen_kw,\n            )\n        else:\n            return self.request_encode_body(\n                method, url, fields=fields, headers=headers, **urlopen_kw\n            )\n\n    def request_encode_url(\n        self,\n        method: str,\n        url: str,\n        fields: _TYPE_ENCODE_URL_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        **urlopen_kw: str,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param fields:\n            Data to encode and send in the request body.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw: dict[str, typing.Any] = {\"headers\": headers}\n        extra_kw.update(urlopen_kw)\n\n        if fields:\n            url += \"?\" + urlencode(fields)\n\n        return self.urlopen(method, url, **extra_kw)\n\n    def request_encode_body(\n        self,\n        method: str,\n        url: str,\n        fields: _TYPE_FIELDS | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        encode_multipart: bool = True,\n        multipart_boundary: str | None = None,\n        **urlopen_kw: str,\n    ) -> BaseHTTPResponse:\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the body. This is useful for request methods like POST, PUT, PATCH, etc.\n\n        When ``encode_multipart=True`` (default), then\n        :func:`urllib3.encode_multipart_formdata` is used to encode\n        the payload with the appropriate content type. Otherwise\n        :func:`urllib.parse.urlencode` is used with the\n        'application/x-www-form-urlencoded' content type.\n\n        Multipart encoding must be used when posting files, and it's reasonably\n        safe to use it in other times too. However, it may break request\n        signing, such as with OAuth.\n\n        Supports an optional ``fields`` parameter of key/value strings AND\n        key/filetuple. A filetuple is a (filename, data, MIME type) tuple where\n        the MIME type is optional. For example::\n\n            fields = {\n                'foo': 'bar',\n                'fakefile': ('foofile.txt', 'contents of foofile'),\n                'realfile': ('barfile.txt', open('realfile').read()),\n                'typedfile': ('bazfile.bin', open('bazfile').read(),\n                              'image/jpeg'),\n                'nonamefile': 'contents of nonamefile field',\n            }\n\n        When uploading a file, providing a filename (the first parameter of the\n        tuple) is optional but recommended to best mimic behavior of browsers.\n\n        Note that if ``headers`` are supplied, the 'Content-Type' header will\n        be overwritten because it depends on the dynamic random boundary string\n        which is used to compose the body of the request. The random boundary\n        string can be explicitly set with the ``multipart_boundary`` parameter.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param fields:\n            Data to encode and send in the request body.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param encode_multipart:\n            If True, encode the ``fields`` using the multipart/form-data MIME\n            format.\n\n        :param multipart_boundary:\n            If not specified, then a random boundary will be generated using\n            :func:`urllib3.filepost.choose_boundary`.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw: dict[str, typing.Any] = {\"headers\": HTTPHeaderDict(headers)}\n        body: bytes | str\n\n        if fields:\n            if \"body\" in urlopen_kw:\n                raise TypeError(\n                    \"request got values for both 'fields' and 'body', can only specify one.\"\n                )\n\n            if encode_multipart:\n                body, content_type = encode_multipart_formdata(\n                    fields, boundary=multipart_boundary\n                )\n            else:\n                body, content_type = (\n                    urlencode(fields),  # type: ignore[arg-type]\n                    \"application/x-www-form-urlencoded\",\n                )\n\n            extra_kw[\"body\"] = body\n            extra_kw[\"headers\"].setdefault(\"Content-Type\", content_type)\n\n        extra_kw.update(urlopen_kw)\n\n        return self.urlopen(method, url, **extra_kw)\n", "src/urllib3/contrib/socks.py": "\"\"\"\nThis module contains provisional support for SOCKS proxies from within\nurllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and\nSOCKS5. To enable its functionality, either install PySocks or install this\nmodule with the ``socks`` extra.\n\nThe SOCKS implementation supports the full range of urllib3 features. It also\nsupports the following SOCKS features:\n\n- SOCKS4A (``proxy_url='socks4a://...``)\n- SOCKS4 (``proxy_url='socks4://...``)\n- SOCKS5 with remote DNS (``proxy_url='socks5h://...``)\n- SOCKS5 with local DNS (``proxy_url='socks5://...``)\n- Usernames and passwords for the SOCKS proxy\n\n.. note::\n   It is recommended to use ``socks5h://`` or ``socks4a://`` schemes in\n   your ``proxy_url`` to ensure that DNS resolution is done from the remote\n   server instead of client-side when connecting to a domain name.\n\nSOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5\nsupports IPv4, IPv6, and domain names.\n\nWhen connecting to a SOCKS4 proxy the ``username`` portion of the ``proxy_url``\nwill be sent as the ``userid`` section of the SOCKS request:\n\n.. code-block:: python\n\n    proxy_url=\"socks4a://<userid>@proxy-host\"\n\nWhen connecting to a SOCKS5 proxy the ``username`` and ``password`` portion\nof the ``proxy_url`` will be sent as the username/password to authenticate\nwith the proxy:\n\n.. code-block:: python\n\n    proxy_url=\"socks5h://<username>:<password>@proxy-host\"\n\n\"\"\"\n\nfrom __future__ import annotations\n\ntry:\n    import socks  # type: ignore[import-not-found]\nexcept ImportError:\n    import warnings\n\n    from ..exceptions import DependencyWarning\n\n    warnings.warn(\n        (\n            \"SOCKS support in urllib3 requires the installation of optional \"\n            \"dependencies: specifically, PySocks.  For more information, see \"\n            \"https://urllib3.readthedocs.io/en/latest/advanced-usage.html#socks-proxies\"\n        ),\n        DependencyWarning,\n    )\n    raise\n\nimport typing\nfrom socket import timeout as SocketTimeout\n\nfrom ..connection import HTTPConnection, HTTPSConnection\nfrom ..connectionpool import HTTPConnectionPool, HTTPSConnectionPool\nfrom ..exceptions import ConnectTimeoutError, NewConnectionError\nfrom ..poolmanager import PoolManager\nfrom ..util.url import parse_url\n\ntry:\n    import ssl\nexcept ImportError:\n    ssl = None  # type: ignore[assignment]\n\n\nclass _TYPE_SOCKS_OPTIONS(typing.TypedDict):\n    socks_version: int\n    proxy_host: str | None\n    proxy_port: str | None\n    username: str | None\n    password: str | None\n    rdns: bool\n\n\nclass SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n\n    def __init__(\n        self,\n        _socks_options: _TYPE_SOCKS_OPTIONS,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> None:\n        self._socks_options = _socks_options\n        super().__init__(*args, **kwargs)\n\n    def _new_conn(self) -> socks.socksocket:\n        \"\"\"\n        Establish a new connection via the SOCKS proxy.\n        \"\"\"\n        extra_kw: dict[str, typing.Any] = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n\n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n\n        try:\n            conn = socks.create_connection(\n                (self.host, self.port),\n                proxy_type=self._socks_options[\"socks_version\"],\n                proxy_addr=self._socks_options[\"proxy_host\"],\n                proxy_port=self._socks_options[\"proxy_port\"],\n                proxy_username=self._socks_options[\"username\"],\n                proxy_password=self._socks_options[\"password\"],\n                proxy_rdns=self._socks_options[\"rdns\"],\n                timeout=self.timeout,\n                **extra_kw,\n            )\n\n        except SocketTimeout as e:\n            raise ConnectTimeoutError(\n                self,\n                f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n            ) from e\n\n        except socks.ProxyError as e:\n            # This is fragile as hell, but it seems to be the only way to raise\n            # useful errors here.\n            if e.socket_err:\n                error = e.socket_err\n                if isinstance(error, SocketTimeout):\n                    raise ConnectTimeoutError(\n                        self,\n                        f\"Connection to {self.host} timed out. (connect timeout={self.timeout})\",\n                    ) from e\n                else:\n                    # Adding `from e` messes with coverage somehow, so it's omitted.\n                    # See #2386.\n                    raise NewConnectionError(\n                        self, f\"Failed to establish a new connection: {error}\"\n                    )\n            else:\n                raise NewConnectionError(\n                    self, f\"Failed to establish a new connection: {e}\"\n                ) from e\n\n        except OSError as e:  # Defensive: PySocks should catch all these.\n            raise NewConnectionError(\n                self, f\"Failed to establish a new connection: {e}\"\n            ) from e\n\n        return conn\n\n\n# We don't need to duplicate the Verified/Unverified distinction from\n# urllib3/connection.py here because the HTTPSConnection will already have been\n# correctly set to either the Verified or Unverified form by that module. This\n# means the SOCKSHTTPSConnection will automatically be the correct type.\nclass SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):\n    pass\n\n\nclass SOCKSHTTPConnectionPool(HTTPConnectionPool):\n    ConnectionCls = SOCKSConnection\n\n\nclass SOCKSHTTPSConnectionPool(HTTPSConnectionPool):\n    ConnectionCls = SOCKSHTTPSConnection\n\n\nclass SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n\n    def __init__(\n        self,\n        proxy_url: str,\n        username: str | None = None,\n        password: str | None = None,\n        num_pools: int = 10,\n        headers: typing.Mapping[str, str] | None = None,\n        **connection_pool_kw: typing.Any,\n    ):\n        parsed = parse_url(proxy_url)\n\n        if username is None and password is None and parsed.auth is not None:\n            split = parsed.auth.split(\":\")\n            if len(split) == 2:\n                username, password = split\n        if parsed.scheme == \"socks5\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = False\n        elif parsed.scheme == \"socks5h\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = True\n        elif parsed.scheme == \"socks4\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = False\n        elif parsed.scheme == \"socks4a\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = True\n        else:\n            raise ValueError(f\"Unable to determine SOCKS version from {proxy_url}\")\n\n        self.proxy_url = proxy_url\n\n        socks_options = {\n            \"socks_version\": socks_version,\n            \"proxy_host\": parsed.host,\n            \"proxy_port\": parsed.port,\n            \"username\": username,\n            \"password\": password,\n            \"rdns\": rdns,\n        }\n        connection_pool_kw[\"_socks_options\"] = socks_options\n\n        super().__init__(num_pools, headers, **connection_pool_kw)\n\n        self.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme\n", "src/urllib3/contrib/__init__.py": "", "src/urllib3/contrib/pyopenssl.py": "\"\"\"\nModule for using pyOpenSSL as a TLS backend. This module was relevant before\nthe standard library ``ssl`` module supported SNI, but now that we've dropped\nsupport for Python 2.7 all relevant Python versions support SNI so\n**this module is no longer recommended**.\n\nThis needs the following packages installed:\n\n* `pyOpenSSL`_ (tested with 16.0.0)\n* `cryptography`_ (minimum 1.3.4, from pyopenssl)\n* `idna`_ (minimum 2.0)\n\nHowever, pyOpenSSL depends on cryptography, so while we use all three directly here we\nend up having relatively few packages required.\n\nYou can install them with the following command:\n\n.. code-block:: bash\n\n    $ python -m pip install pyopenssl cryptography idna\n\nTo activate certificate checking, call\n:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code\nbefore you begin making HTTP requests. This can be done in a ``sitecustomize``\nmodule, or at any other time before your application begins using ``urllib3``,\nlike this:\n\n.. code-block:: python\n\n    try:\n        import urllib3.contrib.pyopenssl\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n    except ImportError:\n        pass\n\n.. _pyopenssl: https://www.pyopenssl.org\n.. _cryptography: https://cryptography.io\n.. _idna: https://github.com/kjd/idna\n\"\"\"\n\nfrom __future__ import annotations\n\nimport OpenSSL.SSL  # type: ignore[import-untyped]\nfrom cryptography import x509\n\ntry:\n    from cryptography.x509 import UnsupportedExtension  # type: ignore[attr-defined]\nexcept ImportError:\n    # UnsupportedExtension is gone in cryptography >= 2.1.0\n    class UnsupportedExtension(Exception):  # type: ignore[no-redef]\n        pass\n\n\nimport logging\nimport ssl\nimport typing\nfrom io import BytesIO\nfrom socket import socket as socket_cls\nfrom socket import timeout\n\nfrom .. import util\n\nif typing.TYPE_CHECKING:\n    from OpenSSL.crypto import X509  # type: ignore[import-untyped]\n\n\n__all__ = [\"inject_into_urllib3\", \"extract_from_urllib3\"]\n\n# Map from urllib3 to PyOpenSSL compatible parameter-values.\n_openssl_versions: dict[int, int] = {\n    util.ssl_.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    util.ssl_.PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,  # type: ignore[attr-defined]\n    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,\n}\n\nif hasattr(ssl, \"PROTOCOL_TLSv1_1\") and hasattr(OpenSSL.SSL, \"TLSv1_1_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD\n\nif hasattr(ssl, \"PROTOCOL_TLSv1_2\") and hasattr(OpenSSL.SSL, \"TLSv1_2_METHOD\"):\n    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD\n\n\n_stdlib_to_openssl_verify = {\n    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,\n    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,\n    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER\n    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,\n}\n_openssl_to_stdlib_verify = {v: k for k, v in _stdlib_to_openssl_verify.items()}\n\n# The SSLvX values are the most likely to be missing in the future\n# but we check them all just to be sure.\n_OP_NO_SSLv2_OR_SSLv3: int = getattr(OpenSSL.SSL, \"OP_NO_SSLv2\", 0) | getattr(\n    OpenSSL.SSL, \"OP_NO_SSLv3\", 0\n)\n_OP_NO_TLSv1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1\", 0)\n_OP_NO_TLSv1_1: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_1\", 0)\n_OP_NO_TLSv1_2: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_2\", 0)\n_OP_NO_TLSv1_3: int = getattr(OpenSSL.SSL, \"OP_NO_TLSv1_3\", 0)\n\n_openssl_to_ssl_minimum_version: dict[int, int] = {\n    ssl.TLSVersion.MINIMUM_SUPPORTED: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.TLSv1: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.TLSv1_1: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1,\n    ssl.TLSVersion.TLSv1_2: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1,\n    ssl.TLSVersion.TLSv1_3: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2\n    ),\n    ssl.TLSVersion.MAXIMUM_SUPPORTED: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2\n    ),\n}\n_openssl_to_ssl_maximum_version: dict[int, int] = {\n    ssl.TLSVersion.MINIMUM_SUPPORTED: (\n        _OP_NO_SSLv2_OR_SSLv3\n        | _OP_NO_TLSv1\n        | _OP_NO_TLSv1_1\n        | _OP_NO_TLSv1_2\n        | _OP_NO_TLSv1_3\n    ),\n    ssl.TLSVersion.TLSv1: (\n        _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_1 | _OP_NO_TLSv1_2 | _OP_NO_TLSv1_3\n    ),\n    ssl.TLSVersion.TLSv1_1: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_2 | _OP_NO_TLSv1_3,\n    ssl.TLSVersion.TLSv1_2: _OP_NO_SSLv2_OR_SSLv3 | _OP_NO_TLSv1_3,\n    ssl.TLSVersion.TLSv1_3: _OP_NO_SSLv2_OR_SSLv3,\n    ssl.TLSVersion.MAXIMUM_SUPPORTED: _OP_NO_SSLv2_OR_SSLv3,\n}\n\n# OpenSSL will only write 16K at a time\nSSL_WRITE_BLOCKSIZE = 16384\n\norig_util_SSLContext = util.ssl_.SSLContext\n\n\nlog = logging.getLogger(__name__)\n\n\ndef inject_into_urllib3() -> None:\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n\n    _validate_dependencies_met()\n\n    util.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.ssl_.SSLContext = PyOpenSSLContext  # type: ignore[assignment]\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\n\n\ndef extract_from_urllib3() -> None:\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\n\n\ndef _validate_dependencies_met() -> None:\n    \"\"\"\n    Verifies that PyOpenSSL's package-level dependencies have been met.\n    Throws `ImportError` if they are not met.\n    \"\"\"\n    # Method added in `cryptography==1.1`; not available in older versions\n    from cryptography.x509.extensions import Extensions\n\n    if getattr(Extensions, \"get_extension_for_class\", None) is None:\n        raise ImportError(\n            \"'cryptography' module missing required functionality.  \"\n            \"Try upgrading to v1.3.4 or newer.\"\n        )\n\n    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509\n    # attribute is only present on those versions.\n    from OpenSSL.crypto import X509\n\n    x509 = X509()\n    if getattr(x509, \"_x509\", None) is None:\n        raise ImportError(\n            \"'pyOpenSSL' module missing required functionality. \"\n            \"Try upgrading to v0.14 or newer.\"\n        )\n\n\ndef _dnsname_to_stdlib(name: str) -> str | None:\n    \"\"\"\n    Converts a dNSName SubjectAlternativeName field to the form used by the\n    standard library on the given Python version.\n\n    Cryptography produces a dNSName as a unicode string that was idna-decoded\n    from ASCII bytes. We need to idna-encode that string to get it back, and\n    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib\n    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).\n\n    If the name cannot be idna-encoded then we return None signalling that\n    the name given should be skipped.\n    \"\"\"\n\n    def idna_encode(name: str) -> bytes | None:\n        \"\"\"\n        Borrowed wholesale from the Python Cryptography Project. It turns out\n        that we can't just safely call `idna.encode`: it can explode for\n        wildcard names. This avoids that problem.\n        \"\"\"\n        import idna\n\n        try:\n            for prefix in [\"*.\", \".\"]:\n                if name.startswith(prefix):\n                    name = name[len(prefix) :]\n                    return prefix.encode(\"ascii\") + idna.encode(name)\n            return idna.encode(name)\n        except idna.core.IDNAError:\n            return None\n\n    # Don't send IPv6 addresses through the IDNA encoder.\n    if \":\" in name:\n        return name\n\n    encoded_name = idna_encode(name)\n    if encoded_name is None:\n        return None\n    return encoded_name.decode(\"utf-8\")\n\n\ndef get_subj_alt_name(peer_cert: X509) -> list[tuple[str, str]]:\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    cert = peer_cert.to_cryptography()\n\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:\n        # No such extension, return the empty list.\n        return []\n    except (\n        x509.DuplicateExtension,\n        UnsupportedExtension,\n        x509.UnsupportedGeneralNameType,\n        UnicodeError,\n    ) as e:\n        # A problem has been found with the quality of the certificate. Assume\n        # no SAN field is present.\n        log.warning(\n            \"A problem was encountered with the certificate that prevented \"\n            \"urllib3 from finding the SubjectAlternativeName field. This can \"\n            \"affect certificate validation. The error was %s\",\n            e,\n        )\n        return []\n\n    # We want to return dNSName and iPAddress fields. We need to cast the IPs\n    # back to strings because the match_hostname function wants them as\n    # strings.\n    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8\n    # decoded. This is pretty frustrating, but that's what the standard library\n    # does with certificates, and so we need to attempt to do the same.\n    # We also want to skip over names which cannot be idna encoded.\n    names = [\n        (\"DNS\", name)\n        for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))\n        if name is not None\n    ]\n    names.extend(\n        (\"IP Address\", str(name)) for name in ext.get_values_for_type(x509.IPAddress)\n    )\n\n    return names\n\n\nclass WrappedSocket:\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\"\"\"\n\n    def __init__(\n        self,\n        connection: OpenSSL.SSL.Connection,\n        socket: socket_cls,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        self.connection = connection\n        self.socket = socket\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self._io_refs = 0\n        self._closed = False\n\n    def fileno(self) -> int:\n        return self.socket.fileno()\n\n    # Copy-pasted from Python 3.5 source code\n    def _decref_socketios(self) -> None:\n        if self._io_refs > 0:\n            self._io_refs -= 1\n        if self._closed:\n            self.close()\n\n    def recv(self, *args: typing.Any, **kwargs: typing.Any) -> bytes:\n        try:\n            data = self.connection.recv(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return b\"\"\n            else:\n                raise OSError(e.args[0], str(e)) from e\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return b\"\"\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError as e:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\") from e\n            else:\n                return self.recv(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"read error: {e!r}\") from e\n        else:\n            return data  # type: ignore[no-any-return]\n\n    def recv_into(self, *args: typing.Any, **kwargs: typing.Any) -> int:\n        try:\n            return self.connection.recv_into(*args, **kwargs)  # type: ignore[no-any-return]\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return 0\n            else:\n                raise OSError(e.args[0], str(e)) from e\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return 0\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError as e:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\") from e\n            else:\n                return self.recv_into(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"read error: {e!r}\") from e\n\n    def settimeout(self, timeout: float) -> None:\n        return self.socket.settimeout(timeout)\n\n    def _send_until_done(self, data: bytes) -> int:\n        while True:\n            try:\n                return self.connection.send(data)  # type: ignore[no-any-return]\n            except OpenSSL.SSL.WantWriteError as e:\n                if not util.wait_for_write(self.socket, self.socket.gettimeout()):\n                    raise timeout() from e\n                continue\n            except OpenSSL.SSL.SysCallError as e:\n                raise OSError(e.args[0], str(e)) from e\n\n    def sendall(self, data: bytes) -> None:\n        total_sent = 0\n        while total_sent < len(data):\n            sent = self._send_until_done(\n                data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE]\n            )\n            total_sent += sent\n\n    def shutdown(self) -> None:\n        # FIXME rethrow compatible exceptions should we ever use this\n        self.connection.shutdown()\n\n    def close(self) -> None:\n        self._closed = True\n        if self._io_refs <= 0:\n            self._real_close()\n\n    def _real_close(self) -> None:\n        try:\n            return self.connection.close()  # type: ignore[no-any-return]\n        except OpenSSL.SSL.Error:\n            return\n\n    def getpeercert(\n        self, binary_form: bool = False\n    ) -> dict[str, list[typing.Any]] | None:\n        x509 = self.connection.get_peer_certificate()\n\n        if not x509:\n            return x509  # type: ignore[no-any-return]\n\n        if binary_form:\n            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)  # type: ignore[no-any-return]\n\n        return {\n            \"subject\": (((\"commonName\", x509.get_subject().CN),),),  # type: ignore[dict-item]\n            \"subjectAltName\": get_subj_alt_name(x509),\n        }\n\n    def version(self) -> str:\n        return self.connection.get_protocol_version_name()  # type: ignore[no-any-return]\n\n\nWrappedSocket.makefile = socket_cls.makefile  # type: ignore[attr-defined]\n\n\nclass PyOpenSSLContext:\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n\n    def __init__(self, protocol: int) -> None:\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0\n        self.check_hostname = False\n        self._minimum_version: int = ssl.TLSVersion.MINIMUM_SUPPORTED\n        self._maximum_version: int = ssl.TLSVersion.MAXIMUM_SUPPORTED\n\n    @property\n    def options(self) -> int:\n        return self._options\n\n    @options.setter\n    def options(self, value: int) -> None:\n        self._options = value\n        self._set_ctx_options()\n\n    @property\n    def verify_mode(self) -> int:\n        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]\n\n    @verify_mode.setter\n    def verify_mode(self, value: ssl.VerifyMode) -> None:\n        self._ctx.set_verify(_stdlib_to_openssl_verify[value], _verify_callback)\n\n    def set_default_verify_paths(self) -> None:\n        self._ctx.set_default_verify_paths()\n\n    def set_ciphers(self, ciphers: bytes | str) -> None:\n        if isinstance(ciphers, str):\n            ciphers = ciphers.encode(\"utf-8\")\n        self._ctx.set_cipher_list(ciphers)\n\n    def load_verify_locations(\n        self,\n        cafile: str | None = None,\n        capath: str | None = None,\n        cadata: bytes | None = None,\n    ) -> None:\n        if cafile is not None:\n            cafile = cafile.encode(\"utf-8\")  # type: ignore[assignment]\n        if capath is not None:\n            capath = capath.encode(\"utf-8\")  # type: ignore[assignment]\n        try:\n            self._ctx.load_verify_locations(cafile, capath)\n            if cadata is not None:\n                self._ctx.load_verify_locations(BytesIO(cadata))\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"unable to load trusted certificates: {e!r}\") from e\n\n    def load_cert_chain(\n        self,\n        certfile: str,\n        keyfile: str | None = None,\n        password: str | None = None,\n    ) -> None:\n        try:\n            self._ctx.use_certificate_chain_file(certfile)\n            if password is not None:\n                if not isinstance(password, bytes):\n                    password = password.encode(\"utf-8\")  # type: ignore[assignment]\n                self._ctx.set_passwd_cb(lambda *_: password)\n            self._ctx.use_privatekey_file(keyfile or certfile)\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(f\"Unable to load certificate chain: {e!r}\") from e\n\n    def set_alpn_protocols(self, protocols: list[bytes | str]) -> None:\n        protocols = [util.util.to_bytes(p, \"ascii\") for p in protocols]\n        return self._ctx.set_alpn_protos(protocols)  # type: ignore[no-any-return]\n\n    def wrap_socket(\n        self,\n        sock: socket_cls,\n        server_side: bool = False,\n        do_handshake_on_connect: bool = True,\n        suppress_ragged_eofs: bool = True,\n        server_hostname: bytes | str | None = None,\n    ) -> WrappedSocket:\n        cnx = OpenSSL.SSL.Connection(self._ctx, sock)\n\n        # If server_hostname is an IP, don't use it for SNI, per RFC6066 Section 3\n        if server_hostname and not util.ssl_.is_ipaddress(server_hostname):\n            if isinstance(server_hostname, str):\n                server_hostname = server_hostname.encode(\"utf-8\")\n            cnx.set_tlsext_host_name(server_hostname)\n\n        cnx.set_connect_state()\n\n        while True:\n            try:\n                cnx.do_handshake()\n            except OpenSSL.SSL.WantReadError as e:\n                if not util.wait_for_read(sock, sock.gettimeout()):\n                    raise timeout(\"select timed out\") from e\n                continue\n            except OpenSSL.SSL.Error as e:\n                raise ssl.SSLError(f\"bad handshake: {e!r}\") from e\n            break\n\n        return WrappedSocket(cnx, sock)\n\n    def _set_ctx_options(self) -> None:\n        self._ctx.set_options(\n            self._options\n            | _openssl_to_ssl_minimum_version[self._minimum_version]\n            | _openssl_to_ssl_maximum_version[self._maximum_version]\n        )\n\n    @property\n    def minimum_version(self) -> int:\n        return self._minimum_version\n\n    @minimum_version.setter\n    def minimum_version(self, minimum_version: int) -> None:\n        self._minimum_version = minimum_version\n        self._set_ctx_options()\n\n    @property\n    def maximum_version(self) -> int:\n        return self._maximum_version\n\n    @maximum_version.setter\n    def maximum_version(self, maximum_version: int) -> None:\n        self._maximum_version = maximum_version\n        self._set_ctx_options()\n\n\ndef _verify_callback(\n    cnx: OpenSSL.SSL.Connection,\n    x509: X509,\n    err_no: int,\n    err_depth: int,\n    return_code: int,\n) -> bool:\n    return err_no == 0\n", "src/urllib3/contrib/emscripten/response.py": "from __future__ import annotations\n\nimport json as _json\nimport logging\nimport typing\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom http.client import HTTPException as HTTPException\nfrom io import BytesIO, IOBase\n\nfrom ...exceptions import InvalidHeader, TimeoutError\nfrom ...response import BaseHTTPResponse\nfrom ...util.retry import Retry\nfrom .request import EmscriptenRequest\n\nif typing.TYPE_CHECKING:\n    from ..._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\nlog = logging.getLogger(__name__)\n\n\n@dataclass\nclass EmscriptenResponse:\n    status_code: int\n    headers: dict[str, str]\n    body: IOBase | bytes\n    request: EmscriptenRequest\n\n\nclass EmscriptenHttpResponseWrapper(BaseHTTPResponse):\n    def __init__(\n        self,\n        internal_response: EmscriptenResponse,\n        url: str | None = None,\n        connection: BaseHTTPConnection | BaseHTTPSConnection | None = None,\n    ):\n        self._pool = None  # set by pool class\n        self._body = None\n        self._response = internal_response\n        self._url = url\n        self._connection = connection\n        self._closed = False\n        super().__init__(\n            headers=internal_response.headers,\n            status=internal_response.status_code,\n            request_url=url,\n            version=0,\n            version_string=\"HTTP/?\",\n            reason=\"\",\n            decode_content=True,\n        )\n        self.length_remaining = self._init_length(self._response.request.method)\n        self.length_is_certain = False\n\n    @property\n    def url(self) -> str | None:\n        return self._url\n\n    @url.setter\n    def url(self, url: str | None) -> None:\n        self._url = url\n\n    @property\n    def connection(self) -> BaseHTTPConnection | BaseHTTPSConnection | None:\n        return self._connection\n\n    @property\n    def retries(self) -> Retry | None:\n        return self._retries\n\n    @retries.setter\n    def retries(self, retries: Retry | None) -> None:\n        # Override the request_url if retries has a redirect location.\n        self._retries = retries\n\n    def stream(\n        self, amt: int | None = 2**16, decode_content: bool | None = None\n    ) -> typing.Generator[bytes, None, None]:\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        while True:\n            data = self.read(amt=amt, decode_content=decode_content)\n\n            if data:\n                yield data\n            else:\n                break\n\n    def _init_length(self, request_method: str | None) -> int | None:\n        length: int | None\n        content_length: str | None = self.headers.get(\"content-length\")\n\n        if content_length is not None:\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = {int(val) for val in content_length.split(\",\")}\n                if len(lengths) > 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % content_length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length < 0:\n                    length = None\n\n        else:  # if content_length is None\n            length = None\n\n        # Check for responses that shouldn't include a body\n        if (\n            self.status in (204, 304)\n            or 100 <= self.status < 200\n            or request_method == \"HEAD\"\n        ):\n            length = 0\n\n        return length\n\n    def read(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,  # ignored because browser decodes always\n        cache_content: bool = False,\n    ) -> bytes:\n        if (\n            self._closed\n            or self._response is None\n            or (isinstance(self._response.body, IOBase) and self._response.body.closed)\n        ):\n            return b\"\"\n\n        with self._error_catcher():\n            # body has been preloaded as a string by XmlHttpRequest\n            if not isinstance(self._response.body, IOBase):\n                self.length_remaining = len(self._response.body)\n                self.length_is_certain = True\n                # wrap body in IOStream\n                self._response.body = BytesIO(self._response.body)\n            if amt is not None and amt >= 0:\n                # don't cache partial content\n                cache_content = False\n                data = self._response.body.read(amt)\n                if self.length_remaining is not None:\n                    self.length_remaining = max(self.length_remaining - len(data), 0)\n                if (self.length_is_certain and self.length_remaining == 0) or len(\n                    data\n                ) < amt:\n                    # definitely finished reading, close response stream\n                    self._response.body.close()\n                return typing.cast(bytes, data)\n            else:  # read all we can (and cache it)\n                data = self._response.body.read()\n                if cache_content:\n                    self._body = data\n                if self.length_remaining is not None:\n                    self.length_remaining = max(self.length_remaining - len(data), 0)\n                if len(data) == 0 or (\n                    self.length_is_certain and self.length_remaining == 0\n                ):\n                    # definitely finished reading, close response stream\n                    self._response.body.close()\n                return typing.cast(bytes, data)\n\n    def read_chunked(\n        self,\n        amt: int | None = None,\n        decode_content: bool | None = None,\n    ) -> typing.Generator[bytes, None, None]:\n        # chunked is handled by browser\n        while True:\n            bytes = self.read(amt, decode_content)\n            if not bytes:\n                break\n            yield bytes\n\n    def release_conn(self) -> None:\n        if not self._pool or not self._connection:\n            return None\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self) -> None:\n        self.close()\n\n    @property\n    def data(self) -> bytes:\n        if self._body:\n            return self._body\n        else:\n            return self.read(cache_content=True)\n\n    def json(self) -> typing.Any:\n        \"\"\"\n        Deserializes the body of the HTTP response as a Python object.\n\n        The body of the HTTP response must be encoded using UTF-8, as per\n        `RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\n        To use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\n        your custom decoder instead.\n\n        If the body of the HTTP response is not decodable to UTF-8, a\n        `UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\n        valid JSON document, a `json.JSONDecodeError` will be raised.\n\n        Read more :ref:`here <json_content>`.\n\n        :returns: The body of the HTTP response as a Python object.\n        \"\"\"\n        data = self.data.decode(\"utf-8\")\n        return _json.loads(data)\n\n    def close(self) -> None:\n        if not self._closed:\n            if isinstance(self._response.body, IOBase):\n                self._response.body.close()\n            if self._connection:\n                self._connection.close()\n                self._connection = None\n            self._closed = True\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Catch Emscripten specific exceptions thrown by fetch.py,\n        instead re-raising urllib3 variants, so that low-level exceptions\n        are not leaked in the high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        from .fetch import _RequestError, _TimeoutError  # avoid circular import\n\n        clean_exit = False\n\n        try:\n            yield\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        except _TimeoutError as e:\n            raise TimeoutError(str(e))\n        except _RequestError as e:\n            raise HTTPException(str(e))\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now\n                if (\n                    isinstance(self._response.body, IOBase)\n                    and not self._response.body.closed\n                ):\n                    self._response.body.close()\n                # release the connection back to the pool\n                self.release_conn()\n            else:\n                # If we have read everything from the response stream,\n                # return the connection back to the pool.\n                if (\n                    isinstance(self._response.body, IOBase)\n                    and self._response.body.closed\n                ):\n                    self.release_conn()\n", "src/urllib3/contrib/emscripten/fetch.py": "\"\"\"\nSupport for streaming http requests in emscripten.\n\nA few caveats -\n\nFirstly, you can't do streaming http in the main UI thread, because atomics.wait isn't allowed.\nStreaming only works if you're running pyodide in a web worker.\n\nSecondly, this uses an extra web worker and SharedArrayBuffer to do the asynchronous fetch\noperation, so it requires that you have crossOriginIsolation enabled, by serving over https\n(or from localhost) with the two headers below set:\n\n    Cross-Origin-Opener-Policy: same-origin\n    Cross-Origin-Embedder-Policy: require-corp\n\nYou can tell if cross origin isolation is successfully enabled by looking at the global crossOriginIsolated variable in\njavascript console. If it isn't, streaming requests will fallback to XMLHttpRequest, i.e. getting the whole\nrequest into a buffer and then returning it. it shows a warning in the javascript console in this case.\n\nFinally, the webworker which does the streaming fetch is created on initial import, but will only be started once\ncontrol is returned to javascript. Call `await wait_for_streaming_ready()` to wait for streaming fetch.\n\nNB: in this code, there are a lot of javascript objects. They are named js_*\nto make it clear what type of object they are.\n\"\"\"\nfrom __future__ import annotations\n\nimport io\nimport json\nfrom email.parser import Parser\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING, Any\n\nimport js  # type: ignore[import-not-found]\nfrom pyodide.ffi import (  # type: ignore[import-not-found]\n    JsArray,\n    JsException,\n    JsProxy,\n    to_js,\n)\n\nif TYPE_CHECKING:\n    from typing_extensions import Buffer\n\nfrom .request import EmscriptenRequest\nfrom .response import EmscriptenResponse\n\n\"\"\"\nThere are some headers that trigger unintended CORS preflight requests.\nSee also https://github.com/koenvo/pyodide-http/issues/22\n\"\"\"\nHEADERS_TO_IGNORE = (\"user-agent\",)\n\nSUCCESS_HEADER = -1\nSUCCESS_EOF = -2\nERROR_TIMEOUT = -3\nERROR_EXCEPTION = -4\n\n_STREAMING_WORKER_CODE = (\n    files(__package__)\n    .joinpath(\"emscripten_fetch_worker.js\")\n    .read_text(encoding=\"utf-8\")\n)\n\n\nclass _RequestError(Exception):\n    def __init__(\n        self,\n        message: str | None = None,\n        *,\n        request: EmscriptenRequest | None = None,\n        response: EmscriptenResponse | None = None,\n    ):\n        self.request = request\n        self.response = response\n        self.message = message\n        super().__init__(self.message)\n\n\nclass _StreamingError(_RequestError):\n    pass\n\n\nclass _TimeoutError(_RequestError):\n    pass\n\n\ndef _obj_from_dict(dict_val: dict[str, Any]) -> JsProxy:\n    return to_js(dict_val, dict_converter=js.Object.fromEntries)\n\n\nclass _ReadStream(io.RawIOBase):\n    def __init__(\n        self,\n        int_buffer: JsArray,\n        byte_buffer: JsArray,\n        timeout: float,\n        worker: JsProxy,\n        connection_id: int,\n        request: EmscriptenRequest,\n    ):\n        self.int_buffer = int_buffer\n        self.byte_buffer = byte_buffer\n        self.read_pos = 0\n        self.read_len = 0\n        self.connection_id = connection_id\n        self.worker = worker\n        self.timeout = int(1000 * timeout) if timeout > 0 else None\n        self.is_live = True\n        self._is_closed = False\n        self.request: EmscriptenRequest | None = request\n\n    def __del__(self) -> None:\n        self.close()\n\n    # this is compatible with _base_connection\n    def is_closed(self) -> bool:\n        return self._is_closed\n\n    # for compatibility with RawIOBase\n    @property\n    def closed(self) -> bool:\n        return self.is_closed()\n\n    def close(self) -> None:\n        if not self.is_closed():\n            self.read_len = 0\n            self.read_pos = 0\n            self.int_buffer = None\n            self.byte_buffer = None\n            self._is_closed = True\n            self.request = None\n            if self.is_live:\n                self.worker.postMessage(_obj_from_dict({\"close\": self.connection_id}))\n                self.is_live = False\n            super().close()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def seekable(self) -> bool:\n        return False\n\n    def readinto(self, byte_obj: Buffer) -> int:\n        if not self.int_buffer:\n            raise _StreamingError(\n                \"No buffer for stream in _ReadStream.readinto\",\n                request=self.request,\n                response=None,\n            )\n        if self.read_len == 0:\n            # wait for the worker to send something\n            js.Atomics.store(self.int_buffer, 0, ERROR_TIMEOUT)\n            self.worker.postMessage(_obj_from_dict({\"getMore\": self.connection_id}))\n            if (\n                js.Atomics.wait(self.int_buffer, 0, ERROR_TIMEOUT, self.timeout)\n                == \"timed-out\"\n            ):\n                raise _TimeoutError\n            data_len = self.int_buffer[0]\n            if data_len > 0:\n                self.read_len = data_len\n                self.read_pos = 0\n            elif data_len == ERROR_EXCEPTION:\n                string_len = self.int_buffer[1]\n                # decode the error string\n                js_decoder = js.TextDecoder.new()\n                json_str = js_decoder.decode(self.byte_buffer.slice(0, string_len))\n                raise _StreamingError(\n                    f\"Exception thrown in fetch: {json_str}\",\n                    request=self.request,\n                    response=None,\n                )\n            else:\n                # EOF, free the buffers and return zero\n                # and free the request\n                self.is_live = False\n                self.close()\n                return 0\n        # copy from int32array to python bytes\n        ret_length = min(self.read_len, len(memoryview(byte_obj)))\n        subarray = self.byte_buffer.subarray(\n            self.read_pos, self.read_pos + ret_length\n        ).to_py()\n        memoryview(byte_obj)[0:ret_length] = subarray\n        self.read_len -= ret_length\n        self.read_pos += ret_length\n        return ret_length\n\n\nclass _StreamingFetcher:\n    def __init__(self) -> None:\n        # make web-worker and data buffer on startup\n        self.streaming_ready = False\n\n        js_data_blob = js.Blob.new(\n            [_STREAMING_WORKER_CODE], _obj_from_dict({\"type\": \"application/javascript\"})\n        )\n\n        def promise_resolver(js_resolve_fn: JsProxy, js_reject_fn: JsProxy) -> None:\n            def onMsg(e: JsProxy) -> None:\n                self.streaming_ready = True\n                js_resolve_fn(e)\n\n            def onErr(e: JsProxy) -> None:\n                js_reject_fn(e)  # Defensive: never happens in ci\n\n            self.js_worker.onmessage = onMsg\n            self.js_worker.onerror = onErr\n\n        js_data_url = js.URL.createObjectURL(js_data_blob)\n        self.js_worker = js.globalThis.Worker.new(js_data_url)\n        self.js_worker_ready_promise = js.globalThis.Promise.new(promise_resolver)\n\n    def send(self, request: EmscriptenRequest) -> EmscriptenResponse:\n        headers = {\n            k: v for k, v in request.headers.items() if k not in HEADERS_TO_IGNORE\n        }\n\n        body = request.body\n        fetch_data = {\"headers\": headers, \"body\": to_js(body), \"method\": request.method}\n        # start the request off in the worker\n        timeout = int(1000 * request.timeout) if request.timeout > 0 else None\n        js_shared_buffer = js.SharedArrayBuffer.new(1048576)\n        js_int_buffer = js.Int32Array.new(js_shared_buffer)\n        js_byte_buffer = js.Uint8Array.new(js_shared_buffer, 8)\n\n        js.Atomics.store(js_int_buffer, 0, ERROR_TIMEOUT)\n        js.Atomics.notify(js_int_buffer, 0)\n        js_absolute_url = js.URL.new(request.url, js.location).href\n        self.js_worker.postMessage(\n            _obj_from_dict(\n                {\n                    \"buffer\": js_shared_buffer,\n                    \"url\": js_absolute_url,\n                    \"fetchParams\": fetch_data,\n                }\n            )\n        )\n        # wait for the worker to send something\n        js.Atomics.wait(js_int_buffer, 0, ERROR_TIMEOUT, timeout)\n        if js_int_buffer[0] == ERROR_TIMEOUT:\n            raise _TimeoutError(\n                \"Timeout connecting to streaming request\",\n                request=request,\n                response=None,\n            )\n        elif js_int_buffer[0] == SUCCESS_HEADER:\n            # got response\n            # header length is in second int of intBuffer\n            string_len = js_int_buffer[1]\n            # decode the rest to a JSON string\n            js_decoder = js.TextDecoder.new()\n            # this does a copy (the slice) because decode can't work on shared array\n            # for some silly reason\n            json_str = js_decoder.decode(js_byte_buffer.slice(0, string_len))\n            # get it as an object\n            response_obj = json.loads(json_str)\n            return EmscriptenResponse(\n                request=request,\n                status_code=response_obj[\"status\"],\n                headers=response_obj[\"headers\"],\n                body=_ReadStream(\n                    js_int_buffer,\n                    js_byte_buffer,\n                    request.timeout,\n                    self.js_worker,\n                    response_obj[\"connectionID\"],\n                    request,\n                ),\n            )\n        elif js_int_buffer[0] == ERROR_EXCEPTION:\n            string_len = js_int_buffer[1]\n            # decode the error string\n            js_decoder = js.TextDecoder.new()\n            json_str = js_decoder.decode(js_byte_buffer.slice(0, string_len))\n            raise _StreamingError(\n                f\"Exception thrown in fetch: {json_str}\", request=request, response=None\n            )\n        else:\n            raise _StreamingError(\n                f\"Unknown status from worker in fetch: {js_int_buffer[0]}\",\n                request=request,\n                response=None,\n            )\n\n\n# check if we are in a worker or not\ndef is_in_browser_main_thread() -> bool:\n    return hasattr(js, \"window\") and hasattr(js, \"self\") and js.self == js.window\n\n\ndef is_cross_origin_isolated() -> bool:\n    return hasattr(js, \"crossOriginIsolated\") and js.crossOriginIsolated\n\n\ndef is_in_node() -> bool:\n    return (\n        hasattr(js, \"process\")\n        and hasattr(js.process, \"release\")\n        and hasattr(js.process.release, \"name\")\n        and js.process.release.name == \"node\"\n    )\n\n\ndef is_worker_available() -> bool:\n    return hasattr(js, \"Worker\") and hasattr(js, \"Blob\")\n\n\n_fetcher: _StreamingFetcher | None = None\n\nif is_worker_available() and (\n    (is_cross_origin_isolated() and not is_in_browser_main_thread())\n    and (not is_in_node())\n):\n    _fetcher = _StreamingFetcher()\nelse:\n    _fetcher = None\n\n\ndef send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:\n    if _fetcher and streaming_ready():\n        return _fetcher.send(request)\n    else:\n        _show_streaming_warning()\n        return None\n\n\n_SHOWN_TIMEOUT_WARNING = False\n\n\ndef _show_timeout_warning() -> None:\n    global _SHOWN_TIMEOUT_WARNING\n    if not _SHOWN_TIMEOUT_WARNING:\n        _SHOWN_TIMEOUT_WARNING = True\n        message = \"Warning: Timeout is not available on main browser thread\"\n        js.console.warn(message)\n\n\n_SHOWN_STREAMING_WARNING = False\n\n\ndef _show_streaming_warning() -> None:\n    global _SHOWN_STREAMING_WARNING\n    if not _SHOWN_STREAMING_WARNING:\n        _SHOWN_STREAMING_WARNING = True\n        message = \"Can't stream HTTP requests because: \\n\"\n        if not is_cross_origin_isolated():\n            message += \"  Page is not cross-origin isolated\\n\"\n        if is_in_browser_main_thread():\n            message += \"  Python is running in main browser thread\\n\"\n        if not is_worker_available():\n            message += \" Worker or Blob classes are not available in this environment.\"  # Defensive: this is always False in browsers that we test in\n        if streaming_ready() is False:\n            message += \"\"\" Streaming fetch worker isn't ready. If you want to be sure that streaming fetch\nis working, you need to call: 'await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()`\"\"\"\n        from js import console\n\n        console.warn(message)\n\n\ndef send_request(request: EmscriptenRequest) -> EmscriptenResponse:\n    try:\n        js_xhr = js.XMLHttpRequest.new()\n\n        if not is_in_browser_main_thread():\n            js_xhr.responseType = \"arraybuffer\"\n            if request.timeout:\n                js_xhr.timeout = int(request.timeout * 1000)\n        else:\n            js_xhr.overrideMimeType(\"text/plain; charset=ISO-8859-15\")\n            if request.timeout:\n                # timeout isn't available on the main thread - show a warning in console\n                # if it is set\n                _show_timeout_warning()\n\n        js_xhr.open(request.method, request.url, False)\n        for name, value in request.headers.items():\n            if name.lower() not in HEADERS_TO_IGNORE:\n                js_xhr.setRequestHeader(name, value)\n\n        js_xhr.send(to_js(request.body))\n\n        headers = dict(Parser().parsestr(js_xhr.getAllResponseHeaders()))\n\n        if not is_in_browser_main_thread():\n            body = js_xhr.response.to_py().tobytes()\n        else:\n            body = js_xhr.response.encode(\"ISO-8859-15\")\n        return EmscriptenResponse(\n            status_code=js_xhr.status, headers=headers, body=body, request=request\n        )\n    except JsException as err:\n        if err.name == \"TimeoutError\":\n            raise _TimeoutError(err.message, request=request)\n        elif err.name == \"NetworkError\":\n            raise _RequestError(err.message, request=request)\n        else:\n            # general http error\n            raise _RequestError(err.message, request=request)\n\n\ndef streaming_ready() -> bool | None:\n    if _fetcher:\n        return _fetcher.streaming_ready\n    else:\n        return None  # no fetcher, return None to signify that\n\n\nasync def wait_for_streaming_ready() -> bool:\n    if _fetcher:\n        await _fetcher.js_worker_ready_promise\n        return True\n    else:\n        return False\n", "src/urllib3/contrib/emscripten/connection.py": "from __future__ import annotations\n\nimport os\nimport typing\n\n# use http.client.HTTPException for consistency with non-emscripten\nfrom http.client import HTTPException as HTTPException  # noqa: F401\nfrom http.client import ResponseNotReady\n\nfrom ..._base_connection import _TYPE_BODY\nfrom ...connection import HTTPConnection, ProxyConfig, port_by_scheme\nfrom ...exceptions import TimeoutError\nfrom ...response import BaseHTTPResponse\nfrom ...util.connection import _TYPE_SOCKET_OPTIONS\nfrom ...util.timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\nfrom ...util.url import Url\nfrom .fetch import _RequestError, _TimeoutError, send_request, send_streaming_request\nfrom .request import EmscriptenRequest\nfrom .response import EmscriptenHttpResponseWrapper, EmscriptenResponse\n\nif typing.TYPE_CHECKING:\n    from ..._base_connection import BaseHTTPConnection, BaseHTTPSConnection\n\n\nclass EmscriptenHTTPConnection:\n    default_port: typing.ClassVar[int] = port_by_scheme[\"http\"]\n    default_socket_options: typing.ClassVar[_TYPE_SOCKET_OPTIONS]\n\n    timeout: None | (float)\n\n    host: str\n    port: int\n    blocksize: int\n    source_address: tuple[str, int] | None\n    socket_options: _TYPE_SOCKET_OPTIONS | None\n\n    proxy: Url | None\n    proxy_config: ProxyConfig | None\n\n    is_verified: bool = False\n    proxy_is_verified: bool | None = None\n\n    _response: EmscriptenResponse | None\n\n    def __init__(\n        self,\n        host: str,\n        port: int = 0,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 8192,\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n    ) -> None:\n        self.host = host\n        self.port = port\n        self.timeout = timeout if isinstance(timeout, float) else 0.0\n        self.scheme = \"http\"\n        self._closed = True\n        self._response = None\n        # ignore these things because we don't\n        # have control over that stuff\n        self.proxy = None\n        self.proxy_config = None\n        self.blocksize = blocksize\n        self.source_address = None\n        self.socket_options = None\n        self.is_verified = False\n\n    def set_tunnel(\n        self,\n        host: str,\n        port: int | None = 0,\n        headers: typing.Mapping[str, str] | None = None,\n        scheme: str = \"http\",\n    ) -> None:\n        pass\n\n    def connect(self) -> None:\n        pass\n\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: _TYPE_BODY | None = None,\n        headers: typing.Mapping[str, str] | None = None,\n        # We know *at least* botocore is depending on the order of the\n        # first 3 parameters so to be safe we only mark the later ones\n        # as keyword-only to ensure we have space to extend.\n        *,\n        chunked: bool = False,\n        preload_content: bool = True,\n        decode_content: bool = True,\n        enforce_content_length: bool = True,\n    ) -> None:\n        self._closed = False\n        if url.startswith(\"/\"):\n            # no scheme / host / port included, make a full url\n            url = f\"{self.scheme}://{self.host}:{self.port}\" + url\n        request = EmscriptenRequest(\n            url=url,\n            method=method,\n            timeout=self.timeout if self.timeout else 0,\n            decode_content=decode_content,\n        )\n        request.set_body(body)\n        if headers:\n            for k, v in headers.items():\n                request.set_header(k, v)\n        self._response = None\n        try:\n            if not preload_content:\n                self._response = send_streaming_request(request)\n            if self._response is None:\n                self._response = send_request(request)\n        except _TimeoutError as e:\n            raise TimeoutError(e.message) from e\n        except _RequestError as e:\n            raise HTTPException(e.message) from e\n\n    def getresponse(self) -> BaseHTTPResponse:\n        if self._response is not None:\n            return EmscriptenHttpResponseWrapper(\n                internal_response=self._response,\n                url=self._response.request.url,\n                connection=self,\n            )\n        else:\n            raise ResponseNotReady()\n\n    def close(self) -> None:\n        self._closed = True\n        self._response = None\n\n    @property\n    def is_closed(self) -> bool:\n        \"\"\"Whether the connection either is brand new or has been previously closed.\n        If this property is True then both ``is_connected`` and ``has_connected_to_proxy``\n        properties must be False.\n        \"\"\"\n        return self._closed\n\n    @property\n    def is_connected(self) -> bool:\n        \"\"\"Whether the connection is actively connected to any origin (proxy or target)\"\"\"\n        return True\n\n    @property\n    def has_connected_to_proxy(self) -> bool:\n        \"\"\"Whether the connection has successfully connected to its proxy.\n        This returns False if no proxy is in use. Used to determine whether\n        errors are coming from the proxy layer or from tunnelling to the target origin.\n        \"\"\"\n        return False\n\n\nclass EmscriptenHTTPSConnection(EmscriptenHTTPConnection):\n    default_port = port_by_scheme[\"https\"]\n    # all this is basically ignored, as browser handles https\n    cert_reqs: int | str | None = None\n    ca_certs: str | None = None\n    ca_cert_dir: str | None = None\n    ca_cert_data: None | str | bytes = None\n    cert_file: str | None\n    key_file: str | None\n    key_password: str | None\n    ssl_context: typing.Any | None\n    ssl_version: int | str | None = None\n    ssl_minimum_version: int | None = None\n    ssl_maximum_version: int | None = None\n    assert_hostname: None | str | typing.Literal[False]\n    assert_fingerprint: str | None = None\n\n    def __init__(\n        self,\n        host: str,\n        port: int = 0,\n        *,\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 16384,\n        socket_options: None\n        | _TYPE_SOCKET_OPTIONS = HTTPConnection.default_socket_options,\n        proxy: Url | None = None,\n        proxy_config: ProxyConfig | None = None,\n        cert_reqs: int | str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        server_hostname: str | None = None,\n        ssl_context: typing.Any | None = None,\n        ca_certs: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n        ssl_minimum_version: int | None = None,\n        ssl_maximum_version: int | None = None,\n        ssl_version: int | str | None = None,  # Deprecated\n        cert_file: str | None = None,\n        key_file: str | None = None,\n        key_password: str | None = None,\n    ) -> None:\n        super().__init__(\n            host,\n            port=port,\n            timeout=timeout,\n            source_address=source_address,\n            blocksize=blocksize,\n            socket_options=socket_options,\n            proxy=proxy,\n            proxy_config=proxy_config,\n        )\n        self.scheme = \"https\"\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.key_password = key_password\n        self.ssl_context = ssl_context\n        self.server_hostname = server_hostname\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ssl_version = ssl_version\n        self.ssl_minimum_version = ssl_minimum_version\n        self.ssl_maximum_version = ssl_maximum_version\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n        self.cert_reqs = None\n\n        # The browser will automatically verify all requests.\n        # We have no control over that setting.\n        self.is_verified = True\n\n    def set_cert(\n        self,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        cert_reqs: int | str | None = None,\n        key_password: str | None = None,\n        ca_certs: str | None = None,\n        assert_hostname: None | str | typing.Literal[False] = None,\n        assert_fingerprint: str | None = None,\n        ca_cert_dir: str | None = None,\n        ca_cert_data: None | str | bytes = None,\n    ) -> None:\n        pass\n\n\n# verify that this class implements BaseHTTP(s) connection correctly\nif typing.TYPE_CHECKING:\n    _supports_http_protocol: BaseHTTPConnection = EmscriptenHTTPConnection(\"\", 0)\n    _supports_https_protocol: BaseHTTPSConnection = EmscriptenHTTPSConnection(\"\", 0)\n", "src/urllib3/contrib/emscripten/request.py": "from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nfrom ..._base_connection import _TYPE_BODY\n\n\n@dataclass\nclass EmscriptenRequest:\n    method: str\n    url: str\n    params: dict[str, str] | None = None\n    body: _TYPE_BODY | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    timeout: float = 0\n    decode_content: bool = True\n\n    def set_header(self, name: str, value: str) -> None:\n        self.headers[name.capitalize()] = value\n\n    def set_body(self, body: _TYPE_BODY | None) -> None:\n        self.body = body\n", "src/urllib3/contrib/emscripten/__init__.py": "from __future__ import annotations\n\nimport urllib3.connection\n\nfrom ...connectionpool import HTTPConnectionPool, HTTPSConnectionPool\nfrom .connection import EmscriptenHTTPConnection, EmscriptenHTTPSConnection\n\n\ndef inject_into_urllib3() -> None:\n    # override connection classes to use emscripten specific classes\n    # n.b. mypy complains about the overriding of classes below\n    # if it isn't ignored\n    HTTPConnectionPool.ConnectionCls = EmscriptenHTTPConnection\n    HTTPSConnectionPool.ConnectionCls = EmscriptenHTTPSConnection\n    urllib3.connection.HTTPConnection = EmscriptenHTTPConnection  # type: ignore[misc,assignment]\n    urllib3.connection.HTTPSConnection = EmscriptenHTTPSConnection  # type: ignore[misc,assignment]\n", "src/urllib3/util/response.py": "from __future__ import annotations\n\nimport http.client as httplib\nfrom email.errors import MultipartInvariantViolationDefect, StartBoundaryNotFoundDefect\n\nfrom ..exceptions import HeaderParsingError\n\n\ndef is_fp_closed(obj: object) -> bool:\n    \"\"\"\n    Checks whether a given file-like object is closed.\n\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()  # type: ignore[no-any-return, attr-defined]\n    except AttributeError:\n        pass\n\n    try:\n        # Check via the official file-like-object way.\n        return obj.closed  # type: ignore[no-any-return, attr-defined]\n    except AttributeError:\n        pass\n\n    try:\n        # Check if the object is a container for another file-like object that\n        # gets released on exhaustion (e.g. HTTPResponse).\n        return obj.fp is None  # type: ignore[attr-defined]\n    except AttributeError:\n        pass\n\n    raise ValueError(\"Unable to determine whether fp is closed.\")\n\n\ndef assert_header_parsing(headers: httplib.HTTPMessage) -> None:\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n\n    Only works on Python 3.\n\n    :param http.client.HTTPMessage headers: Headers to verify.\n\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n\n    # This will fail silently if we pass in the wrong kind of parameter.\n    # To make debugging easier add an explicit check.\n    if not isinstance(headers, httplib.HTTPMessage):\n        raise TypeError(f\"expected httplib.Message, got {type(headers)}.\")\n\n    unparsed_data = None\n\n    # get_payload is actually email.message.Message.get_payload;\n    # we're only interested in the result if it's not a multipart message\n    if not headers.is_multipart():\n        payload = headers.get_payload()\n\n        if isinstance(payload, (bytes, str)):\n            unparsed_data = payload\n\n    # httplib is assuming a response body is available\n    # when parsing headers even when httplib only sends\n    # header data to parse_headers() This results in\n    # defects on multipart responses in particular.\n    # See: https://github.com/urllib3/urllib3/issues/800\n\n    # So we ignore the following defects:\n    # - StartBoundaryNotFoundDefect:\n    #     The claimed start boundary was never found.\n    # - MultipartInvariantViolationDefect:\n    #     A message claimed to be a multipart but no subparts were found.\n    defects = [\n        defect\n        for defect in headers.defects\n        if not isinstance(\n            defect, (StartBoundaryNotFoundDefect, MultipartInvariantViolationDefect)\n        )\n    ]\n\n    if defects or unparsed_data:\n        raise HeaderParsingError(defects=defects, unparsed_data=unparsed_data)\n\n\ndef is_response_to_head(response: httplib.HTTPResponse) -> bool:\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method_str = response._method  # type: str  # type: ignore[attr-defined]\n    return method_str.upper() == \"HEAD\"\n", "src/urllib3/util/connection.py": "from __future__ import annotations\n\nimport socket\nimport typing\n\nfrom ..exceptions import LocationParseError\nfrom .timeout import _DEFAULT_TIMEOUT, _TYPE_TIMEOUT\n\n_TYPE_SOCKET_OPTIONS = typing.Sequence[typing.Tuple[int, int, typing.Union[int, bytes]]]\n\nif typing.TYPE_CHECKING:\n    from .._base_connection import BaseHTTPConnection\n\n\ndef is_connection_dropped(conn: BaseHTTPConnection) -> bool:  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n    :param conn: :class:`urllib3.connection.HTTPConnection` object.\n    \"\"\"\n    return not conn.is_connected\n\n\n# This function is copied from socket.py in the Python 2.7 standard\n# library test suite. Added to its signature is only `socket_options`.\n# One additional modification is that we avoid binding to IPv6 servers\n# discovered in DNS if the system doesn't have IPv6 functionality.\ndef create_connection(\n    address: tuple[str, int],\n    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    source_address: tuple[str, int] | None = None,\n    socket_options: _TYPE_SOCKET_OPTIONS | None = None,\n) -> socket.socket:\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`socket.getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n    \"\"\"\n\n    host, port = address\n    if host.startswith(\"[\"):\n        host = host.strip(\"[]\")\n    err = None\n\n    # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n    # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n    # The original create_connection function always returns all records.\n    family = allowed_gai_family()\n\n    try:\n        host.encode(\"idna\")\n    except UnicodeError:\n        raise LocationParseError(f\"'{host}', label empty or too long\") from None\n\n    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n\n            # If provided, set socket level options before connecting.\n            _set_socket_options(sock, socket_options)\n\n            if timeout is not _DEFAULT_TIMEOUT:\n                sock.settimeout(timeout)\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            # Break explicitly a reference cycle\n            err = None\n            return sock\n\n        except OSError as _:\n            err = _\n            if sock is not None:\n                sock.close()\n\n    if err is not None:\n        try:\n            raise err\n        finally:\n            # Break explicitly a reference cycle\n            err = None\n    else:\n        raise OSError(\"getaddrinfo returns an empty list\")\n\n\ndef _set_socket_options(\n    sock: socket.socket, options: _TYPE_SOCKET_OPTIONS | None\n) -> None:\n    if options is None:\n        return\n\n    for opt in options:\n        sock.setsockopt(*opt)\n\n\ndef allowed_gai_family() -> socket.AddressFamily:\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\n\n\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        # has_ipv6 returns true if cPython was compiled with IPv6 support.\n        # It does not tell us if the system has IPv6 support enabled. To\n        # determine that we must bind to an IPv6 address.\n        # https://github.com/urllib3/urllib3/pull/611\n        # https://bugs.python.org/issue658327\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = True\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6\n\n\nHAS_IPV6 = _has_ipv6(\"::1\")\n", "src/urllib3/util/retry.py": "from __future__ import annotations\n\nimport email\nimport logging\nimport random\nimport re\nimport time\nimport typing\nfrom itertools import takewhile\nfrom types import TracebackType\n\nfrom ..exceptions import (\n    ConnectTimeoutError,\n    InvalidHeader,\n    MaxRetryError,\n    ProtocolError,\n    ProxyError,\n    ReadTimeoutError,\n    ResponseError,\n)\nfrom .util import reraise\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from ..connectionpool import ConnectionPool\n    from ..response import BaseHTTPResponse\n\nlog = logging.getLogger(__name__)\n\n\n# Data structure for representing the metadata of requests that result in a retry.\nclass RequestHistory(typing.NamedTuple):\n    method: str | None\n    url: str | None\n    error: Exception | None\n    status: int | None\n    redirect_location: str | None\n\n\nclass Retry:\n    \"\"\"Retry configuration.\n\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n\n    Retries can be defined as a default for a pool:\n\n    .. code-block:: python\n\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request(\"GET\", \"https://example.com/\")\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n        response = http.request(\"GET\", \"https://example.com/\", retries=Retry(10))\n\n    Retries can be disabled by passing ``False``:\n\n    .. code-block:: python\n\n        response = http.request(\"GET\", \"https://example.com/\", retries=False)\n\n    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\n    retries are disabled, in which case the causing exception will be raised.\n\n    :param int total:\n        Total number of retries to allow. Takes precedence over other counts.\n\n        Set to ``None`` to remove this constraint and fall back on other\n        counts.\n\n        Set to ``0`` to fail on the first retry.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int connect:\n        How many connection-related errors to retry on.\n\n        These are errors raised before the request is sent to the remote server,\n        which we assume has not triggered the server to process the request.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int read:\n        How many times to retry on read errors.\n\n        These errors are raised after the request was sent to the server, so the\n        request may have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int redirect:\n        How many redirects to perform. Limit this to avoid infinite redirect\n        loops.\n\n        A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n        308.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int status:\n        How many times to retry on bad status codes.\n\n        These are retries made on responses, where status code matches\n        ``status_forcelist``.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int other:\n        How many times to retry on other errors.\n\n        Other errors are errors that are not connect, read, redirect or status errors.\n        These errors might be raised after the request was sent to the server, so the\n        request might have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        If ``total`` is not set, it's a good idea to set this to 0 to account\n        for unexpected edge cases and avoid infinite retry loops.\n\n    :param Collection allowed_methods:\n        Set of uppercased HTTP method verbs that we should retry on.\n\n        By default, we only retry on methods which are considered to be\n        idempotent (multiple requests with the same parameters end with the\n        same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n        Set to a ``None`` value to retry on any verb.\n\n    :param Collection status_forcelist:\n        A set of integer HTTP status codes that we should force a retry on.\n        A retry is initiated if the request method is in ``allowed_methods``\n        and the response status code is in ``status_forcelist``.\n\n        By default, this is disabled with ``None``.\n\n    :param float backoff_factor:\n        A backoff factor to apply between attempts after the second try\n        (most errors are resolved immediately by a second try without a\n        delay). urllib3 will sleep for::\n\n            {backoff factor} * (2 ** ({number of previous retries}))\n\n        seconds. If `backoff_jitter` is non-zero, this sleep is extended by::\n\n            random.uniform(0, {backoff jitter})\n\n        seconds. For example, if the backoff_factor is 0.1, then :func:`Retry.sleep` will\n        sleep for [0.0s, 0.2s, 0.4s, 0.8s, ...] between retries. No backoff will ever\n        be longer than `backoff_max`.\n\n        By default, backoff is disabled (factor set to 0).\n\n    :param bool raise_on_redirect: Whether, if the number of redirects is\n        exhausted, to raise a MaxRetryError, or to return a response with a\n        response code in the 3xx range.\n\n    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n        whether we should raise an exception, or return a response,\n        if status falls in ``status_forcelist`` range and retries have\n        been exhausted.\n\n    :param tuple history: The history of the request encountered during\n        each call to :meth:`~Retry.increment`. The list is in the order\n        the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n    :param bool respect_retry_after_header:\n        Whether to respect Retry-After header on status codes defined as\n        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n    :param Collection remove_headers_on_redirect:\n        Sequence of headers to remove from the request when a response\n        indicating a redirect is returned before firing off the redirected\n        request.\n    \"\"\"\n\n    #: Default methods to be used for ``allowed_methods``\n    DEFAULT_ALLOWED_METHODS = frozenset(\n        [\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"]\n    )\n\n    #: Default status codes to be used for ``status_forcelist``\n    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])\n\n    #: Default headers to be used for ``remove_headers_on_redirect``\n    DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset(\n        [\"Cookie\", \"Authorization\", \"Proxy-Authorization\"]\n    )\n\n    #: Default maximum backoff time.\n    DEFAULT_BACKOFF_MAX = 120\n\n    # Backward compatibility; assigned outside of the class.\n    DEFAULT: typing.ClassVar[Retry]\n\n    def __init__(\n        self,\n        total: bool | int | None = 10,\n        connect: int | None = None,\n        read: int | None = None,\n        redirect: bool | int | None = None,\n        status: int | None = None,\n        other: int | None = None,\n        allowed_methods: typing.Collection[str] | None = DEFAULT_ALLOWED_METHODS,\n        status_forcelist: typing.Collection[int] | None = None,\n        backoff_factor: float = 0,\n        backoff_max: float = DEFAULT_BACKOFF_MAX,\n        raise_on_redirect: bool = True,\n        raise_on_status: bool = True,\n        history: tuple[RequestHistory, ...] | None = None,\n        respect_retry_after_header: bool = True,\n        remove_headers_on_redirect: typing.Collection[\n            str\n        ] = DEFAULT_REMOVE_HEADERS_ON_REDIRECT,\n        backoff_jitter: float = 0.0,\n    ) -> None:\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.status = status\n        self.other = other\n\n        if redirect is False or total is False:\n            redirect = 0\n            raise_on_redirect = False\n\n        self.redirect = redirect\n        self.status_forcelist = status_forcelist or set()\n        self.allowed_methods = allowed_methods\n        self.backoff_factor = backoff_factor\n        self.backoff_max = backoff_max\n        self.raise_on_redirect = raise_on_redirect\n        self.raise_on_status = raise_on_status\n        self.history = history or ()\n        self.respect_retry_after_header = respect_retry_after_header\n        self.remove_headers_on_redirect = frozenset(\n            h.lower() for h in remove_headers_on_redirect\n        )\n        self.backoff_jitter = backoff_jitter\n\n    def new(self, **kw: typing.Any) -> Self:\n        params = dict(\n            total=self.total,\n            connect=self.connect,\n            read=self.read,\n            redirect=self.redirect,\n            status=self.status,\n            other=self.other,\n            allowed_methods=self.allowed_methods,\n            status_forcelist=self.status_forcelist,\n            backoff_factor=self.backoff_factor,\n            backoff_max=self.backoff_max,\n            raise_on_redirect=self.raise_on_redirect,\n            raise_on_status=self.raise_on_status,\n            history=self.history,\n            remove_headers_on_redirect=self.remove_headers_on_redirect,\n            respect_retry_after_header=self.respect_retry_after_header,\n            backoff_jitter=self.backoff_jitter,\n        )\n\n        params.update(kw)\n        return type(self)(**params)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_int(\n        cls,\n        retries: Retry | bool | int | None,\n        redirect: bool | int | None = True,\n        default: Retry | bool | int | None = None,\n    ) -> Retry:\n        \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -> %r\", retries, new_retries)\n        return new_retries\n\n    def get_backoff_time(self) -> float:\n        \"\"\"Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        # We want to consider only the last consecutive errors sequence (Ignore redirects).\n        consecutive_errors_len = len(\n            list(\n                takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n            )\n        )\n        if consecutive_errors_len <= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n        if self.backoff_jitter != 0.0:\n            backoff_value += random.random() * self.backoff_jitter\n        return float(max(0, min(self.backoff_max, backoff_value)))\n\n    def parse_retry_after(self, retry_after: str) -> float:\n        seconds: float\n        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4\n        if re.match(r\"^\\s*[0-9]+\\s*$\", retry_after):\n            seconds = int(retry_after)\n        else:\n            retry_date_tuple = email.utils.parsedate_tz(retry_after)\n            if retry_date_tuple is None:\n                raise InvalidHeader(f\"Invalid Retry-After header: {retry_after}\")\n\n            retry_date = email.utils.mktime_tz(retry_date_tuple)\n            seconds = retry_date - time.time()\n\n        seconds = max(seconds, 0)\n\n        return seconds\n\n    def get_retry_after(self, response: BaseHTTPResponse) -> float | None:\n        \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n        retry_after = response.headers.get(\"Retry-After\")\n\n        if retry_after is None:\n            return None\n\n        return self.parse_retry_after(retry_after)\n\n    def sleep_for_retry(self, response: BaseHTTPResponse) -> bool:\n        retry_after = self.get_retry_after(response)\n        if retry_after:\n            time.sleep(retry_after)\n            return True\n\n        return False\n\n    def _sleep_backoff(self) -> None:\n        backoff = self.get_backoff_time()\n        if backoff <= 0:\n            return\n        time.sleep(backoff)\n\n    def sleep(self, response: BaseHTTPResponse | None = None) -> None:\n        \"\"\"Sleep between retry attempts.\n\n        This method will respect a server's ``Retry-After`` response header\n        and sleep the duration of the time requested. If that is not present, it\n        will use an exponential backoff. By default, the backoff factor is 0 and\n        this method will return immediately.\n        \"\"\"\n\n        if self.respect_retry_after_header and response:\n            slept = self.sleep_for_retry(response)\n            if slept:\n                return\n\n        self._sleep_backoff()\n\n    def _is_connection_error(self, err: Exception) -> bool:\n        \"\"\"Errors when we're fairly sure that the server did not receive the\n        request, so it should be safe to retry.\n        \"\"\"\n        if isinstance(err, ProxyError):\n            err = err.original_error\n        return isinstance(err, ConnectTimeoutError)\n\n    def _is_read_error(self, err: Exception) -> bool:\n        \"\"\"Errors that occur after the request has been started, so we should\n        assume that the server began processing it.\n        \"\"\"\n        return isinstance(err, (ReadTimeoutError, ProtocolError))\n\n    def _is_method_retryable(self, method: str) -> bool:\n        \"\"\"Checks if a given HTTP method should be retried upon, depending if\n        it is included in the allowed_methods\n        \"\"\"\n        if self.allowed_methods and method.upper() not in self.allowed_methods:\n            return False\n        return True\n\n    def is_retry(\n        self, method: str, status_code: int, has_retry_after: bool = False\n    ) -> bool:\n        \"\"\"Is this method/status code retryable? (Based on allowlists and control\n        variables such as the number of total retries to allow, whether to\n        respect the Retry-After header, whether this header is present, and\n        whether the returned status code is on the list of status codes to\n        be retried upon on the presence of the aforementioned header)\n        \"\"\"\n        if not self._is_method_retryable(method):\n            return False\n\n        if self.status_forcelist and status_code in self.status_forcelist:\n            return True\n\n        return bool(\n            self.total\n            and self.respect_retry_after_header\n            and has_retry_after\n            and (status_code in self.RETRY_AFTER_STATUS_CODES)\n        )\n\n    def is_exhausted(self) -> bool:\n        \"\"\"Are we out of retries?\"\"\"\n        retry_counts = [\n            x\n            for x in (\n                self.total,\n                self.connect,\n                self.read,\n                self.redirect,\n                self.status,\n                self.other,\n            )\n            if x\n        ]\n        if not retry_counts:\n            return False\n\n        return min(retry_counts) < 0\n\n    def increment(\n        self,\n        method: str | None = None,\n        url: str | None = None,\n        response: BaseHTTPResponse | None = None,\n        error: Exception | None = None,\n        _pool: ConnectionPool | None = None,\n        _stacktrace: TracebackType | None = None,\n    ) -> Self:\n        \"\"\"Return a new Retry object with incremented retry counters.\n\n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n\n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise reraise(type(error), error, _stacktrace)\n\n        total = self.total\n        if total is not None:\n            total -= 1\n\n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n\n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n\n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or method is None or not self._is_method_retryable(method):\n                raise reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n\n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n\n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            response_redirect_location = response.get_redirect_location()\n            if response_redirect_location:\n                redirect_location = response_redirect_location\n            status = response.status\n\n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n\n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n\n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n\n        if new_retry.is_exhausted():\n            reason = error or ResponseError(cause)\n            raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\n\n        log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n        return new_retry\n\n    def __repr__(self) -> str:\n        return (\n            f\"{type(self).__name__}(total={self.total}, connect={self.connect}, \"\n            f\"read={self.read}, redirect={self.redirect}, status={self.status})\"\n        )\n\n\n# For backwards compatibility (equivalent to pre-v1.9):\nRetry.DEFAULT = Retry(3)\n", "src/urllib3/util/wait.py": "from __future__ import annotations\n\nimport select\nimport socket\nfrom functools import partial\n\n__all__ = [\"wait_for_read\", \"wait_for_write\"]\n\n\n# How should we wait on sockets?\n#\n# There are two types of APIs you can use for waiting on sockets: the fancy\n# modern stateful APIs like epoll/kqueue, and the older stateless APIs like\n# select/poll. The stateful APIs are more efficient when you have a lots of\n# sockets to keep track of, because you can set them up once and then use them\n# lots of times. But we only ever want to wait on a single socket at a time\n# and don't want to keep track of state, so the stateless APIs are actually\n# more efficient. So we want to use select() or poll().\n#\n# Now, how do we choose between select() and poll()? On traditional Unixes,\n# select() has a strange calling convention that makes it slow, or fail\n# altogether, for high-numbered file descriptors. The point of poll() is to fix\n# that, so on Unixes, we prefer poll().\n#\n# On Windows, there is no poll() (or at least Python doesn't provide a wrapper\n# for it), but that's OK, because on Windows, select() doesn't have this\n# strange calling convention; plain select() works fine.\n#\n# So: on Windows we use select(), and everywhere else we use poll(). We also\n# fall back to select() in case poll() is somehow broken or missing.\n\n\ndef select_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    rcheck = []\n    wcheck = []\n    if read:\n        rcheck.append(sock)\n    if write:\n        wcheck.append(sock)\n    # When doing a non-blocking connect, most systems signal success by\n    # marking the socket writable. Windows, though, signals success by marked\n    # it as \"exceptional\". We paper over the difference by checking the write\n    # sockets for both conditions. (The stdlib selectors module does the same\n    # thing.)\n    fn = partial(select.select, rcheck, wcheck, wcheck)\n    rready, wready, xready = fn(timeout)\n    return bool(rready or wready or xready)\n\n\ndef poll_wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    if not read and not write:\n        raise RuntimeError(\"must specify at least one of read=True, write=True\")\n    mask = 0\n    if read:\n        mask |= select.POLLIN\n    if write:\n        mask |= select.POLLOUT\n    poll_obj = select.poll()\n    poll_obj.register(sock, mask)\n\n    # For some reason, poll() takes timeout in milliseconds\n    def do_poll(t: float | None) -> list[tuple[int, int]]:\n        if t is not None:\n            t *= 1000\n        return poll_obj.poll(t)\n\n    return bool(do_poll(timeout))\n\n\ndef _have_working_poll() -> bool:\n    # Apparently some systems have a select.poll that fails as soon as you try\n    # to use it, either due to strange configuration or broken monkeypatching\n    # from libraries like eventlet/greenlet.\n    try:\n        poll_obj = select.poll()\n        poll_obj.poll(0)\n    except (AttributeError, OSError):\n        return False\n    else:\n        return True\n\n\ndef wait_for_socket(\n    sock: socket.socket,\n    read: bool = False,\n    write: bool = False,\n    timeout: float | None = None,\n) -> bool:\n    # We delay choosing which implementation to use until the first time we're\n    # called. We could do it at import time, but then we might make the wrong\n    # decision if someone goes wild with monkeypatching select.poll after\n    # we're imported.\n    global wait_for_socket\n    if _have_working_poll():\n        wait_for_socket = poll_wait_for_socket\n    elif hasattr(select, \"select\"):\n        wait_for_socket = select_wait_for_socket\n    return wait_for_socket(sock, read, write, timeout)\n\n\ndef wait_for_read(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\n\n\ndef wait_for_write(sock: socket.socket, timeout: float | None = None) -> bool:\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)\n", "src/urllib3/util/request.py": "from __future__ import annotations\n\nimport io\nimport typing\nfrom base64 import b64encode\nfrom enum import Enum\n\nfrom ..exceptions import UnrewindableBodyError\nfrom .util import to_bytes\n\nif typing.TYPE_CHECKING:\n    from typing import Final\n\n# Pass as a value within ``headers`` to skip\n# emitting some HTTP headers that are added automatically.\n# The only headers that are supported are ``Accept-Encoding``,\n# ``Host``, and ``User-Agent``.\nSKIP_HEADER = \"@@@SKIP_HEADER@@@\"\nSKIPPABLE_HEADERS = frozenset([\"accept-encoding\", \"host\", \"user-agent\"])\n\nACCEPT_ENCODING = \"gzip,deflate\"\ntry:\n    try:\n        import brotlicffi as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\n    except ImportError:\n        import brotli as _unused_module_brotli  # type: ignore[import-not-found] # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",br\"\ntry:\n    import zstandard as _unused_module_zstd  # noqa: F401\nexcept ImportError:\n    pass\nelse:\n    ACCEPT_ENCODING += \",zstd\"\n\n\nclass _TYPE_FAILEDTELL(Enum):\n    token = 0\n\n\n_FAILEDTELL: Final[_TYPE_FAILEDTELL] = _TYPE_FAILEDTELL.token\n\n_TYPE_BODY_POSITION = typing.Union[int, _TYPE_FAILEDTELL]\n\n# When sending a request with these methods we aren't expecting\n# a body so don't need to set an explicit 'Content-Length: 0'\n# The reason we do this in the negative instead of tracking methods\n# which 'should' have a body is because unknown methods should be\n# treated as if they were 'POST' which *does* expect a body.\n_METHODS_NOT_EXPECTING_BODY = {\"GET\", \"HEAD\", \"DELETE\", \"TRACE\", \"OPTIONS\", \"CONNECT\"}\n\n\ndef make_headers(\n    keep_alive: bool | None = None,\n    accept_encoding: bool | list[str] | str | None = None,\n    user_agent: str | None = None,\n    basic_auth: str | None = None,\n    proxy_basic_auth: str | None = None,\n    disable_cache: bool | None = None,\n) -> dict[str, str]:\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.  If either the ``brotli`` or\n        ``brotlicffi`` package is installed 'gzip,deflate,br' is used instead.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    :param proxy_basic_auth:\n        Colon-separated username:password string for 'proxy-authorization: basic ...'\n        auth header.\n\n    :param disable_cache:\n        If ``True``, adds 'cache-control: no-cache' header.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        print(urllib3.util.make_headers(keep_alive=True, user_agent=\"Batman/1.0\"))\n        # {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        print(urllib3.util.make_headers(accept_encoding=True))\n        # {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers: dict[str, str] = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"accept-encoding\"] = accept_encoding\n\n    if user_agent:\n        headers[\"user-agent\"] = user_agent\n\n    if keep_alive:\n        headers[\"connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\n            \"authorization\"\n        ] = f\"Basic {b64encode(basic_auth.encode('latin-1')).decode()}\"\n\n    if proxy_basic_auth:\n        headers[\n            \"proxy-authorization\"\n        ] = f\"Basic {b64encode(proxy_basic_auth.encode('latin-1')).decode()}\"\n\n    if disable_cache:\n        headers[\"cache-control\"] = \"no-cache\"\n\n    return headers\n\n\ndef set_file_position(\n    body: typing.Any, pos: _TYPE_BODY_POSITION | None\n) -> _TYPE_BODY_POSITION | None:\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:\n        try:\n            pos = body.tell()\n        except OSError:\n            # This differentiates from None, allowing us to catch\n            # a failed `tell()` later when trying to rewind the body.\n            pos = _FAILEDTELL\n\n    return pos\n\n\ndef rewind_body(body: typing.IO[typing.AnyStr], body_pos: _TYPE_BODY_POSITION) -> None:\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n\n    :param body:\n        File-like object that supports seek.\n\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)\n    if body_seek is not None and isinstance(body_pos, int):\n        try:\n            body_seek(body_pos)\n        except OSError as e:\n            raise UnrewindableBodyError(\n                \"An error occurred when rewinding request body for redirect/retry.\"\n            ) from e\n    elif body_pos is _FAILEDTELL:\n        raise UnrewindableBodyError(\n            \"Unable to record file position for rewinding \"\n            \"request body during a redirect/retry.\"\n        )\n    else:\n        raise ValueError(\n            f\"body_pos must be of type integer, instead it was {type(body_pos)}.\"\n        )\n\n\nclass ChunksAndContentLength(typing.NamedTuple):\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\n\n\ndef body_to_chunks(\n    body: typing.Any | None, method: str, blocksize: int\n) -> ChunksAndContentLength:\n    \"\"\"Takes the HTTP request method, body, and blocksize and\n    transforms them into an iterable of chunks to pass to\n    socket.sendall() and an optional 'Content-Length' header.\n\n    A 'Content-Length' of 'None' indicates the length of the body\n    can't be determined so should use 'Transfer-Encoding: chunked'\n    for framing instead.\n    \"\"\"\n\n    chunks: typing.Iterable[bytes] | None\n    content_length: int | None\n\n    # No body, we need to make a recommendation on 'Content-Length'\n    # based on whether that request method is expected to have\n    # a body or not.\n    if body is None:\n        chunks = None\n        if method.upper() not in _METHODS_NOT_EXPECTING_BODY:\n            content_length = 0\n        else:\n            content_length = None\n\n    # Bytes or strings become bytes\n    elif isinstance(body, (str, bytes)):\n        chunks = (to_bytes(body),)\n        content_length = len(chunks[0])\n\n    # File-like object, TODO: use seek() and tell() for length?\n    elif hasattr(body, \"read\"):\n\n        def chunk_readable() -> typing.Iterable[bytes]:\n            nonlocal body, blocksize\n            encode = isinstance(body, io.TextIOBase)\n            while True:\n                datablock = body.read(blocksize)\n                if not datablock:\n                    break\n                if encode:\n                    datablock = datablock.encode(\"iso-8859-1\")\n                yield datablock\n\n        chunks = chunk_readable()\n        content_length = None\n\n    # Otherwise we need to start checking via duck-typing.\n    else:\n        try:\n            # Check if the body implements the buffer API.\n            mv = memoryview(body)\n        except TypeError:\n            try:\n                # Check if the body is an iterable\n                chunks = iter(body)\n                content_length = None\n            except TypeError:\n                raise TypeError(\n                    f\"'body' must be a bytes-like object, file-like \"\n                    f\"object, or iterable. Instead was {body!r}\"\n                ) from None\n        else:\n            # Since it implements the buffer API can be passed directly to socket.sendall()\n            chunks = (body,)\n            content_length = mv.nbytes\n\n    return ChunksAndContentLength(chunks=chunks, content_length=content_length)\n", "src/urllib3/util/proxy.py": "from __future__ import annotations\n\nimport typing\n\nfrom .url import Url\n\nif typing.TYPE_CHECKING:\n    from ..connection import ProxyConfig\n\n\ndef connection_requires_http_tunnel(\n    proxy_url: Url | None = None,\n    proxy_config: ProxyConfig | None = None,\n    destination_scheme: str | None = None,\n) -> bool:\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    # If we're not using a proxy, no way to use a tunnel.\n    if proxy_url is None:\n        return False\n\n    # HTTP destinations never require tunneling, we always forward.\n    if destination_scheme == \"http\":\n        return False\n\n    # Support for forwarding with HTTPS proxies and HTTPS destinations.\n    if (\n        proxy_url.scheme == \"https\"\n        and proxy_config\n        and proxy_config.use_forwarding_for_https\n    ):\n        return False\n\n    # Otherwise always use a tunnel.\n    return True\n", "src/urllib3/util/ssl_match_hostname.py": "\"\"\"The match_hostname() function from Python 3.5, essential when using SSL.\"\"\"\n\n# Note: This file is under the PSF license as the code comes from the python\n# stdlib.   http://docs.python.org/3/license.html\n# It is modified to remove commonName support.\n\nfrom __future__ import annotations\n\nimport ipaddress\nimport re\nimport typing\nfrom ipaddress import IPv4Address, IPv6Address\n\nif typing.TYPE_CHECKING:\n    from .ssl_ import _TYPE_PEER_CERT_RET_DICT\n\n__version__ = \"3.5.0.1\"\n\n\nclass CertificateError(ValueError):\n    pass\n\n\ndef _dnsname_match(\n    dn: typing.Any, hostname: str, max_wildcards: int = 1\n) -> typing.Match[str] | None | bool:\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"\n    pats = []\n    if not dn:\n        return False\n\n    # Ported from python3-syntax:\n    # leftmost, *remainder = dn.split(r'.')\n    parts = dn.split(r\".\")\n    leftmost = parts[0]\n    remainder = parts[1:]\n\n    wildcards = leftmost.count(\"*\")\n    if wildcards > max_wildcards:\n        # Issue #17980: avoid denials of service by refusing more\n        # than one wildcard per fragment.  A survey of established\n        # policy among SSL implementations showed it to be a\n        # reasonable choice.\n        raise CertificateError(\n            \"too many wildcards in certificate DNS name: \" + repr(dn)\n        )\n\n    # speed up common case w/o wildcards\n    if not wildcards:\n        return bool(dn.lower() == hostname.lower())\n\n    # RFC 6125, section 6.4.3, subitem 1.\n    # The client SHOULD NOT attempt to match a presented identifier in which\n    # the wildcard character comprises a label other than the left-most label.\n    if leftmost == \"*\":\n        # When '*' is a fragment by itself, it matches a non-empty dotless\n        # fragment.\n        pats.append(\"[^.]+\")\n    elif leftmost.startswith(\"xn--\") or hostname.startswith(\"xn--\"):\n        # RFC 6125, section 6.4.3, subitem 3.\n        # The client SHOULD NOT attempt to match a presented identifier\n        # where the wildcard character is embedded within an A-label or\n        # U-label of an internationalized domain name.\n        pats.append(re.escape(leftmost))\n    else:\n        # Otherwise, '*' matches any dotless string, e.g. www*\n        pats.append(re.escape(leftmost).replace(r\"\\*\", \"[^.]*\"))\n\n    # add the remaining fragments, ignore any wildcards\n    for frag in remainder:\n        pats.append(re.escape(frag))\n\n    pat = re.compile(r\"\\A\" + r\"\\.\".join(pats) + r\"\\Z\", re.IGNORECASE)\n    return pat.match(hostname)\n\n\ndef _ipaddress_match(ipname: str, host_ip: IPv4Address | IPv6Address) -> bool:\n    \"\"\"Exact matching of IP addresses.\n\n    RFC 9110 section 4.3.5: \"A reference identity of IP-ID contains the decoded\n    bytes of the IP address. An IP version 4 address is 4 octets, and an IP\n    version 6 address is 16 octets. [...] A reference identity of type IP-ID\n    matches if the address is identical to an iPAddress value of the\n    subjectAltName extension of the certificate.\"\n    \"\"\"\n    # OpenSSL may add a trailing newline to a subjectAltName's IP address\n    # Divergence from upstream: ipaddress can't handle byte str\n    ip = ipaddress.ip_address(ipname.rstrip())\n    return bool(ip.packed == host_ip.packed)\n\n\ndef match_hostname(\n    cert: _TYPE_PEER_CERT_RET_DICT | None,\n    hostname: str,\n    hostname_checks_common_name: bool = False,\n) -> None:\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError(\n            \"empty or no certificate, match_hostname needs a \"\n            \"SSL socket or SSL context with either \"\n            \"CERT_OPTIONAL or CERT_REQUIRED\"\n        )\n    try:\n        # Divergence from upstream: ipaddress can't handle byte str\n        #\n        # The ipaddress module shipped with Python < 3.9 does not support\n        # scoped IPv6 addresses so we unconditionally strip the Zone IDs for\n        # now. Once we drop support for Python 3.9 we can remove this branch.\n        if \"%\" in hostname:\n            host_ip = ipaddress.ip_address(hostname[: hostname.rfind(\"%\")])\n        else:\n            host_ip = ipaddress.ip_address(hostname)\n\n    except ValueError:\n        # Not an IP address (common case)\n        host_ip = None\n    dnsnames = []\n    san: tuple[tuple[str, str], ...] = cert.get(\"subjectAltName\", ())\n    key: str\n    value: str\n    for key, value in san:\n        if key == \"DNS\":\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == \"IP Address\":\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n\n    # We only check 'commonName' if it's enabled and we're not verifying\n    # an IP address. IP addresses aren't valid within 'commonName'.\n    if hostname_checks_common_name and host_ip is None and not dnsnames:\n        for sub in cert.get(\"subject\", ()):\n            for key, value in sub:\n                if key == \"commonName\":\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n\n    if len(dnsnames) > 1:\n        raise CertificateError(\n            \"hostname %r \"\n            \"doesn't match either of %s\" % (hostname, \", \".join(map(repr, dnsnames)))\n        )\n    elif len(dnsnames) == 1:\n        raise CertificateError(f\"hostname {hostname!r} doesn't match {dnsnames[0]!r}\")\n    else:\n        raise CertificateError(\"no appropriate subjectAltName fields were found\")\n", "src/urllib3/util/util.py": "from __future__ import annotations\n\nimport typing\nfrom types import TracebackType\n\n\ndef to_bytes(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> bytes:\n    if isinstance(x, bytes):\n        return x\n    elif not isinstance(x, str):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.encode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.encode()\n\n\ndef to_str(\n    x: str | bytes, encoding: str | None = None, errors: str | None = None\n) -> str:\n    if isinstance(x, str):\n        return x\n    elif not isinstance(x, bytes):\n        raise TypeError(f\"not expecting type {type(x).__name__}\")\n    if encoding or errors:\n        return x.decode(encoding or \"utf-8\", errors=errors or \"strict\")\n    return x.decode()\n\n\ndef reraise(\n    tp: type[BaseException] | None,\n    value: BaseException,\n    tb: TracebackType | None = None,\n) -> typing.NoReturn:\n    try:\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value\n    finally:\n        value = None  # type: ignore[assignment]\n        tb = None\n", "src/urllib3/util/timeout.py": "from __future__ import annotations\n\nimport time\nimport typing\nfrom enum import Enum\nfrom socket import getdefaulttimeout\n\nfrom ..exceptions import TimeoutStateError\n\nif typing.TYPE_CHECKING:\n    from typing import Final\n\n\nclass _TYPE_DEFAULT(Enum):\n    # This value should never be passed to socket.settimeout() so for safety we use a -1.\n    # socket.settimout() raises a ValueError for negative values.\n    token = -1\n\n\n_DEFAULT_TIMEOUT: Final[_TYPE_DEFAULT] = _TYPE_DEFAULT.token\n\n_TYPE_TIMEOUT = typing.Optional[typing.Union[float, _TYPE_DEFAULT]]\n\n\nclass Timeout:\n    \"\"\"Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n        import urllib3\n\n        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n\n        http = urllib3.PoolManager(timeout=timeout)\n\n        resp = http.request(\"GET\", \"https://example.com/\")\n\n        print(resp.status)\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request(\"GET\", \"https://example.com/\", timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request(\"GET\", \"https://example.com/\", timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python's DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n    \"\"\"\n\n    #: A sentinel object representing the default timeout value\n    DEFAULT_TIMEOUT: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT\n\n    def __init__(\n        self,\n        total: _TYPE_TIMEOUT = None,\n        connect: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n        read: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\n    ) -> None:\n        self._connect = self._validate_timeout(connect, \"connect\")\n        self._read = self._validate_timeout(read, \"read\")\n        self.total = self._validate_timeout(total, \"total\")\n        self._start_connect: float | None = None\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}(connect={self._connect!r}, read={self._read!r}, total={self.total!r})\"\n\n    # __str__ provided for backwards compatibility\n    __str__ = __repr__\n\n    @staticmethod\n    def resolve_default_timeout(timeout: _TYPE_TIMEOUT) -> float | None:\n        return getdefaulttimeout() if timeout is _DEFAULT_TIMEOUT else timeout\n\n    @classmethod\n    def _validate_timeout(cls, value: _TYPE_TIMEOUT, name: str) -> _TYPE_TIMEOUT:\n        \"\"\"Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        \"\"\"\n        if value is None or value is _DEFAULT_TIMEOUT:\n            return value\n\n        if isinstance(value, bool):\n            raise ValueError(\n                \"Timeout cannot be a boolean value. It must \"\n                \"be an int, float or None.\"\n            )\n        try:\n            float(value)\n        except (TypeError, ValueError):\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            ) from None\n\n        try:\n            if value <= 0:\n                raise ValueError(\n                    \"Attempted to set %s timeout to %s, but the \"\n                    \"timeout cannot be set to a value less \"\n                    \"than or equal to 0.\" % (name, value)\n                )\n        except TypeError:\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            ) from None\n\n        return value\n\n    @classmethod\n    def from_float(cls, timeout: _TYPE_TIMEOUT) -> Timeout:\n        \"\"\"Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, :attr:`urllib3.util.Timeout.DEFAULT_TIMEOUT`, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        return Timeout(read=timeout, connect=timeout)\n\n    def clone(self) -> Timeout:\n        \"\"\"Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        # We can't use copy.deepcopy because that will also create a new object\n        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n        # detect the user default.\n        return Timeout(connect=self._connect, read=self._read, total=self.total)\n\n    def start_connect(self) -> float:\n        \"\"\"Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        \"\"\"\n        if self._start_connect is not None:\n            raise TimeoutStateError(\"Timeout timer has already been started.\")\n        self._start_connect = time.monotonic()\n        return self._start_connect\n\n    def get_connect_duration(self) -> float:\n        \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        \"\"\"\n        if self._start_connect is None:\n            raise TimeoutStateError(\n                \"Can't get connect duration for timer that has not started.\"\n            )\n        return time.monotonic() - self._start_connect\n\n    @property\n    def connect_timeout(self) -> _TYPE_TIMEOUT:\n        \"\"\"Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        \"\"\"\n        if self.total is None:\n            return self._connect\n\n        if self._connect is None or self._connect is _DEFAULT_TIMEOUT:\n            return self.total\n\n        return min(self._connect, self.total)  # type: ignore[type-var]\n\n    @property\n    def read_timeout(self) -> float | None:\n        \"\"\"Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        \"\"\"\n        if (\n            self.total is not None\n            and self.total is not _DEFAULT_TIMEOUT\n            and self._read is not None\n            and self._read is not _DEFAULT_TIMEOUT\n        ):\n            # In case the connect timeout has not yet been established.\n            if self._start_connect is None:\n                return self._read\n            return max(0, min(self.total - self.get_connect_duration(), self._read))\n        elif self.total is not None and self.total is not _DEFAULT_TIMEOUT:\n            return max(0, self.total - self.get_connect_duration())\n        else:\n            return self.resolve_default_timeout(self._read)\n", "src/urllib3/util/url.py": "from __future__ import annotations\n\nimport re\nimport typing\n\nfrom ..exceptions import LocationParseError\nfrom .util import to_str\n\n# We only want to normalize urls with an HTTP(S) scheme.\n# urllib3 infers URLs without a scheme (None) to be http.\n_NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\n_PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\n_SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\n_URI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n\n_IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\n_HEX_PAT = \"[0-9A-Fa-f]{1,4}\"\n_LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=_HEX_PAT, ipv4=_IPV4_PAT)\n_subs = {\"hex\": _HEX_PAT, \"ls32\": _LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s\",\n    # [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    \"(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s\",\n    # [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    \"(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s\",\n    # [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    \"(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s\",\n    # [ *6( h16 \":\" ) h16 ] \"::\"\n    \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",\n]\n\n_UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\-~\"\n_IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\n_ZONE_ID_PAT = \"(?:%25|%)(?:[\" + _UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\n_IPV6_ADDRZ_PAT = r\"\\[\" + _IPV6_PAT + r\"(?:\" + _ZONE_ID_PAT + r\")?\\]\"\n_REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\n_TARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n\n_IPV4_RE = re.compile(\"^\" + _IPV4_PAT + \"$\")\n_IPV6_RE = re.compile(\"^\" + _IPV6_PAT + \"$\")\n_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT + \"$\")\n_BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + _IPV6_ADDRZ_PAT[2:-2] + \"$\")\n_ZONE_ID_RE = re.compile(\"(\" + _ZONE_ID_PAT + r\")\\]$\")\n\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$\") % (\n    _REG_NAME_PAT,\n    _IPV4_PAT,\n    _IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n\n_UNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\n_SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\n_USERINFO_CHARS = _UNRESERVED_CHARS | _SUB_DELIM_CHARS | {\":\"}\n_PATH_CHARS = _USERINFO_CHARS | {\"@\", \"/\"}\n_QUERY_CHARS = _FRAGMENT_CHARS = _PATH_CHARS | {\"?\"}\n\n\nclass Url(\n    typing.NamedTuple(\n        \"Url\",\n        [\n            (\"scheme\", typing.Optional[str]),\n            (\"auth\", typing.Optional[str]),\n            (\"host\", typing.Optional[str]),\n            (\"port\", typing.Optional[int]),\n            (\"path\", typing.Optional[str]),\n            (\"query\", typing.Optional[str]),\n            (\"fragment\", typing.Optional[str]),\n        ],\n    )\n):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    def __new__(  # type: ignore[no-untyped-def]\n        cls,\n        scheme: str | None = None,\n        auth: str | None = None,\n        host: str | None = None,\n        port: int | None = None,\n        path: str | None = None,\n        query: str | None = None,\n        fragment: str | None = None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super().__new__(cls, scheme, auth, host, port, path, query, fragment)\n\n    @property\n    def hostname(self) -> str | None:\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self) -> str:\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def authority(self) -> str | None:\n        \"\"\"\n        Authority component as defined in RFC 3986 3.2.\n        This includes userinfo (auth), host and port.\n\n        i.e.\n            userinfo@host:port\n        \"\"\"\n        userinfo = self.auth\n        netloc = self.netloc\n        if netloc is None or userinfo is None:\n            return netloc\n        else:\n            return f\"{userinfo}@{netloc}\"\n\n    @property\n    def netloc(self) -> str | None:\n        \"\"\"\n        Network location including host and port.\n\n        If you need the equivalent of urllib.parse's ``netloc``,\n        use the ``authority`` property instead.\n        \"\"\"\n        if self.host is None:\n            return None\n        if self.port:\n            return f\"{self.host}:{self.port}\"\n        return self.host\n\n    @property\n    def url(self) -> str:\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example:\n\n        .. code-block:: python\n\n            import urllib3\n\n            U = urllib3.util.parse_url(\"https://google.com/mail/\")\n\n            print(U.url)\n            # \"https://google.com/mail/\"\n\n            print( urllib3.util.Url(\"https\", \"username:password\",\n                                    \"host.com\", 80, \"/path\", \"query\", \"fragment\"\n                                    ).url\n                )\n            # \"https://username:password@host.com:80/path?query#fragment\"\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = \"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + \"://\"\n        if auth is not None:\n            url += auth + \"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += \":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += \"?\" + query\n        if fragment is not None:\n            url += \"#\" + fragment\n\n        return url\n\n    def __str__(self) -> str:\n        return self.url\n\n\n@typing.overload\ndef _encode_invalid_chars(\n    component: str, allowed_chars: typing.Container[str]\n) -> str:  # Abstract\n    ...\n\n\n@typing.overload\ndef _encode_invalid_chars(\n    component: None, allowed_chars: typing.Container[str]\n) -> None:  # Abstract\n    ...\n\n\ndef _encode_invalid_chars(\n    component: str | None, allowed_chars: typing.Container[str]\n) -> str | None:\n    \"\"\"Percent-encodes a URI component without reapplying\n    onto an already percent-encoded component.\n    \"\"\"\n    if component is None:\n        return component\n\n    component = to_str(component)\n\n    # Normalize existing percent-encoded bytes.\n    # Try to see if the component we're encoding is already percent-encoded\n    # so we can skip all '%' characters but still encode all others.\n    component, percent_encodings = _PERCENT_RE.subn(\n        lambda match: match.group(0).upper(), component\n    )\n\n    uri_bytes = component.encode(\"utf-8\", \"surrogatepass\")\n    is_percent_encoded = percent_encodings == uri_bytes.count(b\"%\")\n    encoded_component = bytearray()\n\n    for i in range(0, len(uri_bytes)):\n        # Will return a single character bytestring\n        byte = uri_bytes[i : i + 1]\n        byte_ord = ord(byte)\n        if (is_percent_encoded and byte == b\"%\") or (\n            byte_ord < 128 and byte.decode() in allowed_chars\n        ):\n            encoded_component += byte\n            continue\n        encoded_component.extend(b\"%\" + (hex(byte_ord)[2:].encode().zfill(2).upper()))\n\n    return encoded_component.decode()\n\n\ndef _remove_path_dot_segments(path: str) -> str:\n    # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code\n    segments = path.split(\"/\")  # Turn the path into a list of segments\n    output = []  # Initialize the variable to use to store output\n\n    for segment in segments:\n        # '.' is the current directory, so ignore it, it is superfluous\n        if segment == \".\":\n            continue\n        # Anything other than '..', should be appended to the output\n        if segment != \"..\":\n            output.append(segment)\n        # In this case segment == '..', if we can, we should pop the last\n        # element\n        elif output:\n            output.pop()\n\n    # If the path starts with '/' and the output is empty or the first string\n    # is non-empty\n    if path.startswith(\"/\") and (not output or output[0]):\n        output.insert(0, \"\")\n\n    # If the path starts with '/.' or '/..' ensure we add one more empty\n    # string to add a trailing '/'\n    if path.endswith((\"/.\", \"/..\")):\n        output.append(\"\")\n\n    return \"/\".join(output)\n\n\n@typing.overload\ndef _normalize_host(host: None, scheme: str | None) -> None:\n    ...\n\n\n@typing.overload\ndef _normalize_host(host: str, scheme: str | None) -> str:\n    ...\n\n\ndef _normalize_host(host: str | None, scheme: str | None) -> str | None:\n    if host:\n        if scheme in _NORMALIZABLE_SCHEMES:\n            is_ipv6 = _IPV6_ADDRZ_RE.match(host)\n            if is_ipv6:\n                # IPv6 hosts of the form 'a::b%zone' are encoded in a URL as\n                # such per RFC 6874: 'a::b%25zone'. Unquote the ZoneID\n                # separator as necessary to return a valid RFC 4007 scoped IP.\n                match = _ZONE_ID_RE.search(host)\n                if match:\n                    start, end = match.span(1)\n                    zone_id = host[start:end]\n\n                    if zone_id.startswith(\"%25\") and zone_id != \"%25\":\n                        zone_id = zone_id[3:]\n                    else:\n                        zone_id = zone_id[1:]\n                    zone_id = _encode_invalid_chars(zone_id, _UNRESERVED_CHARS)\n                    return f\"{host[:start].lower()}%{zone_id}{host[end:]}\"\n                else:\n                    return host.lower()\n            elif not _IPV4_RE.match(host):\n                return to_str(\n                    b\".\".join([_idna_encode(label) for label in host.split(\".\")]),\n                    \"ascii\",\n                )\n    return host\n\n\ndef _idna_encode(name: str) -> bytes:\n    if not name.isascii():\n        try:\n            import idna\n        except ImportError:\n            raise LocationParseError(\n                \"Unable to parse URL without the 'idna' module\"\n            ) from None\n\n        try:\n            return idna.encode(name.lower(), strict=True, std3_rules=True)\n        except idna.IDNAError:\n            raise LocationParseError(\n                f\"Name '{name}' is not a valid IDNA label\"\n            ) from None\n\n    return name.lower().encode(\"ascii\")\n\n\ndef _encode_target(target: str) -> str:\n    \"\"\"Percent-encodes a request target so that there are no invalid characters\n\n    Pre-condition for this function is that 'target' must start with '/'.\n    If that is the case then _TARGET_RE will always produce a match.\n    \"\"\"\n    match = _TARGET_RE.match(target)\n    if not match:  # Defensive:\n        raise LocationParseError(f\"{target!r} is not a valid request URI\")\n\n    path, query = match.groups()\n    encoded_target = _encode_invalid_chars(path, _PATH_CHARS)\n    if query is not None:\n        query = _encode_invalid_chars(query, _QUERY_CHARS)\n        encoded_target += \"?\" + query\n    return encoded_target\n\n\ndef parse_url(url: str) -> Url:\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 and RFC 6874 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urllib.parse`.\n\n    Example:\n\n    .. code-block:: python\n\n        import urllib3\n\n        print( urllib3.util.parse_url('http://google.com/mail/'))\n        # Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n\n        print( urllib3.util.parse_url('google.com:80'))\n        # Url(scheme=None, host='google.com', port=80, path=None, ...)\n\n        print( urllib3.util.parse_url('/foo?bar'))\n        # Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not _SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    scheme: str | None\n    authority: str | None\n    auth: str | None\n    host: str | None\n    port: str | None\n    port_int: int | None\n    path: str | None\n    query: str | None\n    fragment: str | None\n\n    try:\n        scheme, authority, path, query, fragment = _URI_RE.match(url).groups()  # type: ignore[union-attr]\n        normalize_uri = scheme is None or scheme.lower() in _NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, _, host_port = authority.rpartition(\"@\")\n            auth = auth or None\n            host, port = _HOST_PORT_RE.match(host_port).groups()  # type: ignore[union-attr]\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, _USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port_int = int(port)\n            if not (0 <= port_int <= 65535):\n                raise LocationParseError(url)\n        else:\n            port_int = None\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, _PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, _QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, _FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError) as e:\n        raise LocationParseError(source_url) from e\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    return Url(\n        scheme=scheme,\n        auth=auth,\n        host=host,\n        port=port_int,\n        path=path,\n        query=query,\n        fragment=fragment,\n    )\n", "src/urllib3/util/__init__.py": "# For backwards compatibility, provide imports that used to be here.\nfrom __future__ import annotations\n\nfrom .connection import is_connection_dropped\nfrom .request import SKIP_HEADER, SKIPPABLE_HEADERS, make_headers\nfrom .response import is_fp_closed\nfrom .retry import Retry\nfrom .ssl_ import (\n    ALPN_PROTOCOLS,\n    IS_PYOPENSSL,\n    SSLContext,\n    assert_fingerprint,\n    create_urllib3_context,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom .timeout import Timeout\nfrom .url import Url, parse_url\nfrom .wait import wait_for_read, wait_for_write\n\n__all__ = (\n    \"IS_PYOPENSSL\",\n    \"SSLContext\",\n    \"ALPN_PROTOCOLS\",\n    \"Retry\",\n    \"Timeout\",\n    \"Url\",\n    \"assert_fingerprint\",\n    \"create_urllib3_context\",\n    \"is_connection_dropped\",\n    \"is_fp_closed\",\n    \"parse_url\",\n    \"make_headers\",\n    \"resolve_cert_reqs\",\n    \"resolve_ssl_version\",\n    \"ssl_wrap_socket\",\n    \"wait_for_read\",\n    \"wait_for_write\",\n    \"SKIP_HEADER\",\n    \"SKIPPABLE_HEADERS\",\n)\n", "src/urllib3/util/ssltransport.py": "from __future__ import annotations\n\nimport io\nimport socket\nimport ssl\nimport typing\n\nfrom ..exceptions import ProxySchemeUnsupported\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from .ssl_ import _TYPE_PEER_CERT_RET, _TYPE_PEER_CERT_RET_DICT\n\n\n_WriteBuffer = typing.Union[bytearray, memoryview]\n_ReturnValue = typing.TypeVar(\"_ReturnValue\")\n\nSSL_BLOCKSIZE = 16384\n\n\nclass SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n\n    The class supports most of the socket API operations.\n    \"\"\"\n\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None:\n        \"\"\"\n        Raises a ProxySchemeUnsupported if the provided ssl_context can't be used\n        for TLS in TLS.\n\n        The only requirement is that the ssl_context provides the 'wrap_bio'\n        methods.\n        \"\"\"\n\n        if not hasattr(ssl_context, \"wrap_bio\"):\n            raise ProxySchemeUnsupported(\n                \"TLS in TLS requires SSLContext.wrap_bio() which isn't \"\n                \"available on non-native SSLContext\"\n            )\n\n    def __init__(\n        self,\n        socket: socket.socket,\n        ssl_context: ssl.SSLContext,\n        server_hostname: str | None = None,\n        suppress_ragged_eofs: bool = True,\n    ) -> None:\n        \"\"\"\n        Create an SSLTransport around socket using the provided ssl_context.\n        \"\"\"\n        self.incoming = ssl.MemoryBIO()\n        self.outgoing = ssl.MemoryBIO()\n\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self.socket = socket\n\n        self.sslobj = ssl_context.wrap_bio(\n            self.incoming, self.outgoing, server_hostname=server_hostname\n        )\n\n        # Perform initial handshake.\n        self._ssl_io_loop(self.sslobj.do_handshake)\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(self, *_: typing.Any) -> None:\n        self.close()\n\n    def fileno(self) -> int:\n        return self.socket.fileno()\n\n    def read(self, len: int = 1024, buffer: typing.Any | None = None) -> int | bytes:\n        return self._wrap_ssl_read(len, buffer)\n\n    def recv(self, buflen: int = 1024, flags: int = 0) -> int | bytes:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv\")\n        return self._wrap_ssl_read(buflen)\n\n    def recv_into(\n        self,\n        buffer: _WriteBuffer,\n        nbytes: int | None = None,\n        flags: int = 0,\n    ) -> None | int | bytes:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv_into\")\n        if nbytes is None:\n            nbytes = len(buffer)\n        return self.read(nbytes, buffer)\n\n    def sendall(self, data: bytes, flags: int = 0) -> None:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to sendall\")\n        count = 0\n        with memoryview(data) as view, view.cast(\"B\") as byte_view:\n            amount = len(byte_view)\n            while count < amount:\n                v = self.send(byte_view[count:])\n                count += v\n\n    def send(self, data: bytes, flags: int = 0) -> int:\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to send\")\n        return self._ssl_io_loop(self.sslobj.write, data)\n\n    def makefile(\n        self,\n        mode: str,\n        buffering: int | None = None,\n        *,\n        encoding: str | None = None,\n        errors: str | None = None,\n        newline: str | None = None,\n    ) -> typing.BinaryIO | typing.TextIO | socket.SocketIO:\n        \"\"\"\n        Python's httpclient uses makefile and buffered io when reading HTTP\n        messages and we need to support it.\n\n        This is unfortunately a copy and paste of socket.py makefile with small\n        changes to point to the socket directly.\n        \"\"\"\n        if not set(mode) <= {\"r\", \"w\", \"b\"}:\n            raise ValueError(f\"invalid mode {mode!r} (only r, w, b allowed)\")\n\n        writing = \"w\" in mode\n        reading = \"r\" in mode or not writing\n        assert reading or writing\n        binary = \"b\" in mode\n        rawmode = \"\"\n        if reading:\n            rawmode += \"r\"\n        if writing:\n            rawmode += \"w\"\n        raw = socket.SocketIO(self, rawmode)  # type: ignore[arg-type]\n        self.socket._io_refs += 1  # type: ignore[attr-defined]\n        if buffering is None:\n            buffering = -1\n        if buffering < 0:\n            buffering = io.DEFAULT_BUFFER_SIZE\n        if buffering == 0:\n            if not binary:\n                raise ValueError(\"unbuffered streams must be binary\")\n            return raw\n        buffer: typing.BinaryIO\n        if reading and writing:\n            buffer = io.BufferedRWPair(raw, raw, buffering)  # type: ignore[assignment]\n        elif reading:\n            buffer = io.BufferedReader(raw, buffering)\n        else:\n            assert writing\n            buffer = io.BufferedWriter(raw, buffering)\n        if binary:\n            return buffer\n        text = io.TextIOWrapper(buffer, encoding, errors, newline)\n        text.mode = mode  # type: ignore[misc]\n        return text\n\n    def unwrap(self) -> None:\n        self._ssl_io_loop(self.sslobj.unwrap)\n\n    def close(self) -> None:\n        self.socket.close()\n\n    @typing.overload\n    def getpeercert(\n        self, binary_form: typing.Literal[False] = ...\n    ) -> _TYPE_PEER_CERT_RET_DICT | None:\n        ...\n\n    @typing.overload\n    def getpeercert(self, binary_form: typing.Literal[True]) -> bytes | None:\n        ...\n\n    def getpeercert(self, binary_form: bool = False) -> _TYPE_PEER_CERT_RET:\n        return self.sslobj.getpeercert(binary_form)  # type: ignore[return-value]\n\n    def version(self) -> str | None:\n        return self.sslobj.version()\n\n    def cipher(self) -> tuple[str, str, int] | None:\n        return self.sslobj.cipher()\n\n    def selected_alpn_protocol(self) -> str | None:\n        return self.sslobj.selected_alpn_protocol()\n\n    def selected_npn_protocol(self) -> str | None:\n        return self.sslobj.selected_npn_protocol()\n\n    def shared_ciphers(self) -> list[tuple[str, str, int]] | None:\n        return self.sslobj.shared_ciphers()\n\n    def compression(self) -> str | None:\n        return self.sslobj.compression()\n\n    def settimeout(self, value: float | None) -> None:\n        self.socket.settimeout(value)\n\n    def gettimeout(self) -> float | None:\n        return self.socket.gettimeout()\n\n    def _decref_socketios(self) -> None:\n        self.socket._decref_socketios()  # type: ignore[attr-defined]\n\n    def _wrap_ssl_read(self, len: int, buffer: bytearray | None = None) -> int | bytes:\n        try:\n            return self._ssl_io_loop(self.sslobj.read, len, buffer)\n        except ssl.SSLError as e:\n            if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:\n                return 0  # eof, return 0.\n            else:\n                raise\n\n    # func is sslobj.do_handshake or sslobj.unwrap\n    @typing.overload\n    def _ssl_io_loop(self, func: typing.Callable[[], None]) -> None:\n        ...\n\n    # func is sslobj.write, arg1 is data\n    @typing.overload\n    def _ssl_io_loop(self, func: typing.Callable[[bytes], int], arg1: bytes) -> int:\n        ...\n\n    # func is sslobj.read, arg1 is len, arg2 is buffer\n    @typing.overload\n    def _ssl_io_loop(\n        self,\n        func: typing.Callable[[int, bytearray | None], bytes],\n        arg1: int,\n        arg2: bytearray | None,\n    ) -> bytes:\n        ...\n\n    def _ssl_io_loop(\n        self,\n        func: typing.Callable[..., _ReturnValue],\n        arg1: None | bytes | int = None,\n        arg2: bytearray | None = None,\n    ) -> _ReturnValue:\n        \"\"\"Performs an I/O loop between incoming/outgoing and the socket.\"\"\"\n        should_loop = True\n        ret = None\n\n        while should_loop:\n            errno = None\n            try:\n                if arg1 is None and arg2 is None:\n                    ret = func()\n                elif arg2 is None:\n                    ret = func(arg1)\n                else:\n                    ret = func(arg1, arg2)\n            except ssl.SSLError as e:\n                if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):\n                    # WANT_READ, and WANT_WRITE are expected, others are not.\n                    raise e\n                errno = e.errno\n\n            buf = self.outgoing.read()\n            self.socket.sendall(buf)\n\n            if errno is None:\n                should_loop = False\n            elif errno == ssl.SSL_ERROR_WANT_READ:\n                buf = self.socket.recv(SSL_BLOCKSIZE)\n                if buf:\n                    self.incoming.write(buf)\n                else:\n                    self.incoming.write_eof()\n        return typing.cast(_ReturnValue, ret)\n", "src/urllib3/util/ssl_.py": "from __future__ import annotations\n\nimport hmac\nimport os\nimport socket\nimport sys\nimport typing\nimport warnings\nfrom binascii import unhexlify\nfrom hashlib import md5, sha1, sha256\n\nfrom ..exceptions import ProxySchemeUnsupported, SSLError\nfrom .url import _BRACELESS_IPV6_ADDRZ_RE, _IPV4_RE\n\nSSLContext = None\nSSLTransport = None\nHAS_NEVER_CHECK_COMMON_NAME = False\nIS_PYOPENSSL = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n\n_TYPE_VERSION_INFO = typing.Tuple[int, int, int, str, int]\n\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {32: md5, 40: sha1, 64: sha256}\n\n\ndef _is_bpo_43522_fixed(\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    \"\"\"Return True for CPython 3.8.9+, 3.9.3+ or 3.10+ and PyPy 7.3.8+ where\n    setting SSLContext.hostname_checks_common_name to False works.\n\n    Outside of CPython and PyPy we don't know which implementations work\n    or not so we conservatively use our hostname matching as we know that works\n    on all implementations.\n\n    https://github.com/urllib3/urllib3/issues/2192#issuecomment-821832963\n    https://foss.heptapod.net/pypy/pypy/-/issues/3539\n    \"\"\"\n    if implementation_name == \"pypy\":\n        # https://foss.heptapod.net/pypy/pypy/-/issues/3129\n        return pypy_version_info >= (7, 3, 8)  # type: ignore[operator]\n    elif implementation_name == \"cpython\":\n        major_minor = version_info[:2]\n        micro = version_info[2]\n        return (\n            (major_minor == (3, 8) and micro >= 9)\n            or (major_minor == (3, 9) and micro >= 3)\n            or major_minor >= (3, 10)\n        )\n    else:  # Defensive:\n        return False\n\n\ndef _is_has_never_check_common_name_reliable(\n    openssl_version: str,\n    openssl_version_number: int,\n    implementation_name: str,\n    version_info: _TYPE_VERSION_INFO,\n    pypy_version_info: _TYPE_VERSION_INFO | None,\n) -> bool:\n    # As of May 2023, all released versions of LibreSSL fail to reject certificates with\n    # only common names, see https://github.com/urllib3/urllib3/pull/3024\n    is_openssl = openssl_version.startswith(\"OpenSSL \")\n    # Before fixing OpenSSL issue #14579, the SSL_new() API was not copying hostflags\n    # like X509_CHECK_FLAG_NEVER_CHECK_SUBJECT, which tripped up CPython.\n    # https://github.com/openssl/openssl/issues/14579\n    # This was released in OpenSSL 1.1.1l+ (>=0x101010cf)\n    is_openssl_issue_14579_fixed = openssl_version_number >= 0x101010CF\n\n    return is_openssl and (\n        is_openssl_issue_14579_fixed\n        or _is_bpo_43522_fixed(implementation_name, version_info, pypy_version_info)\n    )\n\n\nif typing.TYPE_CHECKING:\n    from ssl import VerifyMode\n    from typing import TypedDict\n\n    from .ssltransport import SSLTransport as SSLTransportType\n\n    class _TYPE_PEER_CERT_RET_DICT(TypedDict, total=False):\n        subjectAltName: tuple[tuple[str, str], ...]\n        subject: tuple[tuple[tuple[str, str], ...], ...]\n        serialNumber: str\n\n\n# Mapping from 'ssl.PROTOCOL_TLSX' to 'TLSVersion.X'\n_SSL_VERSION_TO_TLS_VERSION: dict[int, int] = {}\n\ntry:  # Do we have ssl at all?\n    import ssl\n    from ssl import (  # type: ignore[assignment]\n        CERT_REQUIRED,\n        HAS_NEVER_CHECK_COMMON_NAME,\n        OP_NO_COMPRESSION,\n        OP_NO_TICKET,\n        OPENSSL_VERSION,\n        OPENSSL_VERSION_NUMBER,\n        PROTOCOL_TLS,\n        PROTOCOL_TLS_CLIENT,\n        OP_NO_SSLv2,\n        OP_NO_SSLv3,\n        SSLContext,\n        TLSVersion,\n    )\n\n    PROTOCOL_SSLv23 = PROTOCOL_TLS\n\n    # Setting SSLContext.hostname_checks_common_name = False didn't work before CPython\n    # 3.8.9, 3.9.3, and 3.10 (but OK on PyPy) or OpenSSL 1.1.1l+\n    if HAS_NEVER_CHECK_COMMON_NAME and not _is_has_never_check_common_name_reliable(\n        OPENSSL_VERSION,\n        OPENSSL_VERSION_NUMBER,\n        sys.implementation.name,\n        sys.version_info,\n        sys.pypy_version_info if sys.implementation.name == \"pypy\" else None,  # type: ignore[attr-defined]\n    ):\n        HAS_NEVER_CHECK_COMMON_NAME = False\n\n    # Need to be careful here in case old TLS versions get\n    # removed in future 'ssl' module implementations.\n    for attr in (\"TLSv1\", \"TLSv1_1\", \"TLSv1_2\"):\n        try:\n            _SSL_VERSION_TO_TLS_VERSION[getattr(ssl, f\"PROTOCOL_{attr}\")] = getattr(\n                TLSVersion, attr\n            )\n        except AttributeError:  # Defensive:\n            continue\n\n    from .ssltransport import SSLTransport  # type: ignore[assignment]\nexcept ImportError:\n    OP_NO_COMPRESSION = 0x20000  # type: ignore[assignment]\n    OP_NO_TICKET = 0x4000  # type: ignore[assignment]\n    OP_NO_SSLv2 = 0x1000000  # type: ignore[assignment]\n    OP_NO_SSLv3 = 0x2000000  # type: ignore[assignment]\n    PROTOCOL_SSLv23 = PROTOCOL_TLS = 2  # type: ignore[assignment]\n    PROTOCOL_TLS_CLIENT = 16  # type: ignore[assignment]\n\n\n_TYPE_PEER_CERT_RET = typing.Union[\"_TYPE_PEER_CERT_RET_DICT\", bytes, None]\n\n\ndef assert_fingerprint(cert: bytes | None, fingerprint: str) -> None:\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    if cert is None:\n        raise SSLError(\"No certificate for the peer.\")\n\n    fingerprint = fingerprint.replace(\":\", \"\").lower()\n    digest_length = len(fingerprint)\n    hashfunc = HASHFUNC_MAP.get(digest_length)\n    if not hashfunc:\n        raise SSLError(f\"Fingerprint of invalid length: {fingerprint}\")\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not hmac.compare_digest(cert_digest, fingerprint_bytes):\n        raise SSLError(\n            f'Fingerprints did not match. Expected \"{fingerprint}\", got \"{cert_digest.hex()}\"'\n        )\n\n\ndef resolve_cert_reqs(candidate: None | int | str) -> VerifyMode:\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.\n    \"\"\"\n    if candidate is None:\n        return CERT_REQUIRED\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"CERT_\" + candidate)\n        return res  # type: ignore[no-any-return]\n\n    return candidate  # type: ignore[return-value]\n\n\ndef resolve_ssl_version(candidate: None | int | str) -> int:\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)\n        return typing.cast(int, res)\n\n    return candidate\n\n\ndef create_urllib3_context(\n    ssl_version: int | None = None,\n    cert_reqs: int | None = None,\n    options: int | None = None,\n    ciphers: str | None = None,\n    ssl_minimum_version: int | None = None,\n    ssl_maximum_version: int | None = None,\n) -> ssl.SSLContext:\n    \"\"\"Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3.\n\n    :param ssl_version:\n        The desired protocol version to use. This will default to\n        PROTOCOL_SSLv23 which will negotiate the highest protocol that both\n        the server and your installation of OpenSSL support.\n\n        This parameter is deprecated instead use 'ssl_minimum_version'.\n    :param ssl_minimum_version:\n        The minimum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\n    :param ssl_maximum_version:\n        The maximum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value.\n        Not recommended to set to anything other than 'ssl.TLSVersion.MAXIMUM_SUPPORTED' which is the\n        default value.\n    :param cert_reqs:\n        Whether to require the certificate verification. This defaults to\n        ``ssl.CERT_REQUIRED``.\n    :param options:\n        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,\n        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.\n    :param ciphers:\n        Which cipher suites to allow the server to select. Defaults to either system configured\n        ciphers if OpenSSL 1.1.1+, otherwise uses a secure default set of ciphers.\n    :returns:\n        Constructed SSLContext object with specified options\n    :rtype: SSLContext\n    \"\"\"\n    if SSLContext is None:\n        raise TypeError(\"Can't create an SSLContext object without an ssl module\")\n\n    # This means 'ssl_version' was specified as an exact value.\n    if ssl_version not in (None, PROTOCOL_TLS, PROTOCOL_TLS_CLIENT):\n        # Disallow setting 'ssl_version' and 'ssl_minimum|maximum_version'\n        # to avoid conflicts.\n        if ssl_minimum_version is not None or ssl_maximum_version is not None:\n            raise ValueError(\n                \"Can't specify both 'ssl_version' and either \"\n                \"'ssl_minimum_version' or 'ssl_maximum_version'\"\n            )\n\n        # 'ssl_version' is deprecated and will be removed in the future.\n        else:\n            # Use 'ssl_minimum_version' and 'ssl_maximum_version' instead.\n            ssl_minimum_version = _SSL_VERSION_TO_TLS_VERSION.get(\n                ssl_version, TLSVersion.MINIMUM_SUPPORTED\n            )\n            ssl_maximum_version = _SSL_VERSION_TO_TLS_VERSION.get(\n                ssl_version, TLSVersion.MAXIMUM_SUPPORTED\n            )\n\n            # This warning message is pushing users to use 'ssl_minimum_version'\n            # instead of both min/max. Best practice is to only set the minimum version and\n            # keep the maximum version to be it's default value: 'TLSVersion.MAXIMUM_SUPPORTED'\n            warnings.warn(\n                \"'ssl_version' option is deprecated and will be \"\n                \"removed in urllib3 v2.1.0. Instead use 'ssl_minimum_version'\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n\n    # PROTOCOL_TLS is deprecated in Python 3.10 so we always use PROTOCOL_TLS_CLIENT\n    context = SSLContext(PROTOCOL_TLS_CLIENT)\n\n    if ssl_minimum_version is not None:\n        context.minimum_version = ssl_minimum_version\n    else:  # Python <3.10 defaults to 'MINIMUM_SUPPORTED' so explicitly set TLSv1.2 here\n        context.minimum_version = TLSVersion.TLSv1_2\n\n    if ssl_maximum_version is not None:\n        context.maximum_version = ssl_maximum_version\n\n    # Unless we're given ciphers defer to either system ciphers in\n    # the case of OpenSSL 1.1.1+ or use our own secure default ciphers.\n    if ciphers:\n        context.set_ciphers(ciphers)\n\n    # Setting the default here, as we may have no ssl module on import\n    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs\n\n    if options is None:\n        options = 0\n        # SSLv2 is easily broken and is considered harmful and dangerous\n        options |= OP_NO_SSLv2\n        # SSLv3 has several problems and is now dangerous\n        options |= OP_NO_SSLv3\n        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+\n        # (issue #309)\n        options |= OP_NO_COMPRESSION\n        # TLSv1.2 only. Unless set explicitly, do not request tickets.\n        # This may save some bandwidth on wire, and although the ticket is encrypted,\n        # there is a risk associated with it being on wire,\n        # if the server is not rotating its ticketing keys properly.\n        options |= OP_NO_TICKET\n\n    context.options |= options\n\n    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is\n    # necessary for conditional client cert authentication with TLS 1.3.\n    # The attribute is None for OpenSSL <= 1.1.0 or does not exist when using\n    # an SSLContext created by pyOpenSSL.\n    if getattr(context, \"post_handshake_auth\", None) is not None:\n        context.post_handshake_auth = True\n\n    # The order of the below lines setting verify_mode and check_hostname\n    # matter due to safe-guards SSLContext has to prevent an SSLContext with\n    # check_hostname=True, verify_mode=NONE/OPTIONAL.\n    # We always set 'check_hostname=False' for pyOpenSSL so we rely on our own\n    # 'ssl.match_hostname()' implementation.\n    if cert_reqs == ssl.CERT_REQUIRED and not IS_PYOPENSSL:\n        context.verify_mode = cert_reqs\n        context.check_hostname = True\n    else:\n        context.check_hostname = False\n        context.verify_mode = cert_reqs\n\n    try:\n        context.hostname_checks_common_name = False\n    except AttributeError:  # Defensive: for CPython < 3.8.9 and 3.9.3; for PyPy < 7.3.8\n        pass\n\n    # Enable logging of TLS session keys via defacto standard environment variable\n    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.\n    if hasattr(context, \"keylog_filename\"):\n        sslkeylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n        if sslkeylogfile:\n            context.keylog_filename = sslkeylogfile\n\n    return context\n\n\n@typing.overload\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,\n    ca_cert_dir: str | None = ...,\n    key_password: str | None = ...,\n    ca_cert_data: None | str | bytes = ...,\n    tls_in_tls: typing.Literal[False] = ...,\n) -> ssl.SSLSocket:\n    ...\n\n\n@typing.overload\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = ...,\n    certfile: str | None = ...,\n    cert_reqs: int | None = ...,\n    ca_certs: str | None = ...,\n    server_hostname: str | None = ...,\n    ssl_version: int | None = ...,\n    ciphers: str | None = ...,\n    ssl_context: ssl.SSLContext | None = ...,\n    ca_cert_dir: str | None = ...,\n    key_password: str | None = ...,\n    ca_cert_data: None | str | bytes = ...,\n    tls_in_tls: bool = ...,\n) -> ssl.SSLSocket | SSLTransportType:\n    ...\n\n\ndef ssl_wrap_socket(\n    sock: socket.socket,\n    keyfile: str | None = None,\n    certfile: str | None = None,\n    cert_reqs: int | None = None,\n    ca_certs: str | None = None,\n    server_hostname: str | None = None,\n    ssl_version: int | None = None,\n    ciphers: str | None = None,\n    ssl_context: ssl.SSLContext | None = None,\n    ca_cert_dir: str | None = None,\n    key_password: str | None = None,\n    ca_cert_data: None | str | bytes = None,\n    tls_in_tls: bool = False,\n) -> ssl.SSLSocket | SSLTransportType:\n    \"\"\"\n    All arguments except for server_hostname, ssl_context, tls_in_tls, ca_cert_data and\n    ca_cert_dir have the same meaning as they do when using\n    :func:`ssl.create_default_context`, :meth:`ssl.SSLContext.load_cert_chain`,\n    :meth:`ssl.SSLContext.set_ciphers` and :meth:`ssl.SSLContext.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support.\n    :param ca_cert_dir:\n        A directory containing CA certificates in multiple separate files, as\n        supported by OpenSSL's -CApath flag or the capath argument to\n        SSLContext.load_verify_locations().\n    :param key_password:\n        Optional password if the keyfile is encrypted.\n    :param ca_cert_data:\n        Optional string containing CA certificates in PEM format suitable for\n        passing as the cadata parameter to SSLContext.load_verify_locations()\n    :param tls_in_tls:\n        Use SSLTransport to wrap the existing socket.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        # Note: This branch of code and all the variables in it are only used in tests.\n        # We should consider deprecating and removing this code.\n        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n\n    if ca_certs or ca_cert_dir or ca_cert_data:\n        try:\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n        except OSError as e:\n            raise SSLError(e) from e\n\n    elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n        # try to load OS default certs; works well on Windows.\n        context.load_default_certs()\n\n    # Attempt to detect if we get the goofy behavior of the\n    # keyfile being encrypted and OpenSSL asking for the\n    # passphrase via the terminal and instead error out.\n    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n        raise SSLError(\"Client private key is encrypted, password is required\")\n\n    if certfile:\n        if key_password is None:\n            context.load_cert_chain(certfile, keyfile)\n        else:\n            context.load_cert_chain(certfile, keyfile, key_password)\n\n    try:\n        context.set_alpn_protocols(ALPN_PROTOCOLS)\n    except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols\n        pass\n\n    ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls, server_hostname)\n    return ssl_sock\n\n\ndef is_ipaddress(hostname: str | bytes) -> bool:\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(_IPV4_RE.match(hostname) or _BRACELESS_IPV6_ADDRZ_RE.match(hostname))\n\n\ndef _is_key_file_encrypted(key_file: str) -> bool:\n    \"\"\"Detects if a key file is encrypted or not.\"\"\"\n    with open(key_file) as f:\n        for line in f:\n            # Look for Proc-Type: 4,ENCRYPTED\n            if \"ENCRYPTED\" in line:\n                return True\n\n    return False\n\n\ndef _ssl_wrap_socket_impl(\n    sock: socket.socket,\n    ssl_context: ssl.SSLContext,\n    tls_in_tls: bool,\n    server_hostname: str | None = None,\n) -> ssl.SSLSocket | SSLTransportType:\n    if tls_in_tls:\n        if not SSLTransport:\n            # Import error, ssl is not available.\n            raise ProxySchemeUnsupported(\n                \"TLS in TLS requires support for the 'ssl' module\"\n            )\n\n        SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)\n        return SSLTransport(sock, ssl_context, server_hostname)\n\n    return ssl_context.wrap_socket(sock, server_hostname=server_hostname)\n", "dummyserver/hypercornserver.py": "from __future__ import annotations\n\nimport concurrent.futures\nimport contextlib\nimport functools\nimport sys\nimport threading\nfrom typing import Generator\n\nimport hypercorn\nimport hypercorn.trio\nimport hypercorn.typing\nimport trio\nfrom quart_trio import QuartTrio\n\n\n# https://github.com/pgjones/hypercorn/blob/19dfb96411575a6a647cdea63fa581b48ebb9180/src/hypercorn/utils.py#L172-L178\nasync def graceful_shutdown(shutdown_event: threading.Event) -> None:\n    while True:\n        if shutdown_event.is_set():\n            return\n        await trio.sleep(0.1)\n\n\nasync def _start_server(\n    config: hypercorn.Config,\n    app: QuartTrio,\n    ready_event: threading.Event,\n    shutdown_event: threading.Event,\n) -> None:\n    async with trio.open_nursery() as nursery:\n        config.bind = await nursery.start(\n            functools.partial(\n                hypercorn.trio.serve,\n                app,\n                config,\n                shutdown_trigger=functools.partial(graceful_shutdown, shutdown_event),\n            )\n        )\n        ready_event.set()\n\n\n@contextlib.contextmanager\ndef run_hypercorn_in_thread(\n    config: hypercorn.Config, app: hypercorn.typing.ASGIFramework\n) -> Generator[None, None, None]:\n    ready_event = threading.Event()\n    shutdown_event = threading.Event()\n\n    with concurrent.futures.ThreadPoolExecutor(\n        1, thread_name_prefix=\"hypercorn dummyserver\"\n    ) as executor:\n        future = executor.submit(\n            trio.run,\n            _start_server,\n            config,\n            app,\n            ready_event,\n            shutdown_event,\n        )\n        ready_event.wait(5)\n        if not ready_event.is_set():\n            raise Exception(\"most likely failed to start server\")\n\n        try:\n            yield\n        finally:\n            shutdown_event.set()\n            future.result()\n\n\ndef main() -> int:\n    # For debugging dummyserver itself - PYTHONPATH=src python -m dummyserver.hypercornserver\n    from .app import hypercorn_app\n\n    config = hypercorn.Config()\n    config.bind = [\"localhost:0\"]\n    ready_event = threading.Event()\n    shutdown_event = threading.Event()\n    trio.run(_start_server, config, hypercorn_app, ready_event, shutdown_event)\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "dummyserver/testcase.py": "from __future__ import annotations\n\nimport contextlib\nimport socket\nimport ssl\nimport threading\nimport typing\nfrom test import LONG_TIMEOUT\n\nimport hypercorn\nimport pytest\n\nfrom dummyserver.app import hypercorn_app\nfrom dummyserver.asgi_proxy import ProxyApp\nfrom dummyserver.hypercornserver import run_hypercorn_in_thread\nfrom dummyserver.socketserver import DEFAULT_CERTS, HAS_IPV6, SocketServerThread\nfrom urllib3.connection import HTTPConnection\nfrom urllib3.util.ssltransport import SSLTransport\nfrom urllib3.util.url import parse_url\n\n\ndef consume_socket(\n    sock: SSLTransport | socket.socket,\n    chunks: int = 65536,\n    quit_event: threading.Event | None = None,\n) -> bytearray:\n    consumed = bytearray()\n    sock.settimeout(LONG_TIMEOUT)\n    while True:\n        if quit_event and quit_event.is_set():\n            break\n        try:\n            b = sock.recv(chunks)\n        except (TimeoutError, socket.timeout):\n            continue\n        assert isinstance(b, bytes)\n        consumed += b\n        if b.endswith(b\"\\r\\n\\r\\n\"):\n            break\n    return consumed\n\n\nclass SocketDummyServerTestCase:\n    \"\"\"\n    A simple socket-based server is created for this class that is good for\n    exactly one request.\n    \"\"\"\n\n    scheme = \"http\"\n    host = \"localhost\"\n\n    server_thread: typing.ClassVar[SocketServerThread]\n    port: typing.ClassVar[int]\n\n    tmpdir: typing.ClassVar[str]\n    ca_path: typing.ClassVar[str]\n    cert_combined_path: typing.ClassVar[str]\n    cert_path: typing.ClassVar[str]\n    key_path: typing.ClassVar[str]\n    password_key_path: typing.ClassVar[str]\n\n    server_context: typing.ClassVar[ssl.SSLContext]\n    client_context: typing.ClassVar[ssl.SSLContext]\n\n    proxy_server: typing.ClassVar[SocketDummyServerTestCase]\n\n    @classmethod\n    def _start_server(\n        cls,\n        socket_handler: typing.Callable[[socket.socket], None],\n        quit_event: threading.Event | None = None,\n    ) -> None:\n        ready_event = threading.Event()\n        cls.server_thread = SocketServerThread(\n            socket_handler=socket_handler,\n            ready_event=ready_event,\n            host=cls.host,\n            quit_event=quit_event,\n        )\n        cls.server_thread.start()\n        ready_event.wait(5)\n        if not ready_event.is_set():\n            raise Exception(\"most likely failed to start server\")\n        cls.port = cls.server_thread.port\n\n    @classmethod\n    def start_response_handler(\n        cls,\n        response: bytes,\n        num: int = 1,\n        block_send: threading.Event | None = None,\n    ) -> threading.Event:\n        ready_event = threading.Event()\n        quit_event = threading.Event()\n\n        def socket_handler(listener: socket.socket) -> None:\n            for _ in range(num):\n                ready_event.set()\n\n                listener.settimeout(LONG_TIMEOUT)\n                while True:\n                    if quit_event.is_set():\n                        return\n                    try:\n                        sock = listener.accept()[0]\n                        break\n                    except (TimeoutError, socket.timeout):\n                        continue\n                consume_socket(sock, quit_event=quit_event)\n                if quit_event.is_set():\n                    sock.close()\n                    return\n                if block_send:\n                    while not block_send.wait(LONG_TIMEOUT):\n                        if quit_event.is_set():\n                            sock.close()\n                            return\n                    block_send.clear()\n                sock.send(response)\n                sock.close()\n\n        cls._start_server(socket_handler, quit_event=quit_event)\n        return ready_event\n\n    @classmethod\n    def start_basic_handler(\n        cls, num: int = 1, block_send: threading.Event | None = None\n    ) -> threading.Event:\n        return cls.start_response_handler(\n            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\",\n            num,\n            block_send,\n        )\n\n    @staticmethod\n    def quit_server_thread(server_thread: SocketServerThread) -> None:\n        if server_thread.quit_event:\n            server_thread.quit_event.set()\n        # in principle the maximum time that the thread can take to notice\n        # the quit_event is LONG_TIMEOUT and the thread should terminate\n        # shortly after that, we give 5 seconds leeway just in case\n        server_thread.join(LONG_TIMEOUT * 2 + 5.0)\n        if server_thread.is_alive():\n            raise Exception(\"server_thread did not exit\")\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        if hasattr(cls, \"server_thread\"):\n            cls.quit_server_thread(cls.server_thread)\n\n    def teardown_method(self) -> None:\n        if hasattr(self, \"server_thread\"):\n            self.quit_server_thread(self.server_thread)\n\n    def assert_header_received(\n        self,\n        received_headers: typing.Iterable[bytes],\n        header_name: str,\n        expected_value: str | None = None,\n    ) -> None:\n        header_name_bytes = header_name.encode(\"ascii\")\n        if expected_value is None:\n            expected_value_bytes = None\n        else:\n            expected_value_bytes = expected_value.encode(\"ascii\")\n        header_titles = []\n        for header in received_headers:\n            key, value = header.split(b\": \")\n            header_titles.append(key)\n            if key == header_name_bytes and expected_value_bytes is not None:\n                assert value == expected_value_bytes\n        assert header_name_bytes in header_titles\n\n\nclass IPV4SocketDummyServerTestCase(SocketDummyServerTestCase):\n    @classmethod\n    def _start_server(\n        cls,\n        socket_handler: typing.Callable[[socket.socket], None],\n        quit_event: threading.Event | None = None,\n    ) -> None:\n        ready_event = threading.Event()\n        cls.server_thread = SocketServerThread(\n            socket_handler=socket_handler,\n            ready_event=ready_event,\n            host=cls.host,\n            quit_event=quit_event,\n        )\n        cls.server_thread.USE_IPV6 = False\n        cls.server_thread.start()\n        ready_event.wait(5)\n        if not ready_event.is_set():\n            raise Exception(\"most likely failed to start server\")\n        cls.port = cls.server_thread.port\n\n\nclass HypercornDummyServerTestCase:\n    host = \"localhost\"\n    host_alt = \"127.0.0.1\"\n    port: typing.ClassVar[int]\n    base_url: typing.ClassVar[str]\n    base_url_alt: typing.ClassVar[str]\n    certs: typing.ClassVar[dict[str, typing.Any]] = {}\n\n    _stack: typing.ClassVar[contextlib.ExitStack]\n\n    @classmethod\n    def setup_class(cls) -> None:\n        with contextlib.ExitStack() as stack:\n            config = hypercorn.Config()\n            if cls.certs:\n                config.certfile = cls.certs[\"certfile\"]\n                config.keyfile = cls.certs[\"keyfile\"]\n                config.verify_mode = cls.certs[\"cert_reqs\"]\n                config.ca_certs = cls.certs[\"ca_certs\"]\n                config.alpn_protocols = cls.certs[\"alpn_protocols\"]\n            config.bind = [f\"{cls.host}:0\"]\n            stack.enter_context(run_hypercorn_in_thread(config, hypercorn_app))\n            cls._stack = stack.pop_all()\n            cls.port = typing.cast(int, parse_url(config.bind[0]).port)\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        cls._stack.close()\n\n\nclass HTTPSHypercornDummyServerTestCase(HypercornDummyServerTestCase):\n    scheme = \"https\"\n    host = \"localhost\"\n    certs = DEFAULT_CERTS\n    certs_dir = \"\"\n    bad_ca_path = \"\"\n\n\nclass HypercornDummyProxyTestCase:\n    http_host: typing.ClassVar[str] = \"localhost\"\n    http_host_alt: typing.ClassVar[str] = \"127.0.0.1\"\n    http_port: typing.ClassVar[int]\n    http_url: typing.ClassVar[str]\n    http_url_alt: typing.ClassVar[str]\n\n    https_host: typing.ClassVar[str] = \"localhost\"\n    https_host_alt: typing.ClassVar[str] = \"127.0.0.1\"\n    https_certs: typing.ClassVar[dict[str, typing.Any]] = DEFAULT_CERTS\n    https_port: typing.ClassVar[int]\n    https_url: typing.ClassVar[str]\n    https_url_alt: typing.ClassVar[str]\n    https_url_fqdn: typing.ClassVar[str]\n\n    proxy_host: typing.ClassVar[str] = \"localhost\"\n    proxy_host_alt: typing.ClassVar[str] = \"127.0.0.1\"\n    proxy_port: typing.ClassVar[int]\n    proxy_url: typing.ClassVar[str]\n    https_proxy_port: typing.ClassVar[int]\n    https_proxy_url: typing.ClassVar[str]\n\n    certs_dir: typing.ClassVar[str] = \"\"\n    bad_ca_path: typing.ClassVar[str] = \"\"\n\n    server_thread: typing.ClassVar[threading.Thread]\n    _stack: typing.ClassVar[contextlib.ExitStack]\n\n    @classmethod\n    def setup_class(cls) -> None:\n        with contextlib.ExitStack() as stack:\n            http_server_config = hypercorn.Config()\n            http_server_config.bind = [f\"{cls.http_host}:0\"]\n            stack.enter_context(\n                run_hypercorn_in_thread(http_server_config, hypercorn_app)\n            )\n            cls.http_port = typing.cast(int, parse_url(http_server_config.bind[0]).port)\n\n            https_server_config = hypercorn.Config()\n            https_server_config.certfile = cls.https_certs[\"certfile\"]\n            https_server_config.keyfile = cls.https_certs[\"keyfile\"]\n            https_server_config.verify_mode = cls.https_certs[\"cert_reqs\"]\n            https_server_config.ca_certs = cls.https_certs[\"ca_certs\"]\n            https_server_config.alpn_protocols = cls.https_certs[\"alpn_protocols\"]\n            https_server_config.bind = [f\"{cls.https_host}:0\"]\n            stack.enter_context(\n                run_hypercorn_in_thread(https_server_config, hypercorn_app)\n            )\n            cls.https_port = typing.cast(\n                int, parse_url(https_server_config.bind[0]).port\n            )\n\n            http_proxy_config = hypercorn.Config()\n            http_proxy_config.bind = [f\"{cls.proxy_host}:0\"]\n            stack.enter_context(run_hypercorn_in_thread(http_proxy_config, ProxyApp()))\n            cls.proxy_port = typing.cast(int, parse_url(http_proxy_config.bind[0]).port)\n\n            https_proxy_config = hypercorn.Config()\n            https_proxy_config.certfile = cls.https_certs[\"certfile\"]\n            https_proxy_config.keyfile = cls.https_certs[\"keyfile\"]\n            https_proxy_config.verify_mode = cls.https_certs[\"cert_reqs\"]\n            https_proxy_config.ca_certs = cls.https_certs[\"ca_certs\"]\n            https_proxy_config.alpn_protocols = cls.https_certs[\"alpn_protocols\"]\n            https_proxy_config.bind = [f\"{cls.proxy_host}:0\"]\n            upstream_ca_certs = cls.https_certs.get(\"ca_certs\")\n            stack.enter_context(\n                run_hypercorn_in_thread(https_proxy_config, ProxyApp(upstream_ca_certs))\n            )\n            cls.https_proxy_port = typing.cast(\n                int, parse_url(https_proxy_config.bind[0]).port\n            )\n\n            cls._stack = stack.pop_all()\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        cls._stack.close()\n\n\n@pytest.mark.skipif(not HAS_IPV6, reason=\"IPv6 not available\")\nclass IPv6HypercornDummyServerTestCase(HypercornDummyServerTestCase):\n    host = \"::1\"\n\n\n@pytest.mark.skipif(not HAS_IPV6, reason=\"IPv6 not available\")\nclass IPv6HypercornDummyProxyTestCase(HypercornDummyProxyTestCase):\n    http_host = \"localhost\"\n    http_host_alt = \"127.0.0.1\"\n\n    https_host = \"localhost\"\n    https_host_alt = \"127.0.0.1\"\n    https_certs = DEFAULT_CERTS\n\n    proxy_host = \"::1\"\n    proxy_host_alt = \"127.0.0.1\"\n\n\nclass ConnectionMarker:\n    \"\"\"\n    Marks an HTTP(S)Connection's socket after a request was made.\n\n    Helps a test server understand when a client finished a request,\n    without implementing a complete HTTP server.\n    \"\"\"\n\n    MARK_FORMAT = b\"$#MARK%04x*!\"\n\n    @classmethod\n    @contextlib.contextmanager\n    def mark(\n        cls, monkeypatch: pytest.MonkeyPatch\n    ) -> typing.Generator[None, None, None]:\n        \"\"\"\n        Mark connections under in that context.\n        \"\"\"\n\n        orig_request = HTTPConnection.request\n\n        def call_and_mark(\n            target: typing.Callable[..., None]\n        ) -> typing.Callable[..., None]:\n            def part(\n                self: HTTPConnection, *args: typing.Any, **kwargs: typing.Any\n            ) -> None:\n                target(self, *args, **kwargs)\n                self.sock.sendall(cls._get_socket_mark(self.sock, False))\n\n            return part\n\n        with monkeypatch.context() as m:\n            m.setattr(HTTPConnection, \"request\", call_and_mark(orig_request))\n            yield\n\n    @classmethod\n    def consume_request(cls, sock: socket.socket, chunks: int = 65536) -> bytearray:\n        \"\"\"\n        Consume a socket until after the HTTP request is sent.\n        \"\"\"\n        consumed = bytearray()\n        mark = cls._get_socket_mark(sock, True)\n        while True:\n            b = sock.recv(chunks)\n            if not b:\n                break\n            consumed += b\n            if consumed.endswith(mark):\n                break\n        return consumed\n\n    @classmethod\n    def _get_socket_mark(cls, sock: socket.socket, server: bool) -> bytes:\n        if server:\n            port = sock.getpeername()[1]\n        else:\n            port = sock.getsockname()[1]\n        return cls.MARK_FORMAT % (port,)\n", "dummyserver/asgi_proxy.py": "from __future__ import annotations\n\nimport typing\n\nimport httpx\nimport trio\nfrom hypercorn.typing import (\n    ASGIReceiveCallable,\n    ASGISendCallable,\n    HTTPResponseBodyEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n    Scope,\n)\n\n\nasync def _read_body(receive: ASGIReceiveCallable) -> bytes:\n    body = bytearray()\n    body_consumed = False\n    while not body_consumed:\n        event = await receive()\n        if event[\"type\"] == \"http.request\":\n            body.extend(event[\"body\"])\n            body_consumed = not event[\"more_body\"]\n        else:\n            raise ValueError(event[\"type\"])\n    return bytes(body)\n\n\nclass ProxyApp:\n    def __init__(self, upstream_ca_certs: str | None = None):\n        self.upstream_ca_certs = upstream_ca_certs\n\n    async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -> None:\n        assert scope[\"type\"] == \"http\"\n        if scope[\"method\"] in [\"GET\", \"POST\"]:\n            await self.absolute_uri(scope, receive, send)\n        elif scope[\"method\"] == \"CONNECT\":\n            await self.connect(scope, send)\n        else:\n            raise ValueError(scope[\"method\"])\n\n    async def absolute_uri(\n        self,\n        scope: HTTPScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -> None:\n        async with httpx.AsyncClient(verify=self.upstream_ca_certs or True) as client:\n            client_response = await client.request(\n                method=scope[\"method\"],\n                url=scope[\"path\"],\n                headers=list(scope[\"headers\"]),\n                content=await _read_body(receive),\n            )\n\n        headers = []\n        for header in (\n            \"Date\",\n            \"Cache-Control\",\n            \"Server\",\n            \"Content-Type\",\n            \"Location\",\n        ):\n            v = client_response.headers.get(header)\n            if v:\n                headers.append((header.encode(), v.encode()))\n        headers.append((b\"Content-Length\", str(len(client_response.content)).encode()))\n\n        await send(\n            HTTPResponseStartEvent(\n                type=\"http.response.start\",\n                status=client_response.status_code,\n                headers=headers,\n            )\n        )\n        await send(\n            HTTPResponseBodyEvent(\n                type=\"http.response.body\",\n                body=client_response.content,\n                more_body=False,\n            )\n        )\n\n    async def connect(self, scope: HTTPScope, send: ASGISendCallable) -> None:\n        async def start_forward(\n            reader: trio.SocketStream, writer: trio.SocketStream\n        ) -> None:\n            while True:\n                try:\n                    data = await reader.receive_some(4096)\n                except trio.ClosedResourceError:\n                    break\n                if not data:\n                    break\n                await writer.send_all(data)\n            await writer.aclose()\n\n        host, port = scope[\"path\"].split(\":\")\n        async with await trio.open_tcp_stream(host, int(port)) as upstream:\n            await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": []})\n            await send({\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": True})\n\n            client = typing.cast(trio.SocketStream, scope[\"extensions\"][\"_transport\"])\n\n            async with trio.open_nursery(strict_exception_groups=True) as nursery:\n                nursery.start_soon(start_forward, client, upstream)\n                nursery.start_soon(start_forward, upstream, client)\n", "dummyserver/socketserver.py": "#!/usr/bin/env python\n\n\"\"\"\nDummy server used for unit testing.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport socket\nimport ssl\nimport sys\nimport threading\nimport typing\nimport warnings\n\nimport trustme\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\n\nfrom urllib3.exceptions import HTTPWarning\nfrom urllib3.util import resolve_cert_reqs, resolve_ssl_version\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import ParamSpec\n\n    P = ParamSpec(\"P\")\n\nlog = logging.getLogger(__name__)\n\nCERTS_PATH = os.path.join(os.path.dirname(__file__), \"certs\")\nDEFAULT_CERTS: dict[str, typing.Any] = {\n    \"certfile\": os.path.join(CERTS_PATH, \"server.crt\"),\n    \"keyfile\": os.path.join(CERTS_PATH, \"server.key\"),\n    \"cert_reqs\": ssl.CERT_OPTIONAL,\n    \"ca_certs\": os.path.join(CERTS_PATH, \"cacert.pem\"),\n    \"alpn_protocols\": [\"h2\", \"http/1.1\"],\n}\nDEFAULT_CA = os.path.join(CERTS_PATH, \"cacert.pem\")\nDEFAULT_CA_KEY = os.path.join(CERTS_PATH, \"cacert.key\")\n\n\ndef _resolves_to_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system resolves host to an IPv6 address by default.\"\"\"\n    resolves_to_ipv6 = False\n    try:\n        for res in socket.getaddrinfo(host, None, socket.AF_UNSPEC):\n            af, _, _, _, _ = res\n            if af == socket.AF_INET6:\n                resolves_to_ipv6 = True\n    except socket.gaierror:\n        pass\n\n    return resolves_to_ipv6\n\n\ndef _has_ipv6(host: str) -> bool:\n    \"\"\"Returns True if the system can bind an IPv6 address.\"\"\"\n    sock = None\n    has_ipv6 = False\n\n    if socket.has_ipv6:\n        # has_ipv6 returns true if cPython was compiled with IPv6 support.\n        # It does not tell us if the system has IPv6 support enabled. To\n        # determine that we must bind to an IPv6 address.\n        # https://github.com/urllib3/urllib3/pull/611\n        # https://bugs.python.org/issue658327\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = _resolves_to_ipv6(\"localhost\")\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6\n\n\n# Some systems may have IPv6 support but DNS may not be configured\n# properly. We can not count that localhost will resolve to ::1 on all\n# systems. See https://github.com/urllib3/urllib3/pull/611 and\n# https://bugs.python.org/issue18792\nHAS_IPV6_AND_DNS = _has_ipv6(\"localhost\")\nHAS_IPV6 = _has_ipv6(\"::1\")\n\n\n# Different types of servers we have:\n\n\nclass NoIPv6Warning(HTTPWarning):\n    \"IPv6 is not available\"\n\n\nclass SocketServerThread(threading.Thread):\n    \"\"\"\n    :param socket_handler: Callable which receives a socket argument for one\n        request.\n    :param ready_event: Event which gets set when the socket handler is\n        ready to receive requests.\n    \"\"\"\n\n    USE_IPV6 = HAS_IPV6_AND_DNS\n\n    def __init__(\n        self,\n        socket_handler: typing.Callable[[socket.socket], None],\n        host: str = \"localhost\",\n        ready_event: threading.Event | None = None,\n        quit_event: threading.Event | None = None,\n    ) -> None:\n        super().__init__()\n        self.daemon = True\n\n        self.socket_handler = socket_handler\n        self.host = host\n        self.ready_event = ready_event\n        self.quit_event = quit_event\n\n    def _start_server(self) -> None:\n        if self.USE_IPV6:\n            sock = socket.socket(socket.AF_INET6)\n        else:\n            warnings.warn(\"No IPv6 support. Falling back to IPv4.\", NoIPv6Warning)\n            sock = socket.socket(socket.AF_INET)\n        if sys.platform != \"win32\":\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        with sock:\n            sock.bind((self.host, 0))\n            self.port = sock.getsockname()[1]\n\n            # Once listen() returns, the server socket is ready\n            sock.listen(1)\n\n            if self.ready_event:\n                self.ready_event.set()\n\n            self.socket_handler(sock)\n\n    def run(self) -> None:\n        self._start_server()\n\n\ndef ssl_options_to_context(  # type: ignore[no-untyped-def]\n    keyfile=None,\n    certfile=None,\n    server_side=None,\n    cert_reqs=None,\n    ssl_version: str | int | None = None,\n    ca_certs=None,\n    do_handshake_on_connect=None,\n    suppress_ragged_eofs=None,\n    ciphers=None,\n    alpn_protocols=None,\n) -> ssl.SSLContext:\n    \"\"\"Return an equivalent SSLContext based on ssl.wrap_socket args.\"\"\"\n    ssl_version = resolve_ssl_version(ssl_version)\n    cert_none = resolve_cert_reqs(\"CERT_NONE\")\n    if cert_reqs is None:\n        cert_reqs = cert_none\n    else:\n        cert_reqs = resolve_cert_reqs(cert_reqs)\n\n    ctx = ssl.SSLContext(ssl_version)\n    ctx.load_cert_chain(certfile, keyfile)\n    ctx.verify_mode = cert_reqs\n    if ctx.verify_mode != cert_none:\n        ctx.load_verify_locations(cafile=ca_certs)\n    if alpn_protocols and hasattr(ctx, \"set_alpn_protocols\"):\n        try:\n            ctx.set_alpn_protocols(alpn_protocols)\n        except NotImplementedError:\n            pass\n    return ctx\n\n\ndef get_unreachable_address() -> tuple[str, int]:\n    # reserved as per rfc2606\n    return (\"something.invalid\", 54321)\n\n\ndef encrypt_key_pem(private_key_pem: trustme.Blob, password: bytes) -> trustme.Blob:\n    private_key = serialization.load_pem_private_key(\n        private_key_pem.bytes(), password=None, backend=default_backend()\n    )\n    encrypted_key = private_key.private_bytes(\n        serialization.Encoding.PEM,\n        serialization.PrivateFormat.TraditionalOpenSSL,\n        serialization.BestAvailableEncryption(password),\n    )\n    return trustme.Blob(encrypted_key)\n", "dummyserver/__init__.py": "", "dummyserver/app.py": "from __future__ import annotations\n\nimport collections\nimport contextlib\nimport datetime\nimport email.utils\nimport gzip\nimport mimetypes\nimport zlib\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Iterator\n\nimport trio\nfrom quart import Response, make_response, request\nfrom quart.typing import ResponseReturnValue\nfrom quart_trio import QuartTrio\n\nhypercorn_app = QuartTrio(__name__)\n\n# Globals are not safe in Flask/Quart but work for our Hypercorn use case\nRETRY_TEST_NAMES: collections.Counter[str] = collections.Counter()\nLAST_RETRY_AFTER_REQ: datetime.datetime = datetime.datetime.min\n\n\npyodide_testing_app = QuartTrio(__name__)\nDEFAULT_HEADERS = [\n    # Allow cross-origin requests for emscripten\n    (\"Access-Control-Allow-Origin\", \"*\"),\n    (\"Cross-Origin-Opener-Policy\", \"same-origin\"),\n    (\"Cross-Origin-Embedder-Policy\", \"require-corp\"),\n    (\"Feature-Policy\", \"sync-xhr *;\"),\n    (\"Access-Control-Allow-Headers\", \"*\"),\n]\n\n\n@hypercorn_app.route(\"/\")\n@pyodide_testing_app.route(\"/\")\n@pyodide_testing_app.route(\"/index\")\nasync def index() -> ResponseReturnValue:\n    return await make_response(\"Dummy server!\")\n\n\n@hypercorn_app.route(\"/alpn_protocol\")\nasync def alpn_protocol() -> ResponseReturnValue:\n    \"\"\"Return the requester's certificate.\"\"\"\n    alpn_protocol = request.scope[\"extensions\"][\"tls\"][\"alpn_protocol\"]\n    return await make_response(alpn_protocol)\n\n\n@hypercorn_app.route(\"/certificate\")\nasync def certificate() -> ResponseReturnValue:\n    \"\"\"Return the requester's certificate.\"\"\"\n    print(\"scope\", request.scope)\n    subject = request.scope[\"extensions\"][\"tls\"][\"client_cert_name\"]\n    subject_as_dict = dict(part.split(\"=\") for part in subject.split(\", \"))\n    return await make_response(subject_as_dict)\n\n\n@hypercorn_app.route(\"/specific_method\", methods=[\"GET\", \"POST\", \"PUT\"])\n@pyodide_testing_app.route(\"/specific_method\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def specific_method() -> ResponseReturnValue:\n    \"Confirm that the request matches the desired method type\"\n    method_param = (await request.values).get(\"method\", \"\")\n\n    if request.method.upper() == method_param.upper():\n        return await make_response(\"\", 200)\n    else:\n        return await make_response(\n            f\"Wrong method: {method_param} != {request.method}\", 400\n        )\n\n\n@hypercorn_app.route(\"/upload\", methods=[\"POST\"])\nasync def upload() -> ResponseReturnValue:\n    \"Confirm that the uploaded file conforms to specification\"\n    params = await request.form\n    param = params.get(\"upload_param\")\n    filename_param = params.get(\"upload_filename\")\n    size = int(params.get(\"upload_size\", \"0\"))\n    files_ = (await request.files).getlist(param)\n    assert files_ is not None\n\n    if len(files_) != 1:\n        return await make_response(\n            f\"Expected 1 file for '{param}', not {len(files_)}\", 400\n        )\n\n    file_ = files_[0]\n    # data is short enough to read synchronously without blocking the event loop\n    with contextlib.closing(file_.stream) as stream:\n        data = stream.read()\n\n    if int(size) != len(data):\n        return await make_response(f\"Wrong size: {int(size)} != {len(data)}\", 400)\n\n    if filename_param != file_.filename:\n        return await make_response(\n            f\"Wrong filename: {filename_param} != {file_.filename}\", 400\n        )\n\n    return await make_response()\n\n\n@hypercorn_app.route(\"/chunked\")\nasync def chunked() -> ResponseReturnValue:\n    def generate() -> Iterator[str]:\n        for _ in range(4):\n            yield \"123\"\n\n    return await make_response(generate())\n\n\n@hypercorn_app.route(\"/chunked_gzip\")\nasync def chunked_gzip() -> ResponseReturnValue:\n    def generate() -> Iterator[bytes]:\n        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)\n\n        for uncompressed in [b\"123\"] * 4:\n            yield compressor.compress(uncompressed)\n        yield compressor.flush()\n\n    return await make_response(generate(), 200, [(\"Content-Encoding\", \"gzip\")])\n\n\n@hypercorn_app.route(\"/keepalive\")\nasync def keepalive() -> ResponseReturnValue:\n    if request.args.get(\"close\", b\"0\") == b\"1\":\n        headers = [(\"Connection\", \"close\")]\n        return await make_response(\"Closing\", 200, headers)\n\n    headers = [(\"Connection\", \"keep-alive\")]\n    return await make_response(\"Keeping alive\", 200, headers)\n\n\n@hypercorn_app.route(\"/echo\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def echo() -> ResponseReturnValue:\n    \"Echo back the params\"\n    if request.method == \"GET\":\n        return await make_response(request.query_string)\n\n    return await make_response(await request.get_data())\n\n\n@hypercorn_app.route(\"/echo_json\", methods=[\"POST\"])\n@pyodide_testing_app.route(\"/echo_json\", methods=[\"POST\", \"OPTIONS\"])\nasync def echo_json() -> ResponseReturnValue:\n    \"Echo back the JSON\"\n    if request.method == \"OPTIONS\":\n        return await make_response(\"\", 200)\n    data = await request.get_data()\n    return await make_response(data, 200, request.headers)\n\n\n@hypercorn_app.route(\"/echo_uri/<path:rest>\")\n@hypercorn_app.route(\"/echo_uri\", defaults={\"rest\": \"\"})\nasync def echo_uri(rest: str) -> ResponseReturnValue:\n    \"Echo back the requested URI\"\n    assert request.full_path is not None\n    return await make_response(request.full_path)\n\n\n@hypercorn_app.route(\"/echo_params\")\nasync def echo_params() -> ResponseReturnValue:\n    \"Echo back the query parameters\"\n    await request.get_data()\n    echod = sorted((k, v) for k, v in request.args.items())\n    return await make_response(repr(echod))\n\n\n@hypercorn_app.route(\"/headers\", methods=[\"GET\", \"POST\"])\nasync def headers() -> ResponseReturnValue:\n    return await make_response(dict(request.headers.items()))\n\n\n@hypercorn_app.route(\"/headers_and_params\")\nasync def headers_and_params() -> ResponseReturnValue:\n    return await make_response(\n        {\n            \"headers\": dict(request.headers),\n            \"params\": request.args,\n        }\n    )\n\n\n@hypercorn_app.route(\"/multi_headers\", methods=[\"GET\", \"POST\"])\nasync def multi_headers() -> ResponseReturnValue:\n    return await make_response({\"headers\": list(request.headers)})\n\n\n@hypercorn_app.route(\"/multi_redirect\")\nasync def multi_redirect() -> ResponseReturnValue:\n    \"Performs a redirect chain based on ``redirect_codes``\"\n    params = request.args\n    codes = params.get(\"redirect_codes\", \"200\")\n    head, tail = codes.split(\",\", 1) if \",\" in codes else (codes, None)\n    assert head is not None\n    status = head\n    if not tail:\n        return await make_response(\"Done redirecting\", status)\n\n    headers = [(\"Location\", f\"/multi_redirect?redirect_codes={tail}\")]\n    return await make_response(\"\", status, headers)\n\n\n@hypercorn_app.route(\"/encodingrequest\")\nasync def encodingrequest() -> ResponseReturnValue:\n    \"Check for UA accepting gzip/deflate encoding\"\n    data = b\"hello, world!\"\n    encoding = request.headers.get(\"Accept-Encoding\", \"\")\n    headers = []\n    if encoding == \"gzip\":\n        headers = [(\"Content-Encoding\", \"gzip\")]\n        file_ = BytesIO()\n        with contextlib.closing(gzip.GzipFile(\"\", mode=\"w\", fileobj=file_)) as zipfile:\n            zipfile.write(data)\n        data = file_.getvalue()\n    elif encoding == \"deflate\":\n        headers = [(\"Content-Encoding\", \"deflate\")]\n        data = zlib.compress(data)\n    elif encoding == \"garbage-gzip\":\n        headers = [(\"Content-Encoding\", \"gzip\")]\n        data = b\"garbage\"\n    elif encoding == \"garbage-deflate\":\n        headers = [(\"Content-Encoding\", \"deflate\")]\n        data = b\"garbage\"\n    return await make_response(data, 200, headers)\n\n\n@hypercorn_app.route(\"/redirect\", methods=[\"GET\", \"POST\", \"PUT\"])\nasync def redirect() -> ResponseReturnValue:\n    \"Perform a redirect to ``target``\"\n    values = await request.values\n    target = values.get(\"target\", \"/\")\n    status = values.get(\"status\", \"303 See Other\")\n    status_code = status.split(\" \")[0]\n\n    headers = [(\"Location\", target)]\n    return await make_response(\"\", status_code, headers)\n\n\n@hypercorn_app.route(\"/redirect_after\")\nasync def redirect_after() -> ResponseReturnValue:\n    \"Perform a redirect to ``target``\"\n    params = request.args\n    date = params.get(\"date\")\n    if date:\n        dt = datetime.datetime.fromtimestamp(float(date), tz=datetime.timezone.utc)\n        http_dt = email.utils.format_datetime(dt, usegmt=True)\n        retry_after = str(http_dt)\n    else:\n        retry_after = \"1\"\n    target = params.get(\"target\", \"/\")\n    headers = [(\"Location\", target), (\"Retry-After\", retry_after)]\n    return await make_response(\"\", 303, headers)\n\n\n@hypercorn_app.route(\"/retry_after\")\nasync def retry_after() -> ResponseReturnValue:\n    global LAST_RETRY_AFTER_REQ\n    params = request.args\n    if datetime.datetime.now() - LAST_RETRY_AFTER_REQ < datetime.timedelta(seconds=1):\n        status = params.get(\"status\", \"429 Too Many Requests\")\n        status_code = status.split(\" \")[0]\n\n        return await make_response(\"\", status_code, [(\"Retry-After\", \"1\")])\n\n    LAST_RETRY_AFTER_REQ = datetime.datetime.now()\n    return await make_response(\"\", 200)\n\n\n@hypercorn_app.route(\"/status\")\n@pyodide_testing_app.route(\"/status\")\nasync def status() -> ResponseReturnValue:\n    values = await request.values\n    status = values.get(\"status\", \"200 OK\")\n    status_code = status.split(\" \")[0]\n    return await make_response(\"\", status_code)\n\n\n@hypercorn_app.route(\"/source_address\")\nasync def source_address() -> ResponseReturnValue:\n    \"\"\"Return the requester's IP address.\"\"\"\n    return await make_response(request.remote_addr)\n\n\n@hypercorn_app.route(\"/successful_retry\", methods=[\"GET\", \"PUT\"])\nasync def successful_retry() -> ResponseReturnValue:\n    \"\"\"First return an error and then success\n\n    It's not currently very flexible as the number of retries is hard-coded.\n    \"\"\"\n    test_name = request.headers.get(\"test-name\", None)\n    if not test_name:\n        return await make_response(\"test-name header not set\", 400)\n\n    RETRY_TEST_NAMES[test_name] += 1\n\n    if RETRY_TEST_NAMES[test_name] >= 2:\n        return await make_response(\"Retry successful!\", 200)\n    else:\n        return await make_response(\"need to keep retrying!\", 418)\n\n\n@pyodide_testing_app.after_request\ndef apply_caching(response: Response) -> ResponseReturnValue:\n    for header, value in DEFAULT_HEADERS:\n        response.headers[header] = value\n    return response\n\n\n@pyodide_testing_app.route(\"/slow\")\nasync def slow() -> ResponseReturnValue:\n    await trio.sleep(10)\n    return await make_response(\"TEN SECONDS LATER\", 200)\n\n\n@pyodide_testing_app.route(\"/bigfile\")\nasync def bigfile() -> ResponseReturnValue:\n    # great big text file, should force streaming\n    # if supported\n    bigdata = 1048576 * b\"WOOO YAY BOOYAKAH\"\n    return await make_response(bigdata, 200)\n\n\n@pyodide_testing_app.route(\"/mediumfile\")\nasync def mediumfile() -> ResponseReturnValue:\n    # quite big file\n    bigdata = 1024 * b\"WOOO YAY BOOYAKAH\"\n    return await make_response(bigdata, 200)\n\n\n@pyodide_testing_app.route(\"/upload\", methods=[\"POST\", \"OPTIONS\"])\nasync def pyodide_upload() -> ResponseReturnValue:\n    if request.method == \"OPTIONS\":\n        return await make_response(\"\", 200)\n    spare_data = await request.get_data(parse_form_data=True)\n    if len(spare_data) != 0:\n        return await make_response(\"Bad upload data\", 404)\n    files = await request.files\n    form = await request.form\n    if form[\"upload_param\"] != \"filefield\" or form[\"upload_filename\"] != \"lolcat.txt\":\n        return await make_response(\"Bad upload form values\", 404)\n    if len(files) != 1 or files.get(\"filefield\") is None:\n        return await make_response(\"Missing file in form\", 404)\n    file = files[\"filefield\"]\n    if file.filename != \"lolcat.txt\":\n        return await make_response(f\"File name incorrect {file.name}\", 404)\n    with contextlib.closing(file):\n        data = file.read().decode(\"utf-8\")\n    if data != \"I'm in ur multipart form-data, hazing a cheezburgr\":\n        return await make_response(f\"File data incorrect {data}\", 200)\n    return await make_response(\"Uploaded file correct\", 200)\n\n\n@pyodide_testing_app.route(\"/pyodide/<py_file>\")\nasync def pyodide(py_file: str) -> ResponseReturnValue:\n    file_path = Path(pyodide_testing_app.config[\"pyodide_dist_dir\"], py_file)\n    if file_path.exists():\n        mime_type, encoding = mimetypes.guess_type(file_path)\n        if not mime_type:\n            mime_type = \"text/plain\"\n        return await make_response(\n            file_path.read_bytes(), 200, [(\"Content-Type\", mime_type)]\n        )\n    else:\n        return await make_response(\"\", 404)\n\n\n@pyodide_testing_app.route(\"/wheel/dist.whl\")\nasync def wheel() -> ResponseReturnValue:\n    # serve our wheel\n    wheel_folder = Path(__file__).parent.parent / \"dist\"\n    wheels = list(wheel_folder.glob(\"*.whl\"))\n    if len(wheels) > 0:\n        wheel = wheels[0]\n        headers = [(\"Content-Disposition\", f\"inline; filename='{wheel.name}'\")]\n        resp = await make_response(wheel.read_bytes(), 200, headers)\n        return resp\n    else:\n        return await make_response(f\"NO WHEEL IN {wheel_folder}\", 404)\n"}