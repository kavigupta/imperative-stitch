{"setup.py": "from setuptools import setup\n\nif __name__ == \"__main__\":\n    setup()\n", "tools/check_changes.py": "#!/usr/bin/env python3\n\nimport sys\nfrom pathlib import Path\n\nALLOWED_SUFFIXES = [\".feature\", \".bugfix\", \".doc\", \".removal\", \".misc\"]\n\n\ndef get_root(script_path):\n    folder = script_path.resolve().parent\n    while not (folder / \".git\").exists():\n        folder = folder.parent\n        if folder == folder.anchor:\n            raise RuntimeError(\"git repo not found\")\n    return folder\n\n\ndef main(argv):\n    print('Check \"CHANGES\" folder... ', end=\"\", flush=True)\n    here = Path(argv[0])\n    root = get_root(here)\n    changes = root / \"CHANGES\"\n    failed = False\n    for fname in changes.iterdir():\n        if fname.name in (\".gitignore\", \".TEMPLATE.rst\", \"README.rst\"):\n            continue\n        if fname.suffix == \".rst\":\n            test_name = Path(fname.stem)\n        else:\n            test_name = fname\n        if test_name.suffix not in ALLOWED_SUFFIXES:\n            if not failed:\n                print(\"\")\n            print(fname, \"has illegal suffix\", file=sys.stderr)\n            failed = True\n\n    if failed:\n        print(\"\", file=sys.stderr)\n        print(\n            \"Allowed suffixes are:\",\n            ALLOWED_SUFFIXES + [suff + \".rst\" for suff in ALLOWED_SUFFIXES],\n            file=sys.stderr,\n        )\n        print(\"\", file=sys.stderr)\n    else:\n        print(\"OK\")\n\n    return int(failed)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n", "docs/conf.py": "#!/usr/bin/env python3\n#\n# aiosignal documentation build configuration file, created by\n# sphinx-quickstart on Wed Mar  5 12:35:35 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport os\nimport re\n\n_docs_path = os.path.dirname(__file__)\n_version_path = os.path.abspath(\n    os.path.join(_docs_path, \"..\", \"aiosignal\", \"__init__.py\")\n)\nwith open(_version_path, encoding=\"latin1\") as fp:\n    try:\n        _version_info = re.search(\n            r'^__version__ = \"'\n            r\"(?P<major>\\d+)\"\n            r\"\\.(?P<minor>\\d+)\"\n            r\"\\.(?P<patch>\\d+)\"\n            r'(?P<tag>.*)?\"$',\n            fp.read(),\n            re.M,\n        ).groupdict()\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinxcontrib.asyncio\",\n]\n\n\ntry:\n    import sphinxcontrib.spelling  # noqa\n\n    extensions.append(\"sphinxcontrib.spelling\")\nexcept ImportError:\n    pass\n\n\nintersphinx_mapping = {\n    \"python\": (\"http://docs.python.org/3\", None),\n    \"aiohttp\": (\"https://docs.aiohttp.org/en/stable/\", None),\n    \"frozenlist\": (\"https://frozenlist.readthedocs.io/en/latest/\", None),\n}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"aiosignal\"\ncopyright = \"2013-2019, aiosignal contributors\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \"{major}.{minor}\".format(**_version_info)\n# The full version, including alpha/beta/rc tags.\nrelease = \"{major}.{minor}.{patch}{tag}\".format(**_version_info)\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\n# pygments_style = 'sphinx'\n\n# The default language to highlight source code in.\nhighlight_language = \"python3\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"aiohttp_theme\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \"logo\": None,\n    \"description\": \"aiosignal: a list of registered asynchronous callbacks.\",\n    \"canonical_url\": \"http://aiosignal.readthedocs.io/en/stable/\",\n    \"github_user\": \"aio-libs\",\n    \"github_repo\": \"aiosignal\",\n    \"github_button\": True,\n    \"github_type\": \"star\",\n    \"github_banner\": True,\n    \"badges\": [\n        {\n            \"image\": \"https://github.com/aio-libs/aiosignal/workflows/CI/badge.svg\",\n            \"target\": (\n                \"https://github.com/aio-libs/aiosignal/\" \"actions?query=workflow%3ACI\"\n            ),\n            \"height\": \"20\",\n            \"alt\": \"GitHub CI status for master branch\",\n        },\n        {\n            \"image\": (\n                \"https://codecov.io/github/aio-libs/aiosignal/\"\n                \"coverage.svg?branch=master\"\n            ),\n            \"target\": \"https://codecov.io/github/aio-libs/aiosignal\",\n            \"height\": \"20\",\n            \"alt\": \"Code coverage status\",\n        },\n        {\n            \"image\": \"https://badge.fury.io/py/aiosignal.svg\",\n            \"target\": \"https://badge.fury.io/py/aiosignal\",\n            \"height\": \"20\",\n            \"alt\": \"Latest PyPI package version\",\n        },\n        {\n            \"image\": (\n                \"https://img.shields.io/discourse/\"\n                \"topics?server=https%3A%2F%2Faio-libs.discourse.group%2F\"\n            ),\n            \"target\": \"https://aio-libs.discourse.group/\",\n            \"height\": \"20\",\n            \"alt\": \"Discourse group for io-libs\",\n        },\n        {\n            \"image\": \"https://badges.gitter.im/Join%20Chat.svg\",\n            \"target\": \"https://gitter.im/aio-libs/Lobby\",\n            \"height\": \"20\",\n            \"alt\": \"Chat on Gitter\",\n        },\n    ],\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = [alabaster.get_path()]\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = 'aiosignal-icon.svg'\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = 'favicon.ico'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = []\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n# html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \"**\": [\n        \"about.html\",\n        \"navigation.html\",\n        \"searchbox.html\",\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"aiosignaldoc\"\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    # 'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        \"index\",\n        \"aiosignal.tex\",\n        \"aiosignal Documentation\",\n        \"aiosignal contributors\",\n        \"manual\",\n    ),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", \"aiosignal\", \"aiosignal Documentation\", [\"aiosignal\"], 1)]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        \"aiosignal\",\n        \"aiosignal Documentation\",\n        \"aiosignal contributors\",\n        \"aiosignal\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n", "tests/test_signals.py": "import re\nfrom unittest import mock\n\nimport pytest\n\nfrom aiosignal import Signal\n\n\nclass Owner:\n    def __repr__(self) -> str:\n        return \"<Owner 0xdeadbeef>\"\n\n\n@pytest.fixture\ndef owner() -> Owner:\n    return Owner()\n\n\n@pytest.mark.asyncio\nasync def test_add_signal_handler_not_a_callable(owner: Owner) -> None:\n    callback = True\n    signal = Signal(owner)\n    signal.append(callback)\n    signal.freeze()\n    with pytest.raises(TypeError):\n        await signal.send()\n\n\n@pytest.mark.asyncio\nasync def test_function_signal_dispatch_kwargs(owner: Owner) -> None:\n    signal = Signal(owner)\n    kwargs = {\"foo\": 1, \"bar\": 2}\n\n    callback_mock = mock.Mock()\n\n    async def callback(**kwargs):\n        callback_mock(**kwargs)\n\n    signal.append(callback)\n    signal.freeze()\n\n    await signal.send(**kwargs)\n    callback_mock.assert_called_once_with(**kwargs)\n\n\n@pytest.mark.asyncio\nasync def test_function_signal_dispatch_args_kwargs(owner: Owner) -> None:\n    signal = Signal(owner)\n    args = {\"a\", \"b\"}\n    kwargs = {\"foo\": 1, \"bar\": 2}\n\n    callback_mock = mock.Mock()\n\n    async def callback(*args, **kwargs):\n        callback_mock(*args, **kwargs)\n\n    signal.append(callback)\n    signal.freeze()\n\n    await signal.send(*args, **kwargs)\n    callback_mock.assert_called_once_with(*args, **kwargs)\n\n\n@pytest.mark.asyncio\nasync def test_non_coroutine(owner: Owner) -> None:\n    signal = Signal(owner)\n    kwargs = {\"foo\": 1, \"bar\": 2}\n\n    callback = mock.Mock()\n\n    signal.append(callback)\n    signal.freeze()\n\n    with pytest.raises(TypeError):\n        await signal.send(**kwargs)\n\n\ndef test_setitem(owner: Owner) -> None:\n    signal = Signal(owner)\n    m1 = mock.Mock()\n    signal.append(m1)\n    assert signal[0] is m1\n    m2 = mock.Mock()\n    signal[0] = m2\n    assert signal[0] is m2\n\n\ndef test_delitem(owner: Owner) -> None:\n    signal = Signal(owner)\n    m1 = mock.Mock()\n    signal.append(m1)\n    assert len(signal) == 1\n    del signal[0]\n    assert len(signal) == 0\n\n\ndef test_cannot_append_to_frozen_signal(owner: Owner) -> None:\n    signal = Signal(owner)\n    m1 = mock.Mock()\n    m2 = mock.Mock()\n    signal.append(m1)\n    signal.freeze()\n    with pytest.raises(RuntimeError):\n        signal.append(m2)\n\n    assert list(signal) == [m1]\n\n\ndef test_cannot_setitem_in_frozen_signal(owner: Owner) -> None:\n    signal = Signal(owner)\n    m1 = mock.Mock()\n    m2 = mock.Mock()\n    signal.append(m1)\n    signal.freeze()\n    with pytest.raises(RuntimeError):\n        signal[0] = m2\n\n    assert list(signal) == [m1]\n\n\ndef test_cannot_delitem_in_frozen_signal(owner: Owner) -> None:\n    signal = Signal(owner)\n    m1 = mock.Mock()\n    signal.append(m1)\n    signal.freeze()\n    with pytest.raises(RuntimeError):\n        del signal[0]\n\n    assert list(signal) == [m1]\n\n\n@pytest.mark.asyncio\nasync def test_cannot_send_non_frozen_signal(owner: Owner) -> None:\n    signal = Signal(owner)\n\n    callback_mock = mock.Mock()\n\n    async def callback(**kwargs):\n        callback_mock(**kwargs)\n\n    signal.append(callback)\n\n    with pytest.raises(RuntimeError):\n        await signal.send()\n\n    assert not callback_mock.called\n\n\ndef test_repr(owner: Owner) -> None:\n    signal = Signal(owner)\n\n    signal.append(mock.Mock(__repr__=lambda *a: \"<callback>\"))\n\n    assert (\n        re.match(\n            r\"<Signal owner=<Owner 0xdeadbeef>, frozen=False, \" r\"\\[<callback>\\]>\",\n            repr(signal),\n        )\n        is not None\n    )\n", "tests/conftest.py": "", "aiosignal/__init__.py": "from frozenlist import FrozenList\n\n__version__ = \"1.3.1\"\n\n__all__ = (\"Signal\",)\n\n\nclass Signal(FrozenList):\n    \"\"\"Coroutine-based signal implementation.\n\n    To connect a callback to a signal, use any list method.\n\n    Signals are fired using the send() coroutine, which takes named\n    arguments.\n    \"\"\"\n\n    __slots__ = (\"_owner\",)\n\n    def __init__(self, owner):\n        super().__init__()\n        self._owner = owner\n\n    def __repr__(self):\n        return \"<Signal owner={}, frozen={}, {!r}>\".format(\n            self._owner, self.frozen, list(self)\n        )\n\n    async def send(self, *args, **kwargs):\n        \"\"\"\n        Sends data to all registered receivers.\n        \"\"\"\n        if not self.frozen:\n            raise RuntimeError(\"Cannot send non-frozen signal.\")\n\n        for receiver in self:\n            await receiver(*args, **kwargs)  # type: ignore\n"}