{"setup.py": "# encoding: utf-8\nfrom distutils.core import setup\nimport os\nimport re\nimport sys\n\nif any(a == 'bdist_wheel' for a in sys.argv):\n    from setuptools import setup\n\nwith open(os.path.join(os.path.dirname(__file__), 'pexpect', '__init__.py'), 'r') as f:\n    for line in f:\n        version_match = re.search(r\"__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", line)\n        if version_match:\n            version = version_match.group(1)\n            break\n    else:\n        raise Exception(\"couldn't find version number\")\n\nlong_description = \"\"\"\nPexpect is a pure Python module for spawning child applications; controlling\nthem; and responding to expected patterns in their output. Pexpect works like\nDon Libes' Expect. Pexpect allows your script to spawn a child application and\ncontrol it as if a human were typing commands.\n\nPexpect can be used for automating interactive applications such as ssh, ftp,\npasswd, telnet, etc. It can be used to automate setup scripts for duplicating\nsoftware package installations on different servers. It can be used for\nautomated software testing. Pexpect is in the spirit of Don Libes' Expect, but\nPexpect is pure Python.\n\nThe main features of Pexpect require the pty module in the Python standard\nlibrary, which is only available on Unix-like systems. Some features\u2014waiting\nfor patterns from file descriptors or subprocesses\u2014are also available on\nWindows.\n\"\"\"\n\nsetup(name='pexpect',\n    version=version,\n    packages=['pexpect'],\n    package_data={'pexpect': ['bashrc.sh']},\n    description='Pexpect allows easy control of interactive console applications.',\n    long_description=long_description,\n    author='Noah Spurrier; Thomas Kluyver; Jeff Quast',\n    author_email='noah@noah.org, thomas@kluyver.me.uk, contact@jeffquast.com',\n    url='https://pexpect.readthedocs.io/',\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/pexpect/pexpect/issues\",\n        \"Documentation\": \"https://pexpect.readthedocs.io/\",\n        \"Source Code\": \"https://github.com/pexpect/pexpect\",\n        \"History\": \"https://pexpect.readthedocs.io/en/stable/history.html\",\n    },\n    license='ISC license',\n    platforms='UNIX',\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'Intended Audience :: System Administrators',\n        'License :: OSI Approved :: ISC License (ISCL)',\n        'Operating System :: POSIX',\n        'Operating System :: MacOS :: MacOS X',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Topic :: Software Development',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: Software Development :: Quality Assurance',\n        'Topic :: Software Development :: Testing',\n        'Topic :: System',\n        'Topic :: System :: Archiving :: Packaging',\n        'Topic :: System :: Installation/Setup',\n        'Topic :: System :: Shells',\n        'Topic :: System :: Software Distribution',\n        'Topic :: Terminals',\n    ],\n    install_requires=['ptyprocess>=0.5'],\n)\n", "tools/display-sighandlers.py": "#!/usr/bin/env python\n# Displays all signals, their values, and their handlers.\nfrom __future__ import print_function\nimport signal\nFMT = '{name:<10} {value:<5} {description}'\n\n# header\nprint(FMT.format(name='name', value='value', description='description'))\nprint('-' * (33))\n\nfor name, value in [(signal_name, getattr(signal, signal_name))\n                    for signal_name in dir(signal)\n                    if signal_name.startswith('SIG')\n                    and not signal_name.startswith('SIG_')]:\n    try:\n        handler = signal.getsignal(value)\n    except ValueError:\n        # FreeBSD: signal number out of range\n        handler = 'out of range'\n    description = {\n        signal.SIG_IGN: \"ignored(SIG_IGN)\",\n        signal.SIG_DFL: \"default(SIG_DFL)\"\n    }.get(handler, handler)\n    print(FMT.format(name=name, value=value, description=description))\n", "tools/display-terminalinfo.py": "#!/usr/bin/env python\n\"\"\" Display known information about our terminal. \"\"\"\nfrom __future__ import print_function\nimport termios\nimport locale\nimport sys\nimport os\n\nBITMAP_IFLAG = {\n    'IGNBRK': 'ignore BREAK condition',\n    'BRKINT': 'map BREAK to SIGINTR',\n    'IGNPAR': 'ignore (discard) parity errors',\n    'PARMRK': 'mark parity and framing errors',\n    'INPCK': 'enable checking of parity errors',\n    'ISTRIP': 'strip 8th bit off chars',\n    'INLCR': 'map NL into CR',\n    'IGNCR': 'ignore CR',\n    'ICRNL': 'map CR to NL (ala CRMOD)',\n    'IXON': 'enable output flow control',\n    'IXOFF': 'enable input flow control',\n    'IXANY': 'any char will restart after stop',\n    'IMAXBEL': 'ring bell on input queue full',\n    'IUCLC': 'translate upper case to lower case',\n}\n\nBITMAP_OFLAG = {\n    'OPOST': 'enable following output processing',\n    'ONLCR': 'map NL to CR-NL (ala CRMOD)',\n    'OXTABS': 'expand tabs to spaces',\n    'ONOEOT': 'discard EOT\\'s `^D\\' on output)',\n    'OCRNL': 'map CR to NL',\n    'OLCUC': 'translate lower case to upper case',\n    'ONOCR': 'No CR output at column 0',\n    'ONLRET': 'NL performs CR function',\n}\n\nBITMAP_CFLAG = {\n    'CSIZE': 'character size mask',\n    'CS5': '5 bits (pseudo)',\n    'CS6': '6 bits',\n    'CS7': '7 bits',\n    'CS8': '8 bits',\n    'CSTOPB': 'send 2 stop bits',\n    'CREAD': 'enable receiver',\n    'PARENB': 'parity enable',\n    'PARODD': 'odd parity, else even',\n    'HUPCL': 'hang up on last close',\n    'CLOCAL': 'ignore modem status lines',\n    'CCTS_OFLOW': 'CTS flow control of output',\n    'CRTSCTS': 'same as CCTS_OFLOW',\n    'CRTS_IFLOW': 'RTS flow control of input',\n    'MDMBUF': 'flow control output via Carrier',\n}\n\nBITMAP_LFLAG = {\n    'ECHOKE': 'visual erase for line kill',\n    'ECHOE': 'visually erase chars',\n    'ECHO': 'enable echoing',\n    'ECHONL': 'echo NL even if ECHO is off',\n    'ECHOPRT': 'visual erase mode for hardcopy',\n    'ECHOCTL': 'echo control chars as ^(Char)',\n    'ISIG': 'enable signals INTR, QUIT, [D]SUSP',\n    'ICANON': 'canonicalize input lines',\n    'ALTWERASE': 'use alternate WERASE algorithm',\n    'IEXTEN': 'enable DISCARD and LNEXT',\n    'EXTPROC': 'external processing',\n    'TOSTOP': 'stop background jobs from output',\n    'FLUSHO': 'output being flushed (state)',\n    'NOKERNINFO': 'no kernel output from VSTATUS',\n    'PENDIN': 'XXX retype pending input (state)',\n    'NOFLSH': 'don\\'t flush after interrupt',\n}\n\nCTLCHAR_INDEX = {\n    'VEOF': 'EOF',\n    'VEOL': 'EOL',\n    'VEOL2': 'EOL2',\n    'VERASE': 'ERASE',\n    'VWERASE': 'WERASE',\n    'VKILL': 'KILL',\n    'VREPRINT': 'REPRINT',\n    'VINTR': 'INTR',\n    'VQUIT': 'QUIT',\n    'VSUSP': 'SUSP',\n    'VDSUSP': 'DSUSP',\n    'VSTART': 'START',\n    'VSTOP': 'STOP',\n    'VLNEXT': 'LNEXT',\n    'VDISCARD': 'DISCARD',\n    'VMIN': '---',\n    'VTIME': '---',\n    'VSTATUS': 'STATUS',\n}\n\n\ndef display_bitmask(kind, bitmap, value):\n    \"\"\" Display all matching bitmask values for ``value`` given ``bitmap``. \"\"\"\n    col1_width = max(map(len, list(bitmap.keys()) + [kind]))\n    col2_width = 7\n    FMT = '{name:>{col1_width}} {value:>{col2_width}}   {description}'\n    print(FMT.format(name=kind,\n                     value='Value',\n                     description='Description',\n                     col1_width=col1_width,\n                     col2_width=col2_width))\n    print('{0} {1}   {2}'.format('-' * col1_width,\n                                 '-' * col2_width,\n                                 '-' * max(map(len, bitmap.values()))))\n    for flag_name, description in bitmap.items():\n        try:\n            bitmask = getattr(termios, flag_name)\n            bit_val = 'on' if bool(value & bitmask) else 'off'\n        except AttributeError:\n            bit_val = 'undef'\n        print(FMT.format(name=flag_name,\n                         value=bit_val,\n                         description=description,\n                         col1_width=col1_width,\n                         col2_width=col2_width))\n    print()\n\n\ndef display_ctl_chars(index, cc):\n    \"\"\" Display all control character indicies, names, and values. \"\"\"\n    title = 'Special Character'\n    col1_width = len(title)\n    col2_width = max(map(len, index.values()))\n    FMT = '{idx:<{col1_width}}   {name:<{col2_width}} {value}'\n    print('Special line Characters'.center(40).rstrip())\n    print(FMT.format(idx='Index',\n                     name='Name',\n                     value='Value',\n                     col1_width=col1_width,\n                     col2_width=col2_width))\n    print('{0}   {1} {2}'.format('-' * col1_width,\n                                 '-' * col2_width,\n                                 '-' * 10))\n    for index_name, name in index.items():\n        try:\n            index = getattr(termios, index_name)\n            value = cc[index]\n            if value == b'\\xff':\n                value = '_POSIX_VDISABLE'\n            else:\n                value = repr(value)\n        except AttributeError:\n            value = 'undef'\n        print(FMT.format(idx=index_name,\n                         name=name,\n                         value=value,\n                         col1_width=col1_width,\n                         col2_width=col2_width))\n    print()\n\n\ndef display_conf(kind, names, getter):\n    col1_width = max(map(len, names))\n    FMT = '{name:>{col1_width}}   {value}'\n    print(FMT.format(name=kind,\n                     value='value',\n                     col1_width=col1_width))\n    print('{0} {1}'.format('-' * col1_width, '-' * 27))\n    for name in names:\n        try:\n            value = getter(name)\n        except OSError as err:\n            value = err\n        print(FMT.format(name=name, value=value, col1_width=col1_width))\n    print()\n\n\ndef main():\n    fd = sys.stdin.fileno()\n    locale.setlocale(locale.LC_ALL, '')\n    encoding = locale.getpreferredencoding()\n\n    print('os.isatty({0}) => {1}'.format(fd, os.isatty(fd)))\n    print('locale.getpreferredencoding() => {0}'.format(encoding))\n\n    display_conf(kind='pathconf',\n                 names=os.pathconf_names,\n                 getter=lambda name: os.fpathconf(fd, name))\n\n    try:\n        (iflag, oflag, cflag, lflag, ispeed, ospeed, cc\n         ) = termios.tcgetattr(fd)\n    except termios.error as err:\n        print('stdin is not a typewriter: {0}'.format(err))\n    else:\n        display_bitmask(kind='Input Mode',\n                        bitmap=BITMAP_IFLAG,\n                        value=iflag)\n        display_bitmask(kind='Output Mode',\n                        bitmap=BITMAP_OFLAG,\n                        value=oflag)\n        display_bitmask(kind='Control Mode',\n                        bitmap=BITMAP_CFLAG,\n                        value=cflag)\n        display_bitmask(kind='Local Mode',\n                        bitmap=BITMAP_LFLAG,\n                        value=lflag)\n        display_ctl_chars(index=CTLCHAR_INDEX,\n                          cc=cc)\n        try:\n            print('os.ttyname({0}) => {1}'.format(fd, os.ttyname(fd)))\n            print('os.ctermid() => {0}'.format(os.ctermid()))\n        except OSError as e:\n            # Travis fails on ttyname with errno 0 'Error'.\n            print(\"Error inspecting TTY: {0}\".format(e))\n\nif __name__ == '__main__':\n    main()\n", "tools/display-fpathconf.py": "#!/usr/bin/env python\n\"\"\"Displays os.fpathconf values related to terminals. \"\"\"\nfrom __future__ import print_function\nimport sys\nimport os\n\n\ndef display_fpathconf():\n    DISP_VALUES = (\n        ('PC_MAX_CANON', ('Max no. of bytes in a '\n                          'terminal canonical input line.')),\n        ('PC_MAX_INPUT', ('Max no. of bytes for which '\n                          'space is available in a terminal input queue.')),\n        ('PC_PIPE_BUF', ('Max no. of bytes which will '\n                         'be written atomically to a pipe.')),\n        ('PC_VDISABLE', 'Terminal character disabling value.')\n    )\n    FMT = '{name:<13} {value:<5} {description}'\n\n    # column header\n    print(FMT.format(name='name', value='value', description='description'))\n    print(FMT.format(name=('-' * 13), value=('-' * 5), description=('-' * 11)))\n\n    fd = sys.stdin.fileno()\n    for name, description in DISP_VALUES:\n        key = os.pathconf_names.get(name, None)\n        if key is None:\n            value = 'UNDEF'\n        else:\n            try:\n                value = os.fpathconf(fd, name)\n            except OSError as err:\n                value = 'OSErrno {0.errno}'.format(err)\n        if name == 'PC_VDISABLE':\n            value = hex(value)\n        print(FMT.format(name=name, value=value, description=description))\n    print()\n\n\nif __name__ == '__main__':\n    display_fpathconf()\n", "tools/display-maxcanon.py": "#!/usr/bin/env python\n\"\"\"\nThis tool uses pexpect to test expected Canonical mode length.\n\nAll systems use the value of MAX_CANON which can be found using\nfpathconf(3) value PC_MAX_CANON -- with the exception of Linux\nand FreeBSD.\n\nLinux, though defining a value of 255, actually honors the value\nof 4096 from linux kernel include file tty.h definition\nN_TTY_BUF_SIZE.\n\nLinux also does not honor IMAXBEL. termios(3) states, \"Linux does not\nimplement this bit, and acts as if it is always set.\" Although these\ntests ensure it is enabled, this is a non-op for Linux.\n\nFreeBSD supports neither, and instead uses a fraction (1/5) of the tty\nspeed which is always 9600.  Therefor, the maximum limited input line\nlength is 9600 / 5 = 1920.\n\nThese tests only ensure the correctness of the behavior described by\nthe sendline() docstring -- the values listed there, and above should\nbe equal to the output of the given OS described, but no promises!\n\"\"\"\n# std import\nfrom __future__ import print_function\nimport sys\nimport os\n\n\ndef detect_maxcanon():\n    import pexpect\n    bashrc = os.path.join(\n        # re-use pexpect/replwrap.py's bashrc file,\n        os.path.dirname(__file__), os.path.pardir, 'pexpect', 'bashrc.sh')\n\n    child = pexpect.spawn('bash', ['--rcfile', bashrc],\n                          echo=True, encoding='utf8', timeout=3)\n\n    child.sendline(u'echo -n READY_; echo GO')\n    child.expect_exact(u'READY_GO')\n\n    child.sendline(u'stty icanon imaxbel erase ^H; echo -n retval: $?')\n    child.expect_exact(u'retval: 0')\n\n    child.sendline(u'echo -n GO_; echo AGAIN')\n    child.expect_exact(u'GO_AGAIN')\n    child.sendline(u'cat')\n\n    child.delaybeforesend = 0\n\n    column, blocksize = 0, 64\n    ch_marker = u'_'\n\n    print('auto-detecting MAX_CANON: ', end='')\n    sys.stdout.flush()\n\n    while True:\n        child.send(ch_marker * blocksize)\n        result = child.expect([ch_marker * blocksize, u'\\a'])\n        if result == 0:\n            # entire block fit without emitting bel\n            column += blocksize\n        elif result == 1:\n            # an '\\a' was emitted, count the number of ch_markers\n            # found since last blocksize, determining our MAX_CANON\n            column += child.before.count(ch_marker)\n            break\n    print(column)\n\nif __name__ == '__main__':\n    try:\n        detect_maxcanon()\n    except ImportError:\n        # we'd like to use this with CI -- but until we integrate\n        # with tox, we can't determine a period in testing when\n        # the pexpect module has been installed \n        print('warning: pexpect not in module path, MAX_CANON '\n              'could not be determined by systems test.',\n              file=sys.stderr)\n", "pexpect/run.py": "import sys\nimport types\n\nfrom .exceptions import EOF, TIMEOUT\nfrom .pty_spawn import spawn\n\ndef run(command, timeout=30, withexitstatus=False, events=None,\n        extra_args=None, logfile=None, cwd=None, env=None, **kwargs):\n\n    '''\n    This function runs the given command; waits for it to finish; then\n    returns all output as a string. STDERR is included in output. If the full\n    path to the command is not given then the path is searched.\n\n    Note that lines are terminated by CR/LF (\\\\r\\\\n) combination even on\n    UNIX-like systems because this is the standard for pseudottys. If you set\n    'withexitstatus' to true, then run will return a tuple of (command_output,\n    exitstatus). If 'withexitstatus' is false then this returns just\n    command_output.\n\n    The run() function can often be used instead of creating a spawn instance.\n    For example, the following code uses spawn::\n\n        from pexpect import *\n        child = spawn('scp foo user@example.com:.')\n        child.expect('(?i)password')\n        child.sendline(mypassword)\n\n    The previous code can be replace with the following::\n\n        from pexpect import *\n        run('scp foo user@example.com:.', events={'(?i)password': mypassword})\n\n    **Examples**\n\n    Start the apache daemon on the local machine::\n\n        from pexpect import *\n        run(\"/usr/local/apache/bin/apachectl start\")\n\n    Check in a file using SVN::\n\n        from pexpect import *\n        run(\"svn ci -m 'automatic commit' my_file.py\")\n\n    Run a command and capture exit status::\n\n        from pexpect import *\n        (command_output, exitstatus) = run('ls -l /bin', withexitstatus=1)\n\n    The following will run SSH and execute 'ls -l' on the remote machine. The\n    password 'secret' will be sent if the '(?i)password' pattern is ever seen::\n\n        run(\"ssh username@machine.example.com 'ls -l'\",\n            events={'(?i)password':'secret\\\\n'})\n\n    This will start mencoder to rip a video from DVD. This will also display\n    progress ticks every 5 seconds as it runs. For example::\n\n        from pexpect import *\n        def print_ticks(d):\n            print d['event_count'],\n        run(\"mencoder dvd://1 -o video.avi -oac copy -ovc copy\",\n            events={TIMEOUT:print_ticks}, timeout=5)\n\n    The 'events' argument should be either a dictionary or a tuple list that\n    contains patterns and responses. Whenever one of the patterns is seen\n    in the command output, run() will send the associated response string.\n    So, run() in the above example can be also written as::\n\n        run(\"mencoder dvd://1 -o video.avi -oac copy -ovc copy\",\n            events=[(TIMEOUT,print_ticks)], timeout=5)\n\n    Use a tuple list for events if the command output requires a delicate\n    control over what pattern should be matched, since the tuple list is passed\n    to pexpect() as its pattern list, with the order of patterns preserved.\n\n    Note that you should put newlines in your string if Enter is necessary.\n\n    Like the example above, the responses may also contain a callback, either\n    a function or method.  It should accept a dictionary value as an argument.\n    The dictionary contains all the locals from the run() function, so you can\n    access the child spawn object or any other variable defined in run()\n    (event_count, child, and extra_args are the most useful). A callback may\n    return True to stop the current run process.  Otherwise run() continues\n    until the next event. A callback may also return a string which will be\n    sent to the child. 'extra_args' is not used by directly run(). It provides\n    a way to pass data to a callback function through run() through the locals\n    dictionary passed to a callback.\n\n    Like :class:`spawn`, passing *encoding* will make it work with unicode\n    instead of bytes. You can pass *codec_errors* to control how errors in\n    encoding and decoding are handled.\n    '''\n    if timeout == -1:\n        child = spawn(command, maxread=2000, logfile=logfile, cwd=cwd, env=env,\n                        **kwargs)\n    else:\n        child = spawn(command, timeout=timeout, maxread=2000, logfile=logfile,\n                cwd=cwd, env=env, **kwargs)\n    if isinstance(events, list):\n        patterns= [x for x,y in events]\n        responses = [y for x,y in events]\n    elif isinstance(events, dict):\n        patterns = list(events.keys())\n        responses = list(events.values())\n    else:\n        # This assumes EOF or TIMEOUT will eventually cause run to terminate.\n        patterns = None\n        responses = None\n    child_result_list = []\n    event_count = 0\n    while True:\n        try:\n            index = child.expect(patterns)\n            if isinstance(child.after, child.allowed_string_types):\n                child_result_list.append(child.before + child.after)\n            else:\n                # child.after may have been a TIMEOUT or EOF,\n                # which we don't want appended to the list.\n                child_result_list.append(child.before)\n            if isinstance(responses[index], child.allowed_string_types):\n                child.send(responses[index])\n            elif (isinstance(responses[index], types.FunctionType) or\n                  isinstance(responses[index], types.MethodType)):\n                callback_result = responses[index](locals())\n                sys.stdout.flush()\n                if isinstance(callback_result, child.allowed_string_types):\n                    child.send(callback_result)\n                elif callback_result:\n                    break\n            else:\n                raise TypeError(\"parameter `event' at index {index} must be \"\n                                \"a string, method, or function: {value!r}\"\n                                .format(index=index, value=responses[index]))\n            event_count = event_count + 1\n        except TIMEOUT:\n            child_result_list.append(child.before)\n            break\n        except EOF:\n            child_result_list.append(child.before)\n            break\n    child_result = child.string_type().join(child_result_list)\n    if withexitstatus:\n        child.close()\n        return (child_result, child.exitstatus)\n    else:\n        return child_result\n\ndef runu(command, timeout=30, withexitstatus=False, events=None,\n        extra_args=None, logfile=None, cwd=None, env=None, **kwargs):\n    \"\"\"Deprecated: pass encoding to run() instead.\n    \"\"\"\n    kwargs.setdefault('encoding', 'utf-8')\n    return run(command, timeout=timeout, withexitstatus=withexitstatus,\n                events=events, extra_args=extra_args, logfile=logfile, cwd=cwd,\n                env=env, **kwargs)\n", "pexpect/_async.py": "\"\"\"Facade that provides coroutines implementation pertinent to running Py version.\n\nPython 3.5 introduced the async def/await syntax keyword.\nWith later versions coroutines and methods to get the running asyncio loop are\nbeing deprecated, not supported anymore.\n\nFor Python versions later than 3.6, coroutines and objects that are defined via\n``async def``/``await`` keywords are imported.\n\nHere the code is just imported, to provide the same interface to older code.\n\"\"\"\n# pylint: disable=unused-import\n# flake8: noqa: F401\nfrom sys import version_info as py_version_info\n\n# this assumes async def/await are more stable\nif py_version_info >= (3, 6):\n    from pexpect._async_w_await import (\n        PatternWaiter,\n        expect_async,\n        repl_run_command_async,\n    )\nelse:\n    from pexpect._async_pre_await import (\n        PatternWaiter,\n        expect_async,\n        repl_run_command_async,\n    )\n", "pexpect/FSM.py": "#!/usr/bin/env python\n\n'''This module implements a Finite State Machine (FSM). In addition to state\nthis FSM also maintains a user defined \"memory\". So this FSM can be used as a\nPush-down Automata (PDA) since a PDA is a FSM + memory.\n\nThe following describes how the FSM works, but you will probably also need to\nsee the example function to understand how the FSM is used in practice.\n\nYou define an FSM by building tables of transitions. For a given input symbol\nthe process() method uses these tables to decide what action to call and what\nthe next state will be. The FSM has a table of transitions that associate:\n\n        (input_symbol, current_state) --> (action, next_state)\n\nWhere \"action\" is a function you define. The symbols and states can be any\nobjects. You use the add_transition() and add_transition_list() methods to add\nto the transition table. The FSM also has a table of transitions that\nassociate:\n\n        (current_state) --> (action, next_state)\n\nYou use the add_transition_any() method to add to this transition table. The\nFSM also has one default transition that is not associated with any specific\ninput_symbol or state. You use the set_default_transition() method to set the\ndefault transition.\n\nWhen an action function is called it is passed a reference to the FSM. The\naction function may then access attributes of the FSM such as input_symbol,\ncurrent_state, or \"memory\". The \"memory\" attribute can be any object that you\nwant to pass along to the action functions. It is not used by the FSM itself.\nFor parsing you would typically pass a list to be used as a stack.\n\nThe processing sequence is as follows. The process() method is given an\ninput_symbol to process. The FSM will search the table of transitions that\nassociate:\n\n        (input_symbol, current_state) --> (action, next_state)\n\nIf the pair (input_symbol, current_state) is found then process() will call the\nassociated action function and then set the current state to the next_state.\n\nIf the FSM cannot find a match for (input_symbol, current_state) it will then\nsearch the table of transitions that associate:\n\n        (current_state) --> (action, next_state)\n\nIf the current_state is found then the process() method will call the\nassociated action function and then set the current state to the next_state.\nNotice that this table lacks an input_symbol. It lets you define transitions\nfor a current_state and ANY input_symbol. Hence, it is called the \"any\" table.\nRemember, it is always checked after first searching the table for a specific\n(input_symbol, current_state).\n\nFor the case where the FSM did not match either of the previous two cases the\nFSM will try to use the default transition. If the default transition is\ndefined then the process() method will call the associated action function and\nthen set the current state to the next_state. This lets you define a default\ntransition as a catch-all case. You can think of it as an exception handler.\nThere can be only one default transition.\n\nFinally, if none of the previous cases are defined for an input_symbol and\ncurrent_state then the FSM will raise an exception. This may be desirable, but\nyou can always prevent this just by defining a default transition.\n\nNoah Spurrier 20020822\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nclass ExceptionFSM(Exception):\n\n    '''This is the FSM Exception class.'''\n\n    def __init__(self, value):\n        self.value = value\n\n    def __str__(self):\n        return 'ExceptionFSM: ' + str(self.value)\n\nclass FSM:\n\n    '''This is a Finite State Machine (FSM).\n    '''\n\n    def __init__(self, initial_state, memory=None):\n\n        '''This creates the FSM. You set the initial state here. The \"memory\"\n        attribute is any object that you want to pass along to the action\n        functions. It is not used by the FSM. For parsing you would typically\n        pass a list to be used as a stack. '''\n\n        # Map (input_symbol, current_state) --> (action, next_state).\n        self.state_transitions = {}\n        # Map (current_state) --> (action, next_state).\n        self.state_transitions_any = {}\n        self.default_transition = None\n\n        self.input_symbol = None\n        self.initial_state = initial_state\n        self.current_state = self.initial_state\n        self.next_state = None\n        self.action = None\n        self.memory = memory\n\n    def reset (self):\n\n        '''This sets the current_state to the initial_state and sets\n        input_symbol to None. The initial state was set by the constructor\n        __init__(). '''\n\n        self.current_state = self.initial_state\n        self.input_symbol = None\n\n    def add_transition (self, input_symbol, state, action=None, next_state=None):\n\n        '''This adds a transition that associates:\n\n                (input_symbol, current_state) --> (action, next_state)\n\n        The action may be set to None in which case the process() method will\n        ignore the action and only set the next_state. The next_state may be\n        set to None in which case the current state will be unchanged.\n\n        You can also set transitions for a list of symbols by using\n        add_transition_list(). '''\n\n        if next_state is None:\n            next_state = state\n        self.state_transitions[(input_symbol, state)] = (action, next_state)\n\n    def add_transition_list (self, list_input_symbols, state, action=None, next_state=None):\n\n        '''This adds the same transition for a list of input symbols.\n        You can pass a list or a string. Note that it is handy to use\n        string.digits, string.whitespace, string.letters, etc. to add\n        transitions that match character classes.\n\n        The action may be set to None in which case the process() method will\n        ignore the action and only set the next_state. The next_state may be\n        set to None in which case the current state will be unchanged. '''\n\n        if next_state is None:\n            next_state = state\n        for input_symbol in list_input_symbols:\n            self.add_transition (input_symbol, state, action, next_state)\n\n    def add_transition_any (self, state, action=None, next_state=None):\n\n        '''This adds a transition that associates:\n\n                (current_state) --> (action, next_state)\n\n        That is, any input symbol will match the current state.\n        The process() method checks the \"any\" state associations after it first\n        checks for an exact match of (input_symbol, current_state).\n\n        The action may be set to None in which case the process() method will\n        ignore the action and only set the next_state. The next_state may be\n        set to None in which case the current state will be unchanged. '''\n\n        if next_state is None:\n            next_state = state\n        self.state_transitions_any [state] = (action, next_state)\n\n    def set_default_transition (self, action, next_state):\n\n        '''This sets the default transition. This defines an action and\n        next_state if the FSM cannot find the input symbol and the current\n        state in the transition list and if the FSM cannot find the\n        current_state in the transition_any list. This is useful as a final\n        fall-through state for catching errors and undefined states.\n\n        The default transition can be removed by setting the attribute\n        default_transition to None. '''\n\n        self.default_transition = (action, next_state)\n\n    def get_transition (self, input_symbol, state):\n\n        '''This returns (action, next state) given an input_symbol and state.\n        This does not modify the FSM state, so calling this method has no side\n        effects. Normally you do not call this method directly. It is called by\n        process().\n\n        The sequence of steps to check for a defined transition goes from the\n        most specific to the least specific.\n\n        1. Check state_transitions[] that match exactly the tuple,\n            (input_symbol, state)\n\n        2. Check state_transitions_any[] that match (state)\n            In other words, match a specific state and ANY input_symbol.\n\n        3. Check if the default_transition is defined.\n            This catches any input_symbol and any state.\n            This is a handler for errors, undefined states, or defaults.\n\n        4. No transition was defined. If we get here then raise an exception.\n        '''\n\n        if (input_symbol, state) in self.state_transitions:\n            return self.state_transitions[(input_symbol, state)]\n        elif state in self.state_transitions_any:\n            return self.state_transitions_any[state]\n        elif self.default_transition is not None:\n            return self.default_transition\n        else:\n            raise ExceptionFSM ('Transition is undefined: (%s, %s).' %\n                (str(input_symbol), str(state)) )\n\n    def process (self, input_symbol):\n\n        '''This is the main method that you call to process input. This may\n        cause the FSM to change state and call an action. This method calls\n        get_transition() to find the action and next_state associated with the\n        input_symbol and current_state. If the action is None then the action\n        is not called and only the current state is changed. This method\n        processes one complete input symbol. You can process a list of symbols\n        (or a string) by calling process_list(). '''\n\n        self.input_symbol = input_symbol\n        (self.action, self.next_state) = self.get_transition (self.input_symbol, self.current_state)\n        if self.action is not None:\n            self.action (self)\n        self.current_state = self.next_state\n        self.next_state = None\n\n    def process_list (self, input_symbols):\n\n        '''This takes a list and sends each element to process(). The list may\n        be a string or any iterable object. '''\n\n        for s in input_symbols:\n            self.process (s)\n\n##############################################################################\n# The following is an example that demonstrates the use of the FSM class to\n# process an RPN expression. Run this module from the command line. You will\n# get a prompt > for input. Enter an RPN Expression. Numbers may be integers.\n# Operators are * / + - Use the = sign to evaluate and print the expression.\n# For example:\n#\n#    167 3 2 2 * * * 1 - =\n#\n# will print:\n#\n#    2003\n##############################################################################\n\nimport sys\nimport string\n\nPY3 = (sys.version_info[0] >= 3)\n\n#\n# These define the actions.\n# Note that \"memory\" is a list being used as a stack.\n#\n\ndef BeginBuildNumber (fsm):\n    fsm.memory.append (fsm.input_symbol)\n\ndef BuildNumber (fsm):\n    s = fsm.memory.pop ()\n    s = s + fsm.input_symbol\n    fsm.memory.append (s)\n\ndef EndBuildNumber (fsm):\n    s = fsm.memory.pop ()\n    fsm.memory.append (int(s))\n\ndef DoOperator (fsm):\n    ar = fsm.memory.pop()\n    al = fsm.memory.pop()\n    if fsm.input_symbol == '+':\n        fsm.memory.append (al + ar)\n    elif fsm.input_symbol == '-':\n        fsm.memory.append (al - ar)\n    elif fsm.input_symbol == '*':\n        fsm.memory.append (al * ar)\n    elif fsm.input_symbol == '/':\n        fsm.memory.append (al / ar)\n\ndef DoEqual (fsm):\n    print(str(fsm.memory.pop()))\n\ndef Error (fsm):\n    print('That does not compute.')\n    print(str(fsm.input_symbol))\n\ndef main():\n\n    '''This is where the example starts and the FSM state transitions are\n    defined. Note that states are strings (such as 'INIT'). This is not\n    necessary, but it makes the example easier to read. '''\n\n    f = FSM ('INIT', [])\n    f.set_default_transition (Error, 'INIT')\n    f.add_transition_any  ('INIT', None, 'INIT')\n    f.add_transition      ('=',               'INIT',            DoEqual,          'INIT')\n    f.add_transition_list (string.digits,     'INIT',            BeginBuildNumber, 'BUILDING_NUMBER')\n    f.add_transition_list (string.digits,     'BUILDING_NUMBER', BuildNumber,      'BUILDING_NUMBER')\n    f.add_transition_list (string.whitespace, 'BUILDING_NUMBER', EndBuildNumber,   'INIT')\n    f.add_transition_list ('+-*/',            'INIT',            DoOperator,       'INIT')\n\n    print()\n    print('Enter an RPN Expression.')\n    print('Numbers may be integers. Operators are * / + -')\n    print('Use the = sign to evaluate and print the expression.')\n    print('For example: ')\n    print('    167 3 2 2 * * * 1 - =')\n    inputstr = (input if PY3 else raw_input)('> ')  # analysis:ignore\n    f.process_list(inputstr)\n\n\nif __name__ == '__main__':\n    main()\n", "pexpect/pty_spawn.py": "import os\nimport sys\nimport time\nimport pty\nimport tty\nimport errno\nimport signal\nfrom contextlib import contextmanager\n\nimport ptyprocess\nfrom ptyprocess.ptyprocess import use_native_pty_fork\n\nfrom .exceptions import ExceptionPexpect, EOF, TIMEOUT\nfrom .spawnbase import SpawnBase\nfrom .utils import (\n    which, split_command_line, select_ignore_interrupts, poll_ignore_interrupts\n)\n\n@contextmanager\ndef _wrap_ptyprocess_err():\n    \"\"\"Turn ptyprocess errors into our own ExceptionPexpect errors\"\"\"\n    try:\n        yield\n    except ptyprocess.PtyProcessError as e:\n        raise ExceptionPexpect(*e.args)\n\nPY3 = (sys.version_info[0] >= 3)\n\nclass spawn(SpawnBase):\n    '''This is the main class interface for Pexpect. Use this class to start\n    and control child applications. '''\n\n    # This is purely informational now - changing it has no effect\n    use_native_pty_fork = use_native_pty_fork\n\n    def __init__(self, command, args=[], timeout=30, maxread=2000,\n                 searchwindowsize=None, logfile=None, cwd=None, env=None,\n                 ignore_sighup=False, echo=True, preexec_fn=None,\n                 encoding=None, codec_errors='strict', dimensions=None,\n                 use_poll=False):\n        '''This is the constructor. The command parameter may be a string that\n        includes a command and any arguments to the command. For example::\n\n            child = pexpect.spawn('/usr/bin/ftp')\n            child = pexpect.spawn('/usr/bin/ssh user@example.com')\n            child = pexpect.spawn('ls -latr /tmp')\n\n        You may also construct it with a list of arguments like so::\n\n            child = pexpect.spawn('/usr/bin/ftp', [])\n            child = pexpect.spawn('/usr/bin/ssh', ['user@example.com'])\n            child = pexpect.spawn('ls', ['-latr', '/tmp'])\n\n        After this the child application will be created and will be ready to\n        talk to. For normal use, see expect() and send() and sendline().\n\n        Remember that Pexpect does NOT interpret shell meta characters such as\n        redirect, pipe, or wild cards (``>``, ``|``, or ``*``). This is a\n        common mistake.  If you want to run a command and pipe it through\n        another command then you must also start a shell. For example::\n\n            child = pexpect.spawn('/bin/bash -c \"ls -l | grep LOG > logs.txt\"')\n            child.expect(pexpect.EOF)\n\n        The second form of spawn (where you pass a list of arguments) is useful\n        in situations where you wish to spawn a command and pass it its own\n        argument list. This can make syntax more clear. For example, the\n        following is equivalent to the previous example::\n\n            shell_cmd = 'ls -l | grep LOG > logs.txt'\n            child = pexpect.spawn('/bin/bash', ['-c', shell_cmd])\n            child.expect(pexpect.EOF)\n\n        The maxread attribute sets the read buffer size. This is maximum number\n        of bytes that Pexpect will try to read from a TTY at one time. Setting\n        the maxread size to 1 will turn off buffering. Setting the maxread\n        value higher may help performance in cases where large amounts of\n        output are read back from the child. This feature is useful in\n        conjunction with searchwindowsize.\n\n        When the keyword argument *searchwindowsize* is None (default), the\n        full buffer is searched at each iteration of receiving incoming data.\n        The default number of bytes scanned at each iteration is very large\n        and may be reduced to collaterally reduce search cost.  After\n        :meth:`~.expect` returns, the full buffer attribute remains up to\n        size *maxread* irrespective of *searchwindowsize* value.\n\n        When the keyword argument ``timeout`` is specified as a number,\n        (default: *30*), then :class:`TIMEOUT` will be raised after the value\n        specified has elapsed, in seconds, for any of the :meth:`~.expect`\n        family of method calls.  When None, TIMEOUT will not be raised, and\n        :meth:`~.expect` may block indefinitely until match.\n\n\n        The logfile member turns on or off logging. All input and output will\n        be copied to the given file object. Set logfile to None to stop\n        logging. This is the default. Set logfile to sys.stdout to echo\n        everything to standard output. The logfile is flushed after each write.\n\n        Example log input and output to a file::\n\n            child = pexpect.spawn('some_command')\n            fout = open('mylog.txt','wb')\n            child.logfile = fout\n\n        Example log to stdout::\n\n            # In Python 2:\n            child = pexpect.spawn('some_command')\n            child.logfile = sys.stdout\n\n            # In Python 3, we'll use the ``encoding`` argument to decode data\n            # from the subprocess and handle it as unicode:\n            child = pexpect.spawn('some_command', encoding='utf-8')\n            child.logfile = sys.stdout\n\n        The logfile_read and logfile_send members can be used to separately log\n        the input from the child and output sent to the child. Sometimes you\n        don't want to see everything you write to the child. You only want to\n        log what the child sends back. For example::\n\n            child = pexpect.spawn('some_command')\n            child.logfile_read = sys.stdout\n\n        You will need to pass an encoding to spawn in the above code if you are\n        using Python 3.\n\n        To separately log output sent to the child use logfile_send::\n\n            child.logfile_send = fout\n\n        If ``ignore_sighup`` is True, the child process will ignore SIGHUP\n        signals. The default is False from Pexpect 4.0, meaning that SIGHUP\n        will be handled normally by the child.\n\n        The delaybeforesend helps overcome a weird behavior that many users\n        were experiencing. The typical problem was that a user would expect() a\n        \"Password:\" prompt and then immediately call sendline() to send the\n        password. The user would then see that their password was echoed back\n        to them. Passwords don't normally echo. The problem is caused by the\n        fact that most applications print out the \"Password\" prompt and then\n        turn off stdin echo, but if you send your password before the\n        application turned off echo, then you get your password echoed.\n        Normally this wouldn't be a problem when interacting with a human at a\n        real keyboard. If you introduce a slight delay just before writing then\n        this seems to clear up the problem. This was such a common problem for\n        many users that I decided that the default pexpect behavior should be\n        to sleep just before writing to the child application. 1/20th of a\n        second (50 ms) seems to be enough to clear up the problem. You can set\n        delaybeforesend to None to return to the old behavior.\n\n        Note that spawn is clever about finding commands on your path.\n        It uses the same logic that \"which\" uses to find executables.\n\n        If you wish to get the exit status of the child you must call the\n        close() method. The exit or signal status of the child will be stored\n        in self.exitstatus or self.signalstatus. If the child exited normally\n        then exitstatus will store the exit return code and signalstatus will\n        be None. If the child was terminated abnormally with a signal then\n        signalstatus will store the signal value and exitstatus will be None::\n\n            child = pexpect.spawn('some_command')\n            child.close()\n            print(child.exitstatus, child.signalstatus)\n\n        If you need more detail you can also read the self.status member which\n        stores the status returned by os.waitpid. You can interpret this using\n        os.WIFEXITED/os.WEXITSTATUS or os.WIFSIGNALED/os.TERMSIG.\n\n        The echo attribute may be set to False to disable echoing of input.\n        As a pseudo-terminal, all input echoed by the \"keyboard\" (send()\n        or sendline()) will be repeated to output.  For many cases, it is\n        not desirable to have echo enabled, and it may be later disabled\n        using setecho(False) followed by waitnoecho().  However, for some\n        platforms such as Solaris, this is not possible, and should be\n        disabled immediately on spawn.\n\n        If preexec_fn is given, it will be called in the child process before\n        launching the given command. This is useful to e.g. reset inherited\n        signal handlers.\n\n        The dimensions attribute specifies the size of the pseudo-terminal as\n        seen by the subprocess, and is specified as a two-entry tuple (rows,\n        columns). If this is unspecified, the defaults in ptyprocess will apply.\n\n        The use_poll attribute enables using select.poll() over select.select()\n        for socket handling. This is handy if your system could have > 1024 fds\n        '''\n        super(spawn, self).__init__(timeout=timeout, maxread=maxread, searchwindowsize=searchwindowsize,\n                                    logfile=logfile, encoding=encoding, codec_errors=codec_errors)\n        self.STDIN_FILENO = pty.STDIN_FILENO\n        self.STDOUT_FILENO = pty.STDOUT_FILENO\n        self.STDERR_FILENO = pty.STDERR_FILENO\n        self.str_last_chars = 100\n        self.cwd = cwd\n        self.env = env\n        self.echo = echo\n        self.ignore_sighup = ignore_sighup\n        self.__irix_hack = sys.platform.lower().startswith('irix')\n        if command is None:\n            self.command = None\n            self.args = None\n            self.name = '<pexpect factory incomplete>'\n        else:\n            self._spawn(command, args, preexec_fn, dimensions)\n        self.use_poll = use_poll\n\n    def __str__(self):\n        '''This returns a human-readable string that represents the state of\n        the object. '''\n\n        s = []\n        s.append(repr(self))\n        s.append('command: ' + str(self.command))\n        s.append('args: %r' % (self.args,))\n        s.append('buffer (last %s chars): %r' % (self.str_last_chars,self.buffer[-self.str_last_chars:]))\n        s.append('before (last %s chars): %r' % (self.str_last_chars,self.before[-self.str_last_chars:] if self.before else ''))\n        s.append('after: %r' % (self.after,))\n        s.append('match: %r' % (self.match,))\n        s.append('match_index: ' + str(self.match_index))\n        s.append('exitstatus: ' + str(self.exitstatus))\n        if hasattr(self, 'ptyproc'):\n            s.append('flag_eof: ' + str(self.flag_eof))\n        s.append('pid: ' + str(self.pid))\n        s.append('child_fd: ' + str(self.child_fd))\n        s.append('closed: ' + str(self.closed))\n        s.append('timeout: ' + str(self.timeout))\n        s.append('delimiter: ' + str(self.delimiter))\n        s.append('logfile: ' + str(self.logfile))\n        s.append('logfile_read: ' + str(self.logfile_read))\n        s.append('logfile_send: ' + str(self.logfile_send))\n        s.append('maxread: ' + str(self.maxread))\n        s.append('ignorecase: ' + str(self.ignorecase))\n        s.append('searchwindowsize: ' + str(self.searchwindowsize))\n        s.append('delaybeforesend: ' + str(self.delaybeforesend))\n        s.append('delayafterclose: ' + str(self.delayafterclose))\n        s.append('delayafterterminate: ' + str(self.delayafterterminate))\n        return '\\n'.join(s)\n\n    def _spawn(self, command, args=[], preexec_fn=None, dimensions=None):\n        '''This starts the given command in a child process. This does all the\n        fork/exec type of stuff for a pty. This is called by __init__. If args\n        is empty then command will be parsed (split on spaces) and args will be\n        set to parsed arguments. '''\n\n        # The pid and child_fd of this object get set by this method.\n        # Note that it is difficult for this method to fail.\n        # You cannot detect if the child process cannot start.\n        # So the only way you can tell if the child process started\n        # or not is to try to read from the file descriptor. If you get\n        # EOF immediately then it means that the child is already dead.\n        # That may not necessarily be bad because you may have spawned a child\n        # that performs some task; creates no stdout output; and then dies.\n\n        # If command is an int type then it may represent a file descriptor.\n        if isinstance(command, type(0)):\n            raise ExceptionPexpect('Command is an int type. ' +\n                    'If this is a file descriptor then maybe you want to ' +\n                    'use fdpexpect.fdspawn which takes an existing ' +\n                    'file descriptor instead of a command string.')\n\n        if not isinstance(args, type([])):\n            raise TypeError('The argument, args, must be a list.')\n\n        if args == []:\n            self.args = split_command_line(command)\n            self.command = self.args[0]\n        else:\n            # Make a shallow copy of the args list.\n            self.args = args[:]\n            self.args.insert(0, command)\n            self.command = command\n\n        command_with_path = which(self.command, env=self.env)\n        if command_with_path is None:\n            raise ExceptionPexpect('The command was not found or was not ' +\n                    'executable: %s.' % self.command)\n        self.command = command_with_path\n        self.args[0] = self.command\n\n        self.name = '<' + ' '.join(self.args) + '>'\n\n        assert self.pid is None, 'The pid member must be None.'\n        assert self.command is not None, 'The command member must not be None.'\n\n        kwargs = {'echo': self.echo, 'preexec_fn': preexec_fn}\n        if self.ignore_sighup:\n            def preexec_wrapper():\n                \"Set SIGHUP to be ignored, then call the real preexec_fn\"\n                signal.signal(signal.SIGHUP, signal.SIG_IGN)\n                if preexec_fn is not None:\n                    preexec_fn()\n            kwargs['preexec_fn'] = preexec_wrapper\n\n        if dimensions is not None:\n            kwargs['dimensions'] = dimensions\n\n        if self.encoding is not None:\n            # Encode command line using the specified encoding\n            self.args = [a if isinstance(a, bytes) else a.encode(self.encoding)\n                         for a in self.args]\n\n        self.ptyproc = self._spawnpty(self.args, env=self.env,\n                                     cwd=self.cwd, **kwargs)\n\n        self.pid = self.ptyproc.pid\n        self.child_fd = self.ptyproc.fd\n\n\n        self.terminated = False\n        self.closed = False\n\n    def _spawnpty(self, args, **kwargs):\n        '''Spawn a pty and return an instance of PtyProcess.'''\n        return ptyprocess.PtyProcess.spawn(args, **kwargs)\n\n    def close(self, force=True):\n        '''This closes the connection with the child application. Note that\n        calling close() more than once is valid. This emulates standard Python\n        behavior with files. Set force to True if you want to make sure that\n        the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n        and SIGINT). '''\n\n        self.flush()\n        with _wrap_ptyprocess_err():\n            # PtyProcessError may be raised if it is not possible to terminate\n            # the child.\n            self.ptyproc.close(force=force)\n        self.isalive()  # Update exit status from ptyproc\n        self.child_fd = -1\n        self.closed = True\n\n    def isatty(self):\n        '''This returns True if the file descriptor is open and connected to a\n        tty(-like) device, else False.\n\n        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,\n        the child pty may not appear as a terminal device.  This means\n        methods such as setecho(), setwinsize(), getwinsize() may raise an\n        IOError. '''\n\n        return os.isatty(self.child_fd)\n\n    def waitnoecho(self, timeout=-1):\n        '''This waits until the terminal ECHO flag is set False. This returns\n        True if the echo mode is off. This returns False if the ECHO flag was\n        not set False before the timeout. This can be used to detect when the\n        child is waiting for a password. Usually a child application will turn\n        off echo mode when it is waiting for the user to enter a password. For\n        example, instead of expecting the \"password:\" prompt you can wait for\n        the child to set ECHO off::\n\n            p = pexpect.spawn('ssh user@example.com')\n            p.waitnoecho()\n            p.sendline(mypassword)\n\n        If timeout==-1 then this method will use the value in self.timeout.\n        If timeout==None then this method to block until ECHO flag is False.\n        '''\n\n        if timeout == -1:\n            timeout = self.timeout\n        if timeout is not None:\n            end_time = time.time() + timeout\n        while True:\n            if not self.getecho():\n                return True\n            if timeout < 0 and timeout is not None:\n                return False\n            if timeout is not None:\n                timeout = end_time - time.time()\n            time.sleep(0.1)\n\n    def getecho(self):\n        '''This returns the terminal echo mode. This returns True if echo is\n        on or False if echo is off. Child applications that are expecting you\n        to enter a password often set ECHO False. See waitnoecho().\n\n        Not supported on platforms where ``isatty()`` returns False.  '''\n        return self.ptyproc.getecho()\n\n    def setecho(self, state):\n        '''This sets the terminal echo mode on or off. Note that anything the\n        child sent before the echo will be lost, so you should be sure that\n        your input buffer is empty before you call setecho(). For example, the\n        following will work as expected::\n\n            p = pexpect.spawn('cat') # Echo is on by default.\n            p.sendline('1234') # We expect see this twice from the child...\n            p.expect(['1234']) # ... once from the tty echo...\n            p.expect(['1234']) # ... and again from cat itself.\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n        The following WILL NOT WORK because the lines sent before the setecho\n        will be lost::\n\n            p = pexpect.spawn('cat')\n            p.sendline('1234')\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['1234'])\n            p.expect(['1234'])\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n        return self.ptyproc.setecho(state)\n\n    def read_nonblocking(self, size=1, timeout=-1):\n        '''This reads at most size characters from the child application. It\n        includes a timeout. If the read does not complete within the timeout\n        period then a TIMEOUT exception is raised. If the end of file is read\n        then an EOF exception will be raised.  If a logfile is specified, a\n        copy is written to that log.\n\n        If timeout is None then the read may block indefinitely.\n        If timeout is -1 then the self.timeout value is used. If timeout is 0\n        then the child is polled and if there is no data immediately ready\n        then this will raise a TIMEOUT exception.\n\n        The timeout refers only to the amount of time to read at least one\n        character. This is not affected by the 'size' parameter, so if you call\n        read_nonblocking(size=100, timeout=30) and only one character is\n        available right away then one character will be returned immediately.\n        It will not wait for 30 seconds for another 99 characters to come in.\n\n        On the other hand, if there are bytes available to read immediately,\n        all those bytes will be read (up to the buffer size). So, if the\n        buffer size is 1 megabyte and there is 1 megabyte of data available\n        to read, the buffer will be filled, regardless of timeout.\n\n        This is a wrapper around os.read(). It uses select.select() or\n        select.poll() to implement the timeout. '''\n\n        if self.closed:\n            raise ValueError('I/O operation on closed file.')\n\n        if self.use_poll:\n            def select(timeout):\n                return poll_ignore_interrupts([self.child_fd], timeout)\n        else:\n            def select(timeout):\n                return select_ignore_interrupts([self.child_fd], [], [], timeout)[0]\n\n        # If there is data available to read right now, read as much as\n        # we can. We do this to increase performance if there are a lot\n        # of bytes to be read. This also avoids calling isalive() too\n        # often. See also:\n        # * https://github.com/pexpect/pexpect/pull/304\n        # * http://trac.sagemath.org/ticket/10295\n        if select(0):\n            try:\n                incoming = super(spawn, self).read_nonblocking(size)\n            except EOF:\n                # Maybe the child is dead: update some attributes in that case\n                self.isalive()\n                raise\n            while len(incoming) < size and select(0):\n                try:\n                    incoming += super(spawn, self).read_nonblocking(size - len(incoming))\n                except EOF:\n                    # Maybe the child is dead: update some attributes in that case\n                    self.isalive()\n                    # Don't raise EOF, just return what we read so far.\n                    return incoming\n            return incoming\n\n        if timeout == -1:\n            timeout = self.timeout\n\n        if not self.isalive():\n            # The process is dead, but there may or may not be data\n            # available to read. Note that some systems such as Solaris\n            # do not give an EOF when the child dies. In fact, you can\n            # still try to read from the child_fd -- it will block\n            # forever or until TIMEOUT. For that reason, it's important\n            # to do this check before calling select() with timeout.\n            if select(0):\n                return super(spawn, self).read_nonblocking(size)\n            self.flag_eof = True\n            raise EOF('End Of File (EOF). Braindead platform.')\n        elif self.__irix_hack:\n            # Irix takes a long time before it realizes a child was terminated.\n            # Make sure that the timeout is at least 2 seconds.\n            # FIXME So does this mean Irix systems are forced to always have\n            # FIXME a 2 second delay when calling read_nonblocking? That sucks.\n            if timeout is not None and timeout < 2:\n                timeout = 2\n\n        # Because of the select(0) check above, we know that no data\n        # is available right now. But if a non-zero timeout is given\n        # (possibly timeout=None), we call select() with a timeout.\n        if (timeout != 0) and select(timeout):\n            return super(spawn, self).read_nonblocking(size)\n\n        if not self.isalive():\n            # Some platforms, such as Irix, will claim that their\n            # processes are alive; timeout on the select; and\n            # then finally admit that they are not alive.\n            self.flag_eof = True\n            raise EOF('End of File (EOF). Very slow platform.')\n        else:\n            raise TIMEOUT('Timeout exceeded.')\n\n    def write(self, s):\n        '''This is similar to send() except that there is no return value.\n        '''\n\n        self.send(s)\n\n    def writelines(self, sequence):\n        '''This calls write() for each element in the sequence. The sequence\n        can be any iterable object producing strings, typically a list of\n        strings. This does not add line separators. There is no return value.\n        '''\n\n        for s in sequence:\n            self.write(s)\n\n    def send(self, s):\n        '''Sends string ``s`` to the child process, returning the number of\n        bytes written. If a logfile is specified, a copy is written to that\n        log.\n\n        The default terminal input mode is canonical processing unless set\n        otherwise by the child process. This allows backspace and other line\n        processing to be performed prior to transmitting to the receiving\n        program. As this is buffered, there is a limited size of such buffer.\n\n        On Linux systems, this is 4096 (defined by N_TTY_BUF_SIZE). All\n        other systems honor the POSIX.1 definition PC_MAX_CANON -- 1024\n        on OSX, 256 on OpenSolaris, and 1920 on FreeBSD.\n\n        This value may be discovered using fpathconf(3)::\n\n            >>> from os import fpathconf\n            >>> print(fpathconf(0, 'PC_MAX_CANON'))\n            256\n\n        On such a system, only 256 bytes may be received per line. Any\n        subsequent bytes received will be discarded. BEL (``'\\a'``) is then\n        sent to output if IMAXBEL (termios.h) is set by the tty driver.\n        This is usually enabled by default.  Linux does not honor this as\n        an option -- it behaves as though it is always set on.\n\n        Canonical input processing may be disabled altogether by executing\n        a shell, then stty(1), before executing the final program::\n\n            >>> bash = pexpect.spawn('/bin/bash', echo=False)\n            >>> bash.sendline('stty -icanon')\n            >>> bash.sendline('base64')\n            >>> bash.sendline('x' * 5000)\n        '''\n\n        if self.delaybeforesend is not None:\n            time.sleep(self.delaybeforesend)\n\n        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n\n        b = self._encoder.encode(s, final=False)\n        return os.write(self.child_fd, b)\n\n    def sendline(self, s=''):\n        '''Wraps send(), sending string ``s`` to child process, with\n        ``os.linesep`` automatically appended. Returns number of bytes\n        written.  Only a limited number of bytes may be sent for each\n        line in the default terminal mode, see docstring of :meth:`send`.\n        '''\n        s = self._coerce_send_string(s)\n        return self.send(s + self.linesep)\n\n    def _log_control(self, s):\n        \"\"\"Write control characters to the appropriate log files\"\"\"\n        if self.encoding is not None:\n            s = s.decode(self.encoding, 'replace')\n        self._log(s, 'send')\n\n    def sendcontrol(self, char):\n        '''Helper method that wraps send() with mnemonic access for sending control\n        character to the child (such as Ctrl-C or Ctrl-D).  For example, to send\n        Ctrl-G (ASCII 7, bell, '\\a')::\n\n            child.sendcontrol('g')\n\n        See also, sendintr() and sendeof().\n        '''\n        n, byte = self.ptyproc.sendcontrol(char)\n        self._log_control(byte)\n        return n\n\n    def sendeof(self):\n        '''This sends an EOF to the child. This sends a character which causes\n        the pending parent output buffer to be sent to the waiting child\n        program without waiting for end-of-line. If it is the first character\n        of the line, the read() in the user program returns 0, which signifies\n        end-of-file. This means to work as expected a sendeof() has to be\n        called at the beginning of a line. This method does not send a newline.\n        It is the responsibility of the caller to ensure the eof is sent at the\n        beginning of a line. '''\n\n        n, byte = self.ptyproc.sendeof()\n        self._log_control(byte)\n\n    def sendintr(self):\n        '''This sends a SIGINT to the child. It does not require\n        the SIGINT to be the first character on a line. '''\n\n        n, byte = self.ptyproc.sendintr()\n        self._log_control(byte)\n\n    @property\n    def flag_eof(self):\n        return self.ptyproc.flag_eof\n\n    @flag_eof.setter\n    def flag_eof(self, value):\n        self.ptyproc.flag_eof = value\n\n    def eof(self):\n        '''This returns True if the EOF exception was ever raised.\n        '''\n        return self.flag_eof\n\n    def terminate(self, force=False):\n        '''This forces a child process to terminate. It starts nicely with\n        SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n        returns True if the child was terminated. This returns False if the\n        child could not be terminated. '''\n\n        if not self.isalive():\n            return True\n        try:\n            self.kill(signal.SIGHUP)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGCONT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGINT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            if force:\n                self.kill(signal.SIGKILL)\n                time.sleep(self.delayafterterminate)\n                if not self.isalive():\n                    return True\n                else:\n                    return False\n            return False\n        except OSError:\n            # I think there are kernel timing issues that sometimes cause\n            # this to happen. I think isalive() reports True, but the\n            # process is dead to the kernel.\n            # Make one last attempt to see if the kernel is up to date.\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            else:\n                return False\n\n    def wait(self):\n        '''This waits until the child exits. This is a blocking call. This will\n        not read any data from the child, so this will block forever if the\n        child has unread output and has terminated. In other words, the child\n        may have printed output then called exit(), but, the child is\n        technically still alive until its output is read by the parent.\n\n        This method is non-blocking if :meth:`wait` has already been called\n        previously or :meth:`isalive` method returns False.  It simply returns\n        the previously determined exit status.\n        '''\n\n        ptyproc = self.ptyproc\n        with _wrap_ptyprocess_err():\n            # exception may occur if \"Is some other process attempting\n            # \"job control with our child pid?\"\n            exitstatus = ptyproc.wait()\n        self.status = ptyproc.status\n        self.exitstatus = ptyproc.exitstatus\n        self.signalstatus = ptyproc.signalstatus\n        self.terminated = True\n\n        return exitstatus\n\n    def isalive(self):\n        '''This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status. '''\n\n        ptyproc = self.ptyproc\n        with _wrap_ptyprocess_err():\n            alive = ptyproc.isalive()\n\n        if not alive:\n            self.status = ptyproc.status\n            self.exitstatus = ptyproc.exitstatus\n            self.signalstatus = ptyproc.signalstatus\n            self.terminated = True\n\n        return alive\n\n    def kill(self, sig):\n\n        '''This sends the given signal to the child application. In keeping\n        with UNIX tradition it has a misleading name. It does not necessarily\n        kill the child unless you send the right signal. '''\n\n        # Same as os.kill, but the pid is given for you.\n        if self.isalive():\n            os.kill(self.pid, sig)\n\n    def getwinsize(self):\n        '''This returns the terminal window size of the child tty. The return\n        value is a tuple of (rows, cols). '''\n        return self.ptyproc.getwinsize()\n\n    def setwinsize(self, rows, cols):\n        '''This sets the terminal window size of the child tty. This will cause\n        a SIGWINCH signal to be sent to the child. This does not change the\n        physical window size. It changes the size reported to TTY-aware\n        applications like vi or curses -- applications that respond to the\n        SIGWINCH signal. '''\n        return self.ptyproc.setwinsize(rows, cols)\n\n\n    def interact(self, escape_character=chr(29),\n            input_filter=None, output_filter=None):\n\n        '''This gives control of the child process to the interactive user (the\n        human at the keyboard). Keystrokes are sent to the child process, and\n        the stdout and stderr output of the child process is printed. This\n        simply echos the child stdout and child stderr to the real stdout and\n        it echos the real stdin to the child stdin. When the user types the\n        escape_character this method will return None. The escape_character\n        will not be transmitted.  The default for escape_character is\n        entered as ``Ctrl - ]``, the very same as BSD telnet. To prevent\n        escaping, escape_character may be set to None.\n\n        If a logfile is specified, then the data sent and received from the\n        child process in interact mode is duplicated to the given log.\n\n        You may pass in optional input and output filter functions. These\n        functions should take bytes array and return bytes array too. Even\n        with ``encoding='utf-8'`` support, meth:`interact` will always pass\n        input_filter and output_filter bytes. You may need to wrap your\n        function to decode and encode back to UTF-8.\n\n        The output_filter will be passed all the output from the child process.\n        The input_filter will be passed all the keyboard input from the user.\n        The input_filter is run BEFORE the check for the escape_character.\n\n        Note that if you change the window size of the parent the SIGWINCH\n        signal will not be passed through to the child. If you want the child\n        window size to change when the parent's window size changes then do\n        something like the following example::\n\n            import pexpect, struct, fcntl, termios, signal, sys\n            def sigwinch_passthrough (sig, data):\n                s = struct.pack(\"HHHH\", 0, 0, 0, 0)\n                a = struct.unpack('hhhh', fcntl.ioctl(sys.stdout.fileno(),\n                    termios.TIOCGWINSZ , s))\n                if not p.closed:\n                    p.setwinsize(a[0],a[1])\n\n            # Note this 'p' is global and used in sigwinch_passthrough.\n            p = pexpect.spawn('/bin/bash')\n            signal.signal(signal.SIGWINCH, sigwinch_passthrough)\n            p.interact()\n        '''\n\n        # Flush the buffer.\n        self.write_to_stdout(self.buffer)\n        self.stdout.flush()\n        self._buffer = self.buffer_type()\n        mode = tty.tcgetattr(self.STDIN_FILENO)\n        tty.setraw(self.STDIN_FILENO)\n        if escape_character is not None and PY3:\n            escape_character = escape_character.encode('latin-1')\n        try:\n            self.__interact_copy(escape_character, input_filter, output_filter)\n        finally:\n            tty.tcsetattr(self.STDIN_FILENO, tty.TCSAFLUSH, mode)\n\n    def __interact_writen(self, fd, data):\n        '''This is used by the interact() method.\n        '''\n\n        while data != b'' and self.isalive():\n            n = os.write(fd, data)\n            data = data[n:]\n\n    def __interact_read(self, fd):\n        '''This is used by the interact() method.\n        '''\n\n        return os.read(fd, 1000)\n\n    def __interact_copy(\n        self, escape_character=None, input_filter=None, output_filter=None\n    ):\n\n        '''This is used by the interact() method.\n        '''\n\n        while self.isalive():\n            if self.use_poll:\n                r = poll_ignore_interrupts([self.child_fd, self.STDIN_FILENO])\n            else:\n                r, w, e = select_ignore_interrupts(\n                    [self.child_fd, self.STDIN_FILENO], [], []\n                )\n            if self.child_fd in r:\n                try:\n                    data = self.__interact_read(self.child_fd)\n                except OSError as err:\n                    if err.args[0] == errno.EIO:\n                        # Linux-style EOF\n                        break\n                    raise\n                if data == b'':\n                    # BSD-style EOF\n                    break\n                if output_filter:\n                    data = output_filter(data)\n                self._log(data, 'read')\n                os.write(self.STDOUT_FILENO, data)\n            if self.STDIN_FILENO in r:\n                data = self.__interact_read(self.STDIN_FILENO)\n                if input_filter:\n                    data = input_filter(data)\n                i = -1\n                if escape_character is not None:\n                    i = data.rfind(escape_character)\n                if i != -1:\n                    data = data[:i]\n                    if data:\n                        self._log(data, 'send')\n                    self.__interact_writen(self.child_fd, data)\n                    break\n                self._log(data, 'send')\n                self.__interact_writen(self.child_fd, data)\n\n\ndef spawnu(*args, **kwargs):\n    \"\"\"Deprecated: pass encoding to spawn() instead.\"\"\"\n    kwargs.setdefault('encoding', 'utf-8')\n    return spawn(*args, **kwargs)\n", "pexpect/exceptions.py": "\"\"\"Exception classes used by Pexpect\"\"\"\n\nimport traceback\nimport sys\n\nclass ExceptionPexpect(Exception):\n    '''Base class for all exceptions raised by this module.\n    '''\n\n    def __init__(self, value):\n        super(ExceptionPexpect, self).__init__(value)\n        self.value = value\n\n    def __str__(self):\n        return str(self.value)\n\n    def get_trace(self):\n        '''This returns an abbreviated stack trace with lines that only concern\n        the caller. In other words, the stack trace inside the Pexpect module\n        is not included. '''\n\n        tblist = traceback.extract_tb(sys.exc_info()[2])\n        tblist = [item for item in tblist if ('pexpect/__init__' not in item[0])\n                                           and ('pexpect/expect' not in item[0])]\n        tblist = traceback.format_list(tblist)\n        return ''.join(tblist)\n\n\nclass EOF(ExceptionPexpect):\n    '''Raised when EOF is read from a child.\n    This usually means the child has exited.'''\n\n\nclass TIMEOUT(ExceptionPexpect):\n    '''Raised when a read time exceeds the timeout. '''\n", "pexpect/ANSI.py": "'''This implements an ANSI (VT100) terminal emulator as a subclass of screen.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\n# references:\n#     http://en.wikipedia.org/wiki/ANSI_escape_code\n#     http://www.retards.org/terminals/vt102.html\n#     http://vt100.net/docs/vt102-ug/contents.html\n#     http://vt100.net/docs/vt220-rm/\n#     http://www.termsys.demon.co.uk/vtansi.htm\n\nfrom . import screen\nfrom . import FSM\nimport string\n\n#\n# The 'Do.*' functions are helper functions for the ANSI class.\n#\ndef DoEmit (fsm):\n\n    screen = fsm.memory[0]\n    screen.write_ch(fsm.input_symbol)\n\ndef DoStartNumber (fsm):\n\n    fsm.memory.append (fsm.input_symbol)\n\ndef DoBuildNumber (fsm):\n\n    ns = fsm.memory.pop()\n    ns = ns + fsm.input_symbol\n    fsm.memory.append (ns)\n\ndef DoBackOne (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_back ()\n\ndef DoBack (fsm):\n\n    count = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    screen.cursor_back (count)\n\ndef DoDownOne (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_down ()\n\ndef DoDown (fsm):\n\n    count = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    screen.cursor_down (count)\n\ndef DoForwardOne (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_forward ()\n\ndef DoForward (fsm):\n\n    count = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    screen.cursor_forward (count)\n\ndef DoUpReverse (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_up_reverse()\n\ndef DoUpOne (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_up ()\n\ndef DoUp (fsm):\n\n    count = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    screen.cursor_up (count)\n\ndef DoHome (fsm):\n\n    c = int(fsm.memory.pop())\n    r = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    screen.cursor_home (r,c)\n\ndef DoHomeOrigin (fsm):\n\n    c = 1\n    r = 1\n    screen = fsm.memory[0]\n    screen.cursor_home (r,c)\n\ndef DoEraseDown (fsm):\n\n    screen = fsm.memory[0]\n    screen.erase_down()\n\ndef DoErase (fsm):\n\n    arg = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    if arg == 0:\n        screen.erase_down()\n    elif arg == 1:\n        screen.erase_up()\n    elif arg == 2:\n        screen.erase_screen()\n\ndef DoEraseEndOfLine (fsm):\n\n    screen = fsm.memory[0]\n    screen.erase_end_of_line()\n\ndef DoEraseLine (fsm):\n\n    arg = int(fsm.memory.pop())\n    screen = fsm.memory[0]\n    if arg == 0:\n        screen.erase_end_of_line()\n    elif arg == 1:\n        screen.erase_start_of_line()\n    elif arg == 2:\n        screen.erase_line()\n\ndef DoEnableScroll (fsm):\n\n    screen = fsm.memory[0]\n    screen.scroll_screen()\n\ndef DoCursorSave (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_save_attrs()\n\ndef DoCursorRestore (fsm):\n\n    screen = fsm.memory[0]\n    screen.cursor_restore_attrs()\n\ndef DoScrollRegion (fsm):\n\n    screen = fsm.memory[0]\n    r2 = int(fsm.memory.pop())\n    r1 = int(fsm.memory.pop())\n    screen.scroll_screen_rows (r1,r2)\n\ndef DoMode (fsm):\n\n    screen = fsm.memory[0]\n    mode = fsm.memory.pop() # Should be 4\n    # screen.setReplaceMode ()\n\ndef DoLog (fsm):\n\n    screen = fsm.memory[0]\n    fsm.memory = [screen]\n    fout = open ('log', 'a')\n    fout.write (fsm.input_symbol + ',' + fsm.current_state + '\\n')\n    fout.close()\n\nclass term (screen.screen):\n\n    '''This class is an abstract, generic terminal.\n    This does nothing. This is a placeholder that\n    provides a common base class for other terminals\n    such as an ANSI terminal. '''\n\n    def __init__ (self, r=24, c=80, *args, **kwargs):\n\n        screen.screen.__init__(self, r,c,*args,**kwargs)\n\nclass ANSI (term):\n    '''This class implements an ANSI (VT100) terminal.\n    It is a stream filter that recognizes ANSI terminal\n    escape sequences and maintains the state of a screen object. '''\n\n    def __init__ (self, r=24,c=80,*args,**kwargs):\n\n        term.__init__(self,r,c,*args,**kwargs)\n\n        #self.screen = screen (24,80)\n        self.state = FSM.FSM ('INIT',[self])\n        self.state.set_default_transition (DoLog, 'INIT')\n        self.state.add_transition_any ('INIT', DoEmit, 'INIT')\n        self.state.add_transition ('\\x1b', 'INIT', None, 'ESC')\n        self.state.add_transition_any ('ESC', DoLog, 'INIT')\n        self.state.add_transition ('(', 'ESC', None, 'G0SCS')\n        self.state.add_transition (')', 'ESC', None, 'G1SCS')\n        self.state.add_transition_list ('AB012', 'G0SCS', None, 'INIT')\n        self.state.add_transition_list ('AB012', 'G1SCS', None, 'INIT')\n        self.state.add_transition ('7', 'ESC', DoCursorSave, 'INIT')\n        self.state.add_transition ('8', 'ESC', DoCursorRestore, 'INIT')\n        self.state.add_transition ('M', 'ESC', DoUpReverse, 'INIT')\n        self.state.add_transition ('>', 'ESC', DoUpReverse, 'INIT')\n        self.state.add_transition ('<', 'ESC', DoUpReverse, 'INIT')\n        self.state.add_transition ('=', 'ESC', None, 'INIT') # Selects application keypad.\n        self.state.add_transition ('#', 'ESC', None, 'GRAPHICS_POUND')\n        self.state.add_transition_any ('GRAPHICS_POUND', None, 'INIT')\n        self.state.add_transition ('[', 'ESC', None, 'ELB')\n        # ELB means Escape Left Bracket. That is ^[[\n        self.state.add_transition ('H', 'ELB', DoHomeOrigin, 'INIT')\n        self.state.add_transition ('D', 'ELB', DoBackOne, 'INIT')\n        self.state.add_transition ('B', 'ELB', DoDownOne, 'INIT')\n        self.state.add_transition ('C', 'ELB', DoForwardOne, 'INIT')\n        self.state.add_transition ('A', 'ELB', DoUpOne, 'INIT')\n        self.state.add_transition ('J', 'ELB', DoEraseDown, 'INIT')\n        self.state.add_transition ('K', 'ELB', DoEraseEndOfLine, 'INIT')\n        self.state.add_transition ('r', 'ELB', DoEnableScroll, 'INIT')\n        self.state.add_transition ('m', 'ELB', self.do_sgr, 'INIT')\n        self.state.add_transition ('?', 'ELB', None, 'MODECRAP')\n        self.state.add_transition_list (string.digits, 'ELB', DoStartNumber, 'NUMBER_1')\n        self.state.add_transition_list (string.digits, 'NUMBER_1', DoBuildNumber, 'NUMBER_1')\n        self.state.add_transition ('D', 'NUMBER_1', DoBack, 'INIT')\n        self.state.add_transition ('B', 'NUMBER_1', DoDown, 'INIT')\n        self.state.add_transition ('C', 'NUMBER_1', DoForward, 'INIT')\n        self.state.add_transition ('A', 'NUMBER_1', DoUp, 'INIT')\n        self.state.add_transition ('J', 'NUMBER_1', DoErase, 'INIT')\n        self.state.add_transition ('K', 'NUMBER_1', DoEraseLine, 'INIT')\n        self.state.add_transition ('l', 'NUMBER_1', DoMode, 'INIT')\n        ### It gets worse... the 'm' code can have infinite number of\n        ### number;number;number before it. I've never seen more than two,\n        ### but the specs say it's allowed. crap!\n        self.state.add_transition ('m', 'NUMBER_1', self.do_sgr, 'INIT')\n        ### LED control. Same implementation problem as 'm' code.\n        self.state.add_transition ('q', 'NUMBER_1', self.do_decsca, 'INIT')\n\n        # \\E[?47h switch to alternate screen\n        # \\E[?47l restores to normal screen from alternate screen.\n        self.state.add_transition_list (string.digits, 'MODECRAP', DoStartNumber, 'MODECRAP_NUM')\n        self.state.add_transition_list (string.digits, 'MODECRAP_NUM', DoBuildNumber, 'MODECRAP_NUM')\n        self.state.add_transition ('l', 'MODECRAP_NUM', self.do_modecrap, 'INIT')\n        self.state.add_transition ('h', 'MODECRAP_NUM', self.do_modecrap, 'INIT')\n\n#RM   Reset Mode                Esc [ Ps l                   none\n        self.state.add_transition (';', 'NUMBER_1', None, 'SEMICOLON')\n        self.state.add_transition_any ('SEMICOLON', DoLog, 'INIT')\n        self.state.add_transition_list (string.digits, 'SEMICOLON', DoStartNumber, 'NUMBER_2')\n        self.state.add_transition_list (string.digits, 'NUMBER_2', DoBuildNumber, 'NUMBER_2')\n        self.state.add_transition_any ('NUMBER_2', DoLog, 'INIT')\n        self.state.add_transition ('H', 'NUMBER_2', DoHome, 'INIT')\n        self.state.add_transition ('f', 'NUMBER_2', DoHome, 'INIT')\n        self.state.add_transition ('r', 'NUMBER_2', DoScrollRegion, 'INIT')\n        ### It gets worse... the 'm' code can have infinite number of\n        ### number;number;number before it. I've never seen more than two,\n        ### but the specs say it's allowed. crap!\n        self.state.add_transition ('m', 'NUMBER_2', self.do_sgr, 'INIT')\n        ### LED control. Same problem as 'm' code.\n        self.state.add_transition ('q', 'NUMBER_2', self.do_decsca, 'INIT')\n        self.state.add_transition (';', 'NUMBER_2', None, 'SEMICOLON_X')\n\n        # Create a state for 'q' and 'm' which allows an infinite number of ignored numbers\n        self.state.add_transition_any ('SEMICOLON_X', DoLog, 'INIT')\n        self.state.add_transition_list (string.digits, 'SEMICOLON_X', DoStartNumber, 'NUMBER_X')\n        self.state.add_transition_list (string.digits, 'NUMBER_X', DoBuildNumber, 'NUMBER_X')\n        self.state.add_transition_any ('NUMBER_X', DoLog, 'INIT')\n        self.state.add_transition ('m', 'NUMBER_X', self.do_sgr, 'INIT')\n        self.state.add_transition ('q', 'NUMBER_X', self.do_decsca, 'INIT')\n        self.state.add_transition (';', 'NUMBER_X', None, 'SEMICOLON_X')\n\n    def process (self, c):\n        \"\"\"Process a single character. Called by :meth:`write`.\"\"\"\n        if isinstance(c, bytes):\n            c = self._decode(c)\n        self.state.process(c)\n\n    def process_list (self, l):\n\n        self.write(l)\n\n    def write (self, s):\n        \"\"\"Process text, writing it to the virtual screen while handling\n        ANSI escape codes.\n        \"\"\"\n        if isinstance(s, bytes):\n            s = self._decode(s)\n        for c in s:\n            self.process(c)\n\n    def flush (self):\n        pass\n\n    def write_ch (self, ch):\n        '''This puts a character at the current cursor position. The cursor\n        position is moved forward with wrap-around, but no scrolling is done if\n        the cursor hits the lower-right corner of the screen. '''\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        #\\r and \\n both produce a call to cr() and lf(), respectively.\n        ch = ch[0]\n\n        if ch == u'\\r':\n            self.cr()\n            return\n        if ch == u'\\n':\n            self.crlf()\n            return\n        if ch == chr(screen.BS):\n            self.cursor_back()\n            return\n        self.put_abs(self.cur_r, self.cur_c, ch)\n        old_r = self.cur_r\n        old_c = self.cur_c\n        self.cursor_forward()\n        if old_c == self.cur_c:\n            self.cursor_down()\n            if old_r != self.cur_r:\n                self.cursor_home (self.cur_r, 1)\n            else:\n                self.scroll_up ()\n                self.cursor_home (self.cur_r, 1)\n                self.erase_line()\n\n    def do_sgr (self, fsm):\n        '''Select Graphic Rendition, e.g. color. '''\n        screen = fsm.memory[0]\n        fsm.memory = [screen]\n\n    def do_decsca (self, fsm):\n        '''Select character protection attribute. '''\n        screen = fsm.memory[0]\n        fsm.memory = [screen]\n\n    def do_modecrap (self, fsm):\n        '''Handler for \\x1b[?<number>h and \\x1b[?<number>l. If anyone\n        wanted to actually use these, they'd need to add more states to the\n        FSM rather than just improve or override this method. '''\n        screen = fsm.memory[0]\n        fsm.memory = [screen]\n", "pexpect/_async_w_await.py": "\"\"\"Implementation of coroutines using ``async def``/``await`` keywords.\n\nThese keywords replaced ``@asyncio.coroutine`` and ``yield from`` from\nPython 3.5 onwards.\n\"\"\"\nimport asyncio\nimport errno\nimport signal\nfrom sys import version_info as py_version_info\n\nfrom pexpect import EOF\n\nif py_version_info >= (3, 7):\n    # get_running_loop, new in 3.7, is preferred to get_event_loop\n    _loop_getter = asyncio.get_running_loop\nelse:\n    # Deprecation warning since 3.10\n    _loop_getter = asyncio.get_event_loop\n\n\nasync def expect_async(expecter, timeout=None):\n    # First process data that was previously read - if it maches, we don't need\n    # async stuff.\n    idx = expecter.existing_data()\n    if idx is not None:\n        return idx\n    if not expecter.spawn.async_pw_transport:\n        pattern_waiter = PatternWaiter()\n        pattern_waiter.set_expecter(expecter)\n        transport, pattern_waiter = await _loop_getter().connect_read_pipe(\n            lambda: pattern_waiter, expecter.spawn\n        )\n        expecter.spawn.async_pw_transport = pattern_waiter, transport\n    else:\n        pattern_waiter, transport = expecter.spawn.async_pw_transport\n        pattern_waiter.set_expecter(expecter)\n        transport.resume_reading()\n    try:\n        return await asyncio.wait_for(pattern_waiter.fut, timeout)\n    except asyncio.TimeoutError as exc:\n        transport.pause_reading()\n        return expecter.timeout(exc)\n\n\nasync def repl_run_command_async(repl, cmdlines, timeout=-1):\n    res = []\n    repl.child.sendline(cmdlines[0])\n    for line in cmdlines[1:]:\n        await repl._expect_prompt(timeout=timeout, async_=True)\n        res.append(repl.child.before)\n        repl.child.sendline(line)\n\n    # Command was fully submitted, now wait for the next prompt\n    prompt_idx = await repl._expect_prompt(timeout=timeout, async_=True)\n    if prompt_idx == 1:\n        # We got the continuation prompt - command was incomplete\n        repl.child.kill(signal.SIGINT)\n        await repl._expect_prompt(timeout=1, async_=True)\n        raise ValueError(\"Continuation prompt found - input was incomplete:\")\n    return \"\".join(res + [repl.child.before])\n\n\nclass PatternWaiter(asyncio.Protocol):\n    transport = None\n\n    def set_expecter(self, expecter):\n        self.expecter = expecter\n        self.fut = asyncio.Future()\n\n    def found(self, result):\n        if not self.fut.done():\n            self.fut.set_result(result)\n            self.transport.pause_reading()\n\n    def error(self, exc):\n        if not self.fut.done():\n            self.fut.set_exception(exc)\n            self.transport.pause_reading()\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data):\n        spawn = self.expecter.spawn\n        s = spawn._decoder.decode(data)\n        spawn._log(s, \"read\")\n\n        if self.fut.done():\n            spawn._before.write(s)\n            spawn._buffer.write(s)\n            return\n\n        try:\n            index = self.expecter.new_data(s)\n            if index is not None:\n                # Found a match\n                self.found(index)\n        except Exception as exc:\n            self.expecter.errored()\n            self.error(exc)\n\n    def eof_received(self):\n        # N.B. If this gets called, async will close the pipe (the spawn object)\n        # for us\n        try:\n            self.expecter.spawn.flag_eof = True\n            index = self.expecter.eof()\n        except EOF as exc:\n            self.error(exc)\n        else:\n            self.found(index)\n\n    def connection_lost(self, exc):\n        if isinstance(exc, OSError) and exc.errno == errno.EIO:\n            # We may get here without eof_received being called, e.g on Linux\n            self.eof_received()\n        elif exc is not None:\n            self.error(exc)\n", "pexpect/screen.py": "'''This implements a virtual screen. This is used to support ANSI terminal\nemulation. The screen representation and state is implemented in this class.\nMost of the methods are inspired by ANSI screen control codes. The\n:class:`~pexpect.ANSI.ANSI` class extends this class to add parsing of ANSI\nescape codes.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nimport codecs\nimport copy\nimport sys\n\nimport warnings\n\nwarnings.warn((\"pexpect.screen and pexpect.ANSI are deprecated. \"\n               \"We recommend using pyte to emulate a terminal screen: \"\n               \"https://pypi.python.org/pypi/pyte\"),\n               stacklevel=2)\n\nNUL = 0    # Fill character; ignored on input.\nENQ = 5    # Transmit answerback message.\nBEL = 7    # Ring the bell.\nBS  = 8    # Move cursor left.\nHT  = 9    # Move cursor to next tab stop.\nLF = 10    # Line feed.\nVT = 11    # Same as LF.\nFF = 12    # Same as LF.\nCR = 13    # Move cursor to left margin or newline.\nSO = 14    # Invoke G1 character set.\nSI = 15    # Invoke G0 character set.\nXON = 17   # Resume transmission.\nXOFF = 19  # Halt transmission.\nCAN = 24   # Cancel escape sequence.\nSUB = 26   # Same as CAN.\nESC = 27   # Introduce a control sequence.\nDEL = 127  # Fill character; ignored on input.\nSPACE = u' ' # Space or blank character.\n\nPY3 = (sys.version_info[0] >= 3)\nif PY3:\n    unicode = str\n\ndef constrain (n, min, max):\n\n    '''This returns a number, n constrained to the min and max bounds. '''\n\n    if n < min:\n        return min\n    if n > max:\n        return max\n    return n\n\nclass screen:\n    '''This object maintains the state of a virtual text screen as a\n    rectangular array. This maintains a virtual cursor position and handles\n    scrolling as characters are added. This supports most of the methods needed\n    by an ANSI text screen. Row and column indexes are 1-based (not zero-based,\n    like arrays).\n\n    Characters are represented internally using unicode. Methods that accept\n    input characters, when passed 'bytes' (which in Python 2 is equivalent to\n    'str'), convert them from the encoding specified in the 'encoding'\n    parameter to the constructor. Methods that return screen contents return\n    unicode strings, with the exception of __str__() under Python 2. Passing\n    ``encoding=None`` limits the API to only accept unicode input, so passing\n    bytes in will raise :exc:`TypeError`.\n    '''\n    def __init__(self, r=24, c=80, encoding='latin-1', encoding_errors='replace'):\n        '''This initializes a blank screen of the given dimensions.'''\n\n        self.rows = r\n        self.cols = c\n        self.encoding = encoding\n        self.encoding_errors = encoding_errors\n        if encoding is not None:\n            self.decoder = codecs.getincrementaldecoder(encoding)(encoding_errors)\n        else:\n            self.decoder = None\n        self.cur_r = 1\n        self.cur_c = 1\n        self.cur_saved_r = 1\n        self.cur_saved_c = 1\n        self.scroll_row_start = 1\n        self.scroll_row_end = self.rows\n        self.w = [ [SPACE] * self.cols for _ in range(self.rows)]\n\n    def _decode(self, s):\n        '''This converts from the external coding system (as passed to\n        the constructor) to the internal one (unicode). '''\n        if self.decoder is not None:\n            return self.decoder.decode(s)\n        else:\n            raise TypeError(\"This screen was constructed with encoding=None, \"\n                            \"so it does not handle bytes.\")\n\n    def _unicode(self):\n        '''This returns a printable representation of the screen as a unicode\n        string (which, under Python 3.x, is the same as 'str'). The end of each\n        screen line is terminated by a newline.'''\n\n        return u'\\n'.join ([ u''.join(c) for c in self.w ])\n\n    if PY3:\n        __str__ = _unicode\n    else:\n        __unicode__ = _unicode\n\n        def __str__(self):\n            '''This returns a printable representation of the screen. The end of\n            each screen line is terminated by a newline. '''\n            encoding = self.encoding or 'ascii'\n            return self._unicode().encode(encoding, 'replace')\n\n    def dump (self):\n        '''This returns a copy of the screen as a unicode string. This is similar to\n        __str__/__unicode__ except that lines are not terminated with line\n        feeds.'''\n\n        return u''.join ([ u''.join(c) for c in self.w ])\n\n    def pretty (self):\n        '''This returns a copy of the screen as a unicode string with an ASCII\n        text box around the screen border. This is similar to\n        __str__/__unicode__ except that it adds a box.'''\n\n        top_bot = u'+' + u'-'*self.cols + u'+\\n'\n        return top_bot + u'\\n'.join([u'|'+line+u'|' for line in unicode(self).split(u'\\n')]) + u'\\n' + top_bot\n\n    def fill (self, ch=SPACE):\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        self.fill_region (1,1,self.rows,self.cols, ch)\n\n    def fill_region (self, rs,cs, re,ce, ch=SPACE):\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        rs = constrain (rs, 1, self.rows)\n        re = constrain (re, 1, self.rows)\n        cs = constrain (cs, 1, self.cols)\n        ce = constrain (ce, 1, self.cols)\n        if rs > re:\n            rs, re = re, rs\n        if cs > ce:\n            cs, ce = ce, cs\n        for r in range (rs, re+1):\n            for c in range (cs, ce + 1):\n                self.put_abs (r,c,ch)\n\n    def cr (self):\n        '''This moves the cursor to the beginning (col 1) of the current row.\n        '''\n\n        self.cursor_home (self.cur_r, 1)\n\n    def lf (self):\n        '''This moves the cursor down with scrolling.\n        '''\n\n        old_r = self.cur_r\n        self.cursor_down()\n        if old_r == self.cur_r:\n            self.scroll_up ()\n            self.erase_line()\n\n    def crlf (self):\n        '''This advances the cursor with CRLF properties.\n        The cursor will line wrap and the screen may scroll.\n        '''\n\n        self.cr ()\n        self.lf ()\n\n    def newline (self):\n        '''This is an alias for crlf().\n        '''\n\n        self.crlf()\n\n    def put_abs (self, r, c, ch):\n        '''Screen array starts at 1 index.'''\n\n        r = constrain (r, 1, self.rows)\n        c = constrain (c, 1, self.cols)\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)[0]\n        else:\n            ch = ch[0]\n        self.w[r-1][c-1] = ch\n\n    def put (self, ch):\n        '''This puts a characters at the current cursor position.\n        '''\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        self.put_abs (self.cur_r, self.cur_c, ch)\n\n    def insert_abs (self, r, c, ch):\n        '''This inserts a character at (r,c). Everything under\n        and to the right is shifted right one character.\n        The last character of the line is lost.\n        '''\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        r = constrain (r, 1, self.rows)\n        c = constrain (c, 1, self.cols)\n        for ci in range (self.cols, c, -1):\n            self.put_abs (r,ci, self.get_abs(r,ci-1))\n        self.put_abs (r,c,ch)\n\n    def insert (self, ch):\n\n        if isinstance(ch, bytes):\n            ch = self._decode(ch)\n\n        self.insert_abs (self.cur_r, self.cur_c, ch)\n\n    def get_abs (self, r, c):\n\n        r = constrain (r, 1, self.rows)\n        c = constrain (c, 1, self.cols)\n        return self.w[r-1][c-1]\n\n    def get (self):\n\n        self.get_abs (self.cur_r, self.cur_c)\n\n    def get_region (self, rs,cs, re,ce):\n        '''This returns a list of lines representing the region.\n        '''\n\n        rs = constrain (rs, 1, self.rows)\n        re = constrain (re, 1, self.rows)\n        cs = constrain (cs, 1, self.cols)\n        ce = constrain (ce, 1, self.cols)\n        if rs > re:\n            rs, re = re, rs\n        if cs > ce:\n            cs, ce = ce, cs\n        sc = []\n        for r in range (rs, re+1):\n            line = u''\n            for c in range (cs, ce + 1):\n                ch = self.get_abs (r,c)\n                line = line + ch\n            sc.append (line)\n        return sc\n\n    def cursor_constrain (self):\n        '''This keeps the cursor within the screen area.\n        '''\n\n        self.cur_r = constrain (self.cur_r, 1, self.rows)\n        self.cur_c = constrain (self.cur_c, 1, self.cols)\n\n    def cursor_home (self, r=1, c=1): # <ESC>[{ROW};{COLUMN}H\n\n        self.cur_r = r\n        self.cur_c = c\n        self.cursor_constrain ()\n\n    def cursor_back (self,count=1): # <ESC>[{COUNT}D (not confused with down)\n\n        self.cur_c = self.cur_c - count\n        self.cursor_constrain ()\n\n    def cursor_down (self,count=1): # <ESC>[{COUNT}B (not confused with back)\n\n        self.cur_r = self.cur_r + count\n        self.cursor_constrain ()\n\n    def cursor_forward (self,count=1): # <ESC>[{COUNT}C\n\n        self.cur_c = self.cur_c + count\n        self.cursor_constrain ()\n\n    def cursor_up (self,count=1): # <ESC>[{COUNT}A\n\n        self.cur_r = self.cur_r - count\n        self.cursor_constrain ()\n\n    def cursor_up_reverse (self): # <ESC> M   (called RI -- Reverse Index)\n\n        old_r = self.cur_r\n        self.cursor_up()\n        if old_r == self.cur_r:\n            self.scroll_up()\n\n    def cursor_force_position (self, r, c): # <ESC>[{ROW};{COLUMN}f\n        '''Identical to Cursor Home.'''\n\n        self.cursor_home (r, c)\n\n    def cursor_save (self): # <ESC>[s\n        '''Save current cursor position.'''\n\n        self.cursor_save_attrs()\n\n    def cursor_unsave (self): # <ESC>[u\n        '''Restores cursor position after a Save Cursor.'''\n\n        self.cursor_restore_attrs()\n\n    def cursor_save_attrs (self): # <ESC>7\n        '''Save current cursor position.'''\n\n        self.cur_saved_r = self.cur_r\n        self.cur_saved_c = self.cur_c\n\n    def cursor_restore_attrs (self): # <ESC>8\n        '''Restores cursor position after a Save Cursor.'''\n\n        self.cursor_home (self.cur_saved_r, self.cur_saved_c)\n\n    def scroll_constrain (self):\n        '''This keeps the scroll region within the screen region.'''\n\n        if self.scroll_row_start <= 0:\n            self.scroll_row_start = 1\n        if self.scroll_row_end > self.rows:\n            self.scroll_row_end = self.rows\n\n    def scroll_screen (self): # <ESC>[r\n        '''Enable scrolling for entire display.'''\n\n        self.scroll_row_start = 1\n        self.scroll_row_end = self.rows\n\n    def scroll_screen_rows (self, rs, re): # <ESC>[{start};{end}r\n        '''Enable scrolling from row {start} to row {end}.'''\n\n        self.scroll_row_start = rs\n        self.scroll_row_end = re\n        self.scroll_constrain()\n\n    def scroll_down (self): # <ESC>D\n        '''Scroll display down one line.'''\n\n        # Screen is indexed from 1, but arrays are indexed from 0.\n        s = self.scroll_row_start - 1\n        e = self.scroll_row_end - 1\n        self.w[s+1:e+1] = copy.deepcopy(self.w[s:e])\n\n    def scroll_up (self): # <ESC>M\n        '''Scroll display up one line.'''\n\n        # Screen is indexed from 1, but arrays are indexed from 0.\n        s = self.scroll_row_start - 1\n        e = self.scroll_row_end - 1\n        self.w[s:e] = copy.deepcopy(self.w[s+1:e+1])\n\n    def erase_end_of_line (self): # <ESC>[0K -or- <ESC>[K\n        '''Erases from the current cursor position to the end of the current\n        line.'''\n\n        self.fill_region (self.cur_r, self.cur_c, self.cur_r, self.cols)\n\n    def erase_start_of_line (self): # <ESC>[1K\n        '''Erases from the current cursor position to the start of the current\n        line.'''\n\n        self.fill_region (self.cur_r, 1, self.cur_r, self.cur_c)\n\n    def erase_line (self): # <ESC>[2K\n        '''Erases the entire current line.'''\n\n        self.fill_region (self.cur_r, 1, self.cur_r, self.cols)\n\n    def erase_down (self): # <ESC>[0J -or- <ESC>[J\n        '''Erases the screen from the current line down to the bottom of the\n        screen.'''\n\n        self.erase_end_of_line ()\n        self.fill_region (self.cur_r + 1, 1, self.rows, self.cols)\n\n    def erase_up (self): # <ESC>[1J\n        '''Erases the screen from the current line up to the top of the\n        screen.'''\n\n        self.erase_start_of_line ()\n        self.fill_region (self.cur_r-1, 1, 1, self.cols)\n\n    def erase_screen (self): # <ESC>[2J\n        '''Erases the screen with the background color.'''\n\n        self.fill ()\n\n    def set_tab (self): # <ESC>H\n        '''Sets a tab at the current position.'''\n\n        pass\n\n    def clear_tab (self): # <ESC>[g\n        '''Clears tab at the current position.'''\n\n        pass\n\n    def clear_all_tabs (self): # <ESC>[3g\n        '''Clears all tabs.'''\n\n        pass\n\n#        Insert line             Esc [ Pn L\n#        Delete line             Esc [ Pn M\n#        Delete character        Esc [ Pn P\n#        Scrolling region        Esc [ Pn(top);Pn(bot) r\n\n", "pexpect/utils.py": "import os\nimport sys\nimport stat\nimport select\nimport time\nimport errno\n\ntry:\n    InterruptedError\nexcept NameError:\n    # Alias Python2 exception to Python3\n    InterruptedError = select.error\n\nif sys.version_info[0] >= 3:\n    string_types = (str,)\nelse:\n    string_types = (unicode, str)\n\n\ndef is_executable_file(path):\n    \"\"\"Checks that path is an executable regular file, or a symlink towards one.\n\n    This is roughly ``os.path isfile(path) and os.access(path, os.X_OK)``.\n    \"\"\"\n    # follow symlinks,\n    fpath = os.path.realpath(path)\n\n    if not os.path.isfile(fpath):\n        # non-files (directories, fifo, etc.)\n        return False\n\n    mode = os.stat(fpath).st_mode\n\n    if (sys.platform.startswith('sunos')\n            and os.getuid() == 0):\n        # When root on Solaris, os.X_OK is True for *all* files, irregardless\n        # of their executability -- instead, any permission bit of any user,\n        # group, or other is fine enough.\n        #\n        # (This may be true for other \"Unix98\" OS's such as HP-UX and AIX)\n        return bool(mode & (stat.S_IXUSR |\n                            stat.S_IXGRP |\n                            stat.S_IXOTH))\n\n    return os.access(fpath, os.X_OK)\n\n\ndef which(filename, env=None):\n    '''This takes a given filename; tries to find it in the environment path;\n    then checks if it is executable. This returns the full path to the filename\n    if found and executable. Otherwise this returns None.'''\n\n    # Special case where filename contains an explicit path.\n    if os.path.dirname(filename) != '' and is_executable_file(filename):\n        return filename\n    if env is None:\n        env = os.environ\n    p = env.get('PATH')\n    if not p:\n        p = os.defpath\n    pathlist = p.split(os.pathsep)\n    for path in pathlist:\n        ff = os.path.join(path, filename)\n        if is_executable_file(ff):\n            return ff\n    return None\n\n\ndef split_command_line(command_line):\n\n    '''This splits a command line into a list of arguments. It splits arguments\n    on spaces, but handles embedded quotes, doublequotes, and escaped\n    characters. It's impossible to do this with a regular expression, so I\n    wrote a little state machine to parse the command line. '''\n\n    arg_list = []\n    arg = ''\n\n    # Constants to name the states we can be in.\n    state_basic = 0\n    state_esc = 1\n    state_singlequote = 2\n    state_doublequote = 3\n    # The state when consuming whitespace between commands.\n    state_whitespace = 4\n    state = state_basic\n\n    for c in command_line:\n        if state == state_basic or state == state_whitespace:\n            if c == '\\\\':\n                # Escape the next character\n                state = state_esc\n            elif c == r\"'\":\n                # Handle single quote\n                state = state_singlequote\n            elif c == r'\"':\n                # Handle double quote\n                state = state_doublequote\n            elif c.isspace():\n                # Add arg to arg_list if we aren't in the middle of whitespace.\n                if state == state_whitespace:\n                    # Do nothing.\n                    None\n                else:\n                    arg_list.append(arg)\n                    arg = ''\n                    state = state_whitespace\n            else:\n                arg = arg + c\n                state = state_basic\n        elif state == state_esc:\n            arg = arg + c\n            state = state_basic\n        elif state == state_singlequote:\n            if c == r\"'\":\n                state = state_basic\n            else:\n                arg = arg + c\n        elif state == state_doublequote:\n            if c == r'\"':\n                state = state_basic\n            else:\n                arg = arg + c\n\n    if arg != '':\n        arg_list.append(arg)\n    return arg_list\n\n\ndef select_ignore_interrupts(iwtd, owtd, ewtd, timeout=None):\n\n    '''This is a wrapper around select.select() that ignores signals. If\n    select.select raises a select.error exception and errno is an EINTR\n    error then it is ignored. Mainly this is used to ignore sigwinch\n    (terminal resize). '''\n\n    # if select() is interrupted by a signal (errno==EINTR) then\n    # we loop back and enter the select() again.\n    if timeout is not None:\n        end_time = time.time() + timeout\n    while True:\n        try:\n            return select.select(iwtd, owtd, ewtd, timeout)\n        except InterruptedError:\n            err = sys.exc_info()[1]\n            if err.args[0] == errno.EINTR:\n                # if we loop back we have to subtract the\n                # amount of time we already waited.\n                if timeout is not None:\n                    timeout = end_time - time.time()\n                    if timeout < 0:\n                        return([], [], [])\n            else:\n                # something else caused the select.error, so\n                # this actually is an exception.\n                raise\n\n\ndef poll_ignore_interrupts(fds, timeout=None):\n    '''Simple wrapper around poll to register file descriptors and\n    ignore signals.'''\n\n    if timeout is not None:\n        end_time = time.time() + timeout\n\n    poller = select.poll()\n    for fd in fds:\n        poller.register(fd, select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR)\n\n    while True:\n        try:\n            timeout_ms = None if timeout is None else timeout * 1000\n            results = poller.poll(timeout_ms)\n            return [afd for afd, _ in results]\n        except InterruptedError:\n            err = sys.exc_info()[1]\n            if err.args[0] == errno.EINTR:\n                # if we loop back we have to subtract the\n                # amount of time we already waited.\n                if timeout is not None:\n                    timeout = end_time - time.time()\n                    if timeout < 0:\n                        return []\n            else:\n                # something else caused the select.error, so\n                # this actually is an exception.\n                raise\n", "pexpect/expect.py": "import time\n\nfrom .exceptions import EOF, TIMEOUT\n\nclass Expecter(object):\n    def __init__(self, spawn, searcher, searchwindowsize=-1):\n        self.spawn = spawn\n        self.searcher = searcher\n        # A value of -1 means to use the figure from spawn, which should\n        # be None or a positive number.\n        if searchwindowsize == -1:\n            searchwindowsize = spawn.searchwindowsize\n        self.searchwindowsize = searchwindowsize\n        self.lookback = None\n        if hasattr(searcher, 'longest_string'):\n            self.lookback = searcher.longest_string\n\n    def do_search(self, window, freshlen):\n        spawn = self.spawn\n        searcher = self.searcher\n        if freshlen > len(window):\n            freshlen = len(window)\n        index = searcher.search(window, freshlen, self.searchwindowsize)\n        if index >= 0:\n            spawn._buffer = spawn.buffer_type()\n            spawn._buffer.write(window[searcher.end:])\n            spawn.before = spawn._before.getvalue()[\n                0:-(len(window) - searcher.start)]\n            spawn._before = spawn.buffer_type()\n            spawn._before.write(window[searcher.end:])\n            spawn.after = window[searcher.start:searcher.end]\n            spawn.match = searcher.match\n            spawn.match_index = index\n            # Found a match\n            return index\n        elif self.searchwindowsize or self.lookback:\n            maintain = self.searchwindowsize or self.lookback\n            if spawn._buffer.tell() > maintain:\n                spawn._buffer = spawn.buffer_type()\n                spawn._buffer.write(window[-maintain:])\n\n    def existing_data(self):\n        # First call from a new call to expect_loop or expect_async.\n        # self.searchwindowsize may have changed.\n        # Treat all data as fresh.\n        spawn = self.spawn\n        before_len = spawn._before.tell()\n        buf_len = spawn._buffer.tell()\n        freshlen = before_len\n        if before_len > buf_len:\n            if not self.searchwindowsize:\n                spawn._buffer = spawn.buffer_type()\n                window = spawn._before.getvalue()\n                spawn._buffer.write(window)\n            elif buf_len < self.searchwindowsize:\n                spawn._buffer = spawn.buffer_type()\n                spawn._before.seek(\n                    max(0, before_len - self.searchwindowsize))\n                window = spawn._before.read()\n                spawn._buffer.write(window)\n            else:\n                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))\n                window = spawn._buffer.read()\n        else:\n            if self.searchwindowsize:\n                spawn._buffer.seek(max(0, buf_len - self.searchwindowsize))\n                window = spawn._buffer.read()\n            else:\n                window = spawn._buffer.getvalue()\n        return self.do_search(window, freshlen)\n\n    def new_data(self, data):\n        # A subsequent call, after a call to existing_data.\n        spawn = self.spawn\n        freshlen = len(data)\n        spawn._before.write(data)\n        if not self.searchwindowsize:\n            if self.lookback:\n                # search lookback + new data.\n                old_len = spawn._buffer.tell()\n                spawn._buffer.write(data)\n                spawn._buffer.seek(max(0, old_len - self.lookback))\n                window = spawn._buffer.read()\n            else:\n                # copy the whole buffer (really slow for large datasets).\n                spawn._buffer.write(data)\n                window = spawn.buffer\n        else:\n            if len(data) >= self.searchwindowsize or not spawn._buffer.tell():\n                window = data[-self.searchwindowsize:]\n                spawn._buffer = spawn.buffer_type()\n                spawn._buffer.write(window[-self.searchwindowsize:])\n            else:\n                spawn._buffer.write(data)\n                new_len = spawn._buffer.tell()\n                spawn._buffer.seek(max(0, new_len - self.searchwindowsize))\n                window = spawn._buffer.read()\n        return self.do_search(window, freshlen)\n\n    def eof(self, err=None):\n        spawn = self.spawn\n\n        spawn.before = spawn._before.getvalue()\n        spawn._buffer = spawn.buffer_type()\n        spawn._before = spawn.buffer_type()\n        spawn.after = EOF\n        index = self.searcher.eof_index\n        if index >= 0:\n            spawn.match = EOF\n            spawn.match_index = index\n            return index\n        else:\n            spawn.match = None\n            spawn.match_index = None\n            msg = str(spawn)\n            msg += '\\nsearcher: %s' % self.searcher\n            if err is not None:\n                msg = str(err) + '\\n' + msg\n\n            exc = EOF(msg)\n            exc.__cause__ = None # in Python 3.x we can use \"raise exc from None\"\n            raise exc\n\n    def timeout(self, err=None):\n        spawn = self.spawn\n\n        spawn.before = spawn._before.getvalue()\n        spawn.after = TIMEOUT\n        index = self.searcher.timeout_index\n        if index >= 0:\n            spawn.match = TIMEOUT\n            spawn.match_index = index\n            return index\n        else:\n            spawn.match = None\n            spawn.match_index = None\n            msg = str(spawn)\n            msg += '\\nsearcher: %s' % self.searcher\n            if err is not None:\n                msg = str(err) + '\\n' + msg\n\n            exc = TIMEOUT(msg)\n            exc.__cause__ = None    # in Python 3.x we can use \"raise exc from None\"\n            raise exc\n\n    def errored(self):\n        spawn = self.spawn\n        spawn.before = spawn._before.getvalue()\n        spawn.after = None\n        spawn.match = None\n        spawn.match_index = None\n\n    def expect_loop(self, timeout=-1):\n        \"\"\"Blocking expect\"\"\"\n        spawn = self.spawn\n\n        if timeout is not None:\n            end_time = time.time() + timeout\n\n        try:\n            idx = self.existing_data()\n            if idx is not None:\n                return idx\n            while True:\n                # No match at this point\n                if (timeout is not None) and (timeout < 0):\n                    return self.timeout()\n                # Still have time left, so read more data\n                incoming = spawn.read_nonblocking(spawn.maxread, timeout)\n                if self.spawn.delayafterread is not None:\n                    time.sleep(self.spawn.delayafterread)\n                idx = self.new_data(incoming)\n                # Keep reading until exception or return.\n                if idx is not None:\n                    return idx\n                if timeout is not None:\n                    timeout = end_time - time.time()\n        except EOF as e:\n            return self.eof(e)\n        except TIMEOUT as e:\n            return self.timeout(e)\n        except:\n            self.errored()\n            raise\n\n\nclass searcher_string(object):\n    '''This is a plain string search helper for the spawn.expect_any() method.\n    This helper class is for speed. For more powerful regex patterns\n    see the helper class, searcher_re.\n\n    Attributes:\n\n        eof_index     - index of EOF, or -1\n        timeout_index - index of TIMEOUT, or -1\n\n    After a successful match by the search() method the following attributes\n    are available:\n\n        start - index into the buffer, first byte of match\n        end   - index into the buffer, first byte after match\n        match - the matching string itself\n\n    '''\n\n    def __init__(self, strings):\n        '''This creates an instance of searcher_string. This argument 'strings'\n        may be a list; a sequence of strings; or the EOF or TIMEOUT types. '''\n\n        self.eof_index = -1\n        self.timeout_index = -1\n        self._strings = []\n        self.longest_string = 0\n        for n, s in enumerate(strings):\n            if s is EOF:\n                self.eof_index = n\n                continue\n            if s is TIMEOUT:\n                self.timeout_index = n\n                continue\n            self._strings.append((n, s))\n            if len(s) > self.longest_string:\n                self.longest_string = len(s)\n\n    def __str__(self):\n        '''This returns a human-readable string that represents the state of\n        the object.'''\n\n        ss = [(ns[0], '    %d: %r' % ns) for ns in self._strings]\n        ss.append((-1, 'searcher_string:'))\n        if self.eof_index >= 0:\n            ss.append((self.eof_index, '    %d: EOF' % self.eof_index))\n        if self.timeout_index >= 0:\n            ss.append((self.timeout_index,\n                '    %d: TIMEOUT' % self.timeout_index))\n        ss.sort()\n        ss = list(zip(*ss))[1]\n        return '\\n'.join(ss)\n\n    def search(self, buffer, freshlen, searchwindowsize=None):\n        '''This searches 'buffer' for the first occurrence of one of the search\n        strings.  'freshlen' must indicate the number of bytes at the end of\n        'buffer' which have not been searched before. It helps to avoid\n        searching the same, possibly big, buffer over and over again.\n\n        See class spawn for the 'searchwindowsize' argument.\n\n        If there is a match this returns the index of that string, and sets\n        'start', 'end' and 'match'. Otherwise, this returns -1. '''\n\n        first_match = None\n\n        # 'freshlen' helps a lot here. Further optimizations could\n        # possibly include:\n        #\n        # using something like the Boyer-Moore Fast String Searching\n        # Algorithm; pre-compiling the search through a list of\n        # strings into something that can scan the input once to\n        # search for all N strings; realize that if we search for\n        # ['bar', 'baz'] and the input is '...foo' we need not bother\n        # rescanning until we've read three more bytes.\n        #\n        # Sadly, I don't know enough about this interesting topic. /grahn\n\n        for index, s in self._strings:\n            if searchwindowsize is None:\n                # the match, if any, can only be in the fresh data,\n                # or at the very end of the old data\n                offset = -(freshlen + len(s))\n            else:\n                # better obey searchwindowsize\n                offset = -searchwindowsize\n            n = buffer.find(s, offset)\n            if n >= 0 and (first_match is None or n < first_match):\n                first_match = n\n                best_index, best_match = index, s\n        if first_match is None:\n            return -1\n        self.match = best_match\n        self.start = first_match\n        self.end = self.start + len(self.match)\n        return best_index\n\n\nclass searcher_re(object):\n    '''This is regular expression string search helper for the\n    spawn.expect_any() method. This helper class is for powerful\n    pattern matching. For speed, see the helper class, searcher_string.\n\n    Attributes:\n\n        eof_index     - index of EOF, or -1\n        timeout_index - index of TIMEOUT, or -1\n\n    After a successful match by the search() method the following attributes\n    are available:\n\n        start - index into the buffer, first byte of match\n        end   - index into the buffer, first byte after match\n        match - the re.match object returned by a successful re.search\n\n    '''\n\n    def __init__(self, patterns):\n        '''This creates an instance that searches for 'patterns' Where\n        'patterns' may be a list or other sequence of compiled regular\n        expressions, or the EOF or TIMEOUT types.'''\n\n        self.eof_index = -1\n        self.timeout_index = -1\n        self._searches = []\n        for n, s in enumerate(patterns):\n            if s is EOF:\n                self.eof_index = n\n                continue\n            if s is TIMEOUT:\n                self.timeout_index = n\n                continue\n            self._searches.append((n, s))\n\n    def __str__(self):\n        '''This returns a human-readable string that represents the state of\n        the object.'''\n\n        #ss = [(n, '    %d: re.compile(\"%s\")' %\n        #    (n, repr(s.pattern))) for n, s in self._searches]\n        ss = list()\n        for n, s in self._searches:\n            ss.append((n, '    %d: re.compile(%r)' % (n, s.pattern)))\n        ss.append((-1, 'searcher_re:'))\n        if self.eof_index >= 0:\n            ss.append((self.eof_index, '    %d: EOF' % self.eof_index))\n        if self.timeout_index >= 0:\n            ss.append((self.timeout_index, '    %d: TIMEOUT' %\n                self.timeout_index))\n        ss.sort()\n        ss = list(zip(*ss))[1]\n        return '\\n'.join(ss)\n\n    def search(self, buffer, freshlen, searchwindowsize=None):\n        '''This searches 'buffer' for the first occurrence of one of the regular\n        expressions. 'freshlen' must indicate the number of bytes at the end of\n        'buffer' which have not been searched before.\n\n        See class spawn for the 'searchwindowsize' argument.\n\n        If there is a match this returns the index of that string, and sets\n        'start', 'end' and 'match'. Otherwise, returns -1.'''\n\n        first_match = None\n        # 'freshlen' doesn't help here -- we cannot predict the\n        # length of a match, and the re module provides no help.\n        if searchwindowsize is None:\n            searchstart = 0\n        else:\n            searchstart = max(0, len(buffer) - searchwindowsize)\n        for index, s in self._searches:\n            match = s.search(buffer, searchstart)\n            if match is None:\n                continue\n            n = match.start()\n            if first_match is None or n < first_match:\n                first_match = n\n                the_match = match\n                best_index = index\n        if first_match is None:\n            return -1\n        self.start = first_match\n        self.match = the_match\n        self.end = self.match.end()\n        return best_index\n", "pexpect/replwrap.py": "\"\"\"Generic wrapper for read-eval-print-loops, a.k.a. interactive shells\n\"\"\"\nimport os.path\nimport signal\nimport sys\n\nimport pexpect\n\nPY3 = (sys.version_info[0] >= 3)\n\nif PY3:\n    basestring = str\n\nPEXPECT_PROMPT = u'[PEXPECT_PROMPT>'\nPEXPECT_CONTINUATION_PROMPT = u'[PEXPECT_PROMPT+'\n\nclass REPLWrapper(object):\n    \"\"\"Wrapper for a REPL.\n\n    :param cmd_or_spawn: This can either be an instance of :class:`pexpect.spawn`\n      in which a REPL has already been started, or a str command to start a new\n      REPL process.\n    :param str orig_prompt: The prompt to expect at first.\n    :param str prompt_change: A command to change the prompt to something more\n      unique. If this is ``None``, the prompt will not be changed. This will\n      be formatted with the new and continuation prompts as positional\n      parameters, so you can use ``{}`` style formatting to insert them into\n      the command.\n    :param str new_prompt: The more unique prompt to expect after the change.\n    :param str extra_init_cmd: Commands to do extra initialisation, such as\n      disabling pagers.\n    \"\"\"\n    def __init__(self, cmd_or_spawn, orig_prompt, prompt_change,\n                 new_prompt=PEXPECT_PROMPT,\n                 continuation_prompt=PEXPECT_CONTINUATION_PROMPT,\n                 extra_init_cmd=None):\n        if isinstance(cmd_or_spawn, basestring):\n            self.child = pexpect.spawn(cmd_or_spawn, echo=False, encoding='utf-8')\n        else:\n            self.child = cmd_or_spawn\n        if self.child.echo:\n            # Existing spawn instance has echo enabled, disable it\n            # to prevent our input from being repeated to output.\n            self.child.setecho(False)\n            self.child.waitnoecho()\n\n        if prompt_change is None:\n            self.prompt = orig_prompt\n        else:\n            self.set_prompt(orig_prompt,\n                        prompt_change.format(new_prompt, continuation_prompt))\n            self.prompt = new_prompt\n        self.continuation_prompt = continuation_prompt\n\n        self._expect_prompt()\n\n        if extra_init_cmd is not None:\n            self.run_command(extra_init_cmd)\n\n    def set_prompt(self, orig_prompt, prompt_change):\n        self.child.expect(orig_prompt)\n        self.child.sendline(prompt_change)\n\n    def _expect_prompt(self, timeout=-1, async_=False):\n        return self.child.expect_exact([self.prompt, self.continuation_prompt],\n                                       timeout=timeout, async_=async_)\n\n    def run_command(self, command, timeout=-1, async_=False):\n        \"\"\"Send a command to the REPL, wait for and return output.\n\n        :param str command: The command to send. Trailing newlines are not needed.\n          This should be a complete block of input that will trigger execution;\n          if a continuation prompt is found after sending input, :exc:`ValueError`\n          will be raised.\n        :param int timeout: How long to wait for the next prompt. -1 means the\n          default from the :class:`pexpect.spawn` object (default 30 seconds).\n          None means to wait indefinitely.\n        :param bool async_: On Python 3.4, or Python 3.3 with asyncio\n          installed, passing ``async_=True`` will make this return an\n          :mod:`asyncio` Future, which you can yield from to get the same\n          result that this method would normally give directly.\n        \"\"\"\n        # Split up multiline commands and feed them in bit-by-bit\n        cmdlines = command.splitlines()\n        # splitlines ignores trailing newlines - add it back in manually\n        if command.endswith('\\n'):\n            cmdlines.append('')\n        if not cmdlines:\n            raise ValueError(\"No command was given\")\n\n        if async_:\n            from ._async import repl_run_command_async\n            return repl_run_command_async(self, cmdlines, timeout)\n\n        res = []\n        self.child.sendline(cmdlines[0])\n        for line in cmdlines[1:]:\n            self._expect_prompt(timeout=timeout)\n            res.append(self.child.before)\n            self.child.sendline(line)\n\n        # Command was fully submitted, now wait for the next prompt\n        if self._expect_prompt(timeout=timeout) == 1:\n            # We got the continuation prompt - command was incomplete\n            self.child.kill(signal.SIGINT)\n            self._expect_prompt(timeout=1)\n            raise ValueError(\"Continuation prompt found - input was incomplete:\\n\"\n                             + command)\n        return u''.join(res + [self.child.before])\n\ndef python(command=sys.executable):\n    \"\"\"Start a Python shell and return a :class:`REPLWrapper` object.\"\"\"\n    return REPLWrapper(command, u\">>> \", u\"import sys; sys.ps1={0!r}; sys.ps2={1!r}\")\n\ndef _repl_sh(command, args, non_printable_insert):\n    child = pexpect.spawn(command, args, echo=False, encoding='utf-8')\n\n    # If the user runs 'env', the value of PS1 will be in the output. To avoid\n    # replwrap seeing that as the next prompt, we'll embed the marker characters\n    # for invisible characters in the prompt; these show up when inspecting the\n    # environment variable, but not when bash displays the prompt.\n    ps1 = PEXPECT_PROMPT[:5] + non_printable_insert + PEXPECT_PROMPT[5:]\n    ps2 = PEXPECT_CONTINUATION_PROMPT[:5] + non_printable_insert + PEXPECT_CONTINUATION_PROMPT[5:]\n    prompt_change = u\"PS1='{0}' PS2='{1}' PROMPT_COMMAND=''\".format(ps1, ps2)\n\n    return REPLWrapper(child, u'\\\\$', prompt_change,\n                       extra_init_cmd=\"export PAGER=cat\")\n\ndef bash(command=\"bash\"):\n    \"\"\"Start a bash shell and return a :class:`REPLWrapper` object.\"\"\"\n    bashrc = os.path.join(os.path.dirname(__file__), 'bashrc.sh')\n    return _repl_sh(command, ['--rcfile', bashrc], non_printable_insert='\\\\[\\\\]')\n\ndef zsh(command=\"zsh\", args=(\"--no-rcs\", \"-V\", \"+Z\")):\n    \"\"\"Start a zsh shell and return a :class:`REPLWrapper` object.\"\"\"\n    return _repl_sh(command, list(args), non_printable_insert='%(!..)')\n", "pexpect/_async_pre_await.py": "\"\"\"Implementation of coroutines without using ``async def``/``await`` keywords.\n\n``@asyncio.coroutine`` and ``yield from`` are  used here instead.\n\"\"\"\nimport asyncio\nimport errno\nimport signal\n\nfrom pexpect import EOF\n\n\n@asyncio.coroutine\ndef expect_async(expecter, timeout=None):\n    # First process data that was previously read - if it maches, we don't need\n    # async stuff.\n    idx = expecter.existing_data()\n    if idx is not None:\n        return idx\n    if not expecter.spawn.async_pw_transport:\n        pw = PatternWaiter()\n        pw.set_expecter(expecter)\n        transport, pw = yield from asyncio.get_event_loop().connect_read_pipe(\n            lambda: pw, expecter.spawn\n        )\n        expecter.spawn.async_pw_transport = pw, transport\n    else:\n        pw, transport = expecter.spawn.async_pw_transport\n        pw.set_expecter(expecter)\n        transport.resume_reading()\n    try:\n        return (yield from asyncio.wait_for(pw.fut, timeout))\n    except asyncio.TimeoutError as e:\n        transport.pause_reading()\n        return expecter.timeout(e)\n\n\n@asyncio.coroutine\ndef repl_run_command_async(repl, cmdlines, timeout=-1):\n    res = []\n    repl.child.sendline(cmdlines[0])\n    for line in cmdlines[1:]:\n        yield from repl._expect_prompt(timeout=timeout, async_=True)\n        res.append(repl.child.before)\n        repl.child.sendline(line)\n\n    # Command was fully submitted, now wait for the next prompt\n    prompt_idx = yield from repl._expect_prompt(timeout=timeout, async_=True)\n    if prompt_idx == 1:\n        # We got the continuation prompt - command was incomplete\n        repl.child.kill(signal.SIGINT)\n        yield from repl._expect_prompt(timeout=1, async_=True)\n        raise ValueError(\"Continuation prompt found - input was incomplete:\")\n    return \"\".join(res + [repl.child.before])\n\n\nclass PatternWaiter(asyncio.Protocol):\n    transport = None\n\n    def set_expecter(self, expecter):\n        self.expecter = expecter\n        self.fut = asyncio.Future()\n\n    def found(self, result):\n        if not self.fut.done():\n            self.fut.set_result(result)\n            self.transport.pause_reading()\n\n    def error(self, exc):\n        if not self.fut.done():\n            self.fut.set_exception(exc)\n            self.transport.pause_reading()\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data):\n        spawn = self.expecter.spawn\n        s = spawn._decoder.decode(data)\n        spawn._log(s, \"read\")\n\n        if self.fut.done():\n            spawn._before.write(s)\n            spawn._buffer.write(s)\n            return\n\n        try:\n            index = self.expecter.new_data(s)\n            if index is not None:\n                # Found a match\n                self.found(index)\n        except Exception as e:\n            self.expecter.errored()\n            self.error(e)\n\n    def eof_received(self):\n        # N.B. If this gets called, async will close the pipe (the spawn object)\n        # for us\n        try:\n            self.expecter.spawn.flag_eof = True\n            index = self.expecter.eof()\n        except EOF as e:\n            self.error(e)\n        else:\n            self.found(index)\n\n    def connection_lost(self, exc):\n        if isinstance(exc, OSError) and exc.errno == errno.EIO:\n            # We may get here without eof_received being called, e.g on Linux\n            self.eof_received()\n        elif exc is not None:\n            self.error(exc)\n", "pexpect/spawnbase.py": "from io import StringIO, BytesIO\nimport codecs\nimport os\nimport sys\nimport re\nimport errno\nfrom .exceptions import ExceptionPexpect, EOF, TIMEOUT\nfrom .expect import Expecter, searcher_string, searcher_re\n\nPY3 = (sys.version_info[0] >= 3)\ntext_type = str if PY3 else unicode\n\nclass _NullCoder(object):\n    \"\"\"Pass bytes through unchanged.\"\"\"\n    @staticmethod\n    def encode(b, final=False):\n        return b\n\n    @staticmethod\n    def decode(b, final=False):\n        return b\n\nclass SpawnBase(object):\n    \"\"\"A base class providing the backwards-compatible spawn API for Pexpect.\n\n    This should not be instantiated directly: use :class:`pexpect.spawn` or\n    :class:`pexpect.fdpexpect.fdspawn`.\n    \"\"\"\n    encoding = None\n    pid = None\n    flag_eof = False\n\n    def __init__(self, timeout=30, maxread=2000, searchwindowsize=None,\n                 logfile=None, encoding=None, codec_errors='strict'):\n        self.stdin = sys.stdin\n        self.stdout = sys.stdout\n        self.stderr = sys.stderr\n\n        self.searcher = None\n        self.ignorecase = False\n        self.before = None\n        self.after = None\n        self.match = None\n        self.match_index = None\n        self.terminated = True\n        self.exitstatus = None\n        self.signalstatus = None\n        # status returned by os.waitpid\n        self.status = None\n        # the child file descriptor is initially closed\n        self.child_fd = -1\n        self.timeout = timeout\n        self.delimiter = EOF\n        self.logfile = logfile\n        # input from child (read_nonblocking)\n        self.logfile_read = None\n        # output to send (send, sendline)\n        self.logfile_send = None\n        # max bytes to read at one time into buffer\n        self.maxread = maxread\n        # Data before searchwindowsize point is preserved, but not searched.\n        self.searchwindowsize = searchwindowsize\n        # Delay used before sending data to child. Time in seconds.\n        # Set this to None to skip the time.sleep() call completely.\n        self.delaybeforesend = 0.05\n        # Used by close() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterclose = 0.1\n        # Used by terminate() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterterminate = 0.1\n        # Delay in seconds to sleep after each call to read_nonblocking().\n        # Set this to None to skip the time.sleep() call completely: that\n        # would restore the behavior from pexpect-2.0 (for performance\n        # reasons or because you don't want to release Python's global\n        # interpreter lock).\n        self.delayafterread = 0.0001\n        self.softspace = False\n        self.name = '<' + repr(self) + '>'\n        self.closed = True\n\n        # Unicode interface\n        self.encoding = encoding\n        self.codec_errors = codec_errors\n        if encoding is None:\n            # bytes mode (accepts some unicode for backwards compatibility)\n            self._encoder = self._decoder = _NullCoder()\n            self.string_type = bytes\n            self.buffer_type = BytesIO\n            self.crlf = b'\\r\\n'\n            if PY3:\n                self.allowed_string_types = (bytes, str)\n                self.linesep = os.linesep.encode('ascii')\n                def write_to_stdout(b):\n                    try:\n                        return sys.stdout.buffer.write(b)\n                    except AttributeError:\n                        # If stdout has been replaced, it may not have .buffer\n                        return sys.stdout.write(b.decode('ascii', 'replace'))\n                self.write_to_stdout = write_to_stdout\n            else:\n                self.allowed_string_types = (basestring,)  # analysis:ignore\n                self.linesep = os.linesep\n                self.write_to_stdout = sys.stdout.write\n        else:\n            # unicode mode\n            self._encoder = codecs.getincrementalencoder(encoding)(codec_errors)\n            self._decoder = codecs.getincrementaldecoder(encoding)(codec_errors)\n            self.string_type = text_type\n            self.buffer_type = StringIO\n            self.crlf = u'\\r\\n'\n            self.allowed_string_types = (text_type, )\n            if PY3:\n                self.linesep = os.linesep\n            else:\n                self.linesep = os.linesep.decode('ascii')\n            # This can handle unicode in both Python 2 and 3\n            self.write_to_stdout = sys.stdout.write\n        # storage for async transport\n        self.async_pw_transport = None\n        # This is the read buffer. See maxread.\n        self._buffer = self.buffer_type()\n        # The buffer may be trimmed for efficiency reasons.  This is the\n        # untrimmed buffer, used to create the before attribute.\n        self._before = self.buffer_type()\n\n    def _log(self, s, direction):\n        if self.logfile is not None:\n            self.logfile.write(s)\n            self.logfile.flush()\n        second_log = self.logfile_send if (direction=='send') else self.logfile_read\n        if second_log is not None:\n            second_log.write(s)\n            second_log.flush()\n\n    # For backwards compatibility, in bytes mode (when encoding is None)\n    # unicode is accepted for send and expect. Unicode mode is strictly unicode\n    # only.\n    def _coerce_expect_string(self, s):\n        if self.encoding is None and not isinstance(s, bytes):\n            return s.encode('ascii')\n        return s\n\n    # In bytes mode, regex patterns should also be of bytes type\n    def _coerce_expect_re(self, r):\n        p = r.pattern\n        if self.encoding is None and not isinstance(p, bytes):\n            return re.compile(p.encode('utf-8'))\n        # And vice-versa\n        elif self.encoding is not None and isinstance(p, bytes):\n            return re.compile(p.decode('utf-8'))\n        return r\n\n    def _coerce_send_string(self, s):\n        if self.encoding is None and not isinstance(s, bytes):\n            return s.encode('utf-8')\n        return s\n\n    def _get_buffer(self):\n        return self._buffer.getvalue()\n\n    def _set_buffer(self, value):\n        self._buffer = self.buffer_type()\n        self._buffer.write(value)\n\n    # This property is provided for backwards compatibility (self.buffer used\n    # to be a string/bytes object)\n    buffer = property(_get_buffer, _set_buffer)\n\n    def read_nonblocking(self, size=1, timeout=None):\n        \"\"\"This reads data from the file descriptor.\n\n        This is a simple implementation suitable for a regular file. Subclasses using ptys or pipes should override it.\n\n        The timeout parameter is ignored.\n        \"\"\"\n\n        try:\n            s = os.read(self.child_fd, size)\n        except OSError as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOF('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF\n            self.flag_eof = True\n            raise EOF('End Of File (EOF). Empty string style platform.')\n\n        s = self._decoder.decode(s, final=False)\n        self._log(s, 'read')\n        return s\n\n    def _pattern_type_err(self, pattern):\n        raise TypeError('got {badtype} ({badobj!r}) as pattern, must be one'\n                        ' of: {goodtypes}, pexpect.EOF, pexpect.TIMEOUT'\\\n                        .format(badtype=type(pattern),\n                                badobj=pattern,\n                                goodtypes=', '.join([str(ast)\\\n                                    for ast in self.allowed_string_types])\n                                )\n                        )\n\n    def compile_pattern_list(self, patterns):\n        '''This compiles a pattern-string or a list of pattern-strings.\n        Patterns must be a StringType, EOF, TIMEOUT, SRE_Pattern, or a list of\n        those. Patterns may also be None which results in an empty list (you\n        might do this if waiting for an EOF or TIMEOUT condition without\n        expecting any pattern).\n\n        This is used by expect() when calling expect_list(). Thus expect() is\n        nothing more than::\n\n             cpl = self.compile_pattern_list(pl)\n             return self.expect_list(cpl, timeout)\n\n        If you are using expect() within a loop it may be more\n        efficient to compile the patterns first and then call expect_list().\n        This avoid calls in a loop to compile_pattern_list()::\n\n             cpl = self.compile_pattern_list(my_pattern)\n             while some_condition:\n                ...\n                i = self.expect_list(cpl, timeout)\n                ...\n        '''\n\n        if patterns is None:\n            return []\n        if not isinstance(patterns, list):\n            patterns = [patterns]\n\n        # Allow dot to match \\n\n        compile_flags = re.DOTALL\n        if self.ignorecase:\n            compile_flags = compile_flags | re.IGNORECASE\n        compiled_pattern_list = []\n        for idx, p in enumerate(patterns):\n            if isinstance(p, self.allowed_string_types):\n                p = self._coerce_expect_string(p)\n                compiled_pattern_list.append(re.compile(p, compile_flags))\n            elif p is EOF:\n                compiled_pattern_list.append(EOF)\n            elif p is TIMEOUT:\n                compiled_pattern_list.append(TIMEOUT)\n            elif isinstance(p, type(re.compile(''))):\n                p = self._coerce_expect_re(p)\n                compiled_pattern_list.append(p)\n            else:\n                self._pattern_type_err(p)\n        return compiled_pattern_list\n\n    def expect(self, pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw):\n        '''This seeks through the stream until a pattern is matched. The\n        pattern is overloaded and may take several types. The pattern can be a\n        StringType, EOF, a compiled re, or a list of any of those types.\n        Strings will be compiled to re types. This returns the index into the\n        pattern list. If the pattern was not a list this returns index 0 on a\n        successful match. This may raise exceptions for EOF or TIMEOUT. To\n        avoid the EOF or TIMEOUT exceptions add EOF or TIMEOUT to the pattern\n        list. That will cause expect to match an EOF or TIMEOUT condition\n        instead of raising an exception.\n\n        If you pass a list of patterns and more than one matches, the first\n        match in the stream is chosen. If more than one pattern matches at that\n        point, the leftmost in the pattern list is chosen. For example::\n\n            # the input is 'foobar'\n            index = p.expect(['bar', 'foo', 'foobar'])\n            # returns 1('foo') even though 'foobar' is a \"better\" match\n\n        Please note, however, that buffering can affect this behavior, since\n        input arrives in unpredictable chunks. For example::\n\n            # the input is 'foobar'\n            index = p.expect(['foobar', 'foo'])\n            # returns 0('foobar') if all input is available at once,\n            # but returns 1('foo') if parts of the final 'bar' arrive late\n\n        When a match is found for the given pattern, the class instance\n        attribute *match* becomes an re.MatchObject result.  Should an EOF\n        or TIMEOUT pattern match, then the match attribute will be an instance\n        of that exception class.  The pairing before and after class\n        instance attributes are views of the data preceding and following\n        the matching pattern.  On general exception, class attribute\n        *before* is all data received up to the exception, while *match* and\n        *after* attributes are value None.\n\n        When the keyword argument timeout is -1 (default), then TIMEOUT will\n        raise after the default value specified by the class timeout\n        attribute. When None, TIMEOUT will not be raised and may block\n        indefinitely until match.\n\n        When the keyword argument searchwindowsize is -1 (default), then the\n        value specified by the class maxread attribute is used.\n\n        A list entry may be EOF or TIMEOUT instead of a string. This will\n        catch these exceptions and return the index of the list entry instead\n        of raising the exception. The attribute 'after' will be set to the\n        exception type. The attribute 'match' will be None. This allows you to\n        write code like this::\n\n                index = p.expect(['good', 'bad', pexpect.EOF, pexpect.TIMEOUT])\n                if index == 0:\n                    do_something()\n                elif index == 1:\n                    do_something_else()\n                elif index == 2:\n                    do_some_other_thing()\n                elif index == 3:\n                    do_something_completely_different()\n\n        instead of code like this::\n\n                try:\n                    index = p.expect(['good', 'bad'])\n                    if index == 0:\n                        do_something()\n                    elif index == 1:\n                        do_something_else()\n                except EOF:\n                    do_some_other_thing()\n                except TIMEOUT:\n                    do_something_completely_different()\n\n        These two forms are equivalent. It all depends on what you want. You\n        can also just expect the EOF if you are waiting for all output of a\n        child to finish. For example::\n\n                p = pexpect.spawn('/bin/ls')\n                p.expect(pexpect.EOF)\n                print p.before\n\n        If you are trying to optimize for speed then see expect_list().\n\n        On Python 3.4, or Python 3.3 with asyncio installed, passing\n        ``async_=True``  will make this return an :mod:`asyncio` coroutine,\n        which you can yield from to get the same result that this method would\n        normally give directly. So, inside a coroutine, you can replace this code::\n\n            index = p.expect(patterns)\n\n        With this non-blocking form::\n\n            index = yield from p.expect(patterns, async_=True)\n        '''\n        if 'async' in kw:\n            async_ = kw.pop('async')\n        if kw:\n            raise TypeError(\"Unknown keyword arguments: {}\".format(kw))\n\n        compiled_pattern_list = self.compile_pattern_list(pattern)\n        return self.expect_list(compiled_pattern_list,\n                timeout, searchwindowsize, async_)\n\n    def expect_list(self, pattern_list, timeout=-1, searchwindowsize=-1,\n                    async_=False, **kw):\n        '''This takes a list of compiled regular expressions and returns the\n        index into the pattern_list that matched the child output. The list may\n        also contain EOF or TIMEOUT(which are not compiled regular\n        expressions). This method is similar to the expect() method except that\n        expect_list() does not recompile the pattern list on every call. This\n        may help if you are trying to optimize for speed, otherwise just use\n        the expect() method.  This is called by expect().\n\n\n        Like :meth:`expect`, passing ``async_=True`` will make this return an\n        asyncio coroutine.\n        '''\n        if timeout == -1:\n            timeout = self.timeout\n        if 'async' in kw:\n            async_ = kw.pop('async')\n        if kw:\n            raise TypeError(\"Unknown keyword arguments: {}\".format(kw))\n\n        exp = Expecter(self, searcher_re(pattern_list), searchwindowsize)\n        if async_:\n            from ._async import expect_async\n            return expect_async(exp, timeout)\n        else:\n            return exp.expect_loop(timeout)\n\n    def expect_exact(self, pattern_list, timeout=-1, searchwindowsize=-1,\n                     async_=False, **kw):\n\n        '''This is similar to expect(), but uses plain string matching instead\n        of compiled regular expressions in 'pattern_list'. The 'pattern_list'\n        may be a string; a list or other sequence of strings; or TIMEOUT and\n        EOF.\n\n        This call might be faster than expect() for two reasons: string\n        searching is faster than RE matching and it is possible to limit the\n        search to just the end of the input buffer.\n\n        This method is also useful when you don't want to have to worry about\n        escaping regular expression characters that you want to match.\n\n        Like :meth:`expect`, passing ``async_=True`` will make this return an\n        asyncio coroutine.\n        '''\n        if timeout == -1:\n            timeout = self.timeout\n        if 'async' in kw:\n            async_ = kw.pop('async')\n        if kw:\n            raise TypeError(\"Unknown keyword arguments: {}\".format(kw))\n\n        if (isinstance(pattern_list, self.allowed_string_types) or\n                pattern_list in (TIMEOUT, EOF)):\n            pattern_list = [pattern_list]\n\n        def prepare_pattern(pattern):\n            if pattern in (TIMEOUT, EOF):\n                return pattern\n            if isinstance(pattern, self.allowed_string_types):\n                return self._coerce_expect_string(pattern)\n            self._pattern_type_err(pattern)\n\n        try:\n            pattern_list = iter(pattern_list)\n        except TypeError:\n            self._pattern_type_err(pattern_list)\n        pattern_list = [prepare_pattern(p) for p in pattern_list]\n\n        exp = Expecter(self, searcher_string(pattern_list), searchwindowsize)\n        if async_:\n            from ._async import expect_async\n            return expect_async(exp, timeout)\n        else:\n            return exp.expect_loop(timeout)\n\n    def expect_loop(self, searcher, timeout=-1, searchwindowsize=-1):\n        '''This is the common loop used inside expect. The 'searcher' should be\n        an instance of searcher_re or searcher_string, which describes how and\n        what to search for in the input.\n\n        See expect() for other arguments, return value and exceptions. '''\n\n        exp = Expecter(self, searcher, searchwindowsize)\n        return exp.expect_loop(timeout)\n\n    def read(self, size=-1):\n        '''This reads at most \"size\" bytes from the file (less if the read hits\n        EOF before obtaining size bytes). If the size argument is negative or\n        omitted, read all data until EOF is reached. The bytes are returned as\n        a string object. An empty string is returned when EOF is encountered\n        immediately. '''\n\n        if size == 0:\n            return self.string_type()\n        if size < 0:\n            # delimiter default is EOF\n            self.expect(self.delimiter)\n            return self.before\n\n        # I could have done this more directly by not using expect(), but\n        # I deliberately decided to couple read() to expect() so that\n        # I would catch any bugs early and ensure consistent behavior.\n        # It's a little less efficient, but there is less for me to\n        # worry about if I have to later modify read() or expect().\n        # Note, it's OK if size==-1 in the regex. That just means it\n        # will never match anything in which case we stop only on EOF.\n        cre = re.compile(self._coerce_expect_string('.{%d}' % size), re.DOTALL)\n        # delimiter default is EOF\n        index = self.expect([cre, self.delimiter])\n        if index == 0:\n            ### FIXME self.before should be ''. Should I assert this?\n            return self.after\n        return self.before\n\n    def readline(self, size=-1):\n        '''This reads and returns one entire line. The newline at the end of\n        line is returned as part of the string, unless the file ends without a\n        newline. An empty string is returned if EOF is encountered immediately.\n        This looks for a newline as a CR/LF pair (\\\\r\\\\n) even on UNIX because\n        this is what the pseudotty device returns. So contrary to what you may\n        expect you will receive newlines as \\\\r\\\\n.\n\n        If the size argument is 0 then an empty string is returned. In all\n        other cases the size argument is ignored, which is not standard\n        behavior for a file-like object. '''\n\n        if size == 0:\n            return self.string_type()\n        # delimiter default is EOF\n        index = self.expect([self.crlf, self.delimiter])\n        if index == 0:\n            return self.before + self.crlf\n        else:\n            return self.before\n\n    def __iter__(self):\n        '''This is to support iterators over a file-like object.\n        '''\n        return iter(self.readline, self.string_type())\n\n    def readlines(self, sizehint=-1):\n        '''This reads until EOF using readline() and returns a list containing\n        the lines thus read. The optional 'sizehint' argument is ignored.\n        Remember, because this reads until EOF that means the child\n        process should have closed its stdout. If you run this method on\n        a child that is still running with its stdout open then this\n        method will block until it timesout.'''\n\n        lines = []\n        while True:\n            line = self.readline()\n            if not line:\n                break\n            lines.append(line)\n        return lines\n\n    def fileno(self):\n        '''Expose file descriptor for a file-like interface\n        '''\n        return self.child_fd\n\n    def flush(self):\n        '''This does nothing. It is here to support the interface for a\n        File-like object. '''\n        pass\n\n    def isatty(self):\n        \"\"\"Overridden in subclass using tty\"\"\"\n        return False\n\n    # For 'with spawn(...) as child:'\n    def __enter__(self):\n        return self\n\n    def __exit__(self, etype, evalue, tb):\n        # We rely on subclasses to implement close(). If they don't, it's not\n        # clear what a context manager should do.\n        self.close()\n", "pexpect/pxssh.py": "'''This class extends pexpect.spawn to specialize setting up SSH connections.\nThis adds methods for login, logout, and expecting the shell prompt.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom pexpect import ExceptionPexpect, TIMEOUT, EOF, spawn\nimport time\nimport os\nimport sys\nimport re\n\n__all__ = ['ExceptionPxssh', 'pxssh']\n\n# Exception classes used by this module.\nclass ExceptionPxssh(ExceptionPexpect):\n    '''Raised for pxssh exceptions.\n    '''\n\nif sys.version_info > (3, 0):\n    from shlex import quote\nelse:\n    _find_unsafe = re.compile(r'[^\\w@%+=:,./-]').search\n\n    def quote(s):\n        \"\"\"Return a shell-escaped version of the string *s*.\"\"\"\n        if not s:\n            return \"''\"\n        if _find_unsafe(s) is None:\n            return s\n\n        # use single quotes, and put single quotes into double quotes\n        # the string $'b is then quoted as '$'\"'\"'b'\n        return \"'\" + s.replace(\"'\", \"'\\\"'\\\"'\") + \"'\"\n\nclass pxssh (spawn):\n    '''This class extends pexpect.spawn to specialize setting up SSH\n    connections. This adds methods for login, logout, and expecting the shell\n    prompt. It does various tricky things to handle many situations in the SSH\n    login process. For example, if the session is your first login, then pxssh\n    automatically accepts the remote certificate; or if you have public key\n    authentication setup then pxssh won't wait for the password prompt.\n\n    pxssh uses the shell prompt to synchronize output from the remote host. In\n    order to make this more robust it sets the shell prompt to something more\n    unique than just $ or #. This should work on most Borne/Bash or Csh style\n    shells.\n\n    Example that runs a few commands on a remote server and prints the result::\n\n        from pexpect import pxssh\n        import getpass\n        try:\n            s = pxssh.pxssh()\n            hostname = raw_input('hostname: ')\n            username = raw_input('username: ')\n            password = getpass.getpass('password: ')\n            s.login(hostname, username, password)\n            s.sendline('uptime')   # run a command\n            s.prompt()             # match the prompt\n            print(s.before)        # print everything before the prompt.\n            s.sendline('ls -l')\n            s.prompt()\n            print(s.before)\n            s.sendline('df')\n            s.prompt()\n            print(s.before)\n            s.logout()\n        except pxssh.ExceptionPxssh as e:\n            print(\"pxssh failed on login.\")\n            print(e)\n\n    Example showing how to specify SSH options::\n\n        from pexpect import pxssh\n        s = pxssh.pxssh(options={\n                            \"StrictHostKeyChecking\": \"no\",\n                            \"UserKnownHostsFile\": \"/dev/null\"})\n        ...\n\n    Note that if you have ssh-agent running while doing development with pxssh\n    then this can lead to a lot of confusion. Many X display managers (xdm,\n    gdm, kdm, etc.) will automatically start a GUI agent. You may see a GUI\n    dialog box popup asking for a password during development. You should turn\n    off any key agents during testing. The 'force_password' attribute will turn\n    off public key authentication. This will only work if the remote SSH server\n    is configured to allow password logins. Example of using 'force_password'\n    attribute::\n\n            s = pxssh.pxssh()\n            s.force_password = True\n            hostname = raw_input('hostname: ')\n            username = raw_input('username: ')\n            password = getpass.getpass('password: ')\n            s.login (hostname, username, password)\n\n    `debug_command_string` is only for the test suite to confirm that the string\n    generated for SSH is correct, using this will not allow you to do\n    anything other than get a string back from `pxssh.pxssh.login()`.\n    '''\n\n    def __init__ (self, timeout=30, maxread=2000, searchwindowsize=None,\n                    logfile=None, cwd=None, env=None, ignore_sighup=True, echo=True,\n                    options={}, encoding=None, codec_errors='strict',\n                    debug_command_string=False, use_poll=False):\n\n        spawn.__init__(self, None, timeout=timeout, maxread=maxread,\n                       searchwindowsize=searchwindowsize, logfile=logfile,\n                       cwd=cwd, env=env, ignore_sighup=ignore_sighup, echo=echo,\n                       encoding=encoding, codec_errors=codec_errors, use_poll=use_poll)\n\n        self.name = '<pxssh>'\n\n        #SUBTLE HACK ALERT! Note that the command that SETS the prompt uses a\n        #slightly different string than the regular expression to match it. This\n        #is because when you set the prompt the command will echo back, but we\n        #don't want to match the echoed command. So if we make the set command\n        #slightly different than the regex we eliminate the problem. To make the\n        #set command different we add a backslash in front of $. The $ doesn't\n        #need to be escaped, but it doesn't hurt and serves to make the set\n        #prompt command different than the regex.\n\n        # used to match the command-line prompt\n        self.UNIQUE_PROMPT = r\"\\[PEXPECT\\][\\$\\#] \"\n        self.PROMPT = self.UNIQUE_PROMPT\n\n        # used to set shell command-line prompt to UNIQUE_PROMPT.\n        self.PROMPT_SET_SH = r\"PS1='[PEXPECT]\\$ '\"\n        self.PROMPT_SET_CSH = r\"set prompt='[PEXPECT]\\$ '\"\n        self.PROMPT_SET_ZSH = \"prompt restore;\\nPS1='[PEXPECT]%(!.#.$) '\"\n        self.SSH_OPTS = (\" -o 'PubkeyAuthentication=no'\")\n# Disabling host key checking, makes you vulnerable to MITM attacks.\n#                + \" -o 'StrictHostKeyChecking=no'\"\n#                + \" -o 'UserKnownHostsFile /dev/null' \")\n        # Disabling X11 forwarding gets rid of the annoying SSH_ASKPASS from\n        # displaying a GUI password dialog. I have not figured out how to\n        # disable only SSH_ASKPASS without also disabling X11 forwarding.\n        # Unsetting SSH_ASKPASS on the remote side doesn't disable it! Annoying!\n        #self.SSH_OPTS = \"-x -o 'PubkeyAuthentication=no'\"\n        self.force_password = False\n\n        self.debug_command_string = debug_command_string\n\n        # User defined SSH options, eg,\n        # ssh.otions = dict(StrictHostKeyChecking=\"no\",UserKnownHostsFile=\"/dev/null\")\n        self.options = options\n\n    def levenshtein_distance(self, a, b):\n        '''This calculates the Levenshtein distance between a and b.\n        '''\n\n        n, m = len(a), len(b)\n        if n > m:\n            a,b = b,a\n            n,m = m,n\n        current = range(n+1)\n        for i in range(1,m+1):\n            previous, current = current, [i]+[0]*n\n            for j in range(1,n+1):\n                add, delete = previous[j]+1, current[j-1]+1\n                change = previous[j-1]\n                if a[j-1] != b[i-1]:\n                    change = change + 1\n                current[j] = min(add, delete, change)\n        return current[n]\n\n    def try_read_prompt(self, timeout_multiplier):\n        '''This facilitates using communication timeouts to perform\n        synchronization as quickly as possible, while supporting high latency\n        connections with a tunable worst case performance. Fast connections\n        should be read almost immediately. Worst case performance for this\n        method is timeout_multiplier * 3 seconds.\n        '''\n\n        # maximum time allowed to read the first response\n        first_char_timeout = timeout_multiplier * 0.5\n\n        # maximum time allowed between subsequent characters\n        inter_char_timeout = timeout_multiplier * 0.1\n\n        # maximum time for reading the entire prompt\n        total_timeout = timeout_multiplier * 3.0\n\n        prompt = self.string_type()\n        begin = time.time()\n        expired = 0.0\n        timeout = first_char_timeout\n\n        while expired < total_timeout:\n            try:\n                prompt += self.read_nonblocking(size=1, timeout=timeout)\n                expired = time.time() - begin # updated total time expired\n                timeout = inter_char_timeout\n            except TIMEOUT:\n                break\n\n        return prompt\n\n    def sync_original_prompt (self, sync_multiplier=1.0):\n        '''This attempts to find the prompt. Basically, press enter and record\n        the response; press enter again and record the response; if the two\n        responses are similar then assume we are at the original prompt.\n        This can be a slow function. Worst case with the default sync_multiplier\n        can take 12 seconds. Low latency connections are more likely to fail\n        with a low sync_multiplier. Best case sync time gets worse with a\n        high sync multiplier (500 ms with default). '''\n\n        # All of these timing pace values are magic.\n        # I came up with these based on what seemed reliable for\n        # connecting to a heavily loaded machine I have.\n        self.sendline()\n        time.sleep(0.1)\n\n        try:\n            # Clear the buffer before getting the prompt.\n            self.try_read_prompt(sync_multiplier)\n        except TIMEOUT:\n            pass\n\n        self.sendline()\n        x = self.try_read_prompt(sync_multiplier)\n\n        self.sendline()\n        a = self.try_read_prompt(sync_multiplier)\n\n        self.sendline()\n        b = self.try_read_prompt(sync_multiplier)\n\n        ld = self.levenshtein_distance(a,b)\n        len_a = len(a)\n        if len_a == 0:\n            return False\n        if float(ld)/len_a < 0.4:\n            return True\n        return False\n\n    ### TODO: This is getting messy and I'm pretty sure this isn't perfect.\n    ### TODO: I need to draw a flow chart for this.\n    ### TODO: Unit tests for SSH tunnels, remote SSH command exec, disabling original prompt sync\n    def login (self, server, username=None, password='', terminal_type='ansi',\n                original_prompt=r\"[#$]\", login_timeout=10, port=None,\n                auto_prompt_reset=True, ssh_key=None, quiet=True,\n                sync_multiplier=1, check_local_ip=True,\n                password_regex=r'(?i)(?:password:)|(?:passphrase for key)',\n                ssh_tunnels={}, spawn_local_ssh=True,\n                sync_original_prompt=True, ssh_config=None, cmd='ssh'):\n        '''This logs the user into the given server.\n\n        It uses 'original_prompt' to try to find the prompt right after login.\n        When it finds the prompt it immediately tries to reset the prompt to\n        something more easily matched. The default 'original_prompt' is very\n        optimistic and is easily fooled. It's more reliable to try to match the original\n        prompt as exactly as possible to prevent false matches by server\n        strings such as the \"Message Of The Day\". On many systems you can\n        disable the MOTD on the remote server by creating a zero-length file\n        called :file:`~/.hushlogin` on the remote server. If a prompt cannot be found\n        then this will not necessarily cause the login to fail. In the case of\n        a timeout when looking for the prompt we assume that the original\n        prompt was so weird that we could not match it, so we use a few tricks\n        to guess when we have reached the prompt. Then we hope for the best and\n        blindly try to reset the prompt to something more unique. If that fails\n        then login() raises an :class:`ExceptionPxssh` exception.\n\n        In some situations it is not possible or desirable to reset the\n        original prompt. In this case, pass ``auto_prompt_reset=False`` to\n        inhibit setting the prompt to the UNIQUE_PROMPT. Remember that pxssh\n        uses a unique prompt in the :meth:`prompt` method. If the original prompt is\n        not reset then this will disable the :meth:`prompt` method unless you\n        manually set the :attr:`PROMPT` attribute.\n\n        Set ``password_regex`` if there is a MOTD message with `password` in it.\n        Changing this is like playing in traffic, don't (p)expect it to match straight\n        away.\n\n        If you require to connect to another SSH server from the your original SSH\n        connection set ``spawn_local_ssh`` to `False` and this will use your current\n        session to do so. Setting this option to `False` and not having an active session\n        will trigger an error.\n\n        Set ``ssh_key`` to a file path to an SSH private key to use that SSH key\n        for the session authentication.\n        Set ``ssh_key`` to `True` to force passing the current SSH authentication socket\n        to the desired ``hostname``.\n\n        Set ``ssh_config`` to a file path string of an SSH client config file to pass that\n        file to the client to handle itself. You may set any options you wish in here, however\n        doing so will require you to post extra information that you may not want to if you\n        run into issues.\n\n        Alter the ``cmd`` to change the ssh client used, or to prepend it with network\n        namespaces. For example ```cmd=\"ip netns exec vlan2 ssh\"``` to execute the ssh in\n        network namespace named ```vlan```.\n        '''\n\n        session_regex_array = [\"(?i)are you sure you want to continue connecting\", original_prompt, password_regex, \"(?i)permission denied\", \"(?i)terminal type\", TIMEOUT]\n        session_init_regex_array = []\n        session_init_regex_array.extend(session_regex_array)\n        session_init_regex_array.extend([\"(?i)connection closed by remote host\", EOF])\n\n        ssh_options = ''.join([\" -o '%s=%s'\" % (o, v) for (o, v) in self.options.items()])\n        if quiet:\n            ssh_options = ssh_options + ' -q'\n        if not check_local_ip:\n            ssh_options = ssh_options + \" -o'NoHostAuthenticationForLocalhost=yes'\"\n        if self.force_password:\n            ssh_options = ssh_options + ' ' + self.SSH_OPTS\n        if ssh_config is not None:\n            if spawn_local_ssh and not os.path.isfile(ssh_config):\n                raise ExceptionPxssh('SSH config does not exist or is not a file.')\n            ssh_options = ssh_options + ' -F ' + ssh_config\n        if port is not None:\n            ssh_options = ssh_options + ' -p %s'%(str(port))\n        if ssh_key is not None:\n            # Allow forwarding our SSH key to the current session\n            if ssh_key==True:\n                ssh_options = ssh_options + ' -A'\n            else:\n                if spawn_local_ssh and not os.path.isfile(ssh_key):\n                    raise ExceptionPxssh('private ssh key does not exist or is not a file.')\n                ssh_options = ssh_options + ' -i %s' % (ssh_key)\n\n        # SSH tunnels, make sure you know what you're putting into the lists\n        # under each heading. Do not expect these to open 100% of the time,\n        # The port you're requesting might be bound.\n        #\n        # The structure should be like this:\n        # { 'local': ['2424:localhost:22'],  # Local SSH tunnels\n        # 'remote': ['2525:localhost:22'],   # Remote SSH tunnels\n        # 'dynamic': [8888] } # Dynamic/SOCKS tunnels\n        if ssh_tunnels!={} and isinstance({},type(ssh_tunnels)):\n            tunnel_types = {\n                'local':'L',\n                'remote':'R',\n                'dynamic':'D'\n            }\n            for tunnel_type in tunnel_types:\n                cmd_type = tunnel_types[tunnel_type]\n                if tunnel_type in ssh_tunnels:\n                    tunnels = ssh_tunnels[tunnel_type]\n                    for tunnel in tunnels:\n                        if spawn_local_ssh==False:\n                            tunnel = quote(str(tunnel))\n                        ssh_options = ssh_options + ' -' + cmd_type + ' ' + str(tunnel)\n\n        if username is not None:\n            ssh_options = ssh_options + ' -l ' + username\n        elif ssh_config is None:\n            raise TypeError('login() needs either a username or an ssh_config')\n        else:  # make sure ssh_config has an entry for the server with a username\n            with open(ssh_config, 'rt') as f:\n                lines = [l.strip() for l in f.readlines()]\n\n            server_regex = r'^Host\\s+%s\\s*$' % server\n            user_regex = r'^User\\s+\\w+\\s*$'\n            config_has_server = False\n            server_has_username = False\n            for line in lines:\n                if not config_has_server and re.match(server_regex, line, re.IGNORECASE):\n                    config_has_server = True\n                elif config_has_server and 'hostname' in line.lower():\n                    pass\n                elif config_has_server and 'host' in line.lower():\n                    server_has_username = False  # insurance\n                    break  # we have left the relevant section\n                elif config_has_server and re.match(user_regex, line, re.IGNORECASE):\n                    server_has_username = True\n                    break\n\n            if lines:\n                del line\n\n            del lines\n\n            if not config_has_server:\n                raise TypeError('login() ssh_config has no Host entry for %s' % server)\n            elif not server_has_username:\n                raise TypeError('login() ssh_config has no user entry for %s' % server)\n\n        cmd += \" %s %s\" % (ssh_options, server)\n        if self.debug_command_string:\n            return(cmd)\n\n        # Are we asking for a local ssh command or to spawn one in another session?\n        if spawn_local_ssh:\n            spawn._spawn(self, cmd)\n        else:\n            self.sendline(cmd)\n\n        # This does not distinguish between a remote server 'password' prompt\n        # and a local ssh 'passphrase' prompt (for unlocking a private key).\n        i = self.expect(session_init_regex_array, timeout=login_timeout)\n\n        # First phase\n        if i==0:\n            # New certificate -- always accept it.\n            # This is what you get if SSH does not have the remote host's\n            # public key stored in the 'known_hosts' cache.\n            self.sendline(\"yes\")\n            i = self.expect(session_regex_array)\n        if i==2: # password or passphrase\n            self.sendline(password)\n            i = self.expect(session_regex_array)\n        if i==4:\n            self.sendline(terminal_type)\n            i = self.expect(session_regex_array)\n        if i==7:\n            self.close()\n            raise ExceptionPxssh('Could not establish connection to host')\n\n        # Second phase\n        if i==0:\n            # This is weird. This should not happen twice in a row.\n            self.close()\n            raise ExceptionPxssh('Weird error. Got \"are you sure\" prompt twice.')\n        elif i==1: # can occur if you have a public key pair set to authenticate.\n            ### TODO: May NOT be OK if expect() got tricked and matched a false prompt.\n            pass\n        elif i==2: # password prompt again\n            # For incorrect passwords, some ssh servers will\n            # ask for the password again, others return 'denied' right away.\n            # If we get the password prompt again then this means\n            # we didn't get the password right the first time.\n            self.close()\n            raise ExceptionPxssh('password refused')\n        elif i==3: # permission denied -- password was bad.\n            self.close()\n            raise ExceptionPxssh('permission denied')\n        elif i==4: # terminal type again? WTF?\n            self.close()\n            raise ExceptionPxssh('Weird error. Got \"terminal type\" prompt twice.')\n        elif i==5: # Timeout\n            #This is tricky... I presume that we are at the command-line prompt.\n            #It may be that the shell prompt was so weird that we couldn't match\n            #it. Or it may be that we couldn't log in for some other reason. I\n            #can't be sure, but it's safe to guess that we did login because if\n            #I presume wrong and we are not logged in then this should be caught\n            #later when I try to set the shell prompt.\n            pass\n        elif i==6: # Connection closed by remote host\n            self.close()\n            raise ExceptionPxssh('connection closed')\n        else: # Unexpected\n            self.close()\n            raise ExceptionPxssh('unexpected login response')\n        if sync_original_prompt:\n            if not self.sync_original_prompt(sync_multiplier):\n                self.close()\n                raise ExceptionPxssh('could not synchronize with original prompt')\n        # We appear to be in.\n        # set shell prompt to something unique.\n        if auto_prompt_reset:\n            if not self.set_unique_prompt():\n                self.close()\n                raise ExceptionPxssh('could not set shell prompt '\n                                     '(received: %r, expected: %r).' % (\n                                         self.before, self.PROMPT,))\n        return True\n\n    def logout (self):\n        '''Sends exit to the remote shell.\n\n        If there are stopped jobs then this automatically sends exit twice.\n        '''\n        self.sendline(\"exit\")\n        index = self.expect([EOF, \"(?i)there are stopped jobs\"])\n        if index==1:\n            self.sendline(\"exit\")\n            self.expect(EOF)\n        self.close()\n\n    def prompt(self, timeout=-1):\n        '''Match the next shell prompt.\n\n        This is little more than a short-cut to the :meth:`~pexpect.spawn.expect`\n        method. Note that if you called :meth:`login` with\n        ``auto_prompt_reset=False``, then before calling :meth:`prompt` you must\n        set the :attr:`PROMPT` attribute to a regex that it will use for\n        matching the prompt.\n\n        Calling :meth:`prompt` will erase the contents of the :attr:`before`\n        attribute even if no prompt is ever matched. If timeout is not given or\n        it is set to -1 then self.timeout is used.\n\n        :return: True if the shell prompt was matched, False if the timeout was\n                 reached.\n        '''\n\n        if timeout == -1:\n            timeout = self.timeout\n        i = self.expect([self.PROMPT, TIMEOUT], timeout=timeout)\n        if i==1:\n            return False\n        return True\n\n    def set_unique_prompt(self):\n        '''This sets the remote prompt to something more unique than ``#`` or ``$``.\n        This makes it easier for the :meth:`prompt` method to match the shell prompt\n        unambiguously. This method is called automatically by the :meth:`login`\n        method, but you may want to call it manually if you somehow reset the\n        shell prompt. For example, if you 'su' to a different user then you\n        will need to manually reset the prompt. This sends shell commands to\n        the remote host to set the prompt, so this assumes the remote host is\n        ready to receive commands.\n\n        Alternatively, you may use your own prompt pattern. In this case you\n        should call :meth:`login` with ``auto_prompt_reset=False``; then set the\n        :attr:`PROMPT` attribute to a regular expression. After that, the\n        :meth:`prompt` method will try to match your prompt pattern.\n        '''\n\n        self.sendline(\"unset PROMPT_COMMAND\")\n        self.sendline(self.PROMPT_SET_SH) # sh-style\n        i = self.expect ([TIMEOUT, self.PROMPT], timeout=10)\n        if i == 0: # csh-style\n            self.sendline(self.PROMPT_SET_CSH)\n            i = self.expect([TIMEOUT, self.PROMPT], timeout=10)\n            if i == 0: # zsh-style\n                self.sendline(self.PROMPT_SET_ZSH)\n                i = self.expect([TIMEOUT, self.PROMPT], timeout=10)\n                if i == 0:\n                    return False\n        return True\n\n# vi:ts=4:sw=4:expandtab:ft=python:\n", "pexpect/fdpexpect.py": "'''This is like :mod:`pexpect`, but it will work with any file descriptor that you\npass it. You are responsible for opening and close the file descriptor.\nThis allows you to use Pexpect with sockets and named pipes (FIFOs).\n\n.. note::\n    socket.fileno() does not give a readable file descriptor on windows.\n    Use :mod:`pexpect.socket_pexpect` for cross-platform socket support\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom .spawnbase import SpawnBase\nfrom .exceptions import ExceptionPexpect, TIMEOUT\nfrom .utils import select_ignore_interrupts, poll_ignore_interrupts\nimport os\n\n__all__ = ['fdspawn']\n\nclass fdspawn(SpawnBase):\n    '''This is like pexpect.spawn but allows you to supply your own open file\n    descriptor. For example, you could use it to read through a file looking\n    for patterns, or to control a modem or serial device. '''\n\n    def __init__ (self, fd, args=None, timeout=30, maxread=2000, searchwindowsize=None,\n                  logfile=None, encoding=None, codec_errors='strict', use_poll=False):\n        '''This takes a file descriptor (an int) or an object that support the\n        fileno() method (returning an int). All Python file-like objects\n        support fileno(). '''\n\n        if type(fd) != type(0) and hasattr(fd, 'fileno'):\n            fd = fd.fileno()\n\n        if type(fd) != type(0):\n            raise ExceptionPexpect('The fd argument is not an int. If this is a command string then maybe you want to use pexpect.spawn.')\n\n        try: # make sure fd is a valid file descriptor\n            os.fstat(fd)\n        except OSError:\n            raise ExceptionPexpect('The fd argument is not a valid file descriptor.')\n\n        self.args = None\n        self.command = None\n        SpawnBase.__init__(self, timeout, maxread, searchwindowsize, logfile,\n                           encoding=encoding, codec_errors=codec_errors)\n        self.child_fd = fd\n        self.own_fd = False\n        self.closed = False\n        self.name = '<file descriptor %d>' % fd\n        self.use_poll = use_poll\n\n    def close (self):\n        \"\"\"Close the file descriptor.\n\n        Calling this method a second time does nothing, but if the file\n        descriptor was closed elsewhere, :class:`OSError` will be raised.\n        \"\"\"\n        if self.child_fd == -1:\n            return\n\n        self.flush()\n        os.close(self.child_fd)\n        self.child_fd = -1\n        self.closed = True\n\n    def isalive (self):\n        '''This checks if the file descriptor is still valid. If :func:`os.fstat`\n        does not raise an exception then we assume it is alive. '''\n\n        if self.child_fd == -1:\n            return False\n        try:\n            os.fstat(self.child_fd)\n            return True\n        except:\n            return False\n\n    def terminate (self, force=False):  # pragma: no cover\n        '''Deprecated and invalid. Just raises an exception.'''\n        raise ExceptionPexpect('This method is not valid for file descriptors.')\n\n    # These four methods are left around for backwards compatibility, but not\n    # documented as part of fdpexpect. You're encouraged to use os.write\n    # directly.\n    def send(self, s):\n        \"Write to fd, return number of bytes written\"\n        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n\n        b = self._encoder.encode(s, final=False)\n        return os.write(self.child_fd, b)\n\n    def sendline(self, s):\n        \"Write to fd with trailing newline, return number of bytes written\"\n        s = self._coerce_send_string(s)\n        return self.send(s + self.linesep)\n\n    def write(self, s):\n        \"Write to fd, return None\"\n        self.send(s)\n\n    def writelines(self, sequence):\n        \"Call self.write() for each item in sequence\"\n        for s in sequence:\n            self.write(s)\n\n    def read_nonblocking(self, size=1, timeout=-1):\n        \"\"\"\n        Read from the file descriptor and return the result as a string.\n\n        The read_nonblocking method of :class:`SpawnBase` assumes that a call\n        to os.read will not block (timeout parameter is ignored). This is not\n        the case for POSIX file-like objects such as sockets and serial ports.\n\n        Use :func:`select.select`, timeout is implemented conditionally for\n        POSIX systems.\n\n        :param int size: Read at most *size* bytes.\n        :param int timeout: Wait timeout seconds for file descriptor to be\n            ready to read. When -1 (default), use self.timeout. When 0, poll.\n        :return: String containing the bytes read\n        \"\"\"\n        if os.name == 'posix':\n            if timeout == -1:\n                timeout = self.timeout\n            rlist = [self.child_fd]\n            wlist = []\n            xlist = []\n            if self.use_poll:\n                rlist = poll_ignore_interrupts(rlist, timeout)\n            else:\n                rlist, wlist, xlist = select_ignore_interrupts(\n                    rlist, wlist, xlist, timeout\n                )\n            if self.child_fd not in rlist:\n                raise TIMEOUT('Timeout exceeded.')\n        return super(fdspawn, self).read_nonblocking(size)\n", "pexpect/socket_pexpect.py": "\"\"\"This is like :mod:`pexpect`, but it will work with any socket that you\npass it. You are responsible for opening and closing the socket.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\"\"\"\n\nimport socket\nfrom contextlib import contextmanager\n\nfrom .exceptions import TIMEOUT, EOF\nfrom .spawnbase import SpawnBase\n\n__all__ = [\"SocketSpawn\"]\n\n\nclass SocketSpawn(SpawnBase):\n    \"\"\"This is like :mod:`pexpect.fdpexpect` but uses the cross-platform python socket api,\n    rather than the unix-specific file descriptor api. Thus, it works with\n    remote connections on both unix and windows.\"\"\"\n\n    def __init__(\n        self,\n        socket: socket.socket,\n        args=None,\n        timeout=30,\n        maxread=2000,\n        searchwindowsize=None,\n        logfile=None,\n        encoding=None,\n        codec_errors=\"strict\",\n        use_poll=False,\n    ):\n        \"\"\"This takes an open socket.\"\"\"\n\n        self.args = None\n        self.command = None\n        SpawnBase.__init__(\n            self,\n            timeout,\n            maxread,\n            searchwindowsize,\n            logfile,\n            encoding=encoding,\n            codec_errors=codec_errors,\n        )\n        self.socket = socket\n        self.child_fd = socket.fileno()\n        self.closed = False\n        self.name = \"<socket %s>\" % socket\n        self.use_poll = use_poll\n\n    def close(self):\n        \"\"\"Close the socket.\n\n        Calling this method a second time does nothing, but if the file\n        descriptor was closed elsewhere, :class:`OSError` will be raised.\n        \"\"\"\n        if self.child_fd == -1:\n            return\n\n        self.flush()\n        self.socket.shutdown(socket.SHUT_RDWR)\n        self.socket.close()\n        self.child_fd = -1\n        self.closed = True\n\n    def isalive(self):\n        \"\"\" Alive if the fileno is valid \"\"\"\n        return self.socket.fileno() >= 0\n\n    def send(self, s) -> int:\n        \"\"\"Write to socket, return number of bytes written\"\"\"\n        s = self._coerce_send_string(s)\n        self._log(s, \"send\")\n\n        b = self._encoder.encode(s, final=False)\n        self.socket.sendall(b)\n        return len(b)\n\n    def sendline(self, s) -> int:\n        \"\"\"Write to socket with trailing newline, return number of bytes written\"\"\"\n        s = self._coerce_send_string(s)\n        return self.send(s + self.linesep)\n\n    def write(self, s):\n        \"\"\"Write to socket, return None\"\"\"\n        self.send(s)\n\n    def writelines(self, sequence):\n        \"Call self.write() for each item in sequence\"\n        for s in sequence:\n            self.write(s)\n\n    @contextmanager\n    def _timeout(self, timeout):\n        saved_timeout = self.socket.gettimeout()\n        try:\n            self.socket.settimeout(timeout)\n            yield\n        finally:\n            self.socket.settimeout(saved_timeout)\n\n    def read_nonblocking(self, size=1, timeout=-1):\n        \"\"\"\n        Read from the file descriptor and return the result as a string.\n\n        The read_nonblocking method of :class:`SpawnBase` assumes that a call\n        to os.read will not block (timeout parameter is ignored). This is not\n        the case for POSIX file-like objects such as sockets and serial ports.\n\n        Use :func:`select.select`, timeout is implemented conditionally for\n        POSIX systems.\n\n        :param int size: Read at most *size* bytes.\n        :param int timeout: Wait timeout seconds for file descriptor to be\n            ready to read. When -1 (default), use self.timeout. When 0, poll.\n        :return: String containing the bytes read\n        \"\"\"\n        if timeout == -1:\n            timeout = self.timeout\n        try:\n            with self._timeout(timeout):\n                s = self.socket.recv(size)\n                if s == b'':\n                    self.flag_eof = True\n                    raise EOF(\"Socket closed\")\n                return s\n        except socket.timeout:\n            raise TIMEOUT(\"Timeout exceeded.\")\n", "pexpect/__init__.py": "'''Pexpect is a Python module for spawning child applications and controlling\nthem automatically. Pexpect can be used for automating interactive applications\nsuch as ssh, ftp, passwd, telnet, etc. It can be used to automate setup\nscripts for duplicating software package installations on different servers. It\ncan be used for automated software testing. Pexpect is in the spirit of Don\nLibes' Expect, but Pexpect is pure Python. Other Expect-like modules for Python\nrequire TCL and Expect or require C extensions to be compiled. Pexpect does not\nuse C, Expect, or TCL extensions. It should work on any platform that supports\nthe standard Python pty module. The Pexpect interface focuses on ease of use so\nthat simple tasks are easy.\n\nThere are two main interfaces to the Pexpect system; these are the function,\nrun() and the class, spawn. The spawn class is more powerful. The run()\nfunction is simpler than spawn, and is good for quickly calling program. When\nyou call the run() function it executes a given program and then returns the\noutput. This is a handy replacement for os.system().\n\nFor example::\n\n    pexpect.run('ls -la')\n\nThe spawn class is the more powerful interface to the Pexpect system. You can\nuse this to spawn a child program then interact with it by sending input and\nexpecting responses (waiting for patterns in the child's output).\n\nFor example::\n\n    child = pexpect.spawn('scp foo user@example.com:.')\n    child.expect('Password:')\n    child.sendline(mypassword)\n\nContext manager can be used for the spawn() function::\n\n    with pexpect.spawn('scp foo user@example.com:.') as child:\n        child.expect('Password:')\n        child.sendline(mypassword)\n\nThis works even for commands that ask for passwords or other input outside of\nthe normal stdio streams. For example, ssh reads input directly from the TTY\ndevice which bypasses stdin.\n\nCredits: Noah Spurrier, Richard Holden, Marco Molteni, Kimberley Burchett,\nRobert Stone, Hartmut Goebel, Chad Schroeder, Erick Tryzelaar, Dave Kirby, Ids\nvander Molen, George Todd, Noel Taylor, Nicolas D. Cesar, Alexander Gattin,\nJacques-Etienne Baudoux, Geoffrey Marshall, Francisco Lourenco, Glen Mabey,\nKarthik Gurusamy, Fernando Perez, Corey Minyard, Jon Cohen, Guillaume\nChazarain, Andrew Ryan, Nick Craig-Wood, Andrew Stone, Jorgen Grahn, John\nSpiegel, Jan Grant, and Shane Kerr. Let me know if I forgot anyone.\n\nPexpect is free, open source, and all that good stuff.\nhttp://pexpect.sourceforge.net/\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nimport sys\nPY3 = (sys.version_info[0] >= 3)\n\nfrom .exceptions import ExceptionPexpect, EOF, TIMEOUT\nfrom .utils import split_command_line, which, is_executable_file\nfrom .expect import Expecter, searcher_re, searcher_string\n\nif sys.platform != 'win32':\n    # On Unix, these are available at the top level for backwards compatibility\n    from .pty_spawn import spawn, spawnu\n    from .run import run, runu\n\n__version__ = '4.9.0'\n__revision__ = ''\n__all__ = ['ExceptionPexpect', 'EOF', 'TIMEOUT', 'spawn', 'spawnu', 'run', 'runu',\n           'which', 'split_command_line', '__version__', '__revision__']\n\n\n\n# vim: set shiftround expandtab tabstop=4 shiftwidth=4 ft=python autoindent :\n", "pexpect/popen_spawn.py": "\"\"\"Provides an interface like pexpect.spawn interface using subprocess.Popen\n\"\"\"\nimport os\nimport threading\nimport subprocess\nimport sys\nimport time\nimport signal\nimport shlex\n\ntry:\n    from queue import Queue, Empty  # Python 3\nexcept ImportError:\n    from Queue import Queue, Empty  # Python 2\n\nfrom .spawnbase import SpawnBase, PY3\nfrom .exceptions import EOF\nfrom .utils import string_types\n\nclass PopenSpawn(SpawnBase):\n    def __init__(self, cmd, timeout=30, maxread=2000, searchwindowsize=None,\n                 logfile=None, cwd=None, env=None, encoding=None,\n                 codec_errors='strict', preexec_fn=None):\n        super(PopenSpawn, self).__init__(timeout=timeout, maxread=maxread,\n                searchwindowsize=searchwindowsize, logfile=logfile,\n                encoding=encoding, codec_errors=codec_errors)\n\n        # Note that `SpawnBase` initializes `self.crlf` to `\\r\\n`\n        # because the default behaviour for a PTY is to convert\n        # incoming LF to `\\r\\n` (see the `onlcr` flag and\n        # https://stackoverflow.com/a/35887657/5397009). Here we set\n        # it to `os.linesep` because that is what the spawned\n        # application outputs by default and `popen` doesn't translate\n        # anything.\n        if encoding is None:\n            self.crlf = os.linesep.encode (\"ascii\")\n        else:\n            self.crlf = self.string_type (os.linesep)\n\n        kwargs = dict(bufsize=0, stdin=subprocess.PIPE,\n                      stderr=subprocess.STDOUT, stdout=subprocess.PIPE,\n                      cwd=cwd, preexec_fn=preexec_fn, env=env)\n\n        if sys.platform == 'win32':\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            kwargs['startupinfo'] = startupinfo\n            kwargs['creationflags'] = subprocess.CREATE_NEW_PROCESS_GROUP\n\n        if isinstance(cmd, string_types) and sys.platform != 'win32':\n            cmd = shlex.split(cmd, posix=os.name == 'posix')\n\n        self.proc = subprocess.Popen(cmd, **kwargs)\n        self.pid = self.proc.pid\n        self.closed = False\n        self._buf = self.string_type()\n\n        self._read_queue = Queue()\n        self._read_thread = threading.Thread(target=self._read_incoming)\n        self._read_thread.daemon = True\n        self._read_thread.start()\n\n    _read_reached_eof = False\n\n    def read_nonblocking(self, size, timeout):\n        buf = self._buf\n        if self._read_reached_eof:\n            # We have already finished reading. Use up any buffered data,\n            # then raise EOF\n            if buf:\n                self._buf = buf[size:]\n                return buf[:size]\n            else:\n                self.flag_eof = True\n                raise EOF('End Of File (EOF).')\n\n        if timeout == -1:\n            timeout = self.timeout\n        elif timeout is None:\n            timeout = 1e6\n\n        t0 = time.time()\n        while (time.time() - t0) < timeout and size and len(buf) < size:\n            try:\n                incoming = self._read_queue.get_nowait()\n            except Empty:\n                break\n            else:\n                if incoming is None:\n                    self._read_reached_eof = True\n                    break\n\n                buf += self._decoder.decode(incoming, final=False)\n\n        r, self._buf = buf[:size], buf[size:]\n\n        self._log(r, 'read')\n        return r\n\n    def _read_incoming(self):\n        \"\"\"Run in a thread to move output from a pipe to a queue.\"\"\"\n        fileno = self.proc.stdout.fileno()\n        while 1:\n            buf = b''\n            try:\n                buf = os.read(fileno, 1024)\n            except OSError as e:\n                self._log(e, 'read')\n\n            if not buf:\n                # This indicates we have reached EOF\n                self._read_queue.put(None)\n                return\n\n            self._read_queue.put(buf)\n\n    def write(self, s):\n        '''This is similar to send() except that there is no return value.\n        '''\n        self.send(s)\n\n    def writelines(self, sequence):\n        '''This calls write() for each element in the sequence.\n\n        The sequence can be any iterable object producing strings, typically a\n        list of strings. This does not add line separators. There is no return\n        value.\n        '''\n        for s in sequence:\n            self.send(s)\n\n    def send(self, s):\n        '''Send data to the subprocess' stdin.\n\n        Returns the number of bytes written.\n        '''\n        s = self._coerce_send_string(s)\n        self._log(s, 'send')\n\n        b = self._encoder.encode(s, final=False)\n        if PY3:\n            return self.proc.stdin.write(b)\n        else:\n            # On Python 2, .write() returns None, so we return the length of\n            # bytes written ourselves. This assumes they all got written.\n            self.proc.stdin.write(b)\n            return len(b)\n\n    def sendline(self, s=''):\n        '''Wraps send(), sending string ``s`` to child process, with os.linesep\n        automatically appended. Returns number of bytes written. '''\n\n        n = self.send(s)\n        return n + self.send(self.linesep)\n\n    def wait(self):\n        '''Wait for the subprocess to finish.\n\n        Returns the exit code.\n        '''\n        status = self.proc.wait()\n        if status >= 0:\n            self.exitstatus = status\n            self.signalstatus = None\n        else:\n            self.exitstatus = None\n            self.signalstatus = -status\n        self.terminated = True\n        return status\n\n    def kill(self, sig):\n        '''Sends a Unix signal to the subprocess.\n\n        Use constants from the :mod:`signal` module to specify which signal.\n        '''\n        if sys.platform == 'win32':\n            if sig in [signal.SIGINT, signal.CTRL_C_EVENT]:\n                sig = signal.CTRL_C_EVENT\n            elif sig in [signal.SIGBREAK, signal.CTRL_BREAK_EVENT]:\n                sig = signal.CTRL_BREAK_EVENT\n            else:\n                sig = signal.SIGTERM\n\n        os.kill(self.proc.pid, sig)\n\n    def sendeof(self):\n        '''Closes the stdin pipe from the writing end.'''\n        self.proc.stdin.close()\n", "examples/astat.py": "#!/usr/bin/env python\n\n'''This runs Apache Status on the remote host and returns the number of requests per second.\n\n./astat.py [-s server_hostname] [-u username] [-p password]\n    -s : hostname of the remote server to login to.\n    -u : username to user for login.\n    -p : Password to user for login.\n\nExample:\n    This will print information about the given host:\n        ./astat.py -s www.example.com -u mylogin -p mypassword\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport os\nimport sys\nimport getopt\nimport getpass\nfrom pexpect import pxssh\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\ndef exit_with_usage():\n\n    print(globals()['__doc__'])\n    os._exit(1)\n\n\ndef main():\n\n    ######################################################################\n    ## Parse the options, arguments, get ready, etc.\n    ######################################################################\n    try:\n        optlist, args = getopt.getopt(sys.argv[1:], 'h?s:u:p:', ['help','h','?'])\n    except Exception as e:\n        print(str(e))\n        exit_with_usage()\n    options = dict(optlist)\n    if len(args) > 1:\n        exit_with_usage()\n\n    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:\n        print(\"Help:\")\n        exit_with_usage()\n\n    if '-s' in options:\n        hostname = options['-s']\n    else:\n        hostname = raw_input('hostname: ')\n    if '-u' in options:\n        username = options['-u']\n    else:\n        username = raw_input('username: ')\n    if '-p' in options:\n        password = options['-p']\n    else:\n        password = getpass.getpass('password: ')\n\n    #\n    # Login via SSH\n    #\n    p = pxssh.pxssh()\n    p.login(hostname, username, password)\n    p.sendline('apachectl status')\n    p.expect(r'([0-9]+\\.[0-9]+)\\s*requests/sec')\n    requests_per_second = p.match.groups()[0]\n    p.logout()\n    print(requests_per_second)\n\nif __name__ == \"__main__\":\n    main()\n", "examples/monitor.py": "#!/usr/bin/env python\n\n''' This runs a sequence of commands on a remote host using SSH. It runs a\nsimple system checks such as uptime and free to monitor the state of the remote\nhost.\n\n./monitor.py [-s server_hostname] [-u username] [-p password]\n    -s : hostname of the remote server to login to.\n    -u : username to user for login.\n    -p : Password to user for login.\n\nExample:\n    This will print information about the given host:\n        ./monitor.py -s www.example.com -u mylogin -p mypassword\n\nIt works like this:\n    Login via SSH (This is the hardest part).\n    Run and parse 'uptime'.\n    Run 'iostat'.\n    Run 'vmstat'.\n    Run 'netstat'\n    Run 'free'.\n    Exit the remote host.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport os, sys, re, getopt, getpass\nimport pexpect\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\n#\n# Some constants.\n#\nCOMMAND_PROMPT = '[#$] ' ### This is way too simple for industrial use -- we will change is ASAP.\nTERMINAL_PROMPT = r'(?i)terminal type\\?'\nTERMINAL_TYPE = 'vt100'\n# This is the prompt we get if SSH does not have the remote host's public key stored in the cache.\nSSH_NEWKEY = '(?i)are you sure you want to continue connecting'\n\ndef exit_with_usage():\n\n    print(globals()['__doc__'])\n    os._exit(1)\n\ndef main():\n\n    global COMMAND_PROMPT, TERMINAL_PROMPT, TERMINAL_TYPE, SSH_NEWKEY\n    ######################################################################\n    ## Parse the options, arguments, get ready, etc.\n    ######################################################################\n    try:\n        optlist, args = getopt.getopt(sys.argv[1:], 'h?s:u:p:', ['help','h','?'])\n    except Exception as e:\n        print(str(e))\n        exit_with_usage()\n    options = dict(optlist)\n    if len(args) > 1:\n        exit_with_usage()\n\n    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:\n        print(\"Help:\")\n        exit_with_usage()\n\n    if '-s' in options:\n        host = options['-s']\n    else:\n        host = raw_input('hostname: ')\n    if '-u' in options:\n        user = options['-u']\n    else:\n        user = raw_input('username: ')\n    if '-p' in options:\n        password = options['-p']\n    else:\n        password = getpass.getpass('password: ')\n\n    #\n    # Login via SSH\n    #\n    child = pexpect.spawn('ssh -l %s %s'%(user, host))\n    i = child.expect([pexpect.TIMEOUT, SSH_NEWKEY, COMMAND_PROMPT, '(?i)password'])\n    if i == 0: # Timeout\n        print('ERROR! could not login with SSH. Here is what SSH said:')\n        print(child.before, child.after)\n        print(str(child))\n        sys.exit (1)\n    if i == 1: # In this case SSH does not have the public key cached.\n        child.sendline ('yes')\n        child.expect ('(?i)password')\n    if i == 2:\n        # This may happen if a public key was setup to automatically login.\n        # But beware, the COMMAND_PROMPT at this point is very trivial and\n        # could be fooled by some output in the MOTD or login message.\n        pass\n    if i == 3:\n        child.sendline(password)\n        # Now we are either at the command prompt or\n        # the login process is asking for our terminal type.\n        i = child.expect ([COMMAND_PROMPT, TERMINAL_PROMPT])\n        if i == 1:\n            child.sendline (TERMINAL_TYPE)\n            child.expect (COMMAND_PROMPT)\n    #\n    # Set command prompt to something more unique.\n    #\n    COMMAND_PROMPT = r\"\\[PEXPECT\\]\\$ \"\n    child.sendline (r\"PS1='[PEXPECT]\\$ '\") # In case of sh-style\n    i = child.expect ([pexpect.TIMEOUT, COMMAND_PROMPT], timeout=10)\n    if i == 0:\n        print(\"# Couldn't set sh-style prompt -- trying csh-style.\")\n        child.sendline (r\"set prompt='[PEXPECT]\\$ '\")\n        i = child.expect ([pexpect.TIMEOUT, COMMAND_PROMPT], timeout=10)\n        if i == 0:\n            print(\"Failed to set command prompt using sh or csh style.\")\n            print(\"Response was:\")\n            print(child.before)\n            sys.exit (1)\n\n    # Now we should be at the command prompt and ready to run some commands.\n    print('---------------------------------------')\n    print('Report of commands run on remote host.')\n    print('---------------------------------------')\n\n    # Run uname.\n    child.sendline ('uname -a')\n    child.expect (COMMAND_PROMPT)\n    print(child.before)\n    if 'linux' in child.before.lower():\n        LINUX_MODE = 1\n    else:\n        LINUX_MODE = 0\n\n    # Run and parse 'uptime'.\n    child.sendline ('uptime')\n    child.expect(r'up\\s+(.*?),\\s+([0-9]+) users?,\\s+load averages?: ([0-9]+\\.[0-9][0-9]),?\\s+([0-9]+\\.[0-9][0-9]),?\\s+([0-9]+\\.[0-9][0-9])')\n    duration, users, av1, av5, av15 = child.match.groups()\n    days = '0'\n    hours = '0'\n    mins = '0'\n    if 'day' in duration:\n        child.match = re.search(r'([0-9]+)\\s+day',duration)\n        days = str(int(child.match.group(1)))\n    if ':' in duration:\n        child.match = re.search('([0-9]+):([0-9]+)',duration)\n        hours = str(int(child.match.group(1)))\n        mins = str(int(child.match.group(2)))\n    if 'min' in duration:\n        child.match = re.search(r'([0-9]+)\\s+min',duration)\n        mins = str(int(child.match.group(1)))\n    print()\n    print('Uptime: %s days, %s users, %s (1 min), %s (5 min), %s (15 min)' % (\n        duration, users, av1, av5, av15))\n    child.expect (COMMAND_PROMPT)\n\n    # Run iostat.\n    child.sendline ('iostat')\n    child.expect (COMMAND_PROMPT)\n    print(child.before)\n\n    # Run vmstat.\n    child.sendline ('vmstat')\n    child.expect (COMMAND_PROMPT)\n    print(child.before)\n\n    # Run free.\n    if LINUX_MODE:\n        child.sendline ('free') # Linux systems only.\n        child.expect (COMMAND_PROMPT)\n        print(child.before)\n\n    # Run df.\n    child.sendline ('df')\n    child.expect (COMMAND_PROMPT)\n    print(child.before)\n\n    # Run lsof.\n    child.sendline ('lsof')\n    child.expect (COMMAND_PROMPT)\n    print(child.before)\n\n#    # Run netstat\n#    child.sendline ('netstat')\n#    child.expect (COMMAND_PROMPT)\n#    print child.before\n\n#    # Run MySQL show status.\n#    child.sendline ('mysql -p -e \"SHOW STATUS;\"')\n#    child.expect (PASSWORD_PROMPT_MYSQL)\n#    child.sendline (password_mysql)\n#    child.expect (COMMAND_PROMPT)\n#    print\n#    print child.before\n\n    # Now exit the remote host.\n    child.sendline ('exit')\n    index = child.expect([pexpect.EOF, \"(?i)there are stopped jobs\"])\n    if index==1:\n        child.sendline(\"exit\")\n        child.expect(EOF)\n\nif __name__ == \"__main__\":\n    main()\n", "examples/df.py": "#!/usr/bin/env python\n\n'''This collects filesystem capacity info using the 'df' command. Tuples of\nfilesystem name and percentage are stored in a list. A simple report is\nprinted. Filesystems over 95% capacity are highlighted. Note that this does not\nparse filesystem names after the first space, so names with spaces in them will\nbe truncated. This will produce ambiguous results for automount filesystems on\nApple OSX.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\n\nchild = pexpect.spawn ('df')\n\n# parse 'df' output into a list.\npattern = r\"\\n(\\S+).*?([0-9]+)%\"\nfilesystem_list = []\nfor dummy in range (0, 1000):\n    i = child.expect ([pattern, pexpect.EOF])\n    if i == 0:\n        filesystem_list.append (child.match.groups())\n    else:\n        break\n\n# Print report\nprint()\nfor m in filesystem_list:\n    s = \"Filesystem %s is at %s%%\" % (m[0], m[1])\n    # highlight filesystems over 95% capacity\n    if int(m[1]) > 95:\n        s = '! ' + s\n    else:\n        s = '  ' + s\n    print(s)\n\n", "examples/topip.py": "#!/usr/bin/env python\n\n''' This runs netstat on a local or remote server. It calculates some simple\nstatistical information on the number of external inet connections. It groups\nby IP address. This can be used to detect if one IP address is taking up an\nexcessive number of connections. It can also send an email alert if a given IP\naddress exceeds a threshold between runs of the script. This script can be used\nas a drop-in Munin plugin or it can be used stand-alone from cron. I used this\non a busy web server that would sometimes get hit with denial of service\nattacks. This made it easy to see if a script was opening many multiple\nconnections. A typical browser would open fewer than 10 connections at once.\nA script might open over 100 simultaneous connections.\n\n./topip.py [-s server_hostname] [-u username] [-p password]\n        {-a from_addr,to_addr} {-n N} {-v} {--ipv6}\n\n    -s : hostname of the remote server to login to.\n    -u : username to user for login.\n    -p : password to user for login.\n    -n : print stddev for the the number of the top 'N' ipaddresses.\n    -v : verbose - print stats and list of top ipaddresses.\n    -a : send alert if stddev goes over 20.\n    -l : to log message to /var/log/topip.log\n    --ipv6 : this parses netstat output that includes ipv6 format.\n        Note that this actually only works with ipv4 addresses, but for\n        versions of netstat that print in ipv6 format.\n    --stdev=N : Where N is an integer. This sets the trigger point\n        for alerts and logs. Default is to trigger if the\n        max value is over 5 standard deviations.\n\nExample:\n\n    This will print stats for the top IP addresses connected to the given host:\n\n        ./topip.py -s www.example.com -u mylogin -p mypassword -n 10 -v\n\n    This will send an alert email if the maxip goes over the stddev trigger\n    value and the the current top ip is the same as the last top ip\n    (/tmp/topip.last):\n\n        ./topip.py -s www.example.com -u mylogin -p mypassword \\\\\n                -n 10 -v -a alert@example.com,user@example.com\n\n    This will print the connection stats for the localhost in Munin format:\n\n        ./topip.py\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\n# See http://pexpect.sourceforge.net/\nimport pexpect\nfrom pexpect import pxssh\nimport os\nimport sys\nimport time\nimport getopt\nimport pickle\nimport getpass\nimport smtplib\nfrom pprint import pprint\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nTOPIP_LOG_FILE = '/var/log/topip.log'\nTOPIP_LAST_RUN_STATS = '/var/run/topip.last'\n\ndef exit_with_usage():\n\n    print(globals()['__doc__'])\n    os._exit(1)\n\ndef stats(r):\n\n    '''This returns a dict of the median, average, standard deviation,\n    min and max of the given sequence.\n\n    >>> from topip import stats\n    >>> print stats([5,6,8,9])\n    {'med': 8, 'max': 9, 'avg': 7.0, 'stddev': 1.5811388300841898, 'min': 5}\n    >>> print stats([1000,1006,1008,1014])\n    {'med': 1008, 'max': 1014, 'avg': 1007.0, 'stddev': 5.0, 'min': 1000}\n    >>> print stats([1,3,4,5,18,16,4,3,3,5,13])\n    {'med': 4, 'max': 18, 'avg': 6.8181818181818183, 'stddev': 5.6216817577237475, 'min': 1}\n    >>> print stats([1,3,4,5,18,16,4,3,3,5,13,14,5,6,7,8,7,6,6,7,5,6,4,14,7])\n    {'med': 6, 'max': 18, 'avg': 7.0800000000000001, 'stddev': 4.3259218670706474, 'min': 1}\n    '''\n\n    total = sum(r)\n    avg = float(total)/float(len(r))\n    sdsq = sum([(i-avg)**2 for i in r])\n    s = sorted(list(r))\n    return dict(list(zip(['med', 'avg', 'stddev', 'min', 'max'],\n        (s[len(s)//2], avg, (sdsq/len(r))**.5, min(r), max(r)))))\n\ndef send_alert (message, subject, addr_from, addr_to, smtp_server='localhost'):\n\n    '''This sends an email alert.\n    '''\n\n    message = ( 'From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n'\n            % (addr_from, addr_to, subject) + message )\n    server = smtplib.SMTP(smtp_server)\n    server.sendmail(addr_from, addr_to, message)\n    server.quit()\n\ndef main():\n\n    # Parse the options, arguments, etc.\n    try:\n        optlist, args = getopt.getopt(sys.argv[1:],\n                'h?valqs:u:p:n:', ['help','h','?','ipv6','stddev='])\n    except Exception as e:\n        print(str(e))\n        exit_with_usage()\n    options = dict(optlist)\n\n    munin_flag = False\n    if len(args) > 0:\n        if args[0] == 'config':\n            print('graph_title Netstat Connections per IP')\n            print('graph_vlabel Socket connections per IP')\n            print('connections_max.label max')\n            print('connections_max.info Maximum number of connections per IP')\n            print('connections_avg.label avg')\n            print('connections_avg.info Average number of connections per IP')\n            print('connections_stddev.label stddev')\n            print('connections_stddev.info Standard deviation')\n            return 0\n        elif args[0] != '':\n            print(args, len(args))\n            return 0\n            exit_with_usage()\n    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:\n        print('Help:')\n        exit_with_usage()\n    if '-s' in options:\n        hostname = options['-s']\n    else:\n        # if host was not specified then assume localhost munin plugin.\n        munin_flag = True\n        hostname = 'localhost'\n    # If localhost then don't ask for username/password.\n    if hostname != 'localhost' and hostname != '127.0.0.1':\n        if '-u' in options:\n            username = options['-u']\n        else:\n            username = raw_input('username: ')\n        if '-p' in options:\n            password = options['-p']\n        else:\n            password = getpass.getpass('password: ')\n        use_localhost = False\n    else:\n        use_localhost = True\n\n    if '-l' in options:\n        log_flag = True\n    else:\n        log_flag = False\n    if '-n' in options:\n        average_n = int(options['-n'])\n    else:\n        average_n = None\n    if '-v' in options:\n        verbose = True\n    else:\n        verbose = False\n    if '-a' in options:\n        alert_flag = True\n        (alert_addr_from, alert_addr_to) = tuple(options['-a'].split(','))\n    else:\n        alert_flag = False\n    if '--ipv6' in options:\n        ipv6_flag = True\n    else:\n        ipv6_flag = False\n    if '--stddev' in options:\n        stddev_trigger = float(options['--stddev'])\n    else:\n        stddev_trigger = 5\n\n    if ipv6_flag:\n        netstat_pattern = r'(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+::ffff:(\\S+):(\\S+)\\s+.*?\\r'\n    else:\n        netstat_pattern = r'(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(?:::ffff:)*(\\S+):(\\S+)\\s+.*?\\r'\n        #netstat_pattern = r'(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+):(\\S+)\\s+.*?\\r'\n\n    # run netstat (either locally or via SSH).\n    if use_localhost:\n        p = pexpect.spawn('netstat -n -t')\n        PROMPT = pexpect.TIMEOUT\n    else:\n        p = pxssh.pxssh()\n        p.login(hostname, username, password)\n        p.sendline('netstat -n -t')\n        PROMPT = p.PROMPT\n\n    # For each matching netstat_pattern put the ip address in the list.\n    ip_list = {}\n    try:\n        while 1:\n            i = p.expect([PROMPT, netstat_pattern])\n            if i == 0:\n                break\n            k = p.match.groups()[4].decode('utf-8')\n            if k in ip_list:\n                ip_list[k] = ip_list[k] + 1\n            else:\n                ip_list[k] = 1\n    except:\n        pass\n\n    # remove a few common, uninteresting addresses from the dictionary.\n    ip_list = dict([ (key,value) for key,value in ip_list.items() if '192.168.' not in key])\n    ip_list = dict([ (key,value) for key,value in ip_list.items() if '127.0.0.1' not in key])\n\n    ip_list = list(ip_list.items())\n    if len(ip_list) < 1:\n        if verbose: print('Warning: no networks connections worth looking at.')\n        return 0\n    ip_list.sort(key=lambda x:x[1])\n\n    # generate some stats for the ip addresses found.\n    if average_n is not None and average_n <= 1:\n        average_n = None\n    # Reminder: the * unary operator treats the list elements as arguments.\n    zipped = zip(*ip_list[0:average_n])\n    s = stats(list(zipped)[1])\n    s['maxip'] = ip_list[0]\n\n    # print munin-style or verbose results for the stats.\n    if munin_flag:\n        print('connections_max.value', s['max'])\n        print('connections_avg.value', s['avg'])\n        print('connections_stddev.value', s['stddev'])\n        return 0\n    if verbose:\n        pprint (s)\n        print()\n        pprint (ip_list[0:average_n])\n\n    # load the stats from the last run.\n    try:\n        last_stats = pickle.load(file(TOPIP_LAST_RUN_STATS))\n    except:\n        last_stats = {'maxip':None}\n\n    if ( s['maxip'][1] > (s['stddev'] * stddev_trigger)\n            and s['maxip']==last_stats['maxip'] ):\n        if verbose: print('The maxip has been above trigger for two consecutive samples.')\n        if alert_flag:\n            if verbose: print('SENDING ALERT EMAIL')\n            send_alert(str(s), 'ALERT on %s'\n                    % hostname, alert_addr_from, alert_addr_to)\n        if log_flag:\n            if verbose: print('LOGGING THIS EVENT')\n            fout = file(TOPIP_LOG_FILE,'a')\n            #dts = time.strftime('%Y:%m:%d:%H:%M:%S', time.localtime())\n            dts = time.asctime()\n            fout.write ('%s - %d connections from %s\\n'\n                    % (dts,s['maxip'][1],str(s['maxip'][0])))\n            fout.close()\n\n    # save state to TOPIP_LAST_RUN_STATS\n    try:\n        pickle.dump(s, file(TOPIP_LAST_RUN_STATS,'w'))\n        os.chmod (TOPIP_LAST_RUN_STATS, 0o664)\n    except:\n        pass\n    # p.logout()\n\nif __name__ == '__main__':\n    main()\n", "examples/ftp.py": "#!/usr/bin/env python\n\n'''This demonstrates an FTP \"bookmark\". This connects to an ftp site; does a\nfew ftp stuff; and then gives the user interactive control over the session. In\nthis case the \"bookmark\" is to a directory on the OpenBSD ftp server. It puts\nyou in the i386 packages directory. You can easily modify this for other sites.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport pexpect\nimport sys\n\n# Note that, for Python 3 compatibility reasons, we are using spawnu and\n# importing unicode_literals (above). spawnu accepts Unicode input and\n# unicode_literals makes all string literals in this script Unicode by default.\nchild = pexpect.spawnu('ftp ftp.openbsd.org')\n\nchild.expect('(?i)name .*: ')\nchild.sendline('anonymous')\nchild.expect('(?i)password')\nchild.sendline('pexpect@sourceforge.net')\nchild.expect('ftp> ')\nchild.sendline('cd /pub/OpenBSD/3.7/packages/i386')\nchild.expect('ftp> ')\nchild.sendline('bin')\nchild.expect('ftp> ')\nchild.sendline('prompt')\nchild.expect('ftp> ')\nchild.sendline('pwd')\nchild.expect('ftp> ')\nprint(\"Escape character is '^]'.\\n\")\nsys.stdout.write (child.after)\nsys.stdout.flush()\nchild.interact() # Escape character defaults to ^]\n# At this point this script blocks until the user presses the escape character\n# or until the child exits. The human user and the child should be talking\n# to each other now.\n\n# At this point the script is running again.\nprint('Left interactve mode.')\n\n# The rest is not strictly necessary. This just demonstrates a few functions.\n# This makes sure the child is dead; although it would be killed when Python exits.\nif child.isalive():\n    child.sendline('bye') # Try to ask ftp child to exit.\n    child.close()\n# Print the final state of the child. Normally isalive() should be FALSE.\nif child.isalive():\n    print('Child did not exit gracefully.')\nelse:\n    print('Child exited gracefully.')\n\n", "examples/python.py": "#!/usr/bin/env python\n\n'''This starts the python interpreter; captures the startup message; then gives\nthe user interactive control over the session. Why? For fun...\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport pexpect\n\n# Don't do this unless you like being John Malkovich\n# c = pexpect.spawnu('/usr/bin/env python ./python.py')\n\n# Note that, for Python 3 compatibility reasons, we are using spawnu and\n# importing unicode_literals (above). spawnu accepts Unicode input and\n# unicode_literals makes all string literals in this script Unicode by default.\nc = pexpect.spawnu('/usr/bin/env python')\n\nc.expect('>>>')\nprint('And now for something completely different...')\nprint(''.join(reversed((c.before))))\nprint('Yes, it\\'s python, but it\\'s backwards.')\nprint()\nprint('Escape character is \\'^]\\'.')\nprint(c.after, end=' ')\nc.interact()\nc.kill(1)\nprint('is alive:', c.isalive())\n\n", "examples/passmass.py": "#!/usr/bin/env python\n\n'''Change passwords on the named machines. passmass host1 host2 host3 . . .\nNote that login shell prompt on remote machine must end in # or $.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\nimport sys, getpass\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nUSAGE = '''passmass host1 host2 host3 . . .'''\nCOMMAND_PROMPT = '[$#] '\nTERMINAL_PROMPT = r'Terminal type\\?'\nTERMINAL_TYPE = 'vt100'\nSSH_NEWKEY = r'Are you sure you want to continue connecting \\(yes/no\\)\\?'\n\ndef login(host, user, password):\n\n    child = pexpect.spawn('ssh -l %s %s'%(user, host))\n    fout = file (\"LOG.TXT\",\"wb\")\n    child.logfile_read = fout #use child.logfile to also log writes (passwords!)\n\n    i = child.expect([pexpect.TIMEOUT, SSH_NEWKEY, '[Pp]assword: '])\n    if i == 0: # Timeout\n        print('ERROR!')\n        print('SSH could not login. Here is what SSH said:')\n        print(child.before, child.after)\n        sys.exit (1)\n    if i == 1: # SSH does not have the public key. Just accept it.\n        child.sendline ('yes')\n        child.expect ('[Pp]assword: ')\n    child.sendline(password)\n    # Now we are either at the command prompt or\n    # the login process is asking for our terminal type.\n    i = child.expect (['Permission denied', TERMINAL_PROMPT, COMMAND_PROMPT])\n    if i == 0:\n        print('Permission denied on host:', host)\n        sys.exit (1)\n    if i == 1:\n        child.sendline (TERMINAL_TYPE)\n        child.expect (COMMAND_PROMPT)\n    return child\n\n# (current) UNIX password:\ndef change_password(child, user, oldpassword, newpassword):\n\n    child.sendline('passwd')\n    i = child.expect(['[Oo]ld [Pp]assword', '.current.*password', '[Nn]ew [Pp]assword'])\n    # Root does not require old password, so it gets to bypass the next step.\n    if i == 0 or i == 1:\n        child.sendline(oldpassword)\n        child.expect('[Nn]ew [Pp]assword')\n    child.sendline(newpassword)\n    i = child.expect(['[Nn]ew [Pp]assword', '[Rr]etype', '[Rr]e-enter'])\n    if i == 0:\n        print('Host did not like new password. Here is what it said...')\n        print(child.before)\n        child.send (chr(3)) # Ctrl-C\n        child.sendline('') # This should tell remote passwd command to quit.\n        return\n    child.sendline(newpassword)\n\ndef main():\n\n    if len(sys.argv) <= 1:\n        print(USAGE)\n        return 1\n\n    user = raw_input('Username: ')\n    password = getpass.getpass('Current Password: ')\n    newpassword = getpass.getpass('New Password: ')\n    newpasswordconfirm = getpass.getpass('Confirm New Password: ')\n    if newpassword != newpasswordconfirm:\n        print('New Passwords do not match.')\n        return 1\n\n    for host in sys.argv[1:]:\n        child = login(host, user, password)\n        if child == None:\n            print('Could not login to host:', host)\n            continue\n        print('Changing password on host:', host)\n        change_password(child, user, password, newpassword)\n        child.expect(COMMAND_PROMPT)\n        child.sendline('exit')\n\nif __name__ == '__main__':\n    main()\n", "examples/ssh_tunnel.py": "#!/usr/bin/env python\n\n'''This starts an SSH tunnel to a given host. If the SSH process ever dies then\nthis script will detect that and restart it. I use this under Cygwin to keep\nopen encrypted tunnels to port 25 (SMTP), port 143 (IMAP4), and port 110\n(POP3). I set my mail client to talk to localhost and I keep this script\nrunning in the background.\n\nNote that this is a rather stupid script at the moment because it just looks to\nsee if any ssh process is running. It should really make sure that our specific\nssh process is running. The problem is that ssh is missing a very useful\nfeature. It has no way to report the process id of the background daemon that\nit creates with the -f command. This would be a really useful script if I could\nfigure a way around this problem.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\nimport getpass\nimport time\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\n# SMTP:25 IMAP4:143 POP3:110\ntunnel_command = 'ssh -C -N -f -L 25:127.0.0.1:25 -L 143:127.0.0.1:143 -L 110:127.0.0.1:110 %(user)@%(host)'\nhost = raw_input('Hostname: ')\nuser = raw_input('Username: ')\nX = getpass.getpass('Password: ')\n\ndef get_process_info ():\n\n    # This seems to work on both Linux and BSD, but should otherwise be considered highly UNportable.\n\n    ps = pexpect.run ('ps ax -O ppid')\n    pass\n\ndef start_tunnel ():\n\n    try:\n        ssh_tunnel = pexpect.spawn (tunnel_command % globals())\n        ssh_tunnel.expect ('password:')\n        time.sleep (0.1)\n        ssh_tunnel.sendline (X)\n        time.sleep (60) # Cygwin is slow to update process status.\n        ssh_tunnel.expect (pexpect.EOF)\n\n    except Exception as e:\n        print(str(e))\n\ndef main ():\n\n    while True:\n        ps = pexpect.spawn ('ps')\n        time.sleep (1)\n        index = ps.expect (['/usr/bin/ssh', pexpect.EOF, pexpect.TIMEOUT])\n        if index == 2:\n            print('TIMEOUT in ps command...')\n            print(str(ps))\n            time.sleep (13)\n        if index == 1:\n            print(time.asctime(), end=' ')\n            print('restarting tunnel')\n            start_tunnel ()\n            time.sleep (11)\n            print('tunnel OK')\n        else:\n            # print 'tunnel OK'\n            time.sleep (7)\n\nif __name__ == '__main__':\n\n    main ()\n\n# This was for older SSH versions that didn't have -f option\n#tunnel_command = 'ssh -C -n -L 25:%(host)s:25 -L 110:%(host)s:110 %(user)s@%(host)s -f nothing.sh'\n#nothing_script = '''#!/bin/sh\n#while true; do sleep 53; done\n#'''\n\n", "examples/terminal_emulation.py": "#!/usr/bin/env python\n\n'''These examples show how to integrate pexpect with pyte, an ANSI terminal\nemulator.\n\nThese examples were taken from:\nhttps://byexamples.github.io/byexample\n\nWe will execute three commands:\n    - an 'echo' of a colored message to show how the ANSI colors can be removed.\n    - an 'echo' of a very large message to show how pyte emulates the terminal\n    geometry\n    - a 'less' of a very small file to show how pyte handles not only\n    the terminal geometry but also how interprets ANSI commands that control\n    the position of the cursor.\n\nSee also https://github.com/pexpect/pexpect/issues/587\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\nfrom __future__ import absolute_import\nfrom __future__ import unicode_literals\n\nimport pexpect\nimport pyte\nimport os\n\n# The geometry of the terminal. Typically this is 24x80\n# but we are going to us set a much smaller terminal\n# to show how to change the default.\nROWS, COLS = 10, 40\n\n# We create the Screen with the correct geometry and\n# a Stream to process the output coming from pexpect.\nscreen = pyte.Screen(COLS, ROWS)\nstream = pyte.Stream(screen)\n\n# Spawn a process using pexpect.spawn as usual\n# with a particularity: it sets the geometry of the terminal\n# using the environment variables *and* using the 'dimensions'\n# parameter of pexpect.spawn.\n# This is needed because no all the program honors the geometry\n# set by pexpect or by the env vars.\ndef spawn_process(cmd):\n    env = os.environ.copy()\n    env.update({'LINES': str(ROWS), 'COLUMNS': str(COLS)})\n\n    return pexpect.spawn(cmd, echo=False, encoding='utf-8', dimensions=(ROWS, COLS), env=env)\n\n# Send the raw output to pyte.Stream and get the emulated output\n# from pyte.Screen.\n# In each call we *reset* the display so we don't get the same\n# emulated output twice.\n#\n# Pyte emulates the whole terminal so it will return us ROWS rows\n# of each COLS columns each one completed with spaces.\n#\n# Optionally we strip the whitespace on the right and any empty line\ndef emulate_ansi_terminal(raw_output, clean=True):\n    stream.feed(raw_output)\n\n    lines = screen.display\n    screen.reset()\n\n    if clean:\n        lines = (line.rstrip() for line in lines)\n        lines = (line for line in lines if line)\n\n    return '\\n'.join(lines)\n\ndef pprint(out):\n    print(\"-\" * COLS)\n    print(out)\n    print(\"-\" * COLS)\n\nprint(\"\\nFirst example: echo a message with ANSI color sequences.\")\nchild = spawn_process(r'echo -e \"\\033[31mThis message should not be in red\\033[0m\"')\nchild.expect(pexpect.EOF)\nout = emulate_ansi_terminal(child.before)\n\nprint(\"This should *not* print any escape sequence,\",\n      \"those were emulated and discarded by pyte.\\n\")\npprint(out)\n\nprint(\"\\nSecond example: echo a very large message.\")\nmsg = (\"aaaabbbb\" * 8)\nchild = spawn_process('echo \"%s\"' % msg)\nchild.expect(pexpect.EOF)\nout = emulate_ansi_terminal(child.before)\n\nprint(\"This should print the message in *two* lines because we\",\n      \"configured a terminal very small and the message will\",\n      \"not fit in one line.\\n\")\npprint(out)\n\n\nprint(\"\\nThird example: run the less program.\")\nchild = spawn_process('''bash -c \"head -n7 '%s' | less\"''' % __file__)\nchild.expect(pexpect.TIMEOUT, timeout=5)\nout = emulate_ansi_terminal(child.before, clean=False)\n\npprint(out)\n", "examples/chess3.py": "#!/usr/bin/env python\n\n'''This demonstrates controlling a screen oriented application (curses).\nIt starts two instances of gnuchess and then pits them against each other.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\nfrom pexpect import ANSI\n\nREGEX_MOVE = r'(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)'\nREGEX_MOVE_PART = r'(?:[0-9]|\\x1b\\[C)(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)'\n\nclass Chess:\n\n    def __init__(self, engine = \"/usr/local/bin/gnuchess -a -h 1\"):\n        self.child = pexpect.spawn (engine)\n        self.term = ANSI.ANSI ()\n\n#\t\tself.child.expect ('Chess')\n    #\tif self.child.after != 'Chess':\n    #\t\traise IOError, 'incompatible chess program'\n    #        self.term.process_list (self.before)\n    #        self.term.process_list (self.after)\n        self.last_computer_move = ''\n    def read_until_cursor (self, r,c):\n        fout = open ('log','a')\n        while 1:\n            k = self.child.read(1, 10)\n            self.term.process (k)\n            fout.write ('(r,c):(%d,%d)\\n' %(self.term.cur_r, self.term.cur_c))\n            fout.flush()\n            if self.term.cur_r == r and self.term.cur_c == c:\n                fout.close()\n                return 1\n            sys.stdout.write (k)\n            sys.stdout.flush()\n\n    def do_scan (self):\n        fout = open ('log','a')\n        while 1:\n            c = self.child.read(1,10)\n            self.term.process (c)\n            fout.write ('(r,c):(%d,%d)\\n' %(self.term.cur_r, self.term.cur_c))\n            fout.flush()\n            sys.stdout.write (c)\n            sys.stdout.flush()\n\n    def do_move (self, move):\n        self.read_until_cursor (19,60)\n        self.child.sendline (move)\n        return move\n\n    def get_computer_move (self):\n        print('Here')\n        i = self.child.expect ([r'\\[17;59H', r'\\[17;58H'])\n        print(i)\n        if i == 0:\n            self.child.expect (REGEX_MOVE)\n            if len(self.child.after) < 4:\n                self.child.after = self.child.after + self.last_computer_move[3]\n        if i == 1:\n            self.child.expect (REGEX_MOVE_PART)\n            self.child.after = self.last_computer_move[0] + self.child.after\n        print('', self.child.after)\n        self.last_computer_move = self.child.after\n        return self.child.after\n\n    def switch (self):\n        self.child.sendline ('switch')\n\n    def set_depth (self, depth):\n        self.child.sendline ('depth')\n        self.child.expect ('depth=')\n        self.child.sendline ('%d' % depth)\n\n    def quit(self):\n        self.child.sendline ('quit')\nimport sys\nprint('Starting...')\nwhite = Chess()\nwhite.do_move('b2b4')\nwhite.read_until_cursor (19,60)\nc1 = white.term.get_abs(17,58)\nc2 = white.term.get_abs(17,59)\nc3 = white.term.get_abs(17,60)\nc4 = white.term.get_abs(17,61)\nfout = open ('log','a')\nfout.write ('Computer:%s%s%s%s\\n' %(c1,c2,c3,c4))\nfout.close()\nwhite.do_move('c2c4')\nwhite.read_until_cursor (19,60)\nc1 = white.term.get_abs(17,58)\nc2 = white.term.get_abs(17,59)\nc3 = white.term.get_abs(17,60)\nc4 = white.term.get_abs(17,61)\nfout = open ('log','a')\nfout.write ('Computer:%s%s%s%s\\n' %(c1,c2,c3,c4))\nfout.close()\nwhite.do_scan ()\n\n#white.do_move ('b8a6')\n#move_white = white.get_computer_move()\n#print 'move white:', move_white\n\nsys.exit(1)\n\n\n\nblack = Chess()\nwhite = Chess()\nwhite.child.expect ('Your move is')\nwhite.switch()\n\nmove_white = white.get_first_computer_move()\nprint('first move white:', move_white)\n\nblack.do_first_move (move_white)\nmove_black = black.get_first_computer_move()\nprint('first move black:', move_black)\n\nwhite.do_move (move_black)\n\ndone = 0\nwhile not done:\n    move_white = white.get_computer_move()\n    print('move white:', move_white)\n\n    black.do_move (move_white)\n    move_black = black.get_computer_move()\n    print('move black:', move_black)\n\n    white.do_move (move_black)\n    print('tail of loop')\n\ng.quit()\n", "examples/hive.py": "#!/usr/bin/env python\n\n'''hive -- Hive Shell\n\nThis lets you ssh to a group of servers and control them as if they were one.\nEach command you enter is sent to each host in parallel. The response of each\nhost is collected and printed. In normal synchronous mode Hive will wait for\neach host to return the shell command line prompt. The shell prompt is used to\nsync output.\n\nExample:\n\n    $ hive.py --sameuser --samepass host1.example.com host2.example.net\n    username: myusername\n    password:\n    connecting to host1.example.com - OK\n    connecting to host2.example.net - OK\n    targeting hosts: 192.168.1.104 192.168.1.107\n    CMD (? for help) > uptime\n    =======================================================================\n    host1.example.com\n    -----------------------------------------------------------------------\n    uptime\n    23:49:55 up 74 days,  5:14,  2 users,  load average: 0.15, 0.05, 0.01\n    =======================================================================\n    host2.example.net\n    -----------------------------------------------------------------------\n    uptime\n    23:53:02 up 1 day, 13:36,  2 users,  load average: 0.50, 0.40, 0.46\n    =======================================================================\n\nOther Usage Examples:\n\n1. You will be asked for your username and password for each host.\n\n    hive.py host1 host2 host3 ... hostN\n\n2. You will be asked once for your username and password.\n   This will be used for each host.\n\n    hive.py --sameuser --samepass host1 host2 host3 ... hostN\n\n3. Give a username and password on the command-line:\n\n    hive.py user1:pass2@host1 user2:pass2@host2 ... userN:passN@hostN\n\nYou can use an extended host notation to specify username, password, and host\ninstead of entering auth information interactively. Where you would enter a\nhost name use this format:\n\n    username:password@host\n\nThis assumes that ':' is not part of the password. If your password contains a\n':' then you can use '\\\\:' to indicate a ':' and '\\\\\\\\' to indicate a single\n'\\\\'. Remember that this information will appear in the process listing. Anyone\non your machine can see this auth information. This is not secure.\n\nThis is a crude script that begs to be multithreaded. But it serves its\npurpose.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\n# TODO add feature to support username:password@host combination\n# TODO add feature to log each host output in separate file\n\nimport sys\nimport os\nimport re\nimport optparse\nimport time\nimport getpass\nimport readline\nimport atexit\ntry:\n    import pexpect\n    from pexpect import pxssh\nexcept ImportError:\n    sys.stderr.write(\"You do not have 'pexpect' installed.\\n\")\n    sys.stderr.write(\"On Ubuntu you need the 'python-pexpect' package.\\n\")\n    sys.stderr.write(\"    aptitude -y install python-pexpect\\n\")\n    exit(1)\n\n\ntry:\n    raw_input\nexcept NameError:\n    raw_input = input\n\n\nhistfile = os.path.join(os.environ[\"HOME\"], \".hive_history\")\ntry:\n    readline.read_history_file(histfile)\nexcept IOError:\n    pass\natexit.register(readline.write_history_file, histfile)\n\nCMD_HELP='''Hive commands are preceded by a colon : (just think of vi).\n\n:target name1 name2 name3 ...\n\n    set list of hosts to target commands\n\n:target all\n\n    reset list of hosts to target all hosts in the hive.\n\n:to name command\n\n    send a command line to the named host. This is similar to :target, but\n    sends only one command and does not change the list of targets for future\n    commands.\n\n:sync\n\n    set mode to wait for shell prompts after commands are run. This is the\n    default. When Hive first logs into a host it sets a special shell prompt\n    pattern that it can later look for to synchronize output of the hosts. If\n    you 'su' to another user then it can upset the synchronization. If you need\n    to run something like 'su' then use the following pattern:\n\n    CMD (? for help) > :async\n    CMD (? for help) > sudo su - root\n    CMD (? for help) > :prompt\n    CMD (? for help) > :sync\n\n:async\n\n    set mode to not expect command line prompts (see :sync). Afterwards\n    commands are send to target hosts, but their responses are not read back\n    until :sync is run. This is useful to run before commands that will not\n    return with the special shell prompt pattern that Hive uses to synchronize.\n\n:refresh\n\n    refresh the display. This shows the last few lines of output from all hosts.\n    This is similar to resync, but does not expect the promt. This is useful\n    for seeing what hosts are doing during long running commands.\n\n:resync\n\n    This is similar to :sync, but it does not change the mode. It looks for the\n    prompt and thus consumes all input from all targeted hosts.\n\n:prompt\n\n    force each host to reset command line prompt to the special pattern used to\n    synchronize all the hosts. This is useful if you 'su' to a different user\n    where Hive would not know the prompt to match.\n\n:send my text\n\n    This will send the 'my text' wihtout a line feed to the targeted hosts.\n    This output of the hosts is not automatically synchronized.\n\n:control X\n\n    This will send the given control character to the targeted hosts.\n    For example, \":control c\" will send ASCII 3.\n\n:exit\n\n    This will exit the hive shell.\n\n'''\n\ndef login (args, cli_username=None, cli_password=None):\n\n    # I have to keep a separate list of host names because Python dicts are not ordered.\n    # I want to keep the same order as in the args list.\n    host_names = []\n    hive_connect_info = {}\n    hive = {}\n    # build up the list of connection information (hostname, username, password, port)\n    for host_connect_string in args:\n        hcd = parse_host_connect_string (host_connect_string)\n        hostname = hcd['hostname']\n        port     = hcd['port']\n        if port == '':\n            port = None\n        if len(hcd['username']) > 0:\n            username = hcd['username']\n        elif cli_username is not None:\n            username = cli_username\n        else:\n            username = raw_input('%s username: ' % hostname)\n        if len(hcd['password']) > 0:\n            password = hcd['password']\n        elif cli_password is not None:\n            password = cli_password\n        else:\n            password = getpass.getpass('%s password: ' % hostname)\n        host_names.append(hostname)\n        hive_connect_info[hostname] = (hostname, username, password, port)\n    # build up the list of hive connections using the connection information.\n    for hostname in host_names:\n        print('connecting to', hostname)\n        try:\n            fout = file(\"log_\"+hostname, \"w\")\n            hive[hostname] = pxssh.pxssh()\n            # Disable host key checking.\n            hive[hostname].SSH_OPTS = (hive[hostname].SSH_OPTS\n                    + \" -o 'StrictHostKeyChecking=no'\"\n                    + \" -o 'UserKnownHostsFile /dev/null' \")\n            hive[hostname].force_password = True\n            hive[hostname].login(*hive_connect_info[hostname])\n            print(hive[hostname].before)\n            hive[hostname].logfile = fout\n            print('- OK')\n        except Exception as e:\n            print('- ERROR', end=' ')\n            print(str(e))\n            print('Skipping', hostname)\n            hive[hostname] = None\n    return host_names, hive\n\ndef main ():\n\n    global options, args, CMD_HELP\n\n    rows = 24\n    cols = 80\n\n    if options.sameuser:\n        cli_username = raw_input('username: ')\n    else:\n        cli_username = None\n\n    if options.samepass:\n        cli_password = getpass.getpass('password: ')\n    else:\n        cli_password = None\n\n    host_names, hive = login(args, cli_username, cli_password)\n\n    synchronous_mode = True\n    target_hostnames = host_names[:]\n    print('targeting hosts:', ' '.join(target_hostnames))\n    while True:\n        cmd = raw_input('CMD (? for help) > ')\n        cmd = cmd.strip()\n        if cmd=='?' or cmd==':help' or cmd==':h':\n            print(CMD_HELP)\n            continue\n        elif cmd==':refresh':\n            refresh (hive, target_hostnames, timeout=0.5)\n            for hostname in target_hostnames:\n                print('/' + '=' * (cols - 2))\n                print('| ' + hostname)\n                print('\\\\' + '-' * (cols - 2))\n                if hive[hostname] is None:\n                    print('# DEAD: %s' % hostname)\n                else:\n                    print(hive[hostname].before)\n            print('#' * 79)\n            continue\n        elif cmd==':resync':\n            resync (hive, target_hostnames, timeout=0.5)\n            for hostname in target_hostnames:\n                print('/' + '=' * (cols - 2))\n                print('| ' + hostname)\n                print('\\\\' + '-' * (cols - 2))\n                if hive[hostname] is None:\n                    print('# DEAD: %s' % hostname)\n                else:\n                    print(hive[hostname].before)\n            print('#' * 79)\n            continue\n        elif cmd==':sync':\n            synchronous_mode = True\n            resync (hive, target_hostnames, timeout=0.5)\n            continue\n        elif cmd==':async':\n            synchronous_mode = False\n            continue\n        elif cmd==':prompt':\n            for hostname in target_hostnames:\n                try:\n                    if hive[hostname] is not None:\n                        hive[hostname].set_unique_prompt()\n                except Exception as e:\n                    print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                    print(str(e))\n                    hive[hostname] = None\n            continue\n        elif cmd[:5] == ':send':\n            cmd, txt = cmd.split(None,1)\n            for hostname in target_hostnames:\n                try:\n                    if hive[hostname] is not None:\n                        hive[hostname].send(txt)\n                except Exception as e:\n                    print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                    print(str(e))\n                    hive[hostname] = None\n            continue\n        elif cmd[:3] == ':to':\n            cmd, hostname, txt = cmd.split(None,2)\n            print('/' + '=' * (cols - 2))\n            print('| ' + hostname)\n            print('\\\\' + '-' * (cols - 2))\n            if hive[hostname] is None:\n                print('# DEAD: %s' % hostname)\n                continue\n            try:\n                hive[hostname].sendline (txt)\n                hive[hostname].prompt(timeout=2)\n                print(hive[hostname].before)\n            except Exception as e:\n                print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                print(str(e))\n                hive[hostname] = None\n            continue\n        elif cmd[:7] == ':expect':\n            cmd, pattern = cmd.split(None,1)\n            print('looking for', pattern)\n            try:\n                for hostname in target_hostnames:\n                    if hive[hostname] is not None:\n                        hive[hostname].expect(pattern)\n                        print(hive[hostname].before)\n            except Exception as e:\n                print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                print(str(e))\n                hive[hostname] = None\n            continue\n        elif cmd[:7] == ':target':\n            target_hostnames = cmd.split()[1:]\n            if len(target_hostnames) == 0 or target_hostnames[0] == all:\n                target_hostnames = host_names[:]\n            print('targeting hosts:', ' '.join(target_hostnames))\n            continue\n        elif cmd == ':exit' or cmd == ':q' or cmd == ':quit':\n            break\n        elif cmd[:8] == ':control' or cmd[:5] == ':ctrl' :\n            cmd, c = cmd.split(None,1)\n            if ord(c)-96 < 0 or ord(c)-96 > 255:\n                print('/' + '=' * (cols - 2))\n                print('| Invalid character. Must be [a-zA-Z], @, [, ], \\\\, ^, _, or ?')\n                print('\\\\' + '-' * (cols - 2))\n                continue\n            for hostname in target_hostnames:\n                try:\n                    if hive[hostname] is not None:\n                        hive[hostname].sendcontrol(c)\n                except Exception as e:\n                    print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                    print(str(e))\n                    hive[hostname] = None\n            continue\n        elif cmd == ':esc':\n            for hostname in target_hostnames:\n                if hive[hostname] is not None:\n                    hive[hostname].send(chr(27))\n            continue\n        #\n        # Run the command on all targets in parallel\n        #\n        for hostname in target_hostnames:\n            try:\n                if hive[hostname] is not None:\n                    hive[hostname].sendline (cmd)\n            except Exception as e:\n                print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                print(str(e))\n                hive[hostname] = None\n\n        #\n        # print the response for each targeted host.\n        #\n        if synchronous_mode:\n            for hostname in target_hostnames:\n                try:\n                    print('/' + '=' * (cols - 2))\n                    print('| ' + hostname)\n                    print('\\\\' + '-' * (cols - 2))\n                    if hive[hostname] is None:\n                        print('# DEAD: %s' % hostname)\n                    else:\n                        hive[hostname].prompt(timeout=2)\n                        print(hive[hostname].before)\n                except Exception as e:\n                    print(\"Had trouble communicating with %s, so removing it from the target list.\" % hostname)\n                    print(str(e))\n                    hive[hostname] = None\n            print('#' * 79)\n\ndef refresh (hive, hive_names, timeout=0.5):\n\n    '''This waits for the TIMEOUT on each host.\n    '''\n\n    # TODO This is ideal for threading.\n    for hostname in hive_names:\n        if hive[hostname] is not None:\n            hive[hostname].expect([pexpect.TIMEOUT,pexpect.EOF],timeout=timeout)\n\ndef resync (hive, hive_names, timeout=2, max_attempts=5):\n\n    '''This waits for the shell prompt for each host in an effort to try to get\n    them all to the same state. The timeout is set low so that hosts that are\n    already at the prompt will not slow things down too much. If a prompt match\n    is made for a hosts then keep asking until it stops matching. This is a\n    best effort to consume all input if it printed more than one prompt. It's\n    kind of kludgy. Note that this will always introduce a delay equal to the\n    timeout for each machine. So for 10 machines with a 2 second delay you will\n    get AT LEAST a 20 second delay if not more. '''\n\n    # TODO This is ideal for threading.\n    for hostname in hive_names:\n        if hive[hostname] is not None:\n            for attempts in range(0, max_attempts):\n                if not hive[hostname].prompt(timeout=timeout):\n                    break\n\ndef parse_host_connect_string (hcs):\n\n    '''This parses a host connection string in the form\n    username:password@hostname:port. All fields are optional except hostname. A\n    dictionary is returned with all four keys. Keys that were not included are\n    set to empty strings ''. Note that if your password has the '@' character\n    then you must backslash escape it. '''\n\n    if '@' in hcs:\n        p = re.compile (r'(?P<username>[^@:]*)(:?)(?P<password>.*)(?!\\\\)@(?P<hostname>[^:]*):?(?P<port>[0-9]*)')\n    else:\n        p = re.compile (r'(?P<username>)(?P<password>)(?P<hostname>[^:]*):?(?P<port>[0-9]*)')\n    m = p.search (hcs)\n    d = m.groupdict()\n    d['password'] = d['password'].replace('\\\\@','@')\n    return d\n\nif __name__ == '__main__':\n    start_time = time.time()\n    parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='$Id: hive.py 533 2012-10-20 02:19:33Z noah $',conflict_handler=\"resolve\")\n    parser.add_option ('-v', '--verbose', action='store_true', default=False, help='verbose output')\n    parser.add_option ('--samepass', action='store_true', default=False, help='Use same password for each login.')\n    parser.add_option ('--sameuser', action='store_true', default=False, help='Use same username for each login.')\n    (options, args) = parser.parse_args()\n    if len(args) < 1:\n        parser.error ('missing argument')\n    if options.verbose: print(time.asctime())\n    main()\n    if options.verbose: print(time.asctime())\n    if options.verbose: print('TOTAL TIME IN MINUTES:', end=' ')\n    if options.verbose: print((time.time() - start_time) / 60.0)\n", "examples/chess.py": "#!/usr/bin/env python\n\n'''This demonstrates controlling a screen oriented application (curses).\nIt starts two instances of gnuchess and then pits them against each other.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\nfrom pexpect import ANSI\n\nREGEX_MOVE = r'(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)'\nREGEX_MOVE_PART = r'(?:[0-9]|\\x1b\\[C)(?:[a-z]|\\x1b\\[C)(?:[0-9]|\\x1b\\[C)'\n\nclass Chess:\n\n    def __init__(self, engine = \"/usr/local/bin/gnuchess -a -h 1\"):\n        self.child = pexpect.spawn (engine)\n        self.term = ANSI.ANSI ()\n\n        self.child.expect ('Chess')\n        if self.child.after != 'Chess':\n            raise IOError('incompatible chess program')\n        self.term.process_list (self.before)\n        self.term.process_list (self.after)\n        self.last_computer_move = ''\n\n    def read_until_cursor (self, r,c):\n        while 1:\n            self.child.read(1, 60)\n            self.term.process (c)\n            if self.term.cur_r == r and self.term.cur_c == c:\n                return 1\n\n    def do_first_move (self, move):\n        self.child.expect ('Your move is')\n        self.child.sendline (move)\n        self.term.process_list (self.before)\n        self.term.process_list (self.after)\n        return move\n\n    def do_move (self, move):\n        self.read_until_cursor (19,60)\n        self.child.sendline (move)\n        return move\n\n    def get_first_computer_move (self):\n        self.child.expect ('My move is')\n        self.child.expect (REGEX_MOVE)\n        return self.child.after\n\n    def get_computer_move (self):\n        print('Here')\n        i = self.child.expect ([r'\\[17;59H', r'\\[17;58H'])\n        print(i)\n        if i == 0:\n            self.child.expect (REGEX_MOVE)\n            if len(self.child.after) < 4:\n                self.child.after = self.child.after + self.last_computer_move[3]\n        if i == 1:\n            self.child.expect (REGEX_MOVE_PART)\n            self.child.after = self.last_computer_move[0] + self.child.after\n        print('', self.child.after)\n        self.last_computer_move = self.child.after\n        return self.child.after\n\n    def switch (self):\n        self.child.sendline ('switch')\n\n    def set_depth (self, depth):\n        self.child.sendline ('depth')\n        self.child.expect ('depth=')\n        self.child.sendline ('%d' % depth)\n\n    def quit(self):\n        self.child.sendline ('quit')\nimport sys\nprint('Starting...')\nwhite = Chess()\nwhite.child.echo = 1\nwhite.child.expect ('Your move is')\nwhite.set_depth(2)\nwhite.switch()\n\nmove_white = white.get_first_computer_move()\nprint('first move white:', move_white)\n\nwhite.do_move ('e7e5')\nmove_white = white.get_computer_move()\nprint('move white:', move_white)\nwhite.do_move ('f8c5')\nmove_white = white.get_computer_move()\nprint('move white:', move_white)\nwhite.do_move ('b8a6')\nmove_white = white.get_computer_move()\nprint('move white:', move_white)\n\nsys.exit(1)\n\n\n\nblack = Chess()\nwhite = Chess()\nwhite.child.expect ('Your move is')\nwhite.switch()\n\nmove_white = white.get_first_computer_move()\nprint('first move white:', move_white)\n\nblack.do_first_move (move_white)\nmove_black = black.get_first_computer_move()\nprint('first move black:', move_black)\n\nwhite.do_move (move_black)\n\ndone = 0\nwhile not done:\n    move_white = white.get_computer_move()\n    print('move white:', move_white)\n\n    black.do_move (move_white)\n    move_black = black.get_computer_move()\n    print('move black:', move_black)\n\n    white.do_move (move_black)\n    print('tail of loop')\n\ng.quit()\n", "examples/chess2.py": "#!/usr/bin/env python\n\n'''This demonstrates controlling a screen oriented application (curses).\nIt starts two instances of gnuchess and then pits them against each other.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport pexpect\nfrom pexpect import ANSI\nimport sys\nimport time\n\nclass Chess:\n\n        def __init__(self, engine = \"/usr/local/bin/gnuchess -a -h 1\"):\n                self.child = pexpect.spawn (engine)\n                self.term = ANSI.ANSI ()\n\n                #self.child.expect ('Chess')\n                #if self.child.after != 'Chess':\n                #        raise IOError, 'incompatible chess program'\n                #self.term.process_list (self.child.before)\n                #self.term.process_list (self.child.after)\n\n                self.last_computer_move = ''\n\n        def read_until_cursor (self, r,c, e=0):\n            '''Eventually something like this should move into the screen class or\n            a subclass. Maybe a combination of pexpect and screen...\n            '''\n            fout = open ('log','a')\n            while self.term.cur_r != r or self.term.cur_c != c:\n                try:\n                    k = self.child.read(1, 10)\n                except Exception as e:\n                    print('EXCEPTION, (r,c):(%d,%d)\\n' %(self.term.cur_r, self.term.cur_c))\n                    sys.stdout.flush()\n                self.term.process (k)\n                fout.write ('(r,c):(%d,%d)\\n' %(self.term.cur_r, self.term.cur_c))\n                fout.flush()\n                if e:\n                    sys.stdout.write (k)\n                    sys.stdout.flush()\n                if self.term.cur_r == r and self.term.cur_c == c:\n                    fout.close()\n                    return 1\n            print('DIDNT EVEN HIT.')\n            fout.close()\n            return 1\n\n        def expect_region (self):\n            '''This is another method that would be moved into the\n            screen class.\n            '''\n            pass\n        def do_scan (self):\n            fout = open ('log','a')\n            while 1:\n                c = self.child.read(1,10)\n                self.term.process (c)\n                fout.write ('(r,c):(%d,%d)\\n' %(self.term.cur_r, self.term.cur_c))\n                fout.flush()\n                sys.stdout.write (c)\n                sys.stdout.flush()\n\n        def do_move (self, move, e = 0):\n                time.sleep(1)\n                self.read_until_cursor (19,60, e)\n                self.child.sendline (move)\n\n        def wait (self, color):\n            while 1:\n                r = self.term.get_region (14,50,14,60)[0]\n                r = r.strip()\n                if r == color:\n                    return\n                time.sleep (1)\n\n        def parse_computer_move (self, s):\n                i = s.find ('is: ')\n                cm = s[i+3:i+9]\n                return cm\n        def get_computer_move (self, e = 0):\n                time.sleep(1)\n                self.read_until_cursor (19,60, e)\n                time.sleep(1)\n                r = self.term.get_region (17,50,17,62)[0]\n                cm = self.parse_computer_move (r)\n                return cm\n\n        def switch (self):\n                print('switching')\n                self.child.sendline ('switch')\n\n        def set_depth (self, depth):\n                self.child.sendline ('depth')\n                self.child.expect ('depth=')\n                self.child.sendline ('%d' % depth)\n\n        def quit(self):\n                self.child.sendline ('quit')\n\ndef LOG (s):\n    print(s)\n    sys.stdout.flush ()\n    fout = open ('moves.log', 'a')\n    fout.write (s + '\\n')\n    fout.close()\n\nprint('Starting...')\n\nblack = Chess()\nwhite = Chess()\nwhite.read_until_cursor (19,60,1)\nwhite.switch()\n\ndone = 0\nwhile not done:\n    white.wait ('Black')\n    move_white = white.get_computer_move(1)\n    LOG ( 'move white:'+ move_white )\n\n    black.do_move (move_white)\n    black.wait ('White')\n    move_black = black.get_computer_move()\n    LOG ( 'move black:'+ move_black )\n\n    white.do_move (move_black, 1)\n\ng.quit()\n\n\n", "examples/uptime.py": "#!/usr/bin/env python\n\n'''This displays uptime information using uptime. This is redundant,\nbut it demonstrates expecting for a regular expression that uses subgroups.\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport pexpect\nimport re\n\n# There are many different styles of uptime results. I try to parse them all. Yeee!\n# Examples from different machines:\n# [x86] Linux 2.4 (Redhat 7.3)\n#  2:06pm  up 63 days, 18 min,  3 users,  load average: 0.32, 0.08, 0.02\n# [x86] Linux 2.4.18-14 (Redhat 8.0)\n#  3:07pm  up 29 min,  1 user,  load average: 2.44, 2.51, 1.57\n# [PPC - G4] MacOS X 10.1 SERVER Edition\n# 2:11PM  up 3 days, 13:50, 3 users, load averages: 0.01, 0.00, 0.00\n# [powerpc] Darwin v1-58.corefa.com 8.2.0 Darwin Kernel Version 8.2.0\n# 10:35  up 18:06, 4 users, load averages: 0.52 0.47 0.36\n# [Sparc - R220] Sun Solaris (8)\n#  2:13pm  up 22 min(s),  1 user,  load average: 0.02, 0.01, 0.01\n# [x86] Linux 2.4.18-14 (Redhat 8)\n# 11:36pm  up 4 days, 17:58,  1 user,  load average: 0.03, 0.01, 0.00\n# AIX jwdir 2 5 0001DBFA4C00\n#  09:43AM   up  23:27,  1 user,  load average: 0.49, 0.32, 0.23\n# OpenBSD box3 2.9 GENERIC#653 i386\n#  6:08PM  up 4 days, 22:26, 1 user, load averages: 0.13, 0.09, 0.08\n\n# Note that, for Python 3 compatibility reasons, we are using spawnu and\n# importing unicode_literals (above). spawnu accepts Unicode input and\n# unicode_literals makes all string literals in this script Unicode by default.\np = pexpect.spawnu('uptime')\n\n# This parses uptime output into the major groups using regex group matching.\np.expect(r'up\\s+(.*?),\\s+([0-9]+) users?,\\s+load averages?: ([0-9]+\\.[0-9][0-9]),?\\s+([0-9]+\\.[0-9][0-9]),?\\s+([0-9]+\\.[0-9][0-9])')\nduration, users, av1, av5, av15 = p.match.groups()\n\n# The duration is a little harder to parse because of all the different\n# styles of uptime. I'm sure there is a way to do this all at once with\n# one single regex, but I bet it would be hard to read and maintain.\n# If anyone wants to send me a version using a single regex I'd be happy to see it.\ndays = '0'\nhours = '0'\nmins = '0'\nif 'day' in duration:\n    p.match = re.search(r'([0-9]+)\\s+day',duration)\n    days = str(int(p.match.group(1)))\nif ':' in duration:\n    p.match = re.search('([0-9]+):([0-9]+)',duration)\n    hours = str(int(p.match.group(1)))\n    mins = str(int(p.match.group(2)))\nif 'min' in duration:\n    p.match = re.search(r'([0-9]+)\\s+min',duration)\n    mins = str(int(p.match.group(1)))\n\n# Print the parsed fields in CSV format.\nprint('days, hours, minutes, users, cpu avg 1 min, cpu avg 5 min, cpu avg 15 min')\nprint('%s, %s, %s, %s, %s, %s, %s' % (days, hours, mins, users, av1, av5, av15))\n\n", "examples/script.py": "#!/usr/bin/env python\n\n'''This spawns a sub-shell (bash) and gives the user interactive control. The\nentire shell session is logged to a file called script.log. This behaves much\nlike the classic BSD command 'script'.\n\n./script.py [-a] [-c command] {logfilename}\n\n    logfilename : This is the name of the log file. Default is script.log.\n    -a : Append to log file. Default is to overwrite log file.\n    -c : spawn command. Default is to spawn the sh shell.\n\nExample:\n\n    This will start a bash shell and append to the log named my_session.log:\n\n        ./script.py -a -c bash my_session.log\n\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\n\nfrom __future__ import print_function\n\nfrom __future__ import absolute_import\n\nimport os, sys, time, getopt\nimport signal, fcntl, termios, struct\nimport pexpect\n\nglobal_pexpect_instance = None # Used by signal handler\n\ndef exit_with_usage():\n\n    print(globals()['__doc__'])\n    os._exit(1)\n\ndef main():\n\n    ######################################################################\n    # Parse the options, arguments, get ready, etc.\n    ######################################################################\n    try:\n        optlist, args = getopt.getopt(sys.argv[1:], 'h?ac:', ['help','h','?'])\n    except Exception as e:\n        print(str(e))\n        exit_with_usage()\n    options = dict(optlist)\n    if len(args) > 1:\n        exit_with_usage()\n\n    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:\n        print(\"Help:\")\n        exit_with_usage()\n\n    if len(args) == 1:\n        script_filename = args[0]\n    else:\n        script_filename = \"script.log\"\n    if '-a' in options:\n        fout = open(script_filename, \"ab\")\n    else:\n        fout = open(script_filename, \"wb\")\n    if '-c' in options:\n        command = options['-c']\n    else:\n        command = \"sh\"\n\n    # Begin log with date/time in the form CCCCyymm.hhmmss\n    fout.write ('# %4d%02d%02d.%02d%02d%02d \\n' % time.localtime()[:-3])\n\n    ######################################################################\n    # Start the interactive session\n    ######################################################################\n    p = pexpect.spawn(command)\n    p.logfile = fout\n    global global_pexpect_instance\n    global_pexpect_instance = p\n    signal.signal(signal.SIGWINCH, sigwinch_passthrough)\n\n    print(\"Script recording started. Type ^] (ASCII 29) to escape from the script shell.\")\n    p.interact(chr(29))\n    fout.close()\n    return 0\n\ndef sigwinch_passthrough (sig, data):\n\n    # Check for buggy platforms (see pexpect.setwinsize()).\n    if 'TIOCGWINSZ' in dir(termios):\n        TIOCGWINSZ = termios.TIOCGWINSZ\n    else:\n        TIOCGWINSZ = 1074295912 # assume\n    s = struct.pack (\"HHHH\", 0, 0, 0, 0)\n    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))\n    global global_pexpect_instance\n    global_pexpect_instance.setwinsize(a[0],a[1])\n\nif __name__ == \"__main__\":\n    main()\n"}