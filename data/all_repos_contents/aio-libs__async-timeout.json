{"setup.py": "from setuptools import setup\n\n\nsetup()\n", "async_timeout/__init__.py": "import asyncio\nimport enum\nimport sys\nimport warnings\nfrom types import TracebackType\nfrom typing import Optional, Type\n\n\nif sys.version_info >= (3, 8):\n    from typing import final\nelse:\n    from typing_extensions import final\n\n\nif sys.version_info >= (3, 11):\n\n    def _uncancel_task(task: \"asyncio.Task[object]\") -> None:\n        task.uncancel()\n\nelse:\n\n    def _uncancel_task(task: \"asyncio.Task[object]\") -> None:\n        pass\n\n\n__version__ = \"4.0.3\"\n\n\n__all__ = (\"timeout\", \"timeout_at\", \"Timeout\")\n\n\ndef timeout(delay: Optional[float]) -> \"Timeout\":\n    \"\"\"timeout context manager.\n\n    Useful in cases when you want to apply timeout logic around block\n    of code or in cases when asyncio.wait_for is not suitable. For example:\n\n    >>> async with timeout(0.001):\n    ...     async with aiohttp.get('https://github.com') as r:\n    ...         await r.text()\n\n\n    delay - value in seconds or None to disable timeout logic\n    \"\"\"\n    loop = asyncio.get_running_loop()\n    if delay is not None:\n        deadline = loop.time() + delay  # type: Optional[float]\n    else:\n        deadline = None\n    return Timeout(deadline, loop)\n\n\ndef timeout_at(deadline: Optional[float]) -> \"Timeout\":\n    \"\"\"Schedule the timeout at absolute time.\n\n    deadline argument points on the time in the same clock system\n    as loop.time().\n\n    Please note: it is not POSIX time but a time with\n    undefined starting base, e.g. the time of the system power on.\n\n    >>> async with timeout_at(loop.time() + 10):\n    ...     async with aiohttp.get('https://github.com') as r:\n    ...         await r.text()\n\n\n    \"\"\"\n    loop = asyncio.get_running_loop()\n    return Timeout(deadline, loop)\n\n\nclass _State(enum.Enum):\n    INIT = \"INIT\"\n    ENTER = \"ENTER\"\n    TIMEOUT = \"TIMEOUT\"\n    EXIT = \"EXIT\"\n\n\n@final\nclass Timeout:\n    # Internal class, please don't instantiate it directly\n    # Use timeout() and timeout_at() public factories instead.\n    #\n    # Implementation note: `async with timeout()` is preferred\n    # over `with timeout()`.\n    # While technically the Timeout class implementation\n    # doesn't need to be async at all,\n    # the `async with` statement explicitly points that\n    # the context manager should be used from async function context.\n    #\n    # This design allows to avoid many silly misusages.\n    #\n    # TimeoutError is raised immediately when scheduled\n    # if the deadline is passed.\n    # The purpose is to time out as soon as possible\n    # without waiting for the next await expression.\n\n    __slots__ = (\"_deadline\", \"_loop\", \"_state\", \"_timeout_handler\", \"_task\")\n\n    def __init__(\n        self, deadline: Optional[float], loop: asyncio.AbstractEventLoop\n    ) -> None:\n        self._loop = loop\n        self._state = _State.INIT\n\n        self._task: Optional[\"asyncio.Task[object]\"] = None\n        self._timeout_handler = None  # type: Optional[asyncio.Handle]\n        if deadline is None:\n            self._deadline = None  # type: Optional[float]\n        else:\n            self.update(deadline)\n\n    def __enter__(self) -> \"Timeout\":\n        warnings.warn(\n            \"with timeout() is deprecated, use async with timeout() instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self._do_enter()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        self._do_exit(exc_type)\n        return None\n\n    async def __aenter__(self) -> \"Timeout\":\n        self._do_enter()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        self._do_exit(exc_type)\n        return None\n\n    @property\n    def expired(self) -> bool:\n        \"\"\"Is timeout expired during execution?\"\"\"\n        return self._state == _State.TIMEOUT\n\n    @property\n    def deadline(self) -> Optional[float]:\n        return self._deadline\n\n    def reject(self) -> None:\n        \"\"\"Reject scheduled timeout if any.\"\"\"\n        # cancel is maybe better name but\n        # task.cancel() raises CancelledError in asyncio world.\n        if self._state not in (_State.INIT, _State.ENTER):\n            raise RuntimeError(f\"invalid state {self._state.value}\")\n        self._reject()\n\n    def _reject(self) -> None:\n        self._task = None\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n\n    def shift(self, delay: float) -> None:\n        \"\"\"Advance timeout on delay seconds.\n\n        The delay can be negative.\n\n        Raise RuntimeError if shift is called when deadline is not scheduled\n        \"\"\"\n        deadline = self._deadline\n        if deadline is None:\n            raise RuntimeError(\"cannot shift timeout if deadline is not scheduled\")\n        self.update(deadline + delay)\n\n    def update(self, deadline: float) -> None:\n        \"\"\"Set deadline to absolute value.\n\n        deadline argument points on the time in the same clock system\n        as loop.time().\n\n        If new deadline is in the past the timeout is raised immediately.\n\n        Please note: it is not POSIX time but a time with\n        undefined starting base, e.g. the time of the system power on.\n        \"\"\"\n        if self._state == _State.EXIT:\n            raise RuntimeError(\"cannot reschedule after exit from context manager\")\n        if self._state == _State.TIMEOUT:\n            raise RuntimeError(\"cannot reschedule expired timeout\")\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n        self._deadline = deadline\n        if self._state != _State.INIT:\n            self._reschedule()\n\n    def _reschedule(self) -> None:\n        assert self._state == _State.ENTER\n        deadline = self._deadline\n        if deadline is None:\n            return\n\n        now = self._loop.time()\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n\n        self._task = asyncio.current_task()\n        if deadline <= now:\n            self._timeout_handler = self._loop.call_soon(self._on_timeout)\n        else:\n            self._timeout_handler = self._loop.call_at(deadline, self._on_timeout)\n\n    def _do_enter(self) -> None:\n        if self._state != _State.INIT:\n            raise RuntimeError(f\"invalid state {self._state.value}\")\n        self._state = _State.ENTER\n        self._reschedule()\n\n    def _do_exit(self, exc_type: Optional[Type[BaseException]]) -> None:\n        if exc_type is asyncio.CancelledError and self._state == _State.TIMEOUT:\n            assert self._task is not None\n            _uncancel_task(self._task)\n            self._timeout_handler = None\n            self._task = None\n            raise asyncio.TimeoutError\n        # timeout has not expired\n        self._state = _State.EXIT\n        self._reject()\n        return None\n\n    def _on_timeout(self) -> None:\n        assert self._task is not None\n        self._task.cancel()\n        self._state = _State.TIMEOUT\n        # drop the reference early\n        self._timeout_handler = None\n"}