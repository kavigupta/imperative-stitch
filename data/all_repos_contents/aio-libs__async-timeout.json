{"setup.py": "from setuptools import setup\n\n\nsetup()\n", "async_timeout/__init__.py": "import asyncio\nimport enum\nimport sys\nimport warnings\nfrom types import TracebackType\nfrom typing import Optional, Type\n\n\nif sys.version_info >= (3, 8):\n    from typing import final\nelse:\n    from typing_extensions import final\n\n\nif sys.version_info >= (3, 11):\n\n    def _uncancel_task(task: \"asyncio.Task[object]\") -> None:\n        task.uncancel()\n\nelse:\n\n    def _uncancel_task(task: \"asyncio.Task[object]\") -> None:\n        pass\n\n\n__version__ = \"4.0.3\"\n\n\n__all__ = (\"timeout\", \"timeout_at\", \"Timeout\")\n\n\ndef timeout(delay: Optional[float]) -> \"Timeout\":\n    \"\"\"timeout context manager.\n\n    Useful in cases when you want to apply timeout logic around block\n    of code or in cases when asyncio.wait_for is not suitable. For example:\n\n    >>> async with timeout(0.001):\n    ...     async with aiohttp.get('https://github.com') as r:\n    ...         await r.text()\n\n\n    delay - value in seconds or None to disable timeout logic\n    \"\"\"\n    loop = asyncio.get_running_loop()\n    if delay is not None:\n        deadline = loop.time() + delay  # type: Optional[float]\n    else:\n        deadline = None\n    return Timeout(deadline, loop)\n\n\ndef timeout_at(deadline: Optional[float]) -> \"Timeout\":\n    \"\"\"Schedule the timeout at absolute time.\n\n    deadline argument points on the time in the same clock system\n    as loop.time().\n\n    Please note: it is not POSIX time but a time with\n    undefined starting base, e.g. the time of the system power on.\n\n    >>> async with timeout_at(loop.time() + 10):\n    ...     async with aiohttp.get('https://github.com') as r:\n    ...         await r.text()\n\n\n    \"\"\"\n    loop = asyncio.get_running_loop()\n    return Timeout(deadline, loop)\n\n\nclass _State(enum.Enum):\n    INIT = \"INIT\"\n    ENTER = \"ENTER\"\n    TIMEOUT = \"TIMEOUT\"\n    EXIT = \"EXIT\"\n\n\n@final\nclass Timeout:\n    # Internal class, please don't instantiate it directly\n    # Use timeout() and timeout_at() public factories instead.\n    #\n    # Implementation note: `async with timeout()` is preferred\n    # over `with timeout()`.\n    # While technically the Timeout class implementation\n    # doesn't need to be async at all,\n    # the `async with` statement explicitly points that\n    # the context manager should be used from async function context.\n    #\n    # This design allows to avoid many silly misusages.\n    #\n    # TimeoutError is raised immediately when scheduled\n    # if the deadline is passed.\n    # The purpose is to time out as soon as possible\n    # without waiting for the next await expression.\n\n    __slots__ = (\"_deadline\", \"_loop\", \"_state\", \"_timeout_handler\", \"_task\")\n\n    def __init__(\n        self, deadline: Optional[float], loop: asyncio.AbstractEventLoop\n    ) -> None:\n        self._loop = loop\n        self._state = _State.INIT\n\n        self._task: Optional[\"asyncio.Task[object]\"] = None\n        self._timeout_handler = None  # type: Optional[asyncio.Handle]\n        if deadline is None:\n            self._deadline = None  # type: Optional[float]\n        else:\n            self.update(deadline)\n\n    def __enter__(self) -> \"Timeout\":\n        warnings.warn(\n            \"with timeout() is deprecated, use async with timeout() instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self._do_enter()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        self._do_exit(exc_type)\n        return None\n\n    async def __aenter__(self) -> \"Timeout\":\n        self._do_enter()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        self._do_exit(exc_type)\n        return None\n\n    @property\n    def expired(self) -> bool:\n        \"\"\"Is timeout expired during execution?\"\"\"\n        return self._state == _State.TIMEOUT\n\n    @property\n    def deadline(self) -> Optional[float]:\n        return self._deadline\n\n    def reject(self) -> None:\n        \"\"\"Reject scheduled timeout if any.\"\"\"\n        # cancel is maybe better name but\n        # task.cancel() raises CancelledError in asyncio world.\n        if self._state not in (_State.INIT, _State.ENTER):\n            raise RuntimeError(f\"invalid state {self._state.value}\")\n        self._reject()\n\n    def _reject(self) -> None:\n        self._task = None\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n\n    def shift(self, delay: float) -> None:\n        \"\"\"Advance timeout on delay seconds.\n\n        The delay can be negative.\n\n        Raise RuntimeError if shift is called when deadline is not scheduled\n        \"\"\"\n        deadline = self._deadline\n        if deadline is None:\n            raise RuntimeError(\"cannot shift timeout if deadline is not scheduled\")\n        self.update(deadline + delay)\n\n    def update(self, deadline: float) -> None:\n        \"\"\"Set deadline to absolute value.\n\n        deadline argument points on the time in the same clock system\n        as loop.time().\n\n        If new deadline is in the past the timeout is raised immediately.\n\n        Please note: it is not POSIX time but a time with\n        undefined starting base, e.g. the time of the system power on.\n        \"\"\"\n        if self._state == _State.EXIT:\n            raise RuntimeError(\"cannot reschedule after exit from context manager\")\n        if self._state == _State.TIMEOUT:\n            raise RuntimeError(\"cannot reschedule expired timeout\")\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n        self._deadline = deadline\n        if self._state != _State.INIT:\n            self._reschedule()\n\n    def _reschedule(self) -> None:\n        assert self._state == _State.ENTER\n        deadline = self._deadline\n        if deadline is None:\n            return\n\n        now = self._loop.time()\n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n\n        self._task = asyncio.current_task()\n        if deadline <= now:\n            self._timeout_handler = self._loop.call_soon(self._on_timeout)\n        else:\n            self._timeout_handler = self._loop.call_at(deadline, self._on_timeout)\n\n    def _do_enter(self) -> None:\n        if self._state != _State.INIT:\n            raise RuntimeError(f\"invalid state {self._state.value}\")\n        self._state = _State.ENTER\n        self._reschedule()\n\n    def _do_exit(self, exc_type: Optional[Type[BaseException]]) -> None:\n        if exc_type is asyncio.CancelledError and self._state == _State.TIMEOUT:\n            assert self._task is not None\n            _uncancel_task(self._task)\n            self._timeout_handler = None\n            self._task = None\n            raise asyncio.TimeoutError\n        # timeout has not expired\n        self._state = _State.EXIT\n        self._reject()\n        return None\n\n    def _on_timeout(self) -> None:\n        assert self._task is not None\n        self._task.cancel()\n        self._state = _State.TIMEOUT\n        # drop the reference early\n        self._timeout_handler = None\n", "tests/test_timeout.py": "import asyncio\nimport sys\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, List, TypeVar\n\nimport pytest\n\nfrom async_timeout import timeout, timeout_at\n\n\n_Func = TypeVar(\"_Func\", bound=Callable[..., Any])\n\n\ndef log_func(func: _Func, msg: str, call_order: List[str]) -> _Func:\n    \"\"\"Simple wrapper to add a log to call_order when the function is called.\"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:  # type: ignore[misc]\n        call_order.append(msg)\n        return func(*args, **kwargs)\n\n    return wrapper  # type: ignore[return-value]\n\n\n@pytest.mark.asyncio\nasync def test_timeout() -> None:\n    canceled_raised = False\n\n    async def long_running_task() -> None:\n        try:\n            await asyncio.sleep(10)\n        except asyncio.CancelledError:\n            nonlocal canceled_raised\n            canceled_raised = True\n            raise\n\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.01) as t:\n            await long_running_task()\n            assert t._loop is asyncio.get_event_loop()\n    assert canceled_raised, \"CancelledError was not raised\"\n    if sys.version_info >= (3, 11):\n        task = asyncio.current_task()\n        assert task is not None\n        assert not task.cancelling()\n\n\n@pytest.mark.asyncio\nasync def test_timeout_finish_in_time() -> None:\n    async def long_running_task() -> str:\n        await asyncio.sleep(0.01)\n        return \"done\"\n\n    # timeout should be long enough to work even on slow bisy test boxes\n    async with timeout(0.5):\n        resp = await long_running_task()\n    assert resp == \"done\"\n\n\n@pytest.mark.asyncio\nasync def test_timeout_disable() -> None:\n    async def long_running_task() -> str:\n        await asyncio.sleep(0.1)\n        return \"done\"\n\n    loop = asyncio.get_event_loop()\n    t0 = loop.time()\n    async with timeout(None):\n        resp = await long_running_task()\n    assert resp == \"done\"\n    dt = loop.time() - t0\n    assert 0.09 < dt < 0.3, dt\n\n\n@pytest.mark.asyncio\nasync def test_timeout_is_none_no_schedule() -> None:\n    async with timeout(None) as cm:\n        assert cm._timeout_handler is None\n        assert cm.deadline is None\n\n\ndef test_timeout_no_loop() -> None:\n    with pytest.raises(RuntimeError, match=\"no running event loop\"):\n        timeout(None)\n\n\n@pytest.mark.asyncio\nasync def test_timeout_zero() -> None:\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0):\n            await asyncio.sleep(10)\n\n\n@pytest.mark.asyncio\nasync def test_timeout_not_relevant_exception() -> None:\n    await asyncio.sleep(0)\n    with pytest.raises(KeyError):\n        async with timeout(0.1):\n            raise KeyError\n\n\n@pytest.mark.asyncio\nasync def test_timeout_canceled_error_is_not_converted_to_timeout() -> None:\n    await asyncio.sleep(0)\n    with pytest.raises(asyncio.CancelledError):\n        async with timeout(0.001):\n            raise asyncio.CancelledError\n\n\n@pytest.mark.asyncio\nasync def test_timeout_blocking_loop() -> None:\n    async def long_running_task() -> str:\n        time.sleep(0.1)\n        return \"done\"\n\n    async with timeout(0.01):\n        result = await long_running_task()\n    assert result == \"done\"\n\n\n@pytest.mark.asyncio\nasync def test_for_race_conditions() -> None:\n    loop = asyncio.get_event_loop()\n    fut = loop.create_future()\n    loop.call_later(0.1, fut.set_result, \"done\")\n    async with timeout(0.5):\n        resp = await fut\n    assert resp == \"done\"\n\n\n@pytest.mark.asyncio\nasync def test_timeout_time() -> None:\n    foo_running = None\n    loop = asyncio.get_event_loop()\n    start = loop.time()\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.1):\n            foo_running = True\n            try:\n                await asyncio.sleep(0.2)\n            finally:\n                foo_running = False\n\n    dt = loop.time() - start\n    assert 0.09 < dt < 0.3\n    assert not foo_running\n\n\n@pytest.mark.asyncio\nasync def test_outer_coro_is_not_cancelled() -> None:\n    has_timeout = False\n\n    async def outer() -> None:\n        nonlocal has_timeout\n        try:\n            async with timeout(0.001):\n                await asyncio.sleep(1)\n        except asyncio.TimeoutError:\n            has_timeout = True\n\n    task = asyncio.ensure_future(outer())\n    await task\n    assert has_timeout\n    assert not task.cancelled()\n    if sys.version_info >= (3, 11):\n        assert not task.cancelling()\n    assert task.done()\n\n\n@pytest.mark.asyncio\nasync def test_cancel_outer_coro() -> None:\n    loop = asyncio.get_event_loop()\n    fut = loop.create_future()\n\n    async def outer() -> None:\n        fut.set_result(None)\n        await asyncio.sleep(1)\n\n    task = asyncio.ensure_future(outer())\n    await fut\n    task.cancel()\n    with pytest.raises(asyncio.CancelledError):\n        await task\n    assert task.cancelled()\n    assert task.done()\n\n\n@pytest.mark.asyncio\nasync def test_timeout_suppress_exception_chain() -> None:\n    with pytest.raises(asyncio.TimeoutError) as ctx:\n        async with timeout(0.01):\n            await asyncio.sleep(10)\n    assert not ctx.value.__suppress_context__\n\n\n@pytest.mark.asyncio\nasync def test_timeout_expired() -> None:\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.01) as cm:\n            await asyncio.sleep(10)\n    assert cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_timeout_inner_timeout_error() -> None:\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.01) as cm:\n            raise asyncio.TimeoutError\n    assert not cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_timeout_inner_other_error() -> None:\n    class MyError(RuntimeError):\n        pass\n\n    with pytest.raises(MyError):\n        async with timeout(0.01) as cm:\n            raise MyError\n    assert not cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_timeout_at() -> None:\n    loop = asyncio.get_event_loop()\n    with pytest.raises(asyncio.TimeoutError):\n        now = loop.time()\n        async with timeout_at(now + 0.01) as cm:\n            await asyncio.sleep(10)\n    assert cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_timeout_at_not_fired() -> None:\n    loop = asyncio.get_event_loop()\n    now = loop.time()\n    async with timeout_at(now + 1) as cm:\n        await asyncio.sleep(0)\n    assert not cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_expired_after_rejecting() -> None:\n    t = timeout(10)\n    assert not t.expired\n    t.reject()\n    assert not t.expired\n\n\n@pytest.mark.asyncio\nasync def test_reject_finished() -> None:\n    async with timeout(10) as t:\n        await asyncio.sleep(0)\n\n    assert not t.expired\n    with pytest.raises(RuntimeError, match=\"invalid state EXIT\"):\n        t.reject()\n\n\n@pytest.mark.asyncio\nasync def test_expired_after_timeout() -> None:\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.01) as t:\n            assert not t.expired\n            await asyncio.sleep(10)\n    assert t.expired\n\n\n@pytest.mark.asyncio\nasync def test_deadline() -> None:\n    loop = asyncio.get_event_loop()\n    t0 = loop.time()\n    async with timeout(1) as cm:\n        t1 = loop.time()\n        assert cm.deadline is not None\n        assert t0 + 1 <= cm.deadline <= t1 + 1\n\n\n@pytest.mark.asyncio\nasync def test_async_timeout() -> None:\n    with pytest.raises(asyncio.TimeoutError):\n        async with timeout(0.01) as cm:\n            await asyncio.sleep(10)\n    assert cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_async_no_timeout() -> None:\n    async with timeout(1) as cm:\n        await asyncio.sleep(0)\n    assert not cm.expired\n\n\n@pytest.mark.asyncio\nasync def test_shift() -> None:\n    loop = asyncio.get_event_loop()\n    t0 = loop.time()\n    async with timeout(1) as cm:\n        t1 = loop.time()\n        assert cm.deadline is not None\n        assert t0 + 1 <= cm.deadline <= t1 + 1\n        cm.shift(1)\n        assert t0 + 2 <= cm.deadline <= t0 + 2.1\n\n\n@pytest.mark.asyncio\nasync def test_shift_nonscheduled() -> None:\n    async with timeout(None) as cm:\n        with pytest.raises(\n            RuntimeError,\n            match=\"cannot shift timeout if deadline is not scheduled\",\n        ):\n            cm.shift(1)\n\n\n@pytest.mark.asyncio\nasync def test_shift_negative_expired() -> None:\n    async with timeout(1) as cm:\n        with pytest.raises(asyncio.CancelledError):\n            cm.shift(-1)\n            await asyncio.sleep(10)\n\n\n@pytest.mark.asyncio\nasync def test_shift_by_expired() -> None:\n    async with timeout(0.001) as cm:\n        with pytest.raises(asyncio.CancelledError):\n            await asyncio.sleep(10)\n        with pytest.raises(RuntimeError, match=\"cannot reschedule expired timeout\"):\n            cm.shift(10)\n\n\n@pytest.mark.asyncio\nasync def test_shift_to_expired() -> None:\n    loop = asyncio.get_event_loop()\n    t0 = loop.time()\n    async with timeout_at(t0 + 0.001) as cm:\n        with pytest.raises(asyncio.CancelledError):\n            await asyncio.sleep(10)\n        with pytest.raises(RuntimeError, match=\"cannot reschedule expired timeout\"):\n            cm.update(t0 + 10)\n\n\n@pytest.mark.asyncio\nasync def test_shift_by_after_cm_exit() -> None:\n    async with timeout(1) as cm:\n        await asyncio.sleep(0)\n    with pytest.raises(\n        RuntimeError, match=\"cannot reschedule after exit from context manager\"\n    ):\n        cm.shift(1)\n\n\n@pytest.mark.asyncio\nasync def test_enter_twice() -> None:\n    async with timeout(10) as t:\n        await asyncio.sleep(0)\n\n    with pytest.raises(RuntimeError, match=\"invalid state EXIT\"):\n        async with t:\n            await asyncio.sleep(0)\n\n\n@pytest.mark.asyncio\nasync def test_deprecated_with() -> None:\n    with pytest.warns(DeprecationWarning):\n        with timeout(1):\n            await asyncio.sleep(0)\n"}