{"hubconf.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nPyTorch Hub models https://pytorch.org/hub/ultralytics_yolov5\n\nUsage:\n    import torch\n    model = torch.hub.load('ultralytics/yolov5', 'yolov5s')  # official model\n    model = torch.hub.load('ultralytics/yolov5:master', 'yolov5s')  # from branch\n    model = torch.hub.load('ultralytics/yolov5', 'custom', 'yolov5s.pt')  # custom/local model\n    model = torch.hub.load('.', 'custom', 'yolov5s.pt', source='local')  # local repo\n\"\"\"\n\nimport torch\n\n\ndef _create(name, pretrained=True, channels=3, classes=80, autoshape=True, verbose=True, device=None):\n    \"\"\"\n    Creates or loads a YOLOv5 model.\n\n    Arguments:\n        name (str): model name 'yolov5s' or path 'path/to/best.pt'\n        pretrained (bool): load pretrained weights into the model\n        channels (int): number of input channels\n        classes (int): number of model classes\n        autoshape (bool): apply YOLOv5 .autoshape() wrapper to model\n        verbose (bool): print all information to screen\n        device (str, torch.device, None): device to use for model parameters\n\n    Returns:\n        YOLOv5 model\n    \"\"\"\n    from pathlib import Path\n\n    from models.common import AutoShape, DetectMultiBackend\n    from models.experimental import attempt_load\n    from models.yolo import ClassificationModel, DetectionModel, SegmentationModel\n    from utils.downloads import attempt_download\n    from utils.general import LOGGER, ROOT, check_requirements, intersect_dicts, logging\n    from utils.torch_utils import select_device\n\n    if not verbose:\n        LOGGER.setLevel(logging.WARNING)\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"opencv-python\", \"tensorboard\", \"thop\"))\n    name = Path(name)\n    path = name.with_suffix(\".pt\") if name.suffix == \"\" and not name.is_dir() else name  # checkpoint path\n    try:\n        device = select_device(device)\n        if pretrained and channels == 3 and classes == 80:\n            try:\n                model = DetectMultiBackend(path, device=device, fuse=autoshape)  # detection model\n                if autoshape:\n                    if model.pt and isinstance(model.model, ClassificationModel):\n                        LOGGER.warning(\n                            \"WARNING \u26a0\ufe0f YOLOv5 ClassificationModel is not yet AutoShape compatible. \"\n                            \"You must pass torch tensors in BCHW to this model, i.e. shape(1,3,224,224).\"\n                        )\n                    elif model.pt and isinstance(model.model, SegmentationModel):\n                        LOGGER.warning(\n                            \"WARNING \u26a0\ufe0f YOLOv5 SegmentationModel is not yet AutoShape compatible. \"\n                            \"You will not be able to run inference with this model.\"\n                        )\n                    else:\n                        model = AutoShape(model)  # for file/URI/PIL/cv2/np inputs and NMS\n            except Exception:\n                model = attempt_load(path, device=device, fuse=False)  # arbitrary model\n        else:\n            cfg = list((Path(__file__).parent / \"models\").rglob(f\"{path.stem}.yaml\"))[0]  # model.yaml path\n            model = DetectionModel(cfg, channels, classes)  # create model\n            if pretrained:\n                ckpt = torch.load(attempt_download(path), map_location=device)  # load\n                csd = ckpt[\"model\"].float().state_dict()  # checkpoint state_dict as FP32\n                csd = intersect_dicts(csd, model.state_dict(), exclude=[\"anchors\"])  # intersect\n                model.load_state_dict(csd, strict=False)  # load\n                if len(ckpt[\"model\"].names) == classes:\n                    model.names = ckpt[\"model\"].names  # set class names attribute\n        if not verbose:\n            LOGGER.setLevel(logging.INFO)  # reset to default\n        return model.to(device)\n\n    except Exception as e:\n        help_url = \"https://docs.ultralytics.com/yolov5/tutorials/pytorch_hub_model_loading\"\n        s = f\"{e}. Cache may be out of date, try `force_reload=True` or see {help_url} for help.\"\n        raise Exception(s) from e\n\n\ndef custom(path=\"path/to/model.pt\", autoshape=True, _verbose=True, device=None):\n    \"\"\"Loads a custom or local YOLOv5 model from a given path with optional autoshaping and device specification.\"\"\"\n    return _create(path, autoshape=autoshape, verbose=_verbose, device=device)\n\n\ndef yolov5n(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Instantiates the YOLOv5-nano model with options for pretraining, input channels, class count, autoshaping,\n    verbosity, and device.\n    \"\"\"\n    return _create(\"yolov5n\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5s(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Creates YOLOv5-small model with options for pretraining, input channels, class count, autoshaping, verbosity, and\n    device.\n    \"\"\"\n    return _create(\"yolov5s\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5m(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Instantiates the YOLOv5-medium model with customizable pretraining, channel count, class count, autoshaping,\n    verbosity, and device.\n    \"\"\"\n    return _create(\"yolov5m\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5l(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Creates YOLOv5-large model with options for pretraining, channels, classes, autoshaping, verbosity, and device\n    selection.\n    \"\"\"\n    return _create(\"yolov5l\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5x(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Instantiates the YOLOv5-xlarge model with customizable pretraining, channel count, class count, autoshaping,\n    verbosity, and device.\n    \"\"\"\n    return _create(\"yolov5x\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5n6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Creates YOLOv5-nano-P6 model with options for pretraining, channels, classes, autoshaping, verbosity, and\n    device.\n    \"\"\"\n    return _create(\"yolov5n6\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5s6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Instantiate YOLOv5-small-P6 model with options for pretraining, input channels, number of classes, autoshaping,\n    verbosity, and device selection.\n    \"\"\"\n    return _create(\"yolov5s6\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5m6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Creates YOLOv5-medium-P6 model with options for pretraining, channel count, class count, autoshaping, verbosity,\n    and device.\n    \"\"\"\n    return _create(\"yolov5m6\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5l6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Instantiates the YOLOv5-large-P6 model with customizable pretraining, channel and class counts, autoshaping,\n    verbosity, and device selection.\n    \"\"\"\n    return _create(\"yolov5l6\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\ndef yolov5x6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    \"\"\"Creates YOLOv5-xlarge-P6 model with options for pretraining, channels, classes, autoshaping, verbosity, and\n    device.\n    \"\"\"\n    return _create(\"yolov5x6\", pretrained, channels, classes, autoshape, _verbose, device)\n\n\nif __name__ == \"__main__\":\n    import argparse\n    from pathlib import Path\n\n    import numpy as np\n    from PIL import Image\n\n    from utils.general import cv2, print_args\n\n    # Argparser\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model\", type=str, default=\"yolov5s\", help=\"model name\")\n    opt = parser.parse_args()\n    print_args(vars(opt))\n\n    # Model\n    model = _create(name=opt.model, pretrained=True, channels=3, classes=80, autoshape=True, verbose=True)\n    # model = custom(path='path/to/model.pt')  # custom\n\n    # Images\n    imgs = [\n        \"data/images/zidane.jpg\",  # filename\n        Path(\"data/images/zidane.jpg\"),  # Path\n        \"https://ultralytics.com/images/zidane.jpg\",  # URI\n        cv2.imread(\"data/images/bus.jpg\")[:, :, ::-1],  # OpenCV\n        Image.open(\"data/images/bus.jpg\"),  # PIL\n        np.zeros((320, 640, 3)),\n    ]  # numpy\n\n    # Inference\n    results = model(imgs, size=320)  # batched inference\n\n    # Results\n    results.print()\n    results.save()\n", "val.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nValidate a trained YOLOv5 detection model on a detection dataset.\n\nUsage:\n    $ python val.py --weights yolov5s.pt --data coco128.yaml --img 640\n\nUsage - formats:\n    $ python val.py --weights yolov5s.pt                 # PyTorch\n                              yolov5s.torchscript        # TorchScript\n                              yolov5s.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                              yolov5s_openvino_model     # OpenVINO\n                              yolov5s.engine             # TensorRT\n                              yolov5s.mlmodel            # CoreML (macOS-only)\n                              yolov5s_saved_model        # TensorFlow SavedModel\n                              yolov5s.pb                 # TensorFlow GraphDef\n                              yolov5s.tflite             # TensorFlow Lite\n                              yolov5s_edgetpu.tflite     # TensorFlow Edge TPU\n                              yolov5s_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[0]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom models.common import DetectMultiBackend\nfrom utils.callbacks import Callbacks\nfrom utils.dataloaders import create_dataloader\nfrom utils.general import (\n    LOGGER,\n    TQDM_BAR_FORMAT,\n    Profile,\n    check_dataset,\n    check_img_size,\n    check_requirements,\n    check_yaml,\n    coco80_to_coco91_class,\n    colorstr,\n    increment_path,\n    non_max_suppression,\n    print_args,\n    scale_boxes,\n    xywh2xyxy,\n    xyxy2xywh,\n)\nfrom utils.metrics import ConfusionMatrix, ap_per_class, box_iou\nfrom utils.plots import output_to_target, plot_images, plot_val_study\nfrom utils.torch_utils import select_device, smart_inference_mode\n\n\ndef save_one_txt(predn, save_conf, shape, file):\n    \"\"\"Saves one detection result to a txt file in normalized xywh format, optionally including confidence.\"\"\"\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls in predn.tolist():\n        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n        with open(file, \"a\") as f:\n            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n\ndef save_one_json(predn, jdict, path, class_map):\n    \"\"\"\n    Saves one JSON detection result with image ID, category ID, bounding box, and score.\n\n    Example: {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n    \"\"\"\n    image_id = int(path.stem) if path.stem.isnumeric() else path.stem\n    box = xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    for p, b in zip(predn.tolist(), box.tolist()):\n        jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": class_map[int(p[5])],\n                \"bbox\": [round(x, 3) for x in b],\n                \"score\": round(p[4], 5),\n            }\n        )\n\n\ndef process_batch(detections, labels, iouv):\n    \"\"\"\n    Return correct prediction matrix.\n\n    Arguments:\n        detections (array[N, 6]), x1, y1, x2, y2, conf, class\n        labels (array[M, 5]), class, x1, y1, x2, y2\n    Returns:\n        correct (array[N, 10]), for 10 IoU levels\n    \"\"\"\n    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)\n    iou = box_iou(labels[:, 1:], detections[:, :4])\n    correct_class = labels[:, 0:1] == detections[:, 5]\n    for i in range(len(iouv)):\n        x = torch.where((iou >= iouv[i]) & correct_class)  # IoU > threshold and classes match\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()  # [label, detect, iou]\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                # matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n            correct[matches[:, 1].astype(int), i] = True\n    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)\n\n\n@smart_inference_mode()\ndef run(\n    data,\n    weights=None,  # model.pt path(s)\n    batch_size=32,  # batch size\n    imgsz=640,  # inference size (pixels)\n    conf_thres=0.001,  # confidence threshold\n    iou_thres=0.6,  # NMS IoU threshold\n    max_det=300,  # maximum detections per image\n    task=\"val\",  # train, val, test, speed or study\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    workers=8,  # max dataloader workers (per RANK in DDP mode)\n    single_cls=False,  # treat as single-class dataset\n    augment=False,  # augmented inference\n    verbose=False,  # verbose output\n    save_txt=False,  # save results to *.txt\n    save_hybrid=False,  # save label+prediction hybrid results to *.txt\n    save_conf=False,  # save confidences in --save-txt labels\n    save_json=False,  # save a COCO-JSON results file\n    project=ROOT / \"runs/val\",  # save to project/name\n    name=\"exp\",  # save to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    half=True,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    model=None,\n    dataloader=None,\n    save_dir=Path(\"\"),\n    plots=True,\n    callbacks=Callbacks(),\n    compute_loss=None,\n):\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != \"cpu\"  # half precision only supported on CUDA\n        model.half() if half else model.float()\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        (save_dir / \"labels\" if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f\"Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models\")\n\n        # Data\n        data = check_dataset(data)  # check\n\n    # Configure\n    model.eval()\n    cuda = device.type != \"cpu\"\n    is_coco = isinstance(data.get(\"val\"), str) and data[\"val\"].endswith(f\"coco{os.sep}val2017.txt\")  # COCO dataset\n    nc = 1 if single_cls else int(data[\"nc\"])  # number of classes\n    iouv = torch.linspace(0.5, 0.95, 10, device=device)  # iou vector for mAP@0.5:0.95\n    niou = iouv.numel()\n\n    # Dataloader\n    if not training:\n        if pt and not single_cls:  # check --weights are trained on --data\n            ncm = model.model.nc\n            assert ncm == nc, (\n                f\"{weights} ({ncm} classes) trained on different --data than what you passed ({nc} \"\n                f\"classes). Pass correct combination of --weights and --data that are trained together.\"\n            )\n        model.warmup(imgsz=(1 if pt else batch_size, 3, imgsz, imgsz))  # warmup\n        pad, rect = (0.0, False) if task == \"speed\" else (0.5, pt)  # square inference for benchmarks\n        task = task if task in (\"train\", \"val\", \"test\") else \"val\"  # path to train/val/test images\n        dataloader = create_dataloader(\n            data[task],\n            imgsz,\n            batch_size,\n            stride,\n            single_cls,\n            pad=pad,\n            rect=rect,\n            workers=workers,\n            prefix=colorstr(f\"{task}: \"),\n        )[0]\n\n    seen = 0\n    confusion_matrix = ConfusionMatrix(nc=nc)\n    names = model.names if hasattr(model, \"names\") else model.module.names  # get class names\n    if isinstance(names, (list, tuple)):  # old format\n        names = dict(enumerate(names))\n    class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\n    s = (\"%22s\" + \"%11s\" * 6) % (\"Class\", \"Images\", \"Instances\", \"P\", \"R\", \"mAP50\", \"mAP50-95\")\n    tp, fp, p, r, f1, mp, mr, map50, ap50, map = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n    dt = Profile(device=device), Profile(device=device), Profile(device=device)  # profiling times\n    loss = torch.zeros(3, device=device)\n    jdict, stats, ap, ap_class = [], [], [], []\n    callbacks.run(\"on_val_start\")\n    pbar = tqdm(dataloader, desc=s, bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for batch_i, (im, targets, paths, shapes) in enumerate(pbar):\n        callbacks.run(\"on_val_batch_start\")\n        with dt[0]:\n            if cuda:\n                im = im.to(device, non_blocking=True)\n                targets = targets.to(device)\n            im = im.half() if half else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            nb, _, height, width = im.shape  # batch size, channels, height, width\n\n        # Inference\n        with dt[1]:\n            preds, train_out = model(im) if compute_loss else (model(im, augment=augment), None)\n\n        # Loss\n        if compute_loss:\n            loss += compute_loss(train_out, targets)[1]  # box, obj, cls\n\n        # NMS\n        targets[:, 2:] *= torch.tensor((width, height, width, height), device=device)  # to pixels\n        lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\n        with dt[2]:\n            preds = non_max_suppression(\n                preds, conf_thres, iou_thres, labels=lb, multi_label=True, agnostic=single_cls, max_det=max_det\n            )\n\n        # Metrics\n        for si, pred in enumerate(preds):\n            labels = targets[targets[:, 0] == si, 1:]\n            nl, npr = labels.shape[0], pred.shape[0]  # number of labels, predictions\n            path, shape = Path(paths[si]), shapes[si][0]\n            correct = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            seen += 1\n\n            if npr == 0:\n                if nl:\n                    stats.append((correct, *torch.zeros((2, 0), device=device), labels[:, 0]))\n                    if plots:\n                        confusion_matrix.process_batch(detections=None, labels=labels[:, 0])\n                continue\n\n            # Predictions\n            if single_cls:\n                pred[:, 5] = 0\n            predn = pred.clone()\n            scale_boxes(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\n\n            # Evaluate\n            if nl:\n                tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n                scale_boxes(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\n                labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n                correct = process_batch(predn, labelsn, iouv)\n                if plots:\n                    confusion_matrix.process_batch(predn, labelsn)\n            stats.append((correct, pred[:, 4], pred[:, 5], labels[:, 0]))  # (correct, conf, pcls, tcls)\n\n            # Save/log\n            if save_txt:\n                (save_dir / \"labels\").mkdir(parents=True, exist_ok=True)\n                save_one_txt(predn, save_conf, shape, file=save_dir / \"labels\" / f\"{path.stem}.txt\")\n            if save_json:\n                save_one_json(predn, jdict, path, class_map)  # append to COCO-JSON dictionary\n            callbacks.run(\"on_val_image_end\", pred, predn, path, names, im[si])\n\n        # Plot images\n        if plots and batch_i < 3:\n            plot_images(im, targets, paths, save_dir / f\"val_batch{batch_i}_labels.jpg\", names)  # labels\n            plot_images(im, output_to_target(preds), paths, save_dir / f\"val_batch{batch_i}_pred.jpg\", names)  # pred\n\n        callbacks.run(\"on_val_batch_end\", batch_i, im, targets, paths, shapes, preds)\n\n    # Compute metrics\n    stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*stats)]  # to numpy\n    if len(stats) and stats[0].any():\n        tp, fp, p, r, f1, ap, ap_class = ap_per_class(*stats, plot=plots, save_dir=save_dir, names=names)\n        ap50, ap = ap[:, 0], ap.mean(1)  # AP@0.5, AP@0.5:0.95\n        mp, mr, map50, map = p.mean(), r.mean(), ap50.mean(), ap.mean()\n    nt = np.bincount(stats[3].astype(int), minlength=nc)  # number of targets per class\n\n    # Print results\n    pf = \"%22s\" + \"%11i\" * 2 + \"%11.3g\" * 4  # print format\n    LOGGER.info(pf % (\"all\", seen, nt.sum(), mp, mr, map50, map))\n    if nt.sum() == 0:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f no labels found in {task} set, can not compute metrics without labels\")\n\n    # Print results per class\n    if (verbose or (nc < 50 and not training)) and nc > 1 and len(stats):\n        for i, c in enumerate(ap_class):\n            LOGGER.info(pf % (names[c], seen, nt[c], p[i], r[i], ap50[i], ap[i]))\n\n    # Print speeds\n    t = tuple(x.t / seen * 1e3 for x in dt)  # speeds per image\n    if not training:\n        shape = (batch_size, 3, imgsz, imgsz)\n        LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {shape}\" % t)\n\n    # Plots\n    if plots:\n        confusion_matrix.plot(save_dir=save_dir, names=list(names.values()))\n        callbacks.run(\"on_val_end\", nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix)\n\n    # Save JSON\n    if save_json and len(jdict):\n        w = Path(weights[0] if isinstance(weights, list) else weights).stem if weights is not None else \"\"  # weights\n        anno_json = str(Path(\"../datasets/coco/annotations/instances_val2017.json\"))  # annotations\n        if not os.path.exists(anno_json):\n            anno_json = os.path.join(data[\"path\"], \"annotations\", \"instances_val2017.json\")\n        pred_json = str(save_dir / f\"{w}_predictions.json\")  # predictions\n        LOGGER.info(f\"\\nEvaluating pycocotools mAP... saving {pred_json}...\")\n        with open(pred_json, \"w\") as f:\n            json.dump(jdict, f)\n\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            check_requirements(\"pycocotools>=2.0.6\")\n            from pycocotools.coco import COCO\n            from pycocotools.cocoeval import COCOeval\n\n            anno = COCO(anno_json)  # init annotations api\n            pred = anno.loadRes(pred_json)  # init predictions api\n            eval = COCOeval(anno, pred, \"bbox\")\n            if is_coco:\n                eval.params.imgIds = [int(Path(x).stem) for x in dataloader.dataset.im_files]  # image IDs to evaluate\n            eval.evaluate()\n            eval.accumulate()\n            eval.summarize()\n            map, map50 = eval.stats[:2]  # update results (mAP@0.5:0.95, mAP@0.5)\n        except Exception as e:\n            LOGGER.info(f\"pycocotools unable to run: {e}\")\n\n    # Return results\n    model.float()  # for training\n    if not training:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    maps = np.zeros(nc) + map\n    for i, c in enumerate(ap_class):\n        maps[c] = ap[i]\n    return (mp, mr, map50, map, *(loss.cpu() / len(dataloader)).tolist()), maps, t\n\n\ndef parse_opt():\n    \"\"\"Parses command-line options for YOLOv5 model inference configuration.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s.pt\", help=\"model path(s)\")\n    parser.add_argument(\"--batch-size\", type=int, default=32, help=\"batch size\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"inference size (pixels)\")\n    parser.add_argument(\"--conf-thres\", type=float, default=0.001, help=\"confidence threshold\")\n    parser.add_argument(\"--iou-thres\", type=float, default=0.6, help=\"NMS IoU threshold\")\n    parser.add_argument(\"--max-det\", type=int, default=300, help=\"maximum detections per image\")\n    parser.add_argument(\"--task\", default=\"val\", help=\"train, val, test, speed or study\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--single-cls\", action=\"store_true\", help=\"treat as single-class dataset\")\n    parser.add_argument(\"--augment\", action=\"store_true\", help=\"augmented inference\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"report mAP by class\")\n    parser.add_argument(\"--save-txt\", action=\"store_true\", help=\"save results to *.txt\")\n    parser.add_argument(\"--save-hybrid\", action=\"store_true\", help=\"save label+prediction hybrid results to *.txt\")\n    parser.add_argument(\"--save-conf\", action=\"store_true\", help=\"save confidences in --save-txt labels\")\n    parser.add_argument(\"--save-json\", action=\"store_true\", help=\"save a COCO-JSON results file\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/val\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    opt.save_json |= opt.data.endswith(\"coco.yaml\")\n    opt.save_txt |= opt.save_hybrid\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 tasks like training, validation, testing, speed, and study benchmarks based on provided\n    options.\n    \"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n\n    if opt.task in (\"train\", \"val\", \"test\"):  # run normally\n        if opt.conf_thres > 0.001:  # https://github.com/ultralytics/yolov5/issues/1466\n            LOGGER.info(f\"WARNING \u26a0\ufe0f confidence threshold {opt.conf_thres} > 0.001 produces invalid results\")\n        if opt.save_hybrid:\n            LOGGER.info(\"WARNING \u26a0\ufe0f --save-hybrid will return high mAP from hybrid labels, not from predictions alone\")\n        run(**vars(opt))\n\n    else:\n        weights = opt.weights if isinstance(opt.weights, list) else [opt.weights]\n        opt.half = torch.cuda.is_available() and opt.device != \"cpu\"  # FP16 for fastest results\n        if opt.task == \"speed\":  # speed benchmarks\n            # python val.py --task speed --data coco.yaml --batch 1 --weights yolov5n.pt yolov5s.pt...\n            opt.conf_thres, opt.iou_thres, opt.save_json = 0.25, 0.45, False\n            for opt.weights in weights:\n                run(**vars(opt), plots=False)\n\n        elif opt.task == \"study\":  # speed vs mAP benchmarks\n            # python val.py --task study --data coco.yaml --iou 0.7 --weights yolov5n.pt yolov5s.pt...\n            for opt.weights in weights:\n                f = f\"study_{Path(opt.data).stem}_{Path(opt.weights).stem}.txt\"  # filename to save to\n                x, y = list(range(256, 1536 + 128, 128)), []  # x axis (image sizes), y axis\n                for opt.imgsz in x:  # img-size\n                    LOGGER.info(f\"\\nRunning {f} --imgsz {opt.imgsz}...\")\n                    r, _, t = run(**vars(opt), plots=False)\n                    y.append(r + t)  # results and times\n                np.savetxt(f, y, fmt=\"%10.4g\")  # save\n            subprocess.run([\"zip\", \"-r\", \"study.zip\", \"study_*.txt\"])\n            plot_val_study(x=x)  # plot\n        else:\n            raise NotImplementedError(f'--task {opt.task} not in (\"train\", \"val\", \"test\", \"speed\", \"study\")')\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "detect.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nRun YOLOv5 detection inference on images, videos, directories, globs, YouTube, webcam, streams, etc.\n\nUsage - sources:\n    $ python detect.py --weights yolov5s.pt --source 0                               # webcam\n                                                     img.jpg                         # image\n                                                     vid.mp4                         # video\n                                                     screen                          # screenshot\n                                                     path/                           # directory\n                                                     list.txt                        # list of images\n                                                     list.streams                    # list of streams\n                                                     'path/*.jpg'                    # glob\n                                                     'https://youtu.be/LNwODJXcvt4'  # YouTube\n                                                     'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP stream\n\nUsage - formats:\n    $ python detect.py --weights yolov5s.pt                 # PyTorch\n                                 yolov5s.torchscript        # TorchScript\n                                 yolov5s.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                 yolov5s_openvino_model     # OpenVINO\n                                 yolov5s.engine             # TensorRT\n                                 yolov5s.mlmodel            # CoreML (macOS-only)\n                                 yolov5s_saved_model        # TensorFlow SavedModel\n                                 yolov5s.pb                 # TensorFlow GraphDef\n                                 yolov5s.tflite             # TensorFlow Lite\n                                 yolov5s_edgetpu.tflite     # TensorFlow Edge TPU\n                                 yolov5s_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport csv\nimport os\nimport platform\nimport sys\nfrom pathlib import Path\n\nimport torch\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[0]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom ultralytics.utils.plotting import Annotator, colors, save_one_box\n\nfrom models.common import DetectMultiBackend\nfrom utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams\nfrom utils.general import (\n    LOGGER,\n    Profile,\n    check_file,\n    check_img_size,\n    check_imshow,\n    check_requirements,\n    colorstr,\n    cv2,\n    increment_path,\n    non_max_suppression,\n    print_args,\n    scale_boxes,\n    strip_optimizer,\n    xyxy2xywh,\n)\nfrom utils.torch_utils import select_device, smart_inference_mode\n\n\n@smart_inference_mode()\ndef run(\n    weights=ROOT / \"yolov5s.pt\",  # model path or triton URL\n    source=ROOT / \"data/images\",  # file/dir/URL/glob/screen/0(webcam)\n    data=ROOT / \"data/coco128.yaml\",  # dataset.yaml path\n    imgsz=(640, 640),  # inference size (height, width)\n    conf_thres=0.25,  # confidence threshold\n    iou_thres=0.45,  # NMS IOU threshold\n    max_det=1000,  # maximum detections per image\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    view_img=False,  # show results\n    save_txt=False,  # save results to *.txt\n    save_csv=False,  # save results in CSV format\n    save_conf=False,  # save confidences in --save-txt labels\n    save_crop=False,  # save cropped prediction boxes\n    nosave=False,  # do not save images/videos\n    classes=None,  # filter by class: --class 0, or --class 0 2 3\n    agnostic_nms=False,  # class-agnostic NMS\n    augment=False,  # augmented inference\n    visualize=False,  # visualize features\n    update=False,  # update all models\n    project=ROOT / \"runs/detect\",  # save results to project/name\n    name=\"exp\",  # save results to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    line_thickness=3,  # bounding box thickness (pixels)\n    hide_labels=False,  # hide labels\n    hide_conf=False,  # hide confidences\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    vid_stride=1,  # video frame-rate stride\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith(\".txt\")  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith((\"rtsp://\", \"rtmp://\", \"http://\", \"https://\"))\n    webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n    screenshot = source.lower().startswith(\"screen\")\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / \"labels\" if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(device=device), Profile(device=device), Profile(device=device))\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n            if model.xml and im.shape[0] > 1:\n                ims = torch.chunk(im, im.shape[0], 0)\n\n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            if model.xml and im.shape[0] > 1:\n                pred = None\n                for image in ims:\n                    if pred is None:\n                        pred = model(image, augment=augment, visualize=visualize).unsqueeze(0)\n                    else:\n                        pred = torch.cat((pred, model(image, augment=augment, visualize=visualize).unsqueeze(0)), dim=0)\n                pred = [pred, None]\n            else:\n                pred = model(im, augment=augment, visualize=visualize)\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Define the path for the CSV file\n        csv_path = save_dir / \"predictions.csv\"\n\n        # Create or append to the CSV file\n        def write_to_csv(image_name, prediction, confidence):\n            \"\"\"Writes prediction data for an image to a CSV file, appending if the file exists.\"\"\"\n            data = {\"Image Name\": image_name, \"Prediction\": prediction, \"Confidence\": confidence}\n            with open(csv_path, mode=\"a\", newline=\"\") as f:\n                writer = csv.DictWriter(f, fieldnames=data.keys())\n                if not csv_path.is_file():\n                    writer.writeheader()\n                writer.writerow(data)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f\"{i}: \"\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, \"frame\", 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / \"labels\" / p.stem) + (\"\" if dataset.mode == \"image\" else f\"_{frame}\")  # im.txt\n            s += \"%gx%g \" % im.shape[2:]  # print string\n            gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                # Rescale boxes from img_size to im0 size\n                det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Write results\n                for *xyxy, conf, cls in reversed(det):\n                    c = int(cls)  # integer class\n                    label = names[c] if hide_conf else f\"{names[c]}\"\n                    confidence = float(conf)\n                    confidence_str = f\"{confidence:.2f}\"\n\n                    if save_csv:\n                        write_to_csv(p.name, label, confidence_str)\n\n                    if save_txt:  # Write to file\n                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n                        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n                        with open(f\"{txt_path}.txt\", \"a\") as f:\n                            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f\"{names[c]} {conf:.2f}\")\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / \"crops\" / names[c] / f\"{p.stem}.jpg\", BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == \"Linux\" and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == \"image\":\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix(\".mp4\"))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*\"mp4v\"), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1e3 for x in dt)  # speeds per image\n    LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}\" % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)\n\n\ndef parse_opt():\n    \"\"\"Parses command-line arguments for YOLOv5 detection, setting inference options and model configurations.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s.pt\", help=\"model path or triton URL\")\n    parser.add_argument(\"--source\", type=str, default=ROOT / \"data/images\", help=\"file/dir/URL/glob/screen/0(webcam)\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"(optional) dataset.yaml path\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", nargs=\"+\", type=int, default=[640], help=\"inference size h,w\")\n    parser.add_argument(\"--conf-thres\", type=float, default=0.25, help=\"confidence threshold\")\n    parser.add_argument(\"--iou-thres\", type=float, default=0.45, help=\"NMS IoU threshold\")\n    parser.add_argument(\"--max-det\", type=int, default=1000, help=\"maximum detections per image\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--view-img\", action=\"store_true\", help=\"show results\")\n    parser.add_argument(\"--save-txt\", action=\"store_true\", help=\"save results to *.txt\")\n    parser.add_argument(\"--save-csv\", action=\"store_true\", help=\"save results in CSV format\")\n    parser.add_argument(\"--save-conf\", action=\"store_true\", help=\"save confidences in --save-txt labels\")\n    parser.add_argument(\"--save-crop\", action=\"store_true\", help=\"save cropped prediction boxes\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"do not save images/videos\")\n    parser.add_argument(\"--classes\", nargs=\"+\", type=int, help=\"filter by class: --classes 0, or --classes 0 2 3\")\n    parser.add_argument(\"--agnostic-nms\", action=\"store_true\", help=\"class-agnostic NMS\")\n    parser.add_argument(\"--augment\", action=\"store_true\", help=\"augmented inference\")\n    parser.add_argument(\"--visualize\", action=\"store_true\", help=\"visualize features\")\n    parser.add_argument(\"--update\", action=\"store_true\", help=\"update all models\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/detect\", help=\"save results to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save results to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--line-thickness\", default=3, type=int, help=\"bounding box thickness (pixels)\")\n    parser.add_argument(\"--hide-labels\", default=False, action=\"store_true\", help=\"hide labels\")\n    parser.add_argument(\"--hide-conf\", default=False, action=\"store_true\", help=\"hide confidences\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    parser.add_argument(\"--vid-stride\", type=int, default=1, help=\"video frame-rate stride\")\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 model inference with given options, checking requirements before running the model.\"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n    run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "train.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nTrain a YOLOv5 model on a custom dataset. Models and datasets download automatically from the latest YOLOv5 release.\n\nUsage - Single-GPU training:\n    $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # from pretrained (recommended)\n    $ python train.py --data coco128.yaml --weights '' --cfg yolov5s.yaml --img 640  # from scratch\n\nUsage - Multi-GPU DDP training:\n    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights yolov5s.pt --img 640 --device 0,1,2,3\n\nModels:     https://github.com/ultralytics/yolov5/tree/master/models\nDatasets:   https://github.com/ultralytics/yolov5/tree/master/data\nTutorial:   https://docs.ultralytics.com/yolov5/tutorials/train_custom_data\n\"\"\"\n\nimport argparse\nimport math\nimport os\nimport random\nimport subprocess\nimport sys\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\ntry:\n    import comet_ml  # must be imported before torch (if installed)\nexcept ImportError:\n    comet_ml = None\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\nimport torch.nn as nn\nimport yaml\nfrom torch.optim import lr_scheduler\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[0]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nimport val as validate  # for end-of-epoch mAP\nfrom models.experimental import attempt_load\nfrom models.yolo import Model\nfrom utils.autoanchor import check_anchors\nfrom utils.autobatch import check_train_batch_size\nfrom utils.callbacks import Callbacks\nfrom utils.dataloaders import create_dataloader\nfrom utils.downloads import attempt_download, is_url\nfrom utils.general import (\n    LOGGER,\n    TQDM_BAR_FORMAT,\n    check_amp,\n    check_dataset,\n    check_file,\n    check_git_info,\n    check_git_status,\n    check_img_size,\n    check_requirements,\n    check_suffix,\n    check_yaml,\n    colorstr,\n    get_latest_run,\n    increment_path,\n    init_seeds,\n    intersect_dicts,\n    labels_to_class_weights,\n    labels_to_image_weights,\n    methods,\n    one_cycle,\n    print_args,\n    print_mutation,\n    strip_optimizer,\n    yaml_save,\n)\nfrom utils.loggers import LOGGERS, Loggers\nfrom utils.loggers.comet.comet_utils import check_comet_resume\nfrom utils.loss import ComputeLoss\nfrom utils.metrics import fitness\nfrom utils.plots import plot_evolve\nfrom utils.torch_utils import (\n    EarlyStopping,\n    ModelEMA,\n    de_parallel,\n    select_device,\n    smart_DDP,\n    smart_optimizer,\n    smart_resume,\n    torch_distributed_zero_first,\n)\n\nLOCAL_RANK = int(os.getenv(\"LOCAL_RANK\", -1))  # https://pytorch.org/docs/stable/elastic/run.html\nRANK = int(os.getenv(\"RANK\", -1))\nWORLD_SIZE = int(os.getenv(\"WORLD_SIZE\", 1))\nGIT_INFO = check_git_info()\n\n\ndef train(hyp, opt, device, callbacks):\n    \"\"\"\n    Trains YOLOv5 model with given hyperparameters, options, and device, managing datasets, model architecture, loss\n    computation, and optimizer steps.\n\n    `hyp` argument is path/to/hyp.yaml or hyp dictionary.\n    \"\"\"\n    save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze = (\n        Path(opt.save_dir),\n        opt.epochs,\n        opt.batch_size,\n        opt.weights,\n        opt.single_cls,\n        opt.evolve,\n        opt.data,\n        opt.cfg,\n        opt.resume,\n        opt.noval,\n        opt.nosave,\n        opt.workers,\n        opt.freeze,\n    )\n    callbacks.run(\"on_pretrain_routine_start\")\n\n    # Directories\n    w = save_dir / \"weights\"  # weights dir\n    (w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = w / \"last.pt\", w / \"best.pt\"\n\n    # Hyperparameters\n    if isinstance(hyp, str):\n        with open(hyp, errors=\"ignore\") as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n    LOGGER.info(colorstr(\"hyperparameters: \") + \", \".join(f\"{k}={v}\" for k, v in hyp.items()))\n    opt.hyp = hyp.copy()  # for saving hyps to checkpoints\n\n    # Save run settings\n    if not evolve:\n        yaml_save(save_dir / \"hyp.yaml\", hyp)\n        yaml_save(save_dir / \"opt.yaml\", vars(opt))\n\n    # Loggers\n    data_dict = None\n    if RANK in {-1, 0}:\n        include_loggers = list(LOGGERS)\n        if getattr(opt, \"ndjson_console\", False):\n            include_loggers.append(\"ndjson_console\")\n        if getattr(opt, \"ndjson_file\", False):\n            include_loggers.append(\"ndjson_file\")\n\n        loggers = Loggers(\n            save_dir=save_dir,\n            weights=weights,\n            opt=opt,\n            hyp=hyp,\n            logger=LOGGER,\n            include=tuple(include_loggers),\n        )\n\n        # Register actions\n        for k in methods(loggers):\n            callbacks.register_action(k, callback=getattr(loggers, k))\n\n        # Process custom dataset artifact link\n        data_dict = loggers.remote_dataset\n        if resume:  # If resuming runs from remote artifact\n            weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size\n\n    # Config\n    plots = not evolve and not opt.noplots  # create plots\n    cuda = device.type != \"cpu\"\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    with torch_distributed_zero_first(LOCAL_RANK):\n        data_dict = data_dict or check_dataset(data)  # check if None\n    train_path, val_path = data_dict[\"train\"], data_dict[\"val\"]\n    nc = 1 if single_cls else int(data_dict[\"nc\"])  # number of classes\n    names = {0: \"item\"} if single_cls and len(data_dict[\"names\"]) != 1 else data_dict[\"names\"]  # class names\n    is_coco = isinstance(val_path, str) and val_path.endswith(\"coco/val2017.txt\")  # COCO dataset\n\n    # Model\n    check_suffix(weights, \".pt\")  # check weights\n    pretrained = weights.endswith(\".pt\")\n    if pretrained:\n        with torch_distributed_zero_first(LOCAL_RANK):\n            weights = attempt_download(weights)  # download if not found locally\n        ckpt = torch.load(weights, map_location=\"cpu\")  # load checkpoint to CPU to avoid CUDA memory leak\n        model = Model(cfg or ckpt[\"model\"].yaml, ch=3, nc=nc, anchors=hyp.get(\"anchors\")).to(device)  # create\n        exclude = [\"anchor\"] if (cfg or hyp.get(\"anchors\")) and not resume else []  # exclude keys\n        csd = ckpt[\"model\"].float().state_dict()  # checkpoint state_dict as FP32\n        csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # intersect\n        model.load_state_dict(csd, strict=False)  # load\n        LOGGER.info(f\"Transferred {len(csd)}/{len(model.state_dict())} items from {weights}\")  # report\n    else:\n        model = Model(cfg, ch=3, nc=nc, anchors=hyp.get(\"anchors\")).to(device)  # create\n    amp = check_amp(model)  # check AMP\n\n    # Freeze\n    freeze = [f\"model.{x}.\" for x in (freeze if len(freeze) > 1 else range(freeze[0]))]  # layers to freeze\n    for k, v in model.named_parameters():\n        v.requires_grad = True  # train all layers\n        # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n        if any(x in k for x in freeze):\n            LOGGER.info(f\"freezing {k}\")\n            v.requires_grad = False\n\n    # Image size\n    gs = max(int(model.stride.max()), 32)  # grid size (max stride)\n    imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # verify imgsz is gs-multiple\n\n    # Batch size\n    if RANK == -1 and batch_size == -1:  # single-GPU only, estimate best batch size\n        batch_size = check_train_batch_size(model, imgsz, amp)\n        loggers.on_params_update({\"batch_size\": batch_size})\n\n    # Optimizer\n    nbs = 64  # nominal batch size\n    accumulate = max(round(nbs / batch_size), 1)  # accumulate loss before optimizing\n    hyp[\"weight_decay\"] *= batch_size * accumulate / nbs  # scale weight_decay\n    optimizer = smart_optimizer(model, opt.optimizer, hyp[\"lr0\"], hyp[\"momentum\"], hyp[\"weight_decay\"])\n\n    # Scheduler\n    if opt.cos_lr:\n        lf = one_cycle(1, hyp[\"lrf\"], epochs)  # cosine 1->hyp['lrf']\n    else:\n\n        def lf(x):\n            return (1 - x / epochs) * (1.0 - hyp[\"lrf\"]) + hyp[\"lrf\"]  # linear\n\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # Resume\n    best_fitness, start_epoch = 0.0, 0\n    if pretrained:\n        if resume:\n            best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)\n        del ckpt, csd\n\n    # DP mode\n    if cuda and RANK == -1 and torch.cuda.device_count() > 1:\n        LOGGER.warning(\n            \"WARNING \u26a0\ufe0f DP not recommended, use torch.distributed.run for best DDP Multi-GPU results.\\n\"\n            \"See Multi-GPU Tutorial at https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training to get started.\"\n        )\n        model = torch.nn.DataParallel(model)\n\n    # SyncBatchNorm\n    if opt.sync_bn and cuda and RANK != -1:\n        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)\n        LOGGER.info(\"Using SyncBatchNorm()\")\n\n    # Trainloader\n    train_loader, dataset = create_dataloader(\n        train_path,\n        imgsz,\n        batch_size // WORLD_SIZE,\n        gs,\n        single_cls,\n        hyp=hyp,\n        augment=True,\n        cache=None if opt.cache == \"val\" else opt.cache,\n        rect=opt.rect,\n        rank=LOCAL_RANK,\n        workers=workers,\n        image_weights=opt.image_weights,\n        quad=opt.quad,\n        prefix=colorstr(\"train: \"),\n        shuffle=True,\n        seed=opt.seed,\n    )\n    labels = np.concatenate(dataset.labels, 0)\n    mlc = int(labels[:, 0].max())  # max label class\n    assert mlc < nc, f\"Label class {mlc} exceeds nc={nc} in {data}. Possible class labels are 0-{nc - 1}\"\n\n    # Process 0\n    if RANK in {-1, 0}:\n        val_loader = create_dataloader(\n            val_path,\n            imgsz,\n            batch_size // WORLD_SIZE * 2,\n            gs,\n            single_cls,\n            hyp=hyp,\n            cache=None if noval else opt.cache,\n            rect=True,\n            rank=-1,\n            workers=workers * 2,\n            pad=0.5,\n            prefix=colorstr(\"val: \"),\n        )[0]\n\n        if not resume:\n            if not opt.noautoanchor:\n                check_anchors(dataset, model=model, thr=hyp[\"anchor_t\"], imgsz=imgsz)  # run AutoAnchor\n            model.half().float()  # pre-reduce anchor precision\n\n        callbacks.run(\"on_pretrain_routine_end\", labels, names)\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Model attributes\n    nl = de_parallel(model).model[-1].nl  # number of detection layers (to scale hyps)\n    hyp[\"box\"] *= 3 / nl  # scale to layers\n    hyp[\"cls\"] *= nc / 80 * 3 / nl  # scale to classes and layers\n    hyp[\"obj\"] *= (imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n    hyp[\"label_smoothing\"] = opt.label_smoothing\n    model.nc = nc  # attach number of classes to model\n    model.hyp = hyp  # attach hyperparameters to model\n    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # attach class weights\n    model.names = names\n\n    # Start training\n    t0 = time.time()\n    nb = len(train_loader)  # number of batches\n    nw = max(round(hyp[\"warmup_epochs\"] * nb), 100)  # number of warmup iterations, max(3 epochs, 100 iterations)\n    # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\n    last_opt_step = -1\n    maps = np.zeros(nc)  # mAP per class\n    results = (0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\n    scheduler.last_epoch = start_epoch - 1  # do not move\n    scaler = torch.cuda.amp.GradScaler(enabled=amp)\n    stopper, stop = EarlyStopping(patience=opt.patience), False\n    compute_loss = ComputeLoss(model)  # init loss class\n    callbacks.run(\"on_train_start\")\n    LOGGER.info(\n        f'Image sizes {imgsz} train, {imgsz} val\\n'\n        f'Using {train_loader.num_workers * WORLD_SIZE} dataloader workers\\n'\n        f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n        f'Starting training for {epochs} epochs...'\n    )\n    for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------\n        callbacks.run(\"on_train_epoch_start\")\n        model.train()\n\n        # Update image weights (optional, single-GPU only)\n        if opt.image_weights:\n            cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # class weights\n            iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # image weights\n            dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # rand weighted idx\n\n        # Update mosaic border (optional)\n        # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\n        # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\n\n        mloss = torch.zeros(3, device=device)  # mean losses\n        if RANK != -1:\n            train_loader.sampler.set_epoch(epoch)\n        pbar = enumerate(train_loader)\n        LOGGER.info((\"\\n\" + \"%11s\" * 7) % (\"Epoch\", \"GPU_mem\", \"box_loss\", \"obj_loss\", \"cls_loss\", \"Instances\", \"Size\"))\n        if RANK in {-1, 0}:\n            pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # progress bar\n        optimizer.zero_grad()\n        for i, (imgs, targets, paths, _) in pbar:  # batch -------------------------------------------------------------\n            callbacks.run(\"on_train_batch_start\")\n            ni = i + nb * epoch  # number integrated batches (since train start)\n            imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8 to float32, 0-255 to 0.0-1.0\n\n            # Warmup\n            if ni <= nw:\n                xi = [0, nw]  # x interp\n                # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\n                accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())\n                for j, x in enumerate(optimizer.param_groups):\n                    # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n                    x[\"lr\"] = np.interp(ni, xi, [hyp[\"warmup_bias_lr\"] if j == 0 else 0.0, x[\"initial_lr\"] * lf(epoch)])\n                    if \"momentum\" in x:\n                        x[\"momentum\"] = np.interp(ni, xi, [hyp[\"warmup_momentum\"], hyp[\"momentum\"]])\n\n            # Multi-scale\n            if opt.multi_scale:\n                sz = random.randrange(int(imgsz * 0.5), int(imgsz * 1.5) + gs) // gs * gs  # size\n                sf = sz / max(imgs.shape[2:])  # scale factor\n                if sf != 1:\n                    ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # new shape (stretched to gs-multiple)\n                    imgs = nn.functional.interpolate(imgs, size=ns, mode=\"bilinear\", align_corners=False)\n\n            # Forward\n            with torch.cuda.amp.autocast(amp):\n                pred = model(imgs)  # forward\n                loss, loss_items = compute_loss(pred, targets.to(device))  # loss scaled by batch_size\n                if RANK != -1:\n                    loss *= WORLD_SIZE  # gradient averaged between devices in DDP mode\n                if opt.quad:\n                    loss *= 4.0\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n            if ni - last_opt_step >= accumulate:\n                scaler.unscale_(optimizer)  # unscale gradients\n                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n                scaler.step(optimizer)  # optimizer.step\n                scaler.update()\n                optimizer.zero_grad()\n                if ema:\n                    ema.update(model)\n                last_opt_step = ni\n\n            # Log\n            if RANK in {-1, 0}:\n                mloss = (mloss * i + loss_items) / (i + 1)  # update mean losses\n                mem = f\"{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G\"  # (GB)\n                pbar.set_description(\n                    (\"%11s\" * 2 + \"%11.4g\" * 5)\n                    % (f\"{epoch}/{epochs - 1}\", mem, *mloss, targets.shape[0], imgs.shape[-1])\n                )\n                callbacks.run(\"on_train_batch_end\", model, ni, imgs, targets, paths, list(mloss))\n                if callbacks.stop_training:\n                    return\n            # end batch ------------------------------------------------------------------------------------------------\n\n        # Scheduler\n        lr = [x[\"lr\"] for x in optimizer.param_groups]  # for loggers\n        scheduler.step()\n\n        if RANK in {-1, 0}:\n            # mAP\n            callbacks.run(\"on_train_epoch_end\", epoch=epoch)\n            ema.update_attr(model, include=[\"yaml\", \"nc\", \"hyp\", \"names\", \"stride\", \"class_weights\"])\n            final_epoch = (epoch + 1 == epochs) or stopper.possible_stop\n            if not noval or final_epoch:  # Calculate mAP\n                results, maps, _ = validate.run(\n                    data_dict,\n                    batch_size=batch_size // WORLD_SIZE * 2,\n                    imgsz=imgsz,\n                    half=amp,\n                    model=ema.ema,\n                    single_cls=single_cls,\n                    dataloader=val_loader,\n                    save_dir=save_dir,\n                    plots=False,\n                    callbacks=callbacks,\n                    compute_loss=compute_loss,\n                )\n\n            # Update best mAP\n            fi = fitness(np.array(results).reshape(1, -1))  # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\n            stop = stopper(epoch=epoch, fitness=fi)  # early stop check\n            if fi > best_fitness:\n                best_fitness = fi\n            log_vals = list(mloss) + list(results) + lr\n            callbacks.run(\"on_fit_epoch_end\", log_vals, epoch, best_fitness, fi)\n\n            # Save model\n            if (not nosave) or (final_epoch and not evolve):  # if save\n                ckpt = {\n                    \"epoch\": epoch,\n                    \"best_fitness\": best_fitness,\n                    \"model\": deepcopy(de_parallel(model)).half(),\n                    \"ema\": deepcopy(ema.ema).half(),\n                    \"updates\": ema.updates,\n                    \"optimizer\": optimizer.state_dict(),\n                    \"opt\": vars(opt),\n                    \"git\": GIT_INFO,  # {remote, branch, commit} if a git repo\n                    \"date\": datetime.now().isoformat(),\n                }\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fi:\n                    torch.save(ckpt, best)\n                if opt.save_period > 0 and epoch % opt.save_period == 0:\n                    torch.save(ckpt, w / f\"epoch{epoch}.pt\")\n                del ckpt\n                callbacks.run(\"on_model_save\", last, epoch, final_epoch, best_fitness, fi)\n\n        # EarlyStopping\n        if RANK != -1:  # if DDP training\n            broadcast_list = [stop if RANK == 0 else None]\n            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n            if RANK != 0:\n                stop = broadcast_list[0]\n        if stop:\n            break  # must break all DDP ranks\n\n        # end epoch ----------------------------------------------------------------------------------------------------\n    # end training -----------------------------------------------------------------------------------------------------\n    if RANK in {-1, 0}:\n        LOGGER.info(f\"\\n{epoch - start_epoch + 1} epochs completed in {(time.time() - t0) / 3600:.3f} hours.\")\n        for f in last, best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is best:\n                    LOGGER.info(f\"\\nValidating {f}...\")\n                    results, _, _ = validate.run(\n                        data_dict,\n                        batch_size=batch_size // WORLD_SIZE * 2,\n                        imgsz=imgsz,\n                        model=attempt_load(f, device).half(),\n                        iou_thres=0.65 if is_coco else 0.60,  # best pycocotools at iou 0.65\n                        single_cls=single_cls,\n                        dataloader=val_loader,\n                        save_dir=save_dir,\n                        save_json=is_coco,\n                        verbose=True,\n                        plots=plots,\n                        callbacks=callbacks,\n                        compute_loss=compute_loss,\n                    )  # val best model with plots\n                    if is_coco:\n                        callbacks.run(\"on_fit_epoch_end\", list(mloss) + list(results) + lr, epoch, best_fitness, fi)\n\n        callbacks.run(\"on_train_end\", last, best, epoch, results)\n\n    torch.cuda.empty_cache()\n    return results\n\n\ndef parse_opt(known=False):\n    \"\"\"Parses command-line arguments for YOLOv5 training, validation, and testing.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=ROOT / \"yolov5s.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--cfg\", type=str, default=\"\", help=\"model.yaml path\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--hyp\", type=str, default=ROOT / \"data/hyps/hyp.scratch-low.yaml\", help=\"hyperparameters path\")\n    parser.add_argument(\"--epochs\", type=int, default=100, help=\"total training epochs\")\n    parser.add_argument(\"--batch-size\", type=int, default=16, help=\"total batch size for all GPUs, -1 for autobatch\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"train, val image size (pixels)\")\n    parser.add_argument(\"--rect\", action=\"store_true\", help=\"rectangular training\")\n    parser.add_argument(\"--resume\", nargs=\"?\", const=True, default=False, help=\"resume most recent training\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"only save final checkpoint\")\n    parser.add_argument(\"--noval\", action=\"store_true\", help=\"only validate final epoch\")\n    parser.add_argument(\"--noautoanchor\", action=\"store_true\", help=\"disable AutoAnchor\")\n    parser.add_argument(\"--noplots\", action=\"store_true\", help=\"save no plot files\")\n    parser.add_argument(\"--evolve\", type=int, nargs=\"?\", const=300, help=\"evolve hyperparameters for x generations\")\n    parser.add_argument(\n        \"--evolve_population\", type=str, default=ROOT / \"data/hyps\", help=\"location for loading population\"\n    )\n    parser.add_argument(\"--resume_evolve\", type=str, default=None, help=\"resume evolve from last generation\")\n    parser.add_argument(\"--bucket\", type=str, default=\"\", help=\"gsutil bucket\")\n    parser.add_argument(\"--cache\", type=str, nargs=\"?\", const=\"ram\", help=\"image --cache ram/disk\")\n    parser.add_argument(\"--image-weights\", action=\"store_true\", help=\"use weighted image selection for training\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--multi-scale\", action=\"store_true\", help=\"vary img-size +/- 50%%\")\n    parser.add_argument(\"--single-cls\", action=\"store_true\", help=\"train multi-class data as single-class\")\n    parser.add_argument(\"--optimizer\", type=str, choices=[\"SGD\", \"Adam\", \"AdamW\"], default=\"SGD\", help=\"optimizer\")\n    parser.add_argument(\"--sync-bn\", action=\"store_true\", help=\"use SyncBatchNorm, only available in DDP mode\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/train\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--quad\", action=\"store_true\", help=\"quad dataloader\")\n    parser.add_argument(\"--cos-lr\", action=\"store_true\", help=\"cosine LR scheduler\")\n    parser.add_argument(\"--label-smoothing\", type=float, default=0.0, help=\"Label smoothing epsilon\")\n    parser.add_argument(\"--patience\", type=int, default=100, help=\"EarlyStopping patience (epochs without improvement)\")\n    parser.add_argument(\"--freeze\", nargs=\"+\", type=int, default=[0], help=\"Freeze layers: backbone=10, first3=0 1 2\")\n    parser.add_argument(\"--save-period\", type=int, default=-1, help=\"Save checkpoint every x epochs (disabled if < 1)\")\n    parser.add_argument(\"--seed\", type=int, default=0, help=\"Global training seed\")\n    parser.add_argument(\"--local_rank\", type=int, default=-1, help=\"Automatic DDP Multi-GPU argument, do not modify\")\n\n    # Logger arguments\n    parser.add_argument(\"--entity\", default=None, help=\"Entity\")\n    parser.add_argument(\"--upload_dataset\", nargs=\"?\", const=True, default=False, help='Upload data, \"val\" option')\n    parser.add_argument(\"--bbox_interval\", type=int, default=-1, help=\"Set bounding-box image logging interval\")\n    parser.add_argument(\"--artifact_alias\", type=str, default=\"latest\", help=\"Version of dataset artifact to use\")\n\n    # NDJSON logging\n    parser.add_argument(\"--ndjson-console\", action=\"store_true\", help=\"Log ndjson to console\")\n    parser.add_argument(\"--ndjson-file\", action=\"store_true\", help=\"Log ndjson to file\")\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()\n\n\ndef main(opt, callbacks=Callbacks()):\n    \"\"\"Runs training or hyperparameter evolution with specified options and optional callbacks.\"\"\"\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements(ROOT / \"requirements.txt\")\n\n    # Resume (from specified or most recent last.pt)\n    if opt.resume and not check_comet_resume(opt) and not opt.evolve:\n        last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())\n        opt_yaml = last.parent.parent / \"opt.yaml\"  # train options yaml\n        opt_data = opt.data  # original dataset\n        if opt_yaml.is_file():\n            with open(opt_yaml, errors=\"ignore\") as f:\n                d = yaml.safe_load(f)\n        else:\n            d = torch.load(last, map_location=\"cpu\")[\"opt\"]\n        opt = argparse.Namespace(**d)  # replace\n        opt.cfg, opt.weights, opt.resume = \"\", str(last), True  # reinstate\n        if is_url(opt_data):\n            opt.data = check_file(opt_data)  # avoid HUB resume auth timeout\n    else:\n        opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = (\n            check_file(opt.data),\n            check_yaml(opt.cfg),\n            check_yaml(opt.hyp),\n            str(opt.weights),\n            str(opt.project),\n        )  # checks\n        assert len(opt.cfg) or len(opt.weights), \"either --cfg or --weights must be specified\"\n        if opt.evolve:\n            if opt.project == str(ROOT / \"runs/train\"):  # if default project name, rename to runs/evolve\n                opt.project = str(ROOT / \"runs/evolve\")\n            opt.exist_ok, opt.resume = opt.resume, False  # pass resume to exist_ok and disable resume\n        if opt.name == \"cfg\":\n            opt.name = Path(opt.cfg).stem  # use model.yaml as name\n        opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        msg = \"is not compatible with YOLOv5 Multi-GPU DDP training\"\n        assert not opt.image_weights, f\"--image-weights {msg}\"\n        assert not opt.evolve, f\"--evolve {msg}\"\n        assert opt.batch_size != -1, f\"AutoBatch with --batch-size -1 {msg}, please pass a valid --batch-size\"\n        assert opt.batch_size % WORLD_SIZE == 0, f\"--batch-size {opt.batch_size} must be multiple of WORLD_SIZE\"\n        assert torch.cuda.device_count() > LOCAL_RANK, \"insufficient CUDA devices for DDP command\"\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device(\"cuda\", LOCAL_RANK)\n        dist.init_process_group(\n            backend=\"nccl\" if dist.is_nccl_available() else \"gloo\", timeout=timedelta(seconds=10800)\n        )\n\n    # Train\n    if not opt.evolve:\n        train(opt.hyp, opt, device, callbacks)\n\n    # Evolve hyperparameters (optional)\n    else:\n        # Hyperparameter evolution metadata (including this hyperparameter True-False, lower_limit, upper_limit)\n        meta = {\n            \"lr0\": (False, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)\n            \"lrf\": (False, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n            \"momentum\": (False, 0.6, 0.98),  # SGD momentum/Adam beta1\n            \"weight_decay\": (False, 0.0, 0.001),  # optimizer weight decay\n            \"warmup_epochs\": (False, 0.0, 5.0),  # warmup epochs (fractions ok)\n            \"warmup_momentum\": (False, 0.0, 0.95),  # warmup initial momentum\n            \"warmup_bias_lr\": (False, 0.0, 0.2),  # warmup initial bias lr\n            \"box\": (False, 0.02, 0.2),  # box loss gain\n            \"cls\": (False, 0.2, 4.0),  # cls loss gain\n            \"cls_pw\": (False, 0.5, 2.0),  # cls BCELoss positive_weight\n            \"obj\": (False, 0.2, 4.0),  # obj loss gain (scale with pixels)\n            \"obj_pw\": (False, 0.5, 2.0),  # obj BCELoss positive_weight\n            \"iou_t\": (False, 0.1, 0.7),  # IoU training threshold\n            \"anchor_t\": (False, 2.0, 8.0),  # anchor-multiple threshold\n            \"anchors\": (False, 2.0, 10.0),  # anchors per output grid (0 to ignore)\n            \"fl_gamma\": (False, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)\n            \"hsv_h\": (True, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n            \"hsv_s\": (True, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n            \"hsv_v\": (True, 0.0, 0.9),  # image HSV-Value augmentation (fraction)\n            \"degrees\": (True, 0.0, 45.0),  # image rotation (+/- deg)\n            \"translate\": (True, 0.0, 0.9),  # image translation (+/- fraction)\n            \"scale\": (True, 0.0, 0.9),  # image scale (+/- gain)\n            \"shear\": (True, 0.0, 10.0),  # image shear (+/- deg)\n            \"perspective\": (True, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n            \"flipud\": (True, 0.0, 1.0),  # image flip up-down (probability)\n            \"fliplr\": (True, 0.0, 1.0),  # image flip left-right (probability)\n            \"mosaic\": (True, 0.0, 1.0),  # image mixup (probability)\n            \"mixup\": (True, 0.0, 1.0),  # image mixup (probability)\n            \"copy_paste\": (True, 0.0, 1.0),\n        }  # segment copy-paste (probability)\n\n        # GA configs\n        pop_size = 50\n        mutation_rate_min = 0.01\n        mutation_rate_max = 0.5\n        crossover_rate_min = 0.5\n        crossover_rate_max = 1\n        min_elite_size = 2\n        max_elite_size = 5\n        tournament_size_min = 2\n        tournament_size_max = 10\n\n        with open(opt.hyp, errors=\"ignore\") as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n            if \"anchors\" not in hyp:  # anchors commented in hyp.yaml\n                hyp[\"anchors\"] = 3\n        if opt.noautoanchor:\n            del hyp[\"anchors\"], meta[\"anchors\"]\n        opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # only val/save final epoch\n        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\n        evolve_yaml, evolve_csv = save_dir / \"hyp_evolve.yaml\", save_dir / \"evolve.csv\"\n        if opt.bucket:\n            # download evolve.csv if exists\n            subprocess.run(\n                [\n                    \"gsutil\",\n                    \"cp\",\n                    f\"gs://{opt.bucket}/evolve.csv\",\n                    str(evolve_csv),\n                ]\n            )\n\n        # Delete the items in meta dictionary whose first value is False\n        del_ = [item for item, value_ in meta.items() if value_[0] is False]\n        hyp_GA = hyp.copy()  # Make a copy of hyp dictionary\n        for item in del_:\n            del meta[item]  # Remove the item from meta dictionary\n            del hyp_GA[item]  # Remove the item from hyp_GA dictionary\n\n        # Set lower_limit and upper_limit arrays to hold the search space boundaries\n        lower_limit = np.array([meta[k][1] for k in hyp_GA.keys()])\n        upper_limit = np.array([meta[k][2] for k in hyp_GA.keys()])\n\n        # Create gene_ranges list to hold the range of values for each gene in the population\n        gene_ranges = [(lower_limit[i], upper_limit[i]) for i in range(len(upper_limit))]\n\n        # Initialize the population with initial_values or random values\n        initial_values = []\n\n        # If resuming evolution from a previous checkpoint\n        if opt.resume_evolve is not None:\n            assert os.path.isfile(ROOT / opt.resume_evolve), \"evolve population path is wrong!\"\n            with open(ROOT / opt.resume_evolve, errors=\"ignore\") as f:\n                evolve_population = yaml.safe_load(f)\n                for value in evolve_population.values():\n                    value = np.array([value[k] for k in hyp_GA.keys()])\n                    initial_values.append(list(value))\n\n        # If not resuming from a previous checkpoint, generate initial values from .yaml files in opt.evolve_population\n        else:\n            yaml_files = [f for f in os.listdir(opt.evolve_population) if f.endswith(\".yaml\")]\n            for file_name in yaml_files:\n                with open(os.path.join(opt.evolve_population, file_name)) as yaml_file:\n                    value = yaml.safe_load(yaml_file)\n                    value = np.array([value[k] for k in hyp_GA.keys()])\n                    initial_values.append(list(value))\n\n        # Generate random values within the search space for the rest of the population\n        if initial_values is None:\n            population = [generate_individual(gene_ranges, len(hyp_GA)) for _ in range(pop_size)]\n        elif pop_size > 1:\n            population = [generate_individual(gene_ranges, len(hyp_GA)) for _ in range(pop_size - len(initial_values))]\n            for initial_value in initial_values:\n                population = [initial_value] + population\n\n        # Run the genetic algorithm for a fixed number of generations\n        list_keys = list(hyp_GA.keys())\n        for generation in range(opt.evolve):\n            if generation >= 1:\n                save_dict = {}\n                for i in range(len(population)):\n                    little_dict = {list_keys[j]: float(population[i][j]) for j in range(len(population[i]))}\n                    save_dict[f\"gen{str(generation)}number{str(i)}\"] = little_dict\n\n                with open(save_dir / \"evolve_population.yaml\", \"w\") as outfile:\n                    yaml.dump(save_dict, outfile, default_flow_style=False)\n\n            # Adaptive elite size\n            elite_size = min_elite_size + int((max_elite_size - min_elite_size) * (generation / opt.evolve))\n            # Evaluate the fitness of each individual in the population\n            fitness_scores = []\n            for individual in population:\n                for key, value in zip(hyp_GA.keys(), individual):\n                    hyp_GA[key] = value\n                hyp.update(hyp_GA)\n                results = train(hyp.copy(), opt, device, callbacks)\n                callbacks = Callbacks()\n                # Write mutation results\n                keys = (\n                    \"metrics/precision\",\n                    \"metrics/recall\",\n                    \"metrics/mAP_0.5\",\n                    \"metrics/mAP_0.5:0.95\",\n                    \"val/box_loss\",\n                    \"val/obj_loss\",\n                    \"val/cls_loss\",\n                )\n                print_mutation(keys, results, hyp.copy(), save_dir, opt.bucket)\n                fitness_scores.append(results[2])\n\n            # Select the fittest individuals for reproduction using adaptive tournament selection\n            selected_indices = []\n            for _ in range(pop_size - elite_size):\n                # Adaptive tournament size\n                tournament_size = max(\n                    max(2, tournament_size_min),\n                    int(min(tournament_size_max, pop_size) - (generation / (opt.evolve / 10))),\n                )\n                # Perform tournament selection to choose the best individual\n                tournament_indices = random.sample(range(pop_size), tournament_size)\n                tournament_fitness = [fitness_scores[j] for j in tournament_indices]\n                winner_index = tournament_indices[tournament_fitness.index(max(tournament_fitness))]\n                selected_indices.append(winner_index)\n\n            # Add the elite individuals to the selected indices\n            elite_indices = [i for i in range(pop_size) if fitness_scores[i] in sorted(fitness_scores)[-elite_size:]]\n            selected_indices.extend(elite_indices)\n            # Create the next generation through crossover and mutation\n            next_generation = []\n            for _ in range(pop_size):\n                parent1_index = selected_indices[random.randint(0, pop_size - 1)]\n                parent2_index = selected_indices[random.randint(0, pop_size - 1)]\n                # Adaptive crossover rate\n                crossover_rate = max(\n                    crossover_rate_min, min(crossover_rate_max, crossover_rate_max - (generation / opt.evolve))\n                )\n                if random.uniform(0, 1) < crossover_rate:\n                    crossover_point = random.randint(1, len(hyp_GA) - 1)\n                    child = population[parent1_index][:crossover_point] + population[parent2_index][crossover_point:]\n                else:\n                    child = population[parent1_index]\n                # Adaptive mutation rate\n                mutation_rate = max(\n                    mutation_rate_min, min(mutation_rate_max, mutation_rate_max - (generation / opt.evolve))\n                )\n                for j in range(len(hyp_GA)):\n                    if random.uniform(0, 1) < mutation_rate:\n                        child[j] += random.uniform(-0.1, 0.1)\n                        child[j] = min(max(child[j], gene_ranges[j][0]), gene_ranges[j][1])\n                next_generation.append(child)\n            # Replace the old population with the new generation\n            population = next_generation\n        # Print the best solution found\n        best_index = fitness_scores.index(max(fitness_scores))\n        best_individual = population[best_index]\n        print(\"Best solution found:\", best_individual)\n        # Plot results\n        plot_evolve(evolve_csv)\n        LOGGER.info(\n            f'Hyperparameter evolution finished {opt.evolve} generations\\n'\n            f\"Results saved to {colorstr('bold', save_dir)}\\n\"\n            f'Usage example: $ python train.py --hyp {evolve_yaml}'\n        )\n\n\ndef generate_individual(input_ranges, individual_length):\n    \"\"\"Generates a list of random values within specified input ranges for each gene in the individual.\"\"\"\n    individual = []\n    for i in range(individual_length):\n        lower_bound, upper_bound = input_ranges[i]\n        individual.append(random.uniform(lower_bound, upper_bound))\n    return individual\n\n\ndef run(**kwargs):\n    \"\"\"\n    Executes YOLOv5 training with given options, overriding with any kwargs provided.\n\n    Example: import train; train.run(data='coco128.yaml', imgsz=320, weights='yolov5m.pt')\n    \"\"\"\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "benchmarks.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nRun YOLOv5 benchmarks on all supported export formats.\n\nFormat                      | `export.py --include`         | Model\n---                         | ---                           | ---\nPyTorch                     | -                             | yolov5s.pt\nTorchScript                 | `torchscript`                 | yolov5s.torchscript\nONNX                        | `onnx`                        | yolov5s.onnx\nOpenVINO                    | `openvino`                    | yolov5s_openvino_model/\nTensorRT                    | `engine`                      | yolov5s.engine\nCoreML                      | `coreml`                      | yolov5s.mlmodel\nTensorFlow SavedModel       | `saved_model`                 | yolov5s_saved_model/\nTensorFlow GraphDef         | `pb`                          | yolov5s.pb\nTensorFlow Lite             | `tflite`                      | yolov5s.tflite\nTensorFlow Edge TPU         | `edgetpu`                     | yolov5s_edgetpu.tflite\nTensorFlow.js               | `tfjs`                        | yolov5s_web_model/\n\nRequirements:\n    $ pip install -r requirements.txt coremltools onnx onnx-simplifier onnxruntime openvino-dev tensorflow-cpu  # CPU\n    $ pip install -r requirements.txt coremltools onnx onnx-simplifier onnxruntime-gpu openvino-dev tensorflow  # GPU\n    $ pip install -U nvidia-tensorrt --index-url https://pypi.ngc.nvidia.com  # TensorRT\n\nUsage:\n    $ python benchmarks.py --weights yolov5s.pt --img 640\n\"\"\"\n\nimport argparse\nimport platform\nimport sys\nimport time\nfrom pathlib import Path\n\nimport pandas as pd\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[0]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\n# ROOT = ROOT.relative_to(Path.cwd())  # relative\n\nimport export\nfrom models.experimental import attempt_load\nfrom models.yolo import SegmentationModel\nfrom segment.val import run as val_seg\nfrom utils import notebook_init\nfrom utils.general import LOGGER, check_yaml, file_size, print_args\nfrom utils.torch_utils import select_device\nfrom val import run as val_det\n\n\ndef run(\n    weights=ROOT / \"yolov5s.pt\",  # weights path\n    imgsz=640,  # inference size (pixels)\n    batch_size=1,  # batch size\n    data=ROOT / \"data/coco128.yaml\",  # dataset.yaml path\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    half=False,  # use FP16 half-precision inference\n    test=False,  # test exports only\n    pt_only=False,  # test PyTorch only\n    hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    model_type = type(attempt_load(weights, fuse=False))  # DetectionModel, SegmentationModel, etc.\n    for i, (name, f, suffix, cpu, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, CPU, GPU)\n        try:\n            assert i not in (9, 10), \"inference not supported\"  # Edge TPU and TF.js are unsupported\n            assert i != 5 or platform.system() == \"Darwin\", \"inference only supported on macOS>=10.13\"  # CoreML\n            if \"cpu\" in device.type:\n                assert cpu, \"inference not supported on CPU\"\n            if \"cuda\" in device.type:\n                assert gpu, \"inference not supported on GPU\"\n\n            # Export\n            if f == \"-\":\n                w = weights  # PyTorch format\n            else:\n                w = export.run(\n                    weights=weights, imgsz=[imgsz], include=[f], batch_size=batch_size, device=device, half=half\n                )[-1]  # all others\n            assert suffix in str(w), \"export failed\"\n\n            # Validate\n            if model_type == SegmentationModel:\n                result = val_seg(data, w, batch_size, imgsz, plots=False, device=device, task=\"speed\", half=half)\n                metric = result[0][7]  # (box(p, r, map50, map), mask(p, r, map50, map), *loss(box, obj, cls))\n            else:  # DetectionModel:\n                result = val_det(data, w, batch_size, imgsz, plots=False, device=device, task=\"speed\", half=half)\n                metric = result[0][3]  # (p, r, map50, map, *loss(box, obj, cls))\n            speed = result[2][1]  # times (preprocess, inference, postprocess)\n            y.append([name, round(file_size(w), 1), round(metric, 4), round(speed, 2)])  # MB, mAP, t_inference\n        except Exception as e:\n            if hard_fail:\n                assert type(e) is AssertionError, f\"Benchmark --hard-fail for {name}: {e}\"\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Benchmark failure for {name}: {e}\")\n            y.append([name, None, None, None])  # mAP, t_inference\n        if pt_only and i == 0:\n            break  # break after PyTorch\n\n    # Print results\n    LOGGER.info(\"\\n\")\n    parse_opt()\n    notebook_init()  # print system info\n    c = [\"Format\", \"Size (MB)\", \"mAP50-95\", \"Inference time (ms)\"] if map else [\"Format\", \"Export\", \"\", \"\"]\n    py = pd.DataFrame(y, columns=c)\n    LOGGER.info(f\"\\nBenchmarks complete ({time.time() - t:.2f}s)\")\n    LOGGER.info(str(py if map else py.iloc[:, :2]))\n    if hard_fail and isinstance(hard_fail, str):\n        metrics = py[\"mAP50-95\"].array  # values to compare to floor\n        floor = eval(hard_fail)  # minimum metric floor to pass, i.e. = 0.29 mAP for YOLOv5n\n        assert all(x > floor for x in metrics if pd.notna(x)), f\"HARD FAIL: mAP50-95 < floor {floor}\"\n    return py\n\n\ndef test(\n    weights=ROOT / \"yolov5s.pt\",  # weights path\n    imgsz=640,  # inference size (pixels)\n    batch_size=1,  # batch size\n    data=ROOT / \"data/coco128.yaml\",  # dataset.yaml path\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    half=False,  # use FP16 half-precision inference\n    test=False,  # test exports only\n    pt_only=False,  # test PyTorch only\n    hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    for i, (name, f, suffix, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, gpu-capable)\n        try:\n            w = (\n                weights\n                if f == \"-\"\n                else export.run(weights=weights, imgsz=[imgsz], include=[f], device=device, half=half)[-1]\n            )  # weights\n            assert suffix in str(w), \"export failed\"\n            y.append([name, True])\n        except Exception:\n            y.append([name, False])  # mAP, t_inference\n\n    # Print results\n    LOGGER.info(\"\\n\")\n    parse_opt()\n    notebook_init()  # print system info\n    py = pd.DataFrame(y, columns=[\"Format\", \"Export\"])\n    LOGGER.info(f\"\\nExports complete ({time.time() - t:.2f}s)\")\n    LOGGER.info(str(py))\n    return py\n\n\ndef parse_opt():\n    \"\"\"Parses command-line arguments for YOLOv5 model inference configuration.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=ROOT / \"yolov5s.pt\", help=\"weights path\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"inference size (pixels)\")\n    parser.add_argument(\"--batch-size\", type=int, default=1, help=\"batch size\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"test exports only\")\n    parser.add_argument(\"--pt-only\", action=\"store_true\", help=\"test PyTorch only\")\n    parser.add_argument(\"--hard-fail\", nargs=\"?\", const=True, default=False, help=\"Exception on error or < min metric\")\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes a test run if `opt.test` is True, otherwise starts training or inference with provided options.\"\"\"\n    test(**vars(opt)) if opt.test else run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "export.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nExport a YOLOv5 PyTorch model to other formats. TensorFlow exports authored by https://github.com/zldrobit\n\nFormat                      | `export.py --include`         | Model\n---                         | ---                           | ---\nPyTorch                     | -                             | yolov5s.pt\nTorchScript                 | `torchscript`                 | yolov5s.torchscript\nONNX                        | `onnx`                        | yolov5s.onnx\nOpenVINO                    | `openvino`                    | yolov5s_openvino_model/\nTensorRT                    | `engine`                      | yolov5s.engine\nCoreML                      | `coreml`                      | yolov5s.mlmodel\nTensorFlow SavedModel       | `saved_model`                 | yolov5s_saved_model/\nTensorFlow GraphDef         | `pb`                          | yolov5s.pb\nTensorFlow Lite             | `tflite`                      | yolov5s.tflite\nTensorFlow Edge TPU         | `edgetpu`                     | yolov5s_edgetpu.tflite\nTensorFlow.js               | `tfjs`                        | yolov5s_web_model/\nPaddlePaddle                | `paddle`                      | yolov5s_paddle_model/\n\nRequirements:\n    $ pip install -r requirements.txt coremltools onnx onnx-simplifier onnxruntime openvino-dev tensorflow-cpu  # CPU\n    $ pip install -r requirements.txt coremltools onnx onnx-simplifier onnxruntime-gpu openvino-dev tensorflow  # GPU\n\nUsage:\n    $ python export.py --weights yolov5s.pt --include torchscript onnx openvino engine coreml tflite ...\n\nInference:\n    $ python detect.py --weights yolov5s.pt                 # PyTorch\n                                 yolov5s.torchscript        # TorchScript\n                                 yolov5s.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                 yolov5s_openvino_model     # OpenVINO\n                                 yolov5s.engine             # TensorRT\n                                 yolov5s.mlmodel            # CoreML (macOS-only)\n                                 yolov5s_saved_model        # TensorFlow SavedModel\n                                 yolov5s.pb                 # TensorFlow GraphDef\n                                 yolov5s.tflite             # TensorFlow Lite\n                                 yolov5s_edgetpu.tflite     # TensorFlow Edge TPU\n                                 yolov5s_paddle_model       # PaddlePaddle\n\nTensorFlow.js:\n    $ cd .. && git clone https://github.com/zldrobit/tfjs-yolov5-example.git && cd tfjs-yolov5-example\n    $ npm install\n    $ ln -s ../../yolov5/yolov5s_web_model public/yolov5s_web_model\n    $ npm start\n\"\"\"\n\nimport argparse\nimport contextlib\nimport json\nimport os\nimport platform\nimport re\nimport subprocess\nimport sys\nimport time\nimport warnings\nfrom pathlib import Path\n\nimport pandas as pd\nimport torch\nfrom torch.utils.mobile_optimizer import optimize_for_mobile\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[0]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nif platform.system() != \"Windows\":\n    ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom models.experimental import attempt_load\nfrom models.yolo import ClassificationModel, Detect, DetectionModel, SegmentationModel\nfrom utils.dataloaders import LoadImages\nfrom utils.general import (\n    LOGGER,\n    Profile,\n    check_dataset,\n    check_img_size,\n    check_requirements,\n    check_version,\n    check_yaml,\n    colorstr,\n    file_size,\n    get_default_args,\n    print_args,\n    url2file,\n    yaml_save,\n)\nfrom utils.torch_utils import select_device, smart_inference_mode\n\nMACOS = platform.system() == \"Darwin\"  # macOS environment\n\n\nclass iOSModel(torch.nn.Module):\n    def __init__(self, model, im):\n        \"\"\"Initializes an iOS compatible model with normalization based on image dimensions.\"\"\"\n        super().__init__()\n        b, c, h, w = im.shape  # batch, channel, height, width\n        self.model = model\n        self.nc = model.nc  # number of classes\n        if w == h:\n            self.normalize = 1.0 / w\n        else:\n            self.normalize = torch.tensor([1.0 / w, 1.0 / h, 1.0 / w, 1.0 / h])  # broadcast (slower, smaller)\n            # np = model(im)[0].shape[1]  # number of points\n            # self.normalize = torch.tensor([1. / w, 1. / h, 1. / w, 1. / h]).expand(np, 4)  # explicit (faster, larger)\n\n    def forward(self, x):\n        \"\"\"Runs forward pass on the input tensor, returning class confidences and normalized coordinates.\"\"\"\n        xywh, conf, cls = self.model(x)[0].squeeze().split((4, 1, self.nc), 1)\n        return cls * conf, xywh * self.normalize  # confidence (3780, 80), coordinates (3780, 4)\n\n\ndef export_formats():\n    \"\"\"Returns a DataFrame of supported YOLOv5 model export formats and their properties.\"\"\"\n    x = [\n        [\"PyTorch\", \"-\", \".pt\", True, True],\n        [\"TorchScript\", \"torchscript\", \".torchscript\", True, True],\n        [\"ONNX\", \"onnx\", \".onnx\", True, True],\n        [\"OpenVINO\", \"openvino\", \"_openvino_model\", True, False],\n        [\"TensorRT\", \"engine\", \".engine\", False, True],\n        [\"CoreML\", \"coreml\", \".mlmodel\", True, False],\n        [\"TensorFlow SavedModel\", \"saved_model\", \"_saved_model\", True, True],\n        [\"TensorFlow GraphDef\", \"pb\", \".pb\", True, True],\n        [\"TensorFlow Lite\", \"tflite\", \".tflite\", True, False],\n        [\"TensorFlow Edge TPU\", \"edgetpu\", \"_edgetpu.tflite\", False, False],\n        [\"TensorFlow.js\", \"tfjs\", \"_web_model\", False, False],\n        [\"PaddlePaddle\", \"paddle\", \"_paddle_model\", True, True],\n    ]\n    return pd.DataFrame(x, columns=[\"Format\", \"Argument\", \"Suffix\", \"CPU\", \"GPU\"])\n\n\ndef try_export(inner_func):\n    \"\"\"Decorator @try_export for YOLOv5 model export functions that logs success/failure, time taken, and file size.\"\"\"\n    inner_args = get_default_args(inner_func)\n\n    def outer_func(*args, **kwargs):\n        prefix = inner_args[\"prefix\"]\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f\"{prefix} export success \u2705 {dt.t:.1f}s, saved as {f} ({file_size(f):.1f} MB)\")\n            return f, model\n        except Exception as e:\n            LOGGER.info(f\"{prefix} export failure \u274c {dt.t:.1f}s: {e}\")\n            return None, None\n\n    return outer_func\n\n\n@try_export\ndef export_torchscript(model, im, file, optimize, prefix=colorstr(\"TorchScript:\")):\n    \"\"\"Exports YOLOv5 model to TorchScript format, optionally optimized for mobile, with image shape and stride\n    metadata.\n    \"\"\"\n    LOGGER.info(f\"\\n{prefix} starting export with torch {torch.__version__}...\")\n    f = file.with_suffix(\".torchscript\")\n\n    ts = torch.jit.trace(model, im, strict=False)\n    d = {\"shape\": im.shape, \"stride\": int(max(model.stride)), \"names\": model.names}\n    extra_files = {\"config.txt\": json.dumps(d)}  # torch._C.ExtraFilesMap()\n    if optimize:  # https://pytorch.org/tutorials/recipes/mobile_interpreter.html\n        optimize_for_mobile(ts)._save_for_lite_interpreter(str(f), _extra_files=extra_files)\n    else:\n        ts.save(str(f), _extra_files=extra_files)\n    return f, None\n\n\n@try_export\ndef export_onnx(model, im, file, opset, dynamic, simplify, prefix=colorstr(\"ONNX:\")):\n    \"\"\"Exports a YOLOv5 model to ONNX format with dynamic axes and optional simplification.\"\"\"\n    check_requirements(\"onnx>=1.12.0\")\n    import onnx\n\n    LOGGER.info(f\"\\n{prefix} starting export with onnx {onnx.__version__}...\")\n    f = str(file.with_suffix(\".onnx\"))\n\n    output_names = [\"output0\", \"output1\"] if isinstance(model, SegmentationModel) else [\"output0\"]\n    if dynamic:\n        dynamic = {\"images\": {0: \"batch\", 2: \"height\", 3: \"width\"}}  # shape(1,3,640,640)\n        if isinstance(model, SegmentationModel):\n            dynamic[\"output0\"] = {0: \"batch\", 1: \"anchors\"}  # shape(1,25200,85)\n            dynamic[\"output1\"] = {0: \"batch\", 2: \"mask_height\", 3: \"mask_width\"}  # shape(1,32,160,160)\n        elif isinstance(model, DetectionModel):\n            dynamic[\"output0\"] = {0: \"batch\", 1: \"anchors\"}  # shape(1,25200,85)\n\n    torch.onnx.export(\n        model.cpu() if dynamic else model,  # --dynamic only compatible with cpu\n        im.cpu() if dynamic else im,\n        f,\n        verbose=False,\n        opset_version=opset,\n        do_constant_folding=True,  # WARNING: DNN inference with torch>=1.12 may require do_constant_folding=False\n        input_names=[\"images\"],\n        output_names=output_names,\n        dynamic_axes=dynamic or None,\n    )\n\n    # Checks\n    model_onnx = onnx.load(f)  # load onnx model\n    onnx.checker.check_model(model_onnx)  # check onnx model\n\n    # Metadata\n    d = {\"stride\": int(max(model.stride)), \"names\": model.names}\n    for k, v in d.items():\n        meta = model_onnx.metadata_props.add()\n        meta.key, meta.value = k, str(v)\n    onnx.save(model_onnx, f)\n\n    # Simplify\n    if simplify:\n        try:\n            cuda = torch.cuda.is_available()\n            check_requirements((\"onnxruntime-gpu\" if cuda else \"onnxruntime\", \"onnx-simplifier>=0.4.1\"))\n            import onnxsim\n\n            LOGGER.info(f\"{prefix} simplifying with onnx-simplifier {onnxsim.__version__}...\")\n            model_onnx, check = onnxsim.simplify(model_onnx)\n            assert check, \"assert check failed\"\n            onnx.save(model_onnx, f)\n        except Exception as e:\n            LOGGER.info(f\"{prefix} simplifier failure: {e}\")\n    return f, model_onnx\n\n\n@try_export\ndef export_openvino(file, metadata, half, int8, data, prefix=colorstr(\"OpenVINO:\")):\n    # YOLOv5 OpenVINO export\n    check_requirements(\"openvino-dev>=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n    import openvino.runtime as ov  # noqa\n    from openvino.tools import mo  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with openvino {ov.__version__}...\")\n    f = str(file).replace(file.suffix, f\"_{'int8_' if int8 else ''}openvino_model{os.sep}\")\n    f_onnx = file.with_suffix(\".onnx\")\n    f_ov = str(Path(f) / file.with_suffix(\".xml\").name)\n\n    ov_model = mo.convert_model(f_onnx, model_name=file.stem, framework=\"onnx\", compress_to_fp16=half)  # export\n\n    if int8:\n        check_requirements(\"nncf>=2.5.0\")  # requires at least version 2.5.0 to use the post-training quantization\n        import nncf\n        import numpy as np\n\n        from utils.dataloaders import create_dataloader\n\n        def gen_dataloader(yaml_path, task=\"train\", imgsz=640, workers=4):\n            data_yaml = check_yaml(yaml_path)\n            data = check_dataset(data_yaml)\n            dataloader = create_dataloader(\n                data[task], imgsz=imgsz, batch_size=1, stride=32, pad=0.5, single_cls=False, rect=False, workers=workers\n            )[0]\n            return dataloader\n\n        # noqa: F811\n\n        def transform_fn(data_item):\n            \"\"\"\n            Quantization transform function.\n\n            Extracts and preprocess input data from dataloader item for quantization.\n            Parameters:\n               data_item: Tuple with data item produced by DataLoader during iteration\n            Returns:\n                input_tensor: Input data for quantization\n            \"\"\"\n            assert data_item[0].dtype == torch.uint8, \"input image must be uint8 for the quantization preprocessing\"\n\n            img = data_item[0].numpy().astype(np.float32)  # uint8 to fp16/32\n            img /= 255.0  # 0 - 255 to 0.0 - 1.0\n            return np.expand_dims(img, 0) if img.ndim == 3 else img\n\n        ds = gen_dataloader(data)\n        quantization_dataset = nncf.Dataset(ds, transform_fn)\n        ov_model = nncf.quantize(ov_model, quantization_dataset, preset=nncf.QuantizationPreset.MIXED)\n\n    ov.serialize(ov_model, f_ov)  # save\n    yaml_save(Path(f) / file.with_suffix(\".yaml\").name, metadata)  # add metadata.yaml\n    return f, None\n\n\n@try_export\ndef export_paddle(model, im, file, metadata, prefix=colorstr(\"PaddlePaddle:\")):\n    \"\"\"Exports a YOLOv5 model to PaddlePaddle format using X2Paddle, saving to `save_dir` and adding a metadata.yaml\n    file.\n    \"\"\"\n    check_requirements((\"paddlepaddle\", \"x2paddle\"))\n    import x2paddle\n    from x2paddle.convert import pytorch2paddle\n\n    LOGGER.info(f\"\\n{prefix} starting export with X2Paddle {x2paddle.__version__}...\")\n    f = str(file).replace(\".pt\", f\"_paddle_model{os.sep}\")\n\n    pytorch2paddle(module=model, save_dir=f, jit_type=\"trace\", input_examples=[im])  # export\n    yaml_save(Path(f) / file.with_suffix(\".yaml\").name, metadata)  # add metadata.yaml\n    return f, None\n\n\n@try_export\ndef export_coreml(model, im, file, int8, half, nms, prefix=colorstr(\"CoreML:\")):\n    \"\"\"Exports YOLOv5 model to CoreML format with optional NMS, INT8, and FP16 support; requires coremltools.\"\"\"\n    check_requirements(\"coremltools\")\n    import coremltools as ct\n\n    LOGGER.info(f\"\\n{prefix} starting export with coremltools {ct.__version__}...\")\n    f = file.with_suffix(\".mlmodel\")\n\n    if nms:\n        model = iOSModel(model, im)\n    ts = torch.jit.trace(model, im, strict=False)  # TorchScript model\n    ct_model = ct.convert(ts, inputs=[ct.ImageType(\"image\", shape=im.shape, scale=1 / 255, bias=[0, 0, 0])])\n    bits, mode = (8, \"kmeans_lut\") if int8 else (16, \"linear\") if half else (32, None)\n    if bits < 32:\n        if MACOS:  # quantization only supported on macOS\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\", category=DeprecationWarning)  # suppress numpy==1.20 float warning\n                ct_model = ct.models.neural_network.quantization_utils.quantize_weights(ct_model, bits, mode)\n        else:\n            print(f\"{prefix} quantization only supported on macOS, skipping...\")\n    ct_model.save(f)\n    return f, ct_model\n\n\n@try_export\ndef export_engine(model, im, file, half, dynamic, simplify, workspace=4, verbose=False, prefix=colorstr(\"TensorRT:\")):\n    \"\"\"\n    Exports a YOLOv5 model to TensorRT engine format, requiring GPU and TensorRT>=7.0.0.\n\n    https://developer.nvidia.com/tensorrt\n    \"\"\"\n    assert im.device.type != \"cpu\", \"export running on CPU but must be on GPU, i.e. `python export.py --device 0`\"\n    try:\n        import tensorrt as trt\n    except Exception:\n        if platform.system() == \"Linux\":\n            check_requirements(\"nvidia-tensorrt\", cmds=\"-U --index-url https://pypi.ngc.nvidia.com\")\n        import tensorrt as trt\n\n    if trt.__version__[0] == \"7\":  # TensorRT 7 handling https://github.com/ultralytics/yolov5/issues/6012\n        grid = model.model[-1].anchor_grid\n        model.model[-1].anchor_grid = [a[..., :1, :1, :] for a in grid]\n        export_onnx(model, im, file, 12, dynamic, simplify)  # opset 12\n        model.model[-1].anchor_grid = grid\n    else:  # TensorRT >= 8\n        check_version(trt.__version__, \"8.0.0\", hard=True)  # require tensorrt>=8.0.0\n        export_onnx(model, im, file, 12, dynamic, simplify)  # opset 12\n    onnx = file.with_suffix(\".onnx\")\n\n    LOGGER.info(f\"\\n{prefix} starting export with TensorRT {trt.__version__}...\")\n    is_trt10 = int(trt.__version__.split(\".\")[0]) >= 10  # is TensorRT >= 10\n    assert onnx.exists(), f\"failed to export ONNX file: {onnx}\"\n    f = file.with_suffix(\".engine\")  # TensorRT engine file\n    logger = trt.Logger(trt.Logger.INFO)\n    if verbose:\n        logger.min_severity = trt.Logger.Severity.VERBOSE\n\n    builder = trt.Builder(logger)\n    config = builder.create_builder_config()\n    if is_trt10:\n        config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace << 30)\n    else:  # TensorRT versions 7, 8\n        config.max_workspace_size = workspace * 1 << 30\n    flag = 1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)\n    network = builder.create_network(flag)\n    parser = trt.OnnxParser(network, logger)\n    if not parser.parse_from_file(str(onnx)):\n        raise RuntimeError(f\"failed to load ONNX file: {onnx}\")\n\n    inputs = [network.get_input(i) for i in range(network.num_inputs)]\n    outputs = [network.get_output(i) for i in range(network.num_outputs)]\n    for inp in inputs:\n        LOGGER.info(f'{prefix} input \"{inp.name}\" with shape{inp.shape} {inp.dtype}')\n    for out in outputs:\n        LOGGER.info(f'{prefix} output \"{out.name}\" with shape{out.shape} {out.dtype}')\n\n    if dynamic:\n        if im.shape[0] <= 1:\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f --dynamic model requires maximum --batch-size argument\")\n        profile = builder.create_optimization_profile()\n        for inp in inputs:\n            profile.set_shape(inp.name, (1, *im.shape[1:]), (max(1, im.shape[0] // 2), *im.shape[1:]), im.shape)\n        config.add_optimization_profile(profile)\n\n    LOGGER.info(f\"{prefix} building FP{16 if builder.platform_has_fast_fp16 and half else 32} engine as {f}\")\n    if builder.platform_has_fast_fp16 and half:\n        config.set_flag(trt.BuilderFlag.FP16)\n\n    build = builder.build_serialized_network if is_trt10 else builder.build_engine\n    with build(network, config) as engine, open(f, \"wb\") as t:\n        t.write(engine if is_trt10 else engine.serialize())\n    return f, None\n\n\n@try_export\ndef export_saved_model(\n    model,\n    im,\n    file,\n    dynamic,\n    tf_nms=False,\n    agnostic_nms=False,\n    topk_per_class=100,\n    topk_all=100,\n    iou_thres=0.45,\n    conf_thres=0.25,\n    keras=False,\n    prefix=colorstr(\"TensorFlow SavedModel:\"),\n):\n    # YOLOv5 TensorFlow SavedModel export\n    try:\n        import tensorflow as tf\n    except Exception:\n        check_requirements(f\"tensorflow{'' if torch.cuda.is_available() else '-macos' if MACOS else '-cpu'}<=2.15.1\")\n\n        import tensorflow as tf\n    from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\n    from models.tf import TFModel\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    if tf.__version__ > \"2.13.1\":\n        helper_url = \"https://github.com/ultralytics/yolov5/issues/12489\"\n        LOGGER.info(\n            f\"WARNING \u26a0\ufe0f using Tensorflow {tf.__version__} > 2.13.1 might cause issue when exporting the model to tflite {helper_url}\"\n        )  # handling issue https://github.com/ultralytics/yolov5/issues/12489\n    f = str(file).replace(\".pt\", \"_saved_model\")\n    batch_size, ch, *imgsz = list(im.shape)  # BCHW\n\n    tf_model = TFModel(cfg=model.yaml, model=model, nc=model.nc, imgsz=imgsz)\n    im = tf.zeros((batch_size, *imgsz, ch))  # BHWC order for TensorFlow\n    _ = tf_model.predict(im, tf_nms, agnostic_nms, topk_per_class, topk_all, iou_thres, conf_thres)\n    inputs = tf.keras.Input(shape=(*imgsz, ch), batch_size=None if dynamic else batch_size)\n    outputs = tf_model.predict(inputs, tf_nms, agnostic_nms, topk_per_class, topk_all, iou_thres, conf_thres)\n    keras_model = tf.keras.Model(inputs=inputs, outputs=outputs)\n    keras_model.trainable = False\n    keras_model.summary()\n    if keras:\n        keras_model.save(f, save_format=\"tf\")\n    else:\n        spec = tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype)\n        m = tf.function(lambda x: keras_model(x))  # full model\n        m = m.get_concrete_function(spec)\n        frozen_func = convert_variables_to_constants_v2(m)\n        tfm = tf.Module()\n        tfm.__call__ = tf.function(lambda x: frozen_func(x)[:4] if tf_nms else frozen_func(x), [spec])\n        tfm.__call__(im)\n        tf.saved_model.save(\n            tfm,\n            f,\n            options=tf.saved_model.SaveOptions(experimental_custom_gradients=False)\n            if check_version(tf.__version__, \"2.6\")\n            else tf.saved_model.SaveOptions(),\n        )\n    return f, keras_model\n\n\n@try_export\ndef export_pb(keras_model, file, prefix=colorstr(\"TensorFlow GraphDef:\")):\n    \"\"\"Exports YOLOv5 model to TensorFlow GraphDef *.pb format; see https://github.com/leimao/Frozen_Graph_TensorFlow for details.\"\"\"\n    import tensorflow as tf\n    from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    f = file.with_suffix(\".pb\")\n\n    m = tf.function(lambda x: keras_model(x))  # full model\n    m = m.get_concrete_function(tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))\n    frozen_func = convert_variables_to_constants_v2(m)\n    frozen_func.graph.as_graph_def()\n    tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir=str(f.parent), name=f.name, as_text=False)\n    return f, None\n\n\n@try_export\ndef export_tflite(\n    keras_model, im, file, int8, per_tensor, data, nms, agnostic_nms, prefix=colorstr(\"TensorFlow Lite:\")\n):\n    # YOLOv5 TensorFlow Lite export\n    import tensorflow as tf\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    batch_size, ch, *imgsz = list(im.shape)  # BCHW\n    f = str(file).replace(\".pt\", \"-fp16.tflite\")\n\n    converter = tf.lite.TFLiteConverter.from_keras_model(keras_model)\n    converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]\n    converter.target_spec.supported_types = [tf.float16]\n    converter.optimizations = [tf.lite.Optimize.DEFAULT]\n    if int8:\n        from models.tf import representative_dataset_gen\n\n        dataset = LoadImages(check_dataset(check_yaml(data))[\"train\"], img_size=imgsz, auto=False)\n        converter.representative_dataset = lambda: representative_dataset_gen(dataset, ncalib=100)\n        converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]\n        converter.target_spec.supported_types = []\n        converter.inference_input_type = tf.uint8  # or tf.int8\n        converter.inference_output_type = tf.uint8  # or tf.int8\n        converter.experimental_new_quantizer = True\n        if per_tensor:\n            converter._experimental_disable_per_channel = True\n        f = str(file).replace(\".pt\", \"-int8.tflite\")\n    if nms or agnostic_nms:\n        converter.target_spec.supported_ops.append(tf.lite.OpsSet.SELECT_TF_OPS)\n\n    tflite_model = converter.convert()\n    open(f, \"wb\").write(tflite_model)\n    return f, None\n\n\n@try_export\ndef export_edgetpu(file, prefix=colorstr(\"Edge TPU:\")):\n    \"\"\"\n    Exports a YOLOv5 model to Edge TPU compatible TFLite format; requires Linux and Edge TPU compiler.\n\n    https://coral.ai/docs/edgetpu/models-intro/\n    \"\"\"\n    cmd = \"edgetpu_compiler --version\"\n    help_url = \"https://coral.ai/docs/edgetpu/compiler/\"\n    assert platform.system() == \"Linux\", f\"export only supported on Linux. See {help_url}\"\n    if subprocess.run(f\"{cmd} > /dev/null 2>&1\", shell=True).returncode != 0:\n        LOGGER.info(f\"\\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}\")\n        sudo = subprocess.run(\"sudo --version >/dev/null\", shell=True).returncode == 0  # sudo installed on system\n        for c in (\n            \"curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\",\n            'echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee /etc/apt/sources.list.d/coral-edgetpu.list',\n            \"sudo apt-get update\",\n            \"sudo apt-get install edgetpu-compiler\",\n        ):\n            subprocess.run(c if sudo else c.replace(\"sudo \", \"\"), shell=True, check=True)\n    ver = subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1]\n\n    LOGGER.info(f\"\\n{prefix} starting export with Edge TPU compiler {ver}...\")\n    f = str(file).replace(\".pt\", \"-int8_edgetpu.tflite\")  # Edge TPU model\n    f_tfl = str(file).replace(\".pt\", \"-int8.tflite\")  # TFLite model\n\n    subprocess.run(\n        [\n            \"edgetpu_compiler\",\n            \"-s\",\n            \"-d\",\n            \"-k\",\n            \"10\",\n            \"--out_dir\",\n            str(file.parent),\n            f_tfl,\n        ],\n        check=True,\n    )\n    return f, None\n\n\n@try_export\ndef export_tfjs(file, int8, prefix=colorstr(\"TensorFlow.js:\")):\n    \"\"\"Exports a YOLOv5 model to TensorFlow.js format, optionally with uint8 quantization.\"\"\"\n    check_requirements(\"tensorflowjs\")\n    import tensorflowjs as tfjs\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflowjs {tfjs.__version__}...\")\n    f = str(file).replace(\".pt\", \"_web_model\")  # js dir\n    f_pb = file.with_suffix(\".pb\")  # *.pb path\n    f_json = f\"{f}/model.json\"  # *.json path\n\n    args = [\n        \"tensorflowjs_converter\",\n        \"--input_format=tf_frozen_model\",\n        \"--quantize_uint8\" if int8 else \"\",\n        \"--output_node_names=Identity,Identity_1,Identity_2,Identity_3\",\n        str(f_pb),\n        f,\n    ]\n    subprocess.run([arg for arg in args if arg], check=True)\n\n    json = Path(f_json).read_text()\n    with open(f_json, \"w\") as j:  # sort JSON Identity_* in ascending order\n        subst = re.sub(\n            r'{\"outputs\": {\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}}}',\n            r'{\"outputs\": {\"Identity\": {\"name\": \"Identity\"}, '\n            r'\"Identity_1\": {\"name\": \"Identity_1\"}, '\n            r'\"Identity_2\": {\"name\": \"Identity_2\"}, '\n            r'\"Identity_3\": {\"name\": \"Identity_3\"}}}',\n            json,\n        )\n        j.write(subst)\n    return f, None\n\n\ndef add_tflite_metadata(file, metadata, num_outputs):\n    \"\"\"\n    Adds TFLite metadata to a model file, supporting multiple outputs, as specified by TensorFlow guidelines.\n\n    https://www.tensorflow.org/lite/models/convert/metadata\n    \"\"\"\n    with contextlib.suppress(ImportError):\n        # check_requirements('tflite_support')\n        from tflite_support import flatbuffers\n        from tflite_support import metadata as _metadata\n        from tflite_support import metadata_schema_py_generated as _metadata_fb\n\n        tmp_file = Path(\"/tmp/meta.txt\")\n        with open(tmp_file, \"w\") as meta_f:\n            meta_f.write(str(metadata))\n\n        model_meta = _metadata_fb.ModelMetadataT()\n        label_file = _metadata_fb.AssociatedFileT()\n        label_file.name = tmp_file.name\n        model_meta.associatedFiles = [label_file]\n\n        subgraph = _metadata_fb.SubGraphMetadataT()\n        subgraph.inputTensorMetadata = [_metadata_fb.TensorMetadataT()]\n        subgraph.outputTensorMetadata = [_metadata_fb.TensorMetadataT()] * num_outputs\n        model_meta.subgraphMetadata = [subgraph]\n\n        b = flatbuffers.Builder(0)\n        b.Finish(model_meta.Pack(b), _metadata.MetadataPopulator.METADATA_FILE_IDENTIFIER)\n        metadata_buf = b.Output()\n\n        populator = _metadata.MetadataPopulator.with_model_file(file)\n        populator.load_metadata_buffer(metadata_buf)\n        populator.load_associated_files([str(tmp_file)])\n        populator.populate()\n        tmp_file.unlink()\n\n\ndef pipeline_coreml(model, im, file, names, y, prefix=colorstr(\"CoreML Pipeline:\")):\n    \"\"\"Converts a PyTorch YOLOv5 model to CoreML format with NMS, handling different input/output shapes and saving the\n    model.\n    \"\"\"\n    import coremltools as ct\n    from PIL import Image\n\n    print(f\"{prefix} starting pipeline with coremltools {ct.__version__}...\")\n    batch_size, ch, h, w = list(im.shape)  # BCHW\n    t = time.time()\n\n    # YOLOv5 Output shapes\n    spec = model.get_spec()\n    out0, out1 = iter(spec.description.output)\n    if platform.system() == \"Darwin\":\n        img = Image.new(\"RGB\", (w, h))  # img(192 width, 320 height)\n        # img = torch.zeros((*opt.img_size, 3)).numpy()  # img size(320,192,3) iDetection\n        out = model.predict({\"image\": img})\n        out0_shape, out1_shape = out[out0.name].shape, out[out1.name].shape\n    else:  # linux and windows can not run model.predict(), get sizes from pytorch output y\n        s = tuple(y[0].shape)\n        out0_shape, out1_shape = (s[1], s[2] - 5), (s[1], 4)  # (3780, 80), (3780, 4)\n\n    # Checks\n    nx, ny = spec.description.input[0].type.imageType.width, spec.description.input[0].type.imageType.height\n    na, nc = out0_shape\n    # na, nc = out0.type.multiArrayType.shape  # number anchors, classes\n    assert len(names) == nc, f\"{len(names)} names found for nc={nc}\"  # check\n\n    # Define output shapes (missing)\n    out0.type.multiArrayType.shape[:] = out0_shape  # (3780, 80)\n    out1.type.multiArrayType.shape[:] = out1_shape  # (3780, 4)\n    # spec.neuralNetwork.preprocessing[0].featureName = '0'\n\n    # Flexible input shapes\n    # from coremltools.models.neural_network import flexible_shape_utils\n    # s = [] # shapes\n    # s.append(flexible_shape_utils.NeuralNetworkImageSize(320, 192))\n    # s.append(flexible_shape_utils.NeuralNetworkImageSize(640, 384))  # (height, width)\n    # flexible_shape_utils.add_enumerated_image_sizes(spec, feature_name='image', sizes=s)\n    # r = flexible_shape_utils.NeuralNetworkImageSizeRange()  # shape ranges\n    # r.add_height_range((192, 640))\n    # r.add_width_range((192, 640))\n    # flexible_shape_utils.update_image_size_range(spec, feature_name='image', size_range=r)\n\n    # Print\n    print(spec.description)\n\n    # Model from spec\n    model = ct.models.MLModel(spec)\n\n    # 3. Create NMS protobuf\n    nms_spec = ct.proto.Model_pb2.Model()\n    nms_spec.specificationVersion = 5\n    for i in range(2):\n        decoder_output = model._spec.description.output[i].SerializeToString()\n        nms_spec.description.input.add()\n        nms_spec.description.input[i].ParseFromString(decoder_output)\n        nms_spec.description.output.add()\n        nms_spec.description.output[i].ParseFromString(decoder_output)\n\n    nms_spec.description.output[0].name = \"confidence\"\n    nms_spec.description.output[1].name = \"coordinates\"\n\n    output_sizes = [nc, 4]\n    for i in range(2):\n        ma_type = nms_spec.description.output[i].type.multiArrayType\n        ma_type.shapeRange.sizeRanges.add()\n        ma_type.shapeRange.sizeRanges[0].lowerBound = 0\n        ma_type.shapeRange.sizeRanges[0].upperBound = -1\n        ma_type.shapeRange.sizeRanges.add()\n        ma_type.shapeRange.sizeRanges[1].lowerBound = output_sizes[i]\n        ma_type.shapeRange.sizeRanges[1].upperBound = output_sizes[i]\n        del ma_type.shape[:]\n\n    nms = nms_spec.nonMaximumSuppression\n    nms.confidenceInputFeatureName = out0.name  # 1x507x80\n    nms.coordinatesInputFeatureName = out1.name  # 1x507x4\n    nms.confidenceOutputFeatureName = \"confidence\"\n    nms.coordinatesOutputFeatureName = \"coordinates\"\n    nms.iouThresholdInputFeatureName = \"iouThreshold\"\n    nms.confidenceThresholdInputFeatureName = \"confidenceThreshold\"\n    nms.iouThreshold = 0.45\n    nms.confidenceThreshold = 0.25\n    nms.pickTop.perClass = True\n    nms.stringClassLabels.vector.extend(names.values())\n    nms_model = ct.models.MLModel(nms_spec)\n\n    # 4. Pipeline models together\n    pipeline = ct.models.pipeline.Pipeline(\n        input_features=[\n            (\"image\", ct.models.datatypes.Array(3, ny, nx)),\n            (\"iouThreshold\", ct.models.datatypes.Double()),\n            (\"confidenceThreshold\", ct.models.datatypes.Double()),\n        ],\n        output_features=[\"confidence\", \"coordinates\"],\n    )\n    pipeline.add_model(model)\n    pipeline.add_model(nms_model)\n\n    # Correct datatypes\n    pipeline.spec.description.input[0].ParseFromString(model._spec.description.input[0].SerializeToString())\n    pipeline.spec.description.output[0].ParseFromString(nms_model._spec.description.output[0].SerializeToString())\n    pipeline.spec.description.output[1].ParseFromString(nms_model._spec.description.output[1].SerializeToString())\n\n    # Update metadata\n    pipeline.spec.specificationVersion = 5\n    pipeline.spec.description.metadata.versionString = \"https://github.com/ultralytics/yolov5\"\n    pipeline.spec.description.metadata.shortDescription = \"https://github.com/ultralytics/yolov5\"\n    pipeline.spec.description.metadata.author = \"glenn.jocher@ultralytics.com\"\n    pipeline.spec.description.metadata.license = \"https://github.com/ultralytics/yolov5/blob/master/LICENSE\"\n    pipeline.spec.description.metadata.userDefined.update(\n        {\n            \"classes\": \",\".join(names.values()),\n            \"iou_threshold\": str(nms.iouThreshold),\n            \"confidence_threshold\": str(nms.confidenceThreshold),\n        }\n    )\n\n    # Save the model\n    f = file.with_suffix(\".mlmodel\")  # filename\n    model = ct.models.MLModel(pipeline.spec)\n    model.input_description[\"image\"] = \"Input image\"\n    model.input_description[\"iouThreshold\"] = f\"(optional) IOU Threshold override (default: {nms.iouThreshold})\"\n    model.input_description[\"confidenceThreshold\"] = (\n        f\"(optional) Confidence Threshold override (default: {nms.confidenceThreshold})\"\n    )\n    model.output_description[\"confidence\"] = 'Boxes \u00d7 Class confidence (see user-defined metadata \"classes\")'\n    model.output_description[\"coordinates\"] = \"Boxes \u00d7 [x, y, width, height] (relative to image size)\"\n    model.save(f)  # pipelined\n    print(f\"{prefix} pipeline success ({time.time() - t:.2f}s), saved as {f} ({file_size(f):.1f} MB)\")\n\n\n@smart_inference_mode()\ndef run(\n    data=ROOT / \"data/coco128.yaml\",  # 'dataset.yaml path'\n    weights=ROOT / \"yolov5s.pt\",  # weights path\n    imgsz=(640, 640),  # image (height, width)\n    batch_size=1,  # batch size\n    device=\"cpu\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    include=(\"torchscript\", \"onnx\"),  # include formats\n    half=False,  # FP16 half-precision export\n    inplace=False,  # set YOLOv5 Detect() inplace=True\n    keras=False,  # use Keras\n    optimize=False,  # TorchScript: optimize for mobile\n    int8=False,  # CoreML/TF INT8 quantization\n    per_tensor=False,  # TF per tensor quantization\n    dynamic=False,  # ONNX/TF/TensorRT: dynamic axes\n    simplify=False,  # ONNX: simplify model\n    opset=12,  # ONNX: opset version\n    verbose=False,  # TensorRT: verbose log\n    workspace=4,  # TensorRT: workspace size (GB)\n    nms=False,  # TF: add NMS to model\n    agnostic_nms=False,  # TF: add agnostic NMS to model\n    topk_per_class=100,  # TF.js NMS: topk per class to keep\n    topk_all=100,  # TF.js NMS: topk for all classes to keep\n    iou_thres=0.45,  # TF.js NMS: IoU threshold\n    conf_thres=0.25,  # TF.js NMS: confidence threshold\n):\n    t = time.time()\n    include = [x.lower() for x in include]  # to lowercase\n    fmts = tuple(export_formats()[\"Argument\"][1:])  # --include arguments\n    flags = [x in include for x in fmts]\n    assert sum(flags) == len(include), f\"ERROR: Invalid --include {include}, valid --include arguments are {fmts}\"\n    jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle = flags  # export booleans\n    file = Path(url2file(weights) if str(weights).startswith((\"http:/\", \"https:/\")) else weights)  # PyTorch weights\n\n    # Load PyTorch model\n    device = select_device(device)\n    if half:\n        assert device.type != \"cpu\" or coreml, \"--half only compatible with GPU export, i.e. use --device 0\"\n        assert not dynamic, \"--half not compatible with --dynamic, i.e. use either --half or --dynamic but not both\"\n    model = attempt_load(weights, device=device, inplace=True, fuse=True)  # load FP32 model\n\n    # Checks\n    imgsz *= 2 if len(imgsz) == 1 else 1  # expand\n    if optimize:\n        assert device.type == \"cpu\", \"--optimize not compatible with cuda devices, i.e. use --device cpu\"\n\n    # Input\n    gs = int(max(model.stride))  # grid size (max stride)\n    imgsz = [check_img_size(x, gs) for x in imgsz]  # verify img_size are gs-multiples\n    im = torch.zeros(batch_size, 3, *imgsz).to(device)  # image size(1,3,320,192) BCHW iDetection\n\n    # Update model\n    model.eval()\n    for k, m in model.named_modules():\n        if isinstance(m, Detect):\n            m.inplace = inplace\n            m.dynamic = dynamic\n            m.export = True\n\n    for _ in range(2):\n        y = model(im)  # dry runs\n    if half and not coreml:\n        im, model = im.half(), model.half()  # to FP16\n    shape = tuple((y[0] if isinstance(y, tuple) else y).shape)  # model output shape\n    metadata = {\"stride\": int(max(model.stride)), \"names\": model.names}  # model metadata\n    LOGGER.info(f\"\\n{colorstr('PyTorch:')} starting from {file} with output shape {shape} ({file_size(file):.1f} MB)\")\n\n    # Exports\n    f = [\"\"] * len(fmts)  # exported filenames\n    warnings.filterwarnings(action=\"ignore\", category=torch.jit.TracerWarning)  # suppress TracerWarning\n    if jit:  # TorchScript\n        f[0], _ = export_torchscript(model, im, file, optimize)\n    if engine:  # TensorRT required before ONNX\n        f[1], _ = export_engine(model, im, file, half, dynamic, simplify, workspace, verbose)\n    if onnx or xml:  # OpenVINO requires ONNX\n        f[2], _ = export_onnx(model, im, file, opset, dynamic, simplify)\n    if xml:  # OpenVINO\n        f[3], _ = export_openvino(file, metadata, half, int8, data)\n    if coreml:  # CoreML\n        f[4], ct_model = export_coreml(model, im, file, int8, half, nms)\n        if nms:\n            pipeline_coreml(ct_model, im, file, model.names, y)\n    if any((saved_model, pb, tflite, edgetpu, tfjs)):  # TensorFlow formats\n        assert not tflite or not tfjs, \"TFLite and TF.js models must be exported separately, please pass only one type.\"\n        assert not isinstance(model, ClassificationModel), \"ClassificationModel export to TF formats not yet supported.\"\n        f[5], s_model = export_saved_model(\n            model.cpu(),\n            im,\n            file,\n            dynamic,\n            tf_nms=nms or agnostic_nms or tfjs,\n            agnostic_nms=agnostic_nms or tfjs,\n            topk_per_class=topk_per_class,\n            topk_all=topk_all,\n            iou_thres=iou_thres,\n            conf_thres=conf_thres,\n            keras=keras,\n        )\n        if pb or tfjs:  # pb prerequisite to tfjs\n            f[6], _ = export_pb(s_model, file)\n        if tflite or edgetpu:\n            f[7], _ = export_tflite(\n                s_model, im, file, int8 or edgetpu, per_tensor, data=data, nms=nms, agnostic_nms=agnostic_nms\n            )\n            if edgetpu:\n                f[8], _ = export_edgetpu(file)\n            add_tflite_metadata(f[8] or f[7], metadata, num_outputs=len(s_model.outputs))\n        if tfjs:\n            f[9], _ = export_tfjs(file, int8)\n    if paddle:  # PaddlePaddle\n        f[10], _ = export_paddle(model, im, file, metadata)\n\n    # Finish\n    f = [str(x) for x in f if x]  # filter out '' and None\n    if any(f):\n        cls, det, seg = (isinstance(model, x) for x in (ClassificationModel, DetectionModel, SegmentationModel))  # type\n        det &= not seg  # segmentation models inherit from SegmentationModel(DetectionModel)\n        dir = Path(\"segment\" if seg else \"classify\" if cls else \"\")\n        h = \"--half\" if half else \"\"  # --half FP16 inference arg\n        s = (\n            \"# WARNING \u26a0\ufe0f ClassificationModel not yet supported for PyTorch Hub AutoShape inference\"\n            if cls\n            else \"# WARNING \u26a0\ufe0f SegmentationModel not yet supported for PyTorch Hub AutoShape inference\"\n            if seg\n            else \"\"\n        )\n        LOGGER.info(\n            f'\\nExport complete ({time.time() - t:.1f}s)'\n            f\"\\nResults saved to {colorstr('bold', file.parent.resolve())}\"\n            f\"\\nDetect:          python {dir / ('detect.py' if det else 'predict.py')} --weights {f[-1]} {h}\"\n            f\"\\nValidate:        python {dir / 'val.py'} --weights {f[-1]} {h}\"\n            f\"\\nPyTorch Hub:     model = torch.hub.load('ultralytics/yolov5', 'custom', '{f[-1]}')  {s}\"\n            f'\\nVisualize:       https://netron.app'\n        )\n    return f  # return list of exported files/dirs\n\n\ndef parse_opt(known=False):\n    \"\"\"Parses command-line arguments for YOLOv5 model export configurations, returning the parsed options.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s.pt\", help=\"model.pt path(s)\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", nargs=\"+\", type=int, default=[640, 640], help=\"image (h, w)\")\n    parser.add_argument(\"--batch-size\", type=int, default=1, help=\"batch size\")\n    parser.add_argument(\"--device\", default=\"cpu\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"FP16 half-precision export\")\n    parser.add_argument(\"--inplace\", action=\"store_true\", help=\"set YOLOv5 Detect() inplace=True\")\n    parser.add_argument(\"--keras\", action=\"store_true\", help=\"TF: use Keras\")\n    parser.add_argument(\"--optimize\", action=\"store_true\", help=\"TorchScript: optimize for mobile\")\n    parser.add_argument(\"--int8\", action=\"store_true\", help=\"CoreML/TF/OpenVINO INT8 quantization\")\n    parser.add_argument(\"--per-tensor\", action=\"store_true\", help=\"TF per-tensor quantization\")\n    parser.add_argument(\"--dynamic\", action=\"store_true\", help=\"ONNX/TF/TensorRT: dynamic axes\")\n    parser.add_argument(\"--simplify\", action=\"store_true\", help=\"ONNX: simplify model\")\n    parser.add_argument(\"--opset\", type=int, default=17, help=\"ONNX: opset version\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"TensorRT: verbose log\")\n    parser.add_argument(\"--workspace\", type=int, default=4, help=\"TensorRT: workspace size (GB)\")\n    parser.add_argument(\"--nms\", action=\"store_true\", help=\"TF: add NMS to model\")\n    parser.add_argument(\"--agnostic-nms\", action=\"store_true\", help=\"TF: add agnostic NMS to model\")\n    parser.add_argument(\"--topk-per-class\", type=int, default=100, help=\"TF.js NMS: topk per class to keep\")\n    parser.add_argument(\"--topk-all\", type=int, default=100, help=\"TF.js NMS: topk for all classes to keep\")\n    parser.add_argument(\"--iou-thres\", type=float, default=0.45, help=\"TF.js NMS: IoU threshold\")\n    parser.add_argument(\"--conf-thres\", type=float, default=0.25, help=\"TF.js NMS: confidence threshold\")\n    parser.add_argument(\n        \"--include\",\n        nargs=\"+\",\n        default=[\"torchscript\"],\n        help=\"torchscript, onnx, openvino, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle\",\n    )\n    opt = parser.parse_known_args()[0] if known else parser.parse_args()\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes the YOLOv5 model inference or export with specified weights and options.\"\"\"\n    for opt.weights in opt.weights if isinstance(opt.weights, list) else [opt.weights]:\n        run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "models/common.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Common modules.\"\"\"\n\nimport ast\nimport contextlib\nimport json\nimport math\nimport platform\nimport warnings\nimport zipfile\nfrom collections import OrderedDict, namedtuple\nfrom copy import copy\nfrom pathlib import Path\nfrom urllib.parse import urlparse\n\nimport cv2\nimport numpy as np\nimport pandas as pd\nimport requests\nimport torch\nimport torch.nn as nn\nfrom PIL import Image\nfrom torch.cuda import amp\n\n# Import 'ultralytics' package or install if missing\ntry:\n    import ultralytics\n\n    assert hasattr(ultralytics, \"__version__\")  # verify package is not directory\nexcept (ImportError, AssertionError):\n    import os\n\n    os.system(\"pip install -U ultralytics\")\n    import ultralytics\n\nfrom ultralytics.utils.plotting import Annotator, colors, save_one_box\n\nfrom utils import TryExcept\nfrom utils.dataloaders import exif_transpose, letterbox\nfrom utils.general import (\n    LOGGER,\n    ROOT,\n    Profile,\n    check_requirements,\n    check_suffix,\n    check_version,\n    colorstr,\n    increment_path,\n    is_jupyter,\n    make_divisible,\n    non_max_suppression,\n    scale_boxes,\n    xywh2xyxy,\n    xyxy2xywh,\n    yaml_load,\n)\nfrom utils.torch_utils import copy_attr, smart_inference_mode\n\n\ndef autopad(k, p=None, d=1):\n    \"\"\"\n    Pads kernel to 'same' output shape, adjusting for optional dilation; returns padding size.\n\n    `k`: kernel, `p`: padding, `d`: dilation.\n    \"\"\"\n    if d > 1:\n        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size\n    if p is None:\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\n    return p\n\n\nclass Conv(nn.Module):\n    # Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation)\n    default_act = nn.SiLU()  # default activation\n\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initializes a standard convolution layer with optional batch normalization and activation.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Applies a convolution followed by batch normalization and an activation function to the input tensor `x`.\"\"\"\n        return self.act(self.bn(self.conv(x)))\n\n    def forward_fuse(self, x):\n        \"\"\"Applies a fused convolution and activation function to the input tensor `x`.\"\"\"\n        return self.act(self.conv(x))\n\n\nclass DWConv(Conv):\n    # Depth-wise convolution\n    def __init__(self, c1, c2, k=1, s=1, d=1, act=True):\n        \"\"\"Initializes a depth-wise convolution layer with optional activation; args: input channels (c1), output\n        channels (c2), kernel size (k), stride (s), dilation (d), and activation flag (act).\n        \"\"\"\n        super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)\n\n\nclass DWConvTranspose2d(nn.ConvTranspose2d):\n    # Depth-wise transpose convolution\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):\n        \"\"\"Initializes a depth-wise transpose convolutional layer for YOLOv5; args: input channels (c1), output channels\n        (c2), kernel size (k), stride (s), input padding (p1), output padding (p2).\n        \"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))\n\n\nclass TransformerLayer(nn.Module):\n    # Transformer layer https://arxiv.org/abs/2010.11929 (LayerNorm layers removed for better performance)\n    def __init__(self, c, num_heads):\n        \"\"\"\n        Initializes a transformer layer, sans LayerNorm for performance, with multihead attention and linear layers.\n\n        See  as described in https://arxiv.org/abs/2010.11929.\n        \"\"\"\n        super().__init__()\n        self.q = nn.Linear(c, c, bias=False)\n        self.k = nn.Linear(c, c, bias=False)\n        self.v = nn.Linear(c, c, bias=False)\n        self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n        self.fc1 = nn.Linear(c, c, bias=False)\n        self.fc2 = nn.Linear(c, c, bias=False)\n\n    def forward(self, x):\n        \"\"\"Performs forward pass using MultiheadAttention and two linear transformations with residual connections.\"\"\"\n        x = self.ma(self.q(x), self.k(x), self.v(x))[0] + x\n        x = self.fc2(self.fc1(x)) + x\n        return x\n\n\nclass TransformerBlock(nn.Module):\n    # Vision Transformer https://arxiv.org/abs/2010.11929\n    def __init__(self, c1, c2, num_heads, num_layers):\n        \"\"\"Initializes a Transformer block for vision tasks, adapting dimensions if necessary and stacking specified\n        layers.\n        \"\"\"\n        super().__init__()\n        self.conv = None\n        if c1 != c2:\n            self.conv = Conv(c1, c2)\n        self.linear = nn.Linear(c2, c2)  # learnable position embedding\n        self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))\n        self.c2 = c2\n\n    def forward(self, x):\n        \"\"\"Processes input through an optional convolution, followed by Transformer layers and position embeddings for\n        object detection.\n        \"\"\"\n        if self.conv is not None:\n            x = self.conv(x)\n        b, _, w, h = x.shape\n        p = x.flatten(2).permute(2, 0, 1)\n        return self.tr(p + self.linear(p)).permute(1, 2, 0).reshape(b, self.c2, w, h)\n\n\nclass Bottleneck(nn.Module):\n    # Standard bottleneck\n    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes a standard bottleneck layer with optional shortcut and group convolution, supporting channel\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_, c2, 3, 1, g=g)\n        self.add = shortcut and c1 == c2\n\n    def forward(self, x):\n        \"\"\"Processes input through two convolutions, optionally adds shortcut if channel dimensions match; input is a\n        tensor.\n        \"\"\"\n        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))\n\n\nclass BottleneckCSP(nn.Module):\n    # CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes CSP bottleneck with optional shortcuts; args: ch_in, ch_out, number of repeats, shortcut bool,\n        groups, expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n        self.cv4 = Conv(2 * c_, c2, 1, 1)\n        self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)\n        self.act = nn.SiLU()\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Performs forward pass by applying layers, activation, and concatenation on input x, returning feature-\n        enhanced output.\n        \"\"\"\n        y1 = self.cv3(self.m(self.cv1(x)))\n        y2 = self.cv2(x)\n        return self.cv4(self.act(self.bn(torch.cat((y1, y2), 1))))\n\n\nclass CrossConv(nn.Module):\n    # Cross Convolution Downsample\n    def __init__(self, c1, c2, k=3, s=1, g=1, e=1.0, shortcut=False):\n        \"\"\"\n        Initializes CrossConv with downsampling, expanding, and optionally shortcutting; `c1` input, `c2` output\n        channels.\n\n        Inputs are ch_in, ch_out, kernel, stride, groups, expansion, shortcut.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, (1, k), (1, s))\n        self.cv2 = Conv(c_, c2, (k, 1), (s, 1), g=g)\n        self.add = shortcut and c1 == c2\n\n    def forward(self, x):\n        \"\"\"Performs feature sampling, expanding, and applies shortcut if channels match; expects `x` input tensor.\"\"\"\n        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))\n\n\nclass C3(nn.Module):\n    # CSP Bottleneck with 3 convolutions\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes C3 module with options for channel count, bottleneck repetition, shortcut usage, group\n        convolutions, and expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Performs forward propagation using concatenated outputs from two convolutions and a Bottleneck sequence.\"\"\"\n        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))\n\n\nclass C3x(C3):\n    # C3 module with cross-convolutions\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes C3x module with cross-convolutions, extending C3 with customizable channel dimensions, groups,\n        and expansion.\n        \"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = nn.Sequential(*(CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)))\n\n\nclass C3TR(C3):\n    # C3 module with TransformerBlock()\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes C3 module with TransformerBlock for enhanced feature extraction, accepts channel sizes, shortcut\n        config, group, and expansion.\n        \"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = TransformerBlock(c_, c_, 4, n)\n\n\nclass C3SPP(C3):\n    # C3 module with SPP()\n    def __init__(self, c1, c2, k=(5, 9, 13), n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes a C3 module with SPP layer for advanced spatial feature extraction, given channel sizes, kernel\n        sizes, shortcut, group, and expansion ratio.\n        \"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = SPP(c_, c_, k)\n\n\nclass C3Ghost(C3):\n    # C3 module with GhostBottleneck()\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes YOLOv5's C3 module with Ghost Bottlenecks for efficient feature extraction.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)  # hidden channels\n        self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))\n\n\nclass SPP(nn.Module):\n    # Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729\n    def __init__(self, c1, c2, k=(5, 9, 13)):\n        \"\"\"Initializes SPP layer with Spatial Pyramid Pooling, ref: https://arxiv.org/abs/1406.4729, args: c1 (input channels), c2 (output channels), k (kernel sizes).\"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])\n\n    def forward(self, x):\n        \"\"\"Applies convolution and max pooling layers to the input tensor `x`, concatenates results, and returns output\n        tensor.\n        \"\"\"\n        x = self.cv1(x)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")  # suppress torch 1.9.0 max_pool2d() warning\n            return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))\n\n\nclass SPPF(nn.Module):\n    # Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher\n    def __init__(self, c1, c2, k=5):\n        \"\"\"\n        Initializes YOLOv5 SPPF layer with given channels and kernel size for YOLOv5 model, combining convolution and\n        max pooling.\n\n        Equivalent to SPP(k=(5, 9, 13)).\n        \"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * 4, c2, 1, 1)\n        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n\n    def forward(self, x):\n        \"\"\"Processes input through a series of convolutions and max pooling operations for feature extraction.\"\"\"\n        x = self.cv1(x)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")  # suppress torch 1.9.0 max_pool2d() warning\n            y1 = self.m(x)\n            y2 = self.m(y1)\n            return self.cv2(torch.cat((x, y1, y2, self.m(y2)), 1))\n\n\nclass Focus(nn.Module):\n    # Focus wh information into c-space\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):\n        \"\"\"Initializes Focus module to concentrate width-height info into channel space with configurable convolution\n        parameters.\n        \"\"\"\n        super().__init__()\n        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)\n        # self.contract = Contract(gain=2)\n\n    def forward(self, x):\n        \"\"\"Processes input through Focus mechanism, reshaping (b,c,w,h) to (b,4c,w/2,h/2) then applies convolution.\"\"\"\n        return self.conv(torch.cat((x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]), 1))\n        # return self.conv(self.contract(x))\n\n\nclass GhostConv(nn.Module):\n    # Ghost Convolution https://github.com/huawei-noah/ghostnet\n    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\n        \"\"\"Initializes GhostConv with in/out channels, kernel size, stride, groups, and activation; halves out channels\n        for efficiency.\n        \"\"\"\n        super().__init__()\n        c_ = c2 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)\n\n    def forward(self, x):\n        \"\"\"Performs forward pass, concatenating outputs of two convolutions on input `x`: shape (B,C,H,W).\"\"\"\n        y = self.cv1(x)\n        return torch.cat((y, self.cv2(y)), 1)\n\n\nclass GhostBottleneck(nn.Module):\n    # Ghost Bottleneck https://github.com/huawei-noah/ghostnet\n    def __init__(self, c1, c2, k=3, s=1):\n        \"\"\"Initializes GhostBottleneck with ch_in `c1`, ch_out `c2`, kernel size `k`, stride `s`; see https://github.com/huawei-noah/ghostnet.\"\"\"\n        super().__init__()\n        c_ = c2 // 2\n        self.conv = nn.Sequential(\n            GhostConv(c1, c_, 1, 1),  # pw\n            DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n            GhostConv(c_, c2, 1, 1, act=False),\n        )  # pw-linear\n        self.shortcut = (\n            nn.Sequential(DWConv(c1, c1, k, s, act=False), Conv(c1, c2, 1, 1, act=False)) if s == 2 else nn.Identity()\n        )\n\n    def forward(self, x):\n        \"\"\"Processes input through conv and shortcut layers, returning their summed output.\"\"\"\n        return self.conv(x) + self.shortcut(x)\n\n\nclass Contract(nn.Module):\n    # Contract width-height into channels, i.e. x(1,64,80,80) to x(1,256,40,40)\n    def __init__(self, gain=2):\n        \"\"\"Initializes a layer to contract spatial dimensions (width-height) into channels, e.g., input shape\n        (1,64,80,80) to (1,256,40,40).\n        \"\"\"\n        super().__init__()\n        self.gain = gain\n\n    def forward(self, x):\n        \"\"\"Processes input tensor to expand channel dimensions by contracting spatial dimensions, yielding output shape\n        `(b, c*s*s, h//s, w//s)`.\n        \"\"\"\n        b, c, h, w = x.size()  # assert (h / s == 0) and (W / s == 0), 'Indivisible gain'\n        s = self.gain\n        x = x.view(b, c, h // s, s, w // s, s)  # x(1,64,40,2,40,2)\n        x = x.permute(0, 3, 5, 1, 2, 4).contiguous()  # x(1,2,2,64,40,40)\n        return x.view(b, c * s * s, h // s, w // s)  # x(1,256,40,40)\n\n\nclass Expand(nn.Module):\n    # Expand channels into width-height, i.e. x(1,64,80,80) to x(1,16,160,160)\n    def __init__(self, gain=2):\n        \"\"\"\n        Initializes the Expand module to increase spatial dimensions by redistributing channels, with an optional gain\n        factor.\n\n        Example: x(1,64,80,80) to x(1,16,160,160).\n        \"\"\"\n        super().__init__()\n        self.gain = gain\n\n    def forward(self, x):\n        \"\"\"Processes input tensor x to expand spatial dimensions by redistributing channels, requiring C / gain^2 ==\n        0.\n        \"\"\"\n        b, c, h, w = x.size()  # assert C / s ** 2 == 0, 'Indivisible gain'\n        s = self.gain\n        x = x.view(b, s, s, c // s**2, h, w)  # x(1,2,2,16,80,80)\n        x = x.permute(0, 3, 4, 1, 5, 2).contiguous()  # x(1,16,80,2,80,2)\n        return x.view(b, c // s**2, h * s, w * s)  # x(1,16,160,160)\n\n\nclass Concat(nn.Module):\n    # Concatenate a list of tensors along dimension\n    def __init__(self, dimension=1):\n        \"\"\"Initializes a Concat module to concatenate tensors along a specified dimension.\"\"\"\n        super().__init__()\n        self.d = dimension\n\n    def forward(self, x):\n        \"\"\"Concatenates a list of tensors along a specified dimension; `x` is a list of tensors, `dimension` is an\n        int.\n        \"\"\"\n        return torch.cat(x, self.d)\n\n\nclass DetectMultiBackend(nn.Module):\n    # YOLOv5 MultiBackend class for python inference on various backends\n    def __init__(self, weights=\"yolov5s.pt\", device=torch.device(\"cpu\"), dnn=False, data=None, fp16=False, fuse=True):\n        \"\"\"Initializes DetectMultiBackend with support for various inference backends, including PyTorch and ONNX.\"\"\"\n        #   PyTorch:              weights = *.pt\n        #   TorchScript:                    *.torchscript\n        #   ONNX Runtime:                   *.onnx\n        #   ONNX OpenCV DNN:                *.onnx --dnn\n        #   OpenVINO:                       *_openvino_model\n        #   CoreML:                         *.mlmodel\n        #   TensorRT:                       *.engine\n        #   TensorFlow SavedModel:          *_saved_model\n        #   TensorFlow GraphDef:            *.pb\n        #   TensorFlow Lite:                *.tflite\n        #   TensorFlow Edge TPU:            *_edgetpu.tflite\n        #   PaddlePaddle:                   *_paddle_model\n        from models.experimental import attempt_download, attempt_load  # scoped to avoid circular import\n\n        super().__init__()\n        w = str(weights[0] if isinstance(weights, list) else weights)\n        pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, triton = self._model_type(w)\n        fp16 &= pt or jit or onnx or engine or triton  # FP16\n        nhwc = coreml or saved_model or pb or tflite or edgetpu  # BHWC formats (vs torch BCWH)\n        stride = 32  # default stride\n        cuda = torch.cuda.is_available() and device.type != \"cpu\"  # use CUDA\n        if not (pt or triton):\n            w = attempt_download(w)  # download if not local\n\n        if pt:  # PyTorch\n            model = attempt_load(weights if isinstance(weights, list) else w, device=device, inplace=True, fuse=fuse)\n            stride = max(int(model.stride.max()), 32)  # model stride\n            names = model.module.names if hasattr(model, \"module\") else model.names  # get class names\n            model.half() if fp16 else model.float()\n            self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n        elif jit:  # TorchScript\n            LOGGER.info(f\"Loading {w} for TorchScript inference...\")\n            extra_files = {\"config.txt\": \"\"}  # model metadata\n            model = torch.jit.load(w, _extra_files=extra_files, map_location=device)\n            model.half() if fp16 else model.float()\n            if extra_files[\"config.txt\"]:  # load metadata dict\n                d = json.loads(\n                    extra_files[\"config.txt\"],\n                    object_hook=lambda d: {int(k) if k.isdigit() else k: v for k, v in d.items()},\n                )\n                stride, names = int(d[\"stride\"]), d[\"names\"]\n        elif dnn:  # ONNX OpenCV DNN\n            LOGGER.info(f\"Loading {w} for ONNX OpenCV DNN inference...\")\n            check_requirements(\"opencv-python>=4.5.4\")\n            net = cv2.dnn.readNetFromONNX(w)\n        elif onnx:  # ONNX Runtime\n            LOGGER.info(f\"Loading {w} for ONNX Runtime inference...\")\n            check_requirements((\"onnx\", \"onnxruntime-gpu\" if cuda else \"onnxruntime\"))\n            import onnxruntime\n\n            providers = [\"CUDAExecutionProvider\", \"CPUExecutionProvider\"] if cuda else [\"CPUExecutionProvider\"]\n            session = onnxruntime.InferenceSession(w, providers=providers)\n            output_names = [x.name for x in session.get_outputs()]\n            meta = session.get_modelmeta().custom_metadata_map  # metadata\n            if \"stride\" in meta:\n                stride, names = int(meta[\"stride\"]), eval(meta[\"names\"])\n        elif xml:  # OpenVINO\n            LOGGER.info(f\"Loading {w} for OpenVINO inference...\")\n            check_requirements(\"openvino>=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n            from openvino.runtime import Core, Layout, get_batch\n\n            core = Core()\n            if not Path(w).is_file():  # if not *.xml\n                w = next(Path(w).glob(\"*.xml\"))  # get *.xml file from *_openvino_model dir\n            ov_model = core.read_model(model=w, weights=Path(w).with_suffix(\".bin\"))\n            if ov_model.get_parameters()[0].get_layout().empty:\n                ov_model.get_parameters()[0].set_layout(Layout(\"NCHW\"))\n            batch_dim = get_batch(ov_model)\n            if batch_dim.is_static:\n                batch_size = batch_dim.get_length()\n            ov_compiled_model = core.compile_model(ov_model, device_name=\"AUTO\")  # AUTO selects best available device\n            stride, names = self._load_metadata(Path(w).with_suffix(\".yaml\"))  # load metadata\n        elif engine:  # TensorRT\n            LOGGER.info(f\"Loading {w} for TensorRT inference...\")\n            import tensorrt as trt  # https://developer.nvidia.com/nvidia-tensorrt-download\n\n            check_version(trt.__version__, \"7.0.0\", hard=True)  # require tensorrt>=7.0.0\n            if device.type == \"cpu\":\n                device = torch.device(\"cuda:0\")\n            Binding = namedtuple(\"Binding\", (\"name\", \"dtype\", \"shape\", \"data\", \"ptr\"))\n            logger = trt.Logger(trt.Logger.INFO)\n            with open(w, \"rb\") as f, trt.Runtime(logger) as runtime:\n                model = runtime.deserialize_cuda_engine(f.read())\n            context = model.create_execution_context()\n            bindings = OrderedDict()\n            output_names = []\n            fp16 = False  # default updated below\n            dynamic = False\n            is_trt10 = not hasattr(model, \"num_bindings\")\n            num = range(model.num_io_tensors) if is_trt10 else range(model.num_bindings)\n            for i in num:\n                if is_trt10:\n                    name = model.get_tensor_name(i)\n                    dtype = trt.nptype(model.get_tensor_dtype(name))\n                    is_input = model.get_tensor_mode(name) == trt.TensorIOMode.INPUT\n                    if is_input:\n                        if -1 in tuple(model.get_tensor_shape(name)):  # dynamic\n                            dynamic = True\n                            context.set_input_shape(name, tuple(model.get_profile_shape(name, 0)[2]))\n                        if dtype == np.float16:\n                            fp16 = True\n                    else:  # output\n                        output_names.append(name)\n                    shape = tuple(context.get_tensor_shape(name))\n                else:\n                    name = model.get_binding_name(i)\n                    dtype = trt.nptype(model.get_binding_dtype(i))\n                    if model.binding_is_input(i):\n                        if -1 in tuple(model.get_binding_shape(i)):  # dynamic\n                            dynamic = True\n                            context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[2]))\n                        if dtype == np.float16:\n                            fp16 = True\n                    else:  # output\n                        output_names.append(name)\n                    shape = tuple(context.get_binding_shape(i))\n                im = torch.from_numpy(np.empty(shape, dtype=dtype)).to(device)\n                bindings[name] = Binding(name, dtype, shape, im, int(im.data_ptr()))\n            binding_addrs = OrderedDict((n, d.ptr) for n, d in bindings.items())\n            batch_size = bindings[\"images\"].shape[0]  # if dynamic, this is instead max batch size\n        elif coreml:  # CoreML\n            LOGGER.info(f\"Loading {w} for CoreML inference...\")\n            import coremltools as ct\n\n            model = ct.models.MLModel(w)\n        elif saved_model:  # TF SavedModel\n            LOGGER.info(f\"Loading {w} for TensorFlow SavedModel inference...\")\n            import tensorflow as tf\n\n            keras = False  # assume TF1 saved_model\n            model = tf.keras.models.load_model(w) if keras else tf.saved_model.load(w)\n        elif pb:  # GraphDef https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt\n            LOGGER.info(f\"Loading {w} for TensorFlow GraphDef inference...\")\n            import tensorflow as tf\n\n            def wrap_frozen_graph(gd, inputs, outputs):\n                \"\"\"Wraps a TensorFlow GraphDef for inference, returning a pruned function.\"\"\"\n                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=\"\"), [])  # wrapped\n                ge = x.graph.as_graph_element\n                return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))\n\n            def gd_outputs(gd):\n                \"\"\"Generates a sorted list of graph outputs excluding NoOp nodes and inputs, formatted as '<name>:0'.\"\"\"\n                name_list, input_list = [], []\n                for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n                    name_list.append(node.name)\n                    input_list.extend(node.input)\n                return sorted(f\"{x}:0\" for x in list(set(name_list) - set(input_list)) if not x.startswith(\"NoOp\"))\n\n            gd = tf.Graph().as_graph_def()  # TF GraphDef\n            with open(w, \"rb\") as f:\n                gd.ParseFromString(f.read())\n            frozen_func = wrap_frozen_graph(gd, inputs=\"x:0\", outputs=gd_outputs(gd))\n        elif tflite or edgetpu:  # https://www.tensorflow.org/lite/guide/python#install_tensorflow_lite_for_python\n            try:  # https://coral.ai/docs/edgetpu/tflite-python/#update-existing-tf-lite-code-for-the-edge-tpu\n                from tflite_runtime.interpreter import Interpreter, load_delegate\n            except ImportError:\n                import tensorflow as tf\n\n                Interpreter, load_delegate = (\n                    tf.lite.Interpreter,\n                    tf.lite.experimental.load_delegate,\n                )\n            if edgetpu:  # TF Edge TPU https://coral.ai/software/#edgetpu-runtime\n                LOGGER.info(f\"Loading {w} for TensorFlow Lite Edge TPU inference...\")\n                delegate = {\"Linux\": \"libedgetpu.so.1\", \"Darwin\": \"libedgetpu.1.dylib\", \"Windows\": \"edgetpu.dll\"}[\n                    platform.system()\n                ]\n                interpreter = Interpreter(model_path=w, experimental_delegates=[load_delegate(delegate)])\n            else:  # TFLite\n                LOGGER.info(f\"Loading {w} for TensorFlow Lite inference...\")\n                interpreter = Interpreter(model_path=w)  # load TFLite model\n            interpreter.allocate_tensors()  # allocate\n            input_details = interpreter.get_input_details()  # inputs\n            output_details = interpreter.get_output_details()  # outputs\n            # load metadata\n            with contextlib.suppress(zipfile.BadZipFile):\n                with zipfile.ZipFile(w, \"r\") as model:\n                    meta_file = model.namelist()[0]\n                    meta = ast.literal_eval(model.read(meta_file).decode(\"utf-8\"))\n                    stride, names = int(meta[\"stride\"]), meta[\"names\"]\n        elif tfjs:  # TF.js\n            raise NotImplementedError(\"ERROR: YOLOv5 TF.js inference is not supported\")\n        elif paddle:  # PaddlePaddle\n            LOGGER.info(f\"Loading {w} for PaddlePaddle inference...\")\n            check_requirements(\"paddlepaddle-gpu\" if cuda else \"paddlepaddle\")\n            import paddle.inference as pdi\n\n            if not Path(w).is_file():  # if not *.pdmodel\n                w = next(Path(w).rglob(\"*.pdmodel\"))  # get *.pdmodel file from *_paddle_model dir\n            weights = Path(w).with_suffix(\".pdiparams\")\n            config = pdi.Config(str(w), str(weights))\n            if cuda:\n                config.enable_use_gpu(memory_pool_init_size_mb=2048, device_id=0)\n            predictor = pdi.create_predictor(config)\n            input_handle = predictor.get_input_handle(predictor.get_input_names()[0])\n            output_names = predictor.get_output_names()\n        elif triton:  # NVIDIA Triton Inference Server\n            LOGGER.info(f\"Using {w} as Triton Inference Server...\")\n            check_requirements(\"tritonclient[all]\")\n            from utils.triton import TritonRemoteModel\n\n            model = TritonRemoteModel(url=w)\n            nhwc = model.runtime.startswith(\"tensorflow\")\n        else:\n            raise NotImplementedError(f\"ERROR: {w} is not a supported format\")\n\n        # class names\n        if \"names\" not in locals():\n            names = yaml_load(data)[\"names\"] if data else {i: f\"class{i}\" for i in range(999)}\n        if names[0] == \"n01440764\" and len(names) == 1000:  # ImageNet\n            names = yaml_load(ROOT / \"data/ImageNet.yaml\")[\"names\"]  # human-readable names\n\n        self.__dict__.update(locals())  # assign all variables to self\n\n    def forward(self, im, augment=False, visualize=False):\n        \"\"\"Performs YOLOv5 inference on input images with options for augmentation and visualization.\"\"\"\n        b, ch, h, w = im.shape  # batch, channel, height, width\n        if self.fp16 and im.dtype != torch.float16:\n            im = im.half()  # to FP16\n        if self.nhwc:\n            im = im.permute(0, 2, 3, 1)  # torch BCHW to numpy BHWC shape(1,320,192,3)\n\n        if self.pt:  # PyTorch\n            y = self.model(im, augment=augment, visualize=visualize) if augment or visualize else self.model(im)\n        elif self.jit:  # TorchScript\n            y = self.model(im)\n        elif self.dnn:  # ONNX OpenCV DNN\n            im = im.cpu().numpy()  # torch to numpy\n            self.net.setInput(im)\n            y = self.net.forward()\n        elif self.onnx:  # ONNX Runtime\n            im = im.cpu().numpy()  # torch to numpy\n            y = self.session.run(self.output_names, {self.session.get_inputs()[0].name: im})\n        elif self.xml:  # OpenVINO\n            im = im.cpu().numpy()  # FP32\n            y = list(self.ov_compiled_model(im).values())\n        elif self.engine:  # TensorRT\n            if self.dynamic and im.shape != self.bindings[\"images\"].shape:\n                i = self.model.get_binding_index(\"images\")\n                self.context.set_binding_shape(i, im.shape)  # reshape if dynamic\n                self.bindings[\"images\"] = self.bindings[\"images\"]._replace(shape=im.shape)\n                for name in self.output_names:\n                    i = self.model.get_binding_index(name)\n                    self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))\n            s = self.bindings[\"images\"].shape\n            assert im.shape == s, f\"input size {im.shape} {'>' if self.dynamic else 'not equal to'} max model size {s}\"\n            self.binding_addrs[\"images\"] = int(im.data_ptr())\n            self.context.execute_v2(list(self.binding_addrs.values()))\n            y = [self.bindings[x].data for x in sorted(self.output_names)]\n        elif self.coreml:  # CoreML\n            im = im.cpu().numpy()\n            im = Image.fromarray((im[0] * 255).astype(\"uint8\"))\n            # im = im.resize((192, 320), Image.BILINEAR)\n            y = self.model.predict({\"image\": im})  # coordinates are xywh normalized\n            if \"confidence\" in y:\n                box = xywh2xyxy(y[\"coordinates\"] * [[w, h, w, h]])  # xyxy pixels\n                conf, cls = y[\"confidence\"].max(1), y[\"confidence\"].argmax(1).astype(np.float)\n                y = np.concatenate((box, conf.reshape(-1, 1), cls.reshape(-1, 1)), 1)\n            else:\n                y = list(reversed(y.values()))  # reversed for segmentation models (pred, proto)\n        elif self.paddle:  # PaddlePaddle\n            im = im.cpu().numpy().astype(np.float32)\n            self.input_handle.copy_from_cpu(im)\n            self.predictor.run()\n            y = [self.predictor.get_output_handle(x).copy_to_cpu() for x in self.output_names]\n        elif self.triton:  # NVIDIA Triton Inference Server\n            y = self.model(im)\n        else:  # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)\n            im = im.cpu().numpy()\n            if self.saved_model:  # SavedModel\n                y = self.model(im, training=False) if self.keras else self.model(im)\n            elif self.pb:  # GraphDef\n                y = self.frozen_func(x=self.tf.constant(im))\n            else:  # Lite or Edge TPU\n                input = self.input_details[0]\n                int8 = input[\"dtype\"] == np.uint8  # is TFLite quantized uint8 model\n                if int8:\n                    scale, zero_point = input[\"quantization\"]\n                    im = (im / scale + zero_point).astype(np.uint8)  # de-scale\n                self.interpreter.set_tensor(input[\"index\"], im)\n                self.interpreter.invoke()\n                y = []\n                for output in self.output_details:\n                    x = self.interpreter.get_tensor(output[\"index\"])\n                    if int8:\n                        scale, zero_point = output[\"quantization\"]\n                        x = (x.astype(np.float32) - zero_point) * scale  # re-scale\n                    y.append(x)\n            y = [x if isinstance(x, np.ndarray) else x.numpy() for x in y]\n            y[0][..., :4] *= [w, h, w, h]  # xywh normalized to pixels\n\n        if isinstance(y, (list, tuple)):\n            return self.from_numpy(y[0]) if len(y) == 1 else [self.from_numpy(x) for x in y]\n        else:\n            return self.from_numpy(y)\n\n    def from_numpy(self, x):\n        \"\"\"Converts a NumPy array to a torch tensor, maintaining device compatibility.\"\"\"\n        return torch.from_numpy(x).to(self.device) if isinstance(x, np.ndarray) else x\n\n    def warmup(self, imgsz=(1, 3, 640, 640)):\n        \"\"\"Performs a single inference warmup to initialize model weights, accepting an `imgsz` tuple for image size.\"\"\"\n        warmup_types = self.pt, self.jit, self.onnx, self.engine, self.saved_model, self.pb, self.triton\n        if any(warmup_types) and (self.device.type != \"cpu\" or self.triton):\n            im = torch.empty(*imgsz, dtype=torch.half if self.fp16 else torch.float, device=self.device)  # input\n            for _ in range(2 if self.jit else 1):  #\n                self.forward(im)  # warmup\n\n    @staticmethod\n    def _model_type(p=\"path/to/model.pt\"):\n        \"\"\"\n        Determines model type from file path or URL, supporting various export formats.\n\n        Example: path='path/to/model.onnx' -> type=onnx\n        \"\"\"\n        # types = [pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle]\n        from export import export_formats\n        from utils.downloads import is_url\n\n        sf = list(export_formats().Suffix)  # export suffixes\n        if not is_url(p, check=False):\n            check_suffix(p, sf)  # checks\n        url = urlparse(p)  # if url may be Triton inference server\n        types = [s in Path(p).name for s in sf]\n        types[8] &= not types[9]  # tflite &= not edgetpu\n        triton = not any(types) and all([any(s in url.scheme for s in [\"http\", \"grpc\"]), url.netloc])\n        return types + [triton]\n\n    @staticmethod\n    def _load_metadata(f=Path(\"path/to/meta.yaml\")):\n        \"\"\"Loads metadata from a YAML file, returning strides and names if the file exists, otherwise `None`.\"\"\"\n        if f.exists():\n            d = yaml_load(f)\n            return d[\"stride\"], d[\"names\"]  # assign stride, names\n        return None, None\n\n\nclass AutoShape(nn.Module):\n    # YOLOv5 input-robust model wrapper for passing cv2/np/PIL/torch inputs. Includes preprocessing, inference and NMS\n    conf = 0.25  # NMS confidence threshold\n    iou = 0.45  # NMS IoU threshold\n    agnostic = False  # NMS class-agnostic\n    multi_label = False  # NMS multiple labels per box\n    classes = None  # (optional list) filter by class, i.e. = [0, 15, 16] for COCO persons, cats and dogs\n    max_det = 1000  # maximum number of detections per image\n    amp = False  # Automatic Mixed Precision (AMP) inference\n\n    def __init__(self, model, verbose=True):\n        \"\"\"Initializes YOLOv5 model for inference, setting up attributes and preparing model for evaluation.\"\"\"\n        super().__init__()\n        if verbose:\n            LOGGER.info(\"Adding AutoShape... \")\n        copy_attr(self, model, include=(\"yaml\", \"nc\", \"hyp\", \"names\", \"stride\", \"abc\"), exclude=())  # copy attributes\n        self.dmb = isinstance(model, DetectMultiBackend)  # DetectMultiBackend() instance\n        self.pt = not self.dmb or model.pt  # PyTorch model\n        self.model = model.eval()\n        if self.pt:\n            m = self.model.model.model[-1] if self.dmb else self.model.model[-1]  # Detect()\n            m.inplace = False  # Detect.inplace=False for safe multithread inference\n            m.export = True  # do not output loss values\n\n    def _apply(self, fn):\n        \"\"\"\n        Applies to(), cpu(), cuda(), half() etc.\n\n        to model tensors excluding parameters or registered buffers.\n        \"\"\"\n        self = super()._apply(fn)\n        if self.pt:\n            m = self.model.model.model[-1] if self.dmb else self.model.model[-1]  # Detect()\n            m.stride = fn(m.stride)\n            m.grid = list(map(fn, m.grid))\n            if isinstance(m.anchor_grid, list):\n                m.anchor_grid = list(map(fn, m.anchor_grid))\n        return self\n\n    @smart_inference_mode()\n    def forward(self, ims, size=640, augment=False, profile=False):\n        \"\"\"\n        Performs inference on inputs with optional augment & profiling.\n\n        Supports various formats including file, URI, OpenCV, PIL, numpy, torch.\n        \"\"\"\n        # For size(height=640, width=1280), RGB images example inputs are:\n        #   file:        ims = 'data/images/zidane.jpg'  # str or PosixPath\n        #   URI:             = 'https://ultralytics.com/images/zidane.jpg'\n        #   OpenCV:          = cv2.imread('image.jpg')[:,:,::-1]  # HWC BGR to RGB x(640,1280,3)\n        #   PIL:             = Image.open('image.jpg') or ImageGrab.grab()  # HWC x(640,1280,3)\n        #   numpy:           = np.zeros((640,1280,3))  # HWC\n        #   torch:           = torch.zeros(16,3,320,640)  # BCHW (scaled to size=640, 0-1 values)\n        #   multiple:        = [Image.open('image1.jpg'), Image.open('image2.jpg'), ...]  # list of images\n\n        dt = (Profile(), Profile(), Profile())\n        with dt[0]:\n            if isinstance(size, int):  # expand\n                size = (size, size)\n            p = next(self.model.parameters()) if self.pt else torch.empty(1, device=self.model.device)  # param\n            autocast = self.amp and (p.device.type != \"cpu\")  # Automatic Mixed Precision (AMP) inference\n            if isinstance(ims, torch.Tensor):  # torch\n                with amp.autocast(autocast):\n                    return self.model(ims.to(p.device).type_as(p), augment=augment)  # inference\n\n            # Pre-process\n            n, ims = (len(ims), list(ims)) if isinstance(ims, (list, tuple)) else (1, [ims])  # number, list of images\n            shape0, shape1, files = [], [], []  # image and inference shapes, filenames\n            for i, im in enumerate(ims):\n                f = f\"image{i}\"  # filename\n                if isinstance(im, (str, Path)):  # filename or uri\n                    im, f = Image.open(requests.get(im, stream=True).raw if str(im).startswith(\"http\") else im), im\n                    im = np.asarray(exif_transpose(im))\n                elif isinstance(im, Image.Image):  # PIL Image\n                    im, f = np.asarray(exif_transpose(im)), getattr(im, \"filename\", f) or f\n                files.append(Path(f).with_suffix(\".jpg\").name)\n                if im.shape[0] < 5:  # image in CHW\n                    im = im.transpose((1, 2, 0))  # reverse dataloader .transpose(2, 0, 1)\n                im = im[..., :3] if im.ndim == 3 else cv2.cvtColor(im, cv2.COLOR_GRAY2BGR)  # enforce 3ch input\n                s = im.shape[:2]  # HWC\n                shape0.append(s)  # image shape\n                g = max(size) / max(s)  # gain\n                shape1.append([int(y * g) for y in s])\n                ims[i] = im if im.data.contiguous else np.ascontiguousarray(im)  # update\n            shape1 = [make_divisible(x, self.stride) for x in np.array(shape1).max(0)]  # inf shape\n            x = [letterbox(im, shape1, auto=False)[0] for im in ims]  # pad\n            x = np.ascontiguousarray(np.array(x).transpose((0, 3, 1, 2)))  # stack and BHWC to BCHW\n            x = torch.from_numpy(x).to(p.device).type_as(p) / 255  # uint8 to fp16/32\n\n        with amp.autocast(autocast):\n            # Inference\n            with dt[1]:\n                y = self.model(x, augment=augment)  # forward\n\n            # Post-process\n            with dt[2]:\n                y = non_max_suppression(\n                    y if self.dmb else y[0],\n                    self.conf,\n                    self.iou,\n                    self.classes,\n                    self.agnostic,\n                    self.multi_label,\n                    max_det=self.max_det,\n                )  # NMS\n                for i in range(n):\n                    scale_boxes(shape1, y[i][:, :4], shape0[i])\n\n            return Detections(ims, y, files, dt, self.names, x.shape)\n\n\nclass Detections:\n    # YOLOv5 detections class for inference results\n    def __init__(self, ims, pred, files, times=(0, 0, 0), names=None, shape=None):\n        \"\"\"Initializes the YOLOv5 Detections class with image info, predictions, filenames, timing and normalization.\"\"\"\n        super().__init__()\n        d = pred[0].device  # device\n        gn = [torch.tensor([*(im.shape[i] for i in [1, 0, 1, 0]), 1, 1], device=d) for im in ims]  # normalizations\n        self.ims = ims  # list of images as numpy arrays\n        self.pred = pred  # list of tensors pred[0] = (xyxy, conf, cls)\n        self.names = names  # class names\n        self.files = files  # image filenames\n        self.times = times  # profiling times\n        self.xyxy = pred  # xyxy pixels\n        self.xywh = [xyxy2xywh(x) for x in pred]  # xywh pixels\n        self.xyxyn = [x / g for x, g in zip(self.xyxy, gn)]  # xyxy normalized\n        self.xywhn = [x / g for x, g in zip(self.xywh, gn)]  # xywh normalized\n        self.n = len(self.pred)  # number of images (batch size)\n        self.t = tuple(x.t / self.n * 1e3 for x in times)  # timestamps (ms)\n        self.s = tuple(shape)  # inference BCHW shape\n\n    def _run(self, pprint=False, show=False, save=False, crop=False, render=False, labels=True, save_dir=Path(\"\")):\n        \"\"\"Executes model predictions, displaying and/or saving outputs with optional crops and labels.\"\"\"\n        s, crops = \"\", []\n        for i, (im, pred) in enumerate(zip(self.ims, self.pred)):\n            s += f\"\\nimage {i + 1}/{len(self.pred)}: {im.shape[0]}x{im.shape[1]} \"  # string\n            if pred.shape[0]:\n                for c in pred[:, -1].unique():\n                    n = (pred[:, -1] == c).sum()  # detections per class\n                    s += f\"{n} {self.names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n                s = s.rstrip(\", \")\n                if show or save or render or crop:\n                    annotator = Annotator(im, example=str(self.names))\n                    for *box, conf, cls in reversed(pred):  # xyxy, confidence, class\n                        label = f\"{self.names[int(cls)]} {conf:.2f}\"\n                        if crop:\n                            file = save_dir / \"crops\" / self.names[int(cls)] / self.files[i] if save else None\n                            crops.append(\n                                {\n                                    \"box\": box,\n                                    \"conf\": conf,\n                                    \"cls\": cls,\n                                    \"label\": label,\n                                    \"im\": save_one_box(box, im, file=file, save=save),\n                                }\n                            )\n                        else:  # all others\n                            annotator.box_label(box, label if labels else \"\", color=colors(cls))\n                    im = annotator.im\n            else:\n                s += \"(no detections)\"\n\n            im = Image.fromarray(im.astype(np.uint8)) if isinstance(im, np.ndarray) else im  # from np\n            if show:\n                if is_jupyter():\n                    from IPython.display import display\n\n                    display(im)\n                else:\n                    im.show(self.files[i])\n            if save:\n                f = self.files[i]\n                im.save(save_dir / f)  # save\n                if i == self.n - 1:\n                    LOGGER.info(f\"Saved {self.n} image{'s' * (self.n > 1)} to {colorstr('bold', save_dir)}\")\n            if render:\n                self.ims[i] = np.asarray(im)\n        if pprint:\n            s = s.lstrip(\"\\n\")\n            return f\"{s}\\nSpeed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {self.s}\" % self.t\n        if crop:\n            if save:\n                LOGGER.info(f\"Saved results to {save_dir}\\n\")\n            return crops\n\n    @TryExcept(\"Showing images is not supported in this environment\")\n    def show(self, labels=True):\n        \"\"\"\n        Displays detection results with optional labels.\n\n        Usage: show(labels=True)\n        \"\"\"\n        self._run(show=True, labels=labels)  # show results\n\n    def save(self, labels=True, save_dir=\"runs/detect/exp\", exist_ok=False):\n        \"\"\"\n        Saves detection results with optional labels to a specified directory.\n\n        Usage: save(labels=True, save_dir='runs/detect/exp', exist_ok=False)\n        \"\"\"\n        save_dir = increment_path(save_dir, exist_ok, mkdir=True)  # increment save_dir\n        self._run(save=True, labels=labels, save_dir=save_dir)  # save results\n\n    def crop(self, save=True, save_dir=\"runs/detect/exp\", exist_ok=False):\n        \"\"\"\n        Crops detection results, optionally saves them to a directory.\n\n        Args: save (bool), save_dir (str), exist_ok (bool).\n        \"\"\"\n        save_dir = increment_path(save_dir, exist_ok, mkdir=True) if save else None\n        return self._run(crop=True, save=save, save_dir=save_dir)  # crop results\n\n    def render(self, labels=True):\n        \"\"\"Renders detection results with optional labels on images; args: labels (bool) indicating label inclusion.\"\"\"\n        self._run(render=True, labels=labels)  # render results\n        return self.ims\n\n    def pandas(self):\n        \"\"\"\n        Returns detections as pandas DataFrames for various box formats (xyxy, xyxyn, xywh, xywhn).\n\n        Example: print(results.pandas().xyxy[0]).\n        \"\"\"\n        new = copy(self)  # return copy\n        ca = \"xmin\", \"ymin\", \"xmax\", \"ymax\", \"confidence\", \"class\", \"name\"  # xyxy columns\n        cb = \"xcenter\", \"ycenter\", \"width\", \"height\", \"confidence\", \"class\", \"name\"  # xywh columns\n        for k, c in zip([\"xyxy\", \"xyxyn\", \"xywh\", \"xywhn\"], [ca, ca, cb, cb]):\n            a = [[x[:5] + [int(x[5]), self.names[int(x[5])]] for x in x.tolist()] for x in getattr(self, k)]  # update\n            setattr(new, k, [pd.DataFrame(x, columns=c) for x in a])\n        return new\n\n    def tolist(self):\n        \"\"\"\n        Converts a Detections object into a list of individual detection results for iteration.\n\n        Example: for result in results.tolist():\n        \"\"\"\n        r = range(self.n)  # iterable\n        return [\n            Detections(\n                [self.ims[i]],\n                [self.pred[i]],\n                [self.files[i]],\n                self.times,\n                self.names,\n                self.s,\n            )\n            for i in r\n        ]\n\n    def print(self):\n        \"\"\"Logs the string representation of the current object's state via the LOGGER.\"\"\"\n        LOGGER.info(self.__str__())\n\n    def __len__(self):\n        \"\"\"Returns the number of results stored, overrides the default len(results).\"\"\"\n        return self.n\n\n    def __str__(self):\n        \"\"\"Returns a string representation of the model's results, suitable for printing, overrides default\n        print(results).\n        \"\"\"\n        return self._run(pprint=True)  # print results\n\n    def __repr__(self):\n        \"\"\"Returns a string representation of the YOLOv5 object, including its class and formatted results.\"\"\"\n        return f\"YOLOv5 {self.__class__} instance\\n\" + self.__str__()\n\n\nclass Proto(nn.Module):\n    # YOLOv5 mask Proto module for segmentation models\n    def __init__(self, c1, c_=256, c2=32):\n        \"\"\"Initializes YOLOv5 Proto module for segmentation with input, proto, and mask channels configuration.\"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c_, k=3)\n        self.upsample = nn.Upsample(scale_factor=2, mode=\"nearest\")\n        self.cv2 = Conv(c_, c_, k=3)\n        self.cv3 = Conv(c_, c2)\n\n    def forward(self, x):\n        \"\"\"Performs a forward pass using convolutional layers and upsampling on input tensor `x`.\"\"\"\n        return self.cv3(self.cv2(self.upsample(self.cv1(x))))\n\n\nclass Classify(nn.Module):\n    # YOLOv5 classification head, i.e. x(b,c1,20,20) to x(b,c2)\n    def __init__(\n        self, c1, c2, k=1, s=1, p=None, g=1, dropout_p=0.0\n    ):  # ch_in, ch_out, kernel, stride, padding, groups, dropout probability\n        super().__init__()\n        c_ = 1280  # efficientnet_b0 size\n        self.conv = Conv(c1, c_, k, s, autopad(k, p), g)\n        self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)\n        self.drop = nn.Dropout(p=dropout_p, inplace=True)\n        self.linear = nn.Linear(c_, c2)  # to x(b,c2)\n\n    def forward(self, x):\n        \"\"\"Processes input through conv, pool, drop, and linear layers; supports list concatenation input.\"\"\"\n        if isinstance(x, list):\n            x = torch.cat(x, 1)\n        return self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))\n", "models/experimental.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Experimental modules.\"\"\"\n\nimport math\n\nimport numpy as np\nimport torch\nimport torch.nn as nn\n\nfrom utils.downloads import attempt_download\n\n\nclass Sum(nn.Module):\n    \"\"\"Weighted sum of 2 or more layers https://arxiv.org/abs/1911.09070.\"\"\"\n\n    def __init__(self, n, weight=False):\n        \"\"\"Initializes a module to sum outputs of layers with number of inputs `n` and optional weighting, supporting 2+\n        inputs.\n        \"\"\"\n        super().__init__()\n        self.weight = weight  # apply weights boolean\n        self.iter = range(n - 1)  # iter object\n        if weight:\n            self.w = nn.Parameter(-torch.arange(1.0, n) / 2, requires_grad=True)  # layer weights\n\n    def forward(self, x):\n        \"\"\"Processes input through a customizable weighted sum of `n` inputs, optionally applying learned weights.\"\"\"\n        y = x[0]  # no weight\n        if self.weight:\n            w = torch.sigmoid(self.w) * 2\n            for i in self.iter:\n                y = y + x[i + 1] * w[i]\n        else:\n            for i in self.iter:\n                y = y + x[i + 1]\n        return y\n\n\nclass MixConv2d(nn.Module):\n    \"\"\"Mixed Depth-wise Conv https://arxiv.org/abs/1907.09595.\"\"\"\n\n    def __init__(self, c1, c2, k=(1, 3), s=1, equal_ch=True):\n        \"\"\"Initializes MixConv2d with mixed depth-wise convolutional layers, taking input and output channels (c1, c2),\n        kernel sizes (k), stride (s), and channel distribution strategy (equal_ch).\n        \"\"\"\n        super().__init__()\n        n = len(k)  # number of convolutions\n        if equal_ch:  # equal c_ per group\n            i = torch.linspace(0, n - 1e-6, c2).floor()  # c2 indices\n            c_ = [(i == g).sum() for g in range(n)]  # intermediate channels\n        else:  # equal weight.numel() per group\n            b = [c2] + [0] * n\n            a = np.eye(n + 1, n, k=-1)\n            a -= np.roll(a, 1, axis=1)\n            a *= np.array(k) ** 2\n            a[0] = 1\n            c_ = np.linalg.lstsq(a, b, rcond=None)[0].round()  # solve for equal weight indices, ax = b\n\n        self.m = nn.ModuleList(\n            [nn.Conv2d(c1, int(c_), k, s, k // 2, groups=math.gcd(c1, int(c_)), bias=False) for k, c_ in zip(k, c_)]\n        )\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = nn.SiLU()\n\n    def forward(self, x):\n        \"\"\"Performs forward pass by applying SiLU activation on batch-normalized concatenated convolutional layer\n        outputs.\n        \"\"\"\n        return self.act(self.bn(torch.cat([m(x) for m in self.m], 1)))\n\n\nclass Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes an ensemble of models to be used for aggregated predictions.\"\"\"\n        super().__init__()\n\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Performs forward pass aggregating outputs from an ensemble of models..\"\"\"\n        y = [module(x, augment, profile, visualize)[0] for module in self]\n        # y = torch.stack(y).max(0)[0]  # max ensemble\n        # y = torch.stack(y).mean(0)  # mean ensemble\n        y = torch.cat(y, 1)  # nms ensemble\n        return y, None  # inference, train output\n\n\ndef attempt_load(weights, device=None, inplace=True, fuse=True):\n    \"\"\"\n    Loads and fuses an ensemble or single YOLOv5 model from weights, handling device placement and model adjustments.\n\n    Example inputs: weights=[a,b,c] or a single model weights=[a] or weights=a.\n    \"\"\"\n    from models.yolo import Detect, Model\n\n    model = Ensemble()\n    for w in weights if isinstance(weights, list) else [weights]:\n        ckpt = torch.load(attempt_download(w), map_location=\"cpu\")  # load\n        ckpt = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n\n        # Model compatibility updates\n        if not hasattr(ckpt, \"stride\"):\n            ckpt.stride = torch.tensor([32.0])\n        if hasattr(ckpt, \"names\") and isinstance(ckpt.names, (list, tuple)):\n            ckpt.names = dict(enumerate(ckpt.names))  # convert to dict\n\n        model.append(ckpt.fuse().eval() if fuse and hasattr(ckpt, \"fuse\") else ckpt.eval())  # model in eval mode\n\n    # Module updates\n    for m in model.modules():\n        t = type(m)\n        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Model):\n            m.inplace = inplace\n            if t is Detect and not isinstance(m.anchor_grid, list):\n                delattr(m, \"anchor_grid\")\n                setattr(m, \"anchor_grid\", [torch.zeros(1)] * m.nl)\n        elif t is nn.Upsample and not hasattr(m, \"recompute_scale_factor\"):\n            m.recompute_scale_factor = None  # torch 1.11.0 compatibility\n\n    # Return model\n    if len(model) == 1:\n        return model[-1]\n\n    # Return detection ensemble\n    print(f\"Ensemble created with {weights}\\n\")\n    for k in \"names\", \"nc\", \"yaml\":\n        setattr(model, k, getattr(model[0], k))\n    model.stride = model[torch.argmax(torch.tensor([m.stride.max() for m in model])).int()].stride  # max stride\n    assert all(model[0].nc == m.nc for m in model), f\"Models have different class counts: {[m.nc for m in model]}\"\n    return model\n", "models/yolo.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nYOLO-specific modules.\n\nUsage:\n    $ python models/yolo.py --cfg yolov5s.yaml\n\"\"\"\n\nimport argparse\nimport contextlib\nimport math\nimport os\nimport platform\nimport sys\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport torch\nimport torch.nn as nn\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nif platform.system() != \"Windows\":\n    ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom models.common import (\n    C3,\n    C3SPP,\n    C3TR,\n    SPP,\n    SPPF,\n    Bottleneck,\n    BottleneckCSP,\n    C3Ghost,\n    C3x,\n    Classify,\n    Concat,\n    Contract,\n    Conv,\n    CrossConv,\n    DetectMultiBackend,\n    DWConv,\n    DWConvTranspose2d,\n    Expand,\n    Focus,\n    GhostBottleneck,\n    GhostConv,\n    Proto,\n)\nfrom models.experimental import MixConv2d\nfrom utils.autoanchor import check_anchor_order\nfrom utils.general import LOGGER, check_version, check_yaml, colorstr, make_divisible, print_args\nfrom utils.plots import feature_visualization\nfrom utils.torch_utils import (\n    fuse_conv_and_bn,\n    initialize_weights,\n    model_info,\n    profile,\n    scale_img,\n    select_device,\n    time_sync,\n)\n\ntry:\n    import thop  # for FLOPs computation\nexcept ImportError:\n    thop = None\n\n\nclass Detect(nn.Module):\n    # YOLOv5 Detect head for detection models\n    stride = None  # strides computed during build\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n\n    def __init__(self, nc=80, anchors=(), ch=(), inplace=True):\n        \"\"\"Initializes YOLOv5 detection layer with specified classes, anchors, channels, and inplace operations.\"\"\"\n        super().__init__()\n        self.nc = nc  # number of classes\n        self.no = nc + 5  # number of outputs per anchor\n        self.nl = len(anchors)  # number of detection layers\n        self.na = len(anchors[0]) // 2  # number of anchors\n        self.grid = [torch.empty(0) for _ in range(self.nl)]  # init grid\n        self.anchor_grid = [torch.empty(0) for _ in range(self.nl)]  # init anchor grid\n        self.register_buffer(\"anchors\", torch.tensor(anchors).float().view(self.nl, -1, 2))  # shape(nl,na,2)\n        self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv\n        self.inplace = inplace  # use inplace ops (e.g. slice assignment)\n\n    def forward(self, x):\n        \"\"\"Processes input through YOLOv5 layers, altering shape for detection: `x(bs, 3, ny, nx, 85)`.\"\"\"\n        z = []  # inference output\n        for i in range(self.nl):\n            x[i] = self.m[i](x[i])  # conv\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\n\n            if not self.training:  # inference\n                if self.dynamic or self.grid[i].shape[2:4] != x[i].shape[2:4]:\n                    self.grid[i], self.anchor_grid[i] = self._make_grid(nx, ny, i)\n\n                if isinstance(self, Segment):  # (boxes + masks)\n                    xy, wh, conf, mask = x[i].split((2, 2, self.nc + 1, self.no - self.nc - 5), 4)\n                    xy = (xy.sigmoid() * 2 + self.grid[i]) * self.stride[i]  # xy\n                    wh = (wh.sigmoid() * 2) ** 2 * self.anchor_grid[i]  # wh\n                    y = torch.cat((xy, wh, conf.sigmoid(), mask), 4)\n                else:  # Detect (boxes only)\n                    xy, wh, conf = x[i].sigmoid().split((2, 2, self.nc + 1), 4)\n                    xy = (xy * 2 + self.grid[i]) * self.stride[i]  # xy\n                    wh = (wh * 2) ** 2 * self.anchor_grid[i]  # wh\n                    y = torch.cat((xy, wh, conf), 4)\n                z.append(y.view(bs, self.na * nx * ny, self.no))\n\n        return x if self.training else (torch.cat(z, 1),) if self.export else (torch.cat(z, 1), x)\n\n    def _make_grid(self, nx=20, ny=20, i=0, torch_1_10=check_version(torch.__version__, \"1.10.0\")):\n        \"\"\"Generates a mesh grid for anchor boxes with optional compatibility for torch versions < 1.10.\"\"\"\n        d = self.anchors[i].device\n        t = self.anchors[i].dtype\n        shape = 1, self.na, ny, nx, 2  # grid shape\n        y, x = torch.arange(ny, device=d, dtype=t), torch.arange(nx, device=d, dtype=t)\n        yv, xv = torch.meshgrid(y, x, indexing=\"ij\") if torch_1_10 else torch.meshgrid(y, x)  # torch>=0.7 compatibility\n        grid = torch.stack((xv, yv), 2).expand(shape) - 0.5  # add grid offset, i.e. y = 2.0 * x - 0.5\n        anchor_grid = (self.anchors[i] * self.stride[i]).view((1, self.na, 1, 1, 2)).expand(shape)\n        return grid, anchor_grid\n\n\nclass Segment(Detect):\n    # YOLOv5 Segment head for segmentation models\n    def __init__(self, nc=80, anchors=(), nm=32, npr=256, ch=(), inplace=True):\n        \"\"\"Initializes YOLOv5 Segment head with options for mask count, protos, and channel adjustments.\"\"\"\n        super().__init__(nc, anchors, ch, inplace)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.no = 5 + nc + self.nm  # number of outputs per anchor\n        self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv\n        self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n        self.detect = Detect.forward\n\n    def forward(self, x):\n        \"\"\"Processes input through the network, returning detections and prototypes; adjusts output based on\n        training/export mode.\n        \"\"\"\n        p = self.proto(x[0])\n        x = self.detect(self, x)\n        return (x, p) if self.training else (x[0], p) if self.export else (x[0], p, x[1])\n\n\nclass BaseModel(nn.Module):\n    \"\"\"YOLOv5 base model.\"\"\"\n\n    def forward(self, x, profile=False, visualize=False):\n        \"\"\"Executes a single-scale inference or training pass on the YOLOv5 base model, with options for profiling and\n        visualization.\n        \"\"\"\n        return self._forward_once(x, profile, visualize)  # single-scale inference, train\n\n    def _forward_once(self, x, profile=False, visualize=False):\n        \"\"\"Performs a forward pass on the YOLOv5 model, enabling profiling and feature visualization options.\"\"\"\n        y, dt = [], []  # outputs\n        for m in self.model:\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n            if profile:\n                self._profile_one_layer(m, x, dt)\n            x = m(x)  # run\n            y.append(x if m.i in self.save else None)  # save output\n            if visualize:\n                feature_visualization(x, m.type, m.i, save_dir=visualize)\n        return x\n\n    def _profile_one_layer(self, m, x, dt):\n        \"\"\"Profiles a single layer's performance by computing GFLOPs, execution time, and parameters.\"\"\"\n        c = m == self.model[-1]  # is final layer, copy input as inplace fix\n        o = thop.profile(m, inputs=(x.copy() if c else x,), verbose=False)[0] / 1e9 * 2 if thop else 0  # FLOPs\n        t = time_sync()\n        for _ in range(10):\n            m(x.copy() if c else x)\n        dt.append((time_sync() - t) * 100)\n        if m == self.model[0]:\n            LOGGER.info(f\"{'time (ms)':>10s} {'GFLOPs':>10s} {'params':>10s}  module\")\n        LOGGER.info(f\"{dt[-1]:10.2f} {o:10.2f} {m.np:10.0f}  {m.type}\")\n        if c:\n            LOGGER.info(f\"{sum(dt):10.2f} {'-':>10s} {'-':>10s}  Total\")\n\n    def fuse(self):\n        \"\"\"Fuses Conv2d() and BatchNorm2d() layers in the model to improve inference speed.\"\"\"\n        LOGGER.info(\"Fusing layers... \")\n        for m in self.model.modules():\n            if isinstance(m, (Conv, DWConv)) and hasattr(m, \"bn\"):\n                m.conv = fuse_conv_and_bn(m.conv, m.bn)  # update conv\n                delattr(m, \"bn\")  # remove batchnorm\n                m.forward = m.forward_fuse  # update forward\n        self.info()\n        return self\n\n    def info(self, verbose=False, img_size=640):\n        \"\"\"Prints model information given verbosity and image size, e.g., `info(verbose=True, img_size=640)`.\"\"\"\n        model_info(self, verbose, img_size)\n\n    def _apply(self, fn):\n        \"\"\"Applies transformations like to(), cpu(), cuda(), half() to model tensors excluding parameters or registered\n        buffers.\n        \"\"\"\n        self = super()._apply(fn)\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment)):\n            m.stride = fn(m.stride)\n            m.grid = list(map(fn, m.grid))\n            if isinstance(m.anchor_grid, list):\n                m.anchor_grid = list(map(fn, m.anchor_grid))\n        return self\n\n\nclass DetectionModel(BaseModel):\n    # YOLOv5 detection model\n    def __init__(self, cfg=\"yolov5s.yaml\", ch=3, nc=None, anchors=None):\n        \"\"\"Initializes YOLOv5 model with configuration file, input channels, number of classes, and custom anchors.\"\"\"\n        super().__init__()\n        if isinstance(cfg, dict):\n            self.yaml = cfg  # model dict\n        else:  # is *.yaml\n            import yaml  # for torch hub\n\n            self.yaml_file = Path(cfg).name\n            with open(cfg, encoding=\"ascii\", errors=\"ignore\") as f:\n                self.yaml = yaml.safe_load(f)  # model dict\n\n        # Define model\n        ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml[\"nc\"] = nc  # override yaml value\n        if anchors:\n            LOGGER.info(f\"Overriding model.yaml anchors with anchors={anchors}\")\n            self.yaml[\"anchors\"] = round(anchors)  # override yaml value\n        self.model, self.save = parse_model(deepcopy(self.yaml), ch=[ch])  # model, savelist\n        self.names = [str(i) for i in range(self.yaml[\"nc\"])]  # default names\n        self.inplace = self.yaml.get(\"inplace\", True)\n\n        # Build strides, anchors\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment)):\n\n            def _forward(x):\n                \"\"\"Passes the input 'x' through the model and returns the processed output.\"\"\"\n                return self.forward(x)[0] if isinstance(m, Segment) else self.forward(x)\n\n            s = 256  # 2x min stride\n            m.inplace = self.inplace\n            m.stride = torch.tensor([s / x.shape[-2] for x in _forward(torch.zeros(1, ch, s, s))])  # forward\n            check_anchor_order(m)\n            m.anchors /= m.stride.view(-1, 1, 1)\n            self.stride = m.stride\n            self._initialize_biases()  # only run once\n\n        # Init weights, biases\n        initialize_weights(self)\n        self.info()\n        LOGGER.info(\"\")\n\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Performs single-scale or augmented inference and may include profiling or visualization.\"\"\"\n        if augment:\n            return self._forward_augment(x)  # augmented inference, None\n        return self._forward_once(x, profile, visualize)  # single-scale inference, train\n\n    def _forward_augment(self, x):\n        \"\"\"Performs augmented inference across different scales and flips, returning combined detections.\"\"\"\n        img_size = x.shape[-2:]  # height, width\n        s = [1, 0.83, 0.67]  # scales\n        f = [None, 3, None]  # flips (2-ud, 3-lr)\n        y = []  # outputs\n        for si, fi in zip(s, f):\n            xi = scale_img(x.flip(fi) if fi else x, si, gs=int(self.stride.max()))\n            yi = self._forward_once(xi)[0]  # forward\n            # cv2.imwrite(f'img_{si}.jpg', 255 * xi[0].cpu().numpy().transpose((1, 2, 0))[:, :, ::-1])  # save\n            yi = self._descale_pred(yi, fi, si, img_size)\n            y.append(yi)\n        y = self._clip_augmented(y)  # clip augmented tails\n        return torch.cat(y, 1), None  # augmented inference, train\n\n    def _descale_pred(self, p, flips, scale, img_size):\n        \"\"\"De-scales predictions from augmented inference, adjusting for flips and image size.\"\"\"\n        if self.inplace:\n            p[..., :4] /= scale  # de-scale\n            if flips == 2:\n                p[..., 1] = img_size[0] - p[..., 1]  # de-flip ud\n            elif flips == 3:\n                p[..., 0] = img_size[1] - p[..., 0]  # de-flip lr\n        else:\n            x, y, wh = p[..., 0:1] / scale, p[..., 1:2] / scale, p[..., 2:4] / scale  # de-scale\n            if flips == 2:\n                y = img_size[0] - y  # de-flip ud\n            elif flips == 3:\n                x = img_size[1] - x  # de-flip lr\n            p = torch.cat((x, y, wh, p[..., 4:]), -1)\n        return p\n\n    def _clip_augmented(self, y):\n        \"\"\"Clips augmented inference tails for YOLOv5 models, affecting first and last tensors based on grid points and\n        layer counts.\n        \"\"\"\n        nl = self.model[-1].nl  # number of detection layers (P3-P5)\n        g = sum(4**x for x in range(nl))  # grid points\n        e = 1  # exclude layer count\n        i = (y[0].shape[1] // g) * sum(4**x for x in range(e))  # indices\n        y[0] = y[0][:, :-i]  # large\n        i = (y[-1].shape[1] // g) * sum(4 ** (nl - 1 - x) for x in range(e))  # indices\n        y[-1] = y[-1][:, i:]  # small\n        return y\n\n    def _initialize_biases(self, cf=None):\n        \"\"\"\n        Initializes biases for YOLOv5's Detect() module, optionally using class frequencies (cf).\n\n        For details see https://arxiv.org/abs/1708.02002 section 3.3.\n        \"\"\"\n        # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1.\n        m = self.model[-1]  # Detect() module\n        for mi, s in zip(m.m, m.stride):  # from\n            b = mi.bias.view(m.na, -1)  # conv.bias(255) to (3,85)\n            b.data[:, 4] += math.log(8 / (640 / s) ** 2)  # obj (8 objects per 640 image)\n            b.data[:, 5 : 5 + m.nc] += (\n                math.log(0.6 / (m.nc - 0.99999)) if cf is None else torch.log(cf / cf.sum())\n            )  # cls\n            mi.bias = torch.nn.Parameter(b.view(-1), requires_grad=True)\n\n\nModel = DetectionModel  # retain YOLOv5 'Model' class for backwards compatibility\n\n\nclass SegmentationModel(DetectionModel):\n    # YOLOv5 segmentation model\n    def __init__(self, cfg=\"yolov5s-seg.yaml\", ch=3, nc=None, anchors=None):\n        \"\"\"Initializes a YOLOv5 segmentation model with configurable params: cfg (str) for configuration, ch (int) for channels, nc (int) for num classes, anchors (list).\"\"\"\n        super().__init__(cfg, ch, nc, anchors)\n\n\nclass ClassificationModel(BaseModel):\n    # YOLOv5 classification model\n    def __init__(self, cfg=None, model=None, nc=1000, cutoff=10):\n        \"\"\"Initializes YOLOv5 model with config file `cfg`, input channels `ch`, number of classes `nc`, and `cuttoff`\n        index.\n        \"\"\"\n        super().__init__()\n        self._from_detection_model(model, nc, cutoff) if model is not None else self._from_yaml(cfg)\n\n    def _from_detection_model(self, model, nc=1000, cutoff=10):\n        \"\"\"Creates a classification model from a YOLOv5 detection model, slicing at `cutoff` and adding a classification\n        layer.\n        \"\"\"\n        if isinstance(model, DetectMultiBackend):\n            model = model.model  # unwrap DetectMultiBackend\n        model.model = model.model[:cutoff]  # backbone\n        m = model.model[-1]  # last layer\n        ch = m.conv.in_channels if hasattr(m, \"conv\") else m.cv1.conv.in_channels  # ch into module\n        c = Classify(ch, nc)  # Classify()\n        c.i, c.f, c.type = m.i, m.f, \"models.common.Classify\"  # index, from, type\n        model.model[-1] = c  # replace\n        self.model = model.model\n        self.stride = model.stride\n        self.save = []\n        self.nc = nc\n\n    def _from_yaml(self, cfg):\n        \"\"\"Creates a YOLOv5 classification model from a specified *.yaml configuration file.\"\"\"\n        self.model = None\n\n\ndef parse_model(d, ch):\n    \"\"\"Parses a YOLOv5 model from a dict `d`, configuring layers based on input channels `ch` and model architecture.\"\"\"\n    LOGGER.info(f\"\\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}\")\n    anchors, nc, gd, gw, act, ch_mul = (\n        d[\"anchors\"],\n        d[\"nc\"],\n        d[\"depth_multiple\"],\n        d[\"width_multiple\"],\n        d.get(\"activation\"),\n        d.get(\"channel_multiple\"),\n    )\n    if act:\n        Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()\n        LOGGER.info(f\"{colorstr('activation:')} {act}\")  # print\n    if not ch_mul:\n        ch_mul = 8\n    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors\n    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)\n\n    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n    for i, (f, n, m, args) in enumerate(d[\"backbone\"] + d[\"head\"]):  # from, number, module, args\n        m = eval(m) if isinstance(m, str) else m  # eval strings\n        for j, a in enumerate(args):\n            with contextlib.suppress(NameError):\n                args[j] = eval(a) if isinstance(a, str) else a  # eval strings\n\n        n = n_ = max(round(n * gd), 1) if n > 1 else n  # depth gain\n        if m in {\n            Conv,\n            GhostConv,\n            Bottleneck,\n            GhostBottleneck,\n            SPP,\n            SPPF,\n            DWConv,\n            MixConv2d,\n            Focus,\n            CrossConv,\n            BottleneckCSP,\n            C3,\n            C3TR,\n            C3SPP,\n            C3Ghost,\n            nn.ConvTranspose2d,\n            DWConvTranspose2d,\n            C3x,\n        }:\n            c1, c2 = ch[f], args[0]\n            if c2 != no:  # if not output\n                c2 = make_divisible(c2 * gw, ch_mul)\n\n            args = [c1, c2, *args[1:]]\n            if m in {BottleneckCSP, C3, C3TR, C3Ghost, C3x}:\n                args.insert(2, n)  # number of repeats\n                n = 1\n        elif m is nn.BatchNorm2d:\n            args = [ch[f]]\n        elif m is Concat:\n            c2 = sum(ch[x] for x in f)\n        # TODO: channel, gw, gd\n        elif m in {Detect, Segment}:\n            args.append([ch[x] for x in f])\n            if isinstance(args[1], int):  # number of anchors\n                args[1] = [list(range(args[1] * 2))] * len(f)\n            if m is Segment:\n                args[3] = make_divisible(args[3] * gw, ch_mul)\n        elif m is Contract:\n            c2 = ch[f] * args[0] ** 2\n        elif m is Expand:\n            c2 = ch[f] // args[0] ** 2\n        else:\n            c2 = ch[f]\n\n        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module\n        t = str(m)[8:-2].replace(\"__main__.\", \"\")  # module type\n        np = sum(x.numel() for x in m_.parameters())  # number params\n        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params\n        LOGGER.info(f\"{i:>3}{str(f):>18}{n_:>3}{np:10.0f}  {t:<40}{str(args):<30}\")  # print\n        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n        layers.append(m_)\n        if i == 0:\n            ch = []\n        ch.append(c2)\n    return nn.Sequential(*layers), sorted(save)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--cfg\", type=str, default=\"yolov5s.yaml\", help=\"model.yaml\")\n    parser.add_argument(\"--batch-size\", type=int, default=1, help=\"total batch size for all GPUs\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--profile\", action=\"store_true\", help=\"profile model speed\")\n    parser.add_argument(\"--line-profile\", action=\"store_true\", help=\"profile model speed layer by layer\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"test all yolo*.yaml\")\n    opt = parser.parse_args()\n    opt.cfg = check_yaml(opt.cfg)  # check YAML\n    print_args(vars(opt))\n    device = select_device(opt.device)\n\n    # Create model\n    im = torch.rand(opt.batch_size, 3, 640, 640).to(device)\n    model = Model(opt.cfg).to(device)\n\n    # Options\n    if opt.line_profile:  # profile layer by layer\n        model(im, profile=True)\n\n    elif opt.profile:  # profile forward-backward\n        results = profile(input=im, ops=[model], n=3)\n\n    elif opt.test:  # test all models\n        for cfg in Path(ROOT / \"models\").rglob(\"yolo*.yaml\"):\n            try:\n                _ = Model(cfg)\n            except Exception as e:\n                print(f\"Error in {cfg}: {e}\")\n\n    else:  # report fused model summary\n        model.fuse()\n", "models/tf.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nTensorFlow, Keras and TFLite versions of YOLOv5\nAuthored by https://github.com/zldrobit in PR https://github.com/ultralytics/yolov5/pull/1127\n\nUsage:\n    $ python models/tf.py --weights yolov5s.pt\n\nExport:\n    $ python export.py --weights yolov5s.pt --include saved_model pb tflite tfjs\n\"\"\"\n\nimport argparse\nimport sys\nfrom copy import deepcopy\nfrom pathlib import Path\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\n# ROOT = ROOT.relative_to(Path.cwd())  # relative\n\nimport numpy as np\nimport tensorflow as tf\nimport torch\nimport torch.nn as nn\nfrom tensorflow import keras\n\nfrom models.common import (\n    C3,\n    SPP,\n    SPPF,\n    Bottleneck,\n    BottleneckCSP,\n    C3x,\n    Concat,\n    Conv,\n    CrossConv,\n    DWConv,\n    DWConvTranspose2d,\n    Focus,\n    autopad,\n)\nfrom models.experimental import MixConv2d, attempt_load\nfrom models.yolo import Detect, Segment\nfrom utils.activations import SiLU\nfrom utils.general import LOGGER, make_divisible, print_args\n\n\nclass TFBN(keras.layers.Layer):\n    # TensorFlow BatchNormalization wrapper\n    def __init__(self, w=None):\n        \"\"\"Initializes a TensorFlow BatchNormalization layer with optional pretrained weights.\"\"\"\n        super().__init__()\n        self.bn = keras.layers.BatchNormalization(\n            beta_initializer=keras.initializers.Constant(w.bias.numpy()),\n            gamma_initializer=keras.initializers.Constant(w.weight.numpy()),\n            moving_mean_initializer=keras.initializers.Constant(w.running_mean.numpy()),\n            moving_variance_initializer=keras.initializers.Constant(w.running_var.numpy()),\n            epsilon=w.eps,\n        )\n\n    def call(self, inputs):\n        \"\"\"Applies batch normalization to the inputs.\"\"\"\n        return self.bn(inputs)\n\n\nclass TFPad(keras.layers.Layer):\n    # Pad inputs in spatial dimensions 1 and 2\n    def __init__(self, pad):\n        \"\"\"\n        Initializes a padding layer for spatial dimensions 1 and 2 with specified padding, supporting both int and tuple\n        inputs.\n\n        Inputs are\n        \"\"\"\n        super().__init__()\n        if isinstance(pad, int):\n            self.pad = tf.constant([[0, 0], [pad, pad], [pad, pad], [0, 0]])\n        else:  # tuple/list\n            self.pad = tf.constant([[0, 0], [pad[0], pad[0]], [pad[1], pad[1]], [0, 0]])\n\n    def call(self, inputs):\n        \"\"\"Pads input tensor with zeros using specified padding, suitable for int and tuple pad dimensions.\"\"\"\n        return tf.pad(inputs, self.pad, mode=\"constant\", constant_values=0)\n\n\nclass TFConv(keras.layers.Layer):\n    # Standard convolution\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n        \"\"\"\n        Initializes a standard convolution layer with optional batch normalization and activation; supports only\n        group=1.\n\n        Inputs are ch_in, ch_out, weights, kernel, stride, padding, groups.\n        \"\"\"\n        super().__init__()\n        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n        # TensorFlow convolution padding is inconsistent with PyTorch (e.g. k=3 s=2 'SAME' padding)\n        # see https://stackoverflow.com/questions/52975843/comparing-conv2d-with-padding-between-tensorflow-and-pytorch\n        conv = keras.layers.Conv2D(\n            filters=c2,\n            kernel_size=k,\n            strides=s,\n            padding=\"SAME\" if s == 1 else \"VALID\",\n            use_bias=not hasattr(w, \"bn\"),\n            kernel_initializer=keras.initializers.Constant(w.conv.weight.permute(2, 3, 1, 0).numpy()),\n            bias_initializer=\"zeros\" if hasattr(w, \"bn\") else keras.initializers.Constant(w.conv.bias.numpy()),\n        )\n        self.conv = conv if s == 1 else keras.Sequential([TFPad(autopad(k, p)), conv])\n        self.bn = TFBN(w.bn) if hasattr(w, \"bn\") else tf.identity\n        self.act = activations(w.act) if act else tf.identity\n\n    def call(self, inputs):\n        \"\"\"Applies convolution, batch normalization, and activation function to input tensors.\"\"\"\n        return self.act(self.bn(self.conv(inputs)))\n\n\nclass TFDWConv(keras.layers.Layer):\n    # Depthwise convolution\n    def __init__(self, c1, c2, k=1, s=1, p=None, act=True, w=None):\n        \"\"\"\n        Initializes a depthwise convolution layer with optional batch normalization and activation for TensorFlow\n        models.\n\n        Input are ch_in, ch_out, weights, kernel, stride, padding, groups.\n        \"\"\"\n        super().__init__()\n        assert c2 % c1 == 0, f\"TFDWConv() output={c2} must be a multiple of input={c1} channels\"\n        conv = keras.layers.DepthwiseConv2D(\n            kernel_size=k,\n            depth_multiplier=c2 // c1,\n            strides=s,\n            padding=\"SAME\" if s == 1 else \"VALID\",\n            use_bias=not hasattr(w, \"bn\"),\n            depthwise_initializer=keras.initializers.Constant(w.conv.weight.permute(2, 3, 1, 0).numpy()),\n            bias_initializer=\"zeros\" if hasattr(w, \"bn\") else keras.initializers.Constant(w.conv.bias.numpy()),\n        )\n        self.conv = conv if s == 1 else keras.Sequential([TFPad(autopad(k, p)), conv])\n        self.bn = TFBN(w.bn) if hasattr(w, \"bn\") else tf.identity\n        self.act = activations(w.act) if act else tf.identity\n\n    def call(self, inputs):\n        \"\"\"Applies convolution, batch normalization, and activation function to input tensors.\"\"\"\n        return self.act(self.bn(self.conv(inputs)))\n\n\nclass TFDWConvTranspose2d(keras.layers.Layer):\n    # Depthwise ConvTranspose2d\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0, w=None):\n        \"\"\"\n        Initializes depthwise ConvTranspose2D layer with specific channel, kernel, stride, and padding settings.\n\n        Inputs are ch_in, ch_out, weights, kernel, stride, padding, groups.\n        \"\"\"\n        super().__init__()\n        assert c1 == c2, f\"TFDWConv() output={c2} must be equal to input={c1} channels\"\n        assert k == 4 and p1 == 1, \"TFDWConv() only valid for k=4 and p1=1\"\n        weight, bias = w.weight.permute(2, 3, 1, 0).numpy(), w.bias.numpy()\n        self.c1 = c1\n        self.conv = [\n            keras.layers.Conv2DTranspose(\n                filters=1,\n                kernel_size=k,\n                strides=s,\n                padding=\"VALID\",\n                output_padding=p2,\n                use_bias=True,\n                kernel_initializer=keras.initializers.Constant(weight[..., i : i + 1]),\n                bias_initializer=keras.initializers.Constant(bias[i]),\n            )\n            for i in range(c1)\n        ]\n\n    def call(self, inputs):\n        \"\"\"Processes input through parallel convolutions and concatenates results, trimming border pixels.\"\"\"\n        return tf.concat([m(x) for m, x in zip(self.conv, tf.split(inputs, self.c1, 3))], 3)[:, 1:-1, 1:-1]\n\n\nclass TFFocus(keras.layers.Layer):\n    # Focus wh information into c-space\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n        \"\"\"\n        Initializes TFFocus layer to focus width and height information into channel space with custom convolution\n        parameters.\n\n        Inputs are ch_in, ch_out, kernel, stride, padding, groups.\n        \"\"\"\n        super().__init__()\n        self.conv = TFConv(c1 * 4, c2, k, s, p, g, act, w.conv)\n\n    def call(self, inputs):\n        \"\"\"\n        Performs pixel shuffling and convolution on input tensor, downsampling by 2 and expanding channels by 4.\n\n        Example x(b,w,h,c) -> y(b,w/2,h/2,4c).\n        \"\"\"\n        inputs = [inputs[:, ::2, ::2, :], inputs[:, 1::2, ::2, :], inputs[:, ::2, 1::2, :], inputs[:, 1::2, 1::2, :]]\n        return self.conv(tf.concat(inputs, 3))\n\n\nclass TFBottleneck(keras.layers.Layer):\n    # Standard bottleneck\n    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5, w=None):\n        \"\"\"\n        Initializes a standard bottleneck layer for TensorFlow models, expanding and contracting channels with optional\n        shortcut.\n\n        Arguments are ch_in, ch_out, shortcut, groups, expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_, c2, 3, 1, g=g, w=w.cv2)\n        self.add = shortcut and c1 == c2\n\n    def call(self, inputs):\n        \"\"\"Performs forward pass; if shortcut is True & input/output channels match, adds input to the convolution\n        result.\n        \"\"\"\n        return inputs + self.cv2(self.cv1(inputs)) if self.add else self.cv2(self.cv1(inputs))\n\n\nclass TFCrossConv(keras.layers.Layer):\n    # Cross Convolution\n    def __init__(self, c1, c2, k=3, s=1, g=1, e=1.0, shortcut=False, w=None):\n        \"\"\"Initializes cross convolution layer with optional expansion, grouping, and shortcut addition capabilities.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, (1, k), (1, s), w=w.cv1)\n        self.cv2 = TFConv(c_, c2, (k, 1), (s, 1), g=g, w=w.cv2)\n        self.add = shortcut and c1 == c2\n\n    def call(self, inputs):\n        \"\"\"Passes input through two convolutions optionally adding the input if channel dimensions match.\"\"\"\n        return inputs + self.cv2(self.cv1(inputs)) if self.add else self.cv2(self.cv1(inputs))\n\n\nclass TFConv2d(keras.layers.Layer):\n    # Substitution for PyTorch nn.Conv2D\n    def __init__(self, c1, c2, k, s=1, g=1, bias=True, w=None):\n        \"\"\"Initializes a TensorFlow 2D convolution layer, mimicking PyTorch's nn.Conv2D functionality for given filter\n        sizes and stride.\n        \"\"\"\n        super().__init__()\n        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n        self.conv = keras.layers.Conv2D(\n            filters=c2,\n            kernel_size=k,\n            strides=s,\n            padding=\"VALID\",\n            use_bias=bias,\n            kernel_initializer=keras.initializers.Constant(w.weight.permute(2, 3, 1, 0).numpy()),\n            bias_initializer=keras.initializers.Constant(w.bias.numpy()) if bias else None,\n        )\n\n    def call(self, inputs):\n        \"\"\"Applies a convolution operation to the inputs and returns the result.\"\"\"\n        return self.conv(inputs)\n\n\nclass TFBottleneckCSP(keras.layers.Layer):\n    # CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        \"\"\"\n        Initializes CSP bottleneck layer with specified channel sizes, count, shortcut option, groups, and expansion\n        ratio.\n\n        Inputs are ch_in, ch_out, number, shortcut, groups, expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv2d(c1, c_, 1, 1, bias=False, w=w.cv2)\n        self.cv3 = TFConv2d(c_, c_, 1, 1, bias=False, w=w.cv3)\n        self.cv4 = TFConv(2 * c_, c2, 1, 1, w=w.cv4)\n        self.bn = TFBN(w.bn)\n        self.act = lambda x: keras.activations.swish(x)\n        self.m = keras.Sequential([TFBottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])\n\n    def call(self, inputs):\n        \"\"\"Processes input through the model layers, concatenates, normalizes, activates, and reduces the output\n        dimensions.\n        \"\"\"\n        y1 = self.cv3(self.m(self.cv1(inputs)))\n        y2 = self.cv2(inputs)\n        return self.cv4(self.act(self.bn(tf.concat((y1, y2), axis=3))))\n\n\nclass TFC3(keras.layers.Layer):\n    # CSP Bottleneck with 3 convolutions\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        \"\"\"\n        Initializes CSP Bottleneck with 3 convolutions, supporting optional shortcuts and group convolutions.\n\n        Inputs are ch_in, ch_out, number, shortcut, groups, expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c1, c_, 1, 1, w=w.cv2)\n        self.cv3 = TFConv(2 * c_, c2, 1, 1, w=w.cv3)\n        self.m = keras.Sequential([TFBottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])\n\n    def call(self, inputs):\n        \"\"\"\n        Processes input through a sequence of transformations for object detection (YOLOv5).\n\n        See https://github.com/ultralytics/yolov5.\n        \"\"\"\n        return self.cv3(tf.concat((self.m(self.cv1(inputs)), self.cv2(inputs)), axis=3))\n\n\nclass TFC3x(keras.layers.Layer):\n    # 3 module with cross-convolutions\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        \"\"\"\n        Initializes layer with cross-convolutions for enhanced feature extraction in object detection models.\n\n        Inputs are ch_in, ch_out, number, shortcut, groups, expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c1, c_, 1, 1, w=w.cv2)\n        self.cv3 = TFConv(2 * c_, c2, 1, 1, w=w.cv3)\n        self.m = keras.Sequential(\n            [TFCrossConv(c_, c_, k=3, s=1, g=g, e=1.0, shortcut=shortcut, w=w.m[j]) for j in range(n)]\n        )\n\n    def call(self, inputs):\n        \"\"\"Processes input through cascaded convolutions and merges features, returning the final tensor output.\"\"\"\n        return self.cv3(tf.concat((self.m(self.cv1(inputs)), self.cv2(inputs)), axis=3))\n\n\nclass TFSPP(keras.layers.Layer):\n    # Spatial pyramid pooling layer used in YOLOv3-SPP\n    def __init__(self, c1, c2, k=(5, 9, 13), w=None):\n        \"\"\"Initializes a YOLOv3-SPP layer with specific input/output channels and kernel sizes for pooling.\"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_ * (len(k) + 1), c2, 1, 1, w=w.cv2)\n        self.m = [keras.layers.MaxPool2D(pool_size=x, strides=1, padding=\"SAME\") for x in k]\n\n    def call(self, inputs):\n        \"\"\"Processes input through two TFConv layers and concatenates with max-pooled outputs at intermediate stage.\"\"\"\n        x = self.cv1(inputs)\n        return self.cv2(tf.concat([x] + [m(x) for m in self.m], 3))\n\n\nclass TFSPPF(keras.layers.Layer):\n    # Spatial pyramid pooling-Fast layer\n    def __init__(self, c1, c2, k=5, w=None):\n        \"\"\"Initializes a fast spatial pyramid pooling layer with customizable in/out channels, kernel size, and\n        weights.\n        \"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_ * 4, c2, 1, 1, w=w.cv2)\n        self.m = keras.layers.MaxPool2D(pool_size=k, strides=1, padding=\"SAME\")\n\n    def call(self, inputs):\n        \"\"\"Executes the model's forward pass, concatenating input features with three max-pooled versions before final\n        convolution.\n        \"\"\"\n        x = self.cv1(inputs)\n        y1 = self.m(x)\n        y2 = self.m(y1)\n        return self.cv2(tf.concat([x, y1, y2, self.m(y2)], 3))\n\n\nclass TFDetect(keras.layers.Layer):\n    # TF YOLOv5 Detect layer\n    def __init__(self, nc=80, anchors=(), ch=(), imgsz=(640, 640), w=None):\n        \"\"\"Initializes YOLOv5 detection layer for TensorFlow with configurable classes, anchors, channels, and image\n        size.\n        \"\"\"\n        super().__init__()\n        self.stride = tf.convert_to_tensor(w.stride.numpy(), dtype=tf.float32)\n        self.nc = nc  # number of classes\n        self.no = nc + 5  # number of outputs per anchor\n        self.nl = len(anchors)  # number of detection layers\n        self.na = len(anchors[0]) // 2  # number of anchors\n        self.grid = [tf.zeros(1)] * self.nl  # init grid\n        self.anchors = tf.convert_to_tensor(w.anchors.numpy(), dtype=tf.float32)\n        self.anchor_grid = tf.reshape(self.anchors * tf.reshape(self.stride, [self.nl, 1, 1]), [self.nl, 1, -1, 1, 2])\n        self.m = [TFConv2d(x, self.no * self.na, 1, w=w.m[i]) for i, x in enumerate(ch)]\n        self.training = False  # set to False after building model\n        self.imgsz = imgsz\n        for i in range(self.nl):\n            ny, nx = self.imgsz[0] // self.stride[i], self.imgsz[1] // self.stride[i]\n            self.grid[i] = self._make_grid(nx, ny)\n\n    def call(self, inputs):\n        \"\"\"Performs forward pass through the model layers to predict object bounding boxes and classifications.\"\"\"\n        z = []  # inference output\n        x = []\n        for i in range(self.nl):\n            x.append(self.m[i](inputs[i]))\n            # x(bs,20,20,255) to x(bs,3,20,20,85)\n            ny, nx = self.imgsz[0] // self.stride[i], self.imgsz[1] // self.stride[i]\n            x[i] = tf.reshape(x[i], [-1, ny * nx, self.na, self.no])\n\n            if not self.training:  # inference\n                y = x[i]\n                grid = tf.transpose(self.grid[i], [0, 2, 1, 3]) - 0.5\n                anchor_grid = tf.transpose(self.anchor_grid[i], [0, 2, 1, 3]) * 4\n                xy = (tf.sigmoid(y[..., 0:2]) * 2 + grid) * self.stride[i]  # xy\n                wh = tf.sigmoid(y[..., 2:4]) ** 2 * anchor_grid\n                # Normalize xywh to 0-1 to reduce calibration error\n                xy /= tf.constant([[self.imgsz[1], self.imgsz[0]]], dtype=tf.float32)\n                wh /= tf.constant([[self.imgsz[1], self.imgsz[0]]], dtype=tf.float32)\n                y = tf.concat([xy, wh, tf.sigmoid(y[..., 4 : 5 + self.nc]), y[..., 5 + self.nc :]], -1)\n                z.append(tf.reshape(y, [-1, self.na * ny * nx, self.no]))\n\n        return tf.transpose(x, [0, 2, 1, 3]) if self.training else (tf.concat(z, 1),)\n\n    @staticmethod\n    def _make_grid(nx=20, ny=20):\n        \"\"\"Generates a 2D grid of coordinates in (x, y) format with shape [1, 1, ny*nx, 2].\"\"\"\n        # return torch.stack((xv, yv), 2).view((1, 1, ny, nx, 2)).float()\n        xv, yv = tf.meshgrid(tf.range(nx), tf.range(ny))\n        return tf.cast(tf.reshape(tf.stack([xv, yv], 2), [1, 1, ny * nx, 2]), dtype=tf.float32)\n\n\nclass TFSegment(TFDetect):\n    # YOLOv5 Segment head for segmentation models\n    def __init__(self, nc=80, anchors=(), nm=32, npr=256, ch=(), imgsz=(640, 640), w=None):\n        \"\"\"Initializes YOLOv5 Segment head with specified channel depths, anchors, and input size for segmentation\n        models.\n        \"\"\"\n        super().__init__(nc, anchors, ch, imgsz, w)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.no = 5 + nc + self.nm  # number of outputs per anchor\n        self.m = [TFConv2d(x, self.no * self.na, 1, w=w.m[i]) for i, x in enumerate(ch)]  # output conv\n        self.proto = TFProto(ch[0], self.npr, self.nm, w=w.proto)  # protos\n        self.detect = TFDetect.call\n\n    def call(self, x):\n        \"\"\"Applies detection and proto layers on input, returning detections and optionally protos if training.\"\"\"\n        p = self.proto(x[0])\n        # p = TFUpsample(None, scale_factor=4, mode='nearest')(self.proto(x[0]))  # (optional) full-size protos\n        p = tf.transpose(p, [0, 3, 1, 2])  # from shape(1,160,160,32) to shape(1,32,160,160)\n        x = self.detect(self, x)\n        return (x, p) if self.training else (x[0], p)\n\n\nclass TFProto(keras.layers.Layer):\n    def __init__(self, c1, c_=256, c2=32, w=None):\n        \"\"\"Initializes TFProto layer with convolutional and upsampling layers for feature extraction and\n        transformation.\n        \"\"\"\n        super().__init__()\n        self.cv1 = TFConv(c1, c_, k=3, w=w.cv1)\n        self.upsample = TFUpsample(None, scale_factor=2, mode=\"nearest\")\n        self.cv2 = TFConv(c_, c_, k=3, w=w.cv2)\n        self.cv3 = TFConv(c_, c2, w=w.cv3)\n\n    def call(self, inputs):\n        \"\"\"Performs forward pass through the model, applying convolutions and upscaling on input tensor.\"\"\"\n        return self.cv3(self.cv2(self.upsample(self.cv1(inputs))))\n\n\nclass TFUpsample(keras.layers.Layer):\n    # TF version of torch.nn.Upsample()\n    def __init__(self, size, scale_factor, mode, w=None):\n        \"\"\"\n        Initializes a TensorFlow upsampling layer with specified size, scale_factor, and mode, ensuring scale_factor is\n        even.\n\n        Warning: all arguments needed including 'w'\n        \"\"\"\n        super().__init__()\n        assert scale_factor % 2 == 0, \"scale_factor must be multiple of 2\"\n        self.upsample = lambda x: tf.image.resize(x, (x.shape[1] * scale_factor, x.shape[2] * scale_factor), mode)\n        # self.upsample = keras.layers.UpSampling2D(size=scale_factor, interpolation=mode)\n        # with default arguments: align_corners=False, half_pixel_centers=False\n        # self.upsample = lambda x: tf.raw_ops.ResizeNearestNeighbor(images=x,\n        #                                                            size=(x.shape[1] * 2, x.shape[2] * 2))\n\n    def call(self, inputs):\n        \"\"\"Applies upsample operation to inputs using nearest neighbor interpolation.\"\"\"\n        return self.upsample(inputs)\n\n\nclass TFConcat(keras.layers.Layer):\n    # TF version of torch.concat()\n    def __init__(self, dimension=1, w=None):\n        \"\"\"Initializes a TensorFlow layer for NCHW to NHWC concatenation, requiring dimension=1.\"\"\"\n        super().__init__()\n        assert dimension == 1, \"convert only NCHW to NHWC concat\"\n        self.d = 3\n\n    def call(self, inputs):\n        \"\"\"Concatenates a list of tensors along the last dimension, used for NCHW to NHWC conversion.\"\"\"\n        return tf.concat(inputs, self.d)\n\n\ndef parse_model(d, ch, model, imgsz):\n    \"\"\"Parses a model definition dict `d` to create YOLOv5 model layers, including dynamic channel adjustments.\"\"\"\n    LOGGER.info(f\"\\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}\")\n    anchors, nc, gd, gw, ch_mul = (\n        d[\"anchors\"],\n        d[\"nc\"],\n        d[\"depth_multiple\"],\n        d[\"width_multiple\"],\n        d.get(\"channel_multiple\"),\n    )\n    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors\n    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)\n    if not ch_mul:\n        ch_mul = 8\n\n    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n    for i, (f, n, m, args) in enumerate(d[\"backbone\"] + d[\"head\"]):  # from, number, module, args\n        m_str = m\n        m = eval(m) if isinstance(m, str) else m  # eval strings\n        for j, a in enumerate(args):\n            try:\n                args[j] = eval(a) if isinstance(a, str) else a  # eval strings\n            except NameError:\n                pass\n\n        n = max(round(n * gd), 1) if n > 1 else n  # depth gain\n        if m in [\n            nn.Conv2d,\n            Conv,\n            DWConv,\n            DWConvTranspose2d,\n            Bottleneck,\n            SPP,\n            SPPF,\n            MixConv2d,\n            Focus,\n            CrossConv,\n            BottleneckCSP,\n            C3,\n            C3x,\n        ]:\n            c1, c2 = ch[f], args[0]\n            c2 = make_divisible(c2 * gw, ch_mul) if c2 != no else c2\n\n            args = [c1, c2, *args[1:]]\n            if m in [BottleneckCSP, C3, C3x]:\n                args.insert(2, n)\n                n = 1\n        elif m is nn.BatchNorm2d:\n            args = [ch[f]]\n        elif m is Concat:\n            c2 = sum(ch[-1 if x == -1 else x + 1] for x in f)\n        elif m in [Detect, Segment]:\n            args.append([ch[x + 1] for x in f])\n            if isinstance(args[1], int):  # number of anchors\n                args[1] = [list(range(args[1] * 2))] * len(f)\n            if m is Segment:\n                args[3] = make_divisible(args[3] * gw, ch_mul)\n            args.append(imgsz)\n        else:\n            c2 = ch[f]\n\n        tf_m = eval(\"TF\" + m_str.replace(\"nn.\", \"\"))\n        m_ = (\n            keras.Sequential([tf_m(*args, w=model.model[i][j]) for j in range(n)])\n            if n > 1\n            else tf_m(*args, w=model.model[i])\n        )  # module\n\n        torch_m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module\n        t = str(m)[8:-2].replace(\"__main__.\", \"\")  # module type\n        np = sum(x.numel() for x in torch_m_.parameters())  # number params\n        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params\n        LOGGER.info(f\"{i:>3}{str(f):>18}{str(n):>3}{np:>10}  {t:<40}{str(args):<30}\")  # print\n        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n        layers.append(m_)\n        ch.append(c2)\n    return keras.Sequential(layers), sorted(save)\n\n\nclass TFModel:\n    # TF YOLOv5 model\n    def __init__(self, cfg=\"yolov5s.yaml\", ch=3, nc=None, model=None, imgsz=(640, 640)):\n        \"\"\"Initializes TF YOLOv5 model with specified configuration, channels, classes, model instance, and input\n        size.\n        \"\"\"\n        super().__init__()\n        if isinstance(cfg, dict):\n            self.yaml = cfg  # model dict\n        else:  # is *.yaml\n            import yaml  # for torch hub\n\n            self.yaml_file = Path(cfg).name\n            with open(cfg) as f:\n                self.yaml = yaml.load(f, Loader=yaml.FullLoader)  # model dict\n\n        # Define model\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding {cfg} nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml[\"nc\"] = nc  # override yaml value\n        self.model, self.savelist = parse_model(deepcopy(self.yaml), ch=[ch], model=model, imgsz=imgsz)\n\n    def predict(\n        self,\n        inputs,\n        tf_nms=False,\n        agnostic_nms=False,\n        topk_per_class=100,\n        topk_all=100,\n        iou_thres=0.45,\n        conf_thres=0.25,\n    ):\n        y = []  # outputs\n        x = inputs\n        for m in self.model.layers:\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n\n            x = m(x)  # run\n            y.append(x if m.i in self.savelist else None)  # save output\n\n        # Add TensorFlow NMS\n        if tf_nms:\n            boxes = self._xywh2xyxy(x[0][..., :4])\n            probs = x[0][:, :, 4:5]\n            classes = x[0][:, :, 5:]\n            scores = probs * classes\n            if agnostic_nms:\n                nms = AgnosticNMS()((boxes, classes, scores), topk_all, iou_thres, conf_thres)\n            else:\n                boxes = tf.expand_dims(boxes, 2)\n                nms = tf.image.combined_non_max_suppression(\n                    boxes, scores, topk_per_class, topk_all, iou_thres, conf_thres, clip_boxes=False\n                )\n            return (nms,)\n        return x  # output [1,6300,85] = [xywh, conf, class0, class1, ...]\n        # x = x[0]  # [x(1,6300,85), ...] to x(6300,85)\n        # xywh = x[..., :4]  # x(6300,4) boxes\n        # conf = x[..., 4:5]  # x(6300,1) confidences\n        # cls = tf.reshape(tf.cast(tf.argmax(x[..., 5:], axis=1), tf.float32), (-1, 1))  # x(6300,1)  classes\n        # return tf.concat([conf, cls, xywh], 1)\n\n    @staticmethod\n    def _xywh2xyxy(xywh):\n        \"\"\"Converts bounding box format from [x, y, w, h] to [x1, y1, x2, y2], where xy1=top-left and xy2=bottom-\n        right.\n        \"\"\"\n        x, y, w, h = tf.split(xywh, num_or_size_splits=4, axis=-1)\n        return tf.concat([x - w / 2, y - h / 2, x + w / 2, y + h / 2], axis=-1)\n\n\nclass AgnosticNMS(keras.layers.Layer):\n    # TF Agnostic NMS\n    def call(self, input, topk_all, iou_thres, conf_thres):\n        \"\"\"Performs agnostic NMS on input tensors using given thresholds and top-K selection.\"\"\"\n        return tf.map_fn(\n            lambda x: self._nms(x, topk_all, iou_thres, conf_thres),\n            input,\n            fn_output_signature=(tf.float32, tf.float32, tf.float32, tf.int32),\n            name=\"agnostic_nms\",\n        )\n\n    @staticmethod\n    def _nms(x, topk_all=100, iou_thres=0.45, conf_thres=0.25):\n        \"\"\"Performs agnostic non-maximum suppression (NMS) on detected objects, filtering based on IoU and confidence\n        thresholds.\n        \"\"\"\n        boxes, classes, scores = x\n        class_inds = tf.cast(tf.argmax(classes, axis=-1), tf.float32)\n        scores_inp = tf.reduce_max(scores, -1)\n        selected_inds = tf.image.non_max_suppression(\n            boxes, scores_inp, max_output_size=topk_all, iou_threshold=iou_thres, score_threshold=conf_thres\n        )\n        selected_boxes = tf.gather(boxes, selected_inds)\n        padded_boxes = tf.pad(\n            selected_boxes,\n            paddings=[[0, topk_all - tf.shape(selected_boxes)[0]], [0, 0]],\n            mode=\"CONSTANT\",\n            constant_values=0.0,\n        )\n        selected_scores = tf.gather(scores_inp, selected_inds)\n        padded_scores = tf.pad(\n            selected_scores,\n            paddings=[[0, topk_all - tf.shape(selected_boxes)[0]]],\n            mode=\"CONSTANT\",\n            constant_values=-1.0,\n        )\n        selected_classes = tf.gather(class_inds, selected_inds)\n        padded_classes = tf.pad(\n            selected_classes,\n            paddings=[[0, topk_all - tf.shape(selected_boxes)[0]]],\n            mode=\"CONSTANT\",\n            constant_values=-1.0,\n        )\n        valid_detections = tf.shape(selected_inds)[0]\n        return padded_boxes, padded_scores, padded_classes, valid_detections\n\n\ndef activations(act=nn.SiLU):\n    \"\"\"Converts PyTorch activations to TensorFlow equivalents, supporting LeakyReLU, Hardswish, and SiLU/Swish.\"\"\"\n    if isinstance(act, nn.LeakyReLU):\n        return lambda x: keras.activations.relu(x, alpha=0.1)\n    elif isinstance(act, nn.Hardswish):\n        return lambda x: x * tf.nn.relu6(x + 3) * 0.166666667\n    elif isinstance(act, (nn.SiLU, SiLU)):\n        return lambda x: keras.activations.swish(x)\n    else:\n        raise Exception(f\"no matching TensorFlow activation found for PyTorch activation {act}\")\n\n\ndef representative_dataset_gen(dataset, ncalib=100):\n    \"\"\"Generates a representative dataset for calibration by yielding transformed numpy arrays from the input\n    dataset.\n    \"\"\"\n    for n, (path, img, im0s, vid_cap, string) in enumerate(dataset):\n        im = np.transpose(img, [1, 2, 0])\n        im = np.expand_dims(im, axis=0).astype(np.float32)\n        im /= 255\n        yield [im]\n        if n >= ncalib:\n            break\n\n\ndef run(\n    weights=ROOT / \"yolov5s.pt\",  # weights path\n    imgsz=(640, 640),  # inference size h,w\n    batch_size=1,  # batch size\n    dynamic=False,  # dynamic batch size\n):\n    # PyTorch model\n    im = torch.zeros((batch_size, 3, *imgsz))  # BCHW image\n    model = attempt_load(weights, device=torch.device(\"cpu\"), inplace=True, fuse=False)\n    _ = model(im)  # inference\n    model.info()\n\n    # TensorFlow model\n    im = tf.zeros((batch_size, *imgsz, 3))  # BHWC image\n    tf_model = TFModel(cfg=model.yaml, model=model, nc=model.nc, imgsz=imgsz)\n    _ = tf_model.predict(im)  # inference\n\n    # Keras model\n    im = keras.Input(shape=(*imgsz, 3), batch_size=None if dynamic else batch_size)\n    keras_model = keras.Model(inputs=im, outputs=tf_model.predict(im))\n    keras_model.summary()\n\n    LOGGER.info(\"PyTorch, TensorFlow and Keras models successfully verified.\\nUse export.py for TF model export.\")\n\n\ndef parse_opt():\n    \"\"\"Parses and returns command-line options for model inference, including weights path, image size, batch size, and\n    dynamic batching.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=ROOT / \"yolov5s.pt\", help=\"weights path\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", nargs=\"+\", type=int, default=[640], help=\"inference size h,w\")\n    parser.add_argument(\"--batch-size\", type=int, default=1, help=\"batch size\")\n    parser.add_argument(\"--dynamic\", action=\"store_true\", help=\"dynamic batch size\")\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes the YOLOv5 model run function with parsed command line options.\"\"\"\n    run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "models/__init__.py": "", "utils/loss.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Loss functions.\"\"\"\n\nimport torch\nimport torch.nn as nn\n\nfrom utils.metrics import bbox_iou\nfrom utils.torch_utils import de_parallel\n\n\ndef smooth_BCE(eps=0.1):\n    \"\"\"Returns label smoothing BCE targets for reducing overfitting; pos: `1.0 - 0.5*eps`, neg: `0.5*eps`. For details see https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441\"\"\"\n    return 1.0 - 0.5 * eps, 0.5 * eps\n\n\nclass BCEBlurWithLogitsLoss(nn.Module):\n    # BCEwithLogitLoss() with reduced missing label effects.\n    def __init__(self, alpha=0.05):\n        \"\"\"Initializes a modified BCEWithLogitsLoss with reduced missing label effects, taking optional alpha smoothing\n        parameter.\n        \"\"\"\n        super().__init__()\n        self.loss_fcn = nn.BCEWithLogitsLoss(reduction=\"none\")  # must be nn.BCEWithLogitsLoss()\n        self.alpha = alpha\n\n    def forward(self, pred, true):\n        \"\"\"Computes modified BCE loss for YOLOv5 with reduced missing label effects, taking pred and true tensors,\n        returns mean loss.\n        \"\"\"\n        loss = self.loss_fcn(pred, true)\n        pred = torch.sigmoid(pred)  # prob from logits\n        dx = pred - true  # reduce only missing label effects\n        # dx = (pred - true).abs()  # reduce missing label and false label effects\n        alpha_factor = 1 - torch.exp((dx - 1) / (self.alpha + 1e-4))\n        loss *= alpha_factor\n        return loss.mean()\n\n\nclass FocalLoss(nn.Module):\n    # Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5)\n    def __init__(self, loss_fcn, gamma=1.5, alpha=0.25):\n        \"\"\"Initializes FocalLoss with specified loss function, gamma, and alpha values; modifies loss reduction to\n        'none'.\n        \"\"\"\n        super().__init__()\n        self.loss_fcn = loss_fcn  # must be nn.BCEWithLogitsLoss()\n        self.gamma = gamma\n        self.alpha = alpha\n        self.reduction = loss_fcn.reduction\n        self.loss_fcn.reduction = \"none\"  # required to apply FL to each element\n\n    def forward(self, pred, true):\n        \"\"\"Calculates the focal loss between predicted and true labels using a modified BCEWithLogitsLoss.\"\"\"\n        loss = self.loss_fcn(pred, true)\n        # p_t = torch.exp(-loss)\n        # loss *= self.alpha * (1.000001 - p_t) ** self.gamma  # non-zero power for gradient stability\n\n        # TF implementation https://github.com/tensorflow/addons/blob/v0.7.1/tensorflow_addons/losses/focal_loss.py\n        pred_prob = torch.sigmoid(pred)  # prob from logits\n        p_t = true * pred_prob + (1 - true) * (1 - pred_prob)\n        alpha_factor = true * self.alpha + (1 - true) * (1 - self.alpha)\n        modulating_factor = (1.0 - p_t) ** self.gamma\n        loss *= alpha_factor * modulating_factor\n\n        if self.reduction == \"mean\":\n            return loss.mean()\n        elif self.reduction == \"sum\":\n            return loss.sum()\n        else:  # 'none'\n            return loss\n\n\nclass QFocalLoss(nn.Module):\n    # Wraps Quality focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5)\n    def __init__(self, loss_fcn, gamma=1.5, alpha=0.25):\n        \"\"\"Initializes Quality Focal Loss with given loss function, gamma, alpha; modifies reduction to 'none'.\"\"\"\n        super().__init__()\n        self.loss_fcn = loss_fcn  # must be nn.BCEWithLogitsLoss()\n        self.gamma = gamma\n        self.alpha = alpha\n        self.reduction = loss_fcn.reduction\n        self.loss_fcn.reduction = \"none\"  # required to apply FL to each element\n\n    def forward(self, pred, true):\n        \"\"\"Computes the focal loss between `pred` and `true` using BCEWithLogitsLoss, adjusting for imbalance with\n        `gamma` and `alpha`.\n        \"\"\"\n        loss = self.loss_fcn(pred, true)\n\n        pred_prob = torch.sigmoid(pred)  # prob from logits\n        alpha_factor = true * self.alpha + (1 - true) * (1 - self.alpha)\n        modulating_factor = torch.abs(true - pred_prob) ** self.gamma\n        loss *= alpha_factor * modulating_factor\n\n        if self.reduction == \"mean\":\n            return loss.mean()\n        elif self.reduction == \"sum\":\n            return loss.sum()\n        else:  # 'none'\n            return loss\n\n\nclass ComputeLoss:\n    sort_obj_iou = False\n\n    # Compute losses\n    def __init__(self, model, autobalance=False):\n        \"\"\"Initializes ComputeLoss with model and autobalance option, autobalances losses if True.\"\"\"\n        device = next(model.parameters()).device  # get model device\n        h = model.hyp  # hyperparameters\n\n        # Define criteria\n        BCEcls = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h[\"cls_pw\"]], device=device))\n        BCEobj = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h[\"obj_pw\"]], device=device))\n\n        # Class label smoothing https://arxiv.org/pdf/1902.04103.pdf eqn 3\n        self.cp, self.cn = smooth_BCE(eps=h.get(\"label_smoothing\", 0.0))  # positive, negative BCE targets\n\n        # Focal loss\n        g = h[\"fl_gamma\"]  # focal loss gamma\n        if g > 0:\n            BCEcls, BCEobj = FocalLoss(BCEcls, g), FocalLoss(BCEobj, g)\n\n        m = de_parallel(model).model[-1]  # Detect() module\n        self.balance = {3: [4.0, 1.0, 0.4]}.get(m.nl, [4.0, 1.0, 0.25, 0.06, 0.02])  # P3-P7\n        self.ssi = list(m.stride).index(16) if autobalance else 0  # stride 16 index\n        self.BCEcls, self.BCEobj, self.gr, self.hyp, self.autobalance = BCEcls, BCEobj, 1.0, h, autobalance\n        self.na = m.na  # number of anchors\n        self.nc = m.nc  # number of classes\n        self.nl = m.nl  # number of layers\n        self.anchors = m.anchors\n        self.device = device\n\n    def __call__(self, p, targets):  # predictions, targets\n        \"\"\"Performs forward pass, calculating class, box, and object loss for given predictions and targets.\"\"\"\n        lcls = torch.zeros(1, device=self.device)  # class loss\n        lbox = torch.zeros(1, device=self.device)  # box loss\n        lobj = torch.zeros(1, device=self.device)  # object loss\n        tcls, tbox, indices, anchors = self.build_targets(p, targets)  # targets\n\n        # Losses\n        for i, pi in enumerate(p):  # layer index, layer predictions\n            b, a, gj, gi = indices[i]  # image, anchor, gridy, gridx\n            tobj = torch.zeros(pi.shape[:4], dtype=pi.dtype, device=self.device)  # target obj\n\n            n = b.shape[0]  # number of targets\n            if n:\n                # pxy, pwh, _, pcls = pi[b, a, gj, gi].tensor_split((2, 4, 5), dim=1)  # faster, requires torch 1.8.0\n                pxy, pwh, _, pcls = pi[b, a, gj, gi].split((2, 2, 1, self.nc), 1)  # target-subset of predictions\n\n                # Regression\n                pxy = pxy.sigmoid() * 2 - 0.5\n                pwh = (pwh.sigmoid() * 2) ** 2 * anchors[i]\n                pbox = torch.cat((pxy, pwh), 1)  # predicted box\n                iou = bbox_iou(pbox, tbox[i], CIoU=True).squeeze()  # iou(prediction, target)\n                lbox += (1.0 - iou).mean()  # iou loss\n\n                # Objectness\n                iou = iou.detach().clamp(0).type(tobj.dtype)\n                if self.sort_obj_iou:\n                    j = iou.argsort()\n                    b, a, gj, gi, iou = b[j], a[j], gj[j], gi[j], iou[j]\n                if self.gr < 1:\n                    iou = (1.0 - self.gr) + self.gr * iou\n                tobj[b, a, gj, gi] = iou  # iou ratio\n\n                # Classification\n                if self.nc > 1:  # cls loss (only if multiple classes)\n                    t = torch.full_like(pcls, self.cn, device=self.device)  # targets\n                    t[range(n), tcls[i]] = self.cp\n                    lcls += self.BCEcls(pcls, t)  # BCE\n\n                # Append targets to text file\n                # with open('targets.txt', 'a') as file:\n                #     [file.write('%11.5g ' * 4 % tuple(x) + '\\n') for x in torch.cat((txy[i], twh[i]), 1)]\n\n            obji = self.BCEobj(pi[..., 4], tobj)\n            lobj += obji * self.balance[i]  # obj loss\n            if self.autobalance:\n                self.balance[i] = self.balance[i] * 0.9999 + 0.0001 / obji.detach().item()\n\n        if self.autobalance:\n            self.balance = [x / self.balance[self.ssi] for x in self.balance]\n        lbox *= self.hyp[\"box\"]\n        lobj *= self.hyp[\"obj\"]\n        lcls *= self.hyp[\"cls\"]\n        bs = tobj.shape[0]  # batch size\n\n        return (lbox + lobj + lcls) * bs, torch.cat((lbox, lobj, lcls)).detach()\n\n    def build_targets(self, p, targets):\n        \"\"\"Prepares model targets from input targets (image,class,x,y,w,h) for loss computation, returning class, box,\n        indices, and anchors.\n        \"\"\"\n        na, nt = self.na, targets.shape[0]  # number of anchors, targets\n        tcls, tbox, indices, anch = [], [], [], []\n        gain = torch.ones(7, device=self.device)  # normalized to gridspace gain\n        ai = torch.arange(na, device=self.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)\n        targets = torch.cat((targets.repeat(na, 1, 1), ai[..., None]), 2)  # append anchor indices\n\n        g = 0.5  # bias\n        off = (\n            torch.tensor(\n                [\n                    [0, 0],\n                    [1, 0],\n                    [0, 1],\n                    [-1, 0],\n                    [0, -1],  # j,k,l,m\n                    # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm\n                ],\n                device=self.device,\n            ).float()\n            * g\n        )  # offsets\n\n        for i in range(self.nl):\n            anchors, shape = self.anchors[i], p[i].shape\n            gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]]  # xyxy gain\n\n            # Match targets to anchors\n            t = targets * gain  # shape(3,n,7)\n            if nt:\n                # Matches\n                r = t[..., 4:6] / anchors[:, None]  # wh ratio\n                j = torch.max(r, 1 / r).max(2)[0] < self.hyp[\"anchor_t\"]  # compare\n                # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))\n                t = t[j]  # filter\n\n                # Offsets\n                gxy = t[:, 2:4]  # grid xy\n                gxi = gain[[2, 3]] - gxy  # inverse\n                j, k = ((gxy % 1 < g) & (gxy > 1)).T\n                l, m = ((gxi % 1 < g) & (gxi > 1)).T\n                j = torch.stack((torch.ones_like(j), j, k, l, m))\n                t = t.repeat((5, 1, 1))[j]\n                offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]\n            else:\n                t = targets[0]\n                offsets = 0\n\n            # Define\n            bc, gxy, gwh, a = t.chunk(4, 1)  # (image, class), grid xy, grid wh, anchors\n            a, (b, c) = a.long().view(-1), bc.long().T  # anchors, image, class\n            gij = (gxy - offsets).long()\n            gi, gj = gij.T  # grid indices\n\n            # Append\n            indices.append((b, a, gj.clamp_(0, shape[2] - 1), gi.clamp_(0, shape[3] - 1)))  # image, anchor, grid\n            tbox.append(torch.cat((gxy - gij, gwh), 1))  # box\n            anch.append(anchors[a])  # anchors\n            tcls.append(c)  # class\n\n        return tcls, tbox, indices, anch\n", "utils/torch_utils.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"PyTorch utils.\"\"\"\n\nimport math\nimport os\nimport platform\nimport subprocess\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport torch\nimport torch.distributed as dist\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torch.nn.parallel import DistributedDataParallel as DDP\n\nfrom utils.general import LOGGER, check_version, colorstr, file_date, git_describe\n\nLOCAL_RANK = int(os.getenv(\"LOCAL_RANK\", -1))  # https://pytorch.org/docs/stable/elastic/run.html\nRANK = int(os.getenv(\"RANK\", -1))\nWORLD_SIZE = int(os.getenv(\"WORLD_SIZE\", 1))\n\ntry:\n    import thop  # for FLOPs computation\nexcept ImportError:\n    thop = None\n\n# Suppress PyTorch warnings\nwarnings.filterwarnings(\"ignore\", message=\"User provided device_type of 'cuda', but CUDA is not available. Disabling\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\n\ndef smart_inference_mode(torch_1_9=check_version(torch.__version__, \"1.9.0\")):\n    \"\"\"Applies torch.inference_mode() if torch>=1.9.0, else torch.no_grad() as a decorator for functions.\"\"\"\n\n    def decorate(fn):\n        return (torch.inference_mode if torch_1_9 else torch.no_grad)()(fn)\n\n    return decorate\n\n\ndef smartCrossEntropyLoss(label_smoothing=0.0):\n    \"\"\"Returns a CrossEntropyLoss with optional label smoothing for torch>=1.10.0; warns if smoothing on lower\n    versions.\n    \"\"\"\n    if check_version(torch.__version__, \"1.10.0\"):\n        return nn.CrossEntropyLoss(label_smoothing=label_smoothing)\n    if label_smoothing > 0:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f label smoothing {label_smoothing} requires torch>=1.10.0\")\n    return nn.CrossEntropyLoss()\n\n\ndef smart_DDP(model):\n    \"\"\"Initializes DistributedDataParallel (DDP) for model training, respecting torch version constraints.\"\"\"\n    assert not check_version(torch.__version__, \"1.12.0\", pinned=True), (\n        \"torch==1.12.0 torchvision==0.13.0 DDP training is not supported due to a known issue. \"\n        \"Please upgrade or downgrade torch to use DDP. See https://github.com/ultralytics/yolov5/issues/8395\"\n    )\n    if check_version(torch.__version__, \"1.11.0\"):\n        return DDP(model, device_ids=[LOCAL_RANK], output_device=LOCAL_RANK, static_graph=True)\n    else:\n        return DDP(model, device_ids=[LOCAL_RANK], output_device=LOCAL_RANK)\n\n\ndef reshape_classifier_output(model, n=1000):\n    \"\"\"Reshapes last layer of model to match class count 'n', supporting Classify, Linear, Sequential types.\"\"\"\n    from models.common import Classify\n\n    name, m = list((model.model if hasattr(model, \"model\") else model).named_children())[-1]  # last module\n    if isinstance(m, Classify):  # YOLOv5 Classify() head\n        if m.linear.out_features != n:\n            m.linear = nn.Linear(m.linear.in_features, n)\n    elif isinstance(m, nn.Linear):  # ResNet, EfficientNet\n        if m.out_features != n:\n            setattr(model, name, nn.Linear(m.in_features, n))\n    elif isinstance(m, nn.Sequential):\n        types = [type(x) for x in m]\n        if nn.Linear in types:\n            i = len(types) - 1 - types[::-1].index(nn.Linear)  # last nn.Linear index\n            if m[i].out_features != n:\n                m[i] = nn.Linear(m[i].in_features, n)\n        elif nn.Conv2d in types:\n            i = len(types) - 1 - types[::-1].index(nn.Conv2d)  # last nn.Conv2d index\n            if m[i].out_channels != n:\n                m[i] = nn.Conv2d(m[i].in_channels, n, m[i].kernel_size, m[i].stride, bias=m[i].bias is not None)\n\n\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Context manager ensuring ordered operations in distributed training by making all processes wait for the leading\n    process.\n    \"\"\"\n    if local_rank not in [-1, 0]:\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if local_rank == 0:\n        dist.barrier(device_ids=[0])\n\n\ndef device_count():\n    \"\"\"Returns the number of available CUDA devices; works on Linux and Windows by invoking `nvidia-smi`.\"\"\"\n    assert platform.system() in (\"Linux\", \"Windows\"), \"device_count() only supported on Linux or Windows\"\n    try:\n        cmd = \"nvidia-smi -L | wc -l\" if platform.system() == \"Linux\" else 'nvidia-smi -L | find /c /v \"\"'  # Windows\n        return int(subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1])\n    except Exception:\n        return 0\n\n\ndef select_device(device=\"\", batch_size=0, newline=True):\n    \"\"\"Selects computing device (CPU, CUDA GPU, MPS) for YOLOv5 model deployment, logging device info.\"\"\"\n    s = f\"YOLOv5 \ud83d\ude80 {git_describe() or file_date()} Python-{platform.python_version()} torch-{torch.__version__} \"\n    device = str(device).strip().lower().replace(\"cuda:\", \"\").replace(\"none\", \"\")  # to string, 'cuda:0' to '0'\n    cpu = device == \"cpu\"\n    mps = device == \"mps\"  # Apple Metal Performance Shaders (MPS)\n    if cpu or mps:\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"  # force torch.cuda.is_available() = False\n    elif device:  # non-cpu device requested\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = device  # set environment variable - must be before assert is_available()\n        assert torch.cuda.is_available() and torch.cuda.device_count() >= len(\n            device.replace(\",\", \"\")\n        ), f\"Invalid CUDA '--device {device}' requested, use '--device cpu' or pass valid CUDA device(s)\"\n\n    if not cpu and not mps and torch.cuda.is_available():  # prefer GPU if available\n        devices = device.split(\",\") if device else \"0\"  # range(torch.cuda.device_count())  # i.e. 0,1,6,7\n        n = len(devices)  # device count\n        if n > 1 and batch_size > 0:  # check batch_size is divisible by device_count\n            assert batch_size % n == 0, f\"batch-size {batch_size} not multiple of GPU count {n}\"\n        space = \" \" * (len(s) + 1)\n        for i, d in enumerate(devices):\n            p = torch.cuda.get_device_properties(i)\n            s += f\"{'' if i == 0 else space}CUDA:{d} ({p.name}, {p.total_memory / (1 << 20):.0f}MiB)\\n\"  # bytes to MB\n        arg = \"cuda:0\"\n    elif mps and getattr(torch, \"has_mps\", False) and torch.backends.mps.is_available():  # prefer MPS if available\n        s += \"MPS\\n\"\n        arg = \"mps\"\n    else:  # revert to CPU\n        s += \"CPU\\n\"\n        arg = \"cpu\"\n\n    if not newline:\n        s = s.rstrip()\n    LOGGER.info(s)\n    return torch.device(arg)\n\n\ndef time_sync():\n    \"\"\"Synchronizes PyTorch for accurate timing, leveraging CUDA if available, and returns the current time.\"\"\"\n    if torch.cuda.is_available():\n        torch.cuda.synchronize()\n    return time.time()\n\n\ndef profile(input, ops, n=10, device=None):\n    \"\"\"YOLOv5 speed/memory/FLOPs profiler\n    Usage:\n        input = torch.randn(16, 3, 640, 640)\n        m1 = lambda x: x * torch.sigmoid(x)\n        m2 = nn.SiLU()\n        profile(input, [m1, m2], n=100)  # profile over 100 iterations\n    \"\"\"\n    results = []\n    if not isinstance(device, torch.device):\n        device = select_device(device)\n    print(\n        f\"{'Params':>12s}{'GFLOPs':>12s}{'GPU_mem (GB)':>14s}{'forward (ms)':>14s}{'backward (ms)':>14s}\"\n        f\"{'input':>24s}{'output':>24s}\"\n    )\n\n    for x in input if isinstance(input, list) else [input]:\n        x = x.to(device)\n        x.requires_grad = True\n        for m in ops if isinstance(ops, list) else [ops]:\n            m = m.to(device) if hasattr(m, \"to\") else m  # device\n            m = m.half() if hasattr(m, \"half\") and isinstance(x, torch.Tensor) and x.dtype is torch.float16 else m\n            tf, tb, t = 0, 0, [0, 0, 0]  # dt forward, backward\n            try:\n                flops = thop.profile(m, inputs=(x,), verbose=False)[0] / 1e9 * 2  # GFLOPs\n            except Exception:\n                flops = 0\n\n            try:\n                for _ in range(n):\n                    t[0] = time_sync()\n                    y = m(x)\n                    t[1] = time_sync()\n                    try:\n                        _ = (sum(yi.sum() for yi in y) if isinstance(y, list) else y).sum().backward()\n                        t[2] = time_sync()\n                    except Exception:  # no backward method\n                        # print(e)  # for debug\n                        t[2] = float(\"nan\")\n                    tf += (t[1] - t[0]) * 1000 / n  # ms per op forward\n                    tb += (t[2] - t[1]) * 1000 / n  # ms per op backward\n                mem = torch.cuda.memory_reserved() / 1e9 if torch.cuda.is_available() else 0  # (GB)\n                s_in, s_out = (tuple(x.shape) if isinstance(x, torch.Tensor) else \"list\" for x in (x, y))  # shapes\n                p = sum(x.numel() for x in m.parameters()) if isinstance(m, nn.Module) else 0  # parameters\n                print(f\"{p:12}{flops:12.4g}{mem:>14.3f}{tf:14.4g}{tb:14.4g}{str(s_in):>24s}{str(s_out):>24s}\")\n                results.append([p, flops, mem, tf, tb, s_in, s_out])\n            except Exception as e:\n                print(e)\n                results.append(None)\n            torch.cuda.empty_cache()\n    return results\n\n\ndef is_parallel(model):\n    \"\"\"Checks if the model is using Data Parallelism (DP) or Distributed Data Parallelism (DDP).\"\"\"\n    return type(model) in (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel)\n\n\ndef de_parallel(model):\n    \"\"\"Returns a single-GPU model by removing Data Parallelism (DP) or Distributed Data Parallelism (DDP) if applied.\"\"\"\n    return model.module if is_parallel(model) else model\n\n\ndef initialize_weights(model):\n    \"\"\"Initializes weights of Conv2d, BatchNorm2d, and activations (Hardswish, LeakyReLU, ReLU, ReLU6, SiLU) in the\n    model.\n    \"\"\"\n    for m in model.modules():\n        t = type(m)\n        if t is nn.Conv2d:\n            pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n        elif t is nn.BatchNorm2d:\n            m.eps = 1e-3\n            m.momentum = 0.03\n        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:\n            m.inplace = True\n\n\ndef find_modules(model, mclass=nn.Conv2d):\n    \"\"\"Finds and returns list of layer indices in `model.module_list` matching the specified `mclass`.\"\"\"\n    return [i for i, m in enumerate(model.module_list) if isinstance(m, mclass)]\n\n\ndef sparsity(model):\n    \"\"\"Calculates and returns the global sparsity of a model as the ratio of zero-valued parameters to total\n    parameters.\n    \"\"\"\n    a, b = 0, 0\n    for p in model.parameters():\n        a += p.numel()\n        b += (p == 0).sum()\n    return b / a\n\n\ndef prune(model, amount=0.3):\n    \"\"\"Prunes Conv2d layers in a model to a specified sparsity using L1 unstructured pruning.\"\"\"\n    import torch.nn.utils.prune as prune\n\n    for name, m in model.named_modules():\n        if isinstance(m, nn.Conv2d):\n            prune.l1_unstructured(m, name=\"weight\", amount=amount)  # prune\n            prune.remove(m, \"weight\")  # make permanent\n    LOGGER.info(f\"Model pruned to {sparsity(model):.3g} global sparsity\")\n\n\ndef fuse_conv_and_bn(conv, bn):\n    \"\"\"\n    Fuses Conv2d and BatchNorm2d layers into a single Conv2d layer.\n\n    See https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\n    \"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,\n            conv.out_channels,\n            kernel_size=conv.kernel_size,\n            stride=conv.stride,\n            padding=conv.padding,\n            dilation=conv.dilation,\n            groups=conv.groups,\n            bias=True,\n        )\n        .requires_grad_(False)\n        .to(conv.weight.device)\n    )\n\n    # Prepare filters\n    w_conv = conv.weight.clone().view(conv.out_channels, -1)\n    w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))\n    fusedconv.weight.copy_(torch.mm(w_bn, w_conv).view(fusedconv.weight.shape))\n\n    # Prepare spatial bias\n    b_conv = torch.zeros(conv.weight.size(0), device=conv.weight.device) if conv.bias is None else conv.bias\n    b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))\n    fusedconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)\n\n    return fusedconv\n\n\ndef model_info(model, verbose=False, imgsz=640):\n    \"\"\"\n    Prints model summary including layers, parameters, gradients, and FLOPs; imgsz may be int or list.\n\n    Example: img_size=640 or img_size=[640, 320]\n    \"\"\"\n    n_p = sum(x.numel() for x in model.parameters())  # number parameters\n    n_g = sum(x.numel() for x in model.parameters() if x.requires_grad)  # number gradients\n    if verbose:\n        print(f\"{'layer':>5} {'name':>40} {'gradient':>9} {'parameters':>12} {'shape':>20} {'mu':>10} {'sigma':>10}\")\n        for i, (name, p) in enumerate(model.named_parameters()):\n            name = name.replace(\"module_list.\", \"\")\n            print(\n                \"%5g %40s %9s %12g %20s %10.3g %10.3g\"\n                % (i, name, p.requires_grad, p.numel(), list(p.shape), p.mean(), p.std())\n            )\n\n    try:  # FLOPs\n        p = next(model.parameters())\n        stride = max(int(model.stride.max()), 32) if hasattr(model, \"stride\") else 32  # max stride\n        im = torch.empty((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n        flops = thop.profile(deepcopy(model), inputs=(im,), verbose=False)[0] / 1e9 * 2  # stride GFLOPs\n        imgsz = imgsz if isinstance(imgsz, list) else [imgsz, imgsz]  # expand if int/float\n        fs = f\", {flops * imgsz[0] / stride * imgsz[1] / stride:.1f} GFLOPs\"  # 640x640 GFLOPs\n    except Exception:\n        fs = \"\"\n\n    name = Path(model.yaml_file).stem.replace(\"yolov5\", \"YOLOv5\") if hasattr(model, \"yaml_file\") else \"Model\"\n    LOGGER.info(f\"{name} summary: {len(list(model.modules()))} layers, {n_p} parameters, {n_g} gradients{fs}\")\n\n\ndef scale_img(img, ratio=1.0, same_shape=False, gs=32):  # img(16,3,256,416)\n    \"\"\"Scales an image tensor `img` of shape (bs,3,y,x) by `ratio`, optionally maintaining the original shape, padded to\n    multiples of `gs`.\n    \"\"\"\n    if ratio == 1.0:\n        return img\n    h, w = img.shape[2:]\n    s = (int(h * ratio), int(w * ratio))  # new size\n    img = F.interpolate(img, size=s, mode=\"bilinear\", align_corners=False)  # resize\n    if not same_shape:  # pad/crop img\n        h, w = (math.ceil(x * ratio / gs) * gs for x in (h, w))\n    return F.pad(img, [0, w - s[1], 0, h - s[0]], value=0.447)  # value = imagenet mean\n\n\ndef copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object b to a, optionally filtering with include and exclude lists.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue\n        else:\n            setattr(a, k, v)\n\n\ndef smart_optimizer(model, name=\"Adam\", lr=0.001, momentum=0.9, decay=1e-5):\n    \"\"\"\n    Initializes YOLOv5 smart optimizer with 3 parameter groups for different decay configurations.\n\n    Groups are 0) weights with decay, 1) weights no decay, 2) biases no decay.\n    \"\"\"\n    g = [], [], []  # optimizer parameter groups\n    bn = tuple(v for k, v in nn.__dict__.items() if \"Norm\" in k)  # normalization layers, i.e. BatchNorm2d()\n    for v in model.modules():\n        for p_name, p in v.named_parameters(recurse=0):\n            if p_name == \"bias\":  # bias (no decay)\n                g[2].append(p)\n            elif p_name == \"weight\" and isinstance(v, bn):  # weight (no decay)\n                g[1].append(p)\n            else:\n                g[0].append(p)  # weight (with decay)\n\n    if name == \"Adam\":\n        optimizer = torch.optim.Adam(g[2], lr=lr, betas=(momentum, 0.999))  # adjust beta1 to momentum\n    elif name == \"AdamW\":\n        optimizer = torch.optim.AdamW(g[2], lr=lr, betas=(momentum, 0.999), weight_decay=0.0)\n    elif name == \"RMSProp\":\n        optimizer = torch.optim.RMSprop(g[2], lr=lr, momentum=momentum)\n    elif name == \"SGD\":\n        optimizer = torch.optim.SGD(g[2], lr=lr, momentum=momentum, nesterov=True)\n    else:\n        raise NotImplementedError(f\"Optimizer {name} not implemented.\")\n\n    optimizer.add_param_group({\"params\": g[0], \"weight_decay\": decay})  # add g0 with weight_decay\n    optimizer.add_param_group({\"params\": g[1], \"weight_decay\": 0.0})  # add g1 (BatchNorm2d weights)\n    LOGGER.info(\n        f\"{colorstr('optimizer:')} {type(optimizer).__name__}(lr={lr}) with parameter groups \"\n        f'{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias'\n    )\n    return optimizer\n\n\ndef smart_hub_load(repo=\"ultralytics/yolov5\", model=\"yolov5s\", **kwargs):\n    \"\"\"YOLOv5 torch.hub.load() wrapper with smart error handling, adjusting torch arguments for compatibility.\"\"\"\n    if check_version(torch.__version__, \"1.9.1\"):\n        kwargs[\"skip_validation\"] = True  # validation causes GitHub API rate limit errors\n    if check_version(torch.__version__, \"1.12.0\"):\n        kwargs[\"trust_repo\"] = True  # argument required starting in torch 0.12\n    try:\n        return torch.hub.load(repo, model, **kwargs)\n    except Exception:\n        return torch.hub.load(repo, model, force_reload=True, **kwargs)\n\n\ndef smart_resume(ckpt, optimizer, ema=None, weights=\"yolov5s.pt\", epochs=300, resume=True):\n    \"\"\"Resumes training from a checkpoint, updating optimizer, ema, and epochs, with optional resume verification.\"\"\"\n    best_fitness = 0.0\n    start_epoch = ckpt[\"epoch\"] + 1\n    if ckpt[\"optimizer\"] is not None:\n        optimizer.load_state_dict(ckpt[\"optimizer\"])  # optimizer\n        best_fitness = ckpt[\"best_fitness\"]\n    if ema and ckpt.get(\"ema\"):\n        ema.ema.load_state_dict(ckpt[\"ema\"].float().state_dict())  # EMA\n        ema.updates = ckpt[\"updates\"]\n    if resume:\n        assert start_epoch > 0, (\n            f\"{weights} training to {epochs} epochs is finished, nothing to resume.\\n\"\n            f\"Start a new training without --resume, i.e. 'python train.py --weights {weights}'\"\n        )\n        LOGGER.info(f\"Resuming training from {weights} from epoch {start_epoch} to {epochs} total epochs\")\n    if epochs < start_epoch:\n        LOGGER.info(f\"{weights} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {epochs} more epochs.\")\n        epochs += ckpt[\"epoch\"]  # finetune additional epochs\n    return best_fitness, start_epoch, epochs\n\n\nclass EarlyStopping:\n    # YOLOv5 simple early stopper\n    def __init__(self, patience=30):\n        \"\"\"Initializes simple early stopping mechanism for YOLOv5, with adjustable patience for non-improving epochs.\"\"\"\n        self.best_fitness = 0.0  # i.e. mAP\n        self.best_epoch = 0\n        self.patience = patience or float(\"inf\")  # epochs to wait after fitness stops improving to stop\n        self.possible_stop = False  # possible stop may occur next epoch\n\n    def __call__(self, epoch, fitness):\n        \"\"\"Evaluates if training should stop based on fitness improvement and patience, returning a boolean.\"\"\"\n        if fitness >= self.best_fitness:  # >= 0 to allow for early zero-fitness stage of training\n            self.best_epoch = epoch\n            self.best_fitness = fitness\n        delta = epoch - self.best_epoch  # epochs without improvement\n        self.possible_stop = delta >= (self.patience - 1)  # possible stop may occur next epoch\n        stop = delta >= self.patience  # stop training if patience exceeded\n        if stop:\n            LOGGER.info(\n                f\"Stopping training early as no improvement observed in last {self.patience} epochs. \"\n                f\"Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\\n\"\n                f\"To update EarlyStopping(patience={self.patience}) pass a new patience value, \"\n                f\"i.e. `python train.py --patience 300` or use `--patience 0` to disable EarlyStopping.\"\n            )\n        return stop\n\n\nclass ModelEMA:\n    \"\"\"Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models\n    Keeps a moving average of everything in the model state_dict (parameters and buffers)\n    For EMA details see https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage\n    \"\"\"\n\n    def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n        \"\"\"Initializes EMA with model parameters, decay rate, tau for decay adjustment, and update count; sets model to\n        evaluation mode.\n        \"\"\"\n        self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n        self.updates = updates  # number of EMA updates\n        self.decay = lambda x: decay * (1 - math.exp(-x / tau))  # decay exponential ramp (to help early epochs)\n        for p in self.ema.parameters():\n            p.requires_grad_(False)\n\n    def update(self, model):\n        \"\"\"Updates the Exponential Moving Average (EMA) parameters based on the current model's parameters.\"\"\"\n        self.updates += 1\n        d = self.decay(self.updates)\n\n        msd = de_parallel(model).state_dict()  # model state_dict\n        for k, v in self.ema.state_dict().items():\n            if v.dtype.is_floating_point:  # true for FP16 and FP32\n                v *= d\n                v += (1 - d) * msd[k].detach()\n        # assert v.dtype == msd[k].dtype == torch.float32, f'{k}: EMA {v.dtype} and model {msd[k].dtype} must be FP32'\n\n    def update_attr(self, model, include=(), exclude=(\"process_group\", \"reducer\")):\n        \"\"\"Updates EMA attributes by copying specified attributes from model to EMA, excluding certain attributes by\n        default.\n        \"\"\"\n        copy_attr(self.ema, model, include, exclude)\n", "utils/augmentations.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Image augmentation functions.\"\"\"\n\nimport math\nimport random\n\nimport cv2\nimport numpy as np\nimport torch\nimport torchvision.transforms as T\nimport torchvision.transforms.functional as TF\n\nfrom utils.general import LOGGER, check_version, colorstr, resample_segments, segment2box, xywhn2xyxy\nfrom utils.metrics import bbox_ioa\n\nIMAGENET_MEAN = 0.485, 0.456, 0.406  # RGB mean\nIMAGENET_STD = 0.229, 0.224, 0.225  # RGB standard deviation\n\n\nclass Albumentations:\n    # YOLOv5 Albumentations class (optional, only used if package is installed)\n    def __init__(self, size=640):\n        \"\"\"Initializes Albumentations class for optional data augmentation in YOLOv5 with specified input size.\"\"\"\n        self.transform = None\n        prefix = colorstr(\"albumentations: \")\n        try:\n            import albumentations as A\n\n            check_version(A.__version__, \"1.0.3\", hard=True)  # version requirement\n\n            T = [\n                A.RandomResizedCrop(height=size, width=size, scale=(0.8, 1.0), ratio=(0.9, 1.11), p=0.0),\n                A.Blur(p=0.01),\n                A.MedianBlur(p=0.01),\n                A.ToGray(p=0.01),\n                A.CLAHE(p=0.01),\n                A.RandomBrightnessContrast(p=0.0),\n                A.RandomGamma(p=0.0),\n                A.ImageCompression(quality_lower=75, p=0.0),\n            ]  # transforms\n            self.transform = A.Compose(T, bbox_params=A.BboxParams(format=\"yolo\", label_fields=[\"class_labels\"]))\n\n            LOGGER.info(prefix + \", \".join(f\"{x}\".replace(\"always_apply=False, \", \"\") for x in T if x.p))\n        except ImportError:  # package not installed, skip\n            pass\n        except Exception as e:\n            LOGGER.info(f\"{prefix}{e}\")\n\n    def __call__(self, im, labels, p=1.0):\n        \"\"\"Applies transformations to an image and labels with probability `p`, returning updated image and labels.\"\"\"\n        if self.transform and random.random() < p:\n            new = self.transform(image=im, bboxes=labels[:, 1:], class_labels=labels[:, 0])  # transformed\n            im, labels = new[\"image\"], np.array([[c, *b] for c, b in zip(new[\"class_labels\"], new[\"bboxes\"])])\n        return im, labels\n\n\ndef normalize(x, mean=IMAGENET_MEAN, std=IMAGENET_STD, inplace=False):\n    \"\"\"\n    Applies ImageNet normalization to RGB images in BCHW format, modifying them in-place if specified.\n\n    Example: y = (x - mean) / std\n    \"\"\"\n    return TF.normalize(x, mean, std, inplace=inplace)\n\n\ndef denormalize(x, mean=IMAGENET_MEAN, std=IMAGENET_STD):\n    \"\"\"Reverses ImageNet normalization for BCHW format RGB images by applying `x = x * std + mean`.\"\"\"\n    for i in range(3):\n        x[:, i] = x[:, i] * std[i] + mean[i]\n    return x\n\n\ndef augment_hsv(im, hgain=0.5, sgain=0.5, vgain=0.5):\n    \"\"\"Applies HSV color-space augmentation to an image with random gains for hue, saturation, and value.\"\"\"\n    if hgain or sgain or vgain:\n        r = np.random.uniform(-1, 1, 3) * [hgain, sgain, vgain] + 1  # random gains\n        hue, sat, val = cv2.split(cv2.cvtColor(im, cv2.COLOR_BGR2HSV))\n        dtype = im.dtype  # uint8\n\n        x = np.arange(0, 256, dtype=r.dtype)\n        lut_hue = ((x * r[0]) % 180).astype(dtype)\n        lut_sat = np.clip(x * r[1], 0, 255).astype(dtype)\n        lut_val = np.clip(x * r[2], 0, 255).astype(dtype)\n\n        im_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val)))\n        cv2.cvtColor(im_hsv, cv2.COLOR_HSV2BGR, dst=im)  # no return needed\n\n\ndef hist_equalize(im, clahe=True, bgr=False):\n    \"\"\"Equalizes image histogram, with optional CLAHE, for BGR or RGB image with shape (n,m,3) and range 0-255.\"\"\"\n    yuv = cv2.cvtColor(im, cv2.COLOR_BGR2YUV if bgr else cv2.COLOR_RGB2YUV)\n    if clahe:\n        c = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n        yuv[:, :, 0] = c.apply(yuv[:, :, 0])\n    else:\n        yuv[:, :, 0] = cv2.equalizeHist(yuv[:, :, 0])  # equalize Y channel histogram\n    return cv2.cvtColor(yuv, cv2.COLOR_YUV2BGR if bgr else cv2.COLOR_YUV2RGB)  # convert YUV image to RGB\n\n\ndef replicate(im, labels):\n    \"\"\"\n    Replicates half of the smallest object labels in an image for data augmentation.\n\n    Returns augmented image and labels.\n    \"\"\"\n    h, w = im.shape[:2]\n    boxes = labels[:, 1:].astype(int)\n    x1, y1, x2, y2 = boxes.T\n    s = ((x2 - x1) + (y2 - y1)) / 2  # side length (pixels)\n    for i in s.argsort()[: round(s.size * 0.5)]:  # smallest indices\n        x1b, y1b, x2b, y2b = boxes[i]\n        bh, bw = y2b - y1b, x2b - x1b\n        yc, xc = int(random.uniform(0, h - bh)), int(random.uniform(0, w - bw))  # offset x, y\n        x1a, y1a, x2a, y2a = [xc, yc, xc + bw, yc + bh]\n        im[y1a:y2a, x1a:x2a] = im[y1b:y2b, x1b:x2b]  # im4[ymin:ymax, xmin:xmax]\n        labels = np.append(labels, [[labels[i, 0], x1a, y1a, x2a, y2a]], axis=0)\n\n    return im, labels\n\n\ndef letterbox(im, new_shape=(640, 640), color=(114, 114, 114), auto=True, scaleFill=False, scaleup=True, stride=32):\n    \"\"\"Resizes and pads image to new_shape with stride-multiple constraints, returns resized image, ratio, padding.\"\"\"\n    shape = im.shape[:2]  # current shape [height, width]\n    if isinstance(new_shape, int):\n        new_shape = (new_shape, new_shape)\n\n    # Scale ratio (new / old)\n    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])\n    if not scaleup:  # only scale down, do not scale up (for better val mAP)\n        r = min(r, 1.0)\n\n    # Compute padding\n    ratio = r, r  # width, height ratios\n    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))\n    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding\n    if auto:  # minimum rectangle\n        dw, dh = np.mod(dw, stride), np.mod(dh, stride)  # wh padding\n    elif scaleFill:  # stretch\n        dw, dh = 0.0, 0.0\n        new_unpad = (new_shape[1], new_shape[0])\n        ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios\n\n    dw /= 2  # divide padding into 2 sides\n    dh /= 2\n\n    if shape[::-1] != new_unpad:  # resize\n        im = cv2.resize(im, new_unpad, interpolation=cv2.INTER_LINEAR)\n    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))\n    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))\n    im = cv2.copyMakeBorder(im, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  # add border\n    return im, ratio, (dw, dh)\n\n\ndef random_perspective(\n    im, targets=(), segments=(), degrees=10, translate=0.1, scale=0.1, shear=10, perspective=0.0, border=(0, 0)\n):\n    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(0.1, 0.1), scale=(0.9, 1.1), shear=(-10, 10))\n    # targets = [cls, xyxy]\n\n    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n    width = im.shape[1] + border[1] * 2\n\n    # Center\n    C = np.eye(3)\n    C[0, 2] = -im.shape[1] / 2  # x translation (pixels)\n    C[1, 2] = -im.shape[0] / 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3)\n    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3)\n    a = random.uniform(-degrees, degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - scale, 1 + scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3)\n    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3)\n    T[0, 2] = random.uniform(0.5 - translate, 0.5 + translate) * width  # x translation (pixels)\n    T[1, 2] = random.uniform(0.5 - translate, 0.5 + translate) * height  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if perspective:\n            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n        else:  # affine\n            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n\n    # Visualize\n    # import matplotlib.pyplot as plt\n    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n    # ax[0].imshow(im[:, :, ::-1])  # base\n    # ax[1].imshow(im2[:, :, ::-1])  # warped\n\n    # Transform label coordinates\n    n = len(targets)\n    if n:\n        use_segments = any(x.any() for x in segments) and len(segments) == n\n        new = np.zeros((n, 4))\n        if use_segments:  # warp segments\n            segments = resample_segments(segments)  # upsample\n            for i, segment in enumerate(segments):\n                xy = np.ones((len(segment), 3))\n                xy[:, :2] = segment\n                xy = xy @ M.T  # transform\n                xy = xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]  # perspective rescale or affine\n\n                # clip\n                new[i] = segment2box(xy, width, height)\n\n        else:  # warp boxes\n            xy = np.ones((n * 4, 3))\n            xy[:, :2] = targets[:, [1, 2, 3, 4, 1, 4, 3, 2]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1\n            xy = xy @ M.T  # transform\n            xy = (xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine\n\n            # create new boxes\n            x = xy[:, [0, 2, 4, 6]]\n            y = xy[:, [1, 3, 5, 7]]\n            new = np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1))).reshape(4, n).T\n\n            # clip\n            new[:, [0, 2]] = new[:, [0, 2]].clip(0, width)\n            new[:, [1, 3]] = new[:, [1, 3]].clip(0, height)\n\n        # filter candidates\n        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01 if use_segments else 0.10)\n        targets = targets[i]\n        targets[:, 1:5] = new[i]\n\n    return im, targets\n\n\ndef copy_paste(im, labels, segments, p=0.5):\n    \"\"\"\n    Applies Copy-Paste augmentation by flipping and merging segments and labels on an image.\n\n    Details at https://arxiv.org/abs/2012.07177.\n    \"\"\"\n    n = len(segments)\n    if p and n:\n        h, w, c = im.shape  # height, width, channels\n        im_new = np.zeros(im.shape, np.uint8)\n        for j in random.sample(range(n), k=round(p * n)):\n            l, s = labels[j], segments[j]\n            box = w - l[3], l[2], w - l[1], l[4]\n            ioa = bbox_ioa(box, labels[:, 1:5])  # intersection over area\n            if (ioa < 0.30).all():  # allow 30% obscuration of existing labels\n                labels = np.concatenate((labels, [[l[0], *box]]), 0)\n                segments.append(np.concatenate((w - s[:, 0:1], s[:, 1:2]), 1))\n                cv2.drawContours(im_new, [segments[j].astype(np.int32)], -1, (1, 1, 1), cv2.FILLED)\n\n        result = cv2.flip(im, 1)  # augment segments (flip left-right)\n        i = cv2.flip(im_new, 1).astype(bool)\n        im[i] = result[i]  # cv2.imwrite('debug.jpg', im)  # debug\n\n    return im, labels, segments\n\n\ndef cutout(im, labels, p=0.5):\n    \"\"\"\n    Applies cutout augmentation to an image with optional label adjustment, using random masks of varying sizes.\n\n    Details at https://arxiv.org/abs/1708.04552.\n    \"\"\"\n    if random.random() < p:\n        h, w = im.shape[:2]\n        scales = [0.5] * 1 + [0.25] * 2 + [0.125] * 4 + [0.0625] * 8 + [0.03125] * 16  # image size fraction\n        for s in scales:\n            mask_h = random.randint(1, int(h * s))  # create random masks\n            mask_w = random.randint(1, int(w * s))\n\n            # box\n            xmin = max(0, random.randint(0, w) - mask_w // 2)\n            ymin = max(0, random.randint(0, h) - mask_h // 2)\n            xmax = min(w, xmin + mask_w)\n            ymax = min(h, ymin + mask_h)\n\n            # apply random color mask\n            im[ymin:ymax, xmin:xmax] = [random.randint(64, 191) for _ in range(3)]\n\n            # return unobscured labels\n            if len(labels) and s > 0.03:\n                box = np.array([xmin, ymin, xmax, ymax], dtype=np.float32)\n                ioa = bbox_ioa(box, xywhn2xyxy(labels[:, 1:5], w, h))  # intersection over area\n                labels = labels[ioa < 0.60]  # remove >60% obscured labels\n\n    return labels\n\n\ndef mixup(im, labels, im2, labels2):\n    \"\"\"\n    Applies MixUp augmentation by blending images and labels.\n\n    See https://arxiv.org/pdf/1710.09412.pdf for details.\n    \"\"\"\n    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n    labels = np.concatenate((labels, labels2), 0)\n    return im, labels\n\n\ndef box_candidates(box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):\n    \"\"\"\n    Filters bounding box candidates by minimum width-height threshold `wh_thr` (pixels), aspect ratio threshold\n    `ar_thr`, and area ratio threshold `area_thr`.\n\n    box1(4,n) is before augmentation, box2(4,n) is after augmentation.\n    \"\"\"\n    w1, h1 = box1[2] - box1[0], box1[3] - box1[1]\n    w2, h2 = box2[2] - box2[0], box2[3] - box2[1]\n    ar = np.maximum(w2 / (h2 + eps), h2 / (w2 + eps))  # aspect ratio\n    return (w2 > wh_thr) & (h2 > wh_thr) & (w2 * h2 / (w1 * h1 + eps) > area_thr) & (ar < ar_thr)  # candidates\n\n\ndef classify_albumentations(\n    augment=True,\n    size=224,\n    scale=(0.08, 1.0),\n    ratio=(0.75, 1.0 / 0.75),  # 0.75, 1.33\n    hflip=0.5,\n    vflip=0.0,\n    jitter=0.4,\n    mean=IMAGENET_MEAN,\n    std=IMAGENET_STD,\n    auto_aug=False,\n):\n    # YOLOv5 classification Albumentations (optional, only used if package is installed)\n    prefix = colorstr(\"albumentations: \")\n    try:\n        import albumentations as A\n        from albumentations.pytorch import ToTensorV2\n\n        check_version(A.__version__, \"1.0.3\", hard=True)  # version requirement\n        if augment:  # Resize and crop\n            T = [A.RandomResizedCrop(height=size, width=size, scale=scale, ratio=ratio)]\n            if auto_aug:\n                # TODO: implement AugMix, AutoAug & RandAug in albumentation\n                LOGGER.info(f\"{prefix}auto augmentations are currently not supported\")\n            else:\n                if hflip > 0:\n                    T += [A.HorizontalFlip(p=hflip)]\n                if vflip > 0:\n                    T += [A.VerticalFlip(p=vflip)]\n                if jitter > 0:\n                    color_jitter = (float(jitter),) * 3  # repeat value for brightness, contrast, saturation, 0 hue\n                    T += [A.ColorJitter(*color_jitter, 0)]\n        else:  # Use fixed crop for eval set (reproducibility)\n            T = [A.SmallestMaxSize(max_size=size), A.CenterCrop(height=size, width=size)]\n        T += [A.Normalize(mean=mean, std=std), ToTensorV2()]  # Normalize and convert to Tensor\n        LOGGER.info(prefix + \", \".join(f\"{x}\".replace(\"always_apply=False, \", \"\") for x in T if x.p))\n        return A.Compose(T)\n\n    except ImportError:  # package not installed, skip\n        LOGGER.warning(f\"{prefix}\u26a0\ufe0f not found, install with `pip install albumentations` (recommended)\")\n    except Exception as e:\n        LOGGER.info(f\"{prefix}{e}\")\n\n\ndef classify_transforms(size=224):\n    \"\"\"Applies a series of transformations including center crop, ToTensor, and normalization for classification.\"\"\"\n    assert isinstance(size, int), f\"ERROR: classify_transforms size {size} must be integer, not (list, tuple)\"\n    # T.Compose([T.ToTensor(), T.Resize(size), T.CenterCrop(size), T.Normalize(IMAGENET_MEAN, IMAGENET_STD)])\n    return T.Compose([CenterCrop(size), ToTensor(), T.Normalize(IMAGENET_MEAN, IMAGENET_STD)])\n\n\nclass LetterBox:\n    # YOLOv5 LetterBox class for image preprocessing, i.e. T.Compose([LetterBox(size), ToTensor()])\n    def __init__(self, size=(640, 640), auto=False, stride=32):\n        \"\"\"Initializes a LetterBox object for YOLOv5 image preprocessing with optional auto sizing and stride\n        adjustment.\n        \"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n        self.auto = auto  # pass max size integer, automatically solve for short side using stride\n        self.stride = stride  # used with auto\n\n    def __call__(self, im):\n        \"\"\"\n        Resizes and pads input image `im` (HWC format) to specified dimensions, maintaining aspect ratio.\n\n        im = np.array HWC\n        \"\"\"\n        imh, imw = im.shape[:2]\n        r = min(self.h / imh, self.w / imw)  # ratio of new/old\n        h, w = round(imh * r), round(imw * r)  # resized image\n        hs, ws = (math.ceil(x / self.stride) * self.stride for x in (h, w)) if self.auto else self.h, self.w\n        top, left = round((hs - h) / 2 - 0.1), round((ws - w) / 2 - 0.1)\n        im_out = np.full((self.h, self.w, 3), 114, dtype=im.dtype)\n        im_out[top : top + h, left : left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n        return im_out\n\n\nclass CenterCrop:\n    # YOLOv5 CenterCrop class for image preprocessing, i.e. T.Compose([CenterCrop(size), ToTensor()])\n    def __init__(self, size=640):\n        \"\"\"Initializes CenterCrop for image preprocessing, accepting single int or tuple for size, defaults to 640.\"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n\n    def __call__(self, im):\n        \"\"\"\n        Applies center crop to the input image and resizes it to a specified size, maintaining aspect ratio.\n\n        im = np.array HWC\n        \"\"\"\n        imh, imw = im.shape[:2]\n        m = min(imh, imw)  # min dimension\n        top, left = (imh - m) // 2, (imw - m) // 2\n        return cv2.resize(im[top : top + m, left : left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)\n\n\nclass ToTensor:\n    # YOLOv5 ToTensor class for image preprocessing, i.e. T.Compose([LetterBox(size), ToTensor()])\n    def __init__(self, half=False):\n        \"\"\"Initializes ToTensor for YOLOv5 image preprocessing, with optional half precision (half=True for FP16).\"\"\"\n        super().__init__()\n        self.half = half\n\n    def __call__(self, im):\n        \"\"\"\n        Converts BGR np.array image from HWC to RGB CHW format, and normalizes to [0, 1], with support for FP16 if\n        `half=True`.\n\n        im = np.array HWC in BGR order\n        \"\"\"\n        im = np.ascontiguousarray(im.transpose((2, 0, 1))[::-1])  # HWC to CHW -> BGR to RGB -> contiguous\n        im = torch.from_numpy(im)  # to torch\n        im = im.half() if self.half else im.float()  # uint8 to fp16/32\n        im /= 255.0  # 0-255 to 0.0-1.0\n        return im\n", "utils/activations.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Activation functions.\"\"\"\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass SiLU(nn.Module):\n    @staticmethod\n    def forward(x):\n        \"\"\"\n        Applies the Sigmoid-weighted Linear Unit (SiLU) activation function.\n\n        https://arxiv.org/pdf/1606.08415.pdf.\n        \"\"\"\n        return x * torch.sigmoid(x)\n\n\nclass Hardswish(nn.Module):\n    @staticmethod\n    def forward(x):\n        \"\"\"\n        Applies the Hardswish activation function, compatible with TorchScript, CoreML, and ONNX.\n\n        Equivalent to x * F.hardsigmoid(x)\n        \"\"\"\n        return x * F.hardtanh(x + 3, 0.0, 6.0) / 6.0  # for TorchScript, CoreML and ONNX\n\n\nclass Mish(nn.Module):\n    \"\"\"Mish activation https://github.com/digantamisra98/Mish.\"\"\"\n\n    @staticmethod\n    def forward(x):\n        \"\"\"Applies the Mish activation function, a smooth alternative to ReLU.\"\"\"\n        return x * F.softplus(x).tanh()\n\n\nclass MemoryEfficientMish(nn.Module):\n    class F(torch.autograd.Function):\n        @staticmethod\n        def forward(ctx, x):\n            \"\"\"Applies the Mish activation function, a smooth ReLU alternative, to the input tensor `x`.\"\"\"\n            ctx.save_for_backward(x)\n            return x.mul(torch.tanh(F.softplus(x)))  # x * tanh(ln(1 + exp(x)))\n\n        @staticmethod\n        def backward(ctx, grad_output):\n            \"\"\"Computes the gradient of the Mish activation function with respect to input `x`.\"\"\"\n            x = ctx.saved_tensors[0]\n            sx = torch.sigmoid(x)\n            fx = F.softplus(x).tanh()\n            return grad_output * (fx + x * sx * (1 - fx * fx))\n\n    def forward(self, x):\n        \"\"\"Applies the Mish activation function to the input tensor `x`.\"\"\"\n        return self.F.apply(x)\n\n\nclass FReLU(nn.Module):\n    \"\"\"FReLU activation https://arxiv.org/abs/2007.11824.\"\"\"\n\n    def __init__(self, c1, k=3):  # ch_in, kernel\n        \"\"\"Initializes FReLU activation with channel `c1` and kernel size `k`.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c1, k, 1, 1, groups=c1, bias=False)\n        self.bn = nn.BatchNorm2d(c1)\n\n    def forward(self, x):\n        \"\"\"\n        Applies FReLU activation with max operation between input and BN-convolved input.\n\n        https://arxiv.org/abs/2007.11824\n        \"\"\"\n        return torch.max(x, self.bn(self.conv(x)))\n\n\nclass AconC(nn.Module):\n    \"\"\"\n    ACON activation (activate or not) function.\n\n    AconC: (p1*x-p2*x) * sigmoid(beta*(p1*x-p2*x)) + p2*x, beta is a learnable parameter\n    See \"Activate or Not: Learning Customized Activation\" https://arxiv.org/pdf/2009.04759.pdf.\n    \"\"\"\n\n    def __init__(self, c1):\n        \"\"\"Initializes AconC with learnable parameters p1, p2, and beta for channel-wise activation control.\"\"\"\n        super().__init__()\n        self.p1 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.p2 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.beta = nn.Parameter(torch.ones(1, c1, 1, 1))\n\n    def forward(self, x):\n        \"\"\"Applies AconC activation function with learnable parameters for channel-wise control on input tensor x.\"\"\"\n        dpx = (self.p1 - self.p2) * x\n        return dpx * torch.sigmoid(self.beta * dpx) + self.p2 * x\n\n\nclass MetaAconC(nn.Module):\n    \"\"\"\n    ACON activation (activate or not) function.\n\n    AconC: (p1*x-p2*x) * sigmoid(beta*(p1*x-p2*x)) + p2*x, beta is a learnable parameter\n    See \"Activate or Not: Learning Customized Activation\" https://arxiv.org/pdf/2009.04759.pdf.\n    \"\"\"\n\n    def __init__(self, c1, k=1, s=1, r=16):\n        \"\"\"Initializes MetaAconC with params: channel_in (c1), kernel size (k=1), stride (s=1), reduction (r=16).\"\"\"\n        super().__init__()\n        c2 = max(r, c1 // r)\n        self.p1 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.p2 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.fc1 = nn.Conv2d(c1, c2, k, s, bias=True)\n        self.fc2 = nn.Conv2d(c2, c1, k, s, bias=True)\n        # self.bn1 = nn.BatchNorm2d(c2)\n        # self.bn2 = nn.BatchNorm2d(c1)\n\n    def forward(self, x):\n        \"\"\"Applies a forward pass transforming input `x` using learnable parameters and sigmoid activation.\"\"\"\n        y = x.mean(dim=2, keepdims=True).mean(dim=3, keepdims=True)\n        # batch-size 1 bug/instabilities https://github.com/ultralytics/yolov5/issues/2891\n        # beta = torch.sigmoid(self.bn2(self.fc2(self.bn1(self.fc1(y)))))  # bug/unstable\n        beta = torch.sigmoid(self.fc2(self.fc1(y)))  # bug patch BN layers removed\n        dpx = (self.p1 - self.p2) * x\n        return dpx * torch.sigmoid(beta * dpx) + self.p2 * x\n", "utils/plots.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Plotting utils.\"\"\"\n\nimport contextlib\nimport math\nimport os\nfrom copy import copy\nfrom pathlib import Path\n\nimport cv2\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sn\nimport torch\nfrom PIL import Image, ImageDraw\nfrom scipy.ndimage.filters import gaussian_filter1d\nfrom ultralytics.utils.plotting import Annotator\n\nfrom utils import TryExcept, threaded\nfrom utils.general import LOGGER, clip_boxes, increment_path, xywh2xyxy, xyxy2xywh\nfrom utils.metrics import fitness\n\n# Settings\nRANK = int(os.getenv(\"RANK\", -1))\nmatplotlib.rc(\"font\", **{\"size\": 11})\nmatplotlib.use(\"Agg\")  # for writing to files only\n\n\nclass Colors:\n    # Ultralytics color palette https://ultralytics.com/\n    def __init__(self):\n        \"\"\"\n        Initializes the Colors class with a palette derived from Ultralytics color scheme, converting hex codes to RGB.\n\n        Colors derived from `hex = matplotlib.colors.TABLEAU_COLORS.values()`.\n        \"\"\"\n        hexs = (\n            \"FF3838\",\n            \"FF9D97\",\n            \"FF701F\",\n            \"FFB21D\",\n            \"CFD231\",\n            \"48F90A\",\n            \"92CC17\",\n            \"3DDB86\",\n            \"1A9334\",\n            \"00D4BB\",\n            \"2C99A8\",\n            \"00C2FF\",\n            \"344593\",\n            \"6473FF\",\n            \"0018EC\",\n            \"8438FF\",\n            \"520085\",\n            \"CB38FF\",\n            \"FF95C8\",\n            \"FF37C7\",\n        )\n        self.palette = [self.hex2rgb(f\"#{c}\") for c in hexs]\n        self.n = len(self.palette)\n\n    def __call__(self, i, bgr=False):\n        \"\"\"Returns color from palette by index `i`, in BGR format if `bgr=True`, else RGB; `i` is an integer index.\"\"\"\n        c = self.palette[int(i) % self.n]\n        return (c[2], c[1], c[0]) if bgr else c\n\n    @staticmethod\n    def hex2rgb(h):\n        \"\"\"Converts hexadecimal color `h` to an RGB tuple (PIL-compatible) with order (R, G, B).\"\"\"\n        return tuple(int(h[1 + i : 1 + i + 2], 16) for i in (0, 2, 4))\n\n\ncolors = Colors()  # create instance for 'from utils.plots import colors'\n\n\ndef feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):\n    \"\"\"\n    x:              Features to be visualized\n    module_type:    Module type\n    stage:          Module stage within model\n    n:              Maximum number of feature maps to plot\n    save_dir:       Directory to save results\n    \"\"\"\n    if (\"Detect\" not in module_type) and (\n        \"Segment\" not in module_type\n    ):  # 'Detect' for Object Detect task,'Segment' for Segment task\n        batch, channels, height, width = x.shape  # batch, channels, height, width\n        if height > 1 and width > 1:\n            f = save_dir / f\"stage{stage}_{module_type.split('.')[-1]}_features.png\"  # filename\n\n            blocks = torch.chunk(x[0].cpu(), channels, dim=0)  # select batch index 0, block by channels\n            n = min(n, channels)  # number of plots\n            fig, ax = plt.subplots(math.ceil(n / 8), 8, tight_layout=True)  # 8 rows x n/8 cols\n            ax = ax.ravel()\n            plt.subplots_adjust(wspace=0.05, hspace=0.05)\n            for i in range(n):\n                ax[i].imshow(blocks[i].squeeze())  # cmap='gray'\n                ax[i].axis(\"off\")\n\n            LOGGER.info(f\"Saving {f}... ({n}/{channels})\")\n            plt.savefig(f, dpi=300, bbox_inches=\"tight\")\n            plt.close()\n            np.save(str(f.with_suffix(\".npy\")), x[0].cpu().numpy())  # npy save\n\n\ndef hist2d(x, y, n=100):\n    \"\"\"\n    Generates a logarithmic 2D histogram, useful for visualizing label or evolution distributions.\n\n    Used in used in labels.png and evolve.png.\n    \"\"\"\n    xedges, yedges = np.linspace(x.min(), x.max(), n), np.linspace(y.min(), y.max(), n)\n    hist, xedges, yedges = np.histogram2d(x, y, (xedges, yedges))\n    xidx = np.clip(np.digitize(x, xedges) - 1, 0, hist.shape[0] - 1)\n    yidx = np.clip(np.digitize(y, yedges) - 1, 0, hist.shape[1] - 1)\n    return np.log(hist[xidx, yidx])\n\n\ndef butter_lowpass_filtfilt(data, cutoff=1500, fs=50000, order=5):\n    \"\"\"Applies a low-pass Butterworth filter to `data` with specified `cutoff`, `fs`, and `order`.\"\"\"\n    from scipy.signal import butter, filtfilt\n\n    # https://stackoverflow.com/questions/28536191/how-to-filter-smooth-with-scipy-numpy\n    def butter_lowpass(cutoff, fs, order):\n        nyq = 0.5 * fs\n        normal_cutoff = cutoff / nyq\n        return butter(order, normal_cutoff, btype=\"low\", analog=False)\n\n    b, a = butter_lowpass(cutoff, fs, order=order)\n    return filtfilt(b, a, data)  # forward-backward filter\n\n\ndef output_to_target(output, max_det=300):\n    \"\"\"Converts YOLOv5 model output to [batch_id, class_id, x, y, w, h, conf] format for plotting, limiting detections\n    to `max_det`.\n    \"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, xyxy2xywh(box), conf), 1))\n    return torch.cat(targets, 0).numpy()\n\n\n@threaded\ndef plot_images(images, targets, paths=None, fname=\"images.jpg\", names=None):\n    \"\"\"Plots an image grid with labels from YOLOv5 predictions or targets, saving to `fname`.\"\"\"\n    if isinstance(images, torch.Tensor):\n        images = images.cpu().float().numpy()\n    if isinstance(targets, torch.Tensor):\n        targets = targets.cpu().numpy()\n\n    max_size = 1920  # max image size\n    max_subplots = 16  # max image subplots, i.e. 4x4\n    bs, _, h, w = images.shape  # batch size, _, height, width\n    bs = min(bs, max_subplots)  # limit plot images\n    ns = np.ceil(bs**0.5)  # number of subplots (square)\n    if np.max(images[0]) <= 1:\n        images *= 255  # de-normalise (optional)\n\n    # Build Image\n    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n    for i, im in enumerate(images):\n        if i == max_subplots:  # if last batch has fewer images than we expect\n            break\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        im = im.transpose(1, 2, 0)\n        mosaic[y : y + h, x : x + w, :] = im\n\n    # Resize (optional)\n    scale = max_size / ns / max(h, w)\n    if scale < 1:\n        h = math.ceil(scale * h)\n        w = math.ceil(scale * w)\n        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n\n    # Annotate\n    fs = int((h + w) * ns * 0.01)  # font size\n    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n    for i in range(i + 1):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n        if paths:\n            annotator.text([x + 5, y + 5], text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n        if len(targets) > 0:\n            ti = targets[targets[:, 0] == i]  # image targets\n            boxes = xywh2xyxy(ti[:, 2:6]).T\n            classes = ti[:, 1].astype(\"int\")\n            labels = ti.shape[1] == 6  # labels if no conf column\n            conf = None if labels else ti[:, 6]  # check for confidence presence (label vs pred)\n\n            if boxes.shape[1]:\n                if boxes.max() <= 1.01:  # if normalized with tolerance 0.01\n                    boxes[[0, 2]] *= w  # scale to pixels\n                    boxes[[1, 3]] *= h\n                elif scale < 1:  # absolute coords need scale if image scales\n                    boxes *= scale\n            boxes[[0, 2]] += x\n            boxes[[1, 3]] += y\n            for j, box in enumerate(boxes.T.tolist()):\n                cls = classes[j]\n                color = colors(cls)\n                cls = names[cls] if names else cls\n                if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                    label = f\"{cls}\" if labels else f\"{cls} {conf[j]:.1f}\"\n                    annotator.box_label(box, label, color=color)\n    annotator.im.save(fname)  # save\n\n\ndef plot_lr_scheduler(optimizer, scheduler, epochs=300, save_dir=\"\"):\n    \"\"\"Plots learning rate schedule for given optimizer and scheduler, saving plot to `save_dir`.\"\"\"\n    optimizer, scheduler = copy(optimizer), copy(scheduler)  # do not modify originals\n    y = []\n    for _ in range(epochs):\n        scheduler.step()\n        y.append(optimizer.param_groups[0][\"lr\"])\n    plt.plot(y, \".-\", label=\"LR\")\n    plt.xlabel(\"epoch\")\n    plt.ylabel(\"LR\")\n    plt.grid()\n    plt.xlim(0, epochs)\n    plt.ylim(0)\n    plt.savefig(Path(save_dir) / \"LR.png\", dpi=200)\n    plt.close()\n\n\ndef plot_val_txt():\n    \"\"\"\n    Plots 2D and 1D histograms of bounding box centers from 'val.txt' using matplotlib, saving as 'hist2d.png' and\n    'hist1d.png'.\n\n    Example: from utils.plots import *; plot_val()\n    \"\"\"\n    x = np.loadtxt(\"val.txt\", dtype=np.float32)\n    box = xyxy2xywh(x[:, :4])\n    cx, cy = box[:, 0], box[:, 1]\n\n    fig, ax = plt.subplots(1, 1, figsize=(6, 6), tight_layout=True)\n    ax.hist2d(cx, cy, bins=600, cmax=10, cmin=0)\n    ax.set_aspect(\"equal\")\n    plt.savefig(\"hist2d.png\", dpi=300)\n\n    fig, ax = plt.subplots(1, 2, figsize=(12, 6), tight_layout=True)\n    ax[0].hist(cx, bins=600)\n    ax[1].hist(cy, bins=600)\n    plt.savefig(\"hist1d.png\", dpi=200)\n\n\ndef plot_targets_txt():\n    \"\"\"\n    Plots histograms of object detection targets from 'targets.txt', saving the figure as 'targets.jpg'.\n\n    Example: from utils.plots import *; plot_targets_txt()\n    \"\"\"\n    x = np.loadtxt(\"targets.txt\", dtype=np.float32).T\n    s = [\"x targets\", \"y targets\", \"width targets\", \"height targets\"]\n    fig, ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)\n    ax = ax.ravel()\n    for i in range(4):\n        ax[i].hist(x[i], bins=100, label=f\"{x[i].mean():.3g} +/- {x[i].std():.3g}\")\n        ax[i].legend()\n        ax[i].set_title(s[i])\n    plt.savefig(\"targets.jpg\", dpi=200)\n\n\ndef plot_val_study(file=\"\", dir=\"\", x=None):\n    \"\"\"\n    Plots validation study results from 'study*.txt' files in a directory or a specific file, comparing model\n    performance and speed.\n\n    Example: from utils.plots import *; plot_val_study()\n    \"\"\"\n    save_dir = Path(file).parent if file else Path(dir)\n    plot2 = False  # plot additional results\n    if plot2:\n        ax = plt.subplots(2, 4, figsize=(10, 6), tight_layout=True)[1].ravel()\n\n    fig2, ax2 = plt.subplots(1, 1, figsize=(8, 4), tight_layout=True)\n    # for f in [save_dir / f'study_coco_{x}.txt' for x in ['yolov5n6', 'yolov5s6', 'yolov5m6', 'yolov5l6', 'yolov5x6']]:\n    for f in sorted(save_dir.glob(\"study*.txt\")):\n        y = np.loadtxt(f, dtype=np.float32, usecols=[0, 1, 2, 3, 7, 8, 9], ndmin=2).T\n        x = np.arange(y.shape[1]) if x is None else np.array(x)\n        if plot2:\n            s = [\"P\", \"R\", \"mAP@.5\", \"mAP@.5:.95\", \"t_preprocess (ms/img)\", \"t_inference (ms/img)\", \"t_NMS (ms/img)\"]\n            for i in range(7):\n                ax[i].plot(x, y[i], \".-\", linewidth=2, markersize=8)\n                ax[i].set_title(s[i])\n\n        j = y[3].argmax() + 1\n        ax2.plot(\n            y[5, 1:j],\n            y[3, 1:j] * 1e2,\n            \".-\",\n            linewidth=2,\n            markersize=8,\n            label=f.stem.replace(\"study_coco_\", \"\").replace(\"yolo\", \"YOLO\"),\n        )\n\n    ax2.plot(\n        1e3 / np.array([209, 140, 97, 58, 35, 18]),\n        [34.6, 40.5, 43.0, 47.5, 49.7, 51.5],\n        \"k.-\",\n        linewidth=2,\n        markersize=8,\n        alpha=0.25,\n        label=\"EfficientDet\",\n    )\n\n    ax2.grid(alpha=0.2)\n    ax2.set_yticks(np.arange(20, 60, 5))\n    ax2.set_xlim(0, 57)\n    ax2.set_ylim(25, 55)\n    ax2.set_xlabel(\"GPU Speed (ms/img)\")\n    ax2.set_ylabel(\"COCO AP val\")\n    ax2.legend(loc=\"lower right\")\n    f = save_dir / \"study.png\"\n    print(f\"Saving {f}...\")\n    plt.savefig(f, dpi=300)\n\n\n@TryExcept()  # known issue https://github.com/ultralytics/yolov5/issues/5395\ndef plot_labels(labels, names=(), save_dir=Path(\"\")):\n    \"\"\"Plots dataset labels, saving correlogram and label images, handles classes, and visualizes bounding boxes.\"\"\"\n    LOGGER.info(f\"Plotting labels to {save_dir / 'labels.jpg'}... \")\n    c, b = labels[:, 0], labels[:, 1:].transpose()  # classes, boxes\n    nc = int(c.max() + 1)  # number of classes\n    x = pd.DataFrame(b.transpose(), columns=[\"x\", \"y\", \"width\", \"height\"])\n\n    # seaborn correlogram\n    sn.pairplot(x, corner=True, diag_kind=\"auto\", kind=\"hist\", diag_kws=dict(bins=50), plot_kws=dict(pmax=0.9))\n    plt.savefig(save_dir / \"labels_correlogram.jpg\", dpi=200)\n    plt.close()\n\n    # matplotlib labels\n    matplotlib.use(\"svg\")  # faster\n    ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)[1].ravel()\n    y = ax[0].hist(c, bins=np.linspace(0, nc, nc + 1) - 0.5, rwidth=0.8)\n    with contextlib.suppress(Exception):  # color histogram bars by class\n        [y[2].patches[i].set_color([x / 255 for x in colors(i)]) for i in range(nc)]  # known issue #3195\n    ax[0].set_ylabel(\"instances\")\n    if 0 < len(names) < 30:\n        ax[0].set_xticks(range(len(names)))\n        ax[0].set_xticklabels(list(names.values()), rotation=90, fontsize=10)\n    else:\n        ax[0].set_xlabel(\"classes\")\n    sn.histplot(x, x=\"x\", y=\"y\", ax=ax[2], bins=50, pmax=0.9)\n    sn.histplot(x, x=\"width\", y=\"height\", ax=ax[3], bins=50, pmax=0.9)\n\n    # rectangles\n    labels[:, 1:3] = 0.5  # center\n    labels[:, 1:] = xywh2xyxy(labels[:, 1:]) * 2000\n    img = Image.fromarray(np.ones((2000, 2000, 3), dtype=np.uint8) * 255)\n    for cls, *box in labels[:1000]:\n        ImageDraw.Draw(img).rectangle(box, width=1, outline=colors(cls))  # plot\n    ax[1].imshow(img)\n    ax[1].axis(\"off\")\n\n    for a in [0, 1, 2, 3]:\n        for s in [\"top\", \"right\", \"left\", \"bottom\"]:\n            ax[a].spines[s].set_visible(False)\n\n    plt.savefig(save_dir / \"labels.jpg\", dpi=200)\n    matplotlib.use(\"Agg\")\n    plt.close()\n\n\ndef imshow_cls(im, labels=None, pred=None, names=None, nmax=25, verbose=False, f=Path(\"images.jpg\")):\n    \"\"\"Displays a grid of images with optional labels and predictions, saving to a file.\"\"\"\n    from utils.augmentations import denormalize\n\n    names = names or [f\"class{i}\" for i in range(1000)]\n    blocks = torch.chunk(\n        denormalize(im.clone()).cpu().float(), len(im), dim=0\n    )  # select batch index 0, block by channels\n    n = min(len(blocks), nmax)  # number of plots\n    m = min(8, round(n**0.5))  # 8 x 8 default\n    fig, ax = plt.subplots(math.ceil(n / m), m)  # 8 rows x n/8 cols\n    ax = ax.ravel() if m > 1 else [ax]\n    # plt.subplots_adjust(wspace=0.05, hspace=0.05)\n    for i in range(n):\n        ax[i].imshow(blocks[i].squeeze().permute((1, 2, 0)).numpy().clip(0.0, 1.0))\n        ax[i].axis(\"off\")\n        if labels is not None:\n            s = names[labels[i]] + (f\"\u2014{names[pred[i]]}\" if pred is not None else \"\")\n            ax[i].set_title(s, fontsize=8, verticalalignment=\"top\")\n    plt.savefig(f, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n    if verbose:\n        LOGGER.info(f\"Saving {f}\")\n        if labels is not None:\n            LOGGER.info(\"True:     \" + \" \".join(f\"{names[i]:3s}\" for i in labels[:nmax]))\n        if pred is not None:\n            LOGGER.info(\"Predicted:\" + \" \".join(f\"{names[i]:3s}\" for i in pred[:nmax]))\n    return f\n\n\ndef plot_evolve(evolve_csv=\"path/to/evolve.csv\"):\n    \"\"\"\n    Plots hyperparameter evolution results from a given CSV, saving the plot and displaying best results.\n\n    Example: from utils.plots import *; plot_evolve()\n    \"\"\"\n    evolve_csv = Path(evolve_csv)\n    data = pd.read_csv(evolve_csv)\n    keys = [x.strip() for x in data.columns]\n    x = data.values\n    f = fitness(x)\n    j = np.argmax(f)  # max fitness index\n    plt.figure(figsize=(10, 12), tight_layout=True)\n    matplotlib.rc(\"font\", **{\"size\": 8})\n    print(f\"Best results from row {j} of {evolve_csv}:\")\n    for i, k in enumerate(keys[7:]):\n        v = x[:, 7 + i]\n        mu = v[j]  # best single result\n        plt.subplot(6, 5, i + 1)\n        plt.scatter(v, f, c=hist2d(v, f, 20), cmap=\"viridis\", alpha=0.8, edgecolors=\"none\")\n        plt.plot(mu, f.max(), \"k+\", markersize=15)\n        plt.title(f\"{k} = {mu:.3g}\", fontdict={\"size\": 9})  # limit to 40 characters\n        if i % 5 != 0:\n            plt.yticks([])\n        print(f\"{k:>15}: {mu:.3g}\")\n    f = evolve_csv.with_suffix(\".png\")  # filename\n    plt.savefig(f, dpi=200)\n    plt.close()\n    print(f\"Saved {f}\")\n\n\ndef plot_results(file=\"path/to/results.csv\", dir=\"\"):\n    \"\"\"\n    Plots training results from a 'results.csv' file; accepts file path and directory as arguments.\n\n    Example: from utils.plots import *; plot_results('path/to/results.csv')\n    \"\"\"\n    save_dir = Path(file).parent if file else Path(dir)\n    fig, ax = plt.subplots(2, 5, figsize=(12, 6), tight_layout=True)\n    ax = ax.ravel()\n    files = list(save_dir.glob(\"results*.csv\"))\n    assert len(files), f\"No results.csv files found in {save_dir.resolve()}, nothing to plot.\"\n    for f in files:\n        try:\n            data = pd.read_csv(f)\n            s = [x.strip() for x in data.columns]\n            x = data.values[:, 0]\n            for i, j in enumerate([1, 2, 3, 4, 5, 8, 9, 10, 6, 7]):\n                y = data.values[:, j].astype(\"float\")\n                # y[y == 0] = np.nan  # don't show zero values\n                ax[i].plot(x, y, marker=\".\", label=f.stem, linewidth=2, markersize=8)  # actual results\n                ax[i].plot(x, gaussian_filter1d(y, sigma=3), \":\", label=\"smooth\", linewidth=2)  # smoothing line\n                ax[i].set_title(s[j], fontsize=12)\n                # if j in [8, 9, 10]:  # share train and val loss y axes\n                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n        except Exception as e:\n            LOGGER.info(f\"Warning: Plotting error for {f}: {e}\")\n    ax[1].legend()\n    fig.savefig(save_dir / \"results.png\", dpi=200)\n    plt.close()\n\n\ndef profile_idetection(start=0, stop=0, labels=(), save_dir=\"\"):\n    \"\"\"\n    Plots per-image iDetection logs, comparing metrics like storage and performance over time.\n\n    Example: from utils.plots import *; profile_idetection()\n    \"\"\"\n    ax = plt.subplots(2, 4, figsize=(12, 6), tight_layout=True)[1].ravel()\n    s = [\"Images\", \"Free Storage (GB)\", \"RAM Usage (GB)\", \"Battery\", \"dt_raw (ms)\", \"dt_smooth (ms)\", \"real-world FPS\"]\n    files = list(Path(save_dir).glob(\"frames*.txt\"))\n    for fi, f in enumerate(files):\n        try:\n            results = np.loadtxt(f, ndmin=2).T[:, 90:-30]  # clip first and last rows\n            n = results.shape[1]  # number of rows\n            x = np.arange(start, min(stop, n) if stop else n)\n            results = results[:, x]\n            t = results[0] - results[0].min()  # set t0=0s\n            results[0] = x\n            for i, a in enumerate(ax):\n                if i < len(results):\n                    label = labels[fi] if len(labels) else f.stem.replace(\"frames_\", \"\")\n                    a.plot(t, results[i], marker=\".\", label=label, linewidth=1, markersize=5)\n                    a.set_title(s[i])\n                    a.set_xlabel(\"time (s)\")\n                    # if fi == len(files) - 1:\n                    #     a.set_ylim(bottom=0)\n                    for side in [\"top\", \"right\"]:\n                        a.spines[side].set_visible(False)\n                else:\n                    a.remove()\n        except Exception as e:\n            print(f\"Warning: Plotting error for {f}; {e}\")\n    ax[1].legend()\n    plt.savefig(Path(save_dir) / \"idetection_profile.png\", dpi=200)\n\n\ndef save_one_box(xyxy, im, file=Path(\"im.jpg\"), gain=1.02, pad=10, square=False, BGR=False, save=True):\n    \"\"\"Crops and saves an image from bounding box `xyxy`, applied with `gain` and `pad`, optionally squares and adjusts\n    for BGR.\n    \"\"\"\n    xyxy = torch.tensor(xyxy).view(-1, 4)\n    b = xyxy2xywh(xyxy)  # boxes\n    if square:\n        b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square\n    b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad\n    xyxy = xywh2xyxy(b).long()\n    clip_boxes(xyxy, im.shape)\n    crop = im[int(xyxy[0, 1]) : int(xyxy[0, 3]), int(xyxy[0, 0]) : int(xyxy[0, 2]), :: (1 if BGR else -1)]\n    if save:\n        file.parent.mkdir(parents=True, exist_ok=True)  # make directory\n        f = str(increment_path(file).with_suffix(\".jpg\"))\n        # cv2.imwrite(f, crop)  # save BGR, https://github.com/ultralytics/yolov5/issues/7007 chroma subsampling issue\n        Image.fromarray(crop[..., ::-1]).save(f, quality=95, subsampling=0)  # save RGB\n    return crop\n", "utils/callbacks.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Callback utils.\"\"\"\n\nimport threading\n\n\nclass Callbacks:\n    \"\"\"Handles all registered callbacks for YOLOv5 Hooks.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes a Callbacks object to manage registered YOLOv5 training event hooks.\"\"\"\n        self._callbacks = {\n            \"on_pretrain_routine_start\": [],\n            \"on_pretrain_routine_end\": [],\n            \"on_train_start\": [],\n            \"on_train_epoch_start\": [],\n            \"on_train_batch_start\": [],\n            \"optimizer_step\": [],\n            \"on_before_zero_grad\": [],\n            \"on_train_batch_end\": [],\n            \"on_train_epoch_end\": [],\n            \"on_val_start\": [],\n            \"on_val_batch_start\": [],\n            \"on_val_image_end\": [],\n            \"on_val_batch_end\": [],\n            \"on_val_end\": [],\n            \"on_fit_epoch_end\": [],  # fit = train + val\n            \"on_model_save\": [],\n            \"on_train_end\": [],\n            \"on_params_update\": [],\n            \"teardown\": [],\n        }\n        self.stop_training = False  # set True to interrupt training\n\n    def register_action(self, hook, name=\"\", callback=None):\n        \"\"\"\n        Register a new action to a callback hook.\n\n        Args:\n            hook: The callback hook name to register the action to\n            name: The name of the action for later reference\n            callback: The callback to fire\n        \"\"\"\n        assert hook in self._callbacks, f\"hook '{hook}' not found in callbacks {self._callbacks}\"\n        assert callable(callback), f\"callback '{callback}' is not callable\"\n        self._callbacks[hook].append({\"name\": name, \"callback\": callback})\n\n    def get_registered_actions(self, hook=None):\n        \"\"\"\n        Returns all the registered actions by callback hook.\n\n        Args:\n            hook: The name of the hook to check, defaults to all\n        \"\"\"\n        return self._callbacks[hook] if hook else self._callbacks\n\n    def run(self, hook, *args, thread=False, **kwargs):\n        \"\"\"\n        Loop through the registered actions and fire all callbacks on main thread.\n\n        Args:\n            hook: The name of the hook to check, defaults to all\n            args: Arguments to receive from YOLOv5\n            thread: (boolean) Run callbacks in daemon thread\n            kwargs: Keyword Arguments to receive from YOLOv5\n        \"\"\"\n\n        assert hook in self._callbacks, f\"hook '{hook}' not found in callbacks {self._callbacks}\"\n        for logger in self._callbacks[hook]:\n            if thread:\n                threading.Thread(target=logger[\"callback\"], args=args, kwargs=kwargs, daemon=True).start()\n            else:\n                logger[\"callback\"](*args, **kwargs)\n", "utils/metrics.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Model validation metrics.\"\"\"\n\nimport math\nimport warnings\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom utils import TryExcept, threaded\n\n\ndef fitness(x):\n    \"\"\"Calculates fitness of a model using weighted sum of metrics P, R, mAP@0.5, mAP@0.5:0.95.\"\"\"\n    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]\n    return (x[:, :4] * w).sum(1)\n\n\ndef smooth(y, f=0.05):\n    \"\"\"Applies box filter smoothing to array `y` with fraction `f`, yielding a smoothed array.\"\"\"\n    nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)\n    p = np.ones(nf // 2)  # ones padding\n    yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded\n    return np.convolve(yp, np.ones(nf) / nf, mode=\"valid\")  # y-smoothed\n\n\ndef ap_per_class(tp, conf, pred_cls, target_cls, plot=False, save_dir=\".\", names=(), eps=1e-16, prefix=\"\"):\n    \"\"\"\n    Compute the average precision, given the recall and precision curves.\n\n    Source: https://github.com/rafaelpadilla/Object-Detection-Metrics.\n    # Arguments\n        tp:  True positives (nparray, nx1 or nx10).\n        conf:  Objectness value from 0-1 (nparray).\n        pred_cls:  Predicted object classes (nparray).\n        target_cls:  True object classes (nparray).\n        plot:  Plot precision-recall curve at mAP@0.5\n        save_dir:  Plot save directory\n    # Returns\n        The average precision as computed in py-faster-rcnn.\n    \"\"\"\n\n    # Sort by objectness\n    i = np.argsort(-conf)\n    tp, conf, pred_cls = tp[i], conf[i], pred_cls[i]\n\n    # Find unique classes\n    unique_classes, nt = np.unique(target_cls, return_counts=True)\n    nc = unique_classes.shape[0]  # number of classes, number of detections\n\n    # Create Precision-Recall curve and compute AP for each class\n    px, py = np.linspace(0, 1, 1000), []  # for plotting\n    ap, p, r = np.zeros((nc, tp.shape[1])), np.zeros((nc, 1000)), np.zeros((nc, 1000))\n    for ci, c in enumerate(unique_classes):\n        i = pred_cls == c\n        n_l = nt[ci]  # number of labels\n        n_p = i.sum()  # number of predictions\n        if n_p == 0 or n_l == 0:\n            continue\n\n        # Accumulate FPs and TPs\n        fpc = (1 - tp[i]).cumsum(0)\n        tpc = tp[i].cumsum(0)\n\n        # Recall\n        recall = tpc / (n_l + eps)  # recall curve\n        r[ci] = np.interp(-px, -conf[i], recall[:, 0], left=0)  # negative x, xp because xp decreases\n\n        # Precision\n        precision = tpc / (tpc + fpc)  # precision curve\n        p[ci] = np.interp(-px, -conf[i], precision[:, 0], left=1)  # p at pr_score\n\n        # AP from recall-precision curve\n        for j in range(tp.shape[1]):\n            ap[ci, j], mpre, mrec = compute_ap(recall[:, j], precision[:, j])\n            if plot and j == 0:\n                py.append(np.interp(px, mrec, mpre))  # precision at mAP@0.5\n\n    # Compute F1 (harmonic mean of precision and recall)\n    f1 = 2 * p * r / (p + r + eps)\n    names = [v for k, v in names.items() if k in unique_classes]  # list: only classes that have data\n    names = dict(enumerate(names))  # to dict\n    if plot:\n        plot_pr_curve(px, py, ap, Path(save_dir) / f\"{prefix}PR_curve.png\", names)\n        plot_mc_curve(px, f1, Path(save_dir) / f\"{prefix}F1_curve.png\", names, ylabel=\"F1\")\n        plot_mc_curve(px, p, Path(save_dir) / f\"{prefix}P_curve.png\", names, ylabel=\"Precision\")\n        plot_mc_curve(px, r, Path(save_dir) / f\"{prefix}R_curve.png\", names, ylabel=\"Recall\")\n\n    i = smooth(f1.mean(0), 0.1).argmax()  # max F1 index\n    p, r, f1 = p[:, i], r[:, i], f1[:, i]\n    tp = (r * nt).round()  # true positives\n    fp = (tp / (p + eps) - tp).round()  # false positives\n    return tp, fp, p, r, f1, ap, unique_classes.astype(int)\n\n\ndef compute_ap(recall, precision):\n    \"\"\"Compute the average precision, given the recall and precision curves\n    # Arguments\n        recall:    The recall curve (list)\n        precision: The precision curve (list)\n    # Returns\n        Average precision, precision curve, recall curve\n    \"\"\"\n\n    # Append sentinel values to beginning and end\n    mrec = np.concatenate(([0.0], recall, [1.0]))\n    mpre = np.concatenate(([1.0], precision, [0.0]))\n\n    # Compute the precision envelope\n    mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))\n\n    # Integrate area under curve\n    method = \"interp\"  # methods: 'continuous', 'interp'\n    if method == \"interp\":\n        x = np.linspace(0, 1, 101)  # 101-point interp (COCO)\n        ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate\n    else:  # 'continuous'\n        i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x axis (recall) changes\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve\n\n    return ap, mpre, mrec\n\n\nclass ConfusionMatrix:\n    # Updated version of https://github.com/kaanakan/object_detection_confusion_matrix\n    def __init__(self, nc, conf=0.25, iou_thres=0.45):\n        \"\"\"Initializes ConfusionMatrix with given number of classes, confidence, and IoU threshold.\"\"\"\n        self.matrix = np.zeros((nc + 1, nc + 1))\n        self.nc = nc  # number of classes\n        self.conf = conf\n        self.iou_thres = iou_thres\n\n    def process_batch(self, detections, labels):\n        \"\"\"\n        Return intersection-over-union (Jaccard index) of boxes.\n\n        Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n        Arguments:\n            detections (Array[N, 6]), x1, y1, x2, y2, conf, class\n            labels (Array[M, 5]), class, x1, y1, x2, y2\n        Returns:\n            None, updates confusion matrix accordingly\n        \"\"\"\n        if detections is None:\n            gt_classes = labels.int()\n            for gc in gt_classes:\n                self.matrix[self.nc, gc] += 1  # background FN\n            return\n\n        detections = detections[detections[:, 4] > self.conf]\n        gt_classes = labels[:, 0].int()\n        detection_classes = detections[:, 5].int()\n        iou = box_iou(labels[:, 1:], detections[:, :4])\n\n        x = torch.where(iou > self.iou_thres)\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n        else:\n            matches = np.zeros((0, 3))\n\n        n = matches.shape[0] > 0\n        m0, m1, _ = matches.transpose().astype(int)\n        for i, gc in enumerate(gt_classes):\n            j = m0 == i\n            if n and sum(j) == 1:\n                self.matrix[detection_classes[m1[j]], gc] += 1  # correct\n            else:\n                self.matrix[self.nc, gc] += 1  # true background\n\n        if n:\n            for i, dc in enumerate(detection_classes):\n                if not any(m1 == i):\n                    self.matrix[dc, self.nc] += 1  # predicted background\n\n    def tp_fp(self):\n        \"\"\"Calculates true positives (tp) and false positives (fp) excluding the background class from the confusion\n        matrix.\n        \"\"\"\n        tp = self.matrix.diagonal()  # true positives\n        fp = self.matrix.sum(1) - tp  # false positives\n        # fn = self.matrix.sum(0) - tp  # false negatives (missed detections)\n        return tp[:-1], fp[:-1]  # remove background class\n\n    @TryExcept(\"WARNING \u26a0\ufe0f ConfusionMatrix plot failure\")\n    def plot(self, normalize=True, save_dir=\"\", names=()):\n        \"\"\"Plots confusion matrix using seaborn, optional normalization; can save plot to specified directory.\"\"\"\n        import seaborn as sn\n\n        array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1e-9) if normalize else 1)  # normalize columns\n        array[array < 0.005] = np.nan  # don't annotate (would appear as 0.00)\n\n        fig, ax = plt.subplots(1, 1, figsize=(12, 9), tight_layout=True)\n        nc, nn = self.nc, len(names)  # number of classes, names\n        sn.set(font_scale=1.0 if nc < 50 else 0.8)  # for label size\n        labels = (0 < nn < 99) and (nn == nc)  # apply names to ticklabels\n        ticklabels = (names + [\"background\"]) if labels else \"auto\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")  # suppress empty matrix RuntimeWarning: All-NaN slice encountered\n            sn.heatmap(\n                array,\n                ax=ax,\n                annot=nc < 30,\n                annot_kws={\"size\": 8},\n                cmap=\"Blues\",\n                fmt=\".2f\",\n                square=True,\n                vmin=0.0,\n                xticklabels=ticklabels,\n                yticklabels=ticklabels,\n            ).set_facecolor((1, 1, 1))\n        ax.set_xlabel(\"True\")\n        ax.set_ylabel(\"Predicted\")\n        ax.set_title(\"Confusion Matrix\")\n        fig.savefig(Path(save_dir) / \"confusion_matrix.png\", dpi=250)\n        plt.close(fig)\n\n    def print(self):\n        \"\"\"Prints the confusion matrix row-wise, with each class and its predictions separated by spaces.\"\"\"\n        for i in range(self.nc + 1):\n            print(\" \".join(map(str, self.matrix[i])))\n\n\ndef bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculates IoU, GIoU, DIoU, or CIoU between two boxes, supporting xywh/xyxy formats.\n\n    Input shapes are box1(1,4) to box2(n,4).\n    \"\"\"\n\n    # Get the coordinates of bounding boxes\n    if xywh:  # transform from xywh to xyxy\n        (x1, y1, w1, h1), (x2, y2, w2, h2) = box1.chunk(4, -1), box2.chunk(4, -1)\n        w1_, h1_, w2_, h2_ = w1 / 2, h1 / 2, w2 / 2, h2 / 2\n        b1_x1, b1_x2, b1_y1, b1_y2 = x1 - w1_, x1 + w1_, y1 - h1_, y1 + h1_\n        b2_x1, b2_x2, b2_y1, b2_y2 = x2 - w2_, x2 + w2_, y2 - h2_, y2 + h2_\n    else:  # x1, y1, x2, y2 = box1\n        b1_x1, b1_y1, b1_x2, b1_y2 = box1.chunk(4, -1)\n        b2_x1, b2_y1, b2_x2, b2_y2 = box2.chunk(4, -1)\n        w1, h1 = b1_x2 - b1_x1, (b1_y2 - b1_y1).clamp(eps)\n        w2, h2 = b2_x2 - b2_x1, (b2_y2 - b2_y1).clamp(eps)\n\n    # Intersection area\n    inter = (b1_x2.minimum(b2_x2) - b1_x1.maximum(b2_x1)).clamp(0) * (\n        b1_y2.minimum(b2_y2) - b1_y1.maximum(b2_y1)\n    ).clamp(0)\n\n    # Union Area\n    union = w1 * h1 + w2 * h2 - inter + eps\n\n    # IoU\n    iou = inter / union\n    if CIoU or DIoU or GIoU:\n        cw = b1_x2.maximum(b2_x2) - b1_x1.minimum(b2_x1)  # convex (smallest enclosing box) width\n        ch = b1_y2.maximum(b2_y2) - b1_y1.minimum(b2_y1)  # convex height\n        if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1\n            c2 = cw**2 + ch**2 + eps  # convex diagonal squared\n            rho2 = ((b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2 + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2) / 4  # center dist ** 2\n            if CIoU:  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47\n                v = (4 / math.pi**2) * (torch.atan(w2 / h2) - torch.atan(w1 / h1)).pow(2)\n                with torch.no_grad():\n                    alpha = v / (v - iou + (1 + eps))\n                return iou - (rho2 / c2 + v * alpha)  # CIoU\n            return iou - rho2 / c2  # DIoU\n        c_area = cw * ch + eps  # convex area\n        return iou - (c_area - union) / c_area  # GIoU https://arxiv.org/pdf/1902.09630.pdf\n    return iou  # IoU\n\n\ndef box_iou(box1, box2, eps=1e-7):\n    # https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py\n    \"\"\"\n    Return intersection-over-union (Jaccard index) of boxes.\n\n    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n    Arguments:\n        box1 (Tensor[N, 4])\n        box2 (Tensor[M, 4])\n    Returns:\n        iou (Tensor[N, M]): the NxM matrix containing the pairwise\n            IoU values for every element in boxes1 and boxes2\n    \"\"\"\n\n    # inter(N,M) = (rb(N,M,2) - lt(N,M,2)).clamp(0).prod(2)\n    (a1, a2), (b1, b2) = box1.unsqueeze(1).chunk(2, 2), box2.unsqueeze(0).chunk(2, 2)\n    inter = (torch.min(a2, b2) - torch.max(a1, b1)).clamp(0).prod(2)\n\n    # IoU = inter / (area1 + area2 - inter)\n    return inter / ((a2 - a1).prod(2) + (b2 - b1).prod(2) - inter + eps)\n\n\ndef bbox_ioa(box1, box2, eps=1e-7):\n    \"\"\"\n    Returns the intersection over box2 area given box1, box2.\n\n    Boxes are x1y1x2y2\n    box1:       np.array of shape(4)\n    box2:       np.array of shape(nx4)\n    returns:    np.array of shape(n)\n    \"\"\"\n\n    # Get the coordinates of bounding boxes\n    b1_x1, b1_y1, b1_x2, b1_y2 = box1\n    b2_x1, b2_y1, b2_x2, b2_y2 = box2.T\n\n    # Intersection area\n    inter_area = (np.minimum(b1_x2, b2_x2) - np.maximum(b1_x1, b2_x1)).clip(0) * (\n        np.minimum(b1_y2, b2_y2) - np.maximum(b1_y1, b2_y1)\n    ).clip(0)\n\n    # box2 area\n    box2_area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1) + eps\n\n    # Intersection over box2 area\n    return inter_area / box2_area\n\n\ndef wh_iou(wh1, wh2, eps=1e-7):\n    \"\"\"Calculates the Intersection over Union (IoU) for two sets of widths and heights; `wh1` and `wh2` should be nx2\n    and mx2 tensors.\n    \"\"\"\n    wh1 = wh1[:, None]  # [N,1,2]\n    wh2 = wh2[None]  # [1,M,2]\n    inter = torch.min(wh1, wh2).prod(2)  # [N,M]\n    return inter / (wh1.prod(2) + wh2.prod(2) - inter + eps)  # iou = inter / (area1 + area2 - inter)\n\n\n# Plots ----------------------------------------------------------------------------------------------------------------\n\n\n@threaded\ndef plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=()):\n    \"\"\"Plots precision-recall curve, optionally per class, saving to `save_dir`; `px`, `py` are lists, `ap` is Nx2\n    array, `names` optional.\n    \"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    py = np.stack(py, axis=1)\n\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py.T):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]} {ap[i, 0]:.3f}\")  # plot(recall, precision)\n    else:\n        ax.plot(px, py, linewidth=1, color=\"grey\")  # plot(recall, precision)\n\n    ax.plot(px, py.mean(1), linewidth=3, color=\"blue\", label=\"all classes %.3f mAP@0.5\" % ap[:, 0].mean())\n    ax.set_xlabel(\"Recall\")\n    ax.set_ylabel(\"Precision\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title(\"Precision-Recall Curve\")\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)\n\n\n@threaded\ndef plot_mc_curve(px, py, save_dir=Path(\"mc_curve.png\"), names=(), xlabel=\"Confidence\", ylabel=\"Metric\"):\n    \"\"\"Plots a metric-confidence curve for model predictions, supporting per-class visualization and smoothing.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]}\")  # plot(confidence, metric)\n    else:\n        ax.plot(px, py.T, linewidth=1, color=\"grey\")  # plot(confidence, metric)\n\n    y = smooth(py.mean(0), 0.05)\n    ax.plot(px, y, linewidth=3, color=\"blue\", label=f\"all classes {y.max():.2f} at {px[y.argmax()]:.3f}\")\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title(f\"{ylabel}-Confidence Curve\")\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)\n", "utils/autoanchor.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"AutoAnchor utils.\"\"\"\n\nimport random\n\nimport numpy as np\nimport torch\nimport yaml\nfrom tqdm import tqdm\n\nfrom utils import TryExcept\nfrom utils.general import LOGGER, TQDM_BAR_FORMAT, colorstr\n\nPREFIX = colorstr(\"AutoAnchor: \")\n\n\ndef check_anchor_order(m):\n    \"\"\"Checks and corrects anchor order against stride in YOLOv5 Detect() module if necessary.\"\"\"\n    a = m.anchors.prod(-1).mean(-1).view(-1)  # mean anchor area per output layer\n    da = a[-1] - a[0]  # delta a\n    ds = m.stride[-1] - m.stride[0]  # delta s\n    if da and (da.sign() != ds.sign()):  # same order\n        LOGGER.info(f\"{PREFIX}Reversing anchor order\")\n        m.anchors[:] = m.anchors.flip(0)\n\n\n@TryExcept(f\"{PREFIX}ERROR\")\ndef check_anchors(dataset, model, thr=4.0, imgsz=640):\n    \"\"\"Evaluates anchor fit to dataset and adjusts if necessary, supporting customizable threshold and image size.\"\"\"\n    m = model.module.model[-1] if hasattr(model, \"module\") else model.model[-1]  # Detect()\n    shapes = imgsz * dataset.shapes / dataset.shapes.max(1, keepdims=True)\n    scale = np.random.uniform(0.9, 1.1, size=(shapes.shape[0], 1))  # augment scale\n    wh = torch.tensor(np.concatenate([l[:, 3:5] * s for s, l in zip(shapes * scale, dataset.labels)])).float()  # wh\n\n    def metric(k):  # compute metric\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        best = x.max(1)[0]  # best_x\n        aat = (x > 1 / thr).float().sum(1).mean()  # anchors above threshold\n        bpr = (best > 1 / thr).float().mean()  # best possible recall\n        return bpr, aat\n\n    stride = m.stride.to(m.anchors.device).view(-1, 1, 1)  # model strides\n    anchors = m.anchors.clone() * stride  # current anchors\n    bpr, aat = metric(anchors.cpu().view(-1, 2))\n    s = f\"\\n{PREFIX}{aat:.2f} anchors/target, {bpr:.3f} Best Possible Recall (BPR). \"\n    if bpr > 0.98:  # threshold to recompute\n        LOGGER.info(f\"{s}Current anchors are a good fit to dataset \u2705\")\n    else:\n        LOGGER.info(f\"{s}Anchors are a poor fit to dataset \u26a0\ufe0f, attempting to improve...\")\n        na = m.anchors.numel() // 2  # number of anchors\n        anchors = kmean_anchors(dataset, n=na, img_size=imgsz, thr=thr, gen=1000, verbose=False)\n        new_bpr = metric(anchors)[0]\n        if new_bpr > bpr:  # replace anchors\n            anchors = torch.tensor(anchors, device=m.anchors.device).type_as(m.anchors)\n            m.anchors[:] = anchors.clone().view_as(m.anchors)\n            check_anchor_order(m)  # must be in pixel-space (not grid-space)\n            m.anchors /= stride\n            s = f\"{PREFIX}Done \u2705 (optional: update model *.yaml to use these anchors in the future)\"\n        else:\n            s = f\"{PREFIX}Done \u26a0\ufe0f (original anchors better than new anchors, proceeding with original anchors)\"\n        LOGGER.info(s)\n\n\ndef kmean_anchors(dataset=\"./data/coco128.yaml\", n=9, img_size=640, thr=4.0, gen=1000, verbose=True):\n    \"\"\"\n    Creates kmeans-evolved anchors from training dataset.\n\n    Arguments:\n        dataset: path to data.yaml, or a loaded dataset\n        n: number of anchors\n        img_size: image size used for training\n        thr: anchor-label wh ratio threshold hyperparameter hyp['anchor_t'] used for training, default=4.0\n        gen: generations to evolve anchors using genetic algorithm\n        verbose: print all results\n\n    Return:\n        k: kmeans evolved anchors\n\n    Usage:\n        from utils.autoanchor import *; _ = kmean_anchors()\n    \"\"\"\n    from scipy.cluster.vq import kmeans\n\n    npr = np.random\n    thr = 1 / thr\n\n    def metric(k, wh):  # compute metrics\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        # x = wh_iou(wh, torch.tensor(k))  # iou metric\n        return x, x.max(1)[0]  # x, best_x\n\n    def anchor_fitness(k):  # mutation fitness\n        _, best = metric(torch.tensor(k, dtype=torch.float32), wh)\n        return (best * (best > thr).float()).mean()  # fitness\n\n    def print_results(k, verbose=True):\n        k = k[np.argsort(k.prod(1))]  # sort small to large\n        x, best = metric(k, wh0)\n        bpr, aat = (best > thr).float().mean(), (x > thr).float().mean() * n  # best possible recall, anch > thr\n        s = (\n            f\"{PREFIX}thr={thr:.2f}: {bpr:.4f} best possible recall, {aat:.2f} anchors past thr\\n\"\n            f\"{PREFIX}n={n}, img_size={img_size}, metric_all={x.mean():.3f}/{best.mean():.3f}-mean/best, \"\n            f\"past_thr={x[x > thr].mean():.3f}-mean: \"\n        )\n        for x in k:\n            s += \"%i,%i, \" % (round(x[0]), round(x[1]))\n        if verbose:\n            LOGGER.info(s[:-2])\n        return k\n\n    if isinstance(dataset, str):  # *.yaml file\n        with open(dataset, errors=\"ignore\") as f:\n            data_dict = yaml.safe_load(f)  # model dict\n        from utils.dataloaders import LoadImagesAndLabels\n\n        dataset = LoadImagesAndLabels(data_dict[\"train\"], augment=True, rect=True)\n\n    # Get label wh\n    shapes = img_size * dataset.shapes / dataset.shapes.max(1, keepdims=True)\n    wh0 = np.concatenate([l[:, 3:5] * s for s, l in zip(shapes, dataset.labels)])  # wh\n\n    # Filter\n    i = (wh0 < 3.0).any(1).sum()\n    if i:\n        LOGGER.info(f\"{PREFIX}WARNING \u26a0\ufe0f Extremely small objects found: {i} of {len(wh0)} labels are <3 pixels in size\")\n    wh = wh0[(wh0 >= 2.0).any(1)].astype(np.float32)  # filter > 2 pixels\n    # wh = wh * (npr.rand(wh.shape[0], 1) * 0.9 + 0.1)  # multiply by random scale 0-1\n\n    # Kmeans init\n    try:\n        LOGGER.info(f\"{PREFIX}Running kmeans for {n} anchors on {len(wh)} points...\")\n        assert n <= len(wh)  # apply overdetermined constraint\n        s = wh.std(0)  # sigmas for whitening\n        k = kmeans(wh / s, n, iter=30)[0] * s  # points\n        assert n == len(k)  # kmeans may return fewer points than requested if wh is insufficient or too similar\n    except Exception:\n        LOGGER.warning(f\"{PREFIX}WARNING \u26a0\ufe0f switching strategies from kmeans to random init\")\n        k = np.sort(npr.rand(n * 2)).reshape(n, 2) * img_size  # random init\n    wh, wh0 = (torch.tensor(x, dtype=torch.float32) for x in (wh, wh0))\n    k = print_results(k, verbose=False)\n\n    # Plot\n    # k, d = [None] * 20, [None] * 20\n    # for i in tqdm(range(1, 21)):\n    #     k[i-1], d[i-1] = kmeans(wh / s, i)  # points, mean distance\n    # fig, ax = plt.subplots(1, 2, figsize=(14, 7), tight_layout=True)\n    # ax = ax.ravel()\n    # ax[0].plot(np.arange(1, 21), np.array(d) ** 2, marker='.')\n    # fig, ax = plt.subplots(1, 2, figsize=(14, 7))  # plot wh\n    # ax[0].hist(wh[wh[:, 0]<100, 0],400)\n    # ax[1].hist(wh[wh[:, 1]<100, 1],400)\n    # fig.savefig('wh.png', dpi=200)\n\n    # Evolve\n    f, sh, mp, s = anchor_fitness(k), k.shape, 0.9, 0.1  # fitness, generations, mutation prob, sigma\n    pbar = tqdm(range(gen), bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for _ in pbar:\n        v = np.ones(sh)\n        while (v == 1).all():  # mutate until a change occurs (prevent duplicates)\n            v = ((npr.random(sh) < mp) * random.random() * npr.randn(*sh) * s + 1).clip(0.3, 3.0)\n        kg = (k.copy() * v).clip(min=2.0)\n        fg = anchor_fitness(kg)\n        if fg > f:\n            f, k = fg, kg.copy()\n            pbar.desc = f\"{PREFIX}Evolving anchors with Genetic Algorithm: fitness = {f:.4f}\"\n            if verbose:\n                print_results(k, verbose)\n\n    return print_results(k).astype(np.float32)\n", "utils/general.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"General utils.\"\"\"\n\nimport contextlib\nimport glob\nimport inspect\nimport logging\nimport logging.config\nimport math\nimport os\nimport platform\nimport random\nimport re\nimport signal\nimport subprocess\nimport sys\nimport time\nimport urllib\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom itertools import repeat\nfrom multiprocessing.pool import ThreadPool\nfrom pathlib import Path\nfrom subprocess import check_output\nfrom tarfile import is_tarfile\nfrom typing import Optional\nfrom zipfile import ZipFile, is_zipfile\n\nimport cv2\nimport numpy as np\nimport pandas as pd\nimport pkg_resources as pkg\nimport torch\nimport torchvision\nimport yaml\n\n# Import 'ultralytics' package or install if missing\ntry:\n    import ultralytics\n\n    assert hasattr(ultralytics, \"__version__\")  # verify package is not directory\nexcept (ImportError, AssertionError):\n    os.system(\"pip install -U ultralytics\")\n    import ultralytics\n\nfrom ultralytics.utils.checks import check_requirements\n\nfrom utils import TryExcept, emojis\nfrom utils.downloads import curl_download, gsutil_getsize\nfrom utils.metrics import box_iou, fitness\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nRANK = int(os.getenv(\"RANK\", -1))\n\n# Settings\nNUM_THREADS = min(8, max(1, os.cpu_count() - 1))  # number of YOLOv5 multiprocessing threads\nDATASETS_DIR = Path(os.getenv(\"YOLOv5_DATASETS_DIR\", ROOT.parent / \"datasets\"))  # global datasets directory\nAUTOINSTALL = str(os.getenv(\"YOLOv5_AUTOINSTALL\", True)).lower() == \"true\"  # global auto-install mode\nVERBOSE = str(os.getenv(\"YOLOv5_VERBOSE\", True)).lower() == \"true\"  # global verbose mode\nTQDM_BAR_FORMAT = \"{l_bar}{bar:10}{r_bar}\"  # tqdm bar format\nFONT = \"Arial.ttf\"  # https://ultralytics.com/assets/Arial.ttf\n\ntorch.set_printoptions(linewidth=320, precision=5, profile=\"long\")\nnp.set_printoptions(linewidth=320, formatter={\"float_kind\": \"{:11.5g}\".format})  # format short g, %precision=5\npd.options.display.max_columns = 10\ncv2.setNumThreads(0)  # prevent OpenCV from multithreading (incompatible with PyTorch DataLoader)\nos.environ[\"NUMEXPR_MAX_THREADS\"] = str(NUM_THREADS)  # NumExpr max threads\nos.environ[\"OMP_NUM_THREADS\"] = \"1\" if platform.system() == \"darwin\" else str(NUM_THREADS)  # OpenMP (PyTorch and SciPy)\nos.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"2\"  # suppress verbose TF compiler warnings in Colab\nos.environ[\"TORCH_CPP_LOG_LEVEL\"] = \"ERROR\"  # suppress \"NNPACK.cpp could not initialize NNPACK\" warnings\nos.environ[\"KINETO_LOG_LEVEL\"] = \"5\"  # suppress verbose PyTorch profiler output when computing FLOPs\n\n\ndef is_ascii(s=\"\"):\n    \"\"\"Checks if input string `s` contains only ASCII characters; returns `True` if so, otherwise `False`.\"\"\"\n    s = str(s)  # convert list, tuple, None, etc. to str\n    return len(s.encode().decode(\"ascii\", \"ignore\")) == len(s)\n\n\ndef is_chinese(s=\"\u4eba\u5de5\u667a\u80fd\"):\n    \"\"\"Determines if a string `s` contains any Chinese characters; returns `True` if so, otherwise `False`.\"\"\"\n    return bool(re.search(\"[\\u4e00-\\u9fff]\", str(s)))\n\n\ndef is_colab():\n    \"\"\"Checks if the current environment is a Google Colab instance; returns `True` for Colab, otherwise `False`.\"\"\"\n    return \"google.colab\" in sys.modules\n\n\ndef is_jupyter():\n    \"\"\"\n    Check if the current script is running inside a Jupyter Notebook. Verified on Colab, Jupyterlab, Kaggle, Paperspace.\n\n    Returns:\n        bool: True if running inside a Jupyter Notebook, False otherwise.\n    \"\"\"\n    with contextlib.suppress(Exception):\n        from IPython import get_ipython\n\n        return get_ipython() is not None\n    return False\n\n\ndef is_kaggle():\n    \"\"\"Checks if the current environment is a Kaggle Notebook by validating environment variables.\"\"\"\n    return os.environ.get(\"PWD\") == \"/kaggle/working\" and os.environ.get(\"KAGGLE_URL_BASE\") == \"https://www.kaggle.com\"\n\n\ndef is_docker() -> bool:\n    \"\"\"Check if the process runs inside a docker container.\"\"\"\n    if Path(\"/.dockerenv\").exists():\n        return True\n    try:  # check if docker is in control groups\n        with open(\"/proc/self/cgroup\") as file:\n            return any(\"docker\" in line for line in file)\n    except OSError:\n        return False\n\n\ndef is_writeable(dir, test=False):\n    \"\"\"Checks if a directory is writable, optionally testing by creating a temporary file if `test=True`.\"\"\"\n    if not test:\n        return os.access(dir, os.W_OK)  # possible issues on Windows\n    file = Path(dir) / \"tmp.txt\"\n    try:\n        with open(file, \"w\"):  # open file with write permissions\n            pass\n        file.unlink()  # remove file\n        return True\n    except OSError:\n        return False\n\n\nLOGGING_NAME = \"yolov5\"\n\n\ndef set_logging(name=LOGGING_NAME, verbose=True):\n    \"\"\"Configures logging with specified verbosity; `name` sets the logger's name, `verbose` controls logging level.\"\"\"\n    rank = int(os.getenv(\"RANK\", -1))  # rank in world for Multi-GPU trainings\n    level = logging.INFO if verbose and rank in {-1, 0} else logging.ERROR\n    logging.config.dictConfig(\n        {\n            \"version\": 1,\n            \"disable_existing_loggers\": False,\n            \"formatters\": {name: {\"format\": \"%(message)s\"}},\n            \"handlers\": {\n                name: {\n                    \"class\": \"logging.StreamHandler\",\n                    \"formatter\": name,\n                    \"level\": level,\n                }\n            },\n            \"loggers\": {\n                name: {\n                    \"level\": level,\n                    \"handlers\": [name],\n                    \"propagate\": False,\n                }\n            },\n        }\n    )\n\n\nset_logging(LOGGING_NAME)  # run before defining LOGGER\nLOGGER = logging.getLogger(LOGGING_NAME)  # define globally (used in train.py, val.py, detect.py, etc.)\nif platform.system() == \"Windows\":\n    for fn in LOGGER.info, LOGGER.warning:\n        setattr(LOGGER, fn.__name__, lambda x: fn(emojis(x)))  # emoji safe logging\n\n\ndef user_config_dir(dir=\"Ultralytics\", env_var=\"YOLOV5_CONFIG_DIR\"):\n    \"\"\"Returns user configuration directory path, preferring environment variable `YOLOV5_CONFIG_DIR` if set, else OS-\n    specific.\n    \"\"\"\n    env = os.getenv(env_var)\n    if env:\n        path = Path(env)  # use environment variable\n    else:\n        cfg = {\"Windows\": \"AppData/Roaming\", \"Linux\": \".config\", \"Darwin\": \"Library/Application Support\"}  # 3 OS dirs\n        path = Path.home() / cfg.get(platform.system(), \"\")  # OS-specific config dir\n        path = (path if is_writeable(path) else Path(\"/tmp\")) / dir  # GCP and AWS lambda fix, only /tmp is writeable\n    path.mkdir(exist_ok=True)  # make if required\n    return path\n\n\nCONFIG_DIR = user_config_dir()  # Ultralytics settings dir\n\n\nclass Profile(contextlib.ContextDecorator):\n    # YOLOv5 Profile class. Usage: @Profile() decorator or 'with Profile():' context manager\n    def __init__(self, t=0.0, device: torch.device = None):\n        \"\"\"Initializes a profiling context for YOLOv5 with optional timing threshold and device specification.\"\"\"\n        self.t = t\n        self.device = device\n        self.cuda = bool(device and str(device).startswith(\"cuda\"))\n\n    def __enter__(self):\n        \"\"\"Initializes timing at the start of a profiling context block for performance measurement.\"\"\"\n        self.start = self.time()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"Concludes timing, updating duration for profiling upon exiting a context block.\"\"\"\n        self.dt = self.time() - self.start  # delta-time\n        self.t += self.dt  # accumulate dt\n\n    def time(self):\n        \"\"\"Measures and returns the current time, synchronizing CUDA operations if `cuda` is True.\"\"\"\n        if self.cuda:\n            torch.cuda.synchronize(self.device)\n        return time.time()\n\n\nclass Timeout(contextlib.ContextDecorator):\n    # YOLOv5 Timeout class. Usage: @Timeout(seconds) decorator or 'with Timeout(seconds):' context manager\n    def __init__(self, seconds, *, timeout_msg=\"\", suppress_timeout_errors=True):\n        \"\"\"Initializes a timeout context/decorator with defined seconds, optional message, and error suppression.\"\"\"\n        self.seconds = int(seconds)\n        self.timeout_message = timeout_msg\n        self.suppress = bool(suppress_timeout_errors)\n\n    def _timeout_handler(self, signum, frame):\n        \"\"\"Raises a TimeoutError with a custom message when a timeout event occurs.\"\"\"\n        raise TimeoutError(self.timeout_message)\n\n    def __enter__(self):\n        \"\"\"Initializes timeout mechanism on non-Windows platforms, starting a countdown to raise TimeoutError.\"\"\"\n        if platform.system() != \"Windows\":  # not supported on Windows\n            signal.signal(signal.SIGALRM, self._timeout_handler)  # Set handler for SIGALRM\n            signal.alarm(self.seconds)  # start countdown for SIGALRM to be raised\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Disables active alarm on non-Windows systems and optionally suppresses TimeoutError if set.\"\"\"\n        if platform.system() != \"Windows\":\n            signal.alarm(0)  # Cancel SIGALRM if it's scheduled\n            if self.suppress and exc_type is TimeoutError:  # Suppress TimeoutError\n                return True\n\n\nclass WorkingDirectory(contextlib.ContextDecorator):\n    # Usage: @WorkingDirectory(dir) decorator or 'with WorkingDirectory(dir):' context manager\n    def __init__(self, new_dir):\n        \"\"\"Initializes a context manager/decorator to temporarily change the working directory.\"\"\"\n        self.dir = new_dir  # new dir\n        self.cwd = Path.cwd().resolve()  # current dir\n\n    def __enter__(self):\n        \"\"\"Temporarily changes the working directory within a 'with' statement context.\"\"\"\n        os.chdir(self.dir)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Restores the original working directory upon exiting a 'with' statement context.\"\"\"\n        os.chdir(self.cwd)\n\n\ndef methods(instance):\n    \"\"\"Returns list of method names for a class/instance excluding dunder methods.\"\"\"\n    return [f for f in dir(instance) if callable(getattr(instance, f)) and not f.startswith(\"__\")]\n\n\ndef print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Logs the arguments of the calling function, with options to include the filename and function name.\"\"\"\n    x = inspect.currentframe().f_back  # previous frame\n    file, _, func, _, _ = inspect.getframeinfo(x)\n    if args is None:  # get args automatically\n        args, _, _, frm = inspect.getargvalues(x)\n        args = {k: v for k, v in frm.items() if k in args}\n    try:\n        file = Path(file).resolve().relative_to(ROOT).with_suffix(\"\")\n    except ValueError:\n        file = Path(file).stem\n    s = (f\"{file}: \" if show_file else \"\") + (f\"{func}: \" if show_func else \"\")\n    LOGGER.info(colorstr(s) + \", \".join(f\"{k}={v}\" for k, v in args.items()))\n\n\ndef init_seeds(seed=0, deterministic=False):\n    \"\"\"\n    Initializes RNG seeds and sets deterministic options if specified.\n\n    See https://pytorch.org/docs/stable/notes/randomness.html\n    \"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe\n    # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287\n    if deterministic and check_version(torch.__version__, \"1.12.0\"):  # https://github.com/ultralytics/yolov5/pull/8213\n        torch.use_deterministic_algorithms(True)\n        torch.backends.cudnn.deterministic = True\n        os.environ[\"CUBLAS_WORKSPACE_CONFIG\"] = \":4096:8\"\n        os.environ[\"PYTHONHASHSEED\"] = str(seed)\n\n\ndef intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns intersection of `da` and `db` dicts with matching keys and shapes, excluding `exclude` keys; uses `da`\n    values.\n    \"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\n\n\ndef get_default_args(func):\n    \"\"\"Returns a dict of `func` default arguments by inspecting its signature.\"\"\"\n    signature = inspect.signature(func)\n    return {k: v.default for k, v in signature.parameters.items() if v.default is not inspect.Parameter.empty}\n\n\ndef get_latest_run(search_dir=\".\"):\n    \"\"\"Returns the path to the most recent 'last.pt' file in /runs to resume from, searches in `search_dir`.\"\"\"\n    last_list = glob.glob(f\"{search_dir}/**/last*.pt\", recursive=True)\n    return max(last_list, key=os.path.getctime) if last_list else \"\"\n\n\ndef file_age(path=__file__):\n    \"\"\"Calculates and returns the age of a file in days based on its last modification time.\"\"\"\n    dt = datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime)  # delta\n    return dt.days  # + dt.seconds / 86400  # fractional days\n\n\ndef file_date(path=__file__):\n    \"\"\"Returns a human-readable file modification date in 'YYYY-M-D' format, given a file path.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\n\n\ndef file_size(path):\n    \"\"\"Returns file or directory size in megabytes (MB) for a given path, where directories are recursively summed.\"\"\"\n    mb = 1 << 20  # bytes to MiB (1024 ** 2)\n    path = Path(path)\n    if path.is_file():\n        return path.stat().st_size / mb\n    elif path.is_dir():\n        return sum(f.stat().st_size for f in path.glob(\"**/*\") if f.is_file()) / mb\n    else:\n        return 0.0\n\n\ndef check_online():\n    \"\"\"Checks internet connectivity by attempting to create a connection to \"1.1.1.1\" on port 443, retries once if the\n    first attempt fails.\n    \"\"\"\n    import socket\n\n    def run_once():\n        # Check once\n        try:\n            socket.create_connection((\"1.1.1.1\", 443), 5)  # check host accessibility\n            return True\n        except OSError:\n            return False\n\n    return run_once() or run_once()  # check twice to increase robustness to intermittent connectivity issues\n\n\ndef git_describe(path=ROOT):\n    \"\"\"\n    Returns a human-readable git description of the repository at `path`, or an empty string on failure.\n\n    Example output is 'fv5.0-5-g3e25f1e'. See https://git-scm.com/docs/git-describe.\n    \"\"\"\n    try:\n        assert (Path(path) / \".git\").is_dir()\n        return check_output(f\"git -C {path} describe --tags --long --always\", shell=True).decode()[:-1]\n    except Exception:\n        return \"\"\n\n\n@TryExcept()\n@WorkingDirectory(ROOT)\ndef check_git_status(repo=\"ultralytics/yolov5\", branch=\"master\"):\n    \"\"\"Checks if YOLOv5 code is up-to-date with the repository, advising 'git pull' if behind; errors return informative\n    messages.\n    \"\"\"\n    url = f\"https://github.com/{repo}\"\n    msg = f\", for updates see {url}\"\n    s = colorstr(\"github: \")  # string\n    assert Path(\".git\").exists(), s + \"skipping check (not a git repository)\" + msg\n    assert check_online(), s + \"skipping check (offline)\" + msg\n\n    splits = re.split(pattern=r\"\\s\", string=check_output(\"git remote -v\", shell=True).decode())\n    matches = [repo in s for s in splits]\n    if any(matches):\n        remote = splits[matches.index(True) - 1]\n    else:\n        remote = \"ultralytics\"\n        check_output(f\"git remote add {remote} {url}\", shell=True)\n    check_output(f\"git fetch {remote}\", shell=True, timeout=5)  # git fetch\n    local_branch = check_output(\"git rev-parse --abbrev-ref HEAD\", shell=True).decode().strip()  # checked out\n    n = int(check_output(f\"git rev-list {local_branch}..{remote}/{branch} --count\", shell=True))  # commits behind\n    if n > 0:\n        pull = \"git pull\" if remote == \"origin\" else f\"git pull {remote} {branch}\"\n        s += f\"\u26a0\ufe0f YOLOv5 is out of date by {n} commit{'s' * (n > 1)}. Use '{pull}' or 'git clone {url}' to update.\"\n    else:\n        s += f\"up to date with {url} \u2705\"\n    LOGGER.info(s)\n\n\n@WorkingDirectory(ROOT)\ndef check_git_info(path=\".\"):\n    \"\"\"Checks YOLOv5 git info, returning a dict with remote URL, branch name, and commit hash.\"\"\"\n    check_requirements(\"gitpython\")\n    import git\n\n    try:\n        repo = git.Repo(path)\n        remote = repo.remotes.origin.url.replace(\".git\", \"\")  # i.e. 'https://github.com/ultralytics/yolov5'\n        commit = repo.head.commit.hexsha  # i.e. '3134699c73af83aac2a481435550b968d5792c0d'\n        try:\n            branch = repo.active_branch.name  # i.e. 'main'\n        except TypeError:  # not on any branch\n            branch = None  # i.e. 'detached HEAD' state\n        return {\"remote\": remote, \"branch\": branch, \"commit\": commit}\n    except git.exc.InvalidGitRepositoryError:  # path is not a git dir\n        return {\"remote\": None, \"branch\": None, \"commit\": None}\n\n\ndef check_python(minimum=\"3.8.0\"):\n    \"\"\"Checks if current Python version meets the minimum required version, exits if not.\"\"\"\n    check_version(platform.python_version(), minimum, name=\"Python \", hard=True)\n\n\ndef check_version(current=\"0.0.0\", minimum=\"0.0.0\", name=\"version \", pinned=False, hard=False, verbose=False):\n    \"\"\"Checks if the current version meets the minimum required version, exits or warns based on parameters.\"\"\"\n    current, minimum = (pkg.parse_version(x) for x in (current, minimum))\n    result = (current == minimum) if pinned else (current >= minimum)  # bool\n    s = f\"WARNING \u26a0\ufe0f {name}{minimum} is required by YOLOv5, but {name}{current} is currently installed\"  # string\n    if hard:\n        assert result, emojis(s)  # assert min requirements met\n    if verbose and not result:\n        LOGGER.warning(s)\n    return result\n\n\ndef check_img_size(imgsz, s=32, floor=0):\n    \"\"\"Adjusts image size to be divisible by stride `s`, supports int or list/tuple input, returns adjusted size.\"\"\"\n    if isinstance(imgsz, int):  # integer i.e. img_size=640\n        new_size = max(make_divisible(imgsz, int(s)), floor)\n    else:  # list i.e. img_size=[640, 480]\n        imgsz = list(imgsz)  # convert to list if tuple\n        new_size = [max(make_divisible(x, int(s)), floor) for x in imgsz]\n    if new_size != imgsz:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f --img-size {imgsz} must be multiple of max stride {s}, updating to {new_size}\")\n    return new_size\n\n\ndef check_imshow(warn=False):\n    \"\"\"Checks environment support for image display; warns on failure if `warn=True`.\"\"\"\n    try:\n        assert not is_jupyter()\n        assert not is_docker()\n        cv2.imshow(\"test\", np.zeros((1, 1, 3)))\n        cv2.waitKey(1)\n        cv2.destroyAllWindows()\n        cv2.waitKey(1)\n        return True\n    except Exception as e:\n        if warn:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Environment does not support cv2.imshow() or PIL Image.show()\\n{e}\")\n        return False\n\n\ndef check_suffix(file=\"yolov5s.pt\", suffix=(\".pt\",), msg=\"\"):\n    \"\"\"Validates if a file or files have an acceptable suffix, raising an error if not.\"\"\"\n    if file and suffix:\n        if isinstance(suffix, str):\n            suffix = [suffix]\n        for f in file if isinstance(file, (list, tuple)) else [file]:\n            s = Path(f).suffix.lower()  # file suffix\n            if len(s):\n                assert s in suffix, f\"{msg}{f} acceptable suffix is {suffix}\"\n\n\ndef check_yaml(file, suffix=(\".yaml\", \".yml\")):\n    \"\"\"Searches/downloads a YAML file, verifies its suffix (.yaml or .yml), and returns the file path.\"\"\"\n    return check_file(file, suffix)\n\n\ndef check_file(file, suffix=\"\"):\n    \"\"\"Searches/downloads a file, checks its suffix (if provided), and returns the file path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file)  # convert to str()\n    if os.path.isfile(file) or not file:  # exists\n        return file\n    elif file.startswith((\"http:/\", \"https:/\")):  # download\n        url = file  # warning: Pathlib turns :// -> :/\n        file = Path(urllib.parse.unquote(file).split(\"?\")[0]).name  # '%2F' to '/', split https://url.com/file.txt?auth\n        if os.path.isfile(file):\n            LOGGER.info(f\"Found {url} locally at {file}\")  # file already exists\n        else:\n            LOGGER.info(f\"Downloading {url} to {file}...\")\n            torch.hub.download_url_to_file(url, file)\n            assert Path(file).exists() and Path(file).stat().st_size > 0, f\"File download failed: {url}\"  # check\n        return file\n    elif file.startswith(\"clearml://\"):  # ClearML Dataset ID\n        assert (\n            \"clearml\" in sys.modules\n        ), \"ClearML is not installed, so cannot use ClearML dataset. Try running 'pip install clearml'.\"\n        return file\n    else:  # search\n        files = []\n        for d in \"data\", \"models\", \"utils\":  # search directories\n            files.extend(glob.glob(str(ROOT / d / \"**\" / file), recursive=True))  # find file\n        assert len(files), f\"File not found: {file}\"  # assert file was found\n        assert len(files) == 1, f\"Multiple files match '{file}', specify exact path: {files}\"  # assert unique\n        return files[0]  # return file\n\n\ndef check_font(font=FONT, progress=False):\n    \"\"\"Ensures specified font exists or downloads it from Ultralytics assets, optionally displaying progress.\"\"\"\n    font = Path(font)\n    file = CONFIG_DIR / font.name\n    if not font.exists() and not file.exists():\n        url = f\"https://ultralytics.com/assets/{font.name}\"\n        LOGGER.info(f\"Downloading {url} to {file}...\")\n        torch.hub.download_url_to_file(url, str(file), progress=progress)\n\n\ndef check_dataset(data, autodownload=True):\n    \"\"\"Validates and/or auto-downloads a dataset, returning its configuration as a dictionary.\"\"\"\n\n    # Download (optional)\n    extract_dir = \"\"\n    if isinstance(data, (str, Path)) and (is_zipfile(data) or is_tarfile(data)):\n        download(data, dir=f\"{DATASETS_DIR}/{Path(data).stem}\", unzip=True, delete=False, curl=False, threads=1)\n        data = next((DATASETS_DIR / Path(data).stem).rglob(\"*.yaml\"))\n        extract_dir, autodownload = data.parent, False\n\n    # Read yaml (optional)\n    if isinstance(data, (str, Path)):\n        data = yaml_load(data)  # dictionary\n\n    # Checks\n    for k in \"train\", \"val\", \"names\":\n        assert k in data, emojis(f\"data.yaml '{k}:' field missing \u274c\")\n    if isinstance(data[\"names\"], (list, tuple)):  # old array format\n        data[\"names\"] = dict(enumerate(data[\"names\"]))  # convert to dict\n    assert all(isinstance(k, int) for k in data[\"names\"].keys()), \"data.yaml names keys must be integers, i.e. 2: car\"\n    data[\"nc\"] = len(data[\"names\"])\n\n    # Resolve paths\n    path = Path(extract_dir or data.get(\"path\") or \"\")  # optional 'path' default to '.'\n    if not path.is_absolute():\n        path = (ROOT / path).resolve()\n        data[\"path\"] = path  # download scripts\n    for k in \"train\", \"val\", \"test\":\n        if data.get(k):  # prepend path\n            if isinstance(data[k], str):\n                x = (path / data[k]).resolve()\n                if not x.exists() and data[k].startswith(\"../\"):\n                    x = (path / data[k][3:]).resolve()\n                data[k] = str(x)\n            else:\n                data[k] = [str((path / x).resolve()) for x in data[k]]\n\n    # Parse yaml\n    train, val, test, s = (data.get(x) for x in (\"train\", \"val\", \"test\", \"download\"))\n    if val:\n        val = [Path(x).resolve() for x in (val if isinstance(val, list) else [val])]  # val path\n        if not all(x.exists() for x in val):\n            LOGGER.info(\"\\nDataset not found \u26a0\ufe0f, missing paths %s\" % [str(x) for x in val if not x.exists()])\n            if not s or not autodownload:\n                raise Exception(\"Dataset not found \u274c\")\n            t = time.time()\n            if s.startswith(\"http\") and s.endswith(\".zip\"):  # URL\n                f = Path(s).name  # filename\n                LOGGER.info(f\"Downloading {s} to {f}...\")\n                torch.hub.download_url_to_file(s, f)\n                Path(DATASETS_DIR).mkdir(parents=True, exist_ok=True)  # create root\n                unzip_file(f, path=DATASETS_DIR)  # unzip\n                Path(f).unlink()  # remove zip\n                r = None  # success\n            elif s.startswith(\"bash \"):  # bash script\n                LOGGER.info(f\"Running {s} ...\")\n                r = subprocess.run(s, shell=True)\n            else:  # python script\n                r = exec(s, {\"yaml\": data})  # return None\n            dt = f\"({round(time.time() - t, 1)}s)\"\n            s = f\"success \u2705 {dt}, saved to {colorstr('bold', DATASETS_DIR)}\" if r in (0, None) else f\"failure {dt} \u274c\"\n            LOGGER.info(f\"Dataset download {s}\")\n    check_font(\"Arial.ttf\" if is_ascii(data[\"names\"]) else \"Arial.Unicode.ttf\", progress=True)  # download fonts\n    return data  # dictionary\n\n\ndef check_amp(model):\n    \"\"\"Checks PyTorch AMP functionality for a model, returns True if AMP operates correctly, otherwise False.\"\"\"\n    from models.common import AutoShape, DetectMultiBackend\n\n    def amp_allclose(model, im):\n        # All close FP32 vs AMP results\n        m = AutoShape(model, verbose=False)  # model\n        a = m(im).xywhn[0]  # FP32 inference\n        m.amp = True\n        b = m(im).xywhn[0]  # AMP inference\n        return a.shape == b.shape and torch.allclose(a, b, atol=0.1)  # close to 10% absolute tolerance\n\n    prefix = colorstr(\"AMP: \")\n    device = next(model.parameters()).device  # get model device\n    if device.type in (\"cpu\", \"mps\"):\n        return False  # AMP only used on CUDA devices\n    f = ROOT / \"data\" / \"images\" / \"bus.jpg\"  # image to check\n    im = f if f.exists() else \"https://ultralytics.com/images/bus.jpg\" if check_online() else np.ones((640, 640, 3))\n    try:\n        assert amp_allclose(deepcopy(model), im) or amp_allclose(DetectMultiBackend(\"yolov5n.pt\", device), im)\n        LOGGER.info(f\"{prefix}checks passed \u2705\")\n        return True\n    except Exception:\n        help_url = \"https://github.com/ultralytics/yolov5/issues/7908\"\n        LOGGER.warning(f\"{prefix}checks failed \u274c, disabling Automatic Mixed Precision. See {help_url}\")\n        return False\n\n\ndef yaml_load(file=\"data.yaml\"):\n    \"\"\"Safely loads and returns the contents of a YAML file specified by `file` argument.\"\"\"\n    with open(file, errors=\"ignore\") as f:\n        return yaml.safe_load(f)\n\n\ndef yaml_save(file=\"data.yaml\", data=None):\n    \"\"\"Safely saves `data` to a YAML file specified by `file`, converting `Path` objects to strings; `data` is a\n    dictionary.\n    \"\"\"\n    if data is None:\n        data = {}\n    with open(file, \"w\") as f:\n        yaml.safe_dump({k: str(v) if isinstance(v, Path) else v for k, v in data.items()}, f, sort_keys=False)\n\n\ndef unzip_file(file, path=None, exclude=(\".DS_Store\", \"__MACOSX\")):\n    \"\"\"Unzips `file` to `path` (default: file's parent), excluding filenames containing any in `exclude` (`.DS_Store`,\n    `__MACOSX`).\n    \"\"\"\n    if path is None:\n        path = Path(file).parent  # default path\n    with ZipFile(file) as zipObj:\n        for f in zipObj.namelist():  # list all archived filenames in the zip\n            if all(x not in f for x in exclude):\n                zipObj.extract(f, path=path)\n\n\ndef url2file(url):\n    \"\"\"\n    Converts a URL string to a valid filename by stripping protocol, domain, and any query parameters.\n\n    Example https://url.com/file.txt?auth -> file.txt\n    \"\"\"\n    url = str(Path(url)).replace(\":/\", \"://\")  # Pathlib turns :// -> :/\n    return Path(urllib.parse.unquote(url)).name.split(\"?\")[0]  # '%2F' to '/', split https://url.com/file.txt?auth\n\n\ndef download(url, dir=\".\", unzip=True, delete=True, curl=False, threads=1, retry=3):\n    \"\"\"Downloads and optionally unzips files concurrently, supporting retries and curl fallback.\"\"\"\n\n    def download_one(url, dir):\n        # Download 1 file\n        success = True\n        if os.path.isfile(url):\n            f = Path(url)  # filename\n        else:  # does not exist\n            f = dir / Path(url).name\n            LOGGER.info(f\"Downloading {url} to {f}...\")\n            for i in range(retry + 1):\n                if curl:\n                    success = curl_download(url, f, silent=(threads > 1))\n                else:\n                    torch.hub.download_url_to_file(url, f, progress=threads == 1)  # torch download\n                    success = f.is_file()\n                if success:\n                    break\n                elif i < retry:\n                    LOGGER.warning(f\"\u26a0\ufe0f Download failure, retrying {i + 1}/{retry} {url}...\")\n                else:\n                    LOGGER.warning(f\"\u274c Failed to download {url}...\")\n\n        if unzip and success and (f.suffix == \".gz\" or is_zipfile(f) or is_tarfile(f)):\n            LOGGER.info(f\"Unzipping {f}...\")\n            if is_zipfile(f):\n                unzip_file(f, dir)  # unzip\n            elif is_tarfile(f):\n                subprocess.run([\"tar\", \"xf\", f, \"--directory\", f.parent], check=True)  # unzip\n            elif f.suffix == \".gz\":\n                subprocess.run([\"tar\", \"xfz\", f, \"--directory\", f.parent], check=True)  # unzip\n            if delete:\n                f.unlink()  # remove zip\n\n    dir = Path(dir)\n    dir.mkdir(parents=True, exist_ok=True)  # make directory\n    if threads > 1:\n        pool = ThreadPool(threads)\n        pool.imap(lambda x: download_one(*x), zip(url, repeat(dir)))  # multithreaded\n        pool.close()\n        pool.join()\n    else:\n        for u in [url] if isinstance(url, (str, Path)) else url:\n            download_one(u, dir)\n\n\ndef make_divisible(x, divisor):\n    \"\"\"Adjusts `x` to be divisible by `divisor`, returning the nearest greater or equal value.\"\"\"\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor\n\n\ndef clean_str(s):\n    \"\"\"Cleans a string by replacing special characters with underscore, e.g., `clean_str('#example!')` returns\n    '_example_'.\n    \"\"\"\n    return re.sub(pattern=\"[|@#!\u00a1\u00b7$\u20ac%&()=?\u00bf^*;:,\u00a8\u00b4><+]\", repl=\"_\", string=s)\n\n\ndef one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"\n    Generates a lambda for a sinusoidal ramp from y1 to y2 over 'steps'.\n\n    See https://arxiv.org/pdf/1812.01187.pdf for details.\n    \"\"\"\n    return lambda x: ((1 - math.cos(x * math.pi / steps)) / 2) * (y2 - y1) + y1\n\n\ndef colorstr(*input):\n    \"\"\"\n    Colors a string using ANSI escape codes, e.g., colorstr('blue', 'hello world').\n\n    See https://en.wikipedia.org/wiki/ANSI_escape_code.\n    \"\"\"\n    *args, string = input if len(input) > 1 else (\"blue\", \"bold\", input[0])  # color arguments, string\n    colors = {\n        \"black\": \"\\033[30m\",  # basic colors\n        \"red\": \"\\033[31m\",\n        \"green\": \"\\033[32m\",\n        \"yellow\": \"\\033[33m\",\n        \"blue\": \"\\033[34m\",\n        \"magenta\": \"\\033[35m\",\n        \"cyan\": \"\\033[36m\",\n        \"white\": \"\\033[37m\",\n        \"bright_black\": \"\\033[90m\",  # bright colors\n        \"bright_red\": \"\\033[91m\",\n        \"bright_green\": \"\\033[92m\",\n        \"bright_yellow\": \"\\033[93m\",\n        \"bright_blue\": \"\\033[94m\",\n        \"bright_magenta\": \"\\033[95m\",\n        \"bright_cyan\": \"\\033[96m\",\n        \"bright_white\": \"\\033[97m\",\n        \"end\": \"\\033[0m\",  # misc\n        \"bold\": \"\\033[1m\",\n        \"underline\": \"\\033[4m\",\n    }\n    return \"\".join(colors[x] for x in args) + f\"{string}\" + colors[\"end\"]\n\n\ndef labels_to_class_weights(labels, nc=80):\n    \"\"\"Calculates class weights from labels to handle class imbalance in training; input shape: (n, 5).\"\"\"\n    if labels[0] is None:  # no labels loaded\n        return torch.Tensor()\n\n    labels = np.concatenate(labels, 0)  # labels.shape = (866643, 5) for COCO\n    classes = labels[:, 0].astype(int)  # labels = [class xywh]\n    weights = np.bincount(classes, minlength=nc)  # occurrences per class\n\n    # Prepend gridpoint count (for uCE training)\n    # gpi = ((320 / 32 * np.array([1, 2, 4])) ** 2 * 3).sum()  # gridpoints per image\n    # weights = np.hstack([gpi * len(labels)  - weights.sum() * 9, weights * 9]) ** 0.5  # prepend gridpoints to start\n\n    weights[weights == 0] = 1  # replace empty bins with 1\n    weights = 1 / weights  # number of targets per class\n    weights /= weights.sum()  # normalize\n    return torch.from_numpy(weights).float()\n\n\ndef labels_to_image_weights(labels, nc=80, class_weights=np.ones(80)):\n    \"\"\"Calculates image weights from labels using class weights for weighted sampling.\"\"\"\n    # Usage: index = random.choices(range(n), weights=image_weights, k=1)  # weighted image sample\n    class_counts = np.array([np.bincount(x[:, 0].astype(int), minlength=nc) for x in labels])\n    return (class_weights.reshape(1, nc) * class_counts).sum(1)\n\n\ndef coco80_to_coco91_class():\n    \"\"\"\n    Converts COCO 80-class index to COCO 91-class index used in the paper.\n\n    Reference: https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/\n    \"\"\"\n    # a = np.loadtxt('data/coco.names', dtype='str', delimiter='\\n')\n    # b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\\n')\n    # x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco\n    # x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet\n    return [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n        21,\n        22,\n        23,\n        24,\n        25,\n        27,\n        28,\n        31,\n        32,\n        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n        46,\n        47,\n        48,\n        49,\n        50,\n        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n        57,\n        58,\n        59,\n        60,\n        61,\n        62,\n        63,\n        64,\n        65,\n        67,\n        70,\n        72,\n        73,\n        74,\n        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n        81,\n        82,\n        84,\n        85,\n        86,\n        87,\n        88,\n        89,\n        90,\n    ]\n\n\ndef xyxy2xywh(x):\n    \"\"\"Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] where xy1=top-left, xy2=bottom-right.\"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = (x[..., 0] + x[..., 2]) / 2  # x center\n    y[..., 1] = (x[..., 1] + x[..., 3]) / 2  # y center\n    y[..., 2] = x[..., 2] - x[..., 0]  # width\n    y[..., 3] = x[..., 3] - x[..., 1]  # height\n    return y\n\n\ndef xywh2xyxy(x):\n    \"\"\"Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.\"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] - x[..., 2] / 2  # top left x\n    y[..., 1] = x[..., 1] - x[..., 3] / 2  # top left y\n    y[..., 2] = x[..., 0] + x[..., 2] / 2  # bottom right x\n    y[..., 3] = x[..., 1] + x[..., 3] / 2  # bottom right y\n    return y\n\n\ndef xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):\n    \"\"\"Convert nx4 boxes from [x, y, w, h] normalized to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.\"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = w * (x[..., 0] - x[..., 2] / 2) + padw  # top left x\n    y[..., 1] = h * (x[..., 1] - x[..., 3] / 2) + padh  # top left y\n    y[..., 2] = w * (x[..., 0] + x[..., 2] / 2) + padw  # bottom right x\n    y[..., 3] = h * (x[..., 1] + x[..., 3] / 2) + padh  # bottom right y\n    return y\n\n\ndef xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0):\n    \"\"\"Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] normalized where xy1=top-left, xy2=bottom-right.\"\"\"\n    if clip:\n        clip_boxes(x, (h - eps, w - eps))  # warning: inplace clip\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = ((x[..., 0] + x[..., 2]) / 2) / w  # x center\n    y[..., 1] = ((x[..., 1] + x[..., 3]) / 2) / h  # y center\n    y[..., 2] = (x[..., 2] - x[..., 0]) / w  # width\n    y[..., 3] = (x[..., 3] - x[..., 1]) / h  # height\n    return y\n\n\ndef xyn2xy(x, w=640, h=640, padw=0, padh=0):\n    \"\"\"Convert normalized segments into pixel segments, shape (n,2).\"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = w * x[..., 0] + padw  # top left x\n    y[..., 1] = h * x[..., 1] + padh  # top left y\n    return y\n\n\ndef segment2box(segment, width=640, height=640):\n    \"\"\"Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).\"\"\"\n    x, y = segment.T  # segment xy\n    inside = (x >= 0) & (y >= 0) & (x <= width) & (y <= height)\n    (\n        x,\n        y,\n    ) = x[inside], y[inside]\n    return np.array([x.min(), y.min(), x.max(), y.max()]) if any(x) else np.zeros((1, 4))  # xyxy\n\n\ndef segments2boxes(segments):\n    \"\"\"Convert segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh).\"\"\"\n    boxes = []\n    for s in segments:\n        x, y = s.T  # segment xy\n        boxes.append([x.min(), y.min(), x.max(), y.max()])  # cls, xyxy\n    return xyxy2xywh(np.array(boxes))  # cls, xywh\n\n\ndef resample_segments(segments, n=1000):\n    \"\"\"Resamples an (n,2) segment to a fixed number of points for consistent representation.\"\"\"\n    for i, s in enumerate(segments):\n        s = np.concatenate((s, s[0:1, :]), axis=0)\n        x = np.linspace(0, len(s) - 1, n)\n        xp = np.arange(len(s))\n        segments[i] = np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)]).reshape(2, -1).T  # segment xy\n    return segments\n\n\ndef scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None):\n    \"\"\"Rescales (xyxy) bounding boxes from img1_shape to img0_shape, optionally using provided `ratio_pad`.\"\"\"\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    boxes[..., [0, 2]] -= pad[0]  # x padding\n    boxes[..., [1, 3]] -= pad[1]  # y padding\n    boxes[..., :4] /= gain\n    clip_boxes(boxes, img0_shape)\n    return boxes\n\n\ndef scale_segments(img1_shape, segments, img0_shape, ratio_pad=None, normalize=False):\n    \"\"\"Rescales segment coordinates from img1_shape to img0_shape, optionally normalizing them with custom padding.\"\"\"\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    segments[:, 0] -= pad[0]  # x padding\n    segments[:, 1] -= pad[1]  # y padding\n    segments /= gain\n    clip_segments(segments, img0_shape)\n    if normalize:\n        segments[:, 0] /= img0_shape[1]  # width\n        segments[:, 1] /= img0_shape[0]  # height\n    return segments\n\n\ndef clip_boxes(boxes, shape):\n    \"\"\"Clips bounding box coordinates (xyxy) to fit within the specified image shape (height, width).\"\"\"\n    if isinstance(boxes, torch.Tensor):  # faster individually\n        boxes[..., 0].clamp_(0, shape[1])  # x1\n        boxes[..., 1].clamp_(0, shape[0])  # y1\n        boxes[..., 2].clamp_(0, shape[1])  # x2\n        boxes[..., 3].clamp_(0, shape[0])  # y2\n    else:  # np.array (faster grouped)\n        boxes[..., [0, 2]] = boxes[..., [0, 2]].clip(0, shape[1])  # x1, x2\n        boxes[..., [1, 3]] = boxes[..., [1, 3]].clip(0, shape[0])  # y1, y2\n\n\ndef clip_segments(segments, shape):\n    \"\"\"Clips segment coordinates (xy1, xy2, ...) to an image's boundaries given its shape (height, width).\"\"\"\n    if isinstance(segments, torch.Tensor):  # faster individually\n        segments[:, 0].clamp_(0, shape[1])  # x\n        segments[:, 1].clamp_(0, shape[0])  # y\n    else:  # np.array (faster grouped)\n        segments[:, 0] = segments[:, 0].clip(0, shape[1])  # x\n        segments[:, 1] = segments[:, 1].clip(0, shape[0])  # y\n\n\ndef non_max_suppression(\n    prediction,\n    conf_thres=0.25,\n    iou_thres=0.45,\n    classes=None,\n    agnostic=False,\n    multi_label=False,\n    labels=(),\n    max_det=300,\n    nm=0,  # number of masks\n):\n    \"\"\"\n    Non-Maximum Suppression (NMS) on inference results to reject overlapping detections.\n\n    Returns:\n         list of detections, on (n,6) tensor per image [xyxy, conf, cls]\n    \"\"\"\n\n    # Checks\n    assert 0 <= conf_thres <= 1, f\"Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0\"\n    assert 0 <= iou_thres <= 1, f\"Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0\"\n    if isinstance(prediction, (list, tuple)):  # YOLOv5 model in validation model, output = (inference_out, loss_out)\n        prediction = prediction[0]  # select only inference output\n\n    device = prediction.device\n    mps = \"mps\" in device.type  # Apple MPS\n    if mps:  # MPS not fully supported yet, convert tensors to CPU before NMS\n        prediction = prediction.cpu()\n    bs = prediction.shape[0]  # batch size\n    nc = prediction.shape[2] - nm - 5  # number of classes\n    xc = prediction[..., 4] > conf_thres  # candidates\n\n    # Settings\n    # min_wh = 2  # (pixels) minimum box width and height\n    max_wh = 7680  # (pixels) maximum box width and height\n    max_nms = 30000  # maximum number of boxes into torchvision.ops.nms()\n    time_limit = 0.5 + 0.05 * bs  # seconds to quit after\n    redundant = True  # require redundant detections\n    multi_label &= nc > 1  # multiple labels per box (adds 0.5ms/img)\n    merge = False  # use merge-NMS\n\n    t = time.time()\n    mi = 5 + nc  # mask start index\n    output = [torch.zeros((0, 6 + nm), device=prediction.device)] * bs\n    for xi, x in enumerate(prediction):  # image index, image inference\n        # Apply constraints\n        # x[((x[..., 2:4] < min_wh) | (x[..., 2:4] > max_wh)).any(1), 4] = 0  # width-height\n        x = x[xc[xi]]  # confidence\n\n        # Cat apriori labels if autolabelling\n        if labels and len(labels[xi]):\n            lb = labels[xi]\n            v = torch.zeros((len(lb), nc + nm + 5), device=x.device)\n            v[:, :4] = lb[:, 1:5]  # box\n            v[:, 4] = 1.0  # conf\n            v[range(len(lb)), lb[:, 0].long() + 5] = 1.0  # cls\n            x = torch.cat((x, v), 0)\n\n        # If none remain process next image\n        if not x.shape[0]:\n            continue\n\n        # Compute conf\n        x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf\n\n        # Box/Mask\n        box = xywh2xyxy(x[:, :4])  # center_x, center_y, width, height) to (x1, y1, x2, y2)\n        mask = x[:, mi:]  # zero columns if no masks\n\n        # Detections matrix nx6 (xyxy, conf, cls)\n        if multi_label:\n            i, j = (x[:, 5:mi] > conf_thres).nonzero(as_tuple=False).T\n            x = torch.cat((box[i], x[i, 5 + j, None], j[:, None].float(), mask[i]), 1)\n        else:  # best class only\n            conf, j = x[:, 5:mi].max(1, keepdim=True)\n            x = torch.cat((box, conf, j.float(), mask), 1)[conf.view(-1) > conf_thres]\n\n        # Filter by class\n        if classes is not None:\n            x = x[(x[:, 5:6] == torch.tensor(classes, device=x.device)).any(1)]\n\n        # Apply finite constraint\n        # if not torch.isfinite(x).all():\n        #     x = x[torch.isfinite(x).all(1)]\n\n        # Check shape\n        n = x.shape[0]  # number of boxes\n        if not n:  # no boxes\n            continue\n        x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence and remove excess boxes\n\n        # Batched NMS\n        c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes\n        boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores\n        i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS\n        i = i[:max_det]  # limit detections\n        if merge and (1 < n < 3e3):  # Merge NMS (boxes merged using weighted mean)\n            # update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)\n            iou = box_iou(boxes[i], boxes) > iou_thres  # iou matrix\n            weights = iou * scores[None]  # box weights\n            x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(1, keepdim=True)  # merged boxes\n            if redundant:\n                i = i[iou.sum(1) > 1]  # require redundancy\n\n        output[xi] = x[i]\n        if mps:\n            output[xi] = output[xi].to(device)\n        if (time.time() - t) > time_limit:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f NMS time limit {time_limit:.3f}s exceeded\")\n            break  # time limit exceeded\n\n    return output\n\n\ndef strip_optimizer(f=\"best.pt\", s=\"\"):\n    \"\"\"\n    Strips optimizer and optionally saves checkpoint to finalize training; arguments are file path 'f' and save path\n    's'.\n\n    Example: from utils.general import *; strip_optimizer()\n    \"\"\"\n    x = torch.load(f, map_location=torch.device(\"cpu\"))\n    if x.get(\"ema\"):\n        x[\"model\"] = x[\"ema\"]  # replace model with ema\n    for k in \"optimizer\", \"best_fitness\", \"ema\", \"updates\":  # keys\n        x[k] = None\n    x[\"epoch\"] = -1\n    x[\"model\"].half()  # to FP16\n    for p in x[\"model\"].parameters():\n        p.requires_grad = False\n    torch.save(x, s or f)\n    mb = os.path.getsize(s or f) / 1e6  # filesize\n    LOGGER.info(f\"Optimizer stripped from {f},{f' saved as {s},' if s else ''} {mb:.1f}MB\")\n\n\ndef print_mutation(keys, results, hyp, save_dir, bucket, prefix=colorstr(\"evolve: \")):\n    \"\"\"Logs evolution results and saves to CSV and YAML in `save_dir`, optionally syncs with `bucket`.\"\"\"\n    evolve_csv = save_dir / \"evolve.csv\"\n    evolve_yaml = save_dir / \"hyp_evolve.yaml\"\n    keys = tuple(keys) + tuple(hyp.keys())  # [results + hyps]\n    keys = tuple(x.strip() for x in keys)\n    vals = results + tuple(hyp.values())\n    n = len(keys)\n\n    # Download (optional)\n    if bucket:\n        url = f\"gs://{bucket}/evolve.csv\"\n        if gsutil_getsize(url) > (evolve_csv.stat().st_size if evolve_csv.exists() else 0):\n            subprocess.run([\"gsutil\", \"cp\", f\"{url}\", f\"{save_dir}\"])  # download evolve.csv if larger than local\n\n    # Log to evolve.csv\n    s = \"\" if evolve_csv.exists() else ((\"%20s,\" * n % keys).rstrip(\",\") + \"\\n\")  # add header\n    with open(evolve_csv, \"a\") as f:\n        f.write(s + (\"%20.5g,\" * n % vals).rstrip(\",\") + \"\\n\")\n\n    # Save yaml\n    with open(evolve_yaml, \"w\") as f:\n        data = pd.read_csv(evolve_csv, skipinitialspace=True)\n        data = data.rename(columns=lambda x: x.strip())  # strip keys\n        i = np.argmax(fitness(data.values[:, :4]))  #\n        generations = len(data)\n        f.write(\n            \"# YOLOv5 Hyperparameter Evolution Results\\n\"\n            + f\"# Best generation: {i}\\n\"\n            + f\"# Last generation: {generations - 1}\\n\"\n            + \"# \"\n            + \", \".join(f\"{x.strip():>20s}\" for x in keys[:7])\n            + \"\\n\"\n            + \"# \"\n            + \", \".join(f\"{x:>20.5g}\" for x in data.values[i, :7])\n            + \"\\n\\n\"\n        )\n        yaml.safe_dump(data.loc[i][7:].to_dict(), f, sort_keys=False)\n\n    # Print to screen\n    LOGGER.info(\n        prefix\n        + f\"{generations} generations finished, current result:\\n\"\n        + prefix\n        + \", \".join(f\"{x.strip():>20s}\" for x in keys)\n        + \"\\n\"\n        + prefix\n        + \", \".join(f\"{x:20.5g}\" for x in vals)\n        + \"\\n\\n\"\n    )\n\n    if bucket:\n        subprocess.run([\"gsutil\", \"cp\", f\"{evolve_csv}\", f\"{evolve_yaml}\", f\"gs://{bucket}\"])  # upload\n\n\ndef apply_classifier(x, model, img, im0):\n    \"\"\"Applies second-stage classifier to YOLO outputs, filtering detections by class match.\"\"\"\n    # Example model = torchvision.models.__dict__['efficientnet_b0'](pretrained=True).to(device).eval()\n    im0 = [im0] if isinstance(im0, np.ndarray) else im0\n    for i, d in enumerate(x):  # per image\n        if d is not None and len(d):\n            d = d.clone()\n\n            # Reshape and pad cutouts\n            b = xyxy2xywh(d[:, :4])  # boxes\n            b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # rectangle to square\n            b[:, 2:] = b[:, 2:] * 1.3 + 30  # pad\n            d[:, :4] = xywh2xyxy(b).long()\n\n            # Rescale boxes from img_size to im0 size\n            scale_boxes(img.shape[2:], d[:, :4], im0[i].shape)\n\n            # Classes\n            pred_cls1 = d[:, 5].long()\n            ims = []\n            for a in d:\n                cutout = im0[i][int(a[1]) : int(a[3]), int(a[0]) : int(a[2])]\n                im = cv2.resize(cutout, (224, 224))  # BGR\n\n                im = im[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416\n                im = np.ascontiguousarray(im, dtype=np.float32)  # uint8 to float32\n                im /= 255  # 0 - 255 to 0.0 - 1.0\n                ims.append(im)\n\n            pred_cls2 = model(torch.Tensor(ims).to(d.device)).argmax(1)  # classifier prediction\n            x[i] = x[i][pred_cls1 == pred_cls2]  # retain matching class detections\n\n    return x\n\n\ndef increment_path(path, exist_ok=False, sep=\"\", mkdir=False):\n    \"\"\"\n    Generates an incremented file or directory path if it exists, with optional mkdir; args: path, exist_ok=False,\n    sep=\"\", mkdir=False.\n\n    Example: runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc\n    \"\"\"\n    path = Path(path)  # os-agnostic\n    if path.exists() and not exist_ok:\n        path, suffix = (path.with_suffix(\"\"), path.suffix) if path.is_file() else (path, \"\")\n\n        # Method 1\n        for n in range(2, 9999):\n            p = f\"{path}{sep}{n}{suffix}\"  # increment path\n            if not os.path.exists(p):  #\n                break\n        path = Path(p)\n\n        # Method 2 (deprecated)\n        # dirs = glob.glob(f\"{path}{sep}*\")  # similar paths\n        # matches = [re.search(rf\"{path.stem}{sep}(\\d+)\", d) for d in dirs]\n        # i = [int(m.groups()[0]) for m in matches if m]  # indices\n        # n = max(i) + 1 if i else 2  # increment number\n        # path = Path(f\"{path}{sep}{n}{suffix}\")  # increment path\n\n    if mkdir:\n        path.mkdir(parents=True, exist_ok=True)  # make directory\n\n    return path\n\n\n# OpenCV Multilanguage-friendly functions ------------------------------------------------------------------------------------\nimshow_ = cv2.imshow  # copy to avoid recursion errors\n\n\ndef imread(filename, flags=cv2.IMREAD_COLOR):\n    \"\"\"Reads an image from a file and returns it as a numpy array, using OpenCV's imdecode to support multilanguage\n    paths.\n    \"\"\"\n    return cv2.imdecode(np.fromfile(filename, np.uint8), flags)\n\n\ndef imwrite(filename, img):\n    \"\"\"Writes an image to a file, returns True on success and False on failure, supports multilanguage paths.\"\"\"\n    try:\n        cv2.imencode(Path(filename).suffix, img)[1].tofile(filename)\n        return True\n    except Exception:\n        return False\n\n\ndef imshow(path, im):\n    \"\"\"Displays an image using Unicode path, requires encoded path and image matrix as input.\"\"\"\n    imshow_(path.encode(\"unicode_escape\").decode(), im)\n\n\nif Path(inspect.stack()[0].filename).parent.parent.as_posix() in inspect.stack()[-1].filename:\n    cv2.imread, cv2.imwrite, cv2.imshow = imread, imwrite, imshow  # redefine\n\n# Variables ------------------------------------------------------------------------------------------------------------\n", "utils/downloads.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Download utils.\"\"\"\n\nimport logging\nimport subprocess\nimport urllib\nfrom pathlib import Path\n\nimport requests\nimport torch\n\n\ndef is_url(url, check=True):\n    \"\"\"Determines if a string is a URL and optionally checks its existence online, returning a boolean.\"\"\"\n    try:\n        url = str(url)\n        result = urllib.parse.urlparse(url)\n        assert all([result.scheme, result.netloc])  # check if is url\n        return (urllib.request.urlopen(url).getcode() == 200) if check else True  # check if exists online\n    except (AssertionError, urllib.request.HTTPError):\n        return False\n\n\ndef gsutil_getsize(url=\"\"):\n    \"\"\"\n    Returns the size in bytes of a file at a Google Cloud Storage URL using `gsutil du`.\n\n    Returns 0 if the command fails or output is empty.\n    \"\"\"\n    output = subprocess.check_output([\"gsutil\", \"du\", url], shell=True, encoding=\"utf-8\")\n    return int(output.split()[0]) if output else 0\n\n\ndef url_getsize(url=\"https://ultralytics.com/images/bus.jpg\"):\n    \"\"\"Returns the size in bytes of a downloadable file at a given URL; defaults to -1 if not found.\"\"\"\n    response = requests.head(url, allow_redirects=True)\n    return int(response.headers.get(\"content-length\", -1))\n\n\ndef curl_download(url, filename, *, silent: bool = False) -> bool:\n    \"\"\"Download a file from a url to a filename using curl.\"\"\"\n    silent_option = \"sS\" if silent else \"\"  # silent\n    proc = subprocess.run(\n        [\n            \"curl\",\n            \"-#\",\n            f\"-{silent_option}L\",\n            url,\n            \"--output\",\n            filename,\n            \"--retry\",\n            \"9\",\n            \"-C\",\n            \"-\",\n        ]\n    )\n    return proc.returncode == 0\n\n\ndef safe_download(file, url, url2=None, min_bytes=1e0, error_msg=\"\"):\n    \"\"\"\n    Downloads a file from a URL (or alternate URL) to a specified path if file is above a minimum size.\n\n    Removes incomplete downloads.\n    \"\"\"\n    from utils.general import LOGGER\n\n    file = Path(file)\n    assert_msg = f\"Downloaded file '{file}' does not exist or size is < min_bytes={min_bytes}\"\n    try:  # url1\n        LOGGER.info(f\"Downloading {url} to {file}...\")\n        torch.hub.download_url_to_file(url, str(file), progress=LOGGER.level <= logging.INFO)\n        assert file.exists() and file.stat().st_size > min_bytes, assert_msg  # check\n    except Exception as e:  # url2\n        if file.exists():\n            file.unlink()  # remove partial downloads\n        LOGGER.info(f\"ERROR: {e}\\nRe-attempting {url2 or url} to {file}...\")\n        # curl download, retry and resume on fail\n        curl_download(url2 or url, file)\n    finally:\n        if not file.exists() or file.stat().st_size < min_bytes:  # check\n            if file.exists():\n                file.unlink()  # remove partial downloads\n            LOGGER.info(f\"ERROR: {assert_msg}\\n{error_msg}\")\n        LOGGER.info(\"\")\n\n\ndef attempt_download(file, repo=\"ultralytics/yolov5\", release=\"v7.0\"):\n    \"\"\"Downloads a file from GitHub release assets or via direct URL if not found locally, supporting backup\n    versions.\n    \"\"\"\n    from utils.general import LOGGER\n\n    def github_assets(repository, version=\"latest\"):\n        # Return GitHub repo tag (i.e. 'v7.0') and assets (i.e. ['yolov5s.pt', 'yolov5m.pt', ...])\n        if version != \"latest\":\n            version = f\"tags/{version}\"  # i.e. tags/v7.0\n        response = requests.get(f\"https://api.github.com/repos/{repository}/releases/{version}\").json()  # github api\n        return response[\"tag_name\"], [x[\"name\"] for x in response[\"assets\"]]  # tag, assets\n\n    file = Path(str(file).strip().replace(\"'\", \"\"))\n    if not file.exists():\n        # URL specified\n        name = Path(urllib.parse.unquote(str(file))).name  # decode '%2F' to '/' etc.\n        if str(file).startswith((\"http:/\", \"https:/\")):  # download\n            url = str(file).replace(\":/\", \"://\")  # Pathlib turns :// -> :/\n            file = name.split(\"?\")[0]  # parse authentication https://url.com/file.txt?auth...\n            if Path(file).is_file():\n                LOGGER.info(f\"Found {url} locally at {file}\")  # file already exists\n            else:\n                safe_download(file=file, url=url, min_bytes=1e5)\n            return file\n\n        # GitHub assets\n        assets = [f\"yolov5{size}{suffix}.pt\" for size in \"nsmlx\" for suffix in (\"\", \"6\", \"-cls\", \"-seg\")]  # default\n        try:\n            tag, assets = github_assets(repo, release)\n        except Exception:\n            try:\n                tag, assets = github_assets(repo)  # latest release\n            except Exception:\n                try:\n                    tag = subprocess.check_output(\"git tag\", shell=True, stderr=subprocess.STDOUT).decode().split()[-1]\n                except Exception:\n                    tag = release\n\n        if name in assets:\n            file.parent.mkdir(parents=True, exist_ok=True)  # make parent dir (if required)\n            safe_download(\n                file,\n                url=f\"https://github.com/{repo}/releases/download/{tag}/{name}\",\n                min_bytes=1e5,\n                error_msg=f\"{file} missing, try downloading from https://github.com/{repo}/releases/{tag}\",\n            )\n\n    return str(file)\n", "utils/__init__.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"utils/initialization.\"\"\"\n\nimport contextlib\nimport platform\nimport threading\n\n\ndef emojis(str=\"\"):\n    \"\"\"Returns an emoji-safe version of a string, stripped of emojis on Windows platforms.\"\"\"\n    return str.encode().decode(\"ascii\", \"ignore\") if platform.system() == \"Windows\" else str\n\n\nclass TryExcept(contextlib.ContextDecorator):\n    # YOLOv5 TryExcept class. Usage: @TryExcept() decorator or 'with TryExcept():' context manager\n    def __init__(self, msg=\"\"):\n        \"\"\"Initializes TryExcept with an optional message, used as a decorator or context manager for error handling.\"\"\"\n        self.msg = msg\n\n    def __enter__(self):\n        \"\"\"Enter the runtime context related to this object for error handling with an optional message.\"\"\"\n        pass\n\n    def __exit__(self, exc_type, value, traceback):\n        \"\"\"Context manager exit method that prints an error message with emojis if an exception occurred, always returns\n        True.\n        \"\"\"\n        if value:\n            print(emojis(f\"{self.msg}{': ' if self.msg else ''}{value}\"))\n        return True\n\n\ndef threaded(func):\n    \"\"\"Decorator @threaded to run a function in a separate thread, returning the thread instance.\"\"\"\n\n    def wrapper(*args, **kwargs):\n        thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)\n        thread.start()\n        return thread\n\n    return wrapper\n\n\ndef join_threads(verbose=False):\n    \"\"\"\n    Joins all daemon threads, optionally printing their names if verbose is True.\n\n    Example: atexit.register(lambda: join_threads())\n    \"\"\"\n    main_thread = threading.current_thread()\n    for t in threading.enumerate():\n        if t is not main_thread:\n            if verbose:\n                print(f\"Joining thread {t.name}\")\n            t.join()\n\n\ndef notebook_init(verbose=True):\n    \"\"\"Initializes notebook environment by checking requirements, cleaning up, and displaying system info.\"\"\"\n    print(\"Checking setup...\")\n\n    import os\n    import shutil\n\n    from ultralytics.utils.checks import check_requirements\n\n    from utils.general import check_font, is_colab\n    from utils.torch_utils import select_device  # imports\n\n    check_font()\n\n    import psutil\n\n    if check_requirements(\"wandb\", install=False):\n        os.system(\"pip uninstall -y wandb\")  # eliminate unexpected account creation prompt with infinite hang\n    if is_colab():\n        shutil.rmtree(\"/content/sample_data\", ignore_errors=True)  # remove colab /sample_data directory\n\n    # System info\n    display = None\n    if verbose:\n        gb = 1 << 30  # bytes to GiB (1024 ** 3)\n        ram = psutil.virtual_memory().total\n        total, used, free = shutil.disk_usage(\"/\")\n        with contextlib.suppress(Exception):  # clear display if ipython is installed\n            from IPython import display\n\n            display.clear_output()\n        s = f\"({os.cpu_count()} CPUs, {ram / gb:.1f} GB RAM, {(total - free) / gb:.1f}/{total / gb:.1f} GB disk)\"\n    else:\n        s = \"\"\n\n    select_device(newline=False)\n    print(emojis(f\"Setup complete \u2705 {s}\"))\n    return display\n", "utils/autobatch.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Auto-batch utils.\"\"\"\n\nfrom copy import deepcopy\n\nimport numpy as np\nimport torch\n\nfrom utils.general import LOGGER, colorstr\nfrom utils.torch_utils import profile\n\n\ndef check_train_batch_size(model, imgsz=640, amp=True):\n    \"\"\"Checks and computes optimal training batch size for YOLOv5 model, given image size and AMP setting.\"\"\"\n    with torch.cuda.amp.autocast(amp):\n        return autobatch(deepcopy(model).train(), imgsz)  # compute optimal batch size\n\n\ndef autobatch(model, imgsz=640, fraction=0.8, batch_size=16):\n    \"\"\"Estimates optimal YOLOv5 batch size using `fraction` of CUDA memory.\"\"\"\n    # Usage:\n    #     import torch\n    #     from utils.autobatch import autobatch\n    #     model = torch.hub.load('ultralytics/yolov5', 'yolov5s', autoshape=False)\n    #     print(autobatch(model))\n\n    # Check device\n    prefix = colorstr(\"AutoBatch: \")\n    LOGGER.info(f\"{prefix}Computing optimal batch size for --imgsz {imgsz}\")\n    device = next(model.parameters()).device  # get model device\n    if device.type == \"cpu\":\n        LOGGER.info(f\"{prefix}CUDA not detected, using default CPU batch-size {batch_size}\")\n        return batch_size\n    if torch.backends.cudnn.benchmark:\n        LOGGER.info(f\"{prefix} \u26a0\ufe0f Requires torch.backends.cudnn.benchmark=False, using default batch-size {batch_size}\")\n        return batch_size\n\n    # Inspect CUDA memory\n    gb = 1 << 30  # bytes to GiB (1024 ** 3)\n    d = str(device).upper()  # 'CUDA:0'\n    properties = torch.cuda.get_device_properties(device)  # device properties\n    t = properties.total_memory / gb  # GiB total\n    r = torch.cuda.memory_reserved(device) / gb  # GiB reserved\n    a = torch.cuda.memory_allocated(device) / gb  # GiB allocated\n    f = t - (r + a)  # GiB free\n    LOGGER.info(f\"{prefix}{d} ({properties.name}) {t:.2f}G total, {r:.2f}G reserved, {a:.2f}G allocated, {f:.2f}G free\")\n\n    # Profile batch sizes\n    batch_sizes = [1, 2, 4, 8, 16]\n    try:\n        img = [torch.empty(b, 3, imgsz, imgsz) for b in batch_sizes]\n        results = profile(img, model, n=3, device=device)\n    except Exception as e:\n        LOGGER.warning(f\"{prefix}{e}\")\n\n    # Fit a solution\n    y = [x[2] for x in results if x]  # memory [2]\n    p = np.polyfit(batch_sizes[: len(y)], y, deg=1)  # first degree polynomial fit\n    b = int((f * fraction - p[1]) / p[0])  # y intercept (optimal batch size)\n    if None in results:  # some sizes failed\n        i = results.index(None)  # first fail index\n        if b >= batch_sizes[i]:  # y intercept above failure point\n            b = batch_sizes[max(i - 1, 0)]  # select prior safe point\n    if b < 1 or b > 1024:  # b outside of safe range\n        b = batch_size\n        LOGGER.warning(f\"{prefix}WARNING \u26a0\ufe0f CUDA anomaly detected, recommend restart environment and retry command.\")\n\n    fraction = (np.polyval(p, b) + r + a) / t  # actual fraction predicted\n    LOGGER.info(f\"{prefix}Using batch-size {b} for {d} {t * fraction:.2f}G/{t:.2f}G ({fraction * 100:.0f}%) \u2705\")\n    return b\n", "utils/triton.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Utils to interact with the Triton Inference Server.\"\"\"\n\nimport typing\nfrom urllib.parse import urlparse\n\nimport torch\n\n\nclass TritonRemoteModel:\n    \"\"\"\n    A wrapper over a model served by the Triton Inference Server.\n\n    It can be configured to communicate over GRPC or HTTP. It accepts Torch Tensors as input and returns them as\n    outputs.\n    \"\"\"\n\n    def __init__(self, url: str):\n        \"\"\"\n        Keyword arguments:\n        url: Fully qualified address of the Triton server - for e.g. grpc://localhost:8000\n        \"\"\"\n\n        parsed_url = urlparse(url)\n        if parsed_url.scheme == \"grpc\":\n            from tritonclient.grpc import InferenceServerClient, InferInput\n\n            self.client = InferenceServerClient(parsed_url.netloc)  # Triton GRPC client\n            model_repository = self.client.get_model_repository_index()\n            self.model_name = model_repository.models[0].name\n            self.metadata = self.client.get_model_metadata(self.model_name, as_json=True)\n\n            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i[\"name\"], [int(s) for s in i[\"shape\"]], i[\"datatype\"]) for i in self.metadata[\"inputs\"]\n                ]\n\n        else:\n            from tritonclient.http import InferenceServerClient, InferInput\n\n            self.client = InferenceServerClient(parsed_url.netloc)  # Triton HTTP client\n            model_repository = self.client.get_model_repository_index()\n            self.model_name = model_repository[0][\"name\"]\n            self.metadata = self.client.get_model_metadata(self.model_name)\n\n            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i[\"name\"], [int(s) for s in i[\"shape\"]], i[\"datatype\"]) for i in self.metadata[\"inputs\"]\n                ]\n\n        self._create_input_placeholders_fn = create_input_placeholders\n\n    @property\n    def runtime(self):\n        \"\"\"Returns the model runtime.\"\"\"\n        return self.metadata.get(\"backend\", self.metadata.get(\"platform\"))\n\n    def __call__(self, *args, **kwargs) -> typing.Union[torch.Tensor, typing.Tuple[torch.Tensor, ...]]:\n        \"\"\"\n        Invokes the model.\n\n        Parameters can be provided via args or kwargs. args, if provided, are assumed to match the order of inputs of\n        the model. kwargs are matched with the model input names.\n        \"\"\"\n        inputs = self._create_inputs(*args, **kwargs)\n        response = self.client.infer(model_name=self.model_name, inputs=inputs)\n        result = []\n        for output in self.metadata[\"outputs\"]:\n            tensor = torch.as_tensor(response.as_numpy(output[\"name\"]))\n            result.append(tensor)\n        return result[0] if len(result) == 1 else result\n\n    def _create_inputs(self, *args, **kwargs):\n        \"\"\"Creates input tensors from args or kwargs, not both; raises error if none or both are provided.\"\"\"\n        args_len, kwargs_len = len(args), len(kwargs)\n        if not args_len and not kwargs_len:\n            raise RuntimeError(\"No inputs provided.\")\n        if args_len and kwargs_len:\n            raise RuntimeError(\"Cannot specify args and kwargs at the same time\")\n\n        placeholders = self._create_input_placeholders_fn()\n        if args_len:\n            if args_len != len(placeholders):\n                raise RuntimeError(f\"Expected {len(placeholders)} inputs, got {args_len}.\")\n            for input, value in zip(placeholders, args):\n                input.set_data_from_numpy(value.cpu().numpy())\n        else:\n            for input in placeholders:\n                value = kwargs[input.name]\n                input.set_data_from_numpy(value.cpu().numpy())\n        return placeholders\n", "utils/flask_rest_api/example_request.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Perform test request.\"\"\"\n\nimport pprint\n\nimport requests\n\nDETECTION_URL = \"http://localhost:5000/v1/object-detection/yolov5s\"\nIMAGE = \"zidane.jpg\"\n\n# Read image\nwith open(IMAGE, \"rb\") as f:\n    image_data = f.read()\n\nresponse = requests.post(DETECTION_URL, files={\"image\": image_data}).json()\n\npprint.pprint(response)\n", "utils/flask_rest_api/restapi.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Run a Flask REST API exposing one or more YOLOv5s models.\"\"\"\n\nimport argparse\nimport io\n\nimport torch\nfrom flask import Flask, request\nfrom PIL import Image\n\napp = Flask(__name__)\nmodels = {}\n\nDETECTION_URL = \"/v1/object-detection/<model>\"\n\n\n@app.route(DETECTION_URL, methods=[\"POST\"])\ndef predict(model):\n    \"\"\"Predict and return object detections in JSON format given an image and model name via a Flask REST API POST\n    request.\n    \"\"\"\n    if request.method != \"POST\":\n        return\n\n    if request.files.get(\"image\"):\n        # Method 1\n        # with request.files[\"image\"] as f:\n        #     im = Image.open(io.BytesIO(f.read()))\n\n        # Method 2\n        im_file = request.files[\"image\"]\n        im_bytes = im_file.read()\n        im = Image.open(io.BytesIO(im_bytes))\n\n        if model in models:\n            results = models[model](im, size=640)  # reduce size=320 for faster inference\n            return results.pandas().xyxy[0].to_json(orient=\"records\")\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Flask API exposing YOLOv5 model\")\n    parser.add_argument(\"--port\", default=5000, type=int, help=\"port number\")\n    parser.add_argument(\"--model\", nargs=\"+\", default=[\"yolov5s\"], help=\"model(s) to run, i.e. --model yolov5n yolov5s\")\n    opt = parser.parse_args()\n\n    for m in opt.model:\n        models[m] = torch.hub.load(\"ultralytics/yolov5\", m, force_reload=True, skip_validation=True)\n\n    app.run(host=\"0.0.0.0\", port=opt.port)  # debug=True causes Restarting with stat\n", "utils/segment/loss.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom ..general import xywh2xyxy\nfrom ..loss import FocalLoss, smooth_BCE\nfrom ..metrics import bbox_iou\nfrom ..torch_utils import de_parallel\nfrom .general import crop_mask\n\n\nclass ComputeLoss:\n    # Compute losses\n    def __init__(self, model, autobalance=False, overlap=False):\n        \"\"\"Initializes the compute loss function for YOLOv5 models with options for autobalancing and overlap\n        handling.\n        \"\"\"\n        self.sort_obj_iou = False\n        self.overlap = overlap\n        device = next(model.parameters()).device  # get model device\n        h = model.hyp  # hyperparameters\n\n        # Define criteria\n        BCEcls = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h[\"cls_pw\"]], device=device))\n        BCEobj = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h[\"obj_pw\"]], device=device))\n\n        # Class label smoothing https://arxiv.org/pdf/1902.04103.pdf eqn 3\n        self.cp, self.cn = smooth_BCE(eps=h.get(\"label_smoothing\", 0.0))  # positive, negative BCE targets\n\n        # Focal loss\n        g = h[\"fl_gamma\"]  # focal loss gamma\n        if g > 0:\n            BCEcls, BCEobj = FocalLoss(BCEcls, g), FocalLoss(BCEobj, g)\n\n        m = de_parallel(model).model[-1]  # Detect() module\n        self.balance = {3: [4.0, 1.0, 0.4]}.get(m.nl, [4.0, 1.0, 0.25, 0.06, 0.02])  # P3-P7\n        self.ssi = list(m.stride).index(16) if autobalance else 0  # stride 16 index\n        self.BCEcls, self.BCEobj, self.gr, self.hyp, self.autobalance = BCEcls, BCEobj, 1.0, h, autobalance\n        self.na = m.na  # number of anchors\n        self.nc = m.nc  # number of classes\n        self.nl = m.nl  # number of layers\n        self.nm = m.nm  # number of masks\n        self.anchors = m.anchors\n        self.device = device\n\n    def __call__(self, preds, targets, masks):  # predictions, targets, model\n        \"\"\"Evaluates YOLOv5 model's loss for given predictions, targets, and masks; returns total loss components.\"\"\"\n        p, proto = preds\n        bs, nm, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width\n        lcls = torch.zeros(1, device=self.device)\n        lbox = torch.zeros(1, device=self.device)\n        lobj = torch.zeros(1, device=self.device)\n        lseg = torch.zeros(1, device=self.device)\n        tcls, tbox, indices, anchors, tidxs, xywhn = self.build_targets(p, targets)  # targets\n\n        # Losses\n        for i, pi in enumerate(p):  # layer index, layer predictions\n            b, a, gj, gi = indices[i]  # image, anchor, gridy, gridx\n            tobj = torch.zeros(pi.shape[:4], dtype=pi.dtype, device=self.device)  # target obj\n\n            n = b.shape[0]  # number of targets\n            if n:\n                pxy, pwh, _, pcls, pmask = pi[b, a, gj, gi].split((2, 2, 1, self.nc, nm), 1)  # subset of predictions\n\n                # Box regression\n                pxy = pxy.sigmoid() * 2 - 0.5\n                pwh = (pwh.sigmoid() * 2) ** 2 * anchors[i]\n                pbox = torch.cat((pxy, pwh), 1)  # predicted box\n                iou = bbox_iou(pbox, tbox[i], CIoU=True).squeeze()  # iou(prediction, target)\n                lbox += (1.0 - iou).mean()  # iou loss\n\n                # Objectness\n                iou = iou.detach().clamp(0).type(tobj.dtype)\n                if self.sort_obj_iou:\n                    j = iou.argsort()\n                    b, a, gj, gi, iou = b[j], a[j], gj[j], gi[j], iou[j]\n                if self.gr < 1:\n                    iou = (1.0 - self.gr) + self.gr * iou\n                tobj[b, a, gj, gi] = iou  # iou ratio\n\n                # Classification\n                if self.nc > 1:  # cls loss (only if multiple classes)\n                    t = torch.full_like(pcls, self.cn, device=self.device)  # targets\n                    t[range(n), tcls[i]] = self.cp\n                    lcls += self.BCEcls(pcls, t)  # BCE\n\n                # Mask regression\n                if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample\n                    masks = F.interpolate(masks[None], (mask_h, mask_w), mode=\"nearest\")[0]\n                marea = xywhn[i][:, 2:].prod(1)  # mask width, height normalized\n                mxyxy = xywh2xyxy(xywhn[i] * torch.tensor([mask_w, mask_h, mask_w, mask_h], device=self.device))\n                for bi in b.unique():\n                    j = b == bi  # matching index\n                    if self.overlap:\n                        mask_gti = torch.where(masks[bi][None] == tidxs[i][j].view(-1, 1, 1), 1.0, 0.0)\n                    else:\n                        mask_gti = masks[tidxs[i]][j]\n                    lseg += self.single_mask_loss(mask_gti, pmask[j], proto[bi], mxyxy[j], marea[j])\n\n            obji = self.BCEobj(pi[..., 4], tobj)\n            lobj += obji * self.balance[i]  # obj loss\n            if self.autobalance:\n                self.balance[i] = self.balance[i] * 0.9999 + 0.0001 / obji.detach().item()\n\n        if self.autobalance:\n            self.balance = [x / self.balance[self.ssi] for x in self.balance]\n        lbox *= self.hyp[\"box\"]\n        lobj *= self.hyp[\"obj\"]\n        lcls *= self.hyp[\"cls\"]\n        lseg *= self.hyp[\"box\"] / bs\n\n        loss = lbox + lobj + lcls + lseg\n        return loss * bs, torch.cat((lbox, lseg, lobj, lcls)).detach()\n\n    def single_mask_loss(self, gt_mask, pred, proto, xyxy, area):\n        \"\"\"Calculates and normalizes single mask loss for YOLOv5 between predicted and ground truth masks.\"\"\"\n        pred_mask = (pred @ proto.view(self.nm, -1)).view(-1, *proto.shape[1:])  # (n,32) @ (32,80,80) -> (n,80,80)\n        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction=\"none\")\n        return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).mean()\n\n    def build_targets(self, p, targets):\n        \"\"\"Prepares YOLOv5 targets for loss computation; inputs targets (image, class, x, y, w, h), output target\n        classes/boxes.\n        \"\"\"\n        na, nt = self.na, targets.shape[0]  # number of anchors, targets\n        tcls, tbox, indices, anch, tidxs, xywhn = [], [], [], [], [], []\n        gain = torch.ones(8, device=self.device)  # normalized to gridspace gain\n        ai = torch.arange(na, device=self.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)\n        if self.overlap:\n            batch = p[0].shape[0]\n            ti = []\n            for i in range(batch):\n                num = (targets[:, 0] == i).sum()  # find number of targets of each image\n                ti.append(torch.arange(num, device=self.device).float().view(1, num).repeat(na, 1) + 1)  # (na, num)\n            ti = torch.cat(ti, 1)  # (na, nt)\n        else:\n            ti = torch.arange(nt, device=self.device).float().view(1, nt).repeat(na, 1)\n        targets = torch.cat((targets.repeat(na, 1, 1), ai[..., None], ti[..., None]), 2)  # append anchor indices\n\n        g = 0.5  # bias\n        off = (\n            torch.tensor(\n                [\n                    [0, 0],\n                    [1, 0],\n                    [0, 1],\n                    [-1, 0],\n                    [0, -1],  # j,k,l,m\n                    # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm\n                ],\n                device=self.device,\n            ).float()\n            * g\n        )  # offsets\n\n        for i in range(self.nl):\n            anchors, shape = self.anchors[i], p[i].shape\n            gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]]  # xyxy gain\n\n            # Match targets to anchors\n            t = targets * gain  # shape(3,n,7)\n            if nt:\n                # Matches\n                r = t[..., 4:6] / anchors[:, None]  # wh ratio\n                j = torch.max(r, 1 / r).max(2)[0] < self.hyp[\"anchor_t\"]  # compare\n                # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))\n                t = t[j]  # filter\n\n                # Offsets\n                gxy = t[:, 2:4]  # grid xy\n                gxi = gain[[2, 3]] - gxy  # inverse\n                j, k = ((gxy % 1 < g) & (gxy > 1)).T\n                l, m = ((gxi % 1 < g) & (gxi > 1)).T\n                j = torch.stack((torch.ones_like(j), j, k, l, m))\n                t = t.repeat((5, 1, 1))[j]\n                offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]\n            else:\n                t = targets[0]\n                offsets = 0\n\n            # Define\n            bc, gxy, gwh, at = t.chunk(4, 1)  # (image, class), grid xy, grid wh, anchors\n            (a, tidx), (b, c) = at.long().T, bc.long().T  # anchors, image, class\n            gij = (gxy - offsets).long()\n            gi, gj = gij.T  # grid indices\n\n            # Append\n            indices.append((b, a, gj.clamp_(0, shape[2] - 1), gi.clamp_(0, shape[3] - 1)))  # image, anchor, grid\n            tbox.append(torch.cat((gxy - gij, gwh), 1))  # box\n            anch.append(anchors[a])  # anchors\n            tcls.append(c)  # class\n            tidxs.append(tidx)\n            xywhn.append(torch.cat((gxy, gwh), 1) / gain[2:6])  # xywh normalized\n\n        return tcls, tbox, indices, anch, tidxs, xywhn\n", "utils/segment/augmentations.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Image augmentation functions.\"\"\"\n\nimport math\nimport random\n\nimport cv2\nimport numpy as np\n\nfrom ..augmentations import box_candidates\nfrom ..general import resample_segments, segment2box\n\n\ndef mixup(im, labels, segments, im2, labels2, segments2):\n    \"\"\"\n    Applies MixUp augmentation blending two images, labels, and segments with a random ratio.\n\n    See https://arxiv.org/pdf/1710.09412.pdf\n    \"\"\"\n    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n    labels = np.concatenate((labels, labels2), 0)\n    segments = np.concatenate((segments, segments2), 0)\n    return im, labels, segments\n\n\ndef random_perspective(\n    im, targets=(), segments=(), degrees=10, translate=0.1, scale=0.1, shear=10, perspective=0.0, border=(0, 0)\n):\n    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(.1, .1), scale=(.9, 1.1), shear=(-10, 10))\n    # targets = [cls, xyxy]\n\n    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n    width = im.shape[1] + border[1] * 2\n\n    # Center\n    C = np.eye(3)\n    C[0, 2] = -im.shape[1] / 2  # x translation (pixels)\n    C[1, 2] = -im.shape[0] / 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3)\n    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3)\n    a = random.uniform(-degrees, degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - scale, 1 + scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3)\n    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3)\n    T[0, 2] = random.uniform(0.5 - translate, 0.5 + translate) * width  # x translation (pixels)\n    T[1, 2] = random.uniform(0.5 - translate, 0.5 + translate) * height  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if perspective:\n            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n        else:  # affine\n            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n\n    # Visualize\n    # import matplotlib.pyplot as plt\n    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n    # ax[0].imshow(im[:, :, ::-1])  # base\n    # ax[1].imshow(im2[:, :, ::-1])  # warped\n\n    # Transform label coordinates\n    n = len(targets)\n    new_segments = []\n    if n:\n        new = np.zeros((n, 4))\n        segments = resample_segments(segments)  # upsample\n        for i, segment in enumerate(segments):\n            xy = np.ones((len(segment), 3))\n            xy[:, :2] = segment\n            xy = xy @ M.T  # transform\n            xy = xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]  # perspective rescale or affine\n\n            # clip\n            new[i] = segment2box(xy, width, height)\n            new_segments.append(xy)\n\n        # filter candidates\n        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01)\n        targets = targets[i]\n        targets[:, 1:5] = new[i]\n        new_segments = np.array(new_segments)[i]\n\n    return im, targets, new_segments\n", "utils/segment/plots.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport contextlib\nimport math\nfrom pathlib import Path\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport torch\n\nfrom .. import threaded\nfrom ..general import xywh2xyxy\nfrom ..plots import Annotator, colors\n\n\n@threaded\ndef plot_images_and_masks(images, targets, masks, paths=None, fname=\"images.jpg\", names=None):\n    \"\"\"Plots a grid of images, their labels, and masks with optional resizing and annotations, saving to fname.\"\"\"\n    if isinstance(images, torch.Tensor):\n        images = images.cpu().float().numpy()\n    if isinstance(targets, torch.Tensor):\n        targets = targets.cpu().numpy()\n    if isinstance(masks, torch.Tensor):\n        masks = masks.cpu().numpy().astype(int)\n\n    max_size = 1920  # max image size\n    max_subplots = 16  # max image subplots, i.e. 4x4\n    bs, _, h, w = images.shape  # batch size, _, height, width\n    bs = min(bs, max_subplots)  # limit plot images\n    ns = np.ceil(bs**0.5)  # number of subplots (square)\n    if np.max(images[0]) <= 1:\n        images *= 255  # de-normalise (optional)\n\n    # Build Image\n    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n    for i, im in enumerate(images):\n        if i == max_subplots:  # if last batch has fewer images than we expect\n            break\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        im = im.transpose(1, 2, 0)\n        mosaic[y : y + h, x : x + w, :] = im\n\n    # Resize (optional)\n    scale = max_size / ns / max(h, w)\n    if scale < 1:\n        h = math.ceil(scale * h)\n        w = math.ceil(scale * w)\n        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n\n    # Annotate\n    fs = int((h + w) * ns * 0.01)  # font size\n    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n    for i in range(i + 1):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n        if paths:\n            annotator.text([x + 5, y + 5], text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n        if len(targets) > 0:\n            idx = targets[:, 0] == i\n            ti = targets[idx]  # image targets\n\n            boxes = xywh2xyxy(ti[:, 2:6]).T\n            classes = ti[:, 1].astype(\"int\")\n            labels = ti.shape[1] == 6  # labels if no conf column\n            conf = None if labels else ti[:, 6]  # check for confidence presence (label vs pred)\n\n            if boxes.shape[1]:\n                if boxes.max() <= 1.01:  # if normalized with tolerance 0.01\n                    boxes[[0, 2]] *= w  # scale to pixels\n                    boxes[[1, 3]] *= h\n                elif scale < 1:  # absolute coords need scale if image scales\n                    boxes *= scale\n            boxes[[0, 2]] += x\n            boxes[[1, 3]] += y\n            for j, box in enumerate(boxes.T.tolist()):\n                cls = classes[j]\n                color = colors(cls)\n                cls = names[cls] if names else cls\n                if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                    label = f\"{cls}\" if labels else f\"{cls} {conf[j]:.1f}\"\n                    annotator.box_label(box, label, color=color)\n\n            # Plot masks\n            if len(masks):\n                if masks.max() > 1.0:  # mean that masks are overlap\n                    image_masks = masks[[i]]  # (1, 640, 640)\n                    nl = len(ti)\n                    index = np.arange(nl).reshape(nl, 1, 1) + 1\n                    image_masks = np.repeat(image_masks, nl, axis=0)\n                    image_masks = np.where(image_masks == index, 1.0, 0.0)\n                else:\n                    image_masks = masks[idx]\n\n                im = np.asarray(annotator.im).copy()\n                for j, box in enumerate(boxes.T.tolist()):\n                    if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                        color = colors(classes[j])\n                        mh, mw = image_masks[j].shape\n                        if mh != h or mw != w:\n                            mask = image_masks[j].astype(np.uint8)\n                            mask = cv2.resize(mask, (w, h))\n                            mask = mask.astype(bool)\n                        else:\n                            mask = image_masks[j].astype(bool)\n                        with contextlib.suppress(Exception):\n                            im[y : y + h, x : x + w, :][mask] = (\n                                im[y : y + h, x : x + w, :][mask] * 0.4 + np.array(color) * 0.6\n                            )\n                annotator.fromarray(im)\n    annotator.im.save(fname)  # save\n\n\ndef plot_results_with_masks(file=\"path/to/results.csv\", dir=\"\", best=True):\n    \"\"\"\n    Plots training results from CSV files, plotting best or last result highlights based on `best` parameter.\n\n    Example: from utils.plots import *; plot_results('path/to/results.csv')\n    \"\"\"\n    save_dir = Path(file).parent if file else Path(dir)\n    fig, ax = plt.subplots(2, 8, figsize=(18, 6), tight_layout=True)\n    ax = ax.ravel()\n    files = list(save_dir.glob(\"results*.csv\"))\n    assert len(files), f\"No results.csv files found in {save_dir.resolve()}, nothing to plot.\"\n    for f in files:\n        try:\n            data = pd.read_csv(f)\n            index = np.argmax(\n                0.9 * data.values[:, 8] + 0.1 * data.values[:, 7] + 0.9 * data.values[:, 12] + 0.1 * data.values[:, 11]\n            )\n            s = [x.strip() for x in data.columns]\n            x = data.values[:, 0]\n            for i, j in enumerate([1, 2, 3, 4, 5, 6, 9, 10, 13, 14, 15, 16, 7, 8, 11, 12]):\n                y = data.values[:, j]\n                # y[y == 0] = np.nan  # don't show zero values\n                ax[i].plot(x, y, marker=\".\", label=f.stem, linewidth=2, markersize=2)\n                if best:\n                    # best\n                    ax[i].scatter(index, y[index], color=\"r\", label=f\"best:{index}\", marker=\"*\", linewidth=3)\n                    ax[i].set_title(s[j] + f\"\\n{round(y[index], 5)}\")\n                else:\n                    # last\n                    ax[i].scatter(x[-1], y[-1], color=\"r\", label=\"last\", marker=\"*\", linewidth=3)\n                    ax[i].set_title(s[j] + f\"\\n{round(y[-1], 5)}\")\n                # if j in [8, 9, 10]:  # share train and val loss y axes\n                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n        except Exception as e:\n            print(f\"Warning: Plotting error for {f}: {e}\")\n    ax[1].legend()\n    fig.savefig(save_dir / \"results.png\", dpi=200)\n    plt.close()\n", "utils/segment/metrics.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Model validation metrics.\"\"\"\n\nimport numpy as np\n\nfrom ..metrics import ap_per_class\n\n\ndef fitness(x):\n    \"\"\"Evaluates model fitness by a weighted sum of 8 metrics, `x`: [N,8] array, weights: [0.1, 0.9] for mAP and F1.\"\"\"\n    w = [0.0, 0.0, 0.1, 0.9, 0.0, 0.0, 0.1, 0.9]\n    return (x[:, :8] * w).sum(1)\n\n\ndef ap_per_class_box_and_mask(\n    tp_m,\n    tp_b,\n    conf,\n    pred_cls,\n    target_cls,\n    plot=False,\n    save_dir=\".\",\n    names=(),\n):\n    \"\"\"\n    Args:\n        tp_b: tp of boxes.\n        tp_m: tp of masks.\n        other arguments see `func: ap_per_class`.\n    \"\"\"\n    results_boxes = ap_per_class(\n        tp_b, conf, pred_cls, target_cls, plot=plot, save_dir=save_dir, names=names, prefix=\"Box\"\n    )[2:]\n    results_masks = ap_per_class(\n        tp_m, conf, pred_cls, target_cls, plot=plot, save_dir=save_dir, names=names, prefix=\"Mask\"\n    )[2:]\n\n    return {\n        \"boxes\": {\n            \"p\": results_boxes[0],\n            \"r\": results_boxes[1],\n            \"ap\": results_boxes[3],\n            \"f1\": results_boxes[2],\n            \"ap_class\": results_boxes[4],\n        },\n        \"masks\": {\n            \"p\": results_masks[0],\n            \"r\": results_masks[1],\n            \"ap\": results_masks[3],\n            \"f1\": results_masks[2],\n            \"ap_class\": results_masks[4],\n        },\n    }\n\n\nclass Metric:\n    def __init__(self) -> None:\n        self.p = []  # (nc, )\n        self.r = []  # (nc, )\n        self.f1 = []  # (nc, )\n        self.all_ap = []  # (nc, 10)\n        self.ap_class_index = []  # (nc, )\n\n    @property\n    def ap50(self):\n        \"\"\"\n        AP@0.5 of all classes.\n\n        Return:\n            (nc, ) or [].\n        \"\"\"\n        return self.all_ap[:, 0] if len(self.all_ap) else []\n\n    @property\n    def ap(self):\n        \"\"\"AP@0.5:0.95\n        Return:\n            (nc, ) or [].\n        \"\"\"\n        return self.all_ap.mean(1) if len(self.all_ap) else []\n\n    @property\n    def mp(self):\n        \"\"\"\n        Mean precision of all classes.\n\n        Return:\n            float.\n        \"\"\"\n        return self.p.mean() if len(self.p) else 0.0\n\n    @property\n    def mr(self):\n        \"\"\"\n        Mean recall of all classes.\n\n        Return:\n            float.\n        \"\"\"\n        return self.r.mean() if len(self.r) else 0.0\n\n    @property\n    def map50(self):\n        \"\"\"\n        Mean AP@0.5 of all classes.\n\n        Return:\n            float.\n        \"\"\"\n        return self.all_ap[:, 0].mean() if len(self.all_ap) else 0.0\n\n    @property\n    def map(self):\n        \"\"\"\n        Mean AP@0.5:0.95 of all classes.\n\n        Return:\n            float.\n        \"\"\"\n        return self.all_ap.mean() if len(self.all_ap) else 0.0\n\n    def mean_results(self):\n        \"\"\"Mean of results, return mp, mr, map50, map.\"\"\"\n        return (self.mp, self.mr, self.map50, self.map)\n\n    def class_result(self, i):\n        \"\"\"Class-aware result, return p[i], r[i], ap50[i], ap[i]\"\"\"\n        return (self.p[i], self.r[i], self.ap50[i], self.ap[i])\n\n    def get_maps(self, nc):\n        \"\"\"Calculates and returns mean Average Precision (mAP) for each class given number of classes `nc`.\"\"\"\n        maps = np.zeros(nc) + self.map\n        for i, c in enumerate(self.ap_class_index):\n            maps[c] = self.ap[i]\n        return maps\n\n    def update(self, results):\n        \"\"\"\n        Args:\n            results: tuple(p, r, ap, f1, ap_class)\n        \"\"\"\n        p, r, all_ap, f1, ap_class_index = results\n        self.p = p\n        self.r = r\n        self.all_ap = all_ap\n        self.f1 = f1\n        self.ap_class_index = ap_class_index\n\n\nclass Metrics:\n    \"\"\"Metric for boxes and masks.\"\"\"\n\n    def __init__(self) -> None:\n        self.metric_box = Metric()\n        self.metric_mask = Metric()\n\n    def update(self, results):\n        \"\"\"\n        Args:\n            results: Dict{'boxes': Dict{}, 'masks': Dict{}}\n        \"\"\"\n        self.metric_box.update(list(results[\"boxes\"].values()))\n        self.metric_mask.update(list(results[\"masks\"].values()))\n\n    def mean_results(self):\n        \"\"\"Computes and returns the mean results for both box and mask metrics by summing their individual means.\"\"\"\n        return self.metric_box.mean_results() + self.metric_mask.mean_results()\n\n    def class_result(self, i):\n        \"\"\"Returns the sum of box and mask metric results for a specified class index `i`.\"\"\"\n        return self.metric_box.class_result(i) + self.metric_mask.class_result(i)\n\n    def get_maps(self, nc):\n        \"\"\"Calculates and returns the sum of mean average precisions (mAPs) for both box and mask metrics for `nc`\n        classes.\n        \"\"\"\n        return self.metric_box.get_maps(nc) + self.metric_mask.get_maps(nc)\n\n    @property\n    def ap_class_index(self):\n        \"\"\"Returns the class index for average precision, shared by both box and mask metrics.\"\"\"\n        return self.metric_box.ap_class_index\n\n\nKEYS = [\n    \"train/box_loss\",\n    \"train/seg_loss\",  # train loss\n    \"train/obj_loss\",\n    \"train/cls_loss\",\n    \"metrics/precision(B)\",\n    \"metrics/recall(B)\",\n    \"metrics/mAP_0.5(B)\",\n    \"metrics/mAP_0.5:0.95(B)\",  # metrics\n    \"metrics/precision(M)\",\n    \"metrics/recall(M)\",\n    \"metrics/mAP_0.5(M)\",\n    \"metrics/mAP_0.5:0.95(M)\",  # metrics\n    \"val/box_loss\",\n    \"val/seg_loss\",  # val loss\n    \"val/obj_loss\",\n    \"val/cls_loss\",\n    \"x/lr0\",\n    \"x/lr1\",\n    \"x/lr2\",\n]\n\nBEST_KEYS = [\n    \"best/epoch\",\n    \"best/precision(B)\",\n    \"best/recall(B)\",\n    \"best/mAP_0.5(B)\",\n    \"best/mAP_0.5:0.95(B)\",\n    \"best/precision(M)\",\n    \"best/recall(M)\",\n    \"best/mAP_0.5(M)\",\n    \"best/mAP_0.5:0.95(M)\",\n]\n", "utils/segment/general.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport cv2\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n\ndef crop_mask(masks, boxes):\n    \"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox. Vectorized by Chong (thanks Chong).\n\n    Args:\n        - masks should be a size [n, h, w] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n    \"\"\"\n\n    n, h, w = masks.shape\n    x1, y1, x2, y2 = torch.chunk(boxes[:, :, None], 4, 1)  # x1 shape(1,1,n)\n    r = torch.arange(w, device=masks.device, dtype=x1.dtype)[None, None, :]  # rows shape(1,w,1)\n    c = torch.arange(h, device=masks.device, dtype=x1.dtype)[None, :, None]  # cols shape(h,1,1)\n\n    return masks * ((r >= x1) * (r < x2) * (c >= y1) * (c < y2))\n\n\ndef process_mask_upsample(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Crop after upsample.\n    protos: [mask_dim, mask_h, mask_w]\n    masks_in: [n, mask_dim], n is number of masks after nms\n    bboxes: [n, 4], n is number of masks after nms\n    shape: input_image_size, (h, w)\n\n    return: h, w, n\n    \"\"\"\n\n    c, mh, mw = protos.shape  # CHW\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n    masks = F.interpolate(masks[None], shape, mode=\"bilinear\", align_corners=False)[0]  # CHW\n    masks = crop_mask(masks, bboxes)  # CHW\n    return masks.gt_(0.5)\n\n\ndef process_mask(protos, masks_in, bboxes, shape, upsample=False):\n    \"\"\"\n    Crop before upsample.\n    proto_out: [mask_dim, mask_h, mask_w]\n    out_masks: [n, mask_dim], n is number of masks after nms\n    bboxes: [n, 4], n is number of masks after nms\n    shape:input_image_size, (h, w)\n\n    return: h, w, n\n    \"\"\"\n\n    c, mh, mw = protos.shape  # CHW\n    ih, iw = shape\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)  # CHW\n\n    downsampled_bboxes = bboxes.clone()\n    downsampled_bboxes[:, 0] *= mw / iw\n    downsampled_bboxes[:, 2] *= mw / iw\n    downsampled_bboxes[:, 3] *= mh / ih\n    downsampled_bboxes[:, 1] *= mh / ih\n\n    masks = crop_mask(masks, downsampled_bboxes)  # CHW\n    if upsample:\n        masks = F.interpolate(masks[None], shape, mode=\"bilinear\", align_corners=False)[0]  # CHW\n    return masks.gt_(0.5)\n\n\ndef process_mask_native(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Crop after upsample.\n    protos: [mask_dim, mask_h, mask_w]\n    masks_in: [n, mask_dim], n is number of masks after nms\n    bboxes: [n, 4], n is number of masks after nms\n    shape: input_image_size, (h, w)\n\n    return: h, w, n\n    \"\"\"\n    c, mh, mw = protos.shape  # CHW\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n    gain = min(mh / shape[0], mw / shape[1])  # gain  = old / new\n    pad = (mw - shape[1] * gain) / 2, (mh - shape[0] * gain) / 2  # wh padding\n    top, left = int(pad[1]), int(pad[0])  # y, x\n    bottom, right = int(mh - pad[1]), int(mw - pad[0])\n    masks = masks[:, top:bottom, left:right]\n\n    masks = F.interpolate(masks[None], shape, mode=\"bilinear\", align_corners=False)[0]  # CHW\n    masks = crop_mask(masks, bboxes)  # CHW\n    return masks.gt_(0.5)\n\n\ndef scale_image(im1_shape, masks, im0_shape, ratio_pad=None):\n    \"\"\"\n    img1_shape: model input shape, [h, w]\n    img0_shape: origin pic shape, [h, w, 3]\n    masks: [h, w, num]\n    \"\"\"\n    # Rescale coordinates (xyxy) from im1_shape to im0_shape\n    if ratio_pad is None:  # calculate from im0_shape\n        gain = min(im1_shape[0] / im0_shape[0], im1_shape[1] / im0_shape[1])  # gain  = old / new\n        pad = (im1_shape[1] - im0_shape[1] * gain) / 2, (im1_shape[0] - im0_shape[0] * gain) / 2  # wh padding\n    else:\n        pad = ratio_pad[1]\n    top, left = int(pad[1]), int(pad[0])  # y, x\n    bottom, right = int(im1_shape[0] - pad[1]), int(im1_shape[1] - pad[0])\n\n    if len(masks.shape) < 2:\n        raise ValueError(f'\"len of masks shape\" should be 2 or 3, but got {len(masks.shape)}')\n    masks = masks[top:bottom, left:right]\n    # masks = masks.permute(2, 0, 1).contiguous()\n    # masks = F.interpolate(masks[None], im0_shape[:2], mode='bilinear', align_corners=False)[0]\n    # masks = masks.permute(1, 2, 0).contiguous()\n    masks = cv2.resize(masks, (im0_shape[1], im0_shape[0]))\n\n    if len(masks.shape) == 2:\n        masks = masks[:, :, None]\n    return masks\n\n\ndef mask_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    mask1: [N, n] m1 means number of predicted objects\n    mask2: [M, n] m2 means number of gt objects\n    Note: n means image_w x image_h\n\n    return: masks iou, [N, M]\n    \"\"\"\n    intersection = torch.matmul(mask1, mask2.t()).clamp(0)\n    union = (mask1.sum(1)[:, None] + mask2.sum(1)[None]) - intersection  # (area1 + area2) - intersection\n    return intersection / (union + eps)\n\n\ndef masks_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    mask1: [N, n] m1 means number of predicted objects\n    mask2: [N, n] m2 means number of gt objects\n    Note: n means image_w x image_h\n\n    return: masks iou, (N, )\n    \"\"\"\n    intersection = (mask1 * mask2).sum(1).clamp(0)  # (N, )\n    union = (mask1.sum(1) + mask2.sum(1))[None] - intersection  # (area1 + area2) - intersection\n    return intersection / (union + eps)\n\n\ndef masks2segments(masks, strategy=\"largest\"):\n    \"\"\"Converts binary (n,160,160) masks to polygon segments with options for concatenation or selecting the largest\n    segment.\n    \"\"\"\n    segments = []\n    for x in masks.int().cpu().numpy().astype(\"uint8\"):\n        c = cv2.findContours(x, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]\n        if c:\n            if strategy == \"concat\":  # concatenate all segments\n                c = np.concatenate([x.reshape(-1, 2) for x in c])\n            elif strategy == \"largest\":  # select largest segment\n                c = np.array(c[np.array([len(x) for x in c]).argmax()]).reshape(-1, 2)\n        else:\n            c = np.zeros((0, 2))  # no segments found\n        segments.append(c.astype(\"float32\"))\n    return segments\n", "utils/segment/__init__.py": "", "utils/loggers/__init__.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Logging utils.\"\"\"\n\nimport json\nimport os\nimport warnings\nfrom pathlib import Path\n\nimport pkg_resources as pkg\nimport torch\n\nfrom utils.general import LOGGER, colorstr, cv2\nfrom utils.loggers.clearml.clearml_utils import ClearmlLogger\nfrom utils.loggers.wandb.wandb_utils import WandbLogger\nfrom utils.plots import plot_images, plot_labels, plot_results\nfrom utils.torch_utils import de_parallel\n\nLOGGERS = (\"csv\", \"tb\", \"wandb\", \"clearml\", \"comet\")  # *.csv, TensorBoard, Weights & Biases, ClearML\nRANK = int(os.getenv(\"RANK\", -1))\n\ntry:\n    from torch.utils.tensorboard import SummaryWriter\nexcept ImportError:\n\n    def SummaryWriter(*args):\n        \"\"\"Fall back to SummaryWriter returning None if TensorBoard is not installed.\"\"\"\n        return None  # None = SummaryWriter(str)\n\n\ntry:\n    import wandb\n\n    assert hasattr(wandb, \"__version__\")  # verify package import not local dir\n    if pkg.parse_version(wandb.__version__) >= pkg.parse_version(\"0.12.2\") and RANK in {0, -1}:\n        try:\n            wandb_login_success = wandb.login(timeout=30)\n        except wandb.errors.UsageError:  # known non-TTY terminal issue\n            wandb_login_success = False\n        if not wandb_login_success:\n            wandb = None\nexcept (ImportError, AssertionError):\n    wandb = None\n\ntry:\n    import clearml\n\n    assert hasattr(clearml, \"__version__\")  # verify package import not local dir\nexcept (ImportError, AssertionError):\n    clearml = None\n\ntry:\n    if RANK in {0, -1}:\n        import comet_ml\n\n        assert hasattr(comet_ml, \"__version__\")  # verify package import not local dir\n        from utils.loggers.comet import CometLogger\n\n    else:\n        comet_ml = None\nexcept (ImportError, AssertionError):\n    comet_ml = None\n\n\ndef _json_default(value):\n    \"\"\"\n    Format `value` for JSON serialization (e.g. unwrap tensors).\n\n    Fall back to strings.\n    \"\"\"\n    if isinstance(value, torch.Tensor):\n        try:\n            value = value.item()\n        except ValueError:  # \"only one element tensors can be converted to Python scalars\"\n            pass\n    return value if isinstance(value, float) else str(value)\n\n\nclass Loggers:\n    # YOLOv5 Loggers class\n    def __init__(self, save_dir=None, weights=None, opt=None, hyp=None, logger=None, include=LOGGERS):\n        \"\"\"Initializes loggers for YOLOv5 training and validation metrics, paths, and options.\"\"\"\n        self.save_dir = save_dir\n        self.weights = weights\n        self.opt = opt\n        self.hyp = hyp\n        self.plots = not opt.noplots  # plot results\n        self.logger = logger  # for printing results to console\n        self.include = include\n        self.keys = [\n            \"train/box_loss\",\n            \"train/obj_loss\",\n            \"train/cls_loss\",  # train loss\n            \"metrics/precision\",\n            \"metrics/recall\",\n            \"metrics/mAP_0.5\",\n            \"metrics/mAP_0.5:0.95\",  # metrics\n            \"val/box_loss\",\n            \"val/obj_loss\",\n            \"val/cls_loss\",  # val loss\n            \"x/lr0\",\n            \"x/lr1\",\n            \"x/lr2\",\n        ]  # params\n        self.best_keys = [\"best/epoch\", \"best/precision\", \"best/recall\", \"best/mAP_0.5\", \"best/mAP_0.5:0.95\"]\n        for k in LOGGERS:\n            setattr(self, k, None)  # init empty logger dictionary\n        self.csv = True  # always log to csv\n        self.ndjson_console = \"ndjson_console\" in self.include  # log ndjson to console\n        self.ndjson_file = \"ndjson_file\" in self.include  # log ndjson to file\n\n        # Messages\n        if not comet_ml:\n            prefix = colorstr(\"Comet: \")\n            s = f\"{prefix}run 'pip install comet_ml' to automatically track and visualize YOLOv5 \ud83d\ude80 runs in Comet\"\n            self.logger.info(s)\n        # TensorBoard\n        s = self.save_dir\n        if \"tb\" in self.include and not self.opt.evolve:\n            prefix = colorstr(\"TensorBoard: \")\n            self.logger.info(f\"{prefix}Start with 'tensorboard --logdir {s.parent}', view at http://localhost:6006/\")\n            self.tb = SummaryWriter(str(s))\n\n        # W&B\n        if wandb and \"wandb\" in self.include:\n            self.opt.hyp = self.hyp  # add hyperparameters\n            self.wandb = WandbLogger(self.opt)\n        else:\n            self.wandb = None\n\n        # ClearML\n        if clearml and \"clearml\" in self.include:\n            try:\n                self.clearml = ClearmlLogger(self.opt, self.hyp)\n            except Exception:\n                self.clearml = None\n                prefix = colorstr(\"ClearML: \")\n                LOGGER.warning(\n                    f\"{prefix}WARNING \u26a0\ufe0f ClearML is installed but not configured, skipping ClearML logging.\"\n                    f\" See https://docs.ultralytics.com/yolov5/tutorials/clearml_logging_integration#readme\"\n                )\n\n        else:\n            self.clearml = None\n\n        # Comet\n        if comet_ml and \"comet\" in self.include:\n            if isinstance(self.opt.resume, str) and self.opt.resume.startswith(\"comet://\"):\n                run_id = self.opt.resume.split(\"/\")[-1]\n                self.comet_logger = CometLogger(self.opt, self.hyp, run_id=run_id)\n\n            else:\n                self.comet_logger = CometLogger(self.opt, self.hyp)\n\n        else:\n            self.comet_logger = None\n\n    @property\n    def remote_dataset(self):\n        \"\"\"Fetches dataset dictionary from remote logging services like ClearML, Weights & Biases, or Comet ML.\"\"\"\n        data_dict = None\n        if self.clearml:\n            data_dict = self.clearml.data_dict\n        if self.wandb:\n            data_dict = self.wandb.data_dict\n        if self.comet_logger:\n            data_dict = self.comet_logger.data_dict\n\n        return data_dict\n\n    def on_train_start(self):\n        \"\"\"Initializes the training process for Comet ML logger if it's configured.\"\"\"\n        if self.comet_logger:\n            self.comet_logger.on_train_start()\n\n    def on_pretrain_routine_start(self):\n        \"\"\"Invokes pre-training routine start hook for Comet ML logger if available.\"\"\"\n        if self.comet_logger:\n            self.comet_logger.on_pretrain_routine_start()\n\n    def on_pretrain_routine_end(self, labels, names):\n        \"\"\"Callback that runs at the end of pre-training routine, logging label plots if enabled.\"\"\"\n        if self.plots:\n            plot_labels(labels, names, self.save_dir)\n            paths = self.save_dir.glob(\"*labels*.jpg\")  # training labels\n            if self.wandb:\n                self.wandb.log({\"Labels\": [wandb.Image(str(x), caption=x.name) for x in paths]})\n            if self.comet_logger:\n                self.comet_logger.on_pretrain_routine_end(paths)\n            if self.clearml:\n                for path in paths:\n                    self.clearml.log_plot(title=path.stem, plot_path=path)\n\n    def on_train_batch_end(self, model, ni, imgs, targets, paths, vals):\n        \"\"\"Logs training batch end events, plots images, and updates external loggers with batch-end data.\"\"\"\n        log_dict = dict(zip(self.keys[:3], vals))\n        # Callback runs on train batch end\n        # ni: number integrated batches (since train start)\n        if self.plots:\n            if ni < 3:\n                f = self.save_dir / f\"train_batch{ni}.jpg\"  # filename\n                plot_images(imgs, targets, paths, f)\n                if ni == 0 and self.tb and not self.opt.sync_bn:\n                    log_tensorboard_graph(self.tb, model, imgsz=(self.opt.imgsz, self.opt.imgsz))\n            if ni == 10 and (self.wandb or self.clearml):\n                files = sorted(self.save_dir.glob(\"train*.jpg\"))\n                if self.wandb:\n                    self.wandb.log({\"Mosaics\": [wandb.Image(str(f), caption=f.name) for f in files if f.exists()]})\n                if self.clearml:\n                    self.clearml.log_debug_samples(files, title=\"Mosaics\")\n\n        if self.comet_logger:\n            self.comet_logger.on_train_batch_end(log_dict, step=ni)\n\n    def on_train_epoch_end(self, epoch):\n        \"\"\"Callback that updates the current epoch in Weights & Biases at the end of a training epoch.\"\"\"\n        if self.wandb:\n            self.wandb.current_epoch = epoch + 1\n\n        if self.comet_logger:\n            self.comet_logger.on_train_epoch_end(epoch)\n\n    def on_val_start(self):\n        \"\"\"Callback that signals the start of a validation phase to the Comet logger.\"\"\"\n        if self.comet_logger:\n            self.comet_logger.on_val_start()\n\n    def on_val_image_end(self, pred, predn, path, names, im):\n        \"\"\"Callback that logs a validation image and its predictions to WandB or ClearML.\"\"\"\n        if self.wandb:\n            self.wandb.val_one_image(pred, predn, path, names, im)\n        if self.clearml:\n            self.clearml.log_image_with_boxes(path, pred, names, im)\n\n    def on_val_batch_end(self, batch_i, im, targets, paths, shapes, out):\n        \"\"\"Logs validation batch results to Comet ML during training at the end of each validation batch.\"\"\"\n        if self.comet_logger:\n            self.comet_logger.on_val_batch_end(batch_i, im, targets, paths, shapes, out)\n\n    def on_val_end(self, nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix):\n        \"\"\"Logs validation results to WandB or ClearML at the end of the validation process.\"\"\"\n        if self.wandb or self.clearml:\n            files = sorted(self.save_dir.glob(\"val*.jpg\"))\n        if self.wandb:\n            self.wandb.log({\"Validation\": [wandb.Image(str(f), caption=f.name) for f in files]})\n        if self.clearml:\n            self.clearml.log_debug_samples(files, title=\"Validation\")\n\n        if self.comet_logger:\n            self.comet_logger.on_val_end(nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix)\n\n    def on_fit_epoch_end(self, vals, epoch, best_fitness, fi):\n        \"\"\"Callback that logs metrics and saves them to CSV or NDJSON at the end of each fit (train+val) epoch.\"\"\"\n        x = dict(zip(self.keys, vals))\n        if self.csv:\n            file = self.save_dir / \"results.csv\"\n            n = len(x) + 1  # number of cols\n            s = \"\" if file.exists() else ((\"%20s,\" * n % tuple([\"epoch\"] + self.keys)).rstrip(\",\") + \"\\n\")  # add header\n            with open(file, \"a\") as f:\n                f.write(s + (\"%20.5g,\" * n % tuple([epoch] + vals)).rstrip(\",\") + \"\\n\")\n        if self.ndjson_console or self.ndjson_file:\n            json_data = json.dumps(dict(epoch=epoch, **x), default=_json_default)\n        if self.ndjson_console:\n            print(json_data)\n        if self.ndjson_file:\n            file = self.save_dir / \"results.ndjson\"\n            with open(file, \"a\") as f:\n                print(json_data, file=f)\n\n        if self.tb:\n            for k, v in x.items():\n                self.tb.add_scalar(k, v, epoch)\n        elif self.clearml:  # log to ClearML if TensorBoard not used\n            self.clearml.log_scalars(x, epoch)\n\n        if self.wandb:\n            if best_fitness == fi:\n                best_results = [epoch] + vals[3:7]\n                for i, name in enumerate(self.best_keys):\n                    self.wandb.wandb_run.summary[name] = best_results[i]  # log best results in the summary\n            self.wandb.log(x)\n            self.wandb.end_epoch()\n\n        if self.clearml:\n            self.clearml.current_epoch_logged_images = set()  # reset epoch image limit\n            self.clearml.current_epoch += 1\n\n        if self.comet_logger:\n            self.comet_logger.on_fit_epoch_end(x, epoch=epoch)\n\n    def on_model_save(self, last, epoch, final_epoch, best_fitness, fi):\n        \"\"\"Callback that handles model saving events, logging to Weights & Biases or ClearML if enabled.\"\"\"\n        if (epoch + 1) % self.opt.save_period == 0 and not final_epoch and self.opt.save_period != -1:\n            if self.wandb:\n                self.wandb.log_model(last.parent, self.opt, epoch, fi, best_model=best_fitness == fi)\n            if self.clearml:\n                self.clearml.task.update_output_model(\n                    model_path=str(last), model_name=\"Latest Model\", auto_delete_file=False\n                )\n\n        if self.comet_logger:\n            self.comet_logger.on_model_save(last, epoch, final_epoch, best_fitness, fi)\n\n    def on_train_end(self, last, best, epoch, results):\n        \"\"\"Callback that runs at the end of training to save plots and log results.\"\"\"\n        if self.plots:\n            plot_results(file=self.save_dir / \"results.csv\")  # save results.png\n        files = [\"results.png\", \"confusion_matrix.png\", *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\"))]\n        files = [(self.save_dir / f) for f in files if (self.save_dir / f).exists()]  # filter\n        self.logger.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n\n        if self.tb and not self.clearml:  # These images are already captured by ClearML by now, we don't want doubles\n            for f in files:\n                self.tb.add_image(f.stem, cv2.imread(str(f))[..., ::-1], epoch, dataformats=\"HWC\")\n\n        if self.wandb:\n            self.wandb.log(dict(zip(self.keys[3:10], results)))\n            self.wandb.log({\"Results\": [wandb.Image(str(f), caption=f.name) for f in files]})\n            # Calling wandb.log. TODO: Refactor this into WandbLogger.log_model\n            if not self.opt.evolve:\n                wandb.log_artifact(\n                    str(best if best.exists() else last),\n                    type=\"model\",\n                    name=f\"run_{self.wandb.wandb_run.id}_model\",\n                    aliases=[\"latest\", \"best\", \"stripped\"],\n                )\n            self.wandb.finish_run()\n\n        if self.clearml and not self.opt.evolve:\n            self.clearml.log_summary(dict(zip(self.keys[3:10], results)))\n            [self.clearml.log_plot(title=f.stem, plot_path=f) for f in files]\n            self.clearml.log_model(\n                str(best if best.exists() else last), \"Best Model\" if best.exists() else \"Last Model\", epoch\n            )\n\n        if self.comet_logger:\n            final_results = dict(zip(self.keys[3:10], results))\n            self.comet_logger.on_train_end(files, self.save_dir, last, best, epoch, final_results)\n\n    def on_params_update(self, params: dict):\n        \"\"\"Updates experiment hyperparameters or configurations in WandB, Comet, or ClearML.\"\"\"\n        if self.wandb:\n            self.wandb.wandb_run.config.update(params, allow_val_change=True)\n        if self.comet_logger:\n            self.comet_logger.on_params_update(params)\n        if self.clearml:\n            self.clearml.task.connect(params)\n\n\nclass GenericLogger:\n    \"\"\"\n    YOLOv5 General purpose logger for non-task specific logging\n    Usage: from utils.loggers import GenericLogger; logger = GenericLogger(...)\n    Arguments\n        opt:             Run arguments\n        console_logger:  Console logger\n        include:         loggers to include\n    \"\"\"\n\n    def __init__(self, opt, console_logger, include=(\"tb\", \"wandb\", \"clearml\")):\n        \"\"\"Initializes a generic logger with optional TensorBoard, W&B, and ClearML support.\"\"\"\n        self.save_dir = Path(opt.save_dir)\n        self.include = include\n        self.console_logger = console_logger\n        self.csv = self.save_dir / \"results.csv\"  # CSV logger\n        if \"tb\" in self.include:\n            prefix = colorstr(\"TensorBoard: \")\n            self.console_logger.info(\n                f\"{prefix}Start with 'tensorboard --logdir {self.save_dir.parent}', view at http://localhost:6006/\"\n            )\n            self.tb = SummaryWriter(str(self.save_dir))\n\n        if wandb and \"wandb\" in self.include:\n            self.wandb = wandb.init(\n                project=web_project_name(str(opt.project)), name=None if opt.name == \"exp\" else opt.name, config=opt\n            )\n        else:\n            self.wandb = None\n\n        if clearml and \"clearml\" in self.include:\n            try:\n                # Hyp is not available in classification mode\n                hyp = {} if \"hyp\" not in opt else opt.hyp\n                self.clearml = ClearmlLogger(opt, hyp)\n            except Exception:\n                self.clearml = None\n                prefix = colorstr(\"ClearML: \")\n                LOGGER.warning(\n                    f\"{prefix}WARNING \u26a0\ufe0f ClearML is installed but not configured, skipping ClearML logging.\"\n                    f\" See https://docs.ultralytics.com/yolov5/tutorials/clearml_logging_integration\"\n                )\n        else:\n            self.clearml = None\n\n    def log_metrics(self, metrics, epoch):\n        \"\"\"Logs metrics to CSV, TensorBoard, W&B, and ClearML; `metrics` is a dict, `epoch` is an int.\"\"\"\n        if self.csv:\n            keys, vals = list(metrics.keys()), list(metrics.values())\n            n = len(metrics) + 1  # number of cols\n            s = \"\" if self.csv.exists() else ((\"%23s,\" * n % tuple([\"epoch\"] + keys)).rstrip(\",\") + \"\\n\")  # header\n            with open(self.csv, \"a\") as f:\n                f.write(s + (\"%23.5g,\" * n % tuple([epoch] + vals)).rstrip(\",\") + \"\\n\")\n\n        if self.tb:\n            for k, v in metrics.items():\n                self.tb.add_scalar(k, v, epoch)\n\n        if self.wandb:\n            self.wandb.log(metrics, step=epoch)\n\n        if self.clearml:\n            self.clearml.log_scalars(metrics, epoch)\n\n    def log_images(self, files, name=\"Images\", epoch=0):\n        \"\"\"Logs images to all loggers with optional naming and epoch specification.\"\"\"\n        files = [Path(f) for f in (files if isinstance(files, (tuple, list)) else [files])]  # to Path\n        files = [f for f in files if f.exists()]  # filter by exists\n\n        if self.tb:\n            for f in files:\n                self.tb.add_image(f.stem, cv2.imread(str(f))[..., ::-1], epoch, dataformats=\"HWC\")\n\n        if self.wandb:\n            self.wandb.log({name: [wandb.Image(str(f), caption=f.name) for f in files]}, step=epoch)\n\n        if self.clearml:\n            if name == \"Results\":\n                [self.clearml.log_plot(f.stem, f) for f in files]\n            else:\n                self.clearml.log_debug_samples(files, title=name)\n\n    def log_graph(self, model, imgsz=(640, 640)):\n        \"\"\"Logs model graph to all configured loggers with specified input image size.\"\"\"\n        if self.tb:\n            log_tensorboard_graph(self.tb, model, imgsz)\n\n    def log_model(self, model_path, epoch=0, metadata=None):\n        \"\"\"Logs the model to all configured loggers with optional epoch and metadata.\"\"\"\n        if metadata is None:\n            metadata = {}\n        # Log model to all loggers\n        if self.wandb:\n            art = wandb.Artifact(name=f\"run_{wandb.run.id}_model\", type=\"model\", metadata=metadata)\n            art.add_file(str(model_path))\n            wandb.log_artifact(art)\n        if self.clearml:\n            self.clearml.log_model(model_path=model_path, model_name=model_path.stem)\n\n    def update_params(self, params):\n        \"\"\"Updates logged parameters in WandB and/or ClearML if enabled.\"\"\"\n        if self.wandb:\n            wandb.run.config.update(params, allow_val_change=True)\n        if self.clearml:\n            self.clearml.task.connect(params)\n\n\ndef log_tensorboard_graph(tb, model, imgsz=(640, 640)):\n    \"\"\"Logs the model graph to TensorBoard with specified image size and model.\"\"\"\n    try:\n        p = next(model.parameters())  # for device, type\n        imgsz = (imgsz, imgsz) if isinstance(imgsz, int) else imgsz  # expand\n        im = torch.zeros((1, 3, *imgsz)).to(p.device).type_as(p)  # input image (WARNING: must be zeros, not empty)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")  # suppress jit trace warning\n            tb.add_graph(torch.jit.trace(de_parallel(model), im, strict=False), [])\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f TensorBoard graph visualization failure {e}\")\n\n\ndef web_project_name(project):\n    \"\"\"Converts a local project name to a standardized web project name with optional suffixes.\"\"\"\n    if not project.startswith(\"runs/train\"):\n        return project\n    suffix = \"-Classify\" if project.endswith(\"-cls\") else \"-Segment\" if project.endswith(\"-seg\") else \"\"\n    return f\"YOLOv5{suffix}\"\n", "utils/loggers/clearml/clearml_utils.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"Main Logger class for ClearML experiment tracking.\"\"\"\n\nimport glob\nimport re\nfrom pathlib import Path\n\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport yaml\nfrom ultralytics.utils.plotting import Annotator, colors\n\ntry:\n    import clearml\n    from clearml import Dataset, Task\n\n    assert hasattr(clearml, \"__version__\")  # verify package import not local dir\nexcept (ImportError, AssertionError):\n    clearml = None\n\n\ndef construct_dataset(clearml_info_string):\n    \"\"\"Load in a clearml dataset and fill the internal data_dict with its contents.\"\"\"\n    dataset_id = clearml_info_string.replace(\"clearml://\", \"\")\n    dataset = Dataset.get(dataset_id=dataset_id)\n    dataset_root_path = Path(dataset.get_local_copy())\n\n    # We'll search for the yaml file definition in the dataset\n    yaml_filenames = list(glob.glob(str(dataset_root_path / \"*.yaml\")) + glob.glob(str(dataset_root_path / \"*.yml\")))\n    if len(yaml_filenames) > 1:\n        raise ValueError(\n            \"More than one yaml file was found in the dataset root, cannot determine which one contains \"\n            \"the dataset definition this way.\"\n        )\n    elif not yaml_filenames:\n        raise ValueError(\n            \"No yaml definition found in dataset root path, check that there is a correct yaml file \"\n            \"inside the dataset root path.\"\n        )\n    with open(yaml_filenames[0]) as f:\n        dataset_definition = yaml.safe_load(f)\n\n    assert set(\n        dataset_definition.keys()\n    ).issuperset(\n        {\"train\", \"test\", \"val\", \"nc\", \"names\"}\n    ), \"The right keys were not found in the yaml file, make sure it at least has the following keys: ('train', 'test', 'val', 'nc', 'names')\"\n\n    data_dict = {\n        \"train\": (\n            str((dataset_root_path / dataset_definition[\"train\"]).resolve()) if dataset_definition[\"train\"] else None\n        )\n    }\n    data_dict[\"test\"] = (\n        str((dataset_root_path / dataset_definition[\"test\"]).resolve()) if dataset_definition[\"test\"] else None\n    )\n    data_dict[\"val\"] = (\n        str((dataset_root_path / dataset_definition[\"val\"]).resolve()) if dataset_definition[\"val\"] else None\n    )\n    data_dict[\"nc\"] = dataset_definition[\"nc\"]\n    data_dict[\"names\"] = dataset_definition[\"names\"]\n\n    return data_dict\n\n\nclass ClearmlLogger:\n    \"\"\"\n    Log training runs, datasets, models, and predictions to ClearML.\n\n    This logger sends information to ClearML at app.clear.ml or to your own hosted server. By default, this information\n    includes hyperparameters, system configuration and metrics, model metrics, code information and basic data metrics\n    and analyses.\n\n    By providing additional command line arguments to train.py, datasets, models and predictions can also be logged.\n    \"\"\"\n\n    def __init__(self, opt, hyp):\n        \"\"\"\n        - Initialize ClearML Task, this object will capture the experiment\n        - Upload dataset version to ClearML Data if opt.upload_dataset is True\n\n        arguments:\n        opt (namespace) -- Commandline arguments for this run\n        hyp (dict) -- Hyperparameters for this run\n\n        \"\"\"\n        self.current_epoch = 0\n        # Keep tracked of amount of logged images to enforce a limit\n        self.current_epoch_logged_images = set()\n        # Maximum number of images to log to clearML per epoch\n        self.max_imgs_to_log_per_epoch = 16\n        # Get the interval of epochs when bounding box images should be logged\n        # Only for detection task though!\n        if \"bbox_interval\" in opt:\n            self.bbox_interval = opt.bbox_interval\n        self.clearml = clearml\n        self.task = None\n        self.data_dict = None\n        if self.clearml:\n            self.task = Task.init(\n                project_name=\"YOLOv5\" if str(opt.project).startswith(\"runs/\") else opt.project,\n                task_name=opt.name if opt.name != \"exp\" else \"Training\",\n                tags=[\"YOLOv5\"],\n                output_uri=True,\n                reuse_last_task_id=opt.exist_ok,\n                auto_connect_frameworks={\"pytorch\": False, \"matplotlib\": False},\n                # We disconnect pytorch auto-detection, because we added manual model save points in the code\n            )\n            # ClearML's hooks will already grab all general parameters\n            # Only the hyperparameters coming from the yaml config file\n            # will have to be added manually!\n            self.task.connect(hyp, name=\"Hyperparameters\")\n            self.task.connect(opt, name=\"Args\")\n\n            # Make sure the code is easily remotely runnable by setting the docker image to use by the remote agent\n            self.task.set_base_docker(\n                \"ultralytics/yolov5:latest\",\n                docker_arguments='--ipc=host -e=\"CLEARML_AGENT_SKIP_PYTHON_ENV_INSTALL=1\"',\n                docker_setup_bash_script=\"pip install clearml\",\n            )\n\n            # Get ClearML Dataset Version if requested\n            if opt.data.startswith(\"clearml://\"):\n                # data_dict should have the following keys:\n                # names, nc (number of classes), test, train, val (all three relative paths to ../datasets)\n                self.data_dict = construct_dataset(opt.data)\n                # Set data to data_dict because wandb will crash without this information and opt is the best way\n                # to give it to them\n                opt.data = self.data_dict\n\n    def log_scalars(self, metrics, epoch):\n        \"\"\"\n        Log scalars/metrics to ClearML.\n\n        arguments:\n        metrics (dict) Metrics in dict format: {\"metrics/mAP\": 0.8, ...}\n        epoch (int) iteration number for the current set of metrics\n        \"\"\"\n        for k, v in metrics.items():\n            title, series = k.split(\"/\")\n            self.task.get_logger().report_scalar(title, series, v, epoch)\n\n    def log_model(self, model_path, model_name, epoch=0):\n        \"\"\"\n        Log model weights to ClearML.\n\n        arguments:\n        model_path (PosixPath or str) Path to the model weights\n        model_name (str) Name of the model visible in ClearML\n        epoch (int) Iteration / epoch of the model weights\n        \"\"\"\n        self.task.update_output_model(\n            model_path=str(model_path), name=model_name, iteration=epoch, auto_delete_file=False\n        )\n\n    def log_summary(self, metrics):\n        \"\"\"\n        Log final metrics to a summary table.\n\n        arguments:\n        metrics (dict) Metrics in dict format: {\"metrics/mAP\": 0.8, ...}\n        \"\"\"\n        for k, v in metrics.items():\n            self.task.get_logger().report_single_value(k, v)\n\n    def log_plot(self, title, plot_path):\n        \"\"\"\n        Log image as plot in the plot section of ClearML.\n\n        arguments:\n        title (str) Title of the plot\n        plot_path (PosixPath or str) Path to the saved image file\n        \"\"\"\n        img = mpimg.imread(plot_path)\n        fig = plt.figure()\n        ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=\"auto\", xticks=[], yticks=[])  # no ticks\n        ax.imshow(img)\n\n        self.task.get_logger().report_matplotlib_figure(title, \"\", figure=fig, report_interactive=False)\n\n    def log_debug_samples(self, files, title=\"Debug Samples\"):\n        \"\"\"\n        Log files (images) as debug samples in the ClearML task.\n\n        arguments:\n        files (List(PosixPath)) a list of file paths in PosixPath format\n        title (str) A title that groups together images with the same values\n        \"\"\"\n        for f in files:\n            if f.exists():\n                it = re.search(r\"_batch(\\d+)\", f.name)\n                iteration = int(it.groups()[0]) if it else 0\n                self.task.get_logger().report_image(\n                    title=title, series=f.name.replace(f\"_batch{iteration}\", \"\"), local_path=str(f), iteration=iteration\n                )\n\n    def log_image_with_boxes(self, image_path, boxes, class_names, image, conf_threshold=0.25):\n        \"\"\"\n        Draw the bounding boxes on a single image and report the result as a ClearML debug sample.\n\n        arguments:\n        image_path (PosixPath) the path the original image file\n        boxes (list): list of scaled predictions in the format - [xmin, ymin, xmax, ymax, confidence, class]\n        class_names (dict): dict containing mapping of class int to class name\n        image (Tensor): A torch tensor containing the actual image data\n        \"\"\"\n        if (\n            len(self.current_epoch_logged_images) < self.max_imgs_to_log_per_epoch\n            and self.current_epoch >= 0\n            and (self.current_epoch % self.bbox_interval == 0 and image_path not in self.current_epoch_logged_images)\n        ):\n            im = np.ascontiguousarray(np.moveaxis(image.mul(255).clamp(0, 255).byte().cpu().numpy(), 0, 2))\n            annotator = Annotator(im=im, pil=True)\n            for i, (conf, class_nr, box) in enumerate(zip(boxes[:, 4], boxes[:, 5], boxes[:, :4])):\n                color = colors(i)\n\n                class_name = class_names[int(class_nr)]\n                confidence_percentage = round(float(conf) * 100, 2)\n                label = f\"{class_name}: {confidence_percentage}%\"\n\n                if conf > conf_threshold:\n                    annotator.rectangle(box.cpu().numpy(), outline=color)\n                    annotator.box_label(box.cpu().numpy(), label=label, color=color)\n\n            annotated_image = annotator.result()\n            self.task.get_logger().report_image(\n                title=\"Bounding Boxes\", series=image_path.name, iteration=self.current_epoch, image=annotated_image\n            )\n            self.current_epoch_logged_images.add(image_path)\n", "utils/loggers/clearml/hpo.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nfrom clearml import Task\n\n# Connecting ClearML with the current process,\n# from here on everything is logged automatically\nfrom clearml.automation import HyperParameterOptimizer, UniformParameterRange\nfrom clearml.automation.optuna import OptimizerOptuna\n\ntask = Task.init(\n    project_name=\"Hyper-Parameter Optimization\",\n    task_name=\"YOLOv5\",\n    task_type=Task.TaskTypes.optimizer,\n    reuse_last_task_id=False,\n)\n\n# Example use case:\noptimizer = HyperParameterOptimizer(\n    # This is the experiment we want to optimize\n    base_task_id=\"<your_template_task_id>\",\n    # here we define the hyper-parameters to optimize\n    # Notice: The parameter name should exactly match what you see in the UI: <section_name>/<parameter>\n    # For Example, here we see in the base experiment a section Named: \"General\"\n    # under it a parameter named \"batch_size\", this becomes \"General/batch_size\"\n    # If you have `argparse` for example, then arguments will appear under the \"Args\" section,\n    # and you should instead pass \"Args/batch_size\"\n    hyper_parameters=[\n        UniformParameterRange(\"Hyperparameters/lr0\", min_value=1e-5, max_value=1e-1),\n        UniformParameterRange(\"Hyperparameters/lrf\", min_value=0.01, max_value=1.0),\n        UniformParameterRange(\"Hyperparameters/momentum\", min_value=0.6, max_value=0.98),\n        UniformParameterRange(\"Hyperparameters/weight_decay\", min_value=0.0, max_value=0.001),\n        UniformParameterRange(\"Hyperparameters/warmup_epochs\", min_value=0.0, max_value=5.0),\n        UniformParameterRange(\"Hyperparameters/warmup_momentum\", min_value=0.0, max_value=0.95),\n        UniformParameterRange(\"Hyperparameters/warmup_bias_lr\", min_value=0.0, max_value=0.2),\n        UniformParameterRange(\"Hyperparameters/box\", min_value=0.02, max_value=0.2),\n        UniformParameterRange(\"Hyperparameters/cls\", min_value=0.2, max_value=4.0),\n        UniformParameterRange(\"Hyperparameters/cls_pw\", min_value=0.5, max_value=2.0),\n        UniformParameterRange(\"Hyperparameters/obj\", min_value=0.2, max_value=4.0),\n        UniformParameterRange(\"Hyperparameters/obj_pw\", min_value=0.5, max_value=2.0),\n        UniformParameterRange(\"Hyperparameters/iou_t\", min_value=0.1, max_value=0.7),\n        UniformParameterRange(\"Hyperparameters/anchor_t\", min_value=2.0, max_value=8.0),\n        UniformParameterRange(\"Hyperparameters/fl_gamma\", min_value=0.0, max_value=4.0),\n        UniformParameterRange(\"Hyperparameters/hsv_h\", min_value=0.0, max_value=0.1),\n        UniformParameterRange(\"Hyperparameters/hsv_s\", min_value=0.0, max_value=0.9),\n        UniformParameterRange(\"Hyperparameters/hsv_v\", min_value=0.0, max_value=0.9),\n        UniformParameterRange(\"Hyperparameters/degrees\", min_value=0.0, max_value=45.0),\n        UniformParameterRange(\"Hyperparameters/translate\", min_value=0.0, max_value=0.9),\n        UniformParameterRange(\"Hyperparameters/scale\", min_value=0.0, max_value=0.9),\n        UniformParameterRange(\"Hyperparameters/shear\", min_value=0.0, max_value=10.0),\n        UniformParameterRange(\"Hyperparameters/perspective\", min_value=0.0, max_value=0.001),\n        UniformParameterRange(\"Hyperparameters/flipud\", min_value=0.0, max_value=1.0),\n        UniformParameterRange(\"Hyperparameters/fliplr\", min_value=0.0, max_value=1.0),\n        UniformParameterRange(\"Hyperparameters/mosaic\", min_value=0.0, max_value=1.0),\n        UniformParameterRange(\"Hyperparameters/mixup\", min_value=0.0, max_value=1.0),\n        UniformParameterRange(\"Hyperparameters/copy_paste\", min_value=0.0, max_value=1.0),\n    ],\n    # this is the objective metric we want to maximize/minimize\n    objective_metric_title=\"metrics\",\n    objective_metric_series=\"mAP_0.5\",\n    # now we decide if we want to maximize it or minimize it (accuracy we maximize)\n    objective_metric_sign=\"max\",\n    # let us limit the number of concurrent experiments,\n    # this in turn will make sure we don't bombard the scheduler with experiments.\n    # if we have an auto-scaler connected, this, by proxy, will limit the number of machine\n    max_number_of_concurrent_tasks=1,\n    # this is the optimizer class (actually doing the optimization)\n    # Currently, we can choose from GridSearch, RandomSearch or OptimizerBOHB (Bayesian optimization Hyper-Band)\n    optimizer_class=OptimizerOptuna,\n    # If specified only the top K performing Tasks will be kept, the others will be automatically archived\n    save_top_k_tasks_only=5,  # 5,\n    compute_time_limit=None,\n    total_max_jobs=20,\n    min_iteration_per_job=None,\n    max_iteration_per_job=None,\n)\n\n# report every 10 seconds, this is way too often, but we are testing here\noptimizer.set_report_period(10 / 60)\n# You can also use the line below instead to run all the optimizer tasks locally, without using queues or agent\n# an_optimizer.start_locally(job_complete_callback=job_complete_callback)\n# set the time limit for the optimization process (2 hours)\noptimizer.set_time_limit(in_minutes=120.0)\n# Start the optimization process in the local environment\noptimizer.start_locally()\n# wait until process is done (notice we are controlling the optimization process in the background)\noptimizer.wait()\n# make sure background optimization stopped\noptimizer.stop()\n\nprint(\"We are done, good bye\")\n", "utils/loggers/clearml/__init__.py": "", "utils/loggers/comet/comet_utils.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport logging\nimport os\nfrom urllib.parse import urlparse\n\ntry:\n    import comet_ml\nexcept ImportError:\n    comet_ml = None\n\nimport yaml\n\nlogger = logging.getLogger(__name__)\n\nCOMET_PREFIX = \"comet://\"\nCOMET_MODEL_NAME = os.getenv(\"COMET_MODEL_NAME\", \"yolov5\")\nCOMET_DEFAULT_CHECKPOINT_FILENAME = os.getenv(\"COMET_DEFAULT_CHECKPOINT_FILENAME\", \"last.pt\")\n\n\ndef download_model_checkpoint(opt, experiment):\n    \"\"\"Downloads YOLOv5 model checkpoint from Comet ML experiment, updating `opt.weights` with download path.\"\"\"\n    model_dir = f\"{opt.project}/{experiment.name}\"\n    os.makedirs(model_dir, exist_ok=True)\n\n    model_name = COMET_MODEL_NAME\n    model_asset_list = experiment.get_model_asset_list(model_name)\n\n    if len(model_asset_list) == 0:\n        logger.error(f\"COMET ERROR: No checkpoints found for model name : {model_name}\")\n        return\n\n    model_asset_list = sorted(\n        model_asset_list,\n        key=lambda x: x[\"step\"],\n        reverse=True,\n    )\n    logged_checkpoint_map = {asset[\"fileName\"]: asset[\"assetId\"] for asset in model_asset_list}\n\n    resource_url = urlparse(opt.weights)\n    checkpoint_filename = resource_url.query\n\n    if checkpoint_filename:\n        asset_id = logged_checkpoint_map.get(checkpoint_filename)\n    else:\n        asset_id = logged_checkpoint_map.get(COMET_DEFAULT_CHECKPOINT_FILENAME)\n        checkpoint_filename = COMET_DEFAULT_CHECKPOINT_FILENAME\n\n    if asset_id is None:\n        logger.error(f\"COMET ERROR: Checkpoint {checkpoint_filename} not found in the given Experiment\")\n        return\n\n    try:\n        logger.info(f\"COMET INFO: Downloading checkpoint {checkpoint_filename}\")\n        asset_filename = checkpoint_filename\n\n        model_binary = experiment.get_asset(asset_id, return_type=\"binary\", stream=False)\n        model_download_path = f\"{model_dir}/{asset_filename}\"\n        with open(model_download_path, \"wb\") as f:\n            f.write(model_binary)\n\n        opt.weights = model_download_path\n\n    except Exception as e:\n        logger.warning(\"COMET WARNING: Unable to download checkpoint from Comet\")\n        logger.exception(e)\n\n\ndef set_opt_parameters(opt, experiment):\n    \"\"\"\n    Update the opts Namespace with parameters from Comet's ExistingExperiment when resuming a run.\n\n    Args:\n        opt (argparse.Namespace): Namespace of command line options\n        experiment (comet_ml.APIExperiment): Comet API Experiment object\n    \"\"\"\n    asset_list = experiment.get_asset_list()\n    resume_string = opt.resume\n\n    for asset in asset_list:\n        if asset[\"fileName\"] == \"opt.yaml\":\n            asset_id = asset[\"assetId\"]\n            asset_binary = experiment.get_asset(asset_id, return_type=\"binary\", stream=False)\n            opt_dict = yaml.safe_load(asset_binary)\n            for key, value in opt_dict.items():\n                setattr(opt, key, value)\n            opt.resume = resume_string\n\n    # Save hyperparameters to YAML file\n    # Necessary to pass checks in training script\n    save_dir = f\"{opt.project}/{experiment.name}\"\n    os.makedirs(save_dir, exist_ok=True)\n\n    hyp_yaml_path = f\"{save_dir}/hyp.yaml\"\n    with open(hyp_yaml_path, \"w\") as f:\n        yaml.dump(opt.hyp, f)\n    opt.hyp = hyp_yaml_path\n\n\ndef check_comet_weights(opt):\n    \"\"\"\n    Downloads model weights from Comet and updates the weights path to point to saved weights location.\n\n    Args:\n        opt (argparse.Namespace): Command Line arguments passed\n            to YOLOv5 training script\n\n    Returns:\n        None/bool: Return True if weights are successfully downloaded\n            else return None\n    \"\"\"\n    if comet_ml is None:\n        return\n\n    if isinstance(opt.weights, str) and opt.weights.startswith(COMET_PREFIX):\n        api = comet_ml.API()\n        resource = urlparse(opt.weights)\n        experiment_path = f\"{resource.netloc}{resource.path}\"\n        experiment = api.get(experiment_path)\n        download_model_checkpoint(opt, experiment)\n        return True\n\n    return None\n\n\ndef check_comet_resume(opt):\n    \"\"\"\n    Restores run parameters to its original state based on the model checkpoint and logged Experiment parameters.\n\n    Args:\n        opt (argparse.Namespace): Command Line arguments passed\n            to YOLOv5 training script\n\n    Returns:\n        None/bool: Return True if the run is restored successfully\n            else return None\n    \"\"\"\n    if comet_ml is None:\n        return\n\n    if isinstance(opt.resume, str) and opt.resume.startswith(COMET_PREFIX):\n        api = comet_ml.API()\n        resource = urlparse(opt.resume)\n        experiment_path = f\"{resource.netloc}{resource.path}\"\n        experiment = api.get(experiment_path)\n        set_opt_parameters(opt, experiment)\n        download_model_checkpoint(opt, experiment)\n\n        return True\n\n    return None\n", "utils/loggers/comet/hpo.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport argparse\nimport json\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\n\nimport comet_ml\n\nlogger = logging.getLogger(__name__)\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[3]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\n\nfrom train import train\nfrom utils.callbacks import Callbacks\nfrom utils.general import increment_path\nfrom utils.torch_utils import select_device\n\n# Project Configuration\nconfig = comet_ml.config.get_config()\nCOMET_PROJECT_NAME = config.get_string(os.getenv(\"COMET_PROJECT_NAME\"), \"comet.project_name\", default=\"yolov5\")\n\n\ndef get_args(known=False):\n    \"\"\"Parses command-line arguments for YOLOv5 training, supporting configuration of weights, data paths,\n    hyperparameters, and more.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=ROOT / \"yolov5s.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--cfg\", type=str, default=\"\", help=\"model.yaml path\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--hyp\", type=str, default=ROOT / \"data/hyps/hyp.scratch-low.yaml\", help=\"hyperparameters path\")\n    parser.add_argument(\"--epochs\", type=int, default=300, help=\"total training epochs\")\n    parser.add_argument(\"--batch-size\", type=int, default=16, help=\"total batch size for all GPUs, -1 for autobatch\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"train, val image size (pixels)\")\n    parser.add_argument(\"--rect\", action=\"store_true\", help=\"rectangular training\")\n    parser.add_argument(\"--resume\", nargs=\"?\", const=True, default=False, help=\"resume most recent training\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"only save final checkpoint\")\n    parser.add_argument(\"--noval\", action=\"store_true\", help=\"only validate final epoch\")\n    parser.add_argument(\"--noautoanchor\", action=\"store_true\", help=\"disable AutoAnchor\")\n    parser.add_argument(\"--noplots\", action=\"store_true\", help=\"save no plot files\")\n    parser.add_argument(\"--evolve\", type=int, nargs=\"?\", const=300, help=\"evolve hyperparameters for x generations\")\n    parser.add_argument(\"--bucket\", type=str, default=\"\", help=\"gsutil bucket\")\n    parser.add_argument(\"--cache\", type=str, nargs=\"?\", const=\"ram\", help='--cache images in \"ram\" (default) or \"disk\"')\n    parser.add_argument(\"--image-weights\", action=\"store_true\", help=\"use weighted image selection for training\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--multi-scale\", action=\"store_true\", help=\"vary img-size +/- 50%%\")\n    parser.add_argument(\"--single-cls\", action=\"store_true\", help=\"train multi-class data as single-class\")\n    parser.add_argument(\"--optimizer\", type=str, choices=[\"SGD\", \"Adam\", \"AdamW\"], default=\"SGD\", help=\"optimizer\")\n    parser.add_argument(\"--sync-bn\", action=\"store_true\", help=\"use SyncBatchNorm, only available in DDP mode\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/train\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--quad\", action=\"store_true\", help=\"quad dataloader\")\n    parser.add_argument(\"--cos-lr\", action=\"store_true\", help=\"cosine LR scheduler\")\n    parser.add_argument(\"--label-smoothing\", type=float, default=0.0, help=\"Label smoothing epsilon\")\n    parser.add_argument(\"--patience\", type=int, default=100, help=\"EarlyStopping patience (epochs without improvement)\")\n    parser.add_argument(\"--freeze\", nargs=\"+\", type=int, default=[0], help=\"Freeze layers: backbone=10, first3=0 1 2\")\n    parser.add_argument(\"--save-period\", type=int, default=-1, help=\"Save checkpoint every x epochs (disabled if < 1)\")\n    parser.add_argument(\"--seed\", type=int, default=0, help=\"Global training seed\")\n    parser.add_argument(\"--local_rank\", type=int, default=-1, help=\"Automatic DDP Multi-GPU argument, do not modify\")\n\n    # Weights & Biases arguments\n    parser.add_argument(\"--entity\", default=None, help=\"W&B: Entity\")\n    parser.add_argument(\"--upload_dataset\", nargs=\"?\", const=True, default=False, help='W&B: Upload data, \"val\" option')\n    parser.add_argument(\"--bbox_interval\", type=int, default=-1, help=\"W&B: Set bounding-box image logging interval\")\n    parser.add_argument(\"--artifact_alias\", type=str, default=\"latest\", help=\"W&B: Version of dataset artifact to use\")\n\n    # Comet Arguments\n    parser.add_argument(\"--comet_optimizer_config\", type=str, help=\"Comet: Path to a Comet Optimizer Config File.\")\n    parser.add_argument(\"--comet_optimizer_id\", type=str, help=\"Comet: ID of the Comet Optimizer sweep.\")\n    parser.add_argument(\"--comet_optimizer_objective\", type=str, help=\"Comet: Set to 'minimize' or 'maximize'.\")\n    parser.add_argument(\"--comet_optimizer_metric\", type=str, help=\"Comet: Metric to Optimize.\")\n    parser.add_argument(\n        \"--comet_optimizer_workers\",\n        type=int,\n        default=1,\n        help=\"Comet: Number of Parallel Workers to use with the Comet Optimizer.\",\n    )\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()\n\n\ndef run(parameters, opt):\n    \"\"\"Executes YOLOv5 training with given hyperparameters and options, setting up device and training directories.\"\"\"\n    hyp_dict = {k: v for k, v in parameters.items() if k not in [\"epochs\", \"batch_size\"]}\n\n    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok or opt.evolve))\n    opt.batch_size = parameters.get(\"batch_size\")\n    opt.epochs = parameters.get(\"epochs\")\n\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    train(hyp_dict, opt, device, callbacks=Callbacks())\n\n\nif __name__ == \"__main__\":\n    opt = get_args(known=True)\n\n    opt.weights = str(opt.weights)\n    opt.cfg = str(opt.cfg)\n    opt.data = str(opt.data)\n    opt.project = str(opt.project)\n\n    optimizer_id = os.getenv(\"COMET_OPTIMIZER_ID\")\n    if optimizer_id is None:\n        with open(opt.comet_optimizer_config) as f:\n            optimizer_config = json.load(f)\n        optimizer = comet_ml.Optimizer(optimizer_config)\n    else:\n        optimizer = comet_ml.Optimizer(optimizer_id)\n\n    opt.comet_optimizer_id = optimizer.id\n    status = optimizer.status()\n\n    opt.comet_optimizer_objective = status[\"spec\"][\"objective\"]\n    opt.comet_optimizer_metric = status[\"spec\"][\"metric\"]\n\n    logger.info(\"COMET INFO: Starting Hyperparameter Sweep\")\n    for parameter in optimizer.get_parameters():\n        run(parameter[\"parameters\"], opt)\n", "utils/loggers/comet/__init__.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\nimport glob\nimport json\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[3]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\n\ntry:\n    import comet_ml\n\n    # Project Configuration\n    config = comet_ml.config.get_config()\n    COMET_PROJECT_NAME = config.get_string(os.getenv(\"COMET_PROJECT_NAME\"), \"comet.project_name\", default=\"yolov5\")\nexcept ImportError:\n    comet_ml = None\n    COMET_PROJECT_NAME = None\n\nimport PIL\nimport torch\nimport torchvision.transforms as T\nimport yaml\n\nfrom utils.dataloaders import img2label_paths\nfrom utils.general import check_dataset, scale_boxes, xywh2xyxy\nfrom utils.metrics import box_iou\n\nCOMET_PREFIX = \"comet://\"\n\nCOMET_MODE = os.getenv(\"COMET_MODE\", \"online\")\n\n# Model Saving Settings\nCOMET_MODEL_NAME = os.getenv(\"COMET_MODEL_NAME\", \"yolov5\")\n\n# Dataset Artifact Settings\nCOMET_UPLOAD_DATASET = os.getenv(\"COMET_UPLOAD_DATASET\", \"false\").lower() == \"true\"\n\n# Evaluation Settings\nCOMET_LOG_CONFUSION_MATRIX = os.getenv(\"COMET_LOG_CONFUSION_MATRIX\", \"true\").lower() == \"true\"\nCOMET_LOG_PREDICTIONS = os.getenv(\"COMET_LOG_PREDICTIONS\", \"true\").lower() == \"true\"\nCOMET_MAX_IMAGE_UPLOADS = int(os.getenv(\"COMET_MAX_IMAGE_UPLOADS\", 100))\n\n# Confusion Matrix Settings\nCONF_THRES = float(os.getenv(\"CONF_THRES\", 0.001))\nIOU_THRES = float(os.getenv(\"IOU_THRES\", 0.6))\n\n# Batch Logging Settings\nCOMET_LOG_BATCH_METRICS = os.getenv(\"COMET_LOG_BATCH_METRICS\", \"false\").lower() == \"true\"\nCOMET_BATCH_LOGGING_INTERVAL = os.getenv(\"COMET_BATCH_LOGGING_INTERVAL\", 1)\nCOMET_PREDICTION_LOGGING_INTERVAL = os.getenv(\"COMET_PREDICTION_LOGGING_INTERVAL\", 1)\nCOMET_LOG_PER_CLASS_METRICS = os.getenv(\"COMET_LOG_PER_CLASS_METRICS\", \"false\").lower() == \"true\"\n\nRANK = int(os.getenv(\"RANK\", -1))\n\nto_pil = T.ToPILImage()\n\n\nclass CometLogger:\n    \"\"\"Log metrics, parameters, source code, models and much more with Comet.\"\"\"\n\n    def __init__(self, opt, hyp, run_id=None, job_type=\"Training\", **experiment_kwargs) -> None:\n        self.job_type = job_type\n        self.opt = opt\n        self.hyp = hyp\n\n        # Comet Flags\n        self.comet_mode = COMET_MODE\n\n        self.save_model = opt.save_period > -1\n        self.model_name = COMET_MODEL_NAME\n\n        # Batch Logging Settings\n        self.log_batch_metrics = COMET_LOG_BATCH_METRICS\n        self.comet_log_batch_interval = COMET_BATCH_LOGGING_INTERVAL\n\n        # Dataset Artifact Settings\n        self.upload_dataset = self.opt.upload_dataset or COMET_UPLOAD_DATASET\n        self.resume = self.opt.resume\n\n        # Default parameters to pass to Experiment objects\n        self.default_experiment_kwargs = {\n            \"log_code\": False,\n            \"log_env_gpu\": True,\n            \"log_env_cpu\": True,\n            \"project_name\": COMET_PROJECT_NAME,\n        }\n        self.default_experiment_kwargs.update(experiment_kwargs)\n        self.experiment = self._get_experiment(self.comet_mode, run_id)\n        self.experiment.set_name(self.opt.name)\n\n        self.data_dict = self.check_dataset(self.opt.data)\n        self.class_names = self.data_dict[\"names\"]\n        self.num_classes = self.data_dict[\"nc\"]\n\n        self.logged_images_count = 0\n        self.max_images = COMET_MAX_IMAGE_UPLOADS\n\n        if run_id is None:\n            self.experiment.log_other(\"Created from\", \"YOLOv5\")\n            if not isinstance(self.experiment, comet_ml.OfflineExperiment):\n                workspace, project_name, experiment_id = self.experiment.url.split(\"/\")[-3:]\n                self.experiment.log_other(\n                    \"Run Path\",\n                    f\"{workspace}/{project_name}/{experiment_id}\",\n                )\n            self.log_parameters(vars(opt))\n            self.log_parameters(self.opt.hyp)\n            self.log_asset_data(\n                self.opt.hyp,\n                name=\"hyperparameters.json\",\n                metadata={\"type\": \"hyp-config-file\"},\n            )\n            self.log_asset(\n                f\"{self.opt.save_dir}/opt.yaml\",\n                metadata={\"type\": \"opt-config-file\"},\n            )\n\n        self.comet_log_confusion_matrix = COMET_LOG_CONFUSION_MATRIX\n\n        if hasattr(self.opt, \"conf_thres\"):\n            self.conf_thres = self.opt.conf_thres\n        else:\n            self.conf_thres = CONF_THRES\n        if hasattr(self.opt, \"iou_thres\"):\n            self.iou_thres = self.opt.iou_thres\n        else:\n            self.iou_thres = IOU_THRES\n\n        self.log_parameters({\"val_iou_threshold\": self.iou_thres, \"val_conf_threshold\": self.conf_thres})\n\n        self.comet_log_predictions = COMET_LOG_PREDICTIONS\n        if self.opt.bbox_interval == -1:\n            self.comet_log_prediction_interval = 1 if self.opt.epochs < 10 else self.opt.epochs // 10\n        else:\n            self.comet_log_prediction_interval = self.opt.bbox_interval\n\n        if self.comet_log_predictions:\n            self.metadata_dict = {}\n            self.logged_image_names = []\n\n        self.comet_log_per_class_metrics = COMET_LOG_PER_CLASS_METRICS\n\n        self.experiment.log_others(\n            {\n                \"comet_mode\": COMET_MODE,\n                \"comet_max_image_uploads\": COMET_MAX_IMAGE_UPLOADS,\n                \"comet_log_per_class_metrics\": COMET_LOG_PER_CLASS_METRICS,\n                \"comet_log_batch_metrics\": COMET_LOG_BATCH_METRICS,\n                \"comet_log_confusion_matrix\": COMET_LOG_CONFUSION_MATRIX,\n                \"comet_model_name\": COMET_MODEL_NAME,\n            }\n        )\n\n        # Check if running the Experiment with the Comet Optimizer\n        if hasattr(self.opt, \"comet_optimizer_id\"):\n            self.experiment.log_other(\"optimizer_id\", self.opt.comet_optimizer_id)\n            self.experiment.log_other(\"optimizer_objective\", self.opt.comet_optimizer_objective)\n            self.experiment.log_other(\"optimizer_metric\", self.opt.comet_optimizer_metric)\n            self.experiment.log_other(\"optimizer_parameters\", json.dumps(self.hyp))\n\n    def _get_experiment(self, mode, experiment_id=None):\n        \"\"\"Returns a new or existing Comet.ml experiment based on mode and optional experiment_id.\"\"\"\n        if mode == \"offline\":\n            return (\n                comet_ml.ExistingOfflineExperiment(\n                    previous_experiment=experiment_id,\n                    **self.default_experiment_kwargs,\n                )\n                if experiment_id is not None\n                else comet_ml.OfflineExperiment(\n                    **self.default_experiment_kwargs,\n                )\n            )\n        try:\n            if experiment_id is not None:\n                return comet_ml.ExistingExperiment(\n                    previous_experiment=experiment_id,\n                    **self.default_experiment_kwargs,\n                )\n\n            return comet_ml.Experiment(**self.default_experiment_kwargs)\n\n        except ValueError:\n            logger.warning(\n                \"COMET WARNING: \"\n                \"Comet credentials have not been set. \"\n                \"Comet will default to offline logging. \"\n                \"Please set your credentials to enable online logging.\"\n            )\n            return self._get_experiment(\"offline\", experiment_id)\n\n        return\n\n    def log_metrics(self, log_dict, **kwargs):\n        \"\"\"Logs metrics to the current experiment, accepting a dictionary of metric names and values.\"\"\"\n        self.experiment.log_metrics(log_dict, **kwargs)\n\n    def log_parameters(self, log_dict, **kwargs):\n        \"\"\"Logs parameters to the current experiment, accepting a dictionary of parameter names and values.\"\"\"\n        self.experiment.log_parameters(log_dict, **kwargs)\n\n    def log_asset(self, asset_path, **kwargs):\n        \"\"\"Logs a file or directory as an asset to the current experiment.\"\"\"\n        self.experiment.log_asset(asset_path, **kwargs)\n\n    def log_asset_data(self, asset, **kwargs):\n        \"\"\"Logs in-memory data as an asset to the current experiment, with optional kwargs.\"\"\"\n        self.experiment.log_asset_data(asset, **kwargs)\n\n    def log_image(self, img, **kwargs):\n        \"\"\"Logs an image to the current experiment with optional kwargs.\"\"\"\n        self.experiment.log_image(img, **kwargs)\n\n    def log_model(self, path, opt, epoch, fitness_score, best_model=False):\n        \"\"\"Logs model checkpoint to experiment with path, options, epoch, fitness, and best model flag.\"\"\"\n        if not self.save_model:\n            return\n\n        model_metadata = {\n            \"fitness_score\": fitness_score[-1],\n            \"epochs_trained\": epoch + 1,\n            \"save_period\": opt.save_period,\n            \"total_epochs\": opt.epochs,\n        }\n\n        model_files = glob.glob(f\"{path}/*.pt\")\n        for model_path in model_files:\n            name = Path(model_path).name\n\n            self.experiment.log_model(\n                self.model_name,\n                file_or_folder=model_path,\n                file_name=name,\n                metadata=model_metadata,\n                overwrite=True,\n            )\n\n    def check_dataset(self, data_file):\n        \"\"\"Validates the dataset configuration by loading the YAML file specified in `data_file`.\"\"\"\n        with open(data_file) as f:\n            data_config = yaml.safe_load(f)\n\n        path = data_config.get(\"path\")\n        if path and path.startswith(COMET_PREFIX):\n            path = data_config[\"path\"].replace(COMET_PREFIX, \"\")\n            return self.download_dataset_artifact(path)\n        self.log_asset(self.opt.data, metadata={\"type\": \"data-config-file\"})\n\n        return check_dataset(data_file)\n\n    def log_predictions(self, image, labelsn, path, shape, predn):\n        \"\"\"Logs predictions with IOU filtering, given image, labels, path, shape, and predictions.\"\"\"\n        if self.logged_images_count >= self.max_images:\n            return\n        detections = predn[predn[:, 4] > self.conf_thres]\n        iou = box_iou(labelsn[:, 1:], detections[:, :4])\n        mask, _ = torch.where(iou > self.iou_thres)\n        if len(mask) == 0:\n            return\n\n        filtered_detections = detections[mask]\n        filtered_labels = labelsn[mask]\n\n        image_id = path.split(\"/\")[-1].split(\".\")[0]\n        image_name = f\"{image_id}_curr_epoch_{self.experiment.curr_epoch}\"\n        if image_name not in self.logged_image_names:\n            native_scale_image = PIL.Image.open(path)\n            self.log_image(native_scale_image, name=image_name)\n            self.logged_image_names.append(image_name)\n\n        metadata = [\n            {\n                \"label\": f\"{self.class_names[int(cls)]}-gt\",\n                \"score\": 100,\n                \"box\": {\"x\": xyxy[0], \"y\": xyxy[1], \"x2\": xyxy[2], \"y2\": xyxy[3]},\n            }\n            for cls, *xyxy in filtered_labels.tolist()\n        ]\n        metadata.extend(\n            {\n                \"label\": f\"{self.class_names[int(cls)]}\",\n                \"score\": conf * 100,\n                \"box\": {\"x\": xyxy[0], \"y\": xyxy[1], \"x2\": xyxy[2], \"y2\": xyxy[3]},\n            }\n            for *xyxy, conf, cls in filtered_detections.tolist()\n        )\n        self.metadata_dict[image_name] = metadata\n        self.logged_images_count += 1\n\n        return\n\n    def preprocess_prediction(self, image, labels, shape, pred):\n        \"\"\"Processes prediction data, resizing labels and adding dataset metadata.\"\"\"\n        nl, _ = labels.shape[0], pred.shape[0]\n\n        # Predictions\n        if self.opt.single_cls:\n            pred[:, 5] = 0\n\n        predn = pred.clone()\n        scale_boxes(image.shape[1:], predn[:, :4], shape[0], shape[1])\n\n        labelsn = None\n        if nl:\n            tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n            scale_boxes(image.shape[1:], tbox, shape[0], shape[1])  # native-space labels\n            labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n            scale_boxes(image.shape[1:], predn[:, :4], shape[0], shape[1])  # native-space pred\n\n        return predn, labelsn\n\n    def add_assets_to_artifact(self, artifact, path, asset_path, split):\n        \"\"\"Adds image and label assets to a wandb artifact given dataset split and paths.\"\"\"\n        img_paths = sorted(glob.glob(f\"{asset_path}/*\"))\n        label_paths = img2label_paths(img_paths)\n\n        for image_file, label_file in zip(img_paths, label_paths):\n            image_logical_path, label_logical_path = map(lambda x: os.path.relpath(x, path), [image_file, label_file])\n\n            try:\n                artifact.add(\n                    image_file,\n                    logical_path=image_logical_path,\n                    metadata={\"split\": split},\n                )\n                artifact.add(\n                    label_file,\n                    logical_path=label_logical_path,\n                    metadata={\"split\": split},\n                )\n            except ValueError as e:\n                logger.error(\"COMET ERROR: Error adding file to Artifact. Skipping file.\")\n                logger.error(f\"COMET ERROR: {e}\")\n                continue\n\n        return artifact\n\n    def upload_dataset_artifact(self):\n        \"\"\"Uploads a YOLOv5 dataset as an artifact to the Comet.ml platform.\"\"\"\n        dataset_name = self.data_dict.get(\"dataset_name\", \"yolov5-dataset\")\n        path = str((ROOT / Path(self.data_dict[\"path\"])).resolve())\n\n        metadata = self.data_dict.copy()\n        for key in [\"train\", \"val\", \"test\"]:\n            split_path = metadata.get(key)\n            if split_path is not None:\n                metadata[key] = split_path.replace(path, \"\")\n\n        artifact = comet_ml.Artifact(name=dataset_name, artifact_type=\"dataset\", metadata=metadata)\n        for key in metadata.keys():\n            if key in [\"train\", \"val\", \"test\"]:\n                if isinstance(self.upload_dataset, str) and (key != self.upload_dataset):\n                    continue\n\n                asset_path = self.data_dict.get(key)\n                if asset_path is not None:\n                    artifact = self.add_assets_to_artifact(artifact, path, asset_path, key)\n\n        self.experiment.log_artifact(artifact)\n\n        return\n\n    def download_dataset_artifact(self, artifact_path):\n        \"\"\"Downloads a dataset artifact to a specified directory using the experiment's logged artifact.\"\"\"\n        logged_artifact = self.experiment.get_artifact(artifact_path)\n        artifact_save_dir = str(Path(self.opt.save_dir) / logged_artifact.name)\n        logged_artifact.download(artifact_save_dir)\n\n        metadata = logged_artifact.metadata\n        data_dict = metadata.copy()\n        data_dict[\"path\"] = artifact_save_dir\n\n        metadata_names = metadata.get(\"names\")\n        if isinstance(metadata_names, dict):\n            data_dict[\"names\"] = {int(k): v for k, v in metadata.get(\"names\").items()}\n        elif isinstance(metadata_names, list):\n            data_dict[\"names\"] = {int(k): v for k, v in zip(range(len(metadata_names)), metadata_names)}\n        else:\n            raise \"Invalid 'names' field in dataset yaml file. Please use a list or dictionary\"\n\n        return self.update_data_paths(data_dict)\n\n    def update_data_paths(self, data_dict):\n        \"\"\"Updates data paths in the dataset dictionary, defaulting 'path' to an empty string if not present.\"\"\"\n        path = data_dict.get(\"path\", \"\")\n\n        for split in [\"train\", \"val\", \"test\"]:\n            if data_dict.get(split):\n                split_path = data_dict.get(split)\n                data_dict[split] = (\n                    f\"{path}/{split_path}\" if isinstance(split, str) else [f\"{path}/{x}\" for x in split_path]\n                )\n\n        return data_dict\n\n    def on_pretrain_routine_end(self, paths):\n        \"\"\"Called at the end of pretraining routine to handle paths if training is not being resumed.\"\"\"\n        if self.opt.resume:\n            return\n\n        for path in paths:\n            self.log_asset(str(path))\n\n        if self.upload_dataset and not self.resume:\n            self.upload_dataset_artifact()\n\n        return\n\n    def on_train_start(self):\n        \"\"\"Logs hyperparameters at the start of training.\"\"\"\n        self.log_parameters(self.hyp)\n\n    def on_train_epoch_start(self):\n        \"\"\"Called at the start of each training epoch.\"\"\"\n        return\n\n    def on_train_epoch_end(self, epoch):\n        \"\"\"Updates the current epoch in the experiment tracking at the end of each epoch.\"\"\"\n        self.experiment.curr_epoch = epoch\n\n        return\n\n    def on_train_batch_start(self):\n        \"\"\"Called at the start of each training batch.\"\"\"\n        return\n\n    def on_train_batch_end(self, log_dict, step):\n        \"\"\"Callback function that updates and logs metrics at the end of each training batch if conditions are met.\"\"\"\n        self.experiment.curr_step = step\n        if self.log_batch_metrics and (step % self.comet_log_batch_interval == 0):\n            self.log_metrics(log_dict, step=step)\n\n        return\n\n    def on_train_end(self, files, save_dir, last, best, epoch, results):\n        \"\"\"Logs metadata and optionally saves model files at the end of training.\"\"\"\n        if self.comet_log_predictions:\n            curr_epoch = self.experiment.curr_epoch\n            self.experiment.log_asset_data(self.metadata_dict, \"image-metadata.json\", epoch=curr_epoch)\n\n        for f in files:\n            self.log_asset(f, metadata={\"epoch\": epoch})\n        self.log_asset(f\"{save_dir}/results.csv\", metadata={\"epoch\": epoch})\n\n        if not self.opt.evolve:\n            model_path = str(best if best.exists() else last)\n            name = Path(model_path).name\n            if self.save_model:\n                self.experiment.log_model(\n                    self.model_name,\n                    file_or_folder=model_path,\n                    file_name=name,\n                    overwrite=True,\n                )\n\n        # Check if running Experiment with Comet Optimizer\n        if hasattr(self.opt, \"comet_optimizer_id\"):\n            metric = results.get(self.opt.comet_optimizer_metric)\n            self.experiment.log_other(\"optimizer_metric_value\", metric)\n\n        self.finish_run()\n\n    def on_val_start(self):\n        \"\"\"Called at the start of validation, currently a placeholder with no functionality.\"\"\"\n        return\n\n    def on_val_batch_start(self):\n        \"\"\"Placeholder called at the start of a validation batch with no current functionality.\"\"\"\n        return\n\n    def on_val_batch_end(self, batch_i, images, targets, paths, shapes, outputs):\n        \"\"\"Callback executed at the end of a validation batch, conditionally logs predictions to Comet ML.\"\"\"\n        if not (self.comet_log_predictions and ((batch_i + 1) % self.comet_log_prediction_interval == 0)):\n            return\n\n        for si, pred in enumerate(outputs):\n            if len(pred) == 0:\n                continue\n\n            image = images[si]\n            labels = targets[targets[:, 0] == si, 1:]\n            shape = shapes[si]\n            path = paths[si]\n            predn, labelsn = self.preprocess_prediction(image, labels, shape, pred)\n            if labelsn is not None:\n                self.log_predictions(image, labelsn, path, shape, predn)\n\n        return\n\n    def on_val_end(self, nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix):\n        \"\"\"Logs per-class metrics to Comet.ml after validation if enabled and more than one class exists.\"\"\"\n        if self.comet_log_per_class_metrics and self.num_classes > 1:\n            for i, c in enumerate(ap_class):\n                class_name = self.class_names[c]\n                self.experiment.log_metrics(\n                    {\n                        \"mAP@.5\": ap50[i],\n                        \"mAP@.5:.95\": ap[i],\n                        \"precision\": p[i],\n                        \"recall\": r[i],\n                        \"f1\": f1[i],\n                        \"true_positives\": tp[i],\n                        \"false_positives\": fp[i],\n                        \"support\": nt[c],\n                    },\n                    prefix=class_name,\n                )\n\n        if self.comet_log_confusion_matrix:\n            epoch = self.experiment.curr_epoch\n            class_names = list(self.class_names.values())\n            class_names.append(\"background\")\n            num_classes = len(class_names)\n\n            self.experiment.log_confusion_matrix(\n                matrix=confusion_matrix.matrix,\n                max_categories=num_classes,\n                labels=class_names,\n                epoch=epoch,\n                column_label=\"Actual Category\",\n                row_label=\"Predicted Category\",\n                file_name=f\"confusion-matrix-epoch-{epoch}.json\",\n            )\n\n    def on_fit_epoch_end(self, result, epoch):\n        \"\"\"Logs metrics at the end of each training epoch.\"\"\"\n        self.log_metrics(result, epoch=epoch)\n\n    def on_model_save(self, last, epoch, final_epoch, best_fitness, fi):\n        \"\"\"Callback to save model checkpoints periodically if conditions are met.\"\"\"\n        if ((epoch + 1) % self.opt.save_period == 0 and not final_epoch) and self.opt.save_period != -1:\n            self.log_model(last.parent, self.opt, epoch, fi, best_model=best_fitness == fi)\n\n    def on_params_update(self, params):\n        \"\"\"Logs updated parameters during training.\"\"\"\n        self.log_parameters(params)\n\n    def finish_run(self):\n        \"\"\"Ends the current experiment and logs its completion.\"\"\"\n        self.experiment.end()\n", "utils/loggers/wandb/wandb_utils.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\n# WARNING \u26a0\ufe0f wandb is deprecated and will be removed in future release.\n# See supported integrations at https://github.com/ultralytics/yolov5#integrations\n\nimport logging\nimport os\nimport sys\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\nfrom utils.general import LOGGER, colorstr\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[3]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nRANK = int(os.getenv(\"RANK\", -1))\nDEPRECATION_WARNING = (\n    f\"{colorstr('wandb')}: WARNING \u26a0\ufe0f wandb is deprecated and will be removed in a future release. \"\n    f'See supported integrations at https://github.com/ultralytics/yolov5#integrations.'\n)\n\ntry:\n    import wandb\n\n    assert hasattr(wandb, \"__version__\")  # verify package import not local dir\n    LOGGER.warning(DEPRECATION_WARNING)\nexcept (ImportError, AssertionError):\n    wandb = None\n\n\nclass WandbLogger:\n    \"\"\"\n    Log training runs, datasets, models, and predictions to Weights & Biases.\n\n    This logger sends information to W&B at wandb.ai. By default, this information includes hyperparameters, system\n    configuration and metrics, model metrics, and basic data metrics and analyses.\n\n    By providing additional command line arguments to train.py, datasets, models and predictions can also be logged.\n\n    For more on how this logger is used, see the Weights & Biases documentation:\n    https://docs.wandb.com/guides/integrations/yolov5\n    \"\"\"\n\n    def __init__(self, opt, run_id=None, job_type=\"Training\"):\n        \"\"\"\n        - Initialize WandbLogger instance\n        - Upload dataset if opt.upload_dataset is True\n        - Setup training processes if job_type is 'Training'\n\n        arguments:\n        opt (namespace) -- Commandline arguments for this run\n        run_id (str) -- Run ID of W&B run to be resumed\n        job_type (str) -- To set the job_type for this run\n\n        \"\"\"\n        # Pre-training routine --\n        self.job_type = job_type\n        self.wandb, self.wandb_run = wandb, wandb.run if wandb else None\n        self.val_artifact, self.train_artifact = None, None\n        self.train_artifact_path, self.val_artifact_path = None, None\n        self.result_artifact = None\n        self.val_table, self.result_table = None, None\n        self.max_imgs_to_log = 16\n        self.data_dict = None\n        if self.wandb:\n            self.wandb_run = wandb.run or wandb.init(\n                config=opt,\n                resume=\"allow\",\n                project=\"YOLOv5\" if opt.project == \"runs/train\" else Path(opt.project).stem,\n                entity=opt.entity,\n                name=opt.name if opt.name != \"exp\" else None,\n                job_type=job_type,\n                id=run_id,\n                allow_val_change=True,\n            )\n\n        if self.wandb_run and self.job_type == \"Training\":\n            if isinstance(opt.data, dict):\n                # This means another dataset manager has already processed the dataset info (e.g. ClearML)\n                # and they will have stored the already processed dict in opt.data\n                self.data_dict = opt.data\n            self.setup_training(opt)\n\n    def setup_training(self, opt):\n        \"\"\"\n        Setup the necessary processes for training YOLO models:\n          - Attempt to download model checkpoint and dataset artifacts if opt.resume stats with WANDB_ARTIFACT_PREFIX\n          - Update data_dict, to contain info of previous run if resumed and the paths of dataset artifact if downloaded\n          - Setup log_dict, initialize bbox_interval\n\n        arguments:\n        opt (namespace) -- commandline arguments for this run\n\n        \"\"\"\n        self.log_dict, self.current_epoch = {}, 0\n        self.bbox_interval = opt.bbox_interval\n        if isinstance(opt.resume, str):\n            model_dir, _ = self.download_model_artifact(opt)\n            if model_dir:\n                self.weights = Path(model_dir) / \"last.pt\"\n                config = self.wandb_run.config\n                opt.weights, opt.save_period, opt.batch_size, opt.bbox_interval, opt.epochs, opt.hyp, opt.imgsz = (\n                    str(self.weights),\n                    config.save_period,\n                    config.batch_size,\n                    config.bbox_interval,\n                    config.epochs,\n                    config.hyp,\n                    config.imgsz,\n                )\n\n        if opt.bbox_interval == -1:\n            self.bbox_interval = opt.bbox_interval = (opt.epochs // 10) if opt.epochs > 10 else 1\n            if opt.evolve or opt.noplots:\n                self.bbox_interval = opt.bbox_interval = opt.epochs + 1  # disable bbox_interval\n\n    def log_model(self, path, opt, epoch, fitness_score, best_model=False):\n        \"\"\"\n        Log the model checkpoint as W&B artifact.\n\n        arguments:\n        path (Path)   -- Path of directory containing the checkpoints\n        opt (namespace) -- Command line arguments for this run\n        epoch (int)  -- Current epoch number\n        fitness_score (float) -- fitness score for current epoch\n        best_model (boolean) -- Boolean representing if the current checkpoint is the best yet.\n        \"\"\"\n        model_artifact = wandb.Artifact(\n            f\"run_{wandb.run.id}_model\",\n            type=\"model\",\n            metadata={\n                \"original_url\": str(path),\n                \"epochs_trained\": epoch + 1,\n                \"save period\": opt.save_period,\n                \"project\": opt.project,\n                \"total_epochs\": opt.epochs,\n                \"fitness_score\": fitness_score,\n            },\n        )\n        model_artifact.add_file(str(path / \"last.pt\"), name=\"last.pt\")\n        wandb.log_artifact(\n            model_artifact,\n            aliases=[\n                \"latest\",\n                \"last\",\n                f\"epoch {str(self.current_epoch)}\",\n                \"best\" if best_model else \"\",\n            ],\n        )\n        LOGGER.info(f\"Saving model artifact on epoch {epoch + 1}\")\n\n    def val_one_image(self, pred, predn, path, names, im):\n        \"\"\"Evaluates model prediction for a single image, returning metrics and visualizations.\"\"\"\n        pass\n\n    def log(self, log_dict):\n        \"\"\"\n        Save the metrics to the logging dictionary.\n\n        arguments:\n        log_dict (Dict) -- metrics/media to be logged in current step\n        \"\"\"\n        if self.wandb_run:\n            for key, value in log_dict.items():\n                self.log_dict[key] = value\n\n    def end_epoch(self):\n        \"\"\"\n        Commit the log_dict, model artifacts and Tables to W&B and flush the log_dict.\n\n        arguments:\n        best_result (boolean): Boolean representing if the result of this evaluation is best or not\n        \"\"\"\n        if self.wandb_run:\n            with all_logging_disabled():\n                try:\n                    wandb.log(self.log_dict)\n                except BaseException as e:\n                    LOGGER.info(\n                        f\"An error occurred in wandb logger. The training will proceed without interruption. More info\\n{e}\"\n                    )\n                    self.wandb_run.finish()\n                    self.wandb_run = None\n                self.log_dict = {}\n\n    def finish_run(self):\n        \"\"\"Log metrics if any and finish the current W&B run.\"\"\"\n        if self.wandb_run:\n            if self.log_dict:\n                with all_logging_disabled():\n                    wandb.log(self.log_dict)\n            wandb.run.finish()\n            LOGGER.warning(DEPRECATION_WARNING)\n\n\n@contextmanager\ndef all_logging_disabled(highest_level=logging.CRITICAL):\n    \"\"\"source - https://gist.github.com/simon-weber/7853144\n    A context manager that will prevent any logging messages triggered during the body from being processed.\n    :param highest_level: the maximum logging level in use.\n      This would only need to be changed if a custom level greater than CRITICAL is defined.\n    \"\"\"\n    previous_level = logging.root.manager.disable\n    logging.disable(highest_level)\n    try:\n        yield\n    finally:\n        logging.disable(previous_level)\n", "utils/loggers/wandb/__init__.py": "", "utils/aws/resume.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n# Resume all interrupted trainings in yolov5/ dir including DDP trainings\n# Usage: $ python utils/aws/resume.py\n\nimport os\nimport sys\nfrom pathlib import Path\n\nimport torch\nimport yaml\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[2]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\n\nport = 0  # --master_port\npath = Path(\"\").resolve()\nfor last in path.rglob(\"*/**/last.pt\"):\n    ckpt = torch.load(last)\n    if ckpt[\"optimizer\"] is None:\n        continue\n\n    # Load opt.yaml\n    with open(last.parent.parent / \"opt.yaml\", errors=\"ignore\") as f:\n        opt = yaml.safe_load(f)\n\n    # Get device count\n    d = opt[\"device\"].split(\",\")  # devices\n    nd = len(d)  # number of devices\n    ddp = nd > 1 or (nd == 0 and torch.cuda.device_count() > 1)  # distributed data parallel\n\n    if ddp:  # multi-GPU\n        port += 1\n        cmd = f\"python -m torch.distributed.run --nproc_per_node {nd} --master_port {port} train.py --resume {last}\"\n    else:  # single-GPU\n        cmd = f\"python train.py --resume {last}\"\n\n    cmd += \" > /dev/null 2>&1 &\"  # redirect output to dev/null and run in daemon thread\n    print(cmd)\n    os.system(cmd)\n", "utils/aws/__init__.py": "", "segment/val.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nValidate a trained YOLOv5 segment model on a segment dataset.\n\nUsage:\n    $ bash data/scripts/get_coco.sh --val --segments  # download COCO-segments val split (1G, 5000 images)\n    $ python segment/val.py --weights yolov5s-seg.pt --data coco.yaml --img 640  # validate COCO-segments\n\nUsage - formats:\n    $ python segment/val.py --weights yolov5s-seg.pt                 # PyTorch\n                                      yolov5s-seg.torchscript        # TorchScript\n                                      yolov5s-seg.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                      yolov5s-seg_openvino_label     # OpenVINO\n                                      yolov5s-seg.engine             # TensorRT\n                                      yolov5s-seg.mlmodel            # CoreML (macOS-only)\n                                      yolov5s-seg_saved_model        # TensorFlow SavedModel\n                                      yolov5s-seg.pb                 # TensorFlow GraphDef\n                                      yolov5s-seg.tflite             # TensorFlow Lite\n                                      yolov5s-seg_edgetpu.tflite     # TensorFlow Edge TPU\n                                      yolov5s-seg_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport subprocess\nimport sys\nfrom multiprocessing.pool import ThreadPool\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nimport torch.nn.functional as F\n\nfrom models.common import DetectMultiBackend\nfrom models.yolo import SegmentationModel\nfrom utils.callbacks import Callbacks\nfrom utils.general import (\n    LOGGER,\n    NUM_THREADS,\n    TQDM_BAR_FORMAT,\n    Profile,\n    check_dataset,\n    check_img_size,\n    check_requirements,\n    check_yaml,\n    coco80_to_coco91_class,\n    colorstr,\n    increment_path,\n    non_max_suppression,\n    print_args,\n    scale_boxes,\n    xywh2xyxy,\n    xyxy2xywh,\n)\nfrom utils.metrics import ConfusionMatrix, box_iou\nfrom utils.plots import output_to_target, plot_val_study\nfrom utils.segment.dataloaders import create_dataloader\nfrom utils.segment.general import mask_iou, process_mask, process_mask_native, scale_image\nfrom utils.segment.metrics import Metrics, ap_per_class_box_and_mask\nfrom utils.segment.plots import plot_images_and_masks\nfrom utils.torch_utils import de_parallel, select_device, smart_inference_mode\n\n\ndef save_one_txt(predn, save_conf, shape, file):\n    \"\"\"Saves detection results in txt format; includes class, xywh (normalized), optionally confidence if `save_conf` is\n    True.\n    \"\"\"\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls in predn.tolist():\n        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n        with open(file, \"a\") as f:\n            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n\ndef save_one_json(predn, jdict, path, class_map, pred_masks):\n    \"\"\"\n    Saves a JSON file with detection results including bounding boxes, category IDs, scores, and segmentation masks.\n\n    Example JSON result: {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}.\n    \"\"\"\n    from pycocotools.mask import encode\n\n    def single_encode(x):\n        rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n        rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n        return rle\n\n    image_id = int(path.stem) if path.stem.isnumeric() else path.stem\n    box = xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    pred_masks = np.transpose(pred_masks, (2, 0, 1))\n    with ThreadPool(NUM_THREADS) as pool:\n        rles = pool.map(single_encode, pred_masks)\n    for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):\n        jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": class_map[int(p[5])],\n                \"bbox\": [round(x, 3) for x in b],\n                \"score\": round(p[4], 5),\n                \"segmentation\": rles[i],\n            }\n        )\n\n\ndef process_batch(detections, labels, iouv, pred_masks=None, gt_masks=None, overlap=False, masks=False):\n    \"\"\"\n    Return correct prediction matrix\n    Arguments:\n        detections (array[N, 6]), x1, y1, x2, y2, conf, class\n        labels (array[M, 5]), class, x1, y1, x2, y2\n    Returns:\n        correct (array[N, 10]), for 10 IoU levels\n    \"\"\"\n    if masks:\n        if overlap:\n            nl = len(labels)\n            index = torch.arange(nl, device=gt_masks.device).view(nl, 1, 1) + 1\n            gt_masks = gt_masks.repeat(nl, 1, 1)  # shape(1,640,640) -> (n,640,640)\n            gt_masks = torch.where(gt_masks == index, 1.0, 0.0)\n        if gt_masks.shape[1:] != pred_masks.shape[1:]:\n            gt_masks = F.interpolate(gt_masks[None], pred_masks.shape[1:], mode=\"bilinear\", align_corners=False)[0]\n            gt_masks = gt_masks.gt_(0.5)\n        iou = mask_iou(gt_masks.view(gt_masks.shape[0], -1), pred_masks.view(pred_masks.shape[0], -1))\n    else:  # boxes\n        iou = box_iou(labels[:, 1:], detections[:, :4])\n\n    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)\n    correct_class = labels[:, 0:1] == detections[:, 5]\n    for i in range(len(iouv)):\n        x = torch.where((iou >= iouv[i]) & correct_class)  # IoU > threshold and classes match\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()  # [label, detect, iou]\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                # matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n            correct[matches[:, 1].astype(int), i] = True\n    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)\n\n\n@smart_inference_mode()\ndef run(\n    data,\n    weights=None,  # model.pt path(s)\n    batch_size=32,  # batch size\n    imgsz=640,  # inference size (pixels)\n    conf_thres=0.001,  # confidence threshold\n    iou_thres=0.6,  # NMS IoU threshold\n    max_det=300,  # maximum detections per image\n    task=\"val\",  # train, val, test, speed or study\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    workers=8,  # max dataloader workers (per RANK in DDP mode)\n    single_cls=False,  # treat as single-class dataset\n    augment=False,  # augmented inference\n    verbose=False,  # verbose output\n    save_txt=False,  # save results to *.txt\n    save_hybrid=False,  # save label+prediction hybrid results to *.txt\n    save_conf=False,  # save confidences in --save-txt labels\n    save_json=False,  # save a COCO-JSON results file\n    project=ROOT / \"runs/val-seg\",  # save to project/name\n    name=\"exp\",  # save to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    half=True,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    model=None,\n    dataloader=None,\n    save_dir=Path(\"\"),\n    plots=True,\n    overlap=False,\n    mask_downsample_ratio=1,\n    compute_loss=None,\n    callbacks=Callbacks(),\n):\n    if save_json:\n        check_requirements(\"pycocotools>=2.0.6\")\n        process = process_mask_native  # more accurate\n    else:\n        process = process_mask  # faster\n\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != \"cpu\"  # half precision only supported on CUDA\n        model.half() if half else model.float()\n        nm = de_parallel(model).model[-1].nm  # number of masks\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        (save_dir / \"labels\" if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        nm = de_parallel(model).model.model[-1].nm if isinstance(model, SegmentationModel) else 32  # number of masks\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f\"Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models\")\n\n        # Data\n        data = check_dataset(data)  # check\n\n    # Configure\n    model.eval()\n    cuda = device.type != \"cpu\"\n    is_coco = isinstance(data.get(\"val\"), str) and data[\"val\"].endswith(f\"coco{os.sep}val2017.txt\")  # COCO dataset\n    nc = 1 if single_cls else int(data[\"nc\"])  # number of classes\n    iouv = torch.linspace(0.5, 0.95, 10, device=device)  # iou vector for mAP@0.5:0.95\n    niou = iouv.numel()\n\n    # Dataloader\n    if not training:\n        if pt and not single_cls:  # check --weights are trained on --data\n            ncm = model.model.nc\n            assert ncm == nc, (\n                f\"{weights} ({ncm} classes) trained on different --data than what you passed ({nc} \"\n                f\"classes). Pass correct combination of --weights and --data that are trained together.\"\n            )\n        model.warmup(imgsz=(1 if pt else batch_size, 3, imgsz, imgsz))  # warmup\n        pad, rect = (0.0, False) if task == \"speed\" else (0.5, pt)  # square inference for benchmarks\n        task = task if task in (\"train\", \"val\", \"test\") else \"val\"  # path to train/val/test images\n        dataloader = create_dataloader(\n            data[task],\n            imgsz,\n            batch_size,\n            stride,\n            single_cls,\n            pad=pad,\n            rect=rect,\n            workers=workers,\n            prefix=colorstr(f\"{task}: \"),\n            overlap_mask=overlap,\n            mask_downsample_ratio=mask_downsample_ratio,\n        )[0]\n\n    seen = 0\n    confusion_matrix = ConfusionMatrix(nc=nc)\n    names = model.names if hasattr(model, \"names\") else model.module.names  # get class names\n    if isinstance(names, (list, tuple)):  # old format\n        names = dict(enumerate(names))\n    class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\n    s = (\"%22s\" + \"%11s\" * 10) % (\n        \"Class\",\n        \"Images\",\n        \"Instances\",\n        \"Box(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n        \"Mask(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n    )\n    dt = Profile(device=device), Profile(device=device), Profile(device=device)\n    metrics = Metrics()\n    loss = torch.zeros(4, device=device)\n    jdict, stats = [], []\n    # callbacks.run('on_val_start')\n    pbar = tqdm(dataloader, desc=s, bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for batch_i, (im, targets, paths, shapes, masks) in enumerate(pbar):\n        # callbacks.run('on_val_batch_start')\n        with dt[0]:\n            if cuda:\n                im = im.to(device, non_blocking=True)\n                targets = targets.to(device)\n                masks = masks.to(device)\n            masks = masks.float()\n            im = im.half() if half else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            nb, _, height, width = im.shape  # batch size, channels, height, width\n\n        # Inference\n        with dt[1]:\n            preds, protos, train_out = model(im) if compute_loss else (*model(im, augment=augment)[:2], None)\n\n        # Loss\n        if compute_loss:\n            loss += compute_loss((train_out, protos), targets, masks)[1]  # box, obj, cls\n\n        # NMS\n        targets[:, 2:] *= torch.tensor((width, height, width, height), device=device)  # to pixels\n        lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\n        with dt[2]:\n            preds = non_max_suppression(\n                preds, conf_thres, iou_thres, labels=lb, multi_label=True, agnostic=single_cls, max_det=max_det, nm=nm\n            )\n\n        # Metrics\n        plot_masks = []  # masks for plotting\n        for si, (pred, proto) in enumerate(zip(preds, protos)):\n            labels = targets[targets[:, 0] == si, 1:]\n            nl, npr = labels.shape[0], pred.shape[0]  # number of labels, predictions\n            path, shape = Path(paths[si]), shapes[si][0]\n            correct_masks = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            correct_bboxes = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            seen += 1\n\n            if npr == 0:\n                if nl:\n                    stats.append((correct_masks, correct_bboxes, *torch.zeros((2, 0), device=device), labels[:, 0]))\n                    if plots:\n                        confusion_matrix.process_batch(detections=None, labels=labels[:, 0])\n                continue\n\n            # Masks\n            midx = [si] if overlap else targets[:, 0] == si\n            gt_masks = masks[midx]\n            pred_masks = process(proto, pred[:, 6:], pred[:, :4], shape=im[si].shape[1:])\n\n            # Predictions\n            if single_cls:\n                pred[:, 5] = 0\n            predn = pred.clone()\n            scale_boxes(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\n\n            # Evaluate\n            if nl:\n                tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n                scale_boxes(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\n                labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n                correct_bboxes = process_batch(predn, labelsn, iouv)\n                correct_masks = process_batch(predn, labelsn, iouv, pred_masks, gt_masks, overlap=overlap, masks=True)\n                if plots:\n                    confusion_matrix.process_batch(predn, labelsn)\n            stats.append((correct_masks, correct_bboxes, pred[:, 4], pred[:, 5], labels[:, 0]))  # (conf, pcls, tcls)\n\n            pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)\n            if plots and batch_i < 3:\n                plot_masks.append(pred_masks[:15])  # filter top 15 to plot\n\n            # Save/log\n            if save_txt:\n                save_one_txt(predn, save_conf, shape, file=save_dir / \"labels\" / f\"{path.stem}.txt\")\n            if save_json:\n                pred_masks = scale_image(\n                    im[si].shape[1:], pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(), shape, shapes[si][1]\n                )\n                save_one_json(predn, jdict, path, class_map, pred_masks)  # append to COCO-JSON dictionary\n            # callbacks.run('on_val_image_end', pred, predn, path, names, im[si])\n\n        # Plot images\n        if plots and batch_i < 3:\n            if len(plot_masks):\n                plot_masks = torch.cat(plot_masks, dim=0)\n            plot_images_and_masks(im, targets, masks, paths, save_dir / f\"val_batch{batch_i}_labels.jpg\", names)\n            plot_images_and_masks(\n                im,\n                output_to_target(preds, max_det=15),\n                plot_masks,\n                paths,\n                save_dir / f\"val_batch{batch_i}_pred.jpg\",\n                names,\n            )  # pred\n\n        # callbacks.run('on_val_batch_end')\n\n    # Compute metrics\n    stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*stats)]  # to numpy\n    if len(stats) and stats[0].any():\n        results = ap_per_class_box_and_mask(*stats, plot=plots, save_dir=save_dir, names=names)\n        metrics.update(results)\n    nt = np.bincount(stats[4].astype(int), minlength=nc)  # number of targets per class\n\n    # Print results\n    pf = \"%22s\" + \"%11i\" * 2 + \"%11.3g\" * 8  # print format\n    LOGGER.info(pf % (\"all\", seen, nt.sum(), *metrics.mean_results()))\n    if nt.sum() == 0:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f no labels found in {task} set, can not compute metrics without labels\")\n\n    # Print results per class\n    if (verbose or (nc < 50 and not training)) and nc > 1 and len(stats):\n        for i, c in enumerate(metrics.ap_class_index):\n            LOGGER.info(pf % (names[c], seen, nt[c], *metrics.class_result(i)))\n\n    # Print speeds\n    t = tuple(x.t / seen * 1e3 for x in dt)  # speeds per image\n    if not training:\n        shape = (batch_size, 3, imgsz, imgsz)\n        LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {shape}\" % t)\n\n    # Plots\n    if plots:\n        confusion_matrix.plot(save_dir=save_dir, names=list(names.values()))\n    # callbacks.run('on_val_end')\n\n    mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask = metrics.mean_results()\n\n    # Save JSON\n    if save_json and len(jdict):\n        w = Path(weights[0] if isinstance(weights, list) else weights).stem if weights is not None else \"\"  # weights\n        anno_json = str(Path(\"../datasets/coco/annotations/instances_val2017.json\"))  # annotations\n        pred_json = str(save_dir / f\"{w}_predictions.json\")  # predictions\n        LOGGER.info(f\"\\nEvaluating pycocotools mAP... saving {pred_json}...\")\n        with open(pred_json, \"w\") as f:\n            json.dump(jdict, f)\n\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            from pycocotools.coco import COCO\n            from pycocotools.cocoeval import COCOeval\n\n            anno = COCO(anno_json)  # init annotations api\n            pred = anno.loadRes(pred_json)  # init predictions api\n            results = []\n            for eval in COCOeval(anno, pred, \"bbox\"), COCOeval(anno, pred, \"segm\"):\n                if is_coco:\n                    eval.params.imgIds = [int(Path(x).stem) for x in dataloader.dataset.im_files]  # img ID to evaluate\n                eval.evaluate()\n                eval.accumulate()\n                eval.summarize()\n                results.extend(eval.stats[:2])  # update results (mAP@0.5:0.95, mAP@0.5)\n            map_bbox, map50_bbox, map_mask, map50_mask = results\n        except Exception as e:\n            LOGGER.info(f\"pycocotools unable to run: {e}\")\n\n    # Return results\n    model.float()  # for training\n    if not training:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    final_metric = mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask\n    return (*final_metric, *(loss.cpu() / len(dataloader)).tolist()), metrics.get_maps(nc), t\n\n\ndef parse_opt():\n    \"\"\"Parses command line arguments for configuring YOLOv5 options like dataset path, weights, batch size, and\n    inference settings.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128-seg.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s-seg.pt\", help=\"model path(s)\")\n    parser.add_argument(\"--batch-size\", type=int, default=32, help=\"batch size\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"inference size (pixels)\")\n    parser.add_argument(\"--conf-thres\", type=float, default=0.001, help=\"confidence threshold\")\n    parser.add_argument(\"--iou-thres\", type=float, default=0.6, help=\"NMS IoU threshold\")\n    parser.add_argument(\"--max-det\", type=int, default=300, help=\"maximum detections per image\")\n    parser.add_argument(\"--task\", default=\"val\", help=\"train, val, test, speed or study\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--single-cls\", action=\"store_true\", help=\"treat as single-class dataset\")\n    parser.add_argument(\"--augment\", action=\"store_true\", help=\"augmented inference\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"report mAP by class\")\n    parser.add_argument(\"--save-txt\", action=\"store_true\", help=\"save results to *.txt\")\n    parser.add_argument(\"--save-hybrid\", action=\"store_true\", help=\"save label+prediction hybrid results to *.txt\")\n    parser.add_argument(\"--save-conf\", action=\"store_true\", help=\"save confidences in --save-txt labels\")\n    parser.add_argument(\"--save-json\", action=\"store_true\", help=\"save a COCO-JSON results file\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/val-seg\", help=\"save results to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    # opt.save_json |= opt.data.endswith('coco.yaml')\n    opt.save_txt |= opt.save_hybrid\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 tasks including training, validation, testing, speed, and study with configurable options.\"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n\n    if opt.task in (\"train\", \"val\", \"test\"):  # run normally\n        if opt.conf_thres > 0.001:  # https://github.com/ultralytics/yolov5/issues/1466\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f confidence threshold {opt.conf_thres} > 0.001 produces invalid results\")\n        if opt.save_hybrid:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f --save-hybrid returns high mAP from hybrid labels, not from predictions alone\")\n        run(**vars(opt))\n\n    else:\n        weights = opt.weights if isinstance(opt.weights, list) else [opt.weights]\n        opt.half = torch.cuda.is_available() and opt.device != \"cpu\"  # FP16 for fastest results\n        if opt.task == \"speed\":  # speed benchmarks\n            # python val.py --task speed --data coco.yaml --batch 1 --weights yolov5n.pt yolov5s.pt...\n            opt.conf_thres, opt.iou_thres, opt.save_json = 0.25, 0.45, False\n            for opt.weights in weights:\n                run(**vars(opt), plots=False)\n\n        elif opt.task == \"study\":  # speed vs mAP benchmarks\n            # python val.py --task study --data coco.yaml --iou 0.7 --weights yolov5n.pt yolov5s.pt...\n            for opt.weights in weights:\n                f = f\"study_{Path(opt.data).stem}_{Path(opt.weights).stem}.txt\"  # filename to save to\n                x, y = list(range(256, 1536 + 128, 128)), []  # x axis (image sizes), y axis\n                for opt.imgsz in x:  # img-size\n                    LOGGER.info(f\"\\nRunning {f} --imgsz {opt.imgsz}...\")\n                    r, _, t = run(**vars(opt), plots=False)\n                    y.append(r + t)  # results and times\n                np.savetxt(f, y, fmt=\"%10.4g\")  # save\n            subprocess.run([\"zip\", \"-r\", \"study.zip\", \"study_*.txt\"])\n            plot_val_study(x=x)  # plot\n        else:\n            raise NotImplementedError(f'--task {opt.task} not in (\"train\", \"val\", \"test\", \"speed\", \"study\")')\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "segment/train.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nTrain a YOLOv5 segment model on a segment dataset Models and datasets download automatically from the latest YOLOv5\nrelease.\n\nUsage - Single-GPU training:\n    $ python segment/train.py --data coco128-seg.yaml --weights yolov5s-seg.pt --img 640  # from pretrained (recommended)\n    $ python segment/train.py --data coco128-seg.yaml --weights '' --cfg yolov5s-seg.yaml --img 640  # from scratch\n\nUsage - Multi-GPU DDP training:\n    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 segment/train.py --data coco128-seg.yaml --weights yolov5s-seg.pt --img 640 --device 0,1,2,3\n\nModels:     https://github.com/ultralytics/yolov5/tree/master/models\nDatasets:   https://github.com/ultralytics/yolov5/tree/master/data\nTutorial:   https://docs.ultralytics.com/yolov5/tutorials/train_custom_data\n\"\"\"\n\nimport argparse\nimport math\nimport os\nimport random\nimport subprocess\nimport sys\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nimport torch.distributed as dist\nimport torch.nn as nn\nimport yaml\nfrom torch.optim import lr_scheduler\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nimport segment.val as validate  # for end-of-epoch mAP\nfrom models.experimental import attempt_load\nfrom models.yolo import SegmentationModel\nfrom utils.autoanchor import check_anchors\nfrom utils.autobatch import check_train_batch_size\nfrom utils.callbacks import Callbacks\nfrom utils.downloads import attempt_download, is_url\nfrom utils.general import (\n    LOGGER,\n    TQDM_BAR_FORMAT,\n    check_amp,\n    check_dataset,\n    check_file,\n    check_git_info,\n    check_git_status,\n    check_img_size,\n    check_requirements,\n    check_suffix,\n    check_yaml,\n    colorstr,\n    get_latest_run,\n    increment_path,\n    init_seeds,\n    intersect_dicts,\n    labels_to_class_weights,\n    labels_to_image_weights,\n    one_cycle,\n    print_args,\n    print_mutation,\n    strip_optimizer,\n    yaml_save,\n)\nfrom utils.loggers import GenericLogger\nfrom utils.plots import plot_evolve, plot_labels\nfrom utils.segment.dataloaders import create_dataloader\nfrom utils.segment.loss import ComputeLoss\nfrom utils.segment.metrics import KEYS, fitness\nfrom utils.segment.plots import plot_images_and_masks, plot_results_with_masks\nfrom utils.torch_utils import (\n    EarlyStopping,\n    ModelEMA,\n    de_parallel,\n    select_device,\n    smart_DDP,\n    smart_optimizer,\n    smart_resume,\n    torch_distributed_zero_first,\n)\n\nLOCAL_RANK = int(os.getenv(\"LOCAL_RANK\", -1))  # https://pytorch.org/docs/stable/elastic/run.html\nRANK = int(os.getenv(\"RANK\", -1))\nWORLD_SIZE = int(os.getenv(\"WORLD_SIZE\", 1))\nGIT_INFO = check_git_info()\n\n\ndef train(hyp, opt, device, callbacks):\n    \"\"\"\n    Trains the YOLOv5 model on a dataset, managing hyperparameters, model optimization, logging, and validation.\n\n    `hyp` is path/to/hyp.yaml or hyp dictionary.\n    \"\"\"\n    (\n        save_dir,\n        epochs,\n        batch_size,\n        weights,\n        single_cls,\n        evolve,\n        data,\n        cfg,\n        resume,\n        noval,\n        nosave,\n        workers,\n        freeze,\n        mask_ratio,\n    ) = (\n        Path(opt.save_dir),\n        opt.epochs,\n        opt.batch_size,\n        opt.weights,\n        opt.single_cls,\n        opt.evolve,\n        opt.data,\n        opt.cfg,\n        opt.resume,\n        opt.noval,\n        opt.nosave,\n        opt.workers,\n        opt.freeze,\n        opt.mask_ratio,\n    )\n    # callbacks.run('on_pretrain_routine_start')\n\n    # Directories\n    w = save_dir / \"weights\"  # weights dir\n    (w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = w / \"last.pt\", w / \"best.pt\"\n\n    # Hyperparameters\n    if isinstance(hyp, str):\n        with open(hyp, errors=\"ignore\") as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n    LOGGER.info(colorstr(\"hyperparameters: \") + \", \".join(f\"{k}={v}\" for k, v in hyp.items()))\n    opt.hyp = hyp.copy()  # for saving hyps to checkpoints\n\n    # Save run settings\n    if not evolve:\n        yaml_save(save_dir / \"hyp.yaml\", hyp)\n        yaml_save(save_dir / \"opt.yaml\", vars(opt))\n\n    # Loggers\n    data_dict = None\n    if RANK in {-1, 0}:\n        logger = GenericLogger(opt=opt, console_logger=LOGGER)\n\n    # Config\n    plots = not evolve and not opt.noplots  # create plots\n    overlap = not opt.no_overlap\n    cuda = device.type != \"cpu\"\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    with torch_distributed_zero_first(LOCAL_RANK):\n        data_dict = data_dict or check_dataset(data)  # check if None\n    train_path, val_path = data_dict[\"train\"], data_dict[\"val\"]\n    nc = 1 if single_cls else int(data_dict[\"nc\"])  # number of classes\n    names = {0: \"item\"} if single_cls and len(data_dict[\"names\"]) != 1 else data_dict[\"names\"]  # class names\n    is_coco = isinstance(val_path, str) and val_path.endswith(\"coco/val2017.txt\")  # COCO dataset\n\n    # Model\n    check_suffix(weights, \".pt\")  # check weights\n    pretrained = weights.endswith(\".pt\")\n    if pretrained:\n        with torch_distributed_zero_first(LOCAL_RANK):\n            weights = attempt_download(weights)  # download if not found locally\n        ckpt = torch.load(weights, map_location=\"cpu\")  # load checkpoint to CPU to avoid CUDA memory leak\n        model = SegmentationModel(cfg or ckpt[\"model\"].yaml, ch=3, nc=nc, anchors=hyp.get(\"anchors\")).to(device)\n        exclude = [\"anchor\"] if (cfg or hyp.get(\"anchors\")) and not resume else []  # exclude keys\n        csd = ckpt[\"model\"].float().state_dict()  # checkpoint state_dict as FP32\n        csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # intersect\n        model.load_state_dict(csd, strict=False)  # load\n        LOGGER.info(f\"Transferred {len(csd)}/{len(model.state_dict())} items from {weights}\")  # report\n    else:\n        model = SegmentationModel(cfg, ch=3, nc=nc, anchors=hyp.get(\"anchors\")).to(device)  # create\n    amp = check_amp(model)  # check AMP\n\n    # Freeze\n    freeze = [f\"model.{x}.\" for x in (freeze if len(freeze) > 1 else range(freeze[0]))]  # layers to freeze\n    for k, v in model.named_parameters():\n        v.requires_grad = True  # train all layers\n        # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n        if any(x in k for x in freeze):\n            LOGGER.info(f\"freezing {k}\")\n            v.requires_grad = False\n\n    # Image size\n    gs = max(int(model.stride.max()), 32)  # grid size (max stride)\n    imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # verify imgsz is gs-multiple\n\n    # Batch size\n    if RANK == -1 and batch_size == -1:  # single-GPU only, estimate best batch size\n        batch_size = check_train_batch_size(model, imgsz, amp)\n        logger.update_params({\"batch_size\": batch_size})\n        # loggers.on_params_update({\"batch_size\": batch_size})\n\n    # Optimizer\n    nbs = 64  # nominal batch size\n    accumulate = max(round(nbs / batch_size), 1)  # accumulate loss before optimizing\n    hyp[\"weight_decay\"] *= batch_size * accumulate / nbs  # scale weight_decay\n    optimizer = smart_optimizer(model, opt.optimizer, hyp[\"lr0\"], hyp[\"momentum\"], hyp[\"weight_decay\"])\n\n    # Scheduler\n    if opt.cos_lr:\n        lf = one_cycle(1, hyp[\"lrf\"], epochs)  # cosine 1->hyp['lrf']\n    else:\n\n        def lf(x):\n            return (1 - x / epochs) * (1.0 - hyp[\"lrf\"]) + hyp[\"lrf\"]  # linear\n\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # Resume\n    best_fitness, start_epoch = 0.0, 0\n    if pretrained:\n        if resume:\n            best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)\n        del ckpt, csd\n\n    # DP mode\n    if cuda and RANK == -1 and torch.cuda.device_count() > 1:\n        LOGGER.warning(\n            \"WARNING \u26a0\ufe0f DP not recommended, use torch.distributed.run for best DDP Multi-GPU results.\\n\"\n            \"See Multi-GPU Tutorial at https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training to get started.\"\n        )\n        model = torch.nn.DataParallel(model)\n\n    # SyncBatchNorm\n    if opt.sync_bn and cuda and RANK != -1:\n        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)\n        LOGGER.info(\"Using SyncBatchNorm()\")\n\n    # Trainloader\n    train_loader, dataset = create_dataloader(\n        train_path,\n        imgsz,\n        batch_size // WORLD_SIZE,\n        gs,\n        single_cls,\n        hyp=hyp,\n        augment=True,\n        cache=None if opt.cache == \"val\" else opt.cache,\n        rect=opt.rect,\n        rank=LOCAL_RANK,\n        workers=workers,\n        image_weights=opt.image_weights,\n        quad=opt.quad,\n        prefix=colorstr(\"train: \"),\n        shuffle=True,\n        mask_downsample_ratio=mask_ratio,\n        overlap_mask=overlap,\n    )\n    labels = np.concatenate(dataset.labels, 0)\n    mlc = int(labels[:, 0].max())  # max label class\n    assert mlc < nc, f\"Label class {mlc} exceeds nc={nc} in {data}. Possible class labels are 0-{nc - 1}\"\n\n    # Process 0\n    if RANK in {-1, 0}:\n        val_loader = create_dataloader(\n            val_path,\n            imgsz,\n            batch_size // WORLD_SIZE * 2,\n            gs,\n            single_cls,\n            hyp=hyp,\n            cache=None if noval else opt.cache,\n            rect=True,\n            rank=-1,\n            workers=workers * 2,\n            pad=0.5,\n            mask_downsample_ratio=mask_ratio,\n            overlap_mask=overlap,\n            prefix=colorstr(\"val: \"),\n        )[0]\n\n        if not resume:\n            if not opt.noautoanchor:\n                check_anchors(dataset, model=model, thr=hyp[\"anchor_t\"], imgsz=imgsz)  # run AutoAnchor\n            model.half().float()  # pre-reduce anchor precision\n\n            if plots:\n                plot_labels(labels, names, save_dir)\n        # callbacks.run('on_pretrain_routine_end', labels, names)\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Model attributes\n    nl = de_parallel(model).model[-1].nl  # number of detection layers (to scale hyps)\n    hyp[\"box\"] *= 3 / nl  # scale to layers\n    hyp[\"cls\"] *= nc / 80 * 3 / nl  # scale to classes and layers\n    hyp[\"obj\"] *= (imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n    hyp[\"label_smoothing\"] = opt.label_smoothing\n    model.nc = nc  # attach number of classes to model\n    model.hyp = hyp  # attach hyperparameters to model\n    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # attach class weights\n    model.names = names\n\n    # Start training\n    t0 = time.time()\n    nb = len(train_loader)  # number of batches\n    nw = max(round(hyp[\"warmup_epochs\"] * nb), 100)  # number of warmup iterations, max(3 epochs, 100 iterations)\n    # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\n    last_opt_step = -1\n    maps = np.zeros(nc)  # mAP per class\n    results = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\n    scheduler.last_epoch = start_epoch - 1  # do not move\n    scaler = torch.cuda.amp.GradScaler(enabled=amp)\n    stopper, stop = EarlyStopping(patience=opt.patience), False\n    compute_loss = ComputeLoss(model, overlap=overlap)  # init loss class\n    # callbacks.run('on_train_start')\n    LOGGER.info(\n        f'Image sizes {imgsz} train, {imgsz} val\\n'\n        f'Using {train_loader.num_workers * WORLD_SIZE} dataloader workers\\n'\n        f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n        f'Starting training for {epochs} epochs...'\n    )\n    for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------\n        # callbacks.run('on_train_epoch_start')\n        model.train()\n\n        # Update image weights (optional, single-GPU only)\n        if opt.image_weights:\n            cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # class weights\n            iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # image weights\n            dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # rand weighted idx\n\n        # Update mosaic border (optional)\n        # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\n        # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\n\n        mloss = torch.zeros(4, device=device)  # mean losses\n        if RANK != -1:\n            train_loader.sampler.set_epoch(epoch)\n        pbar = enumerate(train_loader)\n        LOGGER.info(\n            (\"\\n\" + \"%11s\" * 8)\n            % (\"Epoch\", \"GPU_mem\", \"box_loss\", \"seg_loss\", \"obj_loss\", \"cls_loss\", \"Instances\", \"Size\")\n        )\n        if RANK in {-1, 0}:\n            pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # progress bar\n        optimizer.zero_grad()\n        for i, (imgs, targets, paths, _, masks) in pbar:  # batch ------------------------------------------------------\n            # callbacks.run('on_train_batch_start')\n            ni = i + nb * epoch  # number integrated batches (since train start)\n            imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8 to float32, 0-255 to 0.0-1.0\n\n            # Warmup\n            if ni <= nw:\n                xi = [0, nw]  # x interp\n                # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\n                accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())\n                for j, x in enumerate(optimizer.param_groups):\n                    # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n                    x[\"lr\"] = np.interp(ni, xi, [hyp[\"warmup_bias_lr\"] if j == 0 else 0.0, x[\"initial_lr\"] * lf(epoch)])\n                    if \"momentum\" in x:\n                        x[\"momentum\"] = np.interp(ni, xi, [hyp[\"warmup_momentum\"], hyp[\"momentum\"]])\n\n            # Multi-scale\n            if opt.multi_scale:\n                sz = random.randrange(int(imgsz * 0.5), int(imgsz * 1.5) + gs) // gs * gs  # size\n                sf = sz / max(imgs.shape[2:])  # scale factor\n                if sf != 1:\n                    ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # new shape (stretched to gs-multiple)\n                    imgs = nn.functional.interpolate(imgs, size=ns, mode=\"bilinear\", align_corners=False)\n\n            # Forward\n            with torch.cuda.amp.autocast(amp):\n                pred = model(imgs)  # forward\n                loss, loss_items = compute_loss(pred, targets.to(device), masks=masks.to(device).float())\n                if RANK != -1:\n                    loss *= WORLD_SIZE  # gradient averaged between devices in DDP mode\n                if opt.quad:\n                    loss *= 4.0\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n            if ni - last_opt_step >= accumulate:\n                scaler.unscale_(optimizer)  # unscale gradients\n                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n                scaler.step(optimizer)  # optimizer.step\n                scaler.update()\n                optimizer.zero_grad()\n                if ema:\n                    ema.update(model)\n                last_opt_step = ni\n\n            # Log\n            if RANK in {-1, 0}:\n                mloss = (mloss * i + loss_items) / (i + 1)  # update mean losses\n                mem = f\"{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G\"  # (GB)\n                pbar.set_description(\n                    (\"%11s\" * 2 + \"%11.4g\" * 6)\n                    % (f\"{epoch}/{epochs - 1}\", mem, *mloss, targets.shape[0], imgs.shape[-1])\n                )\n                # callbacks.run('on_train_batch_end', model, ni, imgs, targets, paths)\n                # if callbacks.stop_training:\n                #    return\n\n                # Mosaic plots\n                if plots:\n                    if ni < 3:\n                        plot_images_and_masks(imgs, targets, masks, paths, save_dir / f\"train_batch{ni}.jpg\")\n                    if ni == 10:\n                        files = sorted(save_dir.glob(\"train*.jpg\"))\n                        logger.log_images(files, \"Mosaics\", epoch)\n            # end batch ------------------------------------------------------------------------------------------------\n\n        # Scheduler\n        lr = [x[\"lr\"] for x in optimizer.param_groups]  # for loggers\n        scheduler.step()\n\n        if RANK in {-1, 0}:\n            # mAP\n            # callbacks.run('on_train_epoch_end', epoch=epoch)\n            ema.update_attr(model, include=[\"yaml\", \"nc\", \"hyp\", \"names\", \"stride\", \"class_weights\"])\n            final_epoch = (epoch + 1 == epochs) or stopper.possible_stop\n            if not noval or final_epoch:  # Calculate mAP\n                results, maps, _ = validate.run(\n                    data_dict,\n                    batch_size=batch_size // WORLD_SIZE * 2,\n                    imgsz=imgsz,\n                    half=amp,\n                    model=ema.ema,\n                    single_cls=single_cls,\n                    dataloader=val_loader,\n                    save_dir=save_dir,\n                    plots=False,\n                    callbacks=callbacks,\n                    compute_loss=compute_loss,\n                    mask_downsample_ratio=mask_ratio,\n                    overlap=overlap,\n                )\n\n            # Update best mAP\n            fi = fitness(np.array(results).reshape(1, -1))  # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\n            stop = stopper(epoch=epoch, fitness=fi)  # early stop check\n            if fi > best_fitness:\n                best_fitness = fi\n            log_vals = list(mloss) + list(results) + lr\n            # callbacks.run('on_fit_epoch_end', log_vals, epoch, best_fitness, fi)\n            # Log val metrics and media\n            metrics_dict = dict(zip(KEYS, log_vals))\n            logger.log_metrics(metrics_dict, epoch)\n\n            # Save model\n            if (not nosave) or (final_epoch and not evolve):  # if save\n                ckpt = {\n                    \"epoch\": epoch,\n                    \"best_fitness\": best_fitness,\n                    \"model\": deepcopy(de_parallel(model)).half(),\n                    \"ema\": deepcopy(ema.ema).half(),\n                    \"updates\": ema.updates,\n                    \"optimizer\": optimizer.state_dict(),\n                    \"opt\": vars(opt),\n                    \"git\": GIT_INFO,  # {remote, branch, commit} if a git repo\n                    \"date\": datetime.now().isoformat(),\n                }\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fi:\n                    torch.save(ckpt, best)\n                if opt.save_period > 0 and epoch % opt.save_period == 0:\n                    torch.save(ckpt, w / f\"epoch{epoch}.pt\")\n                    logger.log_model(w / f\"epoch{epoch}.pt\")\n                del ckpt\n                # callbacks.run('on_model_save', last, epoch, final_epoch, best_fitness, fi)\n\n        # EarlyStopping\n        if RANK != -1:  # if DDP training\n            broadcast_list = [stop if RANK == 0 else None]\n            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n            if RANK != 0:\n                stop = broadcast_list[0]\n        if stop:\n            break  # must break all DDP ranks\n\n        # end epoch ----------------------------------------------------------------------------------------------------\n    # end training -----------------------------------------------------------------------------------------------------\n    if RANK in {-1, 0}:\n        LOGGER.info(f\"\\n{epoch - start_epoch + 1} epochs completed in {(time.time() - t0) / 3600:.3f} hours.\")\n        for f in last, best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is best:\n                    LOGGER.info(f\"\\nValidating {f}...\")\n                    results, _, _ = validate.run(\n                        data_dict,\n                        batch_size=batch_size // WORLD_SIZE * 2,\n                        imgsz=imgsz,\n                        model=attempt_load(f, device).half(),\n                        iou_thres=0.65 if is_coco else 0.60,  # best pycocotools at iou 0.65\n                        single_cls=single_cls,\n                        dataloader=val_loader,\n                        save_dir=save_dir,\n                        save_json=is_coco,\n                        verbose=True,\n                        plots=plots,\n                        callbacks=callbacks,\n                        compute_loss=compute_loss,\n                        mask_downsample_ratio=mask_ratio,\n                        overlap=overlap,\n                    )  # val best model with plots\n                    if is_coco:\n                        # callbacks.run('on_fit_epoch_end', list(mloss) + list(results) + lr, epoch, best_fitness, fi)\n                        metrics_dict = dict(zip(KEYS, list(mloss) + list(results) + lr))\n                        logger.log_metrics(metrics_dict, epoch)\n\n        # callbacks.run('on_train_end', last, best, epoch, results)\n        # on train end callback using genericLogger\n        logger.log_metrics(dict(zip(KEYS[4:16], results)), epochs)\n        if not opt.evolve:\n            logger.log_model(best, epoch)\n        if plots:\n            plot_results_with_masks(file=save_dir / \"results.csv\")  # save results.png\n            files = [\"results.png\", \"confusion_matrix.png\", *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\"))]\n            files = [(save_dir / f) for f in files if (save_dir / f).exists()]  # filter\n            LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}\")\n            logger.log_images(files, \"Results\", epoch + 1)\n            logger.log_images(sorted(save_dir.glob(\"val*.jpg\")), \"Validation\", epoch + 1)\n    torch.cuda.empty_cache()\n    return results\n\n\ndef parse_opt(known=False):\n    \"\"\"\n    Parses command line arguments for training configurations, returning parsed arguments.\n\n    Supports both known and unknown args.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=ROOT / \"yolov5s-seg.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--cfg\", type=str, default=\"\", help=\"model.yaml path\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128-seg.yaml\", help=\"dataset.yaml path\")\n    parser.add_argument(\"--hyp\", type=str, default=ROOT / \"data/hyps/hyp.scratch-low.yaml\", help=\"hyperparameters path\")\n    parser.add_argument(\"--epochs\", type=int, default=100, help=\"total training epochs\")\n    parser.add_argument(\"--batch-size\", type=int, default=16, help=\"total batch size for all GPUs, -1 for autobatch\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=640, help=\"train, val image size (pixels)\")\n    parser.add_argument(\"--rect\", action=\"store_true\", help=\"rectangular training\")\n    parser.add_argument(\"--resume\", nargs=\"?\", const=True, default=False, help=\"resume most recent training\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"only save final checkpoint\")\n    parser.add_argument(\"--noval\", action=\"store_true\", help=\"only validate final epoch\")\n    parser.add_argument(\"--noautoanchor\", action=\"store_true\", help=\"disable AutoAnchor\")\n    parser.add_argument(\"--noplots\", action=\"store_true\", help=\"save no plot files\")\n    parser.add_argument(\"--evolve\", type=int, nargs=\"?\", const=300, help=\"evolve hyperparameters for x generations\")\n    parser.add_argument(\"--bucket\", type=str, default=\"\", help=\"gsutil bucket\")\n    parser.add_argument(\"--cache\", type=str, nargs=\"?\", const=\"ram\", help=\"image --cache ram/disk\")\n    parser.add_argument(\"--image-weights\", action=\"store_true\", help=\"use weighted image selection for training\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--multi-scale\", action=\"store_true\", help=\"vary img-size +/- 50%%\")\n    parser.add_argument(\"--single-cls\", action=\"store_true\", help=\"train multi-class data as single-class\")\n    parser.add_argument(\"--optimizer\", type=str, choices=[\"SGD\", \"Adam\", \"AdamW\"], default=\"SGD\", help=\"optimizer\")\n    parser.add_argument(\"--sync-bn\", action=\"store_true\", help=\"use SyncBatchNorm, only available in DDP mode\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/train-seg\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--quad\", action=\"store_true\", help=\"quad dataloader\")\n    parser.add_argument(\"--cos-lr\", action=\"store_true\", help=\"cosine LR scheduler\")\n    parser.add_argument(\"--label-smoothing\", type=float, default=0.0, help=\"Label smoothing epsilon\")\n    parser.add_argument(\"--patience\", type=int, default=100, help=\"EarlyStopping patience (epochs without improvement)\")\n    parser.add_argument(\"--freeze\", nargs=\"+\", type=int, default=[0], help=\"Freeze layers: backbone=10, first3=0 1 2\")\n    parser.add_argument(\"--save-period\", type=int, default=-1, help=\"Save checkpoint every x epochs (disabled if < 1)\")\n    parser.add_argument(\"--seed\", type=int, default=0, help=\"Global training seed\")\n    parser.add_argument(\"--local_rank\", type=int, default=-1, help=\"Automatic DDP Multi-GPU argument, do not modify\")\n\n    # Instance Segmentation Args\n    parser.add_argument(\"--mask-ratio\", type=int, default=4, help=\"Downsample the truth masks to saving memory\")\n    parser.add_argument(\"--no-overlap\", action=\"store_true\", help=\"Overlap masks train faster at slightly less mAP\")\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()\n\n\ndef main(opt, callbacks=Callbacks()):\n    \"\"\"Initializes training or evolution of YOLOv5 models based on provided configuration and options.\"\"\"\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements(ROOT / \"requirements.txt\")\n\n    # Resume\n    if opt.resume and not opt.evolve:  # resume from specified or most recent last.pt\n        last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())\n        opt_yaml = last.parent.parent / \"opt.yaml\"  # train options yaml\n        opt_data = opt.data  # original dataset\n        if opt_yaml.is_file():\n            with open(opt_yaml, errors=\"ignore\") as f:\n                d = yaml.safe_load(f)\n        else:\n            d = torch.load(last, map_location=\"cpu\")[\"opt\"]\n        opt = argparse.Namespace(**d)  # replace\n        opt.cfg, opt.weights, opt.resume = \"\", str(last), True  # reinstate\n        if is_url(opt_data):\n            opt.data = check_file(opt_data)  # avoid HUB resume auth timeout\n    else:\n        opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = (\n            check_file(opt.data),\n            check_yaml(opt.cfg),\n            check_yaml(opt.hyp),\n            str(opt.weights),\n            str(opt.project),\n        )  # checks\n        assert len(opt.cfg) or len(opt.weights), \"either --cfg or --weights must be specified\"\n        if opt.evolve:\n            if opt.project == str(ROOT / \"runs/train-seg\"):  # if default project name, rename to runs/evolve-seg\n                opt.project = str(ROOT / \"runs/evolve-seg\")\n            opt.exist_ok, opt.resume = opt.resume, False  # pass resume to exist_ok and disable resume\n        if opt.name == \"cfg\":\n            opt.name = Path(opt.cfg).stem  # use model.yaml as name\n        opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        msg = \"is not compatible with YOLOv5 Multi-GPU DDP training\"\n        assert not opt.image_weights, f\"--image-weights {msg}\"\n        assert not opt.evolve, f\"--evolve {msg}\"\n        assert opt.batch_size != -1, f\"AutoBatch with --batch-size -1 {msg}, please pass a valid --batch-size\"\n        assert opt.batch_size % WORLD_SIZE == 0, f\"--batch-size {opt.batch_size} must be multiple of WORLD_SIZE\"\n        assert torch.cuda.device_count() > LOCAL_RANK, \"insufficient CUDA devices for DDP command\"\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device(\"cuda\", LOCAL_RANK)\n        dist.init_process_group(backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n\n    # Train\n    if not opt.evolve:\n        train(opt.hyp, opt, device, callbacks)\n\n    # Evolve hyperparameters (optional)\n    else:\n        # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)\n        meta = {\n            \"lr0\": (1, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)\n            \"lrf\": (1, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n            \"momentum\": (0.3, 0.6, 0.98),  # SGD momentum/Adam beta1\n            \"weight_decay\": (1, 0.0, 0.001),  # optimizer weight decay\n            \"warmup_epochs\": (1, 0.0, 5.0),  # warmup epochs (fractions ok)\n            \"warmup_momentum\": (1, 0.0, 0.95),  # warmup initial momentum\n            \"warmup_bias_lr\": (1, 0.0, 0.2),  # warmup initial bias lr\n            \"box\": (1, 0.02, 0.2),  # box loss gain\n            \"cls\": (1, 0.2, 4.0),  # cls loss gain\n            \"cls_pw\": (1, 0.5, 2.0),  # cls BCELoss positive_weight\n            \"obj\": (1, 0.2, 4.0),  # obj loss gain (scale with pixels)\n            \"obj_pw\": (1, 0.5, 2.0),  # obj BCELoss positive_weight\n            \"iou_t\": (0, 0.1, 0.7),  # IoU training threshold\n            \"anchor_t\": (1, 2.0, 8.0),  # anchor-multiple threshold\n            \"anchors\": (2, 2.0, 10.0),  # anchors per output grid (0 to ignore)\n            \"fl_gamma\": (0, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)\n            \"hsv_h\": (1, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n            \"hsv_s\": (1, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n            \"hsv_v\": (1, 0.0, 0.9),  # image HSV-Value augmentation (fraction)\n            \"degrees\": (1, 0.0, 45.0),  # image rotation (+/- deg)\n            \"translate\": (1, 0.0, 0.9),  # image translation (+/- fraction)\n            \"scale\": (1, 0.0, 0.9),  # image scale (+/- gain)\n            \"shear\": (1, 0.0, 10.0),  # image shear (+/- deg)\n            \"perspective\": (0, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n            \"flipud\": (1, 0.0, 1.0),  # image flip up-down (probability)\n            \"fliplr\": (0, 0.0, 1.0),  # image flip left-right (probability)\n            \"mosaic\": (1, 0.0, 1.0),  # image mixup (probability)\n            \"mixup\": (1, 0.0, 1.0),  # image mixup (probability)\n            \"copy_paste\": (1, 0.0, 1.0),\n        }  # segment copy-paste (probability)\n\n        with open(opt.hyp, errors=\"ignore\") as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n            if \"anchors\" not in hyp:  # anchors commented in hyp.yaml\n                hyp[\"anchors\"] = 3\n        if opt.noautoanchor:\n            del hyp[\"anchors\"], meta[\"anchors\"]\n        opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # only val/save final epoch\n        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\n        evolve_yaml, evolve_csv = save_dir / \"hyp_evolve.yaml\", save_dir / \"evolve.csv\"\n        if opt.bucket:\n            # download evolve.csv if exists\n            subprocess.run(\n                [\n                    \"gsutil\",\n                    \"cp\",\n                    f\"gs://{opt.bucket}/evolve.csv\",\n                    str(evolve_csv),\n                ]\n            )\n\n        for _ in range(opt.evolve):  # generations to evolve\n            if evolve_csv.exists():  # if evolve.csv exists: select best hyps and mutate\n                # Select parent(s)\n                parent = \"single\"  # parent selection method: 'single' or 'weighted'\n                x = np.loadtxt(evolve_csv, ndmin=2, delimiter=\",\", skiprows=1)\n                n = min(5, len(x))  # number of previous results to consider\n                x = x[np.argsort(-fitness(x))][:n]  # top n mutations\n                w = fitness(x) - fitness(x).min() + 1e-6  # weights (sum > 0)\n                if parent == \"single\" or len(x) == 1:\n                    # x = x[random.randint(0, n - 1)]  # random selection\n                    x = x[random.choices(range(n), weights=w)[0]]  # weighted selection\n                elif parent == \"weighted\":\n                    x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination\n\n                # Mutate\n                mp, s = 0.8, 0.2  # mutation probability, sigma\n                npr = np.random\n                npr.seed(int(time.time()))\n                g = np.array([meta[k][0] for k in hyp.keys()])  # gains 0-1\n                ng = len(meta)\n                v = np.ones(ng)\n                while all(v == 1):  # mutate until a change occurs (prevent duplicates)\n                    v = (g * (npr.random(ng) < mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)\n                for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)\n                    hyp[k] = float(x[i + 12] * v[i])  # mutate\n\n            # Constrain to limits\n            for k, v in meta.items():\n                hyp[k] = max(hyp[k], v[1])  # lower limit\n                hyp[k] = min(hyp[k], v[2])  # upper limit\n                hyp[k] = round(hyp[k], 5)  # significant digits\n\n            # Train mutation\n            results = train(hyp.copy(), opt, device, callbacks)\n            callbacks = Callbacks()\n            # Write mutation results\n            print_mutation(KEYS[4:16], results, hyp.copy(), save_dir, opt.bucket)\n\n        # Plot results\n        plot_evolve(evolve_csv)\n        LOGGER.info(\n            f'Hyperparameter evolution finished {opt.evolve} generations\\n'\n            f\"Results saved to {colorstr('bold', save_dir)}\\n\"\n            f'Usage example: $ python train.py --hyp {evolve_yaml}'\n        )\n\n\ndef run(**kwargs):\n    \"\"\"\n    Executes YOLOv5 training with given parameters, altering options programmatically; returns updated options.\n\n    Example: import train; train.run(data='coco128.yaml', imgsz=320, weights='yolov5m.pt')\n    \"\"\"\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "segment/predict.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nRun YOLOv5 segmentation inference on images, videos, directories, streams, etc.\n\nUsage - sources:\n    $ python segment/predict.py --weights yolov5s-seg.pt --source 0                               # webcam\n                                                                  img.jpg                         # image\n                                                                  vid.mp4                         # video\n                                                                  screen                          # screenshot\n                                                                  path/                           # directory\n                                                                  list.txt                        # list of images\n                                                                  list.streams                    # list of streams\n                                                                  'path/*.jpg'                    # glob\n                                                                  'https://youtu.be/LNwODJXcvt4'  # YouTube\n                                                                  'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP stream\n\nUsage - formats:\n    $ python segment/predict.py --weights yolov5s-seg.pt                 # PyTorch\n                                          yolov5s-seg.torchscript        # TorchScript\n                                          yolov5s-seg.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                          yolov5s-seg_openvino_model     # OpenVINO\n                                          yolov5s-seg.engine             # TensorRT\n                                          yolov5s-seg.mlmodel            # CoreML (macOS-only)\n                                          yolov5s-seg_saved_model        # TensorFlow SavedModel\n                                          yolov5s-seg.pb                 # TensorFlow GraphDef\n                                          yolov5s-seg.tflite             # TensorFlow Lite\n                                          yolov5s-seg_edgetpu.tflite     # TensorFlow Edge TPU\n                                          yolov5s-seg_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport os\nimport platform\nimport sys\nfrom pathlib import Path\n\nimport torch\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom ultralytics.utils.plotting import Annotator, colors, save_one_box\n\nfrom models.common import DetectMultiBackend\nfrom utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams\nfrom utils.general import (\n    LOGGER,\n    Profile,\n    check_file,\n    check_img_size,\n    check_imshow,\n    check_requirements,\n    colorstr,\n    cv2,\n    increment_path,\n    non_max_suppression,\n    print_args,\n    scale_boxes,\n    scale_segments,\n    strip_optimizer,\n)\nfrom utils.segment.general import masks2segments, process_mask, process_mask_native\nfrom utils.torch_utils import select_device, smart_inference_mode\n\n\n@smart_inference_mode()\ndef run(\n    weights=ROOT / \"yolov5s-seg.pt\",  # model.pt path(s)\n    source=ROOT / \"data/images\",  # file/dir/URL/glob/screen/0(webcam)\n    data=ROOT / \"data/coco128.yaml\",  # dataset.yaml path\n    imgsz=(640, 640),  # inference size (height, width)\n    conf_thres=0.25,  # confidence threshold\n    iou_thres=0.45,  # NMS IOU threshold\n    max_det=1000,  # maximum detections per image\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    view_img=False,  # show results\n    save_txt=False,  # save results to *.txt\n    save_conf=False,  # save confidences in --save-txt labels\n    save_crop=False,  # save cropped prediction boxes\n    nosave=False,  # do not save images/videos\n    classes=None,  # filter by class: --class 0, or --class 0 2 3\n    agnostic_nms=False,  # class-agnostic NMS\n    augment=False,  # augmented inference\n    visualize=False,  # visualize features\n    update=False,  # update all models\n    project=ROOT / \"runs/predict-seg\",  # save results to project/name\n    name=\"exp\",  # save results to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    line_thickness=3,  # bounding box thickness (pixels)\n    hide_labels=False,  # hide labels\n    hide_conf=False,  # hide confidences\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    vid_stride=1,  # video frame-rate stride\n    retina_masks=False,\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith(\".txt\")  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith((\"rtsp://\", \"rtmp://\", \"http://\", \"https://\"))\n    webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n    screenshot = source.lower().startswith(\"screen\")\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / \"labels\" if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(device=device), Profile(device=device), Profile(device=device))\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            pred, proto = model(im, augment=augment, visualize=visualize)[:2]\n\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det, nm=32)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f\"{i}: \"\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, \"frame\", 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / \"labels\" / p.stem) + (\"\" if dataset.mode == \"image\" else f\"_{frame}\")  # im.txt\n            s += \"%gx%g \" % im.shape[2:]  # print string\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                if retina_masks:\n                    # scale bbox first the crop masks\n                    det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()  # rescale boxes to im0 size\n                    masks = process_mask_native(proto[i], det[:, 6:], det[:, :4], im0.shape[:2])  # HWC\n                else:\n                    masks = process_mask(proto[i], det[:, 6:], det[:, :4], im.shape[2:], upsample=True)  # HWC\n                    det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()  # rescale boxes to im0 size\n\n                # Segments\n                if save_txt:\n                    segments = [\n                        scale_segments(im0.shape if retina_masks else im.shape[2:], x, im0.shape, normalize=True)\n                        for x in reversed(masks2segments(masks))\n                    ]\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Mask plotting\n                annotator.masks(\n                    masks,\n                    colors=[colors(x, True) for x in det[:, 5]],\n                    im_gpu=torch.as_tensor(im0, dtype=torch.float16).to(device).permute(2, 0, 1).flip(0).contiguous()\n                    / 255\n                    if retina_masks\n                    else im[i],\n                )\n\n                # Write results\n                for j, (*xyxy, conf, cls) in enumerate(reversed(det[:, :6])):\n                    if save_txt:  # Write to file\n                        seg = segments[j].reshape(-1)  # (n,2) to (n*2)\n                        line = (cls, *seg, conf) if save_conf else (cls, *seg)  # label format\n                        with open(f\"{txt_path}.txt\", \"a\") as f:\n                            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f\"{names[c]} {conf:.2f}\")\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                        # annotator.draw.polygon(segments[j], outline=colors(c, True), width=3)\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / \"crops\" / names[c] / f\"{p.stem}.jpg\", BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == \"Linux\" and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                if cv2.waitKey(1) == ord(\"q\"):  # 1 millisecond\n                    exit()\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == \"image\":\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix(\".mp4\"))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*\"mp4v\"), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1e3 for x in dt)  # speeds per image\n    LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}\" % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)\n\n\ndef parse_opt():\n    \"\"\"Parses command-line options for YOLOv5 inference including model paths, data sources, inference settings, and\n    output preferences.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s-seg.pt\", help=\"model path(s)\")\n    parser.add_argument(\"--source\", type=str, default=ROOT / \"data/images\", help=\"file/dir/URL/glob/screen/0(webcam)\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"(optional) dataset.yaml path\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", nargs=\"+\", type=int, default=[640], help=\"inference size h,w\")\n    parser.add_argument(\"--conf-thres\", type=float, default=0.25, help=\"confidence threshold\")\n    parser.add_argument(\"--iou-thres\", type=float, default=0.45, help=\"NMS IoU threshold\")\n    parser.add_argument(\"--max-det\", type=int, default=1000, help=\"maximum detections per image\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--view-img\", action=\"store_true\", help=\"show results\")\n    parser.add_argument(\"--save-txt\", action=\"store_true\", help=\"save results to *.txt\")\n    parser.add_argument(\"--save-conf\", action=\"store_true\", help=\"save confidences in --save-txt labels\")\n    parser.add_argument(\"--save-crop\", action=\"store_true\", help=\"save cropped prediction boxes\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"do not save images/videos\")\n    parser.add_argument(\"--classes\", nargs=\"+\", type=int, help=\"filter by class: --classes 0, or --classes 0 2 3\")\n    parser.add_argument(\"--agnostic-nms\", action=\"store_true\", help=\"class-agnostic NMS\")\n    parser.add_argument(\"--augment\", action=\"store_true\", help=\"augmented inference\")\n    parser.add_argument(\"--visualize\", action=\"store_true\", help=\"visualize features\")\n    parser.add_argument(\"--update\", action=\"store_true\", help=\"update all models\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/predict-seg\", help=\"save results to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save results to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--line-thickness\", default=3, type=int, help=\"bounding box thickness (pixels)\")\n    parser.add_argument(\"--hide-labels\", default=False, action=\"store_true\", help=\"hide labels\")\n    parser.add_argument(\"--hide-conf\", default=False, action=\"store_true\", help=\"hide confidences\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    parser.add_argument(\"--vid-stride\", type=int, default=1, help=\"video frame-rate stride\")\n    parser.add_argument(\"--retina-masks\", action=\"store_true\", help=\"whether to plot masks in native resolution\")\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 model inference with given options, checking for requirements before launching.\"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n    run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "classify/val.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nValidate a trained YOLOv5 classification model on a classification dataset.\n\nUsage:\n    $ bash data/scripts/get_imagenet.sh --val  # download ImageNet val split (6.3G, 50000 images)\n    $ python classify/val.py --weights yolov5m-cls.pt --data ../datasets/imagenet --img 224  # validate ImageNet\n\nUsage - formats:\n    $ python classify/val.py --weights yolov5s-cls.pt                 # PyTorch\n                                       yolov5s-cls.torchscript        # TorchScript\n                                       yolov5s-cls.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                       yolov5s-cls_openvino_model     # OpenVINO\n                                       yolov5s-cls.engine             # TensorRT\n                                       yolov5s-cls.mlmodel            # CoreML (macOS-only)\n                                       yolov5s-cls_saved_model        # TensorFlow SavedModel\n                                       yolov5s-cls.pb                 # TensorFlow GraphDef\n                                       yolov5s-cls.tflite             # TensorFlow Lite\n                                       yolov5s-cls_edgetpu.tflite     # TensorFlow Edge TPU\n                                       yolov5s-cls_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\n\nimport torch\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom models.common import DetectMultiBackend\nfrom utils.dataloaders import create_classification_dataloader\nfrom utils.general import (\n    LOGGER,\n    TQDM_BAR_FORMAT,\n    Profile,\n    check_img_size,\n    check_requirements,\n    colorstr,\n    increment_path,\n    print_args,\n)\nfrom utils.torch_utils import select_device, smart_inference_mode\n\n\n@smart_inference_mode()\ndef run(\n    data=ROOT / \"../datasets/mnist\",  # dataset dir\n    weights=ROOT / \"yolov5s-cls.pt\",  # model.pt path(s)\n    batch_size=128,  # batch size\n    imgsz=224,  # inference size (pixels)\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    workers=8,  # max dataloader workers (per RANK in DDP mode)\n    verbose=False,  # verbose output\n    project=ROOT / \"runs/val-cls\",  # save to project/name\n    name=\"exp\",  # save to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    model=None,\n    dataloader=None,\n    criterion=None,\n    pbar=None,\n):\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != \"cpu\"  # half precision only supported on CUDA\n        model.half() if half else model.float()\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        save_dir.mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f\"Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models\")\n\n        # Dataloader\n        data = Path(data)\n        test_dir = data / \"test\" if (data / \"test\").exists() else data / \"val\"  # data/test or data/val\n        dataloader = create_classification_dataloader(\n            path=test_dir, imgsz=imgsz, batch_size=batch_size, augment=False, rank=-1, workers=workers\n        )\n\n    model.eval()\n    pred, targets, loss, dt = [], [], 0, (Profile(device=device), Profile(device=device), Profile(device=device))\n    n = len(dataloader)  # number of batches\n    action = \"validating\" if dataloader.dataset.root.stem == \"val\" else \"testing\"\n    desc = f\"{pbar.desc[:-36]}{action:>36}\" if pbar else f\"{action}\"\n    bar = tqdm(dataloader, desc, n, not training, bar_format=TQDM_BAR_FORMAT, position=0)\n    with torch.cuda.amp.autocast(enabled=device.type != \"cpu\"):\n        for images, labels in bar:\n            with dt[0]:\n                images, labels = images.to(device, non_blocking=True), labels.to(device)\n\n            with dt[1]:\n                y = model(images)\n\n            with dt[2]:\n                pred.append(y.argsort(1, descending=True)[:, :5])\n                targets.append(labels)\n                if criterion:\n                    loss += criterion(y, labels)\n\n    loss /= n\n    pred, targets = torch.cat(pred), torch.cat(targets)\n    correct = (targets[:, None] == pred).float()\n    acc = torch.stack((correct[:, 0], correct.max(1).values), dim=1)  # (top1, top5) accuracy\n    top1, top5 = acc.mean(0).tolist()\n\n    if pbar:\n        pbar.desc = f\"{pbar.desc[:-36]}{loss:>12.3g}{top1:>12.3g}{top5:>12.3g}\"\n    if verbose:  # all classes\n        LOGGER.info(f\"{'Class':>24}{'Images':>12}{'top1_acc':>12}{'top5_acc':>12}\")\n        LOGGER.info(f\"{'all':>24}{targets.shape[0]:>12}{top1:>12.3g}{top5:>12.3g}\")\n        for i, c in model.names.items():\n            acc_i = acc[targets == i]\n            top1i, top5i = acc_i.mean(0).tolist()\n            LOGGER.info(f\"{c:>24}{acc_i.shape[0]:>12}{top1i:>12.3g}{top5i:>12.3g}\")\n\n        # Print results\n        t = tuple(x.t / len(dataloader.dataset.samples) * 1e3 for x in dt)  # speeds per image\n        shape = (1, 3, imgsz, imgsz)\n        LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms post-process per image at shape {shape}\" % t)\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}\")\n\n    return top1, top5, loss\n\n\ndef parse_opt():\n    \"\"\"Parses and returns command line arguments for YOLOv5 model evaluation and inference settings.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"../datasets/mnist\", help=\"dataset path\")\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s-cls.pt\", help=\"model.pt path(s)\")\n    parser.add_argument(\"--batch-size\", type=int, default=128, help=\"batch size\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=224, help=\"inference size (pixels)\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--verbose\", nargs=\"?\", const=True, default=True, help=\"verbose output\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/val-cls\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    opt = parser.parse_args()\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes the YOLOv5 model prediction workflow, handling argument parsing and requirement checks.\"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n    run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "classify/train.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nTrain a YOLOv5 classifier model on a classification dataset.\n\nUsage - Single-GPU training:\n    $ python classify/train.py --model yolov5s-cls.pt --data imagenette160 --epochs 5 --img 224\n\nUsage - Multi-GPU DDP training:\n    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 2022 classify/train.py --model yolov5s-cls.pt --data imagenet --epochs 5 --img 224 --device 0,1,2,3\n\nDatasets:           --data mnist, fashion-mnist, cifar10, cifar100, imagenette, imagewoof, imagenet, or 'path/to/data'\nYOLOv5-cls models:  --model yolov5n-cls.pt, yolov5s-cls.pt, yolov5m-cls.pt, yolov5l-cls.pt, yolov5x-cls.pt\nTorchvision models: --model resnet50, efficientnet_b0, etc. See https://pytorch.org/vision/stable/models.html\n\"\"\"\n\nimport argparse\nimport os\nimport subprocess\nimport sys\nimport time\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport torch\nimport torch.distributed as dist\nimport torch.hub as hub\nimport torch.optim.lr_scheduler as lr_scheduler\nimport torchvision\nfrom torch.cuda import amp\nfrom tqdm import tqdm\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom classify import val as validate\nfrom models.experimental import attempt_load\nfrom models.yolo import ClassificationModel, DetectionModel\nfrom utils.dataloaders import create_classification_dataloader\nfrom utils.general import (\n    DATASETS_DIR,\n    LOGGER,\n    TQDM_BAR_FORMAT,\n    WorkingDirectory,\n    check_git_info,\n    check_git_status,\n    check_requirements,\n    colorstr,\n    download,\n    increment_path,\n    init_seeds,\n    print_args,\n    yaml_save,\n)\nfrom utils.loggers import GenericLogger\nfrom utils.plots import imshow_cls\nfrom utils.torch_utils import (\n    ModelEMA,\n    de_parallel,\n    model_info,\n    reshape_classifier_output,\n    select_device,\n    smart_DDP,\n    smart_optimizer,\n    smartCrossEntropyLoss,\n    torch_distributed_zero_first,\n)\n\nLOCAL_RANK = int(os.getenv(\"LOCAL_RANK\", -1))  # https://pytorch.org/docs/stable/elastic/run.html\nRANK = int(os.getenv(\"RANK\", -1))\nWORLD_SIZE = int(os.getenv(\"WORLD_SIZE\", 1))\nGIT_INFO = check_git_info()\n\n\ndef train(opt, device):\n    \"\"\"Trains a YOLOv5 model, managing datasets, model optimization, logging, and saving checkpoints.\"\"\"\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    save_dir, data, bs, epochs, nw, imgsz, pretrained = (\n        opt.save_dir,\n        Path(opt.data),\n        opt.batch_size,\n        opt.epochs,\n        min(os.cpu_count() - 1, opt.workers),\n        opt.imgsz,\n        str(opt.pretrained).lower() == \"true\",\n    )\n    cuda = device.type != \"cpu\"\n\n    # Directories\n    wdir = save_dir / \"weights\"\n    wdir.mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = wdir / \"last.pt\", wdir / \"best.pt\"\n\n    # Save run settings\n    yaml_save(save_dir / \"opt.yaml\", vars(opt))\n\n    # Logger\n    logger = GenericLogger(opt=opt, console_logger=LOGGER) if RANK in {-1, 0} else None\n\n    # Download Dataset\n    with torch_distributed_zero_first(LOCAL_RANK), WorkingDirectory(ROOT):\n        data_dir = data if data.is_dir() else (DATASETS_DIR / data)\n        if not data_dir.is_dir():\n            LOGGER.info(f\"\\nDataset not found \u26a0\ufe0f, missing path {data_dir}, attempting download...\")\n            t = time.time()\n            if str(data) == \"imagenet\":\n                subprocess.run([\"bash\", str(ROOT / \"data/scripts/get_imagenet.sh\")], shell=True, check=True)\n            else:\n                url = f\"https://github.com/ultralytics/yolov5/releases/download/v1.0/{data}.zip\"\n                download(url, dir=data_dir.parent)\n            s = f\"Dataset download success \u2705 ({time.time() - t:.1f}s), saved to {colorstr('bold', data_dir)}\\n\"\n            LOGGER.info(s)\n\n    # Dataloaders\n    nc = len([x for x in (data_dir / \"train\").glob(\"*\") if x.is_dir()])  # number of classes\n    trainloader = create_classification_dataloader(\n        path=data_dir / \"train\",\n        imgsz=imgsz,\n        batch_size=bs // WORLD_SIZE,\n        augment=True,\n        cache=opt.cache,\n        rank=LOCAL_RANK,\n        workers=nw,\n    )\n\n    test_dir = data_dir / \"test\" if (data_dir / \"test\").exists() else data_dir / \"val\"  # data/test or data/val\n    if RANK in {-1, 0}:\n        testloader = create_classification_dataloader(\n            path=test_dir,\n            imgsz=imgsz,\n            batch_size=bs // WORLD_SIZE * 2,\n            augment=False,\n            cache=opt.cache,\n            rank=-1,\n            workers=nw,\n        )\n\n    # Model\n    with torch_distributed_zero_first(LOCAL_RANK), WorkingDirectory(ROOT):\n        if Path(opt.model).is_file() or opt.model.endswith(\".pt\"):\n            model = attempt_load(opt.model, device=\"cpu\", fuse=False)\n        elif opt.model in torchvision.models.__dict__:  # TorchVision models i.e. resnet50, efficientnet_b0\n            model = torchvision.models.__dict__[opt.model](weights=\"IMAGENET1K_V1\" if pretrained else None)\n        else:\n            m = hub.list(\"ultralytics/yolov5\")  # + hub.list('pytorch/vision')  # models\n            raise ModuleNotFoundError(f\"--model {opt.model} not found. Available models are: \\n\" + \"\\n\".join(m))\n        if isinstance(model, DetectionModel):\n            LOGGER.warning(\"WARNING \u26a0\ufe0f pass YOLOv5 classifier model with '-cls' suffix, i.e. '--model yolov5s-cls.pt'\")\n            model = ClassificationModel(model=model, nc=nc, cutoff=opt.cutoff or 10)  # convert to classification model\n        reshape_classifier_output(model, nc)  # update class count\n    for m in model.modules():\n        if not pretrained and hasattr(m, \"reset_parameters\"):\n            m.reset_parameters()\n        if isinstance(m, torch.nn.Dropout) and opt.dropout is not None:\n            m.p = opt.dropout  # set dropout\n    for p in model.parameters():\n        p.requires_grad = True  # for training\n    model = model.to(device)\n\n    # Info\n    if RANK in {-1, 0}:\n        model.names = trainloader.dataset.classes  # attach class names\n        model.transforms = testloader.dataset.torch_transforms  # attach inference transforms\n        model_info(model)\n        if opt.verbose:\n            LOGGER.info(model)\n        images, labels = next(iter(trainloader))\n        file = imshow_cls(images[:25], labels[:25], names=model.names, f=save_dir / \"train_images.jpg\")\n        logger.log_images(file, name=\"Train Examples\")\n        logger.log_graph(model, imgsz)  # log model\n\n    # Optimizer\n    optimizer = smart_optimizer(model, opt.optimizer, opt.lr0, momentum=0.9, decay=opt.decay)\n\n    # Scheduler\n    lrf = 0.01  # final lr (fraction of lr0)\n\n    # lf = lambda x: ((1 + math.cos(x * math.pi / epochs)) / 2) * (1 - lrf) + lrf  # cosine\n    def lf(x):\n        return (1 - x / epochs) * (1 - lrf) + lrf  # linear\n\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)\n    # scheduler = lr_scheduler.OneCycleLR(optimizer, max_lr=lr0, total_steps=epochs, pct_start=0.1,\n    #                                    final_div_factor=1 / 25 / lrf)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Train\n    t0 = time.time()\n    criterion = smartCrossEntropyLoss(label_smoothing=opt.label_smoothing)  # loss function\n    best_fitness = 0.0\n    scaler = amp.GradScaler(enabled=cuda)\n    val = test_dir.stem  # 'val' or 'test'\n    LOGGER.info(\n        f'Image sizes {imgsz} train, {imgsz} test\\n'\n        f'Using {nw * WORLD_SIZE} dataloader workers\\n'\n        f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n        f'Starting {opt.model} training on {data} dataset with {nc} classes for {epochs} epochs...\\n\\n'\n        f\"{'Epoch':>10}{'GPU_mem':>10}{'train_loss':>12}{f'{val}_loss':>12}{'top1_acc':>12}{'top5_acc':>12}\"\n    )\n    for epoch in range(epochs):  # loop over the dataset multiple times\n        tloss, vloss, fitness = 0.0, 0.0, 0.0  # train loss, val loss, fitness\n        model.train()\n        if RANK != -1:\n            trainloader.sampler.set_epoch(epoch)\n        pbar = enumerate(trainloader)\n        if RANK in {-1, 0}:\n            pbar = tqdm(enumerate(trainloader), total=len(trainloader), bar_format=TQDM_BAR_FORMAT)\n        for i, (images, labels) in pbar:  # progress bar\n            images, labels = images.to(device, non_blocking=True), labels.to(device)\n\n            # Forward\n            with amp.autocast(enabled=cuda):  # stability issues when enabled\n                loss = criterion(model(images), labels)\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize\n            scaler.unscale_(optimizer)  # unscale gradients\n            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n            scaler.step(optimizer)\n            scaler.update()\n            optimizer.zero_grad()\n            if ema:\n                ema.update(model)\n\n            if RANK in {-1, 0}:\n                # Print\n                tloss = (tloss * i + loss.item()) / (i + 1)  # update mean losses\n                mem = \"%.3gG\" % (torch.cuda.memory_reserved() / 1e9 if torch.cuda.is_available() else 0)  # (GB)\n                pbar.desc = f\"{f'{epoch + 1}/{epochs}':>10}{mem:>10}{tloss:>12.3g}\" + \" \" * 36\n\n                # Test\n                if i == len(pbar) - 1:  # last batch\n                    top1, top5, vloss = validate.run(\n                        model=ema.ema, dataloader=testloader, criterion=criterion, pbar=pbar\n                    )  # test accuracy, loss\n                    fitness = top1  # define fitness as top1 accuracy\n\n        # Scheduler\n        scheduler.step()\n\n        # Log metrics\n        if RANK in {-1, 0}:\n            # Best fitness\n            if fitness > best_fitness:\n                best_fitness = fitness\n\n            # Log\n            metrics = {\n                \"train/loss\": tloss,\n                f\"{val}/loss\": vloss,\n                \"metrics/accuracy_top1\": top1,\n                \"metrics/accuracy_top5\": top5,\n                \"lr/0\": optimizer.param_groups[0][\"lr\"],\n            }  # learning rate\n            logger.log_metrics(metrics, epoch)\n\n            # Save model\n            final_epoch = epoch + 1 == epochs\n            if (not opt.nosave) or final_epoch:\n                ckpt = {\n                    \"epoch\": epoch,\n                    \"best_fitness\": best_fitness,\n                    \"model\": deepcopy(ema.ema).half(),  # deepcopy(de_parallel(model)).half(),\n                    \"ema\": None,  # deepcopy(ema.ema).half(),\n                    \"updates\": ema.updates,\n                    \"optimizer\": None,  # optimizer.state_dict(),\n                    \"opt\": vars(opt),\n                    \"git\": GIT_INFO,  # {remote, branch, commit} if a git repo\n                    \"date\": datetime.now().isoformat(),\n                }\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fitness:\n                    torch.save(ckpt, best)\n                del ckpt\n\n    # Train complete\n    if RANK in {-1, 0} and final_epoch:\n        LOGGER.info(\n            f'\\nTraining complete ({(time.time() - t0) / 3600:.3f} hours)'\n            f\"\\nResults saved to {colorstr('bold', save_dir)}\"\n            f'\\nPredict:         python classify/predict.py --weights {best} --source im.jpg'\n            f'\\nValidate:        python classify/val.py --weights {best} --data {data_dir}'\n            f'\\nExport:          python export.py --weights {best} --include onnx'\n            f\"\\nPyTorch Hub:     model = torch.hub.load('ultralytics/yolov5', 'custom', '{best}')\"\n            f'\\nVisualize:       https://netron.app\\n'\n        )\n\n        # Plot examples\n        images, labels = (x[:25] for x in next(iter(testloader)))  # first 25 images and labels\n        pred = torch.max(ema.ema(images.to(device)), 1)[1]\n        file = imshow_cls(images, labels, pred, de_parallel(model).names, verbose=False, f=save_dir / \"test_images.jpg\")\n\n        # Log results\n        meta = {\"epochs\": epochs, \"top1_acc\": best_fitness, \"date\": datetime.now().isoformat()}\n        logger.log_images(file, name=\"Test Examples (true-predicted)\", epoch=epoch)\n        logger.log_model(best, epochs, metadata=meta)\n\n\ndef parse_opt(known=False):\n    \"\"\"Parses command line arguments for YOLOv5 training including model path, dataset, epochs, and more, returning\n    parsed arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--model\", type=str, default=\"yolov5s-cls.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--data\", type=str, default=\"imagenette160\", help=\"cifar10, cifar100, mnist, imagenet, ...\")\n    parser.add_argument(\"--epochs\", type=int, default=10, help=\"total training epochs\")\n    parser.add_argument(\"--batch-size\", type=int, default=64, help=\"total batch size for all GPUs\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", type=int, default=224, help=\"train, val image size (pixels)\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"only save final checkpoint\")\n    parser.add_argument(\"--cache\", type=str, nargs=\"?\", const=\"ram\", help='--cache images in \"ram\" (default) or \"disk\"')\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--workers\", type=int, default=8, help=\"max dataloader workers (per RANK in DDP mode)\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/train-cls\", help=\"save to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--pretrained\", nargs=\"?\", const=True, default=True, help=\"start from i.e. --pretrained False\")\n    parser.add_argument(\"--optimizer\", choices=[\"SGD\", \"Adam\", \"AdamW\", \"RMSProp\"], default=\"Adam\", help=\"optimizer\")\n    parser.add_argument(\"--lr0\", type=float, default=0.001, help=\"initial learning rate\")\n    parser.add_argument(\"--decay\", type=float, default=5e-5, help=\"weight decay\")\n    parser.add_argument(\"--label-smoothing\", type=float, default=0.1, help=\"Label smoothing epsilon\")\n    parser.add_argument(\"--cutoff\", type=int, default=None, help=\"Model layer cutoff index for Classify() head\")\n    parser.add_argument(\"--dropout\", type=float, default=None, help=\"Dropout (fraction)\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Verbose mode\")\n    parser.add_argument(\"--seed\", type=int, default=0, help=\"Global training seed\")\n    parser.add_argument(\"--local_rank\", type=int, default=-1, help=\"Automatic DDP Multi-GPU argument, do not modify\")\n    return parser.parse_known_args()[0] if known else parser.parse_args()\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 training with given options, handling device setup and DDP mode; includes pre-training checks.\"\"\"\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements(ROOT / \"requirements.txt\")\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        assert opt.batch_size != -1, \"AutoBatch is coming soon for classification, please pass a valid --batch-size\"\n        assert opt.batch_size % WORLD_SIZE == 0, f\"--batch-size {opt.batch_size} must be multiple of WORLD_SIZE\"\n        assert torch.cuda.device_count() > LOCAL_RANK, \"insufficient CUDA devices for DDP command\"\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device(\"cuda\", LOCAL_RANK)\n        dist.init_process_group(backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n\n    # Parameters\n    opt.save_dir = increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok)  # increment run\n\n    # Train\n    train(opt, device)\n\n\ndef run(**kwargs):\n    \"\"\"\n    Executes YOLOv5 model training or inference with specified parameters, returning updated options.\n\n    Example: from yolov5 import classify; classify.train.run(data=mnist, imgsz=320, model='yolov5m')\n    \"\"\"\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n", "classify/predict.py": "# Ultralytics YOLOv5 \ud83d\ude80, AGPL-3.0 license\n\"\"\"\nRun YOLOv5 classification inference on images, videos, directories, globs, YouTube, webcam, streams, etc.\n\nUsage - sources:\n    $ python classify/predict.py --weights yolov5s-cls.pt --source 0                               # webcam\n                                                                   img.jpg                         # image\n                                                                   vid.mp4                         # video\n                                                                   screen                          # screenshot\n                                                                   path/                           # directory\n                                                                   list.txt                        # list of images\n                                                                   list.streams                    # list of streams\n                                                                   'path/*.jpg'                    # glob\n                                                                   'https://youtu.be/LNwODJXcvt4'  # YouTube\n                                                                   'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP stream\n\nUsage - formats:\n    $ python classify/predict.py --weights yolov5s-cls.pt                 # PyTorch\n                                           yolov5s-cls.torchscript        # TorchScript\n                                           yolov5s-cls.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n                                           yolov5s-cls_openvino_model     # OpenVINO\n                                           yolov5s-cls.engine             # TensorRT\n                                           yolov5s-cls.mlmodel            # CoreML (macOS-only)\n                                           yolov5s-cls_saved_model        # TensorFlow SavedModel\n                                           yolov5s-cls.pb                 # TensorFlow GraphDef\n                                           yolov5s-cls.tflite             # TensorFlow Lite\n                                           yolov5s-cls_edgetpu.tflite     # TensorFlow Edge TPU\n                                           yolov5s-cls_paddle_model       # PaddlePaddle\n\"\"\"\n\nimport argparse\nimport os\nimport platform\nimport sys\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\n\nFILE = Path(__file__).resolve()\nROOT = FILE.parents[1]  # YOLOv5 root directory\nif str(ROOT) not in sys.path:\n    sys.path.append(str(ROOT))  # add ROOT to PATH\nROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n\nfrom ultralytics.utils.plotting import Annotator\n\nfrom models.common import DetectMultiBackend\nfrom utils.augmentations import classify_transforms\nfrom utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams\nfrom utils.general import (\n    LOGGER,\n    Profile,\n    check_file,\n    check_img_size,\n    check_imshow,\n    check_requirements,\n    colorstr,\n    cv2,\n    increment_path,\n    print_args,\n    strip_optimizer,\n)\nfrom utils.torch_utils import select_device, smart_inference_mode\n\n\n@smart_inference_mode()\ndef run(\n    weights=ROOT / \"yolov5s-cls.pt\",  # model.pt path(s)\n    source=ROOT / \"data/images\",  # file/dir/URL/glob/screen/0(webcam)\n    data=ROOT / \"data/coco128.yaml\",  # dataset.yaml path\n    imgsz=(224, 224),  # inference size (height, width)\n    device=\"\",  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    view_img=False,  # show results\n    save_txt=False,  # save results to *.txt\n    nosave=False,  # do not save images/videos\n    augment=False,  # augmented inference\n    visualize=False,  # visualize features\n    update=False,  # update all models\n    project=ROOT / \"runs/predict-cls\",  # save results to project/name\n    name=\"exp\",  # save results to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    vid_stride=1,  # video frame-rate stride\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith(\".txt\")  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith((\"rtsp://\", \"rtmp://\", \"http://\", \"https://\"))\n    webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n    screenshot = source.lower().startswith(\"screen\")\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / \"labels\" if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, transforms=classify_transforms(imgsz[0]), vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, transforms=classify_transforms(imgsz[0]), vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(device=device), Profile(device=device), Profile(device=device))\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.Tensor(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            results = model(im)\n\n        # Post-process\n        with dt[2]:\n            pred = F.softmax(results, dim=1)  # probabilities\n\n        # Process predictions\n        for i, prob in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f\"{i}: \"\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, \"frame\", 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / \"labels\" / p.stem) + (\"\" if dataset.mode == \"image\" else f\"_{frame}\")  # im.txt\n\n            s += \"%gx%g \" % im.shape[2:]  # print string\n            annotator = Annotator(im0, example=str(names), pil=True)\n\n            # Print results\n            top5i = prob.argsort(0, descending=True)[:5].tolist()  # top 5 indices\n            s += f\"{', '.join(f'{names[j]} {prob[j]:.2f}' for j in top5i)}, \"\n\n            # Write results\n            text = \"\\n\".join(f\"{prob[j]:.2f} {names[j]}\" for j in top5i)\n            if save_img or view_img:  # Add bbox to image\n                annotator.text([32, 32], text, txt_color=(255, 255, 255))\n            if save_txt:  # Write to file\n                with open(f\"{txt_path}.txt\", \"a\") as f:\n                    f.write(text + \"\\n\")\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == \"Linux\" and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == \"image\":\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix(\".mp4\"))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*\"mp4v\"), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1e3 for x in dt)  # speeds per image\n    LOGGER.info(f\"Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}\" % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)\n\n\ndef parse_opt():\n    \"\"\"Parses command line arguments for YOLOv5 inference settings including model, source, device, and image size.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", nargs=\"+\", type=str, default=ROOT / \"yolov5s-cls.pt\", help=\"model path(s)\")\n    parser.add_argument(\"--source\", type=str, default=ROOT / \"data/images\", help=\"file/dir/URL/glob/screen/0(webcam)\")\n    parser.add_argument(\"--data\", type=str, default=ROOT / \"data/coco128.yaml\", help=\"(optional) dataset.yaml path\")\n    parser.add_argument(\"--imgsz\", \"--img\", \"--img-size\", nargs=\"+\", type=int, default=[224], help=\"inference size h,w\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--view-img\", action=\"store_true\", help=\"show results\")\n    parser.add_argument(\"--save-txt\", action=\"store_true\", help=\"save results to *.txt\")\n    parser.add_argument(\"--nosave\", action=\"store_true\", help=\"do not save images/videos\")\n    parser.add_argument(\"--augment\", action=\"store_true\", help=\"augmented inference\")\n    parser.add_argument(\"--visualize\", action=\"store_true\", help=\"visualize features\")\n    parser.add_argument(\"--update\", action=\"store_true\", help=\"update all models\")\n    parser.add_argument(\"--project\", default=ROOT / \"runs/predict-cls\", help=\"save results to project/name\")\n    parser.add_argument(\"--name\", default=\"exp\", help=\"save results to project/name\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--half\", action=\"store_true\", help=\"use FP16 half-precision inference\")\n    parser.add_argument(\"--dnn\", action=\"store_true\", help=\"use OpenCV DNN for ONNX inference\")\n    parser.add_argument(\"--vid-stride\", type=int, default=1, help=\"video frame-rate stride\")\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt\n\n\ndef main(opt):\n    \"\"\"Executes YOLOv5 model inference with options for ONNX DNN and video frame-rate stride adjustments.\"\"\"\n    check_requirements(ROOT / \"requirements.txt\", exclude=(\"tensorboard\", \"thop\"))\n    run(**vars(opt))\n\n\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)\n"}