{"release.py": "#!/usr/bin/env python\nfrom subprocess import call\nimport os\nimport re\n\n\nversion = None\n\n\ndef get_new_setup_py_lines():\n    global version\n    with open('setup.py', 'r') as sf:\n        current_setup = sf.readlines()\n    for line in current_setup:\n        if line.startswith('VERSION = '):\n            major, minor = re.findall(r\"VERSION = '(\\d+)\\.(\\d+)'\", line)[0]\n            version = \"{}.{}\".format(major, int(minor) + 1)\n            yield \"VERSION = '{}'\\n\".format(version)\n        else:\n            yield line\n\n\nlines = list(get_new_setup_py_lines())\nwith open('setup.py', 'w') as sf:\n    sf.writelines(lines)\n\ncall('git pull', shell=True)\ncall('git commit -am \"Bump to {}\"'.format(version), shell=True)\ncall('git tag {}'.format(version), shell=True)\ncall('git push', shell=True)\ncall('git push --tags', shell=True)\n\nenv = os.environ\nenv['CONVERT_README'] = 'true'\ncall('rm -rf dist/*', shell=True, env=env)\ncall('python setup.py sdist bdist_wheel', shell=True, env=env)\ncall('twine upload dist/*', shell=True, env=env)\n", "fastentrypoints.py": "# Copyright (c) 2016, Aaron Christianson\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n# IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n'''\nMonkey patch setuptools to write faster console_scripts with this format:\n\n    import sys\n    from mymodule import entry_function\n    sys.exit(entry_function())\n\nThis is better.\n\n(c) 2016, Aaron Christianson\nhttp://github.com/ninjaaron/fast-entry_points\n'''\nfrom setuptools.command import easy_install\nimport re\nTEMPLATE = r'''\\\n# -*- coding: utf-8 -*-\n# EASY-INSTALL-ENTRY-SCRIPT: '{3}','{4}','{5}'\n__requires__ = '{3}'\nimport re\nimport sys\n\nfrom {0} import {1}\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n    sys.exit({2}())'''\n\n\n@classmethod\ndef get_args(cls, dist, header=None):\n    \"\"\"\n    Yield write_script() argument tuples for a distribution's\n    console_scripts and gui_scripts entry points.\n    \"\"\"\n    if header is None:\n        header = cls.get_header()\n    spec = str(dist.as_requirement())\n    for type_ in 'console', 'gui':\n        group = type_ + '_scripts'\n        for name, ep in dist.get_entry_map(group).items():\n            # ensure_safe_name\n            if re.search(r'[\\\\/]', name):\n                raise ValueError(\"Path separators not allowed in script names\")\n            script_text = TEMPLATE.format(\n                          ep.module_name, ep.attrs[0], '.'.join(ep.attrs),\n                          spec, group, name)\n            args = cls._get_script_args(type_, name, header, script_text)\n            for res in args:\n                yield res\n\n\neasy_install.ScriptWriter.get_args = get_args\n\n\ndef main():\n    import os\n    import re\n    import shutil\n    import sys\n    dests = sys.argv[1:] or ['.']\n    filename = re.sub(r'\\.pyc$', '.py', __file__)\n\n    for dst in dests:\n        shutil.copy(filename, dst)\n        manifest_path = os.path.join(dst, 'MANIFEST.in')\n        setup_path = os.path.join(dst, 'setup.py')\n\n        # Insert the include statement to MANIFEST.in if not present\n        with open(manifest_path, 'a+') as manifest:\n            manifest.seek(0)\n            manifest_content = manifest.read()\n            if not 'include fastentrypoints.py' in manifest_content:\n                manifest.write(('\\n' if manifest_content else '')\n                               + 'include fastentrypoints.py')\n\n        # Insert the import statement to setup.py if not present\n        with open(setup_path, 'a+') as setup:\n            setup.seek(0)\n            setup_content = setup.read()\n            if not 'import fastentrypoints' in setup_content:\n                setup.seek(0)\n                setup.truncate()\n                setup.write('import fastentrypoints\\n' + setup_content)\n\nprint(__name__)\n", "setup.py": "#!/usr/bin/env python\nfrom setuptools import setup, find_packages\nimport pkg_resources\nimport sys\nimport os\nimport fastentrypoints\n\n\ntry:\n    if int(pkg_resources.get_distribution(\"pip\").version.split('.')[0]) < 6:\n        print('pip older than 6.0 not supported, please upgrade pip with:\\n\\n'\n              '    pip install -U pip')\n        sys.exit(-1)\nexcept pkg_resources.DistributionNotFound:\n    pass\n\nif os.environ.get('CONVERT_README'):\n    import pypandoc\n\n    long_description = pypandoc.convert('README.md', 'rst')\nelse:\n    long_description = ''\n\nversion = sys.version_info[:2]\nif version < (2, 7):\n    print('thefuck requires Python version 2.7 or later' +\n          ' ({}.{} detected).'.format(*version))\n    sys.exit(-1)\nelif (3, 0) < version < (3, 5):\n    print('thefuck requires Python version 3.5 or later' +\n          ' ({}.{} detected).'.format(*version))\n    sys.exit(-1)\n\nVERSION = '3.32'\n\ninstall_requires = ['psutil', 'colorama', 'six']\nextras_require = {':python_version<\"3.4\"': ['pathlib2'],\n                  ':python_version<\"3.3\"': ['backports.shutil_get_terminal_size'],\n                  ':python_version<=\"2.7\"': ['decorator<5', 'pyte<0.8.1'],\n                  ':python_version>\"2.7\"': ['decorator', 'pyte'],\n                  \":sys_platform=='win32'\": ['win_unicode_console']}\n\nif sys.platform == \"win32\":\n    scripts = ['scripts\\\\fuck.bat', 'scripts\\\\fuck.ps1']\n    entry_points = {'console_scripts': [\n                  'thefuck = thefuck.entrypoints.main:main',\n                  'thefuck_firstuse = thefuck.entrypoints.not_configured:main']}\nelse:\n    scripts = []\n    entry_points = {'console_scripts': [\n                  'thefuck = thefuck.entrypoints.main:main',\n                  'fuck = thefuck.entrypoints.not_configured:main']}\n\nsetup(name='thefuck',\n      version=VERSION,\n      description=\"Magnificent app which corrects your previous console command\",\n      long_description=long_description,\n      author='Vladimir Iakovlev',\n      author_email='nvbn.rm@gmail.com',\n      url='https://github.com/nvbn/thefuck',\n      license='MIT',\n      packages=find_packages(exclude=['ez_setup', 'examples',\n                                      'tests', 'tests.*', 'release']),\n      include_package_data=True,\n      zip_safe=False,\n      python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*',\n      install_requires=install_requires,\n      extras_require=extras_require,\n      scripts=scripts,\n      entry_points=entry_points)\n", "thefuck/corrector.py": "import sys\nfrom .conf import settings\nfrom .types import Rule\nfrom .system import Path\nfrom . import logs\n\n\ndef get_loaded_rules(rules_paths):\n    \"\"\"Yields all available rules.\n\n    :type rules_paths: [Path]\n    :rtype: Iterable[Rule]\n\n    \"\"\"\n    for path in rules_paths:\n        if path.name != '__init__.py':\n            rule = Rule.from_path(path)\n            if rule and rule.is_enabled:\n                yield rule\n\n\ndef get_rules_import_paths():\n    \"\"\"Yields all rules import paths.\n\n    :rtype: Iterable[Path]\n\n    \"\"\"\n    # Bundled rules:\n    yield Path(__file__).parent.joinpath('rules')\n    # Rules defined by user:\n    yield settings.user_dir.joinpath('rules')\n    # Packages with third-party rules:\n    for path in sys.path:\n        for contrib_module in Path(path).glob('thefuck_contrib_*'):\n            contrib_rules = contrib_module.joinpath('rules')\n            if contrib_rules.is_dir():\n                yield contrib_rules\n\n\ndef get_rules():\n    \"\"\"Returns all enabled rules.\n\n    :rtype: [Rule]\n\n    \"\"\"\n    paths = [rule_path for path in get_rules_import_paths()\n             for rule_path in sorted(path.glob('*.py'))]\n    return sorted(get_loaded_rules(paths),\n                  key=lambda rule: rule.priority)\n\n\ndef organize_commands(corrected_commands):\n    \"\"\"Yields sorted commands without duplicates.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \"\"\"\n    try:\n        first_command = next(corrected_commands)\n        yield first_command\n    except StopIteration:\n        return\n\n    without_duplicates = {\n        command for command in sorted(\n            corrected_commands, key=lambda command: command.priority)\n        if command != first_command}\n\n    sorted_commands = sorted(\n        without_duplicates,\n        key=lambda corrected_command: corrected_command.priority)\n\n    logs.debug(u'Corrected commands: {}'.format(\n        ', '.join(u'{}'.format(cmd) for cmd in [first_command] + sorted_commands)))\n\n    for command in sorted_commands:\n        yield command\n\n\ndef get_corrected_commands(command):\n    \"\"\"Returns generator with sorted and unique corrected commands.\n\n    :type command: thefuck.types.Command\n    :rtype: Iterable[thefuck.types.CorrectedCommand]\n\n    \"\"\"\n    corrected_commands = (\n        corrected for rule in get_rules()\n        if rule.is_match(command)\n        for corrected in rule.get_corrected_commands(command))\n    return organize_commands(corrected_commands)\n", "thefuck/logs.py": "# -*- encoding: utf-8 -*-\n\nfrom contextlib import contextmanager\nfrom datetime import datetime\nimport sys\nfrom traceback import format_exception\nimport colorama\nfrom .conf import settings\nfrom . import const\n\n\ndef color(color_):\n    \"\"\"Utility for ability to disabling colored output.\"\"\"\n    if settings.no_colors:\n        return ''\n    else:\n        return color_\n\n\ndef warn(title):\n    sys.stderr.write(u'{warn}[WARN] {title}{reset}\\n'.format(\n        warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                   + colorama.Style.BRIGHT),\n        reset=color(colorama.Style.RESET_ALL),\n        title=title))\n\n\ndef exception(title, exc_info):\n    sys.stderr.write(\n        u'{warn}[WARN] {title}:{reset}\\n{trace}'\n        u'{warn}----------------------------{reset}\\n\\n'.format(\n            warn=color(colorama.Back.RED + colorama.Fore.WHITE\n                       + colorama.Style.BRIGHT),\n            reset=color(colorama.Style.RESET_ALL),\n            title=title,\n            trace=''.join(format_exception(*exc_info))))\n\n\ndef rule_failed(rule, exc_info):\n    exception(u'Rule {}'.format(rule.name), exc_info)\n\n\ndef failed(msg):\n    sys.stderr.write(u'{red}{msg}{reset}\\n'.format(\n        msg=msg,\n        red=color(colorama.Fore.RED),\n        reset=color(colorama.Style.RESET_ALL)))\n\n\ndef show_corrected_command(corrected_command):\n    sys.stderr.write(u'{prefix}{bold}{script}{reset}{side_effect}\\n'.format(\n        prefix=const.USER_COMMAND_MARK,\n        script=corrected_command.script,\n        side_effect=u' (+side effect)' if corrected_command.side_effect else u'',\n        bold=color(colorama.Style.BRIGHT),\n        reset=color(colorama.Style.RESET_ALL)))\n\n\ndef confirm_text(corrected_command):\n    sys.stderr.write(\n        (u'{prefix}{clear}{bold}{script}{reset}{side_effect} '\n         u'[{green}enter{reset}/{blue}\u2191{reset}/{blue}\u2193{reset}'\n         u'/{red}ctrl+c{reset}]').format(\n            prefix=const.USER_COMMAND_MARK,\n            script=corrected_command.script,\n            side_effect=' (+side effect)' if corrected_command.side_effect else '',\n            clear='\\033[1K\\r',\n            bold=color(colorama.Style.BRIGHT),\n            green=color(colorama.Fore.GREEN),\n            red=color(colorama.Fore.RED),\n            reset=color(colorama.Style.RESET_ALL),\n            blue=color(colorama.Fore.BLUE)))\n\n\ndef debug(msg):\n    if settings.debug:\n        sys.stderr.write(u'{blue}{bold}DEBUG:{reset} {msg}\\n'.format(\n            msg=msg,\n            reset=color(colorama.Style.RESET_ALL),\n            blue=color(colorama.Fore.BLUE),\n            bold=color(colorama.Style.BRIGHT)))\n\n\n@contextmanager\ndef debug_time(msg):\n    started = datetime.now()\n    try:\n        yield\n    finally:\n        debug(u'{} took: {}'.format(msg, datetime.now() - started))\n\n\ndef how_to_configure_alias(configuration_details):\n    print(u\"Seems like {bold}fuck{reset} alias isn't configured!\".format(\n        bold=color(colorama.Style.BRIGHT),\n        reset=color(colorama.Style.RESET_ALL)))\n\n    if configuration_details:\n        print(\n            u\"Please put {bold}{content}{reset} in your \"\n            u\"{bold}{path}{reset} and apply \"\n            u\"changes with {bold}{reload}{reset} or restart your shell.\".format(\n                bold=color(colorama.Style.BRIGHT),\n                reset=color(colorama.Style.RESET_ALL),\n                **configuration_details._asdict()))\n\n        if configuration_details.can_configure_automatically:\n            print(\n                u\"Or run {bold}fuck{reset} a second time to configure\"\n                u\" it automatically.\".format(\n                    bold=color(colorama.Style.BRIGHT),\n                    reset=color(colorama.Style.RESET_ALL)))\n\n    print(u'More details - https://github.com/nvbn/thefuck#manual-installation')\n\n\ndef already_configured(configuration_details):\n    print(\n        u\"Seems like {bold}fuck{reset} alias already configured!\\n\"\n        u\"For applying changes run {bold}{reload}{reset}\"\n        u\" or restart your shell.\".format(\n            bold=color(colorama.Style.BRIGHT),\n            reset=color(colorama.Style.RESET_ALL),\n            reload=configuration_details.reload))\n\n\ndef configured_successfully(configuration_details):\n    print(\n        u\"{bold}fuck{reset} alias configured successfully!\\n\"\n        u\"For applying changes run {bold}{reload}{reset}\"\n        u\" or restart your shell.\".format(\n            bold=color(colorama.Style.BRIGHT),\n            reset=color(colorama.Style.RESET_ALL),\n            reload=configuration_details.reload))\n\n\ndef version(thefuck_version, python_version, shell_info):\n    sys.stderr.write(\n        u'The Fuck {} using Python {} and {}\\n'.format(thefuck_version,\n                                                       python_version,\n                                                       shell_info))\n", "thefuck/exceptions.py": "class EmptyCommand(Exception):\n    \"\"\"Raised when empty command passed to `thefuck`.\"\"\"\n\n\nclass NoRuleMatched(Exception):\n    \"\"\"Raised when no rule matched for some command.\"\"\"\n\n\nclass ScriptNotInLog(Exception):\n    \"\"\"Script not found in log.\"\"\"\n", "thefuck/utils.py": "import atexit\nimport os\nimport pickle\nimport re\nimport shelve\nimport sys\nimport six\nfrom decorator import decorator\nfrom difflib import get_close_matches as difflib_get_close_matches\nfrom functools import wraps\nfrom .logs import warn, exception\nfrom .conf import settings\nfrom .system import Path\n\nDEVNULL = open(os.devnull, 'w')\n\nif six.PY2:\n    import anydbm\n    shelve_open_error = anydbm.error\nelse:\n    import dbm\n    shelve_open_error = dbm.error\n\n\ndef memoize(fn):\n    \"\"\"Caches previous calls to the function.\"\"\"\n    memo = {}\n\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        if not memoize.disabled:\n            key = pickle.dumps((args, kwargs))\n            if key not in memo:\n                memo[key] = fn(*args, **kwargs)\n            value = memo[key]\n        else:\n            # Memoize is disabled, call the function\n            value = fn(*args, **kwargs)\n\n        return value\n\n    return wrapper\n\n\nmemoize.disabled = False\n\n\n@memoize\ndef which(program):\n    \"\"\"Returns `program` path or `None`.\"\"\"\n    try:\n        from shutil import which\n\n        return which(program)\n    except ImportError:\n        def is_exe(fpath):\n            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n\n        fpath, fname = os.path.split(program)\n        if fpath:\n            if is_exe(program):\n                return program\n        else:\n            for path in os.environ[\"PATH\"].split(os.pathsep):\n                path = path.strip('\"')\n                exe_file = os.path.join(path, program)\n                if is_exe(exe_file):\n                    return exe_file\n\n        return None\n\n\ndef default_settings(params):\n    \"\"\"Adds default values to settings if it not presented.\n\n    Usage:\n\n        @default_settings({'apt': '/usr/bin/apt'})\n        def match(command):\n            print(settings.apt)\n\n    \"\"\"\n    def _default_settings(fn, command):\n        for k, w in params.items():\n            settings.setdefault(k, w)\n        return fn(command)\n    return decorator(_default_settings)\n\n\ndef get_closest(word, possibilities, cutoff=0.6, fallback_to_first=True):\n    \"\"\"Returns closest match or just first from possibilities.\"\"\"\n    possibilities = list(possibilities)\n    try:\n        return difflib_get_close_matches(word, possibilities, 1, cutoff)[0]\n    except IndexError:\n        if fallback_to_first:\n            return possibilities[0]\n\n\ndef get_close_matches(word, possibilities, n=None, cutoff=0.6):\n    \"\"\"Overrides `difflib.get_close_match` to control argument `n`.\"\"\"\n    if n is None:\n        n = settings.num_close_matches\n    return difflib_get_close_matches(word, possibilities, n, cutoff)\n\n\ndef include_path_in_search(path):\n    return not any(path.startswith(x) for x in settings.excluded_search_path_prefixes)\n\n\n@memoize\ndef get_all_executables():\n    from thefuck.shells import shell\n\n    def _safe(fn, fallback):\n        try:\n            return fn()\n        except OSError:\n            return fallback\n\n    tf_alias = get_alias()\n    tf_entry_points = ['thefuck', 'fuck']\n\n    bins = [exe.name.decode('utf8') if six.PY2 else exe.name\n            for path in os.environ.get('PATH', '').split(os.pathsep)\n            if include_path_in_search(path)\n            for exe in _safe(lambda: list(Path(path).iterdir()), [])\n            if not _safe(exe.is_dir, True)\n            and exe.name not in tf_entry_points]\n    aliases = [alias.decode('utf8') if six.PY2 else alias\n               for alias in shell.get_aliases() if alias != tf_alias]\n\n    return bins + aliases\n\n\ndef replace_argument(script, from_, to):\n    \"\"\"Replaces command line argument.\"\"\"\n    replaced_in_the_end = re.sub(u' {}$'.format(re.escape(from_)), u' {}'.format(to),\n                                 script, count=1)\n    if replaced_in_the_end != script:\n        return replaced_in_the_end\n    else:\n        return script.replace(\n            u' {} '.format(from_), u' {} '.format(to), 1)\n\n\n@decorator\ndef eager(fn, *args, **kwargs):\n    return list(fn(*args, **kwargs))\n\n\n@eager\ndef get_all_matched_commands(stderr, separator='Did you mean'):\n    if not isinstance(separator, list):\n        separator = [separator]\n    should_yield = False\n    for line in stderr.split('\\n'):\n        for sep in separator:\n            if sep in line:\n                should_yield = True\n                break\n        else:\n            if should_yield and line:\n                yield line.strip()\n\n\ndef replace_command(command, broken, matched):\n    \"\"\"Helper for *_no_command rules.\"\"\"\n    new_cmds = get_close_matches(broken, matched, cutoff=0.1)\n    return [replace_argument(command.script, broken, new_cmd.strip())\n            for new_cmd in new_cmds]\n\n\n@memoize\ndef is_app(command, *app_names, **kwargs):\n    \"\"\"Returns `True` if command is call to one of passed app names.\"\"\"\n\n    at_least = kwargs.pop('at_least', 0)\n    if kwargs:\n        raise TypeError(\"got an unexpected keyword argument '{}'\".format(kwargs.keys()))\n\n    if len(command.script_parts) > at_least:\n        return os.path.basename(command.script_parts[0]) in app_names\n\n    return False\n\n\ndef for_app(*app_names, **kwargs):\n    \"\"\"Specifies that matching script is for one of app names.\"\"\"\n    def _for_app(fn, command):\n        if is_app(command, *app_names, **kwargs):\n            return fn(command)\n        else:\n            return False\n\n    return decorator(_for_app)\n\n\nclass Cache(object):\n    \"\"\"Lazy read cache and save changes at exit.\"\"\"\n\n    def __init__(self):\n        self._db = None\n\n    def _init_db(self):\n        try:\n            self._setup_db()\n        except Exception:\n            exception(\"Unable to init cache\", sys.exc_info())\n            self._db = {}\n\n    def _setup_db(self):\n        cache_dir = self._get_cache_dir()\n        cache_path = Path(cache_dir).joinpath('thefuck').as_posix()\n\n        try:\n            self._db = shelve.open(cache_path)\n        except shelve_open_error + (ImportError,):\n            # Caused when switching between Python versions\n            warn(\"Removing possibly out-dated cache\")\n            os.remove(cache_path)\n            self._db = shelve.open(cache_path)\n\n        atexit.register(self._db.close)\n\n    def _get_cache_dir(self):\n        default_xdg_cache_dir = os.path.expanduser(\"~/.cache\")\n        cache_dir = os.getenv(\"XDG_CACHE_HOME\", default_xdg_cache_dir)\n\n        # Ensure the cache_path exists, Python 2 does not have the exist_ok\n        # parameter\n        try:\n            os.makedirs(cache_dir)\n        except OSError:\n            if not os.path.isdir(cache_dir):\n                raise\n\n        return cache_dir\n\n    def _get_mtime(self, path):\n        try:\n            return str(os.path.getmtime(path))\n        except OSError:\n            return '0'\n\n    def _get_key(self, fn, depends_on, args, kwargs):\n        parts = (fn.__module__, repr(fn).split('at')[0],\n                 depends_on, args, kwargs)\n        return str(pickle.dumps(parts))\n\n    def get_value(self, fn, depends_on, args, kwargs):\n        if self._db is None:\n            self._init_db()\n\n        depends_on = [Path(name).expanduser().absolute().as_posix()\n                      for name in depends_on]\n        key = self._get_key(fn, depends_on, args, kwargs)\n        etag = '.'.join(self._get_mtime(path) for path in depends_on)\n\n        if self._db.get(key, {}).get('etag') == etag:\n            return self._db[key]['value']\n        else:\n            value = fn(*args, **kwargs)\n            self._db[key] = {'etag': etag, 'value': value}\n            return value\n\n\n_cache = Cache()\n\n\ndef cache(*depends_on):\n    \"\"\"Caches function result in temporary file.\n\n    Cache will be expired when modification date of files from `depends_on`\n    will be changed.\n\n    Only functions should be wrapped in `cache`, not methods.\n\n    \"\"\"\n    def cache_decorator(fn):\n        @memoize\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            if cache.disabled:\n                return fn(*args, **kwargs)\n            else:\n                return _cache.get_value(fn, depends_on, args, kwargs)\n\n        return wrapper\n\n    return cache_decorator\n\n\ncache.disabled = False\n\n\ndef get_installation_version():\n    try:\n        from importlib.metadata import version\n\n        return version('thefuck')\n    except ImportError:\n        import pkg_resources\n\n        return pkg_resources.require('thefuck')[0].version\n\n\ndef get_alias():\n    return os.environ.get('TF_ALIAS', 'fuck')\n\n\n@memoize\ndef get_valid_history_without_current(command):\n    def _not_corrected(history, tf_alias):\n        \"\"\"Returns all lines from history except that comes before `fuck`.\"\"\"\n        previous = None\n        for line in history:\n            if previous is not None and line != tf_alias:\n                yield previous\n            previous = line\n        if history:\n            yield history[-1]\n\n    from thefuck.shells import shell\n    history = shell.get_history()\n    tf_alias = get_alias()\n    executables = set(get_all_executables())\\\n        .union(shell.get_builtin_commands())\n\n    return [line for line in _not_corrected(history, tf_alias)\n            if not line.startswith(tf_alias) and not line == command.script\n            and line.split(' ')[0] in executables]\n\n\ndef format_raw_script(raw_script):\n    \"\"\"Creates single script from a list of script parts.\n\n    :type raw_script: [basestring]\n    :rtype: basestring\n\n    \"\"\"\n    if six.PY2:\n        script = ' '.join(arg.decode('utf-8') for arg in raw_script)\n    else:\n        script = ' '.join(raw_script)\n\n    return script.lstrip()\n", "thefuck/argument_parser.py": "import sys\nfrom argparse import ArgumentParser, SUPPRESS\nfrom .const import ARGUMENT_PLACEHOLDER\nfrom .utils import get_alias\n\n\nclass Parser(object):\n    \"\"\"Argument parser that can handle arguments with our special\n    placeholder.\n\n    \"\"\"\n\n    def __init__(self):\n        self._parser = ArgumentParser(prog='thefuck', add_help=False)\n        self._add_arguments()\n\n    def _add_arguments(self):\n        \"\"\"Adds arguments to parser.\"\"\"\n        self._parser.add_argument(\n            '-v', '--version',\n            action='store_true',\n            help=\"show program's version number and exit\")\n        self._parser.add_argument(\n            '-a', '--alias',\n            nargs='?',\n            const=get_alias(),\n            help='[custom-alias-name] prints alias for current shell')\n        self._parser.add_argument(\n            '-l', '--shell-logger',\n            action='store',\n            help='log shell output to the file')\n        self._parser.add_argument(\n            '--enable-experimental-instant-mode',\n            action='store_true',\n            help='enable experimental instant mode, use on your own risk')\n        self._parser.add_argument(\n            '-h', '--help',\n            action='store_true',\n            help='show this help message and exit')\n        self._add_conflicting_arguments()\n        self._parser.add_argument(\n            '-d', '--debug',\n            action='store_true',\n            help='enable debug output')\n        self._parser.add_argument(\n            '--force-command',\n            action='store',\n            help=SUPPRESS)\n        self._parser.add_argument(\n            'command',\n            nargs='*',\n            help='command that should be fixed')\n\n    def _add_conflicting_arguments(self):\n        \"\"\"It's too dangerous to use `-y` and `-r` together.\"\"\"\n        group = self._parser.add_mutually_exclusive_group()\n        group.add_argument(\n            '-y', '--yes', '--yeah', '--hard',\n            action='store_true',\n            help='execute fixed command without confirmation')\n        group.add_argument(\n            '-r', '--repeat',\n            action='store_true',\n            help='repeat on failure')\n\n    def _prepare_arguments(self, argv):\n        \"\"\"Prepares arguments by:\n\n        - removing placeholder and moving arguments after it to beginning,\n          we need this to distinguish arguments from `command` with ours;\n\n        - adding `--` before `command`, so our parse would ignore arguments\n          of `command`.\n\n        \"\"\"\n        if ARGUMENT_PLACEHOLDER in argv:\n            index = argv.index(ARGUMENT_PLACEHOLDER)\n            return argv[index + 1:] + ['--'] + argv[:index]\n        elif argv and not argv[0].startswith('-') and argv[0] != '--':\n            return ['--'] + argv\n        else:\n            return argv\n\n    def parse(self, argv):\n        arguments = self._prepare_arguments(argv[1:])\n        return self._parser.parse_args(arguments)\n\n    def print_usage(self):\n        self._parser.print_usage(sys.stderr)\n\n    def print_help(self):\n        self._parser.print_help(sys.stderr)\n", "thefuck/conf.py": "import os\nimport sys\nfrom warnings import warn\nfrom six import text_type\nfrom . import const\nfrom .system import Path\n\ntry:\n    import importlib.util\n\n    def load_source(name, pathname, _file=None):\n        module_spec = importlib.util.spec_from_file_location(name, pathname)\n        module = importlib.util.module_from_spec(module_spec)\n        module_spec.loader.exec_module(module)\n        return module\nexcept ImportError:\n    from imp import load_source\n\n\nclass Settings(dict):\n    def __getattr__(self, item):\n        return self.get(item)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def init(self, args=None):\n        \"\"\"Fills `settings` with values from `settings.py` and env.\"\"\"\n        from .logs import exception\n\n        self._setup_user_dir()\n        self._init_settings_file()\n\n        try:\n            self.update(self._settings_from_file())\n        except Exception:\n            exception(\"Can't load settings from file\", sys.exc_info())\n\n        try:\n            self.update(self._settings_from_env())\n        except Exception:\n            exception(\"Can't load settings from env\", sys.exc_info())\n\n        self.update(self._settings_from_args(args))\n\n    def _init_settings_file(self):\n        settings_path = self.user_dir.joinpath('settings.py')\n        if not settings_path.is_file():\n            with settings_path.open(mode='w') as settings_file:\n                settings_file.write(const.SETTINGS_HEADER)\n                for setting in const.DEFAULT_SETTINGS.items():\n                    settings_file.write(u'# {} = {}\\n'.format(*setting))\n\n    def _get_user_dir_path(self):\n        \"\"\"Returns Path object representing the user config resource\"\"\"\n        xdg_config_home = os.environ.get('XDG_CONFIG_HOME', '~/.config')\n        user_dir = Path(xdg_config_home, 'thefuck').expanduser()\n        legacy_user_dir = Path('~', '.thefuck').expanduser()\n\n        # For backward compatibility use legacy '~/.thefuck' if it exists:\n        if legacy_user_dir.is_dir():\n            warn(u'Config path {} is deprecated. Please move to {}'.format(\n                legacy_user_dir, user_dir))\n            return legacy_user_dir\n        else:\n            return user_dir\n\n    def _setup_user_dir(self):\n        \"\"\"Returns user config dir, create it when it doesn't exist.\"\"\"\n        user_dir = self._get_user_dir_path()\n\n        rules_dir = user_dir.joinpath('rules')\n        if not rules_dir.is_dir():\n            rules_dir.mkdir(parents=True)\n        self.user_dir = user_dir\n\n    def _settings_from_file(self):\n        \"\"\"Loads settings from file.\"\"\"\n        settings = load_source(\n            'settings', text_type(self.user_dir.joinpath('settings.py')))\n        return {key: getattr(settings, key)\n                for key in const.DEFAULT_SETTINGS.keys()\n                if hasattr(settings, key)}\n\n    def _rules_from_env(self, val):\n        \"\"\"Transforms rules list from env-string to python.\"\"\"\n        val = val.split(':')\n        if 'DEFAULT_RULES' in val:\n            val = const.DEFAULT_RULES + [rule for rule in val if rule != 'DEFAULT_RULES']\n        return val\n\n    def _priority_from_env(self, val):\n        \"\"\"Gets priority pairs from env.\"\"\"\n        for part in val.split(':'):\n            try:\n                rule, priority = part.split('=')\n                yield rule, int(priority)\n            except ValueError:\n                continue\n\n    def _val_from_env(self, env, attr):\n        \"\"\"Transforms env-strings to python.\"\"\"\n        val = os.environ[env]\n        if attr in ('rules', 'exclude_rules'):\n            return self._rules_from_env(val)\n        elif attr == 'priority':\n            return dict(self._priority_from_env(val))\n        elif attr in ('wait_command', 'history_limit', 'wait_slow_command',\n                      'num_close_matches'):\n            return int(val)\n        elif attr in ('require_confirmation', 'no_colors', 'debug',\n                      'alter_history', 'instant_mode'):\n            return val.lower() == 'true'\n        elif attr in ('slow_commands', 'excluded_search_path_prefixes'):\n            return val.split(':')\n        else:\n            return val\n\n    def _settings_from_env(self):\n        \"\"\"Loads settings from env.\"\"\"\n        return {attr: self._val_from_env(env, attr)\n                for env, attr in const.ENV_TO_ATTR.items()\n                if env in os.environ}\n\n    def _settings_from_args(self, args):\n        \"\"\"Loads settings from args.\"\"\"\n        if not args:\n            return {}\n\n        from_args = {}\n        if args.yes:\n            from_args['require_confirmation'] = not args.yes\n        if args.debug:\n            from_args['debug'] = args.debug\n        if args.repeat:\n            from_args['repeat'] = args.repeat\n        return from_args\n\n\nsettings = Settings(const.DEFAULT_SETTINGS)\n", "thefuck/ui.py": "# -*- encoding: utf-8 -*-\n\nimport sys\nfrom .conf import settings\nfrom .exceptions import NoRuleMatched\nfrom .system import get_key\nfrom .utils import get_alias\nfrom . import logs, const\n\n\ndef read_actions():\n    \"\"\"Yields actions for pressed keys.\"\"\"\n    while True:\n        key = get_key()\n\n        # Handle arrows, j/k (qwerty), and n/e (colemak)\n        if key in (const.KEY_UP, const.KEY_CTRL_N, 'k', 'e'):\n            yield const.ACTION_PREVIOUS\n        elif key in (const.KEY_DOWN, const.KEY_CTRL_P, 'j', 'n'):\n            yield const.ACTION_NEXT\n        elif key in (const.KEY_CTRL_C, 'q'):\n            yield const.ACTION_ABORT\n        elif key in ('\\n', '\\r'):\n            yield const.ACTION_SELECT\n\n\nclass CommandSelector(object):\n    \"\"\"Helper for selecting rule from rules list.\"\"\"\n\n    def __init__(self, commands):\n        \"\"\":type commands: Iterable[thefuck.types.CorrectedCommand]\"\"\"\n        self._commands_gen = commands\n        try:\n            self._commands = [next(self._commands_gen)]\n        except StopIteration:\n            raise NoRuleMatched\n        self._realised = False\n        self._index = 0\n\n    def _realise(self):\n        if not self._realised:\n            self._commands += list(self._commands_gen)\n            self._realised = True\n\n    def next(self):\n        self._realise()\n        self._index = (self._index + 1) % len(self._commands)\n\n    def previous(self):\n        self._realise()\n        self._index = (self._index - 1) % len(self._commands)\n\n    @property\n    def value(self):\n        \"\"\":rtype thefuck.types.CorrectedCommand\"\"\"\n        return self._commands[self._index]\n\n\ndef select_command(corrected_commands):\n    \"\"\"Returns:\n\n     - the first command when confirmation disabled;\n     - None when ctrl+c pressed;\n     - selected command.\n\n    :type corrected_commands: Iterable[thefuck.types.CorrectedCommand]\n    :rtype: thefuck.types.CorrectedCommand | None\n\n    \"\"\"\n    try:\n        selector = CommandSelector(corrected_commands)\n    except NoRuleMatched:\n        logs.failed('No fucks given' if get_alias() == 'fuck'\n                    else 'Nothing found')\n        return\n\n    if not settings.require_confirmation:\n        logs.show_corrected_command(selector.value)\n        return selector.value\n\n    logs.confirm_text(selector.value)\n\n    for action in read_actions():\n        if action == const.ACTION_SELECT:\n            sys.stderr.write('\\n')\n            return selector.value\n        elif action == const.ACTION_ABORT:\n            logs.failed('\\nAborted')\n            return\n        elif action == const.ACTION_PREVIOUS:\n            selector.previous()\n            logs.confirm_text(selector.value)\n        elif action == const.ACTION_NEXT:\n            selector.next()\n            logs.confirm_text(selector.value)\n", "thefuck/types.py": "import os\nimport sys\nfrom . import logs\nfrom .shells import shell\nfrom .conf import settings, load_source\nfrom .const import DEFAULT_PRIORITY, ALL_ENABLED\nfrom .exceptions import EmptyCommand\nfrom .utils import get_alias, format_raw_script\nfrom .output_readers import get_output\n\n\nclass Command(object):\n    \"\"\"Command that should be fixed.\"\"\"\n\n    def __init__(self, script, output):\n        \"\"\"Initializes command with given values.\n\n        :type script: basestring\n        :type output: basestring\n\n        \"\"\"\n        self.script = script\n        self.output = output\n\n    @property\n    def stdout(self):\n        logs.warn('`stdout` is deprecated, please use `output` instead')\n        return self.output\n\n    @property\n    def stderr(self):\n        logs.warn('`stderr` is deprecated, please use `output` instead')\n        return self.output\n\n    @property\n    def script_parts(self):\n        if not hasattr(self, '_script_parts'):\n            try:\n                self._script_parts = shell.split_command(self.script)\n            except Exception:\n                logs.debug(u\"Can't split command script {} because:\\n {}\".format(\n                    self, sys.exc_info()))\n                self._script_parts = []\n\n        return self._script_parts\n\n    def __eq__(self, other):\n        if isinstance(other, Command):\n            return (self.script, self.output) == (other.script, other.output)\n        else:\n            return False\n\n    def __repr__(self):\n        return u'Command(script={}, output={})'.format(\n            self.script, self.output)\n\n    def update(self, **kwargs):\n        \"\"\"Returns new command with replaced fields.\n\n        :rtype: Command\n\n        \"\"\"\n        kwargs.setdefault('script', self.script)\n        kwargs.setdefault('output', self.output)\n        return Command(**kwargs)\n\n    @classmethod\n    def from_raw_script(cls, raw_script):\n        \"\"\"Creates instance of `Command` from a list of script parts.\n\n        :type raw_script: [basestring]\n        :rtype: Command\n        :raises: EmptyCommand\n\n        \"\"\"\n        script = format_raw_script(raw_script)\n        if not script:\n            raise EmptyCommand\n\n        expanded = shell.from_shell(script)\n        output = get_output(script, expanded)\n        return cls(expanded, output)\n\n\nclass Rule(object):\n    \"\"\"Rule for fixing commands.\"\"\"\n\n    def __init__(self, name, match, get_new_command,\n                 enabled_by_default, side_effect,\n                 priority, requires_output):\n        \"\"\"Initializes rule with given fields.\n\n        :type name: basestring\n        :type match: (Command) -> bool\n        :type get_new_command: (Command) -> (basestring | [basestring])\n        :type enabled_by_default: boolean\n        :type side_effect: (Command, basestring) -> None\n        :type priority: int\n        :type requires_output: bool\n\n        \"\"\"\n        self.name = name\n        self.match = match\n        self.get_new_command = get_new_command\n        self.enabled_by_default = enabled_by_default\n        self.side_effect = side_effect\n        self.priority = priority\n        self.requires_output = requires_output\n\n    def __eq__(self, other):\n        if isinstance(other, Rule):\n            return ((self.name, self.match, self.get_new_command,\n                     self.enabled_by_default, self.side_effect,\n                     self.priority, self.requires_output)\n                    == (other.name, other.match, other.get_new_command,\n                        other.enabled_by_default, other.side_effect,\n                        other.priority, other.requires_output))\n        else:\n            return False\n\n    def __repr__(self):\n        return 'Rule(name={}, match={}, get_new_command={}, ' \\\n               'enabled_by_default={}, side_effect={}, ' \\\n               'priority={}, requires_output={})'.format(\n                   self.name, self.match, self.get_new_command,\n                   self.enabled_by_default, self.side_effect,\n                   self.priority, self.requires_output)\n\n    @classmethod\n    def from_path(cls, path):\n        \"\"\"Creates rule instance from path.\n\n        :type path: pathlib.Path\n        :rtype: Rule\n\n        \"\"\"\n        name = path.name[:-3]\n        if name in settings.exclude_rules:\n            logs.debug(u'Ignoring excluded rule: {}'.format(name))\n            return\n        with logs.debug_time(u'Importing rule: {};'.format(name)):\n            try:\n                rule_module = load_source(name, str(path))\n            except Exception:\n                logs.exception(u\"Rule {} failed to load\".format(name), sys.exc_info())\n                return\n        priority = getattr(rule_module, 'priority', DEFAULT_PRIORITY)\n        return cls(name, rule_module.match,\n                   rule_module.get_new_command,\n                   getattr(rule_module, 'enabled_by_default', True),\n                   getattr(rule_module, 'side_effect', None),\n                   settings.priority.get(name, priority),\n                   getattr(rule_module, 'requires_output', True))\n\n    @property\n    def is_enabled(self):\n        \"\"\"Returns `True` when rule enabled.\n\n        :rtype: bool\n\n        \"\"\"\n        return (\n            self.name in settings.rules\n            or self.enabled_by_default\n            and ALL_ENABLED in settings.rules\n        )\n\n    def is_match(self, command):\n        \"\"\"Returns `True` if rule matches the command.\n\n        :type command: Command\n        :rtype: bool\n\n        \"\"\"\n        if command.output is None and self.requires_output:\n            return False\n\n        try:\n            with logs.debug_time(u'Trying rule: {};'.format(self.name)):\n                if self.match(command):\n                    return True\n        except Exception:\n            logs.rule_failed(self, sys.exc_info())\n\n    def get_corrected_commands(self, command):\n        \"\"\"Returns generator with corrected commands.\n\n        :type command: Command\n        :rtype: Iterable[CorrectedCommand]\n\n        \"\"\"\n        new_commands = self.get_new_command(command)\n        if not isinstance(new_commands, list):\n            new_commands = (new_commands,)\n        for n, new_command in enumerate(new_commands):\n            yield CorrectedCommand(script=new_command,\n                                   side_effect=self.side_effect,\n                                   priority=(n + 1) * self.priority)\n\n\nclass CorrectedCommand(object):\n    \"\"\"Corrected by rule command.\"\"\"\n\n    def __init__(self, script, side_effect, priority):\n        \"\"\"Initializes instance with given fields.\n\n        :type script: basestring\n        :type side_effect: (Command, basestring) -> None\n        :type priority: int\n\n        \"\"\"\n        self.script = script\n        self.side_effect = side_effect\n        self.priority = priority\n\n    def __eq__(self, other):\n        \"\"\"Ignores `priority` field.\"\"\"\n        if isinstance(other, CorrectedCommand):\n            return (other.script, other.side_effect) == \\\n                   (self.script, self.side_effect)\n        else:\n            return False\n\n    def __hash__(self):\n        return (self.script, self.side_effect).__hash__()\n\n    def __repr__(self):\n        return u'CorrectedCommand(script={}, side_effect={}, priority={})'.format(\n            self.script, self.side_effect, self.priority)\n\n    def _get_script(self):\n        \"\"\"Returns fixed commands script.\n\n        If `settings.repeat` is `True`, appends command with second attempt\n        of running fuck in case fixed command fails again.\n\n        \"\"\"\n        if settings.repeat:\n            repeat_fuck = '{} --repeat {}--force-command {}'.format(\n                get_alias(),\n                '--debug ' if settings.debug else '',\n                shell.quote(self.script))\n            return shell.or_(self.script, repeat_fuck)\n        else:\n            return self.script\n\n    def run(self, old_cmd):\n        \"\"\"Runs command from rule for passed command.\n\n        :type old_cmd: Command\n\n        \"\"\"\n        if self.side_effect:\n            self.side_effect(old_cmd, self.script)\n        if settings.alter_history:\n            shell.put_to_history(self.script)\n        # This depends on correct setting of PYTHONIOENCODING by the alias:\n        logs.debug(u'PYTHONIOENCODING: {}'.format(\n            os.environ.get('PYTHONIOENCODING', '!!not-set!!')))\n\n        sys.stdout.write(self._get_script())\n", "thefuck/const.py": "# -*- encoding: utf-8 -*-\n\n\nclass _GenConst(object):\n    def __init__(self, name):\n        self._name = name\n\n    def __repr__(self):\n        return u'<const: {}>'.format(self._name)\n\n\nKEY_UP = _GenConst('\u2191')\nKEY_DOWN = _GenConst('\u2193')\nKEY_CTRL_C = _GenConst('Ctrl+C')\nKEY_CTRL_N = _GenConst('Ctrl+N')\nKEY_CTRL_P = _GenConst('Ctrl+P')\n\nKEY_MAPPING = {'\\x0e': KEY_CTRL_N,\n               '\\x03': KEY_CTRL_C,\n               '\\x10': KEY_CTRL_P}\n\nACTION_SELECT = _GenConst('select')\nACTION_ABORT = _GenConst('abort')\nACTION_PREVIOUS = _GenConst('previous')\nACTION_NEXT = _GenConst('next')\n\nALL_ENABLED = _GenConst('All rules enabled')\nDEFAULT_RULES = [ALL_ENABLED]\nDEFAULT_PRIORITY = 1000\n\nDEFAULT_SETTINGS = {'rules': DEFAULT_RULES,\n                    'exclude_rules': [],\n                    'wait_command': 3,\n                    'require_confirmation': True,\n                    'no_colors': False,\n                    'debug': False,\n                    'priority': {},\n                    'history_limit': None,\n                    'alter_history': True,\n                    'wait_slow_command': 15,\n                    'slow_commands': ['lein', 'react-native', 'gradle',\n                                      './gradlew', 'vagrant'],\n                    'repeat': False,\n                    'instant_mode': False,\n                    'num_close_matches': 3,\n                    'env': {'LC_ALL': 'C', 'LANG': 'C', 'GIT_TRACE': '1'},\n                    'excluded_search_path_prefixes': []}\n\nENV_TO_ATTR = {'THEFUCK_RULES': 'rules',\n               'THEFUCK_EXCLUDE_RULES': 'exclude_rules',\n               'THEFUCK_WAIT_COMMAND': 'wait_command',\n               'THEFUCK_REQUIRE_CONFIRMATION': 'require_confirmation',\n               'THEFUCK_NO_COLORS': 'no_colors',\n               'THEFUCK_DEBUG': 'debug',\n               'THEFUCK_PRIORITY': 'priority',\n               'THEFUCK_HISTORY_LIMIT': 'history_limit',\n               'THEFUCK_ALTER_HISTORY': 'alter_history',\n               'THEFUCK_WAIT_SLOW_COMMAND': 'wait_slow_command',\n               'THEFUCK_SLOW_COMMANDS': 'slow_commands',\n               'THEFUCK_REPEAT': 'repeat',\n               'THEFUCK_INSTANT_MODE': 'instant_mode',\n               'THEFUCK_NUM_CLOSE_MATCHES': 'num_close_matches',\n               'THEFUCK_EXCLUDED_SEARCH_PATH_PREFIXES': 'excluded_search_path_prefixes'}\n\nSETTINGS_HEADER = u\"\"\"# The Fuck settings file\n#\n# The rules are defined as in the example bellow:\n#\n# rules = ['cd_parent', 'git_push', 'python_command', 'sudo']\n#\n# The default values are as follows. Uncomment and change to fit your needs.\n# See https://github.com/nvbn/thefuck#settings for more information.\n#\n\n\"\"\"\n\nARGUMENT_PLACEHOLDER = 'THEFUCK_ARGUMENT_PLACEHOLDER'\n\nCONFIGURATION_TIMEOUT = 60\n\nUSER_COMMAND_MARK = u'\\u200B' * 10\n\nLOG_SIZE_IN_BYTES = 1024 * 1024\n\nLOG_SIZE_TO_CLEAN = 10 * 1024\n\nDIFF_WITH_ALIAS = 0.5\n\nSHELL_LOGGER_SOCKET_ENV = 'SHELL_LOGGER_SOCKET'\n\nSHELL_LOGGER_LIMIT = 5\n", "thefuck/__init__.py": "", "thefuck/shells/powershell.py": "from subprocess import Popen, PIPE\nfrom ..utils import DEVNULL\nfrom .generic import Generic, ShellConfiguration\n\n\nclass Powershell(Generic):\n    friendly_name = 'PowerShell'\n\n    def app_alias(self, alias_name):\n        return 'function ' + alias_name + ' {\\n' \\\n               '    $history = (Get-History -Count 1).CommandLine;\\n' \\\n               '    if (-not [string]::IsNullOrWhiteSpace($history)) {\\n' \\\n               '        $fuck = $(thefuck $args $history);\\n' \\\n               '        if (-not [string]::IsNullOrWhiteSpace($fuck)) {\\n' \\\n               '            if ($fuck.StartsWith(\"echo\")) { $fuck = $fuck.Substring(5); }\\n' \\\n               '            else { iex \"$fuck\"; }\\n' \\\n               '        }\\n' \\\n               '    }\\n' \\\n               '    [Console]::ResetColor() \\n' \\\n               '}\\n'\n\n    def and_(self, *commands):\n        return u' -and '.join('({0})'.format(c) for c in commands)\n\n    def how_to_configure(self):\n        return ShellConfiguration(\n            content=u'iex \"$(thefuck --alias)\"',\n            path='$profile',\n            reload='. $profile',\n            can_configure_automatically=False)\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        try:\n            proc = Popen(\n                ['powershell.exe', '$PSVersionTable.PSVersion'],\n                stdout=PIPE,\n                stderr=DEVNULL)\n            version = proc.stdout.read().decode('utf-8').rstrip().split('\\n')\n            return '.'.join(version[-1].split())\n        except IOError:\n            proc = Popen(['pwsh', '--version'], stdout=PIPE, stderr=DEVNULL)\n            return proc.stdout.read().decode('utf-8').split()[-1]\n", "thefuck/shells/generic.py": "import io\nimport os\nimport shlex\nimport six\nfrom collections import namedtuple\nfrom ..logs import warn\nfrom ..utils import memoize\nfrom ..conf import settings\nfrom ..system import Path\n\n\nShellConfiguration = namedtuple('ShellConfiguration', (\n    'content', 'path', 'reload', 'can_configure_automatically'))\n\n\nclass Generic(object):\n    friendly_name = 'Generic Shell'\n\n    def get_aliases(self):\n        return {}\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(' ')[0]\n        if binary in aliases:\n            return command_script.replace(binary, aliases[binary], 1)\n        else:\n            return command_script\n\n    def from_shell(self, command_script):\n        \"\"\"Prepares command before running in app.\"\"\"\n        return self._expand_aliases(command_script)\n\n    def to_shell(self, command_script):\n        \"\"\"Prepares command for running in shell.\"\"\"\n        return command_script\n\n    def app_alias(self, alias_name):\n        return \"\"\"alias {0}='eval \"$(TF_ALIAS={0} PYTHONIOENCODING=utf-8 \"\"\" \\\n               \"\"\"thefuck \"$(fc -ln -1)\")\"'\"\"\".format(alias_name)\n\n    def instant_mode_alias(self, alias_name):\n        warn(\"Instant mode not supported by your shell\")\n        return self.app_alias(alias_name)\n\n    def _get_history_file_name(self):\n        return ''\n\n    def _get_history_line(self, command_script):\n        return ''\n\n    @memoize\n    def get_history(self):\n        return list(self._get_history_lines())\n\n    def _get_history_lines(self):\n        \"\"\"Returns list of history entries.\"\"\"\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with io.open(history_file_name, 'r',\n                         encoding='utf-8', errors='ignore') as history_file:\n\n                lines = history_file.readlines()\n                if settings.history_limit:\n                    lines = lines[-settings.history_limit:]\n\n                for line in lines:\n                    prepared = self._script_from_history(line) \\\n                        .strip()\n                    if prepared:\n                        yield prepared\n\n    def and_(self, *commands):\n        return u' && '.join(commands)\n\n    def or_(self, *commands):\n        return u' || '.join(commands)\n\n    def how_to_configure(self):\n        return\n\n    def split_command(self, command):\n        \"\"\"Split the command using shell-like syntax.\"\"\"\n        encoded = self.encode_utf8(command)\n\n        try:\n            splitted = [s.replace(\"??\", \"\\\\ \") for s in shlex.split(encoded.replace('\\\\ ', '??'))]\n        except ValueError:\n            splitted = encoded.split(' ')\n\n        return self.decode_utf8(splitted)\n\n    def encode_utf8(self, command):\n        if six.PY2:\n            return command.encode('utf8')\n        return command\n\n    def decode_utf8(self, command_parts):\n        if six.PY2:\n            return [s.decode('utf8') for s in command_parts]\n        return command_parts\n\n    def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)\n\n    def _script_from_history(self, line):\n        return line\n\n    def put_to_history(self, command):\n        \"\"\"Adds fixed command to shell history.\n\n        In most of shells we change history on shell-level, but not\n        all shells support it (Fish).\n\n        \"\"\"\n\n    def get_builtin_commands(self):\n        \"\"\"Returns shells builtin commands.\"\"\"\n        return ['alias', 'bg', 'bind', 'break', 'builtin', 'case', 'cd',\n                'command', 'compgen', 'complete', 'continue', 'declare',\n                'dirs', 'disown', 'echo', 'enable', 'eval', 'exec', 'exit',\n                'export', 'fc', 'fg', 'getopts', 'hash', 'help', 'history',\n                'if', 'jobs', 'kill', 'let', 'local', 'logout', 'popd',\n                'printf', 'pushd', 'pwd', 'read', 'readonly', 'return', 'set',\n                'shift', 'shopt', 'source', 'suspend', 'test', 'times', 'trap',\n                'type', 'typeset', 'ulimit', 'umask', 'unalias', 'unset',\n                'until', 'wait', 'while']\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        return ''\n\n    def info(self):\n        \"\"\"Returns the name and version of the current shell\"\"\"\n        try:\n            version = self._get_version()\n        except Exception as e:\n            warn(u'Could not determine shell version: {}'.format(e))\n            version = ''\n        return u'{} {}'.format(self.friendly_name, version).rstrip()\n\n    def _create_shell_configuration(self, content, path, reload):\n        return ShellConfiguration(\n            content=content,\n            path=path,\n            reload=reload,\n            can_configure_automatically=Path(path).expanduser().exists())\n", "thefuck/shells/fish.py": "from subprocess import Popen, PIPE\nfrom time import time\nimport os\nimport sys\nimport six\nfrom .. import logs\nfrom ..conf import settings\nfrom ..const import ARGUMENT_PLACEHOLDER\nfrom ..utils import DEVNULL, cache\nfrom .generic import Generic\n\n\n@cache('~/.config/fish/config.fish', '~/.config/fish/functions')\ndef _get_functions(overridden):\n    proc = Popen(['fish', '-ic', 'functions'], stdout=PIPE, stderr=DEVNULL)\n    functions = proc.stdout.read().decode('utf-8').strip().split('\\n')\n    return {func: func for func in functions if func not in overridden}\n\n\n@cache('~/.config/fish/config.fish')\ndef _get_aliases(overridden):\n    aliases = {}\n    proc = Popen(['fish', '-ic', 'alias'], stdout=PIPE, stderr=DEVNULL)\n    alias_out = proc.stdout.read().decode('utf-8').strip()\n    if not alias_out:\n        return aliases\n    for alias in alias_out.split('\\n'):\n        for separator in (' ', '='):\n            split_alias = alias.replace('alias ', '', 1).split(separator, 1)\n            if len(split_alias) == 2:\n                name, value = split_alias\n                break\n        else:\n            continue\n        if name not in overridden:\n            aliases[name] = value\n    return aliases\n\n\nclass Fish(Generic):\n    friendly_name = 'Fish Shell'\n\n    def _get_overridden_aliases(self):\n        overridden = os.environ.get('THEFUCK_OVERRIDDEN_ALIASES',\n                                    os.environ.get('TF_OVERRIDDEN_ALIASES', ''))\n        default = {'cd', 'grep', 'ls', 'man', 'open'}\n        for alias in overridden.split(','):\n            default.add(alias.strip())\n        return sorted(default)\n\n    def app_alias(self, alias_name):\n        if settings.alter_history:\n            alter_history = ('    builtin history delete --exact'\n                             ' --case-sensitive -- $fucked_up_command\\n'\n                             '    builtin history merge\\n')\n        else:\n            alter_history = ''\n        # It is VERY important to have the variables declared WITHIN the alias\n        return ('function {0} -d \"Correct your previous console command\"\\n'\n                '  set -l fucked_up_command $history[1]\\n'\n                '  env TF_SHELL=fish TF_ALIAS={0} PYTHONIOENCODING=utf-8'\n                ' thefuck $fucked_up_command {2} $argv | read -l unfucked_command\\n'\n                '  if [ \"$unfucked_command\" != \"\" ]\\n'\n                '    eval $unfucked_command\\n{1}'\n                '  end\\n'\n                'end').format(alias_name, alter_history, ARGUMENT_PLACEHOLDER)\n\n    def get_aliases(self):\n        overridden = self._get_overridden_aliases()\n        functions = _get_functions(overridden)\n        raw_aliases = _get_aliases(overridden)\n        functions.update(raw_aliases)\n        return functions\n\n    def _expand_aliases(self, command_script):\n        aliases = self.get_aliases()\n        binary = command_script.split(' ')[0]\n        if binary in aliases and aliases[binary] != binary:\n            return command_script.replace(binary, aliases[binary], 1)\n        elif binary in aliases:\n            return u'fish -ic \"{}\"'.format(command_script.replace('\"', r'\\\"'))\n        else:\n            return command_script\n\n    def _get_history_file_name(self):\n        return os.path.expanduser('~/.config/fish/fish_history')\n\n    def _get_history_line(self, command_script):\n        return u'- cmd: {}\\n   when: {}\\n'.format(command_script, int(time()))\n\n    def _script_from_history(self, line):\n        if '- cmd: ' in line:\n            return line.split('- cmd: ', 1)[1]\n        else:\n            return ''\n\n    def and_(self, *commands):\n        return u'; and '.join(commands)\n\n    def or_(self, *commands):\n        return u'; or '.join(commands)\n\n    def how_to_configure(self):\n        return self._create_shell_configuration(\n            content=u\"thefuck --alias | source\",\n            path='~/.config/fish/config.fish',\n            reload='fish')\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        proc = Popen(['fish', '--version'], stdout=PIPE, stderr=DEVNULL)\n        return proc.stdout.read().decode('utf-8').split()[-1]\n\n    def put_to_history(self, command):\n        try:\n            return self._put_to_history(command)\n        except IOError:\n            logs.exception(\"Can't update history\", sys.exc_info())\n\n    def _put_to_history(self, command_script):\n        \"\"\"Puts command script to shell history.\"\"\"\n        history_file_name = self._get_history_file_name()\n        if os.path.isfile(history_file_name):\n            with open(history_file_name, 'a') as history:\n                entry = self._get_history_line(command_script)\n                if six.PY2:\n                    history.write(entry.encode('utf-8'))\n                else:\n                    history.write(entry)\n", "thefuck/shells/bash.py": "import os\nfrom subprocess import Popen, PIPE\nfrom tempfile import gettempdir\nfrom uuid import uuid4\nfrom ..conf import settings\nfrom ..const import ARGUMENT_PLACEHOLDER, USER_COMMAND_MARK\nfrom ..utils import DEVNULL, memoize\nfrom .generic import Generic\n\n\nclass Bash(Generic):\n    friendly_name = 'Bash'\n\n    def app_alias(self, alias_name):\n        # It is VERY important to have the variables declared WITHIN the function\n        return '''\n            function {name} () {{\n                TF_PYTHONIOENCODING=$PYTHONIOENCODING;\n                export TF_SHELL=bash;\n                export TF_ALIAS={name};\n                export TF_SHELL_ALIASES=$(alias);\n                export TF_HISTORY=$(fc -ln -10);\n                export PYTHONIOENCODING=utf-8;\n                TF_CMD=$(\n                    thefuck {argument_placeholder} \"$@\"\n                ) && eval \"$TF_CMD\";\n                unset TF_HISTORY;\n                export PYTHONIOENCODING=$TF_PYTHONIOENCODING;\n                {alter_history}\n            }}\n        '''.format(\n            name=alias_name,\n            argument_placeholder=ARGUMENT_PLACEHOLDER,\n            alter_history=('history -s $TF_CMD;'\n                           if settings.alter_history else ''))\n\n    def instant_mode_alias(self, alias_name):\n        if os.environ.get('THEFUCK_INSTANT_MODE', '').lower() == 'true':\n            mark = USER_COMMAND_MARK + '\\b' * len(USER_COMMAND_MARK)\n            return '''\n                export PS1=\"{user_command_mark}$PS1\";\n                {app_alias}\n            '''.format(user_command_mark=mark,\n                       app_alias=self.app_alias(alias_name))\n        else:\n            log_path = os.path.join(\n                gettempdir(), 'thefuck-script-log-{}'.format(uuid4().hex))\n            return '''\n                export THEFUCK_INSTANT_MODE=True;\n                export THEFUCK_OUTPUT_LOG={log};\n                thefuck --shell-logger {log};\n                rm {log};\n                exit\n            '''.format(log=log_path)\n\n    def _parse_alias(self, alias):\n        name, value = alias.replace('alias ', '', 1).split('=', 1)\n        if value[0] == value[-1] == '\"' or value[0] == value[-1] == \"'\":\n            value = value[1:-1]\n        return name, value\n\n    @memoize\n    def get_aliases(self):\n        raw_aliases = os.environ.get('TF_SHELL_ALIASES', '').split('\\n')\n        return dict(self._parse_alias(alias)\n                    for alias in raw_aliases if alias and '=' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(\"HISTFILE\",\n                              os.path.expanduser('~/.bash_history'))\n\n    def _get_history_line(self, command_script):\n        return u'{}\\n'.format(command_script)\n\n    def how_to_configure(self):\n        if os.path.join(os.path.expanduser('~'), '.bashrc'):\n            config = '~/.bashrc'\n        elif os.path.join(os.path.expanduser('~'), '.bash_profile'):\n            config = '~/.bash_profile'\n        else:\n            config = 'bash config'\n\n        return self._create_shell_configuration(\n            content=u'eval \"$(thefuck --alias)\"',\n            path=config,\n            reload=u'source {}'.format(config))\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        proc = Popen(['bash', '-c', 'echo $BASH_VERSION'],\n                     stdout=PIPE, stderr=DEVNULL)\n        return proc.stdout.read().decode('utf-8').strip()\n", "thefuck/shells/tcsh.py": "from subprocess import Popen, PIPE\nfrom time import time\nimport os\nfrom ..utils import DEVNULL, memoize\nfrom .generic import Generic\n\n\nclass Tcsh(Generic):\n    friendly_name = 'Tcsh'\n\n    def app_alias(self, alias_name):\n        return (\"alias {0} 'setenv TF_SHELL tcsh && setenv TF_ALIAS {0} && \"\n                \"set fucked_cmd=`history -h 2 | head -n 1` && \"\n                \"eval `thefuck ${{fucked_cmd}}`'\").format(alias_name)\n\n    def _parse_alias(self, alias):\n        name, value = alias.split(\"\\t\", 1)\n        return name, value\n\n    @memoize\n    def get_aliases(self):\n        proc = Popen(['tcsh', '-ic', 'alias'], stdout=PIPE, stderr=DEVNULL)\n        return dict(\n            self._parse_alias(alias)\n            for alias in proc.stdout.read().decode('utf-8').split('\\n')\n            if alias and '\\t' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(\"HISTFILE\",\n                              os.path.expanduser('~/.history'))\n\n    def _get_history_line(self, command_script):\n        return u'#+{}\\n{}\\n'.format(int(time()), command_script)\n\n    def how_to_configure(self):\n        return self._create_shell_configuration(\n            content=u'eval `thefuck --alias`',\n            path='~/.tcshrc',\n            reload='tcsh')\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        proc = Popen(['tcsh', '--version'], stdout=PIPE, stderr=DEVNULL)\n        return proc.stdout.read().decode('utf-8').split()[1]\n", "thefuck/shells/zsh.py": "from time import time\nimport os\nfrom subprocess import Popen, PIPE\nfrom tempfile import gettempdir\nfrom uuid import uuid4\nfrom ..conf import settings\nfrom ..const import ARGUMENT_PLACEHOLDER, USER_COMMAND_MARK\nfrom ..utils import DEVNULL, memoize\nfrom .generic import Generic\n\n\nclass Zsh(Generic):\n    friendly_name = 'ZSH'\n\n    def app_alias(self, alias_name):\n        # It is VERY important to have the variables declared WITHIN the function\n        return '''\n            {name} () {{\n                TF_PYTHONIOENCODING=$PYTHONIOENCODING;\n                export TF_SHELL=zsh;\n                export TF_ALIAS={name};\n                TF_SHELL_ALIASES=$(alias);\n                export TF_SHELL_ALIASES;\n                TF_HISTORY=\"$(fc -ln -10)\";\n                export TF_HISTORY;\n                export PYTHONIOENCODING=utf-8;\n                TF_CMD=$(\n                    thefuck {argument_placeholder} $@\n                ) && eval $TF_CMD;\n                unset TF_HISTORY;\n                export PYTHONIOENCODING=$TF_PYTHONIOENCODING;\n                {alter_history}\n            }}\n        '''.format(\n            name=alias_name,\n            argument_placeholder=ARGUMENT_PLACEHOLDER,\n            alter_history=('test -n \"$TF_CMD\" && print -s $TF_CMD'\n                           if settings.alter_history else ''))\n\n    def instant_mode_alias(self, alias_name):\n        if os.environ.get('THEFUCK_INSTANT_MODE', '').lower() == 'true':\n            mark = ('%{' +\n                    USER_COMMAND_MARK + '\\b' * len(USER_COMMAND_MARK)\n                    + '%}')\n            return '''\n                export PS1=\"{user_command_mark}$PS1\";\n                {app_alias}\n            '''.format(user_command_mark=mark,\n                       app_alias=self.app_alias(alias_name))\n        else:\n            log_path = os.path.join(\n                gettempdir(), 'thefuck-script-log-{}'.format(uuid4().hex))\n            return '''\n                export THEFUCK_INSTANT_MODE=True;\n                export THEFUCK_OUTPUT_LOG={log};\n                thefuck --shell-logger {log};\n                rm -f {log};\n                exit\n            '''.format(log=log_path)\n\n    def _parse_alias(self, alias):\n        name, value = alias.split('=', 1)\n        if value[0] == value[-1] == '\"' or value[0] == value[-1] == \"'\":\n            value = value[1:-1]\n        return name, value\n\n    @memoize\n    def get_aliases(self):\n        raw_aliases = os.environ.get('TF_SHELL_ALIASES', '').split('\\n')\n        return dict(self._parse_alias(alias)\n                    for alias in raw_aliases if alias and '=' in alias)\n\n    def _get_history_file_name(self):\n        return os.environ.get(\"HISTFILE\",\n                              os.path.expanduser('~/.zsh_history'))\n\n    def _get_history_line(self, command_script):\n        return u': {}:0;{}\\n'.format(int(time()), command_script)\n\n    def _script_from_history(self, line):\n        if ';' in line:\n            return line.split(';', 1)[1]\n        else:\n            return ''\n\n    def how_to_configure(self):\n        return self._create_shell_configuration(\n            content=u'eval $(thefuck --alias)',\n            path='~/.zshrc',\n            reload='source ~/.zshrc')\n\n    def _get_version(self):\n        \"\"\"Returns the version of the current shell\"\"\"\n        proc = Popen(['zsh', '-c', 'echo $ZSH_VERSION'],\n                     stdout=PIPE, stderr=DEVNULL)\n        return proc.stdout.read().decode('utf-8').strip()\n", "thefuck/shells/__init__.py": "\"\"\"Package with shell specific actions, each shell class should\nimplement `from_shell`, `to_shell`, `app_alias`, `put_to_history` and\n`get_aliases` methods.\n\"\"\"\nimport os\nfrom psutil import Process\nfrom .bash import Bash\nfrom .fish import Fish\nfrom .generic import Generic\nfrom .tcsh import Tcsh\nfrom .zsh import Zsh\nfrom .powershell import Powershell\n\nshells = {'bash': Bash,\n          'fish': Fish,\n          'zsh': Zsh,\n          'csh': Tcsh,\n          'tcsh': Tcsh,\n          'powershell': Powershell,\n          'pwsh': Powershell}\n\n\ndef _get_shell_from_env():\n    name = os.environ.get('TF_SHELL')\n\n    if name in shells:\n        return shells[name]()\n\n\ndef _get_shell_from_proc():\n    proc = Process(os.getpid())\n\n    while proc is not None and proc.pid > 0:\n        try:\n            name = proc.name()\n        except TypeError:\n            name = proc.name\n\n        name = os.path.splitext(name)[0]\n\n        if name in shells:\n            return shells[name]()\n\n        try:\n            proc = proc.parent()\n        except TypeError:\n            proc = proc.parent\n\n    return Generic()\n\n\nshell = _get_shell_from_env() or _get_shell_from_proc()\n", "thefuck/specific/npm.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import memoize, eager, which\n\nnpm_available = bool(which('npm'))\n\n\n@memoize\n@eager\ndef get_scripts():\n    \"\"\"Get custom npm scripts.\"\"\"\n    proc = Popen(['npm', 'run-script'], stdout=PIPE)\n    should_yeild = False\n    for line in proc.stdout.readlines():\n        line = line.decode()\n        if 'available via `npm run-script`:' in line:\n            should_yeild = True\n            continue\n\n        if should_yeild and re.match(r'^  [^ ]+', line):\n            yield line.strip().split(' ')[0]\n", "thefuck/specific/yum.py": "from thefuck.utils import which\n\nyum_available = bool(which('yum'))\n", "thefuck/specific/brew.py": "import subprocess\nfrom ..utils import memoize, which\n\n\nbrew_available = bool(which('brew'))\n\n\n@memoize\ndef get_brew_path_prefix():\n    \"\"\"To get brew path\"\"\"\n    try:\n        return subprocess.check_output(['brew', '--prefix'],\n                                       universal_newlines=True).strip()\n    except Exception:\n        return None\n", "thefuck/specific/archlinux.py": "\"\"\" This file provide some utility functions for Arch Linux specific rules.\"\"\"\nimport subprocess\nfrom .. import utils\n\n\n@utils.memoize\ndef get_pkgfile(command):\n    \"\"\" Gets the packages that provide the given command using `pkgfile`.\n\n    If the command is of the form `sudo foo`, searches for the `foo` command\n    instead.\n    \"\"\"\n    try:\n        command = command.strip()\n\n        if command.startswith('sudo '):\n            command = command[5:]\n\n        command = command.split(\" \")[0]\n\n        packages = subprocess.check_output(\n            ['pkgfile', '-b', '-v', command],\n            universal_newlines=True, stderr=utils.DEVNULL\n        ).splitlines()\n\n        return [package.split()[0] for package in packages]\n    except subprocess.CalledProcessError as err:\n        if err.returncode == 1 and err.output == \"\":\n            return []\n        else:\n            raise err\n\n\ndef archlinux_env():\n    if utils.which('yay'):\n        pacman = 'yay'\n    elif utils.which('pikaur'):\n        pacman = 'pikaur'\n    elif utils.which('yaourt'):\n        pacman = 'yaourt'\n    elif utils.which('pacman'):\n        pacman = 'sudo pacman'\n    else:\n        return False, None\n\n    enabled_by_default = utils.which('pkgfile')\n\n    return enabled_by_default, pacman\n", "thefuck/specific/git.py": "import re\nfrom decorator import decorator\nfrom ..utils import is_app\nfrom ..shells import shell\n\n\n@decorator\ndef git_support(fn, command):\n    \"\"\"Resolves git aliases and supports testing for both git and hub.\"\"\"\n    # supports GitHub's `hub` command\n    # which is recommended to be used with `alias git=hub`\n    # but at this point, shell aliases have already been resolved\n    if not is_app(command, 'git', 'hub'):\n        return False\n\n    # perform git aliases expansion\n    if command.output and 'trace: alias expansion:' in command.output:\n        search = re.search(\"trace: alias expansion: ([^ ]*) => ([^\\n]*)\",\n                           command.output)\n        alias = search.group(1)\n\n        # by default git quotes everything, for example:\n        #     'commit' '--amend'\n        # which is surprising and does not allow to easily test for\n        # eg. 'git commit'\n        expansion = ' '.join(shell.quote(part)\n                             for part in shell.split_command(search.group(2)))\n        new_script = re.sub(r\"\\b{}\\b\".format(alias), expansion, command.script)\n\n        command = command.update(script=new_script)\n\n    return fn(command)\n", "thefuck/specific/nix.py": "from thefuck.utils import which\n\nnix_available = bool(which('nix'))\n", "thefuck/specific/dnf.py": "from thefuck.utils import which\n\ndnf_available = bool(which('dnf'))\n", "thefuck/specific/sudo.py": "import six\nfrom decorator import decorator\n\n\n@decorator\ndef sudo_support(fn, command):\n    \"\"\"Removes sudo before calling fn and adds it after.\"\"\"\n    if not command.script.startswith('sudo '):\n        return fn(command)\n\n    result = fn(command.update(script=command.script[5:]))\n\n    if result and isinstance(result, six.string_types):\n        return u'sudo {}'.format(result)\n    elif isinstance(result, list):\n        return [u'sudo {}'.format(x) for x in result]\n    else:\n        return result\n", "thefuck/specific/__init__.py": "", "thefuck/specific/apt.py": "from thefuck.utils import which\n\napt_available = bool(which('apt-get'))\n", "thefuck/system/win32.py": "import os\nimport msvcrt\nimport win_unicode_console\nfrom .. import const\n\n\ndef init_output():\n    import colorama\n    win_unicode_console.enable()\n    colorama.init()\n\n\ndef get_key():\n    ch = msvcrt.getwch()\n    if ch in ('\\x00', '\\xe0'):  # arrow or function key prefix?\n        ch = msvcrt.getwch()  # second call returns the actual key code\n\n    if ch in const.KEY_MAPPING:\n        return const.KEY_MAPPING[ch]\n    if ch == 'H':\n        return const.KEY_UP\n    if ch == 'P':\n        return const.KEY_DOWN\n\n    return ch\n\n\ndef open_command(arg):\n    return 'cmd /c start ' + arg\n\n\ntry:\n    from pathlib import Path\nexcept ImportError:\n    from pathlib2 import Path\n\n\ndef _expanduser(self):\n    return self.__class__(os.path.expanduser(str(self)))\n\n\n# pathlib's expanduser fails on windows, see http://bugs.python.org/issue19776\nPath.expanduser = _expanduser\n", "thefuck/system/unix.py": "import os\nimport sys\nimport tty\nimport termios\nimport colorama\nfrom distutils.spawn import find_executable\nfrom .. import const\n\ninit_output = colorama.init\n\n\ndef getch():\n    fd = sys.stdin.fileno()\n    old = termios.tcgetattr(fd)\n    try:\n        tty.setraw(fd)\n        return sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old)\n\n\ndef get_key():\n    ch = getch()\n\n    if ch in const.KEY_MAPPING:\n        return const.KEY_MAPPING[ch]\n    elif ch == '\\x1b':\n        next_ch = getch()\n        if next_ch == '[':\n            last_ch = getch()\n\n            if last_ch == 'A':\n                return const.KEY_UP\n            elif last_ch == 'B':\n                return const.KEY_DOWN\n\n    return ch\n\n\ndef open_command(arg):\n    if find_executable('xdg-open'):\n        return 'xdg-open ' + arg\n    return 'open ' + arg\n\n\ntry:\n    from pathlib import Path\nexcept ImportError:\n    from pathlib2 import Path\n\n\ndef _expanduser(self):\n    return self.__class__(os.path.expanduser(str(self)))\n\n\nif not hasattr(Path, 'expanduser'):\n    Path.expanduser = _expanduser\n", "thefuck/system/__init__.py": "import sys\n\n\nif sys.platform == 'win32':\n    from .win32 import *  # noqa: F401,F403\nelse:\n    from .unix import *  # noqa: F401,F403\n", "thefuck/entrypoints/alias.py": "import six\nfrom ..conf import settings\nfrom ..logs import warn\nfrom ..shells import shell\nfrom ..utils import which\n\n\ndef _get_alias(known_args):\n    if six.PY2:\n        warn(\"The Fuck will drop Python 2 support soon, more details \"\n             \"https://github.com/nvbn/thefuck/issues/685\")\n\n    alias = shell.app_alias(known_args.alias)\n\n    if known_args.enable_experimental_instant_mode:\n        if six.PY2:\n            warn(\"Instant mode requires Python 3\")\n        elif not which('script'):\n            warn(\"Instant mode requires `script` app\")\n        else:\n            return shell.instant_mode_alias(known_args.alias)\n\n    return alias\n\n\ndef print_alias(known_args):\n    settings.init(known_args)\n    print(_get_alias(known_args))\n", "thefuck/entrypoints/not_configured.py": "# Initialize output before importing any module, that can use colorama.\nfrom ..system import init_output\n\ninit_output()\n\nimport getpass  # noqa: E402\nimport os  # noqa: E402\nimport json  # noqa: E402\nfrom tempfile import gettempdir  # noqa: E402\nimport time  # noqa: E402\nimport six  # noqa: E402\nfrom psutil import Process  # noqa: E402\nfrom .. import logs, const  # noqa: E402\nfrom ..shells import shell  # noqa: E402\nfrom ..conf import settings  # noqa: E402\nfrom ..system import Path  # noqa: E402\n\n\ndef _get_shell_pid():\n    \"\"\"Returns parent process pid.\"\"\"\n    proc = Process(os.getpid())\n\n    try:\n        return proc.parent().pid\n    except TypeError:\n        return proc.parent.pid\n\n\ndef _get_not_configured_usage_tracker_path():\n    \"\"\"Returns path of special file where we store latest shell pid.\"\"\"\n    return Path(gettempdir()).joinpath(u'thefuck.last_not_configured_run_{}'.format(\n        getpass.getuser(),\n    ))\n\n\ndef _record_first_run():\n    \"\"\"Records shell pid to tracker file.\"\"\"\n    info = {'pid': _get_shell_pid(),\n            'time': time.time()}\n\n    mode = 'wb' if six.PY2 else 'w'\n    with _get_not_configured_usage_tracker_path().open(mode) as tracker:\n        json.dump(info, tracker)\n\n\ndef _get_previous_command():\n    history = shell.get_history()\n\n    if history:\n        return history[-1]\n    else:\n        return None\n\n\ndef _is_second_run():\n    \"\"\"Returns `True` when we know that `fuck` called second time.\"\"\"\n    tracker_path = _get_not_configured_usage_tracker_path()\n    if not tracker_path.exists():\n        return False\n\n    current_pid = _get_shell_pid()\n    with tracker_path.open('r') as tracker:\n        try:\n            info = json.load(tracker)\n        except ValueError:\n            return False\n\n    if not (isinstance(info, dict) and info.get('pid') == current_pid):\n        return False\n\n    return (_get_previous_command() == 'fuck' or\n            time.time() - info.get('time', 0) < const.CONFIGURATION_TIMEOUT)\n\n\ndef _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()\n\n\ndef _configure(configuration_details):\n    \"\"\"Adds alias to shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('a') as shell_config:\n        shell_config.write(u'\\n')\n        shell_config.write(configuration_details.content)\n        shell_config.write(u'\\n')\n\n\ndef main():\n    \"\"\"Shows useful information about how-to configure alias on a first run\n    and configure automatically on a second.\n\n    It'll be only visible when user type fuck and when alias isn't configured.\n\n    \"\"\"\n    settings.init()\n    configuration_details = shell.how_to_configure()\n    if (\n        configuration_details and\n        configuration_details.can_configure_automatically\n    ):\n        if _is_already_configured(configuration_details):\n            logs.already_configured(configuration_details)\n            return\n        elif _is_second_run():\n            _configure(configuration_details)\n            logs.configured_successfully(configuration_details)\n            return\n        else:\n            _record_first_run()\n\n    logs.how_to_configure_alias(configuration_details)\n", "thefuck/entrypoints/main.py": "# Initialize output before importing any module, that can use colorama.\nfrom ..system import init_output\n\ninit_output()\n\nimport os  # noqa: E402\nimport sys  # noqa: E402\nfrom .. import logs  # noqa: E402\nfrom ..argument_parser import Parser  # noqa: E402\nfrom ..utils import get_installation_version  # noqa: E402\nfrom ..shells import shell  # noqa: E402\nfrom .alias import print_alias  # noqa: E402\nfrom .fix_command import fix_command  # noqa: E402\n\n\ndef main():\n    parser = Parser()\n    known_args = parser.parse(sys.argv)\n\n    if known_args.help:\n        parser.print_help()\n    elif known_args.version:\n        logs.version(get_installation_version(),\n                     sys.version.split()[0], shell.info())\n    # It's important to check if an alias is being requested before checking if\n    # `TF_HISTORY` is in `os.environ`, otherwise it might mess with subshells.\n    # Check https://github.com/nvbn/thefuck/issues/921 for reference\n    elif known_args.alias:\n        print_alias(known_args)\n    elif known_args.command or 'TF_HISTORY' in os.environ:\n        fix_command(known_args)\n    elif known_args.shell_logger:\n        try:\n            from .shell_logger import shell_logger  # noqa: E402\n        except ImportError:\n            logs.warn('Shell logger supports only Linux and macOS')\n        else:\n            shell_logger(known_args.shell_logger)\n    else:\n        parser.print_usage()\n", "thefuck/entrypoints/__init__.py": "", "thefuck/entrypoints/fix_command.py": "from pprint import pformat\nimport os\nimport sys\nfrom difflib import SequenceMatcher\nfrom .. import logs, types, const\nfrom ..conf import settings\nfrom ..corrector import get_corrected_commands\nfrom ..exceptions import EmptyCommand\nfrom ..ui import select_command\nfrom ..utils import get_alias, get_all_executables\n\n\ndef _get_raw_command(known_args):\n    if known_args.force_command:\n        return [known_args.force_command]\n    elif not os.environ.get('TF_HISTORY'):\n        return known_args.command\n    else:\n        history = os.environ['TF_HISTORY'].split('\\n')[::-1]\n        alias = get_alias()\n        executables = get_all_executables()\n        for command in history:\n            diff = SequenceMatcher(a=alias, b=command).ratio()\n            if diff < const.DIFF_WITH_ALIAS or command in executables:\n                return [command]\n    return []\n\n\ndef fix_command(known_args):\n    \"\"\"Fixes previous command. Used when `thefuck` called without arguments.\"\"\"\n    settings.init(known_args)\n    with logs.debug_time('Total'):\n        logs.debug(u'Run with settings: {}'.format(pformat(settings)))\n        raw_command = _get_raw_command(known_args)\n\n        try:\n            command = types.Command.from_raw_script(raw_command)\n        except EmptyCommand:\n            logs.debug('Empty command, nothing to do')\n            return\n\n        corrected_commands = get_corrected_commands(command)\n        selected_command = select_command(corrected_commands)\n\n        if selected_command:\n            selected_command.run(command)\n        else:\n            sys.exit(1)\n", "thefuck/entrypoints/shell_logger.py": "import array\nimport fcntl\nfrom functools import partial\nimport mmap\nimport os\nimport pty\nimport signal\nimport sys\nimport termios\nimport tty\nfrom .. import logs, const\n\n\ndef _read(f, fd):\n    data = os.read(fd, 1024)\n    try:\n        f.write(data)\n    except ValueError:\n        position = const.LOG_SIZE_IN_BYTES - const.LOG_SIZE_TO_CLEAN\n        f.move(0, const.LOG_SIZE_TO_CLEAN, position)\n        f.seek(position)\n        f.write(b'\\x00' * const.LOG_SIZE_TO_CLEAN)\n        f.seek(position)\n    return data\n\n\ndef _set_pty_size(master_fd):\n    buf = array.array('h', [0, 0, 0, 0])\n    fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)\n    fcntl.ioctl(master_fd, termios.TIOCSWINSZ, buf)\n\n\ndef _spawn(shell, master_read):\n    \"\"\"Create a spawned process.\n\n    Modified version of pty.spawn with terminal size support.\n\n    \"\"\"\n    pid, master_fd = pty.fork()\n\n    if pid == pty.CHILD:\n        os.execlp(shell, shell)\n\n    try:\n        mode = tty.tcgetattr(pty.STDIN_FILENO)\n        tty.setraw(pty.STDIN_FILENO)\n        restore = True\n    except tty.error:    # This is the same as termios.error\n        restore = False\n\n    _set_pty_size(master_fd)\n    signal.signal(signal.SIGWINCH, lambda *_: _set_pty_size(master_fd))\n\n    try:\n        pty._copy(master_fd, master_read, pty._read)\n    except OSError:\n        if restore:\n            tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)\n\n    os.close(master_fd)\n    return os.waitpid(pid, 0)[1]\n\n\ndef shell_logger(output):\n    \"\"\"Logs shell output to the `output`.\n\n    Works like unix script command with `-f` flag.\n\n    \"\"\"\n    if not os.environ.get('SHELL'):\n        logs.warn(\"Shell logger doesn't support your platform.\")\n        sys.exit(1)\n\n    fd = os.open(output, os.O_CREAT | os.O_TRUNC | os.O_RDWR)\n    os.write(fd, b'\\x00' * const.LOG_SIZE_IN_BYTES)\n    buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_WRITE)\n    return_code = _spawn(os.environ['SHELL'], partial(_read, buffer))\n\n    sys.exit(return_code)\n", "thefuck/output_readers/rerun.py": "import os\nimport shlex\nimport six\nfrom subprocess import Popen, PIPE, STDOUT\nfrom psutil import AccessDenied, Process, TimeoutExpired\nfrom .. import logs\nfrom ..conf import settings\n\n\ndef _kill_process(proc):\n    \"\"\"Tries to kill the process otherwise just logs a debug message, the\n    process will be killed when thefuck terminates.\n\n    :type proc: Process\n\n    \"\"\"\n    try:\n        proc.kill()\n    except AccessDenied:\n        logs.debug(u'Rerun: process PID {} ({}) could not be terminated'.format(\n            proc.pid, proc.exe()))\n\n\ndef _wait_output(popen, is_slow):\n    \"\"\"Returns `True` if we can get output of the command in the\n    `settings.wait_command` time.\n\n    Command will be killed if it wasn't finished in the time.\n\n    :type popen: Popen\n    :rtype: bool\n\n    \"\"\"\n    proc = Process(popen.pid)\n    try:\n        proc.wait(settings.wait_slow_command if is_slow\n                  else settings.wait_command)\n        return True\n    except TimeoutExpired:\n        for child in proc.children(recursive=True):\n            _kill_process(child)\n        _kill_process(proc)\n        return False\n\n\ndef get_output(script, expanded):\n    \"\"\"Runs the script and obtains stdin/stderr.\n\n    :type script: str\n    :type expanded: str\n    :rtype: str | None\n\n    \"\"\"\n    env = dict(os.environ)\n    env.update(settings.env)\n\n    if six.PY2:\n        expanded = expanded.encode('utf-8')\n\n    split_expand = shlex.split(expanded)\n    is_slow = split_expand[0] in settings.slow_commands if split_expand else False\n    with logs.debug_time(u'Call: {}; with env: {}; is slow: {}'.format(\n            script, env, is_slow)):\n        result = Popen(expanded, shell=True, stdin=PIPE,\n                       stdout=PIPE, stderr=STDOUT, env=env)\n        if _wait_output(result, is_slow):\n            output = result.stdout.read().decode('utf-8', errors='replace')\n            logs.debug(u'Received output: {}'.format(output))\n            return output\n        else:\n            logs.debug(u'Execution timed out!')\n            return None\n", "thefuck/output_readers/read_log.py": "import os\nimport shlex\nimport mmap\nimport re\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n    from backports.shutil_get_terminal_size import get_terminal_size\nimport six\nimport pyte\nfrom ..exceptions import ScriptNotInLog\nfrom .. import const, logs\n\n\ndef _group_by_calls(log):\n    ps1 = os.environ['PS1']\n    ps1_newlines = ps1.count('\\\\n') + ps1.count('\\n')\n    ps1_counter = 0\n\n    script_line = None\n    lines = []\n    for line in log:\n        if const.USER_COMMAND_MARK in line or ps1_counter > 0:\n            if script_line and ps1_counter == 0:\n                yield script_line, lines\n\n            if ps1_newlines > 0:\n                if ps1_counter <= 0:\n                    ps1_counter = ps1_newlines\n                else:\n                    ps1_counter -= 1\n\n            script_line = line\n            lines = [line]\n        elif script_line is not None:\n            lines.append(line)\n\n    if script_line:\n        yield script_line, lines\n\n\ndef _get_script_group_lines(grouped, script):\n    if six.PY2:\n        script = script.encode('utf-8')\n\n    parts = shlex.split(script)\n\n    for script_line, lines in reversed(grouped):\n        if all(part in script_line for part in parts):\n            return lines\n\n    raise ScriptNotInLog\n\n\ndef _get_output_lines(script, log_file):\n    data = log_file.read().decode()\n    data = re.sub(r'\\x00+$', '', data)\n    lines = data.split('\\n')\n    grouped = list(_group_by_calls(lines))\n    script_lines = _get_script_group_lines(grouped, script)\n    screen = pyte.Screen(get_terminal_size().columns, len(script_lines))\n    stream = pyte.Stream(screen)\n    stream.feed('\\n'.join(script_lines))\n    return screen.display\n\n\ndef _skip_old_lines(log_file):\n    size = os.path.getsize(os.environ['THEFUCK_OUTPUT_LOG'])\n    if size > const.LOG_SIZE_IN_BYTES:\n        log_file.seek(size - const.LOG_SIZE_IN_BYTES)\n\n\ndef get_output(script):\n    \"\"\"Reads script output from log.\n\n    :type script: str\n    :rtype: str | None\n\n    \"\"\"\n    if six.PY2:\n        logs.warn('Experimental instant mode is Python 3+ only')\n        return None\n\n    if 'THEFUCK_OUTPUT_LOG' not in os.environ:\n        logs.warn(\"Output log isn't specified\")\n        return None\n\n    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):\n        logs.warn(\n            \"PS1 doesn't contain user command mark, please ensure \"\n            \"that PS1 is not changed after The Fuck alias initialization\")\n        return None\n\n    try:\n        with logs.debug_time(u'Read output from log'):\n            fd = os.open(os.environ['THEFUCK_OUTPUT_LOG'], os.O_RDONLY)\n            buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_READ)\n            _skip_old_lines(buffer)\n            lines = _get_output_lines(script, buffer)\n            output = '\\n'.join(lines).strip()\n            logs.debug(u'Received output: {}'.format(output))\n            return output\n    except OSError:\n        logs.warn(\"Can't read output log\")\n        return None\n    except ScriptNotInLog:\n        logs.warn(\"Script not found in output log\")\n        return None\n", "thefuck/output_readers/__init__.py": "from ..conf import settings\nfrom . import read_log, rerun, shell_logger\n\n\ndef get_output(script, expanded):\n    \"\"\"Get output of the script.\n\n    :param script: Console script.\n    :type script: str\n    :param expanded: Console script with expanded aliases.\n    :type expanded: str\n    :rtype: str\n\n    \"\"\"\n    if shell_logger.is_available():\n        return shell_logger.get_output(script)\n    if settings.instant_mode:\n        return read_log.get_output(script)\n    else:\n        return rerun.get_output(script, expanded)\n", "thefuck/output_readers/shell_logger.py": "import json\nimport os\nimport socket\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n    from backports.shutil_get_terminal_size import get_terminal_size\nimport pyte\nfrom .. import const, logs\n\n\ndef _get_socket_path():\n    return os.environ.get(const.SHELL_LOGGER_SOCKET_ENV)\n\n\ndef is_available():\n    \"\"\"Returns `True` if shell logger socket available.\n\n    :rtype: book\n\n    \"\"\"\n    path = _get_socket_path()\n    if not path:\n        return False\n\n    return os.path.exists(path)\n\n\ndef _get_last_n(n):\n    with socket.socket(socket.AF_UNIX) as client:\n        client.connect(_get_socket_path())\n        request = json.dumps({\n            \"type\": \"list\",\n            \"count\": n,\n        }) + '\\n'\n        client.sendall(request.encode('utf-8'))\n        response = client.makefile().readline()\n        return json.loads(response)['commands']\n\n\ndef _get_output_lines(output):\n    lines = output.split('\\n')\n    screen = pyte.Screen(get_terminal_size().columns, len(lines))\n    stream = pyte.Stream(screen)\n    stream.feed('\\n'.join(lines))\n    return screen.display\n\n\ndef get_output(script):\n    \"\"\"Gets command output from shell logger.\"\"\"\n    with logs.debug_time(u'Read output from external shell logger'):\n        commands = _get_last_n(const.SHELL_LOGGER_LIMIT)\n        for command in commands:\n            if command['command'] == script:\n                lines = _get_output_lines(command['output'])\n                output = '\\n'.join(lines).strip()\n                return output\n            else:\n                logs.warn(\"Output isn't available in shell logger\")\n                return None\n", "thefuck/rules/cd_correction.py": "\"\"\"Attempts to spellcheck and correct failed cd commands\"\"\"\n\nimport os\nimport six\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.rules import cd_mkdir\nfrom thefuck.utils import for_app, get_close_matches\n\n__author__ = \"mmussomele\"\n\nMAX_ALLOWED_DIFF = 0.6\n\n\ndef _get_sub_dirs(parent):\n    \"\"\"Returns a list of the child directories of the given parent directory\"\"\"\n    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]\n\n\n@sudo_support\n@for_app('cd')\ndef match(command):\n    \"\"\"Match function copied from cd_mkdir.py\"\"\"\n    return (\n        command.script.startswith('cd ') and any((\n            'no such file or directory' in command.output.lower(),\n            'cd: can\\'t cd to' in command.output.lower(),\n            'does not exist' in command.output.lower()\n        )))\n\n\n@sudo_support\ndef get_new_command(command):\n    \"\"\"\n    Attempt to rebuild the path string by spellchecking the directories.\n    If it fails (i.e. no directories are a close enough match), then it\n    defaults to the rules of cd_mkdir.\n    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6\n    \"\"\"\n    dest = command.script_parts[1].split(os.sep)\n    if dest[-1] == '':\n        dest = dest[:-1]\n\n    if dest[0] == '':\n        cwd = os.sep\n        dest = dest[1:]\n    elif six.PY2:\n        cwd = os.getcwdu()\n    else:\n        cwd = os.getcwd()\n    for directory in dest:\n        if directory == \".\":\n            continue\n        elif directory == \"..\":\n            cwd = os.path.split(cwd)[0]\n            continue\n        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)\n        if best_matches:\n            cwd = os.path.join(cwd, best_matches[0])\n        else:\n            return cd_mkdir.get_new_command(command)\n    return u'cd \"{0}\"'.format(cwd)\n", "thefuck/rules/has_exists_script.py": "import os\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return command.script_parts and os.path.exists(command.script_parts[0]) \\\n        and 'command not found' in command.output\n\n\n@sudo_support\ndef get_new_command(command):\n    return u'./{}'.format(command.script)\n", "thefuck/rules/dirty_unzip.py": "import os\nimport zipfile\nfrom thefuck.utils import for_app\nfrom thefuck.shells import shell\n\n\ndef _is_bad_zip(file):\n    try:\n        with zipfile.ZipFile(file, 'r') as archive:\n            return len(archive.namelist()) > 1\n    except Exception:\n        return False\n\n\ndef _zip_file(command):\n    # unzip works that way:\n    # unzip [-flags] file[.zip] [file(s) ...] [-x file(s) ...]\n    #                ^          ^ files to unzip from the archive\n    #                archive to unzip\n    for c in command.script_parts[1:]:\n        if not c.startswith('-'):\n            if c.endswith('.zip'):\n                return c\n            else:\n                return u'{}.zip'.format(c)\n\n\n@for_app('unzip')\ndef match(command):\n    if '-d' in command.script:\n        return False\n\n    zip_file = _zip_file(command)\n    if zip_file:\n        return _is_bad_zip(zip_file)\n    else:\n        return False\n\n\ndef get_new_command(command):\n    return u'{} -d {}'.format(\n        command.script, shell.quote(_zip_file(command)[:-4]))\n\n\ndef side_effect(old_cmd, command):\n    with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:\n        for file in archive.namelist():\n            if not os.path.abspath(file).startswith(os.getcwd()):\n                # it's unsafe to overwrite files outside of the current directory\n                continue\n\n            try:\n                os.remove(file)\n            except OSError:\n                # does not try to remove directories as we cannot know if they\n                # already existed before\n                pass\n\n\nrequires_output = False\n", "thefuck/rules/pacman_invalid_option.py": "from thefuck.specific.archlinux import archlinux_env\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app\nimport re\n\n\n@sudo_support\n@for_app(\"pacman\")\ndef match(command):\n    return command.output.startswith(\"error: invalid option '-\") and any(\n        \" -{}\".format(option) in command.script for option in \"surqfdvt\"\n    )\n\n\ndef get_new_command(command):\n    option = re.findall(r\" -[dfqrstuv]\", command.script)[0]\n    return re.sub(option, option.upper(), command.script)\n\n\nenabled_by_default = archlinux_env()\n", "thefuck/rules/systemctl.py": "\"\"\"\nThe confusion in systemctl's param order is massive.\n\"\"\"\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app\n\n\n@sudo_support\n@for_app('systemctl')\ndef match(command):\n    # Catches \"Unknown operation 'service'.\" when executing systemctl with\n    # misordered arguments\n    cmd = command.script_parts\n    return (cmd and 'Unknown operation \\'' in command.output and\n            len(cmd) - cmd.index('systemctl') == 3)\n\n\n@sudo_support\ndef get_new_command(command):\n    cmd = command.script_parts[:]\n    cmd[-1], cmd[-2] = cmd[-2], cmd[-1]\n    return ' '.join(cmd)\n", "thefuck/rules/rm_dir.py": "import re\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return ('rm' in command.script\n            and 'is a directory' in command.output.lower())\n\n\n@sudo_support\ndef get_new_command(command):\n    arguments = '-rf'\n    if 'hdfs' in command.script:\n        arguments = '-r'\n    return re.sub('\\\\brm (.*)', 'rm ' + arguments + ' \\\\1', command.script)\n", "thefuck/rules/react_native_command_unrecognized.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import for_app, replace_command, cache, eager\n\n\n@for_app('react-native')\ndef match(command):\n    return re.findall(r\"Unrecognized command '.*'\", command.output)\n\n\n@cache('package.json')\n@eager\ndef _get_commands():\n    proc = Popen(['react-native', '--help'], stdout=PIPE)\n    should_yield = False\n    for line in proc.stdout.readlines():\n        line = line.decode().strip()\n\n        if not line:\n            continue\n\n        if 'Commands:' in line:\n            should_yield = True\n            continue\n\n        if should_yield:\n            yield line.split(' ')[0]\n\n\ndef get_new_command(command):\n    misspelled_command = re.findall(r\"Unrecognized command '(.*)'\",\n                                    command.output)[0]\n    commands = _get_commands()\n    return replace_command(command, misspelled_command, commands)\n", "thefuck/rules/pip_install.py": "from thefuck.utils import for_app\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\n@for_app('pip')\ndef match(command):\n    return ('pip install' in command.script and 'Permission denied' in command.output)\n\n\ndef get_new_command(command):\n    if '--user' not in command.script:  # add --user (attempt 1)\n        return command.script.replace(' install ', ' install --user ')\n\n    return 'sudo {}'.format(command.script.replace(' --user', ''))  # since --user didn't fix things, let's try sudo (attempt 2)\n", "thefuck/rules/cp_create_destination.py": "from thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app(\"cp\", \"mv\")\ndef match(command):\n    return (\n        \"No such file or directory\" in command.output\n        or command.output.startswith(\"cp: directory\")\n        and command.output.rstrip().endswith(\"does not exist\")\n    )\n\n\ndef get_new_command(command):\n    return shell.and_(u\"mkdir -p {}\".format(command.script_parts[-1]), command.script)\n", "thefuck/rules/vagrant_up.py": "from thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app('vagrant')\ndef match(command):\n    return 'run `vagrant up`' in command.output.lower()\n\n\ndef get_new_command(command):\n    cmds = command.script_parts\n    machine = None\n    if len(cmds) >= 3:\n        machine = cmds[2]\n\n    start_all_instances = shell.and_(u\"vagrant up\", command.script)\n    if machine is None:\n        return start_all_instances\n    else:\n        return [shell.and_(u\"vagrant up {}\".format(machine), command.script),\n                start_all_instances]\n", "thefuck/rules/yum_invalid_operation.py": "import subprocess\nfrom itertools import dropwhile, islice, takewhile\n\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.specific.yum import yum_available\nfrom thefuck.utils import for_app, replace_command, which, cache\n\nenabled_by_default = yum_available\n\n\n@sudo_support\n@for_app('yum')\ndef match(command):\n    return 'No such command: ' in command.output\n\n\ndef _get_operations():\n    proc = subprocess.Popen('yum', stdout=subprocess.PIPE)\n\n    lines = proc.stdout.readlines()\n    lines = [line.decode('utf-8') for line in lines]\n    lines = dropwhile(lambda line: not line.startswith(\"List of Commands:\"), lines)\n    lines = islice(lines, 2, None)\n    lines = list(takewhile(lambda line: line.strip(), lines))\n    return [line.strip().split(' ')[0] for line in lines]\n\n\nif which('yum'):\n    _get_operations = cache(which('yum'))(_get_operations)\n\n\n@sudo_support\ndef get_new_command(command):\n    invalid_operation = command.script_parts[1]\n\n    if invalid_operation == 'uninstall':\n        return [command.script.replace('uninstall', 'remove')]\n\n    return replace_command(command, invalid_operation, _get_operations())\n", "thefuck/rules/man_no_space.py": "def match(command):\n    return (command.script.startswith(u'man')\n            and u'command not found' in command.output.lower())\n\n\ndef get_new_command(command):\n    return u'man {}'.format(command.script[3:])\n\n\npriority = 2000\n", "thefuck/rules/workon_doesnt_exists.py": "from thefuck.utils import for_app, replace_command, eager, memoize\nfrom thefuck.system import Path\n\n\n@memoize\n@eager\ndef _get_all_environments():\n    root = Path('~/.virtualenvs').expanduser()\n    if not root.is_dir():\n        return\n\n    for child in root.iterdir():\n        if child.is_dir():\n            yield child.name\n\n\n@for_app('workon')\ndef match(command):\n    return (len(command.script_parts) >= 2\n            and command.script_parts[1] not in _get_all_environments())\n\n\ndef get_new_command(command):\n    misspelled_env = command.script_parts[1]\n    create_new = u'mkvirtualenv {}'.format(misspelled_env)\n\n    available = _get_all_environments()\n    if available:\n        return (replace_command(command, misspelled_env, available)\n                + [create_new])\n    else:\n        return create_new\n", "thefuck/rules/whois.py": "# -*- encoding: utf-8 -*-\nfrom six.moves.urllib.parse import urlparse\nfrom thefuck.utils import for_app\n\n\n@for_app('whois', at_least=1)\ndef match(command):\n    \"\"\"\n    What the `whois` command returns depends on the 'Whois server' it contacted\n    and is not consistent through different servers. But there can be only two\n    types of errors I can think of with `whois`:\n        - `whois https://en.wikipedia.org/` \u2192 `whois en.wikipedia.org`;\n        - `whois en.wikipedia.org` \u2192 `whois wikipedia.org`.\n    So we match any `whois` command and then:\n        - if there is a slash: keep only the FQDN;\n        - if there is no slash but there is a point: removes the left-most\n          subdomain.\n\n    We cannot either remove all subdomains because we cannot know which part is\n    the subdomains and which is the domain, consider:\n        - www.google.fr \u2192 subdomain: www, domain: 'google.fr';\n        - google.co.uk \u2192 subdomain: None, domain; 'google.co.uk'.\n    \"\"\"\n    return True\n\n\ndef get_new_command(command):\n    url = command.script_parts[1]\n\n    if '/' in command.script:\n        return 'whois ' + urlparse(url).netloc\n    elif '.' in command.script:\n        path = urlparse(url).path.split('.')\n        return ['whois ' + '.'.join(path[n:]) for n in range(1, len(path))]\n", "thefuck/rules/git_push_force.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('push' in command.script\n            and '! [rejected]' in command.output\n            and 'failed to push some refs to' in command.output\n            and 'Updates were rejected because the tip of your current branch is behind' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'push', 'push --force-with-lease')\n\n\nenabled_by_default = False\n", "thefuck/rules/javac.py": "\"\"\"Appends .java when compiling java files\n\nExample:\n > javac foo\n error: Class names, 'foo', are only accepted if annotation\n processing is explicitly requested\n\n\"\"\"\nfrom thefuck.utils import for_app\n\n\n@for_app('javac')\ndef match(command):\n    return not command.script.endswith('.java')\n\n\ndef get_new_command(command):\n    return command.script + '.java'\n", "thefuck/rules/terraform_no_command.py": "import re\nfrom thefuck.utils import for_app\n\nMISTAKE = r'(?<=Terraform has no command named \")([^\"]+)(?=\"\\.)'\nFIX = r'(?<=Did you mean \")([^\"]+)(?=\"\\?)'\n\n\n@for_app('terraform')\ndef match(command):\n    return re.search(MISTAKE, command.output) and re.search(FIX, command.output)\n\n\ndef get_new_command(command):\n    mistake = re.search(MISTAKE, command.output).group(0)\n    fix = re.search(FIX, command.output).group(0)\n    return command.script.replace(mistake, fix)\n", "thefuck/rules/git_pull.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return 'pull' in command.script and 'set-upstream' in command.output\n\n\n@git_support\ndef get_new_command(command):\n    line = command.output.split('\\n')[-3].strip()\n    branch = line.split(' ')[-1]\n    set_upstream = line.replace('<remote>', 'origin')\\\n                       .replace('<branch>', branch)\n    return shell.and_(set_upstream, command.script)\n", "thefuck/rules/mkdir_p.py": "import re\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return ('mkdir' in command.script\n            and 'No such file or directory' in command.output)\n\n\n@sudo_support\ndef get_new_command(command):\n    return re.sub('\\\\bmkdir (.*)', 'mkdir -p \\\\1', command.script)\n", "thefuck/rules/grep_arguments_order.py": "import os\nfrom thefuck.utils import for_app\n\n\ndef _get_actual_file(parts):\n    for part in parts[1:]:\n        if os.path.isfile(part) or os.path.isdir(part):\n            return part\n\n\n@for_app('grep', 'egrep')\ndef match(command):\n    return ': No such file or directory' in command.output \\\n        and _get_actual_file(command.script_parts)\n\n\ndef get_new_command(command):\n    actual_file = _get_actual_file(command.script_parts)\n    parts = command.script_parts[::]\n    # Moves file to the end of the script:\n    parts.remove(actual_file)\n    parts.append(actual_file)\n    return ' '.join(parts)\n", "thefuck/rules/mvn_unknown_lifecycle_phase.py": "from thefuck.utils import for_app, get_close_matches, replace_command\nimport re\n\n\ndef _get_failed_lifecycle(command):\n    return re.search(r'\\[ERROR\\] Unknown lifecycle phase \"(.+)\"',\n                     command.output)\n\n\ndef _getavailable_lifecycles(command):\n    return re.search(\n        r'Available lifecycle phases are: (.+) -> \\[Help 1\\]', command.output)\n\n\n@for_app('mvn')\ndef match(command):\n    failed_lifecycle = _get_failed_lifecycle(command)\n    available_lifecycles = _getavailable_lifecycles(command)\n    return available_lifecycles and failed_lifecycle\n\n\ndef get_new_command(command):\n    failed_lifecycle = _get_failed_lifecycle(command)\n    available_lifecycles = _getavailable_lifecycles(command)\n    if available_lifecycles and failed_lifecycle:\n        selected_lifecycle = get_close_matches(\n            failed_lifecycle.group(1), available_lifecycles.group(1).split(\", \"))\n        return replace_command(command, failed_lifecycle.group(1), selected_lifecycle)\n    else:\n        return []\n", "thefuck/rules/ifconfig_device_not_found.py": "import subprocess\nfrom thefuck.utils import for_app, replace_command, eager\n\n\n@for_app('ifconfig')\ndef match(command):\n    return 'error fetching interface information: Device not found' \\\n           in command.output\n\n\n@eager\ndef _get_possible_interfaces():\n    proc = subprocess.Popen(['ifconfig', '-a'], stdout=subprocess.PIPE)\n    for line in proc.stdout.readlines():\n        line = line.decode()\n        if line and line != '\\n' and not line.startswith(' '):\n            yield line.split(' ')[0]\n\n\ndef get_new_command(command):\n    interface = command.output.split(' ')[0][:-1]\n    possible_interfaces = _get_possible_interfaces()\n    return replace_command(command, interface, possible_interfaces)\n", "thefuck/rules/man.py": "from thefuck.utils import for_app\n\n\n@for_app('man', at_least=1)\ndef match(command):\n    return True\n\n\ndef get_new_command(command):\n    if '3' in command.script:\n        return command.script.replace(\"3\", \"2\")\n    if '2' in command.script:\n        return command.script.replace(\"2\", \"3\")\n\n    last_arg = command.script_parts[-1]\n    help_command = last_arg + ' --help'\n\n    # If there are no man pages for last_arg, suggest `last_arg --help` instead.\n    # Otherwise, suggest `--help` after suggesting other man page sections.\n    if command.output.strip() == 'No manual entry for ' + last_arg:\n        return [help_command]\n\n    split_cmd2 = command.script_parts\n    split_cmd3 = split_cmd2[:]\n\n    split_cmd2.insert(1, ' 2 ')\n    split_cmd3.insert(1, ' 3 ')\n\n    return [\n        \"\".join(split_cmd3),\n        \"\".join(split_cmd2),\n        help_command,\n    ]\n", "thefuck/rules/rails_migrations_pending.py": "import re\nfrom thefuck.shells import shell\n\n\nSUGGESTION_REGEX = r\"To resolve this issue, run:\\s+(.*?)\\n\"\n\n\ndef match(command):\n    return \"Migrations are pending. To resolve this issue, run:\" in command.output\n\n\ndef get_new_command(command):\n    migration_script = re.search(SUGGESTION_REGEX, command.output).group(1)\n    return shell.and_(migration_script, command.script)\n", "thefuck/rules/no_command.py": "from thefuck.utils import get_all_executables, get_close_matches, \\\n    get_valid_history_without_current, get_closest, which\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return (not which(command.script_parts[0])\n            and ('not found' in command.output\n                 or 'is not recognized as' in command.output)\n            and bool(get_close_matches(command.script_parts[0],\n                                       get_all_executables())))\n\n\ndef _get_used_executables(command):\n    for script in get_valid_history_without_current(command):\n        yield script.split(' ')[0]\n\n\n@sudo_support\ndef get_new_command(command):\n    old_command = command.script_parts[0]\n\n    # One from history:\n    already_used = get_closest(\n        old_command, _get_used_executables(command),\n        fallback_to_first=False)\n    if already_used:\n        new_cmds = [already_used]\n    else:\n        new_cmds = []\n\n    # Other from all executables:\n    new_cmds += [cmd for cmd in get_close_matches(old_command,\n                                                  get_all_executables())\n                 if cmd not in new_cmds]\n\n    return [command.script.replace(old_command, cmd, 1) for cmd in new_cmds]\n\n\npriority = 3000\n", "thefuck/rules/npm_missing_script.py": "import re\nfrom thefuck.utils import for_app, replace_command\nfrom thefuck.specific.npm import get_scripts, npm_available\n\nenabled_by_default = npm_available\n\n\n@for_app('npm')\ndef match(command):\n    return (any(part.startswith('ru') for part in command.script_parts)\n            and 'npm ERR! missing script: ' in command.output)\n\n\ndef get_new_command(command):\n    misspelled_script = re.findall(\n        r'.*missing script: (.*)\\n', command.output)[0]\n    return replace_command(command, misspelled_script, get_scripts())\n", "thefuck/rules/cargo_no_command.py": "import re\nfrom thefuck.utils import replace_argument, for_app\n\n\n@for_app('cargo', at_least=1)\ndef match(command):\n    return ('no such subcommand' in command.output.lower()\n            and 'Did you mean' in command.output)\n\n\ndef get_new_command(command):\n    broken = command.script_parts[1]\n    fix = re.findall(r'Did you mean `([^`]*)`', command.output)[0]\n\n    return replace_argument(command.script, broken, fix)\n", "thefuck/rules/npm_wrong_command.py": "from thefuck.specific.npm import npm_available\nfrom thefuck.utils import replace_argument, for_app, eager, get_closest\nfrom thefuck.specific.sudo import sudo_support\n\nenabled_by_default = npm_available\n\n\ndef _get_wrong_command(script_parts):\n    commands = [part for part in script_parts[1:] if not part.startswith('-')]\n    if commands:\n        return commands[0]\n\n\n@sudo_support\n@for_app('npm')\ndef match(command):\n    return (command.script_parts[0] == 'npm' and\n            'where <command> is one of:' in command.output and\n            _get_wrong_command(command.script_parts))\n\n\n@eager\ndef _get_available_commands(stdout):\n    commands_listing = False\n    for line in stdout.split('\\n'):\n        if line.startswith('where <command> is one of:'):\n            commands_listing = True\n        elif commands_listing:\n            if not line:\n                break\n\n            for command in line.split(', '):\n                stripped = command.strip()\n                if stripped:\n                    yield stripped\n\n\ndef get_new_command(command):\n    npm_commands = _get_available_commands(command.output)\n    wrong_command = _get_wrong_command(command.script_parts)\n    fixed = get_closest(wrong_command, npm_commands)\n    return replace_argument(command.script, wrong_command, fixed)\n", "thefuck/rules/git_pull_uncommitted_changes.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('pull' in command.script\n            and ('You have unstaged changes' in command.output\n                 or 'contains uncommitted changes' in command.output))\n\n\n@git_support\ndef get_new_command(command):\n    return shell.and_('git stash', 'git pull', 'git stash pop')\n", "thefuck/rules/cd_mkdir.py": "import re\nfrom thefuck.utils import for_app\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.shells import shell\n\n\n@sudo_support\n@for_app('cd')\ndef match(command):\n    return (\n        command.script.startswith('cd ') and any((\n            'no such file or directory' in command.output.lower(),\n            'cd: can\\'t cd to' in command.output.lower(),\n            'does not exist' in command.output.lower()\n        )))\n\n\n@sudo_support\ndef get_new_command(command):\n    repl = shell.and_('mkdir -p \\\\1', 'cd \\\\1')\n    return re.sub(r'^cd (.*)', repl, command.script)\n", "thefuck/rules/heroku_multiple_apps.py": "import re\nfrom thefuck.utils import for_app\n\n\n@for_app('heroku')\ndef match(command):\n    return 'https://devcenter.heroku.com/articles/multiple-environments' in command.output\n\n\ndef get_new_command(command):\n    apps = re.findall('([^ ]*) \\\\([^)]*\\\\)', command.output)\n    return [command.script + ' --app ' + app for app in apps]\n", "thefuck/rules/yarn_alias.py": "import re\nfrom thefuck.utils import replace_argument, for_app\n\n\n@for_app('yarn', at_least=1)\ndef match(command):\n    return 'Did you mean' in command.output\n\n\ndef get_new_command(command):\n    broken = command.script_parts[1]\n    fix = re.findall(r'Did you mean [`\"](?:yarn )?([^`\"]*)[`\"]', command.output)[0]\n\n    return replace_argument(command.script, broken, fix)\n", "thefuck/rules/yarn_command_not_found.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import (for_app, eager, replace_command, replace_argument,\n                           cache, which)\n\nregex = re.compile(r'error Command \"(.*)\" not found.')\n\n\n@for_app('yarn')\ndef match(command):\n    return regex.findall(command.output)\n\n\nnpm_commands = {'require': 'add'}\n\n\n@eager\ndef _get_all_tasks():\n    proc = Popen(['yarn', '--help'], stdout=PIPE)\n    should_yield = False\n    for line in proc.stdout.readlines():\n        line = line.decode().strip()\n\n        if 'Commands:' in line:\n            should_yield = True\n            continue\n\n        if should_yield and '- ' in line:\n            yield line.split(' ')[-1]\n\n\nif which('yarn'):\n    _get_all_tasks = cache(which('yarn'))(_get_all_tasks)\n\n\ndef get_new_command(command):\n    misspelled_task = regex.findall(command.output)[0]\n    if misspelled_task in npm_commands:\n        yarn_command = npm_commands[misspelled_task]\n        return replace_argument(command.script, misspelled_task, yarn_command)\n    else:\n        tasks = _get_all_tasks()\n        return replace_command(command, misspelled_task, tasks)\n", "thefuck/rules/brew_reinstall.py": "import re\nfrom thefuck.utils import for_app\n\n\nwarning_regex = re.compile(r'Warning: (?:.(?!is ))+ is already installed and '\n                           r'up-to-date')\nmessage_regex = re.compile(r'To reinstall (?:(?!, ).)+, run `brew reinstall '\n                           r'[^`]+`')\n\n\n@for_app('brew', at_least=2)\ndef match(command):\n    return ('install' in command.script\n            and warning_regex.search(command.output)\n            and message_regex.search(command.output))\n\n\ndef get_new_command(command):\n    return command.script.replace('install', 'reinstall')\n", "thefuck/rules/git_fix_stash.py": "from thefuck import utils\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    if command.script_parts and len(command.script_parts) > 1:\n        return (command.script_parts[1] == 'stash'\n                and 'usage:' in command.output)\n    else:\n        return False\n\n\n# git's output here is too complicated to be parsed (see the test file)\nstash_commands = (\n    'apply',\n    'branch',\n    'clear',\n    'drop',\n    'list',\n    'pop',\n    'save',\n    'show')\n\n\n@git_support\ndef get_new_command(command):\n    stash_cmd = command.script_parts[2]\n    fixed = utils.get_closest(stash_cmd, stash_commands, fallback_to_first=False)\n\n    if fixed is not None:\n        return replace_argument(command.script, stash_cmd, fixed)\n    else:\n        cmd = command.script_parts[:]\n        cmd.insert(2, 'save')\n        return ' '.join(cmd)\n", "thefuck/rules/sed_unterminated_s.py": "import shlex\nfrom thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app('sed')\ndef match(command):\n    return \"unterminated `s' command\" in command.output\n\n\ndef get_new_command(command):\n    script = shlex.split(command.script)\n\n    for (i, e) in enumerate(script):\n        if e.startswith(('s/', '-es/')) and e[-1] != '/':\n            script[i] += '/'\n\n    return ' '.join(map(shell.quote, script))\n", "thefuck/rules/ag_literal.py": "from thefuck.utils import for_app\n\n\n@for_app('ag')\ndef match(command):\n    return command.output.endswith('run ag with -Q\\n')\n\n\ndef get_new_command(command):\n    return command.script.replace('ag', 'ag -Q', 1)\n", "thefuck/rules/wrong_hyphen_before_subcommand.py": "from thefuck.utils import get_all_executables\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    first_part = command.script_parts[0]\n    if \"-\" not in first_part or first_part in get_all_executables():\n        return False\n    cmd, _ = first_part.split(\"-\", 1)\n    return cmd in get_all_executables()\n\n\n@sudo_support\ndef get_new_command(command):\n    return command.script.replace(\"-\", \" \", 1)\n\n\npriority = 4500\nrequires_output = False\n", "thefuck/rules/git_rm_recursive.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (' rm ' in command.script\n            and \"fatal: not removing '\" in command.output\n            and \"' recursively without -r\" in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n    index = command_parts.index('rm') + 1\n    command_parts.insert(index, '-r')\n    return u' '.join(command_parts)\n", "thefuck/rules/ls_all.py": "from thefuck.utils import for_app\n\n\n@for_app('ls')\ndef match(command):\n    return command.output.strip() == ''\n\n\ndef get_new_command(command):\n    return ' '.join(['ls', '-A'] + command.script_parts[1:])\n", "thefuck/rules/apt_upgrade.py": "from thefuck.specific.apt import apt_available\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app\n\nenabled_by_default = apt_available\n\n\n@sudo_support\n@for_app('apt')\ndef match(command):\n    return command.script == \"apt list --upgradable\" and len(command.output.strip().split('\\n')) > 1\n\n\n@sudo_support\ndef get_new_command(command):\n    return 'apt upgrade'\n", "thefuck/rules/git_push_different_branch_names.py": "import re\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return \"push\" in command.script and \"The upstream branch of your current branch does not match\" in command.output\n\n\n@git_support\ndef get_new_command(command):\n    return re.findall(r'^ +(git push [^\\s]+ [^\\s]+)', command.output, re.MULTILINE)[0]\n", "thefuck/rules/long_form_help.py": "from thefuck.utils import replace_argument\nimport re\n\n# regex to match a suggested help command from the tool output\nhelp_regex = r\"(?:Run|Try) '([^']+)'(?: or '[^']+')? for (?:details|more information).\"\n\n\ndef match(command):\n    if re.search(help_regex, command.output, re.I) is not None:\n        return True\n\n    if '--help' in command.output:\n        return True\n\n    return False\n\n\ndef get_new_command(command):\n    if re.search(help_regex, command.output) is not None:\n        match_obj = re.search(help_regex, command.output, re.I)\n        return match_obj.group(1)\n\n    return replace_argument(command.script, '-h', '--help')\n\n\nenabled_by_default = True\npriority = 5000\n", "thefuck/rules/sudo_command_from_user_path.py": "import re\nfrom thefuck.utils import for_app, which, replace_argument\n\n\ndef _get_command_name(command):\n    found = re.findall(r'sudo: (.*): command not found', command.output)\n    if found:\n        return found[0]\n\n\n@for_app('sudo')\ndef match(command):\n    if 'command not found' in command.output:\n        command_name = _get_command_name(command)\n        return which(command_name)\n\n\ndef get_new_command(command):\n    command_name = _get_command_name(command)\n    return replace_argument(command.script, command_name,\n                            u'env \"PATH=$PATH\" {}'.format(command_name))\n", "thefuck/rules/git_diff_staged.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('diff' in command.script and\n            '--staged' not in command.script)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'diff', 'diff --staged')\n", "thefuck/rules/sl_ls.py": "\"\"\"\nThis happens way too often\n\nWhen typing really fast cause I'm a 1337 H4X0R,\nI often fuck up 'ls' and type 'sl'. No more!\n\"\"\"\n\n\ndef match(command):\n    return command.script == 'sl'\n\n\ndef get_new_command(command):\n    return 'ls'\n", "thefuck/rules/pacman_not_found.py": "\"\"\" Fixes wrong package names with pacman or yaourt.\n\nFor example the `llc` program is in package `llvm` so this:\n    yay -S llc\nshould be:\n    yay -S llvm\n\"\"\"\n\nfrom thefuck.utils import replace_command\nfrom thefuck.specific.archlinux import get_pkgfile, archlinux_env\n\n\ndef match(command):\n    return (command.script_parts\n            and (command.script_parts[0] in ('pacman', 'yay', 'pikaur', 'yaourt')\n                 or command.script_parts[0:2] == ['sudo', 'pacman'])\n            and 'error: target not found:' in command.output)\n\n\ndef get_new_command(command):\n    pgr = command.script_parts[-1]\n\n    return replace_command(command, pgr, get_pkgfile(pgr))\n\n\nenabled_by_default, _ = archlinux_env()\n", "thefuck/rules/gem_unknown_command.py": "import re\nimport subprocess\nfrom thefuck.utils import for_app, eager, replace_command, cache, which\n\n\n@for_app('gem')\ndef match(command):\n    return ('ERROR:  While executing gem ... (Gem::CommandLineError)'\n            in command.output\n            and 'Unknown command' in command.output)\n\n\ndef _get_unknown_command(command):\n    return re.findall(r'Unknown command (.*)$', command.output)[0]\n\n\n@eager\ndef _get_all_commands():\n    proc = subprocess.Popen(['gem', 'help', 'commands'],\n                            stdout=subprocess.PIPE)\n\n    for line in proc.stdout.readlines():\n        line = line.decode()\n\n        if line.startswith('    '):\n            yield line.strip().split(' ')[0]\n\n\nif which('gem'):\n    _get_all_commands = cache(which('gem'))(_get_all_commands)\n\n\ndef get_new_command(command):\n    unknown_command = _get_unknown_command(command)\n    all_commands = _get_all_commands()\n    return replace_command(command, unknown_command, all_commands)\n", "thefuck/rules/cat_dir.py": "import os\nfrom thefuck.utils import for_app\n\n\n@for_app('cat', at_least=1)\ndef match(command):\n    return (\n        command.output.startswith('cat: ') and\n        os.path.isdir(command.script_parts[1])\n    )\n\n\ndef get_new_command(command):\n    return command.script.replace('cat', 'ls', 1)\n", "thefuck/rules/ssh_known_hosts.py": "import re\nfrom thefuck.utils import for_app\n\ncommands = ('ssh', 'scp')\n\n\n@for_app(*commands)\ndef match(command):\n    if not command.script:\n        return False\n    if not command.script.startswith(commands):\n        return False\n\n    patterns = (\n        r'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!',\n        r'WARNING: POSSIBLE DNS SPOOFING DETECTED!',\n        r\"Warning: the \\S+ host key for '([^']+)' differs from the key for the IP address '([^']+)'\",\n    )\n\n    return any(re.findall(pattern, command.output) for pattern in patterns)\n\n\ndef get_new_command(command):\n    return command.script\n\n\ndef side_effect(old_cmd, command):\n    offending_pattern = re.compile(\n        r'(?:Offending (?:key for IP|\\S+ key)|Matching host key) in ([^:]+):(\\d+)',\n        re.MULTILINE)\n    offending = offending_pattern.findall(old_cmd.output)\n    for filepath, lineno in offending:\n        with open(filepath, 'r') as fh:\n            lines = fh.readlines()\n            del lines[int(lineno) - 1]\n        with open(filepath, 'w') as fh:\n            fh.writelines(lines)\n", "thefuck/rules/brew_link.py": "from thefuck.utils import for_app\n\n\n@for_app('brew', at_least=2)\ndef match(command):\n    return (command.script_parts[1] in ['ln', 'link']\n            and \"brew link --overwrite --dry-run\" in command.output)\n\n\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n    command_parts[1] = 'link'\n    command_parts.insert(2, '--overwrite')\n    command_parts.insert(3, '--dry-run')\n    return ' '.join(command_parts)\n", "thefuck/rules/git_rebase_merge_dir.py": "from thefuck.utils import get_close_matches\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (' rebase' in command.script and\n            'It seems that there is already a rebase-merge directory' in command.output and\n            'I wonder if you are in the middle of another rebase' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    command_list = ['git rebase --continue', 'git rebase --abort', 'git rebase --skip']\n    rm_cmd = command.output.split('\\n')[-4]\n    command_list.append(rm_cmd.strip())\n    return get_close_matches(command.script, command_list, 4, 0)\n", "thefuck/rules/git_add_force.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('add' in command.script_parts\n            and 'Use -f if you really want to add them.' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'add', 'add --force')\n", "thefuck/rules/unsudo.py": "patterns = ['you cannot perform this operation as root']\n\n\ndef match(command):\n    if command.script_parts and command.script_parts[0] != 'sudo':\n        return False\n\n    for pattern in patterns:\n        if pattern in command.output.lower():\n            return True\n    return False\n\n\ndef get_new_command(command):\n    return ' '.join(command.script_parts[1:])\n", "thefuck/rules/omnienv_no_such_command.py": "import re\nfrom thefuck.utils import (cache, for_app, replace_argument, replace_command,\n                           which)\nfrom subprocess import PIPE, Popen\n\n\nsupported_apps = 'goenv', 'nodenv', 'pyenv', 'rbenv'\nenabled_by_default = any(which(a) for a in supported_apps)\n\n\nCOMMON_TYPOS = {\n    'list': ['versions', 'install --list'],\n    'remove': ['uninstall'],\n}\n\n\n@for_app(*supported_apps, at_least=1)\ndef match(command):\n    return 'env: no such command ' in command.output\n\n\ndef get_app_commands(app):\n    proc = Popen([app, 'commands'], stdout=PIPE)\n    return [line.decode('utf-8').strip() for line in proc.stdout.readlines()]\n\n\ndef get_new_command(command):\n    broken = re.findall(r\"env: no such command ['`]([^']*)'\", command.output)[0]\n    matched = [replace_argument(command.script, broken, common_typo)\n               for common_typo in COMMON_TYPOS.get(broken, [])]\n\n    app = command.script_parts[0]\n    app_commands = cache(which(app))(get_app_commands)(app)\n    matched.extend(replace_command(command, broken, app_commands))\n    return matched\n", "thefuck/rules/git_lfs_mistype.py": "import re\nfrom thefuck.utils import get_all_matched_commands, replace_command\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    '''\n    Match a mistyped command\n    '''\n    return 'lfs' in command.script and 'Did you mean this?' in command.output\n\n\n@git_support\ndef get_new_command(command):\n    broken_cmd = re.findall(r'Error: unknown command \"([^\"]*)\" for \"git-lfs\"', command.output)[0]\n    matched = get_all_matched_commands(command.output, ['Did you mean', ' for usage.'])\n    return replace_command(command, broken_cmd, matched)\n", "thefuck/rules/fab_command_not_found.py": "from thefuck.utils import eager, get_closest, for_app\n\n\n@for_app('fab')\ndef match(command):\n    return 'Warning: Command(s) not found:' in command.output\n\n\n# We need different behavior then in get_all_matched_commands.\n@eager\ndef _get_between(content, start, end=None):\n    should_yield = False\n    for line in content.split('\\n'):\n        if start in line:\n            should_yield = True\n            continue\n\n        if end and end in line:\n            return\n\n        if should_yield and line:\n            yield line.strip().split(' ')[0]\n\n\ndef get_new_command(command):\n    not_found_commands = _get_between(\n        command.output, 'Warning: Command(s) not found:',\n        'Available commands:')\n    possible_commands = _get_between(\n        command.output, 'Available commands:')\n\n    script = command.script\n    for not_found in not_found_commands:\n        fix = get_closest(not_found, possible_commands)\n        script = script.replace(' {}'.format(not_found),\n                                ' {}'.format(fix))\n\n    return script\n", "thefuck/rules/git_clone_git_clone.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (' git clone ' in command.script\n            and 'fatal: Too many arguments.' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return command.script.replace(' git clone ', ' ', 1)\n", "thefuck/rules/dirty_untar.py": "import tarfile\nimport os\nfrom thefuck.utils import for_app\nfrom thefuck.shells import shell\n\n\ntar_extensions = ('.tar', '.tar.Z', '.tar.bz2', '.tar.gz', '.tar.lz',\n                  '.tar.lzma', '.tar.xz', '.taz', '.tb2', '.tbz', '.tbz2',\n                  '.tgz', '.tlz', '.txz', '.tz')\n\n\ndef _is_tar_extract(cmd):\n    if '--extract' in cmd:\n        return True\n\n    cmd = cmd.split()\n\n    return len(cmd) > 1 and 'x' in cmd[1]\n\n\ndef _tar_file(cmd):\n    for c in cmd:\n        for ext in tar_extensions:\n            if c.endswith(ext):\n                return (c, c[0:len(c) - len(ext)])\n\n\n@for_app('tar')\ndef match(command):\n    return ('-C' not in command.script\n            and _is_tar_extract(command.script)\n            and _tar_file(command.script_parts) is not None)\n\n\ndef get_new_command(command):\n    dir = shell.quote(_tar_file(command.script_parts)[1])\n    return shell.and_('mkdir -p {dir}', '{cmd} -C {dir}') \\\n        .format(dir=dir, cmd=command.script)\n\n\ndef side_effect(old_cmd, command):\n    with tarfile.TarFile(_tar_file(old_cmd.script_parts)[0]) as archive:\n        for file in archive.getnames():\n            if not os.path.abspath(file).startswith(os.getcwd()):\n                # it's unsafe to overwrite files outside of the current directory\n                continue\n\n            try:\n                os.remove(file)\n            except OSError:\n                # does not try to remove directories as we cannot know if they\n                # already existed before\n                pass\n", "thefuck/rules/cargo.py": "def match(command):\n    return command.script == 'cargo'\n\n\ndef get_new_command(command):\n    return 'cargo build'\n", "thefuck/rules/nixos_cmd_not_found.py": "import re\nfrom thefuck.specific.nix import nix_available\nfrom thefuck.shells import shell\n\nregex = re.compile(r'nix-env -iA ([^\\s]*)')\nenabled_by_default = nix_available\n\n\ndef match(command):\n    return regex.findall(command.output)\n\n\ndef get_new_command(command):\n    name = regex.findall(command.output)[0]\n    return shell.and_('nix-env -iA {}'.format(name), command.script)\n", "thefuck/rules/django_south_merge.py": "def match(command):\n    return 'manage.py' in command.script and \\\n           'migrate' in command.script \\\n           and '--merge: will just attempt the migration' in command.output\n\n\ndef get_new_command(command):\n    return u'{} --merge'.format(command.script)\n", "thefuck/rules/gradle_wrapper.py": "import os\nfrom thefuck.utils import for_app, which\n\n\n@for_app('gradle')\ndef match(command):\n    return (not which(command.script_parts[0])\n            and 'not found' in command.output\n            and os.path.isfile('gradlew'))\n\n\ndef get_new_command(command):\n    return u'./gradlew {}'.format(' '.join(command.script_parts[1:]))\n", "thefuck/rules/tmux.py": "import re\nfrom thefuck.utils import replace_command, for_app\n\n\n@for_app('tmux')\ndef match(command):\n    return ('ambiguous command:' in command.output\n            and 'could be:' in command.output)\n\n\ndef get_new_command(command):\n    cmd = re.match(r\"ambiguous command: (.*), could be: (.*)\",\n                   command.output)\n\n    old_cmd = cmd.group(1)\n    suggestions = [c.strip() for c in cmd.group(2).split(',')]\n\n    return replace_command(command, old_cmd, suggestions)\n", "thefuck/rules/git_remote_seturl_add.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('set-url' in command.script\n            and 'fatal: No such remote' in command.output)\n\n\ndef get_new_command(command):\n    return replace_argument(command.script, 'set-url', 'add')\n", "thefuck/rules/fix_file.py": "import re\nimport os\nfrom thefuck.utils import memoize, default_settings\nfrom thefuck.conf import settings\nfrom thefuck.shells import shell\n\n\n# order is important: only the first match is considered\npatterns = (\n    # js, node:\n    '^    at {file}:{line}:{col}',\n    # cargo:\n    '^   {file}:{line}:{col}',\n    # python, thefuck:\n    '^  File \"{file}\", line {line}',\n    # awk:\n    '^awk: {file}:{line}:',\n    # git\n    '^fatal: bad config file line {line} in {file}',\n    # llc:\n    '^llc: {file}:{line}:{col}:',\n    # lua:\n    '^lua: {file}:{line}:',\n    # fish:\n    '^{file} \\\\(line {line}\\\\):',\n    # bash, sh, ssh:\n    '^{file}: line {line}: ',\n    # cargo, clang, gcc, go, pep8, rustc:\n    '^{file}:{line}:{col}',\n    # ghc, make, ruby, zsh:\n    '^{file}:{line}:',\n    # perl:\n    'at {file} line {line}',\n)\n\n\n# for the sake of readability do not use named groups above\ndef _make_pattern(pattern):\n    pattern = pattern.replace('{file}', '(?P<file>[^:\\n]+)') \\\n                     .replace('{line}', '(?P<line>[0-9]+)') \\\n                     .replace('{col}', '(?P<col>[0-9]+)')\n    return re.compile(pattern, re.MULTILINE)\n\n\npatterns = [_make_pattern(p).search for p in patterns]\n\n\n@memoize\ndef _search(output):\n    for pattern in patterns:\n        m = pattern(output)\n        if m and os.path.isfile(m.group('file')):\n            return m\n\n\ndef match(command):\n    if 'EDITOR' not in os.environ:\n        return False\n\n    return _search(command.output)\n\n\n@default_settings({'fixlinecmd': u'{editor} {file} +{line}',\n                   'fixcolcmd': None})\ndef get_new_command(command):\n    m = _search(command.output)\n\n    # Note: there does not seem to be a standard for columns, so they are just\n    # ignored by default\n    if settings.fixcolcmd and 'col' in m.groupdict():\n        editor_call = settings.fixcolcmd.format(editor=os.environ['EDITOR'],\n                                                file=m.group('file'),\n                                                line=m.group('line'),\n                                                col=m.group('col'))\n    else:\n        editor_call = settings.fixlinecmd.format(editor=os.environ['EDITOR'],\n                                                 file=m.group('file'),\n                                                 line=m.group('line'))\n\n    return shell.and_(editor_call, command.script)\n", "thefuck/rules/gulp_not_task.py": "import re\nimport subprocess\nfrom thefuck.utils import replace_command, for_app, cache\n\n\n@for_app('gulp')\ndef match(command):\n    return 'is not in your gulpfile' in command.output\n\n\n@cache('gulpfile.js')\ndef get_gulp_tasks():\n    proc = subprocess.Popen(['gulp', '--tasks-simple'],\n                            stdout=subprocess.PIPE)\n    return [line.decode('utf-8')[:-1]\n            for line in proc.stdout.readlines()]\n\n\ndef get_new_command(command):\n    wrong_task = re.findall(r\"Task '(\\w+)' is not in your gulpfile\",\n                            command.output)[0]\n    return replace_command(command, wrong_task, get_gulp_tasks())\n", "thefuck/rules/python_command.py": "from thefuck.specific.sudo import sudo_support\n# add 'python' suffix to the command if\n#  1) The script does not have execute permission or\n#  2) is interpreted as shell script\n\n\n@sudo_support\ndef match(command):\n    return (command.script_parts\n            and command.script_parts[0].endswith('.py')\n            and ('Permission denied' in command.output or\n                 'command not found' in command.output))\n\n\n@sudo_support\ndef get_new_command(command):\n    return 'python ' + command.script\n", "thefuck/rules/cpp11.py": "from thefuck.utils import for_app\n\n\n@for_app('g++', 'clang++')\ndef match(command):\n    return ('This file requires compiler and library support for the '\n            'ISO C++ 2011 standard.' in command.output or\n            '-Wc++11-extensions' in command.output)\n\n\ndef get_new_command(command):\n    return command.script + ' -std=c++11'\n", "thefuck/rules/git_diff_no_index.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    files = [arg for arg in command.script_parts[2:]\n             if not arg.startswith('-')]\n    return ('diff' in command.script\n            and '--no-index' not in command.script\n            and len(files) == 2)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'diff', 'diff --no-index')\n", "thefuck/rules/dnf_no_such_command.py": "import subprocess\nimport re\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app, replace_command\nfrom thefuck.specific.dnf import dnf_available\n\n\nregex = re.compile(r'No such command: (.*)\\.')\n\n\n@sudo_support\n@for_app('dnf')\ndef match(command):\n    return 'no such command' in command.output.lower()\n\n\ndef _parse_operations(help_text_lines):\n    operation_regex = re.compile(r'^([a-z-]+) +', re.MULTILINE)\n    return operation_regex.findall(help_text_lines)\n\n\ndef _get_operations():\n    proc = subprocess.Popen([\"dnf\", '--help'],\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE)\n    lines = proc.stdout.read().decode(\"utf-8\")\n\n    return _parse_operations(lines)\n\n\n@sudo_support\ndef get_new_command(command):\n    misspelled_command = regex.findall(command.output)[0]\n    return replace_command(command, misspelled_command, _get_operations())\n\n\nenabled_by_default = dnf_available\n", "thefuck/rules/heroku_not_command.py": "import re\nfrom thefuck.utils import for_app\n\n\n@for_app('heroku')\ndef match(command):\n    return 'Run heroku _ to run' in command.output\n\n\ndef get_new_command(command):\n    return re.findall('Run heroku _ to run ([^.]*)', command.output)[0]\n", "thefuck/rules/php_s.py": "from thefuck.utils import replace_argument, for_app\n\n\n@for_app('php', at_least=2)\ndef match(command):\n    return ('-s' in command.script_parts\n            and command.script_parts[-1] != '-s')\n\n\ndef get_new_command(command):\n    return replace_argument(command.script, \"-s\", \"-S\")\n", "thefuck/rules/tsuru_login.py": "from thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app('tsuru')\ndef match(command):\n    return ('not authenticated' in command.output\n            and 'session has expired' in command.output)\n\n\ndef get_new_command(command):\n    return shell.and_('tsuru login', command.script)\n", "thefuck/rules/git_pull_clone.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('fatal: Not a git repository' in command.output\n            and \"Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\" in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'pull', 'clone')\n", "thefuck/rules/grunt_task_not_found.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import for_app, eager, get_closest, cache\n\nregex = re.compile(r'Warning: Task \"(.*)\" not found.')\n\n\n@for_app('grunt')\ndef match(command):\n    return regex.findall(command.output)\n\n\n@cache('Gruntfile.js')\n@eager\ndef _get_all_tasks():\n    proc = Popen(['grunt', '--help'], stdout=PIPE)\n    should_yield = False\n    for line in proc.stdout.readlines():\n        line = line.decode().strip()\n\n        if 'Available tasks' in line:\n            should_yield = True\n            continue\n\n        if should_yield and not line:\n            return\n\n        if '  ' in line:\n            yield line.split(' ')[0]\n\n\ndef get_new_command(command):\n    misspelled_task = regex.findall(command.output)[0].split(':')[0]\n    tasks = _get_all_tasks()\n    fixed = get_closest(misspelled_task, tasks)\n    return command.script.replace(' {}'.format(misspelled_task),\n                                  ' {}'.format(fixed))\n", "thefuck/rules/choco_install.py": "from thefuck.utils import for_app, which\n\n\n@for_app(\"choco\", \"cinst\")\ndef match(command):\n    return ((command.script.startswith('choco install') or 'cinst' in command.script_parts)\n            and 'Installing the following packages' in command.output)\n\n\ndef get_new_command(command):\n    # Find the argument that is the package name\n    for script_part in command.script_parts:\n        if (\n            script_part not in [\"choco\", \"cinst\", \"install\"]\n            # Need exact match (bc chocolatey is a package)\n            and not script_part.startswith('-')\n            # Leading hyphens are parameters; some packages contain them though\n            and '=' not in script_part and '/' not in script_part\n            # These are certainly parameters\n        ):\n            return command.script.replace(script_part, script_part + \".install\")\n    return []\n\n\nenabled_by_default = bool(which(\"choco\")) or bool(which(\"cinst\"))\n", "thefuck/rules/ln_no_hard_link.py": "# -*- coding: utf-8 -*-\n\"\"\"Suggest creating symbolic link if hard link is not allowed.\n\nExample:\n> ln barDir barLink\nln: \u2018barDir\u2019: hard link not allowed for directory\n\n--> ln -s barDir barLink\n\"\"\"\n\nimport re\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return (command.output.endswith(\"hard link not allowed for directory\") and\n            command.script_parts[0] == 'ln')\n\n\n@sudo_support\ndef get_new_command(command):\n    return re.sub(r'^ln ', 'ln -s ', command.script)\n", "thefuck/rules/git_flag_after_filename.py": "import re\nfrom thefuck.specific.git import git_support\n\nerror_pattern = \"fatal: bad flag '(.*?)' used after filename\"\nerror_pattern2 = \"fatal: option '(.*?)' must come before non-option arguments\"\n\n\n@git_support\ndef match(command):\n    return re.search(error_pattern, command.output) or re.search(error_pattern2, command.output)\n\n\n@git_support\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n\n    # find the bad flag\n    bad_flag = match(command).group(1)\n    bad_flag_index = command_parts.index(bad_flag)\n\n    # find the filename\n    for index in reversed(range(bad_flag_index)):\n        if command_parts[index][0] != '-':\n            filename_index = index\n            break\n\n    # swap them\n    command_parts[bad_flag_index], command_parts[filename_index] = \\\n    command_parts[filename_index], command_parts[bad_flag_index]  # noqa: E122\n\n    return u' '.join(command_parts)\n", "thefuck/rules/cd_parent.py": "# Adds the missing space between the cd command and the target directory\n# when trying to cd to the parent directory.\n#\n# Does not really save chars, but is fun :D\n#\n# Example:\n# > cd..\n# cd..: command not found\n\n\ndef match(command):\n    return command.script == 'cd..'\n\n\ndef get_new_command(command):\n    return 'cd ..'\n", "thefuck/rules/open.py": "# Opens URL's in the default web browser\n#\n# Example:\n# > open github.com\n# The file ~/github.com does not exist.\n# Perhaps you meant 'http://github.com'?\n#\nfrom thefuck.shells import shell\nfrom thefuck.utils import eager, for_app\n\n\ndef is_arg_url(command):\n    return ('.com' in command.script or\n            '.edu' in command.script or\n            '.info' in command.script or\n            '.io' in command.script or\n            '.ly' in command.script or\n            '.me' in command.script or\n            '.net' in command.script or\n            '.org' in command.script or\n            '.se' in command.script or\n            'www.' in command.script)\n\n\n@for_app('open', 'xdg-open', 'gnome-open', 'kde-open')\ndef match(command):\n    return (is_arg_url(command) or\n            command.output.strip().startswith('The file ') and\n            command.output.strip().endswith(' does not exist.'))\n\n\n@eager\ndef get_new_command(command):\n    output = command.output.strip()\n    if is_arg_url(command):\n        yield command.script.replace('open ', 'open http://')\n    elif output.startswith('The file ') and output.endswith(' does not exist.'):\n        arg = command.script.split(' ', 1)[1]\n        for option in ['touch', 'mkdir']:\n            yield shell.and_(u'{} {}'.format(option, arg), command.script)\n", "thefuck/rules/apt_get_search.py": "import re\nfrom thefuck.specific.apt import apt_available\nfrom thefuck.utils import for_app\n\nenabled_by_default = apt_available\n\n\n@for_app('apt-get')\ndef match(command):\n    return command.script.startswith('apt-get search')\n\n\ndef get_new_command(command):\n    return re.sub(r'^apt-get', 'apt-cache', command.script)\n", "thefuck/rules/az_cli.py": "import re\n\nfrom thefuck.utils import for_app, replace_argument\n\nINVALID_CHOICE = \"(?=az)(?:.*): '(.*)' is not in the '.*' command group.\"\nOPTIONS = \"^The most similar choice to '.*' is:\\n\\\\s*(.*)$\"\n\n\n@for_app('az')\ndef match(command):\n    return \"is not in the\" in command.output and \"command group\" in command.output\n\n\ndef get_new_command(command):\n    mistake = re.search(INVALID_CHOICE, command.output).group(1)\n    options = re.findall(OPTIONS, command.output, flags=re.MULTILINE)\n    return [replace_argument(command.script, mistake, o) for o in options]\n", "thefuck/rules/git_branch_delete_checked_out.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\nfrom thefuck.utils import replace_argument\n\n\n@git_support\ndef match(command):\n    return (\n        (\"branch -d\" in command.script or \"branch -D\" in command.script)\n        and \"error: Cannot delete branch '\" in command.output\n        and \"' checked out at '\" in command.output\n    )\n\n\n@git_support\ndef get_new_command(command):\n    return shell.and_(\"git checkout master\", \"{}\").format(\n        replace_argument(command.script, \"-d\", \"-D\")\n    )\n", "thefuck/rules/brew_install.py": "import re\nfrom thefuck.utils import for_app\nfrom thefuck.specific.brew import brew_available\n\nenabled_by_default = brew_available\n\n\ndef _get_suggestions(str):\n    suggestions = str.replace(\" or \", \", \").split(\", \")\n    return suggestions\n\n\n@for_app('brew', at_least=2)\ndef match(command):\n    is_proper_command = ('install' in command.script and\n                         'No available formula' in command.output and\n                         'Did you mean' in command.output)\n    return is_proper_command\n\n\ndef get_new_command(command):\n    matcher = re.search('Warning: No available formula with the name \"(?:[^\"]+)\". Did you mean (.+)\\\\?', command.output)\n    suggestions = _get_suggestions(matcher.group(1))\n    return [\"brew install \" + formula for formula in suggestions]\n", "thefuck/rules/go_unknown_command.py": "from itertools import dropwhile, islice, takewhile\nimport subprocess\n\nfrom thefuck.utils import get_closest, replace_argument, for_app, which, cache\n\n\ndef get_golang_commands():\n    proc = subprocess.Popen('go', stderr=subprocess.PIPE)\n    lines = [line.decode('utf-8').strip() for line in proc.stderr.readlines()]\n    lines = dropwhile(lambda line: line != 'The commands are:', lines)\n    lines = islice(lines, 2, None)\n    lines = takewhile(lambda line: line, lines)\n    return [line.split(' ')[0] for line in lines]\n\n\nif which('go'):\n    get_golang_commands = cache(which('go'))(get_golang_commands)\n\n\n@for_app('go')\ndef match(command):\n    return 'unknown command' in command.output\n\n\ndef get_new_command(command):\n    closest_subcommand = get_closest(command.script_parts[1], get_golang_commands())\n    return replace_argument(command.script, command.script_parts[1],\n                            closest_subcommand)\n", "thefuck/rules/git_commit_reset.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('commit' in command.script_parts)\n\n\n@git_support\ndef get_new_command(command):\n    return 'git reset HEAD~'\n", "thefuck/rules/conda_mistype.py": "import re\nfrom thefuck.utils import replace_command, for_app\n\n\n@for_app(\"conda\")\ndef match(command):\n    \"\"\"\n    Match a mistyped command\n    \"\"\"\n    return \"Did you mean 'conda\" in command.output\n\n\ndef get_new_command(command):\n    match = re.findall(r\"'conda ([^']*)'\", command.output)\n    broken_cmd = match[0]\n    correct_cmd = match[1]\n    return replace_command(command, broken_cmd, [correct_cmd])\n", "thefuck/rules/hostscli.py": "import re\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import replace_command, for_app\n\nno_command = \"Error: No such command\"\nno_website = \"hostscli.errors.WebsiteImportError\"\n\n\n@sudo_support\n@for_app('hostscli')\ndef match(command):\n    errors = [no_command, no_website]\n    for error in errors:\n        if error in command.output:\n            return True\n    return False\n\n\n@sudo_support\ndef get_new_command(command):\n    if no_website in command.output:\n        return ['hostscli websites']\n\n    misspelled_command = re.findall(\n        r'Error: No such command \".*\"', command.output)[0]\n    commands = ['block', 'unblock', 'websites', 'block_all', 'unblock_all']\n    return replace_command(command, misspelled_command, commands)\n", "thefuck/rules/python_execute.py": "# Appends .py when executing python files\n#\n# Example:\n# > python foo\n# error: python: can't open file 'foo': [Errno 2] No such file or directory\nfrom thefuck.utils import for_app\n\n\n@for_app('python')\ndef match(command):\n    return not command.script.endswith('.py')\n\n\ndef get_new_command(command):\n    return command.script + '.py'\n", "thefuck/rules/mercurial.py": "import re\nfrom thefuck.utils import get_closest, for_app\n\n\ndef extract_possibilities(command):\n    possib = re.findall(r'\\n\\(did you mean one of ([^\\?]+)\\?\\)', command.output)\n    if possib:\n        return possib[0].split(', ')\n    possib = re.findall(r'\\n    ([^$]+)$', command.output)\n    if possib:\n        return possib[0].split(' ')\n    return possib\n\n\n@for_app('hg')\ndef match(command):\n    return ('hg: unknown command' in command.output\n            and '(did you mean one of ' in command.output\n            or \"hg: command '\" in command.output\n            and \"' is ambiguous:\" in command.output)\n\n\ndef get_new_command(command):\n    script = command.script_parts[:]\n    possibilities = extract_possibilities(command)\n    script[1] = get_closest(script[1], possibilities)\n    return ' '.join(script)\n", "thefuck/rules/prove_recursively.py": "import os\nfrom thefuck.utils import for_app\n\n\ndef _is_recursive(part):\n    if part == '--recurse':\n        return True\n    elif not part.startswith('--') and part.startswith('-') and 'r' in part:\n        return True\n\n\ndef _isdir(part):\n    return not part.startswith('-') and os.path.isdir(part)\n\n\n@for_app('prove')\ndef match(command):\n    return (\n        'NOTESTS' in command.output\n        and not any(_is_recursive(part) for part in command.script_parts[1:])\n        and any(_isdir(part) for part in command.script_parts[1:]))\n\n\ndef get_new_command(command):\n    parts = command.script_parts[:]\n    parts.insert(1, '-r')\n    return u' '.join(parts)\n", "thefuck/rules/tsuru_not_command.py": "import re\nfrom thefuck.utils import get_all_matched_commands, replace_command, for_app\n\n\n@for_app('tsuru')\ndef match(command):\n    return (' is not a tsuru command. See \"tsuru help\".' in command.output\n            and '\\nDid you mean?\\n\\t' in command.output)\n\n\ndef get_new_command(command):\n    broken_cmd = re.findall(r'tsuru: \"([^\"]*)\" is not a tsuru command',\n                            command.output)[0]\n    return replace_command(command, broken_cmd,\n                           get_all_matched_commands(command.output))\n", "thefuck/rules/lein_not_task.py": "import re\nfrom thefuck.utils import replace_command, get_all_matched_commands, for_app\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\n@for_app('lein')\ndef match(command):\n    return (command.script.startswith('lein')\n            and \"is not a task. See 'lein help'\" in command.output\n            and 'Did you mean this?' in command.output)\n\n\n@sudo_support\ndef get_new_command(command):\n    broken_cmd = re.findall(r\"'([^']*)' is not a task\",\n                            command.output)[0]\n    new_cmds = get_all_matched_commands(command.output, 'Did you mean this?')\n    return replace_command(command, broken_cmd, new_cmds)\n", "thefuck/rules/git_branch_exists.py": "import re\nfrom thefuck.shells import shell\nfrom thefuck.specific.git import git_support\nfrom thefuck.utils import eager\n\n\n@git_support\ndef match(command):\n    return (\"fatal: A branch named '\" in command.output\n            and \"' already exists.\" in command.output)\n\n\n@git_support\n@eager\ndef get_new_command(command):\n    branch_name = re.findall(\n        r\"fatal: A branch named '(.+)' already exists.\", command.output)[0]\n    branch_name = branch_name.replace(\"'\", r\"\\'\")\n    new_command_templates = [['git branch -d {0}', 'git branch {0}'],\n                             ['git branch -d {0}', 'git checkout -b {0}'],\n                             ['git branch -D {0}', 'git branch {0}'],\n                             ['git branch -D {0}', 'git checkout -b {0}'],\n                             ['git checkout {0}']]\n    for new_command_template in new_command_templates:\n        yield shell.and_(*new_command_template).format(branch_name)\n", "thefuck/rules/git_rebase_no_changes.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (\n        {'rebase', '--continue'}.issubset(command.script_parts) and\n        'No changes - did you forget to use \\'git add\\'?' in command.output\n    )\n\n\ndef get_new_command(command):\n    return 'git rebase --skip'\n", "thefuck/rules/git_main_master.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return \"'master'\" in command.output or \"'main'\" in command.output\n\n\n@git_support\ndef get_new_command(command):\n    if \"'master'\" in command.output:\n        return command.script.replace(\"master\", \"main\")\n    return command.script.replace(\"main\", \"master\")\n\n\npriority = 1200\n", "thefuck/rules/django_south_ghost.py": "def match(command):\n    return 'manage.py' in command.script and \\\n           'migrate' in command.script \\\n           and 'or pass --delete-ghost-migrations' in command.output\n\n\ndef get_new_command(command):\n    return u'{} --delete-ghost-migrations'.format(command.script)\n", "thefuck/rules/git_branch_delete.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('branch -d' in command.script\n            and 'If you are sure you want to delete it' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, '-d', '-D')\n", "thefuck/rules/git_checkout.py": "import re\nimport subprocess\nfrom thefuck import utils\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\nfrom thefuck.shells import shell\n\n\n@git_support\ndef match(command):\n    return ('did not match any file(s) known to git' in command.output\n            and \"Did you forget to 'git add'?\" not in command.output)\n\n\ndef get_branches():\n    proc = subprocess.Popen(\n        ['git', 'branch', '-a', '--no-color', '--no-column'],\n        stdout=subprocess.PIPE)\n    for line in proc.stdout.readlines():\n        line = line.decode('utf-8')\n        if '->' in line:    # Remote HEAD like b'  remotes/origin/HEAD -> origin/master'\n            continue\n        if line.startswith('*'):\n            line = line.split(' ')[1]\n        if line.strip().startswith('remotes/'):\n            line = '/'.join(line.split('/')[2:])\n        yield line.strip()\n\n\n@git_support\ndef get_new_command(command):\n    missing_file = re.findall(\n        r\"error: pathspec '([^']*)' \"\n        r\"did not match any file\\(s\\) known to git\", command.output)[0]\n    closest_branch = utils.get_closest(missing_file, get_branches(),\n                                       fallback_to_first=False)\n\n    new_commands = []\n\n    if closest_branch:\n        new_commands.append(replace_argument(command.script, missing_file, closest_branch))\n    if command.script_parts[1] == 'checkout':\n        new_commands.append(replace_argument(command.script, 'checkout', 'checkout -b'))\n\n    if not new_commands:\n        new_commands.append(shell.and_('git branch {}', '{}').format(\n            missing_file, command.script))\n\n    return new_commands\n", "thefuck/rules/git_help_aliased.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return 'help' in command.script and ' is aliased to ' in command.output\n\n\n@git_support\ndef get_new_command(command):\n    aliased = command.output.split('`', 2)[2].split(\"'\", 1)[0].split(' ', 1)[0]\n    return 'git help {}'.format(aliased)\n", "thefuck/rules/remove_trailing_cedilla.py": "# -*- encoding: utf-8 -*-\n\nCEDILLA = u\"\u00e7\"\n\n\ndef match(command):\n    return command.script.endswith(CEDILLA)\n\n\ndef get_new_command(command):\n    return command.script[:-1]\n", "thefuck/rules/path_from_history.py": "from collections import Counter\nimport re\nfrom thefuck.system import Path\nfrom thefuck.utils import (get_valid_history_without_current,\n                           memoize, replace_argument)\nfrom thefuck.shells import shell\n\n\npatterns = [r'no such file or directory: (.*)$',\n            r\"cannot access '(.*)': No such file or directory\",\n            r': (.*): No such file or directory',\n            r\"can't cd to (.*)$\"]\n\n\n@memoize\ndef _get_destination(command):\n    for pattern in patterns:\n        found = re.findall(pattern, command.output)\n        if found:\n            if found[0] in command.script_parts:\n                return found[0]\n\n\ndef match(command):\n    return bool(_get_destination(command))\n\n\ndef _get_all_absolute_paths_from_history(command):\n    counter = Counter()\n\n    for line in get_valid_history_without_current(command):\n        splitted = shell.split_command(line)\n\n        for param in splitted[1:]:\n            if param.startswith('/') or param.startswith('~'):\n                if param.endswith('/'):\n                    param = param[:-1]\n\n                counter[param] += 1\n\n    return (path for path, _ in counter.most_common(None))\n\n\ndef get_new_command(command):\n    destination = _get_destination(command)\n    paths = _get_all_absolute_paths_from_history(command)\n\n    return [replace_argument(command.script, destination, path)\n            for path in paths if path.endswith(destination)\n            and Path(path).expanduser().exists()]\n\n\npriority = 800\n", "thefuck/rules/java.py": "\"\"\"Fixes common java command mistake\n\nExample:\n> java foo.java\nError: Could not find or load main class foo.java\n\n\"\"\"\nfrom thefuck.utils import for_app\n\n\n@for_app('java')\ndef match(command):\n    return command.script.endswith('.java')\n\n\ndef get_new_command(command):\n    return command.script[:-5]\n", "thefuck/rules/git_push_pull.py": "from thefuck.shells import shell\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('push' in command.script and\n            '! [rejected]' in command.output and\n            'failed to push some refs to' in command.output and\n            ('Updates were rejected because the tip of your'\n             ' current branch is behind' in command.output or\n             'Updates were rejected because the remote '\n             'contains work that you do' in command.output))\n\n\n@git_support\ndef get_new_command(command):\n    return shell.and_(replace_argument(command.script, 'push', 'pull'),\n                      command.script)\n", "thefuck/rules/cp_omitting_directory.py": "import re\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app\n\n\n@sudo_support\n@for_app('cp')\ndef match(command):\n    output = command.output.lower()\n    return 'omitting directory' in output or 'is a directory' in output\n\n\n@sudo_support\ndef get_new_command(command):\n    return re.sub(r'^cp', 'cp -a', command.script)\n", "thefuck/rules/brew_update_formula.py": "from thefuck.utils import for_app\n\n\n@for_app('brew', at_least=2)\ndef match(command):\n    return ('update' in command.script\n            and \"Error: This command updates brew itself\" in command.output\n            and \"Use `brew upgrade\" in command.output)\n\n\ndef get_new_command(command):\n    return command.script.replace('update', 'upgrade')\n", "thefuck/rules/yarn_command_replaced.py": "import re\nfrom thefuck.utils import for_app\n\nregex = re.compile(r'Run \"(.*)\" instead')\n\n\n@for_app('yarn', at_least=1)\ndef match(command):\n    return regex.findall(command.output)\n\n\ndef get_new_command(command):\n    return regex.findall(command.output)[0]\n", "thefuck/rules/no_such_file.py": "import re\nfrom thefuck.shells import shell\n\n\npatterns = (\n    r\"mv: cannot move '[^']*' to '([^']*)': No such file or directory\",\n    r\"mv: cannot move '[^']*' to '([^']*)': Not a directory\",\n    r\"cp: cannot create regular file '([^']*)': No such file or directory\",\n    r\"cp: cannot create regular file '([^']*)': Not a directory\",\n)\n\n\ndef match(command):\n    for pattern in patterns:\n        if re.search(pattern, command.output):\n            return True\n\n    return False\n\n\ndef get_new_command(command):\n    for pattern in patterns:\n        file = re.findall(pattern, command.output)\n\n        if file:\n            file = file[0]\n            dir = file[0:file.rfind('/')]\n\n            formatme = shell.and_('mkdir -p {}', '{}')\n            return formatme.format(dir, command.script)\n", "thefuck/rules/git_two_dashes.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('error: did you mean `' in command.output\n            and '` (with two dashes ?)' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    to = command.output.split('`')[1]\n    return replace_argument(command.script, to[1:], to)\n", "thefuck/rules/git_commit_amend.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('commit' in command.script_parts)\n\n\n@git_support\ndef get_new_command(command):\n    return 'git commit --amend'\n", "thefuck/rules/git_clone_missing.py": "'''\nRule: git_clone_missing\n\nCorrect missing `git clone` command when pasting a git URL\n\n```sh\n>>> https://github.com/nvbn/thefuck.git\ngit clone https://github.com/nvbn/thefuck.git\n```\n\nAuthor: Miguel Guthridge\n'''\nfrom six.moves.urllib import parse\nfrom thefuck.utils import which\n\n\ndef match(command):\n    # We want it to be a URL by itself\n    if len(command.script_parts) != 1:\n        return False\n    # Ensure we got the error we expected\n    if which(command.script_parts[0]) or not (\n        'No such file or directory' in command.output\n        or 'not found' in command.output\n        or 'is not recognised as' in command.output\n    ):\n        return False\n    url = parse.urlparse(command.script, scheme='ssh')\n    # HTTP URLs need a network address\n    if not url.netloc and url.scheme != 'ssh':\n        return False\n    # SSH needs a username and a splitter between the path\n    if url.scheme == 'ssh' and not (\n        '@' in command.script\n        and ':' in command.script\n    ):\n        return False\n    return url.scheme in ['http', 'https', 'ssh']\n\n\ndef get_new_command(command):\n    return 'git clone ' + command.script\n", "thefuck/rules/git_rm_local_modifications.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (' rm ' in command.script and\n            'error: the following file has local modifications' in command.output and\n            'use --cached to keep the file, or -f to force removal' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n    index = command_parts.index('rm') + 1\n    command_parts.insert(index, '--cached')\n    command_list = [u' '.join(command_parts)]\n    command_parts[index] = '-f'\n    command_list.append(u' '.join(command_parts))\n    return command_list\n", "thefuck/rules/git_tag_force.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('tag' in command.script_parts\n            and 'already exists' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return replace_argument(command.script, 'tag', 'tag --force')\n", "thefuck/rules/apt_get.py": "from types import ModuleType\nfrom thefuck.specific.apt import apt_available\nfrom thefuck.utils import memoize, which\nfrom thefuck.shells import shell\n\ntry:\n    from CommandNotFound import CommandNotFound\n\n    enabled_by_default = apt_available\n\n    if isinstance(CommandNotFound, ModuleType):\n        # For ubuntu 18.04+\n        _get_packages = CommandNotFound.CommandNotFound().get_packages\n    else:\n        # For older versions\n        _get_packages = CommandNotFound().getPackages\nexcept ImportError:\n    enabled_by_default = False\n\n\ndef _get_executable(command):\n    if command.script_parts[0] == 'sudo':\n        return command.script_parts[1]\n    else:\n        return command.script_parts[0]\n\n\n@memoize\ndef get_package(executable):\n    try:\n        packages = _get_packages(executable)\n        return packages[0][0]\n    except IndexError:\n        # IndexError is thrown when no matching package is found\n        return None\n\n\ndef match(command):\n    if 'not found' in command.output or 'not installed' in command.output:\n        executable = _get_executable(command)\n        return not which(executable) and get_package(executable)\n    else:\n        return False\n\n\ndef get_new_command(command):\n    executable = _get_executable(command)\n    name = get_package(executable)\n    formatme = shell.and_('sudo apt-get install {}', '{}')\n    return formatme.format(name, command.script)\n", "thefuck/rules/git_merge_unrelated.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('merge' in command.script\n            and 'fatal: refusing to merge unrelated histories' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return command.script + ' --allow-unrelated-histories'\n", "thefuck/rules/git_branch_list.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    # catches \"git branch list\" in place of \"git branch\"\n    return (command.script_parts\n            and command.script_parts[1:] == 'branch list'.split())\n\n\n@git_support\ndef get_new_command(command):\n    return shell.and_('git branch --delete list', 'git branch')\n", "thefuck/rules/go_run.py": "from thefuck.utils import for_app\n# Appends .go when compiling go files\n#\n# Example:\n# > go run foo\n# error: go run: no go files listed\n\n\n@for_app('go')\ndef match(command):\n    return (command.script.startswith('go run ')\n            and not command.script.endswith('.go'))\n\n\ndef get_new_command(command):\n    return command.script + '.go'\n", "thefuck/rules/git_commit_add.py": "from thefuck.utils import eager, replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (\n        \"commit\" in command.script_parts\n        and \"no changes added to commit\" in command.output\n    )\n\n\n@eager\n@git_support\ndef get_new_command(command):\n    for opt in (\"-a\", \"-p\"):\n        yield replace_argument(command.script, \"commit\", \"commit {}\".format(opt))\n", "thefuck/rules/grep_recursive.py": "from thefuck.utils import for_app\n\n\n@for_app('grep')\ndef match(command):\n    return 'is a directory' in command.output.lower()\n\n\ndef get_new_command(command):\n    return u'grep -r {}'.format(command.script[5:])\n", "thefuck/rules/git_merge.py": "import re\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('merge' in command.script\n            and ' - not something we can merge' in command.output\n            and 'Did you mean this?' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    unknown_branch = re.findall(r'merge: (.+) - not something we can merge', command.output)[0]\n    remote_branch = re.findall(r'Did you mean this\\?\\n\\t([^\\n]+)', command.output)[0]\n\n    return replace_argument(command.script, unknown_branch, remote_branch)\n", "thefuck/rules/gradle_no_task.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import for_app, eager, replace_command\n\nregex = re.compile(r\"Task '(.*)' (is ambiguous|not found)\")\n\n\n@for_app('gradle', 'gradlew')\ndef match(command):\n    return regex.findall(command.output)\n\n\n@eager\ndef _get_all_tasks(gradle):\n    proc = Popen([gradle, 'tasks'], stdout=PIPE)\n    should_yield = False\n    for line in proc.stdout.readlines():\n        line = line.decode().strip()\n        if line.startswith('----'):\n            should_yield = True\n            continue\n\n        if not line.strip():\n            should_yield = False\n            continue\n\n        if should_yield and not line.startswith('All tasks runnable from root project'):\n            yield line.split(' ')[0]\n\n\ndef get_new_command(command):\n    wrong_task = regex.findall(command.output)[0][0]\n    all_tasks = _get_all_tasks(command.script_parts[0])\n    return replace_command(command, wrong_task, all_tasks)\n", "thefuck/rules/pacman.py": "from thefuck.specific.archlinux import get_pkgfile, archlinux_env\nfrom thefuck.shells import shell\n\n\ndef match(command):\n    return 'not found' in command.output and get_pkgfile(command.script)\n\n\ndef get_new_command(command):\n    packages = get_pkgfile(command.script)\n\n    formatme = shell.and_('{} -S {}', '{}')\n    return [formatme.format(pacman, package, command.script)\n            for package in packages]\n\n\nenabled_by_default, pacman = archlinux_env()\n", "thefuck/rules/quotation_marks.py": "# Fixes careless \" and ' usage\n#\n# Example:\n# > git commit -m 'My Message\"\n\n\ndef match(command):\n    return '\\'' in command.script and '\\\"' in command.script\n\n\ndef get_new_command(command):\n    return command.script.replace('\\'', '\\\"')\n", "thefuck/rules/dry.py": "def match(command):\n    split_command = command.script_parts\n\n    return (split_command\n            and len(split_command) >= 2\n            and split_command[0] == split_command[1])\n\n\ndef get_new_command(command):\n    return ' '.join(command.script_parts[1:])\n\n\n# it should be rare enough to actually have to type twice the same word, so\n# this rule can have a higher priority to come before things like \"cd cd foo\"\npriority = 900\n", "thefuck/rules/scm_correction.py": "from thefuck.utils import for_app, memoize\nfrom thefuck.system import Path\n\npath_to_scm = {\n    '.git': 'git',\n    '.hg': 'hg',\n}\n\nwrong_scm_patterns = {\n    'git': 'fatal: Not a git repository',\n    'hg': 'abort: no repository found',\n}\n\n\n@memoize\ndef _get_actual_scm():\n    for path, scm in path_to_scm.items():\n        if Path(path).is_dir():\n            return scm\n\n\n@for_app(*wrong_scm_patterns.keys())\ndef match(command):\n    scm = command.script_parts[0]\n    pattern = wrong_scm_patterns[scm]\n\n    return pattern in command.output and _get_actual_scm()\n\n\ndef get_new_command(command):\n    scm = _get_actual_scm()\n    return u' '.join([scm] + command.script_parts[1:])\n", "thefuck/rules/yarn_help.py": "import re\nfrom thefuck.utils import for_app\nfrom thefuck.system import open_command\n\n\n@for_app('yarn', at_least=2)\ndef match(command):\n    return (command.script_parts[1] == 'help'\n            and 'for documentation about this command.' in command.output)\n\n\ndef get_new_command(command):\n    url = re.findall(\n        r'Visit ([^ ]*) for documentation about this command.',\n        command.output)[0]\n\n    return open_command(url)\n", "thefuck/rules/brew_uninstall.py": "from thefuck.utils import for_app\n\n\n@for_app('brew', at_least=2)\ndef match(command):\n    return (command.script_parts[1] in ['uninstall', 'rm', 'remove']\n            and \"brew uninstall --force\" in command.output)\n\n\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n    command_parts[1] = 'uninstall'\n    command_parts.insert(2, '--force')\n    return ' '.join(command_parts)\n", "thefuck/rules/brew_unknown_command.py": "import os\nimport re\nfrom thefuck.utils import get_closest, replace_command\nfrom thefuck.specific.brew import get_brew_path_prefix, brew_available\n\nBREW_CMD_PATH = '/Homebrew/Library/Homebrew/cmd'\nTAP_PATH = '/Homebrew/Library/Taps'\nTAP_CMD_PATH = '/%s/%s/cmd'\n\nenabled_by_default = brew_available\n\n\ndef _get_brew_commands(brew_path_prefix):\n    \"\"\"To get brew default commands on local environment\"\"\"\n    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH\n\n    return [name[:-3] for name in os.listdir(brew_cmd_path)\n            if name.endswith(('.rb', '.sh'))]\n\n\ndef _get_brew_tap_specific_commands(brew_path_prefix):\n    \"\"\"To get tap's specific commands\n    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115\"\"\"\n    commands = []\n    brew_taps_path = brew_path_prefix + TAP_PATH\n\n    for user in _get_directory_names_only(brew_taps_path):\n        taps = _get_directory_names_only(brew_taps_path + '/%s' % user)\n\n        # Brew Taps's naming rule\n        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations\n        taps = (tap for tap in taps if tap.startswith('homebrew-'))\n        for tap in taps:\n            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)\n\n            if os.path.isdir(tap_cmd_path):\n                commands += (name.replace('brew-', '').replace('.rb', '')\n                             for name in os.listdir(tap_cmd_path)\n                             if _is_brew_tap_cmd_naming(name))\n\n    return commands\n\n\ndef _is_brew_tap_cmd_naming(name):\n    return name.startswith('brew-') and name.endswith('.rb')\n\n\ndef _get_directory_names_only(path):\n    return [d for d in os.listdir(path)\n            if os.path.isdir(os.path.join(path, d))]\n\n\ndef _brew_commands():\n    brew_path_prefix = get_brew_path_prefix()\n    if brew_path_prefix:\n        try:\n            return (_get_brew_commands(brew_path_prefix)\n                    + _get_brew_tap_specific_commands(brew_path_prefix))\n        except OSError:\n            pass\n\n    # Failback commands for testing (Based on Homebrew 0.9.5)\n    return ['info', 'home', 'options', 'install', 'uninstall',\n            'search', 'list', 'update', 'upgrade', 'pin', 'unpin',\n            'doctor', 'create', 'edit', 'cask']\n\n\ndef match(command):\n    is_proper_command = ('brew' in command.script and\n                         'Unknown command' in command.output)\n\n    if is_proper_command:\n        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                                command.output)[0]\n        return bool(get_closest(broken_cmd, _brew_commands()))\n    return False\n\n\ndef get_new_command(command):\n    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',\n                            command.output)[0]\n    return replace_command(command, broken_cmd, _brew_commands())\n", "thefuck/rules/git_stash_pop.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('stash' in command.script\n            and 'pop' in command.script\n            and 'Your local changes to the following files would be overwritten by merge' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    return shell.and_('git add --update', 'git stash pop', 'git reset .')\n\n\n# make it come before the other applicable rules\npriority = 900\n", "thefuck/rules/git_hook_bypass.py": "from thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\nhooked_commands = (\"am\", \"commit\", \"push\")\n\n\n@git_support\ndef match(command):\n    return any(\n        hooked_command in command.script_parts for hooked_command in hooked_commands\n    )\n\n\n@git_support\ndef get_new_command(command):\n    hooked_command = next(\n        hooked_command\n        for hooked_command in hooked_commands\n        if hooked_command in command.script_parts\n    )\n    return replace_argument(\n        command.script, hooked_command, hooked_command + \" --no-verify\"\n    )\n\n\npriority = 1100\nrequires_output = False\n", "thefuck/rules/git_branch_0flag.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\nfrom thefuck.utils import memoize\n\n\n@memoize\ndef first_0flag(script_parts):\n    return next((p for p in script_parts if len(p) == 2 and p.startswith(\"0\")), None)\n\n\n@git_support\ndef match(command):\n    return command.script_parts[1] == \"branch\" and first_0flag(command.script_parts)\n\n\n@git_support\ndef get_new_command(command):\n    branch_name = first_0flag(command.script_parts)\n    fixed_flag = branch_name.replace(\"0\", \"-\")\n    fixed_script = command.script.replace(branch_name, fixed_flag)\n    if \"A branch named '\" in command.output and \"' already exists.\" in command.output:\n        delete_branch = u\"git branch -D {}\".format(branch_name)\n        return shell.and_(delete_branch, fixed_script)\n    return fixed_script\n", "thefuck/rules/pip_unknown_command.py": "import re\nfrom thefuck.utils import replace_argument, for_app\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\n@for_app('pip', 'pip2', 'pip3')\ndef match(command):\n    return ('pip' in command.script and\n            'unknown command' in command.output and\n            'maybe you meant' in command.output)\n\n\ndef get_new_command(command):\n    broken_cmd = re.findall(r'ERROR: unknown command \"([^\"]+)\"',\n                            command.output)[0]\n    new_cmd = re.findall(r'maybe you meant \"([^\"]+)\"', command.output)[0]\n\n    return replace_argument(command.script, broken_cmd, new_cmd)\n", "thefuck/rules/fix_alt_space.py": "# -*- encoding: utf-8 -*-\n\nimport re\nfrom thefuck.specific.sudo import sudo_support\n\n\n@sudo_support\ndef match(command):\n    return ('command not found' in command.output.lower()\n            and u'\u00a0' in command.script)\n\n\n@sudo_support\ndef get_new_command(command):\n    return re.sub(u'\u00a0', ' ', command.script)\n", "thefuck/rules/apt_list_upgradable.py": "from thefuck.specific.apt import apt_available\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app\n\nenabled_by_default = apt_available\n\n\n@sudo_support\n@for_app('apt')\ndef match(command):\n    return 'apt list --upgradable' in command.output\n\n\n@sudo_support\ndef get_new_command(command):\n    return 'apt list --upgradable'\n", "thefuck/rules/sudo.py": "patterns = ['permission denied',\n            'eacces',\n            'pkg: insufficient privileges',\n            'you cannot perform this operation unless you are root',\n            'non-root users cannot',\n            'operation not permitted',\n            'not super-user',\n            'superuser privilege',\n            'root privilege',\n            'this command has to be run under the root user.',\n            'this operation requires root.',\n            'requested operation requires superuser privilege',\n            'must be run as root',\n            'must run as root',\n            'must be superuser',\n            'must be root',\n            'need to be root',\n            'need root',\n            'needs to be run as root',\n            'only root can ',\n            'you don\\'t have access to the history db.',\n            'authentication is required',\n            'edspermissionerror',\n            'you don\\'t have write permissions',\n            'use `sudo`',\n            'sudorequirederror',\n            'error: insufficient privileges',\n            'updatedb: can not open a temporary file']\n\n\ndef match(command):\n    if command.script_parts and '&&' not in command.script_parts and command.script_parts[0] == 'sudo':\n        return False\n\n    for pattern in patterns:\n        if pattern in command.output.lower():\n            return True\n    return False\n\n\ndef get_new_command(command):\n    if '&&' in command.script:\n        return u'sudo sh -c \"{}\"'.format(\" \".join([part for part in command.script_parts if part != \"sudo\"]))\n    elif '>' in command.script:\n        return u'sudo sh -c \"{}\"'.format(command.script.replace('\"', '\\\\\"'))\n    else:\n        return u'sudo {}'.format(command.script)\n", "thefuck/rules/brew_cask_dependency.py": "from thefuck.utils import for_app, eager\nfrom thefuck.shells import shell\nfrom thefuck.specific.brew import brew_available\n\n\n@for_app('brew')\ndef match(command):\n    return (u'install' in command.script_parts\n            and u'brew cask install' in command.output)\n\n\n@eager\ndef _get_cask_install_lines(output):\n    for line in output.split('\\n'):\n        line = line.strip()\n        if line.startswith('brew cask install'):\n            yield line\n\n\ndef _get_script_for_brew_cask(output):\n    cask_install_lines = _get_cask_install_lines(output)\n    if len(cask_install_lines) > 1:\n        return shell.and_(*cask_install_lines)\n    else:\n        return cask_install_lines[0]\n\n\ndef get_new_command(command):\n    brew_cask_script = _get_script_for_brew_cask(command.output)\n    return shell.and_(brew_cask_script, command.script)\n\n\nenabled_by_default = brew_available\n", "thefuck/rules/chmod_x.py": "import os\nfrom thefuck.shells import shell\n\n\ndef match(command):\n    return (command.script.startswith('./')\n            and 'permission denied' in command.output.lower()\n            and os.path.exists(command.script_parts[0])\n            and not os.access(command.script_parts[0], os.X_OK))\n\n\ndef get_new_command(command):\n    return shell.and_(\n        'chmod +x {}'.format(command.script_parts[0][2:]),\n        command.script)\n", "thefuck/rules/python_module_error.py": "import re\nfrom thefuck.shells import shell\n\nMISSING_MODULE = r\"ModuleNotFoundError: No module named '([^']+)'\"\n\n\ndef match(command):\n    return \"ModuleNotFoundError: No module named '\" in command.output\n\n\ndef get_new_command(command):\n    missing_module = re.findall(MISSING_MODULE, command.output)[0]\n    return shell.and_(\"pip install {}\".format(missing_module), command.script)\n", "thefuck/rules/ls_lah.py": "from thefuck.utils import for_app\n\n\n@for_app('ls')\ndef match(command):\n    return command.script_parts and 'ls -' not in command.script\n\n\ndef get_new_command(command):\n    command = command.script_parts[:]\n    command[0] = 'ls -lah'\n    return ' '.join(command)\n", "thefuck/rules/git_push.py": "import re\nfrom thefuck.utils import replace_argument\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('push' in command.script_parts\n            and 'git push --set-upstream' in command.output)\n\n\ndef _get_upstream_option_index(command_parts):\n    if '--set-upstream' in command_parts:\n        return command_parts.index('--set-upstream')\n    elif '-u' in command_parts:\n        return command_parts.index('-u')\n    else:\n        return None\n\n\n@git_support\ndef get_new_command(command):\n    # If --set-upstream or -u are passed, remove it and its argument. This is\n    # because the remaining arguments are concatenated onto the command suggested\n    # by git, which includes --set-upstream and its argument\n    command_parts = command.script_parts[:]\n    upstream_option_index = _get_upstream_option_index(command_parts)\n\n    if upstream_option_index is not None:\n        command_parts.pop(upstream_option_index)\n\n        # In case of `git push -u` we don't have next argument:\n        if len(command_parts) > upstream_option_index:\n            command_parts.pop(upstream_option_index)\n    else:\n        # the only non-qualified permitted options are the repository and refspec; git's\n        # suggestion include them, so they won't be lost, but would be duplicated otherwise.\n        push_idx = command_parts.index('push') + 1\n        while len(command_parts) > push_idx and command_parts[len(command_parts) - 1][0] != '-':\n            command_parts.pop(len(command_parts) - 1)\n\n    arguments = re.findall(r'git push (.*)', command.output)[-1].replace(\"'\", r\"\\'\").strip()\n    return replace_argument(\" \".join(command_parts), 'push',\n                            'push {}'.format(arguments))\n", "thefuck/rules/__init__.py": "", "thefuck/rules/terraform_init.py": "from thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app('terraform')\ndef match(command):\n    return ('this module is not yet installed' in command.output.lower() or\n            'initialization required' in command.output.lower()\n            )\n\n\ndef get_new_command(command):\n    return shell.and_('terraform init', command.script)\n", "thefuck/rules/ln_s_order.py": "import os\nfrom thefuck.specific.sudo import sudo_support\n\n\ndef _get_destination(script_parts):\n    \"\"\"When arguments order is wrong first argument will be destination.\"\"\"\n    for part in script_parts:\n        if part not in {'ln', '-s', '--symbolic'} and os.path.exists(part):\n            return part\n\n\n@sudo_support\ndef match(command):\n    return (command.script_parts[0] == 'ln'\n            and {'-s', '--symbolic'}.intersection(command.script_parts)\n            and 'File exists' in command.output\n            and _get_destination(command.script_parts))\n\n\n@sudo_support\ndef get_new_command(command):\n    destination = _get_destination(command.script_parts)\n    parts = command.script_parts[:]\n    parts.remove(destination)\n    parts.append(destination)\n    return ' '.join(parts)\n", "thefuck/rules/aws_cli.py": "import re\n\nfrom thefuck.utils import for_app, replace_argument\n\nINVALID_CHOICE = \"(?<=Invalid choice: ')(.*)(?=', maybe you meant:)\"\nOPTIONS = \"^\\\\s*\\\\*\\\\s(.*)\"\n\n\n@for_app('aws')\ndef match(command):\n    return \"usage:\" in command.output and \"maybe you meant:\" in command.output\n\n\ndef get_new_command(command):\n    mistake = re.search(INVALID_CHOICE, command.output).group(0)\n    options = re.findall(OPTIONS, command.output, flags=re.MULTILINE)\n    return [replace_argument(command.script, mistake, o) for o in options]\n", "thefuck/rules/cd_cs.py": "# -*- encoding: utf-8 -*-\n\n# Redirects cs to cd when there is a typo\n# Due to the proximity of the keys - d and s - this seems like a common typo\n# ~ > cs /etc/\n# cs: command not found\n# ~ > fuck\n# cd /etc/ [enter/\u2191/\u2193/ctrl+c]\n# /etc >\n\n\ndef match(command):\n    if command.script_parts[0] == 'cs':\n        return True\n\n\ndef get_new_command(command):\n    return 'cd' + ''.join(command.script[2:])\n\n\npriority = 900\n", "thefuck/rules/mvn_no_command.py": "from thefuck.utils import for_app\n\n\n@for_app('mvn')\ndef match(command):\n    return 'No goals have been specified for this build' in command.output\n\n\ndef get_new_command(command):\n    return [command.script + ' clean package',\n            command.script + ' clean install']\n", "thefuck/rules/git_push_without_commits.py": "import re\nfrom thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return bool(re.search(r\"src refspec \\w+ does not match any\", command.output))\n\n\ndef get_new_command(command):\n    return shell.and_('git commit -m \"Initial commit\"', command.script)\n", "thefuck/rules/composer_not_command.py": "import re\nfrom thefuck.utils import replace_argument, for_app\n\n\n@for_app('composer')\ndef match(command):\n    return (('did you mean this?' in command.output.lower()\n             or 'did you mean one of these?' in command.output.lower())) or (\n        \"install\" in command.script_parts and \"composer require\" in command.output.lower()\n    )\n\n\ndef get_new_command(command):\n    if \"install\" in command.script_parts and \"composer require\" in command.output.lower():\n        broken_cmd, new_cmd = \"install\", \"require\"\n    else:\n        broken_cmd = re.findall(r\"Command \\\"([^']*)\\\" is not defined\", command.output)[0]\n        new_cmd = re.findall(r'Did you mean this\\?[^\\n]*\\n\\s*([^\\n]*)', command.output)\n        if not new_cmd:\n            new_cmd = re.findall(r'Did you mean one of these\\?[^\\n]*\\n\\s*([^\\n]*)', command.output)\n        new_cmd = new_cmd[0].strip()\n    return replace_argument(command.script, broken_cmd, new_cmd)\n", "thefuck/rules/git_bisect_usage.py": "import re\nfrom thefuck.utils import replace_command\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return ('bisect' in command.script_parts and\n            'usage: git bisect' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    broken = re.findall(r'git bisect ([^ $]*).*', command.script)[0]\n    usage = re.findall(r'usage: git bisect \\[([^\\]]+)\\]', command.output)[0]\n    return replace_command(command, broken, usage.split('|'))\n", "thefuck/rules/adb_unknown_command.py": "from thefuck.utils import is_app, get_closest, replace_argument\n\n\n_ADB_COMMANDS = (\n    'backup',\n    'bugreport',\n    'connect',\n    'devices',\n    'disable-verity',\n    'disconnect',\n    'enable-verity',\n    'emu',\n    'forward',\n    'get-devpath',\n    'get-serialno',\n    'get-state',\n    'install',\n    'install-multiple',\n    'jdwp',\n    'keygen',\n    'kill-server',\n    'logcat',\n    'pull',\n    'push',\n    'reboot',\n    'reconnect',\n    'restore',\n    'reverse',\n    'root',\n    'run-as',\n    'shell',\n    'sideload',\n    'start-server',\n    'sync',\n    'tcpip',\n    'uninstall',\n    'unroot',\n    'usb',\n    'wait-for',\n)\n\n\ndef match(command):\n    return (is_app(command, 'adb')\n            and command.output.startswith('Android Debug Bridge version'))\n\n\ndef get_new_command(command):\n    for idx, arg in enumerate(command.script_parts[1:]):\n        # allowed params to ADB are a/d/e/s/H/P/L where s, H, P and L take additional args\n        # for example 'adb -s 111 logcat' or 'adb -e logcat'\n        if not arg[0] == '-' and not command.script_parts[idx] in ('-s', '-H', '-P', '-L'):\n            adb_cmd = get_closest(arg, _ADB_COMMANDS)\n            return replace_argument(command.script, arg, adb_cmd)\n", "thefuck/rules/git_not_command.py": "import re\nfrom thefuck.utils import get_all_matched_commands, replace_command\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (\" is not a git command. See 'git --help'.\" in command.output\n            and ('The most similar command' in command.output\n                 or 'Did you mean' in command.output))\n\n\n@git_support\ndef get_new_command(command):\n    broken_cmd = re.findall(r\"git: '([^']*)' is not a git command\",\n                            command.output)[0]\n    matched = get_all_matched_commands(command.output, ['The most similar command', 'Did you mean'])\n    return replace_command(command, broken_cmd, matched)\n", "thefuck/rules/git_add.py": "import re\nfrom thefuck.shells import shell\nfrom thefuck.specific.git import git_support\nfrom thefuck.system import Path\nfrom thefuck.utils import memoize\n\n\n@memoize\ndef _get_missing_file(command):\n    pathspec = re.findall(\n        r\"error: pathspec '([^']*)' \"\n        r'did not match any file\\(s\\) known to git.', command.output)[0]\n    if Path(pathspec).exists():\n        return pathspec\n\n\n@git_support\ndef match(command):\n    return ('did not match any file(s) known to git.' in command.output\n            and _get_missing_file(command))\n\n\n@git_support\ndef get_new_command(command):\n    missing_file = _get_missing_file(command)\n    formatme = shell.and_('git add -- {}', '{}')\n    return formatme.format(missing_file, command.script)\n", "thefuck/rules/touch.py": "import re\nfrom thefuck.shells import shell\nfrom thefuck.utils import for_app\n\n\n@for_app('touch')\ndef match(command):\n    return 'No such file or directory' in command.output\n\n\ndef get_new_command(command):\n    path = re.findall(\n        r\"touch: (?:cannot touch ')?(.+)/.+'?:\", command.output)[0]\n    return shell.and_(u'mkdir -p {}'.format(path), command.script)\n", "thefuck/rules/unknown_command.py": "import re\nfrom thefuck.utils import replace_command\n\n\ndef match(command):\n    return (re.search(r\"([^:]*): Unknown command.*\", command.output) is not None\n            and re.search(r\"Did you mean ([^?]*)?\", command.output) is not None)\n\n\ndef get_new_command(command):\n    broken_cmd = re.findall(r\"([^:]*): Unknown command.*\", command.output)[0]\n    matched = re.findall(r\"Did you mean ([^?]*)?\", command.output)\n    return replace_command(command, broken_cmd, matched)\n", "thefuck/rules/history.py": "from thefuck.utils import get_close_matches, get_closest, \\\n    get_valid_history_without_current\n\n\ndef match(command):\n    return len(get_close_matches(command.script,\n                                 get_valid_history_without_current(command)))\n\n\ndef get_new_command(command):\n    return get_closest(command.script,\n                       get_valid_history_without_current(command))\n\n\npriority = 9999\n", "thefuck/rules/git_rm_staged.py": "from thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return (' rm ' in command.script and\n            'error: the following file has changes staged in the index' in command.output and\n            'use --cached to keep the file, or -f to force removal' in command.output)\n\n\n@git_support\ndef get_new_command(command):\n    command_parts = command.script_parts[:]\n    index = command_parts.index('rm') + 1\n    command_parts.insert(index, '--cached')\n    command_list = [u' '.join(command_parts)]\n    command_parts[index] = '-f'\n    command_list.append(u' '.join(command_parts))\n    return command_list\n", "thefuck/rules/switch_lang.py": "# -*- encoding: utf-8 -*-\nfrom thefuck.utils import memoize, get_alias\n\ntarget_layout = '''qwertyuiop[]asdfghjkl;'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>?'''\n# any new keyboard layout must be appended\n\ngreek = u''';\u03c2\u03b5\u03c1\u03c4\u03c5\u03b8\u03b9\u03bf\u03c0[]\u03b1\u03c3\u03b4\u03c6\u03b3\u03b7\u03be\u03ba\u03bb\u0384\u03b6\u03c7\u03c8\u03c9\u03b2\u03bd\u03bc,./:\u0385\u0395\u03a1\u03a4\u03a5\u0398\u0399\u039f\u03a0{}\u0391\u03a3\u0394\u03a6\u0393\u0397\u039e\u039a\u039b\u00a8\"\u0396\u03a7\u03a8\u03a9\u0392\u039d\u039c<>?'''\nkorean = u'''\u3142\u3148\u3137\u3131\u3145\u315b\u3155\u3151\u3150\u3154[]\u3141\u3134\u3147\u3139\u314e\u3157\u3153\u314f\u3163;'\u314b\u314c\u314a\u314d\u3160\u315c\u3161,./\u3143\u3149\u3138\u3132\u3146\u315b\u3155\u3151\u3152\u3156{}\u3141\u3134\u3147\u3139\u314e\u3157\u3153\u314f\u3163:\"\u314b\u314c\u314a\u314d\u3160\u315c\u3161<>?'''\n\nsource_layouts = [u'''\u0439\u0446\u0443\u043a\u0435\u043d\u0433\u0448\u0449\u0437\u0445\u044a\u0444\u044b\u0432\u0430\u043f\u0440\u043e\u043b\u0434\u0436\u044d\u044f\u0447\u0441\u043c\u0438\u0442\u044c\u0431\u044e.\u0419\u0426\u0423\u041a\u0415\u041d\u0413\u0428\u0429\u0417\u0425\u042a\u0424\u042b\u0412\u0410\u041f\u0420\u041e\u041b\u0414\u0416\u042d\u042f\u0427\u0421\u041c\u0418\u0422\u042c\u0411\u042e,''',\n                  u'''\u0439\u0446\u0443\u043a\u0435\u043d\u0433\u0448\u0449\u0437\u0445\u0457\u0444\u0456\u0432\u0430\u043f\u0440\u043e\u043b\u0434\u0436\u0454\u044f\u0447\u0441\u043c\u0438\u0442\u044c\u0431\u044e.\u0419\u0426\u0423\u041a\u0415\u041d\u0413\u0428\u0429\u0417\u0425\u0407\u0424\u0406\u0412\u0410\u041f\u0420\u041e\u041b\u0414\u0416\u0404\u042f\u0427\u0421\u041c\u0418\u0422\u042c\u0411\u042e,''',\n                  u'''\u0636\u0635\u062b\u0642\u0641\u063a\u0639\u0647\u062e\u062d\u062c\u0686\u0634\u0633\u06cc\u0628\u0644\u0627\u062a\u0646\u0645\u06a9\u06af\u0638\u0637\u0632\u0631\u0630\u062f\u067e\u0648./\u0652\u064c\u064d\u064b\u064f\u0650\u064e\u0651][}{\u0624\u0626\u064a\u0625\u0623\u0622\u0629\u00bb\u00ab:\u061b\u0643\u0653\u0698\u0670\u200c\u0654\u0621><\u061f''',\n                  u'''/'\u05e7\u05e8\u05d0\u05d8\u05d5\u05df\u05dd\u05e4][\u05e9\u05d3\u05d2\u05db\u05e2\u05d9\u05d7\u05dc\u05da\u05e3,\u05d6\u05e1\u05d1\u05d4\u05e0\u05de\u05e6\u05ea\u05e5.QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>?''',\n                  greek,\n                  korean]\n\nsource_to_target = {\n    greek: {u';': \"q\", u'\u03c2': \"w\", u'\u03b5': \"e\", u'\u03c1': \"r\", u'\u03c4': \"t\", u'\u03c5': \"y\",\n            u'\u03b8': \"u\", u'\u03b9': \"i\", u'\u03bf': \"o\", u'\u03c0': \"p\", u'[': \"[\", u']': \"]\",\n            u'\u03b1': \"a\", u'\u03c3': \"s\", u'\u03b4': \"d\", u'\u03c6': \"f\", u'\u03b3': \"g\", u'\u03b7': \"h\",\n            u'\u03be': \"j\", u'\u03ba': \"k\", u'\u03bb': \"l\", u'\u0384': \"'\", u'\u03b6': \"z\", u'\u03c7': \"x\",\n            u'\u03c8': \"c\", u'\u03c9': \"v\", u'\u03b2': \"b\", u'\u03bd': \"n\", u'\u03bc': \"m\", u',': \",\",\n            u'.': \".\", u'/': \"/\", u':': \"Q\", u'\u0385': \"W\", u'\u0395': \"E\", u'\u03a1': \"R\",\n            u'\u03a4': \"T\", u'\u03a5': \"Y\", u'\u0398': \"U\", u'\u0399': \"I\", u'\u039f': \"O\", u'\u03a0': \"P\",\n            u'{': \"{\", u'}': \"}\", u'\u0391': \"A\", u'\u03a3': \"S\", u'\u0394': \"D\", u'\u03a6': \"F\",\n            u'\u0393': \"G\", u'\u0397': \"H\", u'\u039e': \"J\", u'\u039a': \"K\", u'\u039b': \"L\", u'\u00a8': \":\",\n            u'\"': '\"', u'\u0396': \"Z\", u'\u03a7': \"X\", u'\u03a8': \"C\", u'\u03a9': \"V\", u'\u0392': \"B\",\n            u'\u039d': \"N\", u'\u039c': \"M\", u'<': \"<\", u'>': \">\", u'?': \"?\", u'\u03ac': \"a\",\n            u'\u03ad': \"e\", u'\u03cd': \"y\", u'\u03af': \"i\", u'\u03cc': \"o\", u'\u03ae': 'h', u'\u03ce': u\"v\",\n            u'\u0386': \"A\", u'\u0388': \"E\", u'\u038e': \"Y\", u'\u038a': \"I\", u'\u038c': \"O\", u'\u0389': \"H\",\n            u'\u038f': \"V\"},\n}\n\n'''Lists used for decomposing korean letters.'''\nHEAD_LIST = [u'\u3131', u'\u3132', u'\u3134', u'\u3137', u'\u3138', u'\u3139', u'\u3141', u'\u3142', u'\u3143', u'\u3145', u'\u3146',\n             u'\u3147', u'\u3148', u'\u3149', u'\u314a', u'\u314b', u'\u314c', u'\u314d', u'\u314e']\nBODY_LIST = [u'\u314f', u'\u3150', u'\u3151', u'\u3152', u'\u3153', u'\u3154', u'\u3155', u'\u3156', u'\u3157', u'\u3158', u'\u3159',\n             u'\u315a', u'\u315b', u'\u315c', u'\u315d', u'\u315e', u'\u315f', u'\u3160', u'\u3161', u'\u3162', u'\u3163']\nTAIL_LIST = [u' ', u'\u3131', u'\u3132', u'\u3133', u'\u3134', u'\u3135', u'\u3136', u'\u3137', u'\u3139', u'\u313a', u'\u313b',\n             u'\u313c', u'\u313d', u'\u313e', u'\u313f', u'\u3140', u'\u3141', u'\u3142', u'\u3144', u'\u3145', u'\u3146', u'\u3147', u'\u3148',\n             u'\u314a', u'\u314b', u'\u314c', u'\u314d', u'\u314e']\nDOUBLE_LIST = [u'\u3158', u'\u3159', u'\u315a', u'\u315d', u'\u315e', u'\u315f', u'\u3162', u'\u3133', u'\u3135', u'\u3136', u'\u313a',\n               u'\u313b', u'\u313c', u'\u313d', u'\u313e', u'\u3140', u'\u3144']\nDOUBLE_MOD_LIST = [u'\u3157\u314f', u'\u3157\u3150', u'\u3157\u3163', u'\u315c\u3153', u'\u315c\u3154', u'\u315c\u3163', u'\u3161\u3163', u'\u3131\u3145',\n                   u'\u3134\u3148', u'\u3134\u314e', u'\u3139\u3131', u'\u3139\u3141', u'\u3139\u3142', u'\u3139\u3145', u'\u3139\u314c', u'\u3139\u314e', u'\u3142\u3145']\n\n\n@memoize\ndef _get_matched_layout(command):\n    # don't use command.split_script here because a layout mismatch will likely\n    # result in a non-splitable script as per shlex\n    cmd = command.script.split(' ')\n    for source_layout in source_layouts:\n        is_all_match = True\n        for cmd_part in cmd:\n            if not all([ch in source_layout or ch in '-_' for ch in cmd_part]):\n                is_all_match = False\n                break\n\n        if is_all_match:\n            return source_layout\n\n\ndef _switch(ch, layout):\n    if ch in layout:\n        return target_layout[layout.index(ch)]\n    return ch\n\n\ndef _switch_command(command, layout):\n    # Layouts with different amount of characters than English\n    if layout in source_to_target:\n        return ''.join(source_to_target[layout].get(ch, ch)\n                       for ch in command.script)\n\n    return ''.join(_switch(ch, layout) for ch in command.script)\n\n\ndef _decompose_korean(command):\n    def _change_double(ch):\n        if ch in DOUBLE_LIST:\n            return DOUBLE_MOD_LIST[DOUBLE_LIST.index(ch)]\n        return ch\n\n    hg_str = u''\n    for ch in command.script:\n        if u'\uac00' <= ch <= u'\ud7a3':\n            ord_ch = ord(ch) - ord(u'\uac00')\n            hd = ord_ch // 588\n            bd = (ord_ch - 588 * hd) // 28\n            tl = ord_ch - 588 * hd - 28 * bd\n            for ch in [HEAD_LIST[hd], BODY_LIST[bd], TAIL_LIST[tl]]:\n                if ch != ' ':\n                    hg_str += _change_double(ch)\n        else:\n            hg_str += _change_double(ch)\n    return hg_str\n\n\ndef match(command):\n    if 'not found' not in command.output:\n        return False\n    if any(u'\u3131' <= ch <= u'\u314e' or u'\u314f' <= ch <= u'\u3163' or u'\uac00' <= ch <= u'\ud7a3'\n            for ch in command.script):\n        return True\n\n    matched_layout = _get_matched_layout(command)\n    return (matched_layout and\n            _switch_command(command, matched_layout) != get_alias())\n\n\ndef get_new_command(command):\n    if any(u'\u3131' <= ch <= u'\u314e' or u'\u314f' <= ch <= u'\u3163' or u'\uac00' <= ch <= u'\ud7a3'\n            for ch in command.script):\n        command.script = _decompose_korean(command)\n    matched_layout = _get_matched_layout(command)\n    return _switch_command(command, matched_layout)\n", "thefuck/rules/port_already_in_use.py": "import re\nfrom subprocess import Popen, PIPE\nfrom thefuck.utils import memoize, which\nfrom thefuck.shells import shell\n\nenabled_by_default = bool(which('lsof'))\n\npatterns = [r\"bind on address \\('.*', (?P<port>\\d+)\\)\",\n            r'Unable to bind [^ ]*:(?P<port>\\d+)',\n            r\"can't listen on port (?P<port>\\d+)\",\n            r'listen EADDRINUSE [^ ]*:(?P<port>\\d+)']\n\n\n@memoize\ndef _get_pid_by_port(port):\n    proc = Popen(['lsof', '-i', ':{}'.format(port)], stdout=PIPE)\n    lines = proc.stdout.read().decode().split('\\n')\n    if len(lines) > 1:\n        return lines[1].split()[1]\n    else:\n        return None\n\n\n@memoize\ndef _get_used_port(command):\n    for pattern in patterns:\n        matched = re.search(pattern, command.output)\n        if matched:\n            return matched.group('port')\n\n\ndef match(command):\n    port = _get_used_port(command)\n    return port and _get_pid_by_port(port)\n\n\ndef get_new_command(command):\n    port = _get_used_port(command)\n    pid = _get_pid_by_port(port)\n    return shell.and_(u'kill {}'.format(pid), command.script)\n", "thefuck/rules/git_stash.py": "from thefuck.shells import shell\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    # catches \"Please commit or stash them\" and \"Please, commit your changes or\n    # stash them before you can switch branches.\"\n    return 'or stash them' in command.output\n\n\n@git_support\ndef get_new_command(command):\n    formatme = shell.and_('git stash', '{}')\n    return formatme.format(command.script)\n", "thefuck/rules/npm_run_script.py": "from thefuck.specific.npm import npm_available, get_scripts\nfrom thefuck.utils import for_app\n\nenabled_by_default = npm_available\n\n\n@for_app('npm')\ndef match(command):\n    return ('Usage: npm <command>' in command.output\n            and not any(part.startswith('ru') for part in command.script_parts)\n            and command.script_parts[1] in get_scripts())\n\n\ndef get_new_command(command):\n    parts = command.script_parts[:]\n    parts.insert(1, 'run-script')\n    return ' '.join(parts)\n", "thefuck/rules/git_remote_delete.py": "import re\n\nfrom thefuck.specific.git import git_support\n\n\n@git_support\ndef match(command):\n    return \"remote delete\" in command.script\n\n\n@git_support\ndef get_new_command(command):\n    return re.sub(r\"delete\", \"remove\", command.script, 1)\n", "thefuck/rules/remove_shell_prompt_literal.py": "\"\"\"Fixes error for commands containing one or more occurrences of the shell\nprompt symbol '$'.\n\nThis usually happens when commands are copied from documentations\nincluding them in their code blocks.\n\nExample:\n> $ git clone https://github.com/nvbn/thefuck.git\nbash: $: command not found...\n\"\"\"\n\nimport re\n\n\ndef match(command):\n    return (\n        \"$: command not found\" in command.output\n        and re.search(r\"^[\\s]*\\$ [\\S]+\", command.script) is not None\n    )\n\n\ndef get_new_command(command):\n    return command.script.lstrip(\"$ \")\n", "thefuck/rules/missing_space_before_subcommand.py": "from thefuck.utils import get_all_executables, memoize\n\n\n@memoize\ndef _get_executable(script_part):\n    for executable in get_all_executables():\n        if len(executable) > 1 and script_part.startswith(executable):\n            return executable\n\n\ndef match(command):\n    return (not command.script_parts[0] in get_all_executables()\n            and _get_executable(command.script_parts[0]))\n\n\ndef get_new_command(command):\n    executable = _get_executable(command.script_parts[0])\n    return command.script.replace(executable, u'{} '.format(executable), 1)\n\n\npriority = 4000\n", "thefuck/rules/rm_root.py": "from thefuck.specific.sudo import sudo_support\n\nenabled_by_default = False\n\n\n@sudo_support\ndef match(command):\n    return (command.script_parts\n            and {'rm', '/'}.issubset(command.script_parts)\n            and '--no-preserve-root' not in command.script\n            and '--no-preserve-root' in command.output)\n\n\n@sudo_support\ndef get_new_command(command):\n    return u'{} --no-preserve-root'.format(command.script)\n", "thefuck/rules/apt_invalid_operation.py": "import subprocess\nfrom thefuck.specific.apt import apt_available\nfrom thefuck.specific.sudo import sudo_support\nfrom thefuck.utils import for_app, eager, replace_command\n\nenabled_by_default = apt_available\n\n\n@sudo_support\n@for_app('apt', 'apt-get', 'apt-cache')\ndef match(command):\n    return 'E: Invalid operation' in command.output\n\n\n@eager\ndef _parse_apt_operations(help_text_lines):\n    is_commands_list = False\n    for line in help_text_lines:\n        line = line.decode().strip()\n        if is_commands_list and line:\n            yield line.split()[0]\n        elif line.startswith('Basic commands:') \\\n                or line.startswith('Most used commands:'):\n            is_commands_list = True\n\n\n@eager\ndef _parse_apt_get_and_cache_operations(help_text_lines):\n    is_commands_list = False\n    for line in help_text_lines:\n        line = line.decode().strip()\n        if is_commands_list:\n            if not line:\n                return\n\n            yield line.split()[0]\n        elif line.startswith('Commands:') \\\n                or line.startswith('Most used commands:'):\n            is_commands_list = True\n\n\ndef _get_operations(app):\n    proc = subprocess.Popen([app, '--help'],\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE)\n    lines = proc.stdout.readlines()\n\n    if app == 'apt':\n        return _parse_apt_operations(lines)\n    else:\n        return _parse_apt_get_and_cache_operations(lines)\n\n\n@sudo_support\ndef get_new_command(command):\n    invalid_operation = command.output.split()[-1]\n\n    if invalid_operation == 'uninstall':\n        return [command.script.replace('uninstall', 'remove')]\n\n    else:\n        operations = _get_operations(command.script_parts[0])\n        return replace_command(command, invalid_operation, operations)\n"}