{"setup.py": "from setuptools import setup\n\n\nif __name__ == \"__main__\":\n    setup(use_scm_version={\"write_to\": \"src/pluggy/_version.py\"})\n", "scripts/release.py": "\"\"\"\nRelease script.\n\"\"\"\n\nimport argparse\nfrom subprocess import check_call\nimport sys\n\nfrom colorama import Fore\nfrom colorama import init\nfrom git import Remote\nfrom git import Repo\n\n\ndef create_branch(version):\n    \"\"\"Create a fresh branch from upstream/main\"\"\"\n    repo = Repo.init(\".\")\n    if repo.is_dirty(untracked_files=True):\n        raise RuntimeError(\"Repository is dirty, please commit/stash your changes.\")\n\n    branch_name = f\"release-{version}\"\n    print(f\"{Fore.CYAN}Create {branch_name} branch from upstream main\")\n    upstream = get_upstream(repo)\n    upstream.fetch()\n    release_branch = repo.create_head(branch_name, upstream.refs.main, force=True)\n    release_branch.checkout()\n    return repo\n\n\ndef get_upstream(repo: Repo) -> Remote:\n    \"\"\"Find upstream repository for pluggy on the remotes\"\"\"\n    for remote in repo.remotes:\n        for url in remote.urls:\n            if url.endswith((\"pytest-dev/pluggy.git\", \"pytest-dev/pluggy\")):\n                return remote\n    raise RuntimeError(\"could not find pytest-dev/pluggy remote\")\n\n\ndef pre_release(version):\n    \"\"\"Generates new docs, release announcements and creates a local tag.\"\"\"\n    create_branch(version)\n    changelog(version, write_out=True)\n\n    check_call([\"git\", \"commit\", \"-a\", \"-m\", f\"Preparing release {version}\"])\n\n    print()\n    print(f\"{Fore.GREEN}Please push your branch to your fork and open a PR.\")\n\n\ndef changelog(version, write_out=False):\n    if write_out:\n        addopts = []\n    else:\n        addopts = [\"--draft\"]\n    print(f\"{Fore.CYAN}Generating CHANGELOG\")\n    check_call([\"towncrier\", \"build\", \"--yes\", \"--version\", version] + addopts)\n\n\ndef main():\n    init(autoreset=True)\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"version\", help=\"Release version\")\n    options = parser.parse_args()\n    try:\n        pre_release(options.version)\n    except RuntimeError as e:\n        print(f\"{Fore.RED}ERROR: {e}\")\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "scripts/towncrier-draft-to-file.py": "from subprocess import call\nimport sys\n\n\ndef main():\n    \"\"\"\n    Platform agnostic wrapper script for towncrier.\n    Fixes the issue (pytest#7251) where windows users are unable to natively\n    run tox -e docs to build pytest docs.\n    \"\"\"\n    with open(\"docs/_changelog_towncrier_draft.rst\", \"w\") as draft_file:\n        return call((\"towncrier\", \"--draft\"), stdout=draft_file)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "src/pluggy/_tracing.py": "\"\"\"\nTracing utils\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Sequence\nfrom typing import Tuple\n\n\n_Writer = Callable[[str], object]\n_Processor = Callable[[Tuple[str, ...], Tuple[Any, ...]], object]\n\n\nclass TagTracer:\n    def __init__(self) -> None:\n        self._tags2proc: dict[tuple[str, ...], _Processor] = {}\n        self._writer: _Writer | None = None\n        self.indent = 0\n\n    def get(self, name: str) -> TagTracerSub:\n        return TagTracerSub(self, (name,))\n\n    def _format_message(self, tags: Sequence[str], args: Sequence[object]) -> str:\n        if isinstance(args[-1], dict):\n            extra = args[-1]\n            args = args[:-1]\n        else:\n            extra = {}\n\n        content = \" \".join(map(str, args))\n        indent = \"  \" * self.indent\n\n        lines = [\"{}{} [{}]\\n\".format(indent, content, \":\".join(tags))]\n\n        for name, value in extra.items():\n            lines.append(f\"{indent}    {name}: {value}\\n\")\n\n        return \"\".join(lines)\n\n    def _processmessage(self, tags: tuple[str, ...], args: tuple[object, ...]) -> None:\n        if self._writer is not None and args:\n            self._writer(self._format_message(tags, args))\n        try:\n            processor = self._tags2proc[tags]\n        except KeyError:\n            pass\n        else:\n            processor(tags, args)\n\n    def setwriter(self, writer: _Writer | None) -> None:\n        self._writer = writer\n\n    def setprocessor(self, tags: str | tuple[str, ...], processor: _Processor) -> None:\n        if isinstance(tags, str):\n            tags = tuple(tags.split(\":\"))\n        else:\n            assert isinstance(tags, tuple)\n        self._tags2proc[tags] = processor\n\n\nclass TagTracerSub:\n    def __init__(self, root: TagTracer, tags: tuple[str, ...]) -> None:\n        self.root = root\n        self.tags = tags\n\n    def __call__(self, *args: object) -> None:\n        self.root._processmessage(self.tags, args)\n\n    def get(self, name: str) -> TagTracerSub:\n        return self.__class__(self.root, self.tags + (name,))\n", "src/pluggy/_warnings.py": "from typing import final\n\n\nclass PluggyWarning(UserWarning):\n    \"\"\"Base class for all warnings emitted by pluggy.\"\"\"\n\n    __module__ = \"pluggy\"\n\n\n@final\nclass PluggyTeardownRaisedWarning(PluggyWarning):\n    \"\"\"A plugin raised an exception during an :ref:`old-style hookwrapper\n    <old_style_hookwrappers>` teardown.\n\n    Such exceptions are not handled by pluggy, and may cause subsequent\n    teardowns to be executed at unexpected times, or be skipped entirely.\n\n    This is an issue in the plugin implementation.\n\n    If the exception is unintended, fix the underlying cause.\n\n    If the exception is intended, switch to :ref:`new-style hook wrappers\n    <hookwrappers>`, or use :func:`result.force_exception()\n    <pluggy.Result.force_exception>` to set the exception instead of raising.\n    \"\"\"\n\n    __module__ = \"pluggy\"\n", "src/pluggy/_hooks.py": "\"\"\"\nInternal hook annotation, representation and calling machinery.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nimport sys\nfrom types import ModuleType\nfrom typing import AbstractSet\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Final\nfrom typing import final\nfrom typing import Generator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import TypedDict\nfrom typing import TypeVar\nfrom typing import Union\nimport warnings\n\nfrom ._result import Result\n\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., object])\n_Namespace = Union[ModuleType, type]\n_Plugin = object\n_HookExec = Callable[\n    [str, Sequence[\"HookImpl\"], Mapping[str, object], bool],\n    Union[object, List[object]],\n]\n_HookImplFunction = Callable[..., Union[_T, Generator[None, Result[_T], None]]]\n\n\nclass HookspecOpts(TypedDict):\n    \"\"\"Options for a hook specification.\"\"\"\n\n    #: Whether the hook is :ref:`first result only <firstresult>`.\n    firstresult: bool\n    #: Whether the hook is :ref:`historic <historic>`.\n    historic: bool\n    #: Whether the hook :ref:`warns when implemented <warn_on_impl>`.\n    warn_on_impl: Warning | None\n    #: Whether the hook warns when :ref:`certain arguments are requested\n    #: <warn_on_impl>`.\n    #:\n    #: .. versionadded:: 1.5\n    warn_on_impl_args: Mapping[str, Warning] | None\n\n\nclass HookimplOpts(TypedDict):\n    \"\"\"Options for a hook implementation.\"\"\"\n\n    #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.\n    wrapper: bool\n    #: Whether the hook implementation is an :ref:`old-style wrapper\n    #: <old_style_hookwrappers>`.\n    hookwrapper: bool\n    #: Whether validation against a hook specification is :ref:`optional\n    #: <optionalhook>`.\n    optionalhook: bool\n    #: Whether to try to order this hook implementation :ref:`first\n    #: <callorder>`.\n    tryfirst: bool\n    #: Whether to try to order this hook implementation :ref:`last\n    #: <callorder>`.\n    trylast: bool\n    #: The name of the hook specification to match, see :ref:`specname`.\n    specname: str | None\n\n\n@final\nclass HookspecMarker:\n    \"\"\"Decorator for marking functions as hook specifications.\n\n    Instantiate it with a project_name to get a decorator.\n    Calling :meth:`PluginManager.add_hookspecs` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    \"\"\"\n\n    __slots__ = (\"project_name\",)\n\n    def __init__(self, project_name: str) -> None:\n        self.project_name: Final = project_name\n\n    @overload\n    def __call__(\n        self,\n        function: _F,\n        firstresult: bool = False,\n        historic: bool = False,\n        warn_on_impl: Warning | None = None,\n        warn_on_impl_args: Mapping[str, Warning] | None = None,\n    ) -> _F: ...\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self,\n        function: None = ...,\n        firstresult: bool = ...,\n        historic: bool = ...,\n        warn_on_impl: Warning | None = ...,\n        warn_on_impl_args: Mapping[str, Warning] | None = ...,\n    ) -> Callable[[_F], _F]: ...\n\n    def __call__(  # noqa: F811\n        self,\n        function: _F | None = None,\n        firstresult: bool = False,\n        historic: bool = False,\n        warn_on_impl: Warning | None = None,\n        warn_on_impl_args: Mapping[str, Warning] | None = None,\n    ) -> _F | Callable[[_F], _F]:\n        \"\"\"If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.add_hookspecs`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param firstresult:\n            If ``True``, the 1:N hook call (N being the number of registered\n            hook implementation functions) will stop at I<=N when the I'th\n            function returns a non-``None`` result. See :ref:`firstresult`.\n\n        :param historic:\n            If ``True``, every call to the hook will be memorized and replayed\n            on plugins registered after the call was made. See :ref:`historic`.\n\n        :param warn_on_impl:\n            If given, every implementation of this hook will trigger the given\n            warning. See :ref:`warn_on_impl`.\n\n        :param warn_on_impl_args:\n            If given, every implementation of this hook which requests one of\n            the arguments in the dict will trigger the corresponding warning.\n            See :ref:`warn_on_impl`.\n\n            .. versionadded:: 1.5\n        \"\"\"\n\n        def setattr_hookspec_opts(func: _F) -> _F:\n            if historic and firstresult:\n                raise ValueError(\"cannot have a historic firstresult hook\")\n            opts: HookspecOpts = {\n                \"firstresult\": firstresult,\n                \"historic\": historic,\n                \"warn_on_impl\": warn_on_impl,\n                \"warn_on_impl_args\": warn_on_impl_args,\n            }\n            setattr(func, self.project_name + \"_spec\", opts)\n            return func\n\n        if function is not None:\n            return setattr_hookspec_opts(function)\n        else:\n            return setattr_hookspec_opts\n\n\n@final\nclass HookimplMarker:\n    \"\"\"Decorator for marking functions as hook implementations.\n\n    Instantiate it with a ``project_name`` to get a decorator.\n    Calling :meth:`PluginManager.register` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    \"\"\"\n\n    __slots__ = (\"project_name\",)\n\n    def __init__(self, project_name: str) -> None:\n        self.project_name: Final = project_name\n\n    @overload\n    def __call__(\n        self,\n        function: _F,\n        hookwrapper: bool = ...,\n        optionalhook: bool = ...,\n        tryfirst: bool = ...,\n        trylast: bool = ...,\n        specname: str | None = ...,\n        wrapper: bool = ...,\n    ) -> _F: ...\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self,\n        function: None = ...,\n        hookwrapper: bool = ...,\n        optionalhook: bool = ...,\n        tryfirst: bool = ...,\n        trylast: bool = ...,\n        specname: str | None = ...,\n        wrapper: bool = ...,\n    ) -> Callable[[_F], _F]: ...\n\n    def __call__(  # noqa: F811\n        self,\n        function: _F | None = None,\n        hookwrapper: bool = False,\n        optionalhook: bool = False,\n        tryfirst: bool = False,\n        trylast: bool = False,\n        specname: str | None = None,\n        wrapper: bool = False,\n    ) -> _F | Callable[[_F], _F]:\n        \"\"\"If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.register`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param optionalhook:\n            If ``True``, a missing matching hook specification will not result\n            in an error (by default it is an error if no matching spec is\n            found). See :ref:`optionalhook`.\n\n        :param tryfirst:\n            If ``True``, this hook implementation will run as early as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param trylast:\n            If ``True``, this hook implementation will run as late as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param wrapper:\n            If ``True`` (\"new-style hook wrapper\"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            functions have run. The ``yield`` receives the result value of the\n            inner calls, or raises the exception of inner calls (including\n            earlier hook wrapper calls). The return value of the function\n            becomes the return value of the hook, and a raised exception becomes\n            the exception of the hook. See :ref:`hookwrapper`.\n\n        :param hookwrapper:\n            If ``True`` (\"old-style hook wrapper\"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            function have run  The ``yield`` receives a :class:`Result` object\n            representing the exception or result outcome of the inner calls\n            (including earlier hook wrapper calls). This option is mutually\n            exclusive with ``wrapper``. See :ref:`old_style_hookwrapper`.\n\n        :param specname:\n            If provided, the given name will be used instead of the function\n            name when matching this hook implementation to a hook specification\n            during registration. See :ref:`specname`.\n\n        .. versionadded:: 1.2.0\n            The ``wrapper`` parameter.\n        \"\"\"\n\n        def setattr_hookimpl_opts(func: _F) -> _F:\n            opts: HookimplOpts = {\n                \"wrapper\": wrapper,\n                \"hookwrapper\": hookwrapper,\n                \"optionalhook\": optionalhook,\n                \"tryfirst\": tryfirst,\n                \"trylast\": trylast,\n                \"specname\": specname,\n            }\n            setattr(func, self.project_name + \"_impl\", opts)\n            return func\n\n        if function is None:\n            return setattr_hookimpl_opts\n        else:\n            return setattr_hookimpl_opts(function)\n\n\ndef normalize_hookimpl_opts(opts: HookimplOpts) -> None:\n    opts.setdefault(\"tryfirst\", False)\n    opts.setdefault(\"trylast\", False)\n    opts.setdefault(\"wrapper\", False)\n    opts.setdefault(\"hookwrapper\", False)\n    opts.setdefault(\"optionalhook\", False)\n    opts.setdefault(\"specname\", None)\n\n\n_PYPY = hasattr(sys, \"pypy_version_info\")\n\n\ndef varnames(func: object) -> tuple[tuple[str, ...], tuple[str, ...]]:\n    \"\"\"Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.\n\n    In case of a class, its ``__init__`` method is considered.\n    For methods the ``self`` parameter is not included.\n    \"\"\"\n    if inspect.isclass(func):\n        try:\n            func = func.__init__\n        except AttributeError:\n            return (), ()\n    elif not inspect.isroutine(func):  # callable object?\n        try:\n            func = getattr(func, \"__call__\", func)\n        except Exception:\n            return (), ()\n\n    try:\n        # func MUST be a function or method here or we won't parse any args.\n        sig = inspect.signature(\n            func.__func__ if inspect.ismethod(func) else func  # type:ignore[arg-type]\n        )\n    except TypeError:\n        return (), ()\n\n    _valid_param_kinds = (\n        inspect.Parameter.POSITIONAL_ONLY,\n        inspect.Parameter.POSITIONAL_OR_KEYWORD,\n    )\n    _valid_params = {\n        name: param\n        for name, param in sig.parameters.items()\n        if param.kind in _valid_param_kinds\n    }\n    args = tuple(_valid_params)\n    defaults = (\n        tuple(\n            param.default\n            for param in _valid_params.values()\n            if param.default is not param.empty\n        )\n        or None\n    )\n\n    if defaults:\n        index = -len(defaults)\n        args, kwargs = args[:index], tuple(args[index:])\n    else:\n        kwargs = ()\n\n    # strip any implicit instance arg\n    # pypy3 uses \"obj\" instead of \"self\" for default dunder methods\n    if not _PYPY:\n        implicit_names: tuple[str, ...] = (\"self\",)\n    else:\n        implicit_names = (\"self\", \"obj\")\n    if args:\n        qualname: str = getattr(func, \"__qualname__\", \"\")\n        if inspect.ismethod(func) or (\".\" in qualname and args[0] in implicit_names):\n            args = args[1:]\n\n    return args, kwargs\n\n\n@final\nclass HookRelay:\n    \"\"\"Hook holder object for performing 1:N hook calls where N is the number\n    of registered plugins.\"\"\"\n\n    __slots__ = (\"__dict__\",)\n\n    def __init__(self) -> None:\n        \"\"\":meta private:\"\"\"\n\n    if TYPE_CHECKING:\n\n        def __getattr__(self, name: str) -> HookCaller: ...\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_HookRelay = HookRelay\n\n\n_CallHistory = List[Tuple[Mapping[str, object], Optional[Callable[[Any], None]]]]\n\n\nclass HookCaller:\n    \"\"\"A caller of all registered implementations of a hook specification.\"\"\"\n\n    __slots__ = (\n        \"name\",\n        \"spec\",\n        \"_hookexec\",\n        \"_hookimpls\",\n        \"_call_history\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        hook_execute: _HookExec,\n        specmodule_or_class: _Namespace | None = None,\n        spec_opts: HookspecOpts | None = None,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        #: Name of the hook getting called.\n        self.name: Final = name\n        self._hookexec: Final = hook_execute\n        # The hookimpls list. The caller iterates it *in reverse*. Format:\n        # 1. trylast nonwrappers\n        # 2. nonwrappers\n        # 3. tryfirst nonwrappers\n        # 4. trylast wrappers\n        # 5. wrappers\n        # 6. tryfirst wrappers\n        self._hookimpls: Final[list[HookImpl]] = []\n        self._call_history: _CallHistory | None = None\n        # TODO: Document, or make private.\n        self.spec: HookSpec | None = None\n        if specmodule_or_class is not None:\n            assert spec_opts is not None\n            self.set_specification(specmodule_or_class, spec_opts)\n\n    # TODO: Document, or make private.\n    def has_spec(self) -> bool:\n        return self.spec is not None\n\n    # TODO: Document, or make private.\n    def set_specification(\n        self,\n        specmodule_or_class: _Namespace,\n        spec_opts: HookspecOpts,\n    ) -> None:\n        if self.spec is not None:\n            raise ValueError(\n                f\"Hook {self.spec.name!r} is already registered \"\n                f\"within namespace {self.spec.namespace}\"\n            )\n        self.spec = HookSpec(specmodule_or_class, self.name, spec_opts)\n        if spec_opts.get(\"historic\"):\n            self._call_history = []\n\n    def is_historic(self) -> bool:\n        \"\"\"Whether this caller is :ref:`historic <historic>`.\"\"\"\n        return self._call_history is not None\n\n    def _remove_plugin(self, plugin: _Plugin) -> None:\n        for i, method in enumerate(self._hookimpls):\n            if method.plugin == plugin:\n                del self._hookimpls[i]\n                return\n        raise ValueError(f\"plugin {plugin!r} not found\")\n\n    def get_hookimpls(self) -> list[HookImpl]:\n        \"\"\"Get all registered hook implementations for this hook.\"\"\"\n        return self._hookimpls.copy()\n\n    def _add_hookimpl(self, hookimpl: HookImpl) -> None:\n        \"\"\"Add an implementation to the callback chain.\"\"\"\n        for i, method in enumerate(self._hookimpls):\n            if method.hookwrapper or method.wrapper:\n                splitpoint = i\n                break\n        else:\n            splitpoint = len(self._hookimpls)\n        if hookimpl.hookwrapper or hookimpl.wrapper:\n            start, end = splitpoint, len(self._hookimpls)\n        else:\n            start, end = 0, splitpoint\n\n        if hookimpl.trylast:\n            self._hookimpls.insert(start, hookimpl)\n        elif hookimpl.tryfirst:\n            self._hookimpls.insert(end, hookimpl)\n        else:\n            # find last non-tryfirst method\n            i = end - 1\n            while i >= start and self._hookimpls[i].tryfirst:\n                i -= 1\n            self._hookimpls.insert(i + 1, hookimpl)\n\n    def __repr__(self) -> str:\n        return f\"<HookCaller {self.name!r}>\"\n\n    def _verify_all_args_are_provided(self, kwargs: Mapping[str, object]) -> None:\n        # This is written to avoid expensive operations when not needed.\n        if self.spec:\n            for argname in self.spec.argnames:\n                if argname not in kwargs:\n                    notincall = \", \".join(\n                        repr(argname)\n                        for argname in self.spec.argnames\n                        # Avoid self.spec.argnames - kwargs.keys() - doesn't preserve order.\n                        if argname not in kwargs.keys()\n                    )\n                    warnings.warn(\n                        \"Argument(s) {} which are declared in the hookspec \"\n                        \"cannot be found in this hook call\".format(notincall),\n                        stacklevel=2,\n                    )\n                    break\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n\n        Only accepts keyword arguments, which should match the hook\n        specification.\n\n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\n    def call_historic(\n        self,\n        result_callback: Callable[[Any], None] | None = None,\n        kwargs: Mapping[str, object] | None = None,\n    ) -> None:\n        \"\"\"Call the hook with given ``kwargs`` for all registered plugins and\n        for all plugins which will be registered afterwards, see\n        :ref:`historic`.\n\n        :param result_callback:\n            If provided, will be called for each non-``None`` result obtained\n            from a hook implementation.\n        \"\"\"\n        assert self._call_history is not None\n        kwargs = kwargs or {}\n        self._verify_all_args_are_provided(kwargs)\n        self._call_history.append((kwargs, result_callback))\n        # Historizing hooks don't return results.\n        # Remember firstresult isn't compatible with historic.\n        # Copy because plugins may register other plugins during iteration (#438).\n        res = self._hookexec(self.name, self._hookimpls.copy(), kwargs, False)\n        if result_callback is None:\n            return\n        if isinstance(res, list):\n            for x in res:\n                result_callback(x)\n\n    def call_extra(\n        self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]\n    ) -> Any:\n        \"\"\"Call the hook with some additional temporarily participating\n        methods using the specified ``kwargs`` as call parameters, see\n        :ref:`call_extra`.\"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        opts: HookimplOpts = {\n            \"wrapper\": False,\n            \"hookwrapper\": False,\n            \"optionalhook\": False,\n            \"trylast\": False,\n            \"tryfirst\": False,\n            \"specname\": None,\n        }\n        hookimpls = self._hookimpls.copy()\n        for method in methods:\n            hookimpl = HookImpl(None, \"<temp>\", method, opts)\n            # Find last non-tryfirst nonwrapper method.\n            i = len(hookimpls) - 1\n            while i >= 0 and (\n                # Skip wrappers.\n                (hookimpls[i].hookwrapper or hookimpls[i].wrapper)\n                # Skip tryfirst nonwrappers.\n                or hookimpls[i].tryfirst\n            ):\n                i -= 1\n            hookimpls.insert(i + 1, hookimpl)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        return self._hookexec(self.name, hookimpls, kwargs, firstresult)\n\n    def _maybe_apply_history(self, method: HookImpl) -> None:\n        \"\"\"Apply call history to a new hookimpl if it is marked as historic.\"\"\"\n        if self.is_historic():\n            assert self._call_history is not None\n            for kwargs, result_callback in self._call_history:\n                res = self._hookexec(self.name, [method], kwargs, False)\n                if res and result_callback is not None:\n                    # XXX: remember firstresult isn't compat with historic\n                    assert isinstance(res, list)\n                    result_callback(res[0])\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_HookCaller = HookCaller\n\n\nclass _SubsetHookCaller(HookCaller):\n    \"\"\"A proxy to another HookCaller which manages calls to all registered\n    plugins except the ones from remove_plugins.\"\"\"\n\n    # This class is unusual: in inhertits from `HookCaller` so all of\n    # the *code* runs in the class, but it delegates all underlying *data*\n    # to the original HookCaller.\n    # `subset_hook_caller` used to be implemented by creating a full-fledged\n    # HookCaller, copying all hookimpls from the original. This had problems\n    # with memory leaks (#346) and historic calls (#347), which make a proxy\n    # approach better.\n    # An alternative implementation is to use a `_getattr__`/`__getattribute__`\n    # proxy, however that adds more overhead and is more tricky to implement.\n\n    __slots__ = (\n        \"_orig\",\n        \"_remove_plugins\",\n    )\n\n    def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:\n        self._orig = orig\n        self._remove_plugins = remove_plugins\n        self.name = orig.name  # type: ignore[misc]\n        self._hookexec = orig._hookexec  # type: ignore[misc]\n\n    @property  # type: ignore[misc]\n    def _hookimpls(self) -> list[HookImpl]:\n        return [\n            impl\n            for impl in self._orig._hookimpls\n            if impl.plugin not in self._remove_plugins\n        ]\n\n    @property\n    def spec(self) -> HookSpec | None:  # type: ignore[override]\n        return self._orig.spec\n\n    @property\n    def _call_history(self) -> _CallHistory | None:  # type: ignore[override]\n        return self._orig._call_history\n\n    def __repr__(self) -> str:\n        return f\"<_SubsetHookCaller {self.name!r}>\"\n\n\n@final\nclass HookImpl:\n    \"\"\"A hook implementation in a :class:`HookCaller`.\"\"\"\n\n    __slots__ = (\n        \"function\",\n        \"argnames\",\n        \"kwargnames\",\n        \"plugin\",\n        \"opts\",\n        \"plugin_name\",\n        \"wrapper\",\n        \"hookwrapper\",\n        \"optionalhook\",\n        \"tryfirst\",\n        \"trylast\",\n    )\n\n    def __init__(\n        self,\n        plugin: _Plugin,\n        plugin_name: str,\n        function: _HookImplFunction[object],\n        hook_impl_opts: HookimplOpts,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        #: The hook implementation function.\n        self.function: Final = function\n        argnames, kwargnames = varnames(self.function)\n        #: The positional parameter names of ``function```.\n        self.argnames: Final = argnames\n        #: The keyword parameter names of ``function```.\n        self.kwargnames: Final = kwargnames\n        #: The plugin which defined this hook implementation.\n        self.plugin: Final = plugin\n        #: The :class:`HookimplOpts` used to configure this hook implementation.\n        self.opts: Final = hook_impl_opts\n        #: The name of the plugin which defined this hook implementation.\n        self.plugin_name: Final = plugin_name\n        #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.\n        self.wrapper: Final = hook_impl_opts[\"wrapper\"]\n        #: Whether the hook implementation is an :ref:`old-style wrapper\n        #: <old_style_hookwrappers>`.\n        self.hookwrapper: Final = hook_impl_opts[\"hookwrapper\"]\n        #: Whether validation against a hook specification is :ref:`optional\n        #: <optionalhook>`.\n        self.optionalhook: Final = hook_impl_opts[\"optionalhook\"]\n        #: Whether to try to order this hook implementation :ref:`first\n        #: <callorder>`.\n        self.tryfirst: Final = hook_impl_opts[\"tryfirst\"]\n        #: Whether to try to order this hook implementation :ref:`last\n        #: <callorder>`.\n        self.trylast: Final = hook_impl_opts[\"trylast\"]\n\n    def __repr__(self) -> str:\n        return f\"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>\"\n\n\n@final\nclass HookSpec:\n    __slots__ = (\n        \"namespace\",\n        \"function\",\n        \"name\",\n        \"argnames\",\n        \"kwargnames\",\n        \"opts\",\n        \"warn_on_impl\",\n        \"warn_on_impl_args\",\n    )\n\n    def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:\n        self.namespace = namespace\n        self.function: Callable[..., object] = getattr(namespace, name)\n        self.name = name\n        self.argnames, self.kwargnames = varnames(self.function)\n        self.opts = opts\n        self.warn_on_impl = opts.get(\"warn_on_impl\")\n        self.warn_on_impl_args = opts.get(\"warn_on_impl_args\")\n", "src/pluggy/_manager.py": "from __future__ import annotations\n\nimport inspect\nimport types\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Final\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Sequence\nfrom typing import TYPE_CHECKING\nimport warnings\n\nfrom . import _tracing\nfrom ._callers import _multicall\nfrom ._hooks import _HookImplFunction\nfrom ._hooks import _Namespace\nfrom ._hooks import _Plugin\nfrom ._hooks import _SubsetHookCaller\nfrom ._hooks import HookCaller\nfrom ._hooks import HookImpl\nfrom ._hooks import HookimplOpts\nfrom ._hooks import HookRelay\nfrom ._hooks import HookspecOpts\nfrom ._hooks import normalize_hookimpl_opts\nfrom ._result import Result\n\n\nif TYPE_CHECKING:\n    # importtlib.metadata import is slow, defer it.\n    import importlib.metadata\n\n\n_BeforeTrace = Callable[[str, Sequence[HookImpl], Mapping[str, Any]], None]\n_AfterTrace = Callable[[Result[Any], str, Sequence[HookImpl], Mapping[str, Any]], None]\n\n\ndef _warn_for_function(warning: Warning, function: Callable[..., object]) -> None:\n    func = cast(types.FunctionType, function)\n    warnings.warn_explicit(\n        warning,\n        type(warning),\n        lineno=func.__code__.co_firstlineno,\n        filename=func.__code__.co_filename,\n    )\n\n\nclass PluginValidationError(Exception):\n    \"\"\"Plugin failed validation.\n\n    :param plugin: The plugin which failed validation.\n    :param message: Error message.\n    \"\"\"\n\n    def __init__(self, plugin: _Plugin, message: str) -> None:\n        super().__init__(message)\n        #: The plugin which failed validation.\n        self.plugin = plugin\n\n\nclass DistFacade:\n    \"\"\"Emulate a pkg_resources Distribution\"\"\"\n\n    def __init__(self, dist: importlib.metadata.Distribution) -> None:\n        self._dist = dist\n\n    @property\n    def project_name(self) -> str:\n        name: str = self.metadata[\"name\"]\n        return name\n\n    def __getattr__(self, attr: str, default=None):\n        return getattr(self._dist, attr, default)\n\n    def __dir__(self) -> list[str]:\n        return sorted(dir(self._dist) + [\"_dist\", \"project_name\"])\n\n\nclass PluginManager:\n    \"\"\"Core class which manages registration of plugin objects and 1:N hook\n    calling.\n\n    You can register new hooks by calling :meth:`add_hookspecs(module_or_class)\n    <PluginManager.add_hookspecs>`.\n\n    You can register plugin objects (which contain hook implementations) by\n    calling :meth:`register(plugin) <PluginManager.register>`.\n\n    For debugging purposes you can call :meth:`PluginManager.enable_tracing`\n    which will subsequently send debug information to the trace helper.\n\n    :param project_name:\n        The short project name. Prefer snake case. Make sure it's unique!\n    \"\"\"\n\n    def __init__(self, project_name: str) -> None:\n        #: The project name.\n        self.project_name: Final = project_name\n        self._name2plugin: Final[dict[str, _Plugin]] = {}\n        self._plugin_distinfo: Final[list[tuple[_Plugin, DistFacade]]] = []\n        #: The \"hook relay\", used to call a hook on all registered plugins.\n        #: See :ref:`calling`.\n        self.hook: Final = HookRelay()\n        #: The tracing entry point. See :ref:`tracing`.\n        self.trace: Final[_tracing.TagTracerSub] = _tracing.TagTracer().get(\n            \"pluginmanage\"\n        )\n        self._inner_hookexec = _multicall\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n    def register(self, plugin: _Plugin, name: str | None = None) -> str | None:\n        \"\"\"Register a plugin and return its name.\n\n        :param name:\n            The name under which to register the plugin. If not specified, a\n            name is generated using :func:`get_canonical_name`.\n\n        :returns:\n            The plugin name. If the name is blocked from registering, returns\n            ``None``.\n\n        If the plugin is already registered, raises a :exc:`ValueError`.\n        \"\"\"\n        plugin_name = name or self.get_canonical_name(plugin)\n\n        if plugin_name in self._name2plugin:\n            if self._name2plugin.get(plugin_name, -1) is None:\n                return None  # blocked plugin, return None to indicate no registration\n            raise ValueError(\n                \"Plugin name already registered: %s=%s\\n%s\"\n                % (plugin_name, plugin, self._name2plugin)\n            )\n\n        if plugin in self._name2plugin.values():\n            raise ValueError(\n                \"Plugin already registered under a different name: %s=%s\\n%s\"\n                % (plugin_name, plugin, self._name2plugin)\n            )\n\n        # XXX if an error happens we should make sure no state has been\n        # changed at point of return\n        self._name2plugin[plugin_name] = plugin\n\n        # register matching hook implementations of the plugin\n        for name in dir(plugin):\n            hookimpl_opts = self.parse_hookimpl_opts(plugin, name)\n            if hookimpl_opts is not None:\n                normalize_hookimpl_opts(hookimpl_opts)\n                method: _HookImplFunction[object] = getattr(plugin, name)\n                hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)\n                name = hookimpl_opts.get(\"specname\") or name\n                hook: HookCaller | None = getattr(self.hook, name, None)\n                if hook is None:\n                    hook = HookCaller(name, self._hookexec)\n                    setattr(self.hook, name, hook)\n                elif hook.has_spec():\n                    self._verify_hook(hook, hookimpl)\n                    hook._maybe_apply_history(hookimpl)\n                hook._add_hookimpl(hookimpl)\n        return plugin_name\n\n    def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:\n        \"\"\"Try to obtain a hook implementation from an item with the given name\n        in the given plugin which is being searched for hook impls.\n\n        :returns:\n            The parsed hookimpl options, or None to skip the given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook implementation are picked up. By default, returns the\n        options for items decorated with :class:`HookimplMarker`.\n        \"\"\"\n        method: object = getattr(plugin, name)\n        if not inspect.isroutine(method):\n            return None\n        try:\n            res: HookimplOpts | None = getattr(\n                method, self.project_name + \"_impl\", None\n            )\n        except Exception:\n            res = {}  # type: ignore[assignment]\n        if res is not None and not isinstance(res, dict):\n            # false positive\n            res = None  # type:ignore[unreachable]\n        return res\n\n    def unregister(\n        self, plugin: _Plugin | None = None, name: str | None = None\n    ) -> Any | None:\n        \"\"\"Unregister a plugin and all of its hook implementations.\n\n        The plugin can be specified either by the plugin object or the plugin\n        name. If both are specified, they must agree.\n\n        Returns the unregistered plugin, or ``None`` if not found.\n        \"\"\"\n        if name is None:\n            assert plugin is not None, \"one of name or plugin needs to be specified\"\n            name = self.get_name(plugin)\n            assert name is not None, \"plugin is not registered\"\n\n        if plugin is None:\n            plugin = self.get_plugin(name)\n            if plugin is None:\n                return None\n\n        hookcallers = self.get_hookcallers(plugin)\n        if hookcallers:\n            for hookcaller in hookcallers:\n                hookcaller._remove_plugin(plugin)\n\n        # if self._name2plugin[name] == None registration was blocked: ignore\n        if self._name2plugin.get(name):\n            assert name is not None\n            del self._name2plugin[name]\n\n        return plugin\n\n    def set_blocked(self, name: str) -> None:\n        \"\"\"Block registrations of the given name, unregister if already registered.\"\"\"\n        self.unregister(name=name)\n        self._name2plugin[name] = None\n\n    def is_blocked(self, name: str) -> bool:\n        \"\"\"Return whether the given plugin name is blocked.\"\"\"\n        return name in self._name2plugin and self._name2plugin[name] is None\n\n    def unblock(self, name: str) -> bool:\n        \"\"\"Unblocks a name.\n\n        Returns whether the name was actually blocked.\n        \"\"\"\n        if self._name2plugin.get(name, -1) is None:\n            del self._name2plugin[name]\n            return True\n        return False\n\n    def add_hookspecs(self, module_or_class: _Namespace) -> None:\n        \"\"\"Add new hook specifications defined in the given ``module_or_class``.\n\n        Functions are recognized as hook specifications if they have been\n        decorated with a matching :class:`HookspecMarker`.\n        \"\"\"\n        names = []\n        for name in dir(module_or_class):\n            spec_opts = self.parse_hookspec_opts(module_or_class, name)\n            if spec_opts is not None:\n                hc: HookCaller | None = getattr(self.hook, name, None)\n                if hc is None:\n                    hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)\n                    setattr(self.hook, name, hc)\n                else:\n                    # Plugins registered this hook without knowing the spec.\n                    hc.set_specification(module_or_class, spec_opts)\n                    for hookfunction in hc.get_hookimpls():\n                        self._verify_hook(hc, hookfunction)\n                names.append(name)\n\n        if not names:\n            raise ValueError(\n                f\"did not find any {self.project_name!r} hooks in {module_or_class!r}\"\n            )\n\n    def parse_hookspec_opts(\n        self, module_or_class: _Namespace, name: str\n    ) -> HookspecOpts | None:\n        \"\"\"Try to obtain a hook specification from an item with the given name\n        in the given module or class which is being searched for hook specs.\n\n        :returns:\n            The parsed hookspec options for defining a hook, or None to skip the\n            given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook specifications are picked up. By default, returns the\n        options for items decorated with :class:`HookspecMarker`.\n        \"\"\"\n        method = getattr(module_or_class, name)\n        opts: HookspecOpts | None = getattr(method, self.project_name + \"_spec\", None)\n        return opts\n\n    def get_plugins(self) -> set[Any]:\n        \"\"\"Return a set of all registered plugin objects.\"\"\"\n        return {x for x in self._name2plugin.values() if x is not None}\n\n    def is_registered(self, plugin: _Plugin) -> bool:\n        \"\"\"Return whether the plugin is already registered.\"\"\"\n        return any(plugin == val for val in self._name2plugin.values())\n\n    def get_canonical_name(self, plugin: _Plugin) -> str:\n        \"\"\"Return a canonical name for a plugin object.\n\n        Note that a plugin may be registered under a different name\n        specified by the caller of :meth:`register(plugin, name) <register>`.\n        To obtain the name of a registered plugin use :meth:`get_name(plugin)\n        <get_name>` instead.\n        \"\"\"\n        name: str | None = getattr(plugin, \"__name__\", None)\n        return name or str(id(plugin))\n\n    def get_plugin(self, name: str) -> Any | None:\n        \"\"\"Return the plugin registered under the given name, if any.\"\"\"\n        return self._name2plugin.get(name)\n\n    def has_plugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n        return self.get_plugin(name) is not None\n\n    def get_name(self, plugin: _Plugin) -> str | None:\n        \"\"\"Return the name the plugin is registered under, or ``None`` if\n        is isn't.\"\"\"\n        for name, val in self._name2plugin.items():\n            if plugin == val:\n                return name\n        return None\n\n    def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:\n        if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper\"\n                % (hookimpl.plugin_name, hook.name),\n            )\n\n        assert hook.spec is not None\n        if hook.spec.warn_on_impl:\n            _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)\n\n        # positional arg checking\n        notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)\n        if notinspec:\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"Argument(s) %s are declared in the hookimpl but \"\n                \"can not be found in the hookspec\"\n                % (\n                    hookimpl.plugin_name,\n                    hook.name,\n                    _formatdef(hookimpl.function),\n                    notinspec,\n                ),\n            )\n\n        if hook.spec.warn_on_impl_args:\n            for hookimpl_argname in hookimpl.argnames:\n                argname_warning = hook.spec.warn_on_impl_args.get(hookimpl_argname)\n                if argname_warning is not None:\n                    _warn_for_function(argname_warning, hookimpl.function)\n\n        if (\n            hookimpl.wrapper or hookimpl.hookwrapper\n        ) and not inspect.isgeneratorfunction(hookimpl.function):\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"Declared as wrapper=True or hookwrapper=True \"\n                \"but function is not a generator function\"\n                % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),\n            )\n\n        if hookimpl.wrapper and hookimpl.hookwrapper:\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"The wrapper=True and hookwrapper=True options are mutually exclusive\"\n                % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),\n            )\n\n    def check_pending(self) -> None:\n        \"\"\"Verify that all hooks which have not been verified against a\n        hook specification are optional, otherwise raise\n        :exc:`PluginValidationError`.\"\"\"\n        for name in self.hook.__dict__:\n            if name[0] != \"_\":\n                hook: HookCaller = getattr(self.hook, name)\n                if not hook.has_spec():\n                    for hookimpl in hook.get_hookimpls():\n                        if not hookimpl.optionalhook:\n                            raise PluginValidationError(\n                                hookimpl.plugin,\n                                \"unknown hook %r in plugin %r\"\n                                % (name, hookimpl.plugin),\n                            )\n\n    def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:\n        \"\"\"Load modules from querying the specified setuptools ``group``.\n\n        :param group:\n            Entry point group to load plugins.\n        :param name:\n            If given, loads only plugins with the given ``name``.\n\n        :return:\n            The number of plugins loaded by this call.\n        \"\"\"\n        import importlib.metadata\n\n        count = 0\n        for dist in list(importlib.metadata.distributions()):\n            for ep in dist.entry_points:\n                if (\n                    ep.group != group\n                    or (name is not None and ep.name != name)\n                    # already registered\n                    or self.get_plugin(ep.name)\n                    or self.is_blocked(ep.name)\n                ):\n                    continue\n                plugin = ep.load()\n                self.register(plugin, name=ep.name)\n                self._plugin_distinfo.append((plugin, DistFacade(dist)))\n                count += 1\n        return count\n\n    def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:\n        \"\"\"Return a list of (plugin, distinfo) pairs for all\n        setuptools-registered plugins.\"\"\"\n        return list(self._plugin_distinfo)\n\n    def list_name_plugin(self) -> list[tuple[str, _Plugin]]:\n        \"\"\"Return a list of (name, plugin) pairs for all registered plugins.\"\"\"\n        return list(self._name2plugin.items())\n\n    def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:\n        \"\"\"Get all hook callers for the specified plugin.\n\n        :returns:\n            The hook callers, or ``None`` if ``plugin`` is not registered in\n            this plugin manager.\n        \"\"\"\n        if self.get_name(plugin) is None:\n            return None\n        hookcallers = []\n        for hookcaller in self.hook.__dict__.values():\n            for hookimpl in hookcaller.get_hookimpls():\n                if hookimpl.plugin is plugin:\n                    hookcallers.append(hookcaller)\n        return hookcallers\n\n    def add_hookcall_monitoring(\n        self, before: _BeforeTrace, after: _AfterTrace\n    ) -> Callable[[], None]:\n        \"\"\"Add before/after tracing functions for all hooks.\n\n        Returns an undo function which, when called, removes the added tracers.\n\n        ``before(hook_name, hook_impls, kwargs)`` will be called ahead\n        of all hook calls and receive a hookcaller instance, a list\n        of HookImpl instances and the keyword arguments for the hook call.\n\n        ``after(outcome, hook_name, hook_impls, kwargs)`` receives the\n        same arguments as ``before`` but also a :class:`~pluggy.Result` object\n        which represents the result of the overall hook call.\n        \"\"\"\n        oldcall = self._inner_hookexec\n\n        def traced_hookexec(\n            hook_name: str,\n            hook_impls: Sequence[HookImpl],\n            caller_kwargs: Mapping[str, object],\n            firstresult: bool,\n        ) -> object | list[object]:\n            before(hook_name, hook_impls, caller_kwargs)\n            outcome = Result.from_call(\n                lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\n            )\n            after(outcome, hook_name, hook_impls, caller_kwargs)\n            return outcome.get_result()\n\n        self._inner_hookexec = traced_hookexec\n\n        def undo() -> None:\n            self._inner_hookexec = oldcall\n\n        return undo\n\n    def enable_tracing(self) -> Callable[[], None]:\n        \"\"\"Enable tracing of hook calls.\n\n        Returns an undo function which, when called, removes the added tracing.\n        \"\"\"\n        hooktrace = self.trace.root.get(\"hook\")\n\n        def before(\n            hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]\n        ) -> None:\n            hooktrace.root.indent += 1\n            hooktrace(hook_name, kwargs)\n\n        def after(\n            outcome: Result[object],\n            hook_name: str,\n            methods: Sequence[HookImpl],\n            kwargs: Mapping[str, object],\n        ) -> None:\n            if outcome.exception is None:\n                hooktrace(\"finish\", hook_name, \"-->\", outcome.get_result())\n            hooktrace.root.indent -= 1\n\n        return self.add_hookcall_monitoring(before, after)\n\n    def subset_hook_caller(\n        self, name: str, remove_plugins: Iterable[_Plugin]\n    ) -> HookCaller:\n        \"\"\"Return a proxy :class:`~pluggy.HookCaller` instance for the named\n        method which manages calls to all registered plugins except the ones\n        from remove_plugins.\"\"\"\n        orig: HookCaller = getattr(self.hook, name)\n        plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}\n        if plugins_to_remove:\n            return _SubsetHookCaller(orig, plugins_to_remove)\n        return orig\n\n\ndef _formatdef(func: Callable[..., object]) -> str:\n    return f\"{func.__name__}{inspect.signature(func)}\"\n", "src/pluggy/__init__.py": "try:\n    from ._version import version as __version__\nexcept ImportError:\n    # broken installation, we don't even try\n    # unknown only works because we do poor mans version compare\n    __version__ = \"unknown\"\n\n__all__ = [\n    \"__version__\",\n    \"PluginManager\",\n    \"PluginValidationError\",\n    \"HookCaller\",\n    \"HookCallError\",\n    \"HookspecOpts\",\n    \"HookimplOpts\",\n    \"HookImpl\",\n    \"HookRelay\",\n    \"HookspecMarker\",\n    \"HookimplMarker\",\n    \"Result\",\n    \"PluggyWarning\",\n    \"PluggyTeardownRaisedWarning\",\n]\n\nfrom ._hooks import HookCaller\nfrom ._hooks import HookImpl\nfrom ._hooks import HookimplMarker\nfrom ._hooks import HookimplOpts\nfrom ._hooks import HookRelay\nfrom ._hooks import HookspecMarker\nfrom ._hooks import HookspecOpts\nfrom ._manager import PluginManager\nfrom ._manager import PluginValidationError\nfrom ._result import HookCallError\nfrom ._result import Result\nfrom ._warnings import PluggyTeardownRaisedWarning\nfrom ._warnings import PluggyWarning\n", "src/pluggy/_result.py": "\"\"\"\nHook wrapper \"result\" utilities.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom types import TracebackType\nfrom typing import Callable\nfrom typing import cast\nfrom typing import final\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TypeVar\n\n\n_ExcInfo = Tuple[Type[BaseException], BaseException, Optional[TracebackType]]\nResultType = TypeVar(\"ResultType\")\n\n\nclass HookCallError(Exception):\n    \"\"\"Hook was called incorrectly.\"\"\"\n\n\n@final\nclass Result(Generic[ResultType]):\n    \"\"\"An object used to inspect and set the result in a :ref:`hook wrapper\n    <hookwrappers>`.\"\"\"\n\n    __slots__ = (\"_result\", \"_exception\", \"_traceback\")\n\n    def __init__(\n        self,\n        result: ResultType | None,\n        exception: BaseException | None,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        self._result = result\n        self._exception = exception\n        # Exception __traceback__ is mutable, this keeps the original.\n        self._traceback = exception.__traceback__ if exception is not None else None\n\n    @property\n    def excinfo(self) -> _ExcInfo | None:\n        \"\"\":meta private:\"\"\"\n        exc = self._exception\n        if exc is None:\n            return None\n        else:\n            return (type(exc), exc, self._traceback)\n\n    @property\n    def exception(self) -> BaseException | None:\n        \"\"\":meta private:\"\"\"\n        return self._exception\n\n    @classmethod\n    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:\n        \"\"\":meta private:\"\"\"\n        __tracebackhide__ = True\n        result = exception = None\n        try:\n            result = func()\n        except BaseException as exc:\n            exception = exc\n        return cls(result, exception)\n\n    def force_result(self, result: ResultType) -> None:\n        \"\"\"Force the result(s) to ``result``.\n\n        If the hook was marked as a ``firstresult`` a single value should\n        be set, otherwise set a (modified) list of results. Any exceptions\n        found during invocation will be deleted.\n\n        This overrides any previous result or exception.\n        \"\"\"\n        self._result = result\n        self._exception = None\n        self._traceback = None\n\n    def force_exception(self, exception: BaseException) -> None:\n        \"\"\"Force the result to fail with ``exception``.\n\n        This overrides any previous result or exception.\n\n        .. versionadded:: 1.1.0\n        \"\"\"\n        self._result = None\n        self._exception = exception\n        self._traceback = exception.__traceback__ if exception is not None else None\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n\n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n            raise exc.with_traceback(tb)\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_Result = Result\n", "src/pluggy/_callers.py": "\"\"\"\nCall loop machinery\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import cast\nfrom typing import Generator\nfrom typing import Mapping\nfrom typing import NoReturn\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nimport warnings\n\nfrom ._hooks import HookImpl\nfrom ._result import HookCallError\nfrom ._result import Result\nfrom ._warnings import PluggyTeardownRaisedWarning\n\n\n# Need to distinguish between old- and new-style hook wrappers.\n# Wrapping with a tuple is the fastest type-safe way I found to do it.\nTeardown = Union[\n    Tuple[Generator[None, Result[object], None], HookImpl],\n    Generator[None, object, object],\n]\n\n\ndef _raise_wrapfail(\n    wrap_controller: (\n        Generator[None, Result[object], None] | Generator[None, object, object]\n    ),\n    msg: str,\n) -> NoReturn:\n    co = wrap_controller.gi_code\n    raise RuntimeError(\n        \"wrap_controller at %r %s:%d %s\"\n        % (co.co_name, co.co_filename, co.co_firstlineno, msg)\n    )\n\n\ndef _warn_teardown_exception(\n    hook_name: str, hook_impl: HookImpl, e: BaseException\n) -> None:\n    msg = \"A plugin raised an exception during an old-style hookwrapper teardown.\\n\"\n    msg += f\"Plugin: {hook_impl.plugin_name}, Hook: {hook_name}\\n\"\n    msg += f\"{type(e).__name__}: {e}\\n\"\n    msg += \"For more information see https://pluggy.readthedocs.io/en/stable/api_reference.html#pluggy.PluggyTeardownRaisedWarning\"  # noqa: E501\n    warnings.warn(PluggyTeardownRaisedWarning(msg), stacklevel=5)\n\n\ndef _multicall(\n    hook_name: str,\n    hook_impls: Sequence[HookImpl],\n    caller_kwargs: Mapping[str, object],\n    firstresult: bool,\n) -> object | list[object]:\n    \"\"\"Execute a call into multiple python functions/methods and return the\n    result(s).\n\n    ``caller_kwargs`` comes from HookCaller.__call__().\n    \"\"\"\n    __tracebackhide__ = True\n    results: list[object] = []\n    exception = None\n    only_new_style_wrappers = True\n    try:  # run impl and wrapper setup functions in a loop\n        teardowns: list[Teardown] = []\n        try:\n            for hook_impl in reversed(hook_impls):\n                try:\n                    args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                except KeyError:\n                    for argname in hook_impl.argnames:\n                        if argname not in caller_kwargs:\n                            raise HookCallError(\n                                f\"hook call must provide argument {argname!r}\"\n                            )\n\n                if hook_impl.hookwrapper:\n                    only_new_style_wrappers = False\n                    try:\n                        # If this cast is not valid, a type error is raised below,\n                        # which is the desired response.\n                        res = hook_impl.function(*args)\n                        wrapper_gen = cast(Generator[None, Result[object], None], res)\n                        next(wrapper_gen)  # first yield\n                        teardowns.append((wrapper_gen, hook_impl))\n                    except StopIteration:\n                        _raise_wrapfail(wrapper_gen, \"did not yield\")\n                elif hook_impl.wrapper:\n                    try:\n                        # If this cast is not valid, a type error is raised below,\n                        # which is the desired response.\n                        res = hook_impl.function(*args)\n                        function_gen = cast(Generator[None, object, object], res)\n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n                    except StopIteration:\n                        _raise_wrapfail(function_gen, \"did not yield\")\n                else:\n                    res = hook_impl.function(*args)\n                    if res is not None:\n                        results.append(res)\n                        if firstresult:  # halt further impl calls\n                            break\n        except BaseException as exc:\n            exception = exc\n    finally:\n        # Fast path - only new-style wrappers, no Result.\n        if only_new_style_wrappers:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n\n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        teardown.throw(exception)  # type: ignore[union-attr]\n                    else:\n                        teardown.send(result)  # type: ignore[union-attr]\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()  # type: ignore[union-attr]\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n            if exception is not None:\n                raise exception\n            else:\n                return result\n\n        # Slow path - need to support old-style wrappers.\n        else:\n            if firstresult:  # first result hooks return a single value\n                outcome: Result[object | list[object]] = Result(\n                    results[0] if results else None, exception\n                )\n            else:\n                outcome = Result(results, exception)\n\n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                if isinstance(teardown, tuple):\n                    try:\n                        teardown[0].send(outcome)\n                    except StopIteration:\n                        pass\n                    except BaseException as e:\n                        _warn_teardown_exception(hook_name, teardown[1], e)\n                        raise\n                    else:\n                        _raise_wrapfail(teardown[0], \"has second yield\")\n                else:\n                    try:\n                        if outcome._exception is not None:\n                            teardown.throw(outcome._exception)\n                        else:\n                            teardown.send(outcome._result)\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()\n                    except StopIteration as si:\n                        outcome.force_result(si.value)\n                        continue\n                    except BaseException as e:\n                        outcome.force_exception(e)\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")\n\n            return outcome.get_result()\n"}