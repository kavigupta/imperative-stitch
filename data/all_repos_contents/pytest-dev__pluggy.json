{"setup.py": "from setuptools import setup\n\n\nif __name__ == \"__main__\":\n    setup(use_scm_version={\"write_to\": \"src/pluggy/_version.py\"})\n", "scripts/release.py": "\"\"\"\nRelease script.\n\"\"\"\n\nimport argparse\nfrom subprocess import check_call\nimport sys\n\nfrom colorama import Fore\nfrom colorama import init\nfrom git import Remote\nfrom git import Repo\n\n\ndef create_branch(version):\n    \"\"\"Create a fresh branch from upstream/main\"\"\"\n    repo = Repo.init(\".\")\n    if repo.is_dirty(untracked_files=True):\n        raise RuntimeError(\"Repository is dirty, please commit/stash your changes.\")\n\n    branch_name = f\"release-{version}\"\n    print(f\"{Fore.CYAN}Create {branch_name} branch from upstream main\")\n    upstream = get_upstream(repo)\n    upstream.fetch()\n    release_branch = repo.create_head(branch_name, upstream.refs.main, force=True)\n    release_branch.checkout()\n    return repo\n\n\ndef get_upstream(repo: Repo) -> Remote:\n    \"\"\"Find upstream repository for pluggy on the remotes\"\"\"\n    for remote in repo.remotes:\n        for url in remote.urls:\n            if url.endswith((\"pytest-dev/pluggy.git\", \"pytest-dev/pluggy\")):\n                return remote\n    raise RuntimeError(\"could not find pytest-dev/pluggy remote\")\n\n\ndef pre_release(version):\n    \"\"\"Generates new docs, release announcements and creates a local tag.\"\"\"\n    create_branch(version)\n    changelog(version, write_out=True)\n\n    check_call([\"git\", \"commit\", \"-a\", \"-m\", f\"Preparing release {version}\"])\n\n    print()\n    print(f\"{Fore.GREEN}Please push your branch to your fork and open a PR.\")\n\n\ndef changelog(version, write_out=False):\n    if write_out:\n        addopts = []\n    else:\n        addopts = [\"--draft\"]\n    print(f\"{Fore.CYAN}Generating CHANGELOG\")\n    check_call([\"towncrier\", \"build\", \"--yes\", \"--version\", version] + addopts)\n\n\ndef main():\n    init(autoreset=True)\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"version\", help=\"Release version\")\n    options = parser.parse_args()\n    try:\n        pre_release(options.version)\n    except RuntimeError as e:\n        print(f\"{Fore.RED}ERROR: {e}\")\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "scripts/towncrier-draft-to-file.py": "from subprocess import call\nimport sys\n\n\ndef main():\n    \"\"\"\n    Platform agnostic wrapper script for towncrier.\n    Fixes the issue (pytest#7251) where windows users are unable to natively\n    run tox -e docs to build pytest docs.\n    \"\"\"\n    with open(\"docs/_changelog_towncrier_draft.rst\", \"w\") as draft_file:\n        return call((\"towncrier\", \"--draft\"), stdout=draft_file)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "docs/conf.py": "from importlib import metadata\nfrom typing import TYPE_CHECKING\n\n\nif TYPE_CHECKING:\n    import sphinx.application\n\n\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.viewcode\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\nsource_suffix = \".rst\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\n\nproject = \"pluggy\"\ncopyright = \"2016, Holger Krekel\"\nauthor = \"Holger Krekel\"\n\nrelease = metadata.version(project)\n# The short X.Y version.\nversion = \".\".join(release.split(\".\")[:2])\n\n\nlanguage = \"en\"\n\npygments_style = \"sphinx\"\n# html_logo = \"_static/img/plug.png\"\nhtml_theme = \"alabaster\"\nhtml_theme_options = {\n    \"logo\": \"img/plug.png\",\n    \"description\": \"The pytest plugin system\",\n    \"github_user\": \"pytest-dev\",\n    \"github_repo\": \"pluggy\",\n    \"github_button\": \"true\",\n    \"github_banner\": \"true\",\n    \"github_type\": \"star\",\n    \"badge_branch\": \"main\",\n    \"page_width\": \"1080px\",\n    \"sidebar_width\": \"300px\",\n    \"fixed_sidebar\": \"false\",\n}\nhtml_sidebars = {\n    \"**\": [\"about.html\", \"localtoc.html\", \"relations.html\", \"searchbox.html\"]\n}\nhtml_static_path = [\"_static\"]\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, \"pluggy\", \"pluggy Documentation\", [author], 1)]\n\nautodoc_member_order = \"bysource\"\n\nnitpicky = True\nnitpick_ignore = {\n    # Don't want to expose this yet (see #428).\n    (\"py:class\", \"pluggy._tracing.TagTracerSub\"),\n    # Compat hack, don't want to expose it.\n    (\"py:class\", \"pluggy._manager.DistFacade\"),\n    # `types.ModuleType` turns into `module` but then fails to resolve...\n    (\"py:class\", \"module\"),\n    # Just a TypeVar.\n    (\"py:obj\", \"pluggy._result.ResultType\"),\n    (\"py:class\", \"pluggy._result.ResultType\"),\n}\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"pluggy\",\n        \"pluggy Documentation\",\n        author,\n        \"pluggy\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    )\n]\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"pytest\": (\"https://docs.pytest.org/en/latest\", None),\n    \"setuptools\": (\"https://setuptools.pypa.io/en/latest\", None),\n    \"tox\": (\"https://tox.wiki/en/latest\", None),\n    \"devpi\": (\"https://devpi.net/docs/devpi/devpi/stable/+doc/\", None),\n    \"kedro\": (\"https://docs.kedro.org/en/latest/\", None),\n}\n\n\ndef configure_logging(app: \"sphinx.application.Sphinx\") -> None:\n    \"\"\"Configure Sphinx's WarningHandler to handle (expected) missing include.\"\"\"\n    import logging\n\n    import sphinx.util.logging\n\n    class WarnLogFilter(logging.Filter):\n        def filter(self, record: logging.LogRecord) -> bool:\n            \"\"\"Ignore warnings about missing include with \"only\" directive.\n\n            Ref: https://github.com/sphinx-doc/sphinx/issues/2150.\"\"\"\n            if (\n                record.msg.startswith('Problems with \"include\" directive path:')\n                and \"_changelog_towncrier_draft.rst\" in record.msg\n            ):\n                return False\n            return True\n\n    logger = logging.getLogger(sphinx.util.logging.NAMESPACE)\n    warn_handler = [x for x in logger.handlers if x.level == logging.WARNING]\n    assert len(warn_handler) == 1, warn_handler\n    warn_handler[0].filters.insert(0, WarnLogFilter())\n\n\ndef setup(app: \"sphinx.application.Sphinx\") -> None:\n    configure_logging(app)\n", "docs/examples/toy-example.py": "import pluggy\n\n\nhookspec = pluggy.HookspecMarker(\"myproject\")\nhookimpl = pluggy.HookimplMarker(\"myproject\")\n\n\nclass MySpec:\n    \"\"\"A hook specification namespace.\"\"\"\n\n    @hookspec\n    def myhook(self, arg1, arg2):\n        \"\"\"My special little hook that you can customize.\"\"\"\n\n\nclass Plugin_1:\n    \"\"\"A hook implementation namespace.\"\"\"\n\n    @hookimpl\n    def myhook(self, arg1, arg2):\n        print(\"inside Plugin_1.myhook()\")\n        return arg1 + arg2\n\n\nclass Plugin_2:\n    \"\"\"A 2nd hook implementation namespace.\"\"\"\n\n    @hookimpl\n    def myhook(self, arg1, arg2):\n        print(\"inside Plugin_2.myhook()\")\n        return arg1 - arg2\n\n\n# create a manager and add the spec\npm = pluggy.PluginManager(\"myproject\")\npm.add_hookspecs(MySpec)\n# register plugins\npm.register(Plugin_1())\npm.register(Plugin_2())\n# call our `myhook` hook\nresults = pm.hook.myhook(arg1=1, arg2=2)\nprint(results)\n", "docs/examples/eggsample-spam/setup.py": "from setuptools import setup\n\n\nsetup(\n    name=\"eggsample-spam\",\n    install_requires=\"eggsample\",\n    entry_points={\"eggsample\": [\"spam = eggsample_spam\"]},\n    py_modules=[\"eggsample_spam\"],\n)\n", "docs/examples/eggsample-spam/eggsample_spam.py": "import eggsample\n\n\n@eggsample.hookimpl\ndef eggsample_add_ingredients(ingredients):\n    \"\"\"Here the caller expects us to return a list.\"\"\"\n    if \"egg\" in ingredients:\n        spam = [\"lovely spam\", \"wonderous spam\"]\n    else:\n        spam = [\"splendiferous spam\", \"magnificent spam\"]\n    return spam\n\n\n@eggsample.hookimpl\ndef eggsample_prep_condiments(condiments):\n    \"\"\"Here the caller passes a mutable object, so we mess with it directly.\"\"\"\n    try:\n        del condiments[\"steak sauce\"]\n    except KeyError:\n        pass\n    condiments[\"spam sauce\"] = 42\n    return \"Now this is what I call a condiments tray!\"\n", "docs/examples/eggsample/setup.py": "from setuptools import find_packages\nfrom setuptools import setup\n\n\nsetup(\n    name=\"eggsample\",\n    install_requires=\"pluggy>=0.3,<1.0\",\n    entry_points={\"console_scripts\": [\"eggsample=eggsample.host:main\"]},\n    packages=find_packages(),\n)\n", "docs/examples/eggsample/eggsample/lib.py": "import eggsample\n\n\n@eggsample.hookimpl\ndef eggsample_add_ingredients():\n    spices = [\"salt\", \"pepper\"]\n    you_can_never_have_enough_eggs = [\"egg\", \"egg\"]\n    ingredients = spices + you_can_never_have_enough_eggs\n    return ingredients\n\n\n@eggsample.hookimpl\ndef eggsample_prep_condiments(condiments):\n    condiments[\"mint sauce\"] = 1\n", "docs/examples/eggsample/eggsample/hookspecs.py": "import pluggy\n\n\nhookspec = pluggy.HookspecMarker(\"eggsample\")\n\n\n@hookspec\ndef eggsample_add_ingredients(ingredients: tuple):\n    \"\"\"Have a look at the ingredients and offer your own.\n\n    :param ingredients: the ingredients, don't touch them!\n    :return: a list of ingredients\n    \"\"\"\n\n\n@hookspec\ndef eggsample_prep_condiments(condiments: dict):\n    \"\"\"Reorganize the condiments tray to your heart's content.\n\n    :param condiments: some sauces and stuff\n    :return: a witty comment about your activity\n    \"\"\"\n", "docs/examples/eggsample/eggsample/__init__.py": "import pluggy\n\n\nhookimpl = pluggy.HookimplMarker(\"eggsample\")\n\"\"\"Marker to be imported and used in plugins (and for own implementations)\"\"\"\n", "docs/examples/eggsample/eggsample/host.py": "import itertools\nimport random\n\nfrom eggsample import hookspecs\nfrom eggsample import lib\n\nimport pluggy\n\n\ncondiments_tray = {\"pickled walnuts\": 13, \"steak sauce\": 4, \"mushy peas\": 2}\n\n\ndef main():\n    pm = get_plugin_manager()\n    cook = EggsellentCook(pm.hook)\n    cook.add_ingredients()\n    cook.prepare_the_food()\n    cook.serve_the_food()\n\n\ndef get_plugin_manager():\n    pm = pluggy.PluginManager(\"eggsample\")\n    pm.add_hookspecs(hookspecs)\n    pm.load_setuptools_entrypoints(\"eggsample\")\n    pm.register(lib)\n    return pm\n\n\nclass EggsellentCook:\n    FAVORITE_INGREDIENTS = (\"egg\", \"egg\", \"egg\")\n\n    def __init__(self, hook):\n        self.hook = hook\n        self.ingredients = None\n\n    def add_ingredients(self):\n        results = self.hook.eggsample_add_ingredients(\n            ingredients=self.FAVORITE_INGREDIENTS\n        )\n        my_ingredients = list(self.FAVORITE_INGREDIENTS)\n        # Each hook returns a list - so we chain this list of lists\n        other_ingredients = list(itertools.chain(*results))\n        self.ingredients = my_ingredients + other_ingredients\n\n    def prepare_the_food(self):\n        random.shuffle(self.ingredients)\n\n    def serve_the_food(self):\n        condiment_comments = self.hook.eggsample_prep_condiments(\n            condiments=condiments_tray\n        )\n        print(f\"Your food. Enjoy some {', '.join(self.ingredients)}\")\n        print(f\"Some condiments? We have {', '.join(condiments_tray.keys())}\")\n        if any(condiment_comments):\n            print(\"\\n\".join(condiment_comments))\n\n\nif __name__ == \"__main__\":\n    main()\n", "testing/test_helpers.py": "from functools import wraps\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import TypeVar\n\nfrom pluggy._hooks import varnames\nfrom pluggy._manager import _formatdef\n\n\ndef test_varnames() -> None:\n    def f(x) -> None:\n        i = 3  # noqa\n\n    class A:\n        def f(self, y) -> None:\n            pass\n\n    class B:\n        def __call__(self, z) -> None:\n            pass\n\n    assert varnames(f) == ((\"x\",), ())\n    assert varnames(A().f) == ((\"y\",), ())\n    assert varnames(B()) == ((\"z\",), ())\n\n\ndef test_varnames_default() -> None:\n    def f(x, y=3) -> None:\n        pass\n\n    assert varnames(f) == ((\"x\",), (\"y\",))\n\n\ndef test_varnames_class() -> None:\n    class C:\n        def __init__(self, x) -> None:\n            pass\n\n    class D:\n        pass\n\n    class E:\n        def __init__(self, x) -> None:\n            pass\n\n    class F:\n        pass\n\n    assert varnames(C) == ((\"x\",), ())\n    assert varnames(D) == ((), ())\n    assert varnames(E) == ((\"x\",), ())\n    assert varnames(F) == ((), ())\n\n\ndef test_varnames_keyword_only() -> None:\n    def f1(x, *, y) -> None:\n        pass\n\n    def f2(x, *, y=3) -> None:\n        pass\n\n    def f3(x=1, *, y=3) -> None:\n        pass\n\n    assert varnames(f1) == ((\"x\",), ())\n    assert varnames(f2) == ((\"x\",), ())\n    assert varnames(f3) == ((), (\"x\",))\n\n\ndef test_formatdef() -> None:\n    def function1():\n        pass\n\n    assert _formatdef(function1) == \"function1()\"\n\n    def function2(arg1):\n        pass\n\n    assert _formatdef(function2) == \"function2(arg1)\"\n\n    def function3(arg1, arg2=\"qwe\"):\n        pass\n\n    assert _formatdef(function3) == \"function3(arg1, arg2='qwe')\"\n\n    def function4(arg1, *args, **kwargs):\n        pass\n\n    assert _formatdef(function4) == \"function4(arg1, *args, **kwargs)\"\n\n\ndef test_varnames_decorator() -> None:\n    F = TypeVar(\"F\", bound=Callable[..., Any])\n\n    def my_decorator(func: F) -> F:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n\n        return cast(F, wrapper)\n\n    @my_decorator\n    def example(a, b=123) -> None:\n        pass\n\n    class Example:\n        @my_decorator\n        def example_method(self, x, y=1) -> None:\n            pass\n\n    ex_inst = Example()\n\n    assert varnames(example) == ((\"a\",), (\"b\",))\n    assert varnames(Example.example_method) == ((\"x\",), (\"y\",))\n    assert varnames(ex_inst.example_method) == ((\"x\",), (\"y\",))\n", "testing/test_multicall.py": "from typing import Callable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Sequence\nfrom typing import Type\nfrom typing import Union\n\nimport pytest\n\nfrom pluggy import HookCallError\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy._callers import _multicall\nfrom pluggy._hooks import HookImpl\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\ndef MC(\n    methods: Sequence[Callable[..., object]],\n    kwargs: Mapping[str, object],\n    firstresult: bool = False,\n) -> Union[object, List[object]]:\n    caller = _multicall\n    hookfuncs = []\n    for method in methods:\n        f = HookImpl(None, \"<temp>\", method, method.example_impl)  # type: ignore[attr-defined]\n        hookfuncs.append(f)\n    return caller(\"foo\", hookfuncs, kwargs, firstresult)\n\n\ndef test_keyword_args() -> None:\n    @hookimpl\n    def f(x):\n        return x + 1\n\n    class A:\n        @hookimpl\n        def f(self, x, y):\n            return x + y\n\n    reslist = MC([f, A().f], dict(x=23, y=24))\n    assert reslist == [24 + 23, 24]\n\n\ndef test_keyword_args_with_defaultargs() -> None:\n    @hookimpl\n    def f(x, z=1):\n        return x + z\n\n    reslist = MC([f], dict(x=23, y=24))\n    assert reslist == [24]\n\n\ndef test_tags_call_error() -> None:\n    @hookimpl\n    def f(x):\n        return x\n\n    with pytest.raises(HookCallError):\n        MC([f], {})\n\n\ndef test_call_none_is_no_result() -> None:\n    @hookimpl\n    def m1():\n        return 1\n\n    @hookimpl\n    def m2():\n        return None\n\n    res = MC([m1, m2], {}, firstresult=True)\n    assert res == 1\n    res = MC([m1, m2], {}, firstresult=False)\n    assert res == [1]\n\n\ndef test_hookwrapper() -> None:\n    out = []\n\n    @hookimpl(hookwrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        yield None\n        out.append(\"m1 finish\")\n\n    @hookimpl\n    def m2():\n        out.append(\"m2\")\n        return 2\n\n    res = MC([m2, m1], {})\n    assert res == [2]\n    assert out == [\"m1 init\", \"m2\", \"m1 finish\"]\n    out[:] = []\n    res = MC([m2, m1], {}, firstresult=True)\n    assert res == 2\n    assert out == [\"m1 init\", \"m2\", \"m1 finish\"]\n\n\ndef test_hookwrapper_two_yields() -> None:\n    @hookimpl(hookwrapper=True)\n    def m():\n        yield\n        yield\n\n    with pytest.raises(RuntimeError, match=\"has second yield\"):\n        MC([m], {})\n\n\ndef test_wrapper() -> None:\n    out = []\n\n    @hookimpl(wrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        result = yield\n        out.append(\"m1 finish\")\n        return result * 2\n\n    @hookimpl\n    def m2():\n        out.append(\"m2\")\n        return 2\n\n    res = MC([m2, m1], {})\n    assert res == [2, 2]\n    assert out == [\"m1 init\", \"m2\", \"m1 finish\"]\n    out[:] = []\n    res = MC([m2, m1], {}, firstresult=True)\n    assert res == 4\n    assert out == [\"m1 init\", \"m2\", \"m1 finish\"]\n\n\ndef test_wrapper_two_yields() -> None:\n    @hookimpl(wrapper=True)\n    def m():\n        yield\n        yield\n\n    with pytest.raises(RuntimeError, match=\"has second yield\"):\n        MC([m], {})\n\n\ndef test_hookwrapper_order() -> None:\n    out = []\n\n    @hookimpl(hookwrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        yield 1\n        out.append(\"m1 finish\")\n\n    @hookimpl(wrapper=True)\n    def m2():\n        out.append(\"m2 init\")\n        result = yield 2\n        out.append(\"m2 finish\")\n        return result\n\n    @hookimpl(hookwrapper=True)\n    def m3():\n        out.append(\"m3 init\")\n        yield 3\n        out.append(\"m3 finish\")\n\n    @hookimpl(hookwrapper=True)\n    def m4():\n        out.append(\"m4 init\")\n        yield 4\n        out.append(\"m4 finish\")\n\n    res = MC([m4, m3, m2, m1], {})\n    assert res == []\n    assert out == [\n        \"m1 init\",\n        \"m2 init\",\n        \"m3 init\",\n        \"m4 init\",\n        \"m4 finish\",\n        \"m3 finish\",\n        \"m2 finish\",\n        \"m1 finish\",\n    ]\n\n\ndef test_hookwrapper_not_yield() -> None:\n    @hookimpl(hookwrapper=True)\n    def m1():\n        pass\n\n    with pytest.raises(TypeError):\n        MC([m1], {})\n\n\ndef test_hookwrapper_yield_not_executed() -> None:\n    @hookimpl(hookwrapper=True)\n    def m1():\n        if False:\n            yield  # type: ignore[unreachable]\n\n    with pytest.raises(RuntimeError, match=\"did not yield\"):\n        MC([m1], {})\n\n\ndef test_hookwrapper_too_many_yield() -> None:\n    @hookimpl(hookwrapper=True)\n    def m1():\n        yield 1\n        yield 2\n\n    with pytest.raises(RuntimeError) as ex:\n        MC([m1], {})\n    assert \"m1\" in str(ex.value)\n    assert (__file__ + \":\") in str(ex.value)\n\n\ndef test_wrapper_yield_not_executed() -> None:\n    @hookimpl(wrapper=True)\n    def m1():\n        if False:\n            yield  # type: ignore[unreachable]\n\n    with pytest.raises(RuntimeError, match=\"did not yield\"):\n        MC([m1], {})\n\n\ndef test_wrapper_too_many_yield() -> None:\n    out = []\n\n    @hookimpl(wrapper=True)\n    def m1():\n        try:\n            yield 1\n            yield 2\n        finally:\n            out.append(\"cleanup\")\n\n    with pytest.raises(RuntimeError) as ex:\n        try:\n            MC([m1], {})\n        finally:\n            out.append(\"finally\")\n    assert \"m1\" in str(ex.value)\n    assert (__file__ + \":\") in str(ex.value)\n    assert out == [\"cleanup\", \"finally\"]\n\n\n@pytest.mark.parametrize(\"exc\", [ValueError, SystemExit])\ndef test_hookwrapper_exception(exc: \"Type[BaseException]\") -> None:\n    out = []\n\n    @hookimpl(hookwrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        result = yield\n        assert isinstance(result.exception, exc)\n        assert result.excinfo[0] == exc\n        out.append(\"m1 finish\")\n\n    @hookimpl\n    def m2():\n        raise exc\n\n    with pytest.raises(exc):\n        MC([m2, m1], {})\n    assert out == [\"m1 init\", \"m1 finish\"]\n\n\ndef test_hookwrapper_force_exception() -> None:\n    out = []\n\n    @hookimpl(hookwrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        result = yield\n        try:\n            result.get_result()\n        except BaseException as exc:\n            result.force_exception(exc)\n        out.append(\"m1 finish\")\n\n    @hookimpl(hookwrapper=True)\n    def m2():\n        out.append(\"m2 init\")\n        result = yield\n        try:\n            result.get_result()\n        except BaseException as exc:\n            new_exc = OSError(\"m2\")\n            new_exc.__cause__ = exc\n            result.force_exception(new_exc)\n        out.append(\"m2 finish\")\n\n    @hookimpl(hookwrapper=True)\n    def m3():\n        out.append(\"m3 init\")\n        yield\n        out.append(\"m3 finish\")\n\n    @hookimpl\n    def m4():\n        raise ValueError(\"m4\")\n\n    with pytest.raises(OSError, match=\"m2\") as excinfo:\n        MC([m4, m3, m2, m1], {})\n    assert out == [\n        \"m1 init\",\n        \"m2 init\",\n        \"m3 init\",\n        \"m3 finish\",\n        \"m2 finish\",\n        \"m1 finish\",\n    ]\n    assert excinfo.value.__cause__ is not None\n    assert str(excinfo.value.__cause__) == \"m4\"\n\n\n@pytest.mark.parametrize(\"exc\", [ValueError, SystemExit])\ndef test_wrapper_exception(exc: \"Type[BaseException]\") -> None:\n    out = []\n\n    @hookimpl(wrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        try:\n            result = yield\n        except BaseException as e:\n            assert isinstance(e, exc)\n            raise\n        finally:\n            out.append(\"m1 finish\")\n        return result\n\n    @hookimpl\n    def m2():\n        out.append(\"m2 init\")\n        raise exc\n\n    with pytest.raises(exc):\n        MC([m2, m1], {})\n    assert out == [\"m1 init\", \"m2 init\", \"m1 finish\"]\n\n\ndef test_wrapper_exception_chaining() -> None:\n    @hookimpl\n    def m1():\n        raise Exception(\"m1\")\n\n    @hookimpl(wrapper=True)\n    def m2():\n        try:\n            yield\n        except Exception:\n            raise Exception(\"m2\")\n\n    @hookimpl(wrapper=True)\n    def m3():\n        yield\n        return 10\n\n    @hookimpl(wrapper=True)\n    def m4():\n        try:\n            yield\n        except Exception as e:\n            raise Exception(\"m4\") from e\n\n    with pytest.raises(Exception) as excinfo:\n        MC([m1, m2, m3, m4], {})\n    assert str(excinfo.value) == \"m4\"\n    assert excinfo.value.__cause__ is not None\n    assert str(excinfo.value.__cause__) == \"m2\"\n    assert excinfo.value.__cause__.__context__ is not None\n    assert str(excinfo.value.__cause__.__context__) == \"m1\"\n\n\ndef test_unwind_inner_wrapper_teardown_exc() -> None:\n    out = []\n\n    @hookimpl(wrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        try:\n            yield\n            out.append(\"m1 unreachable\")\n        except BaseException:\n            out.append(\"m1 teardown\")\n            raise\n        finally:\n            out.append(\"m1 cleanup\")\n\n    @hookimpl(wrapper=True)\n    def m2():\n        out.append(\"m2 init\")\n        yield\n        out.append(\"m2 raise\")\n        raise ValueError()\n\n    with pytest.raises(ValueError):\n        try:\n            MC([m2, m1], {})\n        finally:\n            out.append(\"finally\")\n\n    assert out == [\n        \"m1 init\",\n        \"m2 init\",\n        \"m2 raise\",\n        \"m1 teardown\",\n        \"m1 cleanup\",\n        \"finally\",\n    ]\n\n\ndef test_suppress_inner_wrapper_teardown_exc() -> None:\n    out = []\n\n    @hookimpl(wrapper=True)\n    def m1():\n        out.append(\"m1 init\")\n        result = yield\n        out.append(\"m1 finish\")\n        return result\n\n    @hookimpl(wrapper=True)\n    def m2():\n        out.append(\"m2 init\")\n        try:\n            yield\n            out.append(\"m2 unreachable\")\n        except ValueError:\n            out.append(\"m2 suppress\")\n            return 22\n\n    @hookimpl(wrapper=True)\n    def m3():\n        out.append(\"m3 init\")\n        yield\n        out.append(\"m3 raise\")\n        raise ValueError()\n\n    assert MC([m3, m2, m1], {}) == 22\n    assert out == [\n        \"m1 init\",\n        \"m2 init\",\n        \"m3 init\",\n        \"m3 raise\",\n        \"m2 suppress\",\n        \"m1 finish\",\n    ]\n", "testing/test_warnings.py": "from pathlib import Path\n\nimport pytest\n\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluggyTeardownRaisedWarning\nfrom pluggy import PluginManager\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\ndef test_teardown_raised_warning(pm: PluginManager) -> None:\n    class Api:\n        @hookspec\n        def my_hook(self):\n            raise NotImplementedError()\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def my_hook(self):\n            pass\n\n    class Plugin2:\n        @hookimpl(hookwrapper=True)\n        def my_hook(self):\n            yield\n            1 / 0\n\n    class Plugin3:\n        @hookimpl(hookwrapper=True)\n        def my_hook(self):\n            yield\n\n    pm.register(Plugin1(), \"plugin1\")\n    pm.register(Plugin2(), \"plugin2\")\n    pm.register(Plugin3(), \"plugin3\")\n    with pytest.warns(\n        PluggyTeardownRaisedWarning,\n        match=r\"\\bplugin2\\b.*\\bmy_hook\\b.*\\n.*ZeroDivisionError\",\n    ) as wc:\n        with pytest.raises(ZeroDivisionError):\n            pm.hook.my_hook()\n    assert len(wc.list) == 1\n    assert Path(wc.list[0].filename).name == \"test_warnings.py\"\n", "testing/benchmark.py": "\"\"\"\nBenchmarking and performance tests.\n\"\"\"\n\nimport pytest\n\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\nfrom pluggy._callers import _multicall\nfrom pluggy._hooks import HookImpl\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\n@hookimpl\ndef hook(arg1, arg2, arg3):\n    return arg1, arg2, arg3\n\n\n@hookimpl(wrapper=True)\ndef wrapper(arg1, arg2, arg3):\n    return (yield)\n\n\n@pytest.fixture(params=[10, 100], ids=\"hooks={}\".format)\ndef hooks(request):\n    return [hook for i in range(request.param)]\n\n\n@pytest.fixture(params=[10, 100], ids=\"wrappers={}\".format)\ndef wrappers(request):\n    return [wrapper for i in range(request.param)]\n\n\ndef test_hook_and_wrappers_speed(benchmark, hooks, wrappers):\n    def setup():\n        hook_name = \"foo\"\n        hook_impls = []\n        for method in hooks + wrappers:\n            f = HookImpl(None, \"<temp>\", method, method.example_impl)\n            hook_impls.append(f)\n        caller_kwargs = {\"arg1\": 1, \"arg2\": 2, \"arg3\": 3}\n        firstresult = False\n        return (hook_name, hook_impls, caller_kwargs, firstresult), {}\n\n    benchmark.pedantic(_multicall, setup=setup, rounds=10)\n\n\n@pytest.mark.parametrize(\n    (\"plugins, wrappers, nesting\"),\n    [\n        (1, 1, 0),\n        (1, 1, 1),\n        (1, 1, 5),\n        (1, 5, 1),\n        (1, 5, 5),\n        (5, 1, 1),\n        (5, 1, 5),\n        (5, 5, 1),\n        (5, 5, 5),\n        (20, 20, 0),\n        (100, 100, 0),\n    ],\n)\ndef test_call_hook(benchmark, plugins, wrappers, nesting):\n    pm = PluginManager(\"example\")\n\n    class HookSpec:\n        @hookspec\n        def fun(self, hooks, nesting: int):\n            pass\n\n    class Plugin:\n        def __init__(self, num: int) -> None:\n            self.num = num\n\n        def __repr__(self) -> str:\n            return f\"<Plugin {self.num}>\"\n\n        @hookimpl\n        def fun(self, hooks, nesting: int) -> None:\n            if nesting:\n                hooks.fun(hooks=hooks, nesting=nesting - 1)\n\n    class PluginWrap:\n        def __init__(self, num: int) -> None:\n            self.num = num\n\n        def __repr__(self) -> str:\n            return f\"<PluginWrap {self.num}>\"\n\n        @hookimpl(wrapper=True)\n        def fun(self):\n            return (yield)\n\n    pm.add_hookspecs(HookSpec)\n\n    for i in range(plugins):\n        pm.register(Plugin(i), name=f\"plug_{i}\")\n    for i in range(wrappers):\n        pm.register(PluginWrap(i), name=f\"wrap_plug_{i}\")\n\n    benchmark(pm.hook.fun, hooks=pm.hook, nesting=nesting)\n", "testing/test_hookcaller.py": "from typing import Callable\nfrom typing import Generator\nfrom typing import List\nfrom typing import Sequence\nfrom typing import TypeVar\n\nimport pytest\n\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\nfrom pluggy import PluginValidationError\nfrom pluggy._hooks import HookCaller\nfrom pluggy._hooks import HookImpl\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\n@pytest.fixture\ndef hc(pm: PluginManager) -> HookCaller:\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg: object) -> None:\n            pass\n\n    pm.add_hookspecs(Hooks)\n    return pm.hook.he_method1\n\n\nFuncT = TypeVar(\"FuncT\", bound=Callable[..., object])\n\n\nclass AddMeth:\n    def __init__(self, hc: HookCaller) -> None:\n        self.hc = hc\n\n    def __call__(\n        self,\n        tryfirst: bool = False,\n        trylast: bool = False,\n        hookwrapper: bool = False,\n        wrapper: bool = False,\n    ) -> Callable[[FuncT], FuncT]:\n        def wrap(func: FuncT) -> FuncT:\n            hookimpl(\n                tryfirst=tryfirst,\n                trylast=trylast,\n                hookwrapper=hookwrapper,\n                wrapper=wrapper,\n            )(func)\n            self.hc._add_hookimpl(\n                HookImpl(None, \"<temp>\", func, func.example_impl),  # type: ignore[attr-defined]\n            )\n            return func\n\n        return wrap\n\n\n@pytest.fixture\ndef addmeth(hc: HookCaller) -> AddMeth:\n    return AddMeth(hc)\n\n\ndef funcs(hookmethods: Sequence[HookImpl]) -> List[Callable[..., object]]:\n    return [hookmethod.function for hookmethod in hookmethods]\n\n\ndef test_adding_nonwrappers(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth()\n    def he_method1() -> None:\n        pass\n\n    @addmeth()\n    def he_method2() -> None:\n        pass\n\n    @addmeth()\n    def he_method3() -> None:\n        pass\n\n    assert funcs(hc.get_hookimpls()) == [he_method1, he_method2, he_method3]\n\n\ndef test_adding_nonwrappers_trylast(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth()\n    def he_method1_middle() -> None:\n        pass\n\n    @addmeth(trylast=True)\n    def he_method1() -> None:\n        pass\n\n    @addmeth()\n    def he_method1_b() -> None:\n        pass\n\n    assert funcs(hc.get_hookimpls()) == [he_method1, he_method1_middle, he_method1_b]\n\n\ndef test_adding_nonwrappers_trylast3(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth()\n    def he_method1_a() -> None:\n        pass\n\n    @addmeth(trylast=True)\n    def he_method1_b() -> None:\n        pass\n\n    @addmeth()\n    def he_method1_c() -> None:\n        pass\n\n    @addmeth(trylast=True)\n    def he_method1_d() -> None:\n        pass\n\n    assert funcs(hc.get_hookimpls()) == [\n        he_method1_d,\n        he_method1_b,\n        he_method1_a,\n        he_method1_c,\n    ]\n\n\ndef test_adding_nonwrappers_trylast2(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth()\n    def he_method1_middle() -> None:\n        pass\n\n    @addmeth()\n    def he_method1_b() -> None:\n        pass\n\n    @addmeth(trylast=True)\n    def he_method1() -> None:\n        pass\n\n    assert funcs(hc.get_hookimpls()) == [he_method1, he_method1_middle, he_method1_b]\n\n\ndef test_adding_nonwrappers_tryfirst(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth(tryfirst=True)\n    def he_method1() -> None:\n        pass\n\n    @addmeth()\n    def he_method1_middle() -> None:\n        pass\n\n    @addmeth()\n    def he_method1_b() -> None:\n        pass\n\n    assert funcs(hc.get_hookimpls()) == [he_method1_middle, he_method1_b, he_method1]\n\n\ndef test_adding_wrappers_ordering(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth(hookwrapper=True)\n    def he_method1():\n        yield\n\n    @addmeth(wrapper=True)\n    def he_method1_fun():\n        yield\n\n    @addmeth()\n    def he_method1_middle():\n        return\n\n    @addmeth(hookwrapper=True)\n    def he_method3_fun():\n        yield\n\n    @addmeth(hookwrapper=True)\n    def he_method3():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [\n        he_method1_middle,\n        he_method1,\n        he_method1_fun,\n        he_method3_fun,\n        he_method3,\n    ]\n\n\ndef test_adding_wrappers_ordering_tryfirst(hc: HookCaller, addmeth: AddMeth) -> None:\n    @addmeth(hookwrapper=True, tryfirst=True)\n    def he_method1():\n        yield\n\n    @addmeth(hookwrapper=True)\n    def he_method2():\n        yield\n\n    @addmeth(wrapper=True, tryfirst=True)\n    def he_method3():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [he_method2, he_method1, he_method3]\n\n\ndef test_adding_wrappers_complex(hc: HookCaller, addmeth: AddMeth) -> None:\n    assert funcs(hc.get_hookimpls()) == []\n\n    @addmeth(hookwrapper=True, trylast=True)\n    def m1():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [m1]\n\n    @addmeth()\n    def m2() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m2, m1]\n\n    @addmeth(trylast=True)\n    def m3() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m1]\n\n    @addmeth(hookwrapper=True)\n    def m4() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m1, m4]\n\n    @addmeth(wrapper=True, tryfirst=True)\n    def m5():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m1, m4, m5]\n\n    @addmeth(tryfirst=True)\n    def m6() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m6, m1, m4, m5]\n\n    @addmeth()\n    def m7() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m7, m6, m1, m4, m5]\n\n    @addmeth(wrapper=True)\n    def m8():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [m3, m2, m7, m6, m1, m4, m8, m5]\n\n    @addmeth(trylast=True)\n    def m9() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m9, m3, m2, m7, m6, m1, m4, m8, m5]\n\n    @addmeth(tryfirst=True)\n    def m10() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m9, m3, m2, m7, m6, m10, m1, m4, m8, m5]\n\n    @addmeth(hookwrapper=True, trylast=True)\n    def m11() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [m9, m3, m2, m7, m6, m10, m11, m1, m4, m8, m5]\n\n    @addmeth(wrapper=True)\n    def m12():\n        yield\n\n    assert funcs(hc.get_hookimpls()) == [\n        m9,\n        m3,\n        m2,\n        m7,\n        m6,\n        m10,\n        m11,\n        m1,\n        m4,\n        m8,\n        m12,\n        m5,\n    ]\n\n    @addmeth()\n    def m13() -> None: ...\n\n    assert funcs(hc.get_hookimpls()) == [\n        m9,\n        m3,\n        m2,\n        m7,\n        m13,\n        m6,\n        m10,\n        m11,\n        m1,\n        m4,\n        m8,\n        m12,\n        m5,\n    ]\n\n\ndef test_hookspec(pm: PluginManager) -> None:\n    class HookSpec:\n        @hookspec()\n        def he_myhook1(arg1) -> None:\n            pass\n\n        @hookspec(firstresult=True)\n        def he_myhook2(arg1) -> None:\n            pass\n\n        @hookspec(firstresult=False)\n        def he_myhook3(arg1) -> None:\n            pass\n\n    pm.add_hookspecs(HookSpec)\n    assert pm.hook.he_myhook1.spec is not None\n    assert not pm.hook.he_myhook1.spec.opts[\"firstresult\"]\n    assert pm.hook.he_myhook2.spec is not None\n    assert pm.hook.he_myhook2.spec.opts[\"firstresult\"]\n    assert pm.hook.he_myhook3.spec is not None\n    assert not pm.hook.he_myhook3.spec.opts[\"firstresult\"]\n\n\n@pytest.mark.parametrize(\"name\", [\"hookwrapper\", \"optionalhook\", \"tryfirst\", \"trylast\"])\n@pytest.mark.parametrize(\"val\", [True, False])\ndef test_hookimpl(name: str, val: bool) -> None:\n    @hookimpl(**{name: val})  # type: ignore[misc,call-overload]\n    def he_myhook1(arg1) -> None:\n        pass\n\n    if val:\n        assert he_myhook1.example_impl.get(name)\n    else:\n        assert not hasattr(he_myhook1, name)\n\n\ndef test_hookrelay_registry(pm: PluginManager) -> None:\n    \"\"\"Verify hook caller instances are registered by name onto the relay\n    and can be likewise unregistered.\"\"\"\n\n    class Api:\n        @hookspec\n        def hello(self, arg: object) -> None:\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n    hook = pm.hook\n    assert hasattr(hook, \"hello\")\n    assert repr(hook.hello).find(\"hello\") != -1\n\n    class Plugin:\n        @hookimpl\n        def hello(self, arg):\n            return arg + 1\n\n    plugin = Plugin()\n    pm.register(plugin)\n    out = hook.hello(arg=3)\n    assert out == [4]\n    assert not hasattr(hook, \"world\")\n    pm.unregister(plugin)\n    assert hook.hello(arg=3) == []\n\n\ndef test_hookrelay_registration_by_specname(pm: PluginManager) -> None:\n    \"\"\"Verify hook caller instances may also be registered by specifying a\n    specname option to the hookimpl\"\"\"\n\n    class Api:\n        @hookspec\n        def hello(self, arg: object) -> None:\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n    hook = pm.hook\n    assert hasattr(hook, \"hello\")\n    assert len(pm.hook.hello.get_hookimpls()) == 0\n\n    class Plugin:\n        @hookimpl(specname=\"hello\")\n        def foo(self, arg: int) -> int:\n            return arg + 1\n\n    plugin = Plugin()\n    pm.register(plugin)\n    out = hook.hello(arg=3)\n    assert out == [4]\n\n\ndef test_hookrelay_registration_by_specname_raises(pm: PluginManager) -> None:\n    \"\"\"Verify using specname still raises the types of errors during registration as it\n    would have without using specname.\"\"\"\n\n    class Api:\n        @hookspec\n        def hello(self, arg: object) -> None:\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    # make sure a bad signature still raises an error when using specname\n    class Plugin:\n        @hookimpl(specname=\"hello\")\n        def foo(self, arg: int, too, many, args) -> int:\n            return arg + 1\n\n    with pytest.raises(PluginValidationError):\n        pm.register(Plugin())\n\n    # make sure check_pending still fails if specname doesn't have a\n    # corresponding spec.  EVEN if the function name matches one.\n    class Plugin2:\n        @hookimpl(specname=\"bar\")\n        def hello(self, arg: int) -> int:\n            return arg + 1\n\n    pm.register(Plugin2())\n    with pytest.raises(PluginValidationError):\n        pm.check_pending()\n\n\ndef test_hook_conflict(pm: PluginManager) -> None:\n    class Api1:\n        @hookspec\n        def conflict(self) -> None:\n            \"\"\"Api1 hook\"\"\"\n\n    class Api2:\n        @hookspec\n        def conflict(self) -> None:\n            \"\"\"Api2 hook\"\"\"\n\n    pm.add_hookspecs(Api1)\n    with pytest.raises(ValueError) as exc:\n        pm.add_hookspecs(Api2)\n    assert str(exc.value) == (\n        \"Hook 'conflict' is already registered within namespace \"\n        \"<class 'test_hookcaller.test_hook_conflict.<locals>.Api1'>\"\n    )\n\n\ndef test_call_extra_hook_order(hc: HookCaller, addmeth: AddMeth) -> None:\n    \"\"\"Ensure that call_extra is calling hooks in the right order.\"\"\"\n    order = []\n\n    @addmeth(tryfirst=True)\n    def method1() -> str:\n        order.append(\"1\")\n        return \"1\"\n\n    @addmeth()\n    def method2() -> str:\n        order.append(\"2\")\n        return \"2\"\n\n    @addmeth(trylast=True)\n    def method3() -> str:\n        order.append(\"3\")\n        return \"3\"\n\n    @addmeth(wrapper=True, tryfirst=True)\n    def method4() -> Generator[None, str, str]:\n        order.append(\"4pre\")\n        result = yield\n        order.append(\"4post\")\n        return result\n\n    @addmeth(wrapper=True)\n    def method5() -> Generator[None, str, str]:\n        order.append(\"5pre\")\n        result = yield\n        order.append(\"5post\")\n        return result\n\n    @addmeth(wrapper=True, trylast=True)\n    def method6() -> Generator[None, str, str]:\n        order.append(\"6pre\")\n        result = yield\n        order.append(\"6post\")\n        return result\n\n    def extra1() -> str:\n        order.append(\"extra1\")\n        return \"extra1\"\n\n    def extra2() -> str:\n        order.append(\"extra2\")\n        return \"extra2\"\n\n    result = hc.call_extra([extra1, extra2], {\"arg\": \"test\"})\n    assert order == [\n        \"4pre\",\n        \"5pre\",\n        \"6pre\",\n        \"1\",\n        \"extra2\",\n        \"extra1\",\n        \"2\",\n        \"3\",\n        \"6post\",\n        \"5post\",\n        \"4post\",\n    ]\n    assert result == [\n        \"1\",\n        \"extra2\",\n        \"extra1\",\n        \"2\",\n        \"3\",\n    ]\n", "testing/test_tracer.py": "from typing import List\n\nimport pytest\n\nfrom pluggy._tracing import TagTracer\n\n\n@pytest.fixture\ndef rootlogger() -> TagTracer:\n    return TagTracer()\n\n\ndef test_simple(rootlogger: TagTracer) -> None:\n    log = rootlogger.get(\"pytest\")\n    log(\"hello\")\n    out: List[str] = []\n    rootlogger.setwriter(out.append)\n    log(\"world\")\n    assert len(out) == 1\n    assert out[0] == \"world [pytest]\\n\"\n    sublog = log.get(\"collection\")\n    sublog(\"hello\")\n    assert out[1] == \"hello [pytest:collection]\\n\"\n\n\ndef test_indent(rootlogger: TagTracer) -> None:\n    log = rootlogger.get(\"1\")\n    out = []\n    log.root.setwriter(lambda arg: out.append(arg))\n    log(\"hello\")\n    log.root.indent += 1\n    log(\"line1\")\n    log(\"line2\")\n    log.root.indent += 1\n    log(\"line3\")\n    log(\"line4\")\n    log.root.indent -= 1\n    log(\"line5\")\n    log.root.indent -= 1\n    log(\"last\")\n    assert len(out) == 7\n    names = [x[: x.rfind(\" [\")] for x in out]\n    assert names == [\n        \"hello\",\n        \"  line1\",\n        \"  line2\",\n        \"    line3\",\n        \"    line4\",\n        \"  line5\",\n        \"last\",\n    ]\n\n\ndef test_readable_output_dictargs(rootlogger: TagTracer) -> None:\n    out = rootlogger._format_message([\"test\"], [1])\n    assert out == \"1 [test]\\n\"\n\n    out2 = rootlogger._format_message([\"test\"], [\"test\", {\"a\": 1}])\n    assert out2 == \"test [test]\\n    a: 1\\n\"\n\n\ndef test_setprocessor(rootlogger: TagTracer) -> None:\n    log = rootlogger.get(\"1\")\n    log2 = log.get(\"2\")\n    assert log2.tags == tuple(\"12\")\n    out = []\n    rootlogger.setprocessor(tuple(\"12\"), lambda *args: out.append(args))\n    log(\"not seen\")\n    log2(\"seen\")\n    assert len(out) == 1\n    tags, args = out[0]\n    assert \"1\" in tags\n    assert \"2\" in tags\n    assert args == (\"seen\",)\n    l2 = []\n    rootlogger.setprocessor(\"1:2\", lambda *args: l2.append(args))\n    log2(\"seen\")\n    tags, args = l2[0]\n    assert args == (\"seen\",)\n", "testing/test_invocations.py": "from typing import Iterator\n\nimport pytest\n\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\nfrom pluggy import PluginValidationError\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\ndef test_argmismatch(pm: PluginManager) -> None:\n    class Api:\n        @hookspec\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin:\n        @hookimpl\n        def hello(self, argwrong):\n            pass\n\n    with pytest.raises(PluginValidationError) as exc:\n        pm.register(Plugin())\n\n    assert \"argwrong\" in str(exc.value)\n\n\ndef test_only_kwargs(pm: PluginManager) -> None:\n    class Api:\n        @hookspec\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n    with pytest.raises(TypeError) as exc:\n        pm.hook.hello(3)  # type: ignore[call-arg]\n\n    message = \"__call__() takes 1 positional argument but 2 were given\"\n    assert message in str(exc.value)\n\n\ndef test_opt_in_args(pm: PluginManager) -> None:\n    \"\"\"Verify that two hookimpls with mutex args can serve\n    under the same spec.\n    \"\"\"\n\n    class Api:\n        @hookspec\n        def hello(self, arg1, arg2, common_arg):\n            \"api hook 1\"\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg1, common_arg):\n            return arg1 + common_arg\n\n    class Plugin2:\n        @hookimpl\n        def hello(self, arg2, common_arg):\n            return arg2 + common_arg\n\n    pm.add_hookspecs(Api)\n    pm.register(Plugin1())\n    pm.register(Plugin2())\n\n    results = pm.hook.hello(arg1=1, arg2=2, common_arg=0)\n    assert results == [2, 1]\n\n\ndef test_call_order(pm: PluginManager) -> None:\n    class Api:\n        @hookspec\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg):\n            return 1\n\n    class Plugin2:\n        @hookimpl\n        def hello(self, arg):\n            return 2\n\n    class Plugin3:\n        @hookimpl\n        def hello(self, arg):\n            return 3\n\n    class Plugin4:\n        @hookimpl(hookwrapper=True)\n        def hello(self, arg):\n            assert arg == 0\n            outcome = yield\n            assert outcome.get_result() == [3, 2, 1]\n            assert outcome.exception is None\n            assert outcome.excinfo is None\n\n    class Plugin5:\n        @hookimpl(wrapper=True)\n        def hello(self, arg):\n            assert arg == 0\n            result = yield\n            assert result == [3, 2, 1]\n            return result\n\n    pm.register(Plugin1())\n    pm.register(Plugin2())\n    pm.register(Plugin3())\n    pm.register(Plugin4())  # hookwrapper should get same list result\n    pm.register(Plugin5())  # hookwrapper should get same list result\n    res = pm.hook.hello(arg=0)\n    assert res == [3, 2, 1]\n\n\ndef test_firstresult_definition(pm: PluginManager) -> None:\n    class Api:\n        @hookspec(firstresult=True)\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg):\n            return arg + 1\n\n    class Plugin2:\n        @hookimpl\n        def hello(self, arg):\n            return arg - 1\n\n    class Plugin3:\n        @hookimpl\n        def hello(self, arg):\n            return None\n\n    class Plugin4:\n        @hookimpl(wrapper=True)\n        def hello(self, arg):\n            assert arg == 3\n            outcome = yield\n            assert outcome == 2\n            return outcome\n\n    class Plugin5:\n        @hookimpl(hookwrapper=True)\n        def hello(self, arg):\n            assert arg == 3\n            outcome = yield\n            assert outcome.get_result() == 2\n\n    pm.register(Plugin1())  # discarded - not the last registered plugin\n    pm.register(Plugin2())  # used as result\n    pm.register(Plugin3())  # None result is ignored\n    pm.register(Plugin4())  # wrapper should get same non-list result\n    pm.register(Plugin5())  # hookwrapper should get same non-list result\n    res = pm.hook.hello(arg=3)\n    assert res == 2\n\n\ndef test_firstresult_force_result_hookwrapper(pm: PluginManager) -> None:\n    \"\"\"Verify forcing a result in a wrapper.\"\"\"\n\n    class Api:\n        @hookspec(firstresult=True)\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg):\n            return arg + 1\n\n    class Plugin2:\n        @hookimpl(hookwrapper=True)\n        def hello(self, arg):\n            assert arg == 3\n            outcome = yield\n            assert outcome.get_result() == 4\n            outcome.force_result(0)\n\n    class Plugin3:\n        @hookimpl\n        def hello(self, arg):\n            return None\n\n    pm.register(Plugin1())\n    pm.register(Plugin2())  # wrapper\n    pm.register(Plugin3())  # ignored since returns None\n    res = pm.hook.hello(arg=3)\n    assert res == 0  # this result is forced and not a list\n\n\ndef test_firstresult_force_result(pm: PluginManager) -> None:\n    \"\"\"Verify forcing a result in a wrapper.\"\"\"\n\n    class Api:\n        @hookspec(firstresult=True)\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg):\n            return arg + 1\n\n    class Plugin2:\n        @hookimpl(wrapper=True)\n        def hello(self, arg):\n            assert arg == 3\n            outcome = yield\n            assert outcome == 4\n            return 0\n\n    class Plugin3:\n        @hookimpl\n        def hello(self, arg):\n            return None\n\n    pm.register(Plugin1())\n    pm.register(Plugin2())  # wrapper\n    pm.register(Plugin3())  # ignored since returns None\n    res = pm.hook.hello(arg=3)\n    assert res == 0  # this result is forced and not a list\n\n\ndef test_firstresult_returns_none(pm: PluginManager) -> None:\n    \"\"\"If None results are returned by underlying implementations ensure\n    the multi-call loop returns a None value.\n    \"\"\"\n\n    class Api:\n        @hookspec(firstresult=True)\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self, arg):\n            return None\n\n    pm.register(Plugin1())\n    res = pm.hook.hello(arg=3)\n    assert res is None\n\n\ndef test_firstresult_no_plugin(pm: PluginManager) -> None:\n    \"\"\"If no implementations/plugins have been registered for a firstresult\n    hook the multi-call loop should return a None value.\n    \"\"\"\n\n    class Api:\n        @hookspec(firstresult=True)\n        def hello(self, arg):\n            \"api hook 1\"\n\n    pm.add_hookspecs(Api)\n    res = pm.hook.hello(arg=3)\n    assert res is None\n\n\ndef test_no_hookspec(pm: PluginManager) -> None:\n    \"\"\"A hook with hookimpls can still be called even if no hookspec\n    was registered for it (and call_pending wasn't called to check\n    against it).\n    \"\"\"\n\n    class Plugin:\n        @hookimpl\n        def hello(self, arg):\n            return \"Plugin.hello\"\n\n    pm.register(Plugin())\n\n    assert pm.hook.hello(arg=10, extra=20) == [\"Plugin.hello\"]\n\n\ndef test_non_wrapper_generator(pm: PluginManager) -> None:\n    \"\"\"A hookimpl can be a generator without being a wrapper,\n    meaning it returns an iterator result.\"\"\"\n\n    class Api:\n        @hookspec\n        def hello(self) -> Iterator[int]:\n            raise NotImplementedError()\n\n    pm.add_hookspecs(Api)\n\n    class Plugin1:\n        @hookimpl\n        def hello(self):\n            yield 1\n\n    class Plugin2:\n        @hookimpl\n        def hello(self):\n            yield 2\n            yield 3\n\n    class Plugin3:\n        @hookimpl(wrapper=True)\n        def hello(self):\n            return (yield)\n\n    pm.register(Plugin1())\n    pm.register(Plugin2())  # wrapper\n    res = pm.hook.hello()\n    assert [y for x in res for y in x] == [2, 3, 1]\n    pm.register(Plugin3())\n    res = pm.hook.hello()\n    assert [y for x in res for y in x] == [2, 3, 1]\n", "testing/conftest.py": "import pytest\n\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\n\n@pytest.fixture(\n    params=[lambda spec: spec, lambda spec: spec()],\n    ids=[\"spec-is-class\", \"spec-is-instance\"],\n)\ndef he_pm(request, pm: PluginManager) -> PluginManager:\n    hookspec = HookspecMarker(\"example\")\n\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg: int) -> int:\n            return arg + 1\n\n    pm.add_hookspecs(request.param(Hooks))\n    return pm\n\n\n@pytest.fixture\ndef pm() -> PluginManager:\n    return PluginManager(\"example\")\n", "testing/test_result.py": "import traceback\n\nfrom pluggy import Result\n\n\ndef test_exceptions_traceback_doesnt_get_longer_and_longer() -> None:\n    def bad() -> None:\n        1 / 0\n\n    result = Result.from_call(bad)\n\n    try:\n        result.get_result()\n    except Exception as exc:\n        tb1 = traceback.extract_tb(exc.__traceback__)\n\n    try:\n        result.get_result()\n    except Exception as exc:\n        tb2 = traceback.extract_tb(exc.__traceback__)\n\n    try:\n        result.get_result()\n    except Exception as exc:\n        tb3 = traceback.extract_tb(exc.__traceback__)\n\n    assert len(tb1) == len(tb2) == len(tb3)\n", "testing/test_pluginmanager.py": "\"\"\"\n``PluginManager`` unit and public API testing.\n\"\"\"\n\nimport importlib.metadata\nfrom typing import Any\nfrom typing import List\n\nimport pytest\n\nfrom pluggy import HookCallError\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\nfrom pluggy import PluginValidationError\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\ndef test_plugin_double_register(pm: PluginManager) -> None:\n    \"\"\"Registering the same plugin more then once isn't allowed\"\"\"\n    pm.register(42, name=\"abc\")\n    with pytest.raises(ValueError):\n        pm.register(42, name=\"abc\")\n    with pytest.raises(ValueError):\n        pm.register(42, name=\"def\")\n\n\ndef test_pm(pm: PluginManager) -> None:\n    \"\"\"Basic registration with objects\"\"\"\n\n    class A:\n        pass\n\n    a1, a2 = A(), A()\n    pm.register(a1)\n    assert pm.is_registered(a1)\n    pm.register(a2, \"hello\")\n    assert pm.is_registered(a2)\n    out = pm.get_plugins()\n    assert a1 in out\n    assert a2 in out\n    assert pm.get_plugin(\"hello\") == a2\n    assert pm.unregister(a1) == a1\n    assert not pm.is_registered(a1)\n\n    out2 = pm.list_name_plugin()\n    assert len(out2) == 1\n    assert out2 == [(\"hello\", a2)]\n\n\ndef test_has_plugin(pm: PluginManager) -> None:\n    class A:\n        pass\n\n    a1 = A()\n    pm.register(a1, \"hello\")\n    assert pm.is_registered(a1)\n    assert pm.has_plugin(\"hello\")\n\n\ndef test_register_dynamic_attr(he_pm: PluginManager) -> None:\n    class A:\n        def __getattr__(self, name):\n            if name[0] != \"_\":\n                return 42\n            raise AttributeError()\n\n    a = A()\n    he_pm.register(a)\n    assert not he_pm.get_hookcallers(a)\n\n\ndef test_pm_name(pm: PluginManager) -> None:\n    class A:\n        pass\n\n    a1 = A()\n    name = pm.register(a1, name=\"hello\")\n    assert name == \"hello\"\n    pm.unregister(a1)\n    assert pm.get_plugin(\"hello\") is None\n    assert not pm.is_registered(a1)\n    assert not pm.get_plugins()\n    name2 = pm.register(a1, name=\"hello\")\n    assert name2 == name\n    pm.unregister(name=\"hello\")\n    assert pm.get_plugin(\"hello\") is None\n    assert not pm.is_registered(a1)\n    assert not pm.get_plugins()\n\n\ndef test_set_blocked(pm: PluginManager) -> None:\n    class A:\n        pass\n\n    a1 = A()\n    name = pm.register(a1)\n    assert name is not None\n    assert pm.is_registered(a1)\n    assert not pm.is_blocked(name)\n    assert pm.get_plugins() == {a1}\n\n    pm.set_blocked(name)\n    assert pm.is_blocked(name)\n    assert not pm.is_registered(a1)\n    assert pm.get_plugins() == set()\n\n    pm.set_blocked(\"somename\")\n    assert pm.is_blocked(\"somename\")\n    assert not pm.register(A(), \"somename\")\n    pm.unregister(name=\"somename\")\n    assert pm.is_blocked(\"somename\")\n    assert pm.get_plugins() == set()\n\n    # Unblock.\n    assert not pm.unblock(\"someothername\")\n    assert pm.unblock(\"somename\")\n    assert not pm.is_blocked(\"somename\")\n    assert not pm.unblock(\"somename\")\n    assert pm.register(A(), \"somename\")\n\n\ndef test_register_mismatch_method(he_pm: PluginManager) -> None:\n    class hello:\n        @hookimpl\n        def he_method_notexists(self):\n            pass\n\n    plugin = hello()\n\n    he_pm.register(plugin)\n    with pytest.raises(PluginValidationError) as excinfo:\n        he_pm.check_pending()\n    assert excinfo.value.plugin is plugin\n\n\ndef test_register_mismatch_arg(he_pm: PluginManager) -> None:\n    class hello:\n        @hookimpl\n        def he_method1(self, qlwkje):\n            pass\n\n    plugin = hello()\n\n    with pytest.raises(PluginValidationError) as excinfo:\n        he_pm.register(plugin)\n    assert excinfo.value.plugin is plugin\n\n\ndef test_register_hookwrapper_not_a_generator_function(he_pm: PluginManager) -> None:\n    class hello:\n        @hookimpl(hookwrapper=True)\n        def he_method1(self):\n            pass  # pragma: no cover\n\n    plugin = hello()\n\n    with pytest.raises(PluginValidationError, match=\"generator function\") as excinfo:\n        he_pm.register(plugin)\n    assert excinfo.value.plugin is plugin\n\n\ndef test_register_both_wrapper_and_hookwrapper(he_pm: PluginManager) -> None:\n    class hello:\n        @hookimpl(wrapper=True, hookwrapper=True)\n        def he_method1(self):\n            yield  # pragma: no cover\n\n    plugin = hello()\n\n    with pytest.raises(\n        PluginValidationError, match=\"wrapper.*hookwrapper.*mutually exclusive\"\n    ) as excinfo:\n        he_pm.register(plugin)\n    assert excinfo.value.plugin is plugin\n\n\ndef test_register(pm: PluginManager) -> None:\n    class MyPlugin:\n        @hookimpl\n        def he_method1(self): ...\n\n    my = MyPlugin()\n    pm.register(my)\n    assert pm.get_plugins() == {my}\n    my2 = MyPlugin()\n    pm.register(my2)\n    assert pm.get_plugins() == {my, my2}\n\n    assert pm.is_registered(my)\n    assert pm.is_registered(my2)\n    pm.unregister(my)\n    assert not pm.is_registered(my)\n    assert pm.get_plugins() == {my2}\n\n    with pytest.raises(AssertionError, match=r\"not registered\"):\n        pm.unregister(my)\n\n\ndef test_register_unknown_hooks(pm: PluginManager) -> None:\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg + 1\n\n    pname = pm.register(Plugin1())\n    assert pname is not None\n\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n    # assert not pm._unverified_hooks\n    assert pm.hook.he_method1(arg=1) == [2]\n    hookcallers = pm.get_hookcallers(pm.get_plugin(pname))\n    assert hookcallers is not None\n    assert len(hookcallers) == 1\n\n\ndef test_register_historic(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    pm.hook.he_method1.call_historic(kwargs=dict(arg=1))\n    out = []\n\n    class Plugin:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg)\n\n    pm.register(Plugin())\n    assert out == [1]\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg * 10)\n\n    pm.register(Plugin2())\n    assert out == [1, 10]\n    pm.hook.he_method1.call_historic(kwargs=dict(arg=12))\n    assert out == [1, 10, 120, 12]\n\n\ndef test_historic_with_subset_hook_caller(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg): ...\n\n    pm.add_hookspecs(Hooks)\n\n    out = []\n\n    class Plugin:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg)\n\n    plugin = Plugin()\n    pm.register(plugin)\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg * 10)\n\n    shc = pm.subset_hook_caller(\"he_method1\", remove_plugins=[plugin])\n    shc.call_historic(kwargs=dict(arg=1))\n\n    pm.register(Plugin2())\n    assert out == [10]\n\n    pm.register(Plugin())\n    assert out == [10, 1]\n\n\n@pytest.mark.parametrize(\"result_callback\", [True, False])\ndef test_with_result_memorized(pm: PluginManager, result_callback: bool) -> None:\n    \"\"\"Verify that ``HookCaller._maybe_apply_history()`\n    correctly applies the ``result_callback`` function, when provided,\n    to the result from calling each newly registered hook.\n    \"\"\"\n    out = []\n    if not result_callback:\n        callback = None\n    else:\n\n        def callback(res) -> None:\n            out.append(res)\n\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg * 10\n\n    pm.register(Plugin1())\n\n    he_method1 = pm.hook.he_method1\n    he_method1.call_historic(result_callback=callback, kwargs=dict(arg=1))\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg * 10\n\n    pm.register(Plugin2())\n    if result_callback:\n        assert out == [10, 10]\n    else:\n        assert out == []\n\n\ndef test_with_callbacks_immediately_executed(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg * 10\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg * 20\n\n    class Plugin3:\n        @hookimpl\n        def he_method1(self, arg):\n            return arg * 30\n\n    out = []\n    pm.register(Plugin1())\n    pm.register(Plugin2())\n\n    he_method1 = pm.hook.he_method1\n    he_method1.call_historic(lambda res: out.append(res), dict(arg=1))\n    assert out == [20, 10]\n    pm.register(Plugin3())\n    assert out == [20, 10, 30]\n\n\ndef test_register_historic_incompat_hookwrapper(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    out = []\n\n    class Plugin:\n        @hookimpl(hookwrapper=True)\n        def he_method1(self, arg):\n            out.append(arg)\n\n    with pytest.raises(PluginValidationError):\n        pm.register(Plugin())\n\n\ndef test_register_historic_incompat_wrapper(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec(historic=True)\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    class Plugin:\n        @hookimpl(wrapper=True)\n        def he_method1(self, arg):\n            yield\n\n    with pytest.raises(PluginValidationError):\n        pm.register(Plugin())\n\n\ndef test_call_extra(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    def he_method1(arg):\n        return arg * 10\n\n    out = pm.hook.he_method1.call_extra([he_method1], dict(arg=1))\n    assert out == [10]\n\n\ndef test_call_with_too_few_args(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            0 / 0\n\n    pm.register(Plugin1())\n    with pytest.raises(HookCallError):\n        with pytest.warns(UserWarning):\n            pm.hook.he_method1()\n\n\ndef test_subset_hook_caller(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n\n    out = []\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg)\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            out.append(arg * 10)\n\n    class PluginNo:\n        pass\n\n    plugin1, plugin2, plugin3 = Plugin1(), Plugin2(), PluginNo()\n    pm.register(plugin1)\n    pm.register(plugin2)\n    pm.register(plugin3)\n    pm.hook.he_method1(arg=1)\n    assert out == [10, 1]\n    out[:] = []\n\n    hc = pm.subset_hook_caller(\"he_method1\", [plugin1])\n    hc(arg=2)\n    assert out == [20]\n    out[:] = []\n\n    hc = pm.subset_hook_caller(\"he_method1\", [plugin2])\n    hc(arg=2)\n    assert out == [2]\n    out[:] = []\n\n    pm.unregister(plugin1)\n    hc(arg=2)\n    assert out == []\n    out[:] = []\n\n    pm.hook.he_method1(arg=1)\n    assert out == [10]\n\n    assert repr(hc) == \"<_SubsetHookCaller 'he_method1'>\"\n\n\ndef test_get_hookimpls(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec\n        def he_method1(self, arg):\n            pass\n\n    pm.add_hookspecs(Hooks)\n    assert pm.hook.he_method1.get_hookimpls() == []\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self, arg):\n            pass\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self, arg):\n            pass\n\n    class PluginNo:\n        pass\n\n    plugin1, plugin2, plugin3 = Plugin1(), Plugin2(), PluginNo()\n    pm.register(plugin1)\n    pm.register(plugin2)\n    pm.register(plugin3)\n\n    hookimpls = pm.hook.he_method1.get_hookimpls()\n    hook_plugins = [item.plugin for item in hookimpls]\n    assert hook_plugins == [plugin1, plugin2]\n\n\ndef test_get_hookcallers(pm: PluginManager) -> None:\n    class Hooks:\n        @hookspec\n        def he_method1(self): ...\n\n        @hookspec\n        def he_method2(self): ...\n\n    pm.add_hookspecs(Hooks)\n\n    class Plugin1:\n        @hookimpl\n        def he_method1(self): ...\n\n        @hookimpl\n        def he_method2(self): ...\n\n    class Plugin2:\n        @hookimpl\n        def he_method1(self): ...\n\n    class Plugin3:\n        @hookimpl\n        def he_method2(self): ...\n\n    plugin1 = Plugin1()\n    pm.register(plugin1)\n    plugin2 = Plugin2()\n    pm.register(plugin2)\n    plugin3 = Plugin3()\n    pm.register(plugin3)\n\n    hookcallers1 = pm.get_hookcallers(plugin1)\n    assert hookcallers1 is not None\n    assert len(hookcallers1) == 2\n    hookcallers2 = pm.get_hookcallers(plugin2)\n    assert hookcallers2 is not None\n    assert len(hookcallers2) == 1\n    hookcallers3 = pm.get_hookcallers(plugin3)\n    assert hookcallers3 is not None\n    assert len(hookcallers3) == 1\n    assert hookcallers1 == hookcallers2 + hookcallers3\n\n    assert pm.get_hookcallers(object()) is None\n\n\ndef test_add_hookspecs_nohooks(pm: PluginManager) -> None:\n    class NoHooks:\n        pass\n\n    with pytest.raises(ValueError):\n        pm.add_hookspecs(NoHooks)\n\n\ndef test_load_setuptools_instantiation(monkeypatch, pm: PluginManager) -> None:\n    class EntryPoint:\n        name = \"myname\"\n        group = \"hello\"\n        value = \"myname:foo\"\n\n        def load(self):\n            class PseudoPlugin:\n                x = 42\n\n            return PseudoPlugin()\n\n    class Distribution:\n        entry_points = (EntryPoint(),)\n\n    dist = Distribution()\n\n    def my_distributions():\n        return (dist,)\n\n    monkeypatch.setattr(importlib.metadata, \"distributions\", my_distributions)\n    num = pm.load_setuptools_entrypoints(\"hello\")\n    assert num == 1\n    plugin = pm.get_plugin(\"myname\")\n    assert plugin is not None\n    assert plugin.x == 42\n    ret = pm.list_plugin_distinfo()\n    # poor man's `assert ret == [(plugin, mock.ANY)]`\n    assert len(ret) == 1\n    assert len(ret[0]) == 2\n    assert ret[0][0] == plugin\n    assert ret[0][1]._dist == dist  # type: ignore[comparison-overlap]\n    num = pm.load_setuptools_entrypoints(\"hello\")\n    assert num == 0  # no plugin loaded by this call\n\n\ndef test_add_tracefuncs(he_pm: PluginManager) -> None:\n    out: List[Any] = []\n\n    class api1:\n        @hookimpl\n        def he_method1(self):\n            out.append(\"he_method1-api1\")\n\n    class api2:\n        @hookimpl\n        def he_method1(self):\n            out.append(\"he_method1-api2\")\n\n    he_pm.register(api1())\n    he_pm.register(api2())\n\n    def before(hook_name, hook_impls, kwargs):\n        out.append((hook_name, list(hook_impls), kwargs))\n\n    def after(outcome, hook_name, hook_impls, kwargs):\n        out.append((outcome, hook_name, list(hook_impls), kwargs))\n\n    undo = he_pm.add_hookcall_monitoring(before, after)\n\n    he_pm.hook.he_method1(arg=1)\n    assert len(out) == 4\n    assert out[0][0] == \"he_method1\"\n    assert len(out[0][1]) == 2\n    assert isinstance(out[0][2], dict)\n    assert out[1] == \"he_method1-api2\"\n    assert out[2] == \"he_method1-api1\"\n    assert len(out[3]) == 4\n    assert out[3][1] == out[0][0]\n\n    undo()\n    he_pm.hook.he_method1(arg=1)\n    assert len(out) == 4 + 2\n\n\ndef test_hook_tracing(he_pm: PluginManager) -> None:\n    saveindent = []\n\n    class api1:\n        @hookimpl\n        def he_method1(self):\n            saveindent.append(he_pm.trace.root.indent)\n\n    class api2:\n        @hookimpl\n        def he_method1(self):\n            saveindent.append(he_pm.trace.root.indent)\n            raise ValueError()\n\n    he_pm.register(api1())\n    out: List[Any] = []\n    he_pm.trace.root.setwriter(out.append)\n    undo = he_pm.enable_tracing()\n    try:\n        indent = he_pm.trace.root.indent\n        he_pm.hook.he_method1(arg=1)\n        assert indent == he_pm.trace.root.indent\n        assert len(out) == 2\n        assert \"he_method1\" in out[0]\n        assert \"finish\" in out[1]\n\n        out[:] = []\n        he_pm.register(api2())\n\n        with pytest.raises(ValueError):\n            he_pm.hook.he_method1(arg=1)\n        assert he_pm.trace.root.indent == indent\n        assert saveindent[0] > indent\n    finally:\n        undo()\n\n\n@pytest.mark.parametrize(\"historic\", [False, True])\ndef test_register_while_calling(\n    pm: PluginManager,\n    historic: bool,\n) -> None:\n    \"\"\"Test that registering an impl of a hook while it is being called does\n    not affect the call itself, only later calls.\n\n    For historic hooks however, the hook is called immediately on registration.\n\n    Regression test for #438.\n    \"\"\"\n    hookspec = HookspecMarker(\"example\")\n\n    class Hooks:\n        @hookspec(historic=historic)\n        def configure(self) -> int:\n            raise NotImplementedError()\n\n    class Plugin1:\n        @hookimpl\n        def configure(self) -> int:\n            return 1\n\n    class Plugin2:\n        def __init__(self) -> None:\n            self.already_registered = False\n\n        @hookimpl\n        def configure(self) -> int:\n            if not self.already_registered:\n                pm.register(Plugin4())\n                pm.register(Plugin5())\n                pm.register(Plugin6())\n                self.already_registered = True\n            return 2\n\n    class Plugin3:\n        @hookimpl\n        def configure(self) -> int:\n            return 3\n\n    class Plugin4:\n        @hookimpl(tryfirst=True)\n        def configure(self) -> int:\n            return 4\n\n    class Plugin5:\n        @hookimpl()\n        def configure(self) -> int:\n            return 5\n\n    class Plugin6:\n        @hookimpl(trylast=True)\n        def configure(self) -> int:\n            return 6\n\n    pm.add_hookspecs(Hooks)\n    pm.register(Plugin1())\n    pm.register(Plugin2())\n    pm.register(Plugin3())\n\n    if not historic:\n        result = pm.hook.configure()\n        assert result == [3, 2, 1]\n        result = pm.hook.configure()\n        assert result == [4, 5, 3, 2, 1, 6]\n    else:\n        result = []\n        pm.hook.configure.call_historic(result.append)\n        assert result == [4, 5, 6, 3, 2, 1]\n        result = []\n        pm.hook.configure.call_historic(result.append)\n        assert result == [4, 5, 3, 2, 1, 6]\n", "testing/test_details.py": "import pytest\n\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\n\nhookspec = HookspecMarker(\"example\")\nhookimpl = HookimplMarker(\"example\")\n\n\ndef test_parse_hookimpl_override() -> None:\n    class MyPluginManager(PluginManager):\n        def parse_hookimpl_opts(self, module_or_class, name):\n            opts = PluginManager.parse_hookimpl_opts(self, module_or_class, name)\n            if opts is None:\n                if name.startswith(\"x1\"):\n                    opts = {}  # type: ignore[assignment]\n            return opts\n\n    class Plugin:\n        def x1meth(self):\n            pass\n\n        @hookimpl(hookwrapper=True, tryfirst=True)\n        def x1meth2(self):\n            yield  # pragma: no cover\n\n        @hookimpl(wrapper=True, trylast=True)\n        def x1meth3(self):\n            return (yield)  # pragma: no cover\n\n    class Spec:\n        @hookspec\n        def x1meth(self):\n            pass\n\n        @hookspec\n        def x1meth2(self):\n            pass\n\n        @hookspec\n        def x1meth3(self):\n            pass\n\n    pm = MyPluginManager(hookspec.project_name)\n    pm.register(Plugin())\n    pm.add_hookspecs(Spec)\n\n    hookimpls = pm.hook.x1meth.get_hookimpls()\n    assert len(hookimpls) == 1\n    assert not hookimpls[0].hookwrapper\n    assert not hookimpls[0].wrapper\n    assert not hookimpls[0].tryfirst\n    assert not hookimpls[0].trylast\n    assert not hookimpls[0].optionalhook\n\n    hookimpls = pm.hook.x1meth2.get_hookimpls()\n    assert len(hookimpls) == 1\n    assert hookimpls[0].hookwrapper\n    assert not hookimpls[0].wrapper\n    assert hookimpls[0].tryfirst\n\n    hookimpls = pm.hook.x1meth3.get_hookimpls()\n    assert len(hookimpls) == 1\n    assert not hookimpls[0].hookwrapper\n    assert hookimpls[0].wrapper\n    assert not hookimpls[0].tryfirst\n    assert hookimpls[0].trylast\n\n\ndef test_warn_when_deprecated_specified(recwarn) -> None:\n    warning = DeprecationWarning(\"foo is deprecated\")\n\n    class Spec:\n        @hookspec(warn_on_impl=warning)\n        def foo(self):\n            pass\n\n    class Plugin:\n        @hookimpl\n        def foo(self):\n            pass\n\n    pm = PluginManager(hookspec.project_name)\n    pm.add_hookspecs(Spec)\n\n    with pytest.warns(DeprecationWarning) as records:\n        pm.register(Plugin())\n    (record,) = records\n    assert record.message is warning\n    assert record.filename == Plugin.foo.__code__.co_filename\n    assert record.lineno == Plugin.foo.__code__.co_firstlineno\n\n\ndef test_warn_when_deprecated_args_specified(recwarn) -> None:\n    warning1 = DeprecationWarning(\"old1 is deprecated\")\n    warning2 = DeprecationWarning(\"old2 is deprecated\")\n\n    class Spec:\n        @hookspec(\n            warn_on_impl_args={\n                \"old1\": warning1,\n                \"old2\": warning2,\n            },\n        )\n        def foo(self, old1, new, old2):\n            raise NotImplementedError()\n\n    class Plugin:\n        @hookimpl\n        def foo(self, old2, old1, new):\n            raise NotImplementedError()\n\n    pm = PluginManager(hookspec.project_name)\n    pm.add_hookspecs(Spec)\n\n    with pytest.warns(DeprecationWarning) as records:\n        pm.register(Plugin())\n    (record1, record2) = records\n    assert record1.message is warning2\n    assert record1.filename == Plugin.foo.__code__.co_filename\n    assert record1.lineno == Plugin.foo.__code__.co_firstlineno\n    assert record2.message is warning1\n    assert record2.filename == Plugin.foo.__code__.co_filename\n    assert record2.lineno == Plugin.foo.__code__.co_firstlineno\n\n\ndef test_plugin_getattr_raises_errors() -> None:\n    \"\"\"Pluggy must be able to handle plugins which raise weird exceptions\n    when getattr() gets called (#11).\n    \"\"\"\n\n    class DontTouchMe:\n        def __getattr__(self, x):\n            raise Exception(\"can't touch me\")\n\n    class Module:\n        pass\n\n    module = Module()\n    module.x = DontTouchMe()  # type: ignore[attr-defined]\n\n    pm = PluginManager(hookspec.project_name)\n    # register() would raise an error\n    pm.register(module, \"donttouch\")\n    assert pm.get_plugin(\"donttouch\") is module\n\n\ndef test_not_all_arguments_are_provided_issues_a_warning(pm: PluginManager) -> None:\n    \"\"\"Calling a hook without providing all arguments specified in\n    the hook spec issues a warning.\"\"\"\n\n    class Spec:\n        @hookspec\n        def hello(self, arg1, arg2):\n            pass\n\n        @hookspec(historic=True)\n        def herstory(self, arg1, arg2):\n            pass\n\n    pm.add_hookspecs(Spec)\n\n    with pytest.warns(UserWarning, match=r\"'arg1', 'arg2'.*cannot be found.*$\"):\n        pm.hook.hello()\n    with pytest.warns(UserWarning, match=r\"'arg2'.*cannot be found.*$\"):\n        pm.hook.hello(arg1=1)\n    with pytest.warns(UserWarning, match=r\"'arg1'.*cannot be found.*$\"):\n        pm.hook.hello(arg2=2)\n\n    with pytest.warns(UserWarning, match=r\"'arg1', 'arg2'.*cannot be found.*$\"):\n        pm.hook.hello.call_extra([], kwargs=dict())\n\n    with pytest.warns(UserWarning, match=r\"'arg1', 'arg2'.*cannot be found.*$\"):\n        pm.hook.herstory.call_historic(kwargs=dict())\n\n\ndef test_repr() -> None:\n    class Plugin:\n        @hookimpl\n        def myhook(self):\n            raise NotImplementedError()\n\n    pm = PluginManager(hookspec.project_name)\n\n    plugin = Plugin()\n    pname = pm.register(plugin)\n    assert repr(pm.hook.myhook.get_hookimpls()[0]) == (\n        f\"<HookImpl plugin_name={pname!r}, plugin={plugin!r}>\"\n    )\n", "src/pluggy/_tracing.py": "\"\"\"\nTracing utils\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Sequence\nfrom typing import Tuple\n\n\n_Writer = Callable[[str], object]\n_Processor = Callable[[Tuple[str, ...], Tuple[Any, ...]], object]\n\n\nclass TagTracer:\n    def __init__(self) -> None:\n        self._tags2proc: dict[tuple[str, ...], _Processor] = {}\n        self._writer: _Writer | None = None\n        self.indent = 0\n\n    def get(self, name: str) -> TagTracerSub:\n        return TagTracerSub(self, (name,))\n\n    def _format_message(self, tags: Sequence[str], args: Sequence[object]) -> str:\n        if isinstance(args[-1], dict):\n            extra = args[-1]\n            args = args[:-1]\n        else:\n            extra = {}\n\n        content = \" \".join(map(str, args))\n        indent = \"  \" * self.indent\n\n        lines = [\"{}{} [{}]\\n\".format(indent, content, \":\".join(tags))]\n\n        for name, value in extra.items():\n            lines.append(f\"{indent}    {name}: {value}\\n\")\n\n        return \"\".join(lines)\n\n    def _processmessage(self, tags: tuple[str, ...], args: tuple[object, ...]) -> None:\n        if self._writer is not None and args:\n            self._writer(self._format_message(tags, args))\n        try:\n            processor = self._tags2proc[tags]\n        except KeyError:\n            pass\n        else:\n            processor(tags, args)\n\n    def setwriter(self, writer: _Writer | None) -> None:\n        self._writer = writer\n\n    def setprocessor(self, tags: str | tuple[str, ...], processor: _Processor) -> None:\n        if isinstance(tags, str):\n            tags = tuple(tags.split(\":\"))\n        else:\n            assert isinstance(tags, tuple)\n        self._tags2proc[tags] = processor\n\n\nclass TagTracerSub:\n    def __init__(self, root: TagTracer, tags: tuple[str, ...]) -> None:\n        self.root = root\n        self.tags = tags\n\n    def __call__(self, *args: object) -> None:\n        self.root._processmessage(self.tags, args)\n\n    def get(self, name: str) -> TagTracerSub:\n        return self.__class__(self.root, self.tags + (name,))\n", "src/pluggy/_warnings.py": "from typing import final\n\n\nclass PluggyWarning(UserWarning):\n    \"\"\"Base class for all warnings emitted by pluggy.\"\"\"\n\n    __module__ = \"pluggy\"\n\n\n@final\nclass PluggyTeardownRaisedWarning(PluggyWarning):\n    \"\"\"A plugin raised an exception during an :ref:`old-style hookwrapper\n    <old_style_hookwrappers>` teardown.\n\n    Such exceptions are not handled by pluggy, and may cause subsequent\n    teardowns to be executed at unexpected times, or be skipped entirely.\n\n    This is an issue in the plugin implementation.\n\n    If the exception is unintended, fix the underlying cause.\n\n    If the exception is intended, switch to :ref:`new-style hook wrappers\n    <hookwrappers>`, or use :func:`result.force_exception()\n    <pluggy.Result.force_exception>` to set the exception instead of raising.\n    \"\"\"\n\n    __module__ = \"pluggy\"\n", "src/pluggy/_hooks.py": "\"\"\"\nInternal hook annotation, representation and calling machinery.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nimport sys\nfrom types import ModuleType\nfrom typing import AbstractSet\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Final\nfrom typing import final\nfrom typing import Generator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import TypedDict\nfrom typing import TypeVar\nfrom typing import Union\nimport warnings\n\nfrom ._result import Result\n\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., object])\n_Namespace = Union[ModuleType, type]\n_Plugin = object\n_HookExec = Callable[\n    [str, Sequence[\"HookImpl\"], Mapping[str, object], bool],\n    Union[object, List[object]],\n]\n_HookImplFunction = Callable[..., Union[_T, Generator[None, Result[_T], None]]]\n\n\nclass HookspecOpts(TypedDict):\n    \"\"\"Options for a hook specification.\"\"\"\n\n    #: Whether the hook is :ref:`first result only <firstresult>`.\n    firstresult: bool\n    #: Whether the hook is :ref:`historic <historic>`.\n    historic: bool\n    #: Whether the hook :ref:`warns when implemented <warn_on_impl>`.\n    warn_on_impl: Warning | None\n    #: Whether the hook warns when :ref:`certain arguments are requested\n    #: <warn_on_impl>`.\n    #:\n    #: .. versionadded:: 1.5\n    warn_on_impl_args: Mapping[str, Warning] | None\n\n\nclass HookimplOpts(TypedDict):\n    \"\"\"Options for a hook implementation.\"\"\"\n\n    #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.\n    wrapper: bool\n    #: Whether the hook implementation is an :ref:`old-style wrapper\n    #: <old_style_hookwrappers>`.\n    hookwrapper: bool\n    #: Whether validation against a hook specification is :ref:`optional\n    #: <optionalhook>`.\n    optionalhook: bool\n    #: Whether to try to order this hook implementation :ref:`first\n    #: <callorder>`.\n    tryfirst: bool\n    #: Whether to try to order this hook implementation :ref:`last\n    #: <callorder>`.\n    trylast: bool\n    #: The name of the hook specification to match, see :ref:`specname`.\n    specname: str | None\n\n\n@final\nclass HookspecMarker:\n    \"\"\"Decorator for marking functions as hook specifications.\n\n    Instantiate it with a project_name to get a decorator.\n    Calling :meth:`PluginManager.add_hookspecs` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    \"\"\"\n\n    __slots__ = (\"project_name\",)\n\n    def __init__(self, project_name: str) -> None:\n        self.project_name: Final = project_name\n\n    @overload\n    def __call__(\n        self,\n        function: _F,\n        firstresult: bool = False,\n        historic: bool = False,\n        warn_on_impl: Warning | None = None,\n        warn_on_impl_args: Mapping[str, Warning] | None = None,\n    ) -> _F: ...\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self,\n        function: None = ...,\n        firstresult: bool = ...,\n        historic: bool = ...,\n        warn_on_impl: Warning | None = ...,\n        warn_on_impl_args: Mapping[str, Warning] | None = ...,\n    ) -> Callable[[_F], _F]: ...\n\n    def __call__(  # noqa: F811\n        self,\n        function: _F | None = None,\n        firstresult: bool = False,\n        historic: bool = False,\n        warn_on_impl: Warning | None = None,\n        warn_on_impl_args: Mapping[str, Warning] | None = None,\n    ) -> _F | Callable[[_F], _F]:\n        \"\"\"If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.add_hookspecs`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param firstresult:\n            If ``True``, the 1:N hook call (N being the number of registered\n            hook implementation functions) will stop at I<=N when the I'th\n            function returns a non-``None`` result. See :ref:`firstresult`.\n\n        :param historic:\n            If ``True``, every call to the hook will be memorized and replayed\n            on plugins registered after the call was made. See :ref:`historic`.\n\n        :param warn_on_impl:\n            If given, every implementation of this hook will trigger the given\n            warning. See :ref:`warn_on_impl`.\n\n        :param warn_on_impl_args:\n            If given, every implementation of this hook which requests one of\n            the arguments in the dict will trigger the corresponding warning.\n            See :ref:`warn_on_impl`.\n\n            .. versionadded:: 1.5\n        \"\"\"\n\n        def setattr_hookspec_opts(func: _F) -> _F:\n            if historic and firstresult:\n                raise ValueError(\"cannot have a historic firstresult hook\")\n            opts: HookspecOpts = {\n                \"firstresult\": firstresult,\n                \"historic\": historic,\n                \"warn_on_impl\": warn_on_impl,\n                \"warn_on_impl_args\": warn_on_impl_args,\n            }\n            setattr(func, self.project_name + \"_spec\", opts)\n            return func\n\n        if function is not None:\n            return setattr_hookspec_opts(function)\n        else:\n            return setattr_hookspec_opts\n\n\n@final\nclass HookimplMarker:\n    \"\"\"Decorator for marking functions as hook implementations.\n\n    Instantiate it with a ``project_name`` to get a decorator.\n    Calling :meth:`PluginManager.register` later will discover all marked\n    functions if the :class:`PluginManager` uses the same project name.\n    \"\"\"\n\n    __slots__ = (\"project_name\",)\n\n    def __init__(self, project_name: str) -> None:\n        self.project_name: Final = project_name\n\n    @overload\n    def __call__(\n        self,\n        function: _F,\n        hookwrapper: bool = ...,\n        optionalhook: bool = ...,\n        tryfirst: bool = ...,\n        trylast: bool = ...,\n        specname: str | None = ...,\n        wrapper: bool = ...,\n    ) -> _F: ...\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self,\n        function: None = ...,\n        hookwrapper: bool = ...,\n        optionalhook: bool = ...,\n        tryfirst: bool = ...,\n        trylast: bool = ...,\n        specname: str | None = ...,\n        wrapper: bool = ...,\n    ) -> Callable[[_F], _F]: ...\n\n    def __call__(  # noqa: F811\n        self,\n        function: _F | None = None,\n        hookwrapper: bool = False,\n        optionalhook: bool = False,\n        tryfirst: bool = False,\n        trylast: bool = False,\n        specname: str | None = None,\n        wrapper: bool = False,\n    ) -> _F | Callable[[_F], _F]:\n        \"\"\"If passed a function, directly sets attributes on the function\n        which will make it discoverable to :meth:`PluginManager.register`.\n\n        If passed no function, returns a decorator which can be applied to a\n        function later using the attributes supplied.\n\n        :param optionalhook:\n            If ``True``, a missing matching hook specification will not result\n            in an error (by default it is an error if no matching spec is\n            found). See :ref:`optionalhook`.\n\n        :param tryfirst:\n            If ``True``, this hook implementation will run as early as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param trylast:\n            If ``True``, this hook implementation will run as late as possible\n            in the chain of N hook implementations for a specification. See\n            :ref:`callorder`.\n\n        :param wrapper:\n            If ``True`` (\"new-style hook wrapper\"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            functions have run. The ``yield`` receives the result value of the\n            inner calls, or raises the exception of inner calls (including\n            earlier hook wrapper calls). The return value of the function\n            becomes the return value of the hook, and a raised exception becomes\n            the exception of the hook. See :ref:`hookwrapper`.\n\n        :param hookwrapper:\n            If ``True`` (\"old-style hook wrapper\"), the hook implementation\n            needs to execute exactly one ``yield``. The code before the\n            ``yield`` is run early before any non-hook-wrapper function is run.\n            The code after the ``yield`` is run after all non-hook-wrapper\n            function have run  The ``yield`` receives a :class:`Result` object\n            representing the exception or result outcome of the inner calls\n            (including earlier hook wrapper calls). This option is mutually\n            exclusive with ``wrapper``. See :ref:`old_style_hookwrapper`.\n\n        :param specname:\n            If provided, the given name will be used instead of the function\n            name when matching this hook implementation to a hook specification\n            during registration. See :ref:`specname`.\n\n        .. versionadded:: 1.2.0\n            The ``wrapper`` parameter.\n        \"\"\"\n\n        def setattr_hookimpl_opts(func: _F) -> _F:\n            opts: HookimplOpts = {\n                \"wrapper\": wrapper,\n                \"hookwrapper\": hookwrapper,\n                \"optionalhook\": optionalhook,\n                \"tryfirst\": tryfirst,\n                \"trylast\": trylast,\n                \"specname\": specname,\n            }\n            setattr(func, self.project_name + \"_impl\", opts)\n            return func\n\n        if function is None:\n            return setattr_hookimpl_opts\n        else:\n            return setattr_hookimpl_opts(function)\n\n\ndef normalize_hookimpl_opts(opts: HookimplOpts) -> None:\n    opts.setdefault(\"tryfirst\", False)\n    opts.setdefault(\"trylast\", False)\n    opts.setdefault(\"wrapper\", False)\n    opts.setdefault(\"hookwrapper\", False)\n    opts.setdefault(\"optionalhook\", False)\n    opts.setdefault(\"specname\", None)\n\n\n_PYPY = hasattr(sys, \"pypy_version_info\")\n\n\ndef varnames(func: object) -> tuple[tuple[str, ...], tuple[str, ...]]:\n    \"\"\"Return tuple of positional and keywrord argument names for a function,\n    method, class or callable.\n\n    In case of a class, its ``__init__`` method is considered.\n    For methods the ``self`` parameter is not included.\n    \"\"\"\n    if inspect.isclass(func):\n        try:\n            func = func.__init__\n        except AttributeError:\n            return (), ()\n    elif not inspect.isroutine(func):  # callable object?\n        try:\n            func = getattr(func, \"__call__\", func)\n        except Exception:\n            return (), ()\n\n    try:\n        # func MUST be a function or method here or we won't parse any args.\n        sig = inspect.signature(\n            func.__func__ if inspect.ismethod(func) else func  # type:ignore[arg-type]\n        )\n    except TypeError:\n        return (), ()\n\n    _valid_param_kinds = (\n        inspect.Parameter.POSITIONAL_ONLY,\n        inspect.Parameter.POSITIONAL_OR_KEYWORD,\n    )\n    _valid_params = {\n        name: param\n        for name, param in sig.parameters.items()\n        if param.kind in _valid_param_kinds\n    }\n    args = tuple(_valid_params)\n    defaults = (\n        tuple(\n            param.default\n            for param in _valid_params.values()\n            if param.default is not param.empty\n        )\n        or None\n    )\n\n    if defaults:\n        index = -len(defaults)\n        args, kwargs = args[:index], tuple(args[index:])\n    else:\n        kwargs = ()\n\n    # strip any implicit instance arg\n    # pypy3 uses \"obj\" instead of \"self\" for default dunder methods\n    if not _PYPY:\n        implicit_names: tuple[str, ...] = (\"self\",)\n    else:\n        implicit_names = (\"self\", \"obj\")\n    if args:\n        qualname: str = getattr(func, \"__qualname__\", \"\")\n        if inspect.ismethod(func) or (\".\" in qualname and args[0] in implicit_names):\n            args = args[1:]\n\n    return args, kwargs\n\n\n@final\nclass HookRelay:\n    \"\"\"Hook holder object for performing 1:N hook calls where N is the number\n    of registered plugins.\"\"\"\n\n    __slots__ = (\"__dict__\",)\n\n    def __init__(self) -> None:\n        \"\"\":meta private:\"\"\"\n\n    if TYPE_CHECKING:\n\n        def __getattr__(self, name: str) -> HookCaller: ...\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_HookRelay = HookRelay\n\n\n_CallHistory = List[Tuple[Mapping[str, object], Optional[Callable[[Any], None]]]]\n\n\nclass HookCaller:\n    \"\"\"A caller of all registered implementations of a hook specification.\"\"\"\n\n    __slots__ = (\n        \"name\",\n        \"spec\",\n        \"_hookexec\",\n        \"_hookimpls\",\n        \"_call_history\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        hook_execute: _HookExec,\n        specmodule_or_class: _Namespace | None = None,\n        spec_opts: HookspecOpts | None = None,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        #: Name of the hook getting called.\n        self.name: Final = name\n        self._hookexec: Final = hook_execute\n        # The hookimpls list. The caller iterates it *in reverse*. Format:\n        # 1. trylast nonwrappers\n        # 2. nonwrappers\n        # 3. tryfirst nonwrappers\n        # 4. trylast wrappers\n        # 5. wrappers\n        # 6. tryfirst wrappers\n        self._hookimpls: Final[list[HookImpl]] = []\n        self._call_history: _CallHistory | None = None\n        # TODO: Document, or make private.\n        self.spec: HookSpec | None = None\n        if specmodule_or_class is not None:\n            assert spec_opts is not None\n            self.set_specification(specmodule_or_class, spec_opts)\n\n    # TODO: Document, or make private.\n    def has_spec(self) -> bool:\n        return self.spec is not None\n\n    # TODO: Document, or make private.\n    def set_specification(\n        self,\n        specmodule_or_class: _Namespace,\n        spec_opts: HookspecOpts,\n    ) -> None:\n        if self.spec is not None:\n            raise ValueError(\n                f\"Hook {self.spec.name!r} is already registered \"\n                f\"within namespace {self.spec.namespace}\"\n            )\n        self.spec = HookSpec(specmodule_or_class, self.name, spec_opts)\n        if spec_opts.get(\"historic\"):\n            self._call_history = []\n\n    def is_historic(self) -> bool:\n        \"\"\"Whether this caller is :ref:`historic <historic>`.\"\"\"\n        return self._call_history is not None\n\n    def _remove_plugin(self, plugin: _Plugin) -> None:\n        for i, method in enumerate(self._hookimpls):\n            if method.plugin == plugin:\n                del self._hookimpls[i]\n                return\n        raise ValueError(f\"plugin {plugin!r} not found\")\n\n    def get_hookimpls(self) -> list[HookImpl]:\n        \"\"\"Get all registered hook implementations for this hook.\"\"\"\n        return self._hookimpls.copy()\n\n    def _add_hookimpl(self, hookimpl: HookImpl) -> None:\n        \"\"\"Add an implementation to the callback chain.\"\"\"\n        for i, method in enumerate(self._hookimpls):\n            if method.hookwrapper or method.wrapper:\n                splitpoint = i\n                break\n        else:\n            splitpoint = len(self._hookimpls)\n        if hookimpl.hookwrapper or hookimpl.wrapper:\n            start, end = splitpoint, len(self._hookimpls)\n        else:\n            start, end = 0, splitpoint\n\n        if hookimpl.trylast:\n            self._hookimpls.insert(start, hookimpl)\n        elif hookimpl.tryfirst:\n            self._hookimpls.insert(end, hookimpl)\n        else:\n            # find last non-tryfirst method\n            i = end - 1\n            while i >= start and self._hookimpls[i].tryfirst:\n                i -= 1\n            self._hookimpls.insert(i + 1, hookimpl)\n\n    def __repr__(self) -> str:\n        return f\"<HookCaller {self.name!r}>\"\n\n    def _verify_all_args_are_provided(self, kwargs: Mapping[str, object]) -> None:\n        # This is written to avoid expensive operations when not needed.\n        if self.spec:\n            for argname in self.spec.argnames:\n                if argname not in kwargs:\n                    notincall = \", \".join(\n                        repr(argname)\n                        for argname in self.spec.argnames\n                        # Avoid self.spec.argnames - kwargs.keys() - doesn't preserve order.\n                        if argname not in kwargs.keys()\n                    )\n                    warnings.warn(\n                        \"Argument(s) {} which are declared in the hookspec \"\n                        \"cannot be found in this hook call\".format(notincall),\n                        stacklevel=2,\n                    )\n                    break\n\n    def __call__(self, **kwargs: object) -> Any:\n        \"\"\"Call the hook.\n\n        Only accepts keyword arguments, which should match the hook\n        specification.\n\n        Returns the result(s) of calling all registered plugins, see\n        :ref:`calling`.\n        \"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        # Copy because plugins may register other plugins during iteration (#438).\n        return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n\n    def call_historic(\n        self,\n        result_callback: Callable[[Any], None] | None = None,\n        kwargs: Mapping[str, object] | None = None,\n    ) -> None:\n        \"\"\"Call the hook with given ``kwargs`` for all registered plugins and\n        for all plugins which will be registered afterwards, see\n        :ref:`historic`.\n\n        :param result_callback:\n            If provided, will be called for each non-``None`` result obtained\n            from a hook implementation.\n        \"\"\"\n        assert self._call_history is not None\n        kwargs = kwargs or {}\n        self._verify_all_args_are_provided(kwargs)\n        self._call_history.append((kwargs, result_callback))\n        # Historizing hooks don't return results.\n        # Remember firstresult isn't compatible with historic.\n        # Copy because plugins may register other plugins during iteration (#438).\n        res = self._hookexec(self.name, self._hookimpls.copy(), kwargs, False)\n        if result_callback is None:\n            return\n        if isinstance(res, list):\n            for x in res:\n                result_callback(x)\n\n    def call_extra(\n        self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]\n    ) -> Any:\n        \"\"\"Call the hook with some additional temporarily participating\n        methods using the specified ``kwargs`` as call parameters, see\n        :ref:`call_extra`.\"\"\"\n        assert (\n            not self.is_historic()\n        ), \"Cannot directly call a historic hook - use call_historic instead.\"\n        self._verify_all_args_are_provided(kwargs)\n        opts: HookimplOpts = {\n            \"wrapper\": False,\n            \"hookwrapper\": False,\n            \"optionalhook\": False,\n            \"trylast\": False,\n            \"tryfirst\": False,\n            \"specname\": None,\n        }\n        hookimpls = self._hookimpls.copy()\n        for method in methods:\n            hookimpl = HookImpl(None, \"<temp>\", method, opts)\n            # Find last non-tryfirst nonwrapper method.\n            i = len(hookimpls) - 1\n            while i >= 0 and (\n                # Skip wrappers.\n                (hookimpls[i].hookwrapper or hookimpls[i].wrapper)\n                # Skip tryfirst nonwrappers.\n                or hookimpls[i].tryfirst\n            ):\n                i -= 1\n            hookimpls.insert(i + 1, hookimpl)\n        firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\n        return self._hookexec(self.name, hookimpls, kwargs, firstresult)\n\n    def _maybe_apply_history(self, method: HookImpl) -> None:\n        \"\"\"Apply call history to a new hookimpl if it is marked as historic.\"\"\"\n        if self.is_historic():\n            assert self._call_history is not None\n            for kwargs, result_callback in self._call_history:\n                res = self._hookexec(self.name, [method], kwargs, False)\n                if res and result_callback is not None:\n                    # XXX: remember firstresult isn't compat with historic\n                    assert isinstance(res, list)\n                    result_callback(res[0])\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_HookCaller = HookCaller\n\n\nclass _SubsetHookCaller(HookCaller):\n    \"\"\"A proxy to another HookCaller which manages calls to all registered\n    plugins except the ones from remove_plugins.\"\"\"\n\n    # This class is unusual: in inhertits from `HookCaller` so all of\n    # the *code* runs in the class, but it delegates all underlying *data*\n    # to the original HookCaller.\n    # `subset_hook_caller` used to be implemented by creating a full-fledged\n    # HookCaller, copying all hookimpls from the original. This had problems\n    # with memory leaks (#346) and historic calls (#347), which make a proxy\n    # approach better.\n    # An alternative implementation is to use a `_getattr__`/`__getattribute__`\n    # proxy, however that adds more overhead and is more tricky to implement.\n\n    __slots__ = (\n        \"_orig\",\n        \"_remove_plugins\",\n    )\n\n    def __init__(self, orig: HookCaller, remove_plugins: AbstractSet[_Plugin]) -> None:\n        self._orig = orig\n        self._remove_plugins = remove_plugins\n        self.name = orig.name  # type: ignore[misc]\n        self._hookexec = orig._hookexec  # type: ignore[misc]\n\n    @property  # type: ignore[misc]\n    def _hookimpls(self) -> list[HookImpl]:\n        return [\n            impl\n            for impl in self._orig._hookimpls\n            if impl.plugin not in self._remove_plugins\n        ]\n\n    @property\n    def spec(self) -> HookSpec | None:  # type: ignore[override]\n        return self._orig.spec\n\n    @property\n    def _call_history(self) -> _CallHistory | None:  # type: ignore[override]\n        return self._orig._call_history\n\n    def __repr__(self) -> str:\n        return f\"<_SubsetHookCaller {self.name!r}>\"\n\n\n@final\nclass HookImpl:\n    \"\"\"A hook implementation in a :class:`HookCaller`.\"\"\"\n\n    __slots__ = (\n        \"function\",\n        \"argnames\",\n        \"kwargnames\",\n        \"plugin\",\n        \"opts\",\n        \"plugin_name\",\n        \"wrapper\",\n        \"hookwrapper\",\n        \"optionalhook\",\n        \"tryfirst\",\n        \"trylast\",\n    )\n\n    def __init__(\n        self,\n        plugin: _Plugin,\n        plugin_name: str,\n        function: _HookImplFunction[object],\n        hook_impl_opts: HookimplOpts,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        #: The hook implementation function.\n        self.function: Final = function\n        argnames, kwargnames = varnames(self.function)\n        #: The positional parameter names of ``function```.\n        self.argnames: Final = argnames\n        #: The keyword parameter names of ``function```.\n        self.kwargnames: Final = kwargnames\n        #: The plugin which defined this hook implementation.\n        self.plugin: Final = plugin\n        #: The :class:`HookimplOpts` used to configure this hook implementation.\n        self.opts: Final = hook_impl_opts\n        #: The name of the plugin which defined this hook implementation.\n        self.plugin_name: Final = plugin_name\n        #: Whether the hook implementation is a :ref:`wrapper <hookwrapper>`.\n        self.wrapper: Final = hook_impl_opts[\"wrapper\"]\n        #: Whether the hook implementation is an :ref:`old-style wrapper\n        #: <old_style_hookwrappers>`.\n        self.hookwrapper: Final = hook_impl_opts[\"hookwrapper\"]\n        #: Whether validation against a hook specification is :ref:`optional\n        #: <optionalhook>`.\n        self.optionalhook: Final = hook_impl_opts[\"optionalhook\"]\n        #: Whether to try to order this hook implementation :ref:`first\n        #: <callorder>`.\n        self.tryfirst: Final = hook_impl_opts[\"tryfirst\"]\n        #: Whether to try to order this hook implementation :ref:`last\n        #: <callorder>`.\n        self.trylast: Final = hook_impl_opts[\"trylast\"]\n\n    def __repr__(self) -> str:\n        return f\"<HookImpl plugin_name={self.plugin_name!r}, plugin={self.plugin!r}>\"\n\n\n@final\nclass HookSpec:\n    __slots__ = (\n        \"namespace\",\n        \"function\",\n        \"name\",\n        \"argnames\",\n        \"kwargnames\",\n        \"opts\",\n        \"warn_on_impl\",\n        \"warn_on_impl_args\",\n    )\n\n    def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:\n        self.namespace = namespace\n        self.function: Callable[..., object] = getattr(namespace, name)\n        self.name = name\n        self.argnames, self.kwargnames = varnames(self.function)\n        self.opts = opts\n        self.warn_on_impl = opts.get(\"warn_on_impl\")\n        self.warn_on_impl_args = opts.get(\"warn_on_impl_args\")\n", "src/pluggy/_manager.py": "from __future__ import annotations\n\nimport inspect\nimport types\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Final\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Sequence\nfrom typing import TYPE_CHECKING\nimport warnings\n\nfrom . import _tracing\nfrom ._callers import _multicall\nfrom ._hooks import _HookImplFunction\nfrom ._hooks import _Namespace\nfrom ._hooks import _Plugin\nfrom ._hooks import _SubsetHookCaller\nfrom ._hooks import HookCaller\nfrom ._hooks import HookImpl\nfrom ._hooks import HookimplOpts\nfrom ._hooks import HookRelay\nfrom ._hooks import HookspecOpts\nfrom ._hooks import normalize_hookimpl_opts\nfrom ._result import Result\n\n\nif TYPE_CHECKING:\n    # importtlib.metadata import is slow, defer it.\n    import importlib.metadata\n\n\n_BeforeTrace = Callable[[str, Sequence[HookImpl], Mapping[str, Any]], None]\n_AfterTrace = Callable[[Result[Any], str, Sequence[HookImpl], Mapping[str, Any]], None]\n\n\ndef _warn_for_function(warning: Warning, function: Callable[..., object]) -> None:\n    func = cast(types.FunctionType, function)\n    warnings.warn_explicit(\n        warning,\n        type(warning),\n        lineno=func.__code__.co_firstlineno,\n        filename=func.__code__.co_filename,\n    )\n\n\nclass PluginValidationError(Exception):\n    \"\"\"Plugin failed validation.\n\n    :param plugin: The plugin which failed validation.\n    :param message: Error message.\n    \"\"\"\n\n    def __init__(self, plugin: _Plugin, message: str) -> None:\n        super().__init__(message)\n        #: The plugin which failed validation.\n        self.plugin = plugin\n\n\nclass DistFacade:\n    \"\"\"Emulate a pkg_resources Distribution\"\"\"\n\n    def __init__(self, dist: importlib.metadata.Distribution) -> None:\n        self._dist = dist\n\n    @property\n    def project_name(self) -> str:\n        name: str = self.metadata[\"name\"]\n        return name\n\n    def __getattr__(self, attr: str, default=None):\n        return getattr(self._dist, attr, default)\n\n    def __dir__(self) -> list[str]:\n        return sorted(dir(self._dist) + [\"_dist\", \"project_name\"])\n\n\nclass PluginManager:\n    \"\"\"Core class which manages registration of plugin objects and 1:N hook\n    calling.\n\n    You can register new hooks by calling :meth:`add_hookspecs(module_or_class)\n    <PluginManager.add_hookspecs>`.\n\n    You can register plugin objects (which contain hook implementations) by\n    calling :meth:`register(plugin) <PluginManager.register>`.\n\n    For debugging purposes you can call :meth:`PluginManager.enable_tracing`\n    which will subsequently send debug information to the trace helper.\n\n    :param project_name:\n        The short project name. Prefer snake case. Make sure it's unique!\n    \"\"\"\n\n    def __init__(self, project_name: str) -> None:\n        #: The project name.\n        self.project_name: Final = project_name\n        self._name2plugin: Final[dict[str, _Plugin]] = {}\n        self._plugin_distinfo: Final[list[tuple[_Plugin, DistFacade]]] = []\n        #: The \"hook relay\", used to call a hook on all registered plugins.\n        #: See :ref:`calling`.\n        self.hook: Final = HookRelay()\n        #: The tracing entry point. See :ref:`tracing`.\n        self.trace: Final[_tracing.TagTracerSub] = _tracing.TagTracer().get(\n            \"pluginmanage\"\n        )\n        self._inner_hookexec = _multicall\n\n    def _hookexec(\n        self,\n        hook_name: str,\n        methods: Sequence[HookImpl],\n        kwargs: Mapping[str, object],\n        firstresult: bool,\n    ) -> object | list[object]:\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n        return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n    def register(self, plugin: _Plugin, name: str | None = None) -> str | None:\n        \"\"\"Register a plugin and return its name.\n\n        :param name:\n            The name under which to register the plugin. If not specified, a\n            name is generated using :func:`get_canonical_name`.\n\n        :returns:\n            The plugin name. If the name is blocked from registering, returns\n            ``None``.\n\n        If the plugin is already registered, raises a :exc:`ValueError`.\n        \"\"\"\n        plugin_name = name or self.get_canonical_name(plugin)\n\n        if plugin_name in self._name2plugin:\n            if self._name2plugin.get(plugin_name, -1) is None:\n                return None  # blocked plugin, return None to indicate no registration\n            raise ValueError(\n                \"Plugin name already registered: %s=%s\\n%s\"\n                % (plugin_name, plugin, self._name2plugin)\n            )\n\n        if plugin in self._name2plugin.values():\n            raise ValueError(\n                \"Plugin already registered under a different name: %s=%s\\n%s\"\n                % (plugin_name, plugin, self._name2plugin)\n            )\n\n        # XXX if an error happens we should make sure no state has been\n        # changed at point of return\n        self._name2plugin[plugin_name] = plugin\n\n        # register matching hook implementations of the plugin\n        for name in dir(plugin):\n            hookimpl_opts = self.parse_hookimpl_opts(plugin, name)\n            if hookimpl_opts is not None:\n                normalize_hookimpl_opts(hookimpl_opts)\n                method: _HookImplFunction[object] = getattr(plugin, name)\n                hookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)\n                name = hookimpl_opts.get(\"specname\") or name\n                hook: HookCaller | None = getattr(self.hook, name, None)\n                if hook is None:\n                    hook = HookCaller(name, self._hookexec)\n                    setattr(self.hook, name, hook)\n                elif hook.has_spec():\n                    self._verify_hook(hook, hookimpl)\n                    hook._maybe_apply_history(hookimpl)\n                hook._add_hookimpl(hookimpl)\n        return plugin_name\n\n    def parse_hookimpl_opts(self, plugin: _Plugin, name: str) -> HookimplOpts | None:\n        \"\"\"Try to obtain a hook implementation from an item with the given name\n        in the given plugin which is being searched for hook impls.\n\n        :returns:\n            The parsed hookimpl options, or None to skip the given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook implementation are picked up. By default, returns the\n        options for items decorated with :class:`HookimplMarker`.\n        \"\"\"\n        method: object = getattr(plugin, name)\n        if not inspect.isroutine(method):\n            return None\n        try:\n            res: HookimplOpts | None = getattr(\n                method, self.project_name + \"_impl\", None\n            )\n        except Exception:\n            res = {}  # type: ignore[assignment]\n        if res is not None and not isinstance(res, dict):\n            # false positive\n            res = None  # type:ignore[unreachable]\n        return res\n\n    def unregister(\n        self, plugin: _Plugin | None = None, name: str | None = None\n    ) -> Any | None:\n        \"\"\"Unregister a plugin and all of its hook implementations.\n\n        The plugin can be specified either by the plugin object or the plugin\n        name. If both are specified, they must agree.\n\n        Returns the unregistered plugin, or ``None`` if not found.\n        \"\"\"\n        if name is None:\n            assert plugin is not None, \"one of name or plugin needs to be specified\"\n            name = self.get_name(plugin)\n            assert name is not None, \"plugin is not registered\"\n\n        if plugin is None:\n            plugin = self.get_plugin(name)\n            if plugin is None:\n                return None\n\n        hookcallers = self.get_hookcallers(plugin)\n        if hookcallers:\n            for hookcaller in hookcallers:\n                hookcaller._remove_plugin(plugin)\n\n        # if self._name2plugin[name] == None registration was blocked: ignore\n        if self._name2plugin.get(name):\n            assert name is not None\n            del self._name2plugin[name]\n\n        return plugin\n\n    def set_blocked(self, name: str) -> None:\n        \"\"\"Block registrations of the given name, unregister if already registered.\"\"\"\n        self.unregister(name=name)\n        self._name2plugin[name] = None\n\n    def is_blocked(self, name: str) -> bool:\n        \"\"\"Return whether the given plugin name is blocked.\"\"\"\n        return name in self._name2plugin and self._name2plugin[name] is None\n\n    def unblock(self, name: str) -> bool:\n        \"\"\"Unblocks a name.\n\n        Returns whether the name was actually blocked.\n        \"\"\"\n        if self._name2plugin.get(name, -1) is None:\n            del self._name2plugin[name]\n            return True\n        return False\n\n    def add_hookspecs(self, module_or_class: _Namespace) -> None:\n        \"\"\"Add new hook specifications defined in the given ``module_or_class``.\n\n        Functions are recognized as hook specifications if they have been\n        decorated with a matching :class:`HookspecMarker`.\n        \"\"\"\n        names = []\n        for name in dir(module_or_class):\n            spec_opts = self.parse_hookspec_opts(module_or_class, name)\n            if spec_opts is not None:\n                hc: HookCaller | None = getattr(self.hook, name, None)\n                if hc is None:\n                    hc = HookCaller(name, self._hookexec, module_or_class, spec_opts)\n                    setattr(self.hook, name, hc)\n                else:\n                    # Plugins registered this hook without knowing the spec.\n                    hc.set_specification(module_or_class, spec_opts)\n                    for hookfunction in hc.get_hookimpls():\n                        self._verify_hook(hc, hookfunction)\n                names.append(name)\n\n        if not names:\n            raise ValueError(\n                f\"did not find any {self.project_name!r} hooks in {module_or_class!r}\"\n            )\n\n    def parse_hookspec_opts(\n        self, module_or_class: _Namespace, name: str\n    ) -> HookspecOpts | None:\n        \"\"\"Try to obtain a hook specification from an item with the given name\n        in the given module or class which is being searched for hook specs.\n\n        :returns:\n            The parsed hookspec options for defining a hook, or None to skip the\n            given item.\n\n        This method can be overridden by ``PluginManager`` subclasses to\n        customize how hook specifications are picked up. By default, returns the\n        options for items decorated with :class:`HookspecMarker`.\n        \"\"\"\n        method = getattr(module_or_class, name)\n        opts: HookspecOpts | None = getattr(method, self.project_name + \"_spec\", None)\n        return opts\n\n    def get_plugins(self) -> set[Any]:\n        \"\"\"Return a set of all registered plugin objects.\"\"\"\n        return {x for x in self._name2plugin.values() if x is not None}\n\n    def is_registered(self, plugin: _Plugin) -> bool:\n        \"\"\"Return whether the plugin is already registered.\"\"\"\n        return any(plugin == val for val in self._name2plugin.values())\n\n    def get_canonical_name(self, plugin: _Plugin) -> str:\n        \"\"\"Return a canonical name for a plugin object.\n\n        Note that a plugin may be registered under a different name\n        specified by the caller of :meth:`register(plugin, name) <register>`.\n        To obtain the name of a registered plugin use :meth:`get_name(plugin)\n        <get_name>` instead.\n        \"\"\"\n        name: str | None = getattr(plugin, \"__name__\", None)\n        return name or str(id(plugin))\n\n    def get_plugin(self, name: str) -> Any | None:\n        \"\"\"Return the plugin registered under the given name, if any.\"\"\"\n        return self._name2plugin.get(name)\n\n    def has_plugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n        return self.get_plugin(name) is not None\n\n    def get_name(self, plugin: _Plugin) -> str | None:\n        \"\"\"Return the name the plugin is registered under, or ``None`` if\n        is isn't.\"\"\"\n        for name, val in self._name2plugin.items():\n            if plugin == val:\n                return name\n        return None\n\n    def _verify_hook(self, hook: HookCaller, hookimpl: HookImpl) -> None:\n        if hook.is_historic() and (hookimpl.hookwrapper or hookimpl.wrapper):\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r\\nhook %r\\nhistoric incompatible with yield/wrapper/hookwrapper\"\n                % (hookimpl.plugin_name, hook.name),\n            )\n\n        assert hook.spec is not None\n        if hook.spec.warn_on_impl:\n            _warn_for_function(hook.spec.warn_on_impl, hookimpl.function)\n\n        # positional arg checking\n        notinspec = set(hookimpl.argnames) - set(hook.spec.argnames)\n        if notinspec:\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"Argument(s) %s are declared in the hookimpl but \"\n                \"can not be found in the hookspec\"\n                % (\n                    hookimpl.plugin_name,\n                    hook.name,\n                    _formatdef(hookimpl.function),\n                    notinspec,\n                ),\n            )\n\n        if hook.spec.warn_on_impl_args:\n            for hookimpl_argname in hookimpl.argnames:\n                argname_warning = hook.spec.warn_on_impl_args.get(hookimpl_argname)\n                if argname_warning is not None:\n                    _warn_for_function(argname_warning, hookimpl.function)\n\n        if (\n            hookimpl.wrapper or hookimpl.hookwrapper\n        ) and not inspect.isgeneratorfunction(hookimpl.function):\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"Declared as wrapper=True or hookwrapper=True \"\n                \"but function is not a generator function\"\n                % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),\n            )\n\n        if hookimpl.wrapper and hookimpl.hookwrapper:\n            raise PluginValidationError(\n                hookimpl.plugin,\n                \"Plugin %r for hook %r\\nhookimpl definition: %s\\n\"\n                \"The wrapper=True and hookwrapper=True options are mutually exclusive\"\n                % (hookimpl.plugin_name, hook.name, _formatdef(hookimpl.function)),\n            )\n\n    def check_pending(self) -> None:\n        \"\"\"Verify that all hooks which have not been verified against a\n        hook specification are optional, otherwise raise\n        :exc:`PluginValidationError`.\"\"\"\n        for name in self.hook.__dict__:\n            if name[0] != \"_\":\n                hook: HookCaller = getattr(self.hook, name)\n                if not hook.has_spec():\n                    for hookimpl in hook.get_hookimpls():\n                        if not hookimpl.optionalhook:\n                            raise PluginValidationError(\n                                hookimpl.plugin,\n                                \"unknown hook %r in plugin %r\"\n                                % (name, hookimpl.plugin),\n                            )\n\n    def load_setuptools_entrypoints(self, group: str, name: str | None = None) -> int:\n        \"\"\"Load modules from querying the specified setuptools ``group``.\n\n        :param group:\n            Entry point group to load plugins.\n        :param name:\n            If given, loads only plugins with the given ``name``.\n\n        :return:\n            The number of plugins loaded by this call.\n        \"\"\"\n        import importlib.metadata\n\n        count = 0\n        for dist in list(importlib.metadata.distributions()):\n            for ep in dist.entry_points:\n                if (\n                    ep.group != group\n                    or (name is not None and ep.name != name)\n                    # already registered\n                    or self.get_plugin(ep.name)\n                    or self.is_blocked(ep.name)\n                ):\n                    continue\n                plugin = ep.load()\n                self.register(plugin, name=ep.name)\n                self._plugin_distinfo.append((plugin, DistFacade(dist)))\n                count += 1\n        return count\n\n    def list_plugin_distinfo(self) -> list[tuple[_Plugin, DistFacade]]:\n        \"\"\"Return a list of (plugin, distinfo) pairs for all\n        setuptools-registered plugins.\"\"\"\n        return list(self._plugin_distinfo)\n\n    def list_name_plugin(self) -> list[tuple[str, _Plugin]]:\n        \"\"\"Return a list of (name, plugin) pairs for all registered plugins.\"\"\"\n        return list(self._name2plugin.items())\n\n    def get_hookcallers(self, plugin: _Plugin) -> list[HookCaller] | None:\n        \"\"\"Get all hook callers for the specified plugin.\n\n        :returns:\n            The hook callers, or ``None`` if ``plugin`` is not registered in\n            this plugin manager.\n        \"\"\"\n        if self.get_name(plugin) is None:\n            return None\n        hookcallers = []\n        for hookcaller in self.hook.__dict__.values():\n            for hookimpl in hookcaller.get_hookimpls():\n                if hookimpl.plugin is plugin:\n                    hookcallers.append(hookcaller)\n        return hookcallers\n\n    def add_hookcall_monitoring(\n        self, before: _BeforeTrace, after: _AfterTrace\n    ) -> Callable[[], None]:\n        \"\"\"Add before/after tracing functions for all hooks.\n\n        Returns an undo function which, when called, removes the added tracers.\n\n        ``before(hook_name, hook_impls, kwargs)`` will be called ahead\n        of all hook calls and receive a hookcaller instance, a list\n        of HookImpl instances and the keyword arguments for the hook call.\n\n        ``after(outcome, hook_name, hook_impls, kwargs)`` receives the\n        same arguments as ``before`` but also a :class:`~pluggy.Result` object\n        which represents the result of the overall hook call.\n        \"\"\"\n        oldcall = self._inner_hookexec\n\n        def traced_hookexec(\n            hook_name: str,\n            hook_impls: Sequence[HookImpl],\n            caller_kwargs: Mapping[str, object],\n            firstresult: bool,\n        ) -> object | list[object]:\n            before(hook_name, hook_impls, caller_kwargs)\n            outcome = Result.from_call(\n                lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\n            )\n            after(outcome, hook_name, hook_impls, caller_kwargs)\n            return outcome.get_result()\n\n        self._inner_hookexec = traced_hookexec\n\n        def undo() -> None:\n            self._inner_hookexec = oldcall\n\n        return undo\n\n    def enable_tracing(self) -> Callable[[], None]:\n        \"\"\"Enable tracing of hook calls.\n\n        Returns an undo function which, when called, removes the added tracing.\n        \"\"\"\n        hooktrace = self.trace.root.get(\"hook\")\n\n        def before(\n            hook_name: str, methods: Sequence[HookImpl], kwargs: Mapping[str, object]\n        ) -> None:\n            hooktrace.root.indent += 1\n            hooktrace(hook_name, kwargs)\n\n        def after(\n            outcome: Result[object],\n            hook_name: str,\n            methods: Sequence[HookImpl],\n            kwargs: Mapping[str, object],\n        ) -> None:\n            if outcome.exception is None:\n                hooktrace(\"finish\", hook_name, \"-->\", outcome.get_result())\n            hooktrace.root.indent -= 1\n\n        return self.add_hookcall_monitoring(before, after)\n\n    def subset_hook_caller(\n        self, name: str, remove_plugins: Iterable[_Plugin]\n    ) -> HookCaller:\n        \"\"\"Return a proxy :class:`~pluggy.HookCaller` instance for the named\n        method which manages calls to all registered plugins except the ones\n        from remove_plugins.\"\"\"\n        orig: HookCaller = getattr(self.hook, name)\n        plugins_to_remove = {plug for plug in remove_plugins if hasattr(plug, name)}\n        if plugins_to_remove:\n            return _SubsetHookCaller(orig, plugins_to_remove)\n        return orig\n\n\ndef _formatdef(func: Callable[..., object]) -> str:\n    return f\"{func.__name__}{inspect.signature(func)}\"\n", "src/pluggy/__init__.py": "try:\n    from ._version import version as __version__\nexcept ImportError:\n    # broken installation, we don't even try\n    # unknown only works because we do poor mans version compare\n    __version__ = \"unknown\"\n\n__all__ = [\n    \"__version__\",\n    \"PluginManager\",\n    \"PluginValidationError\",\n    \"HookCaller\",\n    \"HookCallError\",\n    \"HookspecOpts\",\n    \"HookimplOpts\",\n    \"HookImpl\",\n    \"HookRelay\",\n    \"HookspecMarker\",\n    \"HookimplMarker\",\n    \"Result\",\n    \"PluggyWarning\",\n    \"PluggyTeardownRaisedWarning\",\n]\n\nfrom ._hooks import HookCaller\nfrom ._hooks import HookImpl\nfrom ._hooks import HookimplMarker\nfrom ._hooks import HookimplOpts\nfrom ._hooks import HookRelay\nfrom ._hooks import HookspecMarker\nfrom ._hooks import HookspecOpts\nfrom ._manager import PluginManager\nfrom ._manager import PluginValidationError\nfrom ._result import HookCallError\nfrom ._result import Result\nfrom ._warnings import PluggyTeardownRaisedWarning\nfrom ._warnings import PluggyWarning\n", "src/pluggy/_result.py": "\"\"\"\nHook wrapper \"result\" utilities.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom types import TracebackType\nfrom typing import Callable\nfrom typing import cast\nfrom typing import final\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TypeVar\n\n\n_ExcInfo = Tuple[Type[BaseException], BaseException, Optional[TracebackType]]\nResultType = TypeVar(\"ResultType\")\n\n\nclass HookCallError(Exception):\n    \"\"\"Hook was called incorrectly.\"\"\"\n\n\n@final\nclass Result(Generic[ResultType]):\n    \"\"\"An object used to inspect and set the result in a :ref:`hook wrapper\n    <hookwrappers>`.\"\"\"\n\n    __slots__ = (\"_result\", \"_exception\", \"_traceback\")\n\n    def __init__(\n        self,\n        result: ResultType | None,\n        exception: BaseException | None,\n    ) -> None:\n        \"\"\":meta private:\"\"\"\n        self._result = result\n        self._exception = exception\n        # Exception __traceback__ is mutable, this keeps the original.\n        self._traceback = exception.__traceback__ if exception is not None else None\n\n    @property\n    def excinfo(self) -> _ExcInfo | None:\n        \"\"\":meta private:\"\"\"\n        exc = self._exception\n        if exc is None:\n            return None\n        else:\n            return (type(exc), exc, self._traceback)\n\n    @property\n    def exception(self) -> BaseException | None:\n        \"\"\":meta private:\"\"\"\n        return self._exception\n\n    @classmethod\n    def from_call(cls, func: Callable[[], ResultType]) -> Result[ResultType]:\n        \"\"\":meta private:\"\"\"\n        __tracebackhide__ = True\n        result = exception = None\n        try:\n            result = func()\n        except BaseException as exc:\n            exception = exc\n        return cls(result, exception)\n\n    def force_result(self, result: ResultType) -> None:\n        \"\"\"Force the result(s) to ``result``.\n\n        If the hook was marked as a ``firstresult`` a single value should\n        be set, otherwise set a (modified) list of results. Any exceptions\n        found during invocation will be deleted.\n\n        This overrides any previous result or exception.\n        \"\"\"\n        self._result = result\n        self._exception = None\n        self._traceback = None\n\n    def force_exception(self, exception: BaseException) -> None:\n        \"\"\"Force the result to fail with ``exception``.\n\n        This overrides any previous result or exception.\n\n        .. versionadded:: 1.1.0\n        \"\"\"\n        self._result = None\n        self._exception = exception\n        self._traceback = exception.__traceback__ if exception is not None else None\n\n    def get_result(self) -> ResultType:\n        \"\"\"Get the result(s) for this hook call.\n\n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned, otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        exc = self._exception\n        tb = self._traceback\n        if exc is None:\n            return cast(ResultType, self._result)\n        else:\n            raise exc.with_traceback(tb)\n\n\n# Historical name (pluggy<=1.2), kept for backward compatibility.\n_Result = Result\n", "src/pluggy/_callers.py": "\"\"\"\nCall loop machinery\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import cast\nfrom typing import Generator\nfrom typing import Mapping\nfrom typing import NoReturn\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nimport warnings\n\nfrom ._hooks import HookImpl\nfrom ._result import HookCallError\nfrom ._result import Result\nfrom ._warnings import PluggyTeardownRaisedWarning\n\n\n# Need to distinguish between old- and new-style hook wrappers.\n# Wrapping with a tuple is the fastest type-safe way I found to do it.\nTeardown = Union[\n    Tuple[Generator[None, Result[object], None], HookImpl],\n    Generator[None, object, object],\n]\n\n\ndef _raise_wrapfail(\n    wrap_controller: (\n        Generator[None, Result[object], None] | Generator[None, object, object]\n    ),\n    msg: str,\n) -> NoReturn:\n    co = wrap_controller.gi_code\n    raise RuntimeError(\n        \"wrap_controller at %r %s:%d %s\"\n        % (co.co_name, co.co_filename, co.co_firstlineno, msg)\n    )\n\n\ndef _warn_teardown_exception(\n    hook_name: str, hook_impl: HookImpl, e: BaseException\n) -> None:\n    msg = \"A plugin raised an exception during an old-style hookwrapper teardown.\\n\"\n    msg += f\"Plugin: {hook_impl.plugin_name}, Hook: {hook_name}\\n\"\n    msg += f\"{type(e).__name__}: {e}\\n\"\n    msg += \"For more information see https://pluggy.readthedocs.io/en/stable/api_reference.html#pluggy.PluggyTeardownRaisedWarning\"  # noqa: E501\n    warnings.warn(PluggyTeardownRaisedWarning(msg), stacklevel=5)\n\n\ndef _multicall(\n    hook_name: str,\n    hook_impls: Sequence[HookImpl],\n    caller_kwargs: Mapping[str, object],\n    firstresult: bool,\n) -> object | list[object]:\n    \"\"\"Execute a call into multiple python functions/methods and return the\n    result(s).\n\n    ``caller_kwargs`` comes from HookCaller.__call__().\n    \"\"\"\n    __tracebackhide__ = True\n    results: list[object] = []\n    exception = None\n    only_new_style_wrappers = True\n    try:  # run impl and wrapper setup functions in a loop\n        teardowns: list[Teardown] = []\n        try:\n            for hook_impl in reversed(hook_impls):\n                try:\n                    args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                except KeyError:\n                    for argname in hook_impl.argnames:\n                        if argname not in caller_kwargs:\n                            raise HookCallError(\n                                f\"hook call must provide argument {argname!r}\"\n                            )\n\n                if hook_impl.hookwrapper:\n                    only_new_style_wrappers = False\n                    try:\n                        # If this cast is not valid, a type error is raised below,\n                        # which is the desired response.\n                        res = hook_impl.function(*args)\n                        wrapper_gen = cast(Generator[None, Result[object], None], res)\n                        next(wrapper_gen)  # first yield\n                        teardowns.append((wrapper_gen, hook_impl))\n                    except StopIteration:\n                        _raise_wrapfail(wrapper_gen, \"did not yield\")\n                elif hook_impl.wrapper:\n                    try:\n                        # If this cast is not valid, a type error is raised below,\n                        # which is the desired response.\n                        res = hook_impl.function(*args)\n                        function_gen = cast(Generator[None, object, object], res)\n                        next(function_gen)  # first yield\n                        teardowns.append(function_gen)\n                    except StopIteration:\n                        _raise_wrapfail(function_gen, \"did not yield\")\n                else:\n                    res = hook_impl.function(*args)\n                    if res is not None:\n                        results.append(res)\n                        if firstresult:  # halt further impl calls\n                            break\n        except BaseException as exc:\n            exception = exc\n    finally:\n        # Fast path - only new-style wrappers, no Result.\n        if only_new_style_wrappers:\n            if firstresult:  # first result hooks return a single value\n                result = results[0] if results else None\n            else:\n                result = results\n\n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                try:\n                    if exception is not None:\n                        teardown.throw(exception)  # type: ignore[union-attr]\n                    else:\n                        teardown.send(result)  # type: ignore[union-attr]\n                    # Following is unreachable for a well behaved hook wrapper.\n                    # Try to force finalizers otherwise postponed till GC action.\n                    # Note: close() may raise if generator handles GeneratorExit.\n                    teardown.close()  # type: ignore[union-attr]\n                except StopIteration as si:\n                    result = si.value\n                    exception = None\n                    continue\n                except BaseException as e:\n                    exception = e\n                    continue\n                _raise_wrapfail(teardown, \"has second yield\")  # type: ignore[arg-type]\n\n            if exception is not None:\n                raise exception\n            else:\n                return result\n\n        # Slow path - need to support old-style wrappers.\n        else:\n            if firstresult:  # first result hooks return a single value\n                outcome: Result[object | list[object]] = Result(\n                    results[0] if results else None, exception\n                )\n            else:\n                outcome = Result(results, exception)\n\n            # run all wrapper post-yield blocks\n            for teardown in reversed(teardowns):\n                if isinstance(teardown, tuple):\n                    try:\n                        teardown[0].send(outcome)\n                    except StopIteration:\n                        pass\n                    except BaseException as e:\n                        _warn_teardown_exception(hook_name, teardown[1], e)\n                        raise\n                    else:\n                        _raise_wrapfail(teardown[0], \"has second yield\")\n                else:\n                    try:\n                        if outcome._exception is not None:\n                            teardown.throw(outcome._exception)\n                        else:\n                            teardown.send(outcome._result)\n                        # Following is unreachable for a well behaved hook wrapper.\n                        # Try to force finalizers otherwise postponed till GC action.\n                        # Note: close() may raise if generator handles GeneratorExit.\n                        teardown.close()\n                    except StopIteration as si:\n                        outcome.force_result(si.value)\n                        continue\n                    except BaseException as e:\n                        outcome.force_exception(e)\n                        continue\n                    _raise_wrapfail(teardown, \"has second yield\")\n\n            return outcome.get_result()\n"}