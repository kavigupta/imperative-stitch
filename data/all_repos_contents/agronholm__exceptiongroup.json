{"src/exceptiongroup/_suppress.py": "from __future__ import annotations\n\nimport sys\nfrom contextlib import AbstractContextManager\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Optional, Type, cast\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup\n\nif TYPE_CHECKING:\n    # requires python 3.9\n    BaseClass = AbstractContextManager[None]\nelse:\n    BaseClass = AbstractContextManager\n\n\nclass suppress(BaseClass):\n    \"\"\"Backport of :class:`contextlib.suppress` from Python 3.12.1.\"\"\"\n\n    def __init__(self, *exceptions: type[BaseException]):\n        self._exceptions = exceptions\n\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(\n        self,\n        exctype: Optional[Type[BaseException]],\n        excinst: Optional[BaseException],\n        exctb: Optional[TracebackType],\n    ) -> bool:\n        # Unlike isinstance and issubclass, CPython exception handling\n        # currently only looks at the concrete type hierarchy (ignoring\n        # the instance and subclass checking hooks). While Guido considers\n        # that a bug rather than a feature, it's a fairly hard one to fix\n        # due to various internal implementation details. suppress provides\n        # the simpler issubclass based semantics, rather than trying to\n        # exactly reproduce the limitations of the CPython interpreter.\n        #\n        # See http://bugs.python.org/issue12029 for more details\n        if exctype is None:\n            return False\n\n        if issubclass(exctype, self._exceptions):\n            return True\n\n        if issubclass(exctype, BaseExceptionGroup):\n            match, rest = cast(BaseExceptionGroup, excinst).split(self._exceptions)\n            if rest is None:\n                return True\n\n            raise rest\n\n        return False\n", "src/exceptiongroup/_exceptions.py": "from __future__ import annotations\n\nfrom collections.abc import Callable, Sequence\nfrom functools import partial\nfrom inspect import getmro, isclass\nfrom typing import TYPE_CHECKING, Generic, Type, TypeVar, cast, overload\n\n_BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True)\n_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\n# using typing.Self would require a typing_extensions dependency on py<3.11\n_ExceptionGroupSelf = TypeVar(\"_ExceptionGroupSelf\", bound=\"ExceptionGroup\")\n_BaseExceptionGroupSelf = TypeVar(\"_BaseExceptionGroupSelf\", bound=\"BaseExceptionGroup\")\n\n\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n\n    return False\n\n\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]\n    | Callable[[_BaseExceptionT_co], bool],\n) -> Callable[[_BaseExceptionT_co], bool]:\n    if isclass(condition) and issubclass(\n        cast(Type[BaseException], condition), BaseException\n    ):\n        return partial(check_direct_subclass, parents=(condition,))\n    elif isinstance(condition, tuple):\n        if all(isclass(x) and issubclass(x, BaseException) for x in condition):\n            return partial(check_direct_subclass, parents=condition)\n    elif callable(condition):\n        return cast(\"Callable[[BaseException], bool]\", condition)\n\n    raise TypeError(\"expected a function, exception type or tuple of exception types\")\n\n\ndef _derive_and_copy_attributes(self, excs):\n    eg = self.derive(excs)\n    eg.__cause__ = self.__cause__\n    eg.__context__ = self.__context__\n    eg.__traceback__ = self.__traceback__\n    if hasattr(self, \"__notes__\"):\n        # Create a new list so that add_note() only affects one exceptiongroup\n        eg.__notes__ = list(self.__notes__)\n    return eg\n\n\nclass BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n    \"\"\"A combination of multiple unrelated exceptions.\"\"\"\n\n    def __new__(\n        cls: type[_BaseExceptionGroupSelf],\n        __message: str,\n        __exceptions: Sequence[_BaseExceptionT_co],\n    ) -> _BaseExceptionGroupSelf:\n        if not isinstance(__message, str):\n            raise TypeError(f\"argument 1 must be str, not {type(__message)}\")\n        if not isinstance(__exceptions, Sequence):\n            raise TypeError(\"second argument (exceptions) must be a sequence\")\n        if not __exceptions:\n            raise ValueError(\n                \"second argument (exceptions) must be a non-empty sequence\"\n            )\n\n        for i, exc in enumerate(__exceptions):\n            if not isinstance(exc, BaseException):\n                raise ValueError(\n                    f\"Item {i} of second argument (exceptions) is not an exception\"\n                )\n\n        if cls is BaseExceptionGroup:\n            if all(isinstance(exc, Exception) for exc in __exceptions):\n                cls = ExceptionGroup\n\n        if issubclass(cls, Exception):\n            for exc in __exceptions:\n                if not isinstance(exc, Exception):\n                    if cls is ExceptionGroup:\n                        raise TypeError(\n                            \"Cannot nest BaseExceptions in an ExceptionGroup\"\n                        )\n                    else:\n                        raise TypeError(\n                            f\"Cannot nest BaseExceptions in {cls.__name__!r}\"\n                        )\n\n        instance = super().__new__(cls, __message, __exceptions)\n        instance._message = __message\n        instance._exceptions = __exceptions\n        return instance\n\n    def add_note(self, note: str) -> None:\n        if not isinstance(note, str):\n            raise TypeError(\n                f\"Expected a string, got note={note!r} (type {type(note).__name__})\"\n            )\n\n        if not hasattr(self, \"__notes__\"):\n            self.__notes__: list[str] = []\n\n        self.__notes__.append(note)\n\n    @property\n    def message(self) -> str:\n        return self._message\n\n    @property\n    def exceptions(\n        self,\n    ) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]:\n        return tuple(self._exceptions)\n\n    @overload\n    def subgroup(\n        self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n    ) -> ExceptionGroup[_ExceptionT] | None: ...\n\n    @overload\n    def subgroup(\n        self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n    ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...\n\n    @overload\n    def subgroup(\n        self,\n        __condition: Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...\n\n    def subgroup(\n        self,\n        __condition: type[_BaseExceptionT]\n        | tuple[type[_BaseExceptionT], ...]\n        | Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> BaseExceptionGroup[_BaseExceptionT] | None:\n        condition = get_condition_filter(__condition)\n        modified = False\n        if condition(self):\n            return self\n\n        exceptions: list[BaseException] = []\n        for exc in self.exceptions:\n            if isinstance(exc, BaseExceptionGroup):\n                subgroup = exc.subgroup(__condition)\n                if subgroup is not None:\n                    exceptions.append(subgroup)\n\n                if subgroup is not exc:\n                    modified = True\n            elif condition(exc):\n                exceptions.append(exc)\n            else:\n                modified = True\n\n        if not modified:\n            return self\n        elif exceptions:\n            group = _derive_and_copy_attributes(self, exceptions)\n            return group\n        else:\n            return None\n\n    @overload\n    def split(\n        self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n    ) -> tuple[\n        ExceptionGroup[_ExceptionT] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    @overload\n    def split(\n        self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n    ) -> tuple[\n        BaseExceptionGroup[_BaseExceptionT] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    @overload\n    def split(\n        self,\n        __condition: Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> tuple[\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    def split(\n        self,\n        __condition: type[_BaseExceptionT]\n        | tuple[type[_BaseExceptionT], ...]\n        | Callable[[_BaseExceptionT_co], bool],\n    ) -> (\n        tuple[\n            ExceptionGroup[_ExceptionT] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n        | tuple[\n            BaseExceptionGroup[_BaseExceptionT] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n        | tuple[\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n    ):\n        condition = get_condition_filter(__condition)\n        if condition(self):\n            return self, None\n\n        matching_exceptions: list[BaseException] = []\n        nonmatching_exceptions: list[BaseException] = []\n        for exc in self.exceptions:\n            if isinstance(exc, BaseExceptionGroup):\n                matching, nonmatching = exc.split(condition)\n                if matching is not None:\n                    matching_exceptions.append(matching)\n\n                if nonmatching is not None:\n                    nonmatching_exceptions.append(nonmatching)\n            elif condition(exc):\n                matching_exceptions.append(exc)\n            else:\n                nonmatching_exceptions.append(exc)\n\n        matching_group: _BaseExceptionGroupSelf | None = None\n        if matching_exceptions:\n            matching_group = _derive_and_copy_attributes(self, matching_exceptions)\n\n        nonmatching_group: _BaseExceptionGroupSelf | None = None\n        if nonmatching_exceptions:\n            nonmatching_group = _derive_and_copy_attributes(\n                self, nonmatching_exceptions\n            )\n\n        return matching_group, nonmatching_group\n\n    @overload\n    def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...\n\n    @overload\n    def derive(\n        self, __excs: Sequence[_BaseExceptionT]\n    ) -> BaseExceptionGroup[_BaseExceptionT]: ...\n\n    def derive(\n        self, __excs: Sequence[_BaseExceptionT]\n    ) -> BaseExceptionGroup[_BaseExceptionT]:\n        return BaseExceptionGroup(self.message, __excs)\n\n    def __str__(self) -> str:\n        suffix = \"\" if len(self._exceptions) == 1 else \"s\"\n        return f\"{self.message} ({len(self._exceptions)} sub-exception{suffix})\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.message!r}, {self._exceptions!r})\"\n\n\nclass ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n    def __new__(\n        cls: type[_ExceptionGroupSelf],\n        __message: str,\n        __exceptions: Sequence[_ExceptionT_co],\n    ) -> _ExceptionGroupSelf:\n        return super().__new__(cls, __message, __exceptions)\n\n    if TYPE_CHECKING:\n\n        @property\n        def exceptions(\n            self,\n        ) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...\n\n        @overload  # type: ignore[override]\n        def subgroup(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n\n        @overload\n        def subgroup(\n            self, __condition: Callable[[_ExceptionT_co | _ExceptionGroupSelf], bool]\n        ) -> ExceptionGroup[_ExceptionT_co] | None: ...\n\n        def subgroup(\n            self,\n            __condition: type[_ExceptionT]\n            | tuple[type[_ExceptionT], ...]\n            | Callable[[_ExceptionT_co], bool],\n        ) -> ExceptionGroup[_ExceptionT] | None:\n            return super().subgroup(__condition)\n\n        @overload\n        def split(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]: ...\n\n        @overload\n        def split(\n            self, __condition: Callable[[_ExceptionT_co | _ExceptionGroupSelf], bool]\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]: ...\n\n        def split(\n            self: _ExceptionGroupSelf,\n            __condition: type[_ExceptionT]\n            | tuple[type[_ExceptionT], ...]\n            | Callable[[_ExceptionT_co], bool],\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]:\n            return super().split(__condition)\n", "src/exceptiongroup/_catch.py": "from __future__ import annotations\n\nimport inspect\nimport sys\nfrom collections.abc import Callable, Iterable, Mapping\nfrom contextlib import AbstractContextManager\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Any\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup\n\nif TYPE_CHECKING:\n    _Handler = Callable[[BaseExceptionGroup[Any]], Any]\n\n\nclass _Catcher:\n    def __init__(self, handler_map: Mapping[tuple[type[BaseException], ...], _Handler]):\n        self._handler_map = handler_map\n\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(\n        self,\n        etype: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool:\n        if exc is not None:\n            unhandled = self.handle_exception(exc)\n            if unhandled is exc:\n                return False\n            elif unhandled is None:\n                return True\n            else:\n                if isinstance(exc, BaseExceptionGroup):\n                    try:\n                        raise unhandled from exc.__cause__\n                    except BaseExceptionGroup:\n                        # Change __context__ to __cause__ because Python 3.11 does this\n                        # too\n                        unhandled.__context__ = exc.__cause__\n                        raise\n\n                raise unhandled from exc\n\n        return False\n\n    def handle_exception(self, exc: BaseException) -> BaseException | None:\n        excgroup: BaseExceptionGroup | None\n        if isinstance(exc, BaseExceptionGroup):\n            excgroup = exc\n        else:\n            excgroup = BaseExceptionGroup(\"\", [exc])\n\n        new_exceptions: list[BaseException] = []\n        for exc_types, handler in self._handler_map.items():\n            matched, excgroup = excgroup.split(exc_types)\n            if matched:\n                try:\n                    try:\n                        raise matched\n                    except BaseExceptionGroup:\n                        result = handler(matched)\n                except BaseExceptionGroup as new_exc:\n                    if new_exc is matched:\n                        new_exceptions.append(new_exc)\n                    else:\n                        new_exceptions.extend(new_exc.exceptions)\n                except BaseException as new_exc:\n                    new_exceptions.append(new_exc)\n                else:\n                    if inspect.iscoroutine(result):\n                        raise TypeError(\n                            f\"Error trying to handle {matched!r} with {handler!r}. \"\n                            \"Exception handler must be a sync function.\"\n                        ) from exc\n\n            if not excgroup:\n                break\n\n        if new_exceptions:\n            if len(new_exceptions) == 1:\n                return new_exceptions[0]\n\n            return BaseExceptionGroup(\"\", new_exceptions)\n        elif (\n            excgroup and len(excgroup.exceptions) == 1 and excgroup.exceptions[0] is exc\n        ):\n            return exc\n        else:\n            return excgroup\n\n\ndef catch(\n    __handlers: Mapping[type[BaseException] | Iterable[type[BaseException]], _Handler],\n) -> AbstractContextManager[None]:\n    if not isinstance(__handlers, Mapping):\n        raise TypeError(\"the argument must be a mapping\")\n\n    handler_map: dict[\n        tuple[type[BaseException], ...], Callable[[BaseExceptionGroup]]\n    ] = {}\n    for type_or_iterable, handler in __handlers.items():\n        iterable: tuple[type[BaseException]]\n        if isinstance(type_or_iterable, type) and issubclass(\n            type_or_iterable, BaseException\n        ):\n            iterable = (type_or_iterable,)\n        elif isinstance(type_or_iterable, Iterable):\n            iterable = tuple(type_or_iterable)\n        else:\n            raise TypeError(\n                \"each key must be either an exception classes or an iterable thereof\"\n            )\n\n        if not callable(handler):\n            raise TypeError(\"handlers must be callable\")\n\n        for exc_type in iterable:\n            if not isinstance(exc_type, type) or not issubclass(\n                exc_type, BaseException\n            ):\n                raise TypeError(\n                    \"each key must be either an exception classes or an iterable \"\n                    \"thereof\"\n                )\n\n            if issubclass(exc_type, BaseExceptionGroup):\n                raise TypeError(\n                    \"catching ExceptionGroup with catch() is not allowed. \"\n                    \"Use except instead.\"\n                )\n\n        handler_map[iterable] = handler\n\n    return _Catcher(handler_map)\n", "src/exceptiongroup/__init__.py": "__all__ = [\n    \"BaseExceptionGroup\",\n    \"ExceptionGroup\",\n    \"catch\",\n    \"format_exception\",\n    \"format_exception_only\",\n    \"print_exception\",\n    \"print_exc\",\n    \"suppress\",\n]\n\nimport os\nimport sys\n\nfrom ._catch import catch\nfrom ._version import version as __version__  # noqa: F401\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup, ExceptionGroup\n    from ._formatting import (\n        format_exception,\n        format_exception_only,\n        print_exc,\n        print_exception,\n    )\n\n    if os.getenv(\"EXCEPTIONGROUP_NO_PATCH\") != \"1\":\n        from . import _formatting  # noqa: F401\n\n    BaseExceptionGroup.__module__ = __name__\n    ExceptionGroup.__module__ = __name__\nelse:\n    from traceback import (\n        format_exception,\n        format_exception_only,\n        print_exc,\n        print_exception,\n    )\n\n    BaseExceptionGroup = BaseExceptionGroup\n    ExceptionGroup = ExceptionGroup\n\nif sys.version_info < (3, 12, 1):\n    from ._suppress import suppress\nelse:\n    from contextlib import suppress\n", "src/exceptiongroup/_formatting.py": "# traceback_exception_init() adapted from trio\n#\n# _ExceptionPrintContext and traceback_exception_format() copied from the standard\n# library\nfrom __future__ import annotations\n\nimport collections.abc\nimport sys\nimport textwrap\nimport traceback\nfrom functools import singledispatch\nfrom types import TracebackType\nfrom typing import Any, List, Optional\n\nfrom ._exceptions import BaseExceptionGroup\n\nmax_group_width = 15\nmax_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\n\n\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"\n    else:\n        line = f\"{etype}: {valuestr}\\n\"\n\n    return line\n\n\ndef _safe_string(value, what, func=str):\n    try:\n        return func(value)\n    except BaseException:\n        return f\"<{what} {func.__name__}() failed>\"\n\n\nclass _ExceptionPrintContext:\n    def __init__(self):\n        self.seen = set()\n        self.exception_group_depth = 0\n        self.need_close = False\n\n    def indent(self):\n        return \" \" * (2 * self.exception_group_depth)\n\n    def emit(self, text_gen, margin_char=None):\n        if margin_char is None:\n            margin_char = \"|\"\n        indent_str = self.indent()\n        if self.exception_group_depth:\n            indent_str += margin_char + \" \"\n\n        if isinstance(text_gen, str):\n            yield textwrap.indent(text_gen, indent_str, lambda line: True)\n        else:\n            for text in text_gen:\n                yield textwrap.indent(text, indent_str, lambda line: True)\n\n\ndef exceptiongroup_excepthook(\n    etype: type[BaseException], value: BaseException, tb: TracebackType | None\n) -> None:\n    sys.stderr.write(\"\".join(traceback.format_exception(etype, value, tb)))\n\n\nclass PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,\n        *,\n        limit: int | None = None,\n        lookup_lines: bool = True,\n        capture_locals: bool = False,\n        compact: bool = False,\n        _seen: set[int] | None = None,\n    ) -> None:\n        kwargs: dict[str, Any] = {}\n        if sys.version_info >= (3, 10):\n            kwargs[\"compact\"] = compact\n\n        is_recursive_call = _seen is not None\n        if _seen is None:\n            _seen = set()\n        _seen.add(id(exc_value))\n\n        self.stack = traceback.StackSummary.extract(\n            traceback.walk_tb(exc_traceback),\n            limit=limit,\n            lookup_lines=lookup_lines,\n            capture_locals=capture_locals,\n        )\n        self.exc_type = exc_type\n        # Capture now to permit freeing resources: only complication is in the\n        # unofficial API _format_final_exc_line\n        self._str = _safe_string(exc_value, \"exception\")\n        try:\n            self.__notes__ = getattr(exc_value, \"__notes__\", None)\n        except KeyError:\n            # Workaround for https://github.com/python/cpython/issues/98778 on Python\n            # <= 3.9, and some 3.10 and 3.11 patch versions.\n            HTTPError = getattr(sys.modules.get(\"urllib.error\", None), \"HTTPError\", ())\n            if sys.version_info[:2] <= (3, 11) and isinstance(exc_value, HTTPError):\n                self.__notes__ = None\n            else:\n                raise\n\n        if exc_type and issubclass(exc_type, SyntaxError):\n            # Handle SyntaxError's specially\n            self.filename = exc_value.filename\n            lno = exc_value.lineno\n            self.lineno = str(lno) if lno is not None else None\n            self.text = exc_value.text\n            self.offset = exc_value.offset\n            self.msg = exc_value.msg\n            if sys.version_info >= (3, 10):\n                end_lno = exc_value.end_lineno\n                self.end_lineno = str(end_lno) if end_lno is not None else None\n                self.end_offset = exc_value.end_offset\n        elif (\n            exc_type\n            and issubclass(exc_type, (NameError, AttributeError))\n            and getattr(exc_value, \"name\", None) is not None\n        ):\n            suggestion = _compute_suggestion_error(exc_value, exc_traceback)\n            if suggestion:\n                self._str += f\". Did you mean: '{suggestion}'?\"\n\n        if lookup_lines:\n            # Force all lines in the stack to be loaded\n            for frame in self.stack:\n                frame.line\n\n        self.__suppress_context__ = (\n            exc_value.__suppress_context__ if exc_value is not None else False\n        )\n\n        # Convert __cause__ and __context__ to `TracebackExceptions`s, use a\n        # queue to avoid recursion (only the top-level call gets _seen == None)\n        if not is_recursive_call:\n            queue = [(self, exc_value)]\n            while queue:\n                te, e = queue.pop()\n\n                if e and e.__cause__ is not None and id(e.__cause__) not in _seen:\n                    cause = PatchedTracebackException(\n                        type(e.__cause__),\n                        e.__cause__,\n                        e.__cause__.__traceback__,\n                        limit=limit,\n                        lookup_lines=lookup_lines,\n                        capture_locals=capture_locals,\n                        _seen=_seen,\n                    )\n                else:\n                    cause = None\n\n                if compact:\n                    need_context = (\n                        cause is None and e is not None and not e.__suppress_context__\n                    )\n                else:\n                    need_context = True\n                if (\n                    e\n                    and e.__context__ is not None\n                    and need_context\n                    and id(e.__context__) not in _seen\n                ):\n                    context = PatchedTracebackException(\n                        type(e.__context__),\n                        e.__context__,\n                        e.__context__.__traceback__,\n                        limit=limit,\n                        lookup_lines=lookup_lines,\n                        capture_locals=capture_locals,\n                        _seen=_seen,\n                    )\n                else:\n                    context = None\n\n                # Capture each of the exceptions in the ExceptionGroup along with each\n                # of their causes and contexts\n                if e and isinstance(e, BaseExceptionGroup):\n                    exceptions = []\n                    for exc in e.exceptions:\n                        texc = PatchedTracebackException(\n                            type(exc),\n                            exc,\n                            exc.__traceback__,\n                            lookup_lines=lookup_lines,\n                            capture_locals=capture_locals,\n                            _seen=_seen,\n                        )\n                        exceptions.append(texc)\n                else:\n                    exceptions = None\n\n                te.__cause__ = cause\n                te.__context__ = context\n                te.exceptions = exceptions\n                if cause:\n                    queue.append((te.__cause__, e.__cause__))\n                if context:\n                    queue.append((te.__context__, e.__context__))\n                if exceptions:\n                    queue.extend(zip(te.exceptions, e.exceptions))\n\n    def format(self, *, chain=True, _ctx=None):\n        if _ctx is None:\n            _ctx = _ExceptionPrintContext()\n\n        output = []\n        exc = self\n        if chain:\n            while exc:\n                if exc.__cause__ is not None:\n                    chained_msg = _cause_message\n                    chained_exc = exc.__cause__\n                elif exc.__context__ is not None and not exc.__suppress_context__:\n                    chained_msg = _context_message\n                    chained_exc = exc.__context__\n                else:\n                    chained_msg = None\n                    chained_exc = None\n\n                output.append((chained_msg, exc))\n                exc = chained_exc\n        else:\n            output.append((None, exc))\n\n        for msg, exc in reversed(output):\n            if msg is not None:\n                yield from _ctx.emit(msg)\n            if exc.exceptions is None:\n                if exc.stack:\n                    yield from _ctx.emit(\"Traceback (most recent call last):\\n\")\n                    yield from _ctx.emit(exc.stack.format())\n                yield from _ctx.emit(exc.format_exception_only())\n            elif _ctx.exception_group_depth > max_group_depth:\n                # exception group, but depth exceeds limit\n                yield from _ctx.emit(f\"... (max_group_depth is {max_group_depth})\\n\")\n            else:\n                # format exception group\n                is_toplevel = _ctx.exception_group_depth == 0\n                if is_toplevel:\n                    _ctx.exception_group_depth += 1\n\n                if exc.stack:\n                    yield from _ctx.emit(\n                        \"Exception Group Traceback (most recent call last):\\n\",\n                        margin_char=\"+\" if is_toplevel else None,\n                    )\n                    yield from _ctx.emit(exc.stack.format())\n\n                yield from _ctx.emit(exc.format_exception_only())\n                num_excs = len(exc.exceptions)\n                if num_excs <= max_group_width:\n                    n = num_excs\n                else:\n                    n = max_group_width + 1\n                _ctx.need_close = False\n                for i in range(n):\n                    last_exc = i == n - 1\n                    if last_exc:\n                        # The closing frame may be added by a recursive call\n                        _ctx.need_close = True\n\n                    if max_group_width is not None:\n                        truncated = i >= max_group_width\n                    else:\n                        truncated = False\n                    title = f\"{i + 1}\" if not truncated else \"...\"\n                    yield (\n                        _ctx.indent()\n                        + (\"+-\" if i == 0 else \"  \")\n                        + f\"+---------------- {title} ----------------\\n\"\n                    )\n                    _ctx.exception_group_depth += 1\n                    if not truncated:\n                        yield from exc.exceptions[i].format(chain=chain, _ctx=_ctx)\n                    else:\n                        remaining = num_excs - max_group_width\n                        plural = \"s\" if remaining > 1 else \"\"\n                        yield from _ctx.emit(\n                            f\"and {remaining} more exception{plural}\\n\"\n                        )\n\n                    if last_exc and _ctx.need_close:\n                        yield _ctx.indent() + \"+------------------------------------\\n\"\n                        _ctx.need_close = False\n                    _ctx.exception_group_depth -= 1\n\n                if is_toplevel:\n                    assert _ctx.exception_group_depth == 1\n                    _ctx.exception_group_depth = 0\n\n    def format_exception_only(self):\n        \"\"\"Format the exception part of the traceback.\n        The return value is a generator of strings, each ending in a newline.\n        Normally, the generator emits a single string; however, for\n        SyntaxError exceptions, it emits several lines that (when\n        printed) display detailed information about where the syntax\n        error occurred.\n        The message indicating which exception occurred is always the last\n        string in the output.\n        \"\"\"\n        if self.exc_type is None:\n            yield traceback._format_final_exc_line(None, self._str)\n            return\n\n        stype = self.exc_type.__qualname__\n        smod = self.exc_type.__module__\n        if smod not in (\"__main__\", \"builtins\"):\n            if not isinstance(smod, str):\n                smod = \"<unknown>\"\n            stype = smod + \".\" + stype\n\n        if not issubclass(self.exc_type, SyntaxError):\n            yield _format_final_exc_line(stype, self._str)\n        elif traceback_exception_format_syntax_error is not None:\n            yield from traceback_exception_format_syntax_error(self, stype)\n        else:\n            yield from traceback_exception_original_format_exception_only(self)\n\n        if isinstance(self.__notes__, collections.abc.Sequence):\n            for note in self.__notes__:\n                note = _safe_string(note, \"note\")\n                yield from [line + \"\\n\" for line in note.split(\"\\n\")]\n        elif self.__notes__ is not None:\n            yield _safe_string(self.__notes__, \"__notes__\", func=repr)\n\n\ntraceback_exception_original_format = traceback.TracebackException.format\ntraceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )\n    traceback.TracebackException.format_exception_only = (  # type: ignore[assignment]\n        PatchedTracebackException.format_exception_only\n    )\n    sys.excepthook = exceptiongroup_excepthook\n\n# Ubuntu's system Python has a sitecustomize.py file that imports\n# apport_python_hook and replaces sys.excepthook.\n#\n# The custom hook captures the error for crash reporting, and then calls\n# sys.__excepthook__ to actually print the error.\n#\n# We don't mind it capturing the error for crash reporting, but we want to\n# take over printing the error. So we monkeypatch the apport_python_hook\n# module so that instead of calling sys.__excepthook__, it calls our custom\n# hook.\n#\n# More details: https://github.com/python-trio/trio/issues/1065\nif getattr(sys.excepthook, \"__name__\", None) in (\n    \"apport_excepthook\",\n    # on ubuntu 22.10 the hook was renamed to partial_apport_excepthook\n    \"partial_apport_excepthook\",\n):\n    # patch traceback like above\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )\n    traceback.TracebackException.format_exception_only = (  # type: ignore[assignment]\n        PatchedTracebackException.format_exception_only\n    )\n\n    from types import ModuleType\n\n    import apport_python_hook\n\n    assert sys.excepthook is apport_python_hook.apport_excepthook\n\n    # monkeypatch the sys module that apport has imported\n    fake_sys = ModuleType(\"exceptiongroup_fake_sys\")\n    fake_sys.__dict__.update(sys.__dict__)\n    fake_sys.__excepthook__ = exceptiongroup_excepthook\n    apport_python_hook.sys = fake_sys\n\n\n@singledispatch\ndef format_exception_only(__exc: BaseException) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, None, compact=True\n        ).format_exception_only()\n    )\n\n\n@format_exception_only.register\ndef _(__exc: type, value: BaseException) -> List[str]:\n    return format_exception_only(value)\n\n\n@singledispatch\ndef format_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, __exc.__traceback__, limit=limit, compact=True\n        ).format(chain=chain)\n    )\n\n\n@format_exception.register\ndef _(\n    __exc: type,\n    value: BaseException,\n    tb: TracebackType,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return format_exception(value, limit, chain)\n\n\n@singledispatch\ndef print_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    if file is None:\n        file = sys.stderr\n\n    for line in PatchedTracebackException(\n        type(__exc), __exc, __exc.__traceback__, limit=limit\n    ).format(chain=chain):\n        print(line, file=file, end=\"\")\n\n\n@print_exception.register\ndef _(\n    __exc: type,\n    value: BaseException,\n    tb: TracebackType,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    print_exception(value, limit, file, chain)\n\n\ndef print_exc(\n    limit: Optional[int] = None,\n    file: Any | None = None,\n    chain: bool = True,\n) -> None:\n    value = sys.exc_info()[1]\n    print_exception(value, limit, file, chain)\n\n\n# Python levenshtein edit distance code for NameError/AttributeError\n# suggestions, backported from 3.12\n\n_MAX_CANDIDATE_ITEMS = 750\n_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\n\n\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\n\n\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)\n    if wrong_name is None or not isinstance(wrong_name, str):\n        return None\n    if isinstance(exc_value, AttributeError):\n        obj = getattr(exc_value, \"obj\", _SENTINEL)\n        if obj is _SENTINEL:\n            return None\n        obj = exc_value.obj\n        try:\n            d = dir(obj)\n        except Exception:\n            return None\n    else:\n        assert isinstance(exc_value, NameError)\n        # find most recent frame\n        if tb is None:\n            return None\n        while tb.tb_next is not None:\n            tb = tb.tb_next\n        frame = tb.tb_frame\n\n        d = list(frame.f_locals) + list(frame.f_globals) + list(frame.f_builtins)\n    if len(d) > _MAX_CANDIDATE_ITEMS:\n        return None\n    wrong_name_len = len(wrong_name)\n    if wrong_name_len > _MAX_STRING_SIZE:\n        return None\n    best_distance = wrong_name_len\n    suggestion = None\n    for possible_name in d:\n        if possible_name == wrong_name:\n            # A missing attribute is \"found\". Don't suggest it (see GH-88821).\n            continue\n        # No more than 1/3 of the involved characters should need changed.\n        max_distance = (len(possible_name) + wrong_name_len + 3) * _MOVE_COST // 6\n        # Don't take matches we've already beaten.\n        max_distance = min(max_distance, best_distance - 1)\n        current_distance = _levenshtein_distance(\n            wrong_name, possible_name, max_distance\n        )\n        if current_distance > max_distance:\n            continue\n        if not suggestion or current_distance < best_distance:\n            suggestion = possible_name\n            best_distance = current_distance\n    return suggestion\n\n\ndef _levenshtein_distance(a, b, max_cost):\n    # A Python implementation of Python/suggestions.c:levenshtein_distance.\n\n    # Both strings are the same\n    if a == b:\n        return 0\n\n    # Trim away common affixes\n    pre = 0\n    while a[pre:] and b[pre:] and a[pre] == b[pre]:\n        pre += 1\n    a = a[pre:]\n    b = b[pre:]\n    post = 0\n    while a[: post or None] and b[: post or None] and a[post - 1] == b[post - 1]:\n        post -= 1\n    a = a[: post or None]\n    b = b[: post or None]\n    if not a or not b:\n        return _MOVE_COST * (len(a) + len(b))\n    if len(a) > _MAX_STRING_SIZE or len(b) > _MAX_STRING_SIZE:\n        return max_cost + 1\n\n    # Prefer shorter buffer\n    if len(b) < len(a):\n        a, b = b, a\n\n    # Quick fail when a match is impossible\n    if (len(b) - len(a)) * _MOVE_COST > max_cost:\n        return max_cost + 1\n\n    # Instead of producing the whole traditional len(a)-by-len(b)\n    # matrix, we can update just one row in place.\n    # Initialize the buffer row\n    row = list(range(_MOVE_COST, _MOVE_COST * (len(a) + 1), _MOVE_COST))\n\n    result = 0\n    for bindex in range(len(b)):\n        bchar = b[bindex]\n        distance = result = bindex * _MOVE_COST\n        minimum = sys.maxsize\n        for index in range(len(a)):\n            # 1) Previous distance in this row is cost(b[:b_index], a[:index])\n            substitute = distance + _substitution_cost(bchar, a[index])\n            # 2) cost(b[:b_index], a[:index+1]) from previous row\n            distance = row[index]\n            # 3) existing result is cost(b[:b_index+1], a[index])\n\n            insert_delete = min(result, distance) + _MOVE_COST\n            result = min(insert_delete, substitute)\n\n            # cost(b[:b_index+1], a[:index+1])\n            row[index] = result\n            if result < minimum:\n                minimum = result\n        if minimum > max_cost:\n            # Everything in this row is too big, so bail early.\n            return max_cost + 1\n    return result\n"}