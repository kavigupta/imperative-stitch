{"tests/test_catch_py311.py": "import sys\n\nimport pytest\n\nfrom exceptiongroup import ExceptionGroup\n\n\ndef test_catch_ungrouped():\n    value_type_errors = []\n    zero_division_errors = []\n    for exc in [ValueError(\"foo\"), TypeError(\"bar\"), ZeroDivisionError()]:\n        try:\n            raise exc\n        except* (ValueError, TypeError) as e:\n            value_type_errors.append(e)\n        except* ZeroDivisionError as e:\n            zero_division_errors.append(e)\n\n    assert len(value_type_errors) == 2\n\n    assert isinstance(value_type_errors[0], ExceptionGroup)\n    assert len(value_type_errors[0].exceptions) == 1\n    assert isinstance(value_type_errors[0].exceptions[0], ValueError)\n\n    assert isinstance(value_type_errors[1], ExceptionGroup)\n    assert len(value_type_errors[1].exceptions) == 1\n    assert isinstance(value_type_errors[1].exceptions[0], TypeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    assert isinstance(zero_division_errors[0].exceptions[0], ZeroDivisionError)\n    assert len(zero_division_errors[0].exceptions) == 1\n\n\ndef test_catch_group():\n    value_runtime_errors = []\n    zero_division_errors = []\n    try:\n        raise ExceptionGroup(\n            \"booboo\",\n            [\n                ValueError(\"foo\"),\n                ValueError(\"bar\"),\n                RuntimeError(\"bar\"),\n                ZeroDivisionError(),\n            ],\n        )\n    except* (ValueError, RuntimeError) as exc:\n        value_runtime_errors.append(exc)\n    except* ZeroDivisionError as exc:\n        zero_division_errors.append(exc)\n\n    assert len(value_runtime_errors) == 1\n    assert isinstance(value_runtime_errors[0], ExceptionGroup)\n    exceptions = value_runtime_errors[0].exceptions\n    assert isinstance(exceptions[0], ValueError)\n    assert isinstance(exceptions[1], ValueError)\n    assert isinstance(exceptions[2], RuntimeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    exceptions = zero_division_errors[0].exceptions\n    assert isinstance(exceptions[0], ZeroDivisionError)\n\n\ndef test_catch_nested_group():\n    value_runtime_errors = []\n    zero_division_errors = []\n    try:\n        nested_group = ExceptionGroup(\n            \"nested\", [RuntimeError(\"bar\"), ZeroDivisionError()]\n        )\n        raise ExceptionGroup(\"booboo\", [ValueError(\"foo\"), nested_group])\n    except* (ValueError, RuntimeError) as exc:\n        value_runtime_errors.append(exc)\n    except* ZeroDivisionError as exc:\n        zero_division_errors.append(exc)\n\n    assert len(value_runtime_errors) == 1\n    exceptions = value_runtime_errors[0].exceptions\n    assert isinstance(exceptions[0], ValueError)\n    assert isinstance(exceptions[1], ExceptionGroup)\n    assert isinstance(exceptions[1].exceptions[0], RuntimeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    assert isinstance(zero_division_errors[0].exceptions[0], ExceptionGroup)\n    assert isinstance(\n        zero_division_errors[0].exceptions[0].exceptions[0], ZeroDivisionError\n    )\n\n\ndef test_catch_no_match():\n    try:\n        try:\n            group = ExceptionGroup(\"booboo\", [ZeroDivisionError()])\n            raise group\n        except* (ValueError, RuntimeError):\n            pass\n    except ExceptionGroup as exc:\n        assert isinstance(exc.exceptions[0], ZeroDivisionError)\n        assert exc is not group\n    else:\n        pytest.fail(\"Did not raise an ExceptionGroup\")\n\n\ndef test_catch_single_no_match():\n    try:\n        try:\n            raise ZeroDivisionError\n        except* (ValueError, RuntimeError):\n            pass\n    except ZeroDivisionError:\n        pass\n    else:\n        pytest.fail(\"Did not raise an ZeroDivisionError\")\n\n\ndef test_catch_full_match():\n    try:\n        raise ExceptionGroup(\"booboo\", [ValueError()])\n    except* (ValueError, RuntimeError):\n        pass\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 11, 4),\n    reason=\"Behavior was changed in 3.11.4\",\n)\ndef test_catch_handler_raises():\n    with pytest.raises(RuntimeError, match=\"new\") as exc:\n        try:\n            excgrp = ExceptionGroup(\"booboo\", [ValueError(\"bar\")])\n            raise excgrp\n        except* ValueError:\n            raise RuntimeError(\"new\")\n\n    context = exc.value.__context__\n    assert isinstance(context, ExceptionGroup)\n    assert str(context) == \"booboo (1 sub-exception)\"\n    assert len(context.exceptions) == 1\n    assert isinstance(context.exceptions[0], ValueError)\n    assert exc.value.__cause__ is None\n\n\ndef test_catch_subclass():\n    lookup_errors = []\n    try:\n        raise KeyError(\"foo\")\n    except* LookupError as e:\n        lookup_errors.append(e)\n\n    assert len(lookup_errors) == 1\n    assert isinstance(lookup_errors[0], ExceptionGroup)\n    exceptions = lookup_errors[0].exceptions\n    assert isinstance(exceptions[0], KeyError)\n\n\ndef test_bare_raise_in_handler():\n    \"\"\"Test that the \"middle\" ecxeption group gets discarded.\"\"\"\n    with pytest.raises(ExceptionGroup) as excgrp:\n        try:\n            try:\n                first_exc = RuntimeError(\"first\")\n                raise first_exc\n            except RuntimeError as exc:\n                middle_exc = ExceptionGroup(\n                    \"bad\", [ValueError(), ValueError(), TypeError()]\n                )\n                raise middle_exc from exc\n        except* ValueError:\n            raise\n        except* TypeError:\n            pass\n\n    assert excgrp.value is not middle_exc\n    assert excgrp.value.__cause__ is first_exc\n    assert excgrp.value.__context__ is first_exc\n\n\ndef test_bare_reraise_from_naked_exception():\n    with pytest.raises(ExceptionGroup) as excgrp:\n        try:\n            raise KeyError(\"foo\")\n        except* KeyError:\n            raise\n\n    assert len(excgrp.value.exceptions) == 1\n    assert isinstance(excgrp.value.exceptions[0], KeyError)\n    assert str(excgrp.value.exceptions[0]) == \"'foo'\"\n", "tests/test_suppress.py": "import sys\n\nimport pytest\n\nfrom exceptiongroup import suppress\n\nif sys.version_info < (3, 11):\n    from exceptiongroup import BaseExceptionGroup, ExceptionGroup\n\n\ndef test_suppress_exception():\n    with pytest.raises(ExceptionGroup) as exc, suppress(SystemExit):\n        raise BaseExceptionGroup(\"\", [SystemExit(1), RuntimeError(\"boo\")])\n\n    assert len(exc.value.exceptions) == 1\n    assert isinstance(exc.value.exceptions[0], RuntimeError)\n", "tests/apport_excepthook.py": "# The apport_python_hook package is only installed as part of Ubuntu's system\n# python, and not available in venvs. So before we can import it we have to\n# make sure it's on sys.path.\nimport sys\n\nsys.path.append(\"/usr/lib/python3/dist-packages\")\nimport apport_python_hook  # unsorted import\n\napport_python_hook.install()\n\nfrom exceptiongroup import ExceptionGroup  # noqa: E402 # unsorted import\n\nraise ExceptionGroup(\"msg1\", [KeyError(\"msg2\"), ValueError(\"msg3\")])\n", "tests/check_types.py": "from typing_extensions import assert_type\n\nfrom exceptiongroup import BaseExceptionGroup, ExceptionGroup, catch, suppress\n\n# issue 117\na = BaseExceptionGroup(\"\", (KeyboardInterrupt(),))\nassert_type(a, BaseExceptionGroup[KeyboardInterrupt])\nb = BaseExceptionGroup(\"\", (ValueError(),))\nassert_type(b, BaseExceptionGroup[ValueError])\nc = ExceptionGroup(\"\", (ValueError(),))\nassert_type(c, ExceptionGroup[ValueError])\n\n# expected type error when passing a BaseException to ExceptionGroup\nExceptionGroup(\"\", (KeyboardInterrupt(),))  # type: ignore[type-var]\n\n\n# code snippets from the README\n\n\ndef value_key_err_handler(excgroup: BaseExceptionGroup) -> None:\n    for exc in excgroup.exceptions:\n        print(\"Caught exception:\", type(exc))\n\n\ndef runtime_err_handler(exc: BaseExceptionGroup) -> None:\n    print(\"Caught runtime error\")\n\n\nwith catch(\n    {(ValueError, KeyError): value_key_err_handler, RuntimeError: runtime_err_handler}\n):\n    ...\n\n\nwith suppress(RuntimeError):\n    raise ExceptionGroup(\"\", [RuntimeError(\"boo\")])\n", "tests/test_formatting.py": "import sys\nimport traceback\nfrom typing import NoReturn\nfrom urllib.error import HTTPError\n\nimport pytest\nfrom _pytest.capture import CaptureFixture\nfrom _pytest.fixtures import SubRequest\nfrom _pytest.monkeypatch import MonkeyPatch\n\nfrom exceptiongroup import ExceptionGroup\n\n\ndef raise_excgroup() -> NoReturn:\n    exceptions = []\n    try:\n        raise ValueError(\"foo\")\n    except ValueError as exc:\n        exceptions.append(exc)\n\n    try:\n        raise RuntimeError(\"bar\")\n    except RuntimeError as exc:\n        exc.__notes__ = [\"Note from bar handler\"]\n        exceptions.append(exc)\n\n    exc = ExceptionGroup(\"test message\", exceptions)\n    exc.add_note(\"Displays notes attached to the group too\")\n    raise exc\n\n\n@pytest.fixture(\n    params=[\n        pytest.param(True, id=\"patched\"),\n        pytest.param(\n            False,\n            id=\"unpatched\",\n            marks=[\n                pytest.mark.skipif(\n                    sys.version_info >= (3, 11),\n                    reason=\"No patching is done on Python >= 3.11\",\n                )\n            ],\n        ),\n    ],\n)\ndef patched(request: SubRequest) -> bool:\n    return request.param\n\n\n@pytest.fixture(\n    params=[pytest.param(False, id=\"newstyle\"), pytest.param(True, id=\"oldstyle\")]\n)\ndef old_argstyle(request: SubRequest) -> bool:\n    return request.param\n\n\ndef test_exceptionhook(capsys: CaptureFixture) -> None:\n    try:\n        raise_excgroup()\n    except ExceptionGroup as exc:\n        sys.excepthook(type(exc), exc, exc.__traceback__)\n\n    local_lineno = test_exceptionhook.__code__.co_firstlineno\n    lineno = raise_excgroup.__code__.co_firstlineno\n    module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n    output = capsys.readouterr().err\n    assert output == (\n        f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {local_lineno + 2}, in test_exceptionhook\n  |     raise_excgroup()\n  |   File \"{__file__}\", line {lineno + 15}, in raise_excgroup\n  |     raise exc\n  | {module_prefix}ExceptionGroup: test message (2 sub-exceptions)\n  | Displays notes attached to the group too\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 3}, in raise_excgroup\n    |     raise ValueError(\"foo\")\n    | ValueError: foo\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 8}, in raise_excgroup\n    |     raise RuntimeError(\"bar\")\n    | RuntimeError: bar\n    | Note from bar handler\n    +------------------------------------\n\"\"\"\n    )\n\n\ndef test_exceptiongroup_as_cause(capsys: CaptureFixture) -> None:\n    try:\n        raise Exception() from ExceptionGroup(\"\", (Exception(),))\n    except Exception as exc:\n        sys.excepthook(type(exc), exc, exc.__traceback__)\n\n    lineno = test_exceptiongroup_as_cause.__code__.co_firstlineno\n    module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n    output = capsys.readouterr().err\n    assert output == (\n        f\"\"\"\\\n  | {module_prefix}ExceptionGroup:  (1 sub-exception)\n  +-+---------------- 1 ----------------\n    | Exception\n    +------------------------------------\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"{__file__}\", line {lineno + 2}, in test_exceptiongroup_as_cause\n    raise Exception() from ExceptionGroup(\"\", (Exception(),))\nException\n\"\"\"\n    )\n\n\ndef test_exceptiongroup_loop(capsys: CaptureFixture) -> None:\n    e0 = Exception(\"e0\")\n    eg0 = ExceptionGroup(\"eg0\", (e0,))\n    eg1 = ExceptionGroup(\"eg1\", (eg0,))\n\n    try:\n        raise eg0 from eg1\n    except ExceptionGroup as exc:\n        sys.excepthook(type(exc), exc, exc.__traceback__)\n\n    lineno = test_exceptiongroup_loop.__code__.co_firstlineno + 6\n    module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n    output = capsys.readouterr().err\n    assert output == (\n        f\"\"\"\\\n  | {module_prefix}ExceptionGroup: eg1 (1 sub-exception)\n  +-+---------------- 1 ----------------\n    | Exception Group Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno}, in test_exceptiongroup_loop\n    |     raise eg0 from eg1\n    | {module_prefix}ExceptionGroup: eg0 (1 sub-exception)\n    +-+---------------- 1 ----------------\n      | Exception: e0\n      +------------------------------------\n\nThe above exception was the direct cause of the following exception:\n\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {lineno}, in test_exceptiongroup_loop\n  |     raise eg0 from eg1\n  | {module_prefix}ExceptionGroup: eg0 (1 sub-exception)\n  +-+---------------- 1 ----------------\n    | Exception: e0\n    +------------------------------------\n\"\"\"\n    )\n\n\ndef test_exceptionhook_format_exception_only(capsys: CaptureFixture) -> None:\n    try:\n        raise_excgroup()\n    except ExceptionGroup as exc:\n        sys.excepthook(type(exc), exc, exc.__traceback__)\n\n    local_lineno = test_exceptionhook_format_exception_only.__code__.co_firstlineno\n    lineno = raise_excgroup.__code__.co_firstlineno\n    module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n    output = capsys.readouterr().err\n    assert output == (\n        f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {local_lineno + 2}, in \\\ntest_exceptionhook_format_exception_only\n  |     raise_excgroup()\n  |   File \"{__file__}\", line {lineno + 15}, in raise_excgroup\n  |     raise exc\n  | {module_prefix}ExceptionGroup: test message (2 sub-exceptions)\n  | Displays notes attached to the group too\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 3}, in raise_excgroup\n    |     raise ValueError(\"foo\")\n    | ValueError: foo\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 8}, in raise_excgroup\n    |     raise RuntimeError(\"bar\")\n    | RuntimeError: bar\n    | Note from bar handler\n    +------------------------------------\n\"\"\"\n    )\n\n\ndef test_formatting_syntax_error(capsys: CaptureFixture) -> None:\n    try:\n        exec(\"//serser\")\n    except SyntaxError as exc:\n        sys.excepthook(type(exc), exc, exc.__traceback__)\n\n    if sys.version_info >= (3, 10):\n        underline = \"\\n    ^^\"\n    elif sys.version_info >= (3, 8):\n        underline = \"\\n    ^\"\n    else:\n        underline = \"\\n     ^\"\n\n    lineno = test_formatting_syntax_error.__code__.co_firstlineno\n    output = capsys.readouterr().err\n    assert output == (\n        f\"\"\"\\\nTraceback (most recent call last):\n  File \"{__file__}\", line {lineno + 2}, \\\nin test_formatting_syntax_error\n    exec(\"//serser\")\n  File \"<string>\", line 1\n    //serser{underline}\nSyntaxError: invalid syntax\n\"\"\"\n    )\n\n\ndef test_format_exception(\n    patched: bool, old_argstyle: bool, monkeypatch: MonkeyPatch\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import format_exception\n\n    exceptions = []\n    try:\n        raise ValueError(\"foo\")\n    except ValueError as exc:\n        exceptions.append(exc)\n\n    try:\n        raise RuntimeError(\"bar\")\n    except RuntimeError as exc:\n        exc.__notes__ = [\"Note from bar handler\"]\n        exceptions.append(exc)\n\n    try:\n        raise_excgroup()\n    except ExceptionGroup as exc:\n        if old_argstyle:\n            lines = format_exception(type(exc), exc, exc.__traceback__)\n        else:\n            lines = format_exception(exc)\n\n        local_lineno = test_format_exception.__code__.co_firstlineno\n        lineno = raise_excgroup.__code__.co_firstlineno\n        assert isinstance(lines, list)\n        module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n        assert \"\".join(lines) == (\n            f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {local_lineno + 25}, in test_format_exception\n  |     raise_excgroup()\n  |   File \"{__file__}\", line {lineno + 15}, in raise_excgroup\n  |     raise exc\n  | {module_prefix}ExceptionGroup: test message (2 sub-exceptions)\n  | Displays notes attached to the group too\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 3}, in raise_excgroup\n    |     raise ValueError(\"foo\")\n    | ValueError: foo\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 8}, in raise_excgroup\n    |     raise RuntimeError(\"bar\")\n    | RuntimeError: bar\n    | Note from bar handler\n    +------------------------------------\n\"\"\"\n        )\n\n\ndef test_format_nested(monkeypatch: MonkeyPatch) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import format_exception\n\n    def raise_exc(max_level: int, level: int = 1) -> NoReturn:\n        if level == max_level:\n            raise Exception(f\"LEVEL_{level}\")\n        else:\n            try:\n                raise_exc(max_level, level + 1)\n            except Exception:\n                raise Exception(f\"LEVEL_{level}\")\n\n    try:\n        raise_exc(3)\n    except Exception as exc:\n        lines = format_exception(type(exc), exc, exc.__traceback__)\n\n    local_lineno = test_format_nested.__code__.co_firstlineno + 20\n    raise_exc_lineno1 = raise_exc.__code__.co_firstlineno + 2\n    raise_exc_lineno2 = raise_exc.__code__.co_firstlineno + 5\n    raise_exc_lineno3 = raise_exc.__code__.co_firstlineno + 7\n    assert isinstance(lines, list)\n    assert \"\".join(lines) == (\n        f\"\"\"\\\nTraceback (most recent call last):\n  File \"{__file__}\", line {raise_exc_lineno2}, in raise_exc\n    raise_exc(max_level, level + 1)\n  File \"{__file__}\", line {raise_exc_lineno1}, in raise_exc\n    raise Exception(f\"LEVEL_{{level}}\")\nException: LEVEL_3\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"{__file__}\", line {raise_exc_lineno2}, in raise_exc\n    raise_exc(max_level, level + 1)\n  File \"{__file__}\", line {raise_exc_lineno3}, in raise_exc\n    raise Exception(f\"LEVEL_{{level}}\")\nException: LEVEL_2\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"{__file__}\", line {local_lineno}, in test_format_nested\n    raise_exc(3)\n  File \"{__file__}\", line {raise_exc_lineno3}, in raise_exc\n    raise Exception(f\"LEVEL_{{level}}\")\nException: LEVEL_1\n\"\"\"\n    )\n\n\ndef test_format_exception_only(\n    patched: bool, old_argstyle: bool, monkeypatch: MonkeyPatch\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import format_exception_only\n\n    try:\n        raise_excgroup()\n    except ExceptionGroup as exc:\n        if old_argstyle:\n            output = format_exception_only(type(exc), exc)\n        else:\n            output = format_exception_only(exc)\n\n        module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n        assert output == [\n            f\"{module_prefix}ExceptionGroup: test message (2 sub-exceptions)\\n\",\n            \"Displays notes attached to the group too\\n\",\n        ]\n\n\ndef test_print_exception(\n    patched: bool, old_argstyle: bool, monkeypatch: MonkeyPatch, capsys: CaptureFixture\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import print_exception\n\n    try:\n        raise_excgroup()\n    except ExceptionGroup as exc:\n        if old_argstyle:\n            print_exception(type(exc), exc, exc.__traceback__)\n        else:\n            print_exception(exc)\n\n        local_lineno = test_print_exception.__code__.co_firstlineno\n        lineno = raise_excgroup.__code__.co_firstlineno\n        module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n        output = capsys.readouterr().err\n        assert output == (\n            f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {local_lineno + 13}, in test_print_exception\n  |     raise_excgroup()\n  |   File \"{__file__}\", line {lineno + 15}, in raise_excgroup\n  |     raise exc\n  | {module_prefix}ExceptionGroup: test message (2 sub-exceptions)\n  | Displays notes attached to the group too\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 3}, in raise_excgroup\n    |     raise ValueError(\"foo\")\n    | ValueError: foo\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 8}, in raise_excgroup\n    |     raise RuntimeError(\"bar\")\n    | RuntimeError: bar\n    | Note from bar handler\n    +------------------------------------\n\"\"\"\n        )\n\n\ndef test_print_exc(\n    patched: bool, monkeypatch: MonkeyPatch, capsys: CaptureFixture\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import print_exc\n\n    try:\n        raise_excgroup()\n    except ExceptionGroup:\n        print_exc()\n        local_lineno = test_print_exc.__code__.co_firstlineno\n        lineno = raise_excgroup.__code__.co_firstlineno\n        module_prefix = \"\" if sys.version_info >= (3, 11) else \"exceptiongroup.\"\n        output = capsys.readouterr().err\n        assert output == (\n            f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{__file__}\", line {local_lineno + 13}, in test_print_exc\n  |     raise_excgroup()\n  |   File \"{__file__}\", line {lineno + 15}, in raise_excgroup\n  |     raise exc\n  | {module_prefix}ExceptionGroup: test message (2 sub-exceptions)\n  | Displays notes attached to the group too\n  +-+---------------- 1 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 3}, in raise_excgroup\n    |     raise ValueError(\"foo\")\n    | ValueError: foo\n    +---------------- 2 ----------------\n    | Traceback (most recent call last):\n    |   File \"{__file__}\", line {lineno + 8}, in raise_excgroup\n    |     raise RuntimeError(\"bar\")\n    | RuntimeError: bar\n    | Note from bar handler\n    +------------------------------------\n\"\"\"\n        )\n\n\n@pytest.mark.skipif(\n    not hasattr(NameError, \"name\") or sys.version_info[:2] == (3, 11),\n    reason=\"only works if NameError exposes the missing name\",\n)\ndef test_nameerror_suggestions(\n    patched: bool, monkeypatch: MonkeyPatch, capsys: CaptureFixture\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import print_exc\n\n    try:\n        folder\n    except NameError:\n        print_exc()\n        output = capsys.readouterr().err\n        assert \"Did you mean\" in output and \"'filter'?\" in output\n\n\n@pytest.mark.skipif(\n    not hasattr(AttributeError, \"name\") or sys.version_info[:2] == (3, 11),\n    reason=\"only works if AttributeError exposes the missing name\",\n)\ndef test_nameerror_suggestions_in_group(\n    patched: bool, monkeypatch: MonkeyPatch, capsys: CaptureFixture\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import print_exception\n\n    try:\n        [].attend\n    except AttributeError as e:\n        eg = ExceptionGroup(\"a\", [e])\n        print_exception(eg)\n        output = capsys.readouterr().err\n        assert \"Did you mean\" in output and \"'append'?\" in output\n\n\ndef test_bug_suggestions_attributeerror_no_obj(\n    patched: bool, monkeypatch: MonkeyPatch, capsys: CaptureFixture\n) -> None:\n    if not patched:\n        # Block monkey patching, then force the module to be re-imported\n        del sys.modules[\"traceback\"]\n        del sys.modules[\"exceptiongroup\"]\n        del sys.modules[\"exceptiongroup._formatting\"]\n        monkeypatch.setattr(sys, \"excepthook\", lambda *args: sys.__excepthook__(*args))\n\n    from exceptiongroup import print_exception\n\n    class NamedAttributeError(AttributeError):\n        def __init__(self, name: str) -> None:\n            self.name: str = name\n\n    try:\n        raise NamedAttributeError(name=\"mykey\")\n    except AttributeError as e:\n        print_exception(e)  # does not crash\n        output = capsys.readouterr().err\n        assert \"NamedAttributeError\" in output\n\n\ndef test_works_around_httperror_bug():\n    # See https://github.com/python/cpython/issues/98778 in Python <= 3.9\n    err = HTTPError(\"url\", 405, \"METHOD NOT ALLOWED\", None, None)\n    traceback.TracebackException(type(err), err, None)\n", "tests/test_exceptions.py": "# Copied from the standard library\nimport collections.abc\nimport sys\nimport unittest\n\nimport pytest\n\nfrom exceptiongroup import BaseExceptionGroup, ExceptionGroup\n\n\nclass TestExceptionGroupTypeHierarchy(unittest.TestCase):\n    def test_exception_group_types(self):\n        self.assertTrue(issubclass(ExceptionGroup, Exception))\n        self.assertTrue(issubclass(ExceptionGroup, BaseExceptionGroup))\n        self.assertTrue(issubclass(BaseExceptionGroup, BaseException))\n\n    def test_exception_group_is_generic_type(self):\n        E = OSError\n        self.assertEqual(ExceptionGroup[E].__origin__, ExceptionGroup)\n        self.assertEqual(BaseExceptionGroup[E].__origin__, BaseExceptionGroup)\n\n\nclass BadConstructorArgs(unittest.TestCase):\n    def test_bad_EG_construction__too_few_args(self):\n        if sys.version_info >= (3, 11):\n            MSG = (\n                r\"BaseExceptionGroup.__new__\\(\\) takes exactly 2 arguments \\(1 given\\)\"\n            )\n        else:\n            MSG = (\n                r\"__new__\\(\\) missing 1 required positional argument: \"\n                r\"'_ExceptionGroup__exceptions'\"\n            )\n\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(\"no errors\")\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup([ValueError(\"no msg\")])\n\n    def test_bad_EG_construction__too_many_args(self):\n        if sys.version_info >= (3, 11):\n            MSG = (\n                r\"BaseExceptionGroup.__new__\\(\\) takes exactly 2 arguments \\(3 given\\)\"\n            )\n        else:\n            MSG = r\"__new__\\(\\) takes 3 positional arguments but 4 were given\"\n\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(\"eg\", [ValueError(\"too\")], [TypeError(\"many\")])\n\n    def test_bad_EG_construction__bad_message(self):\n        MSG = \"argument 1 must be str, not \"\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(ValueError(12), SyntaxError(\"bad syntax\"))\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(None, [ValueError(12)])\n\n    def test_bad_EG_construction__bad_excs_sequence(self):\n        MSG = r\"second argument \\(exceptions\\) must be a sequence\"\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(\"errors not sequence\", {ValueError(42)})\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(\"eg\", None)\n\n        MSG = r\"second argument \\(exceptions\\) must be a non-empty sequence\"\n        with self.assertRaisesRegex(ValueError, MSG):\n            ExceptionGroup(\"eg\", [])\n\n    def test_bad_EG_construction__nested_non_exceptions(self):\n        MSG = r\"Item [0-9]+ of second argument \\(exceptions\\) is not an exception\"\n        with self.assertRaisesRegex(ValueError, MSG):\n            ExceptionGroup(\"expect instance, not type\", [OSError])\n        with self.assertRaisesRegex(ValueError, MSG):\n            ExceptionGroup(\"bad error\", [\"not an exception\"])\n\n\nclass InstanceCreation(unittest.TestCase):\n    def test_EG_wraps_Exceptions__creates_EG(self):\n        excs = [ValueError(1), TypeError(2)]\n        self.assertIs(type(ExceptionGroup(\"eg\", excs)), ExceptionGroup)\n\n    def test_BEG_wraps_Exceptions__creates_EG(self):\n        excs = [ValueError(1), TypeError(2)]\n        self.assertIs(type(BaseExceptionGroup(\"beg\", excs)), ExceptionGroup)\n\n    def test_EG_wraps_BaseException__raises_TypeError(self):\n        MSG = \"Cannot nest BaseExceptions in an ExceptionGroup\"\n        with self.assertRaisesRegex(TypeError, MSG):\n            ExceptionGroup(\"eg\", [ValueError(1), KeyboardInterrupt(2)])\n\n    def test_BEG_wraps_BaseException__creates_BEG(self):\n        beg = BaseExceptionGroup(\"beg\", [ValueError(1), KeyboardInterrupt(2)])\n        self.assertIs(type(beg), BaseExceptionGroup)\n\n    def test_EG_subclass_wraps_non_base_exceptions(self):\n        class MyEG(ExceptionGroup):\n            pass\n\n        self.assertIs(type(MyEG(\"eg\", [ValueError(12), TypeError(42)])), MyEG)\n\n    @pytest.mark.skipif(\n        sys.version_info[:3] == (3, 11, 0),\n        reason=\"Behavior was made stricter in 3.11.1\",\n    )\n    def test_EG_subclass_does_not_wrap_base_exceptions(self):\n        class MyEG(ExceptionGroup):\n            pass\n\n        msg = \"Cannot nest BaseExceptions in 'MyEG'\"\n        with self.assertRaisesRegex(TypeError, msg):\n            MyEG(\"eg\", [ValueError(12), KeyboardInterrupt(42)])\n\n    @pytest.mark.skipif(\n        sys.version_info[:3] == (3, 11, 0),\n        reason=\"Behavior was made stricter in 3.11.1\",\n    )\n    def test_BEG_and_E_subclass_does_not_wrap_base_exceptions(self):\n        class MyEG(BaseExceptionGroup, ValueError):\n            pass\n\n        msg = \"Cannot nest BaseExceptions in 'MyEG'\"\n        with self.assertRaisesRegex(TypeError, msg):\n            MyEG(\"eg\", [ValueError(12), KeyboardInterrupt(42)])\n\n\ndef create_simple_eg():\n    excs = []\n    try:\n        try:\n            raise MemoryError(\"context and cause for ValueError(1)\")\n        except MemoryError as e:\n            raise ValueError(1) from e\n    except ValueError as e:\n        excs.append(e)\n\n    try:\n        try:\n            raise OSError(\"context for TypeError\")\n        except OSError:\n            raise TypeError(int)\n    except TypeError as e:\n        excs.append(e)\n\n    try:\n        try:\n            raise ImportError(\"context for ValueError(2)\")\n        except ImportError:\n            raise ValueError(2)\n    except ValueError as e:\n        excs.append(e)\n\n    try:\n        raise ExceptionGroup(\"simple eg\", excs)\n    except ExceptionGroup as e:\n        return e\n\n\nclass ExceptionGroupFields(unittest.TestCase):\n    def test_basics_ExceptionGroup_fields(self):\n        eg = create_simple_eg()\n\n        # check msg\n        self.assertEqual(eg.message, \"simple eg\")\n        self.assertEqual(eg.args[0], \"simple eg\")\n\n        # check cause and context\n        self.assertIsInstance(eg.exceptions[0], ValueError)\n        self.assertIsInstance(eg.exceptions[0].__cause__, MemoryError)\n        self.assertIsInstance(eg.exceptions[0].__context__, MemoryError)\n        self.assertIsInstance(eg.exceptions[1], TypeError)\n        self.assertIsNone(eg.exceptions[1].__cause__)\n        self.assertIsInstance(eg.exceptions[1].__context__, OSError)\n        self.assertIsInstance(eg.exceptions[2], ValueError)\n        self.assertIsNone(eg.exceptions[2].__cause__)\n        self.assertIsInstance(eg.exceptions[2].__context__, ImportError)\n\n        # check tracebacks\n        line0 = create_simple_eg.__code__.co_firstlineno\n        tb_linenos = [line0 + 27, [line0 + 6, line0 + 14, line0 + 22]]\n        self.assertEqual(eg.__traceback__.tb_lineno, tb_linenos[0])\n        self.assertIsNone(eg.__traceback__.tb_next)\n        for i in range(3):\n            tb = eg.exceptions[i].__traceback__\n            self.assertIsNone(tb.tb_next)\n            self.assertEqual(tb.tb_lineno, tb_linenos[1][i])\n\n    def test_fields_are_readonly(self):\n        eg = ExceptionGroup(\"eg\", [TypeError(1), OSError(2)])\n\n        self.assertEqual(type(eg.exceptions), tuple)\n\n        eg.message\n        with self.assertRaises(AttributeError):\n            eg.message = \"new msg\"\n\n        eg.exceptions\n        with self.assertRaises(AttributeError):\n            eg.exceptions = [OSError(\"xyz\")]\n\n    def test_notes_is_list_of_strings_if_it_exists(self):\n        eg = create_simple_eg()\n\n        note = \"This is a happy note for the exception group\"\n        self.assertFalse(hasattr(eg, \"__notes__\"))\n        eg.add_note(note)\n        self.assertEqual(eg.__notes__, [note])\n\n    def test_derive_doesn_copy_notes(self):\n        eg = create_simple_eg()\n        eg.add_note(\"hello\")\n        assert eg.__notes__ == [\"hello\"]\n        eg2 = eg.derive([ValueError()])\n        assert not hasattr(eg2, \"__notes__\")\n\n\nclass ExceptionGroupTestBase(unittest.TestCase):\n    def assertMatchesTemplate(self, exc, exc_type, template):\n        \"\"\"Assert that the exception matches the template\n\n        A template describes the shape of exc. If exc is a\n        leaf exception (i.e., not an exception group) then\n        template is an exception instance that has the\n        expected type and args value of exc. If exc is an\n        exception group, then template is a list of the\n        templates of its nested exceptions.\n        \"\"\"\n        if exc_type is not None:\n            self.assertIs(type(exc), exc_type)\n\n        if isinstance(exc, BaseExceptionGroup):\n            self.assertIsInstance(template, collections.abc.Sequence)\n            self.assertEqual(len(exc.exceptions), len(template))\n            for e, t in zip(exc.exceptions, template):\n                self.assertMatchesTemplate(e, None, t)\n        else:\n            self.assertIsInstance(template, BaseException)\n            self.assertEqual(type(exc), type(template))\n            self.assertEqual(exc.args, template.args)\n\n\nclass ExceptionGroupSubgroupTests(ExceptionGroupTestBase):\n    def setUp(self):\n        self.eg = create_simple_eg()\n        self.eg_template = [ValueError(1), TypeError(int), ValueError(2)]\n\n    def test_basics_subgroup_split__bad_arg_type(self):\n        bad_args = [\n            \"bad arg\",\n            OSError(\"instance not type\"),\n            [OSError, TypeError],\n            (OSError, 42),\n        ]\n        for arg in bad_args:\n            with self.assertRaises(TypeError):\n                self.eg.subgroup(arg)\n            with self.assertRaises(TypeError):\n                self.eg.split(arg)\n\n    def test_basics_subgroup_by_type__passthrough(self):\n        eg = self.eg\n        # self.assertIs(eg, eg.subgroup(BaseException))\n        # self.assertIs(eg, eg.subgroup(Exception))\n        self.assertIs(eg, eg.subgroup(BaseExceptionGroup))\n        self.assertIs(eg, eg.subgroup(ExceptionGroup))\n\n    def test_basics_subgroup_by_type__no_match(self):\n        self.assertIsNone(self.eg.subgroup(OSError))\n\n    def test_basics_subgroup_by_type__match(self):\n        eg = self.eg\n        testcases = [\n            # (match_type, result_template)\n            (ValueError, [ValueError(1), ValueError(2)]),\n            (TypeError, [TypeError(int)]),\n            ((ValueError, TypeError), self.eg_template),\n        ]\n\n        for match_type, template in testcases:\n            with self.subTest(match=match_type):\n                subeg = eg.subgroup(match_type)\n                self.assertEqual(subeg.message, eg.message)\n                self.assertMatchesTemplate(subeg, ExceptionGroup, template)\n\n    def test_basics_subgroup_by_predicate__passthrough(self):\n        self.assertIs(self.eg, self.eg.subgroup(lambda e: True))\n\n    def test_basics_subgroup_by_predicate__no_match(self):\n        self.assertIsNone(self.eg.subgroup(lambda e: False))\n\n    def test_basics_subgroup_by_predicate__match(self):\n        eg = self.eg\n        testcases = [\n            # (match_type, result_template)\n            (ValueError, [ValueError(1), ValueError(2)]),\n            (TypeError, [TypeError(int)]),\n            ((ValueError, TypeError), self.eg_template),\n        ]\n\n        for match_type, template in testcases:\n            subeg = eg.subgroup(lambda e: isinstance(e, match_type))\n            self.assertEqual(subeg.message, eg.message)\n            self.assertMatchesTemplate(subeg, ExceptionGroup, template)\n\n\nclass ExceptionGroupSplitTests(ExceptionGroupTestBase):\n    def setUp(self):\n        self.eg = create_simple_eg()\n        self.eg_template = [ValueError(1), TypeError(int), ValueError(2)]\n\n    def test_basics_split_by_type__passthrough(self):\n        for E in [BaseException, Exception, BaseExceptionGroup, ExceptionGroup]:\n            match, rest = self.eg.split(E)\n            self.assertMatchesTemplate(match, ExceptionGroup, self.eg_template)\n            self.assertIsNone(rest)\n\n    def test_basics_split_by_type__no_match(self):\n        match, rest = self.eg.split(OSError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(rest, ExceptionGroup, self.eg_template)\n\n    def test_basics_split_by_type__match(self):\n        eg = self.eg\n        VE = ValueError\n        TE = TypeError\n        testcases = [\n            # (matcher, match_template, rest_template)\n            (VE, [VE(1), VE(2)], [TE(int)]),\n            (TE, [TE(int)], [VE(1), VE(2)]),\n            ((VE, TE), self.eg_template, None),\n            ((OSError, VE), [VE(1), VE(2)], [TE(int)]),\n        ]\n\n        for match_type, match_template, rest_template in testcases:\n            match, rest = eg.split(match_type)\n            self.assertEqual(match.message, eg.message)\n            self.assertMatchesTemplate(match, ExceptionGroup, match_template)\n            if rest_template is not None:\n                self.assertEqual(rest.message, eg.message)\n                self.assertMatchesTemplate(rest, ExceptionGroup, rest_template)\n            else:\n                self.assertIsNone(rest)\n\n    def test_basics_split_by_predicate__passthrough(self):\n        match, rest = self.eg.split(lambda e: True)\n        self.assertMatchesTemplate(match, ExceptionGroup, self.eg_template)\n        self.assertIsNone(rest)\n\n    def test_basics_split_by_predicate__no_match(self):\n        match, rest = self.eg.split(lambda e: False)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(rest, ExceptionGroup, self.eg_template)\n\n    def test_basics_split_by_predicate__match(self):\n        eg = self.eg\n        VE = ValueError\n        TE = TypeError\n        testcases = [\n            # (matcher, match_template, rest_template)\n            (VE, [VE(1), VE(2)], [TE(int)]),\n            (TE, [TE(int)], [VE(1), VE(2)]),\n            ((VE, TE), self.eg_template, None),\n        ]\n\n        for match_type, match_template, rest_template in testcases:\n            match, rest = eg.split(lambda e: isinstance(e, match_type))\n            self.assertEqual(match.message, eg.message)\n            self.assertMatchesTemplate(match, ExceptionGroup, match_template)\n            if rest_template is not None:\n                self.assertEqual(rest.message, eg.message)\n                self.assertMatchesTemplate(rest, ExceptionGroup, rest_template)\n\n\nclass DeepRecursionInSplitAndSubgroup(unittest.TestCase):\n    def make_deep_eg(self):\n        e = TypeError(1)\n        for _ in range(10000):\n            e = ExceptionGroup(\"eg\", [e])\n        return e\n\n    def test_deep_split(self):\n        e = self.make_deep_eg()\n        with self.assertRaises(RecursionError):\n            e.split(TypeError)\n\n    def test_deep_subgroup(self):\n        e = self.make_deep_eg()\n        with self.assertRaises(RecursionError):\n            e.subgroup(TypeError)\n\n\ndef leaf_generator(exc, tbs=None):\n    if tbs is None:\n        tbs = []\n    tbs.append(exc.__traceback__)\n    if isinstance(exc, BaseExceptionGroup):\n        for e in exc.exceptions:\n            yield from leaf_generator(e, tbs)\n    else:\n        # exc is a leaf exception and its traceback\n        # is the concatenation of the traceback\n        # segments in tbs\n        yield exc, tbs\n    tbs.pop()\n\n\nclass LeafGeneratorTest(unittest.TestCase):\n    # The leaf_generator is mentioned in PEP 654 as a suggestion\n    # on how to iterate over leaf nodes of an EG. Is is also\n    # used below as a test utility. So we test it here.\n\n    def test_leaf_generator(self):\n        eg = create_simple_eg()\n\n        self.assertSequenceEqual([e for e, _ in leaf_generator(eg)], eg.exceptions)\n\n        for e, tbs in leaf_generator(eg):\n            self.assertSequenceEqual(tbs, [eg.__traceback__, e.__traceback__])\n\n\ndef create_nested_eg():\n    excs = []\n    try:\n        try:\n            raise TypeError(bytes)\n        except TypeError as e:\n            raise ExceptionGroup(\"nested\", [e])\n    except ExceptionGroup as e:\n        excs.append(e)\n\n    try:\n        try:\n            raise MemoryError(\"out of memory\")\n        except MemoryError as e:\n            raise ValueError(1) from e\n    except ValueError as e:\n        excs.append(e)\n\n    try:\n        raise ExceptionGroup(\"root\", excs)\n    except ExceptionGroup as eg:\n        return eg\n\n\nclass NestedExceptionGroupBasicsTest(ExceptionGroupTestBase):\n    def test_nested_group_matches_template(self):\n        eg = create_nested_eg()\n        self.assertMatchesTemplate(\n            eg, ExceptionGroup, [[TypeError(bytes)], ValueError(1)]\n        )\n\n    def test_nested_group_chaining(self):\n        eg = create_nested_eg()\n        self.assertIsInstance(eg.exceptions[1].__context__, MemoryError)\n        self.assertIsInstance(eg.exceptions[1].__cause__, MemoryError)\n        self.assertIsInstance(eg.exceptions[0].__context__, TypeError)\n\n    def test_nested_exception_group_tracebacks(self):\n        eg = create_nested_eg()\n\n        line0 = create_nested_eg.__code__.co_firstlineno\n        for tb, expected in [\n            (eg.__traceback__, line0 + 19),\n            (eg.exceptions[0].__traceback__, line0 + 6),\n            (eg.exceptions[1].__traceback__, line0 + 14),\n            (eg.exceptions[0].exceptions[0].__traceback__, line0 + 4),\n        ]:\n            self.assertEqual(tb.tb_lineno, expected)\n            self.assertIsNone(tb.tb_next)\n\n    def test_iteration_full_tracebacks(self):\n        eg = create_nested_eg()\n        # check that iteration over leaves\n        # produces the expected tracebacks\n        self.assertEqual(len(list(leaf_generator(eg))), 2)\n\n        line0 = create_nested_eg.__code__.co_firstlineno\n        expected_tbs = [[line0 + 19, line0 + 6, line0 + 4], [line0 + 19, line0 + 14]]\n\n        for i, (_, tbs) in enumerate(leaf_generator(eg)):\n            self.assertSequenceEqual([tb.tb_lineno for tb in tbs], expected_tbs[i])\n\n\nclass ExceptionGroupSplitTestBase(ExceptionGroupTestBase):\n    def split_exception_group(self, eg, types):\n        \"\"\"Split an EG and do some sanity checks on the result\"\"\"\n        self.assertIsInstance(eg, BaseExceptionGroup)\n\n        match, rest = eg.split(types)\n        sg = eg.subgroup(types)\n\n        if match is not None:\n            self.assertIsInstance(match, BaseExceptionGroup)\n            for e, _ in leaf_generator(match):\n                self.assertIsInstance(e, types)\n\n            self.assertIsNotNone(sg)\n            self.assertIsInstance(sg, BaseExceptionGroup)\n            for e, _ in leaf_generator(sg):\n                self.assertIsInstance(e, types)\n\n        if rest is not None:\n            self.assertIsInstance(rest, BaseExceptionGroup)\n\n        def leaves(exc):\n            return [] if exc is None else [e for e, _ in leaf_generator(exc)]\n\n        # match and subgroup have the same leaves\n        self.assertSequenceEqual(leaves(match), leaves(sg))\n\n        match_leaves = leaves(match)\n        rest_leaves = leaves(rest)\n        # each leaf exception of eg is in exactly one of match and rest\n        self.assertEqual(len(leaves(eg)), len(leaves(match)) + len(leaves(rest)))\n\n        for e in leaves(eg):\n            self.assertNotEqual(match and e in match_leaves, rest and e in rest_leaves)\n\n        # message, cause and context, traceback and note equal to eg\n        for part in [match, rest, sg]:\n            if part is not None:\n                self.assertEqual(eg.message, part.message)\n                self.assertIs(eg.__cause__, part.__cause__)\n                self.assertIs(eg.__context__, part.__context__)\n                self.assertIs(eg.__traceback__, part.__traceback__)\n                self.assertEqual(\n                    getattr(eg, \"__notes__\", None),\n                    getattr(part, \"__notes__\", None),\n                )\n\n        def tbs_for_leaf(leaf, eg):\n            for e, tbs in leaf_generator(eg):\n                if e is leaf:\n                    return tbs\n\n        def tb_linenos(tbs):\n            return [tb.tb_lineno for tb in tbs if tb]\n\n        # full tracebacks match\n        for part in [match, rest, sg]:\n            for e in leaves(part):\n                self.assertSequenceEqual(\n                    tb_linenos(tbs_for_leaf(e, eg)), tb_linenos(tbs_for_leaf(e, part))\n                )\n\n        return match, rest\n\n\nclass NestedExceptionGroupSplitTest(ExceptionGroupSplitTestBase):\n    def test_split_by_type(self):\n        class MyExceptionGroup(ExceptionGroup):\n            pass\n\n        def raiseVE(v):\n            raise ValueError(v)\n\n        def raiseTE(t):\n            raise TypeError(t)\n\n        def nested_group():\n            def level1(i):\n                excs = []\n                for f, arg in [(raiseVE, i), (raiseTE, int), (raiseVE, i + 1)]:\n                    try:\n                        f(arg)\n                    except Exception as e:\n                        excs.append(e)\n                raise ExceptionGroup(\"msg1\", excs)\n\n            def level2(i):\n                excs = []\n                for f, arg in [(level1, i), (level1, i + 1), (raiseVE, i + 2)]:\n                    try:\n                        f(arg)\n                    except Exception as e:\n                        excs.append(e)\n                raise MyExceptionGroup(\"msg2\", excs)\n\n            def level3(i):\n                excs = []\n                for f, arg in [(level2, i + 1), (raiseVE, i + 2)]:\n                    try:\n                        f(arg)\n                    except Exception as e:\n                        excs.append(e)\n                raise ExceptionGroup(\"msg3\", excs)\n\n            level3(5)\n\n        try:\n            nested_group()\n        except ExceptionGroup as e:\n            e.add_note(f\"the note: {id(e)}\")\n            eg = e\n\n        eg_template = [\n            [\n                [ValueError(6), TypeError(int), ValueError(7)],\n                [ValueError(7), TypeError(int), ValueError(8)],\n                ValueError(8),\n            ],\n            ValueError(7),\n        ]\n\n        valueErrors_template = [\n            [\n                [ValueError(6), ValueError(7)],\n                [ValueError(7), ValueError(8)],\n                ValueError(8),\n            ],\n            ValueError(7),\n        ]\n\n        typeErrors_template = [[[TypeError(int)], [TypeError(int)]]]\n\n        self.assertMatchesTemplate(eg, ExceptionGroup, eg_template)\n\n        # Match Nothing\n        match, rest = self.split_exception_group(eg, SyntaxError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(rest, ExceptionGroup, eg_template)\n\n        # Match Everything\n        match, rest = self.split_exception_group(eg, BaseException)\n        self.assertMatchesTemplate(match, ExceptionGroup, eg_template)\n        self.assertIsNone(rest)\n        match, rest = self.split_exception_group(eg, (ValueError, TypeError))\n        self.assertMatchesTemplate(match, ExceptionGroup, eg_template)\n        self.assertIsNone(rest)\n\n        # Match ValueErrors\n        match, rest = self.split_exception_group(eg, ValueError)\n        self.assertMatchesTemplate(match, ExceptionGroup, valueErrors_template)\n        self.assertMatchesTemplate(rest, ExceptionGroup, typeErrors_template)\n\n        # Match TypeErrors\n        match, rest = self.split_exception_group(eg, (TypeError, SyntaxError))\n        self.assertMatchesTemplate(match, ExceptionGroup, typeErrors_template)\n        self.assertMatchesTemplate(rest, ExceptionGroup, valueErrors_template)\n\n        # Match ExceptionGroup\n        match, rest = eg.split(ExceptionGroup)\n        self.assertIs(match, eg)\n        self.assertIsNone(rest)\n\n        # Match MyExceptionGroup (ExceptionGroup subclass)\n        match, rest = eg.split(MyExceptionGroup)\n        self.assertMatchesTemplate(match, ExceptionGroup, [eg_template[0]])\n        self.assertMatchesTemplate(rest, ExceptionGroup, [eg_template[1]])\n\n    def test_split_BaseExceptionGroup(self):\n        def exc(ex):\n            try:\n                raise ex\n            except BaseException as e:\n                return e\n\n        try:\n            raise BaseExceptionGroup(\n                \"beg\", [exc(ValueError(1)), exc(KeyboardInterrupt(2))]\n            )\n        except BaseExceptionGroup as e:\n            beg = e\n\n        # Match Nothing\n        match, rest = self.split_exception_group(beg, TypeError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(\n            rest, BaseExceptionGroup, [ValueError(1), KeyboardInterrupt(2)]\n        )\n\n        # Match Everything\n        match, rest = self.split_exception_group(beg, (ValueError, KeyboardInterrupt))\n        self.assertMatchesTemplate(\n            match, BaseExceptionGroup, [ValueError(1), KeyboardInterrupt(2)]\n        )\n        self.assertIsNone(rest)\n\n        # Match ValueErrors\n        match, rest = self.split_exception_group(beg, ValueError)\n        self.assertMatchesTemplate(match, ExceptionGroup, [ValueError(1)])\n        self.assertMatchesTemplate(rest, BaseExceptionGroup, [KeyboardInterrupt(2)])\n\n        # Match KeyboardInterrupts\n        match, rest = self.split_exception_group(beg, KeyboardInterrupt)\n        self.assertMatchesTemplate(match, BaseExceptionGroup, [KeyboardInterrupt(2)])\n        self.assertMatchesTemplate(rest, ExceptionGroup, [ValueError(1)])\n\n\nclass NestedExceptionGroupSubclassSplitTest(ExceptionGroupSplitTestBase):\n    def test_split_ExceptionGroup_subclass_no_derive_no_new_override(self):\n        class EG(ExceptionGroup):\n            pass\n\n        try:\n            try:\n                try:\n                    raise TypeError(2)\n                except TypeError as te:\n                    raise EG(\"nested\", [te])\n            except EG as nested:\n                try:\n                    raise ValueError(1)\n                except ValueError as ve:\n                    raise EG(\"eg\", [ve, nested])\n        except EG as e:\n            eg = e\n\n        self.assertMatchesTemplate(eg, EG, [ValueError(1), [TypeError(2)]])\n\n        # Match Nothing\n        match, rest = self.split_exception_group(eg, OSError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(\n            rest, ExceptionGroup, [ValueError(1), [TypeError(2)]]\n        )\n\n        # Match Everything\n        match, rest = self.split_exception_group(eg, (ValueError, TypeError))\n        self.assertMatchesTemplate(\n            match, ExceptionGroup, [ValueError(1), [TypeError(2)]]\n        )\n        self.assertIsNone(rest)\n\n        # Match ValueErrors\n        match, rest = self.split_exception_group(eg, ValueError)\n        self.assertMatchesTemplate(match, ExceptionGroup, [ValueError(1)])\n        self.assertMatchesTemplate(rest, ExceptionGroup, [[TypeError(2)]])\n\n        # Match TypeErrors\n        match, rest = self.split_exception_group(eg, TypeError)\n        self.assertMatchesTemplate(match, ExceptionGroup, [[TypeError(2)]])\n        self.assertMatchesTemplate(rest, ExceptionGroup, [ValueError(1)])\n\n    def test_split_BaseExceptionGroup_subclass_no_derive_new_override(self):\n        class EG(BaseExceptionGroup):\n            def __new__(cls, message, excs, unused):\n                # The \"unused\" arg is here to show that split() doesn't call\n                # the actual class constructor from the default derive()\n                # implementation (it would fail on unused arg if so because\n                # it assumes the BaseExceptionGroup.__new__ signature).\n                return super().__new__(cls, message, excs)\n\n        try:\n            raise EG(\"eg\", [ValueError(1), KeyboardInterrupt(2)], \"unused\")\n        except EG as e:\n            eg = e\n\n        self.assertMatchesTemplate(eg, EG, [ValueError(1), KeyboardInterrupt(2)])\n\n        # Match Nothing\n        match, rest = self.split_exception_group(eg, OSError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(\n            rest, BaseExceptionGroup, [ValueError(1), KeyboardInterrupt(2)]\n        )\n\n        # Match Everything\n        match, rest = self.split_exception_group(eg, (ValueError, KeyboardInterrupt))\n        self.assertMatchesTemplate(\n            match, BaseExceptionGroup, [ValueError(1), KeyboardInterrupt(2)]\n        )\n        self.assertIsNone(rest)\n\n        # Match ValueErrors\n        match, rest = self.split_exception_group(eg, ValueError)\n        self.assertMatchesTemplate(match, ExceptionGroup, [ValueError(1)])\n        self.assertMatchesTemplate(rest, BaseExceptionGroup, [KeyboardInterrupt(2)])\n\n        # Match KeyboardInterrupt\n        match, rest = self.split_exception_group(eg, KeyboardInterrupt)\n        self.assertMatchesTemplate(match, BaseExceptionGroup, [KeyboardInterrupt(2)])\n        self.assertMatchesTemplate(rest, ExceptionGroup, [ValueError(1)])\n\n    def test_split_ExceptionGroup_subclass_derive_and_new_overrides(self):\n        class EG(ExceptionGroup):\n            def __new__(cls, message, excs, code):\n                obj = super().__new__(cls, message, excs)\n                obj.code = code\n                return obj\n\n            def derive(self, excs):\n                return EG(self.message, excs, self.code)\n\n        try:\n            try:\n                try:\n                    raise TypeError(2)\n                except TypeError as te:\n                    raise EG(\"nested\", [te], 101)\n            except EG as nested:\n                try:\n                    raise ValueError(1)\n                except ValueError as ve:\n                    raise EG(\"eg\", [ve, nested], 42)\n        except EG as e:\n            e.add_note(\"hello\")\n            eg = e\n\n        self.assertMatchesTemplate(eg, EG, [ValueError(1), [TypeError(2)]])\n\n        # Match Nothing\n        match, rest = self.split_exception_group(eg, OSError)\n        self.assertIsNone(match)\n        self.assertMatchesTemplate(rest, EG, [ValueError(1), [TypeError(2)]])\n        self.assertEqual(rest.code, 42)\n        self.assertEqual(rest.exceptions[1].code, 101)\n        self.assertEqual(rest.__notes__, [\"hello\"])\n\n        # Match Everything\n        match, rest = self.split_exception_group(eg, (ValueError, TypeError))\n        self.assertMatchesTemplate(match, EG, [ValueError(1), [TypeError(2)]])\n        self.assertEqual(match.code, 42)\n        self.assertEqual(match.exceptions[1].code, 101)\n        self.assertEqual(match.__notes__, [\"hello\"])\n        self.assertIsNone(rest)\n\n        # Match ValueErrors\n        match, rest = self.split_exception_group(eg, ValueError)\n        self.assertMatchesTemplate(match, EG, [ValueError(1)])\n        self.assertEqual(match.code, 42)\n        self.assertEqual(match.__notes__, [\"hello\"])\n        self.assertMatchesTemplate(rest, EG, [[TypeError(2)]])\n        self.assertEqual(rest.code, 42)\n        self.assertEqual(rest.exceptions[0].code, 101)\n        self.assertEqual(rest.__notes__, [\"hello\"])\n\n        # Match TypeErrors\n        match, rest = self.split_exception_group(eg, TypeError)\n        self.assertMatchesTemplate(match, EG, [[TypeError(2)]])\n        self.assertEqual(match.code, 42)\n        self.assertEqual(match.exceptions[0].code, 101)\n        self.assertEqual(match.__notes__, [\"hello\"])\n        self.assertMatchesTemplate(rest, EG, [ValueError(1)])\n        self.assertEqual(rest.code, 42)\n        self.assertEqual(rest.__notes__, [\"hello\"])\n\n\ndef test_repr():\n    group = BaseExceptionGroup(\"foo\", [ValueError(1), KeyboardInterrupt()])\n    assert repr(group) == (\n        \"BaseExceptionGroup('foo', [ValueError(1), KeyboardInterrupt()])\"\n    )\n\n    group = ExceptionGroup(\"foo\", [ValueError(1), RuntimeError(\"bar\")])\n    assert repr(group) == \"ExceptionGroup('foo', [ValueError(1), RuntimeError('bar')])\"\n", "tests/test_apport_monkeypatching.py": "from __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nimport exceptiongroup\n\n\ndef run_script(name: str) -> subprocess.CompletedProcess[bytes]:\n    exceptiongroup_path = Path(exceptiongroup.__file__).parent.parent\n    script_path = Path(__file__).parent / name\n\n    env = dict(os.environ)\n    print(\"parent PYTHONPATH:\", env.get(\"PYTHONPATH\"))\n    if \"PYTHONPATH\" in env:  # pragma: no cover\n        pp = env[\"PYTHONPATH\"].split(os.pathsep)\n    else:\n        pp = []\n\n    pp.insert(0, str(exceptiongroup_path))\n    pp.insert(0, str(script_path.parent))\n    env[\"PYTHONPATH\"] = os.pathsep.join(pp)\n    print(\"subprocess PYTHONPATH:\", env.get(\"PYTHONPATH\"))\n\n    cmd = [sys.executable, \"-u\", str(script_path)]\n    print(\"running:\", cmd)\n    completed = subprocess.run(\n        cmd, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n    )\n    print(\"process output:\")\n    print(completed.stdout.decode(\"utf-8\"))\n    return completed\n\n\n@pytest.mark.skipif(\n    sys.version_info > (3, 11),\n    reason=\"No patching is done on Python >= 3.11\",\n)\n@pytest.mark.skipif(\n    not Path(\"/usr/lib/python3/dist-packages/apport_python_hook.py\").exists(),\n    reason=\"need Ubuntu with python3-apport installed\",\n)\ndef test_apport_excepthook_monkeypatch_interaction():\n    completed = run_script(\"apport_excepthook.py\")\n    stdout = completed.stdout.decode(\"utf-8\")\n    file = Path(__file__).parent / \"apport_excepthook.py\"\n    assert stdout == (\n        f\"\"\"\\\n  + Exception Group Traceback (most recent call last):\n  |   File \"{file}\", line 13, in <module>\n  |     raise ExceptionGroup(\"msg1\", [KeyError(\"msg2\"), ValueError(\"msg3\")])\n  | exceptiongroup.ExceptionGroup: msg1 (2 sub-exceptions)\n  +-+---------------- 1 ----------------\n    | KeyError: 'msg2'\n    +---------------- 2 ----------------\n    | ValueError: msg3\n    +------------------------------------\n\"\"\"\n    )\n", "tests/conftest.py": "import sys\n\nif sys.version_info < (3, 11):\n    collect_ignore_glob = [\"*_py311.py\"]\n", "tests/test_catch.py": "import pytest\n\nfrom exceptiongroup import BaseExceptionGroup, ExceptionGroup, catch\n\n\ndef test_bad_arg():\n    with pytest.raises(TypeError, match=\"the argument must be a mapping\"):\n        with catch(1):\n            pass\n\n\ndef test_bad_handler():\n    with pytest.raises(TypeError, match=\"handlers must be callable\"):\n        with catch({RuntimeError: None}):\n            pass\n\n\n@pytest.mark.parametrize(\n    \"exc_type\",\n    [\n        pytest.param(BaseExceptionGroup, id=\"naked_basegroup\"),\n        pytest.param(ExceptionGroup, id=\"naked_group\"),\n        pytest.param((ValueError, BaseExceptionGroup), id=\"iterable_basegroup\"),\n        pytest.param((ValueError, ExceptionGroup), id=\"iterable_group\"),\n    ],\n)\ndef test_catch_exceptiongroup(exc_type):\n    with pytest.raises(TypeError, match=\"catching ExceptionGroup with catch\"):\n        with catch({exc_type: (lambda e: True)}):\n            pass\n\n\ndef test_catch_ungrouped():\n    value_type_errors = []\n    zero_division_errors = []\n    for exc in [ValueError(\"foo\"), TypeError(\"bar\"), ZeroDivisionError()]:\n        with catch(\n            {\n                (ValueError, TypeError): value_type_errors.append,\n                ZeroDivisionError: zero_division_errors.append,\n            }\n        ):\n            raise exc\n\n    assert len(value_type_errors) == 2\n\n    assert isinstance(value_type_errors[0], ExceptionGroup)\n    assert len(value_type_errors[0].exceptions) == 1\n    assert isinstance(value_type_errors[0].exceptions[0], ValueError)\n\n    assert isinstance(value_type_errors[1], ExceptionGroup)\n    assert len(value_type_errors[1].exceptions) == 1\n    assert isinstance(value_type_errors[1].exceptions[0], TypeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    assert isinstance(zero_division_errors[0].exceptions[0], ZeroDivisionError)\n    assert len(zero_division_errors[0].exceptions) == 1\n\n\ndef test_catch_group():\n    value_runtime_errors = []\n    zero_division_errors = []\n    with catch(\n        {\n            (ValueError, RuntimeError): value_runtime_errors.append,\n            ZeroDivisionError: zero_division_errors.append,\n        }\n    ):\n        raise ExceptionGroup(\n            \"booboo\",\n            [\n                ValueError(\"foo\"),\n                ValueError(\"bar\"),\n                RuntimeError(\"bar\"),\n                ZeroDivisionError(),\n            ],\n        )\n\n    assert len(value_runtime_errors) == 1\n    assert isinstance(value_runtime_errors[0], ExceptionGroup)\n    exceptions = value_runtime_errors[0].exceptions\n    assert isinstance(exceptions[0], ValueError)\n    assert isinstance(exceptions[1], ValueError)\n    assert isinstance(exceptions[2], RuntimeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    exceptions = zero_division_errors[0].exceptions\n    assert isinstance(exceptions[0], ZeroDivisionError)\n\n\ndef test_catch_nested_group():\n    value_runtime_errors = []\n    zero_division_errors = []\n    with catch(\n        {\n            (ValueError, RuntimeError): value_runtime_errors.append,\n            ZeroDivisionError: zero_division_errors.append,\n        }\n    ):\n        nested_group = ExceptionGroup(\n            \"nested\", [RuntimeError(\"bar\"), ZeroDivisionError()]\n        )\n        raise ExceptionGroup(\"booboo\", [ValueError(\"foo\"), nested_group])\n\n    assert len(value_runtime_errors) == 1\n    exceptions = value_runtime_errors[0].exceptions\n    assert isinstance(exceptions[0], ValueError)\n    assert isinstance(exceptions[1], ExceptionGroup)\n    assert isinstance(exceptions[1].exceptions[0], RuntimeError)\n\n    assert len(zero_division_errors) == 1\n    assert isinstance(zero_division_errors[0], ExceptionGroup)\n    assert isinstance(zero_division_errors[0].exceptions[0], ExceptionGroup)\n    assert isinstance(\n        zero_division_errors[0].exceptions[0].exceptions[0], ZeroDivisionError\n    )\n\n\ndef test_catch_no_match():\n    try:\n        with catch({(ValueError, RuntimeError): (lambda e: None)}):\n            group = ExceptionGroup(\"booboo\", [ZeroDivisionError()])\n            raise group\n    except ExceptionGroup as exc:\n        assert exc is not group\n    else:\n        pytest.fail(\"Did not raise an ExceptionGroup\")\n\n\ndef test_catch_single_no_match():\n    try:\n        with catch({(ValueError, RuntimeError): (lambda e: None)}):\n            raise ZeroDivisionError\n    except ZeroDivisionError:\n        pass\n    else:\n        pytest.fail(\"Did not raise an ZeroDivisionError\")\n\n\ndef test_catch_full_match():\n    with catch({(ValueError, RuntimeError): (lambda e: None)}):\n        raise ExceptionGroup(\"booboo\", [ValueError()])\n\n\ndef test_catch_handler_raises():\n    def handler(exc):\n        raise RuntimeError(\"new\")\n\n    with pytest.raises(RuntimeError, match=\"new\") as exc:\n        with catch({(ValueError, ValueError): handler}):\n            excgrp = ExceptionGroup(\"booboo\", [ValueError(\"bar\")])\n            raise excgrp\n\n    context = exc.value.__context__\n    assert isinstance(context, ExceptionGroup)\n    assert str(context) == \"booboo (1 sub-exception)\"\n    assert len(context.exceptions) == 1\n    assert isinstance(context.exceptions[0], ValueError)\n    assert exc.value.__cause__ is None\n\n\ndef test_bare_raise_in_handler():\n    \"\"\"Test that a bare \"raise\"  \"middle\" ecxeption group gets discarded.\"\"\"\n\n    def handler(exc):\n        raise\n\n    with pytest.raises(ExceptionGroup) as excgrp:\n        with catch({(ValueError,): handler, (RuntimeError,): lambda eg: None}):\n            try:\n                first_exc = RuntimeError(\"first\")\n                raise first_exc\n            except RuntimeError as exc:\n                middle_exc = ExceptionGroup(\n                    \"bad\", [ValueError(), ValueError(), TypeError()]\n                )\n                raise middle_exc from exc\n\n    assert len(excgrp.value.exceptions) == 2\n    assert all(isinstance(exc, ValueError) for exc in excgrp.value.exceptions)\n    assert excgrp.value is not middle_exc\n    assert excgrp.value.__cause__ is first_exc\n    assert excgrp.value.__context__ is first_exc\n\n\ndef test_catch_subclass():\n    lookup_errors = []\n    with catch({LookupError: lookup_errors.append}):\n        raise KeyError(\"foo\")\n\n    assert len(lookup_errors) == 1\n    assert isinstance(lookup_errors[0], ExceptionGroup)\n    exceptions = lookup_errors[0].exceptions\n    assert isinstance(exceptions[0], KeyError)\n\n\ndef test_async_handler(request):\n    async def handler(eg):\n        pass\n\n    def delegate(eg):\n        coro = handler(eg)\n        request.addfinalizer(coro.close)\n        return coro\n\n    with pytest.raises(TypeError, match=\"Exception handler must be a sync function.\"):\n        with catch({TypeError: delegate}):\n            raise ExceptionGroup(\"message\", [TypeError(\"uh-oh\")])\n\n\ndef test_bare_reraise_from_naked_exception():\n    def handler(eg):\n        raise\n\n    with pytest.raises(ExceptionGroup) as excgrp, catch({Exception: handler}):\n        raise KeyError(\"foo\")\n\n    assert len(excgrp.value.exceptions) == 1\n    assert isinstance(excgrp.value.exceptions[0], KeyError)\n    assert str(excgrp.value.exceptions[0]) == \"'foo'\"\n", "tests/__init__.py": "", "src/exceptiongroup/_suppress.py": "from __future__ import annotations\n\nimport sys\nfrom contextlib import AbstractContextManager\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Optional, Type, cast\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup\n\nif TYPE_CHECKING:\n    # requires python 3.9\n    BaseClass = AbstractContextManager[None]\nelse:\n    BaseClass = AbstractContextManager\n\n\nclass suppress(BaseClass):\n    \"\"\"Backport of :class:`contextlib.suppress` from Python 3.12.1.\"\"\"\n\n    def __init__(self, *exceptions: type[BaseException]):\n        self._exceptions = exceptions\n\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(\n        self,\n        exctype: Optional[Type[BaseException]],\n        excinst: Optional[BaseException],\n        exctb: Optional[TracebackType],\n    ) -> bool:\n        # Unlike isinstance and issubclass, CPython exception handling\n        # currently only looks at the concrete type hierarchy (ignoring\n        # the instance and subclass checking hooks). While Guido considers\n        # that a bug rather than a feature, it's a fairly hard one to fix\n        # due to various internal implementation details. suppress provides\n        # the simpler issubclass based semantics, rather than trying to\n        # exactly reproduce the limitations of the CPython interpreter.\n        #\n        # See http://bugs.python.org/issue12029 for more details\n        if exctype is None:\n            return False\n\n        if issubclass(exctype, self._exceptions):\n            return True\n\n        if issubclass(exctype, BaseExceptionGroup):\n            match, rest = cast(BaseExceptionGroup, excinst).split(self._exceptions)\n            if rest is None:\n                return True\n\n            raise rest\n\n        return False\n", "src/exceptiongroup/_exceptions.py": "from __future__ import annotations\n\nfrom collections.abc import Callable, Sequence\nfrom functools import partial\nfrom inspect import getmro, isclass\nfrom typing import TYPE_CHECKING, Generic, Type, TypeVar, cast, overload\n\n_BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True)\n_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\n# using typing.Self would require a typing_extensions dependency on py<3.11\n_ExceptionGroupSelf = TypeVar(\"_ExceptionGroupSelf\", bound=\"ExceptionGroup\")\n_BaseExceptionGroupSelf = TypeVar(\"_BaseExceptionGroupSelf\", bound=\"BaseExceptionGroup\")\n\n\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n\n    return False\n\n\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]\n    | Callable[[_BaseExceptionT_co], bool],\n) -> Callable[[_BaseExceptionT_co], bool]:\n    if isclass(condition) and issubclass(\n        cast(Type[BaseException], condition), BaseException\n    ):\n        return partial(check_direct_subclass, parents=(condition,))\n    elif isinstance(condition, tuple):\n        if all(isclass(x) and issubclass(x, BaseException) for x in condition):\n            return partial(check_direct_subclass, parents=condition)\n    elif callable(condition):\n        return cast(\"Callable[[BaseException], bool]\", condition)\n\n    raise TypeError(\"expected a function, exception type or tuple of exception types\")\n\n\ndef _derive_and_copy_attributes(self, excs):\n    eg = self.derive(excs)\n    eg.__cause__ = self.__cause__\n    eg.__context__ = self.__context__\n    eg.__traceback__ = self.__traceback__\n    if hasattr(self, \"__notes__\"):\n        # Create a new list so that add_note() only affects one exceptiongroup\n        eg.__notes__ = list(self.__notes__)\n    return eg\n\n\nclass BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n    \"\"\"A combination of multiple unrelated exceptions.\"\"\"\n\n    def __new__(\n        cls: type[_BaseExceptionGroupSelf],\n        __message: str,\n        __exceptions: Sequence[_BaseExceptionT_co],\n    ) -> _BaseExceptionGroupSelf:\n        if not isinstance(__message, str):\n            raise TypeError(f\"argument 1 must be str, not {type(__message)}\")\n        if not isinstance(__exceptions, Sequence):\n            raise TypeError(\"second argument (exceptions) must be a sequence\")\n        if not __exceptions:\n            raise ValueError(\n                \"second argument (exceptions) must be a non-empty sequence\"\n            )\n\n        for i, exc in enumerate(__exceptions):\n            if not isinstance(exc, BaseException):\n                raise ValueError(\n                    f\"Item {i} of second argument (exceptions) is not an exception\"\n                )\n\n        if cls is BaseExceptionGroup:\n            if all(isinstance(exc, Exception) for exc in __exceptions):\n                cls = ExceptionGroup\n\n        if issubclass(cls, Exception):\n            for exc in __exceptions:\n                if not isinstance(exc, Exception):\n                    if cls is ExceptionGroup:\n                        raise TypeError(\n                            \"Cannot nest BaseExceptions in an ExceptionGroup\"\n                        )\n                    else:\n                        raise TypeError(\n                            f\"Cannot nest BaseExceptions in {cls.__name__!r}\"\n                        )\n\n        instance = super().__new__(cls, __message, __exceptions)\n        instance._message = __message\n        instance._exceptions = __exceptions\n        return instance\n\n    def add_note(self, note: str) -> None:\n        if not isinstance(note, str):\n            raise TypeError(\n                f\"Expected a string, got note={note!r} (type {type(note).__name__})\"\n            )\n\n        if not hasattr(self, \"__notes__\"):\n            self.__notes__: list[str] = []\n\n        self.__notes__.append(note)\n\n    @property\n    def message(self) -> str:\n        return self._message\n\n    @property\n    def exceptions(\n        self,\n    ) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]:\n        return tuple(self._exceptions)\n\n    @overload\n    def subgroup(\n        self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n    ) -> ExceptionGroup[_ExceptionT] | None: ...\n\n    @overload\n    def subgroup(\n        self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n    ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...\n\n    @overload\n    def subgroup(\n        self,\n        __condition: Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...\n\n    def subgroup(\n        self,\n        __condition: type[_BaseExceptionT]\n        | tuple[type[_BaseExceptionT], ...]\n        | Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> BaseExceptionGroup[_BaseExceptionT] | None:\n        condition = get_condition_filter(__condition)\n        modified = False\n        if condition(self):\n            return self\n\n        exceptions: list[BaseException] = []\n        for exc in self.exceptions:\n            if isinstance(exc, BaseExceptionGroup):\n                subgroup = exc.subgroup(__condition)\n                if subgroup is not None:\n                    exceptions.append(subgroup)\n\n                if subgroup is not exc:\n                    modified = True\n            elif condition(exc):\n                exceptions.append(exc)\n            else:\n                modified = True\n\n        if not modified:\n            return self\n        elif exceptions:\n            group = _derive_and_copy_attributes(self, exceptions)\n            return group\n        else:\n            return None\n\n    @overload\n    def split(\n        self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n    ) -> tuple[\n        ExceptionGroup[_ExceptionT] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    @overload\n    def split(\n        self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n    ) -> tuple[\n        BaseExceptionGroup[_BaseExceptionT] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    @overload\n    def split(\n        self,\n        __condition: Callable[[_BaseExceptionT_co | _BaseExceptionGroupSelf], bool],\n    ) -> tuple[\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n        BaseExceptionGroup[_BaseExceptionT_co] | None,\n    ]: ...\n\n    def split(\n        self,\n        __condition: type[_BaseExceptionT]\n        | tuple[type[_BaseExceptionT], ...]\n        | Callable[[_BaseExceptionT_co], bool],\n    ) -> (\n        tuple[\n            ExceptionGroup[_ExceptionT] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n        | tuple[\n            BaseExceptionGroup[_BaseExceptionT] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n        | tuple[\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n            BaseExceptionGroup[_BaseExceptionT_co] | None,\n        ]\n    ):\n        condition = get_condition_filter(__condition)\n        if condition(self):\n            return self, None\n\n        matching_exceptions: list[BaseException] = []\n        nonmatching_exceptions: list[BaseException] = []\n        for exc in self.exceptions:\n            if isinstance(exc, BaseExceptionGroup):\n                matching, nonmatching = exc.split(condition)\n                if matching is not None:\n                    matching_exceptions.append(matching)\n\n                if nonmatching is not None:\n                    nonmatching_exceptions.append(nonmatching)\n            elif condition(exc):\n                matching_exceptions.append(exc)\n            else:\n                nonmatching_exceptions.append(exc)\n\n        matching_group: _BaseExceptionGroupSelf | None = None\n        if matching_exceptions:\n            matching_group = _derive_and_copy_attributes(self, matching_exceptions)\n\n        nonmatching_group: _BaseExceptionGroupSelf | None = None\n        if nonmatching_exceptions:\n            nonmatching_group = _derive_and_copy_attributes(\n                self, nonmatching_exceptions\n            )\n\n        return matching_group, nonmatching_group\n\n    @overload\n    def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...\n\n    @overload\n    def derive(\n        self, __excs: Sequence[_BaseExceptionT]\n    ) -> BaseExceptionGroup[_BaseExceptionT]: ...\n\n    def derive(\n        self, __excs: Sequence[_BaseExceptionT]\n    ) -> BaseExceptionGroup[_BaseExceptionT]:\n        return BaseExceptionGroup(self.message, __excs)\n\n    def __str__(self) -> str:\n        suffix = \"\" if len(self._exceptions) == 1 else \"s\"\n        return f\"{self.message} ({len(self._exceptions)} sub-exception{suffix})\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.message!r}, {self._exceptions!r})\"\n\n\nclass ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n    def __new__(\n        cls: type[_ExceptionGroupSelf],\n        __message: str,\n        __exceptions: Sequence[_ExceptionT_co],\n    ) -> _ExceptionGroupSelf:\n        return super().__new__(cls, __message, __exceptions)\n\n    if TYPE_CHECKING:\n\n        @property\n        def exceptions(\n            self,\n        ) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...\n\n        @overload  # type: ignore[override]\n        def subgroup(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n\n        @overload\n        def subgroup(\n            self, __condition: Callable[[_ExceptionT_co | _ExceptionGroupSelf], bool]\n        ) -> ExceptionGroup[_ExceptionT_co] | None: ...\n\n        def subgroup(\n            self,\n            __condition: type[_ExceptionT]\n            | tuple[type[_ExceptionT], ...]\n            | Callable[[_ExceptionT_co], bool],\n        ) -> ExceptionGroup[_ExceptionT] | None:\n            return super().subgroup(__condition)\n\n        @overload\n        def split(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]: ...\n\n        @overload\n        def split(\n            self, __condition: Callable[[_ExceptionT_co | _ExceptionGroupSelf], bool]\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]: ...\n\n        def split(\n            self: _ExceptionGroupSelf,\n            __condition: type[_ExceptionT]\n            | tuple[type[_ExceptionT], ...]\n            | Callable[[_ExceptionT_co], bool],\n        ) -> tuple[\n            ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None\n        ]:\n            return super().split(__condition)\n", "src/exceptiongroup/_catch.py": "from __future__ import annotations\n\nimport inspect\nimport sys\nfrom collections.abc import Callable, Iterable, Mapping\nfrom contextlib import AbstractContextManager\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Any\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup\n\nif TYPE_CHECKING:\n    _Handler = Callable[[BaseExceptionGroup[Any]], Any]\n\n\nclass _Catcher:\n    def __init__(self, handler_map: Mapping[tuple[type[BaseException], ...], _Handler]):\n        self._handler_map = handler_map\n\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(\n        self,\n        etype: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,\n    ) -> bool:\n        if exc is not None:\n            unhandled = self.handle_exception(exc)\n            if unhandled is exc:\n                return False\n            elif unhandled is None:\n                return True\n            else:\n                if isinstance(exc, BaseExceptionGroup):\n                    try:\n                        raise unhandled from exc.__cause__\n                    except BaseExceptionGroup:\n                        # Change __context__ to __cause__ because Python 3.11 does this\n                        # too\n                        unhandled.__context__ = exc.__cause__\n                        raise\n\n                raise unhandled from exc\n\n        return False\n\n    def handle_exception(self, exc: BaseException) -> BaseException | None:\n        excgroup: BaseExceptionGroup | None\n        if isinstance(exc, BaseExceptionGroup):\n            excgroup = exc\n        else:\n            excgroup = BaseExceptionGroup(\"\", [exc])\n\n        new_exceptions: list[BaseException] = []\n        for exc_types, handler in self._handler_map.items():\n            matched, excgroup = excgroup.split(exc_types)\n            if matched:\n                try:\n                    try:\n                        raise matched\n                    except BaseExceptionGroup:\n                        result = handler(matched)\n                except BaseExceptionGroup as new_exc:\n                    if new_exc is matched:\n                        new_exceptions.append(new_exc)\n                    else:\n                        new_exceptions.extend(new_exc.exceptions)\n                except BaseException as new_exc:\n                    new_exceptions.append(new_exc)\n                else:\n                    if inspect.iscoroutine(result):\n                        raise TypeError(\n                            f\"Error trying to handle {matched!r} with {handler!r}. \"\n                            \"Exception handler must be a sync function.\"\n                        ) from exc\n\n            if not excgroup:\n                break\n\n        if new_exceptions:\n            if len(new_exceptions) == 1:\n                return new_exceptions[0]\n\n            return BaseExceptionGroup(\"\", new_exceptions)\n        elif (\n            excgroup and len(excgroup.exceptions) == 1 and excgroup.exceptions[0] is exc\n        ):\n            return exc\n        else:\n            return excgroup\n\n\ndef catch(\n    __handlers: Mapping[type[BaseException] | Iterable[type[BaseException]], _Handler],\n) -> AbstractContextManager[None]:\n    if not isinstance(__handlers, Mapping):\n        raise TypeError(\"the argument must be a mapping\")\n\n    handler_map: dict[\n        tuple[type[BaseException], ...], Callable[[BaseExceptionGroup]]\n    ] = {}\n    for type_or_iterable, handler in __handlers.items():\n        iterable: tuple[type[BaseException]]\n        if isinstance(type_or_iterable, type) and issubclass(\n            type_or_iterable, BaseException\n        ):\n            iterable = (type_or_iterable,)\n        elif isinstance(type_or_iterable, Iterable):\n            iterable = tuple(type_or_iterable)\n        else:\n            raise TypeError(\n                \"each key must be either an exception classes or an iterable thereof\"\n            )\n\n        if not callable(handler):\n            raise TypeError(\"handlers must be callable\")\n\n        for exc_type in iterable:\n            if not isinstance(exc_type, type) or not issubclass(\n                exc_type, BaseException\n            ):\n                raise TypeError(\n                    \"each key must be either an exception classes or an iterable \"\n                    \"thereof\"\n                )\n\n            if issubclass(exc_type, BaseExceptionGroup):\n                raise TypeError(\n                    \"catching ExceptionGroup with catch() is not allowed. \"\n                    \"Use except instead.\"\n                )\n\n        handler_map[iterable] = handler\n\n    return _Catcher(handler_map)\n", "src/exceptiongroup/__init__.py": "__all__ = [\n    \"BaseExceptionGroup\",\n    \"ExceptionGroup\",\n    \"catch\",\n    \"format_exception\",\n    \"format_exception_only\",\n    \"print_exception\",\n    \"print_exc\",\n    \"suppress\",\n]\n\nimport os\nimport sys\n\nfrom ._catch import catch\nfrom ._version import version as __version__  # noqa: F401\n\nif sys.version_info < (3, 11):\n    from ._exceptions import BaseExceptionGroup, ExceptionGroup\n    from ._formatting import (\n        format_exception,\n        format_exception_only,\n        print_exc,\n        print_exception,\n    )\n\n    if os.getenv(\"EXCEPTIONGROUP_NO_PATCH\") != \"1\":\n        from . import _formatting  # noqa: F401\n\n    BaseExceptionGroup.__module__ = __name__\n    ExceptionGroup.__module__ = __name__\nelse:\n    from traceback import (\n        format_exception,\n        format_exception_only,\n        print_exc,\n        print_exception,\n    )\n\n    BaseExceptionGroup = BaseExceptionGroup\n    ExceptionGroup = ExceptionGroup\n\nif sys.version_info < (3, 12, 1):\n    from ._suppress import suppress\nelse:\n    from contextlib import suppress\n", "src/exceptiongroup/_formatting.py": "# traceback_exception_init() adapted from trio\n#\n# _ExceptionPrintContext and traceback_exception_format() copied from the standard\n# library\nfrom __future__ import annotations\n\nimport collections.abc\nimport sys\nimport textwrap\nimport traceback\nfrom functools import singledispatch\nfrom types import TracebackType\nfrom typing import Any, List, Optional\n\nfrom ._exceptions import BaseExceptionGroup\n\nmax_group_width = 15\nmax_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\n\n\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"\n    else:\n        line = f\"{etype}: {valuestr}\\n\"\n\n    return line\n\n\ndef _safe_string(value, what, func=str):\n    try:\n        return func(value)\n    except BaseException:\n        return f\"<{what} {func.__name__}() failed>\"\n\n\nclass _ExceptionPrintContext:\n    def __init__(self):\n        self.seen = set()\n        self.exception_group_depth = 0\n        self.need_close = False\n\n    def indent(self):\n        return \" \" * (2 * self.exception_group_depth)\n\n    def emit(self, text_gen, margin_char=None):\n        if margin_char is None:\n            margin_char = \"|\"\n        indent_str = self.indent()\n        if self.exception_group_depth:\n            indent_str += margin_char + \" \"\n\n        if isinstance(text_gen, str):\n            yield textwrap.indent(text_gen, indent_str, lambda line: True)\n        else:\n            for text in text_gen:\n                yield textwrap.indent(text, indent_str, lambda line: True)\n\n\ndef exceptiongroup_excepthook(\n    etype: type[BaseException], value: BaseException, tb: TracebackType | None\n) -> None:\n    sys.stderr.write(\"\".join(traceback.format_exception(etype, value, tb)))\n\n\nclass PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,\n        *,\n        limit: int | None = None,\n        lookup_lines: bool = True,\n        capture_locals: bool = False,\n        compact: bool = False,\n        _seen: set[int] | None = None,\n    ) -> None:\n        kwargs: dict[str, Any] = {}\n        if sys.version_info >= (3, 10):\n            kwargs[\"compact\"] = compact\n\n        is_recursive_call = _seen is not None\n        if _seen is None:\n            _seen = set()\n        _seen.add(id(exc_value))\n\n        self.stack = traceback.StackSummary.extract(\n            traceback.walk_tb(exc_traceback),\n            limit=limit,\n            lookup_lines=lookup_lines,\n            capture_locals=capture_locals,\n        )\n        self.exc_type = exc_type\n        # Capture now to permit freeing resources: only complication is in the\n        # unofficial API _format_final_exc_line\n        self._str = _safe_string(exc_value, \"exception\")\n        try:\n            self.__notes__ = getattr(exc_value, \"__notes__\", None)\n        except KeyError:\n            # Workaround for https://github.com/python/cpython/issues/98778 on Python\n            # <= 3.9, and some 3.10 and 3.11 patch versions.\n            HTTPError = getattr(sys.modules.get(\"urllib.error\", None), \"HTTPError\", ())\n            if sys.version_info[:2] <= (3, 11) and isinstance(exc_value, HTTPError):\n                self.__notes__ = None\n            else:\n                raise\n\n        if exc_type and issubclass(exc_type, SyntaxError):\n            # Handle SyntaxError's specially\n            self.filename = exc_value.filename\n            lno = exc_value.lineno\n            self.lineno = str(lno) if lno is not None else None\n            self.text = exc_value.text\n            self.offset = exc_value.offset\n            self.msg = exc_value.msg\n            if sys.version_info >= (3, 10):\n                end_lno = exc_value.end_lineno\n                self.end_lineno = str(end_lno) if end_lno is not None else None\n                self.end_offset = exc_value.end_offset\n        elif (\n            exc_type\n            and issubclass(exc_type, (NameError, AttributeError))\n            and getattr(exc_value, \"name\", None) is not None\n        ):\n            suggestion = _compute_suggestion_error(exc_value, exc_traceback)\n            if suggestion:\n                self._str += f\". Did you mean: '{suggestion}'?\"\n\n        if lookup_lines:\n            # Force all lines in the stack to be loaded\n            for frame in self.stack:\n                frame.line\n\n        self.__suppress_context__ = (\n            exc_value.__suppress_context__ if exc_value is not None else False\n        )\n\n        # Convert __cause__ and __context__ to `TracebackExceptions`s, use a\n        # queue to avoid recursion (only the top-level call gets _seen == None)\n        if not is_recursive_call:\n            queue = [(self, exc_value)]\n            while queue:\n                te, e = queue.pop()\n\n                if e and e.__cause__ is not None and id(e.__cause__) not in _seen:\n                    cause = PatchedTracebackException(\n                        type(e.__cause__),\n                        e.__cause__,\n                        e.__cause__.__traceback__,\n                        limit=limit,\n                        lookup_lines=lookup_lines,\n                        capture_locals=capture_locals,\n                        _seen=_seen,\n                    )\n                else:\n                    cause = None\n\n                if compact:\n                    need_context = (\n                        cause is None and e is not None and not e.__suppress_context__\n                    )\n                else:\n                    need_context = True\n                if (\n                    e\n                    and e.__context__ is not None\n                    and need_context\n                    and id(e.__context__) not in _seen\n                ):\n                    context = PatchedTracebackException(\n                        type(e.__context__),\n                        e.__context__,\n                        e.__context__.__traceback__,\n                        limit=limit,\n                        lookup_lines=lookup_lines,\n                        capture_locals=capture_locals,\n                        _seen=_seen,\n                    )\n                else:\n                    context = None\n\n                # Capture each of the exceptions in the ExceptionGroup along with each\n                # of their causes and contexts\n                if e and isinstance(e, BaseExceptionGroup):\n                    exceptions = []\n                    for exc in e.exceptions:\n                        texc = PatchedTracebackException(\n                            type(exc),\n                            exc,\n                            exc.__traceback__,\n                            lookup_lines=lookup_lines,\n                            capture_locals=capture_locals,\n                            _seen=_seen,\n                        )\n                        exceptions.append(texc)\n                else:\n                    exceptions = None\n\n                te.__cause__ = cause\n                te.__context__ = context\n                te.exceptions = exceptions\n                if cause:\n                    queue.append((te.__cause__, e.__cause__))\n                if context:\n                    queue.append((te.__context__, e.__context__))\n                if exceptions:\n                    queue.extend(zip(te.exceptions, e.exceptions))\n\n    def format(self, *, chain=True, _ctx=None):\n        if _ctx is None:\n            _ctx = _ExceptionPrintContext()\n\n        output = []\n        exc = self\n        if chain:\n            while exc:\n                if exc.__cause__ is not None:\n                    chained_msg = _cause_message\n                    chained_exc = exc.__cause__\n                elif exc.__context__ is not None and not exc.__suppress_context__:\n                    chained_msg = _context_message\n                    chained_exc = exc.__context__\n                else:\n                    chained_msg = None\n                    chained_exc = None\n\n                output.append((chained_msg, exc))\n                exc = chained_exc\n        else:\n            output.append((None, exc))\n\n        for msg, exc in reversed(output):\n            if msg is not None:\n                yield from _ctx.emit(msg)\n            if exc.exceptions is None:\n                if exc.stack:\n                    yield from _ctx.emit(\"Traceback (most recent call last):\\n\")\n                    yield from _ctx.emit(exc.stack.format())\n                yield from _ctx.emit(exc.format_exception_only())\n            elif _ctx.exception_group_depth > max_group_depth:\n                # exception group, but depth exceeds limit\n                yield from _ctx.emit(f\"... (max_group_depth is {max_group_depth})\\n\")\n            else:\n                # format exception group\n                is_toplevel = _ctx.exception_group_depth == 0\n                if is_toplevel:\n                    _ctx.exception_group_depth += 1\n\n                if exc.stack:\n                    yield from _ctx.emit(\n                        \"Exception Group Traceback (most recent call last):\\n\",\n                        margin_char=\"+\" if is_toplevel else None,\n                    )\n                    yield from _ctx.emit(exc.stack.format())\n\n                yield from _ctx.emit(exc.format_exception_only())\n                num_excs = len(exc.exceptions)\n                if num_excs <= max_group_width:\n                    n = num_excs\n                else:\n                    n = max_group_width + 1\n                _ctx.need_close = False\n                for i in range(n):\n                    last_exc = i == n - 1\n                    if last_exc:\n                        # The closing frame may be added by a recursive call\n                        _ctx.need_close = True\n\n                    if max_group_width is not None:\n                        truncated = i >= max_group_width\n                    else:\n                        truncated = False\n                    title = f\"{i + 1}\" if not truncated else \"...\"\n                    yield (\n                        _ctx.indent()\n                        + (\"+-\" if i == 0 else \"  \")\n                        + f\"+---------------- {title} ----------------\\n\"\n                    )\n                    _ctx.exception_group_depth += 1\n                    if not truncated:\n                        yield from exc.exceptions[i].format(chain=chain, _ctx=_ctx)\n                    else:\n                        remaining = num_excs - max_group_width\n                        plural = \"s\" if remaining > 1 else \"\"\n                        yield from _ctx.emit(\n                            f\"and {remaining} more exception{plural}\\n\"\n                        )\n\n                    if last_exc and _ctx.need_close:\n                        yield _ctx.indent() + \"+------------------------------------\\n\"\n                        _ctx.need_close = False\n                    _ctx.exception_group_depth -= 1\n\n                if is_toplevel:\n                    assert _ctx.exception_group_depth == 1\n                    _ctx.exception_group_depth = 0\n\n    def format_exception_only(self):\n        \"\"\"Format the exception part of the traceback.\n        The return value is a generator of strings, each ending in a newline.\n        Normally, the generator emits a single string; however, for\n        SyntaxError exceptions, it emits several lines that (when\n        printed) display detailed information about where the syntax\n        error occurred.\n        The message indicating which exception occurred is always the last\n        string in the output.\n        \"\"\"\n        if self.exc_type is None:\n            yield traceback._format_final_exc_line(None, self._str)\n            return\n\n        stype = self.exc_type.__qualname__\n        smod = self.exc_type.__module__\n        if smod not in (\"__main__\", \"builtins\"):\n            if not isinstance(smod, str):\n                smod = \"<unknown>\"\n            stype = smod + \".\" + stype\n\n        if not issubclass(self.exc_type, SyntaxError):\n            yield _format_final_exc_line(stype, self._str)\n        elif traceback_exception_format_syntax_error is not None:\n            yield from traceback_exception_format_syntax_error(self, stype)\n        else:\n            yield from traceback_exception_original_format_exception_only(self)\n\n        if isinstance(self.__notes__, collections.abc.Sequence):\n            for note in self.__notes__:\n                note = _safe_string(note, \"note\")\n                yield from [line + \"\\n\" for line in note.split(\"\\n\")]\n        elif self.__notes__ is not None:\n            yield _safe_string(self.__notes__, \"__notes__\", func=repr)\n\n\ntraceback_exception_original_format = traceback.TracebackException.format\ntraceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )\n    traceback.TracebackException.format_exception_only = (  # type: ignore[assignment]\n        PatchedTracebackException.format_exception_only\n    )\n    sys.excepthook = exceptiongroup_excepthook\n\n# Ubuntu's system Python has a sitecustomize.py file that imports\n# apport_python_hook and replaces sys.excepthook.\n#\n# The custom hook captures the error for crash reporting, and then calls\n# sys.__excepthook__ to actually print the error.\n#\n# We don't mind it capturing the error for crash reporting, but we want to\n# take over printing the error. So we monkeypatch the apport_python_hook\n# module so that instead of calling sys.__excepthook__, it calls our custom\n# hook.\n#\n# More details: https://github.com/python-trio/trio/issues/1065\nif getattr(sys.excepthook, \"__name__\", None) in (\n    \"apport_excepthook\",\n    # on ubuntu 22.10 the hook was renamed to partial_apport_excepthook\n    \"partial_apport_excepthook\",\n):\n    # patch traceback like above\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )\n    traceback.TracebackException.format_exception_only = (  # type: ignore[assignment]\n        PatchedTracebackException.format_exception_only\n    )\n\n    from types import ModuleType\n\n    import apport_python_hook\n\n    assert sys.excepthook is apport_python_hook.apport_excepthook\n\n    # monkeypatch the sys module that apport has imported\n    fake_sys = ModuleType(\"exceptiongroup_fake_sys\")\n    fake_sys.__dict__.update(sys.__dict__)\n    fake_sys.__excepthook__ = exceptiongroup_excepthook\n    apport_python_hook.sys = fake_sys\n\n\n@singledispatch\ndef format_exception_only(__exc: BaseException) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, None, compact=True\n        ).format_exception_only()\n    )\n\n\n@format_exception_only.register\ndef _(__exc: type, value: BaseException) -> List[str]:\n    return format_exception_only(value)\n\n\n@singledispatch\ndef format_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, __exc.__traceback__, limit=limit, compact=True\n        ).format(chain=chain)\n    )\n\n\n@format_exception.register\ndef _(\n    __exc: type,\n    value: BaseException,\n    tb: TracebackType,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return format_exception(value, limit, chain)\n\n\n@singledispatch\ndef print_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    if file is None:\n        file = sys.stderr\n\n    for line in PatchedTracebackException(\n        type(__exc), __exc, __exc.__traceback__, limit=limit\n    ).format(chain=chain):\n        print(line, file=file, end=\"\")\n\n\n@print_exception.register\ndef _(\n    __exc: type,\n    value: BaseException,\n    tb: TracebackType,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    print_exception(value, limit, file, chain)\n\n\ndef print_exc(\n    limit: Optional[int] = None,\n    file: Any | None = None,\n    chain: bool = True,\n) -> None:\n    value = sys.exc_info()[1]\n    print_exception(value, limit, file, chain)\n\n\n# Python levenshtein edit distance code for NameError/AttributeError\n# suggestions, backported from 3.12\n\n_MAX_CANDIDATE_ITEMS = 750\n_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\n\n\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\n\n\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)\n    if wrong_name is None or not isinstance(wrong_name, str):\n        return None\n    if isinstance(exc_value, AttributeError):\n        obj = getattr(exc_value, \"obj\", _SENTINEL)\n        if obj is _SENTINEL:\n            return None\n        obj = exc_value.obj\n        try:\n            d = dir(obj)\n        except Exception:\n            return None\n    else:\n        assert isinstance(exc_value, NameError)\n        # find most recent frame\n        if tb is None:\n            return None\n        while tb.tb_next is not None:\n            tb = tb.tb_next\n        frame = tb.tb_frame\n\n        d = list(frame.f_locals) + list(frame.f_globals) + list(frame.f_builtins)\n    if len(d) > _MAX_CANDIDATE_ITEMS:\n        return None\n    wrong_name_len = len(wrong_name)\n    if wrong_name_len > _MAX_STRING_SIZE:\n        return None\n    best_distance = wrong_name_len\n    suggestion = None\n    for possible_name in d:\n        if possible_name == wrong_name:\n            # A missing attribute is \"found\". Don't suggest it (see GH-88821).\n            continue\n        # No more than 1/3 of the involved characters should need changed.\n        max_distance = (len(possible_name) + wrong_name_len + 3) * _MOVE_COST // 6\n        # Don't take matches we've already beaten.\n        max_distance = min(max_distance, best_distance - 1)\n        current_distance = _levenshtein_distance(\n            wrong_name, possible_name, max_distance\n        )\n        if current_distance > max_distance:\n            continue\n        if not suggestion or current_distance < best_distance:\n            suggestion = possible_name\n            best_distance = current_distance\n    return suggestion\n\n\ndef _levenshtein_distance(a, b, max_cost):\n    # A Python implementation of Python/suggestions.c:levenshtein_distance.\n\n    # Both strings are the same\n    if a == b:\n        return 0\n\n    # Trim away common affixes\n    pre = 0\n    while a[pre:] and b[pre:] and a[pre] == b[pre]:\n        pre += 1\n    a = a[pre:]\n    b = b[pre:]\n    post = 0\n    while a[: post or None] and b[: post or None] and a[post - 1] == b[post - 1]:\n        post -= 1\n    a = a[: post or None]\n    b = b[: post or None]\n    if not a or not b:\n        return _MOVE_COST * (len(a) + len(b))\n    if len(a) > _MAX_STRING_SIZE or len(b) > _MAX_STRING_SIZE:\n        return max_cost + 1\n\n    # Prefer shorter buffer\n    if len(b) < len(a):\n        a, b = b, a\n\n    # Quick fail when a match is impossible\n    if (len(b) - len(a)) * _MOVE_COST > max_cost:\n        return max_cost + 1\n\n    # Instead of producing the whole traditional len(a)-by-len(b)\n    # matrix, we can update just one row in place.\n    # Initialize the buffer row\n    row = list(range(_MOVE_COST, _MOVE_COST * (len(a) + 1), _MOVE_COST))\n\n    result = 0\n    for bindex in range(len(b)):\n        bchar = b[bindex]\n        distance = result = bindex * _MOVE_COST\n        minimum = sys.maxsize\n        for index in range(len(a)):\n            # 1) Previous distance in this row is cost(b[:b_index], a[:index])\n            substitute = distance + _substitution_cost(bchar, a[index])\n            # 2) cost(b[:b_index], a[:index+1]) from previous row\n            distance = row[index]\n            # 3) existing result is cost(b[:b_index+1], a[index])\n\n            insert_delete = min(result, distance) + _MOVE_COST\n            result = min(insert_delete, substitute)\n\n            # cost(b[:b_index+1], a[:index+1])\n            row[index] = result\n            if result < minimum:\n                minimum = result\n        if minimum > max_cost:\n            # Everything in this row is too big, so bail early.\n            return max_cost + 1\n    return result\n"}