{"src/iniconfig/exceptions.py": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing_extensions import Final\n\n\nclass ParseError(Exception):\n    path: Final[str]\n    lineno: Final[int]\n    msg: Final[str]\n\n    def __init__(self, path: str, lineno: int, msg: str) -> None:\n        super().__init__(path, lineno, msg)\n        self.path = path\n        self.lineno = lineno\n        self.msg = msg\n\n    def __str__(self) -> str:\n        return f\"{self.path}:{self.lineno + 1}: {self.msg}\"\n", "src/iniconfig/_parse.py": "from __future__ import annotations\nfrom .exceptions import ParseError\n\nfrom typing import NamedTuple\n\n\nCOMMENTCHARS = \"#;\"\n\n\nclass _ParsedLine(NamedTuple):\n    lineno: int\n    section: str | None\n    name: str | None\n    value: str | None\n\n\ndef parse_lines(path: str, line_iter: list[str]) -> list[_ParsedLine]:\n    result: list[_ParsedLine] = []\n    section = None\n    for lineno, line in enumerate(line_iter):\n        name, data = _parseline(path, line, lineno)\n        # new value\n        if name is not None and data is not None:\n            result.append(_ParsedLine(lineno, section, name, data))\n        # new section\n        elif name is not None and data is None:\n            if not name:\n                raise ParseError(path, lineno, \"empty section name\")\n            section = name\n            result.append(_ParsedLine(lineno, section, None, None))\n        # continuation\n        elif name is None and data is not None:\n            if not result:\n                raise ParseError(path, lineno, \"unexpected value continuation\")\n            last = result.pop()\n            if last.name is None:\n                raise ParseError(path, lineno, \"unexpected value continuation\")\n\n            if last.value:\n                last = last._replace(value=f\"{last.value}\\n{data}\")\n            else:\n                last = last._replace(value=data)\n            result.append(last)\n    return result\n\n\ndef _parseline(path: str, line: str, lineno: int) -> tuple[str | None, str | None]:\n    # blank lines\n    if iscommentline(line):\n        line = \"\"\n    else:\n        line = line.rstrip()\n    if not line:\n        return None, None\n    # section\n    if line[0] == \"[\":\n        realline = line\n        for c in COMMENTCHARS:\n            line = line.split(c)[0].rstrip()\n        if line[-1] == \"]\":\n            return line[1:-1], None\n        return None, realline.strip()\n    # value\n    elif not line[0].isspace():\n        try:\n            name, value = line.split(\"=\", 1)\n            if \":\" in name:\n                raise ValueError()\n        except ValueError:\n            try:\n                name, value = line.split(\":\", 1)\n            except ValueError:\n                raise ParseError(path, lineno, \"unexpected line: %r\" % line)\n        return name.strip(), value.strip()\n    # continuation\n    else:\n        return None, line.strip()\n\n\ndef iscommentline(line: str) -> bool:\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS\n", "src/iniconfig/__init__.py": "\"\"\" brain-dead simple parser for ini-style files.\n(C) Ronny Pfannschmidt, Holger Krekel -- MIT licensed\n\"\"\"\nfrom __future__ import annotations\nfrom typing import (\n    Callable,\n    Iterator,\n    Mapping,\n    Optional,\n    Tuple,\n    TypeVar,\n    Union,\n    TYPE_CHECKING,\n    NoReturn,\n    NamedTuple,\n    overload,\n    cast,\n)\n\nimport os\n\nif TYPE_CHECKING:\n    from typing_extensions import Final\n\n__all__ = [\"IniConfig\", \"ParseError\", \"COMMENTCHARS\", \"iscommentline\"]\n\nfrom .exceptions import ParseError\nfrom . import _parse\nfrom ._parse import COMMENTCHARS, iscommentline\n\n_D = TypeVar(\"_D\")\n_T = TypeVar(\"_T\")\n\n\nclass SectionWrapper:\n    config: Final[IniConfig]\n    name: Final[str]\n\n    def __init__(self, config: IniConfig, name: str) -> None:\n        self.config = config\n        self.name = name\n\n    def lineof(self, name: str) -> int | None:\n        return self.config.lineof(self.name, name)\n\n    @overload\n    def get(self, key: str) -> str | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        default: None,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(self, key: str, default: _D, convert: None = None) -> str | _D:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        default: _D,\n        convert: Callable[[str], _T],\n    ) -> _T | _D:\n        ...\n\n    # TODO: investigate possible mypy bug wrt matching the passed over data\n    def get(  # type: ignore [misc]\n        self,\n        key: str,\n        default: _D | None = None,\n        convert: Callable[[str], _T] | None = None,\n    ) -> _D | _T | str | None:\n        return self.config.get(self.name, key, convert=convert, default=default)\n\n    def __getitem__(self, key: str) -> str:\n        return self.config.sections[self.name][key]\n\n    def __iter__(self) -> Iterator[str]:\n        section: Mapping[str, str] = self.config.sections.get(self.name, {})\n\n        def lineof(key: str) -> int:\n            return self.config.lineof(self.name, key)  # type: ignore[return-value]\n\n        yield from sorted(section, key=lineof)\n\n    def items(self) -> Iterator[tuple[str, str]]:\n        for name in self:\n            yield name, self[name]\n\n\nclass IniConfig:\n    path: Final[str]\n    sections: Final[Mapping[str, Mapping[str, str]]]\n\n    def __init__(\n        self,\n        path: str | os.PathLike[str],\n        data: str | None = None,\n        encoding: str = \"utf-8\",\n    ) -> None:\n        self.path = os.fspath(path)\n        if data is None:\n            with open(self.path, encoding=encoding) as fp:\n                data = fp.read()\n\n        tokens = _parse.parse_lines(self.path, data.splitlines(True))\n\n        self._sources = {}\n        sections_data: dict[str, dict[str, str]]\n        self.sections = sections_data = {}\n\n        for lineno, section, name, value in tokens:\n            if section is None:\n                raise ParseError(self.path, lineno, \"no section header defined\")\n            self._sources[section, name] = lineno\n            if name is None:\n                if section in self.sections:\n                    raise ParseError(\n                        self.path, lineno, f\"duplicate section {section!r}\"\n                    )\n                sections_data[section] = {}\n            else:\n                if name in self.sections[section]:\n                    raise ParseError(self.path, lineno, f\"duplicate name {name!r}\")\n                assert value is not None\n                sections_data[section][name] = value\n\n    def lineof(self, section: str, name: str | None = None) -> int | None:\n        lineno = self._sources.get((section, name))\n        return None if lineno is None else lineno + 1\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n    ) -> str | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        default: None,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self, section: str, name: str, default: _D, convert: None = None\n    ) -> str | _D:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        default: _D,\n        convert: Callable[[str], _T],\n    ) -> _T | _D:\n        ...\n\n    def get(  # type: ignore\n        self,\n        section: str,\n        name: str,\n        default: _D | None = None,\n        convert: Callable[[str], _T] | None = None,\n    ) -> _D | _T | str | None:\n        try:\n            value: str = self.sections[section][name]\n        except KeyError:\n            return default\n        else:\n            if convert is not None:\n                return convert(value)\n            else:\n                return value\n\n    def __getitem__(self, name: str) -> SectionWrapper:\n        if name not in self.sections:\n            raise KeyError(name)\n        return SectionWrapper(self, name)\n\n    def __iter__(self) -> Iterator[SectionWrapper]:\n        for name in sorted(self.sections, key=self.lineof):  # type: ignore\n            yield SectionWrapper(self, name)\n\n    def __contains__(self, arg: str) -> bool:\n        return arg in self.sections\n"}