{"testing/conftest.py": "option_doctestglob = \"README.txt\"\n", "testing/test_iniconfig.py": "from __future__ import annotations\nimport pytest\nfrom iniconfig import IniConfig, ParseError, __all__ as ALL\nfrom iniconfig._parse import _ParsedLine as PL\nfrom iniconfig import iscommentline\nfrom textwrap import dedent\nfrom pathlib import Path\n\n\ncheck_tokens: dict[str, tuple[str, list[PL]]] = {\n    \"section\": (\"[section]\", [PL(0, \"section\", None, None)]),\n    \"value\": (\"value = 1\", [PL(0, None, \"value\", \"1\")]),\n    \"value in section\": (\n        \"[section]\\nvalue=1\",\n        [PL(0, \"section\", None, None), PL(1, \"section\", \"value\", \"1\")],\n    ),\n    \"value with continuation\": (\n        \"names =\\n Alice\\n Bob\",\n        [PL(0, None, \"names\", \"Alice\\nBob\")],\n    ),\n    \"value with aligned continuation\": (\n        \"names = Alice\\n        Bob\",\n        [PL(0, None, \"names\", \"Alice\\nBob\")],\n    ),\n    \"blank line\": (\n        \"[section]\\n\\nvalue=1\",\n        [PL(0, \"section\", None, None), PL(2, \"section\", \"value\", \"1\")],\n    ),\n    \"comment\": (\"# comment\", []),\n    \"comment on value\": (\"value = 1\", [PL(0, None, \"value\", \"1\")]),\n    \"comment on section\": (\"[section] #comment\", [PL(0, \"section\", None, None)]),\n    \"comment2\": (\"; comment\", []),\n    \"comment2 on section\": (\"[section] ;comment\", [PL(0, \"section\", None, None)]),\n    \"pseudo section syntax in value\": (\n        \"name = value []\",\n        [PL(0, None, \"name\", \"value []\")],\n    ),\n    \"assignment in value\": (\"value = x = 3\", [PL(0, None, \"value\", \"x = 3\")]),\n    \"use of colon for name-values\": (\"name: y\", [PL(0, None, \"name\", \"y\")]),\n    \"use of colon without space\": (\"value:y=5\", [PL(0, None, \"value\", \"y=5\")]),\n    \"equality gets precedence\": (\"value=xyz:5\", [PL(0, None, \"value\", \"xyz:5\")]),\n}\n\n\n@pytest.fixture(params=sorted(check_tokens))\ndef input_expected(request: pytest.FixtureRequest) -> tuple[str, list[PL]]:\n\n    return check_tokens[request.param]\n\n\n@pytest.fixture\ndef input(input_expected: tuple[str, list[PL]]) -> str:\n    return input_expected[0]\n\n\n@pytest.fixture\ndef expected(input_expected: tuple[str, list[PL]]) -> list[PL]:\n    return input_expected[1]\n\n\ndef parse(input: str) -> list[PL]:\n    from iniconfig._parse import parse_lines\n\n    return parse_lines(\"sample\", input.splitlines(True))\n\n\ndef parse_a_error(input: str) -> ParseError:\n    try:\n        parse(input)\n    except ParseError as e:\n        return e\n    else:\n        raise ValueError(input)\n\n\ndef test_tokenize(input: str, expected: list[PL]) -> None:\n    parsed = parse(input)\n    assert parsed == expected\n\n\ndef test_parse_empty() -> None:\n    parsed = parse(\"\")\n    assert not parsed\n    ini = IniConfig(\"sample\", \"\")\n    assert not ini.sections\n\n\ndef test_ParseError() -> None:\n    e = ParseError(\"filename\", 0, \"hello\")\n    assert str(e) == \"filename:1: hello\"\n\n\ndef test_continuation_needs_perceeding_token() -> None:\n    err = parse_a_error(\" Foo\")\n    assert err.lineno == 0\n\n\ndef test_continuation_cant_be_after_section() -> None:\n    err = parse_a_error(\"[section]\\n Foo\")\n    assert err.lineno == 1\n\n\ndef test_section_cant_be_empty() -> None:\n    err = parse_a_error(\"[]\")\n    assert err.lineno == 0\n\n\n@pytest.mark.parametrize(\n    \"line\",\n    [\n        \"!!\",\n    ],\n)\ndef test_error_on_weird_lines(line: str) -> None:\n    parse_a_error(line)\n\n\ndef test_iniconfig_from_file(tmp_path: Path) -> None:\n    path = tmp_path / \"test.txt\"\n    path.write_text(\"[metadata]\\nname=1\")\n\n    config = IniConfig(path=str(path))\n    assert list(config.sections) == [\"metadata\"]\n    config = IniConfig(str(path), \"[diff]\")\n    assert list(config.sections) == [\"diff\"]\n    with pytest.raises(TypeError):\n        IniConfig(data=path.read_text())  # type: ignore\n\n\ndef test_iniconfig_section_first() -> None:\n    with pytest.raises(ParseError) as excinfo:\n        IniConfig(\"x\", data=\"name=1\")\n    assert excinfo.value.msg == \"no section header defined\"\n\n\ndef test_iniconig_section_duplicate_fails() -> None:\n    with pytest.raises(ParseError) as excinfo:\n        IniConfig(\"x\", data=\"[section]\\n[section]\")\n    assert \"duplicate section\" in str(excinfo.value)\n\n\ndef test_iniconfig_duplicate_key_fails() -> None:\n    with pytest.raises(ParseError) as excinfo:\n        IniConfig(\"x\", data=\"[section]\\nname = Alice\\nname = bob\")\n\n    assert \"duplicate name\" in str(excinfo.value)\n\n\ndef test_iniconfig_lineof() -> None:\n    config = IniConfig(\n        \"x.ini\",\n        data=(\"[section]\\nvalue = 1\\n[section2]\\n# comment\\nvalue =2\"),\n    )\n\n    assert config.lineof(\"missing\") is None\n    assert config.lineof(\"section\") == 1\n    assert config.lineof(\"section2\") == 3\n    assert config.lineof(\"section\", \"value\") == 2\n    assert config.lineof(\"section2\", \"value\") == 5\n\n    assert config[\"section\"].lineof(\"value\") == 2\n    assert config[\"section2\"].lineof(\"value\") == 5\n\n\ndef test_iniconfig_get_convert() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nint = 1\\nfloat = 1.1\")\n    assert config.get(\"section\", \"int\") == \"1\"\n    assert config.get(\"section\", \"int\", convert=int) == 1\n\n\ndef test_iniconfig_get_missing() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nint = 1\\nfloat = 1.1\")\n    assert config.get(\"section\", \"missing\", default=1) == 1\n    assert config.get(\"section\", \"missing\") is None\n\n\ndef test_section_get() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nvalue=1\")\n    section = config[\"section\"]\n    assert section.get(\"value\", convert=int) == 1\n    assert section.get(\"value\", 1) == \"1\"\n    assert section.get(\"missing\", 2) == 2\n\n\ndef test_missing_section() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nvalue=1\")\n    with pytest.raises(KeyError):\n        config[\"other\"]\n\n\ndef test_section_getitem() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nvalue=1\")\n    assert config[\"section\"][\"value\"] == \"1\"\n    assert config[\"section\"][\"value\"] == \"1\"\n\n\ndef test_section_iter() -> None:\n    config = IniConfig(\"x\", data=\"[section]\\nvalue=1\")\n    names = list(config[\"section\"])\n    assert names == [\"value\"]\n    items = list(config[\"section\"].items())\n    assert items == [(\"value\", \"1\")]\n\n\ndef test_config_iter() -> None:\n    config = IniConfig(\n        \"x.ini\",\n        data=dedent(\n            \"\"\"\n          [section1]\n          value=1\n          [section2]\n          value=2\n    \"\"\"\n        ),\n    )\n    l = list(config)\n    assert len(l) == 2\n    assert l[0].name == \"section1\"\n    assert l[0][\"value\"] == \"1\"\n    assert l[1].name == \"section2\"\n    assert l[1][\"value\"] == \"2\"\n\n\ndef test_config_contains() -> None:\n    config = IniConfig(\n        \"x.ini\",\n        data=dedent(\n            \"\"\"\n          [section1]\n          value=1\n          [section2]\n          value=2\n    \"\"\"\n        ),\n    )\n    assert \"xyz\" not in config\n    assert \"section1\" in config\n    assert \"section2\" in config\n\n\ndef test_iter_file_order() -> None:\n    config = IniConfig(\n        \"x.ini\",\n        data=\"\"\"\n[section2] #cpython dict ordered before section\nvalue = 1\nvalue2 = 2 # dict ordered before value\n[section]\na = 1\nb = 2\n\"\"\",\n    )\n    l = list(config)\n    secnames = [x.name for x in l]\n    assert secnames == [\"section2\", \"section\"]\n    assert list(config[\"section2\"]) == [\"value\", \"value2\"]\n    assert list(config[\"section\"]) == [\"a\", \"b\"]\n\n\ndef test_example_pypirc() -> None:\n    config = IniConfig(\n        \"pypirc\",\n        data=dedent(\n            \"\"\"\n        [distutils]\n        index-servers =\n            pypi\n            other\n\n        [pypi]\n        repository: <repository-url>\n        username: <username>\n        password: <password>\n\n        [other]\n        repository: http://example.com/pypi\n        username: <username>\n        password: <password>\n    \"\"\"\n        ),\n    )\n    distutils, pypi, other = list(config)\n    assert distutils[\"index-servers\"] == \"pypi\\nother\"\n    assert pypi[\"repository\"] == \"<repository-url>\"\n    assert pypi[\"username\"] == \"<username>\"\n    assert pypi[\"password\"] == \"<password>\"\n    assert [\"repository\", \"username\", \"password\"] == list(other)\n\n\ndef test_api_import() -> None:\n    assert ALL == [\"IniConfig\", \"ParseError\", \"COMMENTCHARS\", \"iscommentline\"]\n\n\n@pytest.mark.parametrize(\n    \"line\",\n    [\n        \"#qwe\",\n        \"  #qwe\",\n        \";qwe\",\n        \" ;qwe\",\n    ],\n)\ndef test_iscommentline_true(line: str) -> None:\n    assert iscommentline(line)\n", "src/iniconfig/exceptions.py": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing_extensions import Final\n\n\nclass ParseError(Exception):\n    path: Final[str]\n    lineno: Final[int]\n    msg: Final[str]\n\n    def __init__(self, path: str, lineno: int, msg: str) -> None:\n        super().__init__(path, lineno, msg)\n        self.path = path\n        self.lineno = lineno\n        self.msg = msg\n\n    def __str__(self) -> str:\n        return f\"{self.path}:{self.lineno + 1}: {self.msg}\"\n", "src/iniconfig/_parse.py": "from __future__ import annotations\nfrom .exceptions import ParseError\n\nfrom typing import NamedTuple\n\n\nCOMMENTCHARS = \"#;\"\n\n\nclass _ParsedLine(NamedTuple):\n    lineno: int\n    section: str | None\n    name: str | None\n    value: str | None\n\n\ndef parse_lines(path: str, line_iter: list[str]) -> list[_ParsedLine]:\n    result: list[_ParsedLine] = []\n    section = None\n    for lineno, line in enumerate(line_iter):\n        name, data = _parseline(path, line, lineno)\n        # new value\n        if name is not None and data is not None:\n            result.append(_ParsedLine(lineno, section, name, data))\n        # new section\n        elif name is not None and data is None:\n            if not name:\n                raise ParseError(path, lineno, \"empty section name\")\n            section = name\n            result.append(_ParsedLine(lineno, section, None, None))\n        # continuation\n        elif name is None and data is not None:\n            if not result:\n                raise ParseError(path, lineno, \"unexpected value continuation\")\n            last = result.pop()\n            if last.name is None:\n                raise ParseError(path, lineno, \"unexpected value continuation\")\n\n            if last.value:\n                last = last._replace(value=f\"{last.value}\\n{data}\")\n            else:\n                last = last._replace(value=data)\n            result.append(last)\n    return result\n\n\ndef _parseline(path: str, line: str, lineno: int) -> tuple[str | None, str | None]:\n    # blank lines\n    if iscommentline(line):\n        line = \"\"\n    else:\n        line = line.rstrip()\n    if not line:\n        return None, None\n    # section\n    if line[0] == \"[\":\n        realline = line\n        for c in COMMENTCHARS:\n            line = line.split(c)[0].rstrip()\n        if line[-1] == \"]\":\n            return line[1:-1], None\n        return None, realline.strip()\n    # value\n    elif not line[0].isspace():\n        try:\n            name, value = line.split(\"=\", 1)\n            if \":\" in name:\n                raise ValueError()\n        except ValueError:\n            try:\n                name, value = line.split(\":\", 1)\n            except ValueError:\n                raise ParseError(path, lineno, \"unexpected line: %r\" % line)\n        return name.strip(), value.strip()\n    # continuation\n    else:\n        return None, line.strip()\n\n\ndef iscommentline(line: str) -> bool:\n    c = line.lstrip()[:1]\n    return c in COMMENTCHARS\n", "src/iniconfig/__init__.py": "\"\"\" brain-dead simple parser for ini-style files.\n(C) Ronny Pfannschmidt, Holger Krekel -- MIT licensed\n\"\"\"\nfrom __future__ import annotations\nfrom typing import (\n    Callable,\n    Iterator,\n    Mapping,\n    Optional,\n    Tuple,\n    TypeVar,\n    Union,\n    TYPE_CHECKING,\n    NoReturn,\n    NamedTuple,\n    overload,\n    cast,\n)\n\nimport os\n\nif TYPE_CHECKING:\n    from typing_extensions import Final\n\n__all__ = [\"IniConfig\", \"ParseError\", \"COMMENTCHARS\", \"iscommentline\"]\n\nfrom .exceptions import ParseError\nfrom . import _parse\nfrom ._parse import COMMENTCHARS, iscommentline\n\n_D = TypeVar(\"_D\")\n_T = TypeVar(\"_T\")\n\n\nclass SectionWrapper:\n    config: Final[IniConfig]\n    name: Final[str]\n\n    def __init__(self, config: IniConfig, name: str) -> None:\n        self.config = config\n        self.name = name\n\n    def lineof(self, name: str) -> int | None:\n        return self.config.lineof(self.name, name)\n\n    @overload\n    def get(self, key: str) -> str | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        default: None,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(self, key: str, default: _D, convert: None = None) -> str | _D:\n        ...\n\n    @overload\n    def get(\n        self,\n        key: str,\n        default: _D,\n        convert: Callable[[str], _T],\n    ) -> _T | _D:\n        ...\n\n    # TODO: investigate possible mypy bug wrt matching the passed over data\n    def get(  # type: ignore [misc]\n        self,\n        key: str,\n        default: _D | None = None,\n        convert: Callable[[str], _T] | None = None,\n    ) -> _D | _T | str | None:\n        return self.config.get(self.name, key, convert=convert, default=default)\n\n    def __getitem__(self, key: str) -> str:\n        return self.config.sections[self.name][key]\n\n    def __iter__(self) -> Iterator[str]:\n        section: Mapping[str, str] = self.config.sections.get(self.name, {})\n\n        def lineof(key: str) -> int:\n            return self.config.lineof(self.name, key)  # type: ignore[return-value]\n\n        yield from sorted(section, key=lineof)\n\n    def items(self) -> Iterator[tuple[str, str]]:\n        for name in self:\n            yield name, self[name]\n\n\nclass IniConfig:\n    path: Final[str]\n    sections: Final[Mapping[str, Mapping[str, str]]]\n\n    def __init__(\n        self,\n        path: str | os.PathLike[str],\n        data: str | None = None,\n        encoding: str = \"utf-8\",\n    ) -> None:\n        self.path = os.fspath(path)\n        if data is None:\n            with open(self.path, encoding=encoding) as fp:\n                data = fp.read()\n\n        tokens = _parse.parse_lines(self.path, data.splitlines(True))\n\n        self._sources = {}\n        sections_data: dict[str, dict[str, str]]\n        self.sections = sections_data = {}\n\n        for lineno, section, name, value in tokens:\n            if section is None:\n                raise ParseError(self.path, lineno, \"no section header defined\")\n            self._sources[section, name] = lineno\n            if name is None:\n                if section in self.sections:\n                    raise ParseError(\n                        self.path, lineno, f\"duplicate section {section!r}\"\n                    )\n                sections_data[section] = {}\n            else:\n                if name in self.sections[section]:\n                    raise ParseError(self.path, lineno, f\"duplicate name {name!r}\")\n                assert value is not None\n                sections_data[section][name] = value\n\n    def lineof(self, section: str, name: str | None = None) -> int | None:\n        lineno = self._sources.get((section, name))\n        return None if lineno is None else lineno + 1\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n    ) -> str | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        default: None,\n        convert: Callable[[str], _T],\n    ) -> _T | None:\n        ...\n\n    @overload\n    def get(\n        self, section: str, name: str, default: _D, convert: None = None\n    ) -> str | _D:\n        ...\n\n    @overload\n    def get(\n        self,\n        section: str,\n        name: str,\n        default: _D,\n        convert: Callable[[str], _T],\n    ) -> _T | _D:\n        ...\n\n    def get(  # type: ignore\n        self,\n        section: str,\n        name: str,\n        default: _D | None = None,\n        convert: Callable[[str], _T] | None = None,\n    ) -> _D | _T | str | None:\n        try:\n            value: str = self.sections[section][name]\n        except KeyError:\n            return default\n        else:\n            if convert is not None:\n                return convert(value)\n            else:\n                return value\n\n    def __getitem__(self, name: str) -> SectionWrapper:\n        if name not in self.sections:\n            raise KeyError(name)\n        return SectionWrapper(self, name)\n\n    def __iter__(self) -> Iterator[SectionWrapper]:\n        for name in sorted(self.sections, key=self.lineof):  # type: ignore\n            yield SectionWrapper(self, name)\n\n    def __contains__(self, arg: str) -> bool:\n        return arg in self.sections\n"}