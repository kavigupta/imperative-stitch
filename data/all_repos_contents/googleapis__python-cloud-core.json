{"noxfile.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import\nimport os\nimport shutil\n\nimport nox\n\n\nBLACK_VERSION = \"black==23.7.0\"\nBLACK_PATHS = [\"docs\", \"google\", \"tests\", \"noxfile.py\", \"setup.py\"]\n\nDEFAULT_PYTHON_VERSION = \"3.8\"\nCURRENT_DIRECTORY = os.path.abspath(os.path.dirname(__file__))\n\n\n@nox.session(python=\"3.10\")\ndef lint(session):\n    \"\"\"Run linters.\n\n    Returns a failure if the linters find linting errors or sufficiently\n    serious code quality issues.\n    \"\"\"\n    session.install(\"flake8\", \"flake8-import-order\", BLACK_VERSION)\n    session.install(\".\")\n    session.run(\"flake8\", \"google\", \"tests\")\n\n\n@nox.session(python=DEFAULT_PYTHON_VERSION)\ndef mypy(session):\n    \"\"\"Run type-checking.\"\"\"\n    session.install(\".\", \"mypy\")\n    # Exclude types-protobuf==4.24.0.20240106\n    # See https://github.com/python/typeshed/issues/11254\n    session.install(\n        \"types-setuptools\",\n        \"types-requests\",\n        \"types-mock\",\n        \"types-protobuf!=4.24.0.20240106\",\n    )\n    session.run(\"mypy\", \"-p\", \"google\", \"-p\", \"tests\")\n\n\n@nox.session(python=DEFAULT_PYTHON_VERSION)\ndef blacken(session):\n    \"\"\"Run black.\n\n    Format code to uniform standard.\n    \"\"\"\n    session.install(BLACK_VERSION)\n    session.run(\"black\", *BLACK_PATHS)\n\n\ndef default(session):\n    \"\"\"Default unit test session.\n    This is intended to be run **without** an interpreter set, so\n    that the current ``python`` (on the ``PATH``) or the version of\n    Python corresponding to the ``nox`` binary the ``PATH`` can\n    run the tests.\n    \"\"\"\n    constraints_path = os.path.join(\n        CURRENT_DIRECTORY, \"testing\", \"constraints-{}.txt\".format(session.python)\n    )\n\n    # Install all test dependencies, then install local packages in-place.\n    session.install(\"pytest\", \"pytest-cov\", \"-c\", constraints_path)\n    session.install(\"-e\", \".[grpc]\", \"-c\", constraints_path)\n\n    # Run py.test against the unit tests.\n    session.run(\n        \"py.test\",\n        \"--quiet\",\n        \"--cov=google.cloud\",\n        \"--cov=tests.unit\",\n        \"--cov-append\",\n        \"--cov-config=.coveragerc\",\n        \"--cov-report=\",\n        \"--cov-fail-under=0\",\n        os.path.join(\"tests\", \"unit\"),\n        *session.posargs,\n    )\n\n\n@nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"])\ndef unit(session):\n    \"\"\"Default unit test session.\"\"\"\n    default(session)\n\n\n@nox.session(python=\"3.10\")\ndef lint_setup_py(session):\n    \"\"\"Verify that setup.py is valid (including RST check).\"\"\"\n\n    session.install(\"docutils\", \"Pygments\")\n    session.run(\"python\", \"setup.py\", \"check\", \"--restructuredtext\", \"--strict\")\n\n\n@nox.session(python=DEFAULT_PYTHON_VERSION)\ndef cover(session):\n    \"\"\"Run the final coverage report.\n\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.install(\"coverage\", \"pytest-cov\")\n    session.run(\"coverage\", \"report\", \"--show-missing\", \"--fail-under=100\")\n    session.run(\"coverage\", \"erase\")\n\n\n@nox.session(python=\"3.9\")\ndef docs(session):\n    \"\"\"Build the docs for this library.\"\"\"\n\n    session.install(\".\", \"grpcio >= 1.8.2\", \"grpcio-gcp >= 0.2.2\")\n    session.install(\"-e\", \".\")\n    session.install(\n        # We need to pin to specific versions of the `sphinxcontrib-*` packages\n        # which still support sphinx 4.x.\n        # See https://github.com/googleapis/sphinx-docfx-yaml/issues/344\n        # and https://github.com/googleapis/sphinx-docfx-yaml/issues/345.\n        \"sphinxcontrib-applehelp==1.0.4\",\n        \"sphinxcontrib-devhelp==1.0.2\",\n        \"sphinxcontrib-htmlhelp==2.0.1\",\n        \"sphinxcontrib-qthelp==1.0.3\",\n        \"sphinxcontrib-serializinghtml==1.1.5\",\n        \"sphinx==4.5.0\",\n        \"alabaster\",\n        \"recommonmark\",\n    )\n\n    shutil.rmtree(os.path.join(\"docs\", \"_build\"), ignore_errors=True)\n    session.run(\n        \"sphinx-build\",\n        \"-W\",  # warnings as errors\n        \"-T\",  # show full traceback on exception\n        \"-N\",  # no colors\n        \"-b\",\n        \"html\",\n        \"-d\",\n        os.path.join(\"docs\", \"_build\", \"doctrees\", \"\"),\n        os.path.join(\"docs\", \"\"),\n        os.path.join(\"docs\", \"_build\", \"html\", \"\"),\n    )\n\n\n@nox.session(python=\"3.10\")\ndef docfx(session):\n    \"\"\"Build the docfx yaml files for this library.\"\"\"\n\n    session.install(\"-e\", \".\")\n    session.install(\n        # We need to pin to specific versions of the `sphinxcontrib-*` packages\n        # which still support sphinx 4.x.\n        # See https://github.com/googleapis/sphinx-docfx-yaml/issues/344\n        # and https://github.com/googleapis/sphinx-docfx-yaml/issues/345.\n        \"sphinxcontrib-applehelp==1.0.4\",\n        \"sphinxcontrib-devhelp==1.0.2\",\n        \"sphinxcontrib-htmlhelp==2.0.1\",\n        \"sphinxcontrib-qthelp==1.0.3\",\n        \"sphinxcontrib-serializinghtml==1.1.5\",\n        \"gcp-sphinx-docfx-yaml\",\n        \"alabaster\",\n        \"recommonmark\",\n    )\n\n    shutil.rmtree(os.path.join(\"docs\", \"_build\"), ignore_errors=True)\n    session.run(\n        \"sphinx-build\",\n        \"-T\",  # show full traceback on exception\n        \"-N\",  # no colors\n        \"-D\",\n        (\n            \"extensions=sphinx.ext.autodoc,\"\n            \"sphinx.ext.autosummary,\"\n            \"docfx_yaml.extension,\"\n            \"sphinx.ext.intersphinx,\"\n            \"sphinx.ext.coverage,\"\n            \"sphinx.ext.napoleon,\"\n            \"sphinx.ext.todo,\"\n            \"sphinx.ext.viewcode,\"\n            \"recommonmark\"\n        ),\n        \"-b\",\n        \"html\",\n        \"-d\",\n        os.path.join(\"docs\", \"_build\", \"doctrees\", \"\"),\n        os.path.join(\"docs\", \"\"),\n        os.path.join(\"docs\", \"_build\", \"html\", \"\"),\n    )\n", "setup.py": "# Copyright 2018 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport os\n\nimport setuptools\n\n\n# Package metadata.\n\nname = \"google-cloud-core\"\ndescription = \"Google Cloud API client core library\"\n# Should be one of:\n# 'Development Status :: 3 - Alpha'\n# 'Development Status :: 4 - Beta'\n# 'Development Status :: 5 - Production/Stable'\nrelease_status = \"Development Status :: 5 - Production/Stable\"\ndependencies = [\n    \"google-api-core >= 1.31.6, <3.0.0dev,!=2.0.*,!=2.1.*,!=2.2.*,!=2.3.0\",\n    \"google-auth >= 1.25.0, < 3.0dev\",\n    \"importlib-metadata > 1.0.0; python_version<'3.8'\",\n]\nextras = {\n    \"grpc\": [\n        \"grpcio >= 1.38.0, < 2.0dev\",\n        \"grpcio-status >= 1.38.0, < 2.0.dev0\",\n    ],\n}\n\n# Setup boilerplate below this line.\n\npackage_root = os.path.abspath(os.path.dirname(__file__))\n\nversion = {}\nwith open(os.path.join(package_root, \"google/cloud/version.py\")) as fp:\n    exec(fp.read(), version)\nversion = version[\"__version__\"]\n\nreadme_filename = os.path.join(package_root, \"README.rst\")\nwith io.open(readme_filename, encoding=\"utf-8\") as readme_file:\n    readme = readme_file.read()\n\n# Only include packages under the 'google' namespace. Do not include tests,\n# benchmarks, etc.\npackages = [\n    package\n    for package in setuptools.find_namespace_packages()\n    if package.startswith(\"google\")\n]\n\nsetuptools.setup(\n    name=name,\n    version=version,\n    description=description,\n    long_description=readme,\n    author=\"Google LLC\",\n    author_email=\"googleapis-packages@google.com\",\n    license=\"Apache 2.0\",\n    url=\"https://github.com/googleapis/python-cloud-core\",\n    classifiers=[\n        release_status,\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Operating System :: OS Independent\",\n        \"Topic :: Internet\",\n    ],\n    platforms=\"Posix; MacOS X; Windows\",\n    packages=packages,\n    install_requires=dependencies,\n    extras_require=extras,\n    python_requires=\">=3.7\",\n    include_package_data=True,\n    zip_safe=False,\n)\n", "owlbot.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"This script is used to synthesize generated parts of this library.\"\"\"\n\nimport synthtool as s\nfrom synthtool import gcp\nfrom synthtool.languages import python\n\ncommon = gcp.CommonTemplates()\n\n# ----------------------------------------------------------------------------\n# Add templated files\n# ----------------------------------------------------------------------------\ntemplated_files = common.py_library(\n    microgenerator=True,\n    cov_level=100,\n)\ns.move(\n    templated_files,\n    excludes=[\n        \"docs/multiprocessing.rst\",\n        \"noxfile.py\",\n        \".flake8\",\n        \".coveragerc\",\n        \"setup.cfg\",\n        \"README.rst\",\n    ],\n)\n\npython.configure_previous_major_version_branches()\n\ns.shell.run([\"nox\", \"-s\", \"blacken\"], hide_output=False)\n", "pylint.config.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"This module is used to configure gcp-devrel-py-tools run-pylint.\"\"\"\n\n# Library configuration\n\n# library_additions = {}\n# library_replacements = {}\n\n# Test configuration\n\n# test_additions = copy.deepcopy(library_additions)\n# test_replacements = copy.deepcopy(library_replacements)\n", "scripts/readme-gen/readme_gen.py": "#!/usr/bin/env python\n\n# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Generates READMEs using configuration defined in yaml.\"\"\"\n\nimport argparse\nimport io\nimport os\nimport subprocess\n\nimport jinja2\nimport yaml\n\n\njinja_env = jinja2.Environment(\n    trim_blocks=True,\n    loader=jinja2.FileSystemLoader(\n        os.path.abspath(os.path.join(os.path.dirname(__file__), \"templates\"))\n    ),\n    autoescape=True,\n)\n\nREADME_TMPL = jinja_env.get_template(\"README.tmpl.rst\")\n\n\ndef get_help(file):\n    return subprocess.check_output([\"python\", file, \"--help\"]).decode()\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"source\")\n    parser.add_argument(\"--destination\", default=\"README.rst\")\n\n    args = parser.parse_args()\n\n    source = os.path.abspath(args.source)\n    root = os.path.dirname(source)\n    destination = os.path.join(root, args.destination)\n\n    jinja_env.globals[\"get_help\"] = get_help\n\n    with io.open(source, \"r\") as f:\n        config = yaml.load(f)\n\n    # This allows get_help to execute in the right directory.\n    os.chdir(root)\n\n    output = README_TMPL.render(config)\n\n    with io.open(destination, \"w\") as f:\n        f.write(output)\n\n\nif __name__ == \"__main__\":\n    main()\n", "google/cloud/version.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__version__ = \"2.4.1\"\n", "google/cloud/client/__init__.py": "# Copyright 2015 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Base classes for client used to interact with Google Cloud APIs.\"\"\"\n\nimport io\nimport json\nimport os\nfrom pickle import PicklingError\nfrom typing import Tuple\nfrom typing import Union\n\nimport google.api_core.client_options\nimport google.api_core.exceptions\nimport google.auth\nfrom google.auth import environment_vars\nimport google.auth.credentials\nimport google.auth.transport.requests\nfrom google.cloud._helpers import _determine_default_project\nfrom google.oauth2 import service_account\n\n\n_GOOGLE_AUTH_CREDENTIALS_HELP = (\n    \"This library only supports credentials from google-auth-library-python. \"\n    \"See https://google-auth.readthedocs.io/en/latest/ \"\n    \"for help on authentication with this library.\"\n)\n\n# Default timeout for auth requests.\n_CREDENTIALS_REFRESH_TIMEOUT = 300\n\n\nclass _ClientFactoryMixin(object):\n    \"\"\"Mixin to allow factories that create credentials.\n\n    .. note::\n\n        This class is virtual.\n    \"\"\"\n\n    _SET_PROJECT = False\n\n    @classmethod\n    def from_service_account_info(cls, info, *args, **kwargs):\n        \"\"\"Factory to retrieve JSON credentials while creating client.\n\n        :type info: dict\n        :param info:\n            The JSON object with a private key and other credentials\n            information (downloaded from the Google APIs console).\n\n        :type args: tuple\n        :param args: Remaining positional arguments to pass to constructor.\n\n        :param kwargs: Remaining keyword arguments to pass to constructor.\n\n        :rtype: :class:`_ClientFactoryMixin`\n        :returns: The client created with the retrieved JSON credentials.\n        :raises TypeError: if there is a conflict with the kwargs\n                 and the credentials created by the factory.\n        \"\"\"\n        if \"credentials\" in kwargs:\n            raise TypeError(\"credentials must not be in keyword arguments\")\n\n        credentials = service_account.Credentials.from_service_account_info(info)\n        if cls._SET_PROJECT:\n            if \"project\" not in kwargs:\n                kwargs[\"project\"] = info.get(\"project_id\")\n\n        kwargs[\"credentials\"] = credentials\n        return cls(*args, **kwargs)\n\n    @classmethod\n    def from_service_account_json(cls, json_credentials_path, *args, **kwargs):\n        \"\"\"Factory to retrieve JSON credentials while creating client.\n\n        :type json_credentials_path: str\n        :param json_credentials_path: The path to a private key file (this file\n                                      was given to you when you created the\n                                      service account). This file must contain\n                                      a JSON object with a private key and\n                                      other credentials information (downloaded\n                                      from the Google APIs console).\n\n        :type args: tuple\n        :param args: Remaining positional arguments to pass to constructor.\n\n        :param kwargs: Remaining keyword arguments to pass to constructor.\n\n        :rtype: :class:`_ClientFactoryMixin`\n        :returns: The client created with the retrieved JSON credentials.\n        :raises TypeError: if there is a conflict with the kwargs\n                 and the credentials created by the factory.\n        \"\"\"\n        with io.open(json_credentials_path, \"r\", encoding=\"utf-8\") as json_fi:\n            credentials_info = json.load(json_fi)\n\n        return cls.from_service_account_info(credentials_info, *args, **kwargs)\n\n\nclass Client(_ClientFactoryMixin):\n    \"\"\"Client to bundle configuration needed for API requests.\n\n    Stores ``credentials`` and an HTTP object so that subclasses\n    can pass them along to a connection class.\n\n    If no value is passed in for ``_http``, a :class:`requests.Session` object\n    will be created and authorized with the ``credentials``. If not, the\n    ``credentials`` and ``_http`` need not be related.\n\n    Callers and subclasses may seek to use the private key from\n    ``credentials`` to sign data.\n\n    Args:\n        credentials (google.auth.credentials.Credentials):\n            (Optional) The OAuth2 Credentials to use for this client. If not\n            passed (and if no ``_http`` object is passed), falls back to the\n            default inferred from the environment.\n        client_options (google.api_core.client_options.ClientOptions):\n            (Optional) Custom options for the client.\n        _http (requests.Session):\n            (Optional) HTTP object to make requests. Can be any object that\n            defines ``request()`` with the same interface as\n            :meth:`requests.Session.request`. If not passed, an ``_http``\n            object is created that is bound to the ``credentials`` for the\n            current object.\n            This parameter should be considered private, and could change in\n            the future.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError:\n            Raised if ``credentials`` is not specified and the library fails\n            to acquire default credentials.\n    \"\"\"\n\n    SCOPE: Union[Tuple[str, ...], None] = None\n    \"\"\"The scopes required for authenticating with a service.\n\n    Needs to be set by subclasses.\n    \"\"\"\n\n    def __init__(self, credentials=None, _http=None, client_options=None):\n        if isinstance(client_options, dict):\n            client_options = google.api_core.client_options.from_dict(client_options)\n        if client_options is None:\n            client_options = google.api_core.client_options.ClientOptions()\n\n        if credentials and client_options.credentials_file:\n            raise google.api_core.exceptions.DuplicateCredentialArgs(\n                \"'credentials' and 'client_options.credentials_file' are mutually exclusive.\"\n            )\n\n        if credentials and not isinstance(\n            credentials, google.auth.credentials.Credentials\n        ):\n            raise ValueError(_GOOGLE_AUTH_CREDENTIALS_HELP)\n\n        scopes = client_options.scopes or self.SCOPE\n\n        # if no http is provided, credentials must exist\n        if not _http and credentials is None:\n            if client_options.credentials_file:\n                credentials, _ = google.auth.load_credentials_from_file(\n                    client_options.credentials_file, scopes=scopes\n                )\n            else:\n                credentials, _ = google.auth.default(scopes=scopes)\n\n        self._credentials = google.auth.credentials.with_scopes_if_required(\n            credentials, scopes=scopes\n        )\n\n        if client_options.quota_project_id:\n            self._credentials = self._credentials.with_quota_project(\n                client_options.quota_project_id\n            )\n\n        self._http_internal = _http\n        self._client_cert_source = client_options.client_cert_source\n\n    def __getstate__(self):\n        \"\"\"Explicitly state that clients are not pickleable.\"\"\"\n        raise PicklingError(\n            \"\\n\".join(\n                [\n                    \"Pickling client objects is explicitly not supported.\",\n                    \"Clients have non-trivial state that is local and unpickleable.\",\n                ]\n            )\n        )\n\n    @property\n    def _http(self):\n        \"\"\"Getter for object used for HTTP transport.\n\n        :rtype: :class:`~requests.Session`\n        :returns: An HTTP object.\n        \"\"\"\n        if self._http_internal is None:\n            self._http_internal = google.auth.transport.requests.AuthorizedSession(\n                self._credentials,\n                refresh_timeout=_CREDENTIALS_REFRESH_TIMEOUT,\n            )\n            self._http_internal.configure_mtls_channel(self._client_cert_source)\n        return self._http_internal\n\n    def close(self):\n        \"\"\"Clean up transport, if set.\n\n        Suggested use:\n\n        .. code-block:: python\n\n           import contextlib\n\n           with contextlib.closing(client):  # closes on exit\n               do_something_with(client)\n        \"\"\"\n        if self._http_internal is not None:\n            self._http_internal.close()\n\n\nclass _ClientProjectMixin(object):\n    \"\"\"Mixin to allow setting the project on the client.\n\n    :type project: str\n    :param project:\n        (Optional) the project which the client acts on behalf of. If not\n        passed, falls back to the default inferred from the environment.\n\n    :type credentials: :class:`google.auth.credentials.Credentials`\n    :param credentials:\n        (Optional) credentials used to discover a project, if not passed.\n\n    :raises: :class:`EnvironmentError` if the project is neither passed in nor\n             set on the credentials or in the environment. :class:`ValueError`\n             if the project value is invalid.\n    \"\"\"\n\n    def __init__(self, project=None, credentials=None):\n        # This test duplicates the one from `google.auth.default`, but earlier,\n        # for backward compatibility:  we want the environment variable to\n        # override any project set on the credentials.  See:\n        # https://github.com/googleapis/python-cloud-core/issues/27\n        if project is None:\n            project = os.getenv(\n                environment_vars.PROJECT,\n                os.getenv(environment_vars.LEGACY_PROJECT),\n            )\n\n        # Project set on explicit credentials overrides discovery from\n        # SDK / GAE / GCE.\n        if project is None and credentials is not None:\n            project = getattr(credentials, \"project_id\", None)\n\n        if project is None:\n            project = self._determine_default(project)\n\n        if project is None:\n            raise EnvironmentError(\n                \"Project was not passed and could not be \"\n                \"determined from the environment.\"\n            )\n\n        if isinstance(project, bytes):\n            project = project.decode(\"utf-8\")\n\n        if not isinstance(project, str):\n            raise ValueError(\"Project must be a string.\")\n\n        self.project = project\n\n    @staticmethod\n    def _determine_default(project):\n        \"\"\"Helper:  use default project detection.\"\"\"\n        return _determine_default_project(project)\n\n\nclass ClientWithProject(Client, _ClientProjectMixin):\n    \"\"\"Client that also stores a project.\n\n    :type project: str\n    :param project: the project which the client acts on behalf of. If not\n                    passed falls back to the default inferred from the\n                    environment.\n\n    :type credentials: :class:`~google.auth.credentials.Credentials`\n    :param credentials: (Optional) The OAuth2 Credentials to use for this\n                        client. If not passed (and if no ``_http`` object is\n                        passed), falls back to the default inferred from the\n                        environment.\n\n    :type _http: :class:`~requests.Session`\n    :param _http: (Optional) HTTP object to make requests. Can be any object\n                  that defines ``request()`` with the same interface as\n                  :meth:`~requests.Session.request`. If not passed, an\n                  ``_http`` object is created that is bound to the\n                  ``credentials`` for the current object.\n                  This parameter should be considered private, and could\n                  change in the future.\n\n    :raises: :class:`ValueError` if the project is neither passed in nor\n             set in the environment.\n    \"\"\"\n\n    _SET_PROJECT = True  # Used by from_service_account_json()\n\n    def __init__(self, project=None, credentials=None, client_options=None, _http=None):\n        _ClientProjectMixin.__init__(self, project=project, credentials=credentials)\n        Client.__init__(\n            self, credentials=credentials, client_options=client_options, _http=_http\n        )\n", "google/cloud/exceptions/__init__.py": "# Copyright 2014 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# pylint: disable=invalid-name\n# pylint recognizies all of these aliases as constants and thinks they have\n# invalid names.\n\n\"\"\"Custom exceptions for :mod:`google.cloud` package.\"\"\"\n\n# Avoid the grpc and google.cloud.grpc collision.\nfrom __future__ import absolute_import\n\nfrom google.api_core import exceptions\n\ntry:\n    from grpc._channel import _Rendezvous\nexcept ImportError:  # pragma: NO COVER\n    _Rendezvous = None\n\nGrpcRendezvous = _Rendezvous\n\"\"\"Exception class raised by gRPC stable.\"\"\"\n\n# Aliases to moved classes.\nGoogleCloudError = exceptions.GoogleAPICallError\nRedirection = exceptions.Redirection\nMovedPermanently = exceptions.MovedPermanently\nNotModified = exceptions.NotModified\nTemporaryRedirect = exceptions.TemporaryRedirect\nResumeIncomplete = exceptions.ResumeIncomplete\nClientError = exceptions.ClientError\nBadRequest = exceptions.BadRequest\nUnauthorized = exceptions.Unauthorized\nForbidden = exceptions.Forbidden\nNotFound = exceptions.NotFound\nMethodNotAllowed = exceptions.MethodNotAllowed\nConflict = exceptions.Conflict\nLengthRequired = exceptions.LengthRequired\nPreconditionFailed = exceptions.PreconditionFailed\nRequestRangeNotSatisfiable = exceptions.RequestRangeNotSatisfiable\nTooManyRequests = exceptions.TooManyRequests\nServerError = exceptions.ServerError\nInternalServerError = exceptions.InternalServerError\nMethodNotImplemented = exceptions.MethodNotImplemented\nBadGateway = exceptions.BadGateway\nServiceUnavailable = exceptions.ServiceUnavailable\nGatewayTimeout = exceptions.GatewayTimeout\nfrom_http_status = exceptions.from_http_status\nfrom_http_response = exceptions.from_http_response\n", "google/cloud/operation/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Wrap long-running operations returned from Google Cloud APIs.\"\"\"\n\nfrom typing import Dict\n\nfrom google.longrunning import operations_pb2\nfrom google.protobuf import json_format\n\n\n_GOOGLE_APIS_PREFIX = \"type.googleapis.com\"\n\n_TYPE_URL_MAP: Dict[str, type] = {}\n\n\ndef _compute_type_url(klass, prefix=_GOOGLE_APIS_PREFIX):\n    \"\"\"Compute a type URL for a klass.\n\n    :type klass: type\n    :param klass: class to be used as a factory for the given type\n\n    :type prefix: str\n    :param prefix: URL prefix for the type\n\n    :rtype: str\n    :returns: the URL, prefixed as appropriate\n    \"\"\"\n    name = klass.DESCRIPTOR.full_name\n    return \"%s/%s\" % (prefix, name)\n\n\ndef register_type(klass, type_url=None):\n    \"\"\"Register a klass as the factory for a given type URL.\n\n    :type klass: :class:`type`\n    :param klass: class to be used as a factory for the given type\n\n    :type type_url: str\n    :param type_url: (Optional) URL naming the type. If not provided,\n                     infers the URL from the type descriptor.\n\n    :raises ValueError: if a registration already exists for the URL.\n    \"\"\"\n    if type_url is None:\n        type_url = _compute_type_url(klass)\n    if type_url in _TYPE_URL_MAP:\n        if _TYPE_URL_MAP[type_url] is not klass:\n            raise ValueError(\"Conflict: %s\" % (_TYPE_URL_MAP[type_url],))\n\n    _TYPE_URL_MAP[type_url] = klass\n\n\ndef _from_any(any_pb):\n    \"\"\"Convert an ``Any`` protobuf into the actual class.\n\n    Uses the type URL to do the conversion.\n\n    .. note::\n\n        This assumes that the type URL is already registered.\n\n    :type any_pb: :class:`google.protobuf.any_pb2.Any`\n    :param any_pb: An any object to be converted.\n\n    :rtype: object\n    :returns: The instance (of the correct type) stored in the any\n              instance.\n    \"\"\"\n    klass = _TYPE_URL_MAP[any_pb.type_url]\n    return klass.FromString(any_pb.value)\n\n\nclass Operation(object):\n    \"\"\"Representation of a Google API Long-Running Operation.\n\n    .. _protobuf: https://github.com/googleapis/googleapis/blob/\\\n                  050400df0fdb16f63b63e9dee53819044bffc857/\\\n                  google/longrunning/operations.proto#L80\n    .. _service: https://github.com/googleapis/googleapis/blob/\\\n                 050400df0fdb16f63b63e9dee53819044bffc857/\\\n                 google/longrunning/operations.proto#L38\n    .. _JSON: https://cloud.google.com/speech/reference/rest/\\\n              v1beta1/operations#Operation\n\n    This wraps an operation `protobuf`_ object and attempts to\n    interact with the long-running operations `service`_ (specific\n    to a given API). (Some services also offer a `JSON`_\n    API that maps the same underlying data type.)\n\n    :type name: str\n    :param name: The fully-qualified path naming the operation.\n\n    :type client: :class:`~google.cloud.client.Client`\n    :param client: The client used to poll for the status of the operation.\n                   If the operation was created via JSON/HTTP, the client\n                   must own a :class:`~google.cloud._http.Connection`\n                   to send polling requests. If created via protobuf, the\n                   client must have a gRPC stub in the ``_operations_stub``\n                   attribute.\n\n    :type caller_metadata: dict\n    :param caller_metadata: caller-assigned metadata about the operation\n    \"\"\"\n\n    target = None\n    \"\"\"Instance assocated with the operations:  callers may set.\"\"\"\n\n    response = None\n    \"\"\"Response returned from completed operation.\n\n    Only one of this and :attr:`error` can be populated.\n    \"\"\"\n\n    error = None\n    \"\"\"Error that resulted from a failed (complete) operation.\n\n    Only one of this and :attr:`response` can be populated.\n    \"\"\"\n\n    metadata = None\n    \"\"\"Metadata about the current operation (as a protobuf).\n\n    Code that uses operations must register the metadata types (via\n    :func:`register_type`) to ensure that the metadata fields can be\n    converted into the correct types.\n    \"\"\"\n\n    _from_grpc = True\n\n    def __init__(self, name, client, **caller_metadata):\n        self.name = name\n        self.client = client\n        self.caller_metadata = caller_metadata.copy()\n        self._complete = False\n\n    @classmethod\n    def from_pb(cls, operation_pb, client, **caller_metadata):\n        \"\"\"Factory:  construct an instance from a protobuf.\n\n        :type operation_pb:\n            :class:`~google.longrunning.operations_pb2.Operation`\n        :param operation_pb: Protobuf to be parsed.\n\n        :type client: object: must provide ``_operations_stub`` accessor.\n        :param client: The client used to poll for the status of the operation.\n\n        :type caller_metadata: dict\n        :param caller_metadata: caller-assigned metadata about the operation\n\n        :rtype: :class:`Operation`\n        :returns: new instance, with attributes based on the protobuf.\n        \"\"\"\n        result = cls(operation_pb.name, client, **caller_metadata)\n        result._update_state(operation_pb)\n        result._from_grpc = True\n        return result\n\n    @classmethod\n    def from_dict(cls, operation, client, **caller_metadata):\n        \"\"\"Factory: construct an instance from a dictionary.\n\n        :type operation: dict\n        :param operation: Operation as a JSON object.\n\n        :type client: :class:`~google.cloud.client.Client`\n        :param client: The client used to poll for the status of the operation.\n\n        :type caller_metadata: dict\n        :param caller_metadata: caller-assigned metadata about the operation\n\n        :rtype: :class:`Operation`\n        :returns: new instance, with attributes based on the protobuf.\n        \"\"\"\n        operation_pb = json_format.ParseDict(operation, operations_pb2.Operation())\n        result = cls(operation_pb.name, client, **caller_metadata)\n        result._update_state(operation_pb)\n        result._from_grpc = False\n        return result\n\n    @property\n    def complete(self):\n        \"\"\"Has the operation already completed?\n\n        :rtype: bool\n        :returns: True if already completed, else false.\n        \"\"\"\n        return self._complete\n\n    def _get_operation_rpc(self):\n        \"\"\"Polls the status of the current operation.\n\n        Uses gRPC request to check.\n\n        :rtype: :class:`~google.longrunning.operations_pb2.Operation`\n        :returns: The latest status of the current operation.\n        \"\"\"\n        request_pb = operations_pb2.GetOperationRequest(name=self.name)\n        return self.client._operations_stub.GetOperation(request_pb)\n\n    def _get_operation_http(self):\n        \"\"\"Checks the status of the current operation.\n\n        Uses HTTP request to check.\n\n        :rtype: :class:`~google.longrunning.operations_pb2.Operation`\n        :returns: The latest status of the current operation.\n        \"\"\"\n        path = \"operations/%s\" % (self.name,)\n        api_response = self.client._connection.api_request(method=\"GET\", path=path)\n        return json_format.ParseDict(api_response, operations_pb2.Operation())\n\n    def _get_operation(self):\n        \"\"\"Checks the status of the current operation.\n\n        :rtype: :class:`~google.longrunning.operations_pb2.Operation`\n        :returns: The latest status of the current operation.\n        \"\"\"\n        if self._from_grpc:\n            return self._get_operation_rpc()\n        else:\n            return self._get_operation_http()\n\n    def _update_state(self, operation_pb):\n        \"\"\"Update the state of the current object based on operation.\n\n        :type operation_pb:\n            :class:`~google.longrunning.operations_pb2.Operation`\n        :param operation_pb: Protobuf to be parsed.\n        \"\"\"\n        if operation_pb.done:\n            self._complete = True\n\n        if operation_pb.HasField(\"metadata\"):\n            self.metadata = _from_any(operation_pb.metadata)\n\n        result_type = operation_pb.WhichOneof(\"result\")\n        if result_type == \"error\":\n            self.error = operation_pb.error\n        elif result_type == \"response\":\n            self.response = _from_any(operation_pb.response)\n\n    def poll(self):\n        \"\"\"Check if the operation has finished.\n\n        :rtype: bool\n        :returns: A boolean indicating if the current operation has completed.\n        :raises ValueError: if the operation\n                 has already completed.\n        \"\"\"\n        if self.complete:\n            raise ValueError(\"The operation has completed.\")\n\n        operation_pb = self._get_operation()\n        self._update_state(operation_pb)\n\n        return self.complete\n", "google/cloud/obsolete/__init__.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helpers for deprecated code and modules.\"\"\"\n\nimport sys\nimport warnings\n\n\nif sys.version_info < (3, 8):\n    import importlib_metadata as metadata\nelse:\n    import importlib.metadata as metadata\n\n\ndef complain(distribution_name):\n    \"\"\"Issue a warning if `distribution_name` is installed.\n\n    In a future release, this method will be updated to raise ImportError\n    rather than just send a warning.\n\n    Args:\n        distribution_name (str): The name of the obsolete distribution.\n    \"\"\"\n    try:\n        metadata.distribution(distribution_name)\n        warnings.warn(\n            \"The {pkg} distribution is now obsolete. \"\n            \"Please `pip uninstall {pkg}`. \"\n            \"In the future, this warning will become an ImportError.\".format(\n                pkg=distribution_name\n            ),\n            DeprecationWarning,\n        )\n    except metadata.PackageNotFoundError:\n        pass\n", "google/cloud/environment_vars/__init__.py": "# Copyright 2015 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Comprehensive list of environment variables used in google-cloud.\n\nThese enable many types of implicit behavior in both production\nand tests.\n\"\"\"\n\nGCD_DATASET = \"DATASTORE_DATASET\"\n\"\"\"Environment variable defining default dataset ID under GCD.\"\"\"\n\nGCD_HOST = \"DATASTORE_EMULATOR_HOST\"\n\"\"\"Environment variable defining host for GCD dataset server.\"\"\"\n\nPUBSUB_EMULATOR = \"PUBSUB_EMULATOR_HOST\"\n\"\"\"Environment variable defining host for Pub/Sub emulator.\"\"\"\n\nBIGTABLE_EMULATOR = \"BIGTABLE_EMULATOR_HOST\"\n\"\"\"Environment variable defining host for Bigtable emulator.\"\"\"\n\nDISABLE_GRPC = \"GOOGLE_CLOUD_DISABLE_GRPC\"\n\"\"\"Environment variable acting as flag to disable gRPC.\n\nTo be used for APIs where both an HTTP and gRPC implementation\nexist.\n\"\"\"\n", "google/cloud/_http/__init__.py": "# Copyright 2014 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Shared implementation of connections to API servers.\"\"\"\n\nimport collections\nimport collections.abc\nimport json\nimport os\nimport platform\nfrom typing import Optional\nfrom urllib.parse import urlencode\nimport warnings\n\nfrom google.api_core.client_info import ClientInfo\nfrom google.cloud import exceptions\nfrom google.cloud import version\n\n\nAPI_BASE_URL = \"https://www.googleapis.com\"\n\"\"\"The base of the API call URL.\"\"\"\n\nDEFAULT_USER_AGENT = \"gcloud-python/{0}\".format(version.__version__)\n\"\"\"The user agent for google-cloud-python requests.\"\"\"\n\nCLIENT_INFO_HEADER = \"X-Goog-API-Client\"\nCLIENT_INFO_TEMPLATE = \"gl-python/\" + platform.python_version() + \" gccl/{}\"\n\n_USER_AGENT_ALL_CAPS_DEPRECATED = \"\"\"\\\nThe 'USER_AGENT' class-level attribute is deprecated.  Please use\n'user_agent' instead.\n\"\"\"\n\n_EXTRA_HEADERS_ALL_CAPS_DEPRECATED = \"\"\"\\\nThe '_EXTRA_HEADERS' class-level attribute is deprecated.  Please use\n'extra_headers' instead.\n\"\"\"\n\n_DEFAULT_TIMEOUT = 60  # in seconds\n\n\nclass Connection(object):\n    \"\"\"A generic connection to Google Cloud Platform.\n\n    :type client: :class:`~google.cloud.client.Client`\n    :param client: The client that owns the current connection.\n\n    :type client_info: :class:`~google.api_core.client_info.ClientInfo`\n    :param client_info: (Optional) instance used to generate user agent.\n    \"\"\"\n\n    _user_agent = DEFAULT_USER_AGENT\n\n    def __init__(self, client, client_info=None):\n        self._client = client\n\n        if client_info is None:\n            client_info = ClientInfo()\n\n        self._client_info = client_info\n        self._extra_headers = {}\n\n    @property\n    def USER_AGENT(self):\n        \"\"\"Deprecated:  get / set user agent sent by connection.\n\n        :rtype: str\n        :returns: user agent\n        \"\"\"\n        warnings.warn(_USER_AGENT_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2)\n        return self.user_agent\n\n    @USER_AGENT.setter\n    def USER_AGENT(self, value):\n        warnings.warn(_USER_AGENT_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2)\n        self.user_agent = value\n\n    @property\n    def user_agent(self):\n        \"\"\"Get / set user agent sent by connection.\n\n        :rtype: str\n        :returns: user agent\n        \"\"\"\n        return self._client_info.to_user_agent()\n\n    @user_agent.setter\n    def user_agent(self, value):\n        self._client_info.user_agent = value\n\n    @property\n    def _EXTRA_HEADERS(self):\n        \"\"\"Deprecated:  get / set extra headers sent by connection.\n\n        :rtype: dict\n        :returns: header keys / values\n        \"\"\"\n        warnings.warn(\n            _EXTRA_HEADERS_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2\n        )\n        return self.extra_headers\n\n    @_EXTRA_HEADERS.setter\n    def _EXTRA_HEADERS(self, value):\n        warnings.warn(\n            _EXTRA_HEADERS_ALL_CAPS_DEPRECATED, DeprecationWarning, stacklevel=2\n        )\n        self.extra_headers = value\n\n    @property\n    def extra_headers(self):\n        \"\"\"Get / set extra headers sent by connection.\n\n        :rtype: dict\n        :returns: header keys / values\n        \"\"\"\n        return self._extra_headers\n\n    @extra_headers.setter\n    def extra_headers(self, value):\n        self._extra_headers = value\n\n    @property\n    def credentials(self):\n        \"\"\"Getter for current credentials.\n\n        :rtype: :class:`google.auth.credentials.Credentials` or\n                :class:`NoneType`\n        :returns: The credentials object associated with this connection.\n        \"\"\"\n        return self._client._credentials\n\n    @property\n    def http(self):\n        \"\"\"A getter for the HTTP transport used in talking to the API.\n\n        Returns:\n            google.auth.transport.requests.AuthorizedSession:\n                A :class:`requests.Session` instance.\n        \"\"\"\n        return self._client._http\n\n\nclass JSONConnection(Connection):\n    \"\"\"A connection to a Google JSON-based API.\n\n    These APIs are discovery based. For reference:\n\n        https://developers.google.com/discovery/\n\n    This defines :meth:`api_request` for making a generic JSON\n    API request and API requests are created elsewhere.\n\n    * :attr:`API_BASE_URL`\n    * :attr:`API_VERSION`\n    * :attr:`API_URL_TEMPLATE`\n\n    must be updated by subclasses.\n    \"\"\"\n\n    API_BASE_URL: Optional[str] = None\n    \"\"\"The base of the API call URL.\"\"\"\n\n    API_BASE_MTLS_URL: Optional[str] = None\n    \"\"\"The base of the API call URL for mutual TLS.\"\"\"\n\n    ALLOW_AUTO_SWITCH_TO_MTLS_URL = False\n    \"\"\"Indicates if auto switch to mTLS url is allowed.\"\"\"\n\n    API_VERSION: Optional[str] = None\n    \"\"\"The version of the API, used in building the API call's URL.\"\"\"\n\n    API_URL_TEMPLATE: Optional[str] = None\n    \"\"\"A template for the URL of a particular API call.\"\"\"\n\n    def get_api_base_url_for_mtls(self, api_base_url=None):\n        \"\"\"Return the api base url for mutual TLS.\n\n        Typically, you shouldn't need to use this method.\n\n        The logic is as follows:\n\n        If `api_base_url` is provided, just return this value; otherwise, the\n        return value depends `GOOGLE_API_USE_MTLS_ENDPOINT` environment variable\n        value.\n\n        If the environment variable value is \"always\", return `API_BASE_MTLS_URL`.\n        If the environment variable value is \"never\", return `API_BASE_URL`.\n        Otherwise, if `ALLOW_AUTO_SWITCH_TO_MTLS_URL` is True and the underlying\n        http is mTLS, then return `API_BASE_MTLS_URL`; otherwise return `API_BASE_URL`.\n\n        :type api_base_url: str\n        :param api_base_url: User provided api base url. It takes precedence over\n                             `API_BASE_URL` and `API_BASE_MTLS_URL`.\n\n        :rtype: str\n        :returns: The api base url used for mTLS.\n        \"\"\"\n        if api_base_url:\n            return api_base_url\n\n        env = os.getenv(\"GOOGLE_API_USE_MTLS_ENDPOINT\", \"auto\")\n        if env == \"always\":\n            url_to_use = self.API_BASE_MTLS_URL\n        elif env == \"never\":\n            url_to_use = self.API_BASE_URL\n        else:\n            if self.ALLOW_AUTO_SWITCH_TO_MTLS_URL:\n                url_to_use = (\n                    self.API_BASE_MTLS_URL if self.http.is_mtls else self.API_BASE_URL\n                )\n            else:\n                url_to_use = self.API_BASE_URL\n        return url_to_use\n\n    def build_api_url(\n        self, path, query_params=None, api_base_url=None, api_version=None\n    ):\n        \"\"\"Construct an API url given a few components, some optional.\n\n        Typically, you shouldn't need to use this method.\n\n        :type path: str\n        :param path: The path to the resource (ie, ``'/b/bucket-name'``).\n\n        :type query_params: dict or list\n        :param query_params: A dictionary of keys and values (or list of\n                             key-value pairs) to insert into the query\n                             string of the URL.\n\n        :type api_base_url: str\n        :param api_base_url: The base URL for the API endpoint.\n                             Typically you won't have to provide this.\n\n        :type api_version: str\n        :param api_version: The version of the API to call.\n                            Typically you shouldn't provide this and instead\n                            use the default for the library.\n\n        :rtype: str\n        :returns: The URL assembled from the pieces provided.\n        \"\"\"\n        url = self.API_URL_TEMPLATE.format(\n            api_base_url=self.get_api_base_url_for_mtls(api_base_url),\n            api_version=(api_version or self.API_VERSION),\n            path=path,\n        )\n\n        query_params = query_params or {}\n\n        if isinstance(query_params, collections.abc.Mapping):\n            query_params = query_params.copy()\n        else:\n            query_params_dict = collections.defaultdict(list)\n            for key, value in query_params:\n                query_params_dict[key].append(value)\n            query_params = query_params_dict\n\n        query_params.setdefault(\"prettyPrint\", \"false\")\n\n        url += \"?\" + urlencode(query_params, doseq=True)\n\n        return url\n\n    def _make_request(\n        self,\n        method,\n        url,\n        data=None,\n        content_type=None,\n        headers=None,\n        target_object=None,\n        timeout=_DEFAULT_TIMEOUT,\n        extra_api_info=None,\n    ):\n        \"\"\"A low level method to send a request to the API.\n\n        Typically, you shouldn't need to use this method.\n\n        :type method: str\n        :param method: The HTTP method to use in the request.\n\n        :type url: str\n        :param url: The URL to send the request to.\n\n        :type data: str\n        :param data: The data to send as the body of the request.\n\n        :type content_type: str\n        :param content_type: The proper MIME type of the data provided.\n\n        :type headers: dict\n        :param headers: (Optional) A dictionary of HTTP headers to send with\n                        the request. If passed, will be modified directly\n                        here with added headers.\n\n        :type target_object: object\n        :param target_object:\n            (Optional) Argument to be used by library callers.  This can allow\n            custom behavior, for example, to defer an HTTP request and complete\n            initialization of the object at a later time.\n\n        :type timeout: float or tuple\n        :param timeout: (optional) The amount of time, in seconds, to wait\n            for the server response.\n\n            Can also be passed as a tuple (connect_timeout, read_timeout).\n            See :meth:`requests.Session.request` documentation for details.\n\n        :type extra_api_info: string\n        :param extra_api_info: (optional) Extra api info to be appended to\n            the X-Goog-API-Client header\n\n        :rtype: :class:`requests.Response`\n        :returns: The HTTP response.\n        \"\"\"\n        headers = headers or {}\n        headers.update(self.extra_headers)\n        headers[\"Accept-Encoding\"] = \"gzip\"\n\n        if content_type:\n            headers[\"Content-Type\"] = content_type\n\n        if extra_api_info:\n            headers[CLIENT_INFO_HEADER] = f\"{self.user_agent} {extra_api_info}\"\n        else:\n            headers[CLIENT_INFO_HEADER] = self.user_agent\n        headers[\"User-Agent\"] = self.user_agent\n\n        return self._do_request(\n            method, url, headers, data, target_object, timeout=timeout\n        )\n\n    def _do_request(\n        self, method, url, headers, data, target_object, timeout=_DEFAULT_TIMEOUT\n    ):  # pylint: disable=unused-argument\n        \"\"\"Low-level helper:  perform the actual API request over HTTP.\n\n        Allows batch context managers to override and defer a request.\n\n        :type method: str\n        :param method: The HTTP method to use in the request.\n\n        :type url: str\n        :param url: The URL to send the request to.\n\n        :type headers: dict\n        :param headers: A dictionary of HTTP headers to send with the request.\n\n        :type data: str\n        :param data: The data to send as the body of the request.\n\n        :type target_object: object\n        :param target_object:\n            (Optional) Unused ``target_object`` here but may be used by a\n            superclass.\n\n        :type timeout: float or tuple\n        :param timeout: (optional) The amount of time, in seconds, to wait\n            for the server response.\n\n            Can also be passed as a tuple (connect_timeout, read_timeout).\n            See :meth:`requests.Session.request` documentation for details.\n\n        :rtype: :class:`requests.Response`\n        :returns: The HTTP response.\n        \"\"\"\n        return self.http.request(\n            url=url, method=method, headers=headers, data=data, timeout=timeout\n        )\n\n    def api_request(\n        self,\n        method,\n        path,\n        query_params=None,\n        data=None,\n        content_type=None,\n        headers=None,\n        api_base_url=None,\n        api_version=None,\n        expect_json=True,\n        _target_object=None,\n        timeout=_DEFAULT_TIMEOUT,\n        extra_api_info=None,\n    ):\n        \"\"\"Make a request over the HTTP transport to the API.\n\n        You shouldn't need to use this method, but if you plan to\n        interact with the API using these primitives, this is the\n        correct one to use.\n\n        :type method: str\n        :param method: The HTTP method name (ie, ``GET``, ``POST``, etc).\n                       Required.\n\n        :type path: str\n        :param path: The path to the resource (ie, ``'/b/bucket-name'``).\n                     Required.\n\n        :type query_params: dict or list\n        :param query_params: A dictionary of keys and values (or list of\n                             key-value pairs) to insert into the query\n                             string of the URL.\n\n        :type data: str\n        :param data: The data to send as the body of the request. Default is\n                     the empty string.\n\n        :type content_type: str\n        :param content_type: The proper MIME type of the data provided. Default\n                             is None.\n\n        :type headers: dict\n        :param headers: extra HTTP headers to be sent with the request.\n\n        :type api_base_url: str\n        :param api_base_url: The base URL for the API endpoint.\n                             Typically you won't have to provide this.\n                             Default is the standard API base URL.\n\n        :type api_version: str\n        :param api_version: The version of the API to call.  Typically\n                            you shouldn't provide this and instead use\n                            the default for the library.  Default is the\n                            latest API version supported by\n                            google-cloud-python.\n\n        :type expect_json: bool\n        :param expect_json: If True, this method will try to parse the\n                            response as JSON and raise an exception if\n                            that cannot be done.  Default is True.\n\n        :type _target_object: :class:`object`\n        :param _target_object:\n            (Optional) Protected argument to be used by library callers. This\n            can allow custom behavior, for example, to defer an HTTP request\n            and complete initialization of the object at a later time.\n\n        :type timeout: float or tuple\n        :param timeout: (optional) The amount of time, in seconds, to wait\n            for the server response.\n\n            Can also be passed as a tuple (connect_timeout, read_timeout).\n            See :meth:`requests.Session.request` documentation for details.\n\n        :type extra_api_info: string\n        :param extra_api_info: (optional) Extra api info to be appended to\n            the X-Goog-API-Client header\n\n        :raises ~google.cloud.exceptions.GoogleCloudError: if the response code\n            is not 200 OK.\n        :raises ValueError: if the response content type is not JSON.\n        :rtype: dict or str\n        :returns: The API response payload, either as a raw string or\n                  a dictionary if the response is valid JSON.\n        \"\"\"\n        url = self.build_api_url(\n            path=path,\n            query_params=query_params,\n            api_base_url=api_base_url,\n            api_version=api_version,\n        )\n\n        # Making the executive decision that any dictionary\n        # data will be sent properly as JSON.\n        if data and isinstance(data, dict):\n            data = json.dumps(data)\n            content_type = \"application/json\"\n\n        response = self._make_request(\n            method=method,\n            url=url,\n            data=data,\n            content_type=content_type,\n            headers=headers,\n            target_object=_target_object,\n            timeout=timeout,\n            extra_api_info=extra_api_info,\n        )\n\n        if not 200 <= response.status_code < 300:\n            raise exceptions.from_http_response(response)\n\n        if expect_json and response.content:\n            return response.json()\n        else:\n            return response.content\n", "google/cloud/_helpers/__init__.py": "# Copyright 2014 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Shared helpers for Google Cloud packages.\n\nThis module is not part of the public API surface.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport calendar\nimport datetime\nimport http.client\nimport os\nimport re\nfrom threading import local as Local\nfrom typing import Union\n\nimport google.auth\nimport google.auth.transport.requests\nfrom google.protobuf import duration_pb2\nfrom google.protobuf import timestamp_pb2\n\ntry:\n    import grpc\n    import google.auth.transport.grpc\nexcept ImportError:  # pragma: NO COVER\n    grpc = None\n\n# `google.cloud._helpers._NOW` is deprecated\n_NOW = datetime.datetime.utcnow\nUTC = datetime.timezone.utc  # Singleton instance to be used throughout.\n_EPOCH = datetime.datetime(1970, 1, 1, tzinfo=datetime.timezone.utc)\n\n_RFC3339_MICROS = \"%Y-%m-%dT%H:%M:%S.%fZ\"\n_RFC3339_NO_FRACTION = \"%Y-%m-%dT%H:%M:%S\"\n_TIMEONLY_W_MICROS = \"%H:%M:%S.%f\"\n_TIMEONLY_NO_FRACTION = \"%H:%M:%S\"\n# datetime.strptime cannot handle nanosecond precision:  parse w/ regex\n_RFC3339_NANOS = re.compile(\n    r\"\"\"\n    (?P<no_fraction>\n        \\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}  # YYYY-MM-DDTHH:MM:SS\n    )\n    (                                        # Optional decimal part\n     \\.                                      # decimal point\n     (?P<nanos>\\d{1,9})                      # nanoseconds, maybe truncated\n    )?\n    Z                                        # Zulu\n\"\"\",\n    re.VERBOSE,\n)\n# NOTE: Catching this ImportError is a workaround for GAE not supporting the\n#       \"pwd\" module which is imported lazily when \"expanduser\" is called.\n_USER_ROOT: Union[str, None]\ntry:\n    _USER_ROOT = os.path.expanduser(\"~\")\nexcept ImportError:  # pragma: NO COVER\n    _USER_ROOT = None\n_GCLOUD_CONFIG_FILE = os.path.join(\"gcloud\", \"configurations\", \"config_default\")\n_GCLOUD_CONFIG_SECTION = \"core\"\n_GCLOUD_CONFIG_KEY = \"project\"\n\n\nclass _LocalStack(Local):\n    \"\"\"Manage a thread-local LIFO stack of resources.\n\n    Intended for use in :class:`google.cloud.datastore.batch.Batch.__enter__`,\n    :class:`google.cloud.storage.batch.Batch.__enter__`, etc.\n    \"\"\"\n\n    def __init__(self):\n        super(_LocalStack, self).__init__()\n        self._stack = []\n\n    def __iter__(self):\n        \"\"\"Iterate the stack in LIFO order.\"\"\"\n        return iter(reversed(self._stack))\n\n    def push(self, resource):\n        \"\"\"Push a resource onto our stack.\"\"\"\n        self._stack.append(resource)\n\n    def pop(self):\n        \"\"\"Pop a resource from our stack.\n\n        :rtype: object\n        :returns: the top-most resource, after removing it.\n        :raises IndexError: if the stack is empty.\n        \"\"\"\n        return self._stack.pop()\n\n    @property\n    def top(self):\n        \"\"\"Get the top-most resource\n\n        :rtype: object\n        :returns: the top-most item, or None if the stack is empty.\n        \"\"\"\n        if self._stack:\n            return self._stack[-1]\n\n\ndef _ensure_tuple_or_list(arg_name, tuple_or_list):\n    \"\"\"Ensures an input is a tuple or list.\n\n    This effectively reduces the iterable types allowed to a very short\n    allowlist: list and tuple.\n\n    :type arg_name: str\n    :param arg_name: Name of argument to use in error message.\n\n    :type tuple_or_list: sequence of str\n    :param tuple_or_list: Sequence to be verified.\n\n    :rtype: list of str\n    :returns: The ``tuple_or_list`` passed in cast to a ``list``.\n    :raises TypeError: if the ``tuple_or_list`` is not a tuple or list.\n    \"\"\"\n    if not isinstance(tuple_or_list, (tuple, list)):\n        raise TypeError(\n            \"Expected %s to be a tuple or list. \"\n            \"Received %r\" % (arg_name, tuple_or_list)\n        )\n    return list(tuple_or_list)\n\n\ndef _determine_default_project(project=None):\n    \"\"\"Determine default project ID explicitly or implicitly as fall-back.\n\n    See :func:`google.auth.default` for details on how the default project\n    is determined.\n\n    :type project: str\n    :param project: Optional. The project name to use as default.\n\n    :rtype: str or ``NoneType``\n    :returns: Default project if it can be determined.\n    \"\"\"\n    if project is None:\n        _, project = google.auth.default()\n    return project\n\n\ndef _millis(when):\n    \"\"\"Convert a zone-aware datetime to integer milliseconds.\n\n    :type when: :class:`datetime.datetime`\n    :param when: the datetime to convert\n\n    :rtype: int\n    :returns: milliseconds since epoch for ``when``\n    \"\"\"\n    micros = _microseconds_from_datetime(when)\n    return micros // 1000\n\n\ndef _datetime_from_microseconds(value):\n    \"\"\"Convert timestamp to datetime, assuming UTC.\n\n    :type value: float\n    :param value: The timestamp to convert\n\n    :rtype: :class:`datetime.datetime`\n    :returns: The datetime object created from the value.\n    \"\"\"\n    return _EPOCH + datetime.timedelta(microseconds=value)\n\n\ndef _microseconds_from_datetime(value):\n    \"\"\"Convert non-none datetime to microseconds.\n\n    :type value: :class:`datetime.datetime`\n    :param value: The timestamp to convert.\n\n    :rtype: int\n    :returns: The timestamp, in microseconds.\n    \"\"\"\n    if not value.tzinfo:\n        value = value.replace(tzinfo=UTC)\n    # Regardless of what timezone is on the value, convert it to UTC.\n    value = value.astimezone(UTC)\n    # Convert the datetime to a microsecond timestamp.\n    return int(calendar.timegm(value.timetuple()) * 1e6) + value.microsecond\n\n\ndef _millis_from_datetime(value):\n    \"\"\"Convert non-none datetime to timestamp, assuming UTC.\n\n    :type value: :class:`datetime.datetime`\n    :param value: (Optional) the timestamp\n\n    :rtype: int, or ``NoneType``\n    :returns: the timestamp, in milliseconds, or None\n    \"\"\"\n    if value is not None:\n        return _millis(value)\n\n\ndef _date_from_iso8601_date(value):\n    \"\"\"Convert a ISO8601 date string to native datetime date\n\n    :type value: str\n    :param value: The date string to convert\n\n    :rtype: :class:`datetime.date`\n    :returns: A datetime date object created from the string\n\n    \"\"\"\n    return datetime.datetime.strptime(value, \"%Y-%m-%d\").date()\n\n\ndef _time_from_iso8601_time_naive(value):\n    \"\"\"Convert a zoneless ISO8601 time string to naive datetime time\n\n    :type value: str\n    :param value: The time string to convert\n\n    :rtype: :class:`datetime.time`\n    :returns: A datetime time object created from the string\n    :raises ValueError: if the value does not match a known format.\n    \"\"\"\n    if len(value) == 8:  # HH:MM:SS\n        fmt = _TIMEONLY_NO_FRACTION\n    elif len(value) == 15:  # HH:MM:SS.micros\n        fmt = _TIMEONLY_W_MICROS\n    else:\n        raise ValueError(\"Unknown time format: {}\".format(value))\n    return datetime.datetime.strptime(value, fmt).time()\n\n\ndef _rfc3339_to_datetime(dt_str):\n    \"\"\"Convert a microsecond-precision timestamp to a native datetime.\n\n    :type dt_str: str\n    :param dt_str: The string to convert.\n\n    :rtype: :class:`datetime.datetime`\n    :returns: The datetime object created from the string.\n    \"\"\"\n    return datetime.datetime.strptime(dt_str, _RFC3339_MICROS).replace(tzinfo=UTC)\n\n\ndef _rfc3339_nanos_to_datetime(dt_str):\n    \"\"\"Convert a nanosecond-precision timestamp to a native datetime.\n\n    .. note::\n\n       Python datetimes do not support nanosecond precision;  this function\n       therefore truncates such values to microseconds.\n\n    :type dt_str: str\n    :param dt_str: The string to convert.\n\n    :rtype: :class:`datetime.datetime`\n    :returns: The datetime object created from the string.\n    :raises ValueError: If the timestamp does not match the RFC 3339\n                        regular expression.\n    \"\"\"\n    with_nanos = _RFC3339_NANOS.match(dt_str)\n    if with_nanos is None:\n        raise ValueError(\n            \"Timestamp: %r, does not match pattern: %r\"\n            % (dt_str, _RFC3339_NANOS.pattern)\n        )\n    bare_seconds = datetime.datetime.strptime(\n        with_nanos.group(\"no_fraction\"), _RFC3339_NO_FRACTION\n    )\n    fraction = with_nanos.group(\"nanos\")\n    if fraction is None:\n        micros = 0\n    else:\n        scale = 9 - len(fraction)\n        nanos = int(fraction) * (10**scale)\n        micros = nanos // 1000\n    return bare_seconds.replace(microsecond=micros, tzinfo=UTC)\n\n\ndef _datetime_to_rfc3339(value, ignore_zone=True):\n    \"\"\"Convert a timestamp to a string.\n\n    :type value: :class:`datetime.datetime`\n    :param value: The datetime object to be converted to a string.\n\n    :type ignore_zone: bool\n    :param ignore_zone: If True, then the timezone (if any) of the datetime\n                        object is ignored.\n\n    :rtype: str\n    :returns: The string representing the datetime stamp.\n    \"\"\"\n    if not ignore_zone and value.tzinfo is not None:\n        # Convert to UTC and remove the time zone info.\n        value = value.replace(tzinfo=None) - value.utcoffset()\n\n    return value.strftime(_RFC3339_MICROS)\n\n\ndef _to_bytes(value, encoding=\"ascii\"):\n    \"\"\"Converts a string value to bytes, if necessary.\n\n    :type value: str / bytes or unicode\n    :param value: The string/bytes value to be converted.\n\n    :type encoding: str\n    :param encoding: The encoding to use to convert unicode to bytes. Defaults\n                     to \"ascii\", which will not allow any characters from\n                     ordinals larger than 127. Other useful values are\n                     \"latin-1\", which which will only allows byte ordinals\n                     (up to 255) and \"utf-8\", which will encode any unicode\n                     that needs to be.\n\n    :rtype: str / bytes\n    :returns: The original value converted to bytes (if unicode) or as passed\n              in if it started out as bytes.\n    :raises TypeError: if the value could not be converted to bytes.\n    \"\"\"\n    result = value.encode(encoding) if isinstance(value, str) else value\n    if isinstance(result, bytes):\n        return result\n    else:\n        raise TypeError(\"%r could not be converted to bytes\" % (value,))\n\n\ndef _bytes_to_unicode(value):\n    \"\"\"Converts bytes to a unicode value, if necessary.\n\n    :type value: bytes\n    :param value: bytes value to attempt string conversion on.\n\n    :rtype: str\n    :returns: The original value converted to unicode (if bytes) or as passed\n              in if it started out as unicode.\n\n    :raises ValueError: if the value could not be converted to unicode.\n    \"\"\"\n    result = value.decode(\"utf-8\") if isinstance(value, bytes) else value\n    if isinstance(result, str):\n        return result\n    else:\n        raise ValueError(\"%r could not be converted to unicode\" % (value,))\n\n\ndef _from_any_pb(pb_type, any_pb):\n    \"\"\"Converts an Any protobuf to the specified message type\n\n    Args:\n        pb_type (type): the type of the message that any_pb stores an instance\n            of.\n        any_pb (google.protobuf.any_pb2.Any): the object to be converted.\n\n    Returns:\n        pb_type: An instance of the pb_type message.\n\n    Raises:\n        TypeError: if the message could not be converted.\n    \"\"\"\n    msg = pb_type()\n    if not any_pb.Unpack(msg):\n        raise TypeError(\n            \"Could not convert {} to {}\".format(\n                any_pb.__class__.__name__, pb_type.__name__\n            )\n        )\n\n    return msg\n\n\ndef _pb_timestamp_to_datetime(timestamp_pb):\n    \"\"\"Convert a Timestamp protobuf to a datetime object.\n\n    :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp`\n    :param timestamp_pb: A Google returned timestamp protobuf.\n\n    :rtype: :class:`datetime.datetime`\n    :returns: A UTC datetime object converted from a protobuf timestamp.\n    \"\"\"\n    return _EPOCH + datetime.timedelta(\n        seconds=timestamp_pb.seconds, microseconds=(timestamp_pb.nanos / 1000.0)\n    )\n\n\ndef _pb_timestamp_to_rfc3339(timestamp_pb):\n    \"\"\"Convert a Timestamp protobuf to an RFC 3339 string.\n\n    :type timestamp_pb: :class:`google.protobuf.timestamp_pb2.Timestamp`\n    :param timestamp_pb: A Google returned timestamp protobuf.\n\n    :rtype: str\n    :returns: An RFC 3339 formatted timestamp string.\n    \"\"\"\n    timestamp = _pb_timestamp_to_datetime(timestamp_pb)\n    return _datetime_to_rfc3339(timestamp)\n\n\ndef _datetime_to_pb_timestamp(when):\n    \"\"\"Convert a datetime object to a Timestamp protobuf.\n\n    :type when: :class:`datetime.datetime`\n    :param when: the datetime to convert\n\n    :rtype: :class:`google.protobuf.timestamp_pb2.Timestamp`\n    :returns: A timestamp protobuf corresponding to the object.\n    \"\"\"\n    ms_value = _microseconds_from_datetime(when)\n    seconds, micros = divmod(ms_value, 10**6)\n    nanos = micros * 10**3\n    return timestamp_pb2.Timestamp(seconds=seconds, nanos=nanos)\n\n\ndef _timedelta_to_duration_pb(timedelta_val):\n    \"\"\"Convert a Python timedelta object to a duration protobuf.\n\n    .. note::\n\n        The Python timedelta has a granularity of microseconds while\n        the protobuf duration type has a duration of nanoseconds.\n\n    :type timedelta_val: :class:`datetime.timedelta`\n    :param timedelta_val: A timedelta object.\n\n    :rtype: :class:`google.protobuf.duration_pb2.Duration`\n    :returns: A duration object equivalent to the time delta.\n    \"\"\"\n    duration_pb = duration_pb2.Duration()\n    duration_pb.FromTimedelta(timedelta_val)\n    return duration_pb\n\n\ndef _duration_pb_to_timedelta(duration_pb):\n    \"\"\"Convert a duration protobuf to a Python timedelta object.\n\n    .. note::\n\n        The Python timedelta has a granularity of microseconds while\n        the protobuf duration type has a duration of nanoseconds.\n\n    :type duration_pb: :class:`google.protobuf.duration_pb2.Duration`\n    :param duration_pb: A protobuf duration object.\n\n    :rtype: :class:`datetime.timedelta`\n    :returns: The converted timedelta object.\n    \"\"\"\n    return datetime.timedelta(\n        seconds=duration_pb.seconds, microseconds=(duration_pb.nanos / 1000.0)\n    )\n\n\ndef _name_from_project_path(path, project, template):\n    \"\"\"Validate a URI path and get the leaf object's name.\n\n    :type path: str\n    :param path: URI path containing the name.\n\n    :type project: str\n    :param project: (Optional) The project associated with the request. It is\n                    included for validation purposes.  If passed as None,\n                    disables validation.\n\n    :type template: str\n    :param template: Template regex describing the expected form of the path.\n                     The regex must have two named groups, 'project' and\n                     'name'.\n\n    :rtype: str\n    :returns: Name parsed from ``path``.\n    :raises ValueError: if the ``path`` is ill-formed or if the project from\n                        the ``path`` does not agree with the ``project``\n                        passed in.\n    \"\"\"\n    if isinstance(template, str):\n        template = re.compile(template)\n\n    match = template.match(path)\n\n    if not match:\n        raise ValueError(\n            'path \"%s\" did not match expected pattern \"%s\"' % (path, template.pattern)\n        )\n\n    if project is not None:\n        found_project = match.group(\"project\")\n        if found_project != project:\n            raise ValueError(\n                \"Project from client (%s) should agree with \"\n                \"project from resource(%s).\" % (project, found_project)\n            )\n\n    return match.group(\"name\")\n\n\ndef make_secure_channel(credentials, user_agent, host, extra_options=()):\n    \"\"\"Makes a secure channel for an RPC service.\n\n    Uses / depends on gRPC.\n\n    :type credentials: :class:`google.auth.credentials.Credentials`\n    :param credentials: The OAuth2 Credentials to use for creating\n                        access tokens.\n\n    :type user_agent: str\n    :param user_agent: The user agent to be used with API requests.\n\n    :type host: str\n    :param host: The host for the service.\n\n    :type extra_options: tuple\n    :param extra_options: (Optional) Extra gRPC options used when creating the\n                          channel.\n\n    :rtype: :class:`grpc._channel.Channel`\n    :returns: gRPC secure channel with credentials attached.\n    \"\"\"\n    target = \"%s:%d\" % (host, http.client.HTTPS_PORT)\n    http_request = google.auth.transport.requests.Request()\n\n    user_agent_option = (\"grpc.primary_user_agent\", user_agent)\n    options = (user_agent_option,) + extra_options\n    return google.auth.transport.grpc.secure_authorized_channel(\n        credentials, http_request, target, options=options\n    )\n\n\ndef make_secure_stub(credentials, user_agent, stub_class, host, extra_options=()):\n    \"\"\"Makes a secure stub for an RPC service.\n\n    Uses / depends on gRPC.\n\n    :type credentials: :class:`google.auth.credentials.Credentials`\n    :param credentials: The OAuth2 Credentials to use for creating\n                        access tokens.\n\n    :type user_agent: str\n    :param user_agent: The user agent to be used with API requests.\n\n    :type stub_class: type\n    :param stub_class: A gRPC stub type for a given service.\n\n    :type host: str\n    :param host: The host for the service.\n\n    :type extra_options: tuple\n    :param extra_options: (Optional) Extra gRPC options passed when creating\n                          the channel.\n\n    :rtype: object, instance of ``stub_class``\n    :returns: The stub object used to make gRPC requests to a given API.\n    \"\"\"\n    channel = make_secure_channel(\n        credentials, user_agent, host, extra_options=extra_options\n    )\n    return stub_class(channel)\n\n\ndef make_insecure_stub(stub_class, host, port=None):\n    \"\"\"Makes an insecure stub for an RPC service.\n\n    Uses / depends on gRPC.\n\n    :type stub_class: type\n    :param stub_class: A gRPC stub type for a given service.\n\n    :type host: str\n    :param host: The host for the service. May also include the port\n                 if ``port`` is unspecified.\n\n    :type port: int\n    :param port: (Optional) The port for the service.\n\n    :rtype: object, instance of ``stub_class``\n    :returns: The stub object used to make gRPC requests to a given API.\n    \"\"\"\n    if port is None:\n        target = host\n    else:\n        # NOTE: This assumes port != http.client.HTTPS_PORT:\n        target = \"%s:%d\" % (host, port)\n    channel = grpc.insecure_channel(target)\n    return stub_class(channel)\n"}