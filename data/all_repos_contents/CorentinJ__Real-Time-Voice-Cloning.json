{"vocoder_train.py": "import argparse\nfrom pathlib import Path\n\nfrom utils.argutils import print_args\nfrom vocoder.train import train\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Trains the vocoder from the synthesizer audios and the GTA synthesized mels, \"\n                    \"or ground truth mels.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n\n    parser.add_argument(\"run_id\", type=str, help= \\\n        \"Name for this model. By default, training outputs will be stored to saved_models/<run_id>/. If a model state \"\n        \"from the same run ID was previously saved, the training will restart from there. Pass -f to overwrite saved \"\n        \"states and restart from scratch.\")\n    parser.add_argument(\"datasets_root\", type=Path, help= \\\n        \"Path to the directory containing your SV2TTS directory. Specifying --syn_dir or --voc_dir \"\n        \"will take priority over this argument.\")\n    parser.add_argument(\"--syn_dir\", type=Path, default=argparse.SUPPRESS, help= \\\n        \"Path to the synthesizer directory that contains the ground truth mel spectrograms, \"\n        \"the wavs and the embeds. Defaults to <datasets_root>/SV2TTS/synthesizer/.\")\n    parser.add_argument(\"--voc_dir\", type=Path, default=argparse.SUPPRESS, help= \\\n        \"Path to the vocoder directory that contains the GTA synthesized mel spectrograms. \"\n        \"Defaults to <datasets_root>/SV2TTS/vocoder/. Unused if --ground_truth is passed.\")\n    parser.add_argument(\"-m\", \"--models_dir\", type=Path, default=\"saved_models\", help=\\\n        \"Path to the directory that will contain the saved model weights, as well as backups \"\n        \"of those weights and wavs generated during training.\")\n    parser.add_argument(\"-g\", \"--ground_truth\", action=\"store_true\", help= \\\n        \"Train on ground truth spectrograms (<datasets_root>/SV2TTS/synthesizer/mels).\")\n    parser.add_argument(\"-s\", \"--save_every\", type=int, default=1000, help= \\\n        \"Number of steps between updates of the model on the disk. Set to 0 to never save the \"\n        \"model.\")\n    parser.add_argument(\"-b\", \"--backup_every\", type=int, default=25000, help= \\\n        \"Number of steps between backups of the model. Set to 0 to never make backups of the \"\n        \"model.\")\n    parser.add_argument(\"-f\", \"--force_restart\", action=\"store_true\", help= \\\n        \"Do not load any saved model and restart from scratch.\")\n    args = parser.parse_args()\n\n    # Process the arguments\n    if not hasattr(args, \"syn_dir\"):\n        args.syn_dir = args.datasets_root / \"SV2TTS\" / \"synthesizer\"\n    if not hasattr(args, \"voc_dir\"):\n        args.voc_dir = args.datasets_root / \"SV2TTS\" / \"vocoder\"\n    del args.datasets_root\n    args.models_dir.mkdir(exist_ok=True)\n\n    # Run the training\n    print_args(args, parser)\n    train(**vars(args))\n", "synthesizer_preprocess_audio.py": "from synthesizer.preprocess import preprocess_dataset\nfrom synthesizer.hparams import hparams\nfrom utils.argutils import print_args\nfrom pathlib import Path\nimport argparse\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Preprocesses audio files from datasets, encodes them as mel spectrograms \"\n                    \"and writes them to  the disk. Audio files are also saved, to be used by the \"\n                    \"vocoder for training.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    parser.add_argument(\"datasets_root\", type=Path, help=\\\n        \"Path to the directory containing your LibriSpeech/TTS datasets.\")\n    parser.add_argument(\"-o\", \"--out_dir\", type=Path, default=argparse.SUPPRESS, help=\\\n        \"Path to the output directory that will contain the mel spectrograms, the audios and the \"\n        \"embeds. Defaults to <datasets_root>/SV2TTS/synthesizer/\")\n    parser.add_argument(\"-n\", \"--n_processes\", type=int, default=4, help=\\\n        \"Number of processes in parallel.\")\n    parser.add_argument(\"-s\", \"--skip_existing\", action=\"store_true\", help=\\\n        \"Whether to overwrite existing files with the same name. Useful if the preprocessing was \"\n        \"interrupted.\")\n    parser.add_argument(\"--hparams\", type=str, default=\"\", help=\\\n        \"Hyperparameter overrides as a comma-separated list of name-value pairs\")\n    parser.add_argument(\"--no_alignments\", action=\"store_true\", help=\\\n        \"Use this option when dataset does not include alignments\\\n        (these are used to split long audio files into sub-utterances.)\")\n    parser.add_argument(\"--datasets_name\", type=str, default=\"LibriSpeech\", help=\\\n        \"Name of the dataset directory to process.\")\n    parser.add_argument(\"--subfolders\", type=str, default=\"train-clean-100,train-clean-360\", help=\\\n        \"Comma-separated list of subfolders to process inside your dataset directory\")\n    args = parser.parse_args()\n\n    # Process the arguments\n    if not hasattr(args, \"out_dir\"):\n        args.out_dir = args.datasets_root.joinpath(\"SV2TTS\", \"synthesizer\")\n\n    # Create directories\n    assert args.datasets_root.exists()\n    args.out_dir.mkdir(exist_ok=True, parents=True)\n\n    # Preprocess the dataset\n    print_args(args, parser)\n    args.hparams = hparams.parse(args.hparams)\n    preprocess_dataset(**vars(args))\n", "synthesizer_preprocess_embeds.py": "from synthesizer.preprocess import create_embeddings\nfrom utils.argutils import print_args\nfrom pathlib import Path\nimport argparse\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Creates embeddings for the synthesizer from the LibriSpeech utterances.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    parser.add_argument(\"synthesizer_root\", type=Path, help=\\\n        \"Path to the synthesizer training data that contains the audios and the train.txt file. \"\n        \"If you let everything as default, it should be <datasets_root>/SV2TTS/synthesizer/.\")\n    parser.add_argument(\"-e\", \"--encoder_model_fpath\", type=Path,\n                        default=\"saved_models/default/encoder.pt\", help=\\\n        \"Path your trained encoder model.\")\n    parser.add_argument(\"-n\", \"--n_processes\", type=int, default=4, help= \\\n        \"Number of parallel processes. An encoder is created for each, so you may need to lower \"\n        \"this value on GPUs with low memory. Set it to 1 if CUDA is unhappy.\")\n    args = parser.parse_args()\n\n    # Preprocess the dataset\n    print_args(args, parser)\n    create_embeddings(**vars(args))\n", "encoder_train.py": "from utils.argutils import print_args\nfrom encoder.train import train\nfrom pathlib import Path\nimport argparse\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Trains the speaker encoder. You must have run encoder_preprocess.py first.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n\n    parser.add_argument(\"run_id\", type=str, help= \\\n        \"Name for this model. By default, training outputs will be stored to saved_models/<run_id>/. If a model state \"\n        \"from the same run ID was previously saved, the training will restart from there. Pass -f to overwrite saved \"\n        \"states and restart from scratch.\")\n    parser.add_argument(\"clean_data_root\", type=Path, help= \\\n        \"Path to the output directory of encoder_preprocess.py. If you left the default \"\n        \"output directory when preprocessing, it should be <datasets_root>/SV2TTS/encoder/.\")\n    parser.add_argument(\"-m\", \"--models_dir\", type=Path, default=\"saved_models\", help=\\\n        \"Path to the root directory that contains all models. A directory <run_name> will be created under this root.\"\n        \"It will contain the saved model weights, as well as backups of those weights and plots generated during \"\n        \"training.\")\n    parser.add_argument(\"-v\", \"--vis_every\", type=int, default=10, help= \\\n        \"Number of steps between updates of the loss and the plots.\")\n    parser.add_argument(\"-u\", \"--umap_every\", type=int, default=100, help= \\\n        \"Number of steps between updates of the umap projection. Set to 0 to never update the \"\n        \"projections.\")\n    parser.add_argument(\"-s\", \"--save_every\", type=int, default=500, help= \\\n        \"Number of steps between updates of the model on the disk. Set to 0 to never save the \"\n        \"model.\")\n    parser.add_argument(\"-b\", \"--backup_every\", type=int, default=7500, help= \\\n        \"Number of steps between backups of the model. Set to 0 to never make backups of the \"\n        \"model.\")\n    parser.add_argument(\"-f\", \"--force_restart\", action=\"store_true\", help= \\\n        \"Do not load any saved model.\")\n    parser.add_argument(\"--visdom_server\", type=str, default=\"http://localhost\")\n    parser.add_argument(\"--no_visdom\", action=\"store_true\", help= \\\n        \"Disable visdom.\")\n    args = parser.parse_args()\n\n    # Run the training\n    print_args(args, parser)\n    train(**vars(args))\n", "vocoder_preprocess.py": "import argparse\nimport os\nfrom pathlib import Path\n\nfrom synthesizer.hparams import hparams\nfrom synthesizer.synthesize import run_synthesis\nfrom utils.argutils import print_args\n\n\n\nif __name__ == \"__main__\":\n    class MyFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):\n        pass\n\n    parser = argparse.ArgumentParser(\n        description=\"Creates ground-truth aligned (GTA) spectrograms from the vocoder.\",\n        formatter_class=MyFormatter\n    )\n    parser.add_argument(\"datasets_root\", type=Path, help=\\\n        \"Path to the directory containing your SV2TTS directory. If you specify both --in_dir and \"\n        \"--out_dir, this argument won't be used.\")\n    parser.add_argument(\"-s\", \"--syn_model_fpath\", type=Path,\n                        default=\"saved_models/default/synthesizer.pt\",\n                        help=\"Path to a saved synthesizer\")\n    parser.add_argument(\"-i\", \"--in_dir\", type=Path, default=argparse.SUPPRESS, help= \\\n        \"Path to the synthesizer directory that contains the mel spectrograms, the wavs and the \"\n        \"embeds. Defaults to  <datasets_root>/SV2TTS/synthesizer/.\")\n    parser.add_argument(\"-o\", \"--out_dir\", type=Path, default=argparse.SUPPRESS, help= \\\n        \"Path to the output vocoder directory that will contain the ground truth aligned mel \"\n        \"spectrograms. Defaults to <datasets_root>/SV2TTS/vocoder/.\")\n    parser.add_argument(\"--hparams\", default=\"\", help=\\\n        \"Hyperparameter overrides as a comma-separated list of name=value pairs\")\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\\\n        \"If True, processing is done on CPU, even when a GPU is available.\")\n    args = parser.parse_args()\n    print_args(args, parser)\n    modified_hp = hparams.parse(args.hparams)\n\n    if not hasattr(args, \"in_dir\"):\n        args.in_dir = args.datasets_root / \"SV2TTS\" / \"synthesizer\"\n    if not hasattr(args, \"out_dir\"):\n        args.out_dir = args.datasets_root / \"SV2TTS\" / \"vocoder\"\n\n    if args.cpu:\n        # Hide GPUs from Pytorch to force CPU processing\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n\n    run_synthesis(args.in_dir, args.out_dir, args.syn_model_fpath, modified_hp)\n", "demo_toolbox.py": "import argparse\nimport os\nfrom pathlib import Path\n\nfrom toolbox import Toolbox\nfrom utils.argutils import print_args\nfrom utils.default_models import ensure_default_models\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=\"Runs the toolbox.\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n\n    parser.add_argument(\"-d\", \"--datasets_root\", type=Path, help= \\\n        \"Path to the directory containing your datasets. See toolbox/__init__.py for a list of \"\n        \"supported datasets.\", default=None)\n    parser.add_argument(\"-m\", \"--models_dir\", type=Path, default=\"saved_models\",\n                        help=\"Directory containing all saved models\")\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\\\n        \"If True, all inference will be done on CPU\")\n    parser.add_argument(\"--seed\", type=int, default=None, help=\\\n        \"Optional random number seed value to make toolbox deterministic.\")\n    args = parser.parse_args()\n    arg_dict = vars(args)\n    print_args(args, parser)\n\n    # Hide GPUs from Pytorch to force CPU processing\n    if arg_dict.pop(\"cpu\"):\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n\n    # Remind the user to download pretrained models if needed\n    ensure_default_models(args.models_dir)\n\n    # Launch the toolbox\n    Toolbox(**arg_dict)\n", "encoder_preprocess.py": "from encoder.preprocess import preprocess_librispeech, preprocess_voxceleb1, preprocess_voxceleb2\nfrom utils.argutils import print_args\nfrom pathlib import Path\nimport argparse\n\n\nif __name__ == \"__main__\":\n    class MyFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):\n        pass\n\n    parser = argparse.ArgumentParser(\n        description=\"Preprocesses audio files from datasets, encodes them as mel spectrograms and \"\n                    \"writes them to the disk. This will allow you to train the encoder. The \"\n                    \"datasets required are at least one of VoxCeleb1, VoxCeleb2 and LibriSpeech. \"\n                    \"Ideally, you should have all three. You should extract them as they are \"\n                    \"after having downloaded them and put them in a same directory, e.g.:\\n\"\n                    \"-[datasets_root]\\n\"\n                    \"  -LibriSpeech\\n\"\n                    \"    -train-other-500\\n\"\n                    \"  -VoxCeleb1\\n\"\n                    \"    -wav\\n\"\n                    \"    -vox1_meta.csv\\n\"\n                    \"  -VoxCeleb2\\n\"\n                    \"    -dev\",\n        formatter_class=MyFormatter\n    )\n    parser.add_argument(\"datasets_root\", type=Path, help=\\\n        \"Path to the directory containing your LibriSpeech/TTS and VoxCeleb datasets.\")\n    parser.add_argument(\"-o\", \"--out_dir\", type=Path, default=argparse.SUPPRESS, help=\\\n        \"Path to the output directory that will contain the mel spectrograms. If left out, \"\n        \"defaults to <datasets_root>/SV2TTS/encoder/\")\n    parser.add_argument(\"-d\", \"--datasets\", type=str,\n                        default=\"librispeech_other,voxceleb1,voxceleb2\", help=\\\n        \"Comma-separated list of the name of the datasets you want to preprocess. Only the train \"\n        \"set of these datasets will be used. Possible names: librispeech_other, voxceleb1, \"\n        \"voxceleb2.\")\n    parser.add_argument(\"-s\", \"--skip_existing\", action=\"store_true\", help=\\\n        \"Whether to skip existing output files with the same name. Useful if this script was \"\n        \"interrupted.\")\n    parser.add_argument(\"--no_trim\", action=\"store_true\", help=\\\n        \"Preprocess audio without trimming silences (not recommended).\")\n    args = parser.parse_args()\n\n    # Verify webrtcvad is available\n    if not args.no_trim:\n        try:\n            import webrtcvad\n        except:\n            raise ModuleNotFoundError(\"Package 'webrtcvad' not found. This package enables \"\n                \"noise removal and is recommended. Please install and try again. If installation fails, \"\n                \"use --no_trim to disable this error message.\")\n    del args.no_trim\n\n    # Process the arguments\n    args.datasets = args.datasets.split(\",\")\n    if not hasattr(args, \"out_dir\"):\n        args.out_dir = args.datasets_root.joinpath(\"SV2TTS\", \"encoder\")\n    assert args.datasets_root.exists()\n    args.out_dir.mkdir(exist_ok=True, parents=True)\n\n    # Preprocess the datasets\n    print_args(args, parser)\n    preprocess_func = {\n        \"librispeech_other\": preprocess_librispeech,\n        \"voxceleb1\": preprocess_voxceleb1,\n        \"voxceleb2\": preprocess_voxceleb2,\n    }\n    args = vars(args)\n    for dataset in args.pop(\"datasets\"):\n        print(\"Preprocessing %s\" % dataset)\n        preprocess_func[dataset](**args)\n", "demo_cli.py": "import argparse\nimport os\nfrom pathlib import Path\n\nimport librosa\nimport numpy as np\nimport soundfile as sf\nimport torch\n\nfrom encoder import inference as encoder\nfrom encoder.params_model import model_embedding_size as speaker_embedding_size\nfrom synthesizer.inference import Synthesizer\nfrom utils.argutils import print_args\nfrom utils.default_models import ensure_default_models\nfrom vocoder import inference as vocoder\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    parser.add_argument(\"-e\", \"--enc_model_fpath\", type=Path,\n                        default=\"saved_models/default/encoder.pt\",\n                        help=\"Path to a saved encoder\")\n    parser.add_argument(\"-s\", \"--syn_model_fpath\", type=Path,\n                        default=\"saved_models/default/synthesizer.pt\",\n                        help=\"Path to a saved synthesizer\")\n    parser.add_argument(\"-v\", \"--voc_model_fpath\", type=Path,\n                        default=\"saved_models/default/vocoder.pt\",\n                        help=\"Path to a saved vocoder\")\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\\\n        \"If True, processing is done on CPU, even when a GPU is available.\")\n    parser.add_argument(\"--no_sound\", action=\"store_true\", help=\\\n        \"If True, audio won't be played.\")\n    parser.add_argument(\"--seed\", type=int, default=None, help=\\\n        \"Optional random number seed value to make toolbox deterministic.\")\n    args = parser.parse_args()\n    arg_dict = vars(args)\n    print_args(args, parser)\n\n    # Hide GPUs from Pytorch to force CPU processing\n    if arg_dict.pop(\"cpu\"):\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"\n\n    print(\"Running a test of your configuration...\\n\")\n\n    if torch.cuda.is_available():\n        device_id = torch.cuda.current_device()\n        gpu_properties = torch.cuda.get_device_properties(device_id)\n        ## Print some environment information (for debugging purposes)\n        print(\"Found %d GPUs available. Using GPU %d (%s) of compute capability %d.%d with \"\n            \"%.1fGb total memory.\\n\" %\n            (torch.cuda.device_count(),\n            device_id,\n            gpu_properties.name,\n            gpu_properties.major,\n            gpu_properties.minor,\n            gpu_properties.total_memory / 1e9))\n    else:\n        print(\"Using CPU for inference.\\n\")\n\n    ## Load the models one by one.\n    print(\"Preparing the encoder, the synthesizer and the vocoder...\")\n    ensure_default_models(Path(\"saved_models\"))\n    encoder.load_model(args.enc_model_fpath)\n    synthesizer = Synthesizer(args.syn_model_fpath)\n    vocoder.load_model(args.voc_model_fpath)\n\n\n    ## Run a test\n    print(\"Testing your configuration with small inputs.\")\n    # Forward an audio waveform of zeroes that lasts 1 second. Notice how we can get the encoder's\n    # sampling rate, which may differ.\n    # If you're unfamiliar with digital audio, know that it is encoded as an array of floats\n    # (or sometimes integers, but mostly floats in this projects) ranging from -1 to 1.\n    # The sampling rate is the number of values (samples) recorded per second, it is set to\n    # 16000 for the encoder. Creating an array of length <sampling_rate> will always correspond\n    # to an audio of 1 second.\n    print(\"\\tTesting the encoder...\")\n    encoder.embed_utterance(np.zeros(encoder.sampling_rate))\n\n    # Create a dummy embedding. You would normally use the embedding that encoder.embed_utterance\n    # returns, but here we're going to make one ourselves just for the sake of showing that it's\n    # possible.\n    embed = np.random.rand(speaker_embedding_size)\n    # Embeddings are L2-normalized (this isn't important here, but if you want to make your own\n    # embeddings it will be).\n    embed /= np.linalg.norm(embed)\n    # The synthesizer can handle multiple inputs with batching. Let's create another embedding to\n    # illustrate that\n    embeds = [embed, np.zeros(speaker_embedding_size)]\n    texts = [\"test 1\", \"test 2\"]\n    print(\"\\tTesting the synthesizer... (loading the model will output a lot of text)\")\n    mels = synthesizer.synthesize_spectrograms(texts, embeds)\n\n    # The vocoder synthesizes one waveform at a time, but it's more efficient for long ones. We\n    # can concatenate the mel spectrograms to a single one.\n    mel = np.concatenate(mels, axis=1)\n    # The vocoder can take a callback function to display the generation. More on that later. For\n    # now we'll simply hide it like this:\n    no_action = lambda *args: None\n    print(\"\\tTesting the vocoder...\")\n    # For the sake of making this test short, we'll pass a short target length. The target length\n    # is the length of the wav segments that are processed in parallel. E.g. for audio sampled\n    # at 16000 Hertz, a target length of 8000 means that the target audio will be cut in chunks of\n    # 0.5 seconds which will all be generated together. The parameters here are absurdly short, and\n    # that has a detrimental effect on the quality of the audio. The default parameters are\n    # recommended in general.\n    vocoder.infer_waveform(mel, target=200, overlap=50, progress_callback=no_action)\n\n    print(\"All test passed! You can now synthesize speech.\\n\\n\")\n\n\n    ## Interactive speech generation\n    print(\"This is a GUI-less example of interface to SV2TTS. The purpose of this script is to \"\n          \"show how you can interface this project easily with your own. See the source code for \"\n          \"an explanation of what is happening.\\n\")\n\n    print(\"Interactive generation loop\")\n    num_generated = 0\n    while True:\n        try:\n            # Get the reference audio filepath\n            message = \"Reference voice: enter an audio filepath of a voice to be cloned (mp3, \" \\\n                      \"wav, m4a, flac, ...):\\n\"\n            in_fpath = Path(input(message).replace(\"\\\"\", \"\").replace(\"\\'\", \"\"))\n\n            ## Computing the embedding\n            # First, we load the wav using the function that the speaker encoder provides. This is\n            # important: there is preprocessing that must be applied.\n\n            # The following two methods are equivalent:\n            # - Directly load from the filepath:\n            preprocessed_wav = encoder.preprocess_wav(in_fpath)\n            # - If the wav is already loaded:\n            original_wav, sampling_rate = librosa.load(str(in_fpath))\n            preprocessed_wav = encoder.preprocess_wav(original_wav, sampling_rate)\n            print(\"Loaded file succesfully\")\n\n            # Then we derive the embedding. There are many functions and parameters that the\n            # speaker encoder interfaces. These are mostly for in-depth research. You will typically\n            # only use this function (with its default parameters):\n            embed = encoder.embed_utterance(preprocessed_wav)\n            print(\"Created the embedding\")\n\n\n            ## Generating the spectrogram\n            text = input(\"Write a sentence (+-20 words) to be synthesized:\\n\")\n\n            # If seed is specified, reset torch seed and force synthesizer reload\n            if args.seed is not None:\n                torch.manual_seed(args.seed)\n                synthesizer = Synthesizer(args.syn_model_fpath)\n\n            # The synthesizer works in batch, so you need to put your data in a list or numpy array\n            texts = [text]\n            embeds = [embed]\n            # If you know what the attention layer alignments are, you can retrieve them here by\n            # passing return_alignments=True\n            specs = synthesizer.synthesize_spectrograms(texts, embeds)\n            spec = specs[0]\n            print(\"Created the mel spectrogram\")\n\n\n            ## Generating the waveform\n            print(\"Synthesizing the waveform:\")\n\n            # If seed is specified, reset torch seed and reload vocoder\n            if args.seed is not None:\n                torch.manual_seed(args.seed)\n                vocoder.load_model(args.voc_model_fpath)\n\n            # Synthesizing the waveform is fairly straightforward. Remember that the longer the\n            # spectrogram, the more time-efficient the vocoder.\n            generated_wav = vocoder.infer_waveform(spec)\n\n\n            ## Post-generation\n            # There's a bug with sounddevice that makes the audio cut one second earlier, so we\n            # pad it.\n            generated_wav = np.pad(generated_wav, (0, synthesizer.sample_rate), mode=\"constant\")\n\n            # Trim excess silences to compensate for gaps in spectrograms (issue #53)\n            generated_wav = encoder.preprocess_wav(generated_wav)\n\n            # Play the audio (non-blocking)\n            if not args.no_sound:\n                import sounddevice as sd\n                try:\n                    sd.stop()\n                    sd.play(generated_wav, synthesizer.sample_rate)\n                except sd.PortAudioError as e:\n                    print(\"\\nCaught exception: %s\" % repr(e))\n                    print(\"Continuing without audio playback. Suppress this message with the \\\"--no_sound\\\" flag.\\n\")\n                except:\n                    raise\n\n            # Save it on the disk\n            filename = \"demo_output_%02d.wav\" % num_generated\n            print(generated_wav.dtype)\n            sf.write(filename, generated_wav.astype(np.float32), synthesizer.sample_rate)\n            num_generated += 1\n            print(\"\\nSaved output as %s\\n\\n\" % filename)\n\n\n        except Exception as e:\n            print(\"Caught exception: %s\" % repr(e))\n            print(\"Restarting\\n\")\n", "synthesizer_train.py": "from pathlib import Path\n\nfrom synthesizer.hparams import hparams\nfrom synthesizer.train import train\nfrom utils.argutils import print_args\nimport argparse\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"run_id\", type=str, help= \\\n        \"Name for this model. By default, training outputs will be stored to saved_models/<run_id>/. If a model state \"\n        \"from the same run ID was previously saved, the training will restart from there. Pass -f to overwrite saved \"\n        \"states and restart from scratch.\")\n    parser.add_argument(\"syn_dir\", type=Path, help= \\\n        \"Path to the synthesizer directory that contains the ground truth mel spectrograms, \"\n        \"the wavs and the embeds.\")\n    parser.add_argument(\"-m\", \"--models_dir\", type=Path, default=\"saved_models\", help=\\\n        \"Path to the output directory that will contain the saved model weights and the logs.\")\n    parser.add_argument(\"-s\", \"--save_every\", type=int, default=1000, help= \\\n        \"Number of steps between updates of the model on the disk. Set to 0 to never save the \"\n        \"model.\")\n    parser.add_argument(\"-b\", \"--backup_every\", type=int, default=25000, help= \\\n        \"Number of steps between backups of the model. Set to 0 to never make backups of the \"\n        \"model.\")\n    parser.add_argument(\"-f\", \"--force_restart\", action=\"store_true\", help= \\\n        \"Do not load any saved model and restart from scratch.\")\n    parser.add_argument(\"--hparams\", default=\"\", help=\\\n        \"Hyperparameter overrides as a comma-separated list of name=value pairs\")\n    args = parser.parse_args()\n    print_args(args, parser)\n\n    args.hparams = hparams.parse(args.hparams)\n\n    # Run the training\n    train(**vars(args))\n", "utils/logmmse.py": "# The MIT License (MIT)\n# \n# Copyright (c) 2015 braindead\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n#\n# This code was extracted from the logmmse package (https://pypi.org/project/logmmse/) and I\n# simply modified the interface to meet my needs.\n\n\nimport numpy as np\nimport math\nfrom scipy.special import expn\nfrom collections import namedtuple\n\nNoiseProfile = namedtuple(\"NoiseProfile\", \"sampling_rate window_size len1 len2 win n_fft noise_mu2\")\n\n\ndef profile_noise(noise, sampling_rate, window_size=0):\n    \"\"\"\n    Creates a profile of the noise in a given waveform.\n    \n    :param noise: a waveform containing noise ONLY, as a numpy array of floats or ints. \n    :param sampling_rate: the sampling rate of the audio\n    :param window_size: the size of the window the logmmse algorithm operates on. A default value \n    will be picked if left as 0.\n    :return: a NoiseProfile object\n    \"\"\"\n    noise, dtype = to_float(noise)\n    noise += np.finfo(np.float64).eps\n\n    if window_size == 0:\n        window_size = int(math.floor(0.02 * sampling_rate))\n\n    if window_size % 2 == 1:\n        window_size = window_size + 1\n    \n    perc = 50\n    len1 = int(math.floor(window_size * perc / 100))\n    len2 = int(window_size - len1)\n\n    win = np.hanning(window_size)\n    win = win * len2 / np.sum(win)\n    n_fft = 2 * window_size\n\n    noise_mean = np.zeros(n_fft)\n    n_frames = len(noise) // window_size\n    for j in range(0, window_size * n_frames, window_size):\n        noise_mean += np.absolute(np.fft.fft(win * noise[j:j + window_size], n_fft, axis=0))\n    noise_mu2 = (noise_mean / n_frames) ** 2\n    \n    return NoiseProfile(sampling_rate, window_size, len1, len2, win, n_fft, noise_mu2)\n\n\ndef denoise(wav, noise_profile: NoiseProfile, eta=0.15):\n    \"\"\"\n    Cleans the noise from a speech waveform given a noise profile. The waveform must have the \n    same sampling rate as the one used to create the noise profile. \n    \n    :param wav: a speech waveform as a numpy array of floats or ints.\n    :param noise_profile: a NoiseProfile object that was created from a similar (or a segment of \n    the same) waveform.\n    :param eta: voice threshold for noise update. While the voice activation detection value is \n    below this threshold, the noise profile will be continuously updated throughout the audio. \n    Set to 0 to disable updating the noise profile.\n    :return: the clean wav as a numpy array of floats or ints of the same length.\n    \"\"\"\n    wav, dtype = to_float(wav)\n    wav += np.finfo(np.float64).eps\n    p = noise_profile\n    \n    nframes = int(math.floor(len(wav) / p.len2) - math.floor(p.window_size / p.len2))\n    x_final = np.zeros(nframes * p.len2)\n\n    aa = 0.98\n    mu = 0.98\n    ksi_min = 10 ** (-25 / 10)\n    \n    x_old = np.zeros(p.len1)\n    xk_prev = np.zeros(p.len1)\n    noise_mu2 = p.noise_mu2\n    for k in range(0, nframes * p.len2, p.len2):\n        insign = p.win * wav[k:k + p.window_size]\n\n        spec = np.fft.fft(insign, p.n_fft, axis=0)\n        sig = np.absolute(spec)\n        sig2 = sig ** 2\n\n        gammak = np.minimum(sig2 / noise_mu2, 40)\n\n        if xk_prev.all() == 0:\n            ksi = aa + (1 - aa) * np.maximum(gammak - 1, 0)\n        else:\n            ksi = aa * xk_prev / noise_mu2 + (1 - aa) * np.maximum(gammak - 1, 0)\n            ksi = np.maximum(ksi_min, ksi)\n\n        log_sigma_k = gammak * ksi/(1 + ksi) - np.log(1 + ksi)\n        vad_decision = np.sum(log_sigma_k) / p.window_size\n        if vad_decision < eta:\n            noise_mu2 = mu * noise_mu2 + (1 - mu) * sig2\n\n        a = ksi / (1 + ksi)\n        vk = a * gammak\n        ei_vk = 0.5 * expn(1, np.maximum(vk, 1e-8))\n        hw = a * np.exp(ei_vk)\n        sig = sig * hw\n        xk_prev = sig ** 2\n        xi_w = np.fft.ifft(hw * spec, p.n_fft, axis=0)\n        xi_w = np.real(xi_w)\n\n        x_final[k:k + p.len2] = x_old + xi_w[0:p.len1]\n        x_old = xi_w[p.len1:p.window_size]\n\n    output = from_float(x_final, dtype)\n    output = np.pad(output, (0, len(wav) - len(output)), mode=\"constant\")\n    return output\n\n\n## Alternative VAD algorithm to webrctvad. It has the advantage of not requiring to install that \n## darn package and it also works for any sampling rate. Maybe I'll eventually use it instead of \n## webrctvad\n# def vad(wav, sampling_rate, eta=0.15, window_size=0):\n#     \"\"\"\n#     TODO: fix doc\n#     Creates a profile of the noise in a given waveform.\n# \n#     :param wav: a waveform containing noise ONLY, as a numpy array of floats or ints. \n#     :param sampling_rate: the sampling rate of the audio\n#     :param window_size: the size of the window the logmmse algorithm operates on. A default value \n#     will be picked if left as 0.\n#     :param eta: voice threshold for noise update. While the voice activation detection value is \n#     below this threshold, the noise profile will be continuously updated throughout the audio. \n#     Set to 0 to disable updating the noise profile.\n#     \"\"\"\n#     wav, dtype = to_float(wav)\n#     wav += np.finfo(np.float64).eps\n#     \n#     if window_size == 0:\n#         window_size = int(math.floor(0.02 * sampling_rate))\n#     \n#     if window_size % 2 == 1:\n#         window_size = window_size + 1\n#     \n#     perc = 50\n#     len1 = int(math.floor(window_size * perc / 100))\n#     len2 = int(window_size - len1)\n#     \n#     win = np.hanning(window_size)\n#     win = win * len2 / np.sum(win)\n#     n_fft = 2 * window_size\n#     \n#     wav_mean = np.zeros(n_fft)\n#     n_frames = len(wav) // window_size\n#     for j in range(0, window_size * n_frames, window_size):\n#         wav_mean += np.absolute(np.fft.fft(win * wav[j:j + window_size], n_fft, axis=0))\n#     noise_mu2 = (wav_mean / n_frames) ** 2\n#     \n#     wav, dtype = to_float(wav)\n#     wav += np.finfo(np.float64).eps\n#     \n#     nframes = int(math.floor(len(wav) / len2) - math.floor(window_size / len2))\n#     vad = np.zeros(nframes * len2, dtype=np.bool)\n# \n#     aa = 0.98\n#     mu = 0.98\n#     ksi_min = 10 ** (-25 / 10)\n#     \n#     xk_prev = np.zeros(len1)\n#     noise_mu2 = noise_mu2\n#     for k in range(0, nframes * len2, len2):\n#         insign = win * wav[k:k + window_size]\n#         \n#         spec = np.fft.fft(insign, n_fft, axis=0)\n#         sig = np.absolute(spec)\n#         sig2 = sig ** 2\n#         \n#         gammak = np.minimum(sig2 / noise_mu2, 40)\n#         \n#         if xk_prev.all() == 0:\n#             ksi = aa + (1 - aa) * np.maximum(gammak - 1, 0)\n#         else:\n#             ksi = aa * xk_prev / noise_mu2 + (1 - aa) * np.maximum(gammak - 1, 0)\n#             ksi = np.maximum(ksi_min, ksi)\n#         \n#         log_sigma_k = gammak * ksi / (1 + ksi) - np.log(1 + ksi)\n#         vad_decision = np.sum(log_sigma_k) / window_size\n#         if vad_decision < eta:\n#             noise_mu2 = mu * noise_mu2 + (1 - mu) * sig2\n#         print(vad_decision)\n#         \n#         a = ksi / (1 + ksi)\n#         vk = a * gammak\n#         ei_vk = 0.5 * expn(1, np.maximum(vk, 1e-8))\n#         hw = a * np.exp(ei_vk)\n#         sig = sig * hw\n#         xk_prev = sig ** 2\n#         \n#         vad[k:k + len2] = vad_decision >= eta\n#         \n#     vad = np.pad(vad, (0, len(wav) - len(vad)), mode=\"constant\")\n#     return vad\n\n\ndef to_float(_input):\n    if _input.dtype == np.float64:\n        return _input, _input.dtype\n    elif _input.dtype == np.float32:\n        return _input.astype(np.float64), _input.dtype\n    elif _input.dtype == np.uint8:\n        return (_input - 128) / 128., _input.dtype\n    elif _input.dtype == np.int16:\n        return _input / 32768., _input.dtype\n    elif _input.dtype == np.int32:\n        return _input / 2147483648., _input.dtype\n    raise ValueError('Unsupported wave file format')\n\n\ndef from_float(_input, dtype):\n    if dtype == np.float64:\n        return _input, np.float64\n    elif dtype == np.float32:\n        return _input.astype(np.float32)\n    elif dtype == np.uint8:\n        return ((_input * 128) + 128).astype(np.uint8)\n    elif dtype == np.int16:\n        return (_input * 32768).astype(np.int16)\n    elif dtype == np.int32:\n        print(_input)\n        return (_input * 2147483648).astype(np.int32)\n    raise ValueError('Unsupported wave file format')\n", "utils/argutils.py": "from pathlib import Path\nimport numpy as np\nimport argparse\n\n_type_priorities = [    # In decreasing order\n    Path,\n    str,\n    int,\n    float,\n    bool,\n]\n\ndef _priority(o):\n    p = next((i for i, t in enumerate(_type_priorities) if type(o) is t), None) \n    if p is not None:\n        return p\n    p = next((i for i, t in enumerate(_type_priorities) if isinstance(o, t)), None) \n    if p is not None:\n        return p\n    return len(_type_priorities)\n\ndef print_args(args: argparse.Namespace, parser=None):\n    args = vars(args)\n    if parser is None:\n        priorities = list(map(_priority, args.values()))\n    else:\n        all_params = [a.dest for g in parser._action_groups for a in g._group_actions ]\n        priority = lambda p: all_params.index(p) if p in all_params else len(all_params)\n        priorities = list(map(priority, args.keys()))\n    \n    pad = max(map(len, args.keys())) + 3\n    indices = np.lexsort((list(args.keys()), priorities))\n    items = list(args.items())\n    \n    print(\"Arguments:\")\n    for i in indices:\n        param, value = items[i]\n        print(\"    {0}:{1}{2}\".format(param, ' ' * (pad - len(param)), value))\n    print(\"\")\n    ", "utils/profiler.py": "from time import perf_counter as timer\nfrom collections import OrderedDict\nimport numpy as np\n\n\nclass Profiler:\n    def __init__(self, summarize_every=5, disabled=False):\n        self.last_tick = timer()\n        self.logs = OrderedDict()\n        self.summarize_every = summarize_every\n        self.disabled = disabled\n    \n    def tick(self, name):\n        if self.disabled:\n            return\n        \n        # Log the time needed to execute that function\n        if not name in self.logs:\n            self.logs[name] = []\n        if len(self.logs[name]) >= self.summarize_every:\n            self.summarize()\n            self.purge_logs()\n        self.logs[name].append(timer() - self.last_tick)\n        \n        self.reset_timer()\n        \n    def purge_logs(self):\n        for name in self.logs:\n            self.logs[name].clear()\n    \n    def reset_timer(self):\n        self.last_tick = timer()\n    \n    def summarize(self):\n        n = max(map(len, self.logs.values()))\n        assert n == self.summarize_every\n        print(\"\\nAverage execution time over %d steps:\" % n)\n\n        name_msgs = [\"%s (%d/%d):\" % (name, len(deltas), n) for name, deltas in self.logs.items()]\n        pad = max(map(len, name_msgs))\n        for name_msg, deltas in zip(name_msgs, self.logs.values()):\n            print(\"  %s  mean: %4.0fms   std: %4.0fms\" % \n                  (name_msg.ljust(pad), np.mean(deltas) * 1000, np.std(deltas) * 1000))\n        print(\"\", flush=True)    \n        ", "utils/default_models.py": "import urllib.request\nfrom pathlib import Path\nfrom threading import Thread\nfrom urllib.error import HTTPError\n\nfrom tqdm import tqdm\n\n\ndefault_models = {\n    \"encoder\": (\"https://drive.google.com/uc?export=download&id=1q8mEGwCkFy23KZsinbuvdKAQLqNKbYf1\", 17090379),\n    \"synthesizer\": (\"https://drive.google.com/u/0/uc?id=1EqFMIbvxffxtjiVrtykroF6_mUh-5Z3s&export=download&confirm=t\", 370554559),\n    \"vocoder\": (\"https://drive.google.com/uc?export=download&id=1cf2NO6FtI0jDuy8AV3Xgn6leO6dHjIgu\", 53845290),\n}\n\n\nclass DownloadProgressBar(tqdm):\n    def update_to(self, b=1, bsize=1, tsize=None):\n        if tsize is not None:\n            self.total = tsize\n        self.update(b * bsize - self.n)\n\n\ndef download(url: str, target: Path, bar_pos=0):\n    # Ensure the directory exists\n    target.parent.mkdir(exist_ok=True, parents=True)\n\n    desc = f\"Downloading {target.name}\"\n    with DownloadProgressBar(unit=\"B\", unit_scale=True, miniters=1, desc=desc, position=bar_pos, leave=False) as t:\n        try:\n            urllib.request.urlretrieve(url, filename=target, reporthook=t.update_to)\n        except HTTPError:\n            return\n\n\ndef ensure_default_models(models_dir: Path):\n    # Define download tasks\n    jobs = []\n    for model_name, (url, size) in default_models.items():\n        target_path = models_dir / \"default\" / f\"{model_name}.pt\"\n        if target_path.exists():\n            if target_path.stat().st_size != size:\n                print(f\"File {target_path} is not of expected size, redownloading...\")\n            else:\n                continue\n\n        thread = Thread(target=download, args=(url, target_path, len(jobs)))\n        thread.start()\n        jobs.append((thread, target_path, size))\n\n    # Run and join threads\n    for thread, target_path, size in jobs:\n        thread.join()\n\n        assert target_path.exists() and target_path.stat().st_size == size, \\\n            f\"Download for {target_path.name} failed. You may download models manually instead.\\n\" \\\n            f\"https://drive.google.com/drive/folders/1fU6umc5uQAVR2udZdHX-lDgXYzTyqG_j\"\n", "utils/__init__.py": "", "synthesizer/preprocess.py": "from multiprocessing.pool import Pool\nfrom synthesizer import audio\nfrom functools import partial\nfrom itertools import chain\nfrom encoder import inference as encoder\nfrom pathlib import Path\nfrom utils import logmmse\nfrom tqdm import tqdm\nimport numpy as np\nimport librosa\n\n\ndef preprocess_dataset(datasets_root: Path, out_dir: Path, n_processes: int, skip_existing: bool, hparams,\n                       no_alignments: bool, datasets_name: str, subfolders: str):\n    # Gather the input directories\n    dataset_root = datasets_root.joinpath(datasets_name)\n    input_dirs = [dataset_root.joinpath(subfolder.strip()) for subfolder in subfolders.split(\",\")]\n    print(\"\\n    \".join(map(str, [\"Using data from:\"] + input_dirs)))\n    assert all(input_dir.exists() for input_dir in input_dirs)\n\n    # Create the output directories for each output file type\n    out_dir.joinpath(\"mels\").mkdir(exist_ok=True)\n    out_dir.joinpath(\"audio\").mkdir(exist_ok=True)\n\n    # Create a metadata file\n    metadata_fpath = out_dir.joinpath(\"train.txt\")\n    metadata_file = metadata_fpath.open(\"a\" if skip_existing else \"w\", encoding=\"utf-8\")\n\n    # Preprocess the dataset\n    speaker_dirs = list(chain.from_iterable(input_dir.glob(\"*\") for input_dir in input_dirs))\n    func = partial(preprocess_speaker, out_dir=out_dir, skip_existing=skip_existing,\n                   hparams=hparams, no_alignments=no_alignments)\n    job = Pool(n_processes).imap(func, speaker_dirs)\n    for speaker_metadata in tqdm(job, datasets_name, len(speaker_dirs), unit=\"speakers\"):\n        for metadatum in speaker_metadata:\n            metadata_file.write(\"|\".join(str(x) for x in metadatum) + \"\\n\")\n    metadata_file.close()\n\n    # Verify the contents of the metadata file\n    with metadata_fpath.open(\"r\", encoding=\"utf-8\") as metadata_file:\n        metadata = [line.split(\"|\") for line in metadata_file]\n    mel_frames = sum([int(m[4]) for m in metadata])\n    timesteps = sum([int(m[3]) for m in metadata])\n    sample_rate = hparams.sample_rate\n    hours = (timesteps / sample_rate) / 3600\n    print(\"The dataset consists of %d utterances, %d mel frames, %d audio timesteps (%.2f hours).\" %\n          (len(metadata), mel_frames, timesteps, hours))\n    print(\"Max input length (text chars): %d\" % max(len(m[5]) for m in metadata))\n    print(\"Max mel frames length: %d\" % max(int(m[4]) for m in metadata))\n    print(\"Max audio timesteps length: %d\" % max(int(m[3]) for m in metadata))\n\n\ndef preprocess_speaker(speaker_dir, out_dir: Path, skip_existing: bool, hparams, no_alignments: bool):\n    metadata = []\n    for book_dir in speaker_dir.glob(\"*\"):\n        if no_alignments:\n            # Gather the utterance audios and texts\n            # LibriTTS uses .wav but we will include extensions for compatibility with other datasets\n            extensions = [\"*.wav\", \"*.flac\", \"*.mp3\"]\n            for extension in extensions:\n                wav_fpaths = book_dir.glob(extension)\n\n                for wav_fpath in wav_fpaths:\n                    # Load the audio waveform\n                    wav, _ = librosa.load(str(wav_fpath), hparams.sample_rate)\n                    if hparams.rescale:\n                        wav = wav / np.abs(wav).max() * hparams.rescaling_max\n\n                    # Get the corresponding text\n                    # Check for .txt (for compatibility with other datasets)\n                    text_fpath = wav_fpath.with_suffix(\".txt\")\n                    if not text_fpath.exists():\n                        # Check for .normalized.txt (LibriTTS)\n                        text_fpath = wav_fpath.with_suffix(\".normalized.txt\")\n                        assert text_fpath.exists()\n                    with text_fpath.open(\"r\") as text_file:\n                        text = \"\".join([line for line in text_file])\n                        text = text.replace(\"\\\"\", \"\")\n                        text = text.strip()\n\n                    # Process the utterance\n                    metadata.append(process_utterance(wav, text, out_dir, str(wav_fpath.with_suffix(\"\").name),\n                                                      skip_existing, hparams))\n        else:\n            # Process alignment file (LibriSpeech support)\n            # Gather the utterance audios and texts\n            try:\n                alignments_fpath = next(book_dir.glob(\"*.alignment.txt\"))\n                with alignments_fpath.open(\"r\") as alignments_file:\n                    alignments = [line.rstrip().split(\" \") for line in alignments_file]\n            except StopIteration:\n                # A few alignment files will be missing\n                continue\n\n            # Iterate over each entry in the alignments file\n            for wav_fname, words, end_times in alignments:\n                wav_fpath = book_dir.joinpath(wav_fname + \".flac\")\n                assert wav_fpath.exists()\n                words = words.replace(\"\\\"\", \"\").split(\",\")\n                end_times = list(map(float, end_times.replace(\"\\\"\", \"\").split(\",\")))\n\n                # Process each sub-utterance\n                wavs, texts = split_on_silences(wav_fpath, words, end_times, hparams)\n                for i, (wav, text) in enumerate(zip(wavs, texts)):\n                    sub_basename = \"%s_%02d\" % (wav_fname, i)\n                    metadata.append(process_utterance(wav, text, out_dir, sub_basename,\n                                                      skip_existing, hparams))\n\n    return [m for m in metadata if m is not None]\n\n\ndef split_on_silences(wav_fpath, words, end_times, hparams):\n    # Load the audio waveform\n    wav, _ = librosa.load(str(wav_fpath), hparams.sample_rate)\n    if hparams.rescale:\n        wav = wav / np.abs(wav).max() * hparams.rescaling_max\n\n    words = np.array(words)\n    start_times = np.array([0.0] + end_times[:-1])\n    end_times = np.array(end_times)\n    assert len(words) == len(end_times) == len(start_times)\n    assert words[0] == \"\" and words[-1] == \"\"\n\n    # Find pauses that are too long\n    mask = (words == \"\") & (end_times - start_times >= hparams.silence_min_duration_split)\n    mask[0] = mask[-1] = True\n    breaks = np.where(mask)[0]\n\n    # Profile the noise from the silences and perform noise reduction on the waveform\n    silence_times = [[start_times[i], end_times[i]] for i in breaks]\n    silence_times = (np.array(silence_times) * hparams.sample_rate).astype(np.int)\n    noisy_wav = np.concatenate([wav[stime[0]:stime[1]] for stime in silence_times])\n    if len(noisy_wav) > hparams.sample_rate * 0.02:\n        profile = logmmse.profile_noise(noisy_wav, hparams.sample_rate)\n        wav = logmmse.denoise(wav, profile, eta=0)\n\n    # Re-attach segments that are too short\n    segments = list(zip(breaks[:-1], breaks[1:]))\n    segment_durations = [start_times[end] - end_times[start] for start, end in segments]\n    i = 0\n    while i < len(segments) and len(segments) > 1:\n        if segment_durations[i] < hparams.utterance_min_duration:\n            # See if the segment can be re-attached with the right or the left segment\n            left_duration = float(\"inf\") if i == 0 else segment_durations[i - 1]\n            right_duration = float(\"inf\") if i == len(segments) - 1 else segment_durations[i + 1]\n            joined_duration = segment_durations[i] + min(left_duration, right_duration)\n\n            # Do not re-attach if it causes the joined utterance to be too long\n            if joined_duration > hparams.hop_size * hparams.max_mel_frames / hparams.sample_rate:\n                i += 1\n                continue\n\n            # Re-attach the segment with the neighbour of shortest duration\n            j = i - 1 if left_duration <= right_duration else i\n            segments[j] = (segments[j][0], segments[j + 1][1])\n            segment_durations[j] = joined_duration\n            del segments[j + 1], segment_durations[j + 1]\n        else:\n            i += 1\n\n    # Split the utterance\n    segment_times = [[end_times[start], start_times[end]] for start, end in segments]\n    segment_times = (np.array(segment_times) * hparams.sample_rate).astype(np.int)\n    wavs = [wav[segment_time[0]:segment_time[1]] for segment_time in segment_times]\n    texts = [\" \".join(words[start + 1:end]).replace(\"  \", \" \") for start, end in segments]\n\n    # # DEBUG: play the audio segments (run with -n=1)\n    # import sounddevice as sd\n    # if len(wavs) > 1:\n    #     print(\"This sentence was split in %d segments:\" % len(wavs))\n    # else:\n    #     print(\"There are no silences long enough for this sentence to be split:\")\n    # for wav, text in zip(wavs, texts):\n    #     # Pad the waveform with 1 second of silence because sounddevice tends to cut them early\n    #     # when playing them. You shouldn't need to do that in your parsers.\n    #     wav = np.concatenate((wav, [0] * 16000))\n    #     print(\"\\t%s\" % text)\n    #     sd.play(wav, 16000, blocking=True)\n    # print(\"\")\n\n    return wavs, texts\n\n\ndef process_utterance(wav: np.ndarray, text: str, out_dir: Path, basename: str,\n                      skip_existing: bool, hparams):\n    ## FOR REFERENCE:\n    # For you not to lose your head if you ever wish to change things here or implement your own\n    # synthesizer.\n    # - Both the audios and the mel spectrograms are saved as numpy arrays\n    # - There is no processing done to the audios that will be saved to disk beyond volume\n    #   normalization (in split_on_silences)\n    # - However, pre-emphasis is applied to the audios before computing the mel spectrogram. This\n    #   is why we re-apply it on the audio on the side of the vocoder.\n    # - Librosa pads the waveform before computing the mel spectrogram. Here, the waveform is saved\n    #   without extra padding. This means that you won't have an exact relation between the length\n    #   of the wav and of the mel spectrogram. See the vocoder data loader.\n\n\n    # Skip existing utterances if needed\n    mel_fpath = out_dir.joinpath(\"mels\", \"mel-%s.npy\" % basename)\n    wav_fpath = out_dir.joinpath(\"audio\", \"audio-%s.npy\" % basename)\n    if skip_existing and mel_fpath.exists() and wav_fpath.exists():\n        return None\n\n    # Trim silence\n    if hparams.trim_silence:\n        wav = encoder.preprocess_wav(wav, normalize=False, trim_silence=True)\n\n    # Skip utterances that are too short\n    if len(wav) < hparams.utterance_min_duration * hparams.sample_rate:\n        return None\n\n    # Compute the mel spectrogram\n    mel_spectrogram = audio.melspectrogram(wav, hparams).astype(np.float32)\n    mel_frames = mel_spectrogram.shape[1]\n\n    # Skip utterances that are too long\n    if mel_frames > hparams.max_mel_frames and hparams.clip_mels_length:\n        return None\n\n    # Write the spectrogram, embed and audio to disk\n    np.save(mel_fpath, mel_spectrogram.T, allow_pickle=False)\n    np.save(wav_fpath, wav, allow_pickle=False)\n\n    # Return a tuple describing this training example\n    return wav_fpath.name, mel_fpath.name, \"embed-%s.npy\" % basename, len(wav), mel_frames, text\n\n\ndef embed_utterance(fpaths, encoder_model_fpath):\n    if not encoder.is_loaded():\n        encoder.load_model(encoder_model_fpath)\n\n    # Compute the speaker embedding of the utterance\n    wav_fpath, embed_fpath = fpaths\n    wav = np.load(wav_fpath)\n    wav = encoder.preprocess_wav(wav)\n    embed = encoder.embed_utterance(wav)\n    np.save(embed_fpath, embed, allow_pickle=False)\n\n\ndef create_embeddings(synthesizer_root: Path, encoder_model_fpath: Path, n_processes: int):\n    wav_dir = synthesizer_root.joinpath(\"audio\")\n    metadata_fpath = synthesizer_root.joinpath(\"train.txt\")\n    assert wav_dir.exists() and metadata_fpath.exists()\n    embed_dir = synthesizer_root.joinpath(\"embeds\")\n    embed_dir.mkdir(exist_ok=True)\n\n    # Gather the input wave filepath and the target output embed filepath\n    with metadata_fpath.open(\"r\") as metadata_file:\n        metadata = [line.split(\"|\") for line in metadata_file]\n        fpaths = [(wav_dir.joinpath(m[0]), embed_dir.joinpath(m[2])) for m in metadata]\n\n    # TODO: improve on the multiprocessing, it's terrible. Disk I/O is the bottleneck here.\n    # Embed the utterances in separate threads\n    func = partial(embed_utterance, encoder_model_fpath=encoder_model_fpath)\n    job = Pool(n_processes).imap(func, fpaths)\n    list(tqdm(job, \"Embedding\", len(fpaths), unit=\"utterances\"))\n\n", "synthesizer/train.py": "from datetime import datetime\nfrom functools import partial\nfrom pathlib import Path\n\nimport torch\nimport torch.nn.functional as F\nfrom torch import optim\nfrom torch.utils.data import DataLoader\n\nfrom synthesizer import audio\nfrom synthesizer.models.tacotron import Tacotron\nfrom synthesizer.synthesizer_dataset import SynthesizerDataset, collate_synthesizer\nfrom synthesizer.utils import ValueWindow, data_parallel_workaround\nfrom synthesizer.utils.plot import plot_spectrogram\nfrom synthesizer.utils.symbols import symbols\nfrom synthesizer.utils.text import sequence_to_text\nfrom vocoder.display import *\n\n\ndef np_now(x: torch.Tensor): return x.detach().cpu().numpy()\n\n\ndef time_string():\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n\n\ndef train(run_id: str, syn_dir: Path, models_dir: Path, save_every: int,  backup_every: int, force_restart: bool,\n          hparams):\n    models_dir.mkdir(exist_ok=True)\n\n    model_dir = models_dir.joinpath(run_id)\n    plot_dir = model_dir.joinpath(\"plots\")\n    wav_dir = model_dir.joinpath(\"wavs\")\n    mel_output_dir = model_dir.joinpath(\"mel-spectrograms\")\n    meta_folder = model_dir.joinpath(\"metas\")\n    model_dir.mkdir(exist_ok=True)\n    plot_dir.mkdir(exist_ok=True)\n    wav_dir.mkdir(exist_ok=True)\n    mel_output_dir.mkdir(exist_ok=True)\n    meta_folder.mkdir(exist_ok=True)\n\n    weights_fpath = model_dir / f\"synthesizer.pt\"\n    metadata_fpath = syn_dir.joinpath(\"train.txt\")\n\n    print(\"Checkpoint path: {}\".format(weights_fpath))\n    print(\"Loading training data from: {}\".format(metadata_fpath))\n    print(\"Using model: Tacotron\")\n\n    # Bookkeeping\n    time_window = ValueWindow(100)\n    loss_window = ValueWindow(100)\n\n    # From WaveRNN/train_tacotron.py\n    if torch.cuda.is_available():\n        device = torch.device(\"cuda\")\n\n        for session in hparams.tts_schedule:\n            _, _, _, batch_size = session\n            if batch_size % torch.cuda.device_count() != 0:\n                raise ValueError(\"`batch_size` must be evenly divisible by n_gpus!\")\n    else:\n        device = torch.device(\"cpu\")\n    print(\"Using device:\", device)\n\n    # Instantiate Tacotron Model\n    print(\"\\nInitialising Tacotron Model...\\n\")\n    model = Tacotron(embed_dims=hparams.tts_embed_dims,\n                     num_chars=len(symbols),\n                     encoder_dims=hparams.tts_encoder_dims,\n                     decoder_dims=hparams.tts_decoder_dims,\n                     n_mels=hparams.num_mels,\n                     fft_bins=hparams.num_mels,\n                     postnet_dims=hparams.tts_postnet_dims,\n                     encoder_K=hparams.tts_encoder_K,\n                     lstm_dims=hparams.tts_lstm_dims,\n                     postnet_K=hparams.tts_postnet_K,\n                     num_highways=hparams.tts_num_highways,\n                     dropout=hparams.tts_dropout,\n                     stop_threshold=hparams.tts_stop_threshold,\n                     speaker_embedding_size=hparams.speaker_embedding_size).to(device)\n\n    # Initialize the optimizer\n    optimizer = optim.Adam(model.parameters())\n\n    # Load the weights\n    if force_restart or not weights_fpath.exists():\n        print(\"\\nStarting the training of Tacotron from scratch\\n\")\n        model.save(weights_fpath)\n\n        # Embeddings metadata\n        char_embedding_fpath = meta_folder.joinpath(\"CharacterEmbeddings.tsv\")\n        with open(char_embedding_fpath, \"w\", encoding=\"utf-8\") as f:\n            for symbol in symbols:\n                if symbol == \" \":\n                    symbol = \"\\\\s\"  # For visual purposes, swap space with \\s\n\n                f.write(\"{}\\n\".format(symbol))\n\n    else:\n        print(\"\\nLoading weights at %s\" % weights_fpath)\n        model.load(weights_fpath, optimizer)\n        print(\"Tacotron weights loaded from step %d\" % model.step)\n\n    # Initialize the dataset\n    metadata_fpath = syn_dir.joinpath(\"train.txt\")\n    mel_dir = syn_dir.joinpath(\"mels\")\n    embed_dir = syn_dir.joinpath(\"embeds\")\n    dataset = SynthesizerDataset(metadata_fpath, mel_dir, embed_dir, hparams)\n\n    for i, session in enumerate(hparams.tts_schedule):\n        current_step = model.get_step()\n\n        r, lr, max_step, batch_size = session\n\n        training_steps = max_step - current_step\n\n        # Do we need to change to the next session?\n        if current_step >= max_step:\n            # Are there no further sessions than the current one?\n            if i == len(hparams.tts_schedule) - 1:\n                # We have completed training. Save the model and exit\n                model.save(weights_fpath, optimizer)\n                break\n            else:\n                # There is a following session, go to it\n                continue\n\n        model.r = r\n\n        # Begin the training\n        simple_table([(f\"Steps with r={r}\", str(training_steps // 1000) + \"k Steps\"),\n                      (\"Batch Size\", batch_size),\n                      (\"Learning Rate\", lr),\n                      (\"Outputs/Step (r)\", model.r)])\n\n        for p in optimizer.param_groups:\n            p[\"lr\"] = lr\n\n        collate_fn = partial(collate_synthesizer, r=r, hparams=hparams)\n        data_loader = DataLoader(dataset, batch_size, shuffle=True, num_workers=2, collate_fn=collate_fn)\n\n        total_iters = len(dataset)\n        steps_per_epoch = np.ceil(total_iters / batch_size).astype(np.int32)\n        epochs = np.ceil(training_steps / steps_per_epoch).astype(np.int32)\n\n        for epoch in range(1, epochs+1):\n            for i, (texts, mels, embeds, idx) in enumerate(data_loader, 1):\n                start_time = time.time()\n\n                # Generate stop tokens for training\n                stop = torch.ones(mels.shape[0], mels.shape[2])\n                for j, k in enumerate(idx):\n                    stop[j, :int(dataset.metadata[k][4])-1] = 0\n\n                texts = texts.to(device)\n                mels = mels.to(device)\n                embeds = embeds.to(device)\n                stop = stop.to(device)\n\n                # Forward pass\n                # Parallelize model onto GPUS using workaround due to python bug\n                if device.type == \"cuda\" and torch.cuda.device_count() > 1:\n                    m1_hat, m2_hat, attention, stop_pred = data_parallel_workaround(model, texts, mels, embeds)\n                else:\n                    m1_hat, m2_hat, attention, stop_pred = model(texts, mels, embeds)\n\n                # Backward pass\n                m1_loss = F.mse_loss(m1_hat, mels) + F.l1_loss(m1_hat, mels)\n                m2_loss = F.mse_loss(m2_hat, mels)\n                stop_loss = F.binary_cross_entropy(stop_pred, stop)\n\n                loss = m1_loss + m2_loss + stop_loss\n\n                optimizer.zero_grad()\n                loss.backward()\n\n                if hparams.tts_clip_grad_norm is not None:\n                    grad_norm = torch.nn.utils.clip_grad_norm_(model.parameters(), hparams.tts_clip_grad_norm)\n                    if np.isnan(grad_norm.cpu()):\n                        print(\"grad_norm was NaN!\")\n\n                optimizer.step()\n\n                time_window.append(time.time() - start_time)\n                loss_window.append(loss.item())\n\n                step = model.get_step()\n                k = step // 1000\n\n                msg = f\"| Epoch: {epoch}/{epochs} ({i}/{steps_per_epoch}) | Loss: {loss_window.average:#.4} | \" \\\n                      f\"{1./time_window.average:#.2} steps/s | Step: {k}k | \"\n                stream(msg)\n\n                # Backup or save model as appropriate\n                if backup_every != 0 and step % backup_every == 0 :\n                    backup_fpath = weights_fpath.parent / f\"synthesizer_{k:06d}.pt\"\n                    model.save(backup_fpath, optimizer)\n\n                if save_every != 0 and step % save_every == 0 :\n                    # Must save latest optimizer state to ensure that resuming training\n                    # doesn't produce artifacts\n                    model.save(weights_fpath, optimizer)\n\n                # Evaluate model to generate samples\n                epoch_eval = hparams.tts_eval_interval == -1 and i == steps_per_epoch  # If epoch is done\n                step_eval = hparams.tts_eval_interval > 0 and step % hparams.tts_eval_interval == 0  # Every N steps\n                if epoch_eval or step_eval:\n                    for sample_idx in range(hparams.tts_eval_num_samples):\n                        # At most, generate samples equal to number in the batch\n                        if sample_idx + 1 <= len(texts):\n                            # Remove padding from mels using frame length in metadata\n                            mel_length = int(dataset.metadata[idx[sample_idx]][4])\n                            mel_prediction = np_now(m2_hat[sample_idx]).T[:mel_length]\n                            target_spectrogram = np_now(mels[sample_idx]).T[:mel_length]\n                            attention_len = mel_length // model.r\n\n                            eval_model(attention=np_now(attention[sample_idx][:, :attention_len]),\n                                       mel_prediction=mel_prediction,\n                                       target_spectrogram=target_spectrogram,\n                                       input_seq=np_now(texts[sample_idx]),\n                                       step=step,\n                                       plot_dir=plot_dir,\n                                       mel_output_dir=mel_output_dir,\n                                       wav_dir=wav_dir,\n                                       sample_num=sample_idx + 1,\n                                       loss=loss,\n                                       hparams=hparams)\n\n                # Break out of loop to update training schedule\n                if step >= max_step:\n                    break\n\n            # Add line break after every epoch\n            print(\"\")\n\n\ndef eval_model(attention, mel_prediction, target_spectrogram, input_seq, step,\n               plot_dir, mel_output_dir, wav_dir, sample_num, loss, hparams):\n    # Save some results for evaluation\n    attention_path = str(plot_dir.joinpath(\"attention_step_{}_sample_{}\".format(step, sample_num)))\n    save_attention(attention, attention_path)\n\n    # save predicted mel spectrogram to disk (debug)\n    mel_output_fpath = mel_output_dir.joinpath(\"mel-prediction-step-{}_sample_{}.npy\".format(step, sample_num))\n    np.save(str(mel_output_fpath), mel_prediction, allow_pickle=False)\n\n    # save griffin lim inverted wav for debug (mel -> wav)\n    wav = audio.inv_mel_spectrogram(mel_prediction.T, hparams)\n    wav_fpath = wav_dir.joinpath(\"step-{}-wave-from-mel_sample_{}.wav\".format(step, sample_num))\n    audio.save_wav(wav, str(wav_fpath), sr=hparams.sample_rate)\n\n    # save real and predicted mel-spectrogram plot to disk (control purposes)\n    spec_fpath = plot_dir.joinpath(\"step-{}-mel-spectrogram_sample_{}.png\".format(step, sample_num))\n    title_str = \"{}, {}, step={}, loss={:.5f}\".format(\"Tacotron\", time_string(), step, loss)\n    plot_spectrogram(mel_prediction, str(spec_fpath), title=title_str,\n                     target_spectrogram=target_spectrogram,\n                     max_len=target_spectrogram.size // hparams.num_mels)\n    print(\"Input at step {}: {}\".format(step, sequence_to_text(input_seq)))\n", "synthesizer/audio.py": "import librosa\nimport librosa.filters\nimport numpy as np\nfrom scipy import signal\nfrom scipy.io import wavfile\nimport soundfile as sf\n\n\ndef load_wav(path, sr):\n    return librosa.core.load(path, sr=sr)[0]\n\ndef save_wav(wav, path, sr):\n    wav *= 32767 / max(0.01, np.max(np.abs(wav)))\n    #proposed by @dsmiller\n    wavfile.write(path, sr, wav.astype(np.int16))\n\ndef save_wavenet_wav(wav, path, sr):\n    sf.write(path, wav.astype(np.float32), sr)\n\ndef preemphasis(wav, k, preemphasize=True):\n    if preemphasize:\n        return signal.lfilter([1, -k], [1], wav)\n    return wav\n\ndef inv_preemphasis(wav, k, inv_preemphasize=True):\n    if inv_preemphasize:\n        return signal.lfilter([1], [1, -k], wav)\n    return wav\n\n#From https://github.com/r9y9/wavenet_vocoder/blob/master/audio.py\ndef start_and_end_indices(quantized, silence_threshold=2):\n    for start in range(quantized.size):\n        if abs(quantized[start] - 127) > silence_threshold:\n            break\n    for end in range(quantized.size - 1, 1, -1):\n        if abs(quantized[end] - 127) > silence_threshold:\n            break\n    \n    assert abs(quantized[start] - 127) > silence_threshold\n    assert abs(quantized[end] - 127) > silence_threshold\n    \n    return start, end\n\ndef get_hop_size(hparams):\n    hop_size = hparams.hop_size\n    if hop_size is None:\n        assert hparams.frame_shift_ms is not None\n        hop_size = int(hparams.frame_shift_ms / 1000 * hparams.sample_rate)\n    return hop_size\n\ndef linearspectrogram(wav, hparams):\n    D = _stft(preemphasis(wav, hparams.preemphasis, hparams.preemphasize), hparams)\n    S = _amp_to_db(np.abs(D), hparams) - hparams.ref_level_db\n    \n    if hparams.signal_normalization:\n        return _normalize(S, hparams)\n    return S\n\ndef melspectrogram(wav, hparams):\n    D = _stft(preemphasis(wav, hparams.preemphasis, hparams.preemphasize), hparams)\n    S = _amp_to_db(_linear_to_mel(np.abs(D), hparams), hparams) - hparams.ref_level_db\n    \n    if hparams.signal_normalization:\n        return _normalize(S, hparams)\n    return S\n\ndef inv_linear_spectrogram(linear_spectrogram, hparams):\n    \"\"\"Converts linear spectrogram to waveform using librosa\"\"\"\n    if hparams.signal_normalization:\n        D = _denormalize(linear_spectrogram, hparams)\n    else:\n        D = linear_spectrogram\n    \n    S = _db_to_amp(D + hparams.ref_level_db) #Convert back to linear\n    \n    if hparams.use_lws:\n        processor = _lws_processor(hparams)\n        D = processor.run_lws(S.astype(np.float64).T ** hparams.power)\n        y = processor.istft(D).astype(np.float32)\n        return inv_preemphasis(y, hparams.preemphasis, hparams.preemphasize)\n    else:\n        return inv_preemphasis(_griffin_lim(S ** hparams.power, hparams), hparams.preemphasis, hparams.preemphasize)\n\ndef inv_mel_spectrogram(mel_spectrogram, hparams):\n    \"\"\"Converts mel spectrogram to waveform using librosa\"\"\"\n    if hparams.signal_normalization:\n        D = _denormalize(mel_spectrogram, hparams)\n    else:\n        D = mel_spectrogram\n    \n    S = _mel_to_linear(_db_to_amp(D + hparams.ref_level_db), hparams)  # Convert back to linear\n    \n    if hparams.use_lws:\n        processor = _lws_processor(hparams)\n        D = processor.run_lws(S.astype(np.float64).T ** hparams.power)\n        y = processor.istft(D).astype(np.float32)\n        return inv_preemphasis(y, hparams.preemphasis, hparams.preemphasize)\n    else:\n        return inv_preemphasis(_griffin_lim(S ** hparams.power, hparams), hparams.preemphasis, hparams.preemphasize)\n\ndef _lws_processor(hparams):\n    import lws\n    return lws.lws(hparams.n_fft, get_hop_size(hparams), fftsize=hparams.win_size, mode=\"speech\")\n\ndef _griffin_lim(S, hparams):\n    \"\"\"librosa implementation of Griffin-Lim\n    Based on https://github.com/librosa/librosa/issues/434\n    \"\"\"\n    angles = np.exp(2j * np.pi * np.random.rand(*S.shape))\n    S_complex = np.abs(S).astype(np.complex)\n    y = _istft(S_complex * angles, hparams)\n    for i in range(hparams.griffin_lim_iters):\n        angles = np.exp(1j * np.angle(_stft(y, hparams)))\n        y = _istft(S_complex * angles, hparams)\n    return y\n\ndef _stft(y, hparams):\n    if hparams.use_lws:\n        return _lws_processor(hparams).stft(y).T\n    else:\n        return librosa.stft(y=y, n_fft=hparams.n_fft, hop_length=get_hop_size(hparams), win_length=hparams.win_size)\n\ndef _istft(y, hparams):\n    return librosa.istft(y, hop_length=get_hop_size(hparams), win_length=hparams.win_size)\n\n##########################################################\n#Those are only correct when using lws!!! (This was messing with Wavenet quality for a long time!)\ndef num_frames(length, fsize, fshift):\n    \"\"\"Compute number of time frames of spectrogram\n    \"\"\"\n    pad = (fsize - fshift)\n    if length % fshift == 0:\n        M = (length + pad * 2 - fsize) // fshift + 1\n    else:\n        M = (length + pad * 2 - fsize) // fshift + 2\n    return M\n\n\ndef pad_lr(x, fsize, fshift):\n    \"\"\"Compute left and right padding\n    \"\"\"\n    M = num_frames(len(x), fsize, fshift)\n    pad = (fsize - fshift)\n    T = len(x) + 2 * pad\n    r = (M - 1) * fshift + fsize - T\n    return pad, pad + r\n##########################################################\n#Librosa correct padding\ndef librosa_pad_lr(x, fsize, fshift):\n    return 0, (x.shape[0] // fshift + 1) * fshift - x.shape[0]\n\n# Conversions\n_mel_basis = None\n_inv_mel_basis = None\n\ndef _linear_to_mel(spectogram, hparams):\n    global _mel_basis\n    if _mel_basis is None:\n        _mel_basis = _build_mel_basis(hparams)\n    return np.dot(_mel_basis, spectogram)\n\ndef _mel_to_linear(mel_spectrogram, hparams):\n    global _inv_mel_basis\n    if _inv_mel_basis is None:\n        _inv_mel_basis = np.linalg.pinv(_build_mel_basis(hparams))\n    return np.maximum(1e-10, np.dot(_inv_mel_basis, mel_spectrogram))\n\ndef _build_mel_basis(hparams):\n    assert hparams.fmax <= hparams.sample_rate // 2\n    return librosa.filters.mel(hparams.sample_rate, hparams.n_fft, n_mels=hparams.num_mels,\n                               fmin=hparams.fmin, fmax=hparams.fmax)\n\ndef _amp_to_db(x, hparams):\n    min_level = np.exp(hparams.min_level_db / 20 * np.log(10))\n    return 20 * np.log10(np.maximum(min_level, x))\n\ndef _db_to_amp(x):\n    return np.power(10.0, (x) * 0.05)\n\ndef _normalize(S, hparams):\n    if hparams.allow_clipping_in_normalization:\n        if hparams.symmetric_mels:\n            return np.clip((2 * hparams.max_abs_value) * ((S - hparams.min_level_db) / (-hparams.min_level_db)) - hparams.max_abs_value,\n                           -hparams.max_abs_value, hparams.max_abs_value)\n        else:\n            return np.clip(hparams.max_abs_value * ((S - hparams.min_level_db) / (-hparams.min_level_db)), 0, hparams.max_abs_value)\n    \n    assert S.max() <= 0 and S.min() - hparams.min_level_db >= 0\n    if hparams.symmetric_mels:\n        return (2 * hparams.max_abs_value) * ((S - hparams.min_level_db) / (-hparams.min_level_db)) - hparams.max_abs_value\n    else:\n        return hparams.max_abs_value * ((S - hparams.min_level_db) / (-hparams.min_level_db))\n\ndef _denormalize(D, hparams):\n    if hparams.allow_clipping_in_normalization:\n        if hparams.symmetric_mels:\n            return (((np.clip(D, -hparams.max_abs_value,\n                              hparams.max_abs_value) + hparams.max_abs_value) * -hparams.min_level_db / (2 * hparams.max_abs_value))\n                    + hparams.min_level_db)\n        else:\n            return ((np.clip(D, 0, hparams.max_abs_value) * -hparams.min_level_db / hparams.max_abs_value) + hparams.min_level_db)\n    \n    if hparams.symmetric_mels:\n        return (((D + hparams.max_abs_value) * -hparams.min_level_db / (2 * hparams.max_abs_value)) + hparams.min_level_db)\n    else:\n        return ((D * -hparams.min_level_db / hparams.max_abs_value) + hparams.min_level_db)\n", "synthesizer/hparams.py": "import ast\nimport pprint\n\nclass HParams(object):\n    def __init__(self, **kwargs): self.__dict__.update(kwargs)\n    def __setitem__(self, key, value): setattr(self, key, value)\n    def __getitem__(self, key): return getattr(self, key)\n    def __repr__(self): return pprint.pformat(self.__dict__)\n\n    def parse(self, string):\n        # Overrides hparams from a comma-separated string of name=value pairs\n        if len(string) > 0:\n            overrides = [s.split(\"=\") for s in string.split(\",\")]\n            keys, values = zip(*overrides)\n            keys = list(map(str.strip, keys))\n            values = list(map(str.strip, values))\n            for k in keys:\n                self.__dict__[k] = ast.literal_eval(values[keys.index(k)])\n        return self\n\nhparams = HParams(\n        ### Signal Processing (used in both synthesizer and vocoder)\n        sample_rate = 16000,\n        n_fft = 800,\n        num_mels = 80,\n        hop_size = 200,                             # Tacotron uses 12.5 ms frame shift (set to sample_rate * 0.0125)\n        win_size = 800,                             # Tacotron uses 50 ms frame length (set to sample_rate * 0.050)\n        fmin = 55,\n        min_level_db = -100,\n        ref_level_db = 20,\n        max_abs_value = 4.,                         # Gradient explodes if too big, premature convergence if too small.\n        preemphasis = 0.97,                         # Filter coefficient to use if preemphasize is True\n        preemphasize = True,\n\n        ### Tacotron Text-to-Speech (TTS)\n        tts_embed_dims = 512,                       # Embedding dimension for the graphemes/phoneme inputs\n        tts_encoder_dims = 256,\n        tts_decoder_dims = 128,\n        tts_postnet_dims = 512,\n        tts_encoder_K = 5,\n        tts_lstm_dims = 1024,\n        tts_postnet_K = 5,\n        tts_num_highways = 4,\n        tts_dropout = 0.5,\n        tts_cleaner_names = [\"english_cleaners\"],\n        tts_stop_threshold = -3.4,                  # Value below which audio generation ends.\n                                                    # For example, for a range of [-4, 4], this\n                                                    # will terminate the sequence at the first\n                                                    # frame that has all values < -3.4\n\n        ### Tacotron Training\n        tts_schedule = [(2,  1e-3,  20_000,  12),   # Progressive training schedule\n                        (2,  5e-4,  40_000,  12),   # (r, lr, step, batch_size)\n                        (2,  2e-4,  80_000,  12),   #\n                        (2,  1e-4, 160_000,  12),   # r = reduction factor (# of mel frames\n                        (2,  3e-5, 320_000,  12),   #     synthesized for each decoder iteration)\n                        (2,  1e-5, 640_000,  12)],  # lr = learning rate\n\n        tts_clip_grad_norm = 1.0,                   # clips the gradient norm to prevent explosion - set to None if not needed\n        tts_eval_interval = 500,                    # Number of steps between model evaluation (sample generation)\n                                                    # Set to -1 to generate after completing epoch, or 0 to disable\n\n        tts_eval_num_samples = 1,                   # Makes this number of samples\n\n        ### Data Preprocessing\n        max_mel_frames = 900,\n        rescale = True,\n        rescaling_max = 0.9,\n        synthesis_batch_size = 16,                  # For vocoder preprocessing and inference.\n\n        ### Mel Visualization and Griffin-Lim\n        signal_normalization = True,\n        power = 1.5,\n        griffin_lim_iters = 60,\n\n        ### Audio processing options\n        fmax = 7600,                                # Should not exceed (sample_rate // 2)\n        allow_clipping_in_normalization = True,     # Used when signal_normalization = True\n        clip_mels_length = True,                    # If true, discards samples exceeding max_mel_frames\n        use_lws = False,                            # \"Fast spectrogram phase recovery using local weighted sums\"\n        symmetric_mels = True,                      # Sets mel range to [-max_abs_value, max_abs_value] if True,\n                                                    #               and [0, max_abs_value] if False\n        trim_silence = True,                        # Use with sample_rate of 16000 for best results\n\n        ### SV2TTS\n        speaker_embedding_size = 256,               # Dimension for the speaker embedding\n        silence_min_duration_split = 0.4,           # Duration in seconds of a silence for an utterance to be split\n        utterance_min_duration = 1.6,               # Duration in seconds below which utterances are discarded\n        )\n\ndef hparams_debug_string():\n    return str(hparams)\n", "synthesizer/__init__.py": "#", "synthesizer/inference.py": "import torch\nfrom synthesizer import audio\nfrom synthesizer.hparams import hparams\nfrom synthesizer.models.tacotron import Tacotron\nfrom synthesizer.utils.symbols import symbols\nfrom synthesizer.utils.text import text_to_sequence\nfrom vocoder.display import simple_table\nfrom pathlib import Path\nfrom typing import Union, List\nimport numpy as np\nimport librosa\n\n\nclass Synthesizer:\n    sample_rate = hparams.sample_rate\n    hparams = hparams\n\n    def __init__(self, model_fpath: Path, verbose=True):\n        \"\"\"\n        The model isn't instantiated and loaded in memory until needed or until load() is called.\n\n        :param model_fpath: path to the trained model file\n        :param verbose: if False, prints less information when using the model\n        \"\"\"\n        self.model_fpath = model_fpath\n        self.verbose = verbose\n\n        # Check for GPU\n        if torch.cuda.is_available():\n            self.device = torch.device(\"cuda\")\n        else:\n            self.device = torch.device(\"cpu\")\n        if self.verbose:\n            print(\"Synthesizer using device:\", self.device)\n\n        # Tacotron model will be instantiated later on first use.\n        self._model = None\n\n    def is_loaded(self):\n        \"\"\"\n        Whether the model is loaded in memory.\n        \"\"\"\n        return self._model is not None\n\n    def load(self):\n        \"\"\"\n        Instantiates and loads the model given the weights file that was passed in the constructor.\n        \"\"\"\n        self._model = Tacotron(embed_dims=hparams.tts_embed_dims,\n                               num_chars=len(symbols),\n                               encoder_dims=hparams.tts_encoder_dims,\n                               decoder_dims=hparams.tts_decoder_dims,\n                               n_mels=hparams.num_mels,\n                               fft_bins=hparams.num_mels,\n                               postnet_dims=hparams.tts_postnet_dims,\n                               encoder_K=hparams.tts_encoder_K,\n                               lstm_dims=hparams.tts_lstm_dims,\n                               postnet_K=hparams.tts_postnet_K,\n                               num_highways=hparams.tts_num_highways,\n                               dropout=hparams.tts_dropout,\n                               stop_threshold=hparams.tts_stop_threshold,\n                               speaker_embedding_size=hparams.speaker_embedding_size).to(self.device)\n\n        self._model.load(self.model_fpath)\n        self._model.eval()\n\n        if self.verbose:\n            print(\"Loaded synthesizer \\\"%s\\\" trained to step %d\" % (self.model_fpath.name, self._model.state_dict()[\"step\"]))\n\n    def synthesize_spectrograms(self, texts: List[str],\n                                embeddings: Union[np.ndarray, List[np.ndarray]],\n                                return_alignments=False):\n        \"\"\"\n        Synthesizes mel spectrograms from texts and speaker embeddings.\n\n        :param texts: a list of N text prompts to be synthesized\n        :param embeddings: a numpy array or list of speaker embeddings of shape (N, 256)\n        :param return_alignments: if True, a matrix representing the alignments between the\n        characters\n        and each decoder output step will be returned for each spectrogram\n        :return: a list of N melspectrograms as numpy arrays of shape (80, Mi), where Mi is the\n        sequence length of spectrogram i, and possibly the alignments.\n        \"\"\"\n        # Load the model on the first request.\n        if not self.is_loaded():\n            self.load()\n\n        # Preprocess text inputs\n        inputs = [text_to_sequence(text.strip(), hparams.tts_cleaner_names) for text in texts]\n        if not isinstance(embeddings, list):\n            embeddings = [embeddings]\n\n        # Batch inputs\n        batched_inputs = [inputs[i:i+hparams.synthesis_batch_size]\n                             for i in range(0, len(inputs), hparams.synthesis_batch_size)]\n        batched_embeds = [embeddings[i:i+hparams.synthesis_batch_size]\n                             for i in range(0, len(embeddings), hparams.synthesis_batch_size)]\n\n        specs = []\n        for i, batch in enumerate(batched_inputs, 1):\n            if self.verbose:\n                print(f\"\\n| Generating {i}/{len(batched_inputs)}\")\n\n            # Pad texts so they are all the same length\n            text_lens = [len(text) for text in batch]\n            max_text_len = max(text_lens)\n            chars = [pad1d(text, max_text_len) for text in batch]\n            chars = np.stack(chars)\n\n            # Stack speaker embeddings into 2D array for batch processing\n            speaker_embeds = np.stack(batched_embeds[i-1])\n\n            # Convert to tensor\n            chars = torch.tensor(chars).long().to(self.device)\n            speaker_embeddings = torch.tensor(speaker_embeds).float().to(self.device)\n\n            # Inference\n            _, mels, alignments = self._model.generate(chars, speaker_embeddings)\n            mels = mels.detach().cpu().numpy()\n            for m in mels:\n                # Trim silence from end of each spectrogram\n                while np.max(m[:, -1]) < hparams.tts_stop_threshold:\n                    m = m[:, :-1]\n                specs.append(m)\n\n        if self.verbose:\n            print(\"\\n\\nDone.\\n\")\n        return (specs, alignments) if return_alignments else specs\n\n    @staticmethod\n    def load_preprocess_wav(fpath):\n        \"\"\"\n        Loads and preprocesses an audio file under the same conditions the audio files were used to\n        train the synthesizer.\n        \"\"\"\n        wav = librosa.load(str(fpath), hparams.sample_rate)[0]\n        if hparams.rescale:\n            wav = wav / np.abs(wav).max() * hparams.rescaling_max\n        return wav\n\n    @staticmethod\n    def make_spectrogram(fpath_or_wav: Union[str, Path, np.ndarray]):\n        \"\"\"\n        Creates a mel spectrogram from an audio file in the same manner as the mel spectrograms that\n        were fed to the synthesizer when training.\n        \"\"\"\n        if isinstance(fpath_or_wav, str) or isinstance(fpath_or_wav, Path):\n            wav = Synthesizer.load_preprocess_wav(fpath_or_wav)\n        else:\n            wav = fpath_or_wav\n\n        mel_spectrogram = audio.melspectrogram(wav, hparams).astype(np.float32)\n        return mel_spectrogram\n\n    @staticmethod\n    def griffin_lim(mel):\n        \"\"\"\n        Inverts a mel spectrogram using Griffin-Lim. The mel spectrogram is expected to have been built\n        with the same parameters present in hparams.py.\n        \"\"\"\n        return audio.inv_mel_spectrogram(mel, hparams)\n\n\ndef pad1d(x, max_len, pad_value=0):\n    return np.pad(x, (0, max_len - len(x)), mode=\"constant\", constant_values=pad_value)\n", "synthesizer/synthesize.py": "import platform\nfrom functools import partial\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nfrom torch.utils.data import DataLoader\nfrom tqdm import tqdm\n\nfrom synthesizer.hparams import hparams_debug_string\nfrom synthesizer.models.tacotron import Tacotron\nfrom synthesizer.synthesizer_dataset import SynthesizerDataset, collate_synthesizer\nfrom synthesizer.utils import data_parallel_workaround\nfrom synthesizer.utils.symbols import symbols\n\n\ndef run_synthesis(in_dir: Path, out_dir: Path, syn_model_fpath: Path, hparams):\n    # This generates ground truth-aligned mels for vocoder training\n    synth_dir = out_dir / \"mels_gta\"\n    synth_dir.mkdir(exist_ok=True, parents=True)\n    print(hparams_debug_string())\n\n    # Check for GPU\n    if torch.cuda.is_available():\n        device = torch.device(\"cuda\")\n        if hparams.synthesis_batch_size % torch.cuda.device_count() != 0:\n            raise ValueError(\"`hparams.synthesis_batch_size` must be evenly divisible by n_gpus!\")\n    else:\n        device = torch.device(\"cpu\")\n    print(\"Synthesizer using device:\", device)\n\n    # Instantiate Tacotron model\n    model = Tacotron(embed_dims=hparams.tts_embed_dims,\n                     num_chars=len(symbols),\n                     encoder_dims=hparams.tts_encoder_dims,\n                     decoder_dims=hparams.tts_decoder_dims,\n                     n_mels=hparams.num_mels,\n                     fft_bins=hparams.num_mels,\n                     postnet_dims=hparams.tts_postnet_dims,\n                     encoder_K=hparams.tts_encoder_K,\n                     lstm_dims=hparams.tts_lstm_dims,\n                     postnet_K=hparams.tts_postnet_K,\n                     num_highways=hparams.tts_num_highways,\n                     dropout=0., # Use zero dropout for gta mels\n                     stop_threshold=hparams.tts_stop_threshold,\n                     speaker_embedding_size=hparams.speaker_embedding_size).to(device)\n\n    # Load the weights\n    print(\"\\nLoading weights at %s\" % syn_model_fpath)\n    model.load(syn_model_fpath)\n    print(\"Tacotron weights loaded from step %d\" % model.step)\n\n    # Synthesize using same reduction factor as the model is currently trained\n    r = np.int32(model.r)\n\n    # Set model to eval mode (disable gradient and zoneout)\n    model.eval()\n\n    # Initialize the dataset\n    metadata_fpath = in_dir.joinpath(\"train.txt\")\n    mel_dir = in_dir.joinpath(\"mels\")\n    embed_dir = in_dir.joinpath(\"embeds\")\n\n    dataset = SynthesizerDataset(metadata_fpath, mel_dir, embed_dir, hparams)\n    collate_fn = partial(collate_synthesizer, r=r, hparams=hparams)\n    data_loader = DataLoader(dataset, hparams.synthesis_batch_size, collate_fn=collate_fn, num_workers=2)\n\n    # Generate GTA mels\n    meta_out_fpath = out_dir / \"synthesized.txt\"\n    with meta_out_fpath.open(\"w\") as file:\n        for i, (texts, mels, embeds, idx) in tqdm(enumerate(data_loader), total=len(data_loader)):\n            texts, mels, embeds = texts.to(device), mels.to(device), embeds.to(device)\n\n            # Parallelize model onto GPUS using workaround due to python bug\n            if device.type == \"cuda\" and torch.cuda.device_count() > 1:\n                _, mels_out, _ = data_parallel_workaround(model, texts, mels, embeds)\n            else:\n                _, mels_out, _, _ = model(texts, mels, embeds)\n\n            for j, k in enumerate(idx):\n                # Note: outputs mel-spectrogram files and target ones have same names, just different folders\n                mel_filename = Path(synth_dir).joinpath(dataset.metadata[k][1])\n                mel_out = mels_out[j].detach().cpu().numpy().T\n\n                # Use the length of the ground truth mel to remove padding from the generated mels\n                mel_out = mel_out[:int(dataset.metadata[k][4])]\n\n                # Write the spectrogram to disk\n                np.save(mel_filename, mel_out, allow_pickle=False)\n\n                # Write metadata into the synthesized file\n                file.write(\"|\".join(dataset.metadata[k]))\n", "synthesizer/models/tacotron.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom pathlib import Path\nfrom typing import Union\n\n\nclass HighwayNetwork(nn.Module):\n    def __init__(self, size):\n        super().__init__()\n        self.W1 = nn.Linear(size, size)\n        self.W2 = nn.Linear(size, size)\n        self.W1.bias.data.fill_(0.)\n\n    def forward(self, x):\n        x1 = self.W1(x)\n        x2 = self.W2(x)\n        g = torch.sigmoid(x2)\n        y = g * F.relu(x1) + (1. - g) * x\n        return y\n\n\nclass Encoder(nn.Module):\n    def __init__(self, embed_dims, num_chars, encoder_dims, K, num_highways, dropout):\n        super().__init__()\n        prenet_dims = (encoder_dims, encoder_dims)\n        cbhg_channels = encoder_dims\n        self.embedding = nn.Embedding(num_chars, embed_dims)\n        self.pre_net = PreNet(embed_dims, fc1_dims=prenet_dims[0], fc2_dims=prenet_dims[1],\n                              dropout=dropout)\n        self.cbhg = CBHG(K=K, in_channels=cbhg_channels, channels=cbhg_channels,\n                         proj_channels=[cbhg_channels, cbhg_channels],\n                         num_highways=num_highways)\n\n    def forward(self, x, speaker_embedding=None):\n        x = self.embedding(x)\n        x = self.pre_net(x)\n        x.transpose_(1, 2)\n        x = self.cbhg(x)\n        if speaker_embedding is not None:\n            x = self.add_speaker_embedding(x, speaker_embedding)\n        return x\n\n    def add_speaker_embedding(self, x, speaker_embedding):\n        # SV2TTS\n        # The input x is the encoder output and is a 3D tensor with size (batch_size, num_chars, tts_embed_dims)\n        # When training, speaker_embedding is also a 2D tensor with size (batch_size, speaker_embedding_size)\n        #     (for inference, speaker_embedding is a 1D tensor with size (speaker_embedding_size))\n        # This concats the speaker embedding for each char in the encoder output\n\n        # Save the dimensions as human-readable names\n        batch_size = x.size()[0]\n        num_chars = x.size()[1]\n\n        if speaker_embedding.dim() == 1:\n            idx = 0\n        else:\n            idx = 1\n\n        # Start by making a copy of each speaker embedding to match the input text length\n        # The output of this has size (batch_size, num_chars * tts_embed_dims)\n        speaker_embedding_size = speaker_embedding.size()[idx]\n        e = speaker_embedding.repeat_interleave(num_chars, dim=idx)\n\n        # Reshape it and transpose\n        e = e.reshape(batch_size, speaker_embedding_size, num_chars)\n        e = e.transpose(1, 2)\n\n        # Concatenate the tiled speaker embedding with the encoder output\n        x = torch.cat((x, e), 2)\n        return x\n\n\nclass BatchNormConv(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel, relu=True):\n        super().__init__()\n        self.conv = nn.Conv1d(in_channels, out_channels, kernel, stride=1, padding=kernel // 2, bias=False)\n        self.bnorm = nn.BatchNorm1d(out_channels)\n        self.relu = relu\n\n    def forward(self, x):\n        x = self.conv(x)\n        x = F.relu(x) if self.relu is True else x\n        return self.bnorm(x)\n\n\nclass CBHG(nn.Module):\n    def __init__(self, K, in_channels, channels, proj_channels, num_highways):\n        super().__init__()\n\n        # List of all rnns to call `flatten_parameters()` on\n        self._to_flatten = []\n\n        self.bank_kernels = [i for i in range(1, K + 1)]\n        self.conv1d_bank = nn.ModuleList()\n        for k in self.bank_kernels:\n            conv = BatchNormConv(in_channels, channels, k)\n            self.conv1d_bank.append(conv)\n\n        self.maxpool = nn.MaxPool1d(kernel_size=2, stride=1, padding=1)\n\n        self.conv_project1 = BatchNormConv(len(self.bank_kernels) * channels, proj_channels[0], 3)\n        self.conv_project2 = BatchNormConv(proj_channels[0], proj_channels[1], 3, relu=False)\n\n        # Fix the highway input if necessary\n        if proj_channels[-1] != channels:\n            self.highway_mismatch = True\n            self.pre_highway = nn.Linear(proj_channels[-1], channels, bias=False)\n        else:\n            self.highway_mismatch = False\n\n        self.highways = nn.ModuleList()\n        for i in range(num_highways):\n            hn = HighwayNetwork(channels)\n            self.highways.append(hn)\n\n        self.rnn = nn.GRU(channels, channels // 2, batch_first=True, bidirectional=True)\n        self._to_flatten.append(self.rnn)\n\n        # Avoid fragmentation of RNN parameters and associated warning\n        self._flatten_parameters()\n\n    def forward(self, x):\n        # Although we `_flatten_parameters()` on init, when using DataParallel\n        # the model gets replicated, making it no longer guaranteed that the\n        # weights are contiguous in GPU memory. Hence, we must call it again\n        self._flatten_parameters()\n\n        # Save these for later\n        residual = x\n        seq_len = x.size(-1)\n        conv_bank = []\n\n        # Convolution Bank\n        for conv in self.conv1d_bank:\n            c = conv(x) # Convolution\n            conv_bank.append(c[:, :, :seq_len])\n\n        # Stack along the channel axis\n        conv_bank = torch.cat(conv_bank, dim=1)\n\n        # dump the last padding to fit residual\n        x = self.maxpool(conv_bank)[:, :, :seq_len]\n\n        # Conv1d projections\n        x = self.conv_project1(x)\n        x = self.conv_project2(x)\n\n        # Residual Connect\n        x = x + residual\n\n        # Through the highways\n        x = x.transpose(1, 2)\n        if self.highway_mismatch is True:\n            x = self.pre_highway(x)\n        for h in self.highways: x = h(x)\n\n        # And then the RNN\n        x, _ = self.rnn(x)\n        return x\n\n    def _flatten_parameters(self):\n        \"\"\"Calls `flatten_parameters` on all the rnns used by the WaveRNN. Used\n        to improve efficiency and avoid PyTorch yelling at us.\"\"\"\n        [m.flatten_parameters() for m in self._to_flatten]\n\nclass PreNet(nn.Module):\n    def __init__(self, in_dims, fc1_dims=256, fc2_dims=128, dropout=0.5):\n        super().__init__()\n        self.fc1 = nn.Linear(in_dims, fc1_dims)\n        self.fc2 = nn.Linear(fc1_dims, fc2_dims)\n        self.p = dropout\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = F.relu(x)\n        x = F.dropout(x, self.p, training=True)\n        x = self.fc2(x)\n        x = F.relu(x)\n        x = F.dropout(x, self.p, training=True)\n        return x\n\n\nclass Attention(nn.Module):\n    def __init__(self, attn_dims):\n        super().__init__()\n        self.W = nn.Linear(attn_dims, attn_dims, bias=False)\n        self.v = nn.Linear(attn_dims, 1, bias=False)\n\n    def forward(self, encoder_seq_proj, query, t):\n\n        # print(encoder_seq_proj.shape)\n        # Transform the query vector\n        query_proj = self.W(query).unsqueeze(1)\n\n        # Compute the scores\n        u = self.v(torch.tanh(encoder_seq_proj + query_proj))\n        scores = F.softmax(u, dim=1)\n\n        return scores.transpose(1, 2)\n\n\nclass LSA(nn.Module):\n    def __init__(self, attn_dim, kernel_size=31, filters=32):\n        super().__init__()\n        self.conv = nn.Conv1d(1, filters, padding=(kernel_size - 1) // 2, kernel_size=kernel_size, bias=True)\n        self.L = nn.Linear(filters, attn_dim, bias=False)\n        self.W = nn.Linear(attn_dim, attn_dim, bias=True) # Include the attention bias in this term\n        self.v = nn.Linear(attn_dim, 1, bias=False)\n        self.cumulative = None\n        self.attention = None\n\n    def init_attention(self, encoder_seq_proj):\n        device = next(self.parameters()).device  # use same device as parameters\n        b, t, c = encoder_seq_proj.size()\n        self.cumulative = torch.zeros(b, t, device=device)\n        self.attention = torch.zeros(b, t, device=device)\n\n    def forward(self, encoder_seq_proj, query, t, chars):\n\n        if t == 0: self.init_attention(encoder_seq_proj)\n\n        processed_query = self.W(query).unsqueeze(1)\n\n        location = self.cumulative.unsqueeze(1)\n        processed_loc = self.L(self.conv(location).transpose(1, 2))\n\n        u = self.v(torch.tanh(processed_query + encoder_seq_proj + processed_loc))\n        u = u.squeeze(-1)\n\n        # Mask zero padding chars\n        u = u * (chars != 0).float()\n\n        # Smooth Attention\n        # scores = torch.sigmoid(u) / torch.sigmoid(u).sum(dim=1, keepdim=True)\n        scores = F.softmax(u, dim=1)\n        self.attention = scores\n        self.cumulative = self.cumulative + self.attention\n\n        return scores.unsqueeze(-1).transpose(1, 2)\n\n\nclass Decoder(nn.Module):\n    # Class variable because its value doesn't change between classes\n    # yet ought to be scoped by class because its a property of a Decoder\n    max_r = 20\n    def __init__(self, n_mels, encoder_dims, decoder_dims, lstm_dims,\n                 dropout, speaker_embedding_size):\n        super().__init__()\n        self.register_buffer(\"r\", torch.tensor(1, dtype=torch.int))\n        self.n_mels = n_mels\n        prenet_dims = (decoder_dims * 2, decoder_dims * 2)\n        self.prenet = PreNet(n_mels, fc1_dims=prenet_dims[0], fc2_dims=prenet_dims[1],\n                             dropout=dropout)\n        self.attn_net = LSA(decoder_dims)\n        self.attn_rnn = nn.GRUCell(encoder_dims + prenet_dims[1] + speaker_embedding_size, decoder_dims)\n        self.rnn_input = nn.Linear(encoder_dims + decoder_dims + speaker_embedding_size, lstm_dims)\n        self.res_rnn1 = nn.LSTMCell(lstm_dims, lstm_dims)\n        self.res_rnn2 = nn.LSTMCell(lstm_dims, lstm_dims)\n        self.mel_proj = nn.Linear(lstm_dims, n_mels * self.max_r, bias=False)\n        self.stop_proj = nn.Linear(encoder_dims + speaker_embedding_size + lstm_dims, 1)\n\n    def zoneout(self, prev, current, p=0.1):\n        device = next(self.parameters()).device  # Use same device as parameters\n        mask = torch.zeros(prev.size(), device=device).bernoulli_(p)\n        return prev * mask + current * (1 - mask)\n\n    def forward(self, encoder_seq, encoder_seq_proj, prenet_in,\n                hidden_states, cell_states, context_vec, t, chars):\n\n        # Need this for reshaping mels\n        batch_size = encoder_seq.size(0)\n\n        # Unpack the hidden and cell states\n        attn_hidden, rnn1_hidden, rnn2_hidden = hidden_states\n        rnn1_cell, rnn2_cell = cell_states\n\n        # PreNet for the Attention RNN\n        prenet_out = self.prenet(prenet_in)\n\n        # Compute the Attention RNN hidden state\n        attn_rnn_in = torch.cat([context_vec, prenet_out], dim=-1)\n        attn_hidden = self.attn_rnn(attn_rnn_in.squeeze(1), attn_hidden)\n\n        # Compute the attention scores\n        scores = self.attn_net(encoder_seq_proj, attn_hidden, t, chars)\n\n        # Dot product to create the context vector\n        context_vec = scores @ encoder_seq\n        context_vec = context_vec.squeeze(1)\n\n        # Concat Attention RNN output w. Context Vector & project\n        x = torch.cat([context_vec, attn_hidden], dim=1)\n        x = self.rnn_input(x)\n\n        # Compute first Residual RNN\n        rnn1_hidden_next, rnn1_cell = self.res_rnn1(x, (rnn1_hidden, rnn1_cell))\n        if self.training:\n            rnn1_hidden = self.zoneout(rnn1_hidden, rnn1_hidden_next)\n        else:\n            rnn1_hidden = rnn1_hidden_next\n        x = x + rnn1_hidden\n\n        # Compute second Residual RNN\n        rnn2_hidden_next, rnn2_cell = self.res_rnn2(x, (rnn2_hidden, rnn2_cell))\n        if self.training:\n            rnn2_hidden = self.zoneout(rnn2_hidden, rnn2_hidden_next)\n        else:\n            rnn2_hidden = rnn2_hidden_next\n        x = x + rnn2_hidden\n\n        # Project Mels\n        mels = self.mel_proj(x)\n        mels = mels.view(batch_size, self.n_mels, self.max_r)[:, :, :self.r]\n        hidden_states = (attn_hidden, rnn1_hidden, rnn2_hidden)\n        cell_states = (rnn1_cell, rnn2_cell)\n\n        # Stop token prediction\n        s = torch.cat((x, context_vec), dim=1)\n        s = self.stop_proj(s)\n        stop_tokens = torch.sigmoid(s)\n\n        return mels, scores, hidden_states, cell_states, context_vec, stop_tokens\n\n\nclass Tacotron(nn.Module):\n    def __init__(self, embed_dims, num_chars, encoder_dims, decoder_dims, n_mels, \n                 fft_bins, postnet_dims, encoder_K, lstm_dims, postnet_K, num_highways,\n                 dropout, stop_threshold, speaker_embedding_size):\n        super().__init__()\n        self.n_mels = n_mels\n        self.lstm_dims = lstm_dims\n        self.encoder_dims = encoder_dims\n        self.decoder_dims = decoder_dims\n        self.speaker_embedding_size = speaker_embedding_size\n        self.encoder = Encoder(embed_dims, num_chars, encoder_dims,\n                               encoder_K, num_highways, dropout)\n        self.encoder_proj = nn.Linear(encoder_dims + speaker_embedding_size, decoder_dims, bias=False)\n        self.decoder = Decoder(n_mels, encoder_dims, decoder_dims, lstm_dims,\n                               dropout, speaker_embedding_size)\n        self.postnet = CBHG(postnet_K, n_mels, postnet_dims,\n                            [postnet_dims, fft_bins], num_highways)\n        self.post_proj = nn.Linear(postnet_dims, fft_bins, bias=False)\n\n        self.init_model()\n        self.num_params()\n\n        self.register_buffer(\"step\", torch.zeros(1, dtype=torch.long))\n        self.register_buffer(\"stop_threshold\", torch.tensor(stop_threshold, dtype=torch.float32))\n\n    @property\n    def r(self):\n        return self.decoder.r.item()\n\n    @r.setter\n    def r(self, value):\n        self.decoder.r = self.decoder.r.new_tensor(value, requires_grad=False)\n\n    def forward(self, x, m, speaker_embedding):\n        device = next(self.parameters()).device  # use same device as parameters\n\n        self.step += 1\n        batch_size, _, steps  = m.size()\n\n        # Initialise all hidden states and pack into tuple\n        attn_hidden = torch.zeros(batch_size, self.decoder_dims, device=device)\n        rnn1_hidden = torch.zeros(batch_size, self.lstm_dims, device=device)\n        rnn2_hidden = torch.zeros(batch_size, self.lstm_dims, device=device)\n        hidden_states = (attn_hidden, rnn1_hidden, rnn2_hidden)\n\n        # Initialise all lstm cell states and pack into tuple\n        rnn1_cell = torch.zeros(batch_size, self.lstm_dims, device=device)\n        rnn2_cell = torch.zeros(batch_size, self.lstm_dims, device=device)\n        cell_states = (rnn1_cell, rnn2_cell)\n\n        # <GO> Frame for start of decoder loop\n        go_frame = torch.zeros(batch_size, self.n_mels, device=device)\n\n        # Need an initial context vector\n        context_vec = torch.zeros(batch_size, self.encoder_dims + self.speaker_embedding_size, device=device)\n\n        # SV2TTS: Run the encoder with the speaker embedding\n        # The projection avoids unnecessary matmuls in the decoder loop\n        encoder_seq = self.encoder(x, speaker_embedding)\n        encoder_seq_proj = self.encoder_proj(encoder_seq)\n\n        # Need a couple of lists for outputs\n        mel_outputs, attn_scores, stop_outputs = [], [], []\n\n        # Run the decoder loop\n        for t in range(0, steps, self.r):\n            prenet_in = m[:, :, t - 1] if t > 0 else go_frame\n            mel_frames, scores, hidden_states, cell_states, context_vec, stop_tokens = \\\n                self.decoder(encoder_seq, encoder_seq_proj, prenet_in,\n                             hidden_states, cell_states, context_vec, t, x)\n            mel_outputs.append(mel_frames)\n            attn_scores.append(scores)\n            stop_outputs.extend([stop_tokens] * self.r)\n\n        # Concat the mel outputs into sequence\n        mel_outputs = torch.cat(mel_outputs, dim=2)\n\n        # Post-Process for Linear Spectrograms\n        postnet_out = self.postnet(mel_outputs)\n        linear = self.post_proj(postnet_out)\n        linear = linear.transpose(1, 2)\n\n        # For easy visualisation\n        attn_scores = torch.cat(attn_scores, 1)\n        # attn_scores = attn_scores.cpu().data.numpy()\n        stop_outputs = torch.cat(stop_outputs, 1)\n\n        return mel_outputs, linear, attn_scores, stop_outputs\n\n    def generate(self, x, speaker_embedding=None, steps=2000):\n        self.eval()\n        device = next(self.parameters()).device  # use same device as parameters\n\n        batch_size, _  = x.size()\n\n        # Need to initialise all hidden states and pack into tuple for tidyness\n        attn_hidden = torch.zeros(batch_size, self.decoder_dims, device=device)\n        rnn1_hidden = torch.zeros(batch_size, self.lstm_dims, device=device)\n        rnn2_hidden = torch.zeros(batch_size, self.lstm_dims, device=device)\n        hidden_states = (attn_hidden, rnn1_hidden, rnn2_hidden)\n\n        # Need to initialise all lstm cell states and pack into tuple for tidyness\n        rnn1_cell = torch.zeros(batch_size, self.lstm_dims, device=device)\n        rnn2_cell = torch.zeros(batch_size, self.lstm_dims, device=device)\n        cell_states = (rnn1_cell, rnn2_cell)\n\n        # Need a <GO> Frame for start of decoder loop\n        go_frame = torch.zeros(batch_size, self.n_mels, device=device)\n\n        # Need an initial context vector\n        context_vec = torch.zeros(batch_size, self.encoder_dims + self.speaker_embedding_size, device=device)\n\n        # SV2TTS: Run the encoder with the speaker embedding\n        # The projection avoids unnecessary matmuls in the decoder loop\n        encoder_seq = self.encoder(x, speaker_embedding)\n        encoder_seq_proj = self.encoder_proj(encoder_seq)\n\n        # Need a couple of lists for outputs\n        mel_outputs, attn_scores, stop_outputs = [], [], []\n\n        # Run the decoder loop\n        for t in range(0, steps, self.r):\n            prenet_in = mel_outputs[-1][:, :, -1] if t > 0 else go_frame\n            mel_frames, scores, hidden_states, cell_states, context_vec, stop_tokens = \\\n            self.decoder(encoder_seq, encoder_seq_proj, prenet_in,\n                         hidden_states, cell_states, context_vec, t, x)\n            mel_outputs.append(mel_frames)\n            attn_scores.append(scores)\n            stop_outputs.extend([stop_tokens] * self.r)\n            # Stop the loop when all stop tokens in batch exceed threshold\n            if (stop_tokens > 0.5).all() and t > 10: break\n\n        # Concat the mel outputs into sequence\n        mel_outputs = torch.cat(mel_outputs, dim=2)\n\n        # Post-Process for Linear Spectrograms\n        postnet_out = self.postnet(mel_outputs)\n        linear = self.post_proj(postnet_out)\n\n\n        linear = linear.transpose(1, 2)\n\n        # For easy visualisation\n        attn_scores = torch.cat(attn_scores, 1)\n        stop_outputs = torch.cat(stop_outputs, 1)\n\n        self.train()\n\n        return mel_outputs, linear, attn_scores\n\n    def init_model(self):\n        for p in self.parameters():\n            if p.dim() > 1: nn.init.xavier_uniform_(p)\n\n    def get_step(self):\n        return self.step.data.item()\n\n    def reset_step(self):\n        # assignment to parameters or buffers is overloaded, updates internal dict entry\n        self.step = self.step.data.new_tensor(1)\n\n    def log(self, path, msg):\n        with open(path, \"a\") as f:\n            print(msg, file=f)\n\n    def load(self, path, optimizer=None):\n        # Use device of model params as location for loaded state\n        device = next(self.parameters()).device\n        checkpoint = torch.load(str(path), map_location=device)\n        self.load_state_dict(checkpoint[\"model_state\"])\n\n        if \"optimizer_state\" in checkpoint and optimizer is not None:\n            optimizer.load_state_dict(checkpoint[\"optimizer_state\"])\n\n    def save(self, path, optimizer=None):\n        if optimizer is not None:\n            torch.save({\n                \"model_state\": self.state_dict(),\n                \"optimizer_state\": optimizer.state_dict(),\n            }, str(path))\n        else:\n            torch.save({\n                \"model_state\": self.state_dict(),\n            }, str(path))\n\n\n    def num_params(self, print_out=True):\n        parameters = filter(lambda p: p.requires_grad, self.parameters())\n        parameters = sum([np.prod(p.size()) for p in parameters]) / 1_000_000\n        if print_out:\n            print(\"Trainable Parameters: %.3fM\" % parameters)\n        return parameters\n", "synthesizer/utils/_cmudict.py": "import re\n\nvalid_symbols = [\n  \"AA\", \"AA0\", \"AA1\", \"AA2\", \"AE\", \"AE0\", \"AE1\", \"AE2\", \"AH\", \"AH0\", \"AH1\", \"AH2\",\n  \"AO\", \"AO0\", \"AO1\", \"AO2\", \"AW\", \"AW0\", \"AW1\", \"AW2\", \"AY\", \"AY0\", \"AY1\", \"AY2\",\n  \"B\", \"CH\", \"D\", \"DH\", \"EH\", \"EH0\", \"EH1\", \"EH2\", \"ER\", \"ER0\", \"ER1\", \"ER2\", \"EY\",\n  \"EY0\", \"EY1\", \"EY2\", \"F\", \"G\", \"HH\", \"IH\", \"IH0\", \"IH1\", \"IH2\", \"IY\", \"IY0\", \"IY1\",\n  \"IY2\", \"JH\", \"K\", \"L\", \"M\", \"N\", \"NG\", \"OW\", \"OW0\", \"OW1\", \"OW2\", \"OY\", \"OY0\",\n  \"OY1\", \"OY2\", \"P\", \"R\", \"S\", \"SH\", \"T\", \"TH\", \"UH\", \"UH0\", \"UH1\", \"UH2\", \"UW\",\n  \"UW0\", \"UW1\", \"UW2\", \"V\", \"W\", \"Y\", \"Z\", \"ZH\"\n]\n\n_valid_symbol_set = set(valid_symbols)\n\n\nclass CMUDict:\n  \"\"\"Thin wrapper around CMUDict data. http://www.speech.cs.cmu.edu/cgi-bin/cmudict\"\"\"\n  def __init__(self, file_or_path, keep_ambiguous=True):\n    if isinstance(file_or_path, str):\n      with open(file_or_path, encoding=\"latin-1\") as f:\n        entries = _parse_cmudict(f)\n    else:\n      entries = _parse_cmudict(file_or_path)\n    if not keep_ambiguous:\n      entries = {word: pron for word, pron in entries.items() if len(pron) == 1}\n    self._entries = entries\n\n\n  def __len__(self):\n    return len(self._entries)\n\n\n  def lookup(self, word):\n    \"\"\"Returns list of ARPAbet pronunciations of the given word.\"\"\"\n    return self._entries.get(word.upper())\n\n\n\n_alt_re = re.compile(r\"\\([0-9]+\\)\")\n\n\ndef _parse_cmudict(file):\n  cmudict = {}\n  for line in file:\n    if len(line) and (line[0] >= \"A\" and line[0] <= \"Z\" or line[0] == \"'\"):\n      parts = line.split(\"  \")\n      word = re.sub(_alt_re, \"\", parts[0])\n      pronunciation = _get_pronunciation(parts[1])\n      if pronunciation:\n        if word in cmudict:\n          cmudict[word].append(pronunciation)\n        else:\n          cmudict[word] = [pronunciation]\n  return cmudict\n\n\ndef _get_pronunciation(s):\n  parts = s.strip().split(\" \")\n  for part in parts:\n    if part not in _valid_symbol_set:\n      return None\n  return \" \".join(parts)\n", "synthesizer/utils/plot.py": "import numpy as np\n\n\ndef split_title_line(title_text, max_words=5):\n\t\"\"\"\n\tA function that splits any string based on specific character\n\t(returning it with the string), with maximum number of words on it\n\t\"\"\"\n\tseq = title_text.split()\n\treturn \"\\n\".join([\" \".join(seq[i:i + max_words]) for i in range(0, len(seq), max_words)])\n\n\ndef plot_alignment(alignment, path, title=None, split_title=False, max_len=None):\n\timport matplotlib\n\tmatplotlib.use(\"Agg\")\n\timport matplotlib.pyplot as plt\n\n\tif max_len is not None:\n\t\talignment = alignment[:, :max_len]\n\n\tfig = plt.figure(figsize=(8, 6))\n\tax = fig.add_subplot(111)\n\n\tim = ax.imshow(\n\t\talignment,\n\t\taspect=\"auto\",\n\t\torigin=\"lower\",\n\t\tinterpolation=\"none\")\n\tfig.colorbar(im, ax=ax)\n\txlabel = \"Decoder timestep\"\n\n\tif split_title:\n\t\ttitle = split_title_line(title)\n\n\tplt.xlabel(xlabel)\n\tplt.title(title)\n\tplt.ylabel(\"Encoder timestep\")\n\tplt.tight_layout()\n\tplt.savefig(path, format=\"png\")\n\tplt.close()\n\n\ndef plot_spectrogram(pred_spectrogram, path, title=None, split_title=False, target_spectrogram=None, max_len=None, auto_aspect=False):\n\timport matplotlib\n\tmatplotlib.use(\"Agg\")\n\timport matplotlib.pyplot as plt\n\n\tif max_len is not None:\n\t\ttarget_spectrogram = target_spectrogram[:max_len]\n\t\tpred_spectrogram = pred_spectrogram[:max_len]\n\n\tif split_title:\n\t\ttitle = split_title_line(title)\n\n\tfig = plt.figure(figsize=(10, 8))\n\t# Set common labels\n\tfig.text(0.5, 0.18, title, horizontalalignment=\"center\", fontsize=16)\n\n\t#target spectrogram subplot\n\tif target_spectrogram is not None:\n\t\tax1 = fig.add_subplot(311)\n\t\tax2 = fig.add_subplot(312)\n\n\t\tif auto_aspect:\n\t\t\tim = ax1.imshow(np.rot90(target_spectrogram), aspect=\"auto\", interpolation=\"none\")\n\t\telse:\n\t\t\tim = ax1.imshow(np.rot90(target_spectrogram), interpolation=\"none\")\n\t\tax1.set_title(\"Target Mel-Spectrogram\")\n\t\tfig.colorbar(mappable=im, shrink=0.65, orientation=\"horizontal\", ax=ax1)\n\t\tax2.set_title(\"Predicted Mel-Spectrogram\")\n\telse:\n\t\tax2 = fig.add_subplot(211)\n\n\tif auto_aspect:\n\t\tim = ax2.imshow(np.rot90(pred_spectrogram), aspect=\"auto\", interpolation=\"none\")\n\telse:\n\t\tim = ax2.imshow(np.rot90(pred_spectrogram), interpolation=\"none\")\n\tfig.colorbar(mappable=im, shrink=0.65, orientation=\"horizontal\", ax=ax2)\n\n\tplt.tight_layout()\n\tplt.savefig(path, format=\"png\")\n\tplt.close()\n", "synthesizer/utils/symbols.py": "\"\"\"\nDefines the set of symbols used in text input to the model.\n\nThe default is a set of ASCII characters that works well for English or text that has been run\nthrough Unidecode. For other data, you can modify _characters. See TRAINING_DATA.md for details.\n\"\"\"\n# from . import cmudict\n\n_pad        = \"_\"\n_eos        = \"~\"\n_characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!\\'\\\"(),-.:;? \"\n\n# Prepend \"@\" to ARPAbet symbols to ensure uniqueness (some are the same as uppercase letters):\n#_arpabet = [\"@' + s for s in cmudict.valid_symbols]\n\n# Export all symbols:\nsymbols = [_pad, _eos] + list(_characters) #+ _arpabet\n", "synthesizer/utils/cleaners.py": "\"\"\"\nCleaners are transformations that run over the input text at both training and eval time.\n\nCleaners can be selected by passing a comma-delimited list of cleaner names as the \"cleaners\"\nhyperparameter. Some cleaners are English-specific. You\"ll typically want to use:\n  1. \"english_cleaners\" for English text\n  2. \"transliteration_cleaners\" for non-English text that can be transliterated to ASCII using\n     the Unidecode library (https://pypi.python.org/pypi/Unidecode)\n  3. \"basic_cleaners\" if you do not want to transliterate (in this case, you should also update\n     the symbols in symbols.py to match your data).\n\"\"\"\nimport re\nfrom unidecode import unidecode\nfrom synthesizer.utils.numbers import normalize_numbers\n\n\n# Regular expression matching whitespace:\n_whitespace_re = re.compile(r\"\\s+\")\n\n# List of (regular expression, replacement) pairs for abbreviations:\n_abbreviations = [(re.compile(\"\\\\b%s\\\\.\" % x[0], re.IGNORECASE), x[1]) for x in [\n    (\"mrs\", \"misess\"),\n    (\"mr\", \"mister\"),\n    (\"dr\", \"doctor\"),\n    (\"st\", \"saint\"),\n    (\"co\", \"company\"),\n    (\"jr\", \"junior\"),\n    (\"maj\", \"major\"),\n    (\"gen\", \"general\"),\n    (\"drs\", \"doctors\"),\n    (\"rev\", \"reverend\"),\n    (\"lt\", \"lieutenant\"),\n    (\"hon\", \"honorable\"),\n    (\"sgt\", \"sergeant\"),\n    (\"capt\", \"captain\"),\n    (\"esq\", \"esquire\"),\n    (\"ltd\", \"limited\"),\n    (\"col\", \"colonel\"),\n    (\"ft\", \"fort\"),\n]]\n\n\ndef expand_abbreviations(text):\n    for regex, replacement in _abbreviations:\n        text = re.sub(regex, replacement, text)\n    return text\n\n\ndef expand_numbers(text):\n    return normalize_numbers(text)\n\n\ndef lowercase(text):\n    \"\"\"lowercase input tokens.\"\"\"\n    return text.lower()\n\n\ndef collapse_whitespace(text):\n    return re.sub(_whitespace_re, \" \", text)\n\n\ndef convert_to_ascii(text):\n    return unidecode(text)\n\n\ndef basic_cleaners(text):\n    \"\"\"Basic pipeline that lowercases and collapses whitespace without transliteration.\"\"\"\n    text = lowercase(text)\n    text = collapse_whitespace(text)\n    return text\n\n\ndef transliteration_cleaners(text):\n    \"\"\"Pipeline for non-English text that transliterates to ASCII.\"\"\"\n    text = convert_to_ascii(text)\n    text = lowercase(text)\n    text = collapse_whitespace(text)\n    return text\n\n\ndef english_cleaners(text):\n    \"\"\"Pipeline for English text, including number and abbreviation expansion.\"\"\"\n    text = convert_to_ascii(text)\n    text = lowercase(text)\n    text = expand_numbers(text)\n    text = expand_abbreviations(text)\n    text = collapse_whitespace(text)\n    return text\n", "synthesizer/utils/__init__.py": "import torch\n\n\n_output_ref = None\n_replicas_ref = None\n\ndef data_parallel_workaround(model, *input):\n    global _output_ref\n    global _replicas_ref\n    device_ids = list(range(torch.cuda.device_count()))\n    output_device = device_ids[0]\n    replicas = torch.nn.parallel.replicate(model, device_ids)\n    # input.shape = (num_args, batch, ...)\n    inputs = torch.nn.parallel.scatter(input, device_ids)\n    # inputs.shape = (num_gpus, num_args, batch/num_gpus, ...)\n    replicas = replicas[:len(inputs)]\n    outputs = torch.nn.parallel.parallel_apply(replicas, inputs)\n    y_hat = torch.nn.parallel.gather(outputs, output_device)\n    _output_ref = outputs\n    _replicas_ref = replicas\n    return y_hat\n\n\nclass ValueWindow():\n  def __init__(self, window_size=100):\n    self._window_size = window_size\n    self._values = []\n\n  def append(self, x):\n    self._values = self._values[-(self._window_size - 1):] + [x]\n\n  @property\n  def sum(self):\n    return sum(self._values)\n\n  @property\n  def count(self):\n    return len(self._values)\n\n  @property\n  def average(self):\n    return self.sum / max(1, self.count)\n\n  def reset(self):\n    self._values = []\n", "synthesizer/utils/text.py": "from synthesizer.utils.symbols import symbols\nfrom synthesizer.utils import cleaners\nimport re\n\n\n# Mappings from symbol to numeric ID and vice versa:\n_symbol_to_id = {s: i for i, s in enumerate(symbols)}\n_id_to_symbol = {i: s for i, s in enumerate(symbols)}\n\n# Regular expression matching text enclosed in curly braces:\n_curly_re = re.compile(r\"(.*?)\\{(.+?)\\}(.*)\")\n\n\ndef text_to_sequence(text, cleaner_names):\n    \"\"\"Converts a string of text to a sequence of IDs corresponding to the symbols in the text.\n\n      The text can optionally have ARPAbet sequences enclosed in curly braces embedded\n      in it. For example, \"Turn left on {HH AW1 S S T AH0 N} Street.\"\n\n      Args:\n        text: string to convert to a sequence\n        cleaner_names: names of the cleaner functions to run the text through\n\n      Returns:\n        List of integers corresponding to the symbols in the text\n    \"\"\"\n    sequence = []\n\n    # Check for curly braces and treat their contents as ARPAbet:\n    while len(text):\n        m = _curly_re.match(text)\n        if not m:\n            sequence += _symbols_to_sequence(_clean_text(text, cleaner_names))\n            break\n        sequence += _symbols_to_sequence(_clean_text(m.group(1), cleaner_names))\n        sequence += _arpabet_to_sequence(m.group(2))\n        text = m.group(3)\n\n    # Append EOS token\n    sequence.append(_symbol_to_id[\"~\"])\n    return sequence\n\n\ndef sequence_to_text(sequence):\n    \"\"\"Converts a sequence of IDs back to a string\"\"\"\n    result = \"\"\n    for symbol_id in sequence:\n        if symbol_id in _id_to_symbol:\n            s = _id_to_symbol[symbol_id]\n            # Enclose ARPAbet back in curly braces:\n            if len(s) > 1 and s[0] == \"@\":\n                s = \"{%s}\" % s[1:]\n            result += s\n    return result.replace(\"}{\", \" \")\n\n\ndef _clean_text(text, cleaner_names):\n    for name in cleaner_names:\n        cleaner = getattr(cleaners, name)\n        if not cleaner:\n            raise Exception(\"Unknown cleaner: %s\" % name)\n        text = cleaner(text)\n    return text\n\n\ndef _symbols_to_sequence(symbols):\n    return [_symbol_to_id[s] for s in symbols if _should_keep_symbol(s)]\n\n\ndef _arpabet_to_sequence(text):\n    return _symbols_to_sequence([\"@\" + s for s in text.split()])\n\n\ndef _should_keep_symbol(s):\n    return s in _symbol_to_id and s not in (\"_\", \"~\")\n", "synthesizer/utils/numbers.py": "import re\nimport inflect\n\n\n_inflect = inflect.engine()\n_comma_number_re = re.compile(r\"([0-9][0-9\\,]+[0-9])\")\n_decimal_number_re = re.compile(r\"([0-9]+\\.[0-9]+)\")\n_pounds_re = re.compile(r\"\u00a3([0-9\\,]*[0-9]+)\")\n_dollars_re = re.compile(r\"\\$([0-9\\.\\,]*[0-9]+)\")\n_ordinal_re = re.compile(r\"[0-9]+(st|nd|rd|th)\")\n_number_re = re.compile(r\"[0-9]+\")\n\n\ndef _remove_commas(m):\n    return m.group(1).replace(\",\", \"\")\n\n\ndef _expand_decimal_point(m):\n    return m.group(1).replace(\".\", \" point \")\n\n\ndef _expand_dollars(m):\n    match = m.group(1)\n    parts = match.split(\".\")\n    if len(parts) > 2:\n        return match + \" dollars\"  # Unexpected format\n    dollars = int(parts[0]) if parts[0] else 0\n    cents = int(parts[1]) if len(parts) > 1 and parts[1] else 0\n    if dollars and cents:\n        dollar_unit = \"dollar\" if dollars == 1 else \"dollars\"\n        cent_unit = \"cent\" if cents == 1 else \"cents\"\n        return \"%s %s, %s %s\" % (dollars, dollar_unit, cents, cent_unit)\n    elif dollars:\n        dollar_unit = \"dollar\" if dollars == 1 else \"dollars\"\n        return \"%s %s\" % (dollars, dollar_unit)\n    elif cents:\n        cent_unit = \"cent\" if cents == 1 else \"cents\"\n        return \"%s %s\" % (cents, cent_unit)\n    else:\n        return \"zero dollars\"\n\n\ndef _expand_ordinal(m):\n    return _inflect.number_to_words(m.group(0))\n\n\ndef _expand_number(m):\n    num = int(m.group(0))\n    if num > 1000 and num < 3000:\n        if num == 2000:\n            return \"two thousand\"\n        elif num > 2000 and num < 2010:\n            return \"two thousand \" + _inflect.number_to_words(num % 100)\n        elif num % 100 == 0:\n            return _inflect.number_to_words(num // 100) + \" hundred\"\n        else:\n            return _inflect.number_to_words(num, andword=\"\", zero=\"oh\", group=2).replace(\", \", \" \")\n    else:\n        return _inflect.number_to_words(num, andword=\"\")\n\n\ndef normalize_numbers(text):\n    text = re.sub(_comma_number_re, _remove_commas, text)\n    text = re.sub(_pounds_re, r\"\\1 pounds\", text)\n    text = re.sub(_dollars_re, _expand_dollars, text)\n    text = re.sub(_decimal_number_re, _expand_decimal_point, text)\n    text = re.sub(_ordinal_re, _expand_ordinal, text)\n    text = re.sub(_number_re, _expand_number, text)\n    return text\n", "vocoder/display.py": "import time\nimport numpy as np\nimport sys\n\n\ndef progbar(i, n, size=16):\n    done = (i * size) // n\n    bar = ''\n    for i in range(size):\n        bar += '\u2588' if i <= done else '\u2591'\n    return bar\n\n\ndef stream(message) :\n    try:\n        sys.stdout.write(\"\\r{%s}\" % message)\n    except:\n        #Remove non-ASCII characters from message\n        message = ''.join(i for i in message if ord(i)<128)\n        sys.stdout.write(\"\\r{%s}\" % message)\n\n\ndef simple_table(item_tuples) :\n\n    border_pattern = '+---------------------------------------'\n    whitespace = '                                            '\n\n    headings, cells, = [], []\n\n    for item in item_tuples :\n\n        heading, cell = str(item[0]), str(item[1])\n\n        pad_head = True if len(heading) < len(cell) else False\n\n        pad = abs(len(heading) - len(cell))\n        pad = whitespace[:pad]\n\n        pad_left = pad[:len(pad)//2]\n        pad_right = pad[len(pad)//2:]\n\n        if pad_head :\n            heading = pad_left + heading + pad_right\n        else :\n            cell = pad_left + cell + pad_right\n\n        headings += [heading]\n        cells += [cell]\n\n    border, head, body = '', '', ''\n\n    for i in range(len(item_tuples)) :\n\n        temp_head = f'| {headings[i]} '\n        temp_body = f'| {cells[i]} '\n\n        border += border_pattern[:len(temp_head)]\n        head += temp_head\n        body += temp_body\n\n        if i == len(item_tuples) - 1 :\n            head += '|'\n            body += '|'\n            border += '+'\n\n    print(border)\n    print(head)\n    print(border)\n    print(body)\n    print(border)\n    print(' ')\n\n\ndef time_since(started) :\n    elapsed = time.time() - started\n    m = int(elapsed // 60)\n    s = int(elapsed % 60)\n    if m >= 60 :\n        h = int(m // 60)\n        m = m % 60\n        return f'{h}h {m}m {s}s'\n    else :\n        return f'{m}m {s}s'\n\n\ndef save_attention(attn, path):\n    import matplotlib.pyplot as plt\n\n    fig = plt.figure(figsize=(12, 6))\n    plt.imshow(attn.T, interpolation='nearest', aspect='auto')\n    fig.savefig(f'{path}.png', bbox_inches='tight')\n    plt.close(fig)\n\n\ndef save_spectrogram(M, path, length=None):\n    import matplotlib.pyplot as plt\n\n    M = np.flip(M, axis=0)\n    if length : M = M[:, :length]\n    fig = plt.figure(figsize=(12, 6))\n    plt.imshow(M, interpolation='nearest', aspect='auto')\n    fig.savefig(f'{path}.png', bbox_inches='tight')\n    plt.close(fig)\n\n\ndef plot(array):\n    import matplotlib.pyplot as plt\n\n    fig = plt.figure(figsize=(30, 5))\n    ax = fig.add_subplot(111)\n    ax.xaxis.label.set_color('grey')\n    ax.yaxis.label.set_color('grey')\n    ax.xaxis.label.set_fontsize(23)\n    ax.yaxis.label.set_fontsize(23)\n    ax.tick_params(axis='x', colors='grey', labelsize=23)\n    ax.tick_params(axis='y', colors='grey', labelsize=23)\n    plt.plot(array)\n\n\ndef plot_spec(M):\n    import matplotlib.pyplot as plt\n\n    M = np.flip(M, axis=0)\n    plt.figure(figsize=(18,4))\n    plt.imshow(M, interpolation='nearest', aspect='auto')\n    plt.show()\n\n", "vocoder/train.py": "import time\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom torch import optim\nfrom torch.utils.data import DataLoader\n\nimport vocoder.hparams as hp\nfrom vocoder.display import stream, simple_table\nfrom vocoder.distribution import discretized_mix_logistic_loss\nfrom vocoder.gen_wavernn import gen_testset\nfrom vocoder.models.fatchord_version import WaveRNN\nfrom vocoder.vocoder_dataset import VocoderDataset, collate_vocoder\n\n\ndef train(run_id: str, syn_dir: Path, voc_dir: Path, models_dir: Path, ground_truth: bool, save_every: int,\n          backup_every: int, force_restart: bool):\n    # Check to make sure the hop length is correctly factorised\n    assert np.cumprod(hp.voc_upsample_factors)[-1] == hp.hop_length\n\n    # Instantiate the model\n    print(\"Initializing the model...\")\n    model = WaveRNN(\n        rnn_dims=hp.voc_rnn_dims,\n        fc_dims=hp.voc_fc_dims,\n        bits=hp.bits,\n        pad=hp.voc_pad,\n        upsample_factors=hp.voc_upsample_factors,\n        feat_dims=hp.num_mels,\n        compute_dims=hp.voc_compute_dims,\n        res_out_dims=hp.voc_res_out_dims,\n        res_blocks=hp.voc_res_blocks,\n        hop_length=hp.hop_length,\n        sample_rate=hp.sample_rate,\n        mode=hp.voc_mode\n    )\n\n    if torch.cuda.is_available():\n        model = model.cuda()\n\n    # Initialize the optimizer\n    optimizer = optim.Adam(model.parameters())\n    for p in optimizer.param_groups:\n        p[\"lr\"] = hp.voc_lr\n    loss_func = F.cross_entropy if model.mode == \"RAW\" else discretized_mix_logistic_loss\n\n    # Load the weights\n    model_dir = models_dir / run_id\n    model_dir.mkdir(exist_ok=True)\n    weights_fpath = model_dir / \"vocoder.pt\"\n    if force_restart or not weights_fpath.exists():\n        print(\"\\nStarting the training of WaveRNN from scratch\\n\")\n        model.save(weights_fpath, optimizer)\n    else:\n        print(\"\\nLoading weights at %s\" % weights_fpath)\n        model.load(weights_fpath, optimizer)\n        print(\"WaveRNN weights loaded from step %d\" % model.step)\n\n    # Initialize the dataset\n    metadata_fpath = syn_dir.joinpath(\"train.txt\") if ground_truth else \\\n        voc_dir.joinpath(\"synthesized.txt\")\n    mel_dir = syn_dir.joinpath(\"mels\") if ground_truth else voc_dir.joinpath(\"mels_gta\")\n    wav_dir = syn_dir.joinpath(\"audio\")\n    dataset = VocoderDataset(metadata_fpath, mel_dir, wav_dir)\n    test_loader = DataLoader(dataset, batch_size=1, shuffle=True)\n\n    # Begin the training\n    simple_table([('Batch size', hp.voc_batch_size),\n                  ('LR', hp.voc_lr),\n                  ('Sequence Len', hp.voc_seq_len)])\n\n    for epoch in range(1, 350):\n        data_loader = DataLoader(dataset, hp.voc_batch_size, shuffle=True, num_workers=2, collate_fn=collate_vocoder)\n        start = time.time()\n        running_loss = 0.\n\n        for i, (x, y, m) in enumerate(data_loader, 1):\n            if torch.cuda.is_available():\n                x, m, y = x.cuda(), m.cuda(), y.cuda()\n\n            # Forward pass\n            y_hat = model(x, m)\n            if model.mode == 'RAW':\n                y_hat = y_hat.transpose(1, 2).unsqueeze(-1)\n            elif model.mode == 'MOL':\n                y = y.float()\n            y = y.unsqueeze(-1)\n\n            # Backward pass\n            loss = loss_func(y_hat, y)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item()\n            speed = i / (time.time() - start)\n            avg_loss = running_loss / i\n\n            step = model.get_step()\n            k = step // 1000\n\n            if backup_every != 0 and step % backup_every == 0 :\n                model.checkpoint(model_dir, optimizer)\n\n            if save_every != 0 and step % save_every == 0 :\n                model.save(weights_fpath, optimizer)\n\n            msg = f\"| Epoch: {epoch} ({i}/{len(data_loader)}) | \" \\\n                f\"Loss: {avg_loss:.4f} | {speed:.1f} \" \\\n                f\"steps/s | Step: {k}k | \"\n            stream(msg)\n\n\n        gen_testset(model, test_loader, hp.voc_gen_at_checkpoint, hp.voc_gen_batched,\n                    hp.voc_target, hp.voc_overlap, model_dir)\n        print(\"\")\n", "vocoder/distribution.py": "import numpy as np\nimport torch\nimport torch.nn.functional as F\n\n\ndef log_sum_exp(x):\n    \"\"\" numerically stable log_sum_exp implementation that prevents overflow \"\"\"\n    # TF ordering\n    axis = len(x.size()) - 1\n    m, _ = torch.max(x, dim=axis)\n    m2, _ = torch.max(x, dim=axis, keepdim=True)\n    return m + torch.log(torch.sum(torch.exp(x - m2), dim=axis))\n\n\n# It is adapted from https://github.com/r9y9/wavenet_vocoder/blob/master/wavenet_vocoder/mixture.py\ndef discretized_mix_logistic_loss(y_hat, y, num_classes=65536,\n                                  log_scale_min=None, reduce=True):\n    if log_scale_min is None:\n        log_scale_min = float(np.log(1e-14))\n    y_hat = y_hat.permute(0,2,1)\n    assert y_hat.dim() == 3\n    assert y_hat.size(1) % 3 == 0\n    nr_mix = y_hat.size(1) // 3\n\n    # (B x T x C)\n    y_hat = y_hat.transpose(1, 2)\n\n    # unpack parameters. (B, T, num_mixtures) x 3\n    logit_probs = y_hat[:, :, :nr_mix]\n    means = y_hat[:, :, nr_mix:2 * nr_mix]\n    log_scales = torch.clamp(y_hat[:, :, 2 * nr_mix:3 * nr_mix], min=log_scale_min)\n\n    # B x T x 1 -> B x T x num_mixtures\n    y = y.expand_as(means)\n\n    centered_y = y - means\n    inv_stdv = torch.exp(-log_scales)\n    plus_in = inv_stdv * (centered_y + 1. / (num_classes - 1))\n    cdf_plus = torch.sigmoid(plus_in)\n    min_in = inv_stdv * (centered_y - 1. / (num_classes - 1))\n    cdf_min = torch.sigmoid(min_in)\n\n    # log probability for edge case of 0 (before scaling)\n    # equivalent: torch.log(F.sigmoid(plus_in))\n    log_cdf_plus = plus_in - F.softplus(plus_in)\n\n    # log probability for edge case of 255 (before scaling)\n    # equivalent: (1 - F.sigmoid(min_in)).log()\n    log_one_minus_cdf_min = -F.softplus(min_in)\n\n    # probability for all other cases\n    cdf_delta = cdf_plus - cdf_min\n\n    mid_in = inv_stdv * centered_y\n    # log probability in the center of the bin, to be used in extreme cases\n    # (not actually used in our code)\n    log_pdf_mid = mid_in - log_scales - 2. * F.softplus(mid_in)\n\n    # tf equivalent\n    \"\"\"\n    log_probs = tf.where(x < -0.999, log_cdf_plus,\n                         tf.where(x > 0.999, log_one_minus_cdf_min,\n                                  tf.where(cdf_delta > 1e-5,\n                                           tf.log(tf.maximum(cdf_delta, 1e-12)),\n                                           log_pdf_mid - np.log(127.5))))\n    \"\"\"\n    # TODO: cdf_delta <= 1e-5 actually can happen. How can we choose the value\n    # for num_classes=65536 case? 1e-7? not sure..\n    inner_inner_cond = (cdf_delta > 1e-5).float()\n\n    inner_inner_out = inner_inner_cond * \\\n        torch.log(torch.clamp(cdf_delta, min=1e-12)) + \\\n        (1. - inner_inner_cond) * (log_pdf_mid - np.log((num_classes - 1) / 2))\n    inner_cond = (y > 0.999).float()\n    inner_out = inner_cond * log_one_minus_cdf_min + (1. - inner_cond) * inner_inner_out\n    cond = (y < -0.999).float()\n    log_probs = cond * log_cdf_plus + (1. - cond) * inner_out\n\n    log_probs = log_probs + F.log_softmax(logit_probs, -1)\n\n    if reduce:\n        return -torch.mean(log_sum_exp(log_probs))\n    else:\n        return -log_sum_exp(log_probs).unsqueeze(-1)\n\n\ndef sample_from_discretized_mix_logistic(y, log_scale_min=None):\n    \"\"\"\n    Sample from discretized mixture of logistic distributions\n    Args:\n        y (Tensor): B x C x T\n        log_scale_min (float): Log scale minimum value\n    Returns:\n        Tensor: sample in range of [-1, 1].\n    \"\"\"\n    if log_scale_min is None:\n        log_scale_min = float(np.log(1e-14))\n    assert y.size(1) % 3 == 0\n    nr_mix = y.size(1) // 3\n\n    # B x T x C\n    y = y.transpose(1, 2)\n    logit_probs = y[:, :, :nr_mix]\n\n    # sample mixture indicator from softmax\n    temp = logit_probs.data.new(logit_probs.size()).uniform_(1e-5, 1.0 - 1e-5)\n    temp = logit_probs.data - torch.log(- torch.log(temp))\n    _, argmax = temp.max(dim=-1)\n\n    # (B, T) -> (B, T, nr_mix)\n    one_hot = to_one_hot(argmax, nr_mix)\n    # select logistic parameters\n    means = torch.sum(y[:, :, nr_mix:2 * nr_mix] * one_hot, dim=-1)\n    log_scales = torch.clamp(torch.sum(\n        y[:, :, 2 * nr_mix:3 * nr_mix] * one_hot, dim=-1), min=log_scale_min)\n    # sample from logistic & clip to interval\n    # we don't actually round to the nearest 8bit value when sampling\n    u = means.data.new(means.size()).uniform_(1e-5, 1.0 - 1e-5)\n    x = means + torch.exp(log_scales) * (torch.log(u) - torch.log(1. - u))\n\n    x = torch.clamp(torch.clamp(x, min=-1.), max=1.)\n\n    return x\n\n\ndef to_one_hot(tensor, n, fill_with=1.):\n    # we perform one hot encore with respect to the last axis\n    one_hot = torch.FloatTensor(tensor.size() + (n,)).zero_()\n    if tensor.is_cuda:\n        one_hot = one_hot.cuda()\n    one_hot.scatter_(len(tensor.size()), tensor.unsqueeze(-1), fill_with)\n    return one_hot\n", "vocoder/audio.py": "import math\nimport numpy as np\nimport librosa\nimport vocoder.hparams as hp\nfrom scipy.signal import lfilter\nimport soundfile as sf\n\n\ndef label_2_float(x, bits) :\n    return 2 * x / (2**bits - 1.) - 1.\n\n\ndef float_2_label(x, bits) :\n    assert abs(x).max() <= 1.0\n    x = (x + 1.) * (2**bits - 1) / 2\n    return x.clip(0, 2**bits - 1)\n\n\ndef load_wav(path) :\n    return librosa.load(str(path), sr=hp.sample_rate)[0]\n\n\ndef save_wav(x, path) :\n    sf.write(path, x.astype(np.float32), hp.sample_rate)\n\n\ndef split_signal(x) :\n    unsigned = x + 2**15\n    coarse = unsigned // 256\n    fine = unsigned % 256\n    return coarse, fine\n\n\ndef combine_signal(coarse, fine) :\n    return coarse * 256 + fine - 2**15\n\n\ndef encode_16bits(x) :\n    return np.clip(x * 2**15, -2**15, 2**15 - 1).astype(np.int16)\n\n\nmel_basis = None\n\n\ndef linear_to_mel(spectrogram):\n    global mel_basis\n    if mel_basis is None:\n        mel_basis = build_mel_basis()\n    return np.dot(mel_basis, spectrogram)\n\n\ndef build_mel_basis():\n    return librosa.filters.mel(hp.sample_rate, hp.n_fft, n_mels=hp.num_mels, fmin=hp.fmin)\n\n\ndef normalize(S):\n    return np.clip((S - hp.min_level_db) / -hp.min_level_db, 0, 1)\n\n\ndef denormalize(S):\n    return (np.clip(S, 0, 1) * -hp.min_level_db) + hp.min_level_db\n\n\ndef amp_to_db(x):\n    return 20 * np.log10(np.maximum(1e-5, x))\n\n\ndef db_to_amp(x):\n    return np.power(10.0, x * 0.05)\n\n\ndef spectrogram(y):\n    D = stft(y)\n    S = amp_to_db(np.abs(D)) - hp.ref_level_db\n    return normalize(S)\n\n\ndef melspectrogram(y):\n    D = stft(y)\n    S = amp_to_db(linear_to_mel(np.abs(D)))\n    return normalize(S)\n\n\ndef stft(y):\n    return librosa.stft(y=y, n_fft=hp.n_fft, hop_length=hp.hop_length, win_length=hp.win_length)\n\n\ndef pre_emphasis(x):\n    return lfilter([1, -hp.preemphasis], [1], x)\n\n\ndef de_emphasis(x):\n    return lfilter([1], [1, -hp.preemphasis], x)\n\n\ndef encode_mu_law(x, mu) :\n    mu = mu - 1\n    fx = np.sign(x) * np.log(1 + mu * np.abs(x)) / np.log(1 + mu)\n    return np.floor((fx + 1) / 2 * mu + 0.5)\n\n\ndef decode_mu_law(y, mu, from_labels=True) :\n    if from_labels: \n        y = label_2_float(y, math.log2(mu))\n    mu = mu - 1\n    x = np.sign(y) / mu * ((1 + mu) ** np.abs(y) - 1)\n    return x\n\n", "vocoder/hparams.py": "from synthesizer.hparams import hparams as _syn_hp\n\n\n# Audio settings------------------------------------------------------------------------\n# Match the values of the synthesizer\nsample_rate = _syn_hp.sample_rate\nn_fft = _syn_hp.n_fft\nnum_mels = _syn_hp.num_mels\nhop_length = _syn_hp.hop_size\nwin_length = _syn_hp.win_size\nfmin = _syn_hp.fmin\nmin_level_db = _syn_hp.min_level_db\nref_level_db = _syn_hp.ref_level_db\nmel_max_abs_value = _syn_hp.max_abs_value\npreemphasis = _syn_hp.preemphasis\napply_preemphasis = _syn_hp.preemphasize\n\nbits = 9                            # bit depth of signal\nmu_law = True                       # Recommended to suppress noise if using raw bits in hp.voc_mode\n                                    # below\n\n\n# WAVERNN / VOCODER --------------------------------------------------------------------------------\nvoc_mode = 'RAW'                    # either 'RAW' (softmax on raw bits) or 'MOL' (sample from \n# mixture of logistics)\nvoc_upsample_factors = (5, 5, 8)    # NB - this needs to correctly factorise hop_length\nvoc_rnn_dims = 512\nvoc_fc_dims = 512\nvoc_compute_dims = 128\nvoc_res_out_dims = 128\nvoc_res_blocks = 10\n\n# Training\nvoc_batch_size = 100\nvoc_lr = 1e-4\nvoc_gen_at_checkpoint = 5           # number of samples to generate at each checkpoint\nvoc_pad = 2                         # this will pad the input so that the resnet can 'see' wider \n                                    # than input length\nvoc_seq_len = hop_length * 5        # must be a multiple of hop_length\n\n# Generating / Synthesizing\nvoc_gen_batched = True              # very fast (realtime+) single utterance batched generation\nvoc_target = 8000                   # target number of samples to be generated in each batch entry\nvoc_overlap = 400                   # number of samples for crossfading between batches\n", "vocoder/gen_wavernn.py": "from vocoder.models.fatchord_version import  WaveRNN\nfrom vocoder.audio import *\n\n\ndef gen_testset(model: WaveRNN, test_set, samples, batched, target, overlap, save_path):\n    k = model.get_step() // 1000\n\n    for i, (m, x) in enumerate(test_set, 1):\n        if i > samples: \n            break\n\n        print('\\n| Generating: %i/%i' % (i, samples))\n\n        x = x[0].numpy()\n\n        bits = 16 if hp.voc_mode == 'MOL' else hp.bits\n\n        if hp.mu_law and hp.voc_mode != 'MOL' :\n            x = decode_mu_law(x, 2**bits, from_labels=True)\n        else :\n            x = label_2_float(x, bits)\n\n        save_wav(x, save_path.joinpath(\"%dk_steps_%d_target.wav\" % (k, i)))\n        \n        batch_str = \"gen_batched_target%d_overlap%d\" % (target, overlap) if batched else \\\n            \"gen_not_batched\"\n        save_str = save_path.joinpath(\"%dk_steps_%d_%s.wav\" % (k, i, batch_str))\n\n        wav = model.generate(m, batched, target, overlap, hp.mu_law)\n        save_wav(wav, save_str)\n\n", "vocoder/inference.py": "from vocoder.models.fatchord_version import WaveRNN\nfrom vocoder import hparams as hp\nimport torch\n\n\n_model = None   # type: WaveRNN\n\ndef load_model(weights_fpath, verbose=True):\n    global _model, _device\n    \n    if verbose:\n        print(\"Building Wave-RNN\")\n    _model = WaveRNN(\n        rnn_dims=hp.voc_rnn_dims,\n        fc_dims=hp.voc_fc_dims,\n        bits=hp.bits,\n        pad=hp.voc_pad,\n        upsample_factors=hp.voc_upsample_factors,\n        feat_dims=hp.num_mels,\n        compute_dims=hp.voc_compute_dims,\n        res_out_dims=hp.voc_res_out_dims,\n        res_blocks=hp.voc_res_blocks,\n        hop_length=hp.hop_length,\n        sample_rate=hp.sample_rate,\n        mode=hp.voc_mode\n    )\n\n    if torch.cuda.is_available():\n        _model = _model.cuda()\n        _device = torch.device('cuda')\n    else:\n        _device = torch.device('cpu')\n    \n    if verbose:\n        print(\"Loading model weights at %s\" % weights_fpath)\n    checkpoint = torch.load(weights_fpath, _device)\n    _model.load_state_dict(checkpoint['model_state'])\n    _model.eval()\n\n\ndef is_loaded():\n    return _model is not None\n\n\ndef infer_waveform(mel, normalize=True,  batched=True, target=8000, overlap=800, \n                   progress_callback=None):\n    \"\"\"\n    Infers the waveform of a mel spectrogram output by the synthesizer (the format must match \n    that of the synthesizer!)\n    \n    :param normalize:  \n    :param batched: \n    :param target: \n    :param overlap: \n    :return: \n    \"\"\"\n    if _model is None:\n        raise Exception(\"Please load Wave-RNN in memory before using it\")\n    \n    if normalize:\n        mel = mel / hp.mel_max_abs_value\n    mel = torch.from_numpy(mel[None, ...])\n    wav = _model.generate(mel, batched, target, overlap, hp.mu_law, progress_callback)\n    return wav\n", "vocoder/models/deepmind_version.py": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom utils.display import *\nfrom utils.dsp import *\n\n\nclass WaveRNN(nn.Module) :\n    def __init__(self, hidden_size=896, quantisation=256) :\n        super(WaveRNN, self).__init__()\n        \n        self.hidden_size = hidden_size\n        self.split_size = hidden_size // 2\n        \n        # The main matmul\n        self.R = nn.Linear(self.hidden_size, 3 * self.hidden_size, bias=False)\n        \n        # Output fc layers\n        self.O1 = nn.Linear(self.split_size, self.split_size)\n        self.O2 = nn.Linear(self.split_size, quantisation)\n        self.O3 = nn.Linear(self.split_size, self.split_size)\n        self.O4 = nn.Linear(self.split_size, quantisation)\n        \n        # Input fc layers\n        self.I_coarse = nn.Linear(2, 3 * self.split_size, bias=False)\n        self.I_fine = nn.Linear(3, 3 * self.split_size, bias=False)\n\n        # biases for the gates\n        self.bias_u = nn.Parameter(torch.zeros(self.hidden_size))\n        self.bias_r = nn.Parameter(torch.zeros(self.hidden_size))\n        self.bias_e = nn.Parameter(torch.zeros(self.hidden_size))\n        \n        # display num params\n        self.num_params()\n\n        \n    def forward(self, prev_y, prev_hidden, current_coarse) :\n        \n        # Main matmul - the projection is split 3 ways\n        R_hidden = self.R(prev_hidden)\n        R_u, R_r, R_e, = torch.split(R_hidden, self.hidden_size, dim=1)\n        \n        # Project the prev input \n        coarse_input_proj = self.I_coarse(prev_y)\n        I_coarse_u, I_coarse_r, I_coarse_e = \\\n            torch.split(coarse_input_proj, self.split_size, dim=1)\n        \n        # Project the prev input and current coarse sample\n        fine_input = torch.cat([prev_y, current_coarse], dim=1)\n        fine_input_proj = self.I_fine(fine_input)\n        I_fine_u, I_fine_r, I_fine_e = \\\n            torch.split(fine_input_proj, self.split_size, dim=1)\n        \n        # concatenate for the gates\n        I_u = torch.cat([I_coarse_u, I_fine_u], dim=1)\n        I_r = torch.cat([I_coarse_r, I_fine_r], dim=1)\n        I_e = torch.cat([I_coarse_e, I_fine_e], dim=1)\n        \n        # Compute all gates for coarse and fine \n        u = F.sigmoid(R_u + I_u + self.bias_u)\n        r = F.sigmoid(R_r + I_r + self.bias_r)\n        e = F.tanh(r * R_e + I_e + self.bias_e)\n        hidden = u * prev_hidden + (1. - u) * e\n        \n        # Split the hidden state\n        hidden_coarse, hidden_fine = torch.split(hidden, self.split_size, dim=1)\n        \n        # Compute outputs \n        out_coarse = self.O2(F.relu(self.O1(hidden_coarse)))\n        out_fine = self.O4(F.relu(self.O3(hidden_fine)))\n\n        return out_coarse, out_fine, hidden\n    \n        \n    def generate(self, seq_len):\n        with torch.no_grad():\n            # First split up the biases for the gates \n            b_coarse_u, b_fine_u = torch.split(self.bias_u, self.split_size)\n            b_coarse_r, b_fine_r = torch.split(self.bias_r, self.split_size)\n            b_coarse_e, b_fine_e = torch.split(self.bias_e, self.split_size)\n\n            # Lists for the two output seqs\n            c_outputs, f_outputs = [], []\n\n            # Some initial inputs\n            out_coarse = torch.LongTensor([0]).cuda()\n            out_fine = torch.LongTensor([0]).cuda()\n\n            # We'll meed a hidden state\n            hidden = self.init_hidden()\n\n            # Need a clock for display\n            start = time.time()\n\n            # Loop for generation\n            for i in range(seq_len) :\n\n                # Split into two hidden states\n                hidden_coarse, hidden_fine = \\\n                    torch.split(hidden, self.split_size, dim=1)\n\n                # Scale and concat previous predictions\n                out_coarse = out_coarse.unsqueeze(0).float() / 127.5 - 1.\n                out_fine = out_fine.unsqueeze(0).float() / 127.5 - 1.\n                prev_outputs = torch.cat([out_coarse, out_fine], dim=1)\n\n                # Project input \n                coarse_input_proj = self.I_coarse(prev_outputs)\n                I_coarse_u, I_coarse_r, I_coarse_e = \\\n                    torch.split(coarse_input_proj, self.split_size, dim=1)\n\n                # Project hidden state and split 6 ways\n                R_hidden = self.R(hidden)\n                R_coarse_u , R_fine_u, \\\n                R_coarse_r, R_fine_r, \\\n                R_coarse_e, R_fine_e = torch.split(R_hidden, self.split_size, dim=1)\n\n                # Compute the coarse gates\n                u = F.sigmoid(R_coarse_u + I_coarse_u + b_coarse_u)\n                r = F.sigmoid(R_coarse_r + I_coarse_r + b_coarse_r)\n                e = F.tanh(r * R_coarse_e + I_coarse_e + b_coarse_e)\n                hidden_coarse = u * hidden_coarse + (1. - u) * e\n\n                # Compute the coarse output\n                out_coarse = self.O2(F.relu(self.O1(hidden_coarse)))\n                posterior = F.softmax(out_coarse, dim=1)\n                distrib = torch.distributions.Categorical(posterior)\n                out_coarse = distrib.sample()\n                c_outputs.append(out_coarse)\n\n                # Project the [prev outputs and predicted coarse sample]\n                coarse_pred = out_coarse.float() / 127.5 - 1.\n                fine_input = torch.cat([prev_outputs, coarse_pred.unsqueeze(0)], dim=1)\n                fine_input_proj = self.I_fine(fine_input)\n                I_fine_u, I_fine_r, I_fine_e = \\\n                    torch.split(fine_input_proj, self.split_size, dim=1)\n\n                # Compute the fine gates\n                u = F.sigmoid(R_fine_u + I_fine_u + b_fine_u)\n                r = F.sigmoid(R_fine_r + I_fine_r + b_fine_r)\n                e = F.tanh(r * R_fine_e + I_fine_e + b_fine_e)\n                hidden_fine = u * hidden_fine + (1. - u) * e\n\n                # Compute the fine output\n                out_fine = self.O4(F.relu(self.O3(hidden_fine)))\n                posterior = F.softmax(out_fine, dim=1)\n                distrib = torch.distributions.Categorical(posterior)\n                out_fine = distrib.sample()\n                f_outputs.append(out_fine)\n\n                # Put the hidden state back together\n                hidden = torch.cat([hidden_coarse, hidden_fine], dim=1)\n\n                # Display progress\n                speed = (i + 1) / (time.time() - start)\n                stream('Gen: %i/%i -- Speed: %i',  (i + 1, seq_len, speed))\n\n            coarse = torch.stack(c_outputs).squeeze(1).cpu().data.numpy()\n            fine = torch.stack(f_outputs).squeeze(1).cpu().data.numpy()        \n            output = combine_signal(coarse, fine)\n        \n        return output, coarse, fine\n\n    def init_hidden(self, batch_size=1) :\n        return torch.zeros(batch_size, self.hidden_size).cuda()\n    \n    def num_params(self) :\n        parameters = filter(lambda p: p.requires_grad, self.parameters())\n        parameters = sum([np.prod(p.size()) for p in parameters]) / 1_000_000\n        print('Trainable Parameters: %.3f million' % parameters)", "vocoder/models/fatchord_version.py": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom vocoder.distribution import sample_from_discretized_mix_logistic\nfrom vocoder.display import *\nfrom vocoder.audio import *\n\n\nclass ResBlock(nn.Module):\n    def __init__(self, dims):\n        super().__init__()\n        self.conv1 = nn.Conv1d(dims, dims, kernel_size=1, bias=False)\n        self.conv2 = nn.Conv1d(dims, dims, kernel_size=1, bias=False)\n        self.batch_norm1 = nn.BatchNorm1d(dims)\n        self.batch_norm2 = nn.BatchNorm1d(dims)\n\n    def forward(self, x):\n        residual = x\n        x = self.conv1(x)\n        x = self.batch_norm1(x)\n        x = F.relu(x)\n        x = self.conv2(x)\n        x = self.batch_norm2(x)\n        return x + residual\n\n\nclass MelResNet(nn.Module):\n    def __init__(self, res_blocks, in_dims, compute_dims, res_out_dims, pad):\n        super().__init__()\n        k_size = pad * 2 + 1\n        self.conv_in = nn.Conv1d(in_dims, compute_dims, kernel_size=k_size, bias=False)\n        self.batch_norm = nn.BatchNorm1d(compute_dims)\n        self.layers = nn.ModuleList()\n        for i in range(res_blocks):\n            self.layers.append(ResBlock(compute_dims))\n        self.conv_out = nn.Conv1d(compute_dims, res_out_dims, kernel_size=1)\n\n    def forward(self, x):\n        x = self.conv_in(x)\n        x = self.batch_norm(x)\n        x = F.relu(x)\n        for f in self.layers: x = f(x)\n        x = self.conv_out(x)\n        return x\n\n\nclass Stretch2d(nn.Module):\n    def __init__(self, x_scale, y_scale):\n        super().__init__()\n        self.x_scale = x_scale\n        self.y_scale = y_scale\n\n    def forward(self, x):\n        b, c, h, w = x.size()\n        x = x.unsqueeze(-1).unsqueeze(3)\n        x = x.repeat(1, 1, 1, self.y_scale, 1, self.x_scale)\n        return x.view(b, c, h * self.y_scale, w * self.x_scale)\n\n\nclass UpsampleNetwork(nn.Module):\n    def __init__(self, feat_dims, upsample_scales, compute_dims,\n                 res_blocks, res_out_dims, pad):\n        super().__init__()\n        total_scale = np.cumproduct(upsample_scales)[-1]\n        self.indent = pad * total_scale\n        self.resnet = MelResNet(res_blocks, feat_dims, compute_dims, res_out_dims, pad)\n        self.resnet_stretch = Stretch2d(total_scale, 1)\n        self.up_layers = nn.ModuleList()\n        for scale in upsample_scales:\n            k_size = (1, scale * 2 + 1)\n            padding = (0, scale)\n            stretch = Stretch2d(scale, 1)\n            conv = nn.Conv2d(1, 1, kernel_size=k_size, padding=padding, bias=False)\n            conv.weight.data.fill_(1. / k_size[1])\n            self.up_layers.append(stretch)\n            self.up_layers.append(conv)\n\n    def forward(self, m):\n        aux = self.resnet(m).unsqueeze(1)\n        aux = self.resnet_stretch(aux)\n        aux = aux.squeeze(1)\n        m = m.unsqueeze(1)\n        for f in self.up_layers: m = f(m)\n        m = m.squeeze(1)[:, :, self.indent:-self.indent]\n        return m.transpose(1, 2), aux.transpose(1, 2)\n\n\nclass WaveRNN(nn.Module):\n    def __init__(self, rnn_dims, fc_dims, bits, pad, upsample_factors,\n                 feat_dims, compute_dims, res_out_dims, res_blocks,\n                 hop_length, sample_rate, mode='RAW'):\n        super().__init__()\n        self.mode = mode\n        self.pad = pad\n        if self.mode == 'RAW' :\n            self.n_classes = 2 ** bits\n        elif self.mode == 'MOL' :\n            self.n_classes = 30\n        else :\n            RuntimeError(\"Unknown model mode value - \", self.mode)\n\n        self.rnn_dims = rnn_dims\n        self.aux_dims = res_out_dims // 4\n        self.hop_length = hop_length\n        self.sample_rate = sample_rate\n\n        self.upsample = UpsampleNetwork(feat_dims, upsample_factors, compute_dims, res_blocks, res_out_dims, pad)\n        self.I = nn.Linear(feat_dims + self.aux_dims + 1, rnn_dims)\n        self.rnn1 = nn.GRU(rnn_dims, rnn_dims, batch_first=True)\n        self.rnn2 = nn.GRU(rnn_dims + self.aux_dims, rnn_dims, batch_first=True)\n        self.fc1 = nn.Linear(rnn_dims + self.aux_dims, fc_dims)\n        self.fc2 = nn.Linear(fc_dims + self.aux_dims, fc_dims)\n        self.fc3 = nn.Linear(fc_dims, self.n_classes)\n\n        self.step = nn.Parameter(torch.zeros(1).long(), requires_grad=False)\n        self.num_params()\n\n    def forward(self, x, mels):\n        self.step += 1\n        bsize = x.size(0)\n        if torch.cuda.is_available():\n            h1 = torch.zeros(1, bsize, self.rnn_dims).cuda()\n            h2 = torch.zeros(1, bsize, self.rnn_dims).cuda()\n        else:\n            h1 = torch.zeros(1, bsize, self.rnn_dims).cpu()\n            h2 = torch.zeros(1, bsize, self.rnn_dims).cpu()\n        mels, aux = self.upsample(mels)\n\n        aux_idx = [self.aux_dims * i for i in range(5)]\n        a1 = aux[:, :, aux_idx[0]:aux_idx[1]]\n        a2 = aux[:, :, aux_idx[1]:aux_idx[2]]\n        a3 = aux[:, :, aux_idx[2]:aux_idx[3]]\n        a4 = aux[:, :, aux_idx[3]:aux_idx[4]]\n\n        x = torch.cat([x.unsqueeze(-1), mels, a1], dim=2)\n        x = self.I(x)\n        res = x\n        x, _ = self.rnn1(x, h1)\n\n        x = x + res\n        res = x\n        x = torch.cat([x, a2], dim=2)\n        x, _ = self.rnn2(x, h2)\n\n        x = x + res\n        x = torch.cat([x, a3], dim=2)\n        x = F.relu(self.fc1(x))\n\n        x = torch.cat([x, a4], dim=2)\n        x = F.relu(self.fc2(x))\n        return self.fc3(x)\n\n    def generate(self, mels, batched, target, overlap, mu_law, progress_callback=None):\n        mu_law = mu_law if self.mode == 'RAW' else False\n        progress_callback = progress_callback or self.gen_display\n\n        self.eval()\n        output = []\n        start = time.time()\n        rnn1 = self.get_gru_cell(self.rnn1)\n        rnn2 = self.get_gru_cell(self.rnn2)\n\n        with torch.no_grad():\n            if torch.cuda.is_available():\n                mels = mels.cuda()\n            else:\n                mels = mels.cpu()\n            wave_len = (mels.size(-1) - 1) * self.hop_length\n            mels = self.pad_tensor(mels.transpose(1, 2), pad=self.pad, side='both')\n            mels, aux = self.upsample(mels.transpose(1, 2))\n\n            if batched:\n                mels = self.fold_with_overlap(mels, target, overlap)\n                aux = self.fold_with_overlap(aux, target, overlap)\n\n            b_size, seq_len, _ = mels.size()\n\n            if torch.cuda.is_available():\n                h1 = torch.zeros(b_size, self.rnn_dims).cuda()\n                h2 = torch.zeros(b_size, self.rnn_dims).cuda()\n                x = torch.zeros(b_size, 1).cuda()\n            else:\n                h1 = torch.zeros(b_size, self.rnn_dims).cpu()\n                h2 = torch.zeros(b_size, self.rnn_dims).cpu()\n                x = torch.zeros(b_size, 1).cpu()\n\n            d = self.aux_dims\n            aux_split = [aux[:, :, d * i:d * (i + 1)] for i in range(4)]\n\n            for i in range(seq_len):\n\n                m_t = mels[:, i, :]\n\n                a1_t, a2_t, a3_t, a4_t = (a[:, i, :] for a in aux_split)\n\n                x = torch.cat([x, m_t, a1_t], dim=1)\n                x = self.I(x)\n                h1 = rnn1(x, h1)\n\n                x = x + h1\n                inp = torch.cat([x, a2_t], dim=1)\n                h2 = rnn2(inp, h2)\n\n                x = x + h2\n                x = torch.cat([x, a3_t], dim=1)\n                x = F.relu(self.fc1(x))\n\n                x = torch.cat([x, a4_t], dim=1)\n                x = F.relu(self.fc2(x))\n\n                logits = self.fc3(x)\n\n                if self.mode == 'MOL':\n                    sample = sample_from_discretized_mix_logistic(logits.unsqueeze(0).transpose(1, 2))\n                    output.append(sample.view(-1))\n                    if torch.cuda.is_available():\n                        # x = torch.FloatTensor([[sample]]).cuda()\n                        x = sample.transpose(0, 1).cuda()\n                    else:\n                        x = sample.transpose(0, 1)\n\n                elif self.mode == 'RAW' :\n                    posterior = F.softmax(logits, dim=1)\n                    distrib = torch.distributions.Categorical(posterior)\n\n                    sample = 2 * distrib.sample().float() / (self.n_classes - 1.) - 1.\n                    output.append(sample)\n                    x = sample.unsqueeze(-1)\n                else:\n                    raise RuntimeError(\"Unknown model mode value - \", self.mode)\n\n                if i % 100 == 0:\n                    gen_rate = (i + 1) / (time.time() - start) * b_size / 1000\n                    progress_callback(i, seq_len, b_size, gen_rate)\n\n        output = torch.stack(output).transpose(0, 1)\n        output = output.cpu().numpy()\n        output = output.astype(np.float64)\n        \n        if batched:\n            output = self.xfade_and_unfold(output, target, overlap)\n        else:\n            output = output[0]\n\n        if mu_law:\n            output = decode_mu_law(output, self.n_classes, False)\n        if hp.apply_preemphasis:\n            output = de_emphasis(output)\n\n        # Fade-out at the end to avoid signal cutting out suddenly\n        fade_out = np.linspace(1, 0, 20 * self.hop_length)\n        output = output[:wave_len]\n        output[-20 * self.hop_length:] *= fade_out\n        \n        self.train()\n\n        return output\n\n\n    def gen_display(self, i, seq_len, b_size, gen_rate):\n        pbar = progbar(i, seq_len)\n        msg = f'| {pbar} {i*b_size}/{seq_len*b_size} | Batch Size: {b_size} | Gen Rate: {gen_rate:.1f}kHz | '\n        stream(msg)\n\n    def get_gru_cell(self, gru):\n        gru_cell = nn.GRUCell(gru.input_size, gru.hidden_size)\n        gru_cell.weight_hh.data = gru.weight_hh_l0.data\n        gru_cell.weight_ih.data = gru.weight_ih_l0.data\n        gru_cell.bias_hh.data = gru.bias_hh_l0.data\n        gru_cell.bias_ih.data = gru.bias_ih_l0.data\n        return gru_cell\n\n    def pad_tensor(self, x, pad, side='both'):\n        # NB - this is just a quick method i need right now\n        # i.e., it won't generalise to other shapes/dims\n        b, t, c = x.size()\n        total = t + 2 * pad if side == 'both' else t + pad\n        if torch.cuda.is_available():\n            padded = torch.zeros(b, total, c).cuda()\n        else:\n            padded = torch.zeros(b, total, c).cpu()\n        if side == 'before' or side == 'both':\n            padded[:, pad:pad + t, :] = x\n        elif side == 'after':\n            padded[:, :t, :] = x\n        return padded\n\n    def fold_with_overlap(self, x, target, overlap):\n\n        ''' Fold the tensor with overlap for quick batched inference.\n            Overlap will be used for crossfading in xfade_and_unfold()\n\n        Args:\n            x (tensor)    : Upsampled conditioning features.\n                            shape=(1, timesteps, features)\n            target (int)  : Target timesteps for each index of batch\n            overlap (int) : Timesteps for both xfade and rnn warmup\n\n        Return:\n            (tensor) : shape=(num_folds, target + 2 * overlap, features)\n\n        Details:\n            x = [[h1, h2, ... hn]]\n\n            Where each h is a vector of conditioning features\n\n            Eg: target=2, overlap=1 with x.size(1)=10\n\n            folded = [[h1, h2, h3, h4],\n                      [h4, h5, h6, h7],\n                      [h7, h8, h9, h10]]\n        '''\n\n        _, total_len, features = x.size()\n\n        # Calculate variables needed\n        num_folds = (total_len - overlap) // (target + overlap)\n        extended_len = num_folds * (overlap + target) + overlap\n        remaining = total_len - extended_len\n\n        # Pad if some time steps poking out\n        if remaining != 0:\n            num_folds += 1\n            padding = target + 2 * overlap - remaining\n            x = self.pad_tensor(x, padding, side='after')\n\n        if torch.cuda.is_available():\n            folded = torch.zeros(num_folds, target + 2 * overlap, features).cuda()\n        else:\n            folded = torch.zeros(num_folds, target + 2 * overlap, features).cpu()\n\n        # Get the values for the folded tensor\n        for i in range(num_folds):\n            start = i * (target + overlap)\n            end = start + target + 2 * overlap\n            folded[i] = x[:, start:end, :]\n\n        return folded\n\n    def xfade_and_unfold(self, y, target, overlap):\n\n        ''' Applies a crossfade and unfolds into a 1d array.\n\n        Args:\n            y (ndarry)    : Batched sequences of audio samples\n                            shape=(num_folds, target + 2 * overlap)\n                            dtype=np.float64\n            overlap (int) : Timesteps for both xfade and rnn warmup\n\n        Return:\n            (ndarry) : audio samples in a 1d array\n                       shape=(total_len)\n                       dtype=np.float64\n\n        Details:\n            y = [[seq1],\n                 [seq2],\n                 [seq3]]\n\n            Apply a gain envelope at both ends of the sequences\n\n            y = [[seq1_in, seq1_target, seq1_out],\n                 [seq2_in, seq2_target, seq2_out],\n                 [seq3_in, seq3_target, seq3_out]]\n\n            Stagger and add up the groups of samples:\n\n            [seq1_in, seq1_target, (seq1_out + seq2_in), seq2_target, ...]\n\n        '''\n\n        num_folds, length = y.shape\n        target = length - 2 * overlap\n        total_len = num_folds * (target + overlap) + overlap\n\n        # Need some silence for the rnn warmup\n        silence_len = overlap // 2\n        fade_len = overlap - silence_len\n        silence = np.zeros((silence_len), dtype=np.float64)\n\n        # Equal power crossfade\n        t = np.linspace(-1, 1, fade_len, dtype=np.float64)\n        fade_in = np.sqrt(0.5 * (1 + t))\n        fade_out = np.sqrt(0.5 * (1 - t))\n\n        # Concat the silence to the fades\n        fade_in = np.concatenate([silence, fade_in])\n        fade_out = np.concatenate([fade_out, silence])\n\n        # Apply the gain to the overlap samples\n        y[:, :overlap] *= fade_in\n        y[:, -overlap:] *= fade_out\n\n        unfolded = np.zeros((total_len), dtype=np.float64)\n\n        # Loop to add up all the samples\n        for i in range(num_folds):\n            start = i * (target + overlap)\n            end = start + target + 2 * overlap\n            unfolded[start:end] += y[i]\n\n        return unfolded\n\n    def get_step(self) :\n        return self.step.data.item()\n\n    def checkpoint(self, model_dir, optimizer) :\n        k_steps = self.get_step() // 1000\n        self.save(model_dir.joinpath(\"checkpoint_%dk_steps.pt\" % k_steps), optimizer)\n\n    def log(self, path, msg) :\n        with open(path, 'a') as f:\n            print(msg, file=f)\n\n    def load(self, path, optimizer) :\n        checkpoint = torch.load(path)\n        if \"optimizer_state\" in checkpoint:\n            self.load_state_dict(checkpoint[\"model_state\"])\n            optimizer.load_state_dict(checkpoint[\"optimizer_state\"])\n        else:\n            # Backwards compatibility\n            self.load_state_dict(checkpoint)\n\n    def save(self, path, optimizer) :\n        torch.save({\n            \"model_state\": self.state_dict(),\n            \"optimizer_state\": optimizer.state_dict(),\n        }, path)\n\n    def num_params(self, print_out=True):\n        parameters = filter(lambda p: p.requires_grad, self.parameters())\n        parameters = sum([np.prod(p.size()) for p in parameters]) / 1_000_000\n        if print_out :\n            print('Trainable Parameters: %.3fM' % parameters)\n", "encoder/preprocess.py": "from datetime import datetime\nfrom functools import partial\nfrom multiprocessing import Pool\nfrom pathlib import Path\n\nimport numpy as np\nfrom tqdm import tqdm\n\nfrom encoder import audio\nfrom encoder.config import librispeech_datasets, anglophone_nationalites\nfrom encoder.params_data import *\n\n\n_AUDIO_EXTENSIONS = (\"wav\", \"flac\", \"m4a\", \"mp3\")\n\nclass DatasetLog:\n    \"\"\"\n    Registers metadata about the dataset in a text file.\n    \"\"\"\n    def __init__(self, root, name):\n        self.text_file = open(Path(root, \"Log_%s.txt\" % name.replace(\"/\", \"_\")), \"w\")\n        self.sample_data = dict()\n\n        start_time = str(datetime.now().strftime(\"%A %d %B %Y at %H:%M\"))\n        self.write_line(\"Creating dataset %s on %s\" % (name, start_time))\n        self.write_line(\"-----\")\n        self._log_params()\n\n    def _log_params(self):\n        from encoder import params_data\n        self.write_line(\"Parameter values:\")\n        for param_name in (p for p in dir(params_data) if not p.startswith(\"__\")):\n            value = getattr(params_data, param_name)\n            self.write_line(\"\\t%s: %s\" % (param_name, value))\n        self.write_line(\"-----\")\n\n    def write_line(self, line):\n        self.text_file.write(\"%s\\n\" % line)\n\n    def add_sample(self, **kwargs):\n        for param_name, value in kwargs.items():\n            if not param_name in self.sample_data:\n                self.sample_data[param_name] = []\n            self.sample_data[param_name].append(value)\n\n    def finalize(self):\n        self.write_line(\"Statistics:\")\n        for param_name, values in self.sample_data.items():\n            self.write_line(\"\\t%s:\" % param_name)\n            self.write_line(\"\\t\\tmin %.3f, max %.3f\" % (np.min(values), np.max(values)))\n            self.write_line(\"\\t\\tmean %.3f, median %.3f\" % (np.mean(values), np.median(values)))\n        self.write_line(\"-----\")\n        end_time = str(datetime.now().strftime(\"%A %d %B %Y at %H:%M\"))\n        self.write_line(\"Finished on %s\" % end_time)\n        self.text_file.close()\n\n\ndef _init_preprocess_dataset(dataset_name, datasets_root, out_dir) -> (Path, DatasetLog):\n    dataset_root = datasets_root.joinpath(dataset_name)\n    if not dataset_root.exists():\n        print(\"Couldn\\'t find %s, skipping this dataset.\" % dataset_root)\n        return None, None\n    return dataset_root, DatasetLog(out_dir, dataset_name)\n\n\ndef _preprocess_speaker(speaker_dir: Path, datasets_root: Path, out_dir: Path, skip_existing: bool):\n    # Give a name to the speaker that includes its dataset\n    speaker_name = \"_\".join(speaker_dir.relative_to(datasets_root).parts)\n\n    # Create an output directory with that name, as well as a txt file containing a\n    # reference to each source file.\n    speaker_out_dir = out_dir.joinpath(speaker_name)\n    speaker_out_dir.mkdir(exist_ok=True)\n    sources_fpath = speaker_out_dir.joinpath(\"_sources.txt\")\n\n    # There's a possibility that the preprocessing was interrupted earlier, check if\n    # there already is a sources file.\n    if sources_fpath.exists():\n        try:\n            with sources_fpath.open(\"r\") as sources_file:\n                existing_fnames = {line.split(\",\")[0] for line in sources_file}\n        except:\n            existing_fnames = {}\n    else:\n        existing_fnames = {}\n\n    # Gather all audio files for that speaker recursively\n    sources_file = sources_fpath.open(\"a\" if skip_existing else \"w\")\n    audio_durs = []\n    for extension in _AUDIO_EXTENSIONS:\n        for in_fpath in speaker_dir.glob(\"**/*.%s\" % extension):\n            # Check if the target output file already exists\n            out_fname = \"_\".join(in_fpath.relative_to(speaker_dir).parts)\n            out_fname = out_fname.replace(\".%s\" % extension, \".npy\")\n            if skip_existing and out_fname in existing_fnames:\n                continue\n\n            # Load and preprocess the waveform\n            wav = audio.preprocess_wav(in_fpath)\n            if len(wav) == 0:\n                continue\n\n            # Create the mel spectrogram, discard those that are too short\n            frames = audio.wav_to_mel_spectrogram(wav)\n            if len(frames) < partials_n_frames:\n                continue\n\n            out_fpath = speaker_out_dir.joinpath(out_fname)\n            np.save(out_fpath, frames)\n            sources_file.write(\"%s,%s\\n\" % (out_fname, in_fpath))\n            audio_durs.append(len(wav) / sampling_rate)\n\n    sources_file.close()\n\n    return audio_durs\n\n\ndef _preprocess_speaker_dirs(speaker_dirs, dataset_name, datasets_root, out_dir, skip_existing, logger):\n    print(\"%s: Preprocessing data for %d speakers.\" % (dataset_name, len(speaker_dirs)))\n\n    # Process the utterances for each speaker\n    work_fn = partial(_preprocess_speaker, datasets_root=datasets_root, out_dir=out_dir, skip_existing=skip_existing)\n    with Pool(4) as pool:\n        tasks = pool.imap(work_fn, speaker_dirs)\n        for sample_durs in tqdm(tasks, dataset_name, len(speaker_dirs), unit=\"speakers\"):\n            for sample_dur in sample_durs:\n                logger.add_sample(duration=sample_dur)\n\n    logger.finalize()\n    print(\"Done preprocessing %s.\\n\" % dataset_name)\n\n\ndef preprocess_librispeech(datasets_root: Path, out_dir: Path, skip_existing=False):\n    for dataset_name in librispeech_datasets[\"train\"][\"other\"]:\n        # Initialize the preprocessing\n        dataset_root, logger = _init_preprocess_dataset(dataset_name, datasets_root, out_dir)\n        if not dataset_root:\n            return\n\n        # Preprocess all speakers\n        speaker_dirs = list(dataset_root.glob(\"*\"))\n        _preprocess_speaker_dirs(speaker_dirs, dataset_name, datasets_root, out_dir, skip_existing, logger)\n\n\ndef preprocess_voxceleb1(datasets_root: Path, out_dir: Path, skip_existing=False):\n    # Initialize the preprocessing\n    dataset_name = \"VoxCeleb1\"\n    dataset_root, logger = _init_preprocess_dataset(dataset_name, datasets_root, out_dir)\n    if not dataset_root:\n        return\n\n    # Get the contents of the meta file\n    with dataset_root.joinpath(\"vox1_meta.csv\").open(\"r\") as metafile:\n        metadata = [line.split(\"\\t\") for line in metafile][1:]\n\n    # Select the ID and the nationality, filter out non-anglophone speakers\n    nationalities = {line[0]: line[3] for line in metadata}\n    keep_speaker_ids = [speaker_id for speaker_id, nationality in nationalities.items() if\n                        nationality.lower() in anglophone_nationalites]\n    print(\"VoxCeleb1: using samples from %d (presumed anglophone) speakers out of %d.\" %\n          (len(keep_speaker_ids), len(nationalities)))\n\n    # Get the speaker directories for anglophone speakers only\n    speaker_dirs = dataset_root.joinpath(\"wav\").glob(\"*\")\n    speaker_dirs = [speaker_dir for speaker_dir in speaker_dirs if\n                    speaker_dir.name in keep_speaker_ids]\n    print(\"VoxCeleb1: found %d anglophone speakers on the disk, %d missing (this is normal).\" %\n          (len(speaker_dirs), len(keep_speaker_ids) - len(speaker_dirs)))\n\n    # Preprocess all speakers\n    _preprocess_speaker_dirs(speaker_dirs, dataset_name, datasets_root, out_dir, skip_existing, logger)\n\n\ndef preprocess_voxceleb2(datasets_root: Path, out_dir: Path, skip_existing=False):\n    # Initialize the preprocessing\n    dataset_name = \"VoxCeleb2\"\n    dataset_root, logger = _init_preprocess_dataset(dataset_name, datasets_root, out_dir)\n    if not dataset_root:\n        return\n\n    # Get the speaker directories\n    # Preprocess all speakers\n    speaker_dirs = list(dataset_root.joinpath(\"dev\", \"aac\").glob(\"*\"))\n    _preprocess_speaker_dirs(speaker_dirs, dataset_name, datasets_root, out_dir, skip_existing, logger)\n", "encoder/model.py": "from encoder.params_model import *\nfrom encoder.params_data import *\nfrom scipy.interpolate import interp1d\nfrom sklearn.metrics import roc_curve\nfrom torch.nn.utils import clip_grad_norm_\nfrom scipy.optimize import brentq\nfrom torch import nn\nimport numpy as np\nimport torch\n\n\nclass SpeakerEncoder(nn.Module):\n    def __init__(self, device, loss_device):\n        super().__init__()\n        self.loss_device = loss_device\n        \n        # Network defition\n        self.lstm = nn.LSTM(input_size=mel_n_channels,\n                            hidden_size=model_hidden_size, \n                            num_layers=model_num_layers, \n                            batch_first=True).to(device)\n        self.linear = nn.Linear(in_features=model_hidden_size, \n                                out_features=model_embedding_size).to(device)\n        self.relu = torch.nn.ReLU().to(device)\n        \n        # Cosine similarity scaling (with fixed initial parameter values)\n        self.similarity_weight = nn.Parameter(torch.tensor([10.])).to(loss_device)\n        self.similarity_bias = nn.Parameter(torch.tensor([-5.])).to(loss_device)\n\n        # Loss\n        self.loss_fn = nn.CrossEntropyLoss().to(loss_device)\n        \n    def do_gradient_ops(self):\n        # Gradient scale\n        self.similarity_weight.grad *= 0.01\n        self.similarity_bias.grad *= 0.01\n            \n        # Gradient clipping\n        clip_grad_norm_(self.parameters(), 3, norm_type=2)\n    \n    def forward(self, utterances, hidden_init=None):\n        \"\"\"\n        Computes the embeddings of a batch of utterance spectrograms.\n        \n        :param utterances: batch of mel-scale filterbanks of same duration as a tensor of shape \n        (batch_size, n_frames, n_channels) \n        :param hidden_init: initial hidden state of the LSTM as a tensor of shape (num_layers, \n        batch_size, hidden_size). Will default to a tensor of zeros if None.\n        :return: the embeddings as a tensor of shape (batch_size, embedding_size)\n        \"\"\"\n        # Pass the input through the LSTM layers and retrieve all outputs, the final hidden state\n        # and the final cell state.\n        out, (hidden, cell) = self.lstm(utterances, hidden_init)\n        \n        # We take only the hidden state of the last layer\n        embeds_raw = self.relu(self.linear(hidden[-1]))\n        \n        # L2-normalize it\n        embeds = embeds_raw / (torch.norm(embeds_raw, dim=1, keepdim=True) + 1e-5)        \n\n        return embeds\n    \n    def similarity_matrix(self, embeds):\n        \"\"\"\n        Computes the similarity matrix according the section 2.1 of GE2E.\n\n        :param embeds: the embeddings as a tensor of shape (speakers_per_batch, \n        utterances_per_speaker, embedding_size)\n        :return: the similarity matrix as a tensor of shape (speakers_per_batch,\n        utterances_per_speaker, speakers_per_batch)\n        \"\"\"\n        speakers_per_batch, utterances_per_speaker = embeds.shape[:2]\n        \n        # Inclusive centroids (1 per speaker). Cloning is needed for reverse differentiation\n        centroids_incl = torch.mean(embeds, dim=1, keepdim=True)\n        centroids_incl = centroids_incl.clone() / (torch.norm(centroids_incl, dim=2, keepdim=True) + 1e-5)\n\n        # Exclusive centroids (1 per utterance)\n        centroids_excl = (torch.sum(embeds, dim=1, keepdim=True) - embeds)\n        centroids_excl /= (utterances_per_speaker - 1)\n        centroids_excl = centroids_excl.clone() / (torch.norm(centroids_excl, dim=2, keepdim=True) + 1e-5)\n\n        # Similarity matrix. The cosine similarity of already 2-normed vectors is simply the dot\n        # product of these vectors (which is just an element-wise multiplication reduced by a sum).\n        # We vectorize the computation for efficiency.\n        sim_matrix = torch.zeros(speakers_per_batch, utterances_per_speaker,\n                                 speakers_per_batch).to(self.loss_device)\n        mask_matrix = 1 - np.eye(speakers_per_batch, dtype=np.int)\n        for j in range(speakers_per_batch):\n            mask = np.where(mask_matrix[j])[0]\n            sim_matrix[mask, :, j] = (embeds[mask] * centroids_incl[j]).sum(dim=2)\n            sim_matrix[j, :, j] = (embeds[j] * centroids_excl[j]).sum(dim=1)\n        \n        ## Even more vectorized version (slower maybe because of transpose)\n        # sim_matrix2 = torch.zeros(speakers_per_batch, speakers_per_batch, utterances_per_speaker\n        #                           ).to(self.loss_device)\n        # eye = np.eye(speakers_per_batch, dtype=np.int)\n        # mask = np.where(1 - eye)\n        # sim_matrix2[mask] = (embeds[mask[0]] * centroids_incl[mask[1]]).sum(dim=2)\n        # mask = np.where(eye)\n        # sim_matrix2[mask] = (embeds * centroids_excl).sum(dim=2)\n        # sim_matrix2 = sim_matrix2.transpose(1, 2)\n        \n        sim_matrix = sim_matrix * self.similarity_weight + self.similarity_bias\n        return sim_matrix\n    \n    def loss(self, embeds):\n        \"\"\"\n        Computes the softmax loss according the section 2.1 of GE2E.\n        \n        :param embeds: the embeddings as a tensor of shape (speakers_per_batch, \n        utterances_per_speaker, embedding_size)\n        :return: the loss and the EER for this batch of embeddings.\n        \"\"\"\n        speakers_per_batch, utterances_per_speaker = embeds.shape[:2]\n        \n        # Loss\n        sim_matrix = self.similarity_matrix(embeds)\n        sim_matrix = sim_matrix.reshape((speakers_per_batch * utterances_per_speaker, \n                                         speakers_per_batch))\n        ground_truth = np.repeat(np.arange(speakers_per_batch), utterances_per_speaker)\n        target = torch.from_numpy(ground_truth).long().to(self.loss_device)\n        loss = self.loss_fn(sim_matrix, target)\n        \n        # EER (not backpropagated)\n        with torch.no_grad():\n            inv_argmax = lambda i: np.eye(1, speakers_per_batch, i, dtype=np.int)[0]\n            labels = np.array([inv_argmax(i) for i in ground_truth])\n            preds = sim_matrix.detach().cpu().numpy()\n\n            # Snippet from https://yangcha.github.io/EER-ROC/\n            fpr, tpr, thresholds = roc_curve(labels.flatten(), preds.flatten())           \n            eer = brentq(lambda x: 1. - x - interp1d(fpr, tpr)(x), 0., 1.)\n            \n        return loss, eer\n", "encoder/train.py": "from pathlib import Path\n\nimport torch\n\nfrom encoder.data_objects import SpeakerVerificationDataLoader, SpeakerVerificationDataset\nfrom encoder.model import SpeakerEncoder\nfrom encoder.params_model import *\nfrom encoder.visualizations import Visualizations\nfrom utils.profiler import Profiler\n\n\ndef sync(device: torch.device):\n    # For correct profiling (cuda operations are async)\n    if device.type == \"cuda\":\n        torch.cuda.synchronize(device)\n\n\ndef train(run_id: str, clean_data_root: Path, models_dir: Path, umap_every: int, save_every: int,\n          backup_every: int, vis_every: int, force_restart: bool, visdom_server: str,\n          no_visdom: bool):\n    # Create a dataset and a dataloader\n    dataset = SpeakerVerificationDataset(clean_data_root)\n    loader = SpeakerVerificationDataLoader(\n        dataset,\n        speakers_per_batch,\n        utterances_per_speaker,\n        num_workers=4,\n    )\n\n    # Setup the device on which to run the forward pass and the loss. These can be different,\n    # because the forward pass is faster on the GPU whereas the loss is often (depending on your\n    # hyperparameters) faster on the CPU.\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    # FIXME: currently, the gradient is None if loss_device is cuda\n    loss_device = torch.device(\"cpu\")\n\n    # Create the model and the optimizer\n    model = SpeakerEncoder(device, loss_device)\n    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate_init)\n    init_step = 1\n\n    # Configure file path for the model\n    model_dir = models_dir / run_id\n    model_dir.mkdir(exist_ok=True, parents=True)\n    state_fpath = model_dir / \"encoder.pt\"\n\n    # Load any existing model\n    if not force_restart:\n        if state_fpath.exists():\n            print(\"Found existing model \\\"%s\\\", loading it and resuming training.\" % run_id)\n            checkpoint = torch.load(state_fpath)\n            init_step = checkpoint[\"step\"]\n            model.load_state_dict(checkpoint[\"model_state\"])\n            optimizer.load_state_dict(checkpoint[\"optimizer_state\"])\n            optimizer.param_groups[0][\"lr\"] = learning_rate_init\n        else:\n            print(\"No model \\\"%s\\\" found, starting training from scratch.\" % run_id)\n    else:\n        print(\"Starting the training from scratch.\")\n    model.train()\n\n    # Initialize the visualization environment\n    vis = Visualizations(run_id, vis_every, server=visdom_server, disabled=no_visdom)\n    vis.log_dataset(dataset)\n    vis.log_params()\n    device_name = str(torch.cuda.get_device_name(0) if torch.cuda.is_available() else \"CPU\")\n    vis.log_implementation({\"Device\": device_name})\n\n    # Training loop\n    profiler = Profiler(summarize_every=10, disabled=False)\n    for step, speaker_batch in enumerate(loader, init_step):\n        profiler.tick(\"Blocking, waiting for batch (threaded)\")\n\n        # Forward pass\n        inputs = torch.from_numpy(speaker_batch.data).to(device)\n        sync(device)\n        profiler.tick(\"Data to %s\" % device)\n        embeds = model(inputs)\n        sync(device)\n        profiler.tick(\"Forward pass\")\n        embeds_loss = embeds.view((speakers_per_batch, utterances_per_speaker, -1)).to(loss_device)\n        loss, eer = model.loss(embeds_loss)\n        sync(loss_device)\n        profiler.tick(\"Loss\")\n\n        # Backward pass\n        model.zero_grad()\n        loss.backward()\n        profiler.tick(\"Backward pass\")\n        model.do_gradient_ops()\n        optimizer.step()\n        profiler.tick(\"Parameter update\")\n\n        # Update visualizations\n        # learning_rate = optimizer.param_groups[0][\"lr\"]\n        vis.update(loss.item(), eer, step)\n\n        # Draw projections and save them to the backup folder\n        if umap_every != 0 and step % umap_every == 0:\n            print(\"Drawing and saving projections (step %d)\" % step)\n            projection_fpath = model_dir / f\"umap_{step:06d}.png\"\n            embeds = embeds.detach().cpu().numpy()\n            vis.draw_projections(embeds, utterances_per_speaker, step, projection_fpath)\n            vis.save()\n\n        # Overwrite the latest version of the model\n        if save_every != 0 and step % save_every == 0:\n            print(\"Saving the model (step %d)\" % step)\n            torch.save({\n                \"step\": step + 1,\n                \"model_state\": model.state_dict(),\n                \"optimizer_state\": optimizer.state_dict(),\n            }, state_fpath)\n\n        # Make a backup\n        if backup_every != 0 and step % backup_every == 0:\n            print(\"Making a backup (step %d)\" % step)\n            backup_fpath = model_dir / f\"encoder_{step:06d}.bak\"\n            torch.save({\n                \"step\": step + 1,\n                \"model_state\": model.state_dict(),\n                \"optimizer_state\": optimizer.state_dict(),\n            }, backup_fpath)\n\n        profiler.tick(\"Extras (visualizations, saving)\")\n", "encoder/config.py": "librispeech_datasets = {\n    \"train\": {\n        \"clean\": [\"LibriSpeech/train-clean-100\", \"LibriSpeech/train-clean-360\"],\n        \"other\": [\"LibriSpeech/train-other-500\"]\n    },\n    \"test\": {\n        \"clean\": [\"LibriSpeech/test-clean\"],\n        \"other\": [\"LibriSpeech/test-other\"]\n    },\n    \"dev\": {\n        \"clean\": [\"LibriSpeech/dev-clean\"],\n        \"other\": [\"LibriSpeech/dev-other\"]\n    },\n}\nlibritts_datasets = {\n    \"train\": {\n        \"clean\": [\"LibriTTS/train-clean-100\", \"LibriTTS/train-clean-360\"],\n        \"other\": [\"LibriTTS/train-other-500\"]\n    },\n    \"test\": {\n        \"clean\": [\"LibriTTS/test-clean\"],\n        \"other\": [\"LibriTTS/test-other\"]\n    },\n    \"dev\": {\n        \"clean\": [\"LibriTTS/dev-clean\"],\n        \"other\": [\"LibriTTS/dev-other\"]\n    },\n}\nvoxceleb_datasets = {\n    \"voxceleb1\" : {\n        \"train\": [\"VoxCeleb1/wav\"],\n        \"test\": [\"VoxCeleb1/test_wav\"]\n    },\n    \"voxceleb2\" : {\n        \"train\": [\"VoxCeleb2/dev/aac\"],\n        \"test\": [\"VoxCeleb2/test_wav\"]\n    }\n}\n\nother_datasets = [\n    \"LJSpeech-1.1\",\n    \"VCTK-Corpus/wav48\",\n]\n\nanglophone_nationalites = [\"australia\", \"canada\", \"ireland\", \"uk\", \"usa\"]\n", "encoder/visualizations.py": "from datetime import datetime\nfrom time import perf_counter as timer\n\nimport numpy as np\nimport umap\nimport visdom\n\nfrom encoder.data_objects.speaker_verification_dataset import SpeakerVerificationDataset\n\n\ncolormap = np.array([\n    [76, 255, 0],\n    [0, 127, 70],\n    [255, 0, 0],\n    [255, 217, 38],\n    [0, 135, 255],\n    [165, 0, 165],\n    [255, 167, 255],\n    [0, 255, 255],\n    [255, 96, 38],\n    [142, 76, 0],\n    [33, 0, 127],\n    [0, 0, 0],\n    [183, 183, 183],\n], dtype=np.float) / 255\n\n\nclass Visualizations:\n    def __init__(self, env_name=None, update_every=10, server=\"http://localhost\", disabled=False):\n        # Tracking data\n        self.last_update_timestamp = timer()\n        self.update_every = update_every\n        self.step_times = []\n        self.losses = []\n        self.eers = []\n        print(\"Updating the visualizations every %d steps.\" % update_every)\n\n        # If visdom is disabled TODO: use a better paradigm for that\n        self.disabled = disabled\n        if self.disabled:\n            return\n\n        # Set the environment name\n        now = str(datetime.now().strftime(\"%d-%m %Hh%M\"))\n        if env_name is None:\n            self.env_name = now\n        else:\n            self.env_name = \"%s (%s)\" % (env_name, now)\n\n        # Connect to visdom and open the corresponding window in the browser\n        try:\n            self.vis = visdom.Visdom(server, env=self.env_name, raise_exceptions=True)\n        except ConnectionError:\n            raise Exception(\"No visdom server detected. Run the command \\\"visdom\\\" in your CLI to \"\n                            \"start it.\")\n        # webbrowser.open(\"http://localhost:8097/env/\" + self.env_name)\n\n        # Create the windows\n        self.loss_win = None\n        self.eer_win = None\n        # self.lr_win = None\n        self.implementation_win = None\n        self.projection_win = None\n        self.implementation_string = \"\"\n\n    def log_params(self):\n        if self.disabled:\n            return\n        from encoder import params_data\n        from encoder import params_model\n        param_string = \"<b>Model parameters</b>:<br>\"\n        for param_name in (p for p in dir(params_model) if not p.startswith(\"__\")):\n            value = getattr(params_model, param_name)\n            param_string += \"\\t%s: %s<br>\" % (param_name, value)\n        param_string += \"<b>Data parameters</b>:<br>\"\n        for param_name in (p for p in dir(params_data) if not p.startswith(\"__\")):\n            value = getattr(params_data, param_name)\n            param_string += \"\\t%s: %s<br>\" % (param_name, value)\n        self.vis.text(param_string, opts={\"title\": \"Parameters\"})\n\n    def log_dataset(self, dataset: SpeakerVerificationDataset):\n        if self.disabled:\n            return\n        dataset_string = \"\"\n        dataset_string += \"<b>Speakers</b>: %s\\n\" % len(dataset.speakers)\n        dataset_string += \"\\n\" + dataset.get_logs()\n        dataset_string = dataset_string.replace(\"\\n\", \"<br>\")\n        self.vis.text(dataset_string, opts={\"title\": \"Dataset\"})\n\n    def log_implementation(self, params):\n        if self.disabled:\n            return\n        implementation_string = \"\"\n        for param, value in params.items():\n            implementation_string += \"<b>%s</b>: %s\\n\" % (param, value)\n            implementation_string = implementation_string.replace(\"\\n\", \"<br>\")\n        self.implementation_string = implementation_string\n        self.implementation_win = self.vis.text(\n            implementation_string,\n            opts={\"title\": \"Training implementation\"}\n        )\n\n    def update(self, loss, eer, step):\n        # Update the tracking data\n        now = timer()\n        self.step_times.append(1000 * (now - self.last_update_timestamp))\n        self.last_update_timestamp = now\n        self.losses.append(loss)\n        self.eers.append(eer)\n        print(\".\", end=\"\")\n\n        # Update the plots every <update_every> steps\n        if step % self.update_every != 0:\n            return\n        time_string = \"Step time:  mean: %5dms  std: %5dms\" % \\\n                      (int(np.mean(self.step_times)), int(np.std(self.step_times)))\n        print(\"\\nStep %6d   Loss: %.4f   EER: %.4f   %s\" %\n              (step, np.mean(self.losses), np.mean(self.eers), time_string))\n        if not self.disabled:\n            self.loss_win = self.vis.line(\n                [np.mean(self.losses)],\n                [step],\n                win=self.loss_win,\n                update=\"append\" if self.loss_win else None,\n                opts=dict(\n                    legend=[\"Avg. loss\"],\n                    xlabel=\"Step\",\n                    ylabel=\"Loss\",\n                    title=\"Loss\",\n                )\n            )\n            self.eer_win = self.vis.line(\n                [np.mean(self.eers)],\n                [step],\n                win=self.eer_win,\n                update=\"append\" if self.eer_win else None,\n                opts=dict(\n                    legend=[\"Avg. EER\"],\n                    xlabel=\"Step\",\n                    ylabel=\"EER\",\n                    title=\"Equal error rate\"\n                )\n            )\n            if self.implementation_win is not None:\n                self.vis.text(\n                    self.implementation_string + (\"<b>%s</b>\" % time_string),\n                    win=self.implementation_win,\n                    opts={\"title\": \"Training implementation\"},\n                )\n\n        # Reset the tracking\n        self.losses.clear()\n        self.eers.clear()\n        self.step_times.clear()\n\n    def draw_projections(self, embeds, utterances_per_speaker, step, out_fpath=None, max_speakers=10):\n        import matplotlib.pyplot as plt\n\n        max_speakers = min(max_speakers, len(colormap))\n        embeds = embeds[:max_speakers * utterances_per_speaker]\n\n        n_speakers = len(embeds) // utterances_per_speaker\n        ground_truth = np.repeat(np.arange(n_speakers), utterances_per_speaker)\n        colors = [colormap[i] for i in ground_truth]\n\n        reducer = umap.UMAP()\n        projected = reducer.fit_transform(embeds)\n        plt.scatter(projected[:, 0], projected[:, 1], c=colors)\n        plt.gca().set_aspect(\"equal\", \"datalim\")\n        plt.title(\"UMAP projection (step %d)\" % step)\n        if not self.disabled:\n            self.projection_win = self.vis.matplot(plt, win=self.projection_win)\n        if out_fpath is not None:\n            plt.savefig(out_fpath)\n        plt.clf()\n\n    def save(self):\n        if not self.disabled:\n            self.vis.save([self.env_name])\n", "encoder/audio.py": "from scipy.ndimage.morphology import binary_dilation\nfrom encoder.params_data import *\nfrom pathlib import Path\nfrom typing import Optional, Union\nfrom warnings import warn\nimport numpy as np\nimport librosa\nimport struct\n\ntry:\n    import webrtcvad\nexcept:\n    warn(\"Unable to import 'webrtcvad'. This package enables noise removal and is recommended.\")\n    webrtcvad=None\n\nint16_max = (2 ** 15) - 1\n\n\ndef preprocess_wav(fpath_or_wav: Union[str, Path, np.ndarray],\n                   source_sr: Optional[int] = None,\n                   normalize: Optional[bool] = True,\n                   trim_silence: Optional[bool] = True):\n    \"\"\"\n    Applies the preprocessing operations used in training the Speaker Encoder to a waveform \n    either on disk or in memory. The waveform will be resampled to match the data hyperparameters.\n\n    :param fpath_or_wav: either a filepath to an audio file (many extensions are supported, not \n    just .wav), either the waveform as a numpy array of floats.\n    :param source_sr: if passing an audio waveform, the sampling rate of the waveform before \n    preprocessing. After preprocessing, the waveform's sampling rate will match the data \n    hyperparameters. If passing a filepath, the sampling rate will be automatically detected and \n    this argument will be ignored.\n    \"\"\"\n    # Load the wav from disk if needed\n    if isinstance(fpath_or_wav, str) or isinstance(fpath_or_wav, Path):\n        wav, source_sr = librosa.load(str(fpath_or_wav), sr=None)\n    else:\n        wav = fpath_or_wav\n    \n    # Resample the wav if needed\n    if source_sr is not None and source_sr != sampling_rate:\n        wav = librosa.resample(wav, source_sr, sampling_rate)\n        \n    # Apply the preprocessing: normalize volume and shorten long silences \n    if normalize:\n        wav = normalize_volume(wav, audio_norm_target_dBFS, increase_only=True)\n    if webrtcvad and trim_silence:\n        wav = trim_long_silences(wav)\n    \n    return wav\n\n\ndef wav_to_mel_spectrogram(wav):\n    \"\"\"\n    Derives a mel spectrogram ready to be used by the encoder from a preprocessed audio waveform.\n    Note: this not a log-mel spectrogram.\n    \"\"\"\n    frames = librosa.feature.melspectrogram(\n        wav,\n        sampling_rate,\n        n_fft=int(sampling_rate * mel_window_length / 1000),\n        hop_length=int(sampling_rate * mel_window_step / 1000),\n        n_mels=mel_n_channels\n    )\n    return frames.astype(np.float32).T\n\n\ndef trim_long_silences(wav):\n    \"\"\"\n    Ensures that segments without voice in the waveform remain no longer than a \n    threshold determined by the VAD parameters in params.py.\n\n    :param wav: the raw waveform as a numpy array of floats \n    :return: the same waveform with silences trimmed away (length <= original wav length)\n    \"\"\"\n    # Compute the voice detection window size\n    samples_per_window = (vad_window_length * sampling_rate) // 1000\n    \n    # Trim the end of the audio to have a multiple of the window size\n    wav = wav[:len(wav) - (len(wav) % samples_per_window)]\n    \n    # Convert the float waveform to 16-bit mono PCM\n    pcm_wave = struct.pack(\"%dh\" % len(wav), *(np.round(wav * int16_max)).astype(np.int16))\n    \n    # Perform voice activation detection\n    voice_flags = []\n    vad = webrtcvad.Vad(mode=3)\n    for window_start in range(0, len(wav), samples_per_window):\n        window_end = window_start + samples_per_window\n        voice_flags.append(vad.is_speech(pcm_wave[window_start * 2:window_end * 2],\n                                         sample_rate=sampling_rate))\n    voice_flags = np.array(voice_flags)\n    \n    # Smooth the voice detection with a moving average\n    def moving_average(array, width):\n        array_padded = np.concatenate((np.zeros((width - 1) // 2), array, np.zeros(width // 2)))\n        ret = np.cumsum(array_padded, dtype=float)\n        ret[width:] = ret[width:] - ret[:-width]\n        return ret[width - 1:] / width\n    \n    audio_mask = moving_average(voice_flags, vad_moving_average_width)\n    audio_mask = np.round(audio_mask).astype(np.bool)\n    \n    # Dilate the voiced regions\n    audio_mask = binary_dilation(audio_mask, np.ones(vad_max_silence_length + 1))\n    audio_mask = np.repeat(audio_mask, samples_per_window)\n    \n    return wav[audio_mask == True]\n\n\ndef normalize_volume(wav, target_dBFS, increase_only=False, decrease_only=False):\n    if increase_only and decrease_only:\n        raise ValueError(\"Both increase only and decrease only are set\")\n    dBFS_change = target_dBFS - 10 * np.log10(np.mean(wav ** 2))\n    if (dBFS_change < 0 and increase_only) or (dBFS_change > 0 and decrease_only):\n        return wav\n    return wav * (10 ** (dBFS_change / 20))\n", "encoder/params_model.py": "\n## Model parameters\nmodel_hidden_size = 256\nmodel_embedding_size = 256\nmodel_num_layers = 3\n\n\n## Training parameters\nlearning_rate_init = 1e-4\nspeakers_per_batch = 64\nutterances_per_speaker = 10\n", "encoder/__init__.py": "", "encoder/inference.py": "from encoder.params_data import *\nfrom encoder.model import SpeakerEncoder\nfrom encoder.audio import preprocess_wav   # We want to expose this function from here\nfrom matplotlib import cm\nfrom encoder import audio\nfrom pathlib import Path\nimport numpy as np\nimport torch\n\n_model = None # type: SpeakerEncoder\n_device = None # type: torch.device\n\n\ndef load_model(weights_fpath: Path, device=None):\n    \"\"\"\n    Loads the model in memory. If this function is not explicitely called, it will be run on the\n    first call to embed_frames() with the default weights file.\n\n    :param weights_fpath: the path to saved model weights.\n    :param device: either a torch device or the name of a torch device (e.g. \"cpu\", \"cuda\"). The\n    model will be loaded and will run on this device. Outputs will however always be on the cpu.\n    If None, will default to your GPU if it\"s available, otherwise your CPU.\n    \"\"\"\n    # TODO: I think the slow loading of the encoder might have something to do with the device it\n    #   was saved on. Worth investigating.\n    global _model, _device\n    if device is None:\n        _device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    elif isinstance(device, str):\n        _device = torch.device(device)\n    _model = SpeakerEncoder(_device, torch.device(\"cpu\"))\n    checkpoint = torch.load(weights_fpath, _device)\n    _model.load_state_dict(checkpoint[\"model_state\"])\n    _model.eval()\n    print(\"Loaded encoder \\\"%s\\\" trained to step %d\" % (weights_fpath.name, checkpoint[\"step\"]))\n\n\ndef is_loaded():\n    return _model is not None\n\n\ndef embed_frames_batch(frames_batch):\n    \"\"\"\n    Computes embeddings for a batch of mel spectrogram.\n\n    :param frames_batch: a batch mel of spectrogram as a numpy array of float32 of shape\n    (batch_size, n_frames, n_channels)\n    :return: the embeddings as a numpy array of float32 of shape (batch_size, model_embedding_size)\n    \"\"\"\n    if _model is None:\n        raise Exception(\"Model was not loaded. Call load_model() before inference.\")\n\n    frames = torch.from_numpy(frames_batch).to(_device)\n    embed = _model.forward(frames).detach().cpu().numpy()\n    return embed\n\n\ndef compute_partial_slices(n_samples, partial_utterance_n_frames=partials_n_frames,\n                           min_pad_coverage=0.75, overlap=0.5):\n    \"\"\"\n    Computes where to split an utterance waveform and its corresponding mel spectrogram to obtain\n    partial utterances of <partial_utterance_n_frames> each. Both the waveform and the mel\n    spectrogram slices are returned, so as to make each partial utterance waveform correspond to\n    its spectrogram. This function assumes that the mel spectrogram parameters used are those\n    defined in params_data.py.\n\n    The returned ranges may be indexing further than the length of the waveform. It is\n    recommended that you pad the waveform with zeros up to wave_slices[-1].stop.\n\n    :param n_samples: the number of samples in the waveform\n    :param partial_utterance_n_frames: the number of mel spectrogram frames in each partial\n    utterance\n    :param min_pad_coverage: when reaching the last partial utterance, it may or may not have\n    enough frames. If at least <min_pad_coverage> of <partial_utterance_n_frames> are present,\n    then the last partial utterance will be considered, as if we padded the audio. Otherwise,\n    it will be discarded, as if we trimmed the audio. If there aren't enough frames for 1 partial\n    utterance, this parameter is ignored so that the function always returns at least 1 slice.\n    :param overlap: by how much the partial utterance should overlap. If set to 0, the partial\n    utterances are entirely disjoint.\n    :return: the waveform slices and mel spectrogram slices as lists of array slices. Index\n    respectively the waveform and the mel spectrogram with these slices to obtain the partial\n    utterances.\n    \"\"\"\n    assert 0 <= overlap < 1\n    assert 0 < min_pad_coverage <= 1\n\n    samples_per_frame = int((sampling_rate * mel_window_step / 1000))\n    n_frames = int(np.ceil((n_samples + 1) / samples_per_frame))\n    frame_step = max(int(np.round(partial_utterance_n_frames * (1 - overlap))), 1)\n\n    # Compute the slices\n    wav_slices, mel_slices = [], []\n    steps = max(1, n_frames - partial_utterance_n_frames + frame_step + 1)\n    for i in range(0, steps, frame_step):\n        mel_range = np.array([i, i + partial_utterance_n_frames])\n        wav_range = mel_range * samples_per_frame\n        mel_slices.append(slice(*mel_range))\n        wav_slices.append(slice(*wav_range))\n\n    # Evaluate whether extra padding is warranted or not\n    last_wav_range = wav_slices[-1]\n    coverage = (n_samples - last_wav_range.start) / (last_wav_range.stop - last_wav_range.start)\n    if coverage < min_pad_coverage and len(mel_slices) > 1:\n        mel_slices = mel_slices[:-1]\n        wav_slices = wav_slices[:-1]\n\n    return wav_slices, mel_slices\n\n\ndef embed_utterance(wav, using_partials=True, return_partials=False, **kwargs):\n    \"\"\"\n    Computes an embedding for a single utterance.\n\n    # TODO: handle multiple wavs to benefit from batching on GPU\n    :param wav: a preprocessed (see audio.py) utterance waveform as a numpy array of float32\n    :param using_partials: if True, then the utterance is split in partial utterances of\n    <partial_utterance_n_frames> frames and the utterance embedding is computed from their\n    normalized average. If False, the utterance is instead computed from feeding the entire\n    spectogram to the network.\n    :param return_partials: if True, the partial embeddings will also be returned along with the\n    wav slices that correspond to the partial embeddings.\n    :param kwargs: additional arguments to compute_partial_splits()\n    :return: the embedding as a numpy array of float32 of shape (model_embedding_size,). If\n    <return_partials> is True, the partial utterances as a numpy array of float32 of shape\n    (n_partials, model_embedding_size) and the wav partials as a list of slices will also be\n    returned. If <using_partials> is simultaneously set to False, both these values will be None\n    instead.\n    \"\"\"\n    # Process the entire utterance if not using partials\n    if not using_partials:\n        frames = audio.wav_to_mel_spectrogram(wav)\n        embed = embed_frames_batch(frames[None, ...])[0]\n        if return_partials:\n            return embed, None, None\n        return embed\n\n    # Compute where to split the utterance into partials and pad if necessary\n    wave_slices, mel_slices = compute_partial_slices(len(wav), **kwargs)\n    max_wave_length = wave_slices[-1].stop\n    if max_wave_length >= len(wav):\n        wav = np.pad(wav, (0, max_wave_length - len(wav)), \"constant\")\n\n    # Split the utterance into partials\n    frames = audio.wav_to_mel_spectrogram(wav)\n    frames_batch = np.array([frames[s] for s in mel_slices])\n    partial_embeds = embed_frames_batch(frames_batch)\n\n    # Compute the utterance embedding from the partial embeddings\n    raw_embed = np.mean(partial_embeds, axis=0)\n    embed = raw_embed / np.linalg.norm(raw_embed, 2)\n\n    if return_partials:\n        return embed, partial_embeds, wave_slices\n    return embed\n\n\ndef embed_speaker(wavs, **kwargs):\n    raise NotImplemented()\n\n\ndef plot_embedding_as_heatmap(embed, ax=None, title=\"\", shape=None, color_range=(0, 0.30)):\n    import matplotlib.pyplot as plt\n    if ax is None:\n        ax = plt.gca()\n\n    if shape is None:\n        height = int(np.sqrt(len(embed)))\n        shape = (height, -1)\n    embed = embed.reshape(shape)\n\n    cmap = cm.get_cmap()\n    mappable = ax.imshow(embed, cmap=cmap)\n    cbar = plt.colorbar(mappable, ax=ax, fraction=0.046, pad=0.04)\n    sm = cm.ScalarMappable(cmap=cmap)\n    sm.set_clim(*color_range)\n\n    ax.set_xticks([]), ax.set_yticks([])\n    ax.set_title(title)\n", "toolbox/ui.py": "import sys\nfrom pathlib import Path\nfrom time import sleep\nfrom typing import List, Set\nfrom warnings import filterwarnings, warn\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sounddevice as sd\nimport soundfile as sf\nimport umap\nfrom PyQt5.QtCore import Qt, QStringListModel\nfrom PyQt5.QtWidgets import *\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\n\nfrom encoder.inference import plot_embedding_as_heatmap\nfrom toolbox.utterance import Utterance\n\nfilterwarnings(\"ignore\")\n\n\ncolormap = np.array([\n    [0, 127, 70],\n    [255, 0, 0],\n    [255, 217, 38],\n    [0, 135, 255],\n    [165, 0, 165],\n    [255, 167, 255],\n    [97, 142, 151],\n    [0, 255, 255],\n    [255, 96, 38],\n    [142, 76, 0],\n    [33, 0, 127],\n    [0, 0, 0],\n    [183, 183, 183],\n    [76, 255, 0],\n], dtype=np.float) / 255\n\ndefault_text = \\\n    \"Welcome to the toolbox! To begin, load an utterance from your datasets or record one \" \\\n    \"yourself.\\nOnce its embedding has been created, you can synthesize any text written here.\\n\" \\\n    \"The synthesizer expects to generate \" \\\n    \"outputs that are somewhere between 5 and 12 seconds.\\nTo mark breaks, write a new line. \" \\\n    \"Each line will be treated separately.\\nThen, they are joined together to make the final \" \\\n    \"spectrogram. Use the vocoder to generate audio.\\nThe vocoder generates almost in constant \" \\\n    \"time, so it will be more time efficient for longer inputs like this one.\\nOn the left you \" \\\n    \"have the embedding projections. Load or record more utterances to see them.\\nIf you have \" \\\n    \"at least 2 or 3 utterances from a same speaker, a cluster should form.\\nSynthesized \" \\\n    \"utterances are of the same color as the speaker whose voice was used, but they're \" \\\n    \"represented with a cross.\"\n\n\nclass UI(QDialog):\n    min_umap_points = 4\n    max_log_lines = 5\n    max_saved_utterances = 20\n\n    def draw_utterance(self, utterance: Utterance, which):\n        self.draw_spec(utterance.spec, which)\n        self.draw_embed(utterance.embed, utterance.name, which)\n\n    def draw_embed(self, embed, name, which):\n        embed_ax, _ = self.current_ax if which == \"current\" else self.gen_ax\n        embed_ax.figure.suptitle(\"\" if embed is None else name)\n\n        ## Embedding\n        # Clear the plot\n        if len(embed_ax.images) > 0:\n            embed_ax.images[0].colorbar.remove()\n        embed_ax.clear()\n\n        # Draw the embed\n        if embed is not None:\n            plot_embedding_as_heatmap(embed, embed_ax)\n            embed_ax.set_title(\"embedding\")\n        embed_ax.set_aspect(\"equal\", \"datalim\")\n        embed_ax.set_xticks([])\n        embed_ax.set_yticks([])\n        embed_ax.figure.canvas.draw()\n\n    def draw_spec(self, spec, which):\n        _, spec_ax = self.current_ax if which == \"current\" else self.gen_ax\n\n        ## Spectrogram\n        # Draw the spectrogram\n        spec_ax.clear()\n        if spec is not None:\n            spec_ax.imshow(spec, aspect=\"auto\", interpolation=\"none\")\n            spec_ax.set_title(\"mel spectrogram\")\n\n        spec_ax.set_xticks([])\n        spec_ax.set_yticks([])\n        spec_ax.figure.canvas.draw()\n        if which != \"current\":\n            self.vocode_button.setDisabled(spec is None)\n\n    def draw_umap_projections(self, utterances: Set[Utterance]):\n        self.umap_ax.clear()\n\n        speakers = np.unique([u.speaker_name for u in utterances])\n        colors = {speaker_name: colormap[i] for i, speaker_name in enumerate(speakers)}\n        embeds = [u.embed for u in utterances]\n\n        # Display a message if there aren't enough points\n        if len(utterances) < self.min_umap_points:\n            self.umap_ax.text(.5, .5, \"Add %d more points to\\ngenerate the projections\" %\n                              (self.min_umap_points - len(utterances)),\n                              horizontalalignment='center', fontsize=15)\n            self.umap_ax.set_title(\"\")\n\n        # Compute the projections\n        else:\n            if not self.umap_hot:\n                self.log(\n                    \"Drawing UMAP projections for the first time, this will take a few seconds.\")\n                self.umap_hot = True\n\n            reducer = umap.UMAP(int(np.ceil(np.sqrt(len(embeds)))), metric=\"cosine\")\n            projections = reducer.fit_transform(embeds)\n\n            speakers_done = set()\n            for projection, utterance in zip(projections, utterances):\n                color = colors[utterance.speaker_name]\n                mark = \"x\" if \"_gen_\" in utterance.name else \"o\"\n                label = None if utterance.speaker_name in speakers_done else utterance.speaker_name\n                speakers_done.add(utterance.speaker_name)\n                self.umap_ax.scatter(projection[0], projection[1], c=[color], marker=mark,\n                                     label=label)\n            self.umap_ax.legend(prop={'size': 10})\n\n        # Draw the plot\n        self.umap_ax.set_aspect(\"equal\", \"datalim\")\n        self.umap_ax.set_xticks([])\n        self.umap_ax.set_yticks([])\n        self.umap_ax.figure.canvas.draw()\n\n    def save_audio_file(self, wav, sample_rate):\n        dialog = QFileDialog()\n        dialog.setDefaultSuffix(\".wav\")\n        fpath, _ = dialog.getSaveFileName(\n            parent=self,\n            caption=\"Select a path to save the audio file\",\n            filter=\"Audio Files (*.flac *.wav)\"\n        )\n        if fpath:\n            #Default format is wav\n            if Path(fpath).suffix == \"\":\n                fpath += \".wav\"\n            sf.write(fpath, wav, sample_rate)\n\n    def setup_audio_devices(self, sample_rate):\n        input_devices = []\n        output_devices = []\n        for device in sd.query_devices():\n            # Check if valid input\n            try:\n                sd.check_input_settings(device=device[\"name\"], samplerate=sample_rate)\n                input_devices.append(device[\"name\"])\n            except:\n                pass\n\n            # Check if valid output\n            try:\n                sd.check_output_settings(device=device[\"name\"], samplerate=sample_rate)\n                output_devices.append(device[\"name\"])\n            except Exception as e:\n                # Log a warning only if the device is not an input\n                if not device[\"name\"] in input_devices:\n                    warn(\"Unsupported output device %s for the sample rate: %d \\nError: %s\" % (device[\"name\"], sample_rate, str(e)))\n\n        if len(input_devices) == 0:\n            self.log(\"No audio input device detected. Recording may not work.\")\n            self.audio_in_device = None\n        else:\n            self.audio_in_device = input_devices[0]\n\n        if len(output_devices) == 0:\n            self.log(\"No supported output audio devices were found! Audio output may not work.\")\n            self.audio_out_devices_cb.addItems([\"None\"])\n            self.audio_out_devices_cb.setDisabled(True)\n        else:\n            self.audio_out_devices_cb.clear()\n            self.audio_out_devices_cb.addItems(output_devices)\n            self.audio_out_devices_cb.currentTextChanged.connect(self.set_audio_device)\n\n        self.set_audio_device()\n\n    def set_audio_device(self):\n\n        output_device = self.audio_out_devices_cb.currentText()\n        if output_device == \"None\":\n            output_device = None\n\n        # If None, sounddevice queries portaudio\n        sd.default.device = (self.audio_in_device, output_device)\n\n    def play(self, wav, sample_rate):\n        try:\n            sd.stop()\n            sd.play(wav, sample_rate)\n        except Exception as e:\n            print(e)\n            self.log(\"Error in audio playback. Try selecting a different audio output device.\")\n            self.log(\"Your device must be connected before you start the toolbox.\")\n\n    def stop(self):\n        sd.stop()\n\n    def record_one(self, sample_rate, duration):\n        self.record_button.setText(\"Recording...\")\n        self.record_button.setDisabled(True)\n\n        self.log(\"Recording %d seconds of audio\" % duration)\n        sd.stop()\n        try:\n            wav = sd.rec(duration * sample_rate, sample_rate, 1)\n        except Exception as e:\n            print(e)\n            self.log(\"Could not record anything. Is your recording device enabled?\")\n            self.log(\"Your device must be connected before you start the toolbox.\")\n            return None\n\n        for i in np.arange(0, duration, 0.1):\n            self.set_loading(i, duration)\n            sleep(0.1)\n        self.set_loading(duration, duration)\n        sd.wait()\n\n        self.log(\"Done recording.\")\n        self.record_button.setText(\"Record\")\n        self.record_button.setDisabled(False)\n\n        return wav.squeeze()\n\n    @property\n    def current_dataset_name(self):\n        return self.dataset_box.currentText()\n\n    @property\n    def current_speaker_name(self):\n        return self.speaker_box.currentText()\n\n    @property\n    def current_utterance_name(self):\n        return self.utterance_box.currentText()\n\n    def browse_file(self):\n        fpath = QFileDialog().getOpenFileName(\n            parent=self,\n            caption=\"Select an audio file\",\n            filter=\"Audio Files (*.mp3 *.flac *.wav *.m4a)\"\n        )\n        return Path(fpath[0]) if fpath[0] != \"\" else \"\"\n\n    @staticmethod\n    def repopulate_box(box, items, random=False):\n        \"\"\"\n        Resets a box and adds a list of items. Pass a list of (item, data) pairs instead to join\n        data to the items\n        \"\"\"\n        box.blockSignals(True)\n        box.clear()\n        for item in items:\n            item = list(item) if isinstance(item, tuple) else [item]\n            box.addItem(str(item[0]), *item[1:])\n        if len(items) > 0:\n            box.setCurrentIndex(np.random.randint(len(items)) if random else 0)\n        box.setDisabled(len(items) == 0)\n        box.blockSignals(False)\n\n    def populate_browser(self, datasets_root: Path, recognized_datasets: List, level: int,\n                         random=True):\n        # Select a random dataset\n        if level <= 0:\n            if datasets_root is not None:\n                datasets = [datasets_root.joinpath(d) for d in recognized_datasets]\n                datasets = [d.relative_to(datasets_root) for d in datasets if d.exists()]\n                self.browser_load_button.setDisabled(len(datasets) == 0)\n            if datasets_root is None or len(datasets) == 0:\n                msg = \"Warning: you d\" + (\"id not pass a root directory for datasets as argument\" \\\n                    if datasets_root is None else \"o not have any of the recognized datasets\" \\\n                                                  \" in %s\" % datasets_root)\n                self.log(msg)\n                msg += \".\\nThe recognized datasets are:\\n\\t%s\\nFeel free to add your own. You \" \\\n                       \"can still use the toolbox by recording samples yourself.\" % \\\n                       (\"\\n\\t\".join(recognized_datasets))\n                print(msg, file=sys.stderr)\n\n                self.random_utterance_button.setDisabled(True)\n                self.random_speaker_button.setDisabled(True)\n                self.random_dataset_button.setDisabled(True)\n                self.utterance_box.setDisabled(True)\n                self.speaker_box.setDisabled(True)\n                self.dataset_box.setDisabled(True)\n                self.browser_load_button.setDisabled(True)\n                self.auto_next_checkbox.setDisabled(True)\n                return\n            self.repopulate_box(self.dataset_box, datasets, random)\n\n        # Select a random speaker\n        if level <= 1:\n            speakers_root = datasets_root.joinpath(self.current_dataset_name)\n            speaker_names = [d.stem for d in speakers_root.glob(\"*\") if d.is_dir()]\n            self.repopulate_box(self.speaker_box, speaker_names, random)\n\n        # Select a random utterance\n        if level <= 2:\n            utterances_root = datasets_root.joinpath(\n                self.current_dataset_name,\n                self.current_speaker_name\n            )\n            utterances = []\n            for extension in ['mp3', 'flac', 'wav', 'm4a']:\n                utterances.extend(Path(utterances_root).glob(\"**/*.%s\" % extension))\n            utterances = [fpath.relative_to(utterances_root) for fpath in utterances]\n            self.repopulate_box(self.utterance_box, utterances, random)\n\n    def browser_select_next(self):\n        index = (self.utterance_box.currentIndex() + 1) % len(self.utterance_box)\n        self.utterance_box.setCurrentIndex(index)\n\n    @property\n    def current_encoder_fpath(self):\n        return self.encoder_box.itemData(self.encoder_box.currentIndex())\n\n    @property\n    def current_synthesizer_fpath(self):\n        return self.synthesizer_box.itemData(self.synthesizer_box.currentIndex())\n\n    @property\n    def current_vocoder_fpath(self):\n        return self.vocoder_box.itemData(self.vocoder_box.currentIndex())\n\n    def populate_models(self, models_dir: Path):\n        # Encoder\n        encoder_fpaths = list(models_dir.glob(\"*/encoder.pt\"))\n        if len(encoder_fpaths) == 0:\n            raise Exception(\"No encoder models found in %s\" % models_dir)\n        self.repopulate_box(self.encoder_box, [(f.parent.name, f) for f in encoder_fpaths])\n\n        # Synthesizer\n        synthesizer_fpaths = list(models_dir.glob(\"*/synthesizer.pt\"))\n        if len(synthesizer_fpaths) == 0:\n            raise Exception(\"No synthesizer models found in %s\" % models_dir)\n        self.repopulate_box(self.synthesizer_box, [(f.parent.name, f) for f in synthesizer_fpaths])\n\n        # Vocoder\n        vocoder_fpaths = list(models_dir.glob(\"*/vocoder.pt\"))\n        vocoder_items = [(f.parent.name, f) for f in vocoder_fpaths] + [(\"Griffin-Lim\", None)]\n        self.repopulate_box(self.vocoder_box, vocoder_items)\n\n    @property\n    def selected_utterance(self):\n        return self.utterance_history.itemData(self.utterance_history.currentIndex())\n\n    def register_utterance(self, utterance: Utterance):\n        self.utterance_history.blockSignals(True)\n        self.utterance_history.insertItem(0, utterance.name, utterance)\n        self.utterance_history.setCurrentIndex(0)\n        self.utterance_history.blockSignals(False)\n\n        if len(self.utterance_history) > self.max_saved_utterances:\n            self.utterance_history.removeItem(self.max_saved_utterances)\n\n        self.play_button.setDisabled(False)\n        self.generate_button.setDisabled(False)\n        self.synthesize_button.setDisabled(False)\n\n    def log(self, line, mode=\"newline\"):\n        if mode == \"newline\":\n            self.logs.append(line)\n            if len(self.logs) > self.max_log_lines:\n                del self.logs[0]\n        elif mode == \"append\":\n            self.logs[-1] += line\n        elif mode == \"overwrite\":\n            self.logs[-1] = line\n        log_text = '\\n'.join(self.logs)\n\n        self.log_window.setText(log_text)\n        self.app.processEvents()\n\n    def set_loading(self, value, maximum=1):\n        self.loading_bar.setValue(value * 100)\n        self.loading_bar.setMaximum(maximum * 100)\n        self.loading_bar.setTextVisible(value != 0)\n        self.app.processEvents()\n\n    def populate_gen_options(self, seed, trim_silences):\n        if seed is not None:\n            self.random_seed_checkbox.setChecked(True)\n            self.seed_textbox.setText(str(seed))\n            self.seed_textbox.setEnabled(True)\n        else:\n            self.random_seed_checkbox.setChecked(False)\n            self.seed_textbox.setText(str(0))\n            self.seed_textbox.setEnabled(False)\n\n        if not trim_silences:\n            self.trim_silences_checkbox.setChecked(False)\n            self.trim_silences_checkbox.setDisabled(True)\n\n    def update_seed_textbox(self):\n        if self.random_seed_checkbox.isChecked():\n            self.seed_textbox.setEnabled(True)\n        else:\n            self.seed_textbox.setEnabled(False)\n\n    def reset_interface(self):\n        self.draw_embed(None, None, \"current\")\n        self.draw_embed(None, None, \"generated\")\n        self.draw_spec(None, \"current\")\n        self.draw_spec(None, \"generated\")\n        self.draw_umap_projections(set())\n        self.set_loading(0)\n        self.play_button.setDisabled(True)\n        self.generate_button.setDisabled(True)\n        self.synthesize_button.setDisabled(True)\n        self.vocode_button.setDisabled(True)\n        self.replay_wav_button.setDisabled(True)\n        self.export_wav_button.setDisabled(True)\n        [self.log(\"\") for _ in range(self.max_log_lines)]\n\n    def __init__(self):\n        ## Initialize the application\n        self.app = QApplication(sys.argv)\n        super().__init__(None)\n        self.setWindowTitle(\"SV2TTS toolbox\")\n\n\n        ## Main layouts\n        # Root\n        root_layout = QGridLayout()\n        self.setLayout(root_layout)\n\n        # Browser\n        browser_layout = QGridLayout()\n        root_layout.addLayout(browser_layout, 0, 0, 1, 2)\n\n        # Generation\n        gen_layout = QVBoxLayout()\n        root_layout.addLayout(gen_layout, 0, 2, 1, 2)\n\n        # Projections\n        self.projections_layout = QVBoxLayout()\n        root_layout.addLayout(self.projections_layout, 1, 0, 1, 1)\n\n        # Visualizations\n        vis_layout = QVBoxLayout()\n        root_layout.addLayout(vis_layout, 1, 1, 1, 3)\n\n\n        ## Projections\n        # UMap\n        fig, self.umap_ax = plt.subplots(figsize=(3, 3), facecolor=\"#F0F0F0\")\n        fig.subplots_adjust(left=0.02, bottom=0.02, right=0.98, top=0.98)\n        self.projections_layout.addWidget(FigureCanvas(fig))\n        self.umap_hot = False\n        self.clear_button = QPushButton(\"Clear\")\n        self.projections_layout.addWidget(self.clear_button)\n\n\n        ## Browser\n        # Dataset, speaker and utterance selection\n        i = 0\n        self.dataset_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Dataset</b>\"), i, 0)\n        browser_layout.addWidget(self.dataset_box, i + 1, 0)\n        self.speaker_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Speaker</b>\"), i, 1)\n        browser_layout.addWidget(self.speaker_box, i + 1, 1)\n        self.utterance_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Utterance</b>\"), i, 2)\n        browser_layout.addWidget(self.utterance_box, i + 1, 2)\n        self.browser_load_button = QPushButton(\"Load\")\n        browser_layout.addWidget(self.browser_load_button, i + 1, 3)\n        i += 2\n\n        # Random buttons\n        self.random_dataset_button = QPushButton(\"Random\")\n        browser_layout.addWidget(self.random_dataset_button, i, 0)\n        self.random_speaker_button = QPushButton(\"Random\")\n        browser_layout.addWidget(self.random_speaker_button, i, 1)\n        self.random_utterance_button = QPushButton(\"Random\")\n        browser_layout.addWidget(self.random_utterance_button, i, 2)\n        self.auto_next_checkbox = QCheckBox(\"Auto select next\")\n        self.auto_next_checkbox.setChecked(True)\n        browser_layout.addWidget(self.auto_next_checkbox, i, 3)\n        i += 1\n\n        # Utterance box\n        browser_layout.addWidget(QLabel(\"<b>Use embedding from:</b>\"), i, 0)\n        self.utterance_history = QComboBox()\n        browser_layout.addWidget(self.utterance_history, i, 1, 1, 3)\n        i += 1\n\n        # Random & next utterance buttons\n        self.browser_browse_button = QPushButton(\"Browse\")\n        browser_layout.addWidget(self.browser_browse_button, i, 0)\n        self.record_button = QPushButton(\"Record\")\n        browser_layout.addWidget(self.record_button, i, 1)\n        self.play_button = QPushButton(\"Play\")\n        browser_layout.addWidget(self.play_button, i, 2)\n        self.stop_button = QPushButton(\"Stop\")\n        browser_layout.addWidget(self.stop_button, i, 3)\n        i += 1\n\n\n        # Model and audio output selection\n        self.encoder_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Encoder</b>\"), i, 0)\n        browser_layout.addWidget(self.encoder_box, i + 1, 0)\n        self.synthesizer_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Synthesizer</b>\"), i, 1)\n        browser_layout.addWidget(self.synthesizer_box, i + 1, 1)\n        self.vocoder_box = QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Vocoder</b>\"), i, 2)\n        browser_layout.addWidget(self.vocoder_box, i + 1, 2)\n\n        self.audio_out_devices_cb=QComboBox()\n        browser_layout.addWidget(QLabel(\"<b>Audio Output</b>\"), i, 3)\n        browser_layout.addWidget(self.audio_out_devices_cb, i + 1, 3)\n        i += 2\n\n        #Replay & Save Audio\n        browser_layout.addWidget(QLabel(\"<b>Toolbox Output:</b>\"), i, 0)\n        self.waves_cb = QComboBox()\n        self.waves_cb_model = QStringListModel()\n        self.waves_cb.setModel(self.waves_cb_model)\n        self.waves_cb.setToolTip(\"Select one of the last generated waves in this section for replaying or exporting\")\n        browser_layout.addWidget(self.waves_cb, i, 1)\n        self.replay_wav_button = QPushButton(\"Replay\")\n        self.replay_wav_button.setToolTip(\"Replay last generated vocoder\")\n        browser_layout.addWidget(self.replay_wav_button, i, 2)\n        self.export_wav_button = QPushButton(\"Export\")\n        self.export_wav_button.setToolTip(\"Save last generated vocoder audio in filesystem as a wav file\")\n        browser_layout.addWidget(self.export_wav_button, i, 3)\n        i += 1\n\n\n        ## Embed & spectrograms\n        vis_layout.addStretch()\n\n        gridspec_kw = {\"width_ratios\": [1, 4]}\n        fig, self.current_ax = plt.subplots(1, 2, figsize=(10, 2.25), facecolor=\"#F0F0F0\",\n                                            gridspec_kw=gridspec_kw)\n        fig.subplots_adjust(left=0, bottom=0.1, right=1, top=0.8)\n        vis_layout.addWidget(FigureCanvas(fig))\n\n        fig, self.gen_ax = plt.subplots(1, 2, figsize=(10, 2.25), facecolor=\"#F0F0F0\",\n                                        gridspec_kw=gridspec_kw)\n        fig.subplots_adjust(left=0, bottom=0.1, right=1, top=0.8)\n        vis_layout.addWidget(FigureCanvas(fig))\n\n        for ax in self.current_ax.tolist() + self.gen_ax.tolist():\n            ax.set_facecolor(\"#F0F0F0\")\n            for side in [\"top\", \"right\", \"bottom\", \"left\"]:\n                ax.spines[side].set_visible(False)\n\n\n        ## Generation\n        self.text_prompt = QPlainTextEdit(default_text)\n        gen_layout.addWidget(self.text_prompt, stretch=1)\n\n        self.generate_button = QPushButton(\"Synthesize and vocode\")\n        gen_layout.addWidget(self.generate_button)\n\n        layout = QHBoxLayout()\n        self.synthesize_button = QPushButton(\"Synthesize only\")\n        layout.addWidget(self.synthesize_button)\n        self.vocode_button = QPushButton(\"Vocode only\")\n        layout.addWidget(self.vocode_button)\n        gen_layout.addLayout(layout)\n\n        layout_seed = QGridLayout()\n        self.random_seed_checkbox = QCheckBox(\"Random seed:\")\n        self.random_seed_checkbox.setToolTip(\"When checked, makes the synthesizer and vocoder deterministic.\")\n        layout_seed.addWidget(self.random_seed_checkbox, 0, 0)\n        self.seed_textbox = QLineEdit()\n        self.seed_textbox.setMaximumWidth(80)\n        layout_seed.addWidget(self.seed_textbox, 0, 1)\n        self.trim_silences_checkbox = QCheckBox(\"Enhance vocoder output\")\n        self.trim_silences_checkbox.setToolTip(\"When checked, trims excess silence in vocoder output.\"\n            \" This feature requires `webrtcvad` to be installed.\")\n        layout_seed.addWidget(self.trim_silences_checkbox, 0, 2, 1, 2)\n        gen_layout.addLayout(layout_seed)\n\n        self.loading_bar = QProgressBar()\n        gen_layout.addWidget(self.loading_bar)\n\n        self.log_window = QLabel()\n        self.log_window.setAlignment(Qt.AlignBottom | Qt.AlignLeft)\n        gen_layout.addWidget(self.log_window)\n        self.logs = []\n        gen_layout.addStretch()\n\n\n        ## Set the size of the window and of the elements\n        max_size = QDesktopWidget().availableGeometry(self).size() * 0.8\n        self.resize(max_size)\n\n        ## Finalize the display\n        self.reset_interface()\n        self.show()\n\n    def start(self):\n        self.app.exec_()\n", "toolbox/utterance.py": "from collections import namedtuple\n\nUtterance = namedtuple(\"Utterance\", \"name speaker_name wav spec embed partial_embeds synth\")\nUtterance.__eq__ = lambda x, y: x.name == y.name\nUtterance.__hash__ = lambda x: hash(x.name)\n", "toolbox/__init__.py": "import sys\nimport traceback\nfrom pathlib import Path\nfrom time import perf_counter as timer\n\nimport numpy as np\nimport torch\n\nfrom encoder import inference as encoder\nfrom synthesizer.inference import Synthesizer\nfrom toolbox.ui import UI\nfrom toolbox.utterance import Utterance\nfrom vocoder import inference as vocoder\n\n\n# Use this directory structure for your datasets, or modify it to fit your needs\nrecognized_datasets = [\n    \"LibriSpeech/dev-clean\",\n    \"LibriSpeech/dev-other\",\n    \"LibriSpeech/test-clean\",\n    \"LibriSpeech/test-other\",\n    \"LibriSpeech/train-clean-100\",\n    \"LibriSpeech/train-clean-360\",\n    \"LibriSpeech/train-other-500\",\n    \"LibriTTS/dev-clean\",\n    \"LibriTTS/dev-other\",\n    \"LibriTTS/test-clean\",\n    \"LibriTTS/test-other\",\n    \"LibriTTS/train-clean-100\",\n    \"LibriTTS/train-clean-360\",\n    \"LibriTTS/train-other-500\",\n    \"LJSpeech-1.1\",\n    \"VoxCeleb1/wav\",\n    \"VoxCeleb1/test_wav\",\n    \"VoxCeleb2/dev/aac\",\n    \"VoxCeleb2/test/aac\",\n    \"VCTK-Corpus/wav48\",\n]\n\n# Maximum of generated wavs to keep on memory\nMAX_WAVS = 15\n\n\nclass Toolbox:\n    def __init__(self, datasets_root: Path, models_dir: Path, seed: int=None):\n        sys.excepthook = self.excepthook\n        self.datasets_root = datasets_root\n        self.utterances = set()\n        self.current_generated = (None, None, None, None) # speaker_name, spec, breaks, wav\n\n        self.synthesizer = None # type: Synthesizer\n        self.current_wav = None\n        self.waves_list = []\n        self.waves_count = 0\n        self.waves_namelist = []\n\n        # Check for webrtcvad (enables removal of silences in vocoder output)\n        try:\n            import webrtcvad\n            self.trim_silences = True\n        except:\n            self.trim_silences = False\n\n        # Initialize the events and the interface\n        self.ui = UI()\n        self.reset_ui(models_dir, seed)\n        self.setup_events()\n        self.ui.start()\n\n    def excepthook(self, exc_type, exc_value, exc_tb):\n        traceback.print_exception(exc_type, exc_value, exc_tb)\n        self.ui.log(\"Exception: %s\" % exc_value)\n\n    def setup_events(self):\n        # Dataset, speaker and utterance selection\n        self.ui.browser_load_button.clicked.connect(lambda: self.load_from_browser())\n        random_func = lambda level: lambda: self.ui.populate_browser(self.datasets_root,\n                                                                     recognized_datasets,\n                                                                     level)\n        self.ui.random_dataset_button.clicked.connect(random_func(0))\n        self.ui.random_speaker_button.clicked.connect(random_func(1))\n        self.ui.random_utterance_button.clicked.connect(random_func(2))\n        self.ui.dataset_box.currentIndexChanged.connect(random_func(1))\n        self.ui.speaker_box.currentIndexChanged.connect(random_func(2))\n\n        # Model selection\n        self.ui.encoder_box.currentIndexChanged.connect(self.init_encoder)\n        def func():\n            self.synthesizer = None\n        self.ui.synthesizer_box.currentIndexChanged.connect(func)\n        self.ui.vocoder_box.currentIndexChanged.connect(self.init_vocoder)\n\n        # Utterance selection\n        func = lambda: self.load_from_browser(self.ui.browse_file())\n        self.ui.browser_browse_button.clicked.connect(func)\n        func = lambda: self.ui.draw_utterance(self.ui.selected_utterance, \"current\")\n        self.ui.utterance_history.currentIndexChanged.connect(func)\n        func = lambda: self.ui.play(self.ui.selected_utterance.wav, Synthesizer.sample_rate)\n        self.ui.play_button.clicked.connect(func)\n        self.ui.stop_button.clicked.connect(self.ui.stop)\n        self.ui.record_button.clicked.connect(self.record)\n\n        #Audio\n        self.ui.setup_audio_devices(Synthesizer.sample_rate)\n\n        #Wav playback & save\n        func = lambda: self.replay_last_wav()\n        self.ui.replay_wav_button.clicked.connect(func)\n        func = lambda: self.export_current_wave()\n        self.ui.export_wav_button.clicked.connect(func)\n        self.ui.waves_cb.currentIndexChanged.connect(self.set_current_wav)\n\n        # Generation\n        func = lambda: self.synthesize() or self.vocode()\n        self.ui.generate_button.clicked.connect(func)\n        self.ui.synthesize_button.clicked.connect(self.synthesize)\n        self.ui.vocode_button.clicked.connect(self.vocode)\n        self.ui.random_seed_checkbox.clicked.connect(self.update_seed_textbox)\n\n        # UMAP legend\n        self.ui.clear_button.clicked.connect(self.clear_utterances)\n\n    def set_current_wav(self, index):\n        self.current_wav = self.waves_list[index]\n\n    def export_current_wave(self):\n        self.ui.save_audio_file(self.current_wav, Synthesizer.sample_rate)\n\n    def replay_last_wav(self):\n        self.ui.play(self.current_wav, Synthesizer.sample_rate)\n\n    def reset_ui(self, models_dir: Path, seed: int=None):\n        self.ui.populate_browser(self.datasets_root, recognized_datasets, 0, True)\n        self.ui.populate_models(models_dir)\n        self.ui.populate_gen_options(seed, self.trim_silences)\n\n    def load_from_browser(self, fpath=None):\n        if fpath is None:\n            fpath = Path(self.datasets_root,\n                         self.ui.current_dataset_name,\n                         self.ui.current_speaker_name,\n                         self.ui.current_utterance_name)\n            name = str(fpath.relative_to(self.datasets_root))\n            speaker_name = self.ui.current_dataset_name + '_' + self.ui.current_speaker_name\n\n            # Select the next utterance\n            if self.ui.auto_next_checkbox.isChecked():\n                self.ui.browser_select_next()\n        elif fpath == \"\":\n            return\n        else:\n            name = fpath.name\n            speaker_name = fpath.parent.name\n\n        # Get the wav from the disk. We take the wav with the vocoder/synthesizer format for\n        # playback, so as to have a fair comparison with the generated audio\n        wav = Synthesizer.load_preprocess_wav(fpath)\n        self.ui.log(\"Loaded %s\" % name)\n\n        self.add_real_utterance(wav, name, speaker_name)\n\n    def record(self):\n        wav = self.ui.record_one(encoder.sampling_rate, 5)\n        if wav is None:\n            return\n        self.ui.play(wav, encoder.sampling_rate)\n\n        speaker_name = \"user01\"\n        name = speaker_name + \"_rec_%05d\" % np.random.randint(100000)\n        self.add_real_utterance(wav, name, speaker_name)\n\n    def add_real_utterance(self, wav, name, speaker_name):\n        # Compute the mel spectrogram\n        spec = Synthesizer.make_spectrogram(wav)\n        self.ui.draw_spec(spec, \"current\")\n\n        # Compute the embedding\n        if not encoder.is_loaded():\n            self.init_encoder()\n        encoder_wav = encoder.preprocess_wav(wav)\n        embed, partial_embeds, _ = encoder.embed_utterance(encoder_wav, return_partials=True)\n\n        # Add the utterance\n        utterance = Utterance(name, speaker_name, wav, spec, embed, partial_embeds, False)\n        self.utterances.add(utterance)\n        self.ui.register_utterance(utterance)\n\n        # Plot it\n        self.ui.draw_embed(embed, name, \"current\")\n        self.ui.draw_umap_projections(self.utterances)\n\n    def clear_utterances(self):\n        self.utterances.clear()\n        self.ui.draw_umap_projections(self.utterances)\n\n    def synthesize(self):\n        self.ui.log(\"Generating the mel spectrogram...\")\n        self.ui.set_loading(1)\n\n        # Update the synthesizer random seed\n        if self.ui.random_seed_checkbox.isChecked():\n            seed = int(self.ui.seed_textbox.text())\n            self.ui.populate_gen_options(seed, self.trim_silences)\n        else:\n            seed = None\n\n        if seed is not None:\n            torch.manual_seed(seed)\n\n        # Synthesize the spectrogram\n        if self.synthesizer is None or seed is not None:\n            self.init_synthesizer()\n\n        texts = self.ui.text_prompt.toPlainText().split(\"\\n\")\n        embed = self.ui.selected_utterance.embed\n        embeds = [embed] * len(texts)\n        specs = self.synthesizer.synthesize_spectrograms(texts, embeds)\n        breaks = [spec.shape[1] for spec in specs]\n        spec = np.concatenate(specs, axis=1)\n\n        self.ui.draw_spec(spec, \"generated\")\n        self.current_generated = (self.ui.selected_utterance.speaker_name, spec, breaks, None)\n        self.ui.set_loading(0)\n\n    def vocode(self):\n        speaker_name, spec, breaks, _ = self.current_generated\n        assert spec is not None\n\n        # Initialize the vocoder model and make it determinstic, if user provides a seed\n        if self.ui.random_seed_checkbox.isChecked():\n            seed = int(self.ui.seed_textbox.text())\n            self.ui.populate_gen_options(seed, self.trim_silences)\n        else:\n            seed = None\n\n        if seed is not None:\n            torch.manual_seed(seed)\n\n        # Synthesize the waveform\n        if not vocoder.is_loaded() or seed is not None:\n            self.init_vocoder()\n\n        def vocoder_progress(i, seq_len, b_size, gen_rate):\n            real_time_factor = (gen_rate / Synthesizer.sample_rate) * 1000\n            line = \"Waveform generation: %d/%d (batch size: %d, rate: %.1fkHz - %.2fx real time)\" \\\n                   % (i * b_size, seq_len * b_size, b_size, gen_rate, real_time_factor)\n            self.ui.log(line, \"overwrite\")\n            self.ui.set_loading(i, seq_len)\n        if self.ui.current_vocoder_fpath is not None:\n            self.ui.log(\"\")\n            wav = vocoder.infer_waveform(spec, progress_callback=vocoder_progress)\n        else:\n            self.ui.log(\"Waveform generation with Griffin-Lim... \")\n            wav = Synthesizer.griffin_lim(spec)\n        self.ui.set_loading(0)\n        self.ui.log(\" Done!\", \"append\")\n\n        # Add breaks\n        b_ends = np.cumsum(np.array(breaks) * Synthesizer.hparams.hop_size)\n        b_starts = np.concatenate(([0], b_ends[:-1]))\n        wavs = [wav[start:end] for start, end, in zip(b_starts, b_ends)]\n        breaks = [np.zeros(int(0.15 * Synthesizer.sample_rate))] * len(breaks)\n        wav = np.concatenate([i for w, b in zip(wavs, breaks) for i in (w, b)])\n\n        # Trim excessive silences\n        if self.ui.trim_silences_checkbox.isChecked():\n            wav = encoder.preprocess_wav(wav)\n\n        # Play it\n        wav = wav / np.abs(wav).max() * 0.97\n        self.ui.play(wav, Synthesizer.sample_rate)\n\n        # Name it (history displayed in combobox)\n        # TODO better naming for the combobox items?\n        wav_name = str(self.waves_count + 1)\n\n        #Update waves combobox\n        self.waves_count += 1\n        if self.waves_count > MAX_WAVS:\n          self.waves_list.pop()\n          self.waves_namelist.pop()\n        self.waves_list.insert(0, wav)\n        self.waves_namelist.insert(0, wav_name)\n\n        self.ui.waves_cb.disconnect()\n        self.ui.waves_cb_model.setStringList(self.waves_namelist)\n        self.ui.waves_cb.setCurrentIndex(0)\n        self.ui.waves_cb.currentIndexChanged.connect(self.set_current_wav)\n\n        # Update current wav\n        self.set_current_wav(0)\n\n        #Enable replay and save buttons:\n        self.ui.replay_wav_button.setDisabled(False)\n        self.ui.export_wav_button.setDisabled(False)\n\n        # Compute the embedding\n        # TODO: this is problematic with different sampling rates, gotta fix it\n        if not encoder.is_loaded():\n            self.init_encoder()\n        encoder_wav = encoder.preprocess_wav(wav)\n        embed, partial_embeds, _ = encoder.embed_utterance(encoder_wav, return_partials=True)\n\n        # Add the utterance\n        name = speaker_name + \"_gen_%05d\" % np.random.randint(100000)\n        utterance = Utterance(name, speaker_name, wav, spec, embed, partial_embeds, True)\n        self.utterances.add(utterance)\n\n        # Plot it\n        self.ui.draw_embed(embed, name, \"generated\")\n        self.ui.draw_umap_projections(self.utterances)\n\n    def init_encoder(self):\n        model_fpath = self.ui.current_encoder_fpath\n\n        self.ui.log(\"Loading the encoder %s... \" % model_fpath)\n        self.ui.set_loading(1)\n        start = timer()\n        encoder.load_model(model_fpath)\n        self.ui.log(\"Done (%dms).\" % int(1000 * (timer() - start)), \"append\")\n        self.ui.set_loading(0)\n\n    def init_synthesizer(self):\n        model_fpath = self.ui.current_synthesizer_fpath\n\n        self.ui.log(\"Loading the synthesizer %s... \" % model_fpath)\n        self.ui.set_loading(1)\n        start = timer()\n        self.synthesizer = Synthesizer(model_fpath)\n        self.ui.log(\"Done (%dms).\" % int(1000 * (timer() - start)), \"append\")\n        self.ui.set_loading(0)\n\n    def init_vocoder(self):\n        model_fpath = self.ui.current_vocoder_fpath\n        # Case of Griffin-lim\n        if model_fpath is None:\n            return\n\n        self.ui.log(\"Loading the vocoder %s... \" % model_fpath)\n        self.ui.set_loading(1)\n        start = timer()\n        vocoder.load_model(model_fpath)\n        self.ui.log(\"Done (%dms).\" % int(1000 * (timer() - start)), \"append\")\n        self.ui.set_loading(0)\n\n    def update_seed_textbox(self):\n       self.ui.update_seed_textbox()\n"}