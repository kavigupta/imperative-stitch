{"idna/core.py": "from . import idnadata\nimport bisect\nimport unicodedata\nimport re\nfrom typing import Union, Optional\nfrom .intranges import intranges_contain\n\n_virama_combining_class = 9\n_alabel_prefix = b'xn--'\n_unicode_dots_re = re.compile('[\\u002e\\u3002\\uff0e\\uff61]')\n\nclass IDNAError(UnicodeError):\n    \"\"\" Base exception for all IDNA-encoding related problems \"\"\"\n    pass\n\n\nclass IDNABidiError(IDNAError):\n    \"\"\" Exception when bidirectional requirements are not satisfied \"\"\"\n    pass\n\n\nclass InvalidCodepoint(IDNAError):\n    \"\"\" Exception when a disallowed or unallocated codepoint is used \"\"\"\n    pass\n\n\nclass InvalidCodepointContext(IDNAError):\n    \"\"\" Exception when the codepoint is not valid in the context it is used \"\"\"\n    pass\n\n\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError('Unknown character in unicodedata')\n    return v\n\ndef _is_script(cp: str, script: str) -> bool:\n    return intranges_contain(ord(cp), idnadata.scripts[script])\n\ndef _punycode(s: str) -> bytes:\n    return s.encode('punycode')\n\ndef _unot(s: int) -> str:\n    return 'U+{:04X}'.format(s)\n\n\ndef valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\n\n\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\n\n\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for (idx, cp) in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == '':\n            # String likely comes from a newer version of Unicode\n            raise IDNABidiError('Unknown directionality in label {} at position {}'.format(repr(label), idx))\n        if direction in ['R', 'AL', 'AN']:\n            bidi_label = True\n    if not bidi_label and not check_ltr:\n        return True\n\n    # Bidi rule 1\n    direction = unicodedata.bidirectional(label[0])\n    if direction in ['R', 'AL']:\n        rtl = True\n    elif direction == 'L':\n        rtl = False\n    else:\n        raise IDNABidiError('First codepoint in label {} must be directionality L, R or AL'.format(repr(label)))\n\n    valid_ending = False\n    number_type = None  # type: Optional[str]\n    for (idx, cp) in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n\n        if rtl:\n            # Bidi rule 2\n            if not direction in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:\n                raise IDNABidiError('Invalid direction for codepoint at position {} in a right-to-left label'.format(idx))\n            # Bidi rule 3\n            if direction in ['R', 'AL', 'EN', 'AN']:\n                valid_ending = True\n            elif direction != 'NSM':\n                valid_ending = False\n            # Bidi rule 4\n            if direction in ['AN', 'EN']:\n                if not number_type:\n                    number_type = direction\n                else:\n                    if number_type != direction:\n                        raise IDNABidiError('Can not mix numeral types in a right-to-left label')\n        else:\n            # Bidi rule 5\n            if not direction in ['L', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:\n                raise IDNABidiError('Invalid direction for codepoint at position {} in a left-to-right label'.format(idx))\n            # Bidi rule 6\n            if direction in ['L', 'EN']:\n                valid_ending = True\n            elif direction != 'NSM':\n                valid_ending = False\n\n    if not valid_ending:\n        raise IDNABidiError('Label ends with illegal codepoint directionality')\n\n    return True\n\n\ndef check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == 'M':\n        raise IDNAError('Label begins with an illegal combining character')\n    return True\n\n\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == '--':\n        raise IDNAError('Label has disallowed hyphens in 3rd and 4th position')\n    if label[0] == '-' or label[-1] == '-':\n        raise IDNAError('Label must not start or end with a hyphen')\n    return True\n\n\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize('NFC', label) != label:\n        raise IDNAError('Label must be in Normalization Form C')\n\n\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n\n    if cp_value == 0x200c:\n\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n\n        ok = False\n        for i in range(pos-1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord('T'):\n                continue\n            elif joining_type in [ord('L'), ord('D')]:\n                ok = True\n                break\n            else:\n                break\n\n        if not ok:\n            return False\n\n        ok = False\n        for i in range(pos+1, len(label)):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord('T'):\n                continue\n            elif joining_type in [ord('R'), ord('D')]:\n                ok = True\n                break\n            else:\n                break\n        return ok\n\n    if cp_value == 0x200d:\n\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        return False\n\n    else:\n\n        return False\n\n\ndef valid_contexto(label: str, pos: int, exception: bool = False) -> bool:\n    cp_value = ord(label[pos])\n\n    if cp_value == 0x00b7:\n        if 0 < pos < len(label)-1:\n            if ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:\n                return True\n        return False\n\n    elif cp_value == 0x0375:\n        if pos < len(label)-1 and len(label) > 1:\n            return _is_script(label[pos + 1], 'Greek')\n        return False\n\n    elif cp_value == 0x05f3 or cp_value == 0x05f4:\n        if pos > 0:\n            return _is_script(label[pos - 1], 'Hebrew')\n        return False\n\n    elif cp_value == 0x30fb:\n        for cp in label:\n            if cp == '\\u30fb':\n                continue\n            if _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):\n                return True\n        return False\n\n    elif 0x660 <= cp_value <= 0x669:\n        for cp in label:\n            if 0x6f0 <= ord(cp) <= 0x06f9:\n                return False\n        return True\n\n    elif 0x6f0 <= cp_value <= 0x6f9:\n        for cp in label:\n            if 0x660 <= ord(cp) <= 0x0669:\n                return False\n        return True\n\n    return False\n\n\ndef check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode('utf-8')\n    if len(label) == 0:\n        raise IDNAError('Empty Label')\n\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n\n    for (pos, cp) in enumerate(label):\n        cp_value = ord(cp)\n        if intranges_contain(cp_value, idnadata.codepoint_classes['PVALID']):\n            continue\n        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTJ']):\n            try:\n                if not valid_contextj(label, pos):\n                    raise InvalidCodepointContext('Joiner {} not allowed at position {} in {}'.format(\n                        _unot(cp_value), pos+1, repr(label)))\n            except ValueError:\n                raise IDNAError('Unknown codepoint adjacent to joiner {} at position {} in {}'.format(\n                    _unot(cp_value), pos+1, repr(label)))\n        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTO']):\n            if not valid_contexto(label, pos):\n                raise InvalidCodepointContext('Codepoint {} not allowed at position {} in {}'.format(_unot(cp_value), pos+1, repr(label)))\n        else:\n            raise InvalidCodepoint('Codepoint {} at position {} of {} not allowed'.format(_unot(cp_value), pos+1, repr(label)))\n\n    check_bidi(label)\n\n\ndef alabel(label: str) -> bytes:\n    try:\n        label_bytes = label.encode('ascii')\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError('Label too long')\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n\n    check_label(label)\n    label_bytes = _alabel_prefix + _punycode(label)\n\n    if not valid_label_length(label_bytes):\n        raise IDNAError('Label too long')\n\n    return label_bytes\n\n\ndef ulabel(label: Union[str, bytes, bytearray]) -> str:\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode('ascii')\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = label\n\n    label_bytes = label_bytes.lower()\n    if label_bytes.startswith(_alabel_prefix):\n        label_bytes = label_bytes[len(_alabel_prefix):]\n        if not label_bytes:\n            raise IDNAError('Malformed A-label, no Punycode eligible content found')\n        if label_bytes.decode('ascii')[-1] == '-':\n            raise IDNAError('A-label must not end with a hyphen')\n    else:\n        check_label(label_bytes)\n        return label_bytes.decode('ascii')\n\n    try:\n        label = label_bytes.decode('punycode')\n    except UnicodeError:\n        raise IDNAError('Invalid A-label')\n    check_label(label)\n    return label\n\n\ndef uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n    output = ''\n\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else\n                bisect.bisect_left(uts46data, (code_point, 'Z')) - 1]\n            status = uts46row[1]\n            replacement = None  # type: Optional[str]\n            if len(uts46row) == 3:\n                replacement = uts46row[2]\n            if (status == 'V' or\n                    (status == 'D' and not transitional) or\n                    (status == '3' and not std3_rules and replacement is None)):\n                output += char\n            elif replacement is not None and (status == 'M' or\n                    (status == '3' and not std3_rules) or\n                    (status == 'D' and transitional)):\n                output += replacement\n            elif status != 'I':\n                raise IndexError()\n        except IndexError:\n            raise InvalidCodepoint(\n                'Codepoint {} not allowed at position {} in {}'.format(\n                _unot(code_point), pos + 1, repr(domain)))\n\n    return unicodedata.normalize('NFC', output)\n\n\ndef encode(s: Union[str, bytes, bytearray], strict: bool = False, uts46: bool = False, std3_rules: bool = False, transitional: bool = False) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, 'ascii')\n        except UnicodeDecodeError:\n            raise IDNAError('should pass a unicode string to the function rather than a byte string.')\n    if uts46:\n        s = uts46_remap(s, std3_rules, transitional)\n    trailing_dot = False\n    result = []\n    if strict:\n        labels = s.split('.')\n    else:\n        labels = _unicode_dots_re.split(s)\n    if not labels or labels == ['']:\n        raise IDNAError('Empty domain')\n    if labels[-1] == '':\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = alabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError('Empty label')\n    if trailing_dot:\n        result.append(b'')\n    s = b'.'.join(result)\n    if not valid_string_length(s, trailing_dot):\n        raise IDNAError('Domain too long')\n    return s\n\n\ndef decode(s: Union[str, bytes, bytearray], strict: bool = False, uts46: bool = False, std3_rules: bool = False) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, 'ascii')\n    except UnicodeDecodeError:\n        raise IDNAError('Invalid ASCII in A-label')\n    if uts46:\n        s = uts46_remap(s, std3_rules, False)\n    trailing_dot = False\n    result = []\n    if not strict:\n        labels = _unicode_dots_re.split(s)\n    else:\n        labels = s.split('.')\n    if not labels or labels == ['']:\n        raise IDNAError('Empty domain')\n    if not labels[-1]:\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = ulabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError('Empty label')\n    if trailing_dot:\n        result.append('')\n    return '.'.join(result)\n", "idna/intranges.py": "\"\"\"\nGiven a list of integers, made up of (hopefully) a small number of long runs\nof consecutive integers, compute a representation of the form\n((start1, end1), (start2, end2) ...). Then answer the question \"was x present\nin the original list?\" in time O(log(# runs)).\n\"\"\"\n\nimport bisect\nfrom typing import List, Tuple\n\ndef intranges_from_list(list_: List[int]) -> Tuple[int, ...]:\n    \"\"\"Represent a list of integers as a sequence of ranges:\n    ((start_0, end_0), (start_1, end_1), ...), such that the original\n    integers are exactly those x such that start_i <= x < end_i for some i.\n\n    Ranges are encoded as single integers (start << 32 | end), not as tuples.\n    \"\"\"\n\n    sorted_list = sorted(list_)\n    ranges = []\n    last_write = -1\n    for i in range(len(sorted_list)):\n        if i+1 < len(sorted_list):\n            if sorted_list[i] == sorted_list[i+1]-1:\n                continue\n        current_range = sorted_list[last_write+1:i+1]\n        ranges.append(_encode_range(current_range[0], current_range[-1] + 1))\n        last_write = i\n\n    return tuple(ranges)\n\ndef _encode_range(start: int, end: int) -> int:\n    return (start << 32) | end\n\ndef _decode_range(r: int) -> Tuple[int, int]:\n    return (r >> 32), (r & ((1 << 32) - 1))\n\n\ndef intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:\n    \"\"\"Determine if `int_` falls into one of the ranges in `ranges`.\"\"\"\n    tuple_ = _encode_range(int_, 0)\n    pos = bisect.bisect_left(ranges, tuple_)\n    # we could be immediately ahead of a tuple (start, end)\n    # with start < int_ <= end\n    if pos > 0:\n        left, right = _decode_range(ranges[pos-1])\n        if left <= int_ < right:\n            return True\n    # or we could be immediately behind a tuple (int_, end)\n    if pos < len(ranges):\n        left, _ = _decode_range(ranges[pos])\n        if left == int_:\n            return True\n    return False\n", "idna/codec.py": "from .core import encode, decode, alabel, ulabel, IDNAError\nimport codecs\nimport re\nfrom typing import Any, Tuple, Optional\n\n_unicode_dots_re = re.compile('[\\u002e\\u3002\\uff0e\\uff61]')\n\nclass Codec(codecs.Codec):\n\n    def encode(self, data: str, errors: str = 'strict') -> Tuple[bytes, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        return encode(data), len(data)\n\n    def decode(self, data: bytes, errors: str = 'strict') -> Tuple[str, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return '', 0\n\n        return decode(data), len(data)\n\nclass IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return b'', 0\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = b'.'\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = b'.'\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(alabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        # Join with U+002E\n        result_bytes = b'.'.join(result) + trailing_dot\n        size += len(trailing_dot)\n        return result_bytes, size\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return ('', 0)\n\n        if not isinstance(data, str):\n            data = str(data, 'ascii')\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = ''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = '.'\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = '.'\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(ulabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        result_str = '.'.join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_str, size)\n\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n\n\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != 'idna2008':\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )\n\ncodecs.register(search_function)\n", "idna/__init__.py": "from .package_data import __version__\nfrom .core import (\n    IDNABidiError,\n    IDNAError,\n    InvalidCodepoint,\n    InvalidCodepointContext,\n    alabel,\n    check_bidi,\n    check_hyphen_ok,\n    check_initial_combiner,\n    check_label,\n    check_nfc,\n    decode,\n    encode,\n    ulabel,\n    uts46_remap,\n    valid_contextj,\n    valid_contexto,\n    valid_label_length,\n    valid_string_length,\n)\nfrom .intranges import intranges_contain\n\n__all__ = [\n    \"IDNABidiError\",\n    \"IDNAError\",\n    \"InvalidCodepoint\",\n    \"InvalidCodepointContext\",\n    \"alabel\",\n    \"check_bidi\",\n    \"check_hyphen_ok\",\n    \"check_initial_combiner\",\n    \"check_label\",\n    \"check_nfc\",\n    \"decode\",\n    \"encode\",\n    \"intranges_contain\",\n    \"ulabel\",\n    \"uts46_remap\",\n    \"valid_contextj\",\n    \"valid_contexto\",\n    \"valid_label_length\",\n    \"valid_string_length\",\n]\n", "idna/compat.py": "from .core import *\nfrom .codec import *\nfrom typing import Any, Union\n\ndef ToASCII(label: str) -> bytes:\n    return encode(label)\n\ndef ToUnicode(label: Union[bytes, bytearray]) -> str:\n    return decode(label)\n\ndef nameprep(s: Any) -> None:\n    raise NotImplementedError('IDNA 2008 does not utilise nameprep protocol')\n\n"}