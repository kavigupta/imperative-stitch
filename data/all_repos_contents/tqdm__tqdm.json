{"tqdm/asyncio.py": "\"\"\"\nAsynchronous progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm.asyncio import trange, tqdm\n>>> async for i in trange(10):\n...     ...\n\"\"\"\nimport asyncio\nfrom sys import version_info\n\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tqdm_asyncio', 'tarange', 'tqdm', 'trange']\n\n\nclass tqdm_asyncio(std_tqdm):\n    \"\"\"\n    Asynchronous-friendly version of tqdm.\n    \"\"\"\n    def __init__(self, iterable=None, *args, **kwargs):\n        super().__init__(iterable, *args, **kwargs)\n        self.iterable_awaitable = False\n        if iterable is not None:\n            if hasattr(iterable, \"__anext__\"):\n                self.iterable_next = iterable.__anext__\n                self.iterable_awaitable = True\n            elif hasattr(iterable, \"__next__\"):\n                self.iterable_next = iterable.__next__\n            else:\n                self.iterable_iterator = iter(iterable)\n                self.iterable_next = self.iterable_iterator.__next__\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        try:\n            if self.iterable_awaitable:\n                res = await self.iterable_next()\n            else:\n                res = self.iterable_next()\n            self.update()\n            return res\n        except StopIteration:\n            self.close()\n            raise StopAsyncIteration\n        except BaseException:\n            self.close()\n            raise\n\n    def send(self, *args, **kwargs):\n        return self.iterable.send(*args, **kwargs)\n\n    @classmethod\n    def as_completed(cls, fs, *, loop=None, timeout=None, total=None, **tqdm_kwargs):\n        \"\"\"\n        Wrapper for `asyncio.as_completed`.\n        \"\"\"\n        if total is None:\n            total = len(fs)\n        kwargs = {}\n        if version_info[:2] < (3, 10):\n            kwargs['loop'] = loop\n        yield from cls(asyncio.as_completed(fs, timeout=timeout, **kwargs),\n                       total=total, **tqdm_kwargs)\n\n    @classmethod\n    async def gather(cls, *fs, loop=None, timeout=None, total=None, **tqdm_kwargs):\n        \"\"\"\n        Wrapper for `asyncio.gather`.\n        \"\"\"\n        async def wrap_awaitable(i, f):\n            return i, await f\n\n        ifs = [wrap_awaitable(i, f) for i, f in enumerate(fs)]\n        res = [await f for f in cls.as_completed(ifs, loop=loop, timeout=timeout,\n                                                 total=total, **tqdm_kwargs)]\n        return [i for _, i in sorted(res)]\n\n\ndef tarange(*args, **kwargs):\n    \"\"\"\n    A shortcut for `tqdm.asyncio.tqdm(range(*args), **kwargs)`.\n    \"\"\"\n    return tqdm_asyncio(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_asyncio\ntrange = tarange\n", "tqdm/cli.py": "\"\"\"\nModule version for monitoring CLI pipes (`... | python -m tqdm | ...`).\n\"\"\"\nimport logging\nimport re\nimport sys\nfrom ast import literal_eval as numeric\n\nfrom .std import TqdmKeyError, TqdmTypeError, tqdm\nfrom .version import __version__\n\n__all__ = [\"main\"]\nlog = logging.getLogger(__name__)\n\n\ndef cast(val, typ):\n    log.debug((val, typ))\n    if \" or \" in typ:\n        for t in typ.split(\" or \"):\n            try:\n                return cast(val, t)\n            except TqdmTypeError:\n                pass\n        raise TqdmTypeError(f\"{val} : {typ}\")\n\n    # sys.stderr.write('\\ndebug | `val:type`: `' + val + ':' + typ + '`.\\n')\n    if typ == 'bool':\n        if (val == 'True') or (val == ''):\n            return True\n        if val == 'False':\n            return False\n        raise TqdmTypeError(val + ' : ' + typ)\n    if typ == 'chr':\n        if len(val) == 1:\n            return val.encode()\n        if re.match(r\"^\\\\\\w+$\", val):\n            return eval(f'\"{val}\"').encode()\n        raise TqdmTypeError(f\"{val} : {typ}\")\n    if typ == 'str':\n        return val\n    if typ == 'int':\n        try:\n            return int(val)\n        except ValueError as exc:\n            raise TqdmTypeError(f\"{val} : {typ}\") from exc\n    if typ == 'float':\n        try:\n            return float(val)\n        except ValueError as exc:\n            raise TqdmTypeError(f\"{val} : {typ}\") from exc\n    raise TqdmTypeError(f\"{val} : {typ}\")\n\n\ndef posix_pipe(fin, fout, delim=b'\\\\n', buf_size=256,\n               callback=lambda float: None, callback_len=True):\n    \"\"\"\n    Params\n    ------\n    fin  : binary file with `read(buf_size : int)` method\n    fout  : binary file with `write` (and optionally `flush`) methods.\n    callback  : function(float), e.g.: `tqdm.update`\n    callback_len  : If (default: True) do `callback(len(buffer))`.\n      Otherwise, do `callback(data) for data in buffer.split(delim)`.\n    \"\"\"\n    fp_write = fout.write\n\n    if not delim:\n        while True:\n            tmp = fin.read(buf_size)\n\n            # flush at EOF\n            if not tmp:\n                getattr(fout, 'flush', lambda: None)()\n                return\n\n            fp_write(tmp)\n            callback(len(tmp))\n        # return\n\n    buf = b''\n    len_delim = len(delim)\n    # n = 0\n    while True:\n        tmp = fin.read(buf_size)\n\n        # flush at EOF\n        if not tmp:\n            if buf:\n                fp_write(buf)\n                if callback_len:\n                    # n += 1 + buf.count(delim)\n                    callback(1 + buf.count(delim))\n                else:\n                    for i in buf.split(delim):\n                        callback(i)\n            getattr(fout, 'flush', lambda: None)()\n            return  # n\n\n        while True:\n            i = tmp.find(delim)\n            if i < 0:\n                buf += tmp\n                break\n            fp_write(buf + tmp[:i + len(delim)])\n            # n += 1\n            callback(1 if callback_len else (buf + tmp[:i]))\n            buf = b''\n            tmp = tmp[i + len_delim:]\n\n\n# ((opt, type), ... )\nRE_OPTS = re.compile(r'\\n {4}(\\S+)\\s{2,}:\\s*([^,]+)')\n# better split method assuming no positional args\nRE_SHLEX = re.compile(r'\\s*(?<!\\S)--?([^\\s=]+)(\\s+|=|$)')\n\n# TODO: add custom support for some of the following?\nUNSUPPORTED_OPTS = ('iterable', 'gui', 'out', 'file')\n\n# The 8 leading spaces are required for consistency\nCLI_EXTRA_DOC = r\"\"\"\n    Extra CLI Options\n    -----------------\n    name  : type, optional\n        TODO: find out why this is needed.\n    delim  : chr, optional\n        Delimiting character [default: '\\n']. Use '\\0' for null.\n        N.B.: on Windows systems, Python converts '\\n' to '\\r\\n'.\n    buf_size  : int, optional\n        String buffer size in bytes [default: 256]\n        used when `delim` is specified.\n    bytes  : bool, optional\n        If true, will count bytes, ignore `delim`, and default\n        `unit_scale` to True, `unit_divisor` to 1024, and `unit` to 'B'.\n    tee  : bool, optional\n        If true, passes `stdin` to both `stderr` and `stdout`.\n    update  : bool, optional\n        If true, will treat input as newly elapsed iterations,\n        i.e. numbers to pass to `update()`. Note that this is slow\n        (~2e5 it/s) since every input must be decoded as a number.\n    update_to  : bool, optional\n        If true, will treat input as total elapsed iterations,\n        i.e. numbers to assign to `self.n`. Note that this is slow\n        (~2e5 it/s) since every input must be decoded as a number.\n    null  : bool, optional\n        If true, will discard input (no stdout).\n    manpath  : str, optional\n        Directory in which to install tqdm man pages.\n    comppath  : str, optional\n        Directory in which to place tqdm completion.\n    log  : str, optional\n        CRITICAL|FATAL|ERROR|WARN(ING)|[default: 'INFO']|DEBUG|NOTSET.\n\"\"\"\n\n\ndef main(fp=sys.stderr, argv=None):\n    \"\"\"\n    Parameters (internal use only)\n    ---------\n    fp  : file-like object for tqdm\n    argv  : list (default: sys.argv[1:])\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    try:\n        log_idx = argv.index('--log')\n    except ValueError:\n        for i in argv:\n            if i.startswith('--log='):\n                logLevel = i[len('--log='):]\n                break\n        else:\n            logLevel = 'INFO'\n    else:\n        # argv.pop(log_idx)\n        # logLevel = argv.pop(log_idx)\n        logLevel = argv[log_idx + 1]\n    logging.basicConfig(level=getattr(logging, logLevel),\n                        format=\"%(levelname)s:%(module)s:%(lineno)d:%(message)s\")\n\n    d = tqdm.__doc__ + CLI_EXTRA_DOC\n\n    opt_types = dict(RE_OPTS.findall(d))\n    # opt_types['delim'] = 'chr'\n\n    for o in UNSUPPORTED_OPTS:\n        opt_types.pop(o)\n\n    log.debug(sorted(opt_types.items()))\n\n    # d = RE_OPTS.sub(r'  --\\1=<\\1>  : \\2', d)\n    split = RE_OPTS.split(d)\n    opt_types_desc = zip(split[1::3], split[2::3], split[3::3])\n    d = ''.join(('\\n  --{0}  : {2}{3}' if otd[1] == 'bool' else\n                 '\\n  --{0}=<{1}>  : {2}{3}').format(\n                     otd[0].replace('_', '-'), otd[0], *otd[1:])\n                for otd in opt_types_desc if otd[0] not in UNSUPPORTED_OPTS)\n\n    help_short = \"Usage:\\n  tqdm [--help | options]\\n\"\n    d = help_short + \"\"\"\nOptions:\n  -h, --help     Print this help and exit.\n  -v, --version  Print version and exit.\n\"\"\" + d.strip('\\n') + '\\n'\n\n    # opts = docopt(d, version=__version__)\n    if any(v in argv for v in ('-v', '--version')):\n        sys.stdout.write(__version__ + '\\n')\n        sys.exit(0)\n    elif any(v in argv for v in ('-h', '--help')):\n        sys.stdout.write(d + '\\n')\n        sys.exit(0)\n    elif argv and argv[0][:2] != '--':\n        sys.stderr.write(f\"Error:Unknown argument:{argv[0]}\\n{help_short}\")\n\n    argv = RE_SHLEX.split(' '.join([\"tqdm\"] + argv))\n    opts = dict(zip(argv[1::3], argv[3::3]))\n\n    log.debug(opts)\n    opts.pop('log', True)\n\n    tqdm_args = {'file': fp}\n    try:\n        for (o, v) in opts.items():\n            o = o.replace('-', '_')\n            try:\n                tqdm_args[o] = cast(v, opt_types[o])\n            except KeyError as e:\n                raise TqdmKeyError(str(e))\n        log.debug('args:' + str(tqdm_args))\n\n        delim_per_char = tqdm_args.pop('bytes', False)\n        update = tqdm_args.pop('update', False)\n        update_to = tqdm_args.pop('update_to', False)\n        if sum((delim_per_char, update, update_to)) > 1:\n            raise TqdmKeyError(\"Can only have one of --bytes --update --update_to\")\n    except Exception:\n        fp.write(\"\\nError:\\n\" + help_short)\n        stdin, stdout_write = sys.stdin, sys.stdout.write\n        for i in stdin:\n            stdout_write(i)\n        raise\n    else:\n        buf_size = tqdm_args.pop('buf_size', 256)\n        delim = tqdm_args.pop('delim', b'\\\\n')\n        tee = tqdm_args.pop('tee', False)\n        manpath = tqdm_args.pop('manpath', None)\n        comppath = tqdm_args.pop('comppath', None)\n        if tqdm_args.pop('null', False):\n            class stdout(object):\n                @staticmethod\n                def write(_):\n                    pass\n        else:\n            stdout = sys.stdout\n            stdout = getattr(stdout, 'buffer', stdout)\n        stdin = getattr(sys.stdin, 'buffer', sys.stdin)\n        if manpath or comppath:\n            from importlib import resources\n            from os import path\n            from shutil import copyfile\n\n            def cp(name, dst):\n                \"\"\"copy resource `name` to `dst`\"\"\"\n                if hasattr(resources, 'files'):\n                    copyfile(str(resources.files('tqdm') / name), dst)\n                else:  # py<3.9\n                    with resources.path('tqdm', name) as src:\n                        copyfile(str(src), dst)\n                log.info(\"written:%s\", dst)\n            if manpath is not None:\n                cp('tqdm.1', path.join(manpath, 'tqdm.1'))\n            if comppath is not None:\n                cp('completion.sh', path.join(comppath, 'tqdm_completion.sh'))\n            sys.exit(0)\n        if tee:\n            stdout_write = stdout.write\n            fp_write = getattr(fp, 'buffer', fp).write\n\n            class stdout(object):  # pylint: disable=function-redefined\n                @staticmethod\n                def write(x):\n                    with tqdm.external_write_mode(file=fp):\n                        fp_write(x)\n                    stdout_write(x)\n        if delim_per_char:\n            tqdm_args.setdefault('unit', 'B')\n            tqdm_args.setdefault('unit_scale', True)\n            tqdm_args.setdefault('unit_divisor', 1024)\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                posix_pipe(stdin, stdout, '', buf_size, t.update)\n        elif delim == b'\\\\n':\n            log.debug(tqdm_args)\n            write = stdout.write\n            if update or update_to:\n                with tqdm(**tqdm_args) as t:\n                    if update:\n                        def callback(i):\n                            t.update(numeric(i.decode()))\n                    else:  # update_to\n                        def callback(i):\n                            t.update(numeric(i.decode()) - t.n)\n                    for i in stdin:\n                        write(i)\n                        callback(i)\n            else:\n                for i in tqdm(stdin, **tqdm_args):\n                    write(i)\n        else:\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                callback_len = False\n                if update:\n                    def callback(i):\n                        t.update(numeric(i.decode()))\n                elif update_to:\n                    def callback(i):\n                        t.update(numeric(i.decode()) - t.n)\n                else:\n                    callback = t.update\n                    callback_len = True\n                posix_pipe(stdin, stdout, delim, buf_size, callback, callback_len)\n", "tqdm/auto.py": "\"\"\"\nEnables multiple commonly used features.\n\nMethod resolution order:\n\n- `tqdm.autonotebook` without import warnings\n- `tqdm.asyncio`\n- `tqdm.std` base class\n\nUsage:\n>>> from tqdm.auto import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport warnings\n\nfrom .std import TqdmExperimentalWarning\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", category=TqdmExperimentalWarning)\n    from .autonotebook import tqdm as notebook_tqdm\n\nfrom .asyncio import tqdm as asyncio_tqdm\nfrom .std import tqdm as std_tqdm\n\nif notebook_tqdm != std_tqdm:\n    class tqdm(notebook_tqdm, asyncio_tqdm):  # pylint: disable=inconsistent-mro\n        pass\nelse:\n    tqdm = asyncio_tqdm\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for `tqdm.auto.tqdm(range(*args), **kwargs)`.\n    \"\"\"\n    return tqdm(range(*args), **kwargs)\n\n\n__all__ = [\"tqdm\", \"trange\"]\n", "tqdm/utils.py": "\"\"\"\nGeneral helpers required for `tqdm.std`.\n\"\"\"\nimport os\nimport re\nimport sys\nfrom functools import partial, partialmethod, wraps\nfrom inspect import signature\n# TODO consider using wcswidth third-party package for 0-width characters\nfrom unicodedata import east_asian_width\nfrom warnings import warn\nfrom weakref import proxy\n\n_range, _unich, _unicode, _basestring = range, chr, str, str\nCUR_OS = sys.platform\nIS_WIN = any(CUR_OS.startswith(i) for i in ['win32', 'cygwin'])\nIS_NIX = any(CUR_OS.startswith(i) for i in ['aix', 'linux', 'darwin'])\nRE_ANSI = re.compile(r\"\\x1b\\[[;\\d]*[A-Za-z]\")\n\ntry:\n    if IS_WIN:\n        import colorama\n    else:\n        raise ImportError\nexcept ImportError:\n    colorama = None\nelse:\n    try:\n        colorama.init(strip=False)\n    except TypeError:\n        colorama.init()\n\n\ndef envwrap(prefix, types=None, is_method=False):\n    \"\"\"\n    Override parameter defaults via `os.environ[prefix + param_name]`.\n    Maps UPPER_CASE env vars map to lower_case param names.\n    camelCase isn't supported (because Windows ignores case).\n\n    Precedence (highest first):\n\n    - call (`foo(a=3)`)\n    - environ (`FOO_A=2`)\n    - signature (`def foo(a=1)`)\n\n    Parameters\n    ----------\n    prefix  : str\n        Env var prefix, e.g. \"FOO_\"\n    types  : dict, optional\n        Fallback mappings `{'param_name': type, ...}` if types cannot be\n        inferred from function signature.\n        Consider using `types=collections.defaultdict(lambda: ast.literal_eval)`.\n    is_method  : bool, optional\n        Whether to use `functools.partialmethod`. If (default: False) use `functools.partial`.\n\n    Examples\n    --------\n    ```\n    $ cat foo.py\n    from tqdm.utils import envwrap\n    @envwrap(\"FOO_\")\n    def test(a=1, b=2, c=3):\n        print(f\"received: a={a}, b={b}, c={c}\")\n\n    $ FOO_A=42 FOO_C=1337 python -c 'import foo; foo.test(c=99)'\n    received: a=42, b=2, c=99\n    ```\n    \"\"\"\n    if types is None:\n        types = {}\n    i = len(prefix)\n    env_overrides = {k[i:].lower(): v for k, v in os.environ.items() if k.startswith(prefix)}\n    part = partialmethod if is_method else partial\n\n    def wrap(func):\n        params = signature(func).parameters\n        # ignore unknown env vars\n        overrides = {k: v for k, v in env_overrides.items() if k in params}\n        # infer overrides' `type`s\n        for k in overrides:\n            param = params[k]\n            if param.annotation is not param.empty:  # typehints\n                for typ in getattr(param.annotation, '__args__', (param.annotation,)):\n                    try:\n                        overrides[k] = typ(overrides[k])\n                    except Exception:\n                        pass\n                    else:\n                        break\n            elif param.default is not None:  # type of default value\n                overrides[k] = type(param.default)(overrides[k])\n            else:\n                try:  # `types` fallback\n                    overrides[k] = types[k](overrides[k])\n                except KeyError:  # keep unconverted (`str`)\n                    pass\n        return part(func, **overrides)\n    return wrap\n\n\nclass FormatReplace(object):\n    \"\"\"\n    >>> a = FormatReplace('something')\n    >>> f\"{a:5d}\"\n    'something'\n    \"\"\"  # NOQA: P102\n    def __init__(self, replace=''):\n        self.replace = replace\n        self.format_called = 0\n\n    def __format__(self, _):\n        self.format_called += 1\n        return self.replace\n\n\nclass Comparable(object):\n    \"\"\"Assumes child has self._comparable attr/@property\"\"\"\n    def __lt__(self, other):\n        return self._comparable < other._comparable\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return self._comparable == other._comparable\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __gt__(self, other):\n        return not self <= other\n\n    def __ge__(self, other):\n        return not self < other\n\n\nclass ObjectWrapper(object):\n    def __getattr__(self, name):\n        return getattr(self._wrapped, name)\n\n    def __setattr__(self, name, value):\n        return setattr(self._wrapped, name, value)\n\n    def wrapper_getattr(self, name):\n        \"\"\"Actual `self.getattr` rather than self._wrapped.getattr\"\"\"\n        try:\n            return object.__getattr__(self, name)\n        except AttributeError:  # py2\n            return getattr(self, name)\n\n    def wrapper_setattr(self, name, value):\n        \"\"\"Actual `self.setattr` rather than self._wrapped.setattr\"\"\"\n        return object.__setattr__(self, name, value)\n\n    def __init__(self, wrapped):\n        \"\"\"\n        Thin wrapper around a given object\n        \"\"\"\n        self.wrapper_setattr('_wrapped', wrapped)\n\n\nclass SimpleTextIOWrapper(ObjectWrapper):\n    \"\"\"\n    Change only `.write()` of the wrapped object by encoding the passed\n    value and passing the result to the wrapped object's `.write()` method.\n    \"\"\"\n    # pylint: disable=too-few-public-methods\n    def __init__(self, wrapped, encoding):\n        super().__init__(wrapped)\n        self.wrapper_setattr('encoding', encoding)\n\n    def write(self, s):\n        \"\"\"\n        Encode `s` and pass to the wrapped object's `.write()` method.\n        \"\"\"\n        return self._wrapped.write(s.encode(self.wrapper_getattr('encoding')))\n\n    def __eq__(self, other):\n        return self._wrapped == getattr(other, '_wrapped', other)\n\n\nclass DisableOnWriteError(ObjectWrapper):\n    \"\"\"\n    Disable the given `tqdm_instance` upon `write()` or `flush()` errors.\n    \"\"\"\n    @staticmethod\n    def disable_on_exception(tqdm_instance, func):\n        \"\"\"\n        Quietly set `tqdm_instance.miniters=inf` if `func` raises `errno=5`.\n        \"\"\"\n        tqdm_instance = proxy(tqdm_instance)\n\n        def inner(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except OSError as e:\n                if e.errno != 5:\n                    raise\n                try:\n                    tqdm_instance.miniters = float('inf')\n                except ReferenceError:\n                    pass\n            except ValueError as e:\n                if 'closed' not in str(e):\n                    raise\n                try:\n                    tqdm_instance.miniters = float('inf')\n                except ReferenceError:\n                    pass\n        return inner\n\n    def __init__(self, wrapped, tqdm_instance):\n        super().__init__(wrapped)\n        if hasattr(wrapped, 'write'):\n            self.wrapper_setattr(\n                'write', self.disable_on_exception(tqdm_instance, wrapped.write))\n        if hasattr(wrapped, 'flush'):\n            self.wrapper_setattr(\n                'flush', self.disable_on_exception(tqdm_instance, wrapped.flush))\n\n    def __eq__(self, other):\n        return self._wrapped == getattr(other, '_wrapped', other)\n\n\nclass CallbackIOWrapper(ObjectWrapper):\n    def __init__(self, callback, stream, method=\"read\"):\n        \"\"\"\n        Wrap a given `file`-like object's `read()` or `write()` to report\n        lengths to the given `callback`\n        \"\"\"\n        super().__init__(stream)\n        func = getattr(stream, method)\n        if method == \"write\":\n            @wraps(func)\n            def write(data, *args, **kwargs):\n                res = func(data, *args, **kwargs)\n                callback(len(data))\n                return res\n            self.wrapper_setattr('write', write)\n        elif method == \"read\":\n            @wraps(func)\n            def read(*args, **kwargs):\n                data = func(*args, **kwargs)\n                callback(len(data))\n                return data\n            self.wrapper_setattr('read', read)\n        else:\n            raise KeyError(\"Can only wrap read/write methods\")\n\n\ndef _is_utf(encoding):\n    try:\n        u'\\u2588\\u2589'.encode(encoding)\n    except UnicodeEncodeError:\n        return False\n    except Exception:\n        try:\n            return encoding.lower().startswith('utf-') or ('U8' == encoding)\n        except Exception:\n            return False\n    else:\n        return True\n\n\ndef _supports_unicode(fp):\n    try:\n        return _is_utf(fp.encoding)\n    except AttributeError:\n        return False\n\n\ndef _is_ascii(s):\n    if isinstance(s, str):\n        for c in s:\n            if ord(c) > 255:\n                return False\n        return True\n    return _supports_unicode(s)\n\n\ndef _screen_shape_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which returns console dimensions (width, height).\n    Supported: linux, osx, windows, cygwin.\n    \"\"\"\n    _screen_shape = None\n    if IS_WIN:\n        _screen_shape = _screen_shape_windows\n        if _screen_shape is None:\n            _screen_shape = _screen_shape_tput\n    if IS_NIX:\n        _screen_shape = _screen_shape_linux\n    return _screen_shape\n\n\ndef _screen_shape_windows(fp):  # pragma: no cover\n    try:\n        import struct\n        from ctypes import create_string_buffer, windll\n        from sys import stdin, stdout\n\n        io_handle = -12  # assume stderr\n        if fp == stdin:\n            io_handle = -10\n        elif fp == stdout:\n            io_handle = -11\n\n        h = windll.kernel32.GetStdHandle(io_handle)\n        csbi = create_string_buffer(22)\n        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n        if res:\n            (_bufx, _bufy, _curx, _cury, _wattr, left, top, right, bottom,\n             _maxx, _maxy) = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n            return right - left, bottom - top  # +1\n    except Exception:  # nosec\n        pass\n    return None, None\n\n\ndef _screen_shape_tput(*_):  # pragma: no cover\n    \"\"\"cygwin xterm (windows)\"\"\"\n    try:\n        import shlex\n        from subprocess import check_call  # nosec\n        return [int(check_call(shlex.split('tput ' + i))) - 1\n                for i in ('cols', 'lines')]\n    except Exception:  # nosec\n        pass\n    return None, None\n\n\ndef _screen_shape_linux(fp):  # pragma: no cover\n\n    try:\n        from array import array\n        from fcntl import ioctl\n        from termios import TIOCGWINSZ\n    except ImportError:\n        return None, None\n    else:\n        try:\n            rows, cols = array('h', ioctl(fp, TIOCGWINSZ, '\\0' * 8))[:2]\n            return cols, rows\n        except Exception:\n            try:\n                return [int(os.environ[i]) - 1 for i in (\"COLUMNS\", \"LINES\")]\n            except (KeyError, ValueError):\n                return None, None\n\n\ndef _environ_cols_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which returns console width.\n    Supported: linux, osx, windows, cygwin.\n    \"\"\"\n    warn(\"Use `_screen_shape_wrapper()(file)[0]` instead of\"\n         \" `_environ_cols_wrapper()(file)`\", DeprecationWarning, stacklevel=2)\n    shape = _screen_shape_wrapper()\n    if not shape:\n        return None\n\n    @wraps(shape)\n    def inner(fp):\n        return shape(fp)[0]\n\n    return inner\n\n\ndef _term_move_up():  # pragma: no cover\n    return '' if (os.name == 'nt') and (colorama is None) else '\\x1b[A'\n\n\ndef _text_width(s):\n    return sum(2 if east_asian_width(ch) in 'FW' else 1 for ch in str(s))\n\n\ndef disp_len(data):\n    \"\"\"\n    Returns the real on-screen length of a string which may contain\n    ANSI control codes and wide chars.\n    \"\"\"\n    return _text_width(RE_ANSI.sub('', data))\n\n\ndef disp_trim(data, length):\n    \"\"\"\n    Trim a string which may contain ANSI control characters.\n    \"\"\"\n    if len(data) == disp_len(data):\n        return data[:length]\n\n    ansi_present = bool(RE_ANSI.search(data))\n    while disp_len(data) > length:  # carefully delete one char at a time\n        data = data[:-1]\n    if ansi_present and bool(RE_ANSI.search(data)):\n        # assume ANSI reset is required\n        return data if data.endswith(\"\\033[0m\") else data + \"\\033[0m\"\n    return data\n", "tqdm/autonotebook.py": "\"\"\"\nAutomatically choose between `tqdm.notebook` and `tqdm.std`.\n\nUsage:\n>>> from tqdm.autonotebook import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport sys\nfrom warnings import warn\n\ntry:\n    get_ipython = sys.modules['IPython'].get_ipython\n    if 'IPKernelApp' not in get_ipython().config:  # pragma: no cover\n        raise ImportError(\"console\")\n    from .notebook import WARN_NOIPYW, IProgress\n    if IProgress is None:\n        from .std import TqdmWarning\n        warn(WARN_NOIPYW, TqdmWarning, stacklevel=2)\n        raise ImportError('ipywidgets')\nexcept Exception:\n    from .std import tqdm, trange\nelse:  # pragma: no cover\n    from .notebook import tqdm, trange\n    from .std import TqdmExperimentalWarning\n    warn(\"Using `tqdm.autonotebook.tqdm` in notebook mode.\"\n         \" Use `tqdm.tqdm` instead to force console mode\"\n         \" (e.g. in jupyter console)\", TqdmExperimentalWarning, stacklevel=2)\n__all__ = [\"tqdm\", \"trange\"]\n", "tqdm/dask.py": "from functools import partial\n\nfrom dask.callbacks import Callback\n\nfrom .auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TqdmCallback']\n\n\nclass TqdmCallback(Callback):\n    \"\"\"Dask callback for task progress.\"\"\"\n    def __init__(self, start=None, pretask=None, tqdm_class=tqdm_auto,\n                 **tqdm_kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        tqdm_class  : optional\n            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].\n        tqdm_kwargs  : optional\n            Any other arguments used for all bars.\n        \"\"\"\n        super().__init__(start=start, pretask=pretask)\n        if tqdm_kwargs:\n            tqdm_class = partial(tqdm_class, **tqdm_kwargs)\n        self.tqdm_class = tqdm_class\n\n    def _start_state(self, _, state):\n        self.pbar = self.tqdm_class(total=sum(\n            len(state[k]) for k in ['ready', 'waiting', 'running', 'finished']))\n\n    def _posttask(self, *_, **__):\n        self.pbar.update()\n\n    def _finish(self, *_, **__):\n        self.pbar.close()\n\n    def display(self):\n        \"\"\"Displays in the current cell in Notebooks.\"\"\"\n        container = getattr(self.bar, 'container', None)\n        if container is None:\n            return\n        from .notebook import display\n        display(container)\n", "tqdm/version.py": "\"\"\"`tqdm` version detector. Precedence: installed dist, git, 'UNKNOWN'.\"\"\"\ntry:\n    from ._dist_ver import __version__\nexcept ImportError:\n    try:\n        from setuptools_scm import get_version\n        __version__ = get_version(root='..', relative_to=__file__)\n    except (ImportError, LookupError):\n        __version__ = \"UNKNOWN\"\n", "tqdm/tk.py": "\"\"\"\nTkinter GUI progressbar decorator for iterators.\n\nUsage:\n>>> from tqdm.tk import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport re\nimport sys\nimport tkinter\nimport tkinter.ttk as ttk\nfrom warnings import warn\n\nfrom .std import TqdmExperimentalWarning, TqdmWarning\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"richardsheridan\", \"casperdcl\"]}\n__all__ = ['tqdm_tk', 'ttkrange', 'tqdm', 'trange']\n\n\nclass tqdm_tk(std_tqdm):  # pragma: no cover\n    \"\"\"\n    Experimental Tkinter GUI version of tqdm!\n\n    Note: Window interactivity suffers if `tqdm_tk` is not running within\n    a Tkinter mainloop and values are generated infrequently. In this case,\n    consider calling `tqdm_tk.refresh()` frequently in the Tk thread.\n    \"\"\"\n\n    # TODO: @classmethod: write()?\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        This class accepts the following parameters *in addition* to\n        the parameters accepted by `tqdm`.\n\n        Parameters\n        ----------\n        grab  : bool, optional\n            Grab the input across all windows of the process.\n        tk_parent  : `tkinter.Wm`, optional\n            Parent Tk window.\n        cancel_callback  : Callable, optional\n            Create a cancel button and set `cancel_callback` to be called\n            when the cancel or window close button is clicked.\n        \"\"\"\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        self._warn_leave = 'leave' in kwargs\n        grab = kwargs.pop('grab', False)\n        tk_parent = kwargs.pop('tk_parent', None)\n        self._cancel_callback = kwargs.pop('cancel_callback', None)\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        if tk_parent is None:  # Discover parent widget\n            try:\n                tk_parent = tkinter._default_root\n            except AttributeError:\n                raise AttributeError(\n                    \"`tk_parent` required when using `tkinter.NoDefaultRoot()`\")\n            if tk_parent is None:  # use new default root window as display\n                self._tk_window = tkinter.Tk()\n            else:  # some other windows already exist\n                self._tk_window = tkinter.Toplevel()\n        else:\n            self._tk_window = tkinter.Toplevel(tk_parent)\n\n        warn(\"GUI is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        self._tk_dispatching = self._tk_dispatching_helper()\n\n        self._tk_window.protocol(\"WM_DELETE_WINDOW\", self.cancel)\n        self._tk_window.wm_title(self.desc)\n        self._tk_window.wm_attributes(\"-topmost\", 1)\n        self._tk_window.after(0, lambda: self._tk_window.wm_attributes(\"-topmost\", 0))\n        self._tk_n_var = tkinter.DoubleVar(self._tk_window, value=0)\n        self._tk_text_var = tkinter.StringVar(self._tk_window)\n        pbar_frame = ttk.Frame(self._tk_window, padding=5)\n        pbar_frame.pack()\n        _tk_label = ttk.Label(pbar_frame, textvariable=self._tk_text_var,\n                              wraplength=600, anchor=\"center\", justify=\"center\")\n        _tk_label.pack()\n        self._tk_pbar = ttk.Progressbar(\n            pbar_frame, variable=self._tk_n_var, length=450)\n        if self.total is not None:\n            self._tk_pbar.configure(maximum=self.total)\n        else:\n            self._tk_pbar.configure(mode=\"indeterminate\")\n        self._tk_pbar.pack()\n        if self._cancel_callback is not None:\n            _tk_button = ttk.Button(pbar_frame, text=\"Cancel\", command=self.cancel)\n            _tk_button.pack()\n        if grab:\n            self._tk_window.grab_set()\n\n    def close(self):\n        if self.disable:\n            return\n\n        self.disable = True\n\n        with self.get_lock():\n            self._instances.remove(self)\n\n        def _close():\n            self._tk_window.after('idle', self._tk_window.destroy)\n            if not self._tk_dispatching:\n                self._tk_window.update()\n\n        self._tk_window.protocol(\"WM_DELETE_WINDOW\", _close)\n\n        # if leave is set but we are self-dispatching, the left window is\n        # totally unresponsive unless the user manually dispatches\n        if not self.leave:\n            _close()\n        elif not self._tk_dispatching:\n            if self._warn_leave:\n                warn(\"leave flag ignored if not in tkinter mainloop\",\n                     TqdmWarning, stacklevel=2)\n            _close()\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        self._tk_n_var.set(self.n)\n        d = self.format_dict\n        # remove {bar}\n        d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n            \"{bar}\", \"<bar/>\")\n        msg = self.format_meter(**d)\n        if '<bar/>' in msg:\n            msg = \"\".join(re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n        self._tk_text_var.set(msg)\n        if not self._tk_dispatching:\n            self._tk_window.update()\n\n    def set_description(self, desc=None, refresh=True):\n        self.set_description_str(desc, refresh)\n\n    def set_description_str(self, desc=None, refresh=True):\n        self.desc = desc\n        if not self.disable:\n            self._tk_window.wm_title(desc)\n            if refresh and not self._tk_dispatching:\n                self._tk_window.update()\n\n    def cancel(self):\n        \"\"\"\n        `cancel_callback()` followed by `close()`\n        when close/cancel buttons clicked.\n        \"\"\"\n        if self._cancel_callback is not None:\n            self._cancel_callback()\n        self.close()\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if hasattr(self, '_tk_pbar'):\n            if total is None:\n                self._tk_pbar.configure(maximum=100, mode=\"indeterminate\")\n            else:\n                self._tk_pbar.configure(maximum=total, mode=\"determinate\")\n        super().reset(total=total)\n\n    @staticmethod\n    def _tk_dispatching_helper():\n        \"\"\"determine if Tkinter mainloop is dispatching events\"\"\"\n        codes = {tkinter.mainloop.__code__, tkinter.Misc.mainloop.__code__}\n        for frame in sys._current_frames().values():\n            while frame:\n                if frame.f_code in codes:\n                    return True\n                frame = frame.f_back\n        return False\n\n\ndef ttkrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.tk.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_tk(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_tk\ntrange = ttkrange\n", "tqdm/_monitor.py": "import atexit\nfrom threading import Event, Thread, current_thread\nfrom time import time\nfrom warnings import warn\n\n__all__ = [\"TMonitor\", \"TqdmSynchronisationWarning\"]\n\n\nclass TqdmSynchronisationWarning(RuntimeWarning):\n    \"\"\"tqdm multi-thread/-process errors which may cause incorrect nesting\n    but otherwise no adverse effects\"\"\"\n    pass\n\n\nclass TMonitor(Thread):\n    \"\"\"\n    Monitoring thread for tqdm bars.\n    Monitors if tqdm bars are taking too much time to display\n    and readjusts miniters automatically if necessary.\n\n    Parameters\n    ----------\n    tqdm_cls  : class\n        tqdm class to use (can be core tqdm or a submodule).\n    sleep_interval  : float\n        Time to sleep between monitoring checks.\n    \"\"\"\n    _test = {}  # internal vars for unit testing\n\n    def __init__(self, tqdm_cls, sleep_interval):\n        Thread.__init__(self)\n        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)\n        self.woken = 0  # last time woken up, to sync with monitor\n        self.tqdm_cls = tqdm_cls\n        self.sleep_interval = sleep_interval\n        self._time = self._test.get(\"time\", time)\n        self.was_killed = self._test.get(\"Event\", Event)()\n        atexit.register(self.exit)\n        self.start()\n\n    def exit(self):\n        self.was_killed.set()\n        if self is not current_thread():\n            self.join()\n        return self.report()\n\n    def get_instances(self):\n        # returns a copy of started `tqdm_cls` instances\n        return [i for i in self.tqdm_cls._instances.copy()\n                # Avoid race by checking that the instance started\n                if hasattr(i, 'start_t')]\n\n    def run(self):\n        cur_t = self._time()\n        while True:\n            # After processing and before sleeping, notify that we woke\n            # Need to be done just before sleeping\n            self.woken = cur_t\n            # Sleep some time...\n            self.was_killed.wait(self.sleep_interval)\n            # Quit if killed\n            if self.was_killed.is_set():\n                return\n            # Then monitor!\n            # Acquire lock (to access _instances)\n            with self.tqdm_cls.get_lock():\n                cur_t = self._time()\n                # Check tqdm instances are waiting too long to print\n                instances = self.get_instances()\n                for instance in instances:\n                    # Check event in loop to reduce blocking time on exit\n                    if self.was_killed.is_set():\n                        return\n                    # Only if mininterval > 1 (else iterations are just slow)\n                    # and last refresh exceeded maxinterval\n                    if (\n                        instance.miniters > 1\n                        and (cur_t - instance.last_print_t) >= instance.maxinterval\n                    ):\n                        # force bypassing miniters on next iteration\n                        # (dynamic_miniters adjusts mininterval automatically)\n                        instance.miniters = 1\n                        # Refresh now! (works only for manual tqdm)\n                        instance.refresh(nolock=True)\n                    # Remove accidental long-lived strong reference\n                    del instance\n                if instances != self.get_instances():  # pragma: nocover\n                    warn(\"Set changed size during iteration\" +\n                         \" (see https://github.com/tqdm/tqdm/issues/481)\",\n                         TqdmSynchronisationWarning, stacklevel=2)\n                # Remove accidental long-lived strong references\n                del instances\n\n    def report(self):\n        return not self.was_killed.is_set()\n", "tqdm/_utils.py": "from warnings import warn\n\nfrom .std import TqdmDeprecationWarning\nfrom .utils import (  # NOQA, pylint: disable=unused-import\n    CUR_OS, IS_NIX, IS_WIN, RE_ANSI, Comparable, FormatReplace, SimpleTextIOWrapper,\n    _environ_cols_wrapper, _is_ascii, _is_utf, _screen_shape_linux, _screen_shape_tput,\n    _screen_shape_windows, _screen_shape_wrapper, _supports_unicode, _term_move_up, colorama)\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.utils.*` instead of `tqdm._utils.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/keras.py": "from copy import copy\nfrom functools import partial\n\nfrom .auto import tqdm as tqdm_auto\n\ntry:\n    import keras\nexcept (ImportError, AttributeError) as e:\n    try:\n        from tensorflow import keras\n    except ImportError:\n        raise e\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TqdmCallback']\n\n\nclass TqdmCallback(keras.callbacks.Callback):\n    \"\"\"Keras callback for epoch and batch progress.\"\"\"\n    @staticmethod\n    def bar2callback(bar, pop=None, delta=(lambda logs: 1)):\n        def callback(_, logs=None):\n            n = delta(logs)\n            if logs:\n                if pop:\n                    logs = copy(logs)\n                    [logs.pop(i, 0) for i in pop]\n                bar.set_postfix(logs, refresh=False)\n            bar.update(n)\n\n        return callback\n\n    def __init__(self, epochs=None, data_size=None, batch_size=None, verbose=1,\n                 tqdm_class=tqdm_auto, **tqdm_kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        epochs  : int, optional\n        data_size  : int, optional\n            Number of training pairs.\n        batch_size  : int, optional\n            Number of training pairs per batch.\n        verbose  : int\n            0: epoch, 1: batch (transient), 2: batch. [default: 1].\n            Will be set to `0` unless both `data_size` and `batch_size`\n            are given.\n        tqdm_class  : optional\n            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].\n        tqdm_kwargs  : optional\n            Any other arguments used for all bars.\n        \"\"\"\n        if tqdm_kwargs:\n            tqdm_class = partial(tqdm_class, **tqdm_kwargs)\n        self.tqdm_class = tqdm_class\n        self.epoch_bar = tqdm_class(total=epochs, unit='epoch')\n        self.on_epoch_end = self.bar2callback(self.epoch_bar)\n        if data_size and batch_size:\n            self.batches = batches = (data_size + batch_size - 1) // batch_size\n        else:\n            self.batches = batches = None\n        self.verbose = verbose\n        if verbose == 1:\n            self.batch_bar = tqdm_class(total=batches, unit='batch', leave=False)\n            self.on_batch_end = self.bar2callback(\n                self.batch_bar, pop=['batch', 'size'],\n                delta=lambda logs: logs.get('size', 1))\n\n    def on_train_begin(self, *_, **__):\n        params = self.params.get\n        auto_total = params('epochs', params('nb_epoch', None))\n        if auto_total is not None and auto_total != self.epoch_bar.total:\n            self.epoch_bar.reset(total=auto_total)\n\n    def on_epoch_begin(self, epoch, *_, **__):\n        if self.epoch_bar.n < epoch:\n            ebar = self.epoch_bar\n            ebar.n = ebar.last_print_n = ebar.initial = epoch\n        if self.verbose:\n            params = self.params.get\n            total = params('samples', params(\n                'nb_sample', params('steps', None))) or self.batches\n            if self.verbose == 2:\n                if hasattr(self, 'batch_bar'):\n                    self.batch_bar.close()\n                self.batch_bar = self.tqdm_class(\n                    total=total, unit='batch', leave=True,\n                    unit_scale=1 / (params('batch_size', 1) or 1))\n                self.on_batch_end = self.bar2callback(\n                    self.batch_bar, pop=['batch', 'size'],\n                    delta=lambda logs: logs.get('size', 1))\n            elif self.verbose == 1:\n                self.batch_bar.unit_scale = 1 / (params('batch_size', 1) or 1)\n                self.batch_bar.reset(total=total)\n            else:\n                raise KeyError('Unknown verbosity')\n\n    def on_train_end(self, *_, **__):\n        if hasattr(self, 'batch_bar'):\n            self.batch_bar.close()\n        self.epoch_bar.close()\n\n    def display(self):\n        \"\"\"Displays in the current cell in Notebooks.\"\"\"\n        container = getattr(self.epoch_bar, 'container', None)\n        if container is None:\n            return\n        from .notebook import display\n        display(container)\n        batch_bar = getattr(self, 'batch_bar', None)\n        if batch_bar is not None:\n            display(batch_bar.container)\n\n    @staticmethod\n    def _implements_train_batch_hooks():\n        return True\n\n    @staticmethod\n    def _implements_test_batch_hooks():\n        return True\n\n    @staticmethod\n    def _implements_predict_batch_hooks():\n        return True\n", "tqdm/__main__.py": "from .cli import main\n\nmain()\n", "tqdm/gui.py": "\"\"\"\nMatplotlib GUI progressbar decorator for iterators.\n\nUsage:\n>>> from tqdm.gui import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nimport re\nfrom warnings import warn\n\n# to inherit from the tqdm class\nfrom .std import TqdmExperimentalWarning\nfrom .std import tqdm as std_tqdm\n\n# import compatibility functions and utilities\n\n__author__ = {\"github.com/\": [\"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm_gui', 'tgrange', 'tqdm', 'trange']\n\n\nclass tqdm_gui(std_tqdm):  # pragma: no cover\n    \"\"\"Experimental Matplotlib GUI version of tqdm!\"\"\"\n    # TODO: @classmethod: write() on GUI?\n    def __init__(self, *args, **kwargs):\n        from collections import deque\n\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        colour = kwargs.pop('colour', 'g')\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        warn(\"GUI is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        self.mpl = mpl\n        self.plt = plt\n\n        # Remember if external environment uses toolbars\n        self.toolbar = self.mpl.rcParams['toolbar']\n        self.mpl.rcParams['toolbar'] = 'None'\n\n        self.mininterval = max(self.mininterval, 0.5)\n        self.fig, ax = plt.subplots(figsize=(9, 2.2))\n        # self.fig.subplots_adjust(bottom=0.2)\n        total = self.__len__()  # avoids TypeError on None #971\n        if total is not None:\n            self.xdata = []\n            self.ydata = []\n            self.zdata = []\n        else:\n            self.xdata = deque([])\n            self.ydata = deque([])\n            self.zdata = deque([])\n        self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n        self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n        ax.set_ylim(0, 0.001)\n        if total is not None:\n            ax.set_xlim(0, 100)\n            ax.set_xlabel(\"percent\")\n            self.fig.legend((self.line1, self.line2), (\"cur\", \"est\"),\n                            loc='center right')\n            # progressbar\n            self.hspan = plt.axhspan(0, 0.001, xmin=0, xmax=0, color=colour)\n        else:\n            # ax.set_xlim(-60, 0)\n            ax.set_xlim(0, 60)\n            ax.invert_xaxis()\n            ax.set_xlabel(\"seconds\")\n            ax.legend((\"cur\", \"est\"), loc='lower left')\n        ax.grid()\n        # ax.set_xlabel('seconds')\n        ax.set_ylabel((self.unit if self.unit else \"it\") + \"/s\")\n        if self.unit_scale:\n            plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))\n            ax.yaxis.get_offset_text().set_x(-0.15)\n\n        # Remember if external environment is interactive\n        self.wasion = plt.isinteractive()\n        plt.ion()\n        self.ax = ax\n\n    def close(self):\n        if self.disable:\n            return\n\n        self.disable = True\n\n        with self.get_lock():\n            self._instances.remove(self)\n\n        # Restore toolbars\n        self.mpl.rcParams['toolbar'] = self.toolbar\n        # Return to non-interactive mode\n        if not self.wasion:\n            self.plt.ioff()\n        if self.leave:\n            self.display()\n        else:\n            self.plt.close(self.fig)\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        n = self.n\n        cur_t = self._time()\n        elapsed = cur_t - self.start_t\n        delta_it = n - self.last_print_n\n        delta_t = cur_t - self.last_print_t\n\n        # Inline due to multiple calls\n        total = self.total\n        xdata = self.xdata\n        ydata = self.ydata\n        zdata = self.zdata\n        ax = self.ax\n        line1 = self.line1\n        line2 = self.line2\n        # instantaneous rate\n        y = delta_it / delta_t\n        # overall rate\n        z = n / elapsed\n        # update line data\n        xdata.append(n * 100.0 / total if total else cur_t)\n        ydata.append(y)\n        zdata.append(z)\n\n        # Discard old values\n        # xmin, xmax = ax.get_xlim()\n        # if (not total) and elapsed > xmin * 1.1:\n        if (not total) and elapsed > 66:\n            xdata.popleft()\n            ydata.popleft()\n            zdata.popleft()\n\n        ymin, ymax = ax.get_ylim()\n        if y > ymax or z > ymax:\n            ymax = 1.1 * y\n            ax.set_ylim(ymin, ymax)\n            ax.figure.canvas.draw()\n\n        if total:\n            line1.set_data(xdata, ydata)\n            line2.set_data(xdata, zdata)\n            try:\n                poly_lims = self.hspan.get_xy()\n            except AttributeError:\n                self.hspan = self.plt.axhspan(0, 0.001, xmin=0, xmax=0, color='g')\n                poly_lims = self.hspan.get_xy()\n            poly_lims[0, 1] = ymin\n            poly_lims[1, 1] = ymax\n            poly_lims[2] = [n / total, ymax]\n            poly_lims[3] = [poly_lims[2, 0], ymin]\n            if len(poly_lims) > 4:\n                poly_lims[4, 1] = ymin\n            self.hspan.set_xy(poly_lims)\n        else:\n            t_ago = [cur_t - i for i in xdata]\n            line1.set_data(t_ago, ydata)\n            line2.set_data(t_ago, zdata)\n\n        d = self.format_dict\n        # remove {bar}\n        d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n            \"{bar}\", \"<bar/>\")\n        msg = self.format_meter(**d)\n        if '<bar/>' in msg:\n            msg = \"\".join(re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n        ax.set_title(msg, fontname=\"DejaVu Sans Mono\", fontsize=11)\n        self.plt.pause(1e-9)\n\n\ndef tgrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.gui.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_gui(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_gui\ntrange = tgrange\n", "tqdm/_tqdm_gui.py": "from warnings import warn\n\nfrom .gui import *  # NOQA\nfrom .gui import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.gui.*` instead of `tqdm._tqdm_gui.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/__init__.py": "from ._monitor import TMonitor, TqdmSynchronisationWarning\nfrom ._tqdm_pandas import tqdm_pandas\nfrom .cli import main  # TODO: remove in v5.0.0\nfrom .gui import tqdm as tqdm_gui  # TODO: remove in v5.0.0\nfrom .gui import trange as tgrange  # TODO: remove in v5.0.0\nfrom .std import (\n    TqdmDeprecationWarning, TqdmExperimentalWarning, TqdmKeyError, TqdmMonitorWarning,\n    TqdmTypeError, TqdmWarning, tqdm, trange)\nfrom .version import __version__\n\n__all__ = ['tqdm', 'tqdm_gui', 'trange', 'tgrange', 'tqdm_pandas',\n           'tqdm_notebook', 'tnrange', 'main', 'TMonitor',\n           'TqdmTypeError', 'TqdmKeyError',\n           'TqdmWarning', 'TqdmDeprecationWarning',\n           'TqdmExperimentalWarning',\n           'TqdmMonitorWarning', 'TqdmSynchronisationWarning',\n           '__version__']\n\n\ndef tqdm_notebook(*args, **kwargs):  # pragma: no cover\n    \"\"\"See tqdm.notebook.tqdm for full documentation\"\"\"\n    from warnings import warn\n\n    from .notebook import tqdm as _tqdm_notebook\n    warn(\"This function will be removed in tqdm==5.0.0\\n\"\n         \"Please use `tqdm.notebook.tqdm` instead of `tqdm.tqdm_notebook`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tqdm_notebook(*args, **kwargs)\n\n\ndef tnrange(*args, **kwargs):  # pragma: no cover\n    \"\"\"Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`.\"\"\"\n    from warnings import warn\n\n    from .notebook import trange as _tnrange\n    warn(\"Please use `tqdm.notebook.trange` instead of `tqdm.tnrange`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tnrange(*args, **kwargs)\n", "tqdm/rich.py": "\"\"\"\n`rich.progress` decorator for iterators.\n\nUsage:\n>>> from tqdm.rich import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nfrom warnings import warn\n\nfrom rich.progress import (\n    BarColumn, Progress, ProgressColumn, Text, TimeElapsedColumn, TimeRemainingColumn, filesize)\n\nfrom .std import TqdmExperimentalWarning\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tqdm_rich', 'trrange', 'tqdm', 'trange']\n\n\nclass FractionColumn(ProgressColumn):\n    \"\"\"Renders completed/total, e.g. '0.5/2.3 G'.\"\"\"\n    def __init__(self, unit_scale=False, unit_divisor=1000):\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        super().__init__()\n\n    def render(self, task):\n        \"\"\"Calculate common unit for completed and total.\"\"\"\n        completed = int(task.completed)\n        total = int(task.total)\n        if self.unit_scale:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                total,\n                [\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"],\n                self.unit_divisor,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(total, [\"\"], 1)\n        precision = 0 if unit == 1 else 1\n        return Text(\n            f\"{completed/unit:,.{precision}f}/{total/unit:,.{precision}f} {suffix}\",\n            style=\"progress.download\")\n\n\nclass RateColumn(ProgressColumn):\n    \"\"\"Renders human readable transfer speed.\"\"\"\n    def __init__(self, unit=\"\", unit_scale=False, unit_divisor=1000):\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        super().__init__()\n\n    def render(self, task):\n        \"\"\"Show data transfer speed.\"\"\"\n        speed = task.speed\n        if speed is None:\n            return Text(f\"? {self.unit}/s\", style=\"progress.data.speed\")\n        if self.unit_scale:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                speed,\n                [\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"],\n                self.unit_divisor,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(speed, [\"\"], 1)\n        precision = 0 if unit == 1 else 1\n        return Text(f\"{speed/unit:,.{precision}f} {suffix}{self.unit}/s\",\n                    style=\"progress.data.speed\")\n\n\nclass tqdm_rich(std_tqdm):  # pragma: no cover\n    \"\"\"Experimental rich.progress GUI version of tqdm!\"\"\"\n    # TODO: @classmethod: write()?\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        This class accepts the following parameters *in addition* to\n        the parameters accepted by `tqdm`.\n\n        Parameters\n        ----------\n        progress  : tuple, optional\n            arguments for `rich.progress.Progress()`.\n        options  : dict, optional\n            keyword arguments for `rich.progress.Progress()`.\n        \"\"\"\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        progress = kwargs.pop('progress', None)\n        options = kwargs.pop('options', {}).copy()\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        warn(\"rich is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        d = self.format_dict\n        if progress is None:\n            progress = (\n                \"[progress.description]{task.description}\"\n                \"[progress.percentage]{task.percentage:>4.0f}%\",\n                BarColumn(bar_width=None),\n                FractionColumn(\n                    unit_scale=d['unit_scale'], unit_divisor=d['unit_divisor']),\n                \"[\", TimeElapsedColumn(), \"<\", TimeRemainingColumn(),\n                \",\", RateColumn(unit=d['unit'], unit_scale=d['unit_scale'],\n                                unit_divisor=d['unit_divisor']), \"]\"\n            )\n        options.setdefault('transient', not self.leave)\n        self._prog = Progress(*progress, **options)\n        self._prog.__enter__()\n        self._task_id = self._prog.add_task(self.desc or \"\", **d)\n\n    def close(self):\n        if self.disable:\n            return\n        self.display()  # print 100%, vis #1306\n        super().close()\n        self._prog.__exit__(None, None, None)\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        if not hasattr(self, '_prog'):\n            return\n        self._prog.update(self._task_id, completed=self.n, description=self.desc)\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if hasattr(self, '_prog'):\n            self._prog.reset(total=total)\n        super().reset(total=total)\n\n\ndef trrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.rich.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_rich(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_rich\ntrange = trrange\n", "tqdm/_main.py": "from warnings import warn\n\nfrom .cli import *  # NOQA\nfrom .cli import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.cli.*` instead of `tqdm._main.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/_tqdm_notebook.py": "from warnings import warn\n\nfrom .notebook import *  # NOQA\nfrom .notebook import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.notebook.*` instead of `tqdm._tqdm_notebook.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/std.py": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport sys\nfrom collections import OrderedDict, defaultdict\nfrom contextlib import contextmanager\nfrom datetime import datetime, timedelta, timezone\nfrom numbers import Number\nfrom time import time\nfrom warnings import warn\nfrom weakref import WeakSet\n\nfrom ._monitor import TMonitor\nfrom .utils import (\n    CallbackIOWrapper, Comparable, DisableOnWriteError, FormatReplace, SimpleTextIOWrapper,\n    _is_ascii, _screen_shape_wrapper, _supports_unicode, _term_move_up, disp_len, disp_trim,\n    envwrap)\n\n__author__ = \"https://github.com/tqdm/tqdm#contributions\"\n__all__ = ['tqdm', 'trange',\n           'TqdmTypeError', 'TqdmKeyError', 'TqdmWarning',\n           'TqdmExperimentalWarning', 'TqdmDeprecationWarning',\n           'TqdmMonitorWarning']\n\n\nclass TqdmTypeError(TypeError):\n    pass\n\n\nclass TqdmKeyError(KeyError):\n    pass\n\n\nclass TqdmWarning(Warning):\n    \"\"\"base class for all tqdm warnings.\n\n    Used for non-external-code-breaking errors, such as garbled printing.\n    \"\"\"\n    def __init__(self, msg, fp_write=None, *a, **k):\n        if fp_write is not None:\n            fp_write(\"\\n\" + self.__class__.__name__ + \": \" + str(msg).rstrip() + '\\n')\n        else:\n            super().__init__(msg, *a, **k)\n\n\nclass TqdmExperimentalWarning(TqdmWarning, FutureWarning):\n    \"\"\"beta feature, unstable API and behaviour\"\"\"\n    pass\n\n\nclass TqdmDeprecationWarning(TqdmWarning, DeprecationWarning):\n    # not suppressed if raised\n    pass\n\n\nclass TqdmMonitorWarning(TqdmWarning, RuntimeWarning):\n    \"\"\"tqdm monitor errors which do not affect external functionality\"\"\"\n    pass\n\n\ndef TRLock(*args, **kwargs):\n    \"\"\"threading RLock\"\"\"\n    try:\n        from threading import RLock\n        return RLock(*args, **kwargs)\n    except (ImportError, OSError):  # pragma: no cover\n        pass\n\n\nclass TqdmDefaultWriteLock(object):\n    \"\"\"\n    Provide a default write lock for thread and multiprocessing safety.\n    Works only on platforms supporting `fork` (so Windows is excluded).\n    You must initialise a `tqdm` or `TqdmDefaultWriteLock` instance\n    before forking in order for the write lock to work.\n    On Windows, you need to supply the lock from the parent to the children as\n    an argument to joblib or the parallelism lib you use.\n    \"\"\"\n    # global thread lock so no setup required for multithreading.\n    # NB: Do not create multiprocessing lock as it sets the multiprocessing\n    # context, disallowing `spawn()`/`forkserver()`\n    th_lock = TRLock()\n\n    def __init__(self):\n        # Create global parallelism locks to avoid racing issues with parallel\n        # bars works only if fork available (Linux/MacOSX, but not Windows)\n        cls = type(self)\n        root_lock = cls.th_lock\n        if root_lock is not None:\n            root_lock.acquire()\n        cls.create_mp_lock()\n        self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]\n        if root_lock is not None:\n            root_lock.release()\n\n    def acquire(self, *a, **k):\n        for lock in self.locks:\n            lock.acquire(*a, **k)\n\n    def release(self):\n        for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n            lock.release()\n\n    def __enter__(self):\n        self.acquire()\n\n    def __exit__(self, *exc):\n        self.release()\n\n    @classmethod\n    def create_mp_lock(cls):\n        if not hasattr(cls, 'mp_lock'):\n            try:\n                from multiprocessing import RLock\n                cls.mp_lock = RLock()\n            except (ImportError, OSError):  # pragma: no cover\n                cls.mp_lock = None\n\n    @classmethod\n    def create_th_lock(cls):\n        assert hasattr(cls, 'th_lock')\n        warn(\"create_th_lock not needed anymore\", TqdmDeprecationWarning, stacklevel=2)\n\n\nclass Bar(object):\n    \"\"\"\n    `str.format`-able bar with format specifiers: `[width][type]`\n\n    - `width`\n      + unspecified (default): use `self.default_len`\n      + `int >= 0`: overrides `self.default_len`\n      + `int < 0`: subtract from `self.default_len`\n    - `type`\n      + `a`: ascii (`charset=self.ASCII` override)\n      + `u`: unicode (`charset=self.UTF` override)\n      + `b`: blank (`charset=\"  \"` override)\n    \"\"\"\n    ASCII = \" 123456789#\"\n    UTF = u\" \" + u''.join(map(chr, range(0x258F, 0x2587, -1)))\n    BLANK = \"  \"\n    COLOUR_RESET = '\\x1b[0m'\n    COLOUR_RGB = '\\x1b[38;2;%d;%d;%dm'\n    COLOURS = {'BLACK': '\\x1b[30m', 'RED': '\\x1b[31m', 'GREEN': '\\x1b[32m',\n               'YELLOW': '\\x1b[33m', 'BLUE': '\\x1b[34m', 'MAGENTA': '\\x1b[35m',\n               'CYAN': '\\x1b[36m', 'WHITE': '\\x1b[37m'}\n\n    def __init__(self, frac, default_len=10, charset=UTF, colour=None):\n        if not 0 <= frac <= 1:\n            warn(\"clamping frac to range [0, 1]\", TqdmWarning, stacklevel=2)\n            frac = max(0, min(1, frac))\n        assert default_len > 0\n        self.frac = frac\n        self.default_len = default_len\n        self.charset = charset\n        self.colour = colour\n\n    @property\n    def colour(self):\n        return self._colour\n\n    @colour.setter\n    def colour(self, value):\n        if not value:\n            self._colour = None\n            return\n        try:\n            if value.upper() in self.COLOURS:\n                self._colour = self.COLOURS[value.upper()]\n            elif value[0] == '#' and len(value) == 7:\n                self._colour = self.COLOUR_RGB % tuple(\n                    int(i, 16) for i in (value[1:3], value[3:5], value[5:7]))\n            else:\n                raise KeyError\n        except (KeyError, AttributeError):\n            warn(\"Unknown colour (%s); valid choices: [hex (#00ff00), %s]\" % (\n                 value, \", \".join(self.COLOURS)),\n                 TqdmWarning, stacklevel=2)\n            self._colour = None\n\n    def __format__(self, format_spec):\n        if format_spec:\n            _type = format_spec[-1].lower()\n            try:\n                charset = {'a': self.ASCII, 'u': self.UTF, 'b': self.BLANK}[_type]\n            except KeyError:\n                charset = self.charset\n            else:\n                format_spec = format_spec[:-1]\n            if format_spec:\n                N_BARS = int(format_spec)\n                if N_BARS < 0:\n                    N_BARS += self.default_len\n            else:\n                N_BARS = self.default_len\n        else:\n            charset = self.charset\n            N_BARS = self.default_len\n\n        nsyms = len(charset) - 1\n        bar_length, frac_bar_length = divmod(int(self.frac * N_BARS * nsyms), nsyms)\n\n        res = charset[-1] * bar_length\n        if bar_length < N_BARS:  # whitespace padding\n            res = res + charset[frac_bar_length] + charset[0] * (N_BARS - bar_length - 1)\n        return self.colour + res + self.COLOUR_RESET if self.colour else res\n\n\nclass EMA(object):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    smoothing  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields old value) to 1 (yields new value).\n    \"\"\"\n    def __init__(self, smoothing=0.3):\n        self.alpha = smoothing\n        self.last = 0\n        self.calls = 0\n\n    def __call__(self, x=None):\n        \"\"\"\n        Parameters\n        ----------\n        x  : float\n            New value to include in EMA.\n        \"\"\"\n        beta = 1 - self.alpha\n        if x is not None:\n            self.last = self.alpha * x + beta * self.last\n            self.calls += 1\n        return self.last / (1 - beta ** self.calls) if self.calls else self.last\n\n\nclass tqdm(Comparable):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int or float, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive number,\n        e.g. 9e9.\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n        If `None`, will leave only if `position` is `0`.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.  For encoding, see `write_bytes`.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int or float, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool or str, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters \" 123456789#\".\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` and `nrows` to the\n        environment (allowing for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n            '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n            percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,\n            rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n            rate_inv, rate_inv_fmt, postfix, unit_divisor,\n            remaining, remaining_s, eta.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int or float, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0]. If using float, consider specifying `{n:.3f}`\n        or similar in `bar_format`, or specifying `unit_scale`.\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    write_bytes  : bool, optional\n        Whether to write bytes. If (default: False) will write unicode.\n    lock_args  : tuple, optional\n        Passed to `refresh` for intermediate output\n        (initialisation, iterating, and updating).\n    nrows  : int, optional\n        The screen height. If specified, hides nested bars outside this\n        bound. If unspecified, attempts to use environment height.\n        The fallback is 20.\n    colour  : str, optional\n        Bar colour (e.g. 'green', '#00ff00').\n    delay  : float, optional\n        Don't display until [default: 0] seconds have elapsed.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm.gui.tqdm(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    monitor_interval = 10  # set to 0 to disable the thread\n    monitor = None\n    _instances = WeakSet()\n\n    @staticmethod\n    def format_sizeof(num, suffix='', divisor=1000):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n        divisor  : float, optional\n            Divisor between prefixes [default: 1000].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.5:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return f'{num:1.2f}{unit}{suffix}'\n                    return f'{num:2.1f}{unit}{suffix}'\n                return f'{num:3.0f}{unit}{suffix}'\n            num /= divisor\n        return f'{num:3.1f}Y{suffix}'\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        return f'{h:d}:{m:02d}:{s:02d}' if h else f'{m:02d}:{s:02d}'\n\n    @staticmethod\n    def format_num(n):\n        \"\"\"\n        Intelligent scientific notation (.3g).\n\n        Parameters\n        ----------\n        n  : int or float or Numeric\n            A Number.\n\n        Returns\n        -------\n        out  : str\n            Formatted number.\n        \"\"\"\n        f = f'{n:.3g}'.replace('e+0', 'e+').replace('e-0', 'e-')\n        n = str(n)\n        return f if len(f) < len(n) else n\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n        if fp in (sys.stderr, sys.stdout):\n            getattr(sys.stderr, 'flush', lambda: None)()\n            getattr(sys.stdout, 'flush', lambda: None)()\n\n        def fp_write(s):\n            fp.write(str(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = disp_len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it',\n                     unit_scale=False, rate=None, bar_format=None, postfix=None,\n                     unit_divisor=1000, initial=0, colour=None, **extra_kwargs):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int or float\n            Number of finished iterations.\n        total  : int or float\n            The expected total number of iterations. If meaningless (None),\n            only basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes `{bar}` to stay within this bound\n            [default: None]. If `0`, will not print any bar (only stats).\n            The fallback is `{bar:10}`.\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n            Use as {desc} in bar_format string.\n        ascii  : bool, optional or str, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            \" 123456789#\".\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be printed with an\n            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n            [default: False]. If any other non-zero number, will scale\n            `total` and `n`.\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,\n              rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, postfix, unit_divisor,\n              remaining, remaining_s, eta.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        postfix  : *, optional\n            Similar to `prefix`, but placed at the end\n            (e.g. for additional stats).\n            Note: postfix is usually a string (not a dict) for this method,\n            and will if possible be set to postfix = ', ' + postfix.\n            However other types are supported (#382).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n        initial  : int or float, optional\n            The initial counter value [default: 0].\n        colour  : str, optional\n            Bar colour (e.g. 'green', '#00ff00').\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n >= (total + 0.5):  # allow float imprecision (#849)\n            total = None\n\n        # apply custom scale if necessary\n        if unit_scale and unit_scale not in (True, 1):\n            if total:\n                total *= unit_scale\n            n *= unit_scale\n            if rate:\n                rate *= unit_scale  # by default rate = self.avg_dn / self.avg_dt\n            unit_scale = False\n\n        elapsed_str = tqdm.format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = (n - initial) / elapsed\n        inv_rate = 1 / rate if rate else None\n        format_sizeof = tqdm.format_sizeof\n        rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else f'{rate:5.2f}')\n                          if rate else '?') + unit + '/s'\n        rate_inv_fmt = (\n            (format_sizeof(inv_rate) if unit_scale else f'{inv_rate:5.2f}')\n            if inv_rate else '?') + 's/' + unit\n        rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n        if unit_scale:\n            n_fmt = format_sizeof(n, divisor=unit_divisor)\n            total_fmt = format_sizeof(total, divisor=unit_divisor) if total is not None else '?'\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total) if total is not None else '?'\n\n        try:\n            postfix = ', ' + postfix if postfix else ''\n        except TypeError:\n            pass\n\n        remaining = (total - n) / rate if rate and total else 0\n        remaining_str = tqdm.format_interval(remaining) if rate else '?'\n        try:\n            eta_dt = (datetime.now() + timedelta(seconds=remaining)\n                      if rate and total else datetime.fromtimestamp(0, timezone.utc))\n        except OverflowError:\n            eta_dt = datetime.max\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n\n        r_bar = f'| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}{postfix}]'\n\n        # Custom bar formatting\n        # Populate a dict with all available progress indicators\n        format_dict = {\n            # slight extension of self.format_dict\n            'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt,\n            'elapsed': elapsed_str, 'elapsed_s': elapsed,\n            'ncols': ncols, 'desc': prefix or '', 'unit': unit,\n            'rate': inv_rate if inv_rate and inv_rate > 1 else rate,\n            'rate_fmt': rate_fmt, 'rate_noinv': rate,\n            'rate_noinv_fmt': rate_noinv_fmt, 'rate_inv': inv_rate,\n            'rate_inv_fmt': rate_inv_fmt,\n            'postfix': postfix, 'unit_divisor': unit_divisor,\n            'colour': colour,\n            # plus more useful definitions\n            'remaining': remaining_str, 'remaining_s': remaining,\n            'l_bar': l_bar, 'r_bar': r_bar, 'eta': eta_dt,\n            **extra_kwargs}\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            l_bar += f'{percentage:3.0f}%|'\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            format_dict.update(l_bar=l_bar)\n            if bar_format:\n                format_dict.update(percentage=percentage)\n\n                # auto-remove colon for empty `{desc}`\n                if not prefix:\n                    bar_format = bar_format.replace(\"{desc}: \", '')\n            else:\n                bar_format = \"{l_bar}{bar}{r_bar}\"\n\n            full_bar = FormatReplace()\n            nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                return nobar  # no `{bar}`; nothing else to do\n\n            # Formatting progress bar space available for bar's display\n            full_bar = Bar(frac,\n                           max(1, ncols - disp_len(nobar)) if ncols else 10,\n                           charset=Bar.ASCII if ascii is True else ascii or Bar.UTF,\n                           colour=colour)\n            if not _is_ascii(full_bar.charset) and _is_ascii(bar_format):\n                bar_format = str(bar_format)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            return disp_trim(res, ncols) if ncols else res\n\n        elif bar_format:\n            # user-specified bar_format but no total\n            l_bar += '|'\n            format_dict.update(l_bar=l_bar, percentage=0)\n            full_bar = FormatReplace()\n            nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                return nobar\n            full_bar = Bar(0,\n                           max(1, ncols - disp_len(nobar)) if ncols else 10,\n                           charset=Bar.BLANK, colour=colour)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            return disp_trim(res, ncols) if ncols else res\n        else:\n            # no total: no progressbar, ETA, just progress stats\n            return (f'{(prefix + \": \") if prefix else \"\"}'\n                    f'{n_fmt}{unit} [{elapsed_str}, {rate_fmt}{postfix}]')\n\n    def __new__(cls, *_, **__):\n        instance = object.__new__(cls)\n        with cls.get_lock():  # also constructs lock if non-existent\n            cls._instances.add(instance)\n            # create monitoring thread\n            if cls.monitor_interval and (cls.monitor is None\n                                         or not cls.monitor.report()):\n                try:\n                    cls.monitor = TMonitor(cls, cls.monitor_interval)\n                except Exception as e:  # pragma: nocover\n                    warn(\"tqdm:disabling monitor support\"\n                         \" (monitor_interval = 0) due to:\\n\" + str(e),\n                         TqdmMonitorWarning, stacklevel=2)\n                    cls.monitor_interval = 0\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\"Skips specified instance.\"\"\"\n        positions = {abs(inst.pos) for inst in cls._instances\n                     if inst is not instance and hasattr(inst, \"pos\")}\n        return min(set(range(len(positions) + 1)).difference(positions))\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition another unfixed bar\n        to fill the new gap.\n\n        This means that by default (where all nested bars are unfixed),\n        order is not maintained but screen flicker/blank space is minimised.\n        (tqdm<=4.44.1 moved ALL subsequent unfixed bars up.)\n        \"\"\"\n        with cls._lock:\n            try:\n                cls._instances.remove(instance)\n            except KeyError:\n                # if not instance.gui:  # pragma: no cover\n                #     raise\n                pass  # py2: maybe magically removed already\n            # else:\n            if not instance.gui:\n                last = (instance.nrows or 20) - 1\n                # find unfixed (`pos >= 0`) overflow (`pos >= nrows - 1`)\n                instances = list(filter(\n                    lambda i: hasattr(i, \"pos\") and last <= i.pos,\n                    cls._instances))\n                # set first found to current `pos`\n                if instances:\n                    inst = min(instances, key=lambda i: i.pos)\n                    inst.clear(nolock=True)\n                    inst.pos = abs(instance.pos)\n\n    @classmethod\n    def write(cls, s, file=None, end=\"\\n\", nolock=False):\n        \"\"\"Print a message via tqdm (without overlap with bars).\"\"\"\n        fp = file if file is not None else sys.stdout\n        with cls.external_write_mode(file=file, nolock=nolock):\n            # Write the message\n            fp.write(s)\n            fp.write(end)\n\n    @classmethod\n    @contextmanager\n    def external_write_mode(cls, file=None, nolock=False):\n        \"\"\"\n        Disable tqdm within context and refresh tqdm when exits.\n        Useful when writing to standard output stream\n        \"\"\"\n        fp = file if file is not None else sys.stdout\n\n        try:\n            if not nolock:\n                cls.get_lock().acquire()\n            # Clear all bars\n            inst_cleared = []\n            for inst in getattr(cls, '_instances', []):\n                # Clear instance if in the target output file\n                # or if write output + tqdm output are both either\n                # sys.stdout or sys.stderr (because both are mixed in terminal)\n                if hasattr(inst, \"start_t\") and (inst.fp == fp or all(\n                        f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n                    inst.clear(nolock=True)\n                    inst_cleared.append(inst)\n            yield\n            # Force refresh display of bars we cleared\n            for inst in inst_cleared:\n                inst.refresh(nolock=True)\n        finally:\n            if not nolock:\n                cls._lock.release()\n\n    @classmethod\n    def set_lock(cls, lock):\n        \"\"\"Set the global lock.\"\"\"\n        cls._lock = lock\n\n    @classmethod\n    def get_lock(cls):\n        \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n        if not hasattr(cls, '_lock'):\n            cls._lock = TqdmDefaultWriteLock()\n        return cls._lock\n\n    @classmethod\n    def pandas(cls, **tqdm_kwargs):\n        \"\"\"\n        Registers the current `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.(generic.)DataFrameGroupBy\n            | groupby.(generic.)SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be created every time `progress_apply` is called,\n        and each instance will automatically `close()` upon completion.\n\n        Parameters\n        ----------\n        tqdm_kwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm\n        >>> from tqdm.gui import tqdm as tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        <https://stackoverflow.com/questions/18603270/\\\n        progress-indicator-during-pandas-operations-python>\n        \"\"\"\n        from warnings import catch_warnings, simplefilter\n\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        try:\n            with catch_warnings():\n                simplefilter(\"ignore\", category=FutureWarning)\n                from pandas import Panel\n        except ImportError:  # pandas>=1.2.0\n            Panel = None\n        Rolling, Expanding = None, None\n        try:  # pandas>=1.0.0\n            from pandas.core.window.rolling import _Rolling_and_Expanding\n        except ImportError:\n            try:  # pandas>=0.18.0\n                from pandas.core.window import _Rolling_and_Expanding\n            except ImportError:  # pandas>=1.2.0\n                try:  # pandas>=1.2.0\n                    from pandas.core.window.expanding import Expanding\n                    from pandas.core.window.rolling import Rolling\n                    _Rolling_and_Expanding = Rolling, Expanding\n                except ImportError:  # pragma: no cover\n                    _Rolling_and_Expanding = None\n        try:  # pandas>=0.25.0\n            from pandas.core.groupby.generic import SeriesGroupBy  # , NDFrameGroupBy\n            from pandas.core.groupby.generic import DataFrameGroupBy\n        except ImportError:  # pragma: no cover\n            try:  # pandas>=0.23.0\n                from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy\n            except ImportError:\n                from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import GroupBy\n        except ImportError:  # pragma: no cover\n            from pandas.core.groupby import GroupBy\n\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import PanelGroupBy\n        except ImportError:\n            try:\n                from pandas.core.groupby import PanelGroupBy\n            except ImportError:  # pandas>=0.25.0\n                PanelGroupBy = None\n\n        tqdm_kwargs = tqdm_kwargs.copy()\n        deprecated_t = [tqdm_kwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                **kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n\n                # Precompute total iterations\n                total = tqdm_kwargs.pop(\"total\", getattr(df, 'ngroups', None))\n                if total is None:  # not grouped\n                    if df_function == 'applymap':\n                        total = df.size\n                    elif isinstance(df, Series):\n                        total = len(df)\n                    elif (_Rolling_and_Expanding is None or\n                          not isinstance(df, _Rolling_and_Expanding)):\n                        # DataFrame or Panel\n                        axis = kwargs.get('axis', 0)\n                        if axis == 'index':\n                            axis = 0\n                        elif axis == 'columns':\n                            axis = 1\n                        # when axis=0, total is shape[axis1]\n                        total = df.size // df.shape[axis]\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = cls(total=total, **tqdm_kwargs)\n\n                if len(args) > 0:\n                    # *args intentionally not supported (see #244, #299)\n                    TqdmDeprecationWarning(\n                        \"Except func, normal arguments are intentionally\" +\n                        \" not supported by\" +\n                        \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                        \" Use keyword arguments instead.\",\n                        fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n                try:  # pandas>=1.3.0\n                    from pandas.core.common import is_builtin_func\n                except ImportError:\n                    is_builtin_func = df._is_builtin_func\n                try:\n                    func = is_builtin_func(func)\n                except TypeError:\n                    pass\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    # update tbar correctly\n                    # it seems `pandas apply` calls `func` twice\n                    # on the first column/row to decide whether it can\n                    # take a fast or slow code path; so stop when t.total==t.n\n                    t.update(n=1 if not t.total or t.n < t.total else 0)\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                try:\n                    return getattr(df, df_function)(wrapper, **kwargs)\n                finally:\n                    t.close()\n\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n        DataFrame.progress_map = inner_generator('map')\n        DataFrameGroupBy.progress_map = inner_generator('map')\n\n        if Panel is not None:\n            Panel.progress_apply = inner_generator()\n        if PanelGroupBy is not None:\n            PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n        if Rolling is not None and Expanding is not None:\n            Rolling.progress_apply = inner_generator()\n            Expanding.progress_apply = inner_generator()\n        elif _Rolling_and_Expanding is not None:\n            _Rolling_and_Expanding.progress_apply = inner_generator()\n\n    # override defaults via env vars\n    @envwrap(\"TQDM_\", is_method=True, types={'total': float, 'ncols': int, 'miniters': float,\n                                             'position': int, 'nrows': int})\n    def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None,\n                 ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None,\n                 ascii=None, disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0,\n                 position=None, postfix=None, unit_divisor=1000, write_bytes=False,\n                 lock_args=None, nrows=None, colour=None, delay=0.0, gui=False,\n                 **kwargs):\n        \"\"\"see tqdm.tqdm for arguments\"\"\"\n        if file is None:\n            file = sys.stderr\n\n        if write_bytes:\n            # Despite coercing unicode into bytes, py2 sys.std* streams\n            # should have bytes written to them.\n            file = SimpleTextIOWrapper(\n                file, encoding=getattr(file, 'encoding', None) or 'utf-8')\n\n        file = DisableOnWriteError(file, tqdm_instance=self)\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n        if total == float(\"inf\"):\n            # Infinite iterations, behave same as unknown\n            total = None\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            self.n = initial\n            self.total = total\n            self.leave = leave\n            return\n\n        if kwargs:\n            self.disable = True\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            raise (\n                TqdmDeprecationWarning(\n                    \"`nested` is deprecated and automated.\\n\"\n                    \"Use `position` instead for manual control.\\n\",\n                    fp_write=getattr(file, 'write', sys.stderr.write))\n                if \"nested\" in kwargs else\n                TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if (\n            (ncols is None or nrows is None) and (file in (sys.stderr, sys.stdout))\n        ) or dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _screen_shape_wrapper()\n                if dynamic_ncols:\n                    ncols, nrows = dynamic_ncols(file)\n            else:\n                _dynamic_ncols = _screen_shape_wrapper()\n                if _dynamic_ncols:\n                    _ncols, _nrows = _dynamic_ncols(file)\n                    if ncols is None:\n                        ncols = _ncols\n                    if nrows is None:\n                        nrows = _nrows\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and ascii is not True and not _is_ascii(ascii):\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = str(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.nrows = nrows\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.initial = initial\n        self.lock_args = lock_args\n        self.delay = delay\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self._ema_dn = EMA(smoothing)\n        self._ema_dt = EMA(smoothing)\n        self._ema_miniters = EMA(smoothing)\n        self.bar_format = bar_format\n        self.postfix = None\n        self.colour = colour\n        self._time = time\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        with self._lock:\n            # mark fixed positions as negative\n            self.pos = self._get_free_pos(self) if position is None else -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if delay <= 0:\n                self.refresh(lock_args=self.lock_args)\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __bool__(self):\n        if self.total is not None:\n            return self.total > 0\n        if self.iterable is None:\n            raise TypeError('bool() undefined when iterable == total == None')\n        return bool(self.iterable)\n\n    def __len__(self):\n        return (\n            self.total if self.iterable is None\n            else self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n            else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n            else self.iterable.__length_hint__() if hasattr(self.iterable, \"__length_hint__\")\n            else getattr(self, \"total\", None))\n\n    def __reversed__(self):\n        try:\n            orig = self.iterable\n        except AttributeError:\n            raise TypeError(\"'tqdm' object is not reversible\")\n        else:\n            self.iterable = reversed(self.iterable)\n            return self.__iter__()\n        finally:\n            self.iterable = orig\n\n    def __contains__(self, item):\n        contains = getattr(self.iterable, '__contains__', None)\n        return contains(item) if contains is not None else item in self.__iter__()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        try:\n            self.close()\n        except AttributeError:\n            # maybe eager thread cleanup upon external error\n            if (exc_type, exc_value, traceback) == (None, None, None):\n                raise\n            warn(\"AttributeError ignored\", TqdmWarning, stacklevel=2)\n\n    def __del__(self):\n        self.close()\n\n    def __str__(self):\n        return self.format_meter(**self.format_dict)\n\n    @property\n    def _comparable(self):\n        return abs(getattr(self, \"pos\", 1 << 31))\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n            return\n\n        mininterval = self.mininterval\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        min_start_t = self.start_t + self.delay\n        n = self.n\n        time = self._time\n\n        try:\n            for obj in iterable:\n                yield obj\n                # Update and possibly print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n\n                if n - last_print_n >= self.miniters:\n                    cur_t = time()\n                    dt = cur_t - last_print_t\n                    if dt >= mininterval and cur_t >= min_start_t:\n                        self.update(n - last_print_n)\n                        last_print_n = self.last_print_n\n                        last_print_t = self.last_print_t\n        finally:\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int or float, optional\n            Increment to add to the internal counter of iterations\n            [default: 1]. If using float, consider specifying `{n:.3f}`\n            or similar in `bar_format`, or specifying `unit_scale`.\n\n        Returns\n        -------\n        out  : bool or None\n            True if a `display()` was triggered.\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            self.last_print_n += n  # for auto-refresh logic to work\n        self.n += n\n\n        # check counter first to reduce calls to time()\n        if self.n - self.last_print_n >= self.miniters:\n            cur_t = self._time()\n            dt = cur_t - self.last_print_t\n            if dt >= self.mininterval and cur_t >= self.start_t + self.delay:\n                cur_t = self._time()\n                dn = self.n - self.last_print_n  # >= n\n                if self.smoothing and dt and dn:\n                    # EMA (not just overall average)\n                    self._ema_dn(dn)\n                    self._ema_dt(dt)\n                self.refresh(lock_args=self.lock_args)\n                if self.dynamic_miniters:\n                    # If no `miniters` was specified, adjust automatically to the\n                    # maximum iteration rate seen so far between two prints.\n                    # e.g.: After running `tqdm.update(5)`, subsequent\n                    # calls to `tqdm.update()` will only cause an update after\n                    # at least 5 more iterations.\n                    if self.maxinterval and dt >= self.maxinterval:\n                        self.miniters = dn * (self.mininterval or self.maxinterval) / dt\n                    elif self.smoothing:\n                        # EMA miniters update\n                        self.miniters = self._ema_miniters(\n                            dn * (self.mininterval / dt if self.mininterval and dt\n                                  else 1))\n                    else:\n                        # max iters between two prints\n                        self.miniters = max(self.miniters, dn)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n                return True\n\n    def close(self):\n        \"\"\"Cleanup and (if leave=False) close the progressbar.\"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = abs(self.pos)\n        self._decr_instances(self)\n\n        if self.last_print_t < self.start_t + self.delay:\n            # haven't ever displayed; nothing to clear\n            return\n\n        # GUI mode\n        if getattr(self, 'sp', None) is None:\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(str(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        leave = pos == 0 if self.leave is None else self.leave\n\n        with self._lock:\n            if leave:\n                # stats for overall rate (no weighted average)\n                self._ema_dt = lambda: None\n                self.display(pos=0)\n                fp_write('\\n')\n            else:\n                # clear previous display\n                if self.display(msg='', pos=pos) and not pos:\n                    fp_write('\\r')\n\n    def clear(self, nolock=False):\n        \"\"\"Clear current bar display.\"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            self._lock.acquire()\n        pos = abs(self.pos)\n        if pos < (self.nrows or 20):\n            self.moveto(pos)\n            self.sp('')\n            self.fp.write('\\r')  # place cursor back at the beginning of line\n            self.moveto(-pos)\n        if not nolock:\n            self._lock.release()\n\n    def refresh(self, nolock=False, lock_args=None):\n        \"\"\"\n        Force refresh the display of this bar.\n\n        Parameters\n        ----------\n        nolock  : bool, optional\n            If `True`, does not lock.\n            If [default: `False`]: calls `acquire()` on internal lock.\n        lock_args  : tuple, optional\n            Passed to internal lock's `acquire()`.\n            If specified, will only `display()` if `acquire()` returns `True`.\n        \"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            if lock_args:\n                if not self._lock.acquire(*lock_args):\n                    return False\n            else:\n                self._lock.acquire()\n        self.display()\n        if not nolock:\n            self._lock.release()\n        return True\n\n    def unpause(self):\n        \"\"\"Restart tqdm timer from last print time.\"\"\"\n        if self.disable:\n            return\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Consider combining with `leave=True`.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        self.n = 0\n        if total is not None:\n            self.total = total\n        if self.disable:\n            return\n        self.last_print_n = 0\n        self.last_print_t = self.start_t = self._time()\n        self._ema_dn = EMA(self.smoothing)\n        self._ema_dt = EMA(self.smoothing)\n        self._ema_miniters = EMA(self.smoothing)\n        self.refresh()\n\n    def set_description(self, desc=None, refresh=True):\n        \"\"\"\n        Set/modify description of the progress bar.\n\n        Parameters\n        ----------\n        desc  : str, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n        if refresh:\n            self.refresh()\n\n    def set_description_str(self, desc=None, refresh=True):\n        \"\"\"Set/modify description without ': ' appended.\"\"\"\n        self.desc = desc or ''\n        if refresh:\n            self.refresh()\n\n    def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n        \"\"\"\n        Set/modify postfix (additional stats)\n        with automatic formatting based on datatype.\n\n        Parameters\n        ----------\n        ordered_dict  : dict or OrderedDict, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        kwargs  : dict, optional\n        \"\"\"\n        # Sort in alphabetical order to be more deterministic\n        postfix = OrderedDict([] if ordered_dict is None else ordered_dict)\n        for key in sorted(kwargs.keys()):\n            postfix[key] = kwargs[key]\n        # Preprocess stats according to datatype\n        for key in postfix.keys():\n            # Number: limit the length of the string\n            if isinstance(postfix[key], Number):\n                postfix[key] = self.format_num(postfix[key])\n            # Else for any other type, try to get the string conversion\n            elif not isinstance(postfix[key], str):\n                postfix[key] = str(postfix[key])\n            # Else if it's a string, don't need to preprocess anything\n        # Stitch together to get the final postfix\n        self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                                 for key in postfix.keys())\n        if refresh:\n            self.refresh()\n\n    def set_postfix_str(self, s='', refresh=True):\n        \"\"\"\n        Postfix without dictionary expansion, similar to prefix handling.\n        \"\"\"\n        self.postfix = str(s)\n        if refresh:\n            self.refresh()\n\n    def moveto(self, n):\n        # TODO: private method\n        self.fp.write('\\n' * n + _term_move_up() * -n)\n        getattr(self.fp, 'flush', lambda: None)()\n\n    @property\n    def format_dict(self):\n        \"\"\"Public API for read-only member access.\"\"\"\n        if self.disable and not hasattr(self, 'unit'):\n            return defaultdict(lambda: None, {\n                'n': self.n, 'total': self.total, 'elapsed': 0, 'unit': 'it'})\n        if self.dynamic_ncols:\n            self.ncols, self.nrows = self.dynamic_ncols(self.fp)\n        return {\n            'n': self.n, 'total': self.total,\n            'elapsed': self._time() - self.start_t if hasattr(self, 'start_t') else 0,\n            'ncols': self.ncols, 'nrows': self.nrows, 'prefix': self.desc,\n            'ascii': self.ascii, 'unit': self.unit, 'unit_scale': self.unit_scale,\n            'rate': self._ema_dn() / self._ema_dt() if self._ema_dt() else None,\n            'bar_format': self.bar_format, 'postfix': self.postfix,\n            'unit_divisor': self.unit_divisor, 'initial': self.initial,\n            'colour': self.colour}\n\n    def display(self, msg=None, pos=None):\n        \"\"\"\n        Use `self.sp` to display `msg` in the specified `pos`.\n\n        Consider overloading this function when inheriting to use e.g.:\n        `self.some_frontend(**self.format_dict)` instead of `self.sp`.\n\n        Parameters\n        ----------\n        msg  : str, optional. What to display (default: `repr(self)`).\n        pos  : int, optional. Position to `moveto`\n          (default: `abs(self.pos)`).\n        \"\"\"\n        if pos is None:\n            pos = abs(self.pos)\n\n        nrows = self.nrows or 20\n        if pos >= nrows - 1:\n            if pos >= nrows:\n                return False\n            if msg or msg is None:  # override at `nrows - 1`\n                msg = \" ... (more hidden) ...\"\n\n        if not hasattr(self, \"sp\"):\n            raise TqdmDeprecationWarning(\n                \"Please use `tqdm.gui.tqdm(...)`\"\n                \" instead of `tqdm(..., gui=True)`\\n\",\n                fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n        if pos:\n            self.moveto(pos)\n        self.sp(self.__str__() if msg is None else msg)\n        if pos:\n            self.moveto(-pos)\n        return True\n\n    @classmethod\n    @contextmanager\n    def wrapattr(cls, stream, method, total=None, bytes=True, **tqdm_kwargs):\n        \"\"\"\n        stream  : file-like object.\n        method  : str, \"read\" or \"write\". The result of `read()` and\n            the first argument of `write()` should have a `len()`.\n\n        >>> with tqdm.wrapattr(file_obj, \"read\", total=file_obj.size) as fobj:\n        ...     while True:\n        ...         chunk = fobj.read(chunk_size)\n        ...         if not chunk:\n        ...             break\n        \"\"\"\n        with cls(total=total, **tqdm_kwargs) as t:\n            if bytes:\n                t.unit = \"B\"\n                t.unit_scale = True\n                t.unit_divisor = 1024\n            yield CallbackIOWrapper(t.update, stream, method)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"Shortcut for tqdm(range(*args), **kwargs).\"\"\"\n    return tqdm(range(*args), **kwargs)\n", "tqdm/_tqdm.py": "from warnings import warn\n\nfrom .std import *  # NOQA\nfrom .std import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.std.*` instead of `tqdm._tqdm.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/notebook.py": "\"\"\"\nIPython/Jupyter Notebook progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm.notebook import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\n# import compatibility functions and utilities\nimport re\nimport sys\nfrom html import escape\nfrom weakref import proxy\n\n# to inherit from the tqdm class\nfrom .std import tqdm as std_tqdm\n\nif True:  # pragma: no cover\n    # import IPython/Jupyter base widget and display utilities\n    IPY = 0\n    try:  # IPython 4.x\n        import ipywidgets\n        IPY = 4\n    except ImportError:  # IPython 3.x / 2.x\n        IPY = 32\n        import warnings\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                'ignore', message=\".*The `IPython.html` package has been deprecated.*\")\n            try:\n                import IPython.html.widgets as ipywidgets  # NOQA: F401\n            except ImportError:\n                pass\n\n    try:  # IPython 4.x / 3.x\n        if IPY == 32:\n            from IPython.html.widgets import HTML\n            from IPython.html.widgets import FloatProgress as IProgress\n            from IPython.html.widgets import HBox\n            IPY = 3\n        else:\n            from ipywidgets import HTML\n            from ipywidgets import FloatProgress as IProgress\n            from ipywidgets import HBox\n    except ImportError:\n        try:  # IPython 2.x\n            from IPython.html.widgets import HTML\n            from IPython.html.widgets import ContainerWidget as HBox\n            from IPython.html.widgets import FloatProgressWidget as IProgress\n            IPY = 2\n        except ImportError:\n            IPY = 0\n            IProgress = None\n            HBox = object\n\n    try:\n        from IPython.display import display  # , clear_output\n    except ImportError:\n        pass\n\n__author__ = {\"github.com/\": [\"lrq3000\", \"casperdcl\", \"alexanderkuk\"]}\n__all__ = ['tqdm_notebook', 'tnrange', 'tqdm', 'trange']\nWARN_NOIPYW = (\"IProgress not found. Please update jupyter and ipywidgets.\"\n               \" See https://ipywidgets.readthedocs.io/en/stable\"\n               \"/user_install.html\")\n\n\nclass TqdmHBox(HBox):\n    \"\"\"`ipywidgets.HBox` with a pretty representation\"\"\"\n    def _json_(self, pretty=None):\n        pbar = getattr(self, 'pbar', None)\n        if pbar is None:\n            return {}\n        d = pbar.format_dict\n        if pretty is not None:\n            d[\"ascii\"] = not pretty\n        return d\n\n    def __repr__(self, pretty=False):\n        pbar = getattr(self, 'pbar', None)\n        if pbar is None:\n            return super().__repr__()\n        return pbar.format_meter(**self._json_(pretty))\n\n    def _repr_pretty_(self, pp, *_, **__):\n        pp.text(self.__repr__(True))\n\n\nclass tqdm_notebook(std_tqdm):\n    \"\"\"\n    Experimental IPython/Jupyter Notebook widget using tqdm!\n    \"\"\"\n    @staticmethod\n    def status_printer(_, total=None, desc=None, ncols=None):\n        \"\"\"\n        Manage the printing of an IPython/Jupyter Notebook progress bar widget.\n        \"\"\"\n        # Fallback to text bar if there's no total\n        # DEPRECATED: replaced with an 'info' style bar\n        # if not total:\n        #    return super(tqdm_notebook, tqdm_notebook).status_printer(file)\n\n        # fp = file\n\n        # Prepare IPython progress bar\n        if IProgress is None:  # #187 #451 #558 #872\n            raise ImportError(WARN_NOIPYW)\n        if total:\n            pbar = IProgress(min=0, max=total)\n        else:  # No total? Show info style bar with no progress tqdm status\n            pbar = IProgress(min=0, max=1)\n            pbar.value = 1\n            pbar.bar_style = 'info'\n            if ncols is None:\n                pbar.layout.width = \"20px\"\n\n        ltext = HTML()\n        rtext = HTML()\n        if desc:\n            ltext.value = desc\n        container = TqdmHBox(children=[ltext, pbar, rtext])\n        # Prepare layout\n        if ncols is not None:  # use default style of ipywidgets\n            # ncols could be 100, \"100px\", \"100%\"\n            ncols = str(ncols)  # ipywidgets only accepts string\n            try:\n                if int(ncols) > 0:  # isnumeric and positive\n                    ncols += 'px'\n            except ValueError:\n                pass\n            pbar.layout.flex = '2'\n            container.layout.width = ncols\n            container.layout.display = 'inline-flex'\n            container.layout.flex_flow = 'row wrap'\n\n        return container\n\n    def display(self, msg=None, pos=None,\n                # additional signals\n                close=False, bar_style=None, check_delay=True):\n        # Note: contrary to native tqdm, msg='' does NOT clear bar\n        # goal is to keep all infos if error happens so user knows\n        # at which iteration the loop failed.\n\n        # Clear previous output (really necessary?)\n        # clear_output(wait=1)\n\n        if not msg and not close:\n            d = self.format_dict\n            # remove {bar}\n            d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n                \"{bar}\", \"<bar/>\")\n            msg = self.format_meter(**d)\n\n        ltext, pbar, rtext = self.container.children\n        pbar.value = self.n\n\n        if msg:\n            msg = msg.replace(' ', u'\\u2007')  # fix html space padding\n            # html escape special characters (like '&')\n            if '<bar/>' in msg:\n                left, right = map(escape, re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n            else:\n                left, right = '', escape(msg)\n\n            # Update description\n            ltext.value = left\n            # never clear the bar (signal: msg='')\n            if right:\n                rtext.value = right\n\n        # Change bar style\n        if bar_style:\n            # Hack-ish way to avoid the danger bar_style being overridden by\n            # success because the bar gets closed after the error...\n            if pbar.bar_style != 'danger' or bar_style != 'success':\n                pbar.bar_style = bar_style\n\n        # Special signal to close the bar\n        if close and pbar.bar_style != 'danger':  # hide only if no error\n            try:\n                self.container.close()\n            except AttributeError:\n                self.container.visible = False\n            self.container.layout.visibility = 'hidden'  # IPYW>=8\n\n        if check_delay and self.delay > 0 and not self.displayed:\n            display(self.container)\n            self.displayed = True\n\n    @property\n    def colour(self):\n        if hasattr(self, 'container'):\n            return self.container.children[-2].style.bar_color\n\n    @colour.setter\n    def colour(self, bar_color):\n        if hasattr(self, 'container'):\n            self.container.children[-2].style.bar_color = bar_color\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Supports the usual `tqdm.tqdm` parameters as well as those listed below.\n\n        Parameters\n        ----------\n        display  : Whether to call `display(self.container)` immediately\n            [default: True].\n        \"\"\"\n        kwargs = kwargs.copy()\n        # Setup default output\n        file_kwarg = kwargs.get('file', sys.stderr)\n        if file_kwarg is sys.stderr or file_kwarg is None:\n            kwargs['file'] = sys.stdout  # avoid the red block in IPython\n\n        # Initialize parent class + avoid printing by using gui=True\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        colour = kwargs.pop('colour', None)\n        display_here = kwargs.pop('display', True)\n        super().__init__(*args, **kwargs)\n        if self.disable or not kwargs['gui']:\n            self.disp = lambda *_, **__: None\n            return\n\n        # Get bar width\n        self.ncols = '100%' if self.dynamic_ncols else kwargs.get(\"ncols\", None)\n\n        # Replace with IPython progress bar display (with correct total)\n        unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1\n        total = self.total * unit_scale if self.total else self.total\n        self.container = self.status_printer(self.fp, total, self.desc, self.ncols)\n        self.container.pbar = proxy(self)\n        self.displayed = False\n        if display_here and self.delay <= 0:\n            display(self.container)\n            self.displayed = True\n        self.disp = self.display\n        self.colour = colour\n\n        # Print initial bar state\n        if not self.disable:\n            self.display(check_delay=False)\n\n    def __iter__(self):\n        try:\n            it = super().__iter__()\n            for obj in it:\n                # return super(tqdm...) will not catch exception\n                yield obj\n        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt\n        except:  # NOQA\n            self.disp(bar_style='danger')\n            raise\n        # NB: don't `finally: close()`\n        # since this could be a shared bar which the user will `reset()`\n\n    def update(self, n=1):\n        try:\n            return super().update(n=n)\n        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt\n        except:  # NOQA\n            # cannot catch KeyboardInterrupt when using manual tqdm\n            # as the interrupt will most likely happen on another statement\n            self.disp(bar_style='danger')\n            raise\n        # NB: don't `finally: close()`\n        # since this could be a shared bar which the user will `reset()`\n\n    def close(self):\n        if self.disable:\n            return\n        super().close()\n        # Try to detect if there was an error or KeyboardInterrupt\n        # in manual mode: if n < total, things probably got wrong\n        if self.total and self.n < self.total:\n            self.disp(bar_style='danger', check_delay=False)\n        else:\n            if self.leave:\n                self.disp(bar_style='success', check_delay=False)\n            else:\n                self.disp(close=True, check_delay=False)\n\n    def clear(self, *_, **__):\n        pass\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Consider combining with `leave=True`.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if self.disable:\n            return super().reset(total=total)\n        _, pbar, _ = self.container.children\n        pbar.bar_style = ''\n        if total is not None:\n            pbar.max = total\n            if not self.total and self.ncols is None:  # no longer unknown total\n                pbar.layout.width = None  # reset width\n        return super().reset(total=total)\n\n\ndef tnrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_notebook(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_notebook\ntrange = tnrange\n", "tqdm/_tqdm_pandas.py": "import sys\n\n__author__ = \"github.com/casperdcl\"\n__all__ = ['tqdm_pandas']\n\n\ndef tqdm_pandas(tclass, **tqdm_kwargs):\n    \"\"\"\n    Registers the given `tqdm` instance with\n    `pandas.core.groupby.DataFrameGroupBy.progress_apply`.\n    \"\"\"\n    from tqdm import TqdmDeprecationWarning\n\n    if isinstance(tclass, type) or (getattr(tclass, '__name__', '').startswith(\n            'tqdm_')):  # delayed adapter case\n        TqdmDeprecationWarning(\n            \"Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm, ...)`.\",\n            fp_write=getattr(tqdm_kwargs.get('file', None), 'write', sys.stderr.write))\n        tclass.pandas(**tqdm_kwargs)\n    else:\n        TqdmDeprecationWarning(\n            \"Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm(...))`.\",\n            fp_write=getattr(tclass.fp, 'write', sys.stderr.write))\n        type(tclass).pandas(deprecated_t=tclass)\n", "tqdm/contrib/logging.py": "\"\"\"\nHelper functionality for interoperability with stdlib `logging`.\n\"\"\"\nimport logging\nimport sys\nfrom contextlib import contextmanager\n\ntry:\n    from typing import Iterator, List, Optional, Type  # noqa: F401\nexcept ImportError:\n    pass\n\nfrom ..std import tqdm as std_tqdm\n\n\nclass _TqdmLoggingHandler(logging.StreamHandler):\n    def __init__(\n        self,\n        tqdm_class=std_tqdm  # type: Type[std_tqdm]\n    ):\n        super().__init__()\n        self.tqdm_class = tqdm_class\n\n    def emit(self, record):\n        try:\n            msg = self.format(record)\n            self.tqdm_class.write(msg, file=self.stream)\n            self.flush()\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except:  # noqa pylint: disable=bare-except\n            self.handleError(record)\n\n\ndef _is_console_logging_handler(handler):\n    return (isinstance(handler, logging.StreamHandler)\n            and handler.stream in {sys.stdout, sys.stderr})\n\n\ndef _get_first_found_console_logging_handler(handlers):\n    for handler in handlers:\n        if _is_console_logging_handler(handler):\n            return handler\n\n\n@contextmanager\ndef logging_redirect_tqdm(\n    loggers=None,  # type: Optional[List[logging.Logger]],\n    tqdm_class=std_tqdm  # type: Type[std_tqdm]\n):\n    # type: (...) -> Iterator[None]\n    \"\"\"\n    Context manager redirecting console logging to `tqdm.write()`, leaving\n    other logging handlers (e.g. log files) unaffected.\n\n    Parameters\n    ----------\n    loggers  : list, optional\n      Which handlers to redirect (default: [logging.root]).\n    tqdm_class  : optional\n\n    Example\n    -------\n    ```python\n    import logging\n    from tqdm import trange\n    from tqdm.contrib.logging import logging_redirect_tqdm\n\n    LOG = logging.getLogger(__name__)\n\n    if __name__ == '__main__':\n        logging.basicConfig(level=logging.INFO)\n        with logging_redirect_tqdm():\n            for i in trange(9):\n                if i == 4:\n                    LOG.info(\"console logging redirected to `tqdm.write()`\")\n        # logging restored\n    ```\n    \"\"\"\n    if loggers is None:\n        loggers = [logging.root]\n    original_handlers_list = [logger.handlers for logger in loggers]\n    try:\n        for logger in loggers:\n            tqdm_handler = _TqdmLoggingHandler(tqdm_class)\n            orig_handler = _get_first_found_console_logging_handler(logger.handlers)\n            if orig_handler is not None:\n                tqdm_handler.setFormatter(orig_handler.formatter)\n                tqdm_handler.stream = orig_handler.stream\n            logger.handlers = [\n                handler for handler in logger.handlers\n                if not _is_console_logging_handler(handler)] + [tqdm_handler]\n        yield\n    finally:\n        for logger, original_handlers in zip(loggers, original_handlers_list):\n            logger.handlers = original_handlers\n\n\n@contextmanager\ndef tqdm_logging_redirect(\n    *args,\n    # loggers=None,  # type: Optional[List[logging.Logger]]\n    # tqdm=None,  # type: Optional[Type[tqdm.tqdm]]\n    **kwargs\n):\n    # type: (...) -> Iterator[None]\n    \"\"\"\n    Convenience shortcut for:\n    ```python\n    with tqdm_class(*args, **tqdm_kwargs) as pbar:\n        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):\n            yield pbar\n    ```\n\n    Parameters\n    ----------\n    tqdm_class  : optional, (default: tqdm.std.tqdm).\n    loggers  : optional, list.\n    **tqdm_kwargs  : passed to `tqdm_class`.\n    \"\"\"\n    tqdm_kwargs = kwargs.copy()\n    loggers = tqdm_kwargs.pop('loggers', None)\n    tqdm_class = tqdm_kwargs.pop('tqdm_class', std_tqdm)\n    with tqdm_class(*args, **tqdm_kwargs) as pbar:\n        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):\n            yield pbar\n", "tqdm/contrib/slack.py": "\"\"\"\nSends updates to a Slack app.\n\nUsage:\n>>> from tqdm.contrib.slack import tqdm, trange\n>>> for i in trange(10, token='{token}', channel='{channel}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-slack.png)\n\"\"\"\nimport logging\nfrom os import getenv\n\ntry:\n    from slack_sdk import WebClient\nexcept ImportError:\n    raise ImportError(\"Please `pip install slack-sdk`\")\n\nfrom ..auto import tqdm as tqdm_auto\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"0x2b3bfa0\", \"casperdcl\"]}\n__all__ = ['SlackIO', 'tqdm_slack', 'tsrange', 'tqdm', 'trange']\n\n\nclass SlackIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Slack app.\"\"\"\n    def __init__(self, token, channel):\n        \"\"\"Creates a new message in the given `channel`.\"\"\"\n        super().__init__()\n        self.client = WebClient(token=token)\n        self.text = self.__class__.__name__\n        try:\n            self.message = self.client.chat_postMessage(channel=channel, text=self.text)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n            self.message = None\n\n    def write(self, s):\n        \"\"\"Replaces internal `message`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # skip duplicate message\n        message = self.message\n        if message is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(self.client.chat_update, channel=message['channel'],\n                                 ts=message['ts'], text='`' + s + '`')\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_slack(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Slack app.\n    May take a few seconds to create (`__init__`).\n\n    - create a Slack app with the `chat:write` scope & invite it to a\n      channel: <https://api.slack.com/authentication/basics>\n    - copy the bot `{token}` & `{channel}` and paste below\n    >>> from tqdm.contrib.slack import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', channel='{channel}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Slack token\n            [default: ${TQDM_SLACK_TOKEN}].\n        channel  : int, required. Slack channel\n            [default: ${TQDM_SLACK_CHANNEL}].\n        mininterval  : float, optional.\n          Minimum of [default: 1.5] to avoid rate limit.\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            logging.getLogger(\"HTTPClient\").setLevel(logging.WARNING)\n            self.sio = SlackIO(\n                kwargs.pop('token', getenv(\"TQDM_SLACK_TOKEN\")),\n                kwargs.pop('channel', getenv(\"TQDM_SLACK_CHANNEL\")))\n            kwargs['mininterval'] = max(1.5, kwargs.get('mininterval', 1.5))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '`{bar:10}`').replace('{bar}', '`{bar:10u}`')\n        else:\n            fmt['bar_format'] = '{l_bar}`{bar:10}`{r_bar}'\n        if fmt['ascii'] is False:\n            fmt['ascii'] = [\":black_square:\", \":small_blue_diamond:\", \":large_blue_diamond:\",\n                            \":large_blue_square:\"]\n            fmt['ncols'] = 336\n        self.sio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.sio.write(\"\")\n\n\ndef tsrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.slack.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_slack(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_slack\ntrange = tsrange\n", "tqdm/contrib/bells.py": "\"\"\"\nEven more features than `tqdm.auto` (all the bells & whistles):\n\n- `tqdm.auto`\n- `tqdm.tqdm.pandas`\n- `tqdm.contrib.telegram`\n    + uses `${TQDM_TELEGRAM_TOKEN}` and `${TQDM_TELEGRAM_CHAT_ID}`\n- `tqdm.contrib.discord`\n    + uses `${TQDM_DISCORD_TOKEN}` and `${TQDM_DISCORD_CHANNEL_ID}`\n\"\"\"\n__all__ = ['tqdm', 'trange']\nimport warnings\nfrom os import getenv\n\nif getenv(\"TQDM_SLACK_TOKEN\") and getenv(\"TQDM_SLACK_CHANNEL\"):\n    from .slack import tqdm, trange\nelif getenv(\"TQDM_TELEGRAM_TOKEN\") and getenv(\"TQDM_TELEGRAM_CHAT_ID\"):\n    from .telegram import tqdm, trange\nelif getenv(\"TQDM_DISCORD_TOKEN\") and getenv(\"TQDM_DISCORD_CHANNEL_ID\"):\n    from .discord import tqdm, trange\nelse:\n    from ..auto import tqdm, trange\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", category=FutureWarning)\n    tqdm.pandas()\n", "tqdm/contrib/utils_worker.py": "\"\"\"\nIO/concurrency helpers for `tqdm.contrib`.\n\"\"\"\nfrom collections import deque\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom ..auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['MonoWorker']\n\n\nclass MonoWorker(object):\n    \"\"\"\n    Supports one running task and one waiting task.\n    The waiting task is the most recent submitted (others are discarded).\n    \"\"\"\n    def __init__(self):\n        self.pool = ThreadPoolExecutor(max_workers=1)\n        self.futures = deque([], 2)\n\n    def submit(self, func, *args, **kwargs):\n        \"\"\"`func(*args, **kwargs)` may replace currently waiting task.\"\"\"\n        futures = self.futures\n        if len(futures) == futures.maxlen:\n            running = futures.popleft()\n            if not running.done():\n                if len(futures):  # clear waiting\n                    waiting = futures.pop()\n                    waiting.cancel()\n                futures.appendleft(running)  # re-insert running\n        try:\n            waiting = self.pool.submit(func, *args, **kwargs)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            futures.append(waiting)\n            return waiting\n", "tqdm/contrib/telegram.py": "\"\"\"\nSends updates to a Telegram bot.\n\nUsage:\n>>> from tqdm.contrib.telegram import tqdm, trange\n>>> for i in trange(10, token='{token}', chat_id='{chat_id}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-telegram.gif)\n\"\"\"\nfrom os import getenv\nfrom warnings import warn\n\nfrom requests import Session\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmWarning\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TelegramIO', 'tqdm_telegram', 'ttgrange', 'tqdm', 'trange']\n\n\nclass TelegramIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Telegram Bot.\"\"\"\n    API = 'https://api.telegram.org/bot'\n\n    def __init__(self, token, chat_id):\n        \"\"\"Creates a new message in the given `chat_id`.\"\"\"\n        super().__init__()\n        self.token = token\n        self.chat_id = chat_id\n        self.session = Session()\n        self.text = self.__class__.__name__\n        self.message_id\n\n    @property\n    def message_id(self):\n        if hasattr(self, '_message_id'):\n            return self._message_id\n        try:\n            res = self.session.post(\n                self.API + '%s/sendMessage' % self.token,\n                data={'text': '`' + self.text + '`', 'chat_id': self.chat_id,\n                      'parse_mode': 'MarkdownV2'}).json()\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            if res.get('error_code') == 429:\n                warn(\"Creation rate limit: try increasing `mininterval`.\",\n                     TqdmWarning, stacklevel=2)\n            else:\n                self._message_id = res['result']['message_id']\n                return self._message_id\n\n    def write(self, s):\n        \"\"\"Replaces internal `message_id`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # avoid duplicate message Bot error\n        message_id = self.message_id\n        if message_id is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(\n                self.session.post, self.API + '%s/editMessageText' % self.token,\n                data={'text': '`' + s + '`', 'chat_id': self.chat_id,\n                      'message_id': message_id, 'parse_mode': 'MarkdownV2'})\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n    def delete(self):\n        \"\"\"Deletes internal `message_id`.\"\"\"\n        try:\n            future = self.submit(\n                self.session.post, self.API + '%s/deleteMessage' % self.token,\n                data={'chat_id': self.chat_id, 'message_id': self.message_id})\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_telegram(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Telegram Bot.\n    May take a few seconds to create (`__init__`).\n\n    - create a bot <https://core.telegram.org/bots#6-botfather>\n    - copy its `{token}`\n    - add the bot to a chat and send it a message such as `/start`\n    - go to <https://api.telegram.org/bot`{token}`/getUpdates> to find out\n      the `{chat_id}`\n    - paste the `{token}` & `{chat_id}` below\n\n    >>> from tqdm.contrib.telegram import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', chat_id='{chat_id}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Telegram token\n            [default: ${TQDM_TELEGRAM_TOKEN}].\n        chat_id  : str, required. Telegram chat ID\n            [default: ${TQDM_TELEGRAM_CHAT_ID}].\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            self.tgio = TelegramIO(\n                kwargs.pop('token', getenv('TQDM_TELEGRAM_TOKEN')),\n                kwargs.pop('chat_id', getenv('TQDM_TELEGRAM_CHAT_ID')))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')\n        else:\n            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'\n        self.tgio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.tgio.write(\"\")\n\n    def close(self):\n        if self.disable:\n            return\n        super().close()\n        if not (self.leave or (self.leave is None and self.pos == 0)):\n            self.tgio.delete()\n\n\ndef ttgrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.telegram.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_telegram(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_telegram\ntrange = ttgrange\n", "tqdm/contrib/itertools.py": "\"\"\"\nThin wrappers around `itertools`.\n\"\"\"\nimport itertools\n\nfrom ..auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['product']\n\n\ndef product(*iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `itertools.product`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    try:\n        lens = list(map(len, iterables))\n    except TypeError:\n        total = None\n    else:\n        total = 1\n        for i in lens:\n            total *= i\n        kwargs.setdefault(\"total\", total)\n    with tqdm_class(**kwargs) as t:\n        it = itertools.product(*iterables)\n        for i in it:\n            yield i\n            t.update()\n", "tqdm/contrib/__init__.py": "\"\"\"\nThin wrappers around common functions.\n\nSubpackages contain potentially unstable extensions.\n\"\"\"\nfrom warnings import warn\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmDeprecationWarning, tqdm\nfrom ..utils import ObjectWrapper\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tenumerate', 'tzip', 'tmap']\n\n\nclass DummyTqdmFile(ObjectWrapper):\n    \"\"\"Dummy file-like that will write to tqdm\"\"\"\n\n    def __init__(self, wrapped):\n        super().__init__(wrapped)\n        self._buf = []\n\n    def write(self, x, nolock=False):\n        nl = b\"\\n\" if isinstance(x, bytes) else \"\\n\"\n        pre, sep, post = x.rpartition(nl)\n        if sep:\n            blank = type(nl)()\n            tqdm.write(blank.join(self._buf + [pre, sep]),\n                       end=blank, file=self._wrapped, nolock=nolock)\n            self._buf = [post]\n        else:\n            self._buf.append(x)\n\n    def __del__(self):\n        if self._buf:\n            blank = type(self._buf[0])()\n            try:\n                tqdm.write(blank.join(self._buf), end=blank, file=self._wrapped)\n            except (OSError, ValueError):\n                pass\n\n\ndef builtin_iterable(func):\n    \"\"\"Returns `func`\"\"\"\n    warn(\"This function has no effect, and will be removed in tqdm==5.0.0\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return func\n\n\ndef tenumerate(iterable, start=0, total=None, tqdm_class=tqdm_auto, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `numpy.ndenumerate` or builtin `enumerate`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    try:\n        import numpy as np\n    except ImportError:\n        pass\n    else:\n        if isinstance(iterable, np.ndarray):\n            return tqdm_class(np.ndenumerate(iterable), total=total or iterable.size,\n                              **tqdm_kwargs)\n    return enumerate(tqdm_class(iterable, total=total, **tqdm_kwargs), start)\n\n\ndef tzip(iter1, *iter2plus, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of builtin `zip`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    for i in zip(tqdm_class(iter1, **kwargs), *iter2plus):\n        yield i\n\n\ndef tmap(function, *sequences, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of builtin `map`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    for i in tzip(*sequences, **tqdm_kwargs):\n        yield function(*i)\n", "tqdm/contrib/concurrent.py": "\"\"\"\nThin wrappers around `concurrent.futures`.\n\"\"\"\nfrom contextlib import contextmanager\nfrom operator import length_hint\nfrom os import cpu_count\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmWarning\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['thread_map', 'process_map']\n\n\n@contextmanager\ndef ensure_lock(tqdm_class, lock_name=\"\"):\n    \"\"\"get (create if necessary) and then restore `tqdm_class`'s lock\"\"\"\n    old_lock = getattr(tqdm_class, '_lock', None)  # don't create a new lock\n    lock = old_lock or tqdm_class.get_lock()  # maybe create a new lock\n    lock = getattr(lock, lock_name, lock)  # maybe subtype\n    tqdm_class.set_lock(lock)\n    yield lock\n    if old_lock is None:\n        del tqdm_class._lock\n    else:\n        tqdm_class.set_lock(old_lock)\n\n\ndef _executor_map(PoolExecutor, fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Implementation of `thread_map` and `process_map`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    max_workers  : [default: min(32, cpu_count() + 4)].\n    chunksize  : [default: 1].\n    lock_name  : [default: \"\":str].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    if \"total\" not in kwargs:\n        kwargs[\"total\"] = length_hint(iterables[0])\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    max_workers = kwargs.pop(\"max_workers\", min(32, cpu_count() + 4))\n    chunksize = kwargs.pop(\"chunksize\", 1)\n    lock_name = kwargs.pop(\"lock_name\", \"\")\n    with ensure_lock(tqdm_class, lock_name=lock_name) as lk:\n        # share lock in case workers are already using `tqdm`\n        with PoolExecutor(max_workers=max_workers, initializer=tqdm_class.set_lock,\n                          initargs=(lk,)) as ex:\n            return list(tqdm_class(ex.map(fn, *iterables, chunksize=chunksize), **kwargs))\n\n\ndef thread_map(fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `list(map(fn, *iterables))`\n    driven by `concurrent.futures.ThreadPoolExecutor`.\n\n    Parameters\n    ----------\n    tqdm_class  : optional\n        `tqdm` class to use for bars [default: tqdm.auto.tqdm].\n    max_workers  : int, optional\n        Maximum number of workers to spawn; passed to\n        `concurrent.futures.ThreadPoolExecutor.__init__`.\n        [default: max(32, cpu_count() + 4)].\n    \"\"\"\n    from concurrent.futures import ThreadPoolExecutor\n    return _executor_map(ThreadPoolExecutor, fn, *iterables, **tqdm_kwargs)\n\n\ndef process_map(fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `list(map(fn, *iterables))`\n    driven by `concurrent.futures.ProcessPoolExecutor`.\n\n    Parameters\n    ----------\n    tqdm_class  : optional\n        `tqdm` class to use for bars [default: tqdm.auto.tqdm].\n    max_workers  : int, optional\n        Maximum number of workers to spawn; passed to\n        `concurrent.futures.ProcessPoolExecutor.__init__`.\n        [default: min(32, cpu_count() + 4)].\n    chunksize  : int, optional\n        Size of chunks sent to worker processes; passed to\n        `concurrent.futures.ProcessPoolExecutor.map`. [default: 1].\n    lock_name  : str, optional\n        Member of `tqdm_class.get_lock()` to use [default: mp_lock].\n    \"\"\"\n    from concurrent.futures import ProcessPoolExecutor\n    if iterables and \"chunksize\" not in tqdm_kwargs:\n        # default `chunksize=1` has poor performance for large iterables\n        # (most time spent dispatching items to workers).\n        longest_iterable_len = max(map(length_hint, iterables))\n        if longest_iterable_len > 1000:\n            from warnings import warn\n            warn(\"Iterable length %d > 1000 but `chunksize` is not set.\"\n                 \" This may seriously degrade multiprocess performance.\"\n                 \" Set `chunksize=1` or more.\" % longest_iterable_len,\n                 TqdmWarning, stacklevel=2)\n    if \"lock_name\" not in tqdm_kwargs:\n        tqdm_kwargs = tqdm_kwargs.copy()\n        tqdm_kwargs[\"lock_name\"] = \"mp_lock\"\n    return _executor_map(ProcessPoolExecutor, fn, *iterables, **tqdm_kwargs)\n", "tqdm/contrib/discord.py": "\"\"\"\nSends updates to a Discord bot.\n\nUsage:\n>>> from tqdm.contrib.discord import tqdm, trange\n>>> for i in trange(10, token='{token}', channel_id='{channel_id}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-discord.png)\n\"\"\"\nimport logging\nfrom os import getenv\n\ntry:\n    from disco.client import Client, ClientConfig\nexcept ImportError:\n    raise ImportError(\"Please `pip install disco-py`\")\n\nfrom ..auto import tqdm as tqdm_auto\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['DiscordIO', 'tqdm_discord', 'tdrange', 'tqdm', 'trange']\n\n\nclass DiscordIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Discord Bot.\"\"\"\n    def __init__(self, token, channel_id):\n        \"\"\"Creates a new message in the given `channel_id`.\"\"\"\n        super().__init__()\n        config = ClientConfig()\n        config.token = token\n        client = Client(config)\n        self.text = self.__class__.__name__\n        try:\n            self.message = client.api.channels_messages_create(channel_id, self.text)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n            self.message = None\n\n    def write(self, s):\n        \"\"\"Replaces internal `message`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # skip duplicate message\n        message = self.message\n        if message is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(message.edit, '`' + s + '`')\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_discord(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Discord Bot.\n    May take a few seconds to create (`__init__`).\n\n    - create a discord bot (not public, no requirement of OAuth2 code\n      grant, only send message permissions) & invite it to a channel:\n      <https://discordpy.readthedocs.io/en/latest/discord.html>\n    - copy the bot `{token}` & `{channel_id}` and paste below\n\n    >>> from tqdm.contrib.discord import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', channel_id='{channel_id}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Discord token\n            [default: ${TQDM_DISCORD_TOKEN}].\n        channel_id  : int, required. Discord channel ID\n            [default: ${TQDM_DISCORD_CHANNEL_ID}].\n        mininterval  : float, optional.\n          Minimum of [default: 1.5] to avoid rate limit.\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            logging.getLogger(\"HTTPClient\").setLevel(logging.WARNING)\n            self.dio = DiscordIO(\n                kwargs.pop('token', getenv(\"TQDM_DISCORD_TOKEN\")),\n                kwargs.pop('channel_id', getenv(\"TQDM_DISCORD_CHANNEL_ID\")))\n            kwargs['mininterval'] = max(1.5, kwargs.get('mininterval', 1.5))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')\n        else:\n            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'\n        self.dio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.dio.write(\"\")\n\n\ndef tdrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.discord.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_discord(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_discord\ntrange = tdrange\n", "benchmarks/benchmarks.py": "# Write the benchmarking functions here.\n# See \"Writing benchmarks\" in the asv docs for more information.\nfrom functools import partial\n\n\nclass Comparison:\n    \"\"\"Running time of wrapped empty loops\"\"\"\n    def __init__(self, length):\n        try:\n            from time import process_time\n            self.time = process_time\n        except ImportError:\n            from time import clock\n            self.time = clock\n        self.iterable = range(int(length))\n\n    def run(self, cls):\n        pbar = cls(self.iterable)\n        t0 = self.time()\n        [0 for _ in pbar]  # pylint: disable=pointless-statement\n        t1 = self.time()\n        return t1 - t0\n\n    def run_by_name(self, method):\n        return getattr(self, method.replace(\"-\", \"_\"))()\n\n    def no_progress(self):\n        return self.run(lambda x: x)\n\n    def tqdm_optimised(self):\n        from tqdm import tqdm\n        return self.run(partial(tqdm, miniters=6e5, smoothing=0))\n\n    def tqdm(self):\n        from tqdm import tqdm\n        return self.run(tqdm)\n\n    def alive_progress(self):\n        from alive_progress import alive_bar\n\n        class wrapper:\n            def __init__(self, iterable):\n                self.iterable = iterable\n\n            def __iter__(self):\n                iterable = self.iterable\n                with alive_bar(len(iterable)) as bar:\n                    for i in iterable:\n                        yield i\n                        bar()\n\n        return self.run(wrapper)\n\n    # def progressbar(self):\n    #     from progressbar.progressbar import ProgressBar\n    #     return self.run(ProgressBar())\n\n    def progressbar2(self):\n        from progressbar import progressbar\n        return self.run(progressbar)\n\n    def rich(self):\n        from rich.progress import track\n        return self.run(track)\n\n\n# thorough test against no-progress\nslow = Comparison(6e6)\n\n\ndef track_tqdm(method):\n    return slow.run_by_name(method)\n\n\ntrack_tqdm.params = [\"tqdm\", \"tqdm-optimised\", \"no-progress\"]\ntrack_tqdm.param_names = [\"method\"]\ntrack_tqdm.unit = \"Seconds (lower is better)\"\n\n# quick test against alternatives\nfast = Comparison(1e5)\n\n\ndef track_alternatives(library):\n    return fast.run_by_name(library)\n\n\ntrack_alternatives.params = [\"rich\", \"progressbar2\", \"alive-progress\", \"tqdm\"]\ntrack_alternatives.param_names = [\"library\"]\ntrack_alternatives.unit = \"Seconds (lower is better)\"\n", "benchmarks/__init__.py": "", ".meta/mksnap.py": "# -*- encoding: utf-8 -*-\n\"\"\"\nAuto-generate snapcraft.yaml.\n\"\"\"\nimport sys\nfrom pathlib import Path\nfrom subprocess import check_output  # nosec\n\nsys.path.insert(1, str(Path(__file__).parent.parent))\nimport tqdm  # NOQA\n\nsnap_yml = r\"\"\"name: tqdm\nsummary: A fast, extensible CLI progress bar\ndescription: |\n https://tqdm.github.io\n\n `tqdm` means \"progress\" in Arabic (taqadum, \u062a\u0642\u062f\u0651\u0645) and is an\n abbreviation for \"I love you so much\" in Spanish (te quiero demasiado).\n\n Instantly make your loops show a smart progress meter and stats - just\n replace any pipe \"`|`\" with \"`| tqdm |`\", and you're done!\n\n ```sh\n $ seq 9999999 | tqdm --bytes | wc -l\n 75.2MB [00:00, 217MB/s]\n 9999999\n $ 7z a -bd -r backup.7z docs/ | grep Compressing | \\\n     tqdm --total $(find docs/ -type f | wc -l) --unit files >> backup.log\n 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 8014/8014 [01:37<00:00, 82.29files/s]\n ```\n\n Overhead is low -- about 60ns per iteration.\n\n In addition to its low overhead, `tqdm` uses smart algorithms to predict\n the remaining time and to skip unnecessary iteration displays, which\n allows for a negligible overhead in most cases.\n\n `tqdm` works on any platform (Linux, Windows, Mac, FreeBSD, NetBSD,\n Solaris/SunOS), in any console or in a GUI, and is also friendly with\n IPython/Jupyter notebooks.\n\n `tqdm` does not require any dependencies, just\n an environment supporting `carriage return \\r` and\n `line feed \\n` control characters.\ngrade: stable\nconfinement: strict\nbase: core22\nicon: logo.png\nversion: '{version}'\nlicense: MPL-2.0\nparts:\n  tqdm:\n    plugin: python\n    source: .\n    source-commit: '{commit}'\n    python-packages: [.]\n    build-packages: [git]\n    override-build: |\n        craftctl default\n        cp $SNAPCRAFT_PART_BUILD/tqdm/completion.sh $SNAPCRAFT_PART_INSTALL/\napps:\n  tqdm:\n    command: bin/tqdm\n    completer: completion.sh\n\"\"\".format(version=tqdm.__version__, commit=check_output([\n    'git', 'describe', '--always']).decode('utf-8').strip())  # nosec\n\nif __name__ == \"__main__\":\n    (Path(__file__).resolve().parent.parent / 'snapcraft.yaml').write_text(\n        snap_yml.decode('utf-8') if hasattr(snap_yml, 'decode') else snap_yml, encoding='utf-8')\n", ".meta/mkcompletion.py": "\"\"\"\nAuto-generate tqdm/completion.sh from docstrings.\n\"\"\"\nimport re\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent))\nimport tqdm  # NOQA\nimport tqdm.cli  # NOQA\n\nRE_OPT = re.compile(r'(\\w+)  :', flags=re.M)\nRE_OPT_INPUT = re.compile(r'(\\w+)  : (?:str|int|float|chr|dict|tuple)', flags=re.M)\n\n\ndef doc2opt(doc, user_input=True):\n    \"\"\"\n    doc  : str, document to parse\n    user_input  : bool, optional.\n      [default: True] for only options requiring user input\n    \"\"\"\n    RE = RE_OPT_INPUT if user_input else RE_OPT\n    return ('--' + i for i in RE.findall(doc))\n\n\n# CLI options\noptions = {'-h', '--help', '-v', '--version'}\noptions_input = set()\nfor doc in (tqdm.tqdm.__doc__, tqdm.cli.CLI_EXTRA_DOC):\n    options.update(doc2opt(doc, user_input=False))\n    options_input.update(doc2opt(doc, user_input=True))\noptions.difference_update('--' + i for i in ('name',) + tqdm.cli.UNSUPPORTED_OPTS)\noptions_input &= options\noptions_input -= {\"--log\"}  # manually dealt with\ncompletion = u\"\"\"\\\n#!/usr/bin/env bash\n_tqdm(){{\n  local cur prv\n  cur=\"${{COMP_WORDS[COMP_CWORD]}}\"\n  prv=\"${{COMP_WORDS[COMP_CWORD - 1]}}\"\n\n  case ${{prv}} in\n  {opts_manual})\n    # await user input\n    ;;\n  \"--log\")\n    COMPREPLY=($(compgen -W \\\n      'CRITICAL FATAL ERROR WARN WARNING INFO DEBUG NOTSET' -- ${{cur}}))\n    ;;\n  *)\n    COMPREPLY=($(compgen -W '{opts}' -- ${{cur}}))\n    ;;\n  esac\n}}\ncomplete -F _tqdm tqdm\n\"\"\".format(opts=' '.join(sorted(options)), opts_manual='|'.join(sorted(options_input)))\n\nif __name__ == \"__main__\":\n    (Path(__file__).resolve().parent.parent / 'tqdm' / 'completion.sh').write_text(\n        completion, encoding='utf-8')\n", "examples/redirect_print.py": "\"\"\"Redirecting writing\n\nIf using a library that can print messages to the console, editing the library\nby  replacing `print()` with `tqdm.write()` may not be desirable.\nIn that case, redirecting `sys.stdout` to `tqdm.write()` is an option.\n\nTo redirect `sys.stdout`, create a file-like class that will write\nany input string to `tqdm.write()`, and supply the arguments\n`file=sys.stdout, dynamic_ncols=True`.\n\nA reusable canonical example is given below:\n\"\"\"\nimport contextlib\nimport sys\nfrom time import sleep\n\nfrom tqdm import tqdm\nfrom tqdm.contrib import DummyTqdmFile\n\n\n@contextlib.contextmanager\ndef std_out_err_redirect_tqdm():\n    orig_out_err = sys.stdout, sys.stderr\n    try:\n        # sys.stdout = sys.stderr = DummyTqdmFile(orig_out_err[0])\n        sys.stdout, sys.stderr = map(DummyTqdmFile, orig_out_err)\n        yield orig_out_err[0]\n    # Relay exceptions\n    except Exception as exc:\n        raise exc\n    # Always restore sys.stdout/err if necessary\n    finally:\n        sys.stdout, sys.stderr = orig_out_err\n\n\ndef some_fun(i):\n    print(\"Fee, fi, fo,\".split()[i])\n\n\n# Redirect stdout to tqdm.write()\nwith std_out_err_redirect_tqdm() as orig_stdout:\n    # tqdm needs the original stdout\n    # and dynamic_ncols=True to autodetect console width\n    for i in tqdm(range(3), file=orig_stdout, dynamic_ncols=True):\n        # order of the following two lines should not matter\n        some_fun(i)\n        sleep(.5)\n\n# After the `with`, printing is restored\nprint(\"Done!\")\n", "examples/include_no_requirements.py": "# How to import tqdm in any frontend without enforcing it as a dependency\ntry:\n    from tqdm.auto import tqdm\nexcept ImportError:\n\n    def tqdm(*args, **kwargs):\n        if args:\n            return args[0]\n        return kwargs.get('iterable', None)\n\n__all__ = ['tqdm']\n", "examples/tqdm_requests.py": "\"\"\"An example of wrapping manual tqdm updates for `requests.get`.\nSee also: tqdm_wget.py.\n\nUsage:\n    tqdm_requests.py [options]\n\nOptions:\n-h, --help\n    Print this help message and exit\n-u URL, --url URL  : string, optional\n    The url to fetch.\n    [default: https://caspersci.uk.to/matryoshka.zip]\n-o FILE, --output FILE  : string, optional\n    The local file path in which to save the url [default: /dev/null].\n\"\"\"\n\nfrom os import devnull\n\nimport requests\nfrom docopt import docopt\n\nfrom tqdm.auto import tqdm\n\nopts = docopt(__doc__)\n\neg_link = opts['--url']\neg_file = eg_link.replace('/', ' ').split()[-1]\neg_out = opts['--output'].replace(\"/dev/null\", devnull)\n\nresponse = requests.get(eg_link, stream=True)\nwith open(eg_out, \"wb\") as fout:\n    with tqdm(\n        # all optional kwargs\n        unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n        desc=eg_file, total=int(response.headers.get('content-length', 0))\n    ) as pbar:\n        for chunk in response.iter_content(chunk_size=4096):\n            fout.write(chunk)\n            pbar.update(len(chunk))\n\n# Even simpler progress by wrapping the output file's `write()`\nresponse = requests.get(eg_link, stream=True)\nwith tqdm.wrapattr(\n    open(eg_out, \"wb\"), \"write\",\n    unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n    desc=eg_file, total=int(response.headers.get('content-length', 0))\n) as fout:\n    for chunk in response.iter_content(chunk_size=4096):\n        fout.write(chunk)\n", "examples/parallel_bars.py": "from concurrent.futures import ThreadPoolExecutor\nfrom functools import partial\nfrom multiprocessing import Pool, RLock, freeze_support\nfrom random import random\nfrom threading import RLock as TRLock\nfrom time import sleep\n\nfrom tqdm.auto import tqdm, trange\nfrom tqdm.contrib.concurrent import process_map, thread_map\n\nNUM_SUBITERS = 9\n\n\ndef progresser(n, auto_position=True, write_safe=False, blocking=True, progress=False):\n    interval = random() * 0.002 / (NUM_SUBITERS - n + 2)  # nosec\n    total = 5000\n    text = f\"#{n}, est. {interval * total:<04.2g}s\"\n    for _ in trange(total, desc=text, disable=not progress,\n                    lock_args=None if blocking else (False,),\n                    position=None if auto_position else n):\n        sleep(interval)\n    # NB: may not clear instances with higher `position` upon completion\n    # since this worker may not know about other bars #796\n    if write_safe:  # we think we know about other bars\n        if n == 6:\n            tqdm.write(\"n == 6 completed\")\n    return n + 1\n\n\nif __name__ == '__main__':\n    freeze_support()  # for Windows support\n    L = list(range(NUM_SUBITERS))[::-1]\n\n    print(\"Simple thread mapping\")\n    thread_map(partial(progresser, write_safe=True), L, max_workers=4)\n\n    print(\"Simple process mapping\")\n    process_map(partial(progresser), L, max_workers=4)\n\n    print(\"Manual nesting\")\n    for i in trange(16, desc=\"1\"):\n        for _ in trange(16, desc=\"2 @ %d\" % i, leave=i % 2):\n            sleep(0.01)\n\n    print(\"Multi-processing\")\n    tqdm.set_lock(RLock())\n    p = Pool(initializer=tqdm.set_lock, initargs=(tqdm.get_lock(),))\n    p.map(partial(progresser, progress=True), L)\n\n    print(\"Multi-threading\")\n    tqdm.set_lock(TRLock())\n    with ThreadPoolExecutor(initializer=tqdm.set_lock, initargs=(tqdm.get_lock(),)) as p:\n        p.map(partial(progresser, progress=True, write_safe=True, blocking=False), L)\n", "examples/wrapping_generators.py": "import numpy as np\n\nfrom tqdm.contrib import tenumerate, tmap, tzip\n\nfor _ in tenumerate(range(int(1e6)), desc=\"builtin enumerate\"):\n    pass\n\nfor _ in tenumerate(np.random.random((999, 999)), desc=\"numpy.ndenumerate\"):\n    pass\n\nfor _ in tzip(np.arange(1e6), np.arange(1e6) + 1, desc=\"builtin zip\"):\n    pass\n\nmapped = tmap(lambda x: x + 1, np.arange(1e6), desc=\"builtin map\")\nassert (np.arange(1e6) + 1 == list(mapped)).all()\n", "examples/7zx.py": "# -*- coding: utf-8 -*-\n\"\"\"Usage:\n  7zx.py [--help | options] <zipfiles>...\n\nOptions:\n  -h, --help     Print this help and exit\n  -v, --version  Print version and exit\n  -c, --compressed       Use compressed (instead of uncompressed) file sizes\n  -s, --silent   Do not print one row per zip file\n  -y, --yes      Assume yes to all queries (for extraction)\n  -D=<level>, --debug=<level>\n                 Print various types of debugging information. Choices:\n                         CRITICAL|FATAL\n                         ERROR\n                         WARN(ING)\n                         [default: INFO]\n                         DEBUG\n                         NOTSET\n  -d, --debug-trace      Print lots of debugging information (-D NOTSET)\n\"\"\"\nimport io\nimport logging\nimport os\nimport pty\nimport re\nimport subprocess  # nosec\n\nfrom argopt import argopt\n\nfrom tqdm import tqdm\n\n__author__ = \"Casper da Costa-Luis <casper.dcl@physics.org>\"\n__licence__ = \"MPLv2.0\"\n__version__ = \"0.2.2\"\n__license__ = __licence__\n\nRE_SCN = re.compile(r\"([0-9]+)\\s+([0-9]+)\\s+(.*)$\", flags=re.M)\n\n\ndef main():\n    args = argopt(__doc__, version=__version__).parse_args()\n    if args.debug_trace:\n        args.debug = \"NOTSET\"\n    logging.basicConfig(level=getattr(logging, args.debug, logging.INFO),\n                        format='%(levelname)s:%(message)s')\n    log = logging.getLogger(__name__)\n    log.debug(args)\n\n    # Get compressed sizes\n    zips = {}\n    for fn in args.zipfiles:\n        info = subprocess.check_output([\"7z\", \"l\", fn]).strip()  # nosec\n        finfo = RE_SCN.findall(info)  # size|compressed|name\n\n        # builtin test: last line should be total sizes\n        log.debug(finfo)\n        totals = map(int, finfo[-1][:2])\n        # log.debug(totals)\n        for s in range(2):  # size|compressed totals\n            totals_s = sum(map(int, (inf[s] for inf in finfo[:-1])))\n            if totals_s != totals[s]:\n                log.warn(\"%s: individual total %d != 7z total %d\",\n                         fn, totals_s, totals[s])\n        fcomp = {n: int(c if args.compressed else u) for (u, c, n) in finfo[:-1]}\n        # log.debug(fcomp)\n        # zips  : {'zipname' : {'filename' : int(size)}}\n        zips[fn] = fcomp\n\n    # Extract\n    cmd7zx = [\"7z\", \"x\", \"-bd\"]\n    if args.yes:\n        cmd7zx += [\"-y\"]\n    log.info(\"Extracting from %d file(s)\", len(zips))\n    with tqdm(total=sum(sum(fcomp.values()) for fcomp in zips.values()),\n              unit=\"B\", unit_scale=True) as tall:\n        for fn, fcomp in zips.items():\n            md, sd = pty.openpty()\n            ex = subprocess.Popen(  # nosec\n                cmd7zx + [fn],\n                bufsize=1,\n                stdout=md,  # subprocess.PIPE,\n                stderr=subprocess.STDOUT)\n            os.close(sd)\n            with io.open(md, mode=\"rU\", buffering=1) as m:\n                with tqdm(total=sum(fcomp.values()), disable=len(zips) < 2,\n                          leave=False, unit=\"B\", unit_scale=True) as t:\n                    if not hasattr(t, \"start_t\"):  # disabled\n                        t.start_t = tall._time()\n                    while True:\n                        try:\n                            l_raw = m.readline()\n                        except IOError:\n                            break\n                        ln = l_raw.strip()\n                        if ln.startswith(\"Extracting\"):\n                            exname = ln[len(\"Extracting\"):].lstrip()\n                            s = fcomp.get(exname, 0)  # 0 is likely folders\n                            t.update(s)\n                            tall.update(s)\n                        elif ln:\n                            if not any(\n                                    ln.startswith(i)\n                                    for i in (\"7-Zip \", \"p7zip Version \",\n                                              \"Everything is Ok\", \"Folders: \",\n                                              \"Files: \", \"Size: \", \"Compressed: \")):\n                                if ln.startswith(\"Processing archive: \"):\n                                    if not args.silent:\n                                        t.write(t.format_interval(\n                                            t.start_t - tall.start_t) + ' ' +\n                                            ln.replace(\"Processing archive: \", \"\"))\n                                else:\n                                    t.write(ln)\n            ex.wait()\n\n\nmain.__doc__ = __doc__\n\nif __name__ == \"__main__\":\n    main()\n", "examples/coroutine_pipe.py": "\"\"\"\nInserting `tqdm` as a \"pipe\" in a chain of coroutines.\nNot to be confused with `asyncio.coroutine`.\n\"\"\"\nfrom functools import wraps\n\nfrom tqdm.auto import tqdm\n\n\ndef autonext(func):\n    @wraps(func)\n    def inner(*args, **kwargs):\n        res = func(*args, **kwargs)\n        next(res)\n        return res\n    return inner\n\n\n@autonext\ndef tqdm_pipe(target, **tqdm_kwargs):\n    \"\"\"\n    Coroutine chain pipe `send()`ing to `target`.\n\n    This:\n    >>> r = receiver()\n    >>> p = producer(r)\n    >>> next(r)\n    >>> next(p)\n\n    Becomes:\n    >>> r = receiver()\n    >>> t = tqdm.pipe(r)\n    >>> p = producer(t)\n    >>> next(r)\n    >>> next(p)\n    \"\"\"\n    with tqdm(**tqdm_kwargs) as pbar:\n        while True:\n            obj = (yield)\n            target.send(obj)\n            pbar.update()\n\n\ndef source(target):\n    for i in [\"foo\", \"bar\", \"baz\", \"pythonista\", \"python\", \"py\"]:\n        target.send(i)\n    target.close()\n\n\n@autonext\ndef grep(pattern, target):\n    while True:\n        line = (yield)\n        if pattern in line:\n            target.send(line)\n\n\n@autonext\ndef sink():\n    while True:\n        line = (yield)\n        tqdm.write(line)\n\n\nif __name__ == \"__main__\":\n    source(\n        tqdm_pipe(\n            grep('python',\n                 sink())))\n", "examples/pandas_progress_apply.py": "import numpy as np\nimport pandas as pd\n\nfrom tqdm.auto import tqdm\n\ndf = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n\n# Register `pandas.progress_apply` and `pandas.Series.map_apply` with `tqdm`\n# (can use `tqdm.gui.tqdm`, `tqdm.notebook.tqdm`, optional kwargs, etc.)\ntqdm.pandas(desc=\"my bar!\")\n\n# Now you can use `progress_apply` instead of `apply`\n# and `progress_map` instead of `map`\ndf.progress_apply(lambda x: x**2)\n# can also groupby:\n# df.groupby(0).progress_apply(lambda x: x**2)\n\n# -- Source code for `tqdm_pandas` (really simple!)\n# def tqdm_pandas(t):\n#   from pandas.core.frame import DataFrame\n#   def inner(df, func, *args, **kwargs):\n#       t.total = groups.size // len(groups)\n#       def wrapper(*args, **kwargs):\n#           t.update(1)\n#           return func(*args, **kwargs)\n#       result = df.apply(wrapper, *args, **kwargs)\n#       t.close()\n#       return result\n#   DataFrame.progress_apply = inner\n", "examples/tqdm_wget.py": "\"\"\"An example of wrapping manual tqdm updates for `urllib` reporthook.\nSee also: tqdm_requests.py.\n\n# `urllib.urlretrieve` documentation\n> If present, the hook function will be called once\n> on establishment of the network connection and once after each block read\n> thereafter. The hook will be passed three arguments; a count of blocks\n> transferred so far, a block size in bytes, and the total size of the file.\n\nUsage:\n    tqdm_wget.py [options]\n\nOptions:\n-h, --help\n    Print this help message and exit\n-u URL, --url URL  : string, optional\n    The url to fetch.\n    [default: https://caspersci.uk.to/matryoshka.zip]\n-o FILE, --output FILE  : string, optional\n    The local file path in which to save the url [default: /dev/null].\n\"\"\"\n\nfrom os import devnull\nfrom urllib import request as urllib\n\nfrom docopt import docopt\n\nfrom tqdm.auto import tqdm\n\n\ndef my_hook(t):\n    \"\"\"Wraps tqdm instance.\n\n    Don't forget to close() or __exit__()\n    the tqdm instance once you're done with it (easiest using `with` syntax).\n\n    Example\n    -------\n\n    >>> with tqdm(...) as t:\n    ...     reporthook = my_hook(t)\n    ...     urllib.urlretrieve(..., reporthook=reporthook)\n\n    \"\"\"\n    last_b = [0]\n\n    def update_to(b=1, bsize=1, tsize=None):\n        \"\"\"\n        b  : int, optional\n            Number of blocks transferred so far [default: 1].\n        bsize  : int, optional\n            Size of each block (in tqdm units) [default: 1].\n        tsize  : int, optional\n            Total size (in tqdm units). If [default: None] or -1,\n            remains unchanged.\n        \"\"\"\n        if tsize not in (None, -1):\n            t.total = tsize\n        displayed = t.update((b - last_b[0]) * bsize)\n        last_b[0] = b\n        return displayed\n\n    return update_to\n\n\nclass TqdmUpTo(tqdm):\n    \"\"\"Alternative Class-based version of the above.\n\n    Provides `update_to(n)` which uses `tqdm.update(delta_n)`.\n\n    Inspired by [twine#242](https://github.com/pypa/twine/pull/242),\n    [here](https://github.com/pypa/twine/commit/42e55e06).\n    \"\"\"\n\n    def update_to(self, b=1, bsize=1, tsize=None):\n        \"\"\"\n        b  : int, optional\n            Number of blocks transferred so far [default: 1].\n        bsize  : int, optional\n            Size of each block (in tqdm units) [default: 1].\n        tsize  : int, optional\n            Total size (in tqdm units). If [default: None] remains unchanged.\n        \"\"\"\n        if tsize is not None:\n            self.total = tsize\n        return self.update(b * bsize - self.n)  # also sets self.n = b * bsize\n\n\nopts = docopt(__doc__)\n\neg_link = opts['--url']\neg_file = eg_link.replace('/', ' ').split()[-1]\neg_out = opts['--output'].replace(\"/dev/null\", devnull)\n# with tqdm(unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n#           desc=eg_file) as t:  # all optional kwargs\n#     urllib.urlretrieve(eg_link, filename=eg_out,\n#                        reporthook=my_hook(t), data=None)\nwith TqdmUpTo(unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n              desc=eg_file) as t:  # all optional kwargs\n    urllib.urlretrieve(  # nosec\n        eg_link, filename=eg_out, reporthook=t.update_to, data=None)\n    t.total = t.n\n\n# Even simpler progress by wrapping the output file's `write()`\nresponse = urllib.urlopen(eg_link)  # nosec\nwith tqdm.wrapattr(open(eg_out, \"wb\"), \"write\",\n                   miniters=1, desc=eg_file,\n                   total=getattr(response, 'length', None)) as fout:\n    for chunk in response:\n        fout.write(chunk)\n", "examples/async_coroutines.py": "\"\"\"Asynchronous examples using `asyncio`, `async` and `await`.\"\"\"\nimport asyncio\n\nfrom tqdm.asyncio import tqdm, trange\n\n\ndef count(start=0, step=1):\n    i = start\n    while True:\n        new_start = yield i\n        if new_start is None:\n            i += step\n        else:\n            i = new_start\n\n\nasync def main():\n    N = int(1e6)\n    async for row in tqdm(trange(N, desc=\"inner\"), desc=\"outer\"):\n        if row >= N:\n            break\n    with tqdm(count(), desc=\"coroutine\", total=N + 2) as pbar:\n        async for row in pbar:\n            if row == N:\n                pbar.send(-10)\n            elif row < 0:\n                assert row == -9\n                break\n    # should be ~1sec rather than ~50s due to async scheduling\n    for i in tqdm.as_completed([asyncio.sleep(0.01 * i)\n                                for i in range(100, 0, -1)], desc=\"as_completed\"):\n        await i\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n", "examples/simple_examples.py": "\"\"\"\n# Simple tqdm examples and profiling\n\n# Benchmark\nfor i in range(int(1e8)):\n    pass\n\n# Basic demo\nimport tqdm\nfor i in tqdm.trange(int(1e8)):\n    pass\n\n# Some decorations\nimport tqdm\nfor i in tqdm.trange(int(1e8), miniters=int(1e6), ascii=True,\n                     desc=\"cool\", dynamic_ncols=True):\n    pass\n\n# Nested bars\nfrom tqdm import trange\nfor i in trange(10):\n    for j in trange(int(1e7), leave=False, unit_scale=True):\n        pass\n\n# Experimental GUI demo\nimport tqdm\nfor i in tqdm.tgrange(int(1e8)):\n    pass\n\n# Comparison to https://code.google.com/p/python-progressbar/\ntry:\n    from progressbar.progressbar import ProgressBar\nexcept ImportError:\n    pass\nelse:\n    for i in ProgressBar()(range(int(1e8))):\n        pass\n\n# Dynamic miniters benchmark\nfrom tqdm import trange\nfor i in trange(int(1e8), miniters=None, mininterval=0.1, smoothing=0):\n    pass\n\n# Fixed miniters benchmark\nfrom tqdm import trange\nfor i in trange(int(1e8), miniters=4500000, mininterval=0.1, smoothing=0):\n    pass\n\"\"\"\n\nimport re\nfrom time import sleep\nfrom timeit import timeit\n\n# Simple demo\nfrom tqdm import trange\n\nfor _ in trange(16, leave=True):\n    sleep(0.1)\n\n# Profiling/overhead tests\nstmts = filter(None, re.split(r'\\n\\s*#.*?\\n', __doc__))\nfor s in stmts:\n    print(s.replace('import tqdm\\n', ''))\n    print(timeit(stmt=s, number=1), 'seconds')\n"}