{"tqdm/asyncio.py": "\"\"\"\nAsynchronous progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm.asyncio import trange, tqdm\n>>> async for i in trange(10):\n...     ...\n\"\"\"\nimport asyncio\nfrom sys import version_info\n\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tqdm_asyncio', 'tarange', 'tqdm', 'trange']\n\n\nclass tqdm_asyncio(std_tqdm):\n    \"\"\"\n    Asynchronous-friendly version of tqdm.\n    \"\"\"\n    def __init__(self, iterable=None, *args, **kwargs):\n        super().__init__(iterable, *args, **kwargs)\n        self.iterable_awaitable = False\n        if iterable is not None:\n            if hasattr(iterable, \"__anext__\"):\n                self.iterable_next = iterable.__anext__\n                self.iterable_awaitable = True\n            elif hasattr(iterable, \"__next__\"):\n                self.iterable_next = iterable.__next__\n            else:\n                self.iterable_iterator = iter(iterable)\n                self.iterable_next = self.iterable_iterator.__next__\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        try:\n            if self.iterable_awaitable:\n                res = await self.iterable_next()\n            else:\n                res = self.iterable_next()\n            self.update()\n            return res\n        except StopIteration:\n            self.close()\n            raise StopAsyncIteration\n        except BaseException:\n            self.close()\n            raise\n\n    def send(self, *args, **kwargs):\n        return self.iterable.send(*args, **kwargs)\n\n    @classmethod\n    def as_completed(cls, fs, *, loop=None, timeout=None, total=None, **tqdm_kwargs):\n        \"\"\"\n        Wrapper for `asyncio.as_completed`.\n        \"\"\"\n        if total is None:\n            total = len(fs)\n        kwargs = {}\n        if version_info[:2] < (3, 10):\n            kwargs['loop'] = loop\n        yield from cls(asyncio.as_completed(fs, timeout=timeout, **kwargs),\n                       total=total, **tqdm_kwargs)\n\n    @classmethod\n    async def gather(cls, *fs, loop=None, timeout=None, total=None, **tqdm_kwargs):\n        \"\"\"\n        Wrapper for `asyncio.gather`.\n        \"\"\"\n        async def wrap_awaitable(i, f):\n            return i, await f\n\n        ifs = [wrap_awaitable(i, f) for i, f in enumerate(fs)]\n        res = [await f for f in cls.as_completed(ifs, loop=loop, timeout=timeout,\n                                                 total=total, **tqdm_kwargs)]\n        return [i for _, i in sorted(res)]\n\n\ndef tarange(*args, **kwargs):\n    \"\"\"\n    A shortcut for `tqdm.asyncio.tqdm(range(*args), **kwargs)`.\n    \"\"\"\n    return tqdm_asyncio(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_asyncio\ntrange = tarange\n", "tqdm/cli.py": "\"\"\"\nModule version for monitoring CLI pipes (`... | python -m tqdm | ...`).\n\"\"\"\nimport logging\nimport re\nimport sys\nfrom ast import literal_eval as numeric\n\nfrom .std import TqdmKeyError, TqdmTypeError, tqdm\nfrom .version import __version__\n\n__all__ = [\"main\"]\nlog = logging.getLogger(__name__)\n\n\ndef cast(val, typ):\n    log.debug((val, typ))\n    if \" or \" in typ:\n        for t in typ.split(\" or \"):\n            try:\n                return cast(val, t)\n            except TqdmTypeError:\n                pass\n        raise TqdmTypeError(f\"{val} : {typ}\")\n\n    # sys.stderr.write('\\ndebug | `val:type`: `' + val + ':' + typ + '`.\\n')\n    if typ == 'bool':\n        if (val == 'True') or (val == ''):\n            return True\n        if val == 'False':\n            return False\n        raise TqdmTypeError(val + ' : ' + typ)\n    if typ == 'chr':\n        if len(val) == 1:\n            return val.encode()\n        if re.match(r\"^\\\\\\w+$\", val):\n            return eval(f'\"{val}\"').encode()\n        raise TqdmTypeError(f\"{val} : {typ}\")\n    if typ == 'str':\n        return val\n    if typ == 'int':\n        try:\n            return int(val)\n        except ValueError as exc:\n            raise TqdmTypeError(f\"{val} : {typ}\") from exc\n    if typ == 'float':\n        try:\n            return float(val)\n        except ValueError as exc:\n            raise TqdmTypeError(f\"{val} : {typ}\") from exc\n    raise TqdmTypeError(f\"{val} : {typ}\")\n\n\ndef posix_pipe(fin, fout, delim=b'\\\\n', buf_size=256,\n               callback=lambda float: None, callback_len=True):\n    \"\"\"\n    Params\n    ------\n    fin  : binary file with `read(buf_size : int)` method\n    fout  : binary file with `write` (and optionally `flush`) methods.\n    callback  : function(float), e.g.: `tqdm.update`\n    callback_len  : If (default: True) do `callback(len(buffer))`.\n      Otherwise, do `callback(data) for data in buffer.split(delim)`.\n    \"\"\"\n    fp_write = fout.write\n\n    if not delim:\n        while True:\n            tmp = fin.read(buf_size)\n\n            # flush at EOF\n            if not tmp:\n                getattr(fout, 'flush', lambda: None)()\n                return\n\n            fp_write(tmp)\n            callback(len(tmp))\n        # return\n\n    buf = b''\n    len_delim = len(delim)\n    # n = 0\n    while True:\n        tmp = fin.read(buf_size)\n\n        # flush at EOF\n        if not tmp:\n            if buf:\n                fp_write(buf)\n                if callback_len:\n                    # n += 1 + buf.count(delim)\n                    callback(1 + buf.count(delim))\n                else:\n                    for i in buf.split(delim):\n                        callback(i)\n            getattr(fout, 'flush', lambda: None)()\n            return  # n\n\n        while True:\n            i = tmp.find(delim)\n            if i < 0:\n                buf += tmp\n                break\n            fp_write(buf + tmp[:i + len(delim)])\n            # n += 1\n            callback(1 if callback_len else (buf + tmp[:i]))\n            buf = b''\n            tmp = tmp[i + len_delim:]\n\n\n# ((opt, type), ... )\nRE_OPTS = re.compile(r'\\n {4}(\\S+)\\s{2,}:\\s*([^,]+)')\n# better split method assuming no positional args\nRE_SHLEX = re.compile(r'\\s*(?<!\\S)--?([^\\s=]+)(\\s+|=|$)')\n\n# TODO: add custom support for some of the following?\nUNSUPPORTED_OPTS = ('iterable', 'gui', 'out', 'file')\n\n# The 8 leading spaces are required for consistency\nCLI_EXTRA_DOC = r\"\"\"\n    Extra CLI Options\n    -----------------\n    name  : type, optional\n        TODO: find out why this is needed.\n    delim  : chr, optional\n        Delimiting character [default: '\\n']. Use '\\0' for null.\n        N.B.: on Windows systems, Python converts '\\n' to '\\r\\n'.\n    buf_size  : int, optional\n        String buffer size in bytes [default: 256]\n        used when `delim` is specified.\n    bytes  : bool, optional\n        If true, will count bytes, ignore `delim`, and default\n        `unit_scale` to True, `unit_divisor` to 1024, and `unit` to 'B'.\n    tee  : bool, optional\n        If true, passes `stdin` to both `stderr` and `stdout`.\n    update  : bool, optional\n        If true, will treat input as newly elapsed iterations,\n        i.e. numbers to pass to `update()`. Note that this is slow\n        (~2e5 it/s) since every input must be decoded as a number.\n    update_to  : bool, optional\n        If true, will treat input as total elapsed iterations,\n        i.e. numbers to assign to `self.n`. Note that this is slow\n        (~2e5 it/s) since every input must be decoded as a number.\n    null  : bool, optional\n        If true, will discard input (no stdout).\n    manpath  : str, optional\n        Directory in which to install tqdm man pages.\n    comppath  : str, optional\n        Directory in which to place tqdm completion.\n    log  : str, optional\n        CRITICAL|FATAL|ERROR|WARN(ING)|[default: 'INFO']|DEBUG|NOTSET.\n\"\"\"\n\n\ndef main(fp=sys.stderr, argv=None):\n    \"\"\"\n    Parameters (internal use only)\n    ---------\n    fp  : file-like object for tqdm\n    argv  : list (default: sys.argv[1:])\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    try:\n        log_idx = argv.index('--log')\n    except ValueError:\n        for i in argv:\n            if i.startswith('--log='):\n                logLevel = i[len('--log='):]\n                break\n        else:\n            logLevel = 'INFO'\n    else:\n        # argv.pop(log_idx)\n        # logLevel = argv.pop(log_idx)\n        logLevel = argv[log_idx + 1]\n    logging.basicConfig(level=getattr(logging, logLevel),\n                        format=\"%(levelname)s:%(module)s:%(lineno)d:%(message)s\")\n\n    d = tqdm.__doc__ + CLI_EXTRA_DOC\n\n    opt_types = dict(RE_OPTS.findall(d))\n    # opt_types['delim'] = 'chr'\n\n    for o in UNSUPPORTED_OPTS:\n        opt_types.pop(o)\n\n    log.debug(sorted(opt_types.items()))\n\n    # d = RE_OPTS.sub(r'  --\\1=<\\1>  : \\2', d)\n    split = RE_OPTS.split(d)\n    opt_types_desc = zip(split[1::3], split[2::3], split[3::3])\n    d = ''.join(('\\n  --{0}  : {2}{3}' if otd[1] == 'bool' else\n                 '\\n  --{0}=<{1}>  : {2}{3}').format(\n                     otd[0].replace('_', '-'), otd[0], *otd[1:])\n                for otd in opt_types_desc if otd[0] not in UNSUPPORTED_OPTS)\n\n    help_short = \"Usage:\\n  tqdm [--help | options]\\n\"\n    d = help_short + \"\"\"\nOptions:\n  -h, --help     Print this help and exit.\n  -v, --version  Print version and exit.\n\"\"\" + d.strip('\\n') + '\\n'\n\n    # opts = docopt(d, version=__version__)\n    if any(v in argv for v in ('-v', '--version')):\n        sys.stdout.write(__version__ + '\\n')\n        sys.exit(0)\n    elif any(v in argv for v in ('-h', '--help')):\n        sys.stdout.write(d + '\\n')\n        sys.exit(0)\n    elif argv and argv[0][:2] != '--':\n        sys.stderr.write(f\"Error:Unknown argument:{argv[0]}\\n{help_short}\")\n\n    argv = RE_SHLEX.split(' '.join([\"tqdm\"] + argv))\n    opts = dict(zip(argv[1::3], argv[3::3]))\n\n    log.debug(opts)\n    opts.pop('log', True)\n\n    tqdm_args = {'file': fp}\n    try:\n        for (o, v) in opts.items():\n            o = o.replace('-', '_')\n            try:\n                tqdm_args[o] = cast(v, opt_types[o])\n            except KeyError as e:\n                raise TqdmKeyError(str(e))\n        log.debug('args:' + str(tqdm_args))\n\n        delim_per_char = tqdm_args.pop('bytes', False)\n        update = tqdm_args.pop('update', False)\n        update_to = tqdm_args.pop('update_to', False)\n        if sum((delim_per_char, update, update_to)) > 1:\n            raise TqdmKeyError(\"Can only have one of --bytes --update --update_to\")\n    except Exception:\n        fp.write(\"\\nError:\\n\" + help_short)\n        stdin, stdout_write = sys.stdin, sys.stdout.write\n        for i in stdin:\n            stdout_write(i)\n        raise\n    else:\n        buf_size = tqdm_args.pop('buf_size', 256)\n        delim = tqdm_args.pop('delim', b'\\\\n')\n        tee = tqdm_args.pop('tee', False)\n        manpath = tqdm_args.pop('manpath', None)\n        comppath = tqdm_args.pop('comppath', None)\n        if tqdm_args.pop('null', False):\n            class stdout(object):\n                @staticmethod\n                def write(_):\n                    pass\n        else:\n            stdout = sys.stdout\n            stdout = getattr(stdout, 'buffer', stdout)\n        stdin = getattr(sys.stdin, 'buffer', sys.stdin)\n        if manpath or comppath:\n            from importlib import resources\n            from os import path\n            from shutil import copyfile\n\n            def cp(name, dst):\n                \"\"\"copy resource `name` to `dst`\"\"\"\n                if hasattr(resources, 'files'):\n                    copyfile(str(resources.files('tqdm') / name), dst)\n                else:  # py<3.9\n                    with resources.path('tqdm', name) as src:\n                        copyfile(str(src), dst)\n                log.info(\"written:%s\", dst)\n            if manpath is not None:\n                cp('tqdm.1', path.join(manpath, 'tqdm.1'))\n            if comppath is not None:\n                cp('completion.sh', path.join(comppath, 'tqdm_completion.sh'))\n            sys.exit(0)\n        if tee:\n            stdout_write = stdout.write\n            fp_write = getattr(fp, 'buffer', fp).write\n\n            class stdout(object):  # pylint: disable=function-redefined\n                @staticmethod\n                def write(x):\n                    with tqdm.external_write_mode(file=fp):\n                        fp_write(x)\n                    stdout_write(x)\n        if delim_per_char:\n            tqdm_args.setdefault('unit', 'B')\n            tqdm_args.setdefault('unit_scale', True)\n            tqdm_args.setdefault('unit_divisor', 1024)\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                posix_pipe(stdin, stdout, '', buf_size, t.update)\n        elif delim == b'\\\\n':\n            log.debug(tqdm_args)\n            write = stdout.write\n            if update or update_to:\n                with tqdm(**tqdm_args) as t:\n                    if update:\n                        def callback(i):\n                            t.update(numeric(i.decode()))\n                    else:  # update_to\n                        def callback(i):\n                            t.update(numeric(i.decode()) - t.n)\n                    for i in stdin:\n                        write(i)\n                        callback(i)\n            else:\n                for i in tqdm(stdin, **tqdm_args):\n                    write(i)\n        else:\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                callback_len = False\n                if update:\n                    def callback(i):\n                        t.update(numeric(i.decode()))\n                elif update_to:\n                    def callback(i):\n                        t.update(numeric(i.decode()) - t.n)\n                else:\n                    callback = t.update\n                    callback_len = True\n                posix_pipe(stdin, stdout, delim, buf_size, callback, callback_len)\n", "tqdm/auto.py": "\"\"\"\nEnables multiple commonly used features.\n\nMethod resolution order:\n\n- `tqdm.autonotebook` without import warnings\n- `tqdm.asyncio`\n- `tqdm.std` base class\n\nUsage:\n>>> from tqdm.auto import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport warnings\n\nfrom .std import TqdmExperimentalWarning\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", category=TqdmExperimentalWarning)\n    from .autonotebook import tqdm as notebook_tqdm\n\nfrom .asyncio import tqdm as asyncio_tqdm\nfrom .std import tqdm as std_tqdm\n\nif notebook_tqdm != std_tqdm:\n    class tqdm(notebook_tqdm, asyncio_tqdm):  # pylint: disable=inconsistent-mro\n        pass\nelse:\n    tqdm = asyncio_tqdm\n\n\ndef trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for `tqdm.auto.tqdm(range(*args), **kwargs)`.\n    \"\"\"\n    return tqdm(range(*args), **kwargs)\n\n\n__all__ = [\"tqdm\", \"trange\"]\n", "tqdm/utils.py": "\"\"\"\nGeneral helpers required for `tqdm.std`.\n\"\"\"\nimport os\nimport re\nimport sys\nfrom functools import partial, partialmethod, wraps\nfrom inspect import signature\n# TODO consider using wcswidth third-party package for 0-width characters\nfrom unicodedata import east_asian_width\nfrom warnings import warn\nfrom weakref import proxy\n\n_range, _unich, _unicode, _basestring = range, chr, str, str\nCUR_OS = sys.platform\nIS_WIN = any(CUR_OS.startswith(i) for i in ['win32', 'cygwin'])\nIS_NIX = any(CUR_OS.startswith(i) for i in ['aix', 'linux', 'darwin'])\nRE_ANSI = re.compile(r\"\\x1b\\[[;\\d]*[A-Za-z]\")\n\ntry:\n    if IS_WIN:\n        import colorama\n    else:\n        raise ImportError\nexcept ImportError:\n    colorama = None\nelse:\n    try:\n        colorama.init(strip=False)\n    except TypeError:\n        colorama.init()\n\n\ndef envwrap(prefix, types=None, is_method=False):\n    \"\"\"\n    Override parameter defaults via `os.environ[prefix + param_name]`.\n    Maps UPPER_CASE env vars map to lower_case param names.\n    camelCase isn't supported (because Windows ignores case).\n\n    Precedence (highest first):\n\n    - call (`foo(a=3)`)\n    - environ (`FOO_A=2`)\n    - signature (`def foo(a=1)`)\n\n    Parameters\n    ----------\n    prefix  : str\n        Env var prefix, e.g. \"FOO_\"\n    types  : dict, optional\n        Fallback mappings `{'param_name': type, ...}` if types cannot be\n        inferred from function signature.\n        Consider using `types=collections.defaultdict(lambda: ast.literal_eval)`.\n    is_method  : bool, optional\n        Whether to use `functools.partialmethod`. If (default: False) use `functools.partial`.\n\n    Examples\n    --------\n    ```\n    $ cat foo.py\n    from tqdm.utils import envwrap\n    @envwrap(\"FOO_\")\n    def test(a=1, b=2, c=3):\n        print(f\"received: a={a}, b={b}, c={c}\")\n\n    $ FOO_A=42 FOO_C=1337 python -c 'import foo; foo.test(c=99)'\n    received: a=42, b=2, c=99\n    ```\n    \"\"\"\n    if types is None:\n        types = {}\n    i = len(prefix)\n    env_overrides = {k[i:].lower(): v for k, v in os.environ.items() if k.startswith(prefix)}\n    part = partialmethod if is_method else partial\n\n    def wrap(func):\n        params = signature(func).parameters\n        # ignore unknown env vars\n        overrides = {k: v for k, v in env_overrides.items() if k in params}\n        # infer overrides' `type`s\n        for k in overrides:\n            param = params[k]\n            if param.annotation is not param.empty:  # typehints\n                for typ in getattr(param.annotation, '__args__', (param.annotation,)):\n                    try:\n                        overrides[k] = typ(overrides[k])\n                    except Exception:\n                        pass\n                    else:\n                        break\n            elif param.default is not None:  # type of default value\n                overrides[k] = type(param.default)(overrides[k])\n            else:\n                try:  # `types` fallback\n                    overrides[k] = types[k](overrides[k])\n                except KeyError:  # keep unconverted (`str`)\n                    pass\n        return part(func, **overrides)\n    return wrap\n\n\nclass FormatReplace(object):\n    \"\"\"\n    >>> a = FormatReplace('something')\n    >>> f\"{a:5d}\"\n    'something'\n    \"\"\"  # NOQA: P102\n    def __init__(self, replace=''):\n        self.replace = replace\n        self.format_called = 0\n\n    def __format__(self, _):\n        self.format_called += 1\n        return self.replace\n\n\nclass Comparable(object):\n    \"\"\"Assumes child has self._comparable attr/@property\"\"\"\n    def __lt__(self, other):\n        return self._comparable < other._comparable\n\n    def __le__(self, other):\n        return (self < other) or (self == other)\n\n    def __eq__(self, other):\n        return self._comparable == other._comparable\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __gt__(self, other):\n        return not self <= other\n\n    def __ge__(self, other):\n        return not self < other\n\n\nclass ObjectWrapper(object):\n    def __getattr__(self, name):\n        return getattr(self._wrapped, name)\n\n    def __setattr__(self, name, value):\n        return setattr(self._wrapped, name, value)\n\n    def wrapper_getattr(self, name):\n        \"\"\"Actual `self.getattr` rather than self._wrapped.getattr\"\"\"\n        try:\n            return object.__getattr__(self, name)\n        except AttributeError:  # py2\n            return getattr(self, name)\n\n    def wrapper_setattr(self, name, value):\n        \"\"\"Actual `self.setattr` rather than self._wrapped.setattr\"\"\"\n        return object.__setattr__(self, name, value)\n\n    def __init__(self, wrapped):\n        \"\"\"\n        Thin wrapper around a given object\n        \"\"\"\n        self.wrapper_setattr('_wrapped', wrapped)\n\n\nclass SimpleTextIOWrapper(ObjectWrapper):\n    \"\"\"\n    Change only `.write()` of the wrapped object by encoding the passed\n    value and passing the result to the wrapped object's `.write()` method.\n    \"\"\"\n    # pylint: disable=too-few-public-methods\n    def __init__(self, wrapped, encoding):\n        super().__init__(wrapped)\n        self.wrapper_setattr('encoding', encoding)\n\n    def write(self, s):\n        \"\"\"\n        Encode `s` and pass to the wrapped object's `.write()` method.\n        \"\"\"\n        return self._wrapped.write(s.encode(self.wrapper_getattr('encoding')))\n\n    def __eq__(self, other):\n        return self._wrapped == getattr(other, '_wrapped', other)\n\n\nclass DisableOnWriteError(ObjectWrapper):\n    \"\"\"\n    Disable the given `tqdm_instance` upon `write()` or `flush()` errors.\n    \"\"\"\n    @staticmethod\n    def disable_on_exception(tqdm_instance, func):\n        \"\"\"\n        Quietly set `tqdm_instance.miniters=inf` if `func` raises `errno=5`.\n        \"\"\"\n        tqdm_instance = proxy(tqdm_instance)\n\n        def inner(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except OSError as e:\n                if e.errno != 5:\n                    raise\n                try:\n                    tqdm_instance.miniters = float('inf')\n                except ReferenceError:\n                    pass\n            except ValueError as e:\n                if 'closed' not in str(e):\n                    raise\n                try:\n                    tqdm_instance.miniters = float('inf')\n                except ReferenceError:\n                    pass\n        return inner\n\n    def __init__(self, wrapped, tqdm_instance):\n        super().__init__(wrapped)\n        if hasattr(wrapped, 'write'):\n            self.wrapper_setattr(\n                'write', self.disable_on_exception(tqdm_instance, wrapped.write))\n        if hasattr(wrapped, 'flush'):\n            self.wrapper_setattr(\n                'flush', self.disable_on_exception(tqdm_instance, wrapped.flush))\n\n    def __eq__(self, other):\n        return self._wrapped == getattr(other, '_wrapped', other)\n\n\nclass CallbackIOWrapper(ObjectWrapper):\n    def __init__(self, callback, stream, method=\"read\"):\n        \"\"\"\n        Wrap a given `file`-like object's `read()` or `write()` to report\n        lengths to the given `callback`\n        \"\"\"\n        super().__init__(stream)\n        func = getattr(stream, method)\n        if method == \"write\":\n            @wraps(func)\n            def write(data, *args, **kwargs):\n                res = func(data, *args, **kwargs)\n                callback(len(data))\n                return res\n            self.wrapper_setattr('write', write)\n        elif method == \"read\":\n            @wraps(func)\n            def read(*args, **kwargs):\n                data = func(*args, **kwargs)\n                callback(len(data))\n                return data\n            self.wrapper_setattr('read', read)\n        else:\n            raise KeyError(\"Can only wrap read/write methods\")\n\n\ndef _is_utf(encoding):\n    try:\n        u'\\u2588\\u2589'.encode(encoding)\n    except UnicodeEncodeError:\n        return False\n    except Exception:\n        try:\n            return encoding.lower().startswith('utf-') or ('U8' == encoding)\n        except Exception:\n            return False\n    else:\n        return True\n\n\ndef _supports_unicode(fp):\n    try:\n        return _is_utf(fp.encoding)\n    except AttributeError:\n        return False\n\n\ndef _is_ascii(s):\n    if isinstance(s, str):\n        for c in s:\n            if ord(c) > 255:\n                return False\n        return True\n    return _supports_unicode(s)\n\n\ndef _screen_shape_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which returns console dimensions (width, height).\n    Supported: linux, osx, windows, cygwin.\n    \"\"\"\n    _screen_shape = None\n    if IS_WIN:\n        _screen_shape = _screen_shape_windows\n        if _screen_shape is None:\n            _screen_shape = _screen_shape_tput\n    if IS_NIX:\n        _screen_shape = _screen_shape_linux\n    return _screen_shape\n\n\ndef _screen_shape_windows(fp):  # pragma: no cover\n    try:\n        import struct\n        from ctypes import create_string_buffer, windll\n        from sys import stdin, stdout\n\n        io_handle = -12  # assume stderr\n        if fp == stdin:\n            io_handle = -10\n        elif fp == stdout:\n            io_handle = -11\n\n        h = windll.kernel32.GetStdHandle(io_handle)\n        csbi = create_string_buffer(22)\n        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n        if res:\n            (_bufx, _bufy, _curx, _cury, _wattr, left, top, right, bottom,\n             _maxx, _maxy) = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n            return right - left, bottom - top  # +1\n    except Exception:  # nosec\n        pass\n    return None, None\n\n\ndef _screen_shape_tput(*_):  # pragma: no cover\n    \"\"\"cygwin xterm (windows)\"\"\"\n    try:\n        import shlex\n        from subprocess import check_call  # nosec\n        return [int(check_call(shlex.split('tput ' + i))) - 1\n                for i in ('cols', 'lines')]\n    except Exception:  # nosec\n        pass\n    return None, None\n\n\ndef _screen_shape_linux(fp):  # pragma: no cover\n\n    try:\n        from array import array\n        from fcntl import ioctl\n        from termios import TIOCGWINSZ\n    except ImportError:\n        return None, None\n    else:\n        try:\n            rows, cols = array('h', ioctl(fp, TIOCGWINSZ, '\\0' * 8))[:2]\n            return cols, rows\n        except Exception:\n            try:\n                return [int(os.environ[i]) - 1 for i in (\"COLUMNS\", \"LINES\")]\n            except (KeyError, ValueError):\n                return None, None\n\n\ndef _environ_cols_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which returns console width.\n    Supported: linux, osx, windows, cygwin.\n    \"\"\"\n    warn(\"Use `_screen_shape_wrapper()(file)[0]` instead of\"\n         \" `_environ_cols_wrapper()(file)`\", DeprecationWarning, stacklevel=2)\n    shape = _screen_shape_wrapper()\n    if not shape:\n        return None\n\n    @wraps(shape)\n    def inner(fp):\n        return shape(fp)[0]\n\n    return inner\n\n\ndef _term_move_up():  # pragma: no cover\n    return '' if (os.name == 'nt') and (colorama is None) else '\\x1b[A'\n\n\ndef _text_width(s):\n    return sum(2 if east_asian_width(ch) in 'FW' else 1 for ch in str(s))\n\n\ndef disp_len(data):\n    \"\"\"\n    Returns the real on-screen length of a string which may contain\n    ANSI control codes and wide chars.\n    \"\"\"\n    return _text_width(RE_ANSI.sub('', data))\n\n\ndef disp_trim(data, length):\n    \"\"\"\n    Trim a string which may contain ANSI control characters.\n    \"\"\"\n    if len(data) == disp_len(data):\n        return data[:length]\n\n    ansi_present = bool(RE_ANSI.search(data))\n    while disp_len(data) > length:  # carefully delete one char at a time\n        data = data[:-1]\n    if ansi_present and bool(RE_ANSI.search(data)):\n        # assume ANSI reset is required\n        return data if data.endswith(\"\\033[0m\") else data + \"\\033[0m\"\n    return data\n", "tqdm/autonotebook.py": "\"\"\"\nAutomatically choose between `tqdm.notebook` and `tqdm.std`.\n\nUsage:\n>>> from tqdm.autonotebook import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport sys\nfrom warnings import warn\n\ntry:\n    get_ipython = sys.modules['IPython'].get_ipython\n    if 'IPKernelApp' not in get_ipython().config:  # pragma: no cover\n        raise ImportError(\"console\")\n    from .notebook import WARN_NOIPYW, IProgress\n    if IProgress is None:\n        from .std import TqdmWarning\n        warn(WARN_NOIPYW, TqdmWarning, stacklevel=2)\n        raise ImportError('ipywidgets')\nexcept Exception:\n    from .std import tqdm, trange\nelse:  # pragma: no cover\n    from .notebook import tqdm, trange\n    from .std import TqdmExperimentalWarning\n    warn(\"Using `tqdm.autonotebook.tqdm` in notebook mode.\"\n         \" Use `tqdm.tqdm` instead to force console mode\"\n         \" (e.g. in jupyter console)\", TqdmExperimentalWarning, stacklevel=2)\n__all__ = [\"tqdm\", \"trange\"]\n", "tqdm/dask.py": "from functools import partial\n\nfrom dask.callbacks import Callback\n\nfrom .auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TqdmCallback']\n\n\nclass TqdmCallback(Callback):\n    \"\"\"Dask callback for task progress.\"\"\"\n    def __init__(self, start=None, pretask=None, tqdm_class=tqdm_auto,\n                 **tqdm_kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        tqdm_class  : optional\n            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].\n        tqdm_kwargs  : optional\n            Any other arguments used for all bars.\n        \"\"\"\n        super().__init__(start=start, pretask=pretask)\n        if tqdm_kwargs:\n            tqdm_class = partial(tqdm_class, **tqdm_kwargs)\n        self.tqdm_class = tqdm_class\n\n    def _start_state(self, _, state):\n        self.pbar = self.tqdm_class(total=sum(\n            len(state[k]) for k in ['ready', 'waiting', 'running', 'finished']))\n\n    def _posttask(self, *_, **__):\n        self.pbar.update()\n\n    def _finish(self, *_, **__):\n        self.pbar.close()\n\n    def display(self):\n        \"\"\"Displays in the current cell in Notebooks.\"\"\"\n        container = getattr(self.bar, 'container', None)\n        if container is None:\n            return\n        from .notebook import display\n        display(container)\n", "tqdm/version.py": "\"\"\"`tqdm` version detector. Precedence: installed dist, git, 'UNKNOWN'.\"\"\"\ntry:\n    from ._dist_ver import __version__\nexcept ImportError:\n    try:\n        from setuptools_scm import get_version\n        __version__ = get_version(root='..', relative_to=__file__)\n    except (ImportError, LookupError):\n        __version__ = \"UNKNOWN\"\n", "tqdm/tk.py": "\"\"\"\nTkinter GUI progressbar decorator for iterators.\n\nUsage:\n>>> from tqdm.tk import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport re\nimport sys\nimport tkinter\nimport tkinter.ttk as ttk\nfrom warnings import warn\n\nfrom .std import TqdmExperimentalWarning, TqdmWarning\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"richardsheridan\", \"casperdcl\"]}\n__all__ = ['tqdm_tk', 'ttkrange', 'tqdm', 'trange']\n\n\nclass tqdm_tk(std_tqdm):  # pragma: no cover\n    \"\"\"\n    Experimental Tkinter GUI version of tqdm!\n\n    Note: Window interactivity suffers if `tqdm_tk` is not running within\n    a Tkinter mainloop and values are generated infrequently. In this case,\n    consider calling `tqdm_tk.refresh()` frequently in the Tk thread.\n    \"\"\"\n\n    # TODO: @classmethod: write()?\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        This class accepts the following parameters *in addition* to\n        the parameters accepted by `tqdm`.\n\n        Parameters\n        ----------\n        grab  : bool, optional\n            Grab the input across all windows of the process.\n        tk_parent  : `tkinter.Wm`, optional\n            Parent Tk window.\n        cancel_callback  : Callable, optional\n            Create a cancel button and set `cancel_callback` to be called\n            when the cancel or window close button is clicked.\n        \"\"\"\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        self._warn_leave = 'leave' in kwargs\n        grab = kwargs.pop('grab', False)\n        tk_parent = kwargs.pop('tk_parent', None)\n        self._cancel_callback = kwargs.pop('cancel_callback', None)\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        if tk_parent is None:  # Discover parent widget\n            try:\n                tk_parent = tkinter._default_root\n            except AttributeError:\n                raise AttributeError(\n                    \"`tk_parent` required when using `tkinter.NoDefaultRoot()`\")\n            if tk_parent is None:  # use new default root window as display\n                self._tk_window = tkinter.Tk()\n            else:  # some other windows already exist\n                self._tk_window = tkinter.Toplevel()\n        else:\n            self._tk_window = tkinter.Toplevel(tk_parent)\n\n        warn(\"GUI is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        self._tk_dispatching = self._tk_dispatching_helper()\n\n        self._tk_window.protocol(\"WM_DELETE_WINDOW\", self.cancel)\n        self._tk_window.wm_title(self.desc)\n        self._tk_window.wm_attributes(\"-topmost\", 1)\n        self._tk_window.after(0, lambda: self._tk_window.wm_attributes(\"-topmost\", 0))\n        self._tk_n_var = tkinter.DoubleVar(self._tk_window, value=0)\n        self._tk_text_var = tkinter.StringVar(self._tk_window)\n        pbar_frame = ttk.Frame(self._tk_window, padding=5)\n        pbar_frame.pack()\n        _tk_label = ttk.Label(pbar_frame, textvariable=self._tk_text_var,\n                              wraplength=600, anchor=\"center\", justify=\"center\")\n        _tk_label.pack()\n        self._tk_pbar = ttk.Progressbar(\n            pbar_frame, variable=self._tk_n_var, length=450)\n        if self.total is not None:\n            self._tk_pbar.configure(maximum=self.total)\n        else:\n            self._tk_pbar.configure(mode=\"indeterminate\")\n        self._tk_pbar.pack()\n        if self._cancel_callback is not None:\n            _tk_button = ttk.Button(pbar_frame, text=\"Cancel\", command=self.cancel)\n            _tk_button.pack()\n        if grab:\n            self._tk_window.grab_set()\n\n    def close(self):\n        if self.disable:\n            return\n\n        self.disable = True\n\n        with self.get_lock():\n            self._instances.remove(self)\n\n        def _close():\n            self._tk_window.after('idle', self._tk_window.destroy)\n            if not self._tk_dispatching:\n                self._tk_window.update()\n\n        self._tk_window.protocol(\"WM_DELETE_WINDOW\", _close)\n\n        # if leave is set but we are self-dispatching, the left window is\n        # totally unresponsive unless the user manually dispatches\n        if not self.leave:\n            _close()\n        elif not self._tk_dispatching:\n            if self._warn_leave:\n                warn(\"leave flag ignored if not in tkinter mainloop\",\n                     TqdmWarning, stacklevel=2)\n            _close()\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        self._tk_n_var.set(self.n)\n        d = self.format_dict\n        # remove {bar}\n        d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n            \"{bar}\", \"<bar/>\")\n        msg = self.format_meter(**d)\n        if '<bar/>' in msg:\n            msg = \"\".join(re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n        self._tk_text_var.set(msg)\n        if not self._tk_dispatching:\n            self._tk_window.update()\n\n    def set_description(self, desc=None, refresh=True):\n        self.set_description_str(desc, refresh)\n\n    def set_description_str(self, desc=None, refresh=True):\n        self.desc = desc\n        if not self.disable:\n            self._tk_window.wm_title(desc)\n            if refresh and not self._tk_dispatching:\n                self._tk_window.update()\n\n    def cancel(self):\n        \"\"\"\n        `cancel_callback()` followed by `close()`\n        when close/cancel buttons clicked.\n        \"\"\"\n        if self._cancel_callback is not None:\n            self._cancel_callback()\n        self.close()\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if hasattr(self, '_tk_pbar'):\n            if total is None:\n                self._tk_pbar.configure(maximum=100, mode=\"indeterminate\")\n            else:\n                self._tk_pbar.configure(maximum=total, mode=\"determinate\")\n        super().reset(total=total)\n\n    @staticmethod\n    def _tk_dispatching_helper():\n        \"\"\"determine if Tkinter mainloop is dispatching events\"\"\"\n        codes = {tkinter.mainloop.__code__, tkinter.Misc.mainloop.__code__}\n        for frame in sys._current_frames().values():\n            while frame:\n                if frame.f_code in codes:\n                    return True\n                frame = frame.f_back\n        return False\n\n\ndef ttkrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.tk.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_tk(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_tk\ntrange = ttkrange\n", "tqdm/_monitor.py": "import atexit\nfrom threading import Event, Thread, current_thread\nfrom time import time\nfrom warnings import warn\n\n__all__ = [\"TMonitor\", \"TqdmSynchronisationWarning\"]\n\n\nclass TqdmSynchronisationWarning(RuntimeWarning):\n    \"\"\"tqdm multi-thread/-process errors which may cause incorrect nesting\n    but otherwise no adverse effects\"\"\"\n    pass\n\n\nclass TMonitor(Thread):\n    \"\"\"\n    Monitoring thread for tqdm bars.\n    Monitors if tqdm bars are taking too much time to display\n    and readjusts miniters automatically if necessary.\n\n    Parameters\n    ----------\n    tqdm_cls  : class\n        tqdm class to use (can be core tqdm or a submodule).\n    sleep_interval  : float\n        Time to sleep between monitoring checks.\n    \"\"\"\n    _test = {}  # internal vars for unit testing\n\n    def __init__(self, tqdm_cls, sleep_interval):\n        Thread.__init__(self)\n        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)\n        self.woken = 0  # last time woken up, to sync with monitor\n        self.tqdm_cls = tqdm_cls\n        self.sleep_interval = sleep_interval\n        self._time = self._test.get(\"time\", time)\n        self.was_killed = self._test.get(\"Event\", Event)()\n        atexit.register(self.exit)\n        self.start()\n\n    def exit(self):\n        self.was_killed.set()\n        if self is not current_thread():\n            self.join()\n        return self.report()\n\n    def get_instances(self):\n        # returns a copy of started `tqdm_cls` instances\n        return [i for i in self.tqdm_cls._instances.copy()\n                # Avoid race by checking that the instance started\n                if hasattr(i, 'start_t')]\n\n    def run(self):\n        cur_t = self._time()\n        while True:\n            # After processing and before sleeping, notify that we woke\n            # Need to be done just before sleeping\n            self.woken = cur_t\n            # Sleep some time...\n            self.was_killed.wait(self.sleep_interval)\n            # Quit if killed\n            if self.was_killed.is_set():\n                return\n            # Then monitor!\n            # Acquire lock (to access _instances)\n            with self.tqdm_cls.get_lock():\n                cur_t = self._time()\n                # Check tqdm instances are waiting too long to print\n                instances = self.get_instances()\n                for instance in instances:\n                    # Check event in loop to reduce blocking time on exit\n                    if self.was_killed.is_set():\n                        return\n                    # Only if mininterval > 1 (else iterations are just slow)\n                    # and last refresh exceeded maxinterval\n                    if (\n                        instance.miniters > 1\n                        and (cur_t - instance.last_print_t) >= instance.maxinterval\n                    ):\n                        # force bypassing miniters on next iteration\n                        # (dynamic_miniters adjusts mininterval automatically)\n                        instance.miniters = 1\n                        # Refresh now! (works only for manual tqdm)\n                        instance.refresh(nolock=True)\n                    # Remove accidental long-lived strong reference\n                    del instance\n                if instances != self.get_instances():  # pragma: nocover\n                    warn(\"Set changed size during iteration\" +\n                         \" (see https://github.com/tqdm/tqdm/issues/481)\",\n                         TqdmSynchronisationWarning, stacklevel=2)\n                # Remove accidental long-lived strong references\n                del instances\n\n    def report(self):\n        return not self.was_killed.is_set()\n", "tqdm/_utils.py": "from warnings import warn\n\nfrom .std import TqdmDeprecationWarning\nfrom .utils import (  # NOQA, pylint: disable=unused-import\n    CUR_OS, IS_NIX, IS_WIN, RE_ANSI, Comparable, FormatReplace, SimpleTextIOWrapper,\n    _environ_cols_wrapper, _is_ascii, _is_utf, _screen_shape_linux, _screen_shape_tput,\n    _screen_shape_windows, _screen_shape_wrapper, _supports_unicode, _term_move_up, colorama)\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.utils.*` instead of `tqdm._utils.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/keras.py": "from copy import copy\nfrom functools import partial\n\nfrom .auto import tqdm as tqdm_auto\n\ntry:\n    import keras\nexcept (ImportError, AttributeError) as e:\n    try:\n        from tensorflow import keras\n    except ImportError:\n        raise e\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TqdmCallback']\n\n\nclass TqdmCallback(keras.callbacks.Callback):\n    \"\"\"Keras callback for epoch and batch progress.\"\"\"\n    @staticmethod\n    def bar2callback(bar, pop=None, delta=(lambda logs: 1)):\n        def callback(_, logs=None):\n            n = delta(logs)\n            if logs:\n                if pop:\n                    logs = copy(logs)\n                    [logs.pop(i, 0) for i in pop]\n                bar.set_postfix(logs, refresh=False)\n            bar.update(n)\n\n        return callback\n\n    def __init__(self, epochs=None, data_size=None, batch_size=None, verbose=1,\n                 tqdm_class=tqdm_auto, **tqdm_kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        epochs  : int, optional\n        data_size  : int, optional\n            Number of training pairs.\n        batch_size  : int, optional\n            Number of training pairs per batch.\n        verbose  : int\n            0: epoch, 1: batch (transient), 2: batch. [default: 1].\n            Will be set to `0` unless both `data_size` and `batch_size`\n            are given.\n        tqdm_class  : optional\n            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].\n        tqdm_kwargs  : optional\n            Any other arguments used for all bars.\n        \"\"\"\n        if tqdm_kwargs:\n            tqdm_class = partial(tqdm_class, **tqdm_kwargs)\n        self.tqdm_class = tqdm_class\n        self.epoch_bar = tqdm_class(total=epochs, unit='epoch')\n        self.on_epoch_end = self.bar2callback(self.epoch_bar)\n        if data_size and batch_size:\n            self.batches = batches = (data_size + batch_size - 1) // batch_size\n        else:\n            self.batches = batches = None\n        self.verbose = verbose\n        if verbose == 1:\n            self.batch_bar = tqdm_class(total=batches, unit='batch', leave=False)\n            self.on_batch_end = self.bar2callback(\n                self.batch_bar, pop=['batch', 'size'],\n                delta=lambda logs: logs.get('size', 1))\n\n    def on_train_begin(self, *_, **__):\n        params = self.params.get\n        auto_total = params('epochs', params('nb_epoch', None))\n        if auto_total is not None and auto_total != self.epoch_bar.total:\n            self.epoch_bar.reset(total=auto_total)\n\n    def on_epoch_begin(self, epoch, *_, **__):\n        if self.epoch_bar.n < epoch:\n            ebar = self.epoch_bar\n            ebar.n = ebar.last_print_n = ebar.initial = epoch\n        if self.verbose:\n            params = self.params.get\n            total = params('samples', params(\n                'nb_sample', params('steps', None))) or self.batches\n            if self.verbose == 2:\n                if hasattr(self, 'batch_bar'):\n                    self.batch_bar.close()\n                self.batch_bar = self.tqdm_class(\n                    total=total, unit='batch', leave=True,\n                    unit_scale=1 / (params('batch_size', 1) or 1))\n                self.on_batch_end = self.bar2callback(\n                    self.batch_bar, pop=['batch', 'size'],\n                    delta=lambda logs: logs.get('size', 1))\n            elif self.verbose == 1:\n                self.batch_bar.unit_scale = 1 / (params('batch_size', 1) or 1)\n                self.batch_bar.reset(total=total)\n            else:\n                raise KeyError('Unknown verbosity')\n\n    def on_train_end(self, *_, **__):\n        if hasattr(self, 'batch_bar'):\n            self.batch_bar.close()\n        self.epoch_bar.close()\n\n    def display(self):\n        \"\"\"Displays in the current cell in Notebooks.\"\"\"\n        container = getattr(self.epoch_bar, 'container', None)\n        if container is None:\n            return\n        from .notebook import display\n        display(container)\n        batch_bar = getattr(self, 'batch_bar', None)\n        if batch_bar is not None:\n            display(batch_bar.container)\n\n    @staticmethod\n    def _implements_train_batch_hooks():\n        return True\n\n    @staticmethod\n    def _implements_test_batch_hooks():\n        return True\n\n    @staticmethod\n    def _implements_predict_batch_hooks():\n        return True\n", "tqdm/__main__.py": "from .cli import main\n\nmain()\n", "tqdm/gui.py": "\"\"\"\nMatplotlib GUI progressbar decorator for iterators.\n\nUsage:\n>>> from tqdm.gui import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\n# future division is important to divide integers and get as\n# a result precise floating numbers (instead of truncated int)\nimport re\nfrom warnings import warn\n\n# to inherit from the tqdm class\nfrom .std import TqdmExperimentalWarning\nfrom .std import tqdm as std_tqdm\n\n# import compatibility functions and utilities\n\n__author__ = {\"github.com/\": [\"casperdcl\", \"lrq3000\"]}\n__all__ = ['tqdm_gui', 'tgrange', 'tqdm', 'trange']\n\n\nclass tqdm_gui(std_tqdm):  # pragma: no cover\n    \"\"\"Experimental Matplotlib GUI version of tqdm!\"\"\"\n    # TODO: @classmethod: write() on GUI?\n    def __init__(self, *args, **kwargs):\n        from collections import deque\n\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        colour = kwargs.pop('colour', 'g')\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        warn(\"GUI is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        self.mpl = mpl\n        self.plt = plt\n\n        # Remember if external environment uses toolbars\n        self.toolbar = self.mpl.rcParams['toolbar']\n        self.mpl.rcParams['toolbar'] = 'None'\n\n        self.mininterval = max(self.mininterval, 0.5)\n        self.fig, ax = plt.subplots(figsize=(9, 2.2))\n        # self.fig.subplots_adjust(bottom=0.2)\n        total = self.__len__()  # avoids TypeError on None #971\n        if total is not None:\n            self.xdata = []\n            self.ydata = []\n            self.zdata = []\n        else:\n            self.xdata = deque([])\n            self.ydata = deque([])\n            self.zdata = deque([])\n        self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n        self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n        ax.set_ylim(0, 0.001)\n        if total is not None:\n            ax.set_xlim(0, 100)\n            ax.set_xlabel(\"percent\")\n            self.fig.legend((self.line1, self.line2), (\"cur\", \"est\"),\n                            loc='center right')\n            # progressbar\n            self.hspan = plt.axhspan(0, 0.001, xmin=0, xmax=0, color=colour)\n        else:\n            # ax.set_xlim(-60, 0)\n            ax.set_xlim(0, 60)\n            ax.invert_xaxis()\n            ax.set_xlabel(\"seconds\")\n            ax.legend((\"cur\", \"est\"), loc='lower left')\n        ax.grid()\n        # ax.set_xlabel('seconds')\n        ax.set_ylabel((self.unit if self.unit else \"it\") + \"/s\")\n        if self.unit_scale:\n            plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))\n            ax.yaxis.get_offset_text().set_x(-0.15)\n\n        # Remember if external environment is interactive\n        self.wasion = plt.isinteractive()\n        plt.ion()\n        self.ax = ax\n\n    def close(self):\n        if self.disable:\n            return\n\n        self.disable = True\n\n        with self.get_lock():\n            self._instances.remove(self)\n\n        # Restore toolbars\n        self.mpl.rcParams['toolbar'] = self.toolbar\n        # Return to non-interactive mode\n        if not self.wasion:\n            self.plt.ioff()\n        if self.leave:\n            self.display()\n        else:\n            self.plt.close(self.fig)\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        n = self.n\n        cur_t = self._time()\n        elapsed = cur_t - self.start_t\n        delta_it = n - self.last_print_n\n        delta_t = cur_t - self.last_print_t\n\n        # Inline due to multiple calls\n        total = self.total\n        xdata = self.xdata\n        ydata = self.ydata\n        zdata = self.zdata\n        ax = self.ax\n        line1 = self.line1\n        line2 = self.line2\n        # instantaneous rate\n        y = delta_it / delta_t\n        # overall rate\n        z = n / elapsed\n        # update line data\n        xdata.append(n * 100.0 / total if total else cur_t)\n        ydata.append(y)\n        zdata.append(z)\n\n        # Discard old values\n        # xmin, xmax = ax.get_xlim()\n        # if (not total) and elapsed > xmin * 1.1:\n        if (not total) and elapsed > 66:\n            xdata.popleft()\n            ydata.popleft()\n            zdata.popleft()\n\n        ymin, ymax = ax.get_ylim()\n        if y > ymax or z > ymax:\n            ymax = 1.1 * y\n            ax.set_ylim(ymin, ymax)\n            ax.figure.canvas.draw()\n\n        if total:\n            line1.set_data(xdata, ydata)\n            line2.set_data(xdata, zdata)\n            try:\n                poly_lims = self.hspan.get_xy()\n            except AttributeError:\n                self.hspan = self.plt.axhspan(0, 0.001, xmin=0, xmax=0, color='g')\n                poly_lims = self.hspan.get_xy()\n            poly_lims[0, 1] = ymin\n            poly_lims[1, 1] = ymax\n            poly_lims[2] = [n / total, ymax]\n            poly_lims[3] = [poly_lims[2, 0], ymin]\n            if len(poly_lims) > 4:\n                poly_lims[4, 1] = ymin\n            self.hspan.set_xy(poly_lims)\n        else:\n            t_ago = [cur_t - i for i in xdata]\n            line1.set_data(t_ago, ydata)\n            line2.set_data(t_ago, zdata)\n\n        d = self.format_dict\n        # remove {bar}\n        d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n            \"{bar}\", \"<bar/>\")\n        msg = self.format_meter(**d)\n        if '<bar/>' in msg:\n            msg = \"\".join(re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n        ax.set_title(msg, fontname=\"DejaVu Sans Mono\", fontsize=11)\n        self.plt.pause(1e-9)\n\n\ndef tgrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.gui.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_gui(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_gui\ntrange = tgrange\n", "tqdm/_tqdm_gui.py": "from warnings import warn\n\nfrom .gui import *  # NOQA\nfrom .gui import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.gui.*` instead of `tqdm._tqdm_gui.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/__init__.py": "from ._monitor import TMonitor, TqdmSynchronisationWarning\nfrom ._tqdm_pandas import tqdm_pandas\nfrom .cli import main  # TODO: remove in v5.0.0\nfrom .gui import tqdm as tqdm_gui  # TODO: remove in v5.0.0\nfrom .gui import trange as tgrange  # TODO: remove in v5.0.0\nfrom .std import (\n    TqdmDeprecationWarning, TqdmExperimentalWarning, TqdmKeyError, TqdmMonitorWarning,\n    TqdmTypeError, TqdmWarning, tqdm, trange)\nfrom .version import __version__\n\n__all__ = ['tqdm', 'tqdm_gui', 'trange', 'tgrange', 'tqdm_pandas',\n           'tqdm_notebook', 'tnrange', 'main', 'TMonitor',\n           'TqdmTypeError', 'TqdmKeyError',\n           'TqdmWarning', 'TqdmDeprecationWarning',\n           'TqdmExperimentalWarning',\n           'TqdmMonitorWarning', 'TqdmSynchronisationWarning',\n           '__version__']\n\n\ndef tqdm_notebook(*args, **kwargs):  # pragma: no cover\n    \"\"\"See tqdm.notebook.tqdm for full documentation\"\"\"\n    from warnings import warn\n\n    from .notebook import tqdm as _tqdm_notebook\n    warn(\"This function will be removed in tqdm==5.0.0\\n\"\n         \"Please use `tqdm.notebook.tqdm` instead of `tqdm.tqdm_notebook`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tqdm_notebook(*args, **kwargs)\n\n\ndef tnrange(*args, **kwargs):  # pragma: no cover\n    \"\"\"Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`.\"\"\"\n    from warnings import warn\n\n    from .notebook import trange as _tnrange\n    warn(\"Please use `tqdm.notebook.trange` instead of `tqdm.tnrange`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tnrange(*args, **kwargs)\n", "tqdm/rich.py": "\"\"\"\n`rich.progress` decorator for iterators.\n\nUsage:\n>>> from tqdm.rich import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nfrom warnings import warn\n\nfrom rich.progress import (\n    BarColumn, Progress, ProgressColumn, Text, TimeElapsedColumn, TimeRemainingColumn, filesize)\n\nfrom .std import TqdmExperimentalWarning\nfrom .std import tqdm as std_tqdm\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tqdm_rich', 'trrange', 'tqdm', 'trange']\n\n\nclass FractionColumn(ProgressColumn):\n    \"\"\"Renders completed/total, e.g. '0.5/2.3 G'.\"\"\"\n    def __init__(self, unit_scale=False, unit_divisor=1000):\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        super().__init__()\n\n    def render(self, task):\n        \"\"\"Calculate common unit for completed and total.\"\"\"\n        completed = int(task.completed)\n        total = int(task.total)\n        if self.unit_scale:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                total,\n                [\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"],\n                self.unit_divisor,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(total, [\"\"], 1)\n        precision = 0 if unit == 1 else 1\n        return Text(\n            f\"{completed/unit:,.{precision}f}/{total/unit:,.{precision}f} {suffix}\",\n            style=\"progress.download\")\n\n\nclass RateColumn(ProgressColumn):\n    \"\"\"Renders human readable transfer speed.\"\"\"\n    def __init__(self, unit=\"\", unit_scale=False, unit_divisor=1000):\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        super().__init__()\n\n    def render(self, task):\n        \"\"\"Show data transfer speed.\"\"\"\n        speed = task.speed\n        if speed is None:\n            return Text(f\"? {self.unit}/s\", style=\"progress.data.speed\")\n        if self.unit_scale:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                speed,\n                [\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"],\n                self.unit_divisor,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(speed, [\"\"], 1)\n        precision = 0 if unit == 1 else 1\n        return Text(f\"{speed/unit:,.{precision}f} {suffix}{self.unit}/s\",\n                    style=\"progress.data.speed\")\n\n\nclass tqdm_rich(std_tqdm):  # pragma: no cover\n    \"\"\"Experimental rich.progress GUI version of tqdm!\"\"\"\n    # TODO: @classmethod: write()?\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        This class accepts the following parameters *in addition* to\n        the parameters accepted by `tqdm`.\n\n        Parameters\n        ----------\n        progress  : tuple, optional\n            arguments for `rich.progress.Progress()`.\n        options  : dict, optional\n            keyword arguments for `rich.progress.Progress()`.\n        \"\"\"\n        kwargs = kwargs.copy()\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        progress = kwargs.pop('progress', None)\n        options = kwargs.pop('options', {}).copy()\n        super().__init__(*args, **kwargs)\n\n        if self.disable:\n            return\n\n        warn(\"rich is experimental/alpha\", TqdmExperimentalWarning, stacklevel=2)\n        d = self.format_dict\n        if progress is None:\n            progress = (\n                \"[progress.description]{task.description}\"\n                \"[progress.percentage]{task.percentage:>4.0f}%\",\n                BarColumn(bar_width=None),\n                FractionColumn(\n                    unit_scale=d['unit_scale'], unit_divisor=d['unit_divisor']),\n                \"[\", TimeElapsedColumn(), \"<\", TimeRemainingColumn(),\n                \",\", RateColumn(unit=d['unit'], unit_scale=d['unit_scale'],\n                                unit_divisor=d['unit_divisor']), \"]\"\n            )\n        options.setdefault('transient', not self.leave)\n        self._prog = Progress(*progress, **options)\n        self._prog.__enter__()\n        self._task_id = self._prog.add_task(self.desc or \"\", **d)\n\n    def close(self):\n        if self.disable:\n            return\n        self.display()  # print 100%, vis #1306\n        super().close()\n        self._prog.__exit__(None, None, None)\n\n    def clear(self, *_, **__):\n        pass\n\n    def display(self, *_, **__):\n        if not hasattr(self, '_prog'):\n            return\n        self._prog.update(self._task_id, completed=self.n, description=self.desc)\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if hasattr(self, '_prog'):\n            self._prog.reset(total=total)\n        super().reset(total=total)\n\n\ndef trrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.rich.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_rich(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_rich\ntrange = trrange\n", "tqdm/_main.py": "from warnings import warn\n\nfrom .cli import *  # NOQA\nfrom .cli import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.cli.*` instead of `tqdm._main.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/_tqdm_notebook.py": "from warnings import warn\n\nfrom .notebook import *  # NOQA\nfrom .notebook import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.notebook.*` instead of `tqdm._tqdm_notebook.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/std.py": "\"\"\"\nCustomisable progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\nimport sys\nfrom collections import OrderedDict, defaultdict\nfrom contextlib import contextmanager\nfrom datetime import datetime, timedelta, timezone\nfrom numbers import Number\nfrom time import time\nfrom warnings import warn\nfrom weakref import WeakSet\n\nfrom ._monitor import TMonitor\nfrom .utils import (\n    CallbackIOWrapper, Comparable, DisableOnWriteError, FormatReplace, SimpleTextIOWrapper,\n    _is_ascii, _screen_shape_wrapper, _supports_unicode, _term_move_up, disp_len, disp_trim,\n    envwrap)\n\n__author__ = \"https://github.com/tqdm/tqdm#contributions\"\n__all__ = ['tqdm', 'trange',\n           'TqdmTypeError', 'TqdmKeyError', 'TqdmWarning',\n           'TqdmExperimentalWarning', 'TqdmDeprecationWarning',\n           'TqdmMonitorWarning']\n\n\nclass TqdmTypeError(TypeError):\n    pass\n\n\nclass TqdmKeyError(KeyError):\n    pass\n\n\nclass TqdmWarning(Warning):\n    \"\"\"base class for all tqdm warnings.\n\n    Used for non-external-code-breaking errors, such as garbled printing.\n    \"\"\"\n    def __init__(self, msg, fp_write=None, *a, **k):\n        if fp_write is not None:\n            fp_write(\"\\n\" + self.__class__.__name__ + \": \" + str(msg).rstrip() + '\\n')\n        else:\n            super().__init__(msg, *a, **k)\n\n\nclass TqdmExperimentalWarning(TqdmWarning, FutureWarning):\n    \"\"\"beta feature, unstable API and behaviour\"\"\"\n    pass\n\n\nclass TqdmDeprecationWarning(TqdmWarning, DeprecationWarning):\n    # not suppressed if raised\n    pass\n\n\nclass TqdmMonitorWarning(TqdmWarning, RuntimeWarning):\n    \"\"\"tqdm monitor errors which do not affect external functionality\"\"\"\n    pass\n\n\ndef TRLock(*args, **kwargs):\n    \"\"\"threading RLock\"\"\"\n    try:\n        from threading import RLock\n        return RLock(*args, **kwargs)\n    except (ImportError, OSError):  # pragma: no cover\n        pass\n\n\nclass TqdmDefaultWriteLock(object):\n    \"\"\"\n    Provide a default write lock for thread and multiprocessing safety.\n    Works only on platforms supporting `fork` (so Windows is excluded).\n    You must initialise a `tqdm` or `TqdmDefaultWriteLock` instance\n    before forking in order for the write lock to work.\n    On Windows, you need to supply the lock from the parent to the children as\n    an argument to joblib or the parallelism lib you use.\n    \"\"\"\n    # global thread lock so no setup required for multithreading.\n    # NB: Do not create multiprocessing lock as it sets the multiprocessing\n    # context, disallowing `spawn()`/`forkserver()`\n    th_lock = TRLock()\n\n    def __init__(self):\n        # Create global parallelism locks to avoid racing issues with parallel\n        # bars works only if fork available (Linux/MacOSX, but not Windows)\n        cls = type(self)\n        root_lock = cls.th_lock\n        if root_lock is not None:\n            root_lock.acquire()\n        cls.create_mp_lock()\n        self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]\n        if root_lock is not None:\n            root_lock.release()\n\n    def acquire(self, *a, **k):\n        for lock in self.locks:\n            lock.acquire(*a, **k)\n\n    def release(self):\n        for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n            lock.release()\n\n    def __enter__(self):\n        self.acquire()\n\n    def __exit__(self, *exc):\n        self.release()\n\n    @classmethod\n    def create_mp_lock(cls):\n        if not hasattr(cls, 'mp_lock'):\n            try:\n                from multiprocessing import RLock\n                cls.mp_lock = RLock()\n            except (ImportError, OSError):  # pragma: no cover\n                cls.mp_lock = None\n\n    @classmethod\n    def create_th_lock(cls):\n        assert hasattr(cls, 'th_lock')\n        warn(\"create_th_lock not needed anymore\", TqdmDeprecationWarning, stacklevel=2)\n\n\nclass Bar(object):\n    \"\"\"\n    `str.format`-able bar with format specifiers: `[width][type]`\n\n    - `width`\n      + unspecified (default): use `self.default_len`\n      + `int >= 0`: overrides `self.default_len`\n      + `int < 0`: subtract from `self.default_len`\n    - `type`\n      + `a`: ascii (`charset=self.ASCII` override)\n      + `u`: unicode (`charset=self.UTF` override)\n      + `b`: blank (`charset=\"  \"` override)\n    \"\"\"\n    ASCII = \" 123456789#\"\n    UTF = u\" \" + u''.join(map(chr, range(0x258F, 0x2587, -1)))\n    BLANK = \"  \"\n    COLOUR_RESET = '\\x1b[0m'\n    COLOUR_RGB = '\\x1b[38;2;%d;%d;%dm'\n    COLOURS = {'BLACK': '\\x1b[30m', 'RED': '\\x1b[31m', 'GREEN': '\\x1b[32m',\n               'YELLOW': '\\x1b[33m', 'BLUE': '\\x1b[34m', 'MAGENTA': '\\x1b[35m',\n               'CYAN': '\\x1b[36m', 'WHITE': '\\x1b[37m'}\n\n    def __init__(self, frac, default_len=10, charset=UTF, colour=None):\n        if not 0 <= frac <= 1:\n            warn(\"clamping frac to range [0, 1]\", TqdmWarning, stacklevel=2)\n            frac = max(0, min(1, frac))\n        assert default_len > 0\n        self.frac = frac\n        self.default_len = default_len\n        self.charset = charset\n        self.colour = colour\n\n    @property\n    def colour(self):\n        return self._colour\n\n    @colour.setter\n    def colour(self, value):\n        if not value:\n            self._colour = None\n            return\n        try:\n            if value.upper() in self.COLOURS:\n                self._colour = self.COLOURS[value.upper()]\n            elif value[0] == '#' and len(value) == 7:\n                self._colour = self.COLOUR_RGB % tuple(\n                    int(i, 16) for i in (value[1:3], value[3:5], value[5:7]))\n            else:\n                raise KeyError\n        except (KeyError, AttributeError):\n            warn(\"Unknown colour (%s); valid choices: [hex (#00ff00), %s]\" % (\n                 value, \", \".join(self.COLOURS)),\n                 TqdmWarning, stacklevel=2)\n            self._colour = None\n\n    def __format__(self, format_spec):\n        if format_spec:\n            _type = format_spec[-1].lower()\n            try:\n                charset = {'a': self.ASCII, 'u': self.UTF, 'b': self.BLANK}[_type]\n            except KeyError:\n                charset = self.charset\n            else:\n                format_spec = format_spec[:-1]\n            if format_spec:\n                N_BARS = int(format_spec)\n                if N_BARS < 0:\n                    N_BARS += self.default_len\n            else:\n                N_BARS = self.default_len\n        else:\n            charset = self.charset\n            N_BARS = self.default_len\n\n        nsyms = len(charset) - 1\n        bar_length, frac_bar_length = divmod(int(self.frac * N_BARS * nsyms), nsyms)\n\n        res = charset[-1] * bar_length\n        if bar_length < N_BARS:  # whitespace padding\n            res = res + charset[frac_bar_length] + charset[0] * (N_BARS - bar_length - 1)\n        return self.colour + res + self.COLOUR_RESET if self.colour else res\n\n\nclass EMA(object):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    smoothing  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields old value) to 1 (yields new value).\n    \"\"\"\n    def __init__(self, smoothing=0.3):\n        self.alpha = smoothing\n        self.last = 0\n        self.calls = 0\n\n    def __call__(self, x=None):\n        \"\"\"\n        Parameters\n        ----------\n        x  : float\n            New value to include in EMA.\n        \"\"\"\n        beta = 1 - self.alpha\n        if x is not None:\n            self.last = self.alpha * x + beta * self.last\n            self.calls += 1\n        return self.last / (1 - beta ** self.calls) if self.calls else self.last\n\n\nclass tqdm(Comparable):\n    \"\"\"\n    Decorate an iterable object, returning an iterator which acts exactly\n    like the original iterable, but prints a dynamically updating\n    progressbar every time a value is requested.\n\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int or float, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive number,\n        e.g. 9e9.\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n        If `None`, will leave only if `position` is `0`.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.  For encoding, see `write_bytes`.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int or float, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool or str, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters \" 123456789#\".\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` and `nrows` to the\n        environment (allowing for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n            '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n            percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,\n            rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n            rate_inv, rate_inv_fmt, postfix, unit_divisor,\n            remaining, remaining_s, eta.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int or float, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0]. If using float, consider specifying `{n:.3f}`\n        or similar in `bar_format`, or specifying `unit_scale`.\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    write_bytes  : bool, optional\n        Whether to write bytes. If (default: False) will write unicode.\n    lock_args  : tuple, optional\n        Passed to `refresh` for intermediate output\n        (initialisation, iterating, and updating).\n    nrows  : int, optional\n        The screen height. If specified, hides nested bars outside this\n        bound. If unspecified, attempts to use environment height.\n        The fallback is 20.\n    colour  : str, optional\n        Bar colour (e.g. 'green', '#00ff00').\n    delay  : float, optional\n        Don't display until [default: 0] seconds have elapsed.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm.gui.tqdm(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    monitor_interval = 10  # set to 0 to disable the thread\n    monitor = None\n    _instances = WeakSet()\n\n    @staticmethod\n    def format_sizeof(num, suffix='', divisor=1000):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n        divisor  : float, optional\n            Divisor between prefixes [default: 1000].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.5:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return f'{num:1.2f}{unit}{suffix}'\n                    return f'{num:2.1f}{unit}{suffix}'\n                return f'{num:3.0f}{unit}{suffix}'\n            num /= divisor\n        return f'{num:3.1f}Y{suffix}'\n\n    @staticmethod\n    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        return f'{h:d}:{m:02d}:{s:02d}' if h else f'{m:02d}:{s:02d}'\n\n    @staticmethod\n    def format_num(n):\n        \"\"\"\n        Intelligent scientific notation (.3g).\n\n        Parameters\n        ----------\n        n  : int or float or Numeric\n            A Number.\n\n        Returns\n        -------\n        out  : str\n            Formatted number.\n        \"\"\"\n        f = f'{n:.3g}'.replace('e+0', 'e+').replace('e-0', 'e-')\n        n = str(n)\n        return f if len(f) < len(n) else n\n\n    @staticmethod\n    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n        if fp in (sys.stderr, sys.stdout):\n            getattr(sys.stderr, 'flush', lambda: None)()\n            getattr(sys.stdout, 'flush', lambda: None)()\n\n        def fp_write(s):\n            fp.write(str(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = disp_len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n\n        return print_status\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it',\n                     unit_scale=False, rate=None, bar_format=None, postfix=None,\n                     unit_divisor=1000, initial=0, colour=None, **extra_kwargs):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int or float\n            Number of finished iterations.\n        total  : int or float\n            The expected total number of iterations. If meaningless (None),\n            only basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes `{bar}` to stay within this bound\n            [default: None]. If `0`, will not print any bar (only stats).\n            The fallback is `{bar:10}`.\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n            Use as {desc} in bar_format string.\n        ascii  : bool, optional or str, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            \" 123456789#\".\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be printed with an\n            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n            [default: False]. If any other non-zero number, will scale\n            `total` and `n`.\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,\n              rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, postfix, unit_divisor,\n              remaining, remaining_s, eta.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        postfix  : *, optional\n            Similar to `prefix`, but placed at the end\n            (e.g. for additional stats).\n            Note: postfix is usually a string (not a dict) for this method,\n            and will if possible be set to postfix = ', ' + postfix.\n            However other types are supported (#382).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n        initial  : int or float, optional\n            The initial counter value [default: 0].\n        colour  : str, optional\n            Bar colour (e.g. 'green', '#00ff00').\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n >= (total + 0.5):  # allow float imprecision (#849)\n            total = None\n\n        # apply custom scale if necessary\n        if unit_scale and unit_scale not in (True, 1):\n            if total:\n                total *= unit_scale\n            n *= unit_scale\n            if rate:\n                rate *= unit_scale  # by default rate = self.avg_dn / self.avg_dt\n            unit_scale = False\n\n        elapsed_str = tqdm.format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = (n - initial) / elapsed\n        inv_rate = 1 / rate if rate else None\n        format_sizeof = tqdm.format_sizeof\n        rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else f'{rate:5.2f}')\n                          if rate else '?') + unit + '/s'\n        rate_inv_fmt = (\n            (format_sizeof(inv_rate) if unit_scale else f'{inv_rate:5.2f}')\n            if inv_rate else '?') + 's/' + unit\n        rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n        if unit_scale:\n            n_fmt = format_sizeof(n, divisor=unit_divisor)\n            total_fmt = format_sizeof(total, divisor=unit_divisor) if total is not None else '?'\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total) if total is not None else '?'\n\n        try:\n            postfix = ', ' + postfix if postfix else ''\n        except TypeError:\n            pass\n\n        remaining = (total - n) / rate if rate and total else 0\n        remaining_str = tqdm.format_interval(remaining) if rate else '?'\n        try:\n            eta_dt = (datetime.now() + timedelta(seconds=remaining)\n                      if rate and total else datetime.fromtimestamp(0, timezone.utc))\n        except OverflowError:\n            eta_dt = datetime.max\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n\n        r_bar = f'| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}{postfix}]'\n\n        # Custom bar formatting\n        # Populate a dict with all available progress indicators\n        format_dict = {\n            # slight extension of self.format_dict\n            'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt,\n            'elapsed': elapsed_str, 'elapsed_s': elapsed,\n            'ncols': ncols, 'desc': prefix or '', 'unit': unit,\n            'rate': inv_rate if inv_rate and inv_rate > 1 else rate,\n            'rate_fmt': rate_fmt, 'rate_noinv': rate,\n            'rate_noinv_fmt': rate_noinv_fmt, 'rate_inv': inv_rate,\n            'rate_inv_fmt': rate_inv_fmt,\n            'postfix': postfix, 'unit_divisor': unit_divisor,\n            'colour': colour,\n            # plus more useful definitions\n            'remaining': remaining_str, 'remaining_s': remaining,\n            'l_bar': l_bar, 'r_bar': r_bar, 'eta': eta_dt,\n            **extra_kwargs}\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            l_bar += f'{percentage:3.0f}%|'\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            format_dict.update(l_bar=l_bar)\n            if bar_format:\n                format_dict.update(percentage=percentage)\n\n                # auto-remove colon for empty `{desc}`\n                if not prefix:\n                    bar_format = bar_format.replace(\"{desc}: \", '')\n            else:\n                bar_format = \"{l_bar}{bar}{r_bar}\"\n\n            full_bar = FormatReplace()\n            nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                return nobar  # no `{bar}`; nothing else to do\n\n            # Formatting progress bar space available for bar's display\n            full_bar = Bar(frac,\n                           max(1, ncols - disp_len(nobar)) if ncols else 10,\n                           charset=Bar.ASCII if ascii is True else ascii or Bar.UTF,\n                           colour=colour)\n            if not _is_ascii(full_bar.charset) and _is_ascii(bar_format):\n                bar_format = str(bar_format)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            return disp_trim(res, ncols) if ncols else res\n\n        elif bar_format:\n            # user-specified bar_format but no total\n            l_bar += '|'\n            format_dict.update(l_bar=l_bar, percentage=0)\n            full_bar = FormatReplace()\n            nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                return nobar\n            full_bar = Bar(0,\n                           max(1, ncols - disp_len(nobar)) if ncols else 10,\n                           charset=Bar.BLANK, colour=colour)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            return disp_trim(res, ncols) if ncols else res\n        else:\n            # no total: no progressbar, ETA, just progress stats\n            return (f'{(prefix + \": \") if prefix else \"\"}'\n                    f'{n_fmt}{unit} [{elapsed_str}, {rate_fmt}{postfix}]')\n\n    def __new__(cls, *_, **__):\n        instance = object.__new__(cls)\n        with cls.get_lock():  # also constructs lock if non-existent\n            cls._instances.add(instance)\n            # create monitoring thread\n            if cls.monitor_interval and (cls.monitor is None\n                                         or not cls.monitor.report()):\n                try:\n                    cls.monitor = TMonitor(cls, cls.monitor_interval)\n                except Exception as e:  # pragma: nocover\n                    warn(\"tqdm:disabling monitor support\"\n                         \" (monitor_interval = 0) due to:\\n\" + str(e),\n                         TqdmMonitorWarning, stacklevel=2)\n                    cls.monitor_interval = 0\n        return instance\n\n    @classmethod\n    def _get_free_pos(cls, instance=None):\n        \"\"\"Skips specified instance.\"\"\"\n        positions = {abs(inst.pos) for inst in cls._instances\n                     if inst is not instance and hasattr(inst, \"pos\")}\n        return min(set(range(len(positions) + 1)).difference(positions))\n\n    @classmethod\n    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition another unfixed bar\n        to fill the new gap.\n\n        This means that by default (where all nested bars are unfixed),\n        order is not maintained but screen flicker/blank space is minimised.\n        (tqdm<=4.44.1 moved ALL subsequent unfixed bars up.)\n        \"\"\"\n        with cls._lock:\n            try:\n                cls._instances.remove(instance)\n            except KeyError:\n                # if not instance.gui:  # pragma: no cover\n                #     raise\n                pass  # py2: maybe magically removed already\n            # else:\n            if not instance.gui:\n                last = (instance.nrows or 20) - 1\n                # find unfixed (`pos >= 0`) overflow (`pos >= nrows - 1`)\n                instances = list(filter(\n                    lambda i: hasattr(i, \"pos\") and last <= i.pos,\n                    cls._instances))\n                # set first found to current `pos`\n                if instances:\n                    inst = min(instances, key=lambda i: i.pos)\n                    inst.clear(nolock=True)\n                    inst.pos = abs(instance.pos)\n\n    @classmethod\n    def write(cls, s, file=None, end=\"\\n\", nolock=False):\n        \"\"\"Print a message via tqdm (without overlap with bars).\"\"\"\n        fp = file if file is not None else sys.stdout\n        with cls.external_write_mode(file=file, nolock=nolock):\n            # Write the message\n            fp.write(s)\n            fp.write(end)\n\n    @classmethod\n    @contextmanager\n    def external_write_mode(cls, file=None, nolock=False):\n        \"\"\"\n        Disable tqdm within context and refresh tqdm when exits.\n        Useful when writing to standard output stream\n        \"\"\"\n        fp = file if file is not None else sys.stdout\n\n        try:\n            if not nolock:\n                cls.get_lock().acquire()\n            # Clear all bars\n            inst_cleared = []\n            for inst in getattr(cls, '_instances', []):\n                # Clear instance if in the target output file\n                # or if write output + tqdm output are both either\n                # sys.stdout or sys.stderr (because both are mixed in terminal)\n                if hasattr(inst, \"start_t\") and (inst.fp == fp or all(\n                        f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n                    inst.clear(nolock=True)\n                    inst_cleared.append(inst)\n            yield\n            # Force refresh display of bars we cleared\n            for inst in inst_cleared:\n                inst.refresh(nolock=True)\n        finally:\n            if not nolock:\n                cls._lock.release()\n\n    @classmethod\n    def set_lock(cls, lock):\n        \"\"\"Set the global lock.\"\"\"\n        cls._lock = lock\n\n    @classmethod\n    def get_lock(cls):\n        \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n        if not hasattr(cls, '_lock'):\n            cls._lock = TqdmDefaultWriteLock()\n        return cls._lock\n\n    @classmethod\n    def pandas(cls, **tqdm_kwargs):\n        \"\"\"\n        Registers the current `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.(generic.)DataFrameGroupBy\n            | groupby.(generic.)SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be created every time `progress_apply` is called,\n        and each instance will automatically `close()` upon completion.\n\n        Parameters\n        ----------\n        tqdm_kwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm\n        >>> from tqdm.gui import tqdm as tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        <https://stackoverflow.com/questions/18603270/\\\n        progress-indicator-during-pandas-operations-python>\n        \"\"\"\n        from warnings import catch_warnings, simplefilter\n\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        try:\n            with catch_warnings():\n                simplefilter(\"ignore\", category=FutureWarning)\n                from pandas import Panel\n        except ImportError:  # pandas>=1.2.0\n            Panel = None\n        Rolling, Expanding = None, None\n        try:  # pandas>=1.0.0\n            from pandas.core.window.rolling import _Rolling_and_Expanding\n        except ImportError:\n            try:  # pandas>=0.18.0\n                from pandas.core.window import _Rolling_and_Expanding\n            except ImportError:  # pandas>=1.2.0\n                try:  # pandas>=1.2.0\n                    from pandas.core.window.expanding import Expanding\n                    from pandas.core.window.rolling import Rolling\n                    _Rolling_and_Expanding = Rolling, Expanding\n                except ImportError:  # pragma: no cover\n                    _Rolling_and_Expanding = None\n        try:  # pandas>=0.25.0\n            from pandas.core.groupby.generic import SeriesGroupBy  # , NDFrameGroupBy\n            from pandas.core.groupby.generic import DataFrameGroupBy\n        except ImportError:  # pragma: no cover\n            try:  # pandas>=0.23.0\n                from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy\n            except ImportError:\n                from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import GroupBy\n        except ImportError:  # pragma: no cover\n            from pandas.core.groupby import GroupBy\n\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import PanelGroupBy\n        except ImportError:\n            try:\n                from pandas.core.groupby import PanelGroupBy\n            except ImportError:  # pandas>=0.25.0\n                PanelGroupBy = None\n\n        tqdm_kwargs = tqdm_kwargs.copy()\n        deprecated_t = [tqdm_kwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                **kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n\n                # Precompute total iterations\n                total = tqdm_kwargs.pop(\"total\", getattr(df, 'ngroups', None))\n                if total is None:  # not grouped\n                    if df_function == 'applymap':\n                        total = df.size\n                    elif isinstance(df, Series):\n                        total = len(df)\n                    elif (_Rolling_and_Expanding is None or\n                          not isinstance(df, _Rolling_and_Expanding)):\n                        # DataFrame or Panel\n                        axis = kwargs.get('axis', 0)\n                        if axis == 'index':\n                            axis = 0\n                        elif axis == 'columns':\n                            axis = 1\n                        # when axis=0, total is shape[axis1]\n                        total = df.size // df.shape[axis]\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = cls(total=total, **tqdm_kwargs)\n\n                if len(args) > 0:\n                    # *args intentionally not supported (see #244, #299)\n                    TqdmDeprecationWarning(\n                        \"Except func, normal arguments are intentionally\" +\n                        \" not supported by\" +\n                        \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                        \" Use keyword arguments instead.\",\n                        fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n                try:  # pandas>=1.3.0\n                    from pandas.core.common import is_builtin_func\n                except ImportError:\n                    is_builtin_func = df._is_builtin_func\n                try:\n                    func = is_builtin_func(func)\n                except TypeError:\n                    pass\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    # update tbar correctly\n                    # it seems `pandas apply` calls `func` twice\n                    # on the first column/row to decide whether it can\n                    # take a fast or slow code path; so stop when t.total==t.n\n                    t.update(n=1 if not t.total or t.n < t.total else 0)\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                try:\n                    return getattr(df, df_function)(wrapper, **kwargs)\n                finally:\n                    t.close()\n\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n        DataFrame.progress_map = inner_generator('map')\n        DataFrameGroupBy.progress_map = inner_generator('map')\n\n        if Panel is not None:\n            Panel.progress_apply = inner_generator()\n        if PanelGroupBy is not None:\n            PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n        if Rolling is not None and Expanding is not None:\n            Rolling.progress_apply = inner_generator()\n            Expanding.progress_apply = inner_generator()\n        elif _Rolling_and_Expanding is not None:\n            _Rolling_and_Expanding.progress_apply = inner_generator()\n\n    # override defaults via env vars\n    @envwrap(\"TQDM_\", is_method=True, types={'total': float, 'ncols': int, 'miniters': float,\n                                             'position': int, 'nrows': int})\n    def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None,\n                 ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None,\n                 ascii=None, disable=False, unit='it', unit_scale=False,\n                 dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0,\n                 position=None, postfix=None, unit_divisor=1000, write_bytes=False,\n                 lock_args=None, nrows=None, colour=None, delay=0.0, gui=False,\n                 **kwargs):\n        \"\"\"see tqdm.tqdm for arguments\"\"\"\n        if file is None:\n            file = sys.stderr\n\n        if write_bytes:\n            # Despite coercing unicode into bytes, py2 sys.std* streams\n            # should have bytes written to them.\n            file = SimpleTextIOWrapper(\n                file, encoding=getattr(file, 'encoding', None) or 'utf-8')\n\n        file = DisableOnWriteError(file, tqdm_instance=self)\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n        if total == float(\"inf\"):\n            # Infinite iterations, behave same as unknown\n            total = None\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            self.n = initial\n            self.total = total\n            self.leave = leave\n            return\n\n        if kwargs:\n            self.disable = True\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            raise (\n                TqdmDeprecationWarning(\n                    \"`nested` is deprecated and automated.\\n\"\n                    \"Use `position` instead for manual control.\\n\",\n                    fp_write=getattr(file, 'write', sys.stderr.write))\n                if \"nested\" in kwargs else\n                TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if (\n            (ncols is None or nrows is None) and (file in (sys.stderr, sys.stdout))\n        ) or dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _screen_shape_wrapper()\n                if dynamic_ncols:\n                    ncols, nrows = dynamic_ncols(file)\n            else:\n                _dynamic_ncols = _screen_shape_wrapper()\n                if _dynamic_ncols:\n                    _ncols, _nrows = _dynamic_ncols(file)\n                    if ncols is None:\n                        ncols = _ncols\n                    if nrows is None:\n                        nrows = _nrows\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and ascii is not True and not _is_ascii(ascii):\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = str(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.nrows = nrows\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.initial = initial\n        self.lock_args = lock_args\n        self.delay = delay\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self._ema_dn = EMA(smoothing)\n        self._ema_dt = EMA(smoothing)\n        self._ema_miniters = EMA(smoothing)\n        self.bar_format = bar_format\n        self.postfix = None\n        self.colour = colour\n        self._time = time\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        with self._lock:\n            # mark fixed positions as negative\n            self.pos = self._get_free_pos(self) if position is None else -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if delay <= 0:\n                self.refresh(lock_args=self.lock_args)\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n\n    def __bool__(self):\n        if self.total is not None:\n            return self.total > 0\n        if self.iterable is None:\n            raise TypeError('bool() undefined when iterable == total == None')\n        return bool(self.iterable)\n\n    def __len__(self):\n        return (\n            self.total if self.iterable is None\n            else self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n            else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n            else self.iterable.__length_hint__() if hasattr(self.iterable, \"__length_hint__\")\n            else getattr(self, \"total\", None))\n\n    def __reversed__(self):\n        try:\n            orig = self.iterable\n        except AttributeError:\n            raise TypeError(\"'tqdm' object is not reversible\")\n        else:\n            self.iterable = reversed(self.iterable)\n            return self.__iter__()\n        finally:\n            self.iterable = orig\n\n    def __contains__(self, item):\n        contains = getattr(self.iterable, '__contains__', None)\n        return contains(item) if contains is not None else item in self.__iter__()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        try:\n            self.close()\n        except AttributeError:\n            # maybe eager thread cleanup upon external error\n            if (exc_type, exc_value, traceback) == (None, None, None):\n                raise\n            warn(\"AttributeError ignored\", TqdmWarning, stacklevel=2)\n\n    def __del__(self):\n        self.close()\n\n    def __str__(self):\n        return self.format_meter(**self.format_dict)\n\n    @property\n    def _comparable(self):\n        return abs(getattr(self, \"pos\", 1 << 31))\n\n    def __hash__(self):\n        return id(self)\n\n    def __iter__(self):\n        \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n            return\n\n        mininterval = self.mininterval\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        min_start_t = self.start_t + self.delay\n        n = self.n\n        time = self._time\n\n        try:\n            for obj in iterable:\n                yield obj\n                # Update and possibly print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n\n                if n - last_print_n >= self.miniters:\n                    cur_t = time()\n                    dt = cur_t - last_print_t\n                    if dt >= mininterval and cur_t >= min_start_t:\n                        self.update(n - last_print_n)\n                        last_print_n = self.last_print_n\n                        last_print_t = self.last_print_t\n        finally:\n            self.n = n\n            self.close()\n\n    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int or float, optional\n            Increment to add to the internal counter of iterations\n            [default: 1]. If using float, consider specifying `{n:.3f}`\n            or similar in `bar_format`, or specifying `unit_scale`.\n\n        Returns\n        -------\n        out  : bool or None\n            True if a `display()` was triggered.\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            self.last_print_n += n  # for auto-refresh logic to work\n        self.n += n\n\n        # check counter first to reduce calls to time()\n        if self.n - self.last_print_n >= self.miniters:\n            cur_t = self._time()\n            dt = cur_t - self.last_print_t\n            if dt >= self.mininterval and cur_t >= self.start_t + self.delay:\n                cur_t = self._time()\n                dn = self.n - self.last_print_n  # >= n\n                if self.smoothing and dt and dn:\n                    # EMA (not just overall average)\n                    self._ema_dn(dn)\n                    self._ema_dt(dt)\n                self.refresh(lock_args=self.lock_args)\n                if self.dynamic_miniters:\n                    # If no `miniters` was specified, adjust automatically to the\n                    # maximum iteration rate seen so far between two prints.\n                    # e.g.: After running `tqdm.update(5)`, subsequent\n                    # calls to `tqdm.update()` will only cause an update after\n                    # at least 5 more iterations.\n                    if self.maxinterval and dt >= self.maxinterval:\n                        self.miniters = dn * (self.mininterval or self.maxinterval) / dt\n                    elif self.smoothing:\n                        # EMA miniters update\n                        self.miniters = self._ema_miniters(\n                            dn * (self.mininterval / dt if self.mininterval and dt\n                                  else 1))\n                    else:\n                        # max iters between two prints\n                        self.miniters = max(self.miniters, dn)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t\n                return True\n\n    def close(self):\n        \"\"\"Cleanup and (if leave=False) close the progressbar.\"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = abs(self.pos)\n        self._decr_instances(self)\n\n        if self.last_print_t < self.start_t + self.delay:\n            # haven't ever displayed; nothing to clear\n            return\n\n        # GUI mode\n        if getattr(self, 'sp', None) is None:\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(str(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        leave = pos == 0 if self.leave is None else self.leave\n\n        with self._lock:\n            if leave:\n                # stats for overall rate (no weighted average)\n                self._ema_dt = lambda: None\n                self.display(pos=0)\n                fp_write('\\n')\n            else:\n                # clear previous display\n                if self.display(msg='', pos=pos) and not pos:\n                    fp_write('\\r')\n\n    def clear(self, nolock=False):\n        \"\"\"Clear current bar display.\"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            self._lock.acquire()\n        pos = abs(self.pos)\n        if pos < (self.nrows or 20):\n            self.moveto(pos)\n            self.sp('')\n            self.fp.write('\\r')  # place cursor back at the beginning of line\n            self.moveto(-pos)\n        if not nolock:\n            self._lock.release()\n\n    def refresh(self, nolock=False, lock_args=None):\n        \"\"\"\n        Force refresh the display of this bar.\n\n        Parameters\n        ----------\n        nolock  : bool, optional\n            If `True`, does not lock.\n            If [default: `False`]: calls `acquire()` on internal lock.\n        lock_args  : tuple, optional\n            Passed to internal lock's `acquire()`.\n            If specified, will only `display()` if `acquire()` returns `True`.\n        \"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            if lock_args:\n                if not self._lock.acquire(*lock_args):\n                    return False\n            else:\n                self._lock.acquire()\n        self.display()\n        if not nolock:\n            self._lock.release()\n        return True\n\n    def unpause(self):\n        \"\"\"Restart tqdm timer from last print time.\"\"\"\n        if self.disable:\n            return\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Consider combining with `leave=True`.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        self.n = 0\n        if total is not None:\n            self.total = total\n        if self.disable:\n            return\n        self.last_print_n = 0\n        self.last_print_t = self.start_t = self._time()\n        self._ema_dn = EMA(self.smoothing)\n        self._ema_dt = EMA(self.smoothing)\n        self._ema_miniters = EMA(self.smoothing)\n        self.refresh()\n\n    def set_description(self, desc=None, refresh=True):\n        \"\"\"\n        Set/modify description of the progress bar.\n\n        Parameters\n        ----------\n        desc  : str, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n        if refresh:\n            self.refresh()\n\n    def set_description_str(self, desc=None, refresh=True):\n        \"\"\"Set/modify description without ': ' appended.\"\"\"\n        self.desc = desc or ''\n        if refresh:\n            self.refresh()\n\n    def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n        \"\"\"\n        Set/modify postfix (additional stats)\n        with automatic formatting based on datatype.\n\n        Parameters\n        ----------\n        ordered_dict  : dict or OrderedDict, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        kwargs  : dict, optional\n        \"\"\"\n        # Sort in alphabetical order to be more deterministic\n        postfix = OrderedDict([] if ordered_dict is None else ordered_dict)\n        for key in sorted(kwargs.keys()):\n            postfix[key] = kwargs[key]\n        # Preprocess stats according to datatype\n        for key in postfix.keys():\n            # Number: limit the length of the string\n            if isinstance(postfix[key], Number):\n                postfix[key] = self.format_num(postfix[key])\n            # Else for any other type, try to get the string conversion\n            elif not isinstance(postfix[key], str):\n                postfix[key] = str(postfix[key])\n            # Else if it's a string, don't need to preprocess anything\n        # Stitch together to get the final postfix\n        self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                                 for key in postfix.keys())\n        if refresh:\n            self.refresh()\n\n    def set_postfix_str(self, s='', refresh=True):\n        \"\"\"\n        Postfix without dictionary expansion, similar to prefix handling.\n        \"\"\"\n        self.postfix = str(s)\n        if refresh:\n            self.refresh()\n\n    def moveto(self, n):\n        # TODO: private method\n        self.fp.write('\\n' * n + _term_move_up() * -n)\n        getattr(self.fp, 'flush', lambda: None)()\n\n    @property\n    def format_dict(self):\n        \"\"\"Public API for read-only member access.\"\"\"\n        if self.disable and not hasattr(self, 'unit'):\n            return defaultdict(lambda: None, {\n                'n': self.n, 'total': self.total, 'elapsed': 0, 'unit': 'it'})\n        if self.dynamic_ncols:\n            self.ncols, self.nrows = self.dynamic_ncols(self.fp)\n        return {\n            'n': self.n, 'total': self.total,\n            'elapsed': self._time() - self.start_t if hasattr(self, 'start_t') else 0,\n            'ncols': self.ncols, 'nrows': self.nrows, 'prefix': self.desc,\n            'ascii': self.ascii, 'unit': self.unit, 'unit_scale': self.unit_scale,\n            'rate': self._ema_dn() / self._ema_dt() if self._ema_dt() else None,\n            'bar_format': self.bar_format, 'postfix': self.postfix,\n            'unit_divisor': self.unit_divisor, 'initial': self.initial,\n            'colour': self.colour}\n\n    def display(self, msg=None, pos=None):\n        \"\"\"\n        Use `self.sp` to display `msg` in the specified `pos`.\n\n        Consider overloading this function when inheriting to use e.g.:\n        `self.some_frontend(**self.format_dict)` instead of `self.sp`.\n\n        Parameters\n        ----------\n        msg  : str, optional. What to display (default: `repr(self)`).\n        pos  : int, optional. Position to `moveto`\n          (default: `abs(self.pos)`).\n        \"\"\"\n        if pos is None:\n            pos = abs(self.pos)\n\n        nrows = self.nrows or 20\n        if pos >= nrows - 1:\n            if pos >= nrows:\n                return False\n            if msg or msg is None:  # override at `nrows - 1`\n                msg = \" ... (more hidden) ...\"\n\n        if not hasattr(self, \"sp\"):\n            raise TqdmDeprecationWarning(\n                \"Please use `tqdm.gui.tqdm(...)`\"\n                \" instead of `tqdm(..., gui=True)`\\n\",\n                fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n        if pos:\n            self.moveto(pos)\n        self.sp(self.__str__() if msg is None else msg)\n        if pos:\n            self.moveto(-pos)\n        return True\n\n    @classmethod\n    @contextmanager\n    def wrapattr(cls, stream, method, total=None, bytes=True, **tqdm_kwargs):\n        \"\"\"\n        stream  : file-like object.\n        method  : str, \"read\" or \"write\". The result of `read()` and\n            the first argument of `write()` should have a `len()`.\n\n        >>> with tqdm.wrapattr(file_obj, \"read\", total=file_obj.size) as fobj:\n        ...     while True:\n        ...         chunk = fobj.read(chunk_size)\n        ...         if not chunk:\n        ...             break\n        \"\"\"\n        with cls(total=total, **tqdm_kwargs) as t:\n            if bytes:\n                t.unit = \"B\"\n                t.unit_scale = True\n                t.unit_divisor = 1024\n            yield CallbackIOWrapper(t.update, stream, method)\n\n\ndef trange(*args, **kwargs):\n    \"\"\"Shortcut for tqdm(range(*args), **kwargs).\"\"\"\n    return tqdm(range(*args), **kwargs)\n", "tqdm/_tqdm.py": "from warnings import warn\n\nfrom .std import *  # NOQA\nfrom .std import __all__  # NOQA\nfrom .std import TqdmDeprecationWarning\n\nwarn(\"This function will be removed in tqdm==5.0.0\\n\"\n     \"Please use `tqdm.std.*` instead of `tqdm._tqdm.*`\",\n     TqdmDeprecationWarning, stacklevel=2)\n", "tqdm/notebook.py": "\"\"\"\nIPython/Jupyter Notebook progressbar decorator for iterators.\nIncludes a default `range` iterator printing to `stderr`.\n\nUsage:\n>>> from tqdm.notebook import trange, tqdm\n>>> for i in trange(10):\n...     ...\n\"\"\"\n# import compatibility functions and utilities\nimport re\nimport sys\nfrom html import escape\nfrom weakref import proxy\n\n# to inherit from the tqdm class\nfrom .std import tqdm as std_tqdm\n\nif True:  # pragma: no cover\n    # import IPython/Jupyter base widget and display utilities\n    IPY = 0\n    try:  # IPython 4.x\n        import ipywidgets\n        IPY = 4\n    except ImportError:  # IPython 3.x / 2.x\n        IPY = 32\n        import warnings\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                'ignore', message=\".*The `IPython.html` package has been deprecated.*\")\n            try:\n                import IPython.html.widgets as ipywidgets  # NOQA: F401\n            except ImportError:\n                pass\n\n    try:  # IPython 4.x / 3.x\n        if IPY == 32:\n            from IPython.html.widgets import HTML\n            from IPython.html.widgets import FloatProgress as IProgress\n            from IPython.html.widgets import HBox\n            IPY = 3\n        else:\n            from ipywidgets import HTML\n            from ipywidgets import FloatProgress as IProgress\n            from ipywidgets import HBox\n    except ImportError:\n        try:  # IPython 2.x\n            from IPython.html.widgets import HTML\n            from IPython.html.widgets import ContainerWidget as HBox\n            from IPython.html.widgets import FloatProgressWidget as IProgress\n            IPY = 2\n        except ImportError:\n            IPY = 0\n            IProgress = None\n            HBox = object\n\n    try:\n        from IPython.display import display  # , clear_output\n    except ImportError:\n        pass\n\n__author__ = {\"github.com/\": [\"lrq3000\", \"casperdcl\", \"alexanderkuk\"]}\n__all__ = ['tqdm_notebook', 'tnrange', 'tqdm', 'trange']\nWARN_NOIPYW = (\"IProgress not found. Please update jupyter and ipywidgets.\"\n               \" See https://ipywidgets.readthedocs.io/en/stable\"\n               \"/user_install.html\")\n\n\nclass TqdmHBox(HBox):\n    \"\"\"`ipywidgets.HBox` with a pretty representation\"\"\"\n    def _json_(self, pretty=None):\n        pbar = getattr(self, 'pbar', None)\n        if pbar is None:\n            return {}\n        d = pbar.format_dict\n        if pretty is not None:\n            d[\"ascii\"] = not pretty\n        return d\n\n    def __repr__(self, pretty=False):\n        pbar = getattr(self, 'pbar', None)\n        if pbar is None:\n            return super().__repr__()\n        return pbar.format_meter(**self._json_(pretty))\n\n    def _repr_pretty_(self, pp, *_, **__):\n        pp.text(self.__repr__(True))\n\n\nclass tqdm_notebook(std_tqdm):\n    \"\"\"\n    Experimental IPython/Jupyter Notebook widget using tqdm!\n    \"\"\"\n    @staticmethod\n    def status_printer(_, total=None, desc=None, ncols=None):\n        \"\"\"\n        Manage the printing of an IPython/Jupyter Notebook progress bar widget.\n        \"\"\"\n        # Fallback to text bar if there's no total\n        # DEPRECATED: replaced with an 'info' style bar\n        # if not total:\n        #    return super(tqdm_notebook, tqdm_notebook).status_printer(file)\n\n        # fp = file\n\n        # Prepare IPython progress bar\n        if IProgress is None:  # #187 #451 #558 #872\n            raise ImportError(WARN_NOIPYW)\n        if total:\n            pbar = IProgress(min=0, max=total)\n        else:  # No total? Show info style bar with no progress tqdm status\n            pbar = IProgress(min=0, max=1)\n            pbar.value = 1\n            pbar.bar_style = 'info'\n            if ncols is None:\n                pbar.layout.width = \"20px\"\n\n        ltext = HTML()\n        rtext = HTML()\n        if desc:\n            ltext.value = desc\n        container = TqdmHBox(children=[ltext, pbar, rtext])\n        # Prepare layout\n        if ncols is not None:  # use default style of ipywidgets\n            # ncols could be 100, \"100px\", \"100%\"\n            ncols = str(ncols)  # ipywidgets only accepts string\n            try:\n                if int(ncols) > 0:  # isnumeric and positive\n                    ncols += 'px'\n            except ValueError:\n                pass\n            pbar.layout.flex = '2'\n            container.layout.width = ncols\n            container.layout.display = 'inline-flex'\n            container.layout.flex_flow = 'row wrap'\n\n        return container\n\n    def display(self, msg=None, pos=None,\n                # additional signals\n                close=False, bar_style=None, check_delay=True):\n        # Note: contrary to native tqdm, msg='' does NOT clear bar\n        # goal is to keep all infos if error happens so user knows\n        # at which iteration the loop failed.\n\n        # Clear previous output (really necessary?)\n        # clear_output(wait=1)\n\n        if not msg and not close:\n            d = self.format_dict\n            # remove {bar}\n            d['bar_format'] = (d['bar_format'] or \"{l_bar}<bar/>{r_bar}\").replace(\n                \"{bar}\", \"<bar/>\")\n            msg = self.format_meter(**d)\n\n        ltext, pbar, rtext = self.container.children\n        pbar.value = self.n\n\n        if msg:\n            msg = msg.replace(' ', u'\\u2007')  # fix html space padding\n            # html escape special characters (like '&')\n            if '<bar/>' in msg:\n                left, right = map(escape, re.split(r'\\|?<bar/>\\|?', msg, maxsplit=1))\n            else:\n                left, right = '', escape(msg)\n\n            # Update description\n            ltext.value = left\n            # never clear the bar (signal: msg='')\n            if right:\n                rtext.value = right\n\n        # Change bar style\n        if bar_style:\n            # Hack-ish way to avoid the danger bar_style being overridden by\n            # success because the bar gets closed after the error...\n            if pbar.bar_style != 'danger' or bar_style != 'success':\n                pbar.bar_style = bar_style\n\n        # Special signal to close the bar\n        if close and pbar.bar_style != 'danger':  # hide only if no error\n            try:\n                self.container.close()\n            except AttributeError:\n                self.container.visible = False\n            self.container.layout.visibility = 'hidden'  # IPYW>=8\n\n        if check_delay and self.delay > 0 and not self.displayed:\n            display(self.container)\n            self.displayed = True\n\n    @property\n    def colour(self):\n        if hasattr(self, 'container'):\n            return self.container.children[-2].style.bar_color\n\n    @colour.setter\n    def colour(self, bar_color):\n        if hasattr(self, 'container'):\n            self.container.children[-2].style.bar_color = bar_color\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Supports the usual `tqdm.tqdm` parameters as well as those listed below.\n\n        Parameters\n        ----------\n        display  : Whether to call `display(self.container)` immediately\n            [default: True].\n        \"\"\"\n        kwargs = kwargs.copy()\n        # Setup default output\n        file_kwarg = kwargs.get('file', sys.stderr)\n        if file_kwarg is sys.stderr or file_kwarg is None:\n            kwargs['file'] = sys.stdout  # avoid the red block in IPython\n\n        # Initialize parent class + avoid printing by using gui=True\n        kwargs['gui'] = True\n        # convert disable = None to False\n        kwargs['disable'] = bool(kwargs.get('disable', False))\n        colour = kwargs.pop('colour', None)\n        display_here = kwargs.pop('display', True)\n        super().__init__(*args, **kwargs)\n        if self.disable or not kwargs['gui']:\n            self.disp = lambda *_, **__: None\n            return\n\n        # Get bar width\n        self.ncols = '100%' if self.dynamic_ncols else kwargs.get(\"ncols\", None)\n\n        # Replace with IPython progress bar display (with correct total)\n        unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1\n        total = self.total * unit_scale if self.total else self.total\n        self.container = self.status_printer(self.fp, total, self.desc, self.ncols)\n        self.container.pbar = proxy(self)\n        self.displayed = False\n        if display_here and self.delay <= 0:\n            display(self.container)\n            self.displayed = True\n        self.disp = self.display\n        self.colour = colour\n\n        # Print initial bar state\n        if not self.disable:\n            self.display(check_delay=False)\n\n    def __iter__(self):\n        try:\n            it = super().__iter__()\n            for obj in it:\n                # return super(tqdm...) will not catch exception\n                yield obj\n        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt\n        except:  # NOQA\n            self.disp(bar_style='danger')\n            raise\n        # NB: don't `finally: close()`\n        # since this could be a shared bar which the user will `reset()`\n\n    def update(self, n=1):\n        try:\n            return super().update(n=n)\n        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt\n        except:  # NOQA\n            # cannot catch KeyboardInterrupt when using manual tqdm\n            # as the interrupt will most likely happen on another statement\n            self.disp(bar_style='danger')\n            raise\n        # NB: don't `finally: close()`\n        # since this could be a shared bar which the user will `reset()`\n\n    def close(self):\n        if self.disable:\n            return\n        super().close()\n        # Try to detect if there was an error or KeyboardInterrupt\n        # in manual mode: if n < total, things probably got wrong\n        if self.total and self.n < self.total:\n            self.disp(bar_style='danger', check_delay=False)\n        else:\n            if self.leave:\n                self.disp(bar_style='success', check_delay=False)\n            else:\n                self.disp(close=True, check_delay=False)\n\n    def clear(self, *_, **__):\n        pass\n\n    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Consider combining with `leave=True`.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        if self.disable:\n            return super().reset(total=total)\n        _, pbar, _ = self.container.children\n        pbar.bar_style = ''\n        if total is not None:\n            pbar.max = total\n            if not self.total and self.ncols is None:  # no longer unknown total\n                pbar.layout.width = None  # reset width\n        return super().reset(total=total)\n\n\ndef tnrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_notebook(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_notebook\ntrange = tnrange\n", "tqdm/_tqdm_pandas.py": "import sys\n\n__author__ = \"github.com/casperdcl\"\n__all__ = ['tqdm_pandas']\n\n\ndef tqdm_pandas(tclass, **tqdm_kwargs):\n    \"\"\"\n    Registers the given `tqdm` instance with\n    `pandas.core.groupby.DataFrameGroupBy.progress_apply`.\n    \"\"\"\n    from tqdm import TqdmDeprecationWarning\n\n    if isinstance(tclass, type) or (getattr(tclass, '__name__', '').startswith(\n            'tqdm_')):  # delayed adapter case\n        TqdmDeprecationWarning(\n            \"Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm, ...)`.\",\n            fp_write=getattr(tqdm_kwargs.get('file', None), 'write', sys.stderr.write))\n        tclass.pandas(**tqdm_kwargs)\n    else:\n        TqdmDeprecationWarning(\n            \"Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm(...))`.\",\n            fp_write=getattr(tclass.fp, 'write', sys.stderr.write))\n        type(tclass).pandas(deprecated_t=tclass)\n", "tqdm/contrib/logging.py": "\"\"\"\nHelper functionality for interoperability with stdlib `logging`.\n\"\"\"\nimport logging\nimport sys\nfrom contextlib import contextmanager\n\ntry:\n    from typing import Iterator, List, Optional, Type  # noqa: F401\nexcept ImportError:\n    pass\n\nfrom ..std import tqdm as std_tqdm\n\n\nclass _TqdmLoggingHandler(logging.StreamHandler):\n    def __init__(\n        self,\n        tqdm_class=std_tqdm  # type: Type[std_tqdm]\n    ):\n        super().__init__()\n        self.tqdm_class = tqdm_class\n\n    def emit(self, record):\n        try:\n            msg = self.format(record)\n            self.tqdm_class.write(msg, file=self.stream)\n            self.flush()\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except:  # noqa pylint: disable=bare-except\n            self.handleError(record)\n\n\ndef _is_console_logging_handler(handler):\n    return (isinstance(handler, logging.StreamHandler)\n            and handler.stream in {sys.stdout, sys.stderr})\n\n\ndef _get_first_found_console_logging_handler(handlers):\n    for handler in handlers:\n        if _is_console_logging_handler(handler):\n            return handler\n\n\n@contextmanager\ndef logging_redirect_tqdm(\n    loggers=None,  # type: Optional[List[logging.Logger]],\n    tqdm_class=std_tqdm  # type: Type[std_tqdm]\n):\n    # type: (...) -> Iterator[None]\n    \"\"\"\n    Context manager redirecting console logging to `tqdm.write()`, leaving\n    other logging handlers (e.g. log files) unaffected.\n\n    Parameters\n    ----------\n    loggers  : list, optional\n      Which handlers to redirect (default: [logging.root]).\n    tqdm_class  : optional\n\n    Example\n    -------\n    ```python\n    import logging\n    from tqdm import trange\n    from tqdm.contrib.logging import logging_redirect_tqdm\n\n    LOG = logging.getLogger(__name__)\n\n    if __name__ == '__main__':\n        logging.basicConfig(level=logging.INFO)\n        with logging_redirect_tqdm():\n            for i in trange(9):\n                if i == 4:\n                    LOG.info(\"console logging redirected to `tqdm.write()`\")\n        # logging restored\n    ```\n    \"\"\"\n    if loggers is None:\n        loggers = [logging.root]\n    original_handlers_list = [logger.handlers for logger in loggers]\n    try:\n        for logger in loggers:\n            tqdm_handler = _TqdmLoggingHandler(tqdm_class)\n            orig_handler = _get_first_found_console_logging_handler(logger.handlers)\n            if orig_handler is not None:\n                tqdm_handler.setFormatter(orig_handler.formatter)\n                tqdm_handler.stream = orig_handler.stream\n            logger.handlers = [\n                handler for handler in logger.handlers\n                if not _is_console_logging_handler(handler)] + [tqdm_handler]\n        yield\n    finally:\n        for logger, original_handlers in zip(loggers, original_handlers_list):\n            logger.handlers = original_handlers\n\n\n@contextmanager\ndef tqdm_logging_redirect(\n    *args,\n    # loggers=None,  # type: Optional[List[logging.Logger]]\n    # tqdm=None,  # type: Optional[Type[tqdm.tqdm]]\n    **kwargs\n):\n    # type: (...) -> Iterator[None]\n    \"\"\"\n    Convenience shortcut for:\n    ```python\n    with tqdm_class(*args, **tqdm_kwargs) as pbar:\n        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):\n            yield pbar\n    ```\n\n    Parameters\n    ----------\n    tqdm_class  : optional, (default: tqdm.std.tqdm).\n    loggers  : optional, list.\n    **tqdm_kwargs  : passed to `tqdm_class`.\n    \"\"\"\n    tqdm_kwargs = kwargs.copy()\n    loggers = tqdm_kwargs.pop('loggers', None)\n    tqdm_class = tqdm_kwargs.pop('tqdm_class', std_tqdm)\n    with tqdm_class(*args, **tqdm_kwargs) as pbar:\n        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):\n            yield pbar\n", "tqdm/contrib/slack.py": "\"\"\"\nSends updates to a Slack app.\n\nUsage:\n>>> from tqdm.contrib.slack import tqdm, trange\n>>> for i in trange(10, token='{token}', channel='{channel}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-slack.png)\n\"\"\"\nimport logging\nfrom os import getenv\n\ntry:\n    from slack_sdk import WebClient\nexcept ImportError:\n    raise ImportError(\"Please `pip install slack-sdk`\")\n\nfrom ..auto import tqdm as tqdm_auto\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"0x2b3bfa0\", \"casperdcl\"]}\n__all__ = ['SlackIO', 'tqdm_slack', 'tsrange', 'tqdm', 'trange']\n\n\nclass SlackIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Slack app.\"\"\"\n    def __init__(self, token, channel):\n        \"\"\"Creates a new message in the given `channel`.\"\"\"\n        super().__init__()\n        self.client = WebClient(token=token)\n        self.text = self.__class__.__name__\n        try:\n            self.message = self.client.chat_postMessage(channel=channel, text=self.text)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n            self.message = None\n\n    def write(self, s):\n        \"\"\"Replaces internal `message`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # skip duplicate message\n        message = self.message\n        if message is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(self.client.chat_update, channel=message['channel'],\n                                 ts=message['ts'], text='`' + s + '`')\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_slack(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Slack app.\n    May take a few seconds to create (`__init__`).\n\n    - create a Slack app with the `chat:write` scope & invite it to a\n      channel: <https://api.slack.com/authentication/basics>\n    - copy the bot `{token}` & `{channel}` and paste below\n    >>> from tqdm.contrib.slack import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', channel='{channel}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Slack token\n            [default: ${TQDM_SLACK_TOKEN}].\n        channel  : int, required. Slack channel\n            [default: ${TQDM_SLACK_CHANNEL}].\n        mininterval  : float, optional.\n          Minimum of [default: 1.5] to avoid rate limit.\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            logging.getLogger(\"HTTPClient\").setLevel(logging.WARNING)\n            self.sio = SlackIO(\n                kwargs.pop('token', getenv(\"TQDM_SLACK_TOKEN\")),\n                kwargs.pop('channel', getenv(\"TQDM_SLACK_CHANNEL\")))\n            kwargs['mininterval'] = max(1.5, kwargs.get('mininterval', 1.5))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '`{bar:10}`').replace('{bar}', '`{bar:10u}`')\n        else:\n            fmt['bar_format'] = '{l_bar}`{bar:10}`{r_bar}'\n        if fmt['ascii'] is False:\n            fmt['ascii'] = [\":black_square:\", \":small_blue_diamond:\", \":large_blue_diamond:\",\n                            \":large_blue_square:\"]\n            fmt['ncols'] = 336\n        self.sio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.sio.write(\"\")\n\n\ndef tsrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.slack.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_slack(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_slack\ntrange = tsrange\n", "tqdm/contrib/bells.py": "\"\"\"\nEven more features than `tqdm.auto` (all the bells & whistles):\n\n- `tqdm.auto`\n- `tqdm.tqdm.pandas`\n- `tqdm.contrib.telegram`\n    + uses `${TQDM_TELEGRAM_TOKEN}` and `${TQDM_TELEGRAM_CHAT_ID}`\n- `tqdm.contrib.discord`\n    + uses `${TQDM_DISCORD_TOKEN}` and `${TQDM_DISCORD_CHANNEL_ID}`\n\"\"\"\n__all__ = ['tqdm', 'trange']\nimport warnings\nfrom os import getenv\n\nif getenv(\"TQDM_SLACK_TOKEN\") and getenv(\"TQDM_SLACK_CHANNEL\"):\n    from .slack import tqdm, trange\nelif getenv(\"TQDM_TELEGRAM_TOKEN\") and getenv(\"TQDM_TELEGRAM_CHAT_ID\"):\n    from .telegram import tqdm, trange\nelif getenv(\"TQDM_DISCORD_TOKEN\") and getenv(\"TQDM_DISCORD_CHANNEL_ID\"):\n    from .discord import tqdm, trange\nelse:\n    from ..auto import tqdm, trange\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", category=FutureWarning)\n    tqdm.pandas()\n", "tqdm/contrib/utils_worker.py": "\"\"\"\nIO/concurrency helpers for `tqdm.contrib`.\n\"\"\"\nfrom collections import deque\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom ..auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['MonoWorker']\n\n\nclass MonoWorker(object):\n    \"\"\"\n    Supports one running task and one waiting task.\n    The waiting task is the most recent submitted (others are discarded).\n    \"\"\"\n    def __init__(self):\n        self.pool = ThreadPoolExecutor(max_workers=1)\n        self.futures = deque([], 2)\n\n    def submit(self, func, *args, **kwargs):\n        \"\"\"`func(*args, **kwargs)` may replace currently waiting task.\"\"\"\n        futures = self.futures\n        if len(futures) == futures.maxlen:\n            running = futures.popleft()\n            if not running.done():\n                if len(futures):  # clear waiting\n                    waiting = futures.pop()\n                    waiting.cancel()\n                futures.appendleft(running)  # re-insert running\n        try:\n            waiting = self.pool.submit(func, *args, **kwargs)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            futures.append(waiting)\n            return waiting\n", "tqdm/contrib/telegram.py": "\"\"\"\nSends updates to a Telegram bot.\n\nUsage:\n>>> from tqdm.contrib.telegram import tqdm, trange\n>>> for i in trange(10, token='{token}', chat_id='{chat_id}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-telegram.gif)\n\"\"\"\nfrom os import getenv\nfrom warnings import warn\n\nfrom requests import Session\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmWarning\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['TelegramIO', 'tqdm_telegram', 'ttgrange', 'tqdm', 'trange']\n\n\nclass TelegramIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Telegram Bot.\"\"\"\n    API = 'https://api.telegram.org/bot'\n\n    def __init__(self, token, chat_id):\n        \"\"\"Creates a new message in the given `chat_id`.\"\"\"\n        super().__init__()\n        self.token = token\n        self.chat_id = chat_id\n        self.session = Session()\n        self.text = self.__class__.__name__\n        self.message_id\n\n    @property\n    def message_id(self):\n        if hasattr(self, '_message_id'):\n            return self._message_id\n        try:\n            res = self.session.post(\n                self.API + '%s/sendMessage' % self.token,\n                data={'text': '`' + self.text + '`', 'chat_id': self.chat_id,\n                      'parse_mode': 'MarkdownV2'}).json()\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            if res.get('error_code') == 429:\n                warn(\"Creation rate limit: try increasing `mininterval`.\",\n                     TqdmWarning, stacklevel=2)\n            else:\n                self._message_id = res['result']['message_id']\n                return self._message_id\n\n    def write(self, s):\n        \"\"\"Replaces internal `message_id`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # avoid duplicate message Bot error\n        message_id = self.message_id\n        if message_id is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(\n                self.session.post, self.API + '%s/editMessageText' % self.token,\n                data={'text': '`' + s + '`', 'chat_id': self.chat_id,\n                      'message_id': message_id, 'parse_mode': 'MarkdownV2'})\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n    def delete(self):\n        \"\"\"Deletes internal `message_id`.\"\"\"\n        try:\n            future = self.submit(\n                self.session.post, self.API + '%s/deleteMessage' % self.token,\n                data={'chat_id': self.chat_id, 'message_id': self.message_id})\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_telegram(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Telegram Bot.\n    May take a few seconds to create (`__init__`).\n\n    - create a bot <https://core.telegram.org/bots#6-botfather>\n    - copy its `{token}`\n    - add the bot to a chat and send it a message such as `/start`\n    - go to <https://api.telegram.org/bot`{token}`/getUpdates> to find out\n      the `{chat_id}`\n    - paste the `{token}` & `{chat_id}` below\n\n    >>> from tqdm.contrib.telegram import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', chat_id='{chat_id}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Telegram token\n            [default: ${TQDM_TELEGRAM_TOKEN}].\n        chat_id  : str, required. Telegram chat ID\n            [default: ${TQDM_TELEGRAM_CHAT_ID}].\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            self.tgio = TelegramIO(\n                kwargs.pop('token', getenv('TQDM_TELEGRAM_TOKEN')),\n                kwargs.pop('chat_id', getenv('TQDM_TELEGRAM_CHAT_ID')))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')\n        else:\n            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'\n        self.tgio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.tgio.write(\"\")\n\n    def close(self):\n        if self.disable:\n            return\n        super().close()\n        if not (self.leave or (self.leave is None and self.pos == 0)):\n            self.tgio.delete()\n\n\ndef ttgrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.telegram.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_telegram(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_telegram\ntrange = ttgrange\n", "tqdm/contrib/itertools.py": "\"\"\"\nThin wrappers around `itertools`.\n\"\"\"\nimport itertools\n\nfrom ..auto import tqdm as tqdm_auto\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['product']\n\n\ndef product(*iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `itertools.product`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    try:\n        lens = list(map(len, iterables))\n    except TypeError:\n        total = None\n    else:\n        total = 1\n        for i in lens:\n            total *= i\n        kwargs.setdefault(\"total\", total)\n    with tqdm_class(**kwargs) as t:\n        it = itertools.product(*iterables)\n        for i in it:\n            yield i\n            t.update()\n", "tqdm/contrib/__init__.py": "\"\"\"\nThin wrappers around common functions.\n\nSubpackages contain potentially unstable extensions.\n\"\"\"\nfrom warnings import warn\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmDeprecationWarning, tqdm\nfrom ..utils import ObjectWrapper\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['tenumerate', 'tzip', 'tmap']\n\n\nclass DummyTqdmFile(ObjectWrapper):\n    \"\"\"Dummy file-like that will write to tqdm\"\"\"\n\n    def __init__(self, wrapped):\n        super().__init__(wrapped)\n        self._buf = []\n\n    def write(self, x, nolock=False):\n        nl = b\"\\n\" if isinstance(x, bytes) else \"\\n\"\n        pre, sep, post = x.rpartition(nl)\n        if sep:\n            blank = type(nl)()\n            tqdm.write(blank.join(self._buf + [pre, sep]),\n                       end=blank, file=self._wrapped, nolock=nolock)\n            self._buf = [post]\n        else:\n            self._buf.append(x)\n\n    def __del__(self):\n        if self._buf:\n            blank = type(self._buf[0])()\n            try:\n                tqdm.write(blank.join(self._buf), end=blank, file=self._wrapped)\n            except (OSError, ValueError):\n                pass\n\n\ndef builtin_iterable(func):\n    \"\"\"Returns `func`\"\"\"\n    warn(\"This function has no effect, and will be removed in tqdm==5.0.0\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return func\n\n\ndef tenumerate(iterable, start=0, total=None, tqdm_class=tqdm_auto, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `numpy.ndenumerate` or builtin `enumerate`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    try:\n        import numpy as np\n    except ImportError:\n        pass\n    else:\n        if isinstance(iterable, np.ndarray):\n            return tqdm_class(np.ndenumerate(iterable), total=total or iterable.size,\n                              **tqdm_kwargs)\n    return enumerate(tqdm_class(iterable, total=total, **tqdm_kwargs), start)\n\n\ndef tzip(iter1, *iter2plus, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of builtin `zip`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    for i in zip(tqdm_class(iter1, **kwargs), *iter2plus):\n        yield i\n\n\ndef tmap(function, *sequences, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of builtin `map`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    \"\"\"\n    for i in tzip(*sequences, **tqdm_kwargs):\n        yield function(*i)\n", "tqdm/contrib/concurrent.py": "\"\"\"\nThin wrappers around `concurrent.futures`.\n\"\"\"\nfrom contextlib import contextmanager\nfrom operator import length_hint\nfrom os import cpu_count\n\nfrom ..auto import tqdm as tqdm_auto\nfrom ..std import TqdmWarning\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['thread_map', 'process_map']\n\n\n@contextmanager\ndef ensure_lock(tqdm_class, lock_name=\"\"):\n    \"\"\"get (create if necessary) and then restore `tqdm_class`'s lock\"\"\"\n    old_lock = getattr(tqdm_class, '_lock', None)  # don't create a new lock\n    lock = old_lock or tqdm_class.get_lock()  # maybe create a new lock\n    lock = getattr(lock, lock_name, lock)  # maybe subtype\n    tqdm_class.set_lock(lock)\n    yield lock\n    if old_lock is None:\n        del tqdm_class._lock\n    else:\n        tqdm_class.set_lock(old_lock)\n\n\ndef _executor_map(PoolExecutor, fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Implementation of `thread_map` and `process_map`.\n\n    Parameters\n    ----------\n    tqdm_class  : [default: tqdm.auto.tqdm].\n    max_workers  : [default: min(32, cpu_count() + 4)].\n    chunksize  : [default: 1].\n    lock_name  : [default: \"\":str].\n    \"\"\"\n    kwargs = tqdm_kwargs.copy()\n    if \"total\" not in kwargs:\n        kwargs[\"total\"] = length_hint(iterables[0])\n    tqdm_class = kwargs.pop(\"tqdm_class\", tqdm_auto)\n    max_workers = kwargs.pop(\"max_workers\", min(32, cpu_count() + 4))\n    chunksize = kwargs.pop(\"chunksize\", 1)\n    lock_name = kwargs.pop(\"lock_name\", \"\")\n    with ensure_lock(tqdm_class, lock_name=lock_name) as lk:\n        # share lock in case workers are already using `tqdm`\n        with PoolExecutor(max_workers=max_workers, initializer=tqdm_class.set_lock,\n                          initargs=(lk,)) as ex:\n            return list(tqdm_class(ex.map(fn, *iterables, chunksize=chunksize), **kwargs))\n\n\ndef thread_map(fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `list(map(fn, *iterables))`\n    driven by `concurrent.futures.ThreadPoolExecutor`.\n\n    Parameters\n    ----------\n    tqdm_class  : optional\n        `tqdm` class to use for bars [default: tqdm.auto.tqdm].\n    max_workers  : int, optional\n        Maximum number of workers to spawn; passed to\n        `concurrent.futures.ThreadPoolExecutor.__init__`.\n        [default: max(32, cpu_count() + 4)].\n    \"\"\"\n    from concurrent.futures import ThreadPoolExecutor\n    return _executor_map(ThreadPoolExecutor, fn, *iterables, **tqdm_kwargs)\n\n\ndef process_map(fn, *iterables, **tqdm_kwargs):\n    \"\"\"\n    Equivalent of `list(map(fn, *iterables))`\n    driven by `concurrent.futures.ProcessPoolExecutor`.\n\n    Parameters\n    ----------\n    tqdm_class  : optional\n        `tqdm` class to use for bars [default: tqdm.auto.tqdm].\n    max_workers  : int, optional\n        Maximum number of workers to spawn; passed to\n        `concurrent.futures.ProcessPoolExecutor.__init__`.\n        [default: min(32, cpu_count() + 4)].\n    chunksize  : int, optional\n        Size of chunks sent to worker processes; passed to\n        `concurrent.futures.ProcessPoolExecutor.map`. [default: 1].\n    lock_name  : str, optional\n        Member of `tqdm_class.get_lock()` to use [default: mp_lock].\n    \"\"\"\n    from concurrent.futures import ProcessPoolExecutor\n    if iterables and \"chunksize\" not in tqdm_kwargs:\n        # default `chunksize=1` has poor performance for large iterables\n        # (most time spent dispatching items to workers).\n        longest_iterable_len = max(map(length_hint, iterables))\n        if longest_iterable_len > 1000:\n            from warnings import warn\n            warn(\"Iterable length %d > 1000 but `chunksize` is not set.\"\n                 \" This may seriously degrade multiprocess performance.\"\n                 \" Set `chunksize=1` or more.\" % longest_iterable_len,\n                 TqdmWarning, stacklevel=2)\n    if \"lock_name\" not in tqdm_kwargs:\n        tqdm_kwargs = tqdm_kwargs.copy()\n        tqdm_kwargs[\"lock_name\"] = \"mp_lock\"\n    return _executor_map(ProcessPoolExecutor, fn, *iterables, **tqdm_kwargs)\n", "tqdm/contrib/discord.py": "\"\"\"\nSends updates to a Discord bot.\n\nUsage:\n>>> from tqdm.contrib.discord import tqdm, trange\n>>> for i in trange(10, token='{token}', channel_id='{channel_id}'):\n...     ...\n\n![screenshot](https://tqdm.github.io/img/screenshot-discord.png)\n\"\"\"\nimport logging\nfrom os import getenv\n\ntry:\n    from disco.client import Client, ClientConfig\nexcept ImportError:\n    raise ImportError(\"Please `pip install disco-py`\")\n\nfrom ..auto import tqdm as tqdm_auto\nfrom .utils_worker import MonoWorker\n\n__author__ = {\"github.com/\": [\"casperdcl\"]}\n__all__ = ['DiscordIO', 'tqdm_discord', 'tdrange', 'tqdm', 'trange']\n\n\nclass DiscordIO(MonoWorker):\n    \"\"\"Non-blocking file-like IO using a Discord Bot.\"\"\"\n    def __init__(self, token, channel_id):\n        \"\"\"Creates a new message in the given `channel_id`.\"\"\"\n        super().__init__()\n        config = ClientConfig()\n        config.token = token\n        client = Client(config)\n        self.text = self.__class__.__name__\n        try:\n            self.message = client.api.channels_messages_create(channel_id, self.text)\n        except Exception as e:\n            tqdm_auto.write(str(e))\n            self.message = None\n\n    def write(self, s):\n        \"\"\"Replaces internal `message`'s text with `s`.\"\"\"\n        if not s:\n            s = \"...\"\n        s = s.replace('\\r', '').strip()\n        if s == self.text:\n            return  # skip duplicate message\n        message = self.message\n        if message is None:\n            return\n        self.text = s\n        try:\n            future = self.submit(message.edit, '`' + s + '`')\n        except Exception as e:\n            tqdm_auto.write(str(e))\n        else:\n            return future\n\n\nclass tqdm_discord(tqdm_auto):\n    \"\"\"\n    Standard `tqdm.auto.tqdm` but also sends updates to a Discord Bot.\n    May take a few seconds to create (`__init__`).\n\n    - create a discord bot (not public, no requirement of OAuth2 code\n      grant, only send message permissions) & invite it to a channel:\n      <https://discordpy.readthedocs.io/en/latest/discord.html>\n    - copy the bot `{token}` & `{channel_id}` and paste below\n\n    >>> from tqdm.contrib.discord import tqdm, trange\n    >>> for i in tqdm(iterable, token='{token}', channel_id='{channel_id}'):\n    ...     ...\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        token  : str, required. Discord token\n            [default: ${TQDM_DISCORD_TOKEN}].\n        channel_id  : int, required. Discord channel ID\n            [default: ${TQDM_DISCORD_CHANNEL_ID}].\n        mininterval  : float, optional.\n          Minimum of [default: 1.5] to avoid rate limit.\n\n        See `tqdm.auto.tqdm.__init__` for other parameters.\n        \"\"\"\n        if not kwargs.get('disable'):\n            kwargs = kwargs.copy()\n            logging.getLogger(\"HTTPClient\").setLevel(logging.WARNING)\n            self.dio = DiscordIO(\n                kwargs.pop('token', getenv(\"TQDM_DISCORD_TOKEN\")),\n                kwargs.pop('channel_id', getenv(\"TQDM_DISCORD_CHANNEL_ID\")))\n            kwargs['mininterval'] = max(1.5, kwargs.get('mininterval', 1.5))\n        super().__init__(*args, **kwargs)\n\n    def display(self, **kwargs):\n        super().display(**kwargs)\n        fmt = self.format_dict\n        if fmt.get('bar_format', None):\n            fmt['bar_format'] = fmt['bar_format'].replace(\n                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')\n        else:\n            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'\n        self.dio.write(self.format_meter(**fmt))\n\n    def clear(self, *args, **kwargs):\n        super().clear(*args, **kwargs)\n        if not self.disable:\n            self.dio.write(\"\")\n\n\ndef tdrange(*args, **kwargs):\n    \"\"\"Shortcut for `tqdm.contrib.discord.tqdm(range(*args), **kwargs)`.\"\"\"\n    return tqdm_discord(range(*args), **kwargs)\n\n\n# Aliases\ntqdm = tqdm_discord\ntrange = tdrange\n", "tests/tests_rich.py": "\"\"\"Test `tqdm.rich`.\"\"\"\nfrom .tests_tqdm import importorskip\n\n\ndef test_rich_import():\n    \"\"\"Test `tqdm.rich` import\"\"\"\n    importorskip('tqdm.rich')\n", "tests/tests_perf.py": "import sys\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom time import sleep, time\n\n# Use relative/cpu timer to have reliable timings when there is a sudden load\ntry:\n    from time import process_time\nexcept ImportError:\n    from time import clock\n    process_time = clock\n\nfrom tqdm import tqdm, trange\n\nfrom .tests_tqdm import importorskip, mark, patch_lock, skip\n\npytestmark = mark.slow\n\n\ndef cpu_sleep(t):\n    \"\"\"Sleep the given amount of cpu time\"\"\"\n    start = process_time()\n    while (process_time() - start) < t:\n        pass\n\n\ndef checkCpuTime(sleeptime=0.2):\n    \"\"\"Check if cpu time works correctly\"\"\"\n    if checkCpuTime.passed:\n        return True\n    # First test that sleeping does not consume cputime\n    start1 = process_time()\n    sleep(sleeptime)\n    t1 = process_time() - start1\n\n    # secondly check by comparing to cpusleep (where we actually do something)\n    start2 = process_time()\n    cpu_sleep(sleeptime)\n    t2 = process_time() - start2\n\n    if abs(t1) < 0.0001 and t1 < t2 / 10:\n        checkCpuTime.passed = True\n        return True\n    skip(\"cpu time not reliable on this machine\")\n\n\ncheckCpuTime.passed = False\n\n\n@contextmanager\ndef relative_timer():\n    \"\"\"yields a context timer function which stops ticking on exit\"\"\"\n    start = process_time()\n\n    def elapser():\n        return process_time() - start\n\n    yield lambda: elapser()\n    spent = elapser()\n\n    def elapser():  # NOQA\n        return spent\n\n\ndef retry_on_except(n=3, check_cpu_time=True):\n    \"\"\"decroator for retrying `n` times before raising Exceptions\"\"\"\n    def wrapper(func):\n        \"\"\"actual decorator\"\"\"\n        @wraps(func)\n        def test_inner(*args, **kwargs):\n            \"\"\"may skip if `check_cpu_time` fails\"\"\"\n            for i in range(1, n + 1):\n                try:\n                    if check_cpu_time:\n                        checkCpuTime()\n                    func(*args, **kwargs)\n                except Exception:\n                    if i >= n:\n                        raise\n                else:\n                    return\n        return test_inner\n    return wrapper\n\n\ndef simple_progress(iterable=None, total=None, file=sys.stdout, desc='',\n                    leave=False, miniters=1, mininterval=0.1, width=60):\n    \"\"\"Simple progress bar reproducing tqdm's major features\"\"\"\n    n = [0]  # use a closure\n    start_t = [time()]\n    last_n = [0]\n    last_t = [0]\n    if iterable is not None:\n        total = len(iterable)\n\n    def format_interval(t):\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        return f'{h:d}:{m:02d}:{s:02d}' if h else f'{m:02d}:{s:02d}'\n\n    def update_and_print(i=1):\n        n[0] += i\n        if (n[0] - last_n[0]) >= miniters:\n            last_n[0] = n[0]\n\n            if (time() - last_t[0]) >= mininterval:\n                last_t[0] = time()  # last_t[0] == current time\n\n                spent = last_t[0] - start_t[0]\n                spent_fmt = format_interval(spent)\n                rate = n[0] / spent if spent > 0 else 0\n                rate_fmt = \"%.2fs/it\" % (1.0 / rate) if 0.0 < rate < 1.0 else \"%.2fit/s\" % rate\n\n                frac = n[0] / total\n                percentage = int(frac * 100)\n                eta = (total - n[0]) / rate if rate > 0 else 0\n                eta_fmt = format_interval(eta)\n\n                # full_bar = \"#\" * int(frac * width)\n                barfill = \" \" * int((1.0 - frac) * width)\n                bar_length, frac_bar_length = divmod(int(frac * width * 10), 10)\n                full_bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n\n                file.write(\"\\r%s %i%%|%s%s%s| %i/%i [%s<%s, %s]\" %\n                           (desc, percentage, full_bar, frac_bar, barfill, n[0],\n                            total, spent_fmt, eta_fmt, rate_fmt))\n\n                if n[0] == total and leave:\n                    file.write(\"\\n\")\n                file.flush()\n\n    def update_and_yield():\n        for elt in iterable:\n            yield elt\n            update_and_print()\n\n    update_and_print(0)\n    if iterable is not None:\n        return update_and_yield()\n    return update_and_print\n\n\ndef assert_performance(thresh, name_left, time_left, name_right, time_right):\n    \"\"\"raises if time_left > thresh * time_right\"\"\"\n    if time_left > thresh * time_right:\n        raise ValueError(\n            f'{name_left}: {time_left:f}, {name_right}: {time_right:f}'\n            f', ratio {time_left / time_right:f} > {thresh:f}')\n\n\n@retry_on_except()\ndef test_iter_basic_overhead():\n    \"\"\"Test overhead of iteration based tqdm\"\"\"\n    total = int(1e6)\n\n    a = 0\n    with trange(total) as t:\n        with relative_timer() as time_tqdm:\n            for i in t:\n                a += i\n    assert a == (total ** 2 - total) / 2.0\n\n    a = 0\n    with relative_timer() as time_bench:\n        for i in range(total):\n            a += i\n            sys.stdout.write(str(a))\n\n    assert_performance(3, 'trange', time_tqdm(), 'range', time_bench())\n\n\n@retry_on_except()\ndef test_manual_basic_overhead():\n    \"\"\"Test overhead of manual tqdm\"\"\"\n    total = int(1e6)\n\n    with tqdm(total=total * 10, leave=True) as t:\n        a = 0\n        with relative_timer() as time_tqdm:\n            for i in range(total):\n                a += i\n                t.update(10)\n\n    a = 0\n    with relative_timer() as time_bench:\n        for i in range(total):\n            a += i\n            sys.stdout.write(str(a))\n\n    assert_performance(5, 'tqdm', time_tqdm(), 'range', time_bench())\n\n\ndef worker(total, blocking=True):\n    def incr_bar(x):\n        for _ in trange(total, lock_args=None if blocking else (False,),\n                        miniters=1, mininterval=0, maxinterval=0):\n            pass\n        return x + 1\n    return incr_bar\n\n\n@retry_on_except()\n@patch_lock(thread=True)\ndef test_lock_args():\n    \"\"\"Test overhead of nonblocking threads\"\"\"\n    ThreadPoolExecutor = importorskip('concurrent.futures').ThreadPoolExecutor\n\n    total = 16\n    subtotal = 10000\n\n    with ThreadPoolExecutor() as pool:\n        sys.stderr.write('block ... ')\n        sys.stderr.flush()\n        with relative_timer() as time_tqdm:\n            res = list(pool.map(worker(subtotal, True), range(total)))\n            assert sum(res) == sum(range(total)) + total\n        sys.stderr.write('noblock ... ')\n        sys.stderr.flush()\n        with relative_timer() as time_noblock:\n            res = list(pool.map(worker(subtotal, False), range(total)))\n            assert sum(res) == sum(range(total)) + total\n\n    assert_performance(0.5, 'noblock', time_noblock(), 'tqdm', time_tqdm())\n\n\n@retry_on_except(10)\ndef test_iter_overhead_hard():\n    \"\"\"Test overhead of iteration based tqdm (hard)\"\"\"\n    total = int(1e5)\n\n    a = 0\n    with trange(total, leave=True, miniters=1,\n                mininterval=0, maxinterval=0) as t:\n        with relative_timer() as time_tqdm:\n            for i in t:\n                a += i\n    assert a == (total ** 2 - total) / 2.0\n\n    a = 0\n    with relative_timer() as time_bench:\n        for i in range(total):\n            a += i\n            sys.stdout.write((\"%i\" % a) * 40)\n\n    assert_performance(130, 'trange', time_tqdm(), 'range', time_bench())\n\n\n@retry_on_except(10)\ndef test_manual_overhead_hard():\n    \"\"\"Test overhead of manual tqdm (hard)\"\"\"\n    total = int(1e5)\n\n    with tqdm(total=total * 10, leave=True, miniters=1,\n              mininterval=0, maxinterval=0) as t:\n        a = 0\n        with relative_timer() as time_tqdm:\n            for i in range(total):\n                a += i\n                t.update(10)\n\n    a = 0\n    with relative_timer() as time_bench:\n        for i in range(total):\n            a += i\n            sys.stdout.write((\"%i\" % a) * 40)\n\n    assert_performance(130, 'tqdm', time_tqdm(), 'range', time_bench())\n\n\n@retry_on_except(10)\ndef test_iter_overhead_simplebar_hard():\n    \"\"\"Test overhead of iteration based tqdm vs simple progress bar (hard)\"\"\"\n    total = int(1e4)\n\n    a = 0\n    with trange(total, leave=True, miniters=1,\n                mininterval=0, maxinterval=0) as t:\n        with relative_timer() as time_tqdm:\n            for i in t:\n                a += i\n    assert a == (total ** 2 - total) / 2.0\n\n    a = 0\n    s = simple_progress(range(total), leave=True,\n                        miniters=1, mininterval=0)\n    with relative_timer() as time_bench:\n        for i in s:\n            a += i\n\n    assert_performance(10, 'trange', time_tqdm(), 'simple_progress', time_bench())\n\n\n@retry_on_except(10)\ndef test_manual_overhead_simplebar_hard():\n    \"\"\"Test overhead of manual tqdm vs simple progress bar (hard)\"\"\"\n    total = int(1e4)\n\n    with tqdm(total=total * 10, leave=True, miniters=1,\n              mininterval=0, maxinterval=0) as t:\n        a = 0\n        with relative_timer() as time_tqdm:\n            for i in range(total):\n                a += i\n                t.update(10)\n\n    simplebar_update = simple_progress(total=total * 10, leave=True,\n                                       miniters=1, mininterval=0)\n    a = 0\n    with relative_timer() as time_bench:\n        for i in range(total):\n            a += i\n            simplebar_update(10)\n\n    assert_performance(10, 'tqdm', time_tqdm(), 'simple_progress', time_bench())\n", "tests/tests_keras.py": "from .tests_tqdm import importorskip, mark\n\npytestmark = mark.slow\n\n\n@mark.filterwarnings(\"ignore:.*:DeprecationWarning\")\ndef test_keras(capsys):\n    \"\"\"Test tqdm.keras.TqdmCallback\"\"\"\n    TqdmCallback = importorskip('tqdm.keras').TqdmCallback\n    np = importorskip('numpy')\n    try:\n        import keras as K\n    except ImportError:\n        K = importorskip('tensorflow.keras')\n\n    # 1D autoencoder\n    dtype = np.float32\n    model = K.models.Sequential([\n        K.layers.InputLayer((1, 1), dtype=dtype), K.layers.Conv1D(1, 1)])\n    model.compile(\"adam\", \"mse\")\n    x = np.random.rand(100, 1, 1).astype(dtype)\n    batch_size = 10\n    batches = len(x) / batch_size\n    epochs = 5\n\n    # just epoch (no batch) progress\n    model.fit(\n        x,\n        x,\n        epochs=epochs,\n        batch_size=batch_size,\n        verbose=False,\n        callbacks=[\n            TqdmCallback(\n                epochs,\n                desc=\"training\",\n                data_size=len(x),\n                batch_size=batch_size,\n                verbose=0)])\n    _, res = capsys.readouterr()\n    assert \"training: \" in res\n    assert f\"{epochs}/{epochs}\" in res\n    assert f\"{batches}/{batches}\" not in res\n\n    # full (epoch and batch) progress\n    model.fit(\n        x,\n        x,\n        epochs=epochs,\n        batch_size=batch_size,\n        verbose=False,\n        callbacks=[\n            TqdmCallback(\n                epochs,\n                desc=\"training\",\n                data_size=len(x),\n                batch_size=batch_size,\n                verbose=2)])\n    _, res = capsys.readouterr()\n    assert \"training: \" in res\n    assert f\"{epochs}/{epochs}\" in res\n    assert f\"{batches}/{batches}\" in res\n\n    # auto-detect epochs and batches\n    model.fit(\n        x,\n        x,\n        epochs=epochs,\n        batch_size=batch_size,\n        verbose=False,\n        callbacks=[TqdmCallback(desc=\"training\", verbose=2)])\n    _, res = capsys.readouterr()\n    assert \"training: \" in res\n    assert f\"{epochs}/{epochs}\" in res\n    assert f\"{batches}/{batches}\" in res\n\n    # continue training (start from epoch != 0)\n    initial_epoch = 3\n    model.fit(\n        x,\n        x,\n        initial_epoch=initial_epoch,\n        epochs=epochs,\n        batch_size=batch_size,\n        verbose=False,\n        callbacks=[TqdmCallback(desc=\"training\", verbose=0,\n                                miniters=1, mininterval=0, maxinterval=0)])\n    _, res = capsys.readouterr()\n    assert \"training: \" in res\n    assert f\"{initial_epoch - 1}/{initial_epoch - 1}\" not in res\n    assert f\"{epochs}/{epochs}\" in res\n", "tests/tests_utils.py": "from ast import literal_eval\nfrom collections import defaultdict\nfrom typing import Union  # py<3.10\n\nfrom tqdm.utils import envwrap\n\n\ndef test_envwrap(monkeypatch):\n    \"\"\"Test @envwrap (basic)\"\"\"\n    monkeypatch.setenv('FUNC_A', \"42\")\n    monkeypatch.setenv('FUNC_TyPe_HiNt', \"1337\")\n    monkeypatch.setenv('FUNC_Unused', \"x\")\n\n    @envwrap(\"FUNC_\")\n    def func(a=1, b=2, type_hint: int = None):\n        return a, b, type_hint\n\n    assert (42, 2, 1337) == func()\n    assert (99, 2, 1337) == func(a=99)\n\n\ndef test_envwrap_types(monkeypatch):\n    \"\"\"Test @envwrap(types)\"\"\"\n    monkeypatch.setenv('FUNC_notype', \"3.14159\")\n\n    @envwrap(\"FUNC_\", types=defaultdict(lambda: literal_eval))\n    def func(notype=None):\n        return notype\n\n    assert 3.14159 == func()\n\n    monkeypatch.setenv('FUNC_number', \"1\")\n    monkeypatch.setenv('FUNC_string', \"1\")\n\n    @envwrap(\"FUNC_\", types={'number': int})\n    def nofallback(number=None, string=None):\n        return number, string\n\n    assert 1, \"1\" == nofallback()\n\n\ndef test_envwrap_annotations(monkeypatch):\n    \"\"\"Test @envwrap with typehints\"\"\"\n    monkeypatch.setenv('FUNC_number', \"1.1\")\n    monkeypatch.setenv('FUNC_string', \"1.1\")\n\n    @envwrap(\"FUNC_\")\n    def annotated(number: Union[int, float] = None, string: int = None):\n        return number, string\n\n    assert 1.1, \"1.1\" == annotated()\n", "tests/tests_main.py": "\"\"\"Test CLI usage.\"\"\"\nimport logging\nimport subprocess  # nosec\nimport sys\nfrom functools import wraps\nfrom os import linesep\n\nfrom tqdm.cli import TqdmKeyError, TqdmTypeError, main\nfrom tqdm.utils import IS_WIN\n\nfrom .tests_tqdm import BytesIO, closing, mark, raises\n\n\ndef restore_sys(func):\n    \"\"\"Decorates `func(capsysbinary)` to save & restore `sys.(stdin|argv)`.\"\"\"\n    @wraps(func)\n    def inner(capsysbinary):\n        \"\"\"function requiring capsysbinary which may alter `sys.(stdin|argv)`\"\"\"\n        _SYS = sys.stdin, sys.argv\n        try:\n            res = func(capsysbinary)\n        finally:\n            sys.stdin, sys.argv = _SYS\n        return res\n\n    return inner\n\n\ndef norm(bytestr):\n    \"\"\"Normalise line endings.\"\"\"\n    return bytestr if linesep == \"\\n\" else bytestr.replace(linesep.encode(), b\"\\n\")\n\n\n@mark.slow\ndef test_pipes():\n    \"\"\"Test command line pipes\"\"\"\n    ls_out = subprocess.check_output(['ls'])  # nosec\n    ls = subprocess.Popen(['ls'], stdout=subprocess.PIPE)  # nosec\n    res = subprocess.Popen(  # nosec\n        [sys.executable, '-c', 'from tqdm.cli import main; main()'],\n        stdin=ls.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, err = res.communicate()\n    assert ls.poll() == 0\n\n    # actual test:\n    assert norm(ls_out) == norm(out)\n    assert b\"it/s\" in err\n    assert b\"Error\" not in err\n\n\nif sys.version_info[:2] >= (3, 8):\n    test_pipes = mark.filterwarnings(\"ignore:unclosed file:ResourceWarning\")(\n        test_pipes)\n\n\ndef test_main_import():\n    \"\"\"Test main CLI import\"\"\"\n    N = 123\n    _SYS = sys.stdin, sys.argv\n    # test direct import\n    sys.stdin = [str(i).encode() for i in range(N)]\n    sys.argv = ['', '--desc', 'Test CLI import',\n                '--ascii', 'True', '--unit_scale', 'True']\n    try:\n        import tqdm.__main__  # NOQA, pylint: disable=unused-variable\n    finally:\n        sys.stdin, sys.argv = _SYS\n\n\n@restore_sys\ndef test_main_bytes(capsysbinary):\n    \"\"\"Test CLI --bytes\"\"\"\n    N = 123\n\n    # test --delim\n    IN_DATA = '\\0'.join(map(str, range(N))).encode()\n    with closing(BytesIO()) as sys.stdin:\n        sys.stdin.write(IN_DATA)\n        # sys.stdin.write(b'\\xff')  # TODO\n        sys.stdin.seek(0)\n        main(sys.stderr, ['--desc', 'Test CLI delim', '--ascii', 'True',\n                          '--delim', r'\\0', '--buf_size', '64'])\n        out, err = capsysbinary.readouterr()\n        assert out == IN_DATA\n        assert str(N) + \"it\" in err.decode(\"U8\")\n\n    # test --bytes\n    IN_DATA = IN_DATA.replace(b'\\0', b'\\n')\n    with closing(BytesIO()) as sys.stdin:\n        sys.stdin.write(IN_DATA)\n        sys.stdin.seek(0)\n        main(sys.stderr, ['--ascii', '--bytes=True', '--unit_scale', 'False'])\n        out, err = capsysbinary.readouterr()\n        assert out == IN_DATA\n        assert str(len(IN_DATA)) + \"B\" in err.decode(\"U8\")\n\n\ndef test_main_log(capsysbinary, caplog):\n    \"\"\"Test CLI --log\"\"\"\n    _SYS = sys.stdin, sys.argv\n    N = 123\n    sys.stdin = [(str(i) + '\\n').encode() for i in range(N)]\n    IN_DATA = b''.join(sys.stdin)\n    try:\n        with caplog.at_level(logging.INFO):\n            main(sys.stderr, ['--log', 'INFO'])\n            out, err = capsysbinary.readouterr()\n            assert norm(out) == IN_DATA and b\"123/123\" in err\n            assert not caplog.record_tuples\n        with caplog.at_level(logging.DEBUG):\n            main(sys.stderr, ['--log', 'DEBUG'])\n            out, err = capsysbinary.readouterr()\n            assert norm(out) == IN_DATA and b\"123/123\" in err\n            assert caplog.record_tuples\n    finally:\n        sys.stdin, sys.argv = _SYS\n\n\n@restore_sys\ndef test_main(capsysbinary):\n    \"\"\"Test misc CLI options\"\"\"\n    N = 123\n    sys.stdin = [(str(i) + '\\n').encode() for i in range(N)]\n    IN_DATA = b''.join(sys.stdin)\n\n    # test --tee\n    main(sys.stderr, ['--mininterval', '0', '--miniters', '1'])\n    out, err = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA and b\"123/123\" in err\n    assert N <= len(err.split(b\"\\r\")) < N + 5\n\n    len_err = len(err)\n    main(sys.stderr, ['--tee', '--mininterval', '0', '--miniters', '1'])\n    out, err = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA and b\"123/123\" in err\n    # spaces to clear intermediate lines could increase length\n    assert len_err + len(norm(out)) <= len(err)\n\n    # test --null\n    main(sys.stderr, ['--null'])\n    out, err = capsysbinary.readouterr()\n    assert not out and b\"123/123\" in err\n\n    # test integer --update\n    main(sys.stderr, ['--update'])\n    out, err = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n    assert (str(N // 2 * N) + \"it\").encode() in err, \"expected arithmetic sum formula\"\n\n    # test integer --update_to\n    main(sys.stderr, ['--update-to'])\n    out, err = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n    assert (str(N - 1) + \"it\").encode() in err\n    assert (str(N) + \"it\").encode() not in err\n\n    with closing(BytesIO()) as sys.stdin:\n        sys.stdin.write(IN_DATA.replace(b'\\n', b'D'))\n\n        # test integer --update --delim\n        sys.stdin.seek(0)\n        main(sys.stderr, ['--update', '--delim', 'D'])\n        out, err = capsysbinary.readouterr()\n        assert out == IN_DATA.replace(b'\\n', b'D')\n        assert (str(N // 2 * N) + \"it\").encode() in err, \"expected arithmetic sum\"\n\n        # test integer --update_to --delim\n        sys.stdin.seek(0)\n        main(sys.stderr, ['--update-to', '--delim', 'D'])\n        out, err = capsysbinary.readouterr()\n        assert out == IN_DATA.replace(b'\\n', b'D')\n        assert (str(N - 1) + \"it\").encode() in err\n        assert (str(N) + \"it\").encode() not in err\n\n    # test float --update_to\n    sys.stdin = [(str(i / 2.0) + '\\n').encode() for i in range(N)]\n    IN_DATA = b''.join(sys.stdin)\n    main(sys.stderr, ['--update-to'])\n    out, err = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n    assert (str((N - 1) / 2.0) + \"it\").encode() in err\n    assert (str(N / 2.0) + \"it\").encode() not in err\n\n\n@mark.slow\n@mark.skipif(IS_WIN, reason=\"no manpages on windows\")\ndef test_manpath(tmp_path):\n    \"\"\"Test CLI --manpath\"\"\"\n    man = tmp_path / \"tqdm.1\"\n    assert not man.exists()\n    with raises(SystemExit):\n        main(argv=['--manpath', str(tmp_path)])\n    assert man.is_file()\n\n\n@mark.slow\n@mark.skipif(IS_WIN, reason=\"no completion on windows\")\ndef test_comppath(tmp_path):\n    \"\"\"Test CLI --comppath\"\"\"\n    man = tmp_path / \"tqdm_completion.sh\"\n    assert not man.exists()\n    with raises(SystemExit):\n        main(argv=['--comppath', str(tmp_path)])\n    assert man.is_file()\n\n    # check most important options appear\n    script = man.read_text()\n    opts = {'--help', '--desc', '--total', '--leave', '--ncols', '--ascii',\n            '--dynamic_ncols', '--position', '--bytes', '--nrows', '--delim',\n            '--manpath', '--comppath'}\n    assert all(args in script for args in opts)\n\n\n@restore_sys\ndef test_exceptions(capsysbinary):\n    \"\"\"Test CLI Exceptions\"\"\"\n    N = 123\n    sys.stdin = [str(i) + '\\n' for i in range(N)]\n    IN_DATA = ''.join(sys.stdin).encode()\n\n    with raises(TqdmKeyError, match=\"bad_arg_u_ment\"):\n        main(sys.stderr, argv=['-ascii', '-unit_scale', '--bad_arg_u_ment', 'foo'])\n    out, _ = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n\n    with raises(TqdmTypeError, match=\"invalid_bool_value\"):\n        main(sys.stderr, argv=['-ascii', '-unit_scale', 'invalid_bool_value'])\n    out, _ = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n\n    with raises(TqdmTypeError, match=\"invalid_int_value\"):\n        main(sys.stderr, argv=['-ascii', '--total', 'invalid_int_value'])\n    out, _ = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n\n    with raises(TqdmKeyError, match=\"Can only have one of --\"):\n        main(sys.stderr, argv=['--update', '--update_to'])\n    out, _ = capsysbinary.readouterr()\n    assert norm(out) == IN_DATA\n\n    # test SystemExits\n    for i in ('-h', '--help', '-v', '--version'):\n        with raises(SystemExit):\n            main(argv=[i])\n", "tests/tests_tqdm.py": "# -*- coding: utf-8 -*-\n# Advice: use repr(our_file.read()) to print the full output of tqdm\n# (else '\\r' will replace the previous lines and you'll see only the latest.\nimport csv\nimport os\nimport re\nimport sys\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom warnings import catch_warnings, simplefilter\n\nfrom pytest import importorskip, mark, raises, skip\n\nfrom tqdm import TqdmDeprecationWarning, TqdmWarning, tqdm, trange\nfrom tqdm.contrib import DummyTqdmFile\nfrom tqdm.std import EMA, Bar\n\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\n\nfrom io import IOBase  # to support unicode strings\nfrom io import BytesIO\n\n\nclass DeprecationError(Exception):\n    pass\n\n\n# Ensure we can use `with closing(...) as ... :` syntax\nif getattr(StringIO, '__exit__', False) and getattr(StringIO, '__enter__', False):\n    def closing(arg):\n        return arg\nelse:\n    from contextlib import closing\n\nnt_and_no_colorama = False\nif os.name == 'nt':\n    try:\n        import colorama  # NOQA\n    except ImportError:\n        nt_and_no_colorama = True\n\n# Regex definitions\n# List of control characters\nCTRLCHR = [r'\\r', r'\\n', r'\\x1b\\[A']  # Need to escape [ for regex\n# Regular expressions compilation\nRE_rate = re.compile(r'[^\\d](\\d[.\\d]+)it/s')\nRE_ctrlchr = re.compile(\"(%s)\" % '|'.join(CTRLCHR))  # Match control chars\nRE_ctrlchr_excl = re.compile('|'.join(CTRLCHR))  # Match and exclude ctrl chars\nRE_pos = re.compile(r'([\\r\\n]+((pos\\d+) bar:\\s+\\d+%|\\s{3,6})?[^\\r\\n]*)')\n\n\ndef pos_line_diff(res_list, expected_list, raise_nonempty=True):\n    \"\"\"\n    Return differences between two bar output lists.\n    To be used with `RE_pos`\n    \"\"\"\n    res = [(r, e) for r, e in zip(res_list, expected_list)\n           for pos in [len(e) - len(e.lstrip('\\n'))]  # bar position\n           if r != e  # simple comparison\n           if not r.startswith(e)  # start matches\n           or not (\n               # move up at end (maybe less due to closing bars)\n               any(r.endswith(end + i * '\\x1b[A') for i in range(pos + 1)\n                   for end in [\n                       ']',  # bar\n                       '  '])  # cleared\n               or '100%' in r  # completed bar\n               or r == '\\n')  # final bar\n           or r[(-1 - pos) * len('\\x1b[A'):] == '\\x1b[A']  # too many moves up\n    if raise_nonempty and (res or len(res_list) != len(expected_list)):\n        if len(res_list) < len(expected_list):\n            res.extend([(None, e) for e in expected_list[len(res_list):]])\n        elif len(res_list) > len(expected_list):\n            res.extend([(r, None) for r in res_list[len(expected_list):]])\n        raise AssertionError(\n            \"Got => Expected\\n\" + '\\n'.join('%r => %r' % i for i in res))\n    return res\n\n\nclass DiscreteTimer(object):\n    \"\"\"Virtual discrete time manager, to precisely control time for tests\"\"\"\n    def __init__(self):\n        self.t = 0.0\n\n    def sleep(self, t):\n        \"\"\"Sleep = increment the time counter (almost no CPU used)\"\"\"\n        self.t += t\n\n    def time(self):\n        \"\"\"Get the current time\"\"\"\n        return self.t\n\n\ndef cpu_timify(t, timer=None):\n    \"\"\"Force tqdm to use the specified timer instead of system-wide time()\"\"\"\n    if timer is None:\n        timer = DiscreteTimer()\n    t._time = timer.time\n    t._sleep = timer.sleep\n    t.start_t = t.last_print_t = t._time()\n    return timer\n\n\nclass UnicodeIO(IOBase):\n    \"\"\"Unicode version of StringIO\"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.encoding = 'U8'  # io.StringIO supports unicode, but no encoding\n        self.text = ''\n        self.cursor = 0\n\n    def __len__(self):\n        return len(self.text)\n\n    def seek(self, offset):\n        self.cursor = offset\n\n    def tell(self):\n        return self.cursor\n\n    def write(self, s):\n        self.text = self.text[:self.cursor] + s + self.text[self.cursor + len(s):]\n        self.cursor += len(s)\n\n    def read(self, n=-1):\n        _cur = self.cursor\n        self.cursor = len(self) if n < 0 else min(_cur + n, len(self))\n        return self.text[_cur:self.cursor]\n\n    def getvalue(self):\n        return self.text\n\n\ndef get_bar(all_bars, i=None):\n    \"\"\"Get a specific update from a whole bar traceback\"\"\"\n    # Split according to any used control characters\n    bars_split = RE_ctrlchr_excl.split(all_bars)\n    bars_split = list(filter(None, bars_split))  # filter out empty splits\n    return bars_split if i is None else bars_split[i]\n\n\ndef progressbar_rate(bar_str):\n    return float(RE_rate.search(bar_str).group(1))\n\n\ndef squash_ctrlchars(s):\n    \"\"\"Apply control characters in a string just like a terminal display\"\"\"\n    curline = 0\n    lines = ['']  # state of fake terminal\n    for nextctrl in filter(None, RE_ctrlchr.split(s)):\n        # apply control chars\n        if nextctrl == '\\r':\n            # go to line beginning (simplified here: just empty the string)\n            lines[curline] = ''\n        elif nextctrl == '\\n':\n            if curline >= len(lines) - 1:\n                # wrap-around creates newline\n                lines.append('')\n            # move cursor down\n            curline += 1\n        elif nextctrl == '\\x1b[A':\n            # move cursor up\n            if curline > 0:\n                curline -= 1\n            else:\n                raise ValueError(\"Cannot go further up\")\n        else:\n            # print message on current line\n            lines[curline] += nextctrl\n    return lines\n\n\ndef test_format_interval():\n    \"\"\"Test time interval format\"\"\"\n    format_interval = tqdm.format_interval\n\n    assert format_interval(60) == '01:00'\n    assert format_interval(6160) == '1:42:40'\n    assert format_interval(238113) == '66:08:33'\n\n\ndef test_format_num():\n    \"\"\"Test number format\"\"\"\n    format_num = tqdm.format_num\n\n    assert float(format_num(1337)) == 1337\n    assert format_num(int(1e6)) == '1e+6'\n    assert format_num(1239876) == '1' '239' '876'\n    assert format_num(0.00001234) == '1.23e-5'\n    assert format_num(-0.1234) == '-0.123'\n\n\ndef test_format_meter():\n    \"\"\"Test statistics and progress bar formatting\"\"\"\n    try:\n        unich = unichr\n    except NameError:\n        unich = chr\n\n    format_meter = tqdm.format_meter\n\n    assert format_meter(0, 1000, 13) == \"  0%|          | 0/1000 [00:13<?, ?it/s]\"\n    # If not implementing any changes to _tqdm.py, set prefix='desc'\n    # or else \": : \" will be in output, so assertion should change\n    assert format_meter(0, 1000, 13, ncols=68, prefix='desc: ') == (\n        \"desc:   0%|                                | 0/1000 [00:13<?, ?it/s]\")\n    assert format_meter(231, 1000, 392) == (\" 23%|\" + unich(0x2588) * 2 + unich(0x258e) +\n                                            \"       | 231/1000 [06:32<21:44,  1.70s/it]\")\n    assert format_meter(10000, 1000, 13) == \"10000it [00:13, 769.23it/s]\"\n    assert format_meter(231, 1000, 392, ncols=56, ascii=True) == \" 23%|\" + '#' * 3 + '6' + (\n        \"            | 231/1000 [06:32<21:44,  1.70s/it]\")\n    assert format_meter(100000, 1000, 13, unit_scale=True,\n                        unit='iB') == \"100kiB [00:13, 7.69kiB/s]\"\n    assert format_meter(100, 1000, 12, ncols=0,\n                        rate=7.33) == \" 10% 100/1000 [00:12<02:02,  7.33it/s]\"\n    # ncols is small, l_bar is too large\n    # l_bar gets chopped\n    # no bar\n    # no r_bar\n    # 10/12 stars since ncols is 10\n    assert format_meter(\n        0, 1000, 13, ncols=10,\n        bar_format=\"************{bar:10}$$$$$$$$$$\") == \"**********\"\n    # n_cols allows for l_bar and some of bar\n    # l_bar displays\n    # bar gets chopped\n    # no r_bar\n    # all 12 stars and 8/10 bar parts\n    assert format_meter(\n        0, 1000, 13, ncols=20,\n        bar_format=\"************{bar:10}$$$$$$$$$$\") == \"************        \"\n    # n_cols allows for l_bar, bar, and some of r_bar\n    # l_bar displays\n    # bar displays\n    # r_bar gets chopped\n    # all 12 stars and 10 bar parts, but only 8/10 dollar signs\n    assert format_meter(\n        0, 1000, 13, ncols=30,\n        bar_format=\"************{bar:10}$$$$$$$$$$\") == \"************          $$$$$$$$\"\n    # trim left ANSI; escape is before trim zone\n    # we only know it has ANSI codes, so we append an END code anyway\n    assert format_meter(\n        0, 1000, 13, ncols=10, bar_format=\"*****\\033[22m****\\033[0m***{bar:10}$$$$$$$$$$\"\n    ) == \"*****\\033[22m****\\033[0m*\\033[0m\"\n    # trim left ANSI; escape is at trim zone\n    assert format_meter(\n        0, 1000, 13, ncols=10,\n        bar_format=\"*****\\033[22m*****\\033[0m**{bar:10}$$$$$$$$$$\") == \"*****\\033[22m*****\\033[0m\"\n    # trim left ANSI; escape is after trim zone\n    assert format_meter(\n        0, 1000, 13, ncols=10,\n        bar_format=\"*****\\033[22m******\\033[0m*{bar:10}$$$$$$$$$$\") == \"*****\\033[22m*****\\033[0m\"\n    # Check that bar_format correctly adapts {bar} size to the rest\n    assert format_meter(\n        20, 100, 12, ncols=13, rate=8.1,\n        bar_format=r'{l_bar}{bar}|{n_fmt}/{total_fmt}') == \" 20%|\" + unich(0x258f) + \"|20/100\"\n    assert format_meter(\n        20, 100, 12, ncols=14, rate=8.1,\n        bar_format=r'{l_bar}{bar}|{n_fmt}/{total_fmt}') == \" 20%|\" + unich(0x258d) + \" |20/100\"\n    # Check wide characters\n    assert format_meter(0, 1000, 13, ncols=68, prefix='\uff46\uff55\uff4c\uff4c\uff57\uff49\uff44\uff54\uff48: ') == (\n        \"\uff46\uff55\uff4c\uff4c\uff57\uff49\uff44\uff54\uff48:   0%|                  | 0/1000 [00:13<?, ?it/s]\")\n    assert format_meter(0, 1000, 13, ncols=68, prefix='\u30cb\u30c3\u30dd\u30f3 [\uff86\uff6f\uff8e\uff9f\uff9d]: ') == (\n        \"\u30cb\u30c3\u30dd\u30f3 [\uff86\uff6f\uff8e\uff9f\uff9d]:   0%|                    | 0/1000 [00:13<?, ?it/s]\")\n    # Check that bar_format can print only {bar} or just one side\n    assert format_meter(20, 100, 12, ncols=2, rate=8.1,\n                        bar_format=r'{bar}') == unich(0x258d) + \" \"\n    assert format_meter(20, 100, 12, ncols=7, rate=8.1,\n                        bar_format=r'{l_bar}{bar}') == \" 20%|\" + unich(0x258d) + \" \"\n    assert format_meter(20, 100, 12, ncols=6, rate=8.1,\n                        bar_format=r'{bar}|test') == unich(0x258f) + \"|test\"\n\n\ndef test_ansi_escape_codes():\n    \"\"\"Test stripping of ANSI escape codes\"\"\"\n    ansi = {'BOLD': '\\033[1m', 'RED': '\\033[91m', 'END': '\\033[0m'}\n    desc_raw = '{BOLD}{RED}Colored{END} description'\n    ncols = 123\n\n    desc_stripped = desc_raw.format(BOLD='', RED='', END='')\n    meter = tqdm.format_meter(0, 100, 0, ncols=ncols, prefix=desc_stripped)\n    assert len(meter) == ncols\n\n    desc = desc_raw.format(**ansi)\n    meter = tqdm.format_meter(0, 100, 0, ncols=ncols, prefix=desc)\n    # `format_meter` inserts an extra END for safety\n    ansi_len = len(desc) - len(desc_stripped) + len(ansi['END'])\n    assert len(meter) == ncols + ansi_len\n\n\ndef test_si_format():\n    \"\"\"Test SI unit prefixes\"\"\"\n    format_meter = tqdm.format_meter\n\n    assert '9.00 ' in format_meter(1, 9, 1, unit_scale=True, unit='B')\n    assert '99.0 ' in format_meter(1, 99, 1, unit_scale=True)\n    assert '999 ' in format_meter(1, 999, 1, unit_scale=True)\n    assert '9.99k ' in format_meter(1, 9994, 1, unit_scale=True)\n    assert '10.0k ' in format_meter(1, 9999, 1, unit_scale=True)\n    assert '99.5k ' in format_meter(1, 99499, 1, unit_scale=True)\n    assert '100k ' in format_meter(1, 99999, 1, unit_scale=True)\n    assert '1.00M ' in format_meter(1, 999999, 1, unit_scale=True)\n    assert '1.00G ' in format_meter(1, 999999999, 1, unit_scale=True)\n    assert '1.00T ' in format_meter(1, 999999999999, 1, unit_scale=True)\n    assert '1.00P ' in format_meter(1, 999999999999999, 1, unit_scale=True)\n    assert '1.00E ' in format_meter(1, 999999999999999999, 1, unit_scale=True)\n    assert '1.00Z ' in format_meter(1, 999999999999999999999, 1, unit_scale=True)\n    assert '1.0Y ' in format_meter(1, 999999999999999999999999, 1, unit_scale=True)\n    assert '10.0Y ' in format_meter(1, 9999999999999999999999999, 1, unit_scale=True)\n    assert '100.0Y ' in format_meter(1, 99999999999999999999999999, 1, unit_scale=True)\n    assert '1000.0Y ' in format_meter(1, 999999999999999999999999999, 1,\n                                      unit_scale=True)\n\n\ndef test_bar_formatspec():\n    \"\"\"Test Bar.__format__ spec\"\"\"\n    assert f\"{Bar(0.3):5a}\" == \"#5   \"\n    assert f\"{Bar(0.5, charset=' .oO0'):2}\" == \"0 \"\n    assert f\"{Bar(0.5, charset=' .oO0'):2a}\" == \"# \"\n    assert f\"{Bar(0.5, 10):-6a}\" == '##  '\n    assert f\"{Bar(0.5, 10):2b}\" == '  '\n\n\ndef test_all_defaults():\n    \"\"\"Test default kwargs\"\"\"\n    with closing(UnicodeIO()) as our_file:\n        with tqdm(range(10), file=our_file) as progressbar:\n            assert len(progressbar) == 10\n            for _ in progressbar:\n                pass\n    # restore stdout/stderr output for `nosetest` interface\n    # try:\n    #     sys.stderr.write('\\x1b[A')\n    # except:\n    #     pass\n    sys.stderr.write('\\rTest default kwargs ... ')\n\n\nclass WriteTypeChecker(BytesIO):\n    \"\"\"File-like to assert the expected type is written\"\"\"\n    def __init__(self, expected_type):\n        super().__init__()\n        self.expected_type = expected_type\n\n    def write(self, s):\n        assert isinstance(s, self.expected_type)\n\n\ndef test_native_string_io_for_default_file():\n    \"\"\"Native strings written to unspecified files\"\"\"\n    stderr = sys.stderr\n    try:\n        sys.stderr = WriteTypeChecker(expected_type=type(''))\n        for _ in tqdm(range(3)):\n            pass\n        sys.stderr.encoding = None  # py2 behaviour\n        for _ in tqdm(range(3)):\n            pass\n    finally:\n        sys.stderr = stderr\n\n\ndef test_unicode_string_io_for_specified_file():\n    \"\"\"Unicode strings written to specified files\"\"\"\n    for _ in tqdm(range(3), file=WriteTypeChecker(expected_type=type(u''))):\n        pass\n\n\ndef test_write_bytes():\n    \"\"\"Test write_bytes argument with and without `file`\"\"\"\n    # specified file (and bytes)\n    for _ in tqdm(range(3), file=WriteTypeChecker(expected_type=type(b'')),\n                  write_bytes=True):\n        pass\n    # unspecified file (and unicode)\n    stderr = sys.stderr\n    try:\n        sys.stderr = WriteTypeChecker(expected_type=type(u''))\n        for _ in tqdm(range(3), write_bytes=False):\n            pass\n    finally:\n        sys.stderr = stderr\n\n\ndef test_iterate_over_csv_rows():\n    \"\"\"Test csv iterator\"\"\"\n    # Create a test csv pseudo file\n    with closing(StringIO()) as test_csv_file:\n        writer = csv.writer(test_csv_file)\n        for _ in range(3):\n            writer.writerow(['test'] * 3)\n        test_csv_file.seek(0)\n\n        # Test that nothing fails if we iterate over rows\n        reader = csv.DictReader(test_csv_file, fieldnames=('row1', 'row2', 'row3'))\n        with closing(StringIO()) as our_file:\n            for _ in tqdm(reader, file=our_file):\n                pass\n\n\ndef test_file_output():\n    \"\"\"Test output to arbitrary file-like objects\"\"\"\n    with closing(StringIO()) as our_file:\n        for i in tqdm(range(3), file=our_file):\n            if i == 1:\n                our_file.seek(0)\n                assert '0/3' in our_file.read()\n\n\ndef test_leave_option():\n    \"\"\"Test `leave=True` always prints info about the last iteration\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, leave=True):\n            pass\n        res = our_file.getvalue()\n        assert '| 3/3 ' in res\n        assert '\\n' == res[-1]  # not '\\r'\n\n    with closing(StringIO()) as our_file2:\n        for _ in tqdm(range(3), file=our_file2, leave=False):\n            pass\n        assert '| 3/3 ' not in our_file2.getvalue()\n\n\ndef test_trange():\n    \"\"\"Test trange\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in trange(3, file=our_file, leave=True):\n            pass\n        assert '| 3/3 ' in our_file.getvalue()\n\n    with closing(StringIO()) as our_file2:\n        for _ in trange(3, file=our_file2, leave=False):\n            pass\n        assert '| 3/3 ' not in our_file2.getvalue()\n\n\ndef test_min_interval():\n    \"\"\"Test mininterval\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, mininterval=1e-10):\n            pass\n        assert \"  0%|          | 0/3 [00:00<\" in our_file.getvalue()\n\n\ndef test_max_interval():\n    \"\"\"Test maxinterval\"\"\"\n    total = 100\n    bigstep = 10\n    smallstep = 5\n\n    # Test without maxinterval\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        with closing(StringIO()) as our_file2:\n            # with maxinterval but higher than loop sleep time\n            t = tqdm(total=total, file=our_file, miniters=None, mininterval=0,\n                     smoothing=1, maxinterval=1e-2)\n            cpu_timify(t, timer)\n\n            # without maxinterval\n            t2 = tqdm(total=total, file=our_file2, miniters=None, mininterval=0,\n                      smoothing=1, maxinterval=None)\n            cpu_timify(t2, timer)\n\n            assert t.dynamic_miniters\n            assert t2.dynamic_miniters\n\n            # Increase 10 iterations at once\n            t.update(bigstep)\n            t2.update(bigstep)\n            # The next iterations should not trigger maxinterval (step 10)\n            for _ in range(4):\n                t.update(smallstep)\n                t2.update(smallstep)\n                timer.sleep(1e-5)\n            t.close()  # because PyPy doesn't gc immediately\n            t2.close()  # as above\n\n            assert \"25%\" not in our_file2.getvalue()\n        assert \"25%\" not in our_file.getvalue()\n\n    # Test with maxinterval effect\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        with tqdm(total=total, file=our_file, miniters=None, mininterval=0,\n                  smoothing=1, maxinterval=1e-4) as t:\n            cpu_timify(t, timer)\n\n            # Increase 10 iterations at once\n            t.update(bigstep)\n            # The next iterations should trigger maxinterval (step 5)\n            for _ in range(4):\n                t.update(smallstep)\n                timer.sleep(1e-2)\n\n            assert \"25%\" in our_file.getvalue()\n\n    # Test iteration based tqdm with maxinterval effect\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        with tqdm(range(total), file=our_file, miniters=None,\n                  mininterval=1e-5, smoothing=1, maxinterval=1e-4) as t2:\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i >= (bigstep - 1) and ((i - (bigstep - 1)) % smallstep) == 0:\n                    timer.sleep(1e-2)\n                if i >= 3 * bigstep:\n                    break\n\n        assert \"15%\" in our_file.getvalue()\n\n    # Test different behavior with and without mininterval\n    timer = DiscreteTimer()\n    total = 1000\n    mininterval = 0.1\n    maxinterval = 10\n    with closing(StringIO()) as our_file:\n        with tqdm(total=total, file=our_file, miniters=None, smoothing=1,\n                  mininterval=mininterval, maxinterval=maxinterval) as tm1:\n            with tqdm(total=total, file=our_file, miniters=None, smoothing=1,\n                      mininterval=0, maxinterval=maxinterval) as tm2:\n\n                cpu_timify(tm1, timer)\n                cpu_timify(tm2, timer)\n\n                # Fast iterations, check if dynamic_miniters triggers\n                timer.sleep(mininterval)  # to force update for t1\n                tm1.update(total / 2)\n                tm2.update(total / 2)\n                assert int(tm1.miniters) == tm2.miniters == total / 2\n\n                # Slow iterations, check different miniters if mininterval\n                timer.sleep(maxinterval * 2)\n                tm1.update(total / 2)\n                tm2.update(total / 2)\n                res = [tm1.miniters, tm2.miniters]\n                assert res == [(total / 2) * mininterval / (maxinterval * 2),\n                               (total / 2) * maxinterval / (maxinterval * 2)]\n\n    # Same with iterable based tqdm\n    timer1 = DiscreteTimer()  # need 2 timers for each bar because zip not work\n    timer2 = DiscreteTimer()\n    total = 100\n    mininterval = 0.1\n    maxinterval = 10\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(range(total), file=our_file, miniters=None, smoothing=1,\n                  mininterval=mininterval, maxinterval=maxinterval)\n        t2 = tqdm(range(total), file=our_file, miniters=None, smoothing=1,\n                  mininterval=0, maxinterval=maxinterval)\n\n        cpu_timify(t1, timer1)\n        cpu_timify(t2, timer2)\n\n        for i in t1:\n            if i == ((total / 2) - 2):\n                timer1.sleep(mininterval)\n            if i == (total - 1):\n                timer1.sleep(maxinterval * 2)\n\n        for i in t2:\n            if i == ((total / 2) - 2):\n                timer2.sleep(mininterval)\n            if i == (total - 1):\n                timer2.sleep(maxinterval * 2)\n\n        assert t1.miniters == 0.255\n        assert t2.miniters == 0.5\n\n        t1.close()\n        t2.close()\n\n\ndef test_delay():\n    \"\"\"Test delay\"\"\"\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        t = tqdm(total=2, file=our_file, leave=True, delay=3)\n        cpu_timify(t, timer)\n        timer.sleep(2)\n        t.update(1)\n        assert not our_file.getvalue()\n        timer.sleep(2)\n        t.update(1)\n        assert our_file.getvalue()\n        t.close()\n\n\ndef test_min_iters():\n    \"\"\"Test miniters\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, leave=True, mininterval=0, miniters=2):\n            pass\n\n        out = our_file.getvalue()\n        assert '| 0/3 ' in out\n        assert '| 1/3 ' not in out\n        assert '| 2/3 ' in out\n        assert '| 3/3 ' in out\n\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, leave=True, mininterval=0, miniters=1):\n            pass\n\n        out = our_file.getvalue()\n        assert '| 0/3 ' in out\n        assert '| 1/3 ' in out\n        assert '| 2/3 ' in out\n        assert '| 3/3 ' in out\n\n\ndef test_dynamic_min_iters():\n    \"\"\"Test purely dynamic miniters (and manual updates and __del__)\"\"\"\n    with closing(StringIO()) as our_file:\n        total = 10\n        t = tqdm(total=total, file=our_file, miniters=None, mininterval=0, smoothing=1)\n\n        t.update()\n        # Increase 3 iterations\n        t.update(3)\n        # The next two iterations should be skipped because of dynamic_miniters\n        t.update()\n        t.update()\n        # The third iteration should be displayed\n        t.update()\n\n        out = our_file.getvalue()\n        assert t.dynamic_miniters\n        t.__del__()  # simulate immediate del gc\n\n    assert '  0%|          | 0/10 [00:00<' in out\n    assert '40%' in out\n    assert '50%' not in out\n    assert '60%' not in out\n    assert '70%' in out\n\n    # Check with smoothing=0, miniters should be set to max update seen so far\n    with closing(StringIO()) as our_file:\n        total = 10\n        t = tqdm(total=total, file=our_file, miniters=None, mininterval=0, smoothing=0)\n\n        t.update()\n        t.update(2)\n        t.update(5)  # this should be stored as miniters\n        t.update(1)\n\n        out = our_file.getvalue()\n        assert all(i in out for i in (\"0/10\", \"1/10\", \"3/10\"))\n        assert \"2/10\" not in out\n        assert t.dynamic_miniters and not t.smoothing\n        assert t.miniters == 5\n        t.close()\n\n    # Check iterable based tqdm\n    with closing(StringIO()) as our_file:\n        t = tqdm(range(10), file=our_file, miniters=None, mininterval=None,\n                 smoothing=0.5)\n        for _ in t:\n            pass\n        assert t.dynamic_miniters\n\n    # No smoothing\n    with closing(StringIO()) as our_file:\n        t = tqdm(range(10), file=our_file, miniters=None, mininterval=None,\n                 smoothing=0)\n        for _ in t:\n            pass\n        assert t.dynamic_miniters\n\n    # No dynamic_miniters (miniters is fixed manually)\n    with closing(StringIO()) as our_file:\n        t = tqdm(range(10), file=our_file, miniters=1, mininterval=None)\n        for _ in t:\n            pass\n        assert not t.dynamic_miniters\n\n\ndef test_big_min_interval():\n    \"\"\"Test large mininterval\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(2), file=our_file, mininterval=1E10):\n            pass\n        assert '50%' not in our_file.getvalue()\n\n    with closing(StringIO()) as our_file:\n        with tqdm(range(2), file=our_file, mininterval=1E10) as t:\n            t.update()\n            t.update()\n            assert '50%' not in our_file.getvalue()\n\n\ndef test_smoothed_dynamic_min_iters():\n    \"\"\"Test smoothed dynamic miniters\"\"\"\n    timer = DiscreteTimer()\n\n    with closing(StringIO()) as our_file:\n        with tqdm(total=100, file=our_file, miniters=None, mininterval=1,\n                  smoothing=0.5, maxinterval=0) as t:\n            cpu_timify(t, timer)\n\n            # Increase 10 iterations at once\n            timer.sleep(1)\n            t.update(10)\n            # The next iterations should be partially skipped\n            for _ in range(2):\n                timer.sleep(1)\n                t.update(4)\n            for _ in range(20):\n                timer.sleep(1)\n                t.update()\n\n            assert t.dynamic_miniters\n        out = our_file.getvalue()\n    assert '  0%|          | 0/100 [00:00<' in out\n    assert '20%' in out\n    assert '23%' not in out\n    assert '25%' in out\n    assert '26%' not in out\n    assert '28%' in out\n\n\ndef test_smoothed_dynamic_min_iters_with_min_interval():\n    \"\"\"Test smoothed dynamic miniters with mininterval\"\"\"\n    timer = DiscreteTimer()\n\n    # In this test, `miniters` should gradually decline\n    total = 100\n\n    with closing(StringIO()) as our_file:\n        # Test manual updating tqdm\n        with tqdm(total=total, file=our_file, miniters=None, mininterval=1e-3,\n                  smoothing=1, maxinterval=0) as t:\n            cpu_timify(t, timer)\n\n            t.update(10)\n            timer.sleep(1e-2)\n            for _ in range(4):\n                t.update()\n                timer.sleep(1e-2)\n            out = our_file.getvalue()\n            assert t.dynamic_miniters\n\n    with closing(StringIO()) as our_file:\n        # Test iteration-based tqdm\n        with tqdm(range(total), file=our_file, miniters=None,\n                  mininterval=0.01, smoothing=1, maxinterval=0) as t2:\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i >= 10:\n                    timer.sleep(0.1)\n                if i >= 14:\n                    break\n            out2 = our_file.getvalue()\n\n    assert t.dynamic_miniters\n    assert '  0%|          | 0/100 [00:00<' in out\n    assert '11%' in out and '11%' in out2\n    # assert '12%' not in out and '12%' in out2\n    assert '13%' in out and '13%' in out2\n    assert '14%' in out and '14%' in out2\n\n\n@mark.slow\ndef test_rlock_creation():\n    \"\"\"Test that importing tqdm does not create multiprocessing objects.\"\"\"\n    mp = importorskip('multiprocessing')\n    if not hasattr(mp, 'get_context'):\n        skip(\"missing multiprocessing.get_context\")\n\n    # Use 'spawn' instead of 'fork' so that the process does not inherit any\n    # globals that have been constructed by running other tests\n    ctx = mp.get_context('spawn')\n    with ctx.Pool(1) as pool:\n        # The pool will propagate the error if the target method fails\n        pool.apply(_rlock_creation_target)\n\n\ndef _rlock_creation_target():\n    \"\"\"Check that the RLock has not been constructed.\"\"\"\n    import multiprocessing as mp\n    patch = importorskip('unittest.mock').patch\n\n    # Patch the RLock class/method but use the original implementation\n    with patch('multiprocessing.RLock', wraps=mp.RLock) as rlock_mock:\n        # Importing the module should not create a lock\n        from tqdm import tqdm\n        assert rlock_mock.call_count == 0\n        # Creating a progress bar should initialize the lock\n        with closing(StringIO()) as our_file:\n            with tqdm(file=our_file) as _:  # NOQA\n                pass\n        assert rlock_mock.call_count == 1\n        # Creating a progress bar again should reuse the lock\n        with closing(StringIO()) as our_file:\n            with tqdm(file=our_file) as _:  # NOQA\n                pass\n        assert rlock_mock.call_count == 1\n\n\ndef test_disable():\n    \"\"\"Test disable\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, disable=True):\n            pass\n        assert our_file.getvalue() == ''\n\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=1, disable=True)\n        progressbar.update(3)\n        progressbar.close()\n        assert our_file.getvalue() == ''\n\n\ndef test_infinite_total():\n    \"\"\"Test treatment of infinite total\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, total=float(\"inf\")):\n            pass\n\n\ndef test_nototal():\n    \"\"\"Test unknown total length\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(iter(range(10)), file=our_file, unit_scale=10):\n            pass\n        assert \"100it\" in our_file.getvalue()\n\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(iter(range(10)), file=our_file,\n                      bar_format=\"{l_bar}{bar}{r_bar}\"):\n            pass\n        assert \"10/?\" in our_file.getvalue()\n\n\ndef test_unit():\n    \"\"\"Test SI unit prefix\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), file=our_file, miniters=1, unit=\"bytes\"):\n            pass\n        assert 'bytes/s' in our_file.getvalue()\n\n\ndef test_ascii():\n    \"\"\"Test ascii/unicode bar\"\"\"\n    # Test ascii autodetection\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, ascii=None) as t:\n            assert t.ascii  # TODO: this may fail in the future\n\n    # Test ascii bar\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(3), total=15, file=our_file, miniters=1,\n                      mininterval=0, ascii=True):\n            pass\n        res = our_file.getvalue().strip(\"\\r\").split(\"\\r\")\n    assert '7%|6' in res[1]\n    assert '13%|#3' in res[2]\n    assert '20%|##' in res[3]\n\n    # Test unicode bar\n    with closing(UnicodeIO()) as our_file:\n        with tqdm(total=15, file=our_file, ascii=False, mininterval=0) as t:\n            for _ in range(3):\n                t.update()\n        res = our_file.getvalue().strip(\"\\r\").split(\"\\r\")\n    assert u\"7%|\\u258b\" in res[1]\n    assert u\"13%|\\u2588\\u258e\" in res[2]\n    assert u\"20%|\\u2588\\u2588\" in res[3]\n\n    # Test custom bar\n    for bars in [\" .oO0\", \" #\"]:\n        with closing(StringIO()) as our_file:\n            for _ in tqdm(range(len(bars) - 1), file=our_file, miniters=1,\n                          mininterval=0, ascii=bars, ncols=27):\n                pass\n            res = our_file.getvalue().strip(\"\\r\").split(\"\\r\")\n        for b, line in zip(bars, res):\n            assert '|' + b + '|' in line\n\n\ndef test_update():\n    \"\"\"Test manual creation and updates\"\"\"\n    res = None\n    with closing(StringIO()) as our_file:\n        with tqdm(total=2, file=our_file, miniters=1, mininterval=0) as progressbar:\n            assert len(progressbar) == 2\n            progressbar.update(2)\n            assert '| 2/2' in our_file.getvalue()\n            progressbar.desc = 'dynamically notify of 4 increments in total'\n            progressbar.total = 4\n            progressbar.update(-1)\n            progressbar.update(2)\n        res = our_file.getvalue()\n    assert '| 3/4 ' in res\n    assert 'dynamically notify of 4 increments in total' in res\n\n\ndef test_close():\n    \"\"\"Test manual creation and closure and n_instances\"\"\"\n\n    # With `leave` option\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=10)\n        progressbar.update(3)\n        assert '| 3/3 ' not in our_file.getvalue()  # Should be blank\n        assert len(tqdm._instances) == 1\n        progressbar.close()\n        assert len(tqdm._instances) == 0\n        assert '| 3/3 ' in our_file.getvalue()\n\n    # Without `leave` option\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=10, leave=False)\n        progressbar.update(3)\n        progressbar.close()\n        assert '| 3/3 ' not in our_file.getvalue()  # Should be blank\n\n    # With all updates\n    with closing(StringIO()) as our_file:\n        assert len(tqdm._instances) == 0\n        with tqdm(total=3, file=our_file, miniters=0, mininterval=0,\n                  leave=True) as progressbar:\n            assert len(tqdm._instances) == 1\n            progressbar.update(3)\n            res = our_file.getvalue()\n            assert '| 3/3 ' in res  # Should be blank\n            assert '\\n' not in res\n        # close() called\n        assert len(tqdm._instances) == 0\n\n        exres = res.rsplit(', ', 1)[0]\n        res = our_file.getvalue()\n        assert res[-1] == '\\n'\n        if not res.startswith(exres):\n            raise AssertionError(f\"\\n<<< Expected:\\n{exres}, ...it/s]\\n>>> Got:\\n{res}\\n===\")\n\n    # Closing after the output stream has closed\n    with closing(StringIO()) as our_file:\n        t = tqdm(total=2, file=our_file)\n        t.update()\n        t.update()\n    t.close()\n\n\ndef test_ema():\n    \"\"\"Test exponential weighted average\"\"\"\n    ema = EMA(0.01)\n    assert round(ema(10), 2) == 10\n    assert round(ema(1), 2) == 5.48\n    assert round(ema(), 2) == 5.48\n    assert round(ema(1), 2) == 3.97\n    assert round(ema(1), 2) == 3.22\n\n\ndef test_smoothing():\n    \"\"\"Test exponential weighted average smoothing\"\"\"\n    timer = DiscreteTimer()\n\n    # -- Test disabling smoothing\n    with closing(StringIO()) as our_file:\n        with tqdm(range(3), file=our_file, smoothing=None, leave=True) as t:\n            cpu_timify(t, timer)\n\n            for _ in t:\n                pass\n        assert '| 3/3 ' in our_file.getvalue()\n\n    # -- Test smoothing\n    # 1st case: no smoothing (only use average)\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(range(3), file=our_file2, smoothing=None, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            with tqdm(range(3), file=our_file, smoothing=None, leave=True,\n                      miniters=1, mininterval=0) as t2:\n                cpu_timify(t2, timer)\n\n                for i in t2:\n                    # Sleep more for first iteration and\n                    # see how quickly rate is updated\n                    if i == 0:\n                        timer.sleep(0.01)\n                    else:\n                        # Need to sleep in all iterations\n                        # to calculate smoothed rate\n                        # (else delta_t is 0!)\n                        timer.sleep(0.001)\n                    t.update()\n            n_old = len(tqdm._instances)\n            t.close()\n            assert len(tqdm._instances) == n_old - 1\n            # Get result for iter-based bar\n            a = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        a2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # 2nd case: use max smoothing (= instant rate)\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(range(3), file=our_file2, smoothing=1, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            with tqdm(range(3), file=our_file, smoothing=1, leave=True,\n                      miniters=1, mininterval=0) as t2:\n                cpu_timify(t2, timer)\n\n                for i in t2:\n                    if i == 0:\n                        timer.sleep(0.01)\n                    else:\n                        timer.sleep(0.001)\n                    t.update()\n            t.close()\n            # Get result for iter-based bar\n            b = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        b2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # 3rd case: use medium smoothing\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(range(3), file=our_file2, smoothing=0.5, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            t2 = tqdm(range(3), file=our_file, smoothing=0.5, leave=True,\n                      miniters=1, mininterval=0)\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i == 0:\n                    timer.sleep(0.01)\n                else:\n                    timer.sleep(0.001)\n                t.update()\n            t2.close()\n            t.close()\n            # Get result for iter-based bar\n            c = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        c2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # Check that medium smoothing's rate is between no and max smoothing rates\n    assert a <= c <= b\n    assert a2 <= c2 <= b2\n\n\n@mark.skipif(nt_and_no_colorama, reason=\"Windows without colorama\")\ndef test_deprecated_nested():\n    \"\"\"Test nested progress bars\"\"\"\n    # TODO: test degradation on windows without colorama?\n\n    # Artificially test nested loop printing\n    # Without leave\n    our_file = StringIO()\n    try:\n        tqdm(total=2, file=our_file, nested=True)\n    except TqdmDeprecationWarning:\n        if \"\"\"`nested` is deprecated and automated.\nUse `position` instead for manual control.\"\"\" not in our_file.getvalue():\n            raise\n    else:\n        raise DeprecationError(\"Should not allow nested kwarg\")\n\n\ndef test_bar_format():\n    \"\"\"Test custom bar formatting\"\"\"\n    with closing(StringIO()) as our_file:\n        bar_format = ('{l_bar}{bar}|{n_fmt}/{total_fmt}-{n}/{total}'\n                      '{percentage}{rate}{rate_fmt}{elapsed}{remaining}')\n        for _ in trange(2, file=our_file, leave=True, bar_format=bar_format):\n            pass\n        out = our_file.getvalue()\n    assert \"\\r  0%|          |0/2-0/20.0None?it/s00:00?\\r\" in out\n\n    # Test unicode string auto conversion\n    with closing(StringIO()) as our_file:\n        bar_format = r'hello world'\n        with tqdm(ascii=False, bar_format=bar_format, file=our_file) as t:\n            assert isinstance(t.bar_format, str)\n\n\ndef test_custom_format():\n    \"\"\"Test adding additional derived format arguments\"\"\"\n    class TqdmExtraFormat(tqdm):\n        \"\"\"Provides a `total_time` format parameter\"\"\"\n        @property\n        def format_dict(self):\n            d = super().format_dict\n            total_time = d[\"elapsed\"] * (d[\"total\"] or 0) / max(d[\"n\"], 1)\n            d.update(total_time=self.format_interval(total_time) + \" in total\")\n            return d\n\n    with closing(StringIO()) as our_file:\n        for _ in TqdmExtraFormat(\n                range(10), file=our_file,\n                bar_format=\"{total_time}: {percentage:.0f}%|{bar}{r_bar}\"):\n            pass\n        assert \"00:00 in total\" in our_file.getvalue()\n\n\ndef test_eta(capsys):\n    \"\"\"Test eta bar_format\"\"\"\n    from datetime import datetime as dt\n    for _ in trange(999, miniters=1, mininterval=0, leave=True,\n                    bar_format='{l_bar}{eta:%Y-%m-%d}'):\n        pass\n    _, err = capsys.readouterr()\n    assert f\"\\r100%|{dt.now():%Y-%m-%d}\\n\" in err\n\n\ndef test_unpause():\n    \"\"\"Test unpause\"\"\"\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        t = trange(10, file=our_file, leave=True, mininterval=0)\n        cpu_timify(t, timer)\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.1)  # longer wait time\n        t.unpause()\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.01)\n        t.update()\n        t.close()\n        r_before = progressbar_rate(get_bar(our_file.getvalue(), 2))\n        r_after = progressbar_rate(get_bar(our_file.getvalue(), 3))\n    assert r_before == r_after\n\n\ndef test_disabled_unpause(capsys):\n    \"\"\"Test disabled unpause\"\"\"\n    with tqdm(total=10, disable=True) as t:\n        t.update()\n        t.unpause()\n        t.update()\n        print(t)\n    out, err = capsys.readouterr()\n    assert not err\n    assert out == '  0%|          | 0/10 [00:00<?, ?it/s]\\n'\n\n\ndef test_reset():\n    \"\"\"Test resetting a bar for re-use\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file,\n                  miniters=1, mininterval=0, maxinterval=0) as t:\n            t.update(9)\n            t.reset()\n            t.update()\n            t.reset(total=12)\n            t.update(10)\n        assert '| 1/10' in our_file.getvalue()\n        assert '| 10/12' in our_file.getvalue()\n\n\ndef test_disabled_reset(capsys):\n    \"\"\"Test disabled reset\"\"\"\n    with tqdm(total=10, disable=True) as t:\n        t.update(9)\n        t.reset()\n        t.update()\n        t.reset(total=12)\n        t.update(10)\n        print(t)\n    out, err = capsys.readouterr()\n    assert not err\n    assert out == '  0%|          | 0/12 [00:00<?, ?it/s]\\n'\n\n\n@mark.skipif(nt_and_no_colorama, reason=\"Windows without colorama\")\ndef test_position():\n    \"\"\"Test positioned progress bars\"\"\"\n    # Artificially test nested loop printing\n    # Without leave\n    our_file = StringIO()\n    kwargs = {'file': our_file, 'miniters': 1, 'mininterval': 0, 'maxinterval': 0}\n    t = tqdm(total=2, desc='pos2 bar', leave=False, position=2, **kwargs)\n    t.update()\n    t.close()\n    out = our_file.getvalue()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\n\\n\\rpos2 bar:   0%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\n\\r      ']\n\n    pos_line_diff(res, exres)\n\n    # Test iteration-based tqdm positioning\n    our_file = StringIO()\n    kwargs[\"file\"] = our_file\n    for _ in trange(2, desc='pos0 bar', position=0, **kwargs):\n        for _ in trange(2, desc='pos1 bar', position=1, **kwargs):\n            for _ in trange(2, desc='pos2 bar', position=2, **kwargs):\n                pass\n    out = our_file.getvalue()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\rpos0 bar:   0%',\n             '\\n\\rpos1 bar:   0%',\n             '\\n\\n\\rpos2 bar:   0%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\rpos2 bar: 100%',\n             '\\n\\n\\rpos1 bar:  50%',\n             '\\n\\n\\rpos2 bar:   0%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\rpos2 bar: 100%',\n             '\\n\\n\\rpos1 bar: 100%',\n             '\\rpos1 bar: 100%',\n             '\\n\\rpos0 bar:  50%',\n             '\\n\\rpos1 bar:   0%',\n             '\\n\\n\\rpos2 bar:   0%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\rpos2 bar: 100%',\n             '\\n\\n\\rpos1 bar:  50%',\n             '\\n\\n\\rpos2 bar:   0%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\rpos2 bar: 100%',\n             '\\n\\n\\rpos1 bar: 100%',\n             '\\rpos1 bar: 100%',\n             '\\n\\rpos0 bar: 100%',\n             '\\rpos0 bar: 100%',\n             '\\n']\n    pos_line_diff(res, exres)\n\n    # Test manual tqdm positioning\n    our_file = StringIO()\n    kwargs[\"file\"] = our_file\n    kwargs[\"total\"] = 2\n    t1 = tqdm(desc='pos0 bar', position=0, **kwargs)\n    t2 = tqdm(desc='pos1 bar', position=1, **kwargs)\n    t3 = tqdm(desc='pos2 bar', position=2, **kwargs)\n    for _ in range(2):\n        t1.update()\n        t3.update()\n        t2.update()\n    out = our_file.getvalue()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\rpos0 bar:   0%',\n             '\\n\\rpos1 bar:   0%',\n             '\\n\\n\\rpos2 bar:   0%',\n             '\\rpos0 bar:  50%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\n\\rpos1 bar:  50%',\n             '\\rpos0 bar: 100%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\n\\rpos1 bar: 100%']\n    pos_line_diff(res, exres)\n    t1.close()\n    t2.close()\n    t3.close()\n\n    # Test auto repositioning of bars when a bar is prematurely closed\n    # tqdm._instances.clear()  # reset number of instances\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='1.pos0 bar', mininterval=0)\n        t2 = tqdm(total=10, file=our_file, desc='2.pos1 bar', mininterval=0)\n        t3 = tqdm(total=10, file=our_file, desc='3.pos2 bar', mininterval=0)\n        res = [m[0] for m in RE_pos.findall(our_file.getvalue())]\n        exres = ['\\r1.pos0 bar:   0%',\n                 '\\n\\r2.pos1 bar:   0%',\n                 '\\n\\n\\r3.pos2 bar:   0%']\n        pos_line_diff(res, exres)\n\n        t2.close()\n        t4 = tqdm(total=10, file=our_file, desc='4.pos2 bar', mininterval=0)\n        t1.update(1)\n        t3.update(1)\n        t4.update(1)\n        res = [m[0] for m in RE_pos.findall(our_file.getvalue())]\n        exres = ['\\r1.pos0 bar:   0%',\n                 '\\n\\r2.pos1 bar:   0%',\n                 '\\n\\n\\r3.pos2 bar:   0%',\n                 '\\r2.pos1 bar:   0%',\n                 '\\n\\n\\r4.pos2 bar:   0%',\n                 '\\r1.pos0 bar:  10%',\n                 '\\n\\n\\r3.pos2 bar:  10%',\n                 '\\n\\r4.pos2 bar:  10%']\n        pos_line_diff(res, exres)\n        t4.close()\n        t3.close()\n        t1.close()\n\n\ndef test_set_description():\n    \"\"\"Test set description\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(desc='Hello', file=our_file) as t:\n            assert t.desc == 'Hello'\n            t.set_description_str('World')\n            assert t.desc == 'World'\n            t.set_description()\n            assert t.desc == ''\n            t.set_description('Bye')\n            assert t.desc == 'Bye: '\n        assert \"World\" in our_file.getvalue()\n\n    # without refresh\n    with closing(StringIO()) as our_file:\n        with tqdm(desc='Hello', file=our_file) as t:\n            assert t.desc == 'Hello'\n            t.set_description_str('World', False)\n            assert t.desc == 'World'\n            t.set_description(None, False)\n            assert t.desc == ''\n        assert \"World\" not in our_file.getvalue()\n\n    # unicode\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file) as t:\n            t.set_description(u\"\\xe1\\xe9\\xed\\xf3\\xfa\")\n\n\ndef test_deprecated_gui():\n    \"\"\"Test internal GUI properties\"\"\"\n    # Check: StatusPrinter iff gui is disabled\n    with closing(StringIO()) as our_file:\n        t = tqdm(total=2, gui=True, file=our_file, miniters=1, mininterval=0)\n        assert not hasattr(t, \"sp\")\n        try:\n            t.update(1)\n        except TqdmDeprecationWarning as e:\n            if (\n                'Please use `tqdm.gui.tqdm(...)` instead of `tqdm(..., gui=True)`'\n                not in our_file.getvalue()\n            ):\n                raise e\n        else:\n            raise DeprecationError('Should not allow manual gui=True without'\n                                   ' overriding __iter__() and update()')\n        finally:\n            t._instances.clear()\n            # t.close()\n            # len(tqdm._instances) += 1  # undo the close() decrement\n\n        t = tqdm(range(3), gui=True, file=our_file, miniters=1, mininterval=0)\n        try:\n            for _ in t:\n                pass\n        except TqdmDeprecationWarning as e:\n            if (\n                'Please use `tqdm.gui.tqdm(...)` instead of `tqdm(..., gui=True)`'\n                not in our_file.getvalue()\n            ):\n                raise e\n        else:\n            raise DeprecationError('Should not allow manual gui=True without'\n                                   ' overriding __iter__() and update()')\n        finally:\n            t._instances.clear()\n            # t.close()\n            # len(tqdm._instances) += 1  # undo the close() decrement\n\n        with tqdm(total=1, gui=False, file=our_file) as t:\n            assert hasattr(t, \"sp\")\n\n\ndef test_cmp():\n    \"\"\"Test comparison functions\"\"\"\n    with closing(StringIO()) as our_file:\n        t0 = tqdm(total=10, file=our_file)\n        t1 = tqdm(total=10, file=our_file)\n        t2 = tqdm(total=10, file=our_file)\n\n        assert t0 < t1\n        assert t2 >= t0\n        assert t0 <= t2\n\n        t3 = tqdm(total=10, file=our_file)\n        t4 = tqdm(total=10, file=our_file)\n        t5 = tqdm(total=10, file=our_file)\n        t5.close()\n        t6 = tqdm(total=10, file=our_file)\n\n        assert t3 != t4\n        assert t3 > t2\n        assert t5 == t6\n        t6.close()\n        t4.close()\n        t3.close()\n        t2.close()\n        t1.close()\n        t0.close()\n\n\ndef test_repr():\n    \"\"\"Test representation\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, ascii=True, file=our_file) as t:\n            assert str(t) == '  0%|          | 0/10 [00:00<?, ?it/s]'\n\n\ndef test_clear():\n    \"\"\"Test clearing bar display\"\"\"\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar', bar_format='{l_bar}')\n        t2 = trange(10, file=our_file, desc='pos1 bar', bar_format='{l_bar}')\n        before = squash_ctrlchars(our_file.getvalue())\n        t2.clear()\n        t1.clear()\n        after = squash_ctrlchars(our_file.getvalue())\n        t1.close()\n        t2.close()\n        assert before == ['pos0 bar:   0%|', 'pos1 bar:   0%|']\n        assert after == ['', '']\n\n\ndef test_clear_disabled():\n    \"\"\"Test disabled clear\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, desc='pos0 bar', disable=True,\n                  bar_format='{l_bar}') as t:\n            t.clear()\n        assert our_file.getvalue() == ''\n\n\ndef test_refresh():\n    \"\"\"Test refresh bar display\"\"\"\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{l_bar}', mininterval=999, miniters=999)\n        t2 = tqdm(total=10, file=our_file, desc='pos1 bar',\n                  bar_format='{l_bar}', mininterval=999, miniters=999)\n        t1.update()\n        t2.update()\n        before = squash_ctrlchars(our_file.getvalue())\n        t1.refresh()\n        t2.refresh()\n        after = squash_ctrlchars(our_file.getvalue())\n        t1.close()\n        t2.close()\n\n        # Check that refreshing indeed forced the display to use realtime state\n        assert before == [u'pos0 bar:   0%|', u'pos1 bar:   0%|']\n        assert after == [u'pos0 bar:  10%|', u'pos1 bar:  10%|']\n\n\ndef test_disabled_repr(capsys):\n    \"\"\"Test disabled repr\"\"\"\n    with tqdm(total=10, disable=True) as t:\n        str(t)\n        t.update()\n        print(t)\n    out, err = capsys.readouterr()\n    assert not err\n    assert out == '  0%|          | 0/10 [00:00<?, ?it/s]\\n'\n\n\ndef test_disabled_refresh():\n    \"\"\"Test disabled refresh\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, desc='pos0 bar', disable=True,\n                  bar_format='{l_bar}', mininterval=999, miniters=999) as t:\n            t.update()\n            t.refresh()\n\n        assert our_file.getvalue() == ''\n\n\ndef test_write():\n    \"\"\"Test write messages\"\"\"\n    s = \"Hello world\"\n    with closing(StringIO()) as our_file:\n        # Change format to keep only left part w/o bar and it/s rate\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{l_bar}', mininterval=0, miniters=1)\n        t2 = trange(10, file=our_file, desc='pos1 bar', bar_format='{l_bar}',\n                    mininterval=0, miniters=1)\n        t3 = tqdm(total=10, file=our_file, desc='pos2 bar',\n                  bar_format='{l_bar}', mininterval=0, miniters=1)\n        t1.update()\n        t2.update()\n        t3.update()\n        before = our_file.getvalue()\n\n        # Write msg and see if bars are correctly redrawn below the msg\n        t1.write(s, file=our_file)  # call as an instance method\n        tqdm.write(s, file=our_file)  # call as a class method\n        after = our_file.getvalue()\n\n        t1.close()\n        t2.close()\n        t3.close()\n\n        before_squashed = squash_ctrlchars(before)\n        after_squashed = squash_ctrlchars(after)\n\n        assert after_squashed == [s, s] + before_squashed\n\n    # Check that no bar clearing if different file\n    with closing(StringIO()) as our_file_bar:\n        with closing(StringIO()) as our_file_write:\n            t1 = tqdm(total=10, file=our_file_bar, desc='pos0 bar',\n                      bar_format='{l_bar}', mininterval=0, miniters=1)\n\n            t1.update()\n            before_bar = our_file_bar.getvalue()\n\n            tqdm.write(s, file=our_file_write)\n\n            after_bar = our_file_bar.getvalue()\n            t1.close()\n\n            assert before_bar == after_bar\n\n    # Test stdout/stderr anti-mixup strategy\n    # Backup stdout/stderr\n    stde = sys.stderr\n    stdo = sys.stdout\n    # Mock stdout/stderr\n    with closing(StringIO()) as our_stderr:\n        with closing(StringIO()) as our_stdout:\n            sys.stderr = our_stderr\n            sys.stdout = our_stdout\n            t1 = tqdm(total=10, file=sys.stderr, desc='pos0 bar',\n                      bar_format='{l_bar}', mininterval=0, miniters=1)\n\n            t1.update()\n            before_err = sys.stderr.getvalue()\n            before_out = sys.stdout.getvalue()\n\n            tqdm.write(s, file=sys.stdout)\n            after_err = sys.stderr.getvalue()\n            after_out = sys.stdout.getvalue()\n\n            t1.close()\n\n            assert before_err == '\\rpos0 bar:   0%|\\rpos0 bar:  10%|'\n            assert before_out == ''\n            after_err_res = [m[0] for m in RE_pos.findall(after_err)]\n            exres = ['\\rpos0 bar:   0%|',\n                     '\\rpos0 bar:  10%|',\n                     '\\r               ',\n                     '\\r\\rpos0 bar:  10%|']\n            pos_line_diff(after_err_res, exres)\n            assert after_out == s + '\\n'\n    # Restore stdout and stderr\n    sys.stderr = stde\n    sys.stdout = stdo\n\n\ndef test_len():\n    \"\"\"Test advance len (numpy array shape)\"\"\"\n    np = importorskip('numpy')\n    with closing(StringIO()) as f:\n        with tqdm(np.zeros((3, 4)), file=f) as t:\n            assert len(t) == 3\n\n\ndef test_autodisable_disable():\n    \"\"\"Test autodisable will disable on non-TTY\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, disable=None, file=our_file) as t:\n            t.update(3)\n        assert our_file.getvalue() == ''\n\n\ndef test_autodisable_enable():\n    \"\"\"Test autodisable will not disable on TTY\"\"\"\n    with closing(StringIO()) as our_file:\n        our_file.isatty = lambda: True\n        with tqdm(total=10, disable=None, file=our_file) as t:\n            t.update()\n        assert our_file.getvalue() != ''\n\n\ndef test_deprecation_exception():\n    def test_TqdmDeprecationWarning():\n        with closing(StringIO()) as our_file:\n            raise (TqdmDeprecationWarning('Test!', fp_write=getattr(\n                our_file, 'write', sys.stderr.write)))\n\n    def test_TqdmDeprecationWarning_nofpwrite():\n        raise TqdmDeprecationWarning('Test!', fp_write=None)\n\n    raises(TqdmDeprecationWarning, test_TqdmDeprecationWarning)\n    raises(Exception, test_TqdmDeprecationWarning_nofpwrite)\n\n\ndef test_postfix():\n    \"\"\"Test postfix\"\"\"\n    postfix = {'float': 0.321034, 'gen': 543, 'str': 'h', 'lst': [2]}\n    postfix_order = (('w', 'w'), ('a', 0))  # no need for OrderedDict\n    expected = ['float=0.321', 'gen=543', 'lst=[2]', 'str=h']\n    expected_order = ['w=w', 'a=0', 'float=0.321', 'gen=543', 'lst=[2]', 'str=h']\n\n    # Test postfix set at init\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{r_bar}', postfix=postfix) as t1:\n            t1.refresh()\n            out = our_file.getvalue()\n\n    # Test postfix set after init\n    with closing(StringIO()) as our_file:\n        with trange(10, file=our_file, desc='pos1 bar', bar_format='{r_bar}',\n                    postfix=None) as t2:\n            t2.set_postfix(**postfix)\n            t2.refresh()\n            out2 = our_file.getvalue()\n\n    # Order of items in dict may change, so need a loop to check per item\n    for res in expected:\n        assert res in out\n        assert res in out2\n\n    # Test postfix (with ordered dict and no refresh) set after init\n    with closing(StringIO()) as our_file:\n        with trange(10, file=our_file, desc='pos2 bar', bar_format='{r_bar}',\n                    postfix=None) as t3:\n            t3.set_postfix(postfix_order, False, **postfix)\n            t3.refresh()  # explicit external refresh\n            out3 = our_file.getvalue()\n\n    out3 = out3[1:-1].split(', ')[3:]\n    assert out3 == expected_order\n\n    # Test postfix (with ordered dict and refresh) set after init\n    with closing(StringIO()) as our_file:\n        with trange(10, file=our_file, desc='pos2 bar',\n                    bar_format='{r_bar}', postfix=None) as t4:\n            t4.set_postfix(postfix_order, True, **postfix)\n            t4.refresh()  # double refresh\n            out4 = our_file.getvalue()\n\n    assert out4.count('\\r') > out3.count('\\r')\n    assert out4.count(\", \".join(expected_order)) == 2\n\n    # Test setting postfix string directly\n    with closing(StringIO()) as our_file:\n        with trange(10, file=our_file, desc='pos2 bar', bar_format='{r_bar}',\n                    postfix=None) as t5:\n            t5.set_postfix_str(\"Hello\", False)\n            t5.set_postfix_str(\"World\")\n            out5 = our_file.getvalue()\n\n    assert \"Hello\" not in out5\n    out5 = out5[1:-1].split(', ')[3:]\n    assert out5 == [\"World\"]\n\n\ndef test_postfix_direct():\n    \"\"\"Test directly assigning non-str objects to postfix\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, miniters=1, mininterval=0,\n                  bar_format=\"{postfix[0][name]} {postfix[1]:>5.2f}\",\n                  postfix=[{'name': \"foo\"}, 42]) as t:\n            for i in range(10):\n                if i % 2:\n                    t.postfix[0][\"name\"] = \"abcdefghij\"[i]\n                else:\n                    t.postfix[1] = i\n                t.update()\n        res = our_file.getvalue()\n        assert \"f  6.00\" in res\n        assert \"h  6.00\" in res\n        assert \"h  8.00\" in res\n        assert \"j  8.00\" in res\n\n\n@contextmanager\ndef std_out_err_redirect_tqdm(tqdm_file=sys.stderr):\n    orig_out_err = sys.stdout, sys.stderr\n    try:\n        sys.stdout = sys.stderr = DummyTqdmFile(tqdm_file)\n        yield orig_out_err[0]\n    # Relay exceptions\n    except Exception as exc:\n        raise exc\n    # Always restore sys.stdout/err if necessary\n    finally:\n        sys.stdout, sys.stderr = orig_out_err\n\n\ndef test_file_redirection():\n    \"\"\"Test redirection of output\"\"\"\n    with closing(StringIO()) as our_file:\n        # Redirect stdout to tqdm.write()\n        with std_out_err_redirect_tqdm(tqdm_file=our_file):\n            with tqdm(total=3) as pbar:\n                print(\"Such fun\")\n                pbar.update(1)\n                print(\"Such\", \"fun\")\n                pbar.update(1)\n                print(\"Such \", end=\"\")\n                print(\"fun\")\n                pbar.update(1)\n        res = our_file.getvalue()\n        assert res.count(\"Such fun\\n\") == 3\n        assert \"0/3\" in res\n        assert \"3/3\" in res\n\n\ndef test_external_write():\n    \"\"\"Test external write mode\"\"\"\n    with closing(StringIO()) as our_file:\n        # Redirect stdout to tqdm.write()\n        for _ in trange(3, file=our_file):\n            del tqdm._lock  # classmethod should be able to recreate lock\n            with tqdm.external_write_mode(file=our_file):\n                our_file.write(\"Such fun\\n\")\n        res = our_file.getvalue()\n        assert res.count(\"Such fun\\n\") == 3\n        assert \"0/3\" in res\n        assert \"3/3\" in res\n\n\ndef test_unit_scale():\n    \"\"\"Test numeric `unit_scale`\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(9), unit_scale=9, file=our_file,\n                      miniters=1, mininterval=0):\n            pass\n        out = our_file.getvalue()\n        assert '81/81' in out\n\n\ndef patch_lock(thread=True):\n    \"\"\"decorator replacing tqdm's lock with vanilla threading/multiprocessing\"\"\"\n    try:\n        if thread:\n            from threading import RLock\n        else:\n            from multiprocessing import RLock\n        lock = RLock()\n    except (ImportError, OSError) as err:\n        skip(str(err))\n\n    def outer(func):\n        \"\"\"actual decorator\"\"\"\n        @wraps(func)\n        def inner(*args, **kwargs):\n            \"\"\"set & reset lock even if exceptions occur\"\"\"\n            default_lock = tqdm.get_lock()\n            try:\n                tqdm.set_lock(lock)\n                return func(*args, **kwargs)\n            finally:\n                tqdm.set_lock(default_lock)\n        return inner\n    return outer\n\n\n@patch_lock(thread=False)\ndef test_threading():\n    \"\"\"Test multiprocess/thread-realted features\"\"\"\n    pass  # TODO: test interleaved output #445\n\n\ndef test_bool():\n    \"\"\"Test boolean cast\"\"\"\n    def internal(our_file, disable):\n        kwargs = {'file': our_file, 'disable': disable}\n        with trange(10, **kwargs) as t:\n            assert t\n        with trange(0, **kwargs) as t:\n            assert not t\n        with tqdm(total=10, **kwargs) as t:\n            assert bool(t)\n        with tqdm(total=0, **kwargs) as t:\n            assert not bool(t)\n        with tqdm([], **kwargs) as t:\n            assert not t\n        with tqdm([0], **kwargs) as t:\n            assert t\n        with tqdm(iter([]), **kwargs) as t:\n            assert t\n        with tqdm(iter([1, 2, 3]), **kwargs) as t:\n            assert t\n        with tqdm(**kwargs) as t:\n            try:\n                print(bool(t))\n            except TypeError:\n                pass\n            else:\n                raise TypeError(\"Expected bool(tqdm()) to fail\")\n\n    # test with and without disable\n    with closing(StringIO()) as our_file:\n        internal(our_file, False)\n        internal(our_file, True)\n\n\ndef backendCheck(module):\n    \"\"\"Test tqdm-like module fallback\"\"\"\n    tn = module.tqdm\n    tr = module.trange\n\n    with closing(StringIO()) as our_file:\n        with tn(total=10, file=our_file) as t:\n            assert len(t) == 10\n        with tr(1337) as t:\n            assert len(t) == 1337\n\n\ndef test_auto():\n    \"\"\"Test auto fallback\"\"\"\n    from tqdm import auto, autonotebook\n    backendCheck(autonotebook)\n    backendCheck(auto)\n\n\ndef test_wrapattr():\n    \"\"\"Test wrapping file-like objects\"\"\"\n    data = \"a twenty-char string\"\n\n    with closing(StringIO()) as our_file:\n        with closing(StringIO()) as writer:\n            with tqdm.wrapattr(writer, \"write\", file=our_file, bytes=True) as wrap:\n                wrap.write(data)\n            res = writer.getvalue()\n            assert data == res\n        res = our_file.getvalue()\n        assert '%.1fB [' % len(data) in res\n\n    with closing(StringIO()) as our_file:\n        with closing(StringIO()) as writer:\n            with tqdm.wrapattr(writer, \"write\", file=our_file, bytes=False) as wrap:\n                wrap.write(data)\n        res = our_file.getvalue()\n        assert '%dit [' % len(data) in res\n\n\ndef test_float_progress():\n    \"\"\"Test float totals\"\"\"\n    with closing(StringIO()) as our_file:\n        with trange(10, total=9.6, file=our_file) as t:\n            with catch_warnings(record=True) as w:\n                simplefilter(\"always\", category=TqdmWarning)\n                for i in t:\n                    if i < 9:\n                        assert not w\n                assert w\n                assert \"clamping frac\" in str(w[-1].message)\n\n\ndef test_screen_shape():\n    \"\"\"Test screen shape\"\"\"\n    # ncols\n    with closing(StringIO()) as our_file:\n        with trange(10, file=our_file, ncols=50) as t:\n            list(t)\n\n        res = our_file.getvalue()\n        assert all(len(i) == 50 for i in get_bar(res))\n\n    # no second/third bar, leave=False\n    with closing(StringIO()) as our_file:\n        kwargs = {'file': our_file, 'ncols': 50, 'nrows': 2, 'miniters': 0,\n                  'mininterval': 0, 'leave': False}\n        with trange(10, desc=\"one\", **kwargs) as t1:\n            with trange(10, desc=\"two\", **kwargs) as t2:\n                with trange(10, desc=\"three\", **kwargs) as t3:\n                    list(t3)\n                list(t2)\n            list(t1)\n\n        res = our_file.getvalue()\n        assert \"one\" in res\n        assert \"two\" not in res\n        assert \"three\" not in res\n        assert \"\\n\\n\" not in res\n        assert \"more hidden\" in res\n        # double-check ncols\n        assert all(len(i) == 50 for i in get_bar(res)\n                   if i.strip() and \"more hidden\" not in i)\n\n    # all bars, leave=True\n    with closing(StringIO()) as our_file:\n        kwargs = {'file': our_file, 'ncols': 50, 'nrows': 2,\n                  'miniters': 0, 'mininterval': 0}\n        with trange(10, desc=\"one\", **kwargs) as t1:\n            with trange(10, desc=\"two\", **kwargs) as t2:\n                assert \"two\" not in our_file.getvalue()\n                with trange(10, desc=\"three\", **kwargs) as t3:\n                    assert \"three\" not in our_file.getvalue()\n                    list(t3)\n                list(t2)\n            list(t1)\n\n        res = our_file.getvalue()\n        assert \"one\" in res\n        assert \"two\" in res\n        assert \"three\" in res\n        assert \"\\n\\n\" not in res\n        assert \"more hidden\" in res\n        # double-check ncols\n        assert all(len(i) == 50 for i in get_bar(res)\n                   if i.strip() and \"more hidden\" not in i)\n\n    # second bar becomes first, leave=False\n    with closing(StringIO()) as our_file:\n        kwargs = {'file': our_file, 'ncols': 50, 'nrows': 2, 'miniters': 0,\n                  'mininterval': 0, 'leave': False}\n        t1 = tqdm(total=10, desc=\"one\", **kwargs)\n        with tqdm(total=10, desc=\"two\", **kwargs) as t2:\n            t1.update()\n            t2.update()\n            t1.close()\n            res = our_file.getvalue()\n            assert \"one\" in res\n            assert \"two\" not in res\n            assert \"more hidden\" in res\n            t2.update()\n\n        res = our_file.getvalue()\n        assert \"two\" in res\n\n\ndef test_initial():\n    \"\"\"Test `initial`\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(9), initial=10, total=19, file=our_file,\n                      miniters=1, mininterval=0):\n            pass\n        out = our_file.getvalue()\n        assert '10/19' in out\n        assert '19/19' in out\n\n\ndef test_colour():\n    \"\"\"Test `colour`\"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(range(9), file=our_file, colour=\"#beefed\"):\n            pass\n        out = our_file.getvalue()\n        assert '\\x1b[38;2;%d;%d;%dm' % (0xbe, 0xef, 0xed) in out\n\n        with catch_warnings(record=True) as w:\n            simplefilter(\"always\", category=TqdmWarning)\n            with tqdm(total=1, file=our_file, colour=\"charm\") as t:\n                assert w\n                t.update()\n            assert \"Unknown colour\" in str(w[-1].message)\n\n    with closing(StringIO()) as our_file2:\n        for _ in tqdm(range(9), file=our_file2, colour=\"blue\"):\n            pass\n        out = our_file2.getvalue()\n        assert '\\x1b[34m' in out\n\n\ndef test_closed():\n    \"\"\"Test writing to closed file\"\"\"\n    with closing(StringIO()) as our_file:\n        for i in trange(9, file=our_file, miniters=1, mininterval=0):\n            if i == 5:\n                our_file.close()\n\n\ndef test_reversed(capsys):\n    \"\"\"Test reversed()\"\"\"\n    for _ in reversed(tqdm(range(9))):\n        pass\n    out, err = capsys.readouterr()\n    assert not out\n    assert '  0%' in err\n    assert '100%' in err\n\n\ndef test_contains(capsys):\n    \"\"\"Test __contains__ doesn't iterate\"\"\"\n    with tqdm(list(range(9))) as t:\n        assert 9 not in t\n        assert all(i in t for i in range(9))\n    out, err = capsys.readouterr()\n    assert not out\n    assert '  0%' in err\n    assert '100%' not in err\n", "tests/tests_pandas.py": "from tqdm import tqdm\n\nfrom .tests_tqdm import StringIO, closing, importorskip, mark, skip\n\npytestmark = mark.slow\n\nnp = importorskip('numpy')\nrandom = importorskip('numpy.random')\nrand = random.rand\nrandint = random.randint\npd = importorskip('pandas')\n\n\ndef test_pandas_setup():\n    \"\"\"Test tqdm.pandas()\"\"\"\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=True, ascii=True, total=123)\n        series = pd.Series(randint(0, 50, (100,)))\n        series.progress_apply(lambda x: x + 10)\n        res = our_file.getvalue()\n        assert '100/123' in res\n\n\ndef test_pandas_rolling_expanding():\n    \"\"\"Test pandas.(Series|DataFrame).(rolling|expanding)\"\"\"\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=True, ascii=True)\n\n        series = pd.Series(randint(0, 50, (123,)))\n        res1 = series.rolling(10).progress_apply(lambda x: 1, raw=True)\n        res2 = series.rolling(10).apply(lambda x: 1, raw=True)\n        assert res1.equals(res2)\n\n        res3 = series.expanding(10).progress_apply(lambda x: 2, raw=True)\n        res4 = series.expanding(10).apply(lambda x: 2, raw=True)\n        assert res3.equals(res4)\n\n        expects = ['114it']  # 123-10+1\n        for exres in expects:\n            our_file.seek(0)\n            if our_file.getvalue().count(exres) < 2:\n                our_file.seek(0)\n                raise AssertionError(\n                    f\"\\nExpected:\\n{exres} at least twice.\\nIn:\\n{our_file.read()}\\n\")\n\n\ndef test_pandas_series():\n    \"\"\"Test pandas.Series.progress_apply and .progress_map\"\"\"\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=True, ascii=True)\n\n        series = pd.Series(randint(0, 50, (123,)))\n        res1 = series.progress_apply(lambda x: x + 10)\n        res2 = series.apply(lambda x: x + 10)\n        assert res1.equals(res2)\n\n        res3 = series.progress_map(lambda x: x + 10)\n        res4 = series.map(lambda x: x + 10)\n        assert res3.equals(res4)\n\n        expects = ['100%', '123/123']\n        for exres in expects:\n            our_file.seek(0)\n            if our_file.getvalue().count(exres) < 2:\n                our_file.seek(0)\n                raise AssertionError(\n                    f\"\\nExpected:\\n{exres} at least twice.\\nIn:\\n{our_file.read()}\\n\")\n\n\n@mark.filterwarnings(\"ignore:DataFrame.applymap has been deprecated:FutureWarning\")\ndef test_pandas_data_frame():\n    \"\"\"Test pandas.DataFrame.progress_apply and .progress_applymap\"\"\"\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=True, ascii=True)\n        df = pd.DataFrame(randint(0, 50, (100, 200)))\n\n        def task_func(x):\n            return x + 1\n\n        # applymap\n        res1 = df.progress_applymap(task_func)\n        res2 = df.applymap(task_func)\n        assert res1.equals(res2)\n\n        # map\n        if hasattr(df, 'map'):  # pandas>=2.1.0\n            res1 = df.progress_map(task_func)\n            res2 = df.map(task_func)\n            assert res1.equals(res2)\n\n        # apply unhashable\n        res1 = []\n        df.progress_apply(res1.extend)\n        assert len(res1) == df.size\n\n        # apply\n        for axis in [0, 1, 'index', 'columns']:\n            res3 = df.progress_apply(task_func, axis=axis)\n            res4 = df.apply(task_func, axis=axis)\n            assert res3.equals(res4)\n\n        our_file.seek(0)\n        if our_file.read().count('100%') < 3:\n            our_file.seek(0)\n            raise AssertionError(\n                f\"\\nExpected:\\n100% at least three times\\nIn:\\n{our_file.read()}\\n\")\n\n        # apply_map, apply axis=0, apply axis=1\n        expects = ['20000/20000', '200/200', '100/100']\n        for exres in expects:\n            our_file.seek(0)\n            if our_file.getvalue().count(exres) < 1:\n                our_file.seek(0)\n                raise AssertionError(\n                    f\"\\nExpected:\\n{exres} at least once.\\nIn:\\n{our_file.read()}\\n\")\n\n\n@mark.filterwarnings(\n    \"ignore:DataFrameGroupBy.apply operated on the grouping columns:DeprecationWarning\")\ndef test_pandas_groupby_apply():\n    \"\"\"Test pandas.DataFrame.groupby(...).progress_apply\"\"\"\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=False, ascii=True)\n\n        df = pd.DataFrame(randint(0, 50, (500, 3)))\n        df.groupby(0).progress_apply(lambda x: None)\n\n        dfs = pd.DataFrame(randint(0, 50, (500, 3)), columns=list('abc'))\n        dfs.groupby(['a']).progress_apply(lambda x: None)\n\n        df2 = df = pd.DataFrame({'a': randint(1, 8, 10000), 'b': rand(10000)})\n        res1 = df2.groupby(\"a\").apply(np.maximum.reduce)\n        res2 = df2.groupby(\"a\").progress_apply(np.maximum.reduce)\n        assert res1.equals(res2)\n\n        our_file.seek(0)\n\n        # don't expect final output since no `leave` and\n        # high dynamic `miniters`\n        nexres = '100%|##########|'\n        if nexres in our_file.read():\n            our_file.seek(0)\n            raise AssertionError(f\"\\nDid not expect:\\n{nexres}\\nIn:{our_file.read()}\\n\")\n\n    with closing(StringIO()) as our_file:\n        tqdm.pandas(file=our_file, leave=True, ascii=True)\n\n        dfs = pd.DataFrame(randint(0, 50, (500, 3)), columns=list('abc'))\n        dfs.loc[0] = [2, 1, 1]\n        dfs['d'] = 100\n\n        expects = ['500/500', '1/1', '4/4', '4/4']\n        dfs.groupby(dfs.index).progress_apply(lambda x: None)\n        dfs.groupby('d').progress_apply(lambda x: None)\n        dfs.T.groupby(dfs.columns).progress_apply(lambda x: None)\n        dfs.T.groupby([2, 2, 1, 1]).progress_apply(lambda x: None)\n\n        our_file.seek(0)\n        if our_file.read().count('100%') < 4:\n            our_file.seek(0)\n            raise AssertionError(\n                f\"\\nExpected:\\n100% at least four times\\nIn:\\n{our_file.read()}\\n\")\n\n        for exres in expects:\n            our_file.seek(0)\n            if our_file.getvalue().count(exres) < 1:\n                our_file.seek(0)\n                raise AssertionError(\n                    f\"\\nExpected:\\n{exres} at least once.\\nIn:\\n{our_file.read()}\\n\")\n\n\n@mark.filterwarnings(\n    \"ignore:DataFrameGroupBy.apply operated on the grouping columns:DeprecationWarning\")\ndef test_pandas_leave():\n    \"\"\"Test pandas with `leave=True`\"\"\"\n    with closing(StringIO()) as our_file:\n        df = pd.DataFrame(randint(0, 100, (1000, 6)))\n        tqdm.pandas(file=our_file, leave=True, ascii=True)\n        df.groupby(0).progress_apply(lambda x: None)\n\n        our_file.seek(0)\n\n        exres = '100%|##########| 100/100'\n        if exres not in our_file.read():\n            our_file.seek(0)\n            raise AssertionError(f\"\\nExpected:\\n{exres}\\nIn:{our_file.read()}\\n\")\n\n\ndef test_pandas_apply_args_deprecation():\n    \"\"\"Test warning info in\n    `pandas.Dataframe(Series).progress_apply(func, *args)`\"\"\"\n    try:\n        from tqdm import tqdm_pandas\n    except ImportError as err:\n        skip(str(err))\n\n    with closing(StringIO()) as our_file:\n        tqdm_pandas(tqdm(file=our_file, leave=False, ascii=True, ncols=20))\n        df = pd.DataFrame(randint(0, 50, (500, 3)))\n        df.progress_apply(lambda x: None, 1)  # 1 shall cause a warning\n        # Check deprecation message\n        res = our_file.getvalue()\n        assert all(i in res for i in (\n            \"TqdmDeprecationWarning\", \"not supported\",\n            \"keyword arguments instead\"))\n\n\n@mark.filterwarnings(\n    \"ignore:DataFrameGroupBy.apply operated on the grouping columns:DeprecationWarning\")\ndef test_pandas_deprecation():\n    \"\"\"Test bar object instance as argument deprecation\"\"\"\n    try:\n        from tqdm import tqdm_pandas\n    except ImportError as err:\n        skip(str(err))\n\n    with closing(StringIO()) as our_file:\n        tqdm_pandas(tqdm(file=our_file, leave=False, ascii=True, ncols=20))\n        df = pd.DataFrame(randint(0, 50, (500, 3)))\n        df.groupby(0).progress_apply(lambda x: None)\n        # Check deprecation message\n        assert \"TqdmDeprecationWarning\" in our_file.getvalue()\n        assert \"instead of `tqdm_pandas(tqdm(...))`\" in our_file.getvalue()\n\n    with closing(StringIO()) as our_file:\n        tqdm_pandas(tqdm, file=our_file, leave=False, ascii=True, ncols=20)\n        df = pd.DataFrame(randint(0, 50, (500, 3)))\n        df.groupby(0).progress_apply(lambda x: None)\n        # Check deprecation message\n        assert \"TqdmDeprecationWarning\" in our_file.getvalue()\n        assert \"instead of `tqdm_pandas(tqdm, ...)`\" in our_file.getvalue()\n", "tests/tests_version.py": "\"\"\"Test `tqdm.__version__`.\"\"\"\nimport re\nfrom ast import literal_eval\n\n\ndef test_version():\n    \"\"\"Test version string\"\"\"\n    from tqdm import __version__\n    version_parts = re.split('[.-]', __version__)\n    if __version__ != \"UNKNOWN\":\n        assert 3 <= len(version_parts), \"must have at least Major.minor.patch\"\n        assert all(\n            isinstance(literal_eval(i), int) for i in version_parts[:3]\n        ), \"Version Major.minor.patch must be 3 integers\"\n", "tests/conftest.py": "\"\"\"Shared pytest config.\"\"\"\nimport sys\n\nfrom pytest import fixture\n\nfrom tqdm import tqdm\n\n\n@fixture(autouse=True)\ndef pretest_posttest():\n    \"\"\"Fixture for all tests ensuring environment cleanup\"\"\"\n    try:\n        sys.setswitchinterval(1)\n    except AttributeError:\n        sys.setcheckinterval(100)  # deprecated\n\n    if getattr(tqdm, \"_instances\", False):\n        n = len(tqdm._instances)\n        if n:\n            tqdm._instances.clear()\n            raise EnvironmentError(f\"{n} `tqdm` instances still in existence PRE-test\")\n    yield\n    if getattr(tqdm, \"_instances\", False):\n        n = len(tqdm._instances)\n        if n:\n            tqdm._instances.clear()\n            raise EnvironmentError(f\"{n} `tqdm` instances still in existence POST-test\")\n", "tests/tests_itertools.py": "\"\"\"\nTests for `tqdm.contrib.itertools`.\n\"\"\"\nimport itertools as it\n\nfrom tqdm.contrib.itertools import product\n\nfrom .tests_tqdm import StringIO, closing\n\n\nclass NoLenIter(object):\n    def __init__(self, iterable):\n        self._it = iterable\n\n    def __iter__(self):\n        for i in self._it:\n            yield i\n\n\ndef test_product():\n    \"\"\"Test contrib.itertools.product\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        assert list(product(a, a[::-1], file=our_file)) == list(it.product(a, a[::-1]))\n\n        assert list(product(a, NoLenIter(a), file=our_file)) == list(it.product(a, NoLenIter(a)))\n", "tests/tests_synchronisation.py": "from functools import wraps\nfrom threading import Event\nfrom time import sleep, time\n\nfrom tqdm import TMonitor, tqdm, trange\n\nfrom .tests_tqdm import StringIO, closing, importorskip, patch_lock, skip\n\n\nclass Time(object):\n    \"\"\"Fake time class class providing an offset\"\"\"\n    offset = 0\n\n    @classmethod\n    def reset(cls):\n        \"\"\"zeroes internal offset\"\"\"\n        cls.offset = 0\n\n    @classmethod\n    def time(cls):\n        \"\"\"time.time() + offset\"\"\"\n        return time() + cls.offset\n\n    @staticmethod\n    def sleep(dur):\n        \"\"\"identical to time.sleep()\"\"\"\n        sleep(dur)\n\n    @classmethod\n    def fake_sleep(cls, dur):\n        \"\"\"adds `dur` to internal offset\"\"\"\n        cls.offset += dur\n        sleep(0.000001)  # sleep to allow interrupt (instead of pass)\n\n\nclass FakeEvent(Event):\n    \"\"\"patched `threading.Event` where `wait()` uses `Time.fake_sleep()`\"\"\"\n    def wait(self, timeout=None):\n        \"\"\"uses Time.fake_sleep\"\"\"\n        if timeout is not None:\n            Time.fake_sleep(timeout)\n        return self.is_set()\n\n\ndef patch_sleep(func):\n    \"\"\"Temporarily makes TMonitor use Time.fake_sleep\"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        \"\"\"restores TMonitor on completion regardless of Exceptions\"\"\"\n        TMonitor._test[\"time\"] = Time.time\n        TMonitor._test[\"Event\"] = FakeEvent\n        if tqdm.monitor:\n            assert not tqdm.monitor.get_instances()\n            tqdm.monitor.exit()\n            del tqdm.monitor\n            tqdm.monitor = None\n        try:\n            return func(*args, **kwargs)\n        finally:\n            # Check that class var monitor is deleted if no instance left\n            tqdm.monitor_interval = 10\n            if tqdm.monitor:\n                assert not tqdm.monitor.get_instances()\n                tqdm.monitor.exit()\n                del tqdm.monitor\n                tqdm.monitor = None\n            TMonitor._test.pop(\"Event\")\n            TMonitor._test.pop(\"time\")\n\n    return inner\n\n\ndef cpu_timify(t, timer=Time):\n    \"\"\"Force tqdm to use the specified timer instead of system-wide time\"\"\"\n    t._time = timer.time\n    t._sleep = timer.fake_sleep\n    t.start_t = t.last_print_t = t._time()\n    return timer\n\n\nclass FakeTqdm(object):\n    _instances = set()\n    get_lock = tqdm.get_lock\n\n\ndef incr(x):\n    return x + 1\n\n\ndef incr_bar(x):\n    with closing(StringIO()) as our_file:\n        for _ in trange(x, lock_args=(False,), file=our_file):\n            pass\n    return incr(x)\n\n\n@patch_sleep\ndef test_monitor_thread():\n    \"\"\"Test dummy monitoring thread\"\"\"\n    monitor = TMonitor(FakeTqdm, 10)\n    # Test if alive, then killed\n    assert monitor.report()\n    monitor.exit()\n    assert not monitor.report()\n    assert not monitor.is_alive()\n    del monitor\n\n\n@patch_sleep\ndef test_monitoring_and_cleanup():\n    \"\"\"Test for stalled tqdm instance and monitor deletion\"\"\"\n    # Note: should fix miniters for these tests, else with dynamic_miniters\n    # it's too complicated to handle with monitoring update and maxinterval...\n    maxinterval = tqdm.monitor_interval\n    assert maxinterval == 10\n    total = 1000\n\n    with closing(StringIO()) as our_file:\n        with tqdm(total=total, file=our_file, miniters=500, mininterval=0.1,\n                  maxinterval=maxinterval) as t:\n            cpu_timify(t, Time)\n            # Do a lot of iterations in a small timeframe\n            # (smaller than monitor interval)\n            Time.fake_sleep(maxinterval / 10)  # monitor won't wake up\n            t.update(500)\n            # check that our fixed miniters is still there\n            assert t.miniters <= 500  # TODO: should really be == 500\n            # Then do 1 it after monitor interval, so that monitor kicks in\n            Time.fake_sleep(maxinterval)\n            t.update(1)\n            # Wait for the monitor to get out of sleep's loop and update tqdm.\n            timeend = Time.time()\n            while not (t.monitor.woken >= timeend and t.miniters == 1):\n                Time.fake_sleep(1)  # Force awake up if it woken too soon\n            assert t.miniters == 1  # check that monitor corrected miniters\n            # Note: at this point, there may be a race condition: monitor saved\n            # current woken time but Time.sleep() happen just before monitor\n            # sleep. To fix that, either sleep here or increase time in a loop\n            # to ensure that monitor wakes up at some point.\n\n            # Try again but already at miniters = 1 so nothing will be done\n            Time.fake_sleep(maxinterval)\n            t.update(2)\n            timeend = Time.time()\n            while t.monitor.woken < timeend:\n                Time.fake_sleep(1)  # Force awake if it woken too soon\n            # Wait for the monitor to get out of sleep's loop and update\n            # tqdm\n            assert t.miniters == 1  # check that monitor corrected miniters\n\n\n@patch_sleep\ndef test_monitoring_multi():\n    \"\"\"Test on multiple bars, one not needing miniters adjustment\"\"\"\n    # Note: should fix miniters for these tests, else with dynamic_miniters\n    # it's too complicated to handle with monitoring update and maxinterval...\n    maxinterval = tqdm.monitor_interval\n    assert maxinterval == 10\n    total = 1000\n\n    with closing(StringIO()) as our_file:\n        with tqdm(total=total, file=our_file, miniters=500, mininterval=0.1,\n                  maxinterval=maxinterval) as t1:\n            # Set high maxinterval for t2 so monitor does not need to adjust it\n            with tqdm(total=total, file=our_file, miniters=500, mininterval=0.1,\n                      maxinterval=1E5) as t2:\n                cpu_timify(t1, Time)\n                cpu_timify(t2, Time)\n                # Do a lot of iterations in a small timeframe\n                Time.fake_sleep(maxinterval / 10)\n                t1.update(500)\n                t2.update(500)\n                assert t1.miniters <= 500  # TODO: should really be == 500\n                assert t2.miniters == 500\n                # Then do 1 it after monitor interval, so that monitor kicks in\n                Time.fake_sleep(maxinterval)\n                t1.update(1)\n                t2.update(1)\n                # Wait for the monitor to get out of sleep and update tqdm\n                timeend = Time.time()\n                while not (t1.monitor.woken >= timeend and t1.miniters == 1):\n                    Time.fake_sleep(1)\n                assert t1.miniters == 1  # check that monitor corrected miniters\n                assert t2.miniters == 500  # check that t2 was not adjusted\n\n\ndef test_imap():\n    \"\"\"Test multiprocessing.Pool\"\"\"\n    try:\n        from multiprocessing import Pool\n    except ImportError as err:\n        skip(str(err))\n\n    pool = Pool()\n    res = list(tqdm(pool.imap(incr, range(100)), disable=True))\n    pool.close()\n    assert res[-1] == 100\n\n\n@patch_lock(thread=True)\ndef test_threadpool():\n    \"\"\"Test concurrent.futures.ThreadPoolExecutor\"\"\"\n    ThreadPoolExecutor = importorskip('concurrent.futures').ThreadPoolExecutor\n\n    with ThreadPoolExecutor(8) as pool:\n        res = list(tqdm(pool.map(incr_bar, range(100)), disable=True))\n    assert sum(res) == sum(range(1, 101))\n", "tests/tests_contrib_logging.py": "# pylint: disable=missing-module-docstring, missing-class-docstring\n# pylint: disable=missing-function-docstring, no-self-use\nimport logging\nimport logging.handlers\nimport sys\nfrom io import StringIO\n\nimport pytest\n\nfrom tqdm import tqdm\nfrom tqdm.contrib.logging import _get_first_found_console_logging_handler\nfrom tqdm.contrib.logging import _TqdmLoggingHandler as TqdmLoggingHandler\nfrom tqdm.contrib.logging import logging_redirect_tqdm, tqdm_logging_redirect\n\nfrom .tests_tqdm import importorskip\n\nLOGGER = logging.getLogger(__name__)\n\nTEST_LOGGING_FORMATTER = logging.Formatter()\n\n\nclass CustomTqdm(tqdm):\n    messages = []\n\n    @classmethod\n    def write(cls, s, **__):  # pylint: disable=arguments-differ\n        CustomTqdm.messages.append(s)\n\n\nclass ErrorRaisingTqdm(tqdm):\n    exception_class = RuntimeError\n\n    @classmethod\n    def write(cls, s, **__):  # pylint: disable=arguments-differ\n        raise ErrorRaisingTqdm.exception_class('fail fast')\n\n\nclass TestTqdmLoggingHandler:\n    def test_should_call_tqdm_write(self):\n        CustomTqdm.messages = []\n        logger = logging.Logger('test')\n        logger.handlers = [TqdmLoggingHandler(CustomTqdm)]\n        logger.info('test')\n        assert CustomTqdm.messages == ['test']\n\n    def test_should_call_handle_error_if_exception_was_thrown(self):\n        patch = importorskip('unittest.mock').patch\n        logger = logging.Logger('test')\n        ErrorRaisingTqdm.exception_class = RuntimeError\n        handler = TqdmLoggingHandler(ErrorRaisingTqdm)\n        logger.handlers = [handler]\n        with patch.object(handler, 'handleError') as mock:\n            logger.info('test')\n            assert mock.called\n\n    @pytest.mark.parametrize('exception_class', [\n        KeyboardInterrupt,\n        SystemExit\n    ])\n    def test_should_not_swallow_certain_exceptions(self, exception_class):\n        logger = logging.Logger('test')\n        ErrorRaisingTqdm.exception_class = exception_class\n        handler = TqdmLoggingHandler(ErrorRaisingTqdm)\n        logger.handlers = [handler]\n        with pytest.raises(exception_class):\n            logger.info('test')\n\n\nclass TestGetFirstFoundConsoleLoggingHandler:\n    def test_should_return_none_for_no_handlers(self):\n        assert _get_first_found_console_logging_handler([]) is None\n\n    def test_should_return_none_without_stream_handler(self):\n        handler = logging.handlers.MemoryHandler(capacity=1)\n        assert _get_first_found_console_logging_handler([handler]) is None\n\n    def test_should_return_none_for_stream_handler_not_stdout_or_stderr(self):\n        handler = logging.StreamHandler(StringIO())\n        assert _get_first_found_console_logging_handler([handler]) is None\n\n    def test_should_return_stream_handler_if_stream_is_stdout(self):\n        handler = logging.StreamHandler(sys.stdout)\n        assert _get_first_found_console_logging_handler([handler]) == handler\n\n    def test_should_return_stream_handler_if_stream_is_stderr(self):\n        handler = logging.StreamHandler(sys.stderr)\n        assert _get_first_found_console_logging_handler([handler]) == handler\n\n\nclass TestRedirectLoggingToTqdm:\n    def test_should_add_and_remove_tqdm_handler(self):\n        logger = logging.Logger('test')\n        with logging_redirect_tqdm(loggers=[logger]):\n            assert len(logger.handlers) == 1\n            assert isinstance(logger.handlers[0], TqdmLoggingHandler)\n        assert not logger.handlers\n\n    def test_should_remove_and_restore_console_handlers(self):\n        logger = logging.Logger('test')\n        stderr_console_handler = logging.StreamHandler(sys.stderr)\n        stdout_console_handler = logging.StreamHandler(sys.stderr)\n        logger.handlers = [stderr_console_handler, stdout_console_handler]\n        with logging_redirect_tqdm(loggers=[logger]):\n            assert len(logger.handlers) == 1\n            assert isinstance(logger.handlers[0], TqdmLoggingHandler)\n        assert logger.handlers == [stderr_console_handler, stdout_console_handler]\n\n    def test_should_inherit_console_logger_formatter(self):\n        logger = logging.Logger('test')\n        formatter = logging.Formatter('custom: %(message)s')\n        console_handler = logging.StreamHandler(sys.stderr)\n        console_handler.setFormatter(formatter)\n        logger.handlers = [console_handler]\n        with logging_redirect_tqdm(loggers=[logger]):\n            assert logger.handlers[0].formatter == formatter\n\n    def test_should_not_remove_stream_handlers_not_for_stdout_or_stderr(self):\n        logger = logging.Logger('test')\n        stream_handler = logging.StreamHandler(StringIO())\n        logger.addHandler(stream_handler)\n        with logging_redirect_tqdm(loggers=[logger]):\n            assert len(logger.handlers) == 2\n            assert logger.handlers[0] == stream_handler\n            assert isinstance(logger.handlers[1], TqdmLoggingHandler)\n        assert logger.handlers == [stream_handler]\n\n\nclass TestTqdmWithLoggingRedirect:\n    def test_should_add_and_remove_handler_from_root_logger_by_default(self):\n        original_handlers = list(logging.root.handlers)\n        with tqdm_logging_redirect(total=1) as pbar:\n            assert isinstance(logging.root.handlers[-1], TqdmLoggingHandler)\n            LOGGER.info('test')\n            pbar.update(1)\n        assert logging.root.handlers == original_handlers\n\n    def test_should_add_and_remove_handler_from_custom_logger(self):\n        logger = logging.Logger('test')\n        with tqdm_logging_redirect(total=1, loggers=[logger]) as pbar:\n            assert len(logger.handlers) == 1\n            assert isinstance(logger.handlers[0], TqdmLoggingHandler)\n            logger.info('test')\n            pbar.update(1)\n        assert not logger.handlers\n\n    def test_should_not_fail_with_logger_without_console_handler(self):\n        logger = logging.Logger('test')\n        logger.handlers = []\n        with tqdm_logging_redirect(total=1, loggers=[logger]):\n            logger.info('test')\n        assert not logger.handlers\n\n    def test_should_format_message(self):\n        logger = logging.Logger('test')\n        console_handler = logging.StreamHandler(sys.stdout)\n        console_handler.setFormatter(logging.Formatter(\n            r'prefix:%(message)s'\n        ))\n        logger.handlers = [console_handler]\n        CustomTqdm.messages = []\n        with tqdm_logging_redirect(loggers=[logger], tqdm_class=CustomTqdm):\n            logger.info('test')\n        assert CustomTqdm.messages == ['prefix:test']\n\n    def test_use_root_logger_by_default_and_write_to_custom_tqdm(self):\n        logger = logging.root\n        CustomTqdm.messages = []\n        with tqdm_logging_redirect(total=1, tqdm_class=CustomTqdm) as pbar:\n            assert isinstance(pbar, CustomTqdm)\n            logger.info('test')\n            assert CustomTqdm.messages == ['test']\n", "tests/tests_notebook.py": "from tqdm.notebook import tqdm as tqdm_notebook\n\n\ndef test_notebook_disabled_description():\n    \"\"\"Test that set_description works for disabled tqdm_notebook\"\"\"\n    with tqdm_notebook(1, disable=True) as t:\n        t.set_description(\"description\")\n", "tests/tests_concurrent.py": "\"\"\"\nTests for `tqdm.contrib.concurrent`.\n\"\"\"\nfrom pytest import warns\n\nfrom tqdm.contrib.concurrent import process_map, thread_map\n\nfrom .tests_tqdm import StringIO, TqdmWarning, closing, importorskip, mark, skip\n\n\ndef incr(x):\n    \"\"\"Dummy function\"\"\"\n    return x + 1\n\n\ndef test_thread_map():\n    \"\"\"Test contrib.concurrent.thread_map\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        b = [i + 1 for i in a]\n        try:\n            assert thread_map(lambda x: x + 1, a, file=our_file) == b\n        except ImportError as err:\n            skip(str(err))\n        assert thread_map(incr, a, file=our_file) == b\n\n\ndef test_process_map():\n    \"\"\"Test contrib.concurrent.process_map\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        b = [i + 1 for i in a]\n        try:\n            assert process_map(incr, a, file=our_file) == b\n        except ImportError as err:\n            skip(str(err))\n\n\n@mark.parametrize(\"iterables,should_warn\", [([], False), (['x'], False), ([()], False),\n                                            (['x', ()], False), (['x' * 1001], True),\n                                            (['x' * 100, ('x',) * 1001], True)])\ndef test_chunksize_warning(iterables, should_warn):\n    \"\"\"Test contrib.concurrent.process_map chunksize warnings\"\"\"\n    patch = importorskip('unittest.mock').patch\n    with patch('tqdm.contrib.concurrent._executor_map'):\n        if should_warn:\n            warns(TqdmWarning, process_map, incr, *iterables)\n        else:\n            process_map(incr, *iterables)\n", "tests/tests_contrib.py": "\"\"\"\nTests for `tqdm.contrib`.\n\"\"\"\nimport pytest\n\nfrom tqdm import tqdm\nfrom tqdm.contrib import tenumerate, tmap, tzip\n\nfrom .tests_tqdm import StringIO, closing, importorskip\n\n\ndef incr(x):\n    \"\"\"Dummy function\"\"\"\n    return x + 1\n\n\n@pytest.mark.parametrize(\"tqdm_kwargs\", [{}, {\"tqdm_class\": tqdm}])\ndef test_enumerate(tqdm_kwargs):\n    \"\"\"Test contrib.tenumerate\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        assert list(tenumerate(a, file=our_file, **tqdm_kwargs)) == list(enumerate(a))\n        assert list(tenumerate(a, 42, file=our_file, **tqdm_kwargs)) == list(\n            enumerate(a, 42)\n        )\n    with closing(StringIO()) as our_file:\n        _ = list(tenumerate(iter(a), file=our_file, **tqdm_kwargs))\n        assert \"100%\" not in our_file.getvalue()\n    with closing(StringIO()) as our_file:\n        _ = list(tenumerate(iter(a), file=our_file, total=len(a), **tqdm_kwargs))\n        assert \"100%\" in our_file.getvalue()\n\n\ndef test_enumerate_numpy():\n    \"\"\"Test contrib.tenumerate(numpy.ndarray)\"\"\"\n    np = importorskip(\"numpy\")\n    with closing(StringIO()) as our_file:\n        a = np.random.random((42, 7))\n        assert list(tenumerate(a, file=our_file)) == list(np.ndenumerate(a))\n\n\n@pytest.mark.parametrize(\"tqdm_kwargs\", [{}, {\"tqdm_class\": tqdm}])\ndef test_zip(tqdm_kwargs):\n    \"\"\"Test contrib.tzip\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        b = [i + 1 for i in a]\n        gen = tzip(a, b, file=our_file, **tqdm_kwargs)\n        assert gen != list(zip(a, b))\n        assert list(gen) == list(zip(a, b))\n\n\n@pytest.mark.parametrize(\"tqdm_kwargs\", [{}, {\"tqdm_class\": tqdm}])\ndef test_map(tqdm_kwargs):\n    \"\"\"Test contrib.tmap\"\"\"\n    with closing(StringIO()) as our_file:\n        a = range(9)\n        b = [i + 1 for i in a]\n        gen = tmap(lambda x: x + 1, a, file=our_file, **tqdm_kwargs)\n        assert gen != b\n        assert list(gen) == b\n", "tests/tests_asyncio.py": "\"\"\"Tests `tqdm.asyncio`.\"\"\"\nimport asyncio\nfrom functools import partial\nfrom sys import platform\nfrom time import time\n\nfrom tqdm.asyncio import tarange, tqdm_asyncio\n\nfrom .tests_tqdm import StringIO, closing, mark\n\ntqdm = partial(tqdm_asyncio, miniters=0, mininterval=0)\ntrange = partial(tarange, miniters=0, mininterval=0)\nas_completed = partial(tqdm_asyncio.as_completed, miniters=0, mininterval=0)\ngather = partial(tqdm_asyncio.gather, miniters=0, mininterval=0)\n\n\ndef count(start=0, step=1):\n    i = start\n    while True:\n        new_start = yield i\n        if new_start is None:\n            i += step\n        else:\n            i = new_start\n\n\nasync def acount(*args, **kwargs):\n    for i in count(*args, **kwargs):\n        yield i\n\n\n@mark.asyncio\nasync def test_break():\n    \"\"\"Test asyncio break\"\"\"\n    pbar = tqdm(count())\n    async for _ in pbar:\n        break\n    pbar.close()\n\n\n@mark.asyncio\nasync def test_generators(capsys):\n    \"\"\"Test asyncio generators\"\"\"\n    with tqdm(count(), desc=\"counter\") as pbar:\n        async for i in pbar:\n            if i >= 8:\n                break\n    _, err = capsys.readouterr()\n    assert '9it' in err\n\n    with tqdm(acount(), desc=\"async_counter\") as pbar:\n        async for i in pbar:\n            if i >= 8:\n                break\n    _, err = capsys.readouterr()\n    assert '9it' in err\n\n\n@mark.asyncio\nasync def test_range():\n    \"\"\"Test asyncio range\"\"\"\n    with closing(StringIO()) as our_file:\n        async for _ in tqdm(range(9), desc=\"range\", file=our_file):\n            pass\n        assert '9/9' in our_file.getvalue()\n        our_file.seek(0)\n        our_file.truncate()\n\n        async for _ in trange(9, desc=\"trange\", file=our_file):\n            pass\n        assert '9/9' in our_file.getvalue()\n\n\n@mark.asyncio\nasync def test_nested():\n    \"\"\"Test asyncio nested\"\"\"\n    with closing(StringIO()) as our_file:\n        async for _ in tqdm(trange(9, desc=\"inner\", file=our_file),\n                            desc=\"outer\", file=our_file):\n            pass\n        assert 'inner: 100%' in our_file.getvalue()\n        assert 'outer: 100%' in our_file.getvalue()\n\n\n@mark.asyncio\nasync def test_coroutines():\n    \"\"\"Test asyncio coroutine.send\"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(count(), file=our_file) as pbar:\n            async for i in pbar:\n                if i == 9:\n                    pbar.send(-10)\n                elif i < 0:\n                    assert i == -9\n                    break\n        assert '10it' in our_file.getvalue()\n\n\n@mark.slow\n@mark.asyncio\n@mark.parametrize(\"tol\", [0.2 if platform.startswith(\"darwin\") else 0.1])\nasync def test_as_completed(capsys, tol):\n    \"\"\"Test asyncio as_completed\"\"\"\n    for retry in range(3):\n        t = time()\n        skew = time() - t\n        for i in as_completed([asyncio.sleep(0.01 * i) for i in range(30, 0, -1)]):\n            await i\n        t = time() - t - 2 * skew\n        try:\n            assert 0.3 * (1 - tol) < t < 0.3 * (1 + tol), t\n            _, err = capsys.readouterr()\n            assert '30/30' in err\n        except AssertionError:\n            if retry == 2:\n                raise\n\n\nasync def double(i):\n    return i * 2\n\n\n@mark.asyncio\nasync def test_gather(capsys):\n    \"\"\"Test asyncio gather\"\"\"\n    res = await gather(*map(double, range(30)))\n    _, err = capsys.readouterr()\n    assert '30/30' in err\n    assert res == list(range(0, 30 * 2, 2))\n", "tests/__init__.py": "", "tests/tests_dask.py": "from time import sleep\n\nfrom .tests_tqdm import importorskip, mark\n\npytestmark = mark.slow\n\n\ndef test_dask(capsys):\n    \"\"\"Test tqdm.dask.TqdmCallback\"\"\"\n    ProgressBar = importorskip('tqdm.dask').TqdmCallback\n    dask = importorskip('dask')\n\n    schedule = [dask.delayed(sleep)(i / 10) for i in range(5)]\n    with ProgressBar(desc=\"computing\"):\n        dask.compute(schedule)\n    _, err = capsys.readouterr()\n    assert \"computing: \" in err\n    assert '5/5' in err\n", "tests/tests_tk.py": "\"\"\"Test `tqdm.tk`.\"\"\"\nfrom .tests_tqdm import importorskip\n\n\ndef test_tk_import():\n    \"\"\"Test `tqdm.tk` import\"\"\"\n    importorskip('tqdm.tk')\n", "tests/tests_gui.py": "\"\"\"Test `tqdm.gui`.\"\"\"\nfrom .tests_tqdm import importorskip\n\n\ndef test_gui_import():\n    \"\"\"Test `tqdm.gui` import\"\"\"\n    importorskip('tqdm.gui')\n", "benchmarks/benchmarks.py": "# Write the benchmarking functions here.\n# See \"Writing benchmarks\" in the asv docs for more information.\nfrom functools import partial\n\n\nclass Comparison:\n    \"\"\"Running time of wrapped empty loops\"\"\"\n    def __init__(self, length):\n        try:\n            from time import process_time\n            self.time = process_time\n        except ImportError:\n            from time import clock\n            self.time = clock\n        self.iterable = range(int(length))\n\n    def run(self, cls):\n        pbar = cls(self.iterable)\n        t0 = self.time()\n        [0 for _ in pbar]  # pylint: disable=pointless-statement\n        t1 = self.time()\n        return t1 - t0\n\n    def run_by_name(self, method):\n        return getattr(self, method.replace(\"-\", \"_\"))()\n\n    def no_progress(self):\n        return self.run(lambda x: x)\n\n    def tqdm_optimised(self):\n        from tqdm import tqdm\n        return self.run(partial(tqdm, miniters=6e5, smoothing=0))\n\n    def tqdm(self):\n        from tqdm import tqdm\n        return self.run(tqdm)\n\n    def alive_progress(self):\n        from alive_progress import alive_bar\n\n        class wrapper:\n            def __init__(self, iterable):\n                self.iterable = iterable\n\n            def __iter__(self):\n                iterable = self.iterable\n                with alive_bar(len(iterable)) as bar:\n                    for i in iterable:\n                        yield i\n                        bar()\n\n        return self.run(wrapper)\n\n    # def progressbar(self):\n    #     from progressbar.progressbar import ProgressBar\n    #     return self.run(ProgressBar())\n\n    def progressbar2(self):\n        from progressbar import progressbar\n        return self.run(progressbar)\n\n    def rich(self):\n        from rich.progress import track\n        return self.run(track)\n\n\n# thorough test against no-progress\nslow = Comparison(6e6)\n\n\ndef track_tqdm(method):\n    return slow.run_by_name(method)\n\n\ntrack_tqdm.params = [\"tqdm\", \"tqdm-optimised\", \"no-progress\"]\ntrack_tqdm.param_names = [\"method\"]\ntrack_tqdm.unit = \"Seconds (lower is better)\"\n\n# quick test against alternatives\nfast = Comparison(1e5)\n\n\ndef track_alternatives(library):\n    return fast.run_by_name(library)\n\n\ntrack_alternatives.params = [\"rich\", \"progressbar2\", \"alive-progress\", \"tqdm\"]\ntrack_alternatives.param_names = [\"library\"]\ntrack_alternatives.unit = \"Seconds (lower is better)\"\n", "benchmarks/__init__.py": "", ".meta/mksnap.py": "# -*- encoding: utf-8 -*-\n\"\"\"\nAuto-generate snapcraft.yaml.\n\"\"\"\nimport sys\nfrom pathlib import Path\nfrom subprocess import check_output  # nosec\n\nsys.path.insert(1, str(Path(__file__).parent.parent))\nimport tqdm  # NOQA\n\nsnap_yml = r\"\"\"name: tqdm\nsummary: A fast, extensible CLI progress bar\ndescription: |\n https://tqdm.github.io\n\n `tqdm` means \"progress\" in Arabic (taqadum, \u062a\u0642\u062f\u0651\u0645) and is an\n abbreviation for \"I love you so much\" in Spanish (te quiero demasiado).\n\n Instantly make your loops show a smart progress meter and stats - just\n replace any pipe \"`|`\" with \"`| tqdm |`\", and you're done!\n\n ```sh\n $ seq 9999999 | tqdm --bytes | wc -l\n 75.2MB [00:00, 217MB/s]\n 9999999\n $ 7z a -bd -r backup.7z docs/ | grep Compressing | \\\n     tqdm --total $(find docs/ -type f | wc -l) --unit files >> backup.log\n 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 8014/8014 [01:37<00:00, 82.29files/s]\n ```\n\n Overhead is low -- about 60ns per iteration.\n\n In addition to its low overhead, `tqdm` uses smart algorithms to predict\n the remaining time and to skip unnecessary iteration displays, which\n allows for a negligible overhead in most cases.\n\n `tqdm` works on any platform (Linux, Windows, Mac, FreeBSD, NetBSD,\n Solaris/SunOS), in any console or in a GUI, and is also friendly with\n IPython/Jupyter notebooks.\n\n `tqdm` does not require any dependencies, just\n an environment supporting `carriage return \\r` and\n `line feed \\n` control characters.\ngrade: stable\nconfinement: strict\nbase: core22\nicon: logo.png\nversion: '{version}'\nlicense: MPL-2.0\nparts:\n  tqdm:\n    plugin: python\n    source: .\n    source-commit: '{commit}'\n    python-packages: [.]\n    build-packages: [git]\n    override-build: |\n        craftctl default\n        cp $SNAPCRAFT_PART_BUILD/tqdm/completion.sh $SNAPCRAFT_PART_INSTALL/\napps:\n  tqdm:\n    command: bin/tqdm\n    completer: completion.sh\n\"\"\".format(version=tqdm.__version__, commit=check_output([\n    'git', 'describe', '--always']).decode('utf-8').strip())  # nosec\n\nif __name__ == \"__main__\":\n    (Path(__file__).resolve().parent.parent / 'snapcraft.yaml').write_text(\n        snap_yml.decode('utf-8') if hasattr(snap_yml, 'decode') else snap_yml, encoding='utf-8')\n", ".meta/mkdocs.py": "\"\"\"\nAuto-generate README.rst from .meta/.readme.rst and docstrings.\n\"\"\"\nimport sys\nfrom pathlib import Path\nfrom textwrap import dedent\n\nsys.path.insert(0, str(Path(__file__).parent.parent))\nimport tqdm  # NOQA\nimport tqdm.cli  # NOQA\n\nHEAD_ARGS = \"\"\"\nParameters\n----------\n\"\"\"\nHEAD_RETS = \"\"\"\nReturns\n-------\n\"\"\"\nHEAD_CLI = \"\"\"\nExtra CLI Options\n-----------------\nname  : type, optional\n    TODO: find out why this is needed.\n\"\"\"\n\n\ndef doc2rst(doc, arglist=True, raw=False):\n    \"\"\"\n    arglist  : bool, whether to create argument lists\n    raw  : bool, ignores arglist and indents by 2 spaces\n    \"\"\"\n    doc = doc.replace('`', '``')\n    if raw:\n        doc = doc.replace('\\n ', '\\n   ')\n    else:\n        doc = dedent(doc)\n        if arglist:\n            doc = '\\n'.join(i if not i or i[0] == ' ' else '* ' + i + '  '\n                            for i in doc.split('\\n'))\n    return doc\n\n\nsrc_dir = Path(__file__).parent.resolve()\nREADME_rst = (src_dir / '.readme.rst').read_text(\"utf-8\")\nclass_doc, init_doc = tqdm.tqdm.__doc__.split('\\n\\n', 1)\nDOC_tqdm = doc2rst(class_doc + '\\n', False).replace('\\n', '\\n      ')\nDOC_tqdm_init = doc2rst('\\n' + init_doc)\nDOC_tqdm_init_args = DOC_tqdm_init.partition(doc2rst(HEAD_ARGS))[-1].replace(\n    '\\n      ', '\\n    ').replace('\\n      ', '\\n    ')\nDOC_tqdm_init_args, _, DOC_tqdm_init_rets = DOC_tqdm_init_args.partition(doc2rst(HEAD_RETS))\nDOC_cli = doc2rst(tqdm.cli.CLI_EXTRA_DOC).partition(doc2rst(HEAD_CLI))[-1]\nDOC_tqdm_tqdm = {}\nfor i in dir(tqdm.tqdm):\n    doc = getattr(tqdm.tqdm, i).__doc__\n    if doc:\n        DOC_tqdm_tqdm[i] = doc2rst(doc, raw=True)\n\n# special cases\nDOC_tqdm_init_args = DOC_tqdm_init_args.replace(' *,', ' ``*``,')\nDOC_tqdm_init_args = DOC_tqdm_init_args.partition('* gui  : bool, optional')[0]\n\nREADME_rst = (\n    README_rst.replace('{DOC_tqdm}', DOC_tqdm)\n    .replace('{DOC_tqdm.tqdm.__init__.Parameters}', DOC_tqdm_init_args)\n    .replace('{DOC_tqdm.cli.CLI_EXTRA_DOC}', DOC_cli)\n    .replace('{DOC_tqdm.tqdm.__init__.Returns}', DOC_tqdm_init_rets))\nfor k, v in DOC_tqdm_tqdm.items():\n    README_rst = README_rst.replace('{DOC_tqdm.tqdm.%s}' % k, v)\n\nif __name__ == \"__main__\":\n    (src_dir.parent / 'README.rst').write_text(README_rst, encoding='utf-8')\n", ".meta/mkcompletion.py": "\"\"\"\nAuto-generate tqdm/completion.sh from docstrings.\n\"\"\"\nimport re\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent))\nimport tqdm  # NOQA\nimport tqdm.cli  # NOQA\n\nRE_OPT = re.compile(r'(\\w+)  :', flags=re.M)\nRE_OPT_INPUT = re.compile(r'(\\w+)  : (?:str|int|float|chr|dict|tuple)', flags=re.M)\n\n\ndef doc2opt(doc, user_input=True):\n    \"\"\"\n    doc  : str, document to parse\n    user_input  : bool, optional.\n      [default: True] for only options requiring user input\n    \"\"\"\n    RE = RE_OPT_INPUT if user_input else RE_OPT\n    return ('--' + i for i in RE.findall(doc))\n\n\n# CLI options\noptions = {'-h', '--help', '-v', '--version'}\noptions_input = set()\nfor doc in (tqdm.tqdm.__doc__, tqdm.cli.CLI_EXTRA_DOC):\n    options.update(doc2opt(doc, user_input=False))\n    options_input.update(doc2opt(doc, user_input=True))\noptions.difference_update('--' + i for i in ('name',) + tqdm.cli.UNSUPPORTED_OPTS)\noptions_input &= options\noptions_input -= {\"--log\"}  # manually dealt with\ncompletion = u\"\"\"\\\n#!/usr/bin/env bash\n_tqdm(){{\n  local cur prv\n  cur=\"${{COMP_WORDS[COMP_CWORD]}}\"\n  prv=\"${{COMP_WORDS[COMP_CWORD - 1]}}\"\n\n  case ${{prv}} in\n  {opts_manual})\n    # await user input\n    ;;\n  \"--log\")\n    COMPREPLY=($(compgen -W \\\n      'CRITICAL FATAL ERROR WARN WARNING INFO DEBUG NOTSET' -- ${{cur}}))\n    ;;\n  *)\n    COMPREPLY=($(compgen -W '{opts}' -- ${{cur}}))\n    ;;\n  esac\n}}\ncomplete -F _tqdm tqdm\n\"\"\".format(opts=' '.join(sorted(options)), opts_manual='|'.join(sorted(options_input)))\n\nif __name__ == \"__main__\":\n    (Path(__file__).resolve().parent.parent / 'tqdm' / 'completion.sh').write_text(\n        completion, encoding='utf-8')\n", "examples/redirect_print.py": "\"\"\"Redirecting writing\n\nIf using a library that can print messages to the console, editing the library\nby  replacing `print()` with `tqdm.write()` may not be desirable.\nIn that case, redirecting `sys.stdout` to `tqdm.write()` is an option.\n\nTo redirect `sys.stdout`, create a file-like class that will write\nany input string to `tqdm.write()`, and supply the arguments\n`file=sys.stdout, dynamic_ncols=True`.\n\nA reusable canonical example is given below:\n\"\"\"\nimport contextlib\nimport sys\nfrom time import sleep\n\nfrom tqdm import tqdm\nfrom tqdm.contrib import DummyTqdmFile\n\n\n@contextlib.contextmanager\ndef std_out_err_redirect_tqdm():\n    orig_out_err = sys.stdout, sys.stderr\n    try:\n        # sys.stdout = sys.stderr = DummyTqdmFile(orig_out_err[0])\n        sys.stdout, sys.stderr = map(DummyTqdmFile, orig_out_err)\n        yield orig_out_err[0]\n    # Relay exceptions\n    except Exception as exc:\n        raise exc\n    # Always restore sys.stdout/err if necessary\n    finally:\n        sys.stdout, sys.stderr = orig_out_err\n\n\ndef some_fun(i):\n    print(\"Fee, fi, fo,\".split()[i])\n\n\n# Redirect stdout to tqdm.write()\nwith std_out_err_redirect_tqdm() as orig_stdout:\n    # tqdm needs the original stdout\n    # and dynamic_ncols=True to autodetect console width\n    for i in tqdm(range(3), file=orig_stdout, dynamic_ncols=True):\n        # order of the following two lines should not matter\n        some_fun(i)\n        sleep(.5)\n\n# After the `with`, printing is restored\nprint(\"Done!\")\n", "examples/include_no_requirements.py": "# How to import tqdm in any frontend without enforcing it as a dependency\ntry:\n    from tqdm.auto import tqdm\nexcept ImportError:\n\n    def tqdm(*args, **kwargs):\n        if args:\n            return args[0]\n        return kwargs.get('iterable', None)\n\n__all__ = ['tqdm']\n", "examples/tqdm_requests.py": "\"\"\"An example of wrapping manual tqdm updates for `requests.get`.\nSee also: tqdm_wget.py.\n\nUsage:\n    tqdm_requests.py [options]\n\nOptions:\n-h, --help\n    Print this help message and exit\n-u URL, --url URL  : string, optional\n    The url to fetch.\n    [default: https://caspersci.uk.to/matryoshka.zip]\n-o FILE, --output FILE  : string, optional\n    The local file path in which to save the url [default: /dev/null].\n\"\"\"\n\nfrom os import devnull\n\nimport requests\nfrom docopt import docopt\n\nfrom tqdm.auto import tqdm\n\nopts = docopt(__doc__)\n\neg_link = opts['--url']\neg_file = eg_link.replace('/', ' ').split()[-1]\neg_out = opts['--output'].replace(\"/dev/null\", devnull)\n\nresponse = requests.get(eg_link, stream=True)\nwith open(eg_out, \"wb\") as fout:\n    with tqdm(\n        # all optional kwargs\n        unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n        desc=eg_file, total=int(response.headers.get('content-length', 0))\n    ) as pbar:\n        for chunk in response.iter_content(chunk_size=4096):\n            fout.write(chunk)\n            pbar.update(len(chunk))\n\n# Even simpler progress by wrapping the output file's `write()`\nresponse = requests.get(eg_link, stream=True)\nwith tqdm.wrapattr(\n    open(eg_out, \"wb\"), \"write\",\n    unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n    desc=eg_file, total=int(response.headers.get('content-length', 0))\n) as fout:\n    for chunk in response.iter_content(chunk_size=4096):\n        fout.write(chunk)\n", "examples/parallel_bars.py": "from concurrent.futures import ThreadPoolExecutor\nfrom functools import partial\nfrom multiprocessing import Pool, RLock, freeze_support\nfrom random import random\nfrom threading import RLock as TRLock\nfrom time import sleep\n\nfrom tqdm.auto import tqdm, trange\nfrom tqdm.contrib.concurrent import process_map, thread_map\n\nNUM_SUBITERS = 9\n\n\ndef progresser(n, auto_position=True, write_safe=False, blocking=True, progress=False):\n    interval = random() * 0.002 / (NUM_SUBITERS - n + 2)  # nosec\n    total = 5000\n    text = f\"#{n}, est. {interval * total:<04.2g}s\"\n    for _ in trange(total, desc=text, disable=not progress,\n                    lock_args=None if blocking else (False,),\n                    position=None if auto_position else n):\n        sleep(interval)\n    # NB: may not clear instances with higher `position` upon completion\n    # since this worker may not know about other bars #796\n    if write_safe:  # we think we know about other bars\n        if n == 6:\n            tqdm.write(\"n == 6 completed\")\n    return n + 1\n\n\nif __name__ == '__main__':\n    freeze_support()  # for Windows support\n    L = list(range(NUM_SUBITERS))[::-1]\n\n    print(\"Simple thread mapping\")\n    thread_map(partial(progresser, write_safe=True), L, max_workers=4)\n\n    print(\"Simple process mapping\")\n    process_map(partial(progresser), L, max_workers=4)\n\n    print(\"Manual nesting\")\n    for i in trange(16, desc=\"1\"):\n        for _ in trange(16, desc=\"2 @ %d\" % i, leave=i % 2):\n            sleep(0.01)\n\n    print(\"Multi-processing\")\n    tqdm.set_lock(RLock())\n    p = Pool(initializer=tqdm.set_lock, initargs=(tqdm.get_lock(),))\n    p.map(partial(progresser, progress=True), L)\n\n    print(\"Multi-threading\")\n    tqdm.set_lock(TRLock())\n    with ThreadPoolExecutor(initializer=tqdm.set_lock, initargs=(tqdm.get_lock(),)) as p:\n        p.map(partial(progresser, progress=True, write_safe=True, blocking=False), L)\n", "examples/wrapping_generators.py": "import numpy as np\n\nfrom tqdm.contrib import tenumerate, tmap, tzip\n\nfor _ in tenumerate(range(int(1e6)), desc=\"builtin enumerate\"):\n    pass\n\nfor _ in tenumerate(np.random.random((999, 999)), desc=\"numpy.ndenumerate\"):\n    pass\n\nfor _ in tzip(np.arange(1e6), np.arange(1e6) + 1, desc=\"builtin zip\"):\n    pass\n\nmapped = tmap(lambda x: x + 1, np.arange(1e6), desc=\"builtin map\")\nassert (np.arange(1e6) + 1 == list(mapped)).all()\n", "examples/7zx.py": "# -*- coding: utf-8 -*-\n\"\"\"Usage:\n  7zx.py [--help | options] <zipfiles>...\n\nOptions:\n  -h, --help     Print this help and exit\n  -v, --version  Print version and exit\n  -c, --compressed       Use compressed (instead of uncompressed) file sizes\n  -s, --silent   Do not print one row per zip file\n  -y, --yes      Assume yes to all queries (for extraction)\n  -D=<level>, --debug=<level>\n                 Print various types of debugging information. Choices:\n                         CRITICAL|FATAL\n                         ERROR\n                         WARN(ING)\n                         [default: INFO]\n                         DEBUG\n                         NOTSET\n  -d, --debug-trace      Print lots of debugging information (-D NOTSET)\n\"\"\"\nimport io\nimport logging\nimport os\nimport pty\nimport re\nimport subprocess  # nosec\n\nfrom argopt import argopt\n\nfrom tqdm import tqdm\n\n__author__ = \"Casper da Costa-Luis <casper.dcl@physics.org>\"\n__licence__ = \"MPLv2.0\"\n__version__ = \"0.2.2\"\n__license__ = __licence__\n\nRE_SCN = re.compile(r\"([0-9]+)\\s+([0-9]+)\\s+(.*)$\", flags=re.M)\n\n\ndef main():\n    args = argopt(__doc__, version=__version__).parse_args()\n    if args.debug_trace:\n        args.debug = \"NOTSET\"\n    logging.basicConfig(level=getattr(logging, args.debug, logging.INFO),\n                        format='%(levelname)s:%(message)s')\n    log = logging.getLogger(__name__)\n    log.debug(args)\n\n    # Get compressed sizes\n    zips = {}\n    for fn in args.zipfiles:\n        info = subprocess.check_output([\"7z\", \"l\", fn]).strip()  # nosec\n        finfo = RE_SCN.findall(info)  # size|compressed|name\n\n        # builtin test: last line should be total sizes\n        log.debug(finfo)\n        totals = map(int, finfo[-1][:2])\n        # log.debug(totals)\n        for s in range(2):  # size|compressed totals\n            totals_s = sum(map(int, (inf[s] for inf in finfo[:-1])))\n            if totals_s != totals[s]:\n                log.warn(\"%s: individual total %d != 7z total %d\",\n                         fn, totals_s, totals[s])\n        fcomp = {n: int(c if args.compressed else u) for (u, c, n) in finfo[:-1]}\n        # log.debug(fcomp)\n        # zips  : {'zipname' : {'filename' : int(size)}}\n        zips[fn] = fcomp\n\n    # Extract\n    cmd7zx = [\"7z\", \"x\", \"-bd\"]\n    if args.yes:\n        cmd7zx += [\"-y\"]\n    log.info(\"Extracting from %d file(s)\", len(zips))\n    with tqdm(total=sum(sum(fcomp.values()) for fcomp in zips.values()),\n              unit=\"B\", unit_scale=True) as tall:\n        for fn, fcomp in zips.items():\n            md, sd = pty.openpty()\n            ex = subprocess.Popen(  # nosec\n                cmd7zx + [fn],\n                bufsize=1,\n                stdout=md,  # subprocess.PIPE,\n                stderr=subprocess.STDOUT)\n            os.close(sd)\n            with io.open(md, mode=\"rU\", buffering=1) as m:\n                with tqdm(total=sum(fcomp.values()), disable=len(zips) < 2,\n                          leave=False, unit=\"B\", unit_scale=True) as t:\n                    if not hasattr(t, \"start_t\"):  # disabled\n                        t.start_t = tall._time()\n                    while True:\n                        try:\n                            l_raw = m.readline()\n                        except IOError:\n                            break\n                        ln = l_raw.strip()\n                        if ln.startswith(\"Extracting\"):\n                            exname = ln[len(\"Extracting\"):].lstrip()\n                            s = fcomp.get(exname, 0)  # 0 is likely folders\n                            t.update(s)\n                            tall.update(s)\n                        elif ln:\n                            if not any(\n                                    ln.startswith(i)\n                                    for i in (\"7-Zip \", \"p7zip Version \",\n                                              \"Everything is Ok\", \"Folders: \",\n                                              \"Files: \", \"Size: \", \"Compressed: \")):\n                                if ln.startswith(\"Processing archive: \"):\n                                    if not args.silent:\n                                        t.write(t.format_interval(\n                                            t.start_t - tall.start_t) + ' ' +\n                                            ln.replace(\"Processing archive: \", \"\"))\n                                else:\n                                    t.write(ln)\n            ex.wait()\n\n\nmain.__doc__ = __doc__\n\nif __name__ == \"__main__\":\n    main()\n", "examples/coroutine_pipe.py": "\"\"\"\nInserting `tqdm` as a \"pipe\" in a chain of coroutines.\nNot to be confused with `asyncio.coroutine`.\n\"\"\"\nfrom functools import wraps\n\nfrom tqdm.auto import tqdm\n\n\ndef autonext(func):\n    @wraps(func)\n    def inner(*args, **kwargs):\n        res = func(*args, **kwargs)\n        next(res)\n        return res\n    return inner\n\n\n@autonext\ndef tqdm_pipe(target, **tqdm_kwargs):\n    \"\"\"\n    Coroutine chain pipe `send()`ing to `target`.\n\n    This:\n    >>> r = receiver()\n    >>> p = producer(r)\n    >>> next(r)\n    >>> next(p)\n\n    Becomes:\n    >>> r = receiver()\n    >>> t = tqdm.pipe(r)\n    >>> p = producer(t)\n    >>> next(r)\n    >>> next(p)\n    \"\"\"\n    with tqdm(**tqdm_kwargs) as pbar:\n        while True:\n            obj = (yield)\n            target.send(obj)\n            pbar.update()\n\n\ndef source(target):\n    for i in [\"foo\", \"bar\", \"baz\", \"pythonista\", \"python\", \"py\"]:\n        target.send(i)\n    target.close()\n\n\n@autonext\ndef grep(pattern, target):\n    while True:\n        line = (yield)\n        if pattern in line:\n            target.send(line)\n\n\n@autonext\ndef sink():\n    while True:\n        line = (yield)\n        tqdm.write(line)\n\n\nif __name__ == \"__main__\":\n    source(\n        tqdm_pipe(\n            grep('python',\n                 sink())))\n", "examples/pandas_progress_apply.py": "import numpy as np\nimport pandas as pd\n\nfrom tqdm.auto import tqdm\n\ndf = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n\n# Register `pandas.progress_apply` and `pandas.Series.map_apply` with `tqdm`\n# (can use `tqdm.gui.tqdm`, `tqdm.notebook.tqdm`, optional kwargs, etc.)\ntqdm.pandas(desc=\"my bar!\")\n\n# Now you can use `progress_apply` instead of `apply`\n# and `progress_map` instead of `map`\ndf.progress_apply(lambda x: x**2)\n# can also groupby:\n# df.groupby(0).progress_apply(lambda x: x**2)\n\n# -- Source code for `tqdm_pandas` (really simple!)\n# def tqdm_pandas(t):\n#   from pandas.core.frame import DataFrame\n#   def inner(df, func, *args, **kwargs):\n#       t.total = groups.size // len(groups)\n#       def wrapper(*args, **kwargs):\n#           t.update(1)\n#           return func(*args, **kwargs)\n#       result = df.apply(wrapper, *args, **kwargs)\n#       t.close()\n#       return result\n#   DataFrame.progress_apply = inner\n", "examples/tqdm_wget.py": "\"\"\"An example of wrapping manual tqdm updates for `urllib` reporthook.\nSee also: tqdm_requests.py.\n\n# `urllib.urlretrieve` documentation\n> If present, the hook function will be called once\n> on establishment of the network connection and once after each block read\n> thereafter. The hook will be passed three arguments; a count of blocks\n> transferred so far, a block size in bytes, and the total size of the file.\n\nUsage:\n    tqdm_wget.py [options]\n\nOptions:\n-h, --help\n    Print this help message and exit\n-u URL, --url URL  : string, optional\n    The url to fetch.\n    [default: https://caspersci.uk.to/matryoshka.zip]\n-o FILE, --output FILE  : string, optional\n    The local file path in which to save the url [default: /dev/null].\n\"\"\"\n\nfrom os import devnull\nfrom urllib import request as urllib\n\nfrom docopt import docopt\n\nfrom tqdm.auto import tqdm\n\n\ndef my_hook(t):\n    \"\"\"Wraps tqdm instance.\n\n    Don't forget to close() or __exit__()\n    the tqdm instance once you're done with it (easiest using `with` syntax).\n\n    Example\n    -------\n\n    >>> with tqdm(...) as t:\n    ...     reporthook = my_hook(t)\n    ...     urllib.urlretrieve(..., reporthook=reporthook)\n\n    \"\"\"\n    last_b = [0]\n\n    def update_to(b=1, bsize=1, tsize=None):\n        \"\"\"\n        b  : int, optional\n            Number of blocks transferred so far [default: 1].\n        bsize  : int, optional\n            Size of each block (in tqdm units) [default: 1].\n        tsize  : int, optional\n            Total size (in tqdm units). If [default: None] or -1,\n            remains unchanged.\n        \"\"\"\n        if tsize not in (None, -1):\n            t.total = tsize\n        displayed = t.update((b - last_b[0]) * bsize)\n        last_b[0] = b\n        return displayed\n\n    return update_to\n\n\nclass TqdmUpTo(tqdm):\n    \"\"\"Alternative Class-based version of the above.\n\n    Provides `update_to(n)` which uses `tqdm.update(delta_n)`.\n\n    Inspired by [twine#242](https://github.com/pypa/twine/pull/242),\n    [here](https://github.com/pypa/twine/commit/42e55e06).\n    \"\"\"\n\n    def update_to(self, b=1, bsize=1, tsize=None):\n        \"\"\"\n        b  : int, optional\n            Number of blocks transferred so far [default: 1].\n        bsize  : int, optional\n            Size of each block (in tqdm units) [default: 1].\n        tsize  : int, optional\n            Total size (in tqdm units). If [default: None] remains unchanged.\n        \"\"\"\n        if tsize is not None:\n            self.total = tsize\n        return self.update(b * bsize - self.n)  # also sets self.n = b * bsize\n\n\nopts = docopt(__doc__)\n\neg_link = opts['--url']\neg_file = eg_link.replace('/', ' ').split()[-1]\neg_out = opts['--output'].replace(\"/dev/null\", devnull)\n# with tqdm(unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n#           desc=eg_file) as t:  # all optional kwargs\n#     urllib.urlretrieve(eg_link, filename=eg_out,\n#                        reporthook=my_hook(t), data=None)\nwith TqdmUpTo(unit='B', unit_scale=True, unit_divisor=1024, miniters=1,\n              desc=eg_file) as t:  # all optional kwargs\n    urllib.urlretrieve(  # nosec\n        eg_link, filename=eg_out, reporthook=t.update_to, data=None)\n    t.total = t.n\n\n# Even simpler progress by wrapping the output file's `write()`\nresponse = urllib.urlopen(eg_link)  # nosec\nwith tqdm.wrapattr(open(eg_out, \"wb\"), \"write\",\n                   miniters=1, desc=eg_file,\n                   total=getattr(response, 'length', None)) as fout:\n    for chunk in response:\n        fout.write(chunk)\n", "examples/async_coroutines.py": "\"\"\"Asynchronous examples using `asyncio`, `async` and `await`.\"\"\"\nimport asyncio\n\nfrom tqdm.asyncio import tqdm, trange\n\n\ndef count(start=0, step=1):\n    i = start\n    while True:\n        new_start = yield i\n        if new_start is None:\n            i += step\n        else:\n            i = new_start\n\n\nasync def main():\n    N = int(1e6)\n    async for row in tqdm(trange(N, desc=\"inner\"), desc=\"outer\"):\n        if row >= N:\n            break\n    with tqdm(count(), desc=\"coroutine\", total=N + 2) as pbar:\n        async for row in pbar:\n            if row == N:\n                pbar.send(-10)\n            elif row < 0:\n                assert row == -9\n                break\n    # should be ~1sec rather than ~50s due to async scheduling\n    for i in tqdm.as_completed([asyncio.sleep(0.01 * i)\n                                for i in range(100, 0, -1)], desc=\"as_completed\"):\n        await i\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n", "examples/simple_examples.py": "\"\"\"\n# Simple tqdm examples and profiling\n\n# Benchmark\nfor i in range(int(1e8)):\n    pass\n\n# Basic demo\nimport tqdm\nfor i in tqdm.trange(int(1e8)):\n    pass\n\n# Some decorations\nimport tqdm\nfor i in tqdm.trange(int(1e8), miniters=int(1e6), ascii=True,\n                     desc=\"cool\", dynamic_ncols=True):\n    pass\n\n# Nested bars\nfrom tqdm import trange\nfor i in trange(10):\n    for j in trange(int(1e7), leave=False, unit_scale=True):\n        pass\n\n# Experimental GUI demo\nimport tqdm\nfor i in tqdm.tgrange(int(1e8)):\n    pass\n\n# Comparison to https://code.google.com/p/python-progressbar/\ntry:\n    from progressbar.progressbar import ProgressBar\nexcept ImportError:\n    pass\nelse:\n    for i in ProgressBar()(range(int(1e8))):\n        pass\n\n# Dynamic miniters benchmark\nfrom tqdm import trange\nfor i in trange(int(1e8), miniters=None, mininterval=0.1, smoothing=0):\n    pass\n\n# Fixed miniters benchmark\nfrom tqdm import trange\nfor i in trange(int(1e8), miniters=4500000, mininterval=0.1, smoothing=0):\n    pass\n\"\"\"\n\nimport re\nfrom time import sleep\nfrom timeit import timeit\n\n# Simple demo\nfrom tqdm import trange\n\nfor _ in trange(16, leave=True):\n    sleep(0.1)\n\n# Profiling/overhead tests\nstmts = filter(None, re.split(r'\\n\\s*#.*?\\n', __doc__))\nfor s in stmts:\n    print(s.replace('import tqdm\\n', ''))\n    print(timeit(stmt=s, number=1), 'seconds')\n"}